[{"original_method":"void start() throws IOException {\n        System.out.println(\"Starting \" + processName);\n        synchronized (this) {\n            if (start) {\n                return;\n            }\n            final ProcessBuilder processBuilder = new ProcessBuilder(command);\n            final Map<String, String> env = processBuilder.environment();\n            env.clear();\n            env.putAll(this.env);\n            processBuilder.directory(new File(workingDirectory));\n            final Process process;\n            synchronized (ManagedProcess.class) {\n                // this is the only point in the process manager which opens FDs OR fork/execs after initial boot.  By\n                // restricting it to a single thread we reduce the risk of bogus FDs, resource leaks, and other\n                // issues surrounding fork/exec vs. Java.\n                process = processBuilder.start();\n            }\n            final ErrorStreamHandler errorStreamHandler = new ErrorStreamHandler(processName, process.getErrorStream());\n            final Thread errorThread = new Thread(errorStreamHandler);\n            errorThread.setName(\"Process \" + processName + \" stderr thread\");\n            final OutputStreamHandler outputStreamHandler = new OutputStreamHandler(process.getInputStream());\n            final Thread outputThread = new Thread(outputStreamHandler);\n            outputThread.setName(\"Process \" + processName + \" stdout thread\");\n            // todo - error handling in the event that a thread can't start?\n            errorThread.start();\n            outputThread.start();\n            this.commandStream = process.getOutputStream();\n            this.process = process;\n            start = true;\n        }\n    }","id":93000,"modified_method":"void start() throws IOException {\n        log.info(\"Starting \" + processName);\n        synchronized (this) {\n            if (start) {\n                return;\n            }\n            final ProcessBuilder processBuilder = new ProcessBuilder(command);\n            final Map<String, String> env = processBuilder.environment();\n            env.clear();\n            env.putAll(this.env);\n            processBuilder.directory(new File(workingDirectory));\n            final Process process;\n            synchronized (ManagedProcess.class) {\n                // this is the only point in the process manager which opens FDs OR fork/execs after initial boot.  By\n                // restricting it to a single thread we reduce the risk of bogus FDs, resource leaks, and other\n                // issues surrounding fork/exec vs. Java.\n                process = processBuilder.start();\n            }\n            final ErrorStreamHandler errorStreamHandler = new ErrorStreamHandler(processName, process.getErrorStream());\n            final Thread errorThread = new Thread(errorStreamHandler);\n            errorThread.setName(\"Process \" + processName + \" stderr thread\");\n            final OutputStreamHandler outputStreamHandler = new OutputStreamHandler(process.getInputStream());\n            final Thread outputThread = new Thread(outputStreamHandler);\n            outputThread.setName(\"Process \" + processName + \" stdout thread\");\n            // todo - error handling in the event that a thread can't start?\n            errorThread.start();\n            outputThread.start();\n            this.commandStream = process.getOutputStream();\n            this.process = process;\n            start = true;\n        }\n    }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void run() {\n            \n            // FIXME reliable transmission support (JBAS-8262)\n            \n            final InputStream inputStream = this.inputStream;\n            final StringBuilder b = new StringBuilder();\n            try {\n                for (;;) {\n                    Status status = StreamUtils.readWord(inputStream, b);\n                    if (status == Status.END_OF_STREAM) {\n                        // no more input\n                        return;\n                    }\n                    try {\n                        final Command command = Command.valueOf(b.toString());\n                        OUT: switch (command) {\n                            case ADD: {\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                final String name = b.toString();\n                                status = StreamUtils.readWord(inputStream, b);\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                final String workingDirectory = b.toString();\n                                status = StreamUtils.readWord(inputStream, b);\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                final String sizeString = b.toString();\n                                final int size;\n                                try {\n                                    size = Integer.parseInt(sizeString, 10);\n                                } catch (NumberFormatException e) {\n                                    e.printStackTrace(System.err); // FIXME remove\n                                    break;\n                                }\n                                final List<String> execCmd = new ArrayList<String>();\n                                for (int i = 0; i < size; i++) {\n                                    status = StreamUtils.readWord(inputStream, b);\n                                    if (status != Status.MORE) {\n                                        break OUT;\n                                    }\n                                    execCmd.add(b.toString());\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                final String mapSizeString = b.toString();\n                                final int mapSize, lastEntry;\n                                try {\n                                    mapSize = Integer.parseInt(mapSizeString, 10);\n                                    lastEntry = mapSize - 1;\n                                } catch (NumberFormatException e) {\n                                    e.printStackTrace(System.err); // FIXME remove\n                                    break;\n                                }\n                                final Map<String, String> env = new HashMap<String, String>();\n                                for (int i = 0; i < mapSize; i ++) {\n                                    status = StreamUtils.readWord(inputStream, b);\n                                    if (status != Status.MORE) {\n                                        break OUT;\n                                    }\n                                    final String key = b.toString();\n                                    status = StreamUtils.readWord(inputStream, b);\n                                    if (status == Status.MORE || (i == lastEntry && status == Status.END_OF_LINE)) {\n                                        env.put(key, b.toString());\n                                    }\n                                    else {\n                                        break OUT;\n                                    }                                    \n                                }\n                                master.addProcess(name, execCmd, env, workingDirectory);\n                                break;\n                            }\n                            case START: {\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                final String name = b.toString();\n                                master.startProcess(name);\n                                break;\n                            }\n                            case STOP: {\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                final String name = b.toString();\n                                master.stopProcess(name);\n                                break;\n                            }\n                            case REMOVE: {\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                final String name = b.toString();\n                                master.removeProcess(name);\n                                break;\n                            }\n                            case SEND: {\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                final String recipient = b.toString();\n                                final List<String> msg = new ArrayList<String>(0);\n                                while (status == Status.MORE) {\n                                    status = StreamUtils.readWord(inputStream, b);\n                                    msg.add(b.toString());\n                                }\n                                master.sendMessage(processName, recipient, msg);\n                                break;\n                            }\n                            case SEND_BYTES: {\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                if (status == Status.MORE) {\n                                    final String recipient = b.toString();\n                                    CheckedBytes cb = StreamUtils.readCheckedBytes(inputStream);\n//                                    if (cb.getChecksum() != cb.getExpectedChecksum()) {\n//                                        System.err.println(\"Incorrect checksum\");\n//                                        // FIXME deal with invalid checksum\n//                                    }\n//                                    else {\n                                        master.sendMessage(processName, recipient, cb.getBytes(), cb.getExpectedChecksum());\n//                                    }\n                                }\n                                break;\n                            }\n                            case BROADCAST: {\n                                final List<String> msg = new ArrayList<String>(0);\n                                while (status == Status.MORE) {\n                                    status = StreamUtils.readWord(inputStream, b);\n                                    msg.add(b.toString());\n                                }\n                                master.broadcastMessage(processName, msg);\n                                break;\n                            }\n                            case BROADCAST_BYTES: {\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                if (status == Status.MORE) {\n                                    final String name = b.toString();\n                                    CheckedBytes cb = StreamUtils.readCheckedBytes(inputStream);\n                                    if (cb.getChecksum() != cb.getExpectedChecksum()) {\n                                        // FIXME deal with invalid checksum\n                                    }\n                                    else {\n                                        master.broadcastMessage(processName, cb.getBytes(), cb.getExpectedChecksum());\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                    } catch (IllegalArgumentException e) {\n                        // unknown command...\n                        e.printStackTrace(System.err);\n                    }\n                    if (status == Status.MORE) StreamUtils.readToEol(inputStream);\n                }\n            } catch (Exception e) {\n                // exception caught, shut down channel and exit\n                e.printStackTrace(System.err);\n            } finally {\n                safeClose(inputStream);\n                for (;;) try {\n                    process.waitFor();\n                    break;\n                } catch (InterruptedException e) {\n                }\n                start = false;\n            }\n            // todo - detect crash & respawn logic\n        }","id":93001,"modified_method":"public void run() {\n            \n            // FIXME reliable transmission support (JBAS-8262)\n            \n            final InputStream inputStream = this.inputStream;\n            final StringBuilder b = new StringBuilder();\n            try {\n                for (;;) {\n                    Status status = StreamUtils.readWord(inputStream, b);\n                    if (status == Status.END_OF_STREAM) {\n                        log.info(\"Received end of stream, shutting down\");\n                        // no more input\n                        return;\n                    }\n                    try {\n                        final Command command = Command.valueOf(b.toString());\n                        OUT: switch (command) {\n                            case ADD: {\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                final String name = b.toString();\n                                status = StreamUtils.readWord(inputStream, b);\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                final String workingDirectory = b.toString();\n                                status = StreamUtils.readWord(inputStream, b);\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                final String sizeString = b.toString();\n                                final int size;\n                                try {\n                                    size = Integer.parseInt(sizeString, 10);\n                                } catch (NumberFormatException e) {\n                                    e.printStackTrace(System.err); // FIXME remove\n                                    break;\n                                }\n                                final List<String> execCmd = new ArrayList<String>();\n                                for (int i = 0; i < size; i++) {\n                                    status = StreamUtils.readWord(inputStream, b);\n                                    if (status != Status.MORE) {\n                                        break OUT;\n                                    }\n                                    execCmd.add(b.toString());\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                final String mapSizeString = b.toString();\n                                final int mapSize, lastEntry;\n                                try {\n                                    mapSize = Integer.parseInt(mapSizeString, 10);\n                                    lastEntry = mapSize - 1;\n                                } catch (NumberFormatException e) {\n                                    e.printStackTrace(System.err); // FIXME remove\n                                    break;\n                                }\n                                final Map<String, String> env = new HashMap<String, String>();\n                                for (int i = 0; i < mapSize; i ++) {\n                                    status = StreamUtils.readWord(inputStream, b);\n                                    if (status != Status.MORE) {\n                                        break OUT;\n                                    }\n                                    final String key = b.toString();\n                                    status = StreamUtils.readWord(inputStream, b);\n                                    if (status == Status.MORE || (i == lastEntry && status == Status.END_OF_LINE)) {\n                                        env.put(key, b.toString());\n                                    }\n                                    else {\n                                        break OUT;\n                                    }                                    \n                                }\n                                master.addProcess(name, execCmd, env, workingDirectory);\n                                break;\n                            }\n                            case START: {\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                final String name = b.toString();\n                                master.startProcess(name);\n                                break;\n                            }\n                            case STOP: {\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                final String name = b.toString();\n                                master.stopProcess(name);\n                                break;\n                            }\n                            case REMOVE: {\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                final String name = b.toString();\n                                master.removeProcess(name);\n                                break;\n                            }\n                            case SEND: {\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                final String recipient = b.toString();\n                                final List<String> msg = new ArrayList<String>(0);\n                                while (status == Status.MORE) {\n                                    status = StreamUtils.readWord(inputStream, b);\n                                    msg.add(b.toString());\n                                }\n                                master.sendMessage(processName, recipient, msg);\n                                break;\n                            }\n                            case SEND_BYTES: {\n                                if (status != Status.MORE) {\n                                    break;\n                                }\n                                status = StreamUtils.readWord(inputStream, b);\n                                if (status == Status.MORE) {\n                                    final String recipient = b.toString();\n                                    CheckedBytes cb = StreamUtils.readCheckedBytes(inputStream);\n                                    status = cb.getStatus();\n                                    if (cb.getChecksum() != cb.getExpectedChecksum()) {\n                                        log.error(\"Incorrect checksum on message for \" + recipient);\n                                        // FIXME deal with invalid checksum\n                                    }\n                                    else {\n                                        master.sendMessage(processName, recipient, cb.getBytes(), cb.getExpectedChecksum());\n                                    }\n                                }\n                                break;\n                            }\n                            case BROADCAST: {\n                                final List<String> msg = new ArrayList<String>(0);\n                                while (status == Status.MORE) {\n                                    status = StreamUtils.readWord(inputStream, b);\n                                    msg.add(b.toString());\n                                }\n                                master.broadcastMessage(processName, msg);\n                                break;\n                            }\n                            case BROADCAST_BYTES: {\n                                if (status == Status.MORE) {\n                                    CheckedBytes cb = StreamUtils.readCheckedBytes(inputStream);\n                                    status = cb.getStatus();\n                                    if (cb.getChecksum() != cb.getExpectedChecksum()) {\n                                        // FIXME deal with invalid checksum\n                                    }\n                                    else {\n                                        master.broadcastMessage(processName, cb.getBytes(), cb.getExpectedChecksum());\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                    } catch (IllegalArgumentException e) {\n                        // unknown command...\n                        log.error(\"Received unknown command\", e);\n                    }\n                    if (status == Status.MORE) StreamUtils.readToEol(inputStream);\n\n                }\n            } catch (Exception e) {\n                // exception caught, shut down channel and exit\n                log.error(\"Output stream handler for process \" + processName + \" caught an exception; shutting down\", e);\n            } finally {\n                safeClose(inputStream);\n                for (;;) try {\n                    process.waitFor();\n                    break;\n                } catch (InterruptedException e) {\n                }\n                start = false;\n            }\n            // todo - detect crash & respawn logic\n        }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void addProcess(final String processName, final List<String> command, final Map<String, String> env, final String workingDirectory) throws IOException {\n        if (processName == null) {\n            throw new IllegalArgumentException(\"processName is null\");\n        }\n        if (command == null) {\n            throw new IllegalArgumentException(\"command is null\");\n        }\n        if (env == null) {\n            throw new IllegalArgumentException(\"env is null\");\n        }\n        if (workingDirectory == null) {\n            throw new IllegalArgumentException(\"workingDirectory is null\");\n        }\n        final StringBuilder b = new StringBuilder(256);\n        b.append(Command.ADD).append('\\0');\n        b.append(processName).append('\\0');\n        b.append(workingDirectory).append('\\0');\n        b.append(command.size()).append('\\0');\n        for (String str : command) {\n            b.append(str).append('\\0');\n        }\n        b.append(env.size());\n        for (Map.Entry<String, String> entry : env.entrySet()) {\n            final String key = entry.getKey();\n            if (key != null) {\n                b.append('\\0').append(key);\n                final String value = entry.getValue();\n                b.append('\\0');\n                if (value != null) b.append(value);\n            }\n        }\n        b.append('\\n');\n        StreamUtils.writeString(output, b);\n        output.flush();\n    }","id":93002,"modified_method":"public void addProcess(final String processName, final List<String> command, final Map<String, String> env, final String workingDirectory) throws IOException {\n        if (processName == null) {\n            throw new IllegalArgumentException(\"processName is null\");\n        }\n        if (command == null) {\n            throw new IllegalArgumentException(\"command is null\");\n        }\n        if (env == null) {\n            throw new IllegalArgumentException(\"env is null\");\n        }\n        if (workingDirectory == null) {\n            throw new IllegalArgumentException(\"workingDirectory is null\");\n        }\n        final StringBuilder b = new StringBuilder(256);\n        b.append(Command.ADD).append('\\0');\n        b.append(processName).append('\\0');\n        b.append(workingDirectory).append('\\0');\n        b.append(command.size()).append('\\0');\n        for (String str : command) {\n            b.append(str).append('\\0');\n        }\n        b.append(env.size());\n        for (Map.Entry<String, String> entry : env.entrySet()) {\n            final String key = entry.getKey();\n            if (key != null) {\n                b.append('\\0').append(key);\n                final String value = entry.getValue();\n                b.append('\\0');\n                if (value != null) b.append(value);\n            }\n        }\n        b.append('\\n');\n        synchronized (output) {\n            StreamUtils.writeString(output, b);\n            output.flush();\n        }\n    }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void removeProcess(final String processName) throws IOException {\n        if (processName == null) {\n            throw new IllegalArgumentException(\"processName is null\");\n        }\n        final StringBuilder b = new StringBuilder();\n        b.append(Command.REMOVE).append('\\0');\n        b.append(processName);\n        b.append('\\n');\n        StreamUtils.writeString(output, b);\n        output.flush();\n    }","id":93003,"modified_method":"public void removeProcess(final String processName) throws IOException {\n        if (processName == null) {\n            throw new IllegalArgumentException(\"processName is null\");\n        }\n        final StringBuilder b = new StringBuilder();\n        b.append(Command.REMOVE).append('\\0');\n        b.append(processName);\n        b.append('\\n');\n        synchronized (output) {\n            StreamUtils.writeString(output, b);\n            output.flush();\n        }\n    }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void stopProcess(final String processName) throws IOException {\n        if (processName == null) {\n            throw new IllegalArgumentException(\"processName is null\");\n        }\n        final StringBuilder b = new StringBuilder();\n        b.append(Command.STOP).append('\\0');\n        b.append(processName);\n        b.append('\\n');\n        StreamUtils.writeString(output, b);\n        output.flush();\n    }","id":93004,"modified_method":"public void stopProcess(final String processName) throws IOException {\n        if (processName == null) {\n            throw new IllegalArgumentException(\"processName is null\");\n        }\n        final StringBuilder b = new StringBuilder();\n        b.append(Command.STOP).append('\\0');\n        b.append(processName);\n        b.append('\\n');\n        synchronized (output) {\n            StreamUtils.writeString(output, b);\n            output.flush();\n        }\n    }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void broadcastMessage(final byte[] message, final long checksum) throws IOException {\n        final StringBuilder b = new StringBuilder();\n        b.append(Command.BROADCAST_BYTES).append('\\0');\n        StreamUtils.writeString(output, b);\n        output.write(message.length);\n        output.write(message);\n        StreamUtils.writeLong(output, checksum);\n        StreamUtils.writeChar(output, '\\n');\n        output.flush();\n    }","id":93005,"modified_method":"public void broadcastMessage(final byte[] message, final long checksum) throws IOException {\n        final StringBuilder b = new StringBuilder();\n        b.append(Command.BROADCAST_BYTES).append('\\0');\n        synchronized (output) {\n            StreamUtils.writeString(output, b);\n            output.write(message.length);\n            output.write(message);\n            StreamUtils.writeLong(output, checksum);\n            StreamUtils.writeChar(output, '\\n');\n            output.flush();\n        }\n    }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void broadcastMessage(final List<String> message) throws IOException {\n        final StringBuilder b = new StringBuilder();\n        b.append(Command.BROADCAST);\n        for (String str : message) {\n            b.append('\\0').append(str);\n        }\n        b.append('\\n');\n        StreamUtils.writeString(output, b);\n        output.flush();\n    }","id":93006,"modified_method":"public void broadcastMessage(final List<String> message) throws IOException {\n        final StringBuilder b = new StringBuilder();\n        b.append(Command.BROADCAST);\n        for (String str : message) {\n            b.append('\\0').append(str);\n        }\n        b.append('\\n');\n        synchronized (output) {\n            StreamUtils.writeString(output, b);\n            output.flush();\n        }\n    }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void startProcess(final String processName) throws IOException {\n        if (processName == null) {\n            throw new IllegalArgumentException(\"processName is null\");\n        }\n        final StringBuilder b = new StringBuilder();\n        b.append(Command.START).append('\\0');\n        b.append(processName);\n        b.append('\\n');\n        StreamUtils.writeString(output, b);\n        output.flush();\n    }","id":93007,"modified_method":"public void startProcess(final String processName) throws IOException {\n        if (processName == null) {\n            throw new IllegalArgumentException(\"processName is null\");\n        }\n        final StringBuilder b = new StringBuilder();\n        b.append(Command.START).append('\\0');\n        b.append(processName);\n        b.append('\\n');\n        synchronized (output) {\n            StreamUtils.writeString(output, b);\n            output.flush();\n        }\n    }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void run() {\n            final InputStream input = ProcessManagerSlave.this.input;\n            final StringBuilder b = new StringBuilder();\n            try {\n                for (;;) {\n                    Status status = StreamUtils.readWord(input, b);\n                    if (status == Status.END_OF_STREAM) {\n                        // no more input\n                        shutdown();\n                        break;\n                    }\n                    try {\n                        final Command command = Command.valueOf(b.toString());\n                        switch (command) {\n                            case SHUTDOWN: {\n                                shutdown();\n                                break;\n                            }\n                            case MSG: {\n                                if (status == Status.MORE) {\n                                    status = StreamUtils.readWord(input, b);\n                                    final String sourceProcess = b.toString();\n                                    final List<String> msg = new ArrayList<String>();\n                                    while (status == Status.MORE) {\n                                        status = StreamUtils.readWord(input, b);\n                                        msg.add(b.toString());\n                                    }\n                                    if (status == Status.END_OF_LINE) {\n                                        try {\n                                            handler.handleMessage(sourceProcess, msg);\n                                        } catch (Throwable t) {\n                                            // ignored!\n                                        }\n                                    }\n                                    // else it was end of stream, so only a partial was received\n                                }\n                                break;\n                            }\n                            case MSG_BYTES: {\n                                if (status == Status.MORE) {\n                                    status = StreamUtils.readWord(input, b);\n                                    final String sourceProcess = b.toString();\n                                    if (status == Status.MORE) {\n                                        CheckedBytes cb = StreamUtils.readCheckedBytes(input);\n//                                        if (cb.getChecksum() != cb.getExpectedChecksum()) {\n//                                            // FIXME deal with invalid checksum\n//                                        }\n//                                        else {\n                                            try {\n                                                handler.handleMessage(sourceProcess, cb.getBytes());\n                                            } catch (Throwable t) {\n                                                // ignored!\n                                            }\n//                                        }\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                    } catch (IllegalArgumentException e) {\n                        // unknown command...\n                    }\n                    if (status == Status.MORE) StreamUtils.readToEol(input);\n                }\n            } catch (IOException e) {\n                // exception caught, shut down channel and exit\n                shutdown();\n            }\n        }","id":93008,"modified_method":"public void run() {\n            final InputStream input = ProcessManagerSlave.this.input;\n            final StringBuilder b = new StringBuilder();\n            try {\n                for (;;) {\n                    Status status = StreamUtils.readWord(input, b);\n                    if (status == Status.END_OF_STREAM) {\n                        // no more input\n                        shutdown();\n                        break;\n                    }\n                    try {\n                        final Command command = Command.valueOf(b.toString());\n                        switch (command) {\n                            case SHUTDOWN: {\n                                shutdown();\n                                break;\n                            }\n                            case MSG: {\n                                if (status == Status.MORE) {\n                                    status = StreamUtils.readWord(input, b);\n                                    final String sourceProcess = b.toString();\n                                    final List<String> msg = new ArrayList<String>();\n                                    while (status == Status.MORE) {\n                                        status = StreamUtils.readWord(input, b);\n                                        msg.add(b.toString());\n                                    }\n                                    if (status == Status.END_OF_LINE) {\n                                        try {\n                                            handler.handleMessage(sourceProcess, msg);\n                                        } catch (Throwable t) {\n                                            // ignored!\n                                        }\n                                    }\n                                    // else it was end of stream, so only a partial was received\n                                }\n                                break;\n                            }\n                            case MSG_BYTES: {\n                                if (status == Status.MORE) {\n                                    status = StreamUtils.readWord(input, b);\n                                    final String sourceProcess = b.toString();\n                                    if (status == Status.MORE) {\n                                        CheckedBytes cb = StreamUtils.readCheckedBytes(input);\n                                        status = cb.getStatus();\n                                        if (cb.getChecksum() != cb.getExpectedChecksum()) {\n                                            // FIXME deal with invalid checksum\n                                        }\n                                        else {\n                                            try {\n                                                handler.handleMessage(sourceProcess, cb.getBytes());\n                                            } catch (Throwable t) {\n                                                // ignored!\n                                            }\n                                        }\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                    } catch (IllegalArgumentException e) {\n                        // unknown command...\n                    }\n                    if (status == Status.MORE) StreamUtils.readToEol(input);\n                }\n            } catch (IOException e) {\n                // exception caught, shut down channel and exit\n                shutdown();\n            }\n        }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void sendMessage(final String processName, final List<String> message) throws IOException {\n        if (processName == null) {\n            throw new IllegalArgumentException(\"processName is null\");\n        }\n        final StringBuilder b = new StringBuilder();\n        b.append(Command.SEND).append('\\0');\n        b.append(processName);\n        for (String str : message) {\n            b.append('\\0').append(str);\n        }\n        b.append('\\n');\n        StreamUtils.writeString(output, b);\n        output.flush();\n    }","id":93009,"modified_method":"public void sendMessage(final String processName, final List<String> message) throws IOException {\n        if (processName == null) {\n            throw new IllegalArgumentException(\"processName is null\");\n        }\n        final StringBuilder b = new StringBuilder();\n        b.append(Command.SEND).append('\\0');\n        b.append(processName);\n        for (String str : message) {\n            b.append('\\0').append(str);\n        }\n        b.append('\\n');\n        synchronized (output) {\n            StreamUtils.writeString(output, b);\n            output.flush();\n        }\n    }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void sendMessage(final String recipient, final byte[] message, final long checksum) throws IOException {\n        if (recipient == null) {\n            throw new IllegalArgumentException(\"processName is null\");\n        }\n        final StringBuilder b = new StringBuilder();\n        b.append(Command.SEND_BYTES).append('\\0');\n        b.append(recipient).append('\\0');\n        StreamUtils.writeString(output, b.toString());\n        StreamUtils.writeInt(output, message.length);\n        output.write(message, 0, message.length);\n        StreamUtils.writeLong(output, checksum);\n        StreamUtils.writeChar(output, '\\n');\n        output.flush();\n    }","id":93010,"modified_method":"public void sendMessage(final String recipient, final byte[] message, final long checksum) throws IOException {\n        if (recipient == null) {\n            throw new IllegalArgumentException(\"processName is null\");\n        }\n        final StringBuilder b = new StringBuilder();\n        b.append(Command.SEND_BYTES).append('\\0');\n        b.append(recipient).append('\\0');\n        synchronized (output) {\n            StreamUtils.writeString(output, b.toString());\n            StreamUtils.writeInt(output, message.length);\n            output.write(message, 0, message.length);\n            StreamUtils.writeLong(output, checksum);\n            StreamUtils.writeChar(output, '\\n');\n            output.flush();\n        }\n    }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void run() {\n            final InputStream input = ServerCommunicationHandler.this.input;\n            final StringBuilder b = new StringBuilder();\n            try {\n                for (;;) {\n                    Status status = StreamUtils.readWord(input, b);\n                    if (status == Status.END_OF_STREAM) {\n                        // no more input\n                        shutdown();\n                        break;\n                    }\n                    try {\n                        final Command command = Command.valueOf(b.toString());\n                        switch (command) {\n                            case SHUTDOWN: {\n                                shutdown();\n                                break;\n                            }\n                            case MSG: {\n                                if (status == Status.MORE) {\n                                    status = StreamUtils.readWord(input, b);\n                                    final String sourceProcess = b.toString();\n                                    final List<String> msg = new ArrayList<String>();\n                                    while (status == Status.MORE) {\n                                        status = StreamUtils.readWord(input, b);\n                                        msg.add(b.toString());\n                                    }\n                                    if (status == Status.END_OF_LINE) {\n                                        try {\n                                            handler.handleMessage(msg);\n                                        } catch (Throwable t) {\n                                            // ignored!\n                                        }\n                                    }\n                                    // else it was end of stream, so only a partial was received\n                                }\n                                break;\n                            }\n                            case MSG_BYTES: {\n                                if (status == Status.MORE) {\n                                    status = StreamUtils.readWord(input, b);\n                                    final String sourceProcess = b.toString();\n                                    if (status == Status.MORE) {\n                                        StreamUtils.CheckedBytes cb = StreamUtils.readCheckedBytes(input);\n//                                        if (cb.getChecksum() != cb.getExpectedChecksum()) {\n//                                            // FIXME deal with invalid checksum\n//                                        }\n//                                        else {\n                                            try {\n                                                handler.handleMessage(cb.getBytes());\n                                            } catch (Throwable t) {\n                                                // ignored!\n                                            }\n//                                        }\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                    } catch (IllegalArgumentException e) {\n                        // unknown command...\n                    }\n                    if (status == Status.MORE) StreamUtils.readToEol(input);\n                }\n            } catch (IOException e) {\n                // exception caught, shut down channel and exit\n                shutdown();\n            }\n        }","id":93011,"modified_method":"public void run() {\n            final InputStream input = ServerCommunicationHandler.this.input;\n            final StringBuilder b = new StringBuilder();\n            try {\n                for (;;) {\n                    Status status = StreamUtils.readWord(input, b);\n                    if (status == Status.END_OF_STREAM) {\n                        // no more input\n                        shutdown();\n                        break;\n                    }\n                    try {\n                        final Command command = Command.valueOf(b.toString());\n                        switch (command) {\n                            case SHUTDOWN: {\n                                shutdown();\n                                break;\n                            }\n                            case MSG: {\n                                if (status == Status.MORE) {\n                                    status = StreamUtils.readWord(input, b);\n                                    final String sourceProcess = b.toString();\n                                    final List<String> msg = new ArrayList<String>();\n                                    while (status == Status.MORE) {\n                                        status = StreamUtils.readWord(input, b);\n                                        msg.add(b.toString());\n                                    }\n                                    if (status == Status.END_OF_LINE) {\n                                        try {\n                                            handler.handleMessage(msg);\n                                        } catch (Throwable t) {\n                                            // ignored!\n                                        }\n                                    }\n                                    // else it was end of stream, so only a partial was received\n                                }\n                                break;\n                            }\n                            case MSG_BYTES: {\n                                if (status == Status.MORE) {\n                                    status = StreamUtils.readWord(input, b);\n                                    final String sourceProcess = b.toString();\n                                    if (status == Status.MORE) {\n                                        StreamUtils.CheckedBytes cb = StreamUtils.readCheckedBytes(input);\n                                        status = cb.getStatus();\n                                        if (cb.getChecksum() != cb.getExpectedChecksum()) {\n                                            logger.error(\"Incorrect checksum from process \" + sourceProcess);\n                                            // FIXME deal with invalid checksum\n                                        }\n                                        else {\n                                            try {\n                                                handler.handleMessage(cb.getBytes());\n                                            } catch (Throwable t) {\n                                                // ignored!\n                                            }\n                                        }\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                    } catch (IllegalArgumentException e) {\n                        // unknown command...\n                    }\n                    if (status == Status.MORE) StreamUtils.readToEol(input);\n                }\n            } catch (IOException e) {\n                // exception caught, shut down channel and exit\n                shutdown();\n            }\n        }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"},{"original_method":"private CheckedBytes(InputStream input) throws IOException {\n            this.expectedLength = readInt(input);\n            this.bytez = new byte[expectedLength];\n            readFully(input, bytez, 0, expectedLength);\n            this.expectedChecksum = readLong(input);\n            Adler32 adler = new Adler32();\n            adler.update(bytez, 0, expectedLength);\n            this.checksum = adler.getValue();\n        }","id":93012,"modified_method":"private CheckedBytes(InputStream input) throws IOException {\n            this.expectedLength = readInt(input);\n            this.bytez = new byte[expectedLength];\n            readFully(input, bytez, 0, expectedLength);\n            this.expectedChecksum = readLong(input);\n            Adler32 adler = new Adler32();\n            adler.update(bytez, 0, expectedLength);\n            this.checksum = adler.getValue();\n            int c = readChar(input);\n\n            switch (c) {\n                case -1: {\n                    status = Status.END_OF_STREAM;\n                    break;\n                }                    \n                case 0:  {\n                    status = Status.MORE;\n                    break;\n                }\n                case '\\n': {\n                    status = Status.END_OF_LINE;\n                    break;\n                }\n                default: {\n                    throw new IllegalStateException(\"unexpected char \" + c);\n                }\n            }\n        }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void writeLong(final OutputStream out, final long v) throws IOException {\n        for(int i = 0; i < 8; i++) {\n            out.write((byte)((v >> (8 * i)) & 0xff));\n          }\n    }","id":93013,"modified_method":"public static void writeLong(final OutputStream out, final long v) throws IOException {\n        out.write((byte) (v >>> 56) & 0xFF);\n        out.write((byte) (v >>> 48) & 0xFF);\n        out.write((byte) (v >>> 40) & 0xFF);\n        out.write((byte) (v >>> 32) & 0xFF);\n        out.write((byte) (v >>> 24) & 0xFF);\n        out.write((byte) (v >>> 16) & 0xFF);\n        out.write((byte) (v >>>  8) & 0xFF);\n        out.write((byte) (v >>>  0) & 0xFF);\n    }","commit_id":"2ec9f229138d8edd948ed1183acff85c893fe00a","url":"https://github.com/wildfly/wildfly"},{"original_method":"private Set<ResolvedDependency> mergeChildren(Set<ResolvedDependency> children) {\n        Map<String, Set<ResolvedDependency>> mergedGroups = new HashMap<String, Set<ResolvedDependency>>();\n        for (ResolvedDependency child : children) {\n            Set<ResolvedDependency> mergeGroup = mergedGroups.get(child.getName());\n            if (mergeGroup == null) {\n                mergedGroups.put(child.getName(), mergeGroup = new HashSet<ResolvedDependency>());\n            }\n            mergeGroup.add(child);\n        }\n        Set<ResolvedDependency> mergedChildren = new HashSet<ResolvedDependency>();\n        for (Set<ResolvedDependency> mergedGroup : mergedGroups.values()) {\n            mergedChildren.add(new MergedResolvedDependency(mergedGroup));\n        }\n        return mergedChildren;\n    }","id":93014,"modified_method":"private Set<MergedResolvedDependency> mergeChildren(Set<ResolvedDependency> children) {\n        Map<String, Set<ResolvedDependency>> mergedGroups = new LinkedHashMap<String, Set<ResolvedDependency>>();\n        for (ResolvedDependency child : children) {\n            Set<ResolvedDependency> mergeGroup = mergedGroups.get(child.getName());\n            if (mergeGroup == null) {\n                mergedGroups.put(child.getName(), mergeGroup = new LinkedHashSet<ResolvedDependency>());\n            }\n            mergeGroup.add(child);\n        }\n        Set<MergedResolvedDependency> mergedChildren = new LinkedHashSet<MergedResolvedDependency>();\n        for (Set<ResolvedDependency> mergedGroup : mergedGroups.values()) {\n            mergedChildren.add(new MergedResolvedDependency(mergedGroup));\n        }\n        return mergedChildren;\n    }","commit_id":"6ab750681c8be723b3afcace6f050cbc3ae7033e","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void completeProject(Project project) {\n        if (!hasConfigs) {\n            getTextOutput().println(\"No configurations\");\n        }\n        super.completeProject(project);\n    }","id":93015,"modified_method":"@Override\n    public void completeProject(Project project) {\n        if (!hasConfigs) {\n            getTextOutput().style(Info).println(\"No configurations\").style(Normal);\n        }\n        super.completeProject(project);\n    }","commit_id":"6ab750681c8be723b3afcace6f050cbc3ae7033e","url":"https://github.com/gradle/gradle"},{"original_method":"public void render(ResolvedConfiguration resolvedConfiguration) throws IOException\n    {\n        Set<ResolvedDependency> mergedRoots = mergeChildren(resolvedConfiguration.getFirstLevelModuleDependencies());\n        for (ResolvedDependency root : mergedRoots) {\n            render(root, 1);\n        }\n    }","id":93016,"modified_method":"public void render(ResolvedConfiguration resolvedConfiguration) throws IOException {\n        Set<MergedResolvedDependency> mergedRoots = mergeChildren(resolvedConfiguration.getFirstLevelModuleDependencies());\n        if (mergedRoots.isEmpty()) {\n            getTextOutput().style(Info).text(\"No dependencies\").style(Normal).println();\n            return;\n        }\n        renderChildren(mergedRoots, \"\");\n    }","commit_id":"6ab750681c8be723b3afcace6f050cbc3ae7033e","url":"https://github.com/gradle/gradle"},{"original_method":"public void startConfiguration(Configuration configuration) {\n        hasConfigs = true;\n        getTextOutput().formatln(\"%s%s\", configuration.getName(), getDescription(configuration));\n    }","id":93017,"modified_method":"public void startConfiguration(Configuration configuration) {\n        hasConfigs = true;\n        getTextOutput().println();\n        getTextOutput().style(Identifier).text(configuration.getName()).style(Normal);\n        getTextOutput().style(Info).text(getDescription(configuration)).style(Normal);\n        getTextOutput().println();\n    }","commit_id":"6ab750681c8be723b3afcace6f050cbc3ae7033e","url":"https://github.com/gradle/gradle"},{"original_method":"private void render(ResolvedDependency resolvedDependency, int depth) throws IOException\n    {\n        getTextOutput().text(getIndent(depth));\n        getTextOutput().formatln(\"%s:%s\", resolvedDependency.getName(),\n                resolvedDependency.getConfiguration());\n\n        Collection<ResolvedDependency> mergedChildren = mergeChildren(resolvedDependency.getChildren());\n\n\t\tfor(ResolvedDependency childResolvedDependency : mergedChildren)\n\t\t{\n\t\t\trender(childResolvedDependency, depth + 1);\n\t\t}\n    }","id":93018,"modified_method":"private void render(MergedResolvedDependency resolvedDependency, String prefix, boolean lastChild) throws IOException {\n        getTextOutput().style(Info).text(prefix + \"+--- \").style(Normal);\n        getTextOutput().text(resolvedDependency.getName());\n        getTextOutput().style(Info).format(\" [%s]\", resolvedDependency.getConfiguration()).style(Normal).println();\n\n        renderChildren(mergeChildren(resolvedDependency.getChildren()), prefix + (lastChild ? \"     \" : \"|    \"));\n    }","commit_id":"6ab750681c8be723b3afcace6f050cbc3ae7033e","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Marks the end of the tasks for the current project.\n     */\n    public void completeTasks() {\n        if (!currentProjectHasTasks) {\n            getTextOutput().println(\"No tasks\");\n            hasContent = true;\n        }\n    }","id":93019,"modified_method":"/**\n     * Marks the end of the tasks for the current project.\n     */\n    public void completeTasks() {\n        if (!currentProjectHasTasks) {\n            getTextOutput().style(Info).println(\"No tasks\").style(Normal);\n            hasContent = true;\n        }\n    }","commit_id":"6ab750681c8be723b3afcace6f050cbc3ae7033e","url":"https://github.com/gradle/gradle"},{"original_method":"private void writeTask(TaskDetails task, String prefix) {\n        getTextOutput().text(prefix);\n        getTextOutput().style(UserInput).text(task.getPath()).style(Normal);\n        getTextOutput().text(getDescription(task));\n        if (detail) {\n            SortedSet<String> sortedDependencies = new TreeSet<String>();\n            for (String dependency : task.getDependencies()) {\n                sortedDependencies.add(dependency);\n            }\n            if (sortedDependencies.size() > 0) {\n                getTextOutput().format(\" [%s]\", GUtil.join(sortedDependencies, \", \"));\n            }\n        }\n        getTextOutput().println();\n    }","id":93020,"modified_method":"private void writeTask(TaskDetails task, String prefix) {\n        getTextOutput().text(prefix);\n        getTextOutput().style(UserInput).text(task.getPath()).style(Normal);\n        getTextOutput().style(Info).text(getDescription(task));\n        if (detail) {\n            SortedSet<String> sortedDependencies = new TreeSet<String>();\n            for (String dependency : task.getDependencies()) {\n                sortedDependencies.add(dependency);\n            }\n            if (sortedDependencies.size() > 0) {\n                getTextOutput().format(\" [%s]\", GUtil.join(sortedDependencies, \", \"));\n            }\n        }\n        getTextOutput().style(Normal).println();\n    }","commit_id":"6ab750681c8be723b3afcace6f050cbc3ae7033e","url":"https://github.com/gradle/gradle"},{"original_method":"public VmAllocationInfo verify( VmAllocationInfo vmAllocInfo ) throws EucalyptusCloudException {\n    String walrusUrl = ImageUtil.getWalrusUrl( );\n\n    RunInstancesType msg = vmAllocInfo.getRequest( );\n    ImageInfo searchDiskInfo = new ImageInfo( msg.getImageId( ) );\n    EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>( );\n    ImageInfo diskInfo = null;\n    ArrayList<String> productCodes = Lists.newArrayList( );\n    try {\n      diskInfo = db.getUnique( searchDiskInfo );\n      for ( ProductCode p : diskInfo.getProductCodes( ) ) {\n        productCodes.add( p.getValue( ) );\n      }\n    } catch ( EucalyptusCloudException e ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Failed to find disk image: \" + msg.getImageId( ) );\n    }\n    UserInfo user = null;\n    try {\n      user = db.recast( UserInfo.class ).getUnique( new UserInfo( msg.getUserId( ) ) );\n    } catch ( Exception e1 ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permissions to run this image.\" );\n    }\n    if ( !diskInfo.isAllowed( user ) ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permissions to run this image.\" );\n    }\n    if ( \"deregistered\".equals( diskInfo.getImageState() ) ) {\n      db.delete( diskInfo );\n      db.rollback( );\n      throw new EucalyptusCloudException( \"The requested image is deregistered.\" );\n    }\n    ImageInfo kernelInfo = null;\n    ImageInfo ramdiskInfo = null;\n    if( !ImageManager.IMAGE_PLATFORM_WINDOWS.equals( diskInfo.getPlatform( ) ) ) {\n      String defaultKernelId = null;\n      String defaultRamdiskId = null;\n      try {\n        defaultKernelId = SystemConfiguration.getSystemConfiguration( ).getDefaultKernel( );\n        defaultRamdiskId = SystemConfiguration.getSystemConfiguration( ).getDefaultRamdisk( );\n      } catch ( Exception e1 ) {}\n      String kernelId = ImageUtil.getImageInfobyId( msg.getKernelId( ), diskInfo.getKernelId( ), defaultKernelId );\n      if ( kernelId == null ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"Unable to determine required kernel image.\" );\n      }\n      boolean nord = ( ImageUtil.isSet( msg.getKernelId( ) ) && !ImageUtil.isSet( msg.getRamdiskId( ) ) );\n      nord |= ( !ImageUtil.isSet( msg.getKernelId() ) && ImageUtil.isSet( diskInfo.getKernelId( ) ) && !ImageUtil.isSet( diskInfo.getRamdiskId() ) && !ImageUtil.isSet( msg.getRamdiskId() ) ); \n      String ramdiskId = nord?null:ImageUtil.getImageInfobyId( msg.getRamdiskId( ), diskInfo.getRamdiskId( ), defaultRamdiskId );\n  \n      try {\n        kernelInfo = db.getUnique( new ImageInfo( kernelId ) );\n      } catch ( EucalyptusCloudException e ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"Failed to find kernel image: \" + kernelId );\n      }\n      if ( !diskInfo.isAllowed( user ) ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"You do not have permission to launch: \" + diskInfo.getImageId( ) );\n      }\n      if ( !kernelInfo.isAllowed( user ) ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"You do not have permission to launch: \" + kernelInfo.getImageId( ) );\n      }\n      if ( ramdiskId != null ) {\n        try {\n          ramdiskInfo = db.getUnique( new ImageInfo( ramdiskId ) );\n        } catch ( EucalyptusCloudException e ) {\n          db.rollback( );\n          throw new EucalyptusCloudException( \"Failed to find ramdisk image: \" + ramdiskId );\n        }\n        if ( !ramdiskInfo.isAllowed( user ) ) {\n          db.rollback( );\n          throw new EucalyptusCloudException( \"You do not have permission to launch: \" + ramdiskInfo.getImageId( ) );\n        }\n      }\n      db.commit( );\n      if( !\"kernel\".equals( kernelInfo.getImageType( ) ) ) {\n        throw new EucalyptusCloudException( \"Image specified is not a kernel: \" + kernelInfo.toString( ) );\n      }\n      if((ramdiskInfo != null) && !\"ramdisk\".equals( ramdiskInfo.getImageType( ) ) ) {\n        throw new EucalyptusCloudException( \"Image specified is not a ramdisk: \" + ramdiskInfo.toString( ) );\n      }\n      ImageUtil.checkStoredImage( kernelInfo );\n      ImageUtil.checkStoredImage( ramdiskInfo );\n    }\n    ArrayList<String> ancestorIds = ImageUtil.getAncestors( msg.getUserId( ), diskInfo.getImageLocation( ) );\n    Long imgSize = ImageUtil.getSize( msg.getUserId( ), diskInfo.getImageLocation( ) );\n    ImageUtil.checkStoredImage( diskInfo );\n    \n    // :: get together the required URLs ::/\n    VmImageInfo vmImgInfo = ImageUtil.getVmImageInfo( walrusUrl, diskInfo, kernelInfo, ramdiskInfo, productCodes );\n    vmImgInfo.setAncestorIds( ancestorIds );\n    vmImgInfo.setSize( imgSize );\n    vmAllocInfo.setImageInfo( vmImgInfo );\n    return vmAllocInfo;\n  }","id":93021,"modified_method":"public VmAllocationInfo verify( VmAllocationInfo vmAllocInfo ) throws EucalyptusCloudException {\n    String walrusUrl = ImageUtil.getWalrusUrl( );\n\n    RunInstancesType msg = vmAllocInfo.getRequest( );\n    ImageInfo searchDiskInfo = new ImageInfo( msg.getImageId( ) );\n    EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>( );\n    ImageInfo diskInfo = null;\n    ArrayList<String> productCodes = Lists.newArrayList( );\n    try {\n      diskInfo = db.getUnique( searchDiskInfo );\n      for ( ProductCode p : diskInfo.getProductCodes( ) ) {\n        productCodes.add( p.getValue( ) );\n      }\n    } catch ( EucalyptusCloudException e ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Failed to find disk image: \" + msg.getImageId( ) );\n    }\n    UserInfo user = null;\n    try {\n      user = db.recast( UserInfo.class ).getUnique( new UserInfo( msg.getUserId( ) ) );\n    } catch ( Exception e1 ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permissions to run this image.\" );\n    }\n    if ( !diskInfo.isAllowed( user ) ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permissions to run this image.\" );\n    }\n    if ( \"deregistered\".equals( diskInfo.getImageState() ) ) {\n      db.delete( diskInfo );\n      db.rollback( );\n      throw new EucalyptusCloudException( \"The requested image is deregistered.\" );\n    }\n    ImageInfo kernelInfo = null;\n    ImageInfo ramdiskInfo = null;\n    String defaultKernelId = null;\n    String defaultRamdiskId = null;\n    try {\n      defaultKernelId = SystemConfiguration.getSystemConfiguration( ).getDefaultKernel( );\n      defaultRamdiskId = SystemConfiguration.getSystemConfiguration( ).getDefaultRamdisk( );\n    } catch ( Exception e1 ) {}\n    String kernelId = ImageUtil.getImageInfobyId( msg.getKernelId( ), diskInfo.getKernelId( ), defaultKernelId );\n    if ( kernelId == null ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Unable to determine required kernel image.\" );\n    }\n    try {\n      kernelInfo = db.getUnique( new ImageInfo( kernelId ) );\n    } catch ( EucalyptusCloudException e ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Failed to find kernel image: \" + kernelId );\n    }\n    if ( !kernelInfo.isAllowed( user ) ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permission to launch: \" + kernelInfo.getImageId( ) );\n    }\n    if( !\"kernel\".equals( kernelInfo.getImageType( ) ) ) {\n      throw new EucalyptusCloudException( \"Image specified is not a kernel: \" + kernelInfo.toString( ) );\n    }\n    if( !ImageManager.IMAGE_PLATFORM_WINDOWS.equals( diskInfo.getPlatform( ) ) ) {\n      boolean nord = ( ImageUtil.isSet( msg.getKernelId( ) ) && !ImageUtil.isSet( msg.getRamdiskId( ) ) );\n      nord |= ( !ImageUtil.isSet( msg.getKernelId() ) && ImageUtil.isSet( diskInfo.getKernelId( ) ) && !ImageUtil.isSet( diskInfo.getRamdiskId() ) && !ImageUtil.isSet( msg.getRamdiskId() ) ); \n      String ramdiskId = nord?null:ImageUtil.getImageInfobyId( msg.getRamdiskId( ), diskInfo.getRamdiskId( ), defaultRamdiskId );\n      if ( !diskInfo.isAllowed( user ) ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"You do not have permission to launch: \" + diskInfo.getImageId( ) );\n      }\n      if ( ramdiskId != null ) {\n        try {\n          ramdiskInfo = db.getUnique( new ImageInfo( ramdiskId ) );\n        } catch ( EucalyptusCloudException e ) {\n          db.rollback( );\n          throw new EucalyptusCloudException( \"Failed to find ramdisk image: \" + ramdiskId );\n        }\n        if ( !ramdiskInfo.isAllowed( user ) ) {\n          db.rollback( );\n          throw new EucalyptusCloudException( \"You do not have permission to launch: \" + ramdiskInfo.getImageId( ) );\n        }\n      }\n      db.commit( );\n      if((ramdiskInfo != null) && !\"ramdisk\".equals( ramdiskInfo.getImageType( ) ) ) {\n        throw new EucalyptusCloudException( \"Image specified is not a ramdisk: \" + ramdiskInfo.toString( ) );\n      }\n      ImageUtil.checkStoredImage( ramdiskInfo );\n    }\n    ArrayList<String> ancestorIds = ImageUtil.getAncestors( msg.getUserId( ), diskInfo.getImageLocation( ) );\n    Long imgSize = ImageUtil.getSize( msg.getUserId( ), diskInfo.getImageLocation( ) );\n    ImageUtil.checkStoredImage( kernelInfo );\n    ImageUtil.checkStoredImage( diskInfo );\n    \n    // :: get together the required URLs ::/\n    VmImageInfo vmImgInfo = ImageUtil.getVmImageInfo( walrusUrl, diskInfo, kernelInfo, ramdiskInfo, productCodes );\n    vmImgInfo.setAncestorIds( ancestorIds );\n    vmImgInfo.setSize( imgSize );\n    vmAllocInfo.setImageInfo( vmImgInfo );\n    return vmAllocInfo;\n  }","commit_id":"aa11adc467746418a9d7c729b70dd27432a5a9c3","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static VmImageInfo getVmImageInfo( final String walrusUrl, final ImageInfo diskInfo, final ImageInfo kernelInfo, final ImageInfo ramdiskInfo, final ArrayList<String> productCodes ) throws EucalyptusCloudException {\n    String diskUrl = getImageUrl( walrusUrl, diskInfo );\n    if( !ImageManager.IMAGE_PLATFORM_WINDOWS.equals( diskInfo.getPlatform( ) ) ) {\n      String kernelUrl = getImageUrl( walrusUrl, kernelInfo );\n      String ramdiskUrl = null;\n      if ( ramdiskInfo != null ) ramdiskUrl = getImageUrl( walrusUrl, ramdiskInfo );\n      //:: create the response assets now since we might not have a ramdisk anyway :://\n      VmImageInfo vmImgInfo = new VmImageInfo( diskInfo.getImageId( ), kernelInfo.getImageId( ),\n        ramdiskInfo == null ? null : ramdiskInfo.getImageId( ), diskUrl, kernelUrl, ramdiskInfo == null ? null\n                                                                                                       : ramdiskUrl,\n        productCodes, diskInfo.getPlatform( ) );\n      return vmImgInfo;\n    } else { \n      return new VmImageInfo( diskInfo.getImageId( ), diskUrl, productCodes, diskInfo.getPlatform( ) );\n    }\n  }","id":93022,"modified_method":"public static VmImageInfo getVmImageInfo( final String walrusUrl, final ImageInfo diskInfo, final ImageInfo kernelInfo, final ImageInfo ramdiskInfo, final ArrayList<String> productCodes ) throws EucalyptusCloudException {\n    String diskUrl = getImageUrl( walrusUrl, diskInfo );\n    String kernelUrl = getImageUrl( walrusUrl, kernelInfo );\n    String ramdiskUrl = null;\n    if ( ramdiskInfo != null ) ramdiskUrl = getImageUrl( walrusUrl, ramdiskInfo );\n    //:: create the response assets now since we might not have a ramdisk anyway :://\n    VmImageInfo vmImgInfo = new VmImageInfo( diskInfo.getImageId( ), kernelInfo.getImageId( ),\n      ramdiskInfo == null ? null : ramdiskInfo.getImageId( ), diskUrl, kernelUrl, ramdiskInfo == null ? null\n                                                                                                     : ramdiskUrl,\n      productCodes, diskInfo.getPlatform( ) );\n    return vmImgInfo;\n  }","commit_id":"aa11adc467746418a9d7c729b70dd27432a5a9c3","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public VmAllocationInfo verify( VmAllocationInfo vmAllocInfo ) throws EucalyptusCloudException {\n    String walrusUrl = ImageUtil.getWalrusUrl( );\n\n    RunInstancesType msg = vmAllocInfo.getRequest( );\n    ImageInfo searchDiskInfo = new ImageInfo( msg.getImageId( ) );\n    EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>( );\n    ImageInfo diskInfo = null;\n    ArrayList<String> productCodes = Lists.newArrayList( );\n    try {\n      diskInfo = db.getUnique( searchDiskInfo );\n      for ( ProductCode p : diskInfo.getProductCodes( ) ) {\n        productCodes.add( p.getValue( ) );\n      }\n    } catch ( EucalyptusCloudException e ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Failed to find disk image: \" + msg.getImageId( ) );\n    }\n    UserInfo user = null;\n    try {\n      user = db.recast( UserInfo.class ).getUnique( new UserInfo( msg.getUserId( ) ) );\n    } catch ( Exception e1 ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permissions to run this image.\" );\n    }\n    if ( !diskInfo.isAllowed( user ) ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permissions to run this image.\" );\n    }\n    if ( \"deregistered\".equals( diskInfo.getImageState() ) ) {\n      db.delete( diskInfo );\n      db.rollback( );\n      throw new EucalyptusCloudException( \"The requested image is deregistered.\" );\n    }\n\n    String defaultKernelId = null;\n    String defaultRamdiskId = null;\n    try {\n      defaultKernelId = SystemConfiguration.getSystemConfiguration( ).getDefaultKernel( );\n      defaultRamdiskId = SystemConfiguration.getSystemConfiguration( ).getDefaultRamdisk( );\n    } catch ( Exception e1 ) {}\n    String kernelId = ImageUtil.getImageInfobyId( msg.getKernelId( ), diskInfo.getKernelId( ), defaultKernelId );\n    if ( kernelId == null ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Unable to determine required kernel image.\" );\n    }\n    boolean nord = ( ImageUtil.isSet( msg.getKernelId( ) ) && !ImageUtil.isSet( msg.getRamdiskId( ) ) );\n    nord |= ( !ImageUtil.isSet( msg.getKernelId() ) && ImageUtil.isSet( diskInfo.getKernelId( ) ) && !ImageUtil.isSet( diskInfo.getRamdiskId() ) && !ImageUtil.isSet( msg.getRamdiskId() ) ); \n    String ramdiskId = nord?null:ImageUtil.getImageInfobyId( msg.getRamdiskId( ), diskInfo.getRamdiskId( ), defaultRamdiskId );\n\n    ImageInfo kernelInfo = null;\n    try {\n      kernelInfo = db.getUnique( new ImageInfo( kernelId ) );\n    } catch ( EucalyptusCloudException e ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Failed to find kernel image: \" + kernelId );\n    }\n    if ( !diskInfo.isAllowed( user ) ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permission to launch: \" + diskInfo.getImageId( ) );\n    }\n    if ( !kernelInfo.isAllowed( user ) ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permission to launch: \" + kernelInfo.getImageId( ) );\n    }\n    ImageInfo ramdiskInfo = null;\n    if ( ramdiskId != null ) {\n      try {\n        ramdiskInfo = db.getUnique( new ImageInfo( ramdiskId ) );\n      } catch ( EucalyptusCloudException e ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"Failed to find ramdisk image: \" + ramdiskId );\n      }\n      if ( !ramdiskInfo.isAllowed( user ) ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"You do not have permission to launch: \" + ramdiskInfo.getImageId( ) );\n      }\n    }\n    db.commit( );\n    // :: quietly add the ancestor and size information to the vm info object...\n    // this should never fail noisily :://\n    ArrayList<String> ancestorIds = ImageUtil.getAncestors( msg.getUserId( ), diskInfo.getImageLocation( ) );\n    Long imgSize = ImageUtil.getSize( msg.getUserId( ), diskInfo.getImageLocation( ) );\n    if( !\"kernel\".equals( kernelInfo.getImageType( ) ) ) {\n      throw new EucalyptusCloudException( \"Image specified is not a kernel: \" + kernelInfo.toString( ) );\n    }\n    if((ramdiskInfo != null) && !\"ramdisk\".equals( ramdiskInfo.getImageType( ) ) ) {\n      throw new EucalyptusCloudException( \"Image specified is not a ramdisk: \" + ramdiskInfo.toString( ) );\n    }\n    ImageUtil.checkStoredImage( kernelInfo );\n    ImageUtil.checkStoredImage( diskInfo );\n    ImageUtil.checkStoredImage( ramdiskInfo );\n\n    // :: get together the required URLs ::/\n    VmImageInfo vmImgInfo = ImageUtil.getVmImageInfo( walrusUrl, diskInfo, kernelInfo, ramdiskInfo, productCodes );\n    vmImgInfo.setAncestorIds( ancestorIds );\n    vmImgInfo.setSize( imgSize );\n    vmAllocInfo.setImageInfo( vmImgInfo );\n    return vmAllocInfo;\n  }","id":93023,"modified_method":"public VmAllocationInfo verify( VmAllocationInfo vmAllocInfo ) throws EucalyptusCloudException {\n    String walrusUrl = ImageUtil.getWalrusUrl( );\n\n    RunInstancesType msg = vmAllocInfo.getRequest( );\n    ImageInfo searchDiskInfo = new ImageInfo( msg.getImageId( ) );\n    EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>( );\n    ImageInfo diskInfo = null;\n    ArrayList<String> productCodes = Lists.newArrayList( );\n    try {\n      diskInfo = db.getUnique( searchDiskInfo );\n      for ( ProductCode p : diskInfo.getProductCodes( ) ) {\n        productCodes.add( p.getValue( ) );\n      }\n    } catch ( EucalyptusCloudException e ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Failed to find disk image: \" + msg.getImageId( ) );\n    }\n    UserInfo user = null;\n    try {\n      user = db.recast( UserInfo.class ).getUnique( new UserInfo( msg.getUserId( ) ) );\n    } catch ( Exception e1 ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permissions to run this image.\" );\n    }\n    if ( !diskInfo.isAllowed( user ) ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permissions to run this image.\" );\n    }\n    if ( \"deregistered\".equals( diskInfo.getImageState() ) ) {\n      db.delete( diskInfo );\n      db.rollback( );\n      throw new EucalyptusCloudException( \"The requested image is deregistered.\" );\n    }\n    ImageInfo kernelInfo = null;\n    ImageInfo ramdiskInfo = null;\n    if( !ImageManager.IMAGE_PLATFORM_WINDOWS.equals( diskInfo.getPlatform( ) ) ) {\n      String defaultKernelId = null;\n      String defaultRamdiskId = null;\n      try {\n        defaultKernelId = SystemConfiguration.getSystemConfiguration( ).getDefaultKernel( );\n        defaultRamdiskId = SystemConfiguration.getSystemConfiguration( ).getDefaultRamdisk( );\n      } catch ( Exception e1 ) {}\n      String kernelId = ImageUtil.getImageInfobyId( msg.getKernelId( ), diskInfo.getKernelId( ), defaultKernelId );\n      if ( kernelId == null ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"Unable to determine required kernel image.\" );\n      }\n      boolean nord = ( ImageUtil.isSet( msg.getKernelId( ) ) && !ImageUtil.isSet( msg.getRamdiskId( ) ) );\n      nord |= ( !ImageUtil.isSet( msg.getKernelId() ) && ImageUtil.isSet( diskInfo.getKernelId( ) ) && !ImageUtil.isSet( diskInfo.getRamdiskId() ) && !ImageUtil.isSet( msg.getRamdiskId() ) ); \n      String ramdiskId = nord?null:ImageUtil.getImageInfobyId( msg.getRamdiskId( ), diskInfo.getRamdiskId( ), defaultRamdiskId );\n  \n      try {\n        kernelInfo = db.getUnique( new ImageInfo( kernelId ) );\n      } catch ( EucalyptusCloudException e ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"Failed to find kernel image: \" + kernelId );\n      }\n      if ( !diskInfo.isAllowed( user ) ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"You do not have permission to launch: \" + diskInfo.getImageId( ) );\n      }\n      if ( !kernelInfo.isAllowed( user ) ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"You do not have permission to launch: \" + kernelInfo.getImageId( ) );\n      }\n      if ( ramdiskId != null ) {\n        try {\n          ramdiskInfo = db.getUnique( new ImageInfo( ramdiskId ) );\n        } catch ( EucalyptusCloudException e ) {\n          db.rollback( );\n          throw new EucalyptusCloudException( \"Failed to find ramdisk image: \" + ramdiskId );\n        }\n        if ( !ramdiskInfo.isAllowed( user ) ) {\n          db.rollback( );\n          throw new EucalyptusCloudException( \"You do not have permission to launch: \" + ramdiskInfo.getImageId( ) );\n        }\n      }\n      db.commit( );\n      if( !\"kernel\".equals( kernelInfo.getImageType( ) ) ) {\n        throw new EucalyptusCloudException( \"Image specified is not a kernel: \" + kernelInfo.toString( ) );\n      }\n      if((ramdiskInfo != null) && !\"ramdisk\".equals( ramdiskInfo.getImageType( ) ) ) {\n        throw new EucalyptusCloudException( \"Image specified is not a ramdisk: \" + ramdiskInfo.toString( ) );\n      }\n      ImageUtil.checkStoredImage( kernelInfo );\n      ImageUtil.checkStoredImage( ramdiskInfo );\n    }\n    ArrayList<String> ancestorIds = ImageUtil.getAncestors( msg.getUserId( ), diskInfo.getImageLocation( ) );\n    Long imgSize = ImageUtil.getSize( msg.getUserId( ), diskInfo.getImageLocation( ) );\n    ImageUtil.checkStoredImage( diskInfo );\n    \n    // :: get together the required URLs ::/\n    VmImageInfo vmImgInfo = ImageUtil.getVmImageInfo( walrusUrl, diskInfo, kernelInfo, ramdiskInfo, productCodes );\n    vmImgInfo.setAncestorIds( ancestorIds );\n    vmImgInfo.setSize( imgSize );\n    vmAllocInfo.setImageInfo( vmImgInfo );\n    return vmAllocInfo;\n  }","commit_id":"461a15c787873526b1429ef2f17eb48f775c8757","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static VmImageInfo getVmImageInfo( final String walrusUrl, final ImageInfo diskInfo, final ImageInfo kernelInfo, final ImageInfo ramdiskInfo, final ArrayList<String> productCodes ) throws EucalyptusCloudException {\n    String diskUrl = getImageUrl( walrusUrl, diskInfo );\n    String kernelUrl = getImageUrl( walrusUrl, kernelInfo );\n    String ramdiskUrl = null;\n    if ( ramdiskInfo != null ) ramdiskUrl = getImageUrl( walrusUrl, ramdiskInfo );\n    //:: create the response assets now since we might not have a ramdisk anyway :://\n    VmImageInfo vmImgInfo = new VmImageInfo( diskInfo.getImageId( ), kernelInfo.getImageId( ),\n      ramdiskInfo == null ? null : ramdiskInfo.getImageId( ), diskUrl, kernelUrl, ramdiskInfo == null ? null\n                                                                                                     : ramdiskUrl,\n      productCodes, diskInfo.getPlatform( ) );\n    return vmImgInfo;\n  }","id":93024,"modified_method":"public static VmImageInfo getVmImageInfo( final String walrusUrl, final ImageInfo diskInfo, final ImageInfo kernelInfo, final ImageInfo ramdiskInfo, final ArrayList<String> productCodes ) throws EucalyptusCloudException {\n    String diskUrl = getImageUrl( walrusUrl, diskInfo );\n    if( !ImageManager.IMAGE_PLATFORM_WINDOWS.equals( diskInfo.getPlatform( ) ) ) {\n      String kernelUrl = getImageUrl( walrusUrl, kernelInfo );\n      String ramdiskUrl = null;\n      if ( ramdiskInfo != null ) ramdiskUrl = getImageUrl( walrusUrl, ramdiskInfo );\n      //:: create the response assets now since we might not have a ramdisk anyway :://\n      VmImageInfo vmImgInfo = new VmImageInfo( diskInfo.getImageId( ), kernelInfo.getImageId( ),\n        ramdiskInfo == null ? null : ramdiskInfo.getImageId( ), diskUrl, kernelUrl, ramdiskInfo == null ? null\n                                                                                                       : ramdiskUrl,\n        productCodes, diskInfo.getPlatform( ) );\n      return vmImgInfo;\n    } else { \n      return new VmImageInfo( diskInfo.getImageId( ), diskUrl, productCodes, diskInfo.getPlatform( ) );\n    }\n  }","commit_id":"461a15c787873526b1429ef2f17eb48f775c8757","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public VmAllocationInfo verify( VmAllocationInfo vmAllocInfo ) throws EucalyptusCloudException {\n    RunInstancesType msg = vmAllocInfo.getRequest( );\n    VmTypeInfo vmType = vmAllocInfo.getVmTypeInfo( );\n    ImageInfo searchDiskInfo = new ImageInfo( msg.getImageId( ) );\n    EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>( );\n    ImageInfo diskInfo = null;\n    ArrayList<String> productCodes = Lists.newArrayList( );\n    try {\n      diskInfo = db.getUnique( searchDiskInfo );\n      for ( ProductCode p : diskInfo.getProductCodes( ) ) {\n        productCodes.add( p.getValue( ) );\n      }\n    } catch ( EucalyptusCloudException e ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Failed to find disk image: \" + msg.getImageId( ) );\n    }\n    vmAllocInfo.setPlatform( diskInfo.getPlatform( ) );\n    UserInfo user = null;\n    try {\n      user = UserInfoStore.getUserInfo( new UserInfo( msg.getUserId( ) ) );\n    } catch ( NoSuchUserException e1 ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Can not find user info for this image.\" );\n    }\n    if ( !diskInfo.isAllowed( user ) ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permissions to run this image.\" );\n    }\n    if ( \"deregistered\".equals( diskInfo.getImageState( ) ) ) {\n      db.delete( diskInfo );\n      db.rollback( );\n      throw new EucalyptusCloudException( \"The requested image is deregistered.\" );\n    }\n    ImageInfo kernelInfo = null;\n    ImageInfo ramdiskInfo = null;\n    String defaultKernelId = null;\n    String defaultRamdiskId = null;\n    try {\n      defaultKernelId = SystemConfiguration.getSystemConfiguration( ).getDefaultKernel( );\n      defaultRamdiskId = SystemConfiguration.getSystemConfiguration( ).getDefaultRamdisk( );\n    } catch ( Exception e1 ) {}\n    String kernelId = ImageUtil.getImageInfobyId( msg.getKernelId( ), diskInfo.getKernelId( ), defaultKernelId );\n    if ( kernelId == null ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Unable to determine required kernel image.\" );\n    }\n    try {\n      kernelInfo = db.getUnique( new ImageInfo( kernelId ) );\n    } catch ( EucalyptusCloudException e ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Failed to find kernel image: \" + kernelId );\n    }\n    if ( !kernelInfo.isAllowed( user ) ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permission to launch: \" + kernelInfo.getImageId( ) );\n    }\n    if ( !\"kernel\".equals( kernelInfo.getImageType( ) ) ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Image specified is not a kernel: \" + kernelInfo.toString( ) );\n    }\n    boolean nord = ( ImageUtil.isSet( msg.getKernelId( ) ) && !ImageUtil.isSet( msg.getRamdiskId( ) ) );\n    nord |= ( !ImageUtil.isSet( msg.getKernelId( ) ) && ImageUtil.isSet( diskInfo.getKernelId( ) ) && !ImageUtil.isSet( diskInfo.getRamdiskId( ) ) && !ImageUtil\n                                                                                                                                                                  .isSet( msg\n                                                                                                                                                                             .getRamdiskId( ) ) );\n    String ramdiskId = nord\n      ? null\n      : ImageUtil.getImageInfobyId( msg.getRamdiskId( ), diskInfo.getRamdiskId( ), defaultRamdiskId );\n    if ( !diskInfo.isAllowed( user ) ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permission to launch: \" + diskInfo.getImageId( ) );\n    }\n    if ( ramdiskId != null ) {\n      try {\n        ramdiskInfo = db.getUnique( new ImageInfo( ramdiskId ) );\n      } catch ( EucalyptusCloudException e ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"Failed to find ramdisk image: \" + ramdiskId );\n      }\n      if ( !ramdiskInfo.isAllowed( user ) ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"You do not have permission to launch: \" + ramdiskInfo.getImageId( ) );\n      }\n    }\n    db.commit( );\n    if ( ( ramdiskInfo != null ) && !\"ramdisk\".equals( ramdiskInfo.getImageType( ) ) ) {\n      throw new EucalyptusCloudException( \"Image specified is not a ramdisk: \" + ramdiskInfo.toString( ) );\n    }\n    ImageUtil.checkStoredImage( ramdiskInfo );\n    ArrayList<String> ancestorIds = ImageUtil.getAncestors( msg.getUserId( ), diskInfo.getImageLocation( ) );\n    Long imgSize = ImageUtil.getSize( msg.getUserId( ), diskInfo.getImageLocation( ) );\n    if ( imgSize > 1024l * 1024l * 1024l * vmType.getDisk( ) ) {\n      throw new EucalyptusCloudException( \"image too large [size=\" + imgSize / ( 1024l * 1024l ) + \"MB] for instance type \" + vmType.getName( ) + \" [disk=\"\n                                          + vmType.getDisk( ) * 1024l + \"MB]\" );\n    }\n    \n    ImageUtil.checkStoredImage( kernelInfo );\n    ImageUtil.checkStoredImage( diskInfo );\n    VirtualBootRecord ref = null;\n    vmType.setRoot( diskInfo.getImageId( ), diskInfo.getImageLocation( ), imgSize*1024 );\n    if( kernelInfo != null ) {\n      vmType.setKernel( kernelInfo.getImageId( ), kernelInfo.getImageLocation( ) );\n    }\n    if( ramdiskInfo != null ) {\n      vmType.setRamdisk( ramdiskInfo.getImageId( ), ramdiskInfo.getImageLocation( ) );\n    }\n    return vmAllocInfo;\n  }","id":93025,"modified_method":"public VmAllocationInfo verify( VmAllocationInfo vmAllocInfo ) throws EucalyptusCloudException {\n    RunInstancesType msg = vmAllocInfo.getRequest( );\n    VmTypeInfo vmType = vmAllocInfo.getVmTypeInfo( );\n    ImageInfo searchDiskInfo = new ImageInfo( msg.getImageId( ) );\n    EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>( );\n    ImageInfo diskInfo = null;\n    ArrayList<String> productCodes = Lists.newArrayList( );\n    try {\n      diskInfo = db.getUnique( searchDiskInfo );\n      for ( ProductCode p : diskInfo.getProductCodes( ) ) {\n        productCodes.add( p.getValue( ) );\n      }\n    } catch ( EucalyptusCloudException e ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Failed to find disk image: \" + msg.getImageId( ) );\n    }\n    vmAllocInfo.setPlatform( diskInfo.getPlatform( ) );\n    UserInfo user = null;\n    try {\n      user = UserInfoStore.getUserInfo( new UserInfo( msg.getUserId( ) ) );\n    } catch ( NoSuchUserException e1 ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"Can not find user info for this image.\" );\n    }\n    if ( !diskInfo.isAllowed( user ) ) {\n      db.rollback( );\n      throw new EucalyptusCloudException( \"You do not have permissions to run this image.\" );\n    }\n    if ( \"deregistered\".equals( diskInfo.getImageState( ) ) ) {\n      db.delete( diskInfo );\n      db.rollback( );\n      throw new EucalyptusCloudException( \"The requested image is deregistered.\" );\n    }\n    ImageInfo kernelInfo = null;\n    ImageInfo ramdiskInfo = null;\n    String defaultKernelId = null;\n    String defaultRamdiskId = null;\n    try {\n      defaultKernelId = SystemConfiguration.getSystemConfiguration( ).getDefaultKernel( );\n      defaultRamdiskId = SystemConfiguration.getSystemConfiguration( ).getDefaultRamdisk( );\n    } catch ( Exception e1 ) {}    \n    if ( !ImageManager.IMAGE_PLATFORM_WINDOWS.equals( diskInfo.getPlatform( ) ) ) {\n      String kernelId = ImageUtil.getImageInfobyId( msg.getKernelId( ), diskInfo.getKernelId( ), defaultKernelId );\n      if ( kernelId == null ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"Unable to determine required kernel image.\" );\n      }\n      try {\n        kernelInfo = db.getUnique( new ImageInfo( kernelId ) );\n      } catch ( EucalyptusCloudException e ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"Failed to find kernel image: \" + kernelId );\n      }\n      if ( !kernelInfo.isAllowed( user ) ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"You do not have permission to launch: \" + kernelInfo.getImageId( ) );\n      }\n      if ( !\"kernel\".equals( kernelInfo.getImageType( ) ) ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"Image specified is not a kernel: \" + kernelInfo.toString( ) );\n      }\n      boolean nord = ( ImageUtil.isSet( msg.getKernelId( ) ) && !ImageUtil.isSet( msg.getRamdiskId( ) ) );\n      nord |= ( !ImageUtil.isSet( msg.getKernelId( ) ) && ImageUtil.isSet( diskInfo.getKernelId( ) ) && !ImageUtil.isSet( diskInfo.getRamdiskId( ) ) && !ImageUtil\n                                                                                                                                                                  .isSet( msg\n                                                                                                                                                                             .getRamdiskId( ) ) );\n      String ramdiskId = nord ? null : ImageUtil.getImageInfobyId( msg.getRamdiskId( ), diskInfo.getRamdiskId( ), defaultRamdiskId );\n      if ( !diskInfo.isAllowed( user ) ) {\n        db.rollback( );\n        throw new EucalyptusCloudException( \"You do not have permission to launch: \" + diskInfo.getImageId( ) );\n      }\n      if ( ramdiskId != null ) {\n        try {\n          ramdiskInfo = db.getUnique( new ImageInfo( ramdiskId ) );\n        } catch ( EucalyptusCloudException e ) {\n          db.rollback( );\n          throw new EucalyptusCloudException( \"Failed to find ramdisk image: \" + ramdiskId );\n        }\n        if ( !ramdiskInfo.isAllowed( user ) ) {\n          db.rollback( );\n          throw new EucalyptusCloudException( \"You do not have permission to launch: \" + ramdiskInfo.getImageId( ) );\n        }\n      }\n      db.commit( );\n      if ( ( ramdiskInfo != null ) && !\"ramdisk\".equals( ramdiskInfo.getImageType( ) ) ) {\n        throw new EucalyptusCloudException( \"Image specified is not a ramdisk: \" + ramdiskInfo.toString( ) );\n      }\n      ImageUtil.checkStoredImage( ramdiskInfo );\n    } else {\n      db.commit( );\n    }\n    ArrayList<String> ancestorIds = ImageUtil.getAncestors( msg.getUserId( ), diskInfo.getImageLocation( ) );\n    Long imgSize = ImageUtil.getSize( msg.getUserId( ), diskInfo.getImageLocation( ) );\n    if ( imgSize > 1024l * 1024l * 1024l * vmType.getDisk( ) ) {\n      throw new EucalyptusCloudException( \"image too large [size=\" + imgSize / ( 1024l * 1024l ) + \"MB] for instance type \" + vmType.getName( ) + \" [disk=\"\n                                          + vmType.getDisk( ) * 1024l + \"MB]\" );\n    }\n    ImageUtil.checkStoredImage( kernelInfo );\n    ImageUtil.checkStoredImage( diskInfo );\n    VirtualBootRecord ref = null;\n    vmType.setRoot( diskInfo.getImageId( ), diskInfo.getImageLocation( ), imgSize*1024 );\n    if( kernelInfo != null ) {\n      vmType.setKernel( kernelInfo.getImageId( ), kernelInfo.getImageLocation( ) );\n    }\n    if( ramdiskInfo != null ) {\n      vmType.setRamdisk( ramdiskInfo.getImageId( ), ramdiskInfo.getImageLocation( ) );\n    }\n    return vmAllocInfo;\n  }","commit_id":"25754133cdfac49561e984735ddf2b6c7d32984a","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static Scope virtual_getProjectStructureScope_3734116213129936182(SNode thisNode, final SAbstractConcept kind) {\n    if (kind == MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0xcdff0e1a96739c2L, \"jetbrains.mps.build.structure.BuildSource_JavaOptions\")) {\n      return ScopeUtil.where(new SimpleRoleScope(SNodeOperations.getParent(thisNode), MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, 0x668c6cfbafacf6f2L, \"parts\"), \"jetbrains.mps.build.structure.BuildSource_JavaOptions\") {\n        @Override\n        public String getName(SNode jo) {\n          String optionsName = SPropertyOperations.getString(SNodeOperations.cast(jo, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0xcdff0e1a96739c2L, \"jetbrains.mps.build.structure.BuildSource_JavaOptions\")), MetaAdapterFactory.getProperty(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0xcdff0e1a96739c2L, 0xcdff0e1a96739c3L, \"optionsName\"));\n          return ((optionsName == null || optionsName.length() == 0) ? \"<default options>\" : optionsName);\n        }\n      }, new _FunctionTypes._return_P1_E0<Boolean, SNode>() {\n        public Boolean invoke(SNode node) {\n          return isNotEmptyString(SPropertyOperations.getString(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0xcdff0e1a96739c2L, \"jetbrains.mps.build.structure.BuildSource_JavaOptions\")), MetaAdapterFactory.getProperty(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0xcdff0e1a96739c2L, 0xcdff0e1a96739c3L, \"optionsName\")));\n        }\n      });\n    }\n\n    if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(kind), MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafacdc38L, \"jetbrains.mps.build.structure.BuildSource_JavaModule\")) || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(kind), MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x540febaa6144b873L, \"jetbrains.mps.build.structure.BuildSource_JavaLibrary\"))) {\n      Iterable<DescendantsScope> forAllVisible = Sequence.fromIterable(BuildProject_Behavior.call_getVisibleProjects_1224588814561807665(BuildPlugin_Behavior.call_getProject_1224588814561866657(thisNode), false)).select(new ISelector<SNode, DescendantsScope>() {\n        public DescendantsScope select(SNode it) {\n          return DescendantsScope.forNamedElements(it, MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, 0x668c6cfbafacf6f2L, \"parts\"), kind);\n        }\n      });\n      Iterable<DescendantsScope> forThis = Sequence.<DescendantsScope>singleton(DescendantsScope.forNamedElements(BuildPlugin_Behavior.call_getProject_1224588814561866657(thisNode), MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, 0x668c6cfbafacf6f2L, \"parts\"), kind));\n      return new CompositeScope(Sequence.fromIterable(forAllVisible).concat(Sequence.fromIterable(forThis)).toGenericArray(DescendantsScope.class));\n    }\n\n    return null;\n  }","id":93026,"modified_method":"public static Scope virtual_getProjectStructureScope_3734116213129936182(SNode thisNode, final SAbstractConcept kind) {\n    if (kind == MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0xcdff0e1a96739c2L, \"jetbrains.mps.build.structure.BuildSource_JavaOptions\")) {\n      return ScopeUtil.where(new SimpleRoleScope(SNodeOperations.getParent(thisNode), MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, 0x668c6cfbafacf6f2L, \"parts\"), MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0xcdff0e1a96739c2L, \"jetbrains.mps.build.structure.BuildSource_JavaOptions\")) {\n        @Override\n        public String getName(SNode jo) {\n          String optionsName = SPropertyOperations.getString(SNodeOperations.cast(jo, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0xcdff0e1a96739c2L, \"jetbrains.mps.build.structure.BuildSource_JavaOptions\")), MetaAdapterFactory.getProperty(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0xcdff0e1a96739c2L, 0xcdff0e1a96739c3L, \"optionsName\"));\n          return ((optionsName == null || optionsName.length() == 0) ? \"<default options>\" : optionsName);\n        }\n      }, new _FunctionTypes._return_P1_E0<Boolean, SNode>() {\n        public Boolean invoke(SNode node) {\n          return isNotEmptyString(SPropertyOperations.getString(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0xcdff0e1a96739c2L, \"jetbrains.mps.build.structure.BuildSource_JavaOptions\")), MetaAdapterFactory.getProperty(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0xcdff0e1a96739c2L, 0xcdff0e1a96739c3L, \"optionsName\")));\n        }\n      });\n    }\n\n    if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(kind), MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x668c6cfbafacdc38L, \"jetbrains.mps.build.structure.BuildSource_JavaModule\")) || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(kind), MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x540febaa6144b873L, \"jetbrains.mps.build.structure.BuildSource_JavaLibrary\"))) {\n      Iterable<DescendantsScope> forAllVisible = Sequence.fromIterable(BuildProject_Behavior.call_getVisibleProjects_1224588814561807665(BuildPlugin_Behavior.call_getProject_1224588814561866657(thisNode), false)).select(new ISelector<SNode, DescendantsScope>() {\n        public DescendantsScope select(SNode it) {\n          return DescendantsScope.forNamedElements(it, MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, 0x668c6cfbafacf6f2L, \"parts\"), kind);\n        }\n      });\n      Iterable<DescendantsScope> forThis = Sequence.<DescendantsScope>singleton(DescendantsScope.forNamedElements(BuildPlugin_Behavior.call_getProject_1224588814561866657(thisNode), MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, 0x668c6cfbafacf6f2L, \"parts\"), kind));\n      return new CompositeScope(Sequence.fromIterable(forAllVisible).concat(Sequence.fromIterable(forThis)).toGenericArray(DescendantsScope.class));\n    }\n\n    return null;\n  }","commit_id":"01fe125c157f4c9d80dbdf4b31a0fcb6ad688dd1","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * \n   * @deprecated use concept/../ variant, remove after 3.3\n   */\n  @Deprecated\n  public ModelsScope(Iterable<SModel> models, boolean rootsOnly, String targetConcept) {\n    myModels = SetSequence.fromSetWithValues(new HashSet<SModel>(), models);\n    myRootsOnly = rootsOnly;\n    myTargetConcept=MetaAdapterFactoryByName.getTypedConcept_DoNotUse(targetConcept);\n  }","id":93027,"modified_method":"/**\n   * \n   * @deprecated use concept/../ variant, remove after 3.3\n   */\n  @Deprecated\n  public ModelsScope(Iterable<SModel> models, boolean rootsOnly, String targetConcept) {\n    myModels = SetSequence.fromSetWithValues(new HashSet<SModel>(), models);\n    myRootsOnly = rootsOnly;\n    ConceptDescriptor cd = ConceptRegistryUtil.getConceptDescriptor(targetConcept);\n    if (cd == null) {\n      myTargetConcept = MetaAdapterFactoryByName.getConcept(targetConcept);\n    } else {\n      myTargetConcept = (cd.isInterfaceConcept() ? MetaAdapterFactoryByName.getInterfaceConcept(targetConcept) : MetaAdapterFactoryByName.getConcept(targetConcept));\n    }\n  }","commit_id":"01fe125c157f4c9d80dbdf4b31a0fcb6ad688dd1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SNode resolve(SNode contextNode, String refText) {\n    SNode result = null;\n    for (SNode n : SNodeOperations.getChildren(myNode, myLink)) {\n      if (this.conceptFqName != null && !(SModelUtil.isAssignableConcept(n.getConcept().getQualifiedName(), conceptFqName))) {\n        continue;\n      }\n      if (getName(n).equals(refText)) {\n        if (result != null) {\n          return null;\n        }\n        result = n;\n      }\n    }\n    return result;\n  }","id":93028,"modified_method":"@Override\n  public SNode resolve(SNode contextNode, String refText) {\n    SNode result = null;\n    for (SNode n : SNodeOperations.getChildren(myNode, myLink)) {\n      if (this.concept != null && !(n.getConcept().isSubConceptOf(concept))) {\n        continue;\n      }\n      if (getName(n).equals(refText)) {\n        if (result != null) {\n          return null;\n        }\n        result = n;\n      }\n    }\n    return result;\n  }","commit_id":"01fe125c157f4c9d80dbdf4b31a0fcb6ad688dd1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public String getReferenceText(SNode contextNode, SNode node) {\n    if (node == null || SNodeOperations.getParent(node) != myNode) {\n      return null;\n    }\n    if (this.conceptFqName != null && !(SModelUtil.isAssignableConcept(node.getConcept().getQualifiedName(), conceptFqName))) {\n      return null;\n    }\n\n    String result = getName(node);\n    for (SNode n : SNodeOperations.getChildren(myNode, myLink)) {\n      if (n == node) {\n        continue;\n      }\n      if (this.conceptFqName != null && !(SModelUtil.isAssignableConcept(n.getConcept().getQualifiedName(), conceptFqName))) {\n        continue;\n      }\n      String name = getName(n);\n      if (name.equals(result)) {\n        // ambiguity \n        return null;\n      }\n    }\n    return result;\n  }","id":93029,"modified_method":"@Override\n  public String getReferenceText(SNode contextNode, SNode node) {\n    if (node == null || SNodeOperations.getParent(node) != myNode) {\n      return null;\n    }\n    if (this.concept != null && !(node.getConcept().isSubConceptOf(concept))) {\n      return null;\n    }\n\n    String result = getName(node);\n    for (SNode n : SNodeOperations.getChildren(myNode, myLink)) {\n      if (n == node) {\n        continue;\n      }\n      if (this.concept != null && !(n.getConcept().isSubConceptOf(concept))) {\n        continue;\n      }\n      String name = getName(n);\n      if (name.equals(result)) {\n        // ambiguity \n        return null;\n      }\n    }\n    return result;\n  }","commit_id":"01fe125c157f4c9d80dbdf4b31a0fcb6ad688dd1","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * \n   * @deprecated use SContainmentLink variant, to remove after 3.3\n   */\n  @Deprecated\n  public SimpleRoleScope(SNode node, SNode link, String conceptFqName) {\n    this.myNode = node;\n    this.myLink = MetaAdapterByDeclaration.getContainmentLink(link);\n    this.conceptFqName = conceptFqName;\n  }","id":93030,"modified_method":"/**\n   * \n   * @deprecated use SContainmentLink variant\n   */\n  @Deprecated\n  @ToRemove(version = 3.3)\n  public SimpleRoleScope(SNode node, SNode link, String conceptFqName) {\n    this.myNode = node;\n    this.myLink = MetaAdapterByDeclaration.getContainmentLink(link);\n    this.concept = MetaAdapterFactoryByName.getTypedConcept_DoNotUse(conceptFqName);\n  }","commit_id":"01fe125c157f4c9d80dbdf4b31a0fcb6ad688dd1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SimpleRoleScope(SNode node, SContainmentLink link, String conceptFqName) {\n    this.myNode = node;\n    this.myLink = link;\n    this.conceptFqName = conceptFqName;\n  }","id":93031,"modified_method":"public SimpleRoleScope(SNode node, SContainmentLink link, SAbstractConcept concept) {\n    this.myNode = node;\n    this.myLink = link;\n    this.concept = concept;\n  }","commit_id":"01fe125c157f4c9d80dbdf4b31a0fcb6ad688dd1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SimpleRoleScope(SNode node, SContainmentLink link) {\n    this.myNode = node;\n    this.myLink = link;\n    this.conceptFqName = null;\n  }","id":93032,"modified_method":"public SimpleRoleScope(SNode node, SContainmentLink link) {\n    this.myNode = node;\n    this.myLink = link;\n    this.concept = null;\n  }","commit_id":"01fe125c157f4c9d80dbdf4b31a0fcb6ad688dd1","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * \n   * @deprecated use SContainmentLink variant, to remove after 3.3\n   */\n  @Deprecated\n  public SimpleRoleScope(SNode node, SNode link) {\n    this.myNode = node;\n    this.myLink = MetaAdapterByDeclaration.getContainmentLink(link);\n    this.conceptFqName = null;\n  }","id":93033,"modified_method":"/**\n   * \n   * @deprecated use SContainmentLink variant\n   */\n  @Deprecated\n  @ToRemove(version = 3.3)\n  public SimpleRoleScope(SNode node, SNode link) {\n    this.myNode = node;\n    this.myLink = MetaAdapterByDeclaration.getContainmentLink(link);\n    this.concept = null;\n  }","commit_id":"01fe125c157f4c9d80dbdf4b31a0fcb6ad688dd1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Iterable<SNode> getAvailableElements(@Nullable String prefix) {\n    List<SNode> result = new ArrayList<SNode>();\n    for (SNode n : SNodeOperations.getChildren(myNode, myLink)) {\n      if (this.conceptFqName != null && !(SModelUtil.isAssignableConcept(n.getConcept().getQualifiedName(), conceptFqName))) {\n        continue;\n      }\n      String name = getName(n);\n      if (prefix == null || name.startsWith(prefix)) {\n        ListSequence.fromList(result).addElement(n);\n      }\n    }\n    return result;\n  }","id":93034,"modified_method":"@Override\n  public Iterable<SNode> getAvailableElements(@Nullable String prefix) {\n    List<SNode> result = new ArrayList<SNode>();\n    for (SNode n : SNodeOperations.getChildren(myNode, myLink)) {\n      if (this.concept != null && !(n.getConcept().isSubConceptOf(concept))) {\n        continue;\n      }\n      String name = getName(n);\n      if (prefix == null || name.startsWith(prefix)) {\n        ListSequence.fromList(result).addElement(n);\n      }\n    }\n    return result;\n  }","commit_id":"01fe125c157f4c9d80dbdf4b31a0fcb6ad688dd1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\t\tprotected void doPostXml(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n\t\t\tString ipAddress = request.getRemoteAddr();\n\n\t\t\tM_log.debug(\"LTI POX Service request from IP=\" + ipAddress);\n\n\t\t\tString allowOutcomes = ServerConfigurationService.getString(\n\t\t\t\t\tSakaiBLTIUtil.BASICLTI_OUTCOMES_ENABLED, null);\n\t\t\tif ( ! \"true\".equals(allowOutcomes) ) allowOutcomes = null;\n\n\t\t\tString allowSettings = ServerConfigurationService.getString(\n\t\t\t\t\tSakaiBLTIUtil.BASICLTI_SETTINGS_ENABLED, null);\n\t\t\tif ( ! \"true\".equals(allowSettings) ) allowSettings = null;\n\n\t\t\tString allowRoster = ServerConfigurationService.getString(\n\t\t\t\t\tSakaiBLTIUtil.BASICLTI_ROSTER_ENABLED, null);\n\t\t\tif ( ! \"true\".equals(allowRoster) ) allowRoster = null;\n\n\t\t\tif (allowOutcomes == null && allowSettings == null && allowRoster == null ) {\n\t\t\t\tM_log.warn(\"Basic LTI Services are disabled IP=\" + ipAddress);\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_FORBIDDEN);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tIMSPOXRequest pox = new IMSPOXRequest(request);\n\t\t\tif ( ! pox.valid ) {\n\t\t\t\tdoErrorXml(request, response, pox, \"pox.invalid\", pox.errorMessage, null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//check lti_message_type\n\t\t\tString lti_message_type = pox.getOperation();\n\n\t\t\tString sourcedid = null;\n\t\t\tString message_type = null;\n\t\t\tif ( ( \"replaceResultRequest\".equals(lti_message_type) || \"readResultRequest\".equals(lti_message_type) ||\n                   \"deleteResultRequest\".equals(lti_message_type) )  && allowOutcomes != null ) {\n\t\t\t\tMap<String,String> bodyMap = pox.getBodyMap();\n\t\t\t\tsourcedid = bodyMap.get(\"/resultRecord/sourcedGUID/sourcedId\");\n\t\t\t\t// System.out.println(\"sourcedid=\"+sourcedid);\n\t\t\t\tmessage_type = \"basicoutcome\";\n\t\t\t} else {\n\t\t\t\tString output = pox.getResponseUnsupported(\"Not supported \"+lti_message_type);\n\t\t\t\tresponse.setContentType(\"application/xml\");\n\t\t\t\tPrintWriter out = response.getWriter();\n\t\t\t\tout.println(output);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// No point continuing without a sourcedid\n\t\t\tif(BasicLTIUtil.isBlank(sourcedid)) {\n\t\t\t\tdoErrorXml(request, response, pox, \"outcomes.missing\", \"sourcedid\", null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Truncate this to the maximum length to insure no cruft at the end\n\t\t\tif ( sourcedid.length() > 2048) sourcedid = sourcedid.substring(0,2048);\n\n\t\t\t// Attempt to parse the sourcedid, any failure is fatal\n\t\t\tString placement_id = null;\n\t\t\tString signature = null;\n\t\t\tString user_id = null;\n\t\t\ttry {\n\t\t\t\tint pos = sourcedid.indexOf(\":::\");\n\t\t\t\tif ( pos > 0 ) {\n\t\t\t\t\tsignature = sourcedid.substring(0, pos);\n\t\t\t\t\tString dec2 = sourcedid.substring(pos+3);\n\t\t\t\t\tpos = dec2.indexOf(\":::\");\n\t\t\t\t\tuser_id = dec2.substring(0,pos);\n\t\t\t\t\tplacement_id = dec2.substring(pos+3);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\t// Log some detail for ourselves\n\t\t\t\tM_log.warn(\"Unable to decrypt result_sourcedid IP=\" + ipAddress + \" Error=\" + e.getMessage(),e);\n\t\t\t\tsignature = null;\n\t\t\t\tplacement_id = null;\n\t\t\t\tuser_id = null;\n\t\t\t}\n\n\t\t\t// Send a more generic message back to the caller\n\t\t\tif ( placement_id == null || user_id == null ) {\n\t\t\t\tdoErrorXml(request, response, pox, \"outcomes.sourcedid\", \"sourcedid\", null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tM_log.debug(\"signature=\"+signature);\n\t\t\tM_log.debug(\"user_id=\"+user_id);\n\t\t\tM_log.debug(\"placement_id=\"+placement_id);\n\n\t\t\tToolConfiguration placement = SiteService.findTool(placement_id);\n\t\t\tProperties config = placement.getConfig();\n\t\t\tString siteId = null;\n\t\t\tSite site = null;\n\t\t\ttry { \n\t\t\t\tplacement = SiteService.findTool(placement_id);\n\t\t\t\tconfig = placement.getConfig();\n\t\t\t\tsiteId = placement.getSiteId();\n\t\t\t\tsite = SiteService.getSite(siteId);\n\t\t\t} catch (Exception e) {\n\t\t\t\tM_log.debug(\"Error retrieving result_sourcedid information: \"+e.getLocalizedMessage(), e);\n\t\t\t\tplacement = null;\n\t\t\t}\n\n\t\t\t// Send a more generic message back to the caller\n\t\t\tif ( placement == null || config == null || siteId == null || site == null ) {\n\t\t\t\tdoErrorXml(request, response, pox, \"outcomes.sourcedid\", \"sourcedid\", null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check the message signature using OAuth\n\t\t\tString oauth_consumer_key = pox.getOAuthConsumerKey();\n\t\t\tString oauth_secret = SakaiBLTIUtil.toNull(SakaiBLTIUtil.getCorrectProperty(config,\"secret\", placement));\n\n\t\t\tpox.validateRequest(oauth_consumer_key, oauth_secret, request);\n\t\t\tif ( ! pox.valid ) {\n\t\t\t\tif (pox.base_string != null) {\n\t\t\t\t\tM_log.warn(pox.base_string);\n\t\t\t\t}\n\t\t\t\tdoErrorXml(request, response, pox, \"outcome.no.validate\", oauth_consumer_key, null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check the signature of the sourcedid to make sure it was not altered\n\t\t\tString placement_secret  = SakaiBLTIUtil.toNull(SakaiBLTIUtil.getCorrectProperty(config,\"placementsecret\", placement));\n\n\t\t\t// Send a generic message back to the caller\n\t\t\tif ( placement_secret ==null ) {\n\t\t\t\tdoErrorXml(request, response, pox, \"outcomes.sourcedid\", \"sourcedid\", null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString pre_hash = placement_secret + \":::\" + user_id + \":::\" + placement_id;\n\t\t\tString received_signature = ShaUtil.sha256Hash(pre_hash);\n\t\t\tM_log.debug(\"Received signature=\"+signature+\" received=\"+received_signature);\n\t\t\tboolean matched = signature.equals(received_signature);\n\n\t\t\tString old_placement_secret  = SakaiBLTIUtil.toNull(SakaiBLTIUtil.getCorrectProperty(config,\"oldplacementsecret\", placement));\n\t\t\tif ( old_placement_secret != null && ! matched ) {\n\t\t\t\tpre_hash = placement_secret + \":::\" + user_id + \":::\" + placement_id;\n\t\t\t\treceived_signature = ShaUtil.sha256Hash(pre_hash);\n\t\t\t\tM_log.debug(\"Received signature II=\"+signature+\" received=\"+received_signature);\n\t\t\t\tmatched = signature.equals(received_signature);\n\t\t\t}\n\n\t\t\t// Send a message back to the caller\n\t\t\tif ( ! matched ) {\n\t\t\t\tdoErrorXml(request, response, pox, \"outcomes.sourcedid\", \"sourcedid\", null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( \"basicoutcome\".equals(message_type) ) {\n\t\t\t\tprocessOutcomeXml(request, response, lti_message_type, site, siteId, placement, config, user_id, pox);\n\t\t\t} else {\n\t\t\t\tresponse.setContentType(\"application/xml\");\n\t\t\t\tPrintWriter writer = response.getWriter();\n\t\t\t\tString desc = \"Message received and validated operation=\"+pox.getOperation();\n\t\t\t\tString output = pox.getResponseUnsupported(desc);\n\t\t\t\twriter.println(output);\n\t\t\t}\n\n\t\t}","id":93035,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t\tprotected void doPostXml(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n\t\t\tString ipAddress = request.getRemoteAddr();\n\n\t\t\tM_log.debug(\"LTI POX Service request from IP=\" + ipAddress);\n\n\t\t\tString allowOutcomes = ServerConfigurationService.getString(\n\t\t\t\t\tSakaiBLTIUtil.BASICLTI_OUTCOMES_ENABLED, null);\n\t\t\tif ( ! \"true\".equals(allowOutcomes) ) allowOutcomes = null;\n\n\t\t\tif (allowOutcomes == null ) {\n\t\t\t\tM_log.warn(\"Basic LTI Services are disabled IP=\" + ipAddress);\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_FORBIDDEN);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tIMSPOXRequest pox = new IMSPOXRequest(request);\n\t\t\tif ( ! pox.valid ) {\n\t\t\t\tdoErrorXml(request, response, pox, \"pox.invalid\", pox.errorMessage, null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//check lti_message_type\n\t\t\tString lti_message_type = pox.getOperation();\n\n\t\t\tString sourcedid = null;\n\t\t\tString message_type = null;\n\t\t\tif ( ( \"replaceResultRequest\".equals(lti_message_type) || \"readResultRequest\".equals(lti_message_type) ||\n                   \"deleteResultRequest\".equals(lti_message_type) )  && allowOutcomes != null ) {\n\t\t\t\tMap<String,String> bodyMap = pox.getBodyMap();\n\t\t\t\tsourcedid = bodyMap.get(\"/resultRecord/sourcedGUID/sourcedId\");\n\t\t\t\t// System.out.println(\"sourcedid=\"+sourcedid);\n\t\t\t\tmessage_type = \"basicoutcome\";\n\t\t\t} else {\n\t\t\t\tString output = pox.getResponseUnsupported(\"Not supported \"+lti_message_type);\n\t\t\t\tresponse.setContentType(\"application/xml\");\n\t\t\t\tPrintWriter out = response.getWriter();\n\t\t\t\tout.println(output);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// No point continuing without a sourcedid\n\t\t\tif(BasicLTIUtil.isBlank(sourcedid)) {\n\t\t\t\tdoErrorXml(request, response, pox, \"outcomes.missing\", \"sourcedid\", null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Truncate this to the maximum length to insure no cruft at the end\n\t\t\tif ( sourcedid.length() > 2048) sourcedid = sourcedid.substring(0,2048);\n\n\t\t\t// Attempt to parse the sourcedid, any failure is fatal\n\t\t\tString placement_id = null;\n\t\t\tString signature = null;\n\t\t\tString user_id = null;\n\t\t\ttry {\n\t\t\t\tint pos = sourcedid.indexOf(\":::\");\n\t\t\t\tif ( pos > 0 ) {\n\t\t\t\t\tsignature = sourcedid.substring(0, pos);\n\t\t\t\t\tString dec2 = sourcedid.substring(pos+3);\n\t\t\t\t\tpos = dec2.indexOf(\":::\");\n\t\t\t\t\tuser_id = dec2.substring(0,pos);\n\t\t\t\t\tplacement_id = dec2.substring(pos+3);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\t// Log some detail for ourselves\n\t\t\t\tM_log.warn(\"Unable to decrypt result_sourcedid IP=\" + ipAddress + \" Error=\" + e.getMessage(),e);\n\t\t\t\tsignature = null;\n\t\t\t\tplacement_id = null;\n\t\t\t\tuser_id = null;\n\t\t\t}\n\n\t\t\t// Send a more generic message back to the caller\n\t\t\tif ( placement_id == null || user_id == null ) {\n\t\t\t\tdoErrorXml(request, response, pox, \"outcomes.sourcedid\", \"sourcedid\", null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tM_log.debug(\"signature=\"+signature);\n\t\t\tM_log.debug(\"user_id=\"+user_id);\n\t\t\tM_log.debug(\"placement_id=\"+placement_id);\n\n\t\t\tToolConfiguration placement = SiteService.findTool(placement_id);\n\t\t\tProperties config = placement.getConfig();\n\t\t\tString siteId = null;\n\t\t\tSite site = null;\n\t\t\ttry { \n\t\t\t\tplacement = SiteService.findTool(placement_id);\n\t\t\t\tconfig = placement.getConfig();\n\t\t\t\tsiteId = placement.getSiteId();\n\t\t\t\tsite = SiteService.getSite(siteId);\n\t\t\t} catch (Exception e) {\n\t\t\t\tM_log.debug(\"Error retrieving result_sourcedid information: \"+e.getLocalizedMessage(), e);\n\t\t\t\tplacement = null;\n\t\t\t}\n\n\t\t\t// Send a more generic message back to the caller\n\t\t\tif ( placement == null || config == null || siteId == null || site == null ) {\n\t\t\t\tdoErrorXml(request, response, pox, \"outcomes.sourcedid\", \"sourcedid\", null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check the message signature using OAuth\n\t\t\tString oauth_consumer_key = pox.getOAuthConsumerKey();\n\t\t\tString oauth_secret = SakaiBLTIUtil.toNull(SakaiBLTIUtil.getCorrectProperty(config,\"secret\", placement));\n\n\t\t\tpox.validateRequest(oauth_consumer_key, oauth_secret, request);\n\t\t\tif ( ! pox.valid ) {\n\t\t\t\tif (pox.base_string != null) {\n\t\t\t\t\tM_log.warn(pox.base_string);\n\t\t\t\t}\n\t\t\t\tdoErrorXml(request, response, pox, \"outcome.no.validate\", oauth_consumer_key, null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check the signature of the sourcedid to make sure it was not altered\n\t\t\tString placement_secret  = SakaiBLTIUtil.toNull(SakaiBLTIUtil.getCorrectProperty(config,\"placementsecret\", placement));\n\n\t\t\t// Send a generic message back to the caller\n\t\t\tif ( placement_secret ==null ) {\n\t\t\t\tdoErrorXml(request, response, pox, \"outcomes.sourcedid\", \"sourcedid\", null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString pre_hash = placement_secret + \":::\" + user_id + \":::\" + placement_id;\n\t\t\tString received_signature = ShaUtil.sha256Hash(pre_hash);\n\t\t\tM_log.debug(\"Received signature=\"+signature+\" received=\"+received_signature);\n\t\t\tboolean matched = signature.equals(received_signature);\n\n\t\t\tString old_placement_secret  = SakaiBLTIUtil.toNull(SakaiBLTIUtil.getCorrectProperty(config,\"oldplacementsecret\", placement));\n\t\t\tif ( old_placement_secret != null && ! matched ) {\n\t\t\t\tpre_hash = placement_secret + \":::\" + user_id + \":::\" + placement_id;\n\t\t\t\treceived_signature = ShaUtil.sha256Hash(pre_hash);\n\t\t\t\tM_log.debug(\"Received signature II=\"+signature+\" received=\"+received_signature);\n\t\t\t\tmatched = signature.equals(received_signature);\n\t\t\t}\n\n\t\t\t// Send a message back to the caller\n\t\t\tif ( ! matched ) {\n\t\t\t\tdoErrorXml(request, response, pox, \"outcomes.sourcedid\", \"sourcedid\", null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( \"basicoutcome\".equals(message_type) ) {\n\t\t\t\tprocessOutcomeXml(request, response, lti_message_type, site, siteId, placement, config, user_id, pox);\n\t\t\t} else {\n\t\t\t\tresponse.setContentType(\"application/xml\");\n\t\t\t\tPrintWriter writer = response.getWriter();\n\t\t\t\tString desc = \"Message received and validated operation=\"+pox.getOperation();\n\t\t\t\tString output = pox.getResponseUnsupported(desc);\n\t\t\t\twriter.println(output);\n\t\t\t}\n\n\t\t}","commit_id":"8d9bb94265544eff61592993eedeab071e56ea3f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\t\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\tString contentType = request.getContentType();\n\t\t\tif ( \"application/xml\".equals(contentType) ) {\n\t\t\t\tdoPostXml(request, response);\n\t\t\t} else {\n\t\t\t\tdoPostForm(request, response);\n\t\t\t}\n\t\t}","id":93036,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t\tString contentType = request.getContentType();\n\t\t\tif ( contentType != null && contentType.startsWith(\"application/xml\") ) {\n\t\t\t\tdoPostXml(request, response);\n\t\t\t} else {\n\t\t\t\tdoPostForm(request, response);\n\t\t\t}\n\t\t}","commit_id":"8d9bb94265544eff61592993eedeab071e56ea3f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private static void patchWM() {\n    if (SystemProperties.getBooleanProperty(\"idea.skip.wm.patching\", false)) return;\n    if (!\"sun.awt.X11.XToolkit\".equals(Toolkit.getDefaultToolkit().getClass().getName())) return;\n\n    try {\n      final Class<?> xwmClass = Class.forName(\"sun.awt.X11.XWM\");\n      final Method getWM = xwmClass.getDeclaredMethod(\"getWM\");\n      getWM.setAccessible(true);\n      final Object xwm = getWM.invoke(null);\n      if (xwm == null) return;\n\n      final Method getNetProtocol = xwmClass.getDeclaredMethod(\"getNETProtocol\");\n      getNetProtocol.setAccessible(true);\n      final Object netProtocol = getNetProtocol.invoke(xwm);\n      if (netProtocol == null) return;\n\n      final Method getWMName = netProtocol.getClass().getDeclaredMethod(\"getWMName\");\n      getWMName.setAccessible(true);\n      final String wmName = (String)getWMName.invoke(netProtocol);\n      LOG.info(\"WM detected: \" + wmName);\n      if (wmName == null) return;\n\n      if (\"Mutter\".equals(wmName)) {\n        try {\n          xwmClass.getDeclaredField(\"MUTTER_WM\");\n        }\n        catch (NoSuchFieldException e) {\n          setWM(xwm, \"METACITY_WM\");  // Mutter support absent - mimic Metacity\n        }\n      }\n      else if (\"Muffin\".equals(wmName) || \"GNOME Shell\".equals(wmName)) {\n        try {\n          xwmClass.getDeclaredField(\"MUTTER_WM\");\n          setWM(xwm, \"MUTTER_WM\");\n        }\n        catch (NoSuchFieldException e) {\n          setWM(xwm, \"METACITY_WM\");\n        }\n      }\n      else if (\"Marco\".equals(wmName)) {\n        setWM(xwm, \"METACITY_WM\");\n      }\n      else if (\"awesome\".equals(wmName)) {\n        try {\n          xwmClass.getDeclaredField(\"OTHER_NONREPARENTING_WM\");\n          if (System.getenv(\"_JAVA_AWT_WM_NONREPARENTING\") == null) {\n            setWM(xwm, \"OTHER_NONREPARENTING_WM\");  // patch present but not activated\n          }\n        }\n        catch (NoSuchFieldException e) {\n          setWM(xwm, \"LG3D_WM\");  // patch absent - mimic LG3D\n        }\n      }\n    }\n    catch (Throwable e) {\n      LOG.warn(e);\n    }\n  }","id":93037,"modified_method":"private static void patchWM() {\n    if (SystemProperties.getBooleanProperty(\"idea.skip.wm.patching\", false)) return;\n    if (!\"sun.awt.X11.XToolkit\".equals(Toolkit.getDefaultToolkit().getClass().getName())) return;\n\n    try {\n      final Class<?> xwmClass = Class.forName(\"sun.awt.X11.XWM\");\n      final Method getWM = xwmClass.getDeclaredMethod(\"getWM\");\n      getWM.setAccessible(true);\n      final Object xwm = getWM.invoke(null);\n      if (xwm == null) return;\n\n      final Method getNetProtocol = xwmClass.getDeclaredMethod(\"getNETProtocol\");\n      getNetProtocol.setAccessible(true);\n      final Object netProtocol = getNetProtocol.invoke(xwm);\n      if (netProtocol == null) return;\n\n      final Method getWMName = netProtocol.getClass().getDeclaredMethod(\"getWMName\");\n      getWMName.setAccessible(true);\n      final String wmName = (String)getWMName.invoke(netProtocol);\n      LOG.info(\"WM detected: \" + wmName);\n      if (wmName == null) return;\n\n      if (wmName.startsWith(\"Mutter\") || \"Muffin\".equals(wmName) || \"GNOME Shell\".equals(wmName)) {\n        try {\n          setWM(xwm, \"MUTTER_WM\");\n        }\n        catch (NoSuchFieldException e) {\n          setWM(xwm, \"METACITY_WM\");\n        }\n      }\n      else if (\"Marco\".equals(wmName)) {\n        setWM(xwm, \"METACITY_WM\");\n      }\n      else if (\"awesome\".equals(wmName)) {\n        try {\n          xwmClass.getDeclaredField(\"OTHER_NONREPARENTING_WM\");\n          if (System.getenv(\"_JAVA_AWT_WM_NONREPARENTING\") == null) {\n            setWM(xwm, \"OTHER_NONREPARENTING_WM\");  // patch present but not activated\n          }\n        }\n        catch (NoSuchFieldException e) {\n          setWM(xwm, \"LG3D_WM\");  // patch absent - mimic LG3D\n        }\n      }\n    }\n    catch (Throwable e) {\n      LOG.warn(e);\n    }\n  }","commit_id":"bb96af94769b2922e73fd0b66608e5093ee5eea7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static BufferedImage generateIcon(Content content, int iconSize) {\n\n        InputStream inputStream = null;\n        BufferedImage bi = null;\n        try {\n            inputStream = new ReadContentInputStream(content);\n            bi = ImageIO.read(inputStream);\n            if (bi == null) {\n                logger.log(Level.WARNING, \"No image reader for file: \" + content.getName()); //NON-NLS\n                return null;\n            }\n            BufferedImage biScaled = ScalrWrapper.resizeFast(bi, iconSize);\n            if (biScaled == null) {\n                return DEFAULT_ICON;\n            }\n            return biScaled;\n        } catch (IllegalArgumentException e) {\n            // if resizing does not work due to extremely small height/width ratio,\n            // crop the image instead.\n            BufferedImage biCropped = ScalrWrapper.cropImage(bi, Math.min(iconSize, bi.getWidth()), Math.min(iconSize, bi.getHeight()));\n            return biCropped;\n        } catch (OutOfMemoryError e) {\n            logger.log(Level.WARNING, \"Could not scale image (too large): \" + content.getName(), e); //NON-NLS\n            return null;\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Could not scale image: \" + content.getName(), e); //NON-NLS\n            return null;\n        } finally {\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                } catch (IOException ex) {\n                    logger.log(Level.WARNING, \"Could not close input stream after resizing thumbnail: \" + content.getName(), ex); //NON-NLS\n                }\n            }\n\n        }\n\n    }","id":93038,"modified_method":"private static BufferedImage generateImageThumbnail(Content content, int iconSize) {\n\n        InputStream inputStream = null;\n        BufferedImage bi = null;\n        try {\n            inputStream = new ReadContentInputStream(content);\n            bi = ImageIO.read(inputStream);\n            if (bi == null) {\n                logger.log(Level.WARNING, \"No image reader for file: \" + content.getName()); //NON-NLS\n                return null;\n            }\n            return ScalrWrapper.resizeFast(bi, iconSize);\n         \n        } catch (IllegalArgumentException e) {\n            // if resizing does not work due to extremely small height/width ratio,\n            // crop the image instead.\n            BufferedImage biCropped = ScalrWrapper.cropImage(bi, Math.min(iconSize, bi.getWidth()), Math.min(iconSize, bi.getHeight()));\n            return biCropped;\n        } catch (OutOfMemoryError e) {\n            logger.log(Level.WARNING, \"Could not scale image (too large): \" + content.getName(), e); //NON-NLS\n            return null;\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Could not scale image: \" + content.getName(), e); //NON-NLS\n            return null;\n        } finally {\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                } catch (IOException ex) {\n                    logger.log(Level.WARNING, \"Could not close input stream after resizing thumbnail: \" + content.getName(), ex); //NON-NLS\n                }\n            }\n        }\n    }","commit_id":"faa0c886cf662278c1ea463f75e4eaf5ba35301c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Get a file object for where the cached icon should exist. The returned\n     * file may not exist.\n     *\n     * @param fileID\n     *\n     * @return\n     *\n     */\n    private static File getCachedThumbnailLocation(long fileID) {\n        return Paths.get(Case.getCurrentCase().getCacheDirectory(), fileID + \".png\").toFile();\n    }","id":93039,"modified_method":"/**\n     * Get a file object for where the cached icon should exist. The returned\n     * file may not exist.\n     *\n     * @param fileID\n     *\n     * @return\n     *\n     */\n    private static File getCachedThumbnailLocation(long fileID) {\n        return Paths.get(Case.getCurrentCase().getCacheDirectory(), \"thumbnails\", fileID + \".png\").toFile();\n    }","commit_id":"faa0c886cf662278c1ea463f75e4eaf5ba35301c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private static BufferedImage generateVideoIcon(AbstractFile file, int iconSize) {\n\n        final String extension = file.getNameExtension();\n\n        java.io.File tempFile = Paths.get(Case.getCurrentCase().getTempDirectory(), \"videos\", file.getId() + \".\" + extension).toFile();\n\n        try {\n\n            copyFileUsingStream(file, tempFile); //create small file in TEMP directory from the content object\n        } catch (IOException ex) {\n            return DEFAULT_ICON;\n        }\n\n        VideoCapture videoFile = new VideoCapture(); // will contain the video     \n\n        if (!videoFile.open(tempFile.toString())) {\n            return DEFAULT_ICON;\n        }\n        double fps = videoFile.get(CV_CAP_PROP_FPS); // gets frame per second\n        double totalFrames = videoFile.get(CV_CAP_PROP_FRAME_COUNT); // gets total frames\n        if (fps <= 0 || totalFrames <= 0) {\n            return DEFAULT_ICON;\n        }\n        double milliseconds = 1000 * (totalFrames / fps); //total milliseconds\n\n        double timestamp = Math.min(milliseconds, 500); //default time to check for is 500ms, unless the files is extremely small\n\n        int framkeskip = Double.valueOf(Math.floor(milliseconds / 9)).intValue();\n\n        Mat imageMatrix = new Mat();\n        BufferedImage bufferedImage = null;\n        for (int x = 0; x < 3; x++) {\n            for (int y = 0; y < 3; y++) {\n                if (!videoFile.set(CV_CAP_PROP_POS_MSEC, timestamp + x * framkeskip)) {\n                    return DEFAULT_ICON;\n                }\n                if (!videoFile.read(imageMatrix)) { //read the frame into the image/matrix\n                    return DEFAULT_ICON; //if the image for some reason is bad, return default icon\n                }\n\n                if (bufferedImage == null) {\n                    bufferedImage = new BufferedImage(imageMatrix.cols() * 3, imageMatrix.rows() * 3, BufferedImage.TYPE_3BYTE_BGR);\n                }\n\n                byte[] data = new byte[imageMatrix.rows() * imageMatrix.cols() * (int) (imageMatrix.elemSize())];\n                imageMatrix.get(0, 0, data); //copy the image to data\n\n                //todo: this looks like we are swapping the first and third channels.  so we can use  BufferedImage.TYPE_3BYTE_BGR\n                if (imageMatrix.channels() == 3) {\n                    for (int k = 0; k < data.length; k += 3) {\n                        byte temp = data[k];\n                        data[k] = data[k + 2];\n                        data[k + 2] = temp;\n                    }\n                }\n\n                bufferedImage.getRaster().setDataElements(imageMatrix.cols() * x, imageMatrix.rows() * y, imageMatrix.cols(), imageMatrix.rows(), data);\n            }\n        }\n\n        videoFile.release(); // close the file\n\n        bufferedImage = ScalrWrapper.resizeFast(bufferedImage, iconSize);\n        if (bufferedImage == null) {\n            return DEFAULT_ICON;\n        } else {\n            return bufferedImage;\n        }\n    }","id":93040,"modified_method":"private static BufferedImage generateVideoThumbnail(AbstractFile file, int iconSize) {\n\n        final String extension = file.getNameExtension();\n\n        java.io.File tempFile = Paths.get(Case.getCurrentCase().getCacheDirectory(), \"videos\", file.getId() + \".\" + extension).toFile();\n\n        try {\n            if (tempFile.exists() == false || tempFile.length() < file.getSize()) {\n                copyFileUsingStream(file, tempFile);\n            }\n        } catch (IOException ex) {\n            return null;\n        }\n\n        VideoCapture videoFile = new VideoCapture(); // will contain the video\n\n        if (!videoFile.open(tempFile.toString())) {\n            return null;\n        }\n        double fps = videoFile.get(CV_CAP_PROP_FPS); // gets frame per second\n        double totalFrames = videoFile.get(CV_CAP_PROP_FRAME_COUNT); // gets total frames\n        if (fps <= 0 || totalFrames <= 0) {\n            return null;\n        }\n        double milliseconds = 1000 * (totalFrames / fps); //total milliseconds\n\n        double timestamp = Math.min(milliseconds, 500); //default time to check for is 500ms, unless the files is extremely small\n\n        int framkeskip = Double.valueOf(Math.floor((milliseconds - timestamp) / (THUMB_COLUMNS * THUMB_ROWS))).intValue();\n\n        Mat imageMatrix = new Mat();\n        BufferedImage bufferedImage = null;\n\n        for (int x = 0; x < THUMB_COLUMNS; x++) {\n            for (int y = 0; y < THUMB_ROWS; y++) {\n                if (!videoFile.set(CV_CAP_PROP_POS_MSEC, timestamp + x * framkeskip + y * framkeskip * THUMB_COLUMNS)) {\n                    break;\n                }\n                //read the frame into the image/matrix\n                if (!videoFile.read(imageMatrix)) {\n                    break; //if the image for some reason is bad, return default icon\n                }\n\n                if (bufferedImage == null) {\n                    bufferedImage = new BufferedImage(imageMatrix.cols() * THUMB_COLUMNS, imageMatrix.rows() * THUMB_ROWS, BufferedImage.TYPE_3BYTE_BGR);\n                }\n\n                byte[] data = new byte[imageMatrix.rows() * imageMatrix.cols() * (int) (imageMatrix.elemSize())];\n                imageMatrix.get(0, 0, data); //copy the image to data\n\n                //todo: this looks like we are swapping the first and third channels.  so we can use  BufferedImage.TYPE_3BYTE_BGR\n                if (imageMatrix.channels() == 3) {\n                    for (int k = 0; k < data.length; k += 3) {\n                        byte temp = data[k];\n                        data[k] = data[k + 2];\n                        data[k + 2] = temp;\n                    }\n                }\n\n                bufferedImage.getRaster().setDataElements(imageMatrix.cols() * x, imageMatrix.rows() * y, imageMatrix.cols(), imageMatrix.rows(), data);\n            }\n        }\n\n        videoFile.release(); // close the file\n\n        return ScalrWrapper.resizeFast(bufferedImage, iconSize);\n    }","commit_id":"faa0c886cf662278c1ea463f75e4eaf5ba35301c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Get a thumbnail of a specified size. Generates the image if it is\n     * not already cached.\n     *\n     * @param content\n     * @param iconSize\n     *\n     * @return\n     */\n    public static Image getIcon(Content content, int iconSize) {\n        //TODO: why do we allow Content here if we only handle AbstractFiles?\n\n        Image icon = null;\n        // If a thumbnail file is already saved locally\n        // @@@ Bug here in that we do not refer to size in the cache. \n\n        File iconFile = getCachedThumbnailLocation(content.getId());\n        // If a thumbnail file is already saved locally\n        if (iconFile.exists()) {\n            try {\n                BufferedImage bicon = ImageIO.read(iconFile);\n                if (bicon == null) {\n                    icon = DEFAULT_ICON;\n                } else if (bicon.getWidth() != iconSize) {\n                    icon = generateAndSaveIcon(content, iconSize, iconFile);\n                } else {\n                    icon = bicon;\n                }\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Error while reading image.\", ex); //NON-NLS\n                icon = DEFAULT_ICON;\n            }\n        } else {\n            final String extension = ((AbstractFile) content).getNameExtension();\n\n            if (SUPP_VIDEO_EXTENSIONS.contains(extension) || SUPP_IMAGE_EXTENSIONS.contains(extension)) {\n                icon = generateAndSaveIcon(content, iconSize, iconFile);\n            }\n        }\n        if (icon == null) {\n            return DEFAULT_ICON;\n        }\n        return icon;\n    }","id":93041,"modified_method":"/**\n     * Get a thumbnail of a specified size. Generates the image if it is\n     * not already cached.\n     *\n     * @param content\n     * @param iconSize\n     *\n     * @return\n     */\n    public static Image getIcon(Content content, int iconSize) {\n        //TODO: why do we allow Content here if we only handle AbstractFiles?\n\n        Image icon = null;\n        // If a thumbnail file is already saved locally\n        // @@@ Bug here in that we do not refer to size in the cache. \n\n        File iconFile = getCachedThumbnailLocation(content.getId());\n        // If a thumbnail file is already saved locally\n        if (iconFile.exists()) {\n            try {\n                BufferedImage bicon = ImageIO.read(iconFile);\n                if (bicon == null) {\n                    icon = DEFAULT_ICON;\n                } else if (bicon.getWidth() != iconSize) {\n                    icon = generateAndSaveIcon(content, iconSize, iconFile);\n                } else {\n                    icon = bicon;\n                }\n            } catch (Exception ex) {\n                logger.log(Level.WARNING, \"Error while reading image.\", ex); //NON-NLS\n                icon = DEFAULT_ICON;\n            }\n        } else {\n            final String extension = ((AbstractFile) content).getNameExtension();\n\n            if (SUPP_VIDEO_EXTENSIONS.contains(extension) || SUPP_IMAGE_EXTENSIONS.contains(extension)) {\n                icon = generateAndSaveIcon(content, iconSize, iconFile);\n            }\n        }\n        if (icon == null) {\n            return DEFAULT_ICON;\n        }\n        return icon;\n    }","commit_id":"faa0c886cf662278c1ea463f75e4eaf5ba35301c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Generate an icon and save it to specified location.\n     *\n     * @param content  File to generate icon for\n     * @param iconSize\n     * @param saveFile Location to save thumbnail to\n     *\n     * @return Generated icon or null on error\n     */\n    private static Image generateAndSaveIcon(Content content, int iconSize, File saveFile) {\n        AbstractFile f = (AbstractFile) content;\n        final String extension = f.getNameExtension();\n        BufferedImage icon = null;\n        try {\n            if (SUPP_VIDEO_EXTENSIONS.contains(extension)) {\n                if (openCVLoaded) {\n                    icon = generateVideoIcon((AbstractFile) content, iconSize);\n                } else {\n                    return DEFAULT_ICON;\n                }\n            } else if (SUPP_IMAGE_EXTENSIONS.contains(extension)) {\n                icon = generateIcon(content, iconSize);\n            }\n\n            if (icon == null) {\n                return DEFAULT_ICON;\n\n            } else {\n                if (saveFile.exists()) {\n                    saveFile.delete();\n                }\n                ImageIO.write(icon, \"png\", saveFile); //NON-NLS\n            }\n        } catch (NullPointerException | IOException ex) {\n            logger.log(Level.WARNING, \"Could not write cache thumbnail: \" + content, ex); //NON-NLS\n        }\n        return icon;\n\n    }","id":93042,"modified_method":"/**\n     * Generate an icon and save it to specified location.\n     *\n     * @param content  File to generate icon for\n     * @param iconSize\n     * @param saveFile Location to save thumbnail to\n     *\n     * @return Generated icon or null on error\n     */\n    private static Image generateAndSaveIcon(Content content, int iconSize, File saveFile) {\n        AbstractFile f = (AbstractFile) content;\n        final String extension = f.getNameExtension();\n        BufferedImage icon = null;\n        try {\n            if (SUPP_VIDEO_EXTENSIONS.contains(extension)) {\n                if (openCVLoaded) {\n                    icon = generateVideoThumbnail((AbstractFile) content, iconSize);\n                } else {\n                    return DEFAULT_ICON;\n                }\n            } else if (SUPP_IMAGE_EXTENSIONS.contains(extension)) {\n                icon = generateImageThumbnail(content, iconSize);\n            }\n\n            if (icon == null) {\n                return DEFAULT_ICON;\n\n            } else {\n                if (saveFile.exists()) {\n                    saveFile.delete();\n                }\n                Files.createParentDirs(saveFile);\n                ImageIO.write(icon, \"png\", saveFile); //NON-NLS\n            }\n        } catch (NullPointerException | IOException ex) {\n            logger.log(Level.WARNING, \"Could not write cache thumbnail: \" + content, ex); //NON-NLS\n        }\n        return icon;\n    }","commit_id":"faa0c886cf662278c1ea463f75e4eaf5ba35301c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * copy the first 500kb to a temporary file\n     *\n     * @param file\n     * @param jFile\n     *\n     * @throws IOException\n     */\n    public static void copyFileUsingStream(Content file, java.io.File jFile) throws IOException {\n\n        try (InputStream is = new ReadContentInputStream(file);) {\n            // copy the file data to the temporary file\n\n//        OutputStream os = new FileOutputStream(jFile);\n            Files.copy(is, jFile.toPath());\n        }\n\n//        byte[] buffer = new byte[8192];\n//        int length;\n//        int counter = 0;\n//        try {\n//            while ((length = is.read(buffer)) != -1) {\n//                os.write(buffer, 0, length);\n//                counter++;\n//                if (counter >= 63) {\n//                    break; //after saving 500 KB (63*8192)\n//                }\n//            }\n//\n//        } finally {\n//            is.close();\n//            os.close();\n//        }\n    }","id":93043,"modified_method":"/**\n     * copy the first 500kb to a temporary file\n     *\n     * @param file\n     * @param tempFile\n     *\n     * @throws IOException\n     */\n    public static void copyFileUsingStream(Content file, java.io.File tempFile) throws IOException {\n        com.google.common.io.Files.createParentDirs(tempFile);\n\n        ProgressHandle progress = ProgressHandleFactory.createHandle(\"extracting temporary file \" + file.getName());\n        progress.start();\n        progress.switchToDeterminate(100);\n        try {\n            ContentUtils.writeToFile(file, tempFile, progress, null, true);\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, \"Error buffering file\", ex); //NON-NLS\n        }\n        progress.finish();\n    }","commit_id":"faa0c886cf662278c1ea463f75e4eaf5ba35301c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public Image getIcon(int type) {\n        Image icon = null;\n                  \n        if (iconCache != null) {\n            icon = iconCache.get();\n        }\n\n        if (icon == null) {\n            Content content = this.getLookup().lookup(Content.class);\n\n            if (content != null) {\n                icon = ImageUtils.getIcon(content, iconSize);\n            } else {\n                icon = ImageUtils.getDefaultIcon();\n            }\n\n            iconCache = new SoftReference<>(icon);\n        }\n        \n        return icon;\n    }","id":93044,"modified_method":"@Override\n     public Image getIcon(int type) {\n        Image icon = null;\n\n        if (iconCache != null) {\n            icon = iconCache.get();\n        }\n\n        if (icon != null) {\n            return icon;\n        } else {\n            final Content content = this.getLookup().lookup(Content.class);\n            if (content == null) {\n                return ImageUtils.getDefaultIcon();\n            }\n            if (swingWorker == null || swingWorker.isDone()) {\n                swingWorker = new SwingWorker<Image, Object>() {\n                    final private ProgressHandle progressHandle = ProgressHandleFactory.createHandle(\"generating thumbnail for video file \" + content.getName());\n\n                    @Override\n                    protected Image doInBackground() throws Exception {\n                        progressHandle.start();\n                        return ImageUtils.getIcon(content, iconSize);\n                    }\n\n                    @Override\n                    protected void done() {\n                        super.done();\n                        try {\n                            iconCache = new SoftReference<>(super.get());\n                            progressHandle.finish();\n                            fireIconChange();\n                        } catch (InterruptedException | ExecutionException ex) {\n                            Exceptions.printStackTrace(ex);\n                        }\n                        swingWorker = null;\n                    }\n                };\n                swingWorker.execute();\n            }\n\n            return waitingIcon;\n        }\n    }","commit_id":"faa0c886cf662278c1ea463f75e4eaf5ba35301c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public Image getThumbnail() {\n        //TODO: implement video thumbnailing here?\n        return getGenericVideoThumbnail();\n    }","id":93045,"modified_method":"@Override\n    public Image getThumbnail() {\n        return ThumbnailCache.getDefault().get(this);\n    }","commit_id":"faa0c886cf662278c1ea463f75e4eaf5ba35301c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@NotNull\n  public static Icon getIcon(@NotNull final Notification notification) {\n    Icon icon = notification.getIcon();\n    return icon != null ? icon : getMessageType(notification).getDefaultIcon();\n  }","id":93046,"modified_method":"@NotNull\n  public static Icon getIcon(@NotNull final Notification notification) {\n    Icon icon = notification.getIcon();\n    if (icon != null) {\n      return icon;\n    }\n\n    if (!NotificationsManagerImpl.newEnabled()) {\n      return getMessageType(notification).getDefaultIcon();\n    }\n\n    switch (notification.getType()) {\n      case WARNING:\n        return AllIcons.General.BalloonWarning;\n      case ERROR:\n        return AllIcons.Ide.FatalError;\n      case INFORMATION:\n      default:\n        return AllIcons.General.BalloonInformation;\n    }\n  }","commit_id":"a34fa435dc1e90f51039fa0089d9f0b7a49b10f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void retryFileTransfers(long syncAccountId)\n\t\tthrows IOException {\n\n\t\tList<SyncFile> deletingSyncFiles = SyncFileService.findSyncFiles(\n\t\t\tsyncAccountId, SyncFile.UI_EVENT_DELETED_LOCAL, \"syncFileId\", true);\n\n\t\tfor (SyncFile deletingSyncFile : deletingSyncFiles) {\n\t\t\tif (!Files.notExists(\n\t\t\t\t\tPaths.get(deletingSyncFile.getFilePathName()))) {\n\n\t\t\t\tdeletingSyncFile.setState(SyncFile.STATE_SYNCED);\n\t\t\t\tdeletingSyncFile.setUiEvent(SyncFile.UI_EVENT_NONE);\n\n\t\t\t\tSyncFileService.update(deletingSyncFile);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (deletingSyncFile.isFolder()) {\n\t\t\t\tdeleteFolder(syncAccountId, deletingSyncFile);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeleteFile(syncAccountId, deletingSyncFile);\n\t\t\t}\n\t\t}\n\n\t\tList<SyncFile> downloadingSyncFiles = SyncFileService.findSyncFiles(\n\t\t\tsyncAccountId, SyncFile.UI_EVENT_DOWNLOADING, \"size\", true);\n\n\t\tfor (SyncFile downloadingSyncFile : downloadingSyncFiles) {\n\t\t\tdownloadFile(syncAccountId, downloadingSyncFile);\n\t\t}\n\n\t\tBatchDownloadEvent batchDownloadEvent =\n\t\t\tBatchEventManager.getBatchDownloadEvent(syncAccountId);\n\n\t\tbatchDownloadEvent.fireBatchEvent();\n\n\t\tList<SyncFile> uploadingSyncFiles = SyncFileService.findSyncFiles(\n\t\t\tsyncAccountId, SyncFile.UI_EVENT_UPLOADING, \"size\", true);\n\n\t\tfor (SyncFile uploadingSyncFile : uploadingSyncFiles) {\n\t\t\tPath filePath = Paths.get(uploadingSyncFile.getFilePathName());\n\n\t\t\tif (Files.notExists(filePath)) {\n\t\t\t\tif (uploadingSyncFile.getTypePK() == 0) {\n\t\t\t\t\tSyncFileService.deleteSyncFile(uploadingSyncFile, false);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (uploadingSyncFile.isFolder()) {\n\t\t\t\tif (uploadingSyncFile.getTypePK() > 0) {\n\t\t\t\t\tupdateFolder(\n\t\t\t\t\t\tfilePath, uploadingSyncFile.getSyncAccountId(),\n\t\t\t\t\t\tuploadingSyncFile);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddFolder(\n\t\t\t\t\t\tuploadingSyncFile.getParentFolderId(),\n\t\t\t\t\t\tuploadingSyncFile.getRepositoryId(), syncAccountId,\n\t\t\t\t\t\tuploadingSyncFile.getName(), uploadingSyncFile);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString checksum = FileUtil.getChecksum(filePath);\n\n\t\t\tuploadingSyncFile.setChecksum(checksum);\n\n\t\t\tuploadingSyncFile.setSize(Files.size(filePath));\n\n\t\t\tSyncFileService.update(uploadingSyncFile);\n\n\t\t\tif (uploadingSyncFile.getTypePK() > 0) {\n\t\t\t\tupdateFile(\n\t\t\t\t\tfilePath, syncAccountId, uploadingSyncFile, null,\n\t\t\t\t\tuploadingSyncFile.getName(), \"\", null, 0, checksum);\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddFile(\n\t\t\t\t\tfilePath, uploadingSyncFile.getParentFolderId(),\n\t\t\t\t\tuploadingSyncFile.getRepositoryId(), syncAccountId,\n\t\t\t\t\tchecksum, uploadingSyncFile.getName(),\n\t\t\t\t\tuploadingSyncFile.getMimeType(), uploadingSyncFile);\n\t\t\t}\n\t\t}\n\n\t\tList<SyncFile> movingSyncFiles = SyncFileService.findSyncFiles(\n\t\t\tsyncAccountId, SyncFile.UI_EVENT_MOVED_LOCAL, \"syncFileId\", true);\n\n\t\tfor (SyncFile movingSyncFile : movingSyncFiles) {\n\t\t\tif (movingSyncFile.isFolder()) {\n\t\t\t\tmoveFolder(\n\t\t\t\t\tmovingSyncFile.getParentFolderId(), syncAccountId,\n\t\t\t\t\tmovingSyncFile);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmoveFile(\n\t\t\t\t\tmovingSyncFile.getParentFolderId(), syncAccountId,\n\t\t\t\t\tmovingSyncFile);\n\t\t\t}\n\t\t}\n\n\t\tBatchEvent batchEvent = BatchEventManager.getBatchEvent(syncAccountId);\n\n\t\tbatchEvent.fireBatchEvent();\n\t}","id":93047,"modified_method":"public static void retryFileTransfers(long syncAccountId)\n\t\tthrows IOException {\n\n\t\tList<SyncFile> deletingSyncFiles = SyncFileService.findSyncFiles(\n\t\t\tsyncAccountId, SyncFile.UI_EVENT_DELETED_LOCAL, \"syncFileId\", true);\n\n\t\tfor (SyncFile deletingSyncFile : deletingSyncFiles) {\n\t\t\tif (!Files.notExists(\n\t\t\t\t\tPaths.get(deletingSyncFile.getFilePathName()))) {\n\n\t\t\t\tdeletingSyncFile.setState(SyncFile.STATE_SYNCED);\n\t\t\t\tdeletingSyncFile.setUiEvent(SyncFile.UI_EVENT_NONE);\n\n\t\t\t\tSyncFileService.update(deletingSyncFile);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (deletingSyncFile.isFolder()) {\n\t\t\t\tdeleteFolder(syncAccountId, deletingSyncFile);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeleteFile(syncAccountId, deletingSyncFile);\n\t\t\t}\n\t\t}\n\n\t\tList<SyncFile> downloadingSyncFiles = SyncFileService.findSyncFiles(\n\t\t\tsyncAccountId, SyncFile.UI_EVENT_DOWNLOADING, \"size\", true);\n\n\t\tfor (SyncFile downloadingSyncFile : downloadingSyncFiles) {\n\t\t\tdownloadFile(syncAccountId, downloadingSyncFile);\n\t\t}\n\n\t\tBatchDownloadEvent batchDownloadEvent =\n\t\t\tBatchEventManager.getBatchDownloadEvent(syncAccountId);\n\n\t\tbatchDownloadEvent.fireBatchEvent();\n\n\t\tList<SyncFile> uploadingSyncFiles = SyncFileService.findSyncFiles(\n\t\t\tsyncAccountId, SyncFile.UI_EVENT_UPLOADING, \"size\", true);\n\n\t\tfor (SyncFile uploadingSyncFile : uploadingSyncFiles) {\n\t\t\tPath filePath = Paths.get(uploadingSyncFile.getFilePathName());\n\n\t\t\tif (Files.notExists(filePath)) {\n\t\t\t\tif (uploadingSyncFile.getTypePK() == 0) {\n\t\t\t\t\tSyncFileService.deleteSyncFile(uploadingSyncFile, false);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (uploadingSyncFile.isFolder()) {\n\t\t\t\tif (uploadingSyncFile.getTypePK() > 0) {\n\t\t\t\t\tupdateFolder(\n\t\t\t\t\t\tfilePath, uploadingSyncFile.getSyncAccountId(),\n\t\t\t\t\t\tuploadingSyncFile);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddFolder(\n\t\t\t\t\t\tuploadingSyncFile.getParentFolderId(),\n\t\t\t\t\t\tuploadingSyncFile.getRepositoryId(), syncAccountId,\n\t\t\t\t\t\tuploadingSyncFile.getName(), uploadingSyncFile);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString checksum = FileUtil.getChecksum(filePath);\n\n\t\t\tuploadingSyncFile.setChecksum(checksum);\n\n\t\t\tuploadingSyncFile.setSize(Files.size(filePath));\n\n\t\t\tSyncFileService.update(uploadingSyncFile);\n\n\t\t\tIODeltaUtil.checksums(uploadingSyncFile);\n\n\t\t\tif (uploadingSyncFile.getTypePK() > 0) {\n\t\t\t\tupdateFile(\n\t\t\t\t\tfilePath, syncAccountId, uploadingSyncFile, null,\n\t\t\t\t\tuploadingSyncFile.getName(), \"\", null, 0, checksum);\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddFile(\n\t\t\t\t\tfilePath, uploadingSyncFile.getParentFolderId(),\n\t\t\t\t\tuploadingSyncFile.getRepositoryId(), syncAccountId,\n\t\t\t\t\tchecksum, uploadingSyncFile.getName(),\n\t\t\t\t\tuploadingSyncFile.getMimeType(), uploadingSyncFile);\n\t\t\t}\n\t\t}\n\n\t\tList<SyncFile> movingSyncFiles = SyncFileService.findSyncFiles(\n\t\t\tsyncAccountId, SyncFile.UI_EVENT_MOVED_LOCAL, \"syncFileId\", true);\n\n\t\tfor (SyncFile movingSyncFile : movingSyncFiles) {\n\t\t\tif (movingSyncFile.isFolder()) {\n\t\t\t\tmoveFolder(\n\t\t\t\t\tmovingSyncFile.getParentFolderId(), syncAccountId,\n\t\t\t\t\tmovingSyncFile);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmoveFile(\n\t\t\t\t\tmovingSyncFile.getParentFolderId(), syncAccountId,\n\t\t\t\t\tmovingSyncFile);\n\t\t\t}\n\t\t}\n\n\t\tBatchEvent batchEvent = BatchEventManager.getBatchEvent(syncAccountId);\n\n\t\tbatchEvent.fireBatchEvent();\n\t}","commit_id":"391b223a959084963ddcffc7faced8bd99abd134","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static SyncFile updateFileSyncFile(\n\t\t\tPath filePath, long syncAccountId, SyncFile syncFile)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tFileKeyUtil.writeFileKey(\n\t\t\tfilePath, String.valueOf(syncFile.getSyncFileId()), true);\n\n\t\tPath deltaFilePath = null;\n\n\t\tif (MSOfficeFileUtil.isLegacyExcelFile(filePath)) {\n\t\t\tsyncFile.setLocalExtraSetting(\n\t\t\t\t\"lastSavedDate\", MSOfficeFileUtil.getLastSavedDate(filePath));\n\t\t}\n\n\t\tString name = _getName(filePath, syncFile);\n\t\tString sourceChecksum = syncFile.getChecksum();\n\t\tString sourceFileName = syncFile.getName();\n\t\tlong sourceVersionId = syncFile.getVersionId();\n\t\tString targetChecksum = FileUtil.getChecksum(filePath);\n\n\t\tif (!FileUtil.checksumsEqual(sourceChecksum, targetChecksum) &&\n\t\t\t!IODeltaUtil.isIgnoredFilePatchingExtension(syncFile)) {\n\n\t\t\tdeltaFilePath = Files.createTempFile(\n\t\t\t\tString.valueOf(filePath.getFileName()), \".tmp\");\n\n\t\t\tdeltaFilePath = IODeltaUtil.delta(\n\t\t\t\tfilePath, IODeltaUtil.getChecksumsFilePath(syncFile),\n\t\t\t\tdeltaFilePath);\n\n\t\t\tIODeltaUtil.checksums(syncFile);\n\t\t}\n\n\t\tsyncFile.setChecksum(targetChecksum);\n\t\tsyncFile.setFilePathName(filePath.toString());\n\t\tsyncFile.setName(name);\n\t\tsyncFile.setSize(Files.size(filePath));\n\n\t\tupdate(syncFile);\n\n\t\t// Remote sync file\n\n\t\tif ((syncFile.getState() != SyncFile.STATE_ERROR) &&\n\t\t\t(syncFile.getState() != SyncFile.STATE_UNSYNCED)) {\n\n\t\t\tFileEventUtil.updateFile(\n\t\t\t\tfilePath, syncAccountId, syncFile, deltaFilePath, name,\n\t\t\t\tsourceChecksum, sourceFileName, sourceVersionId,\n\t\t\t\ttargetChecksum);\n\t\t}\n\n\t\treturn syncFile;\n\t}","id":93048,"modified_method":"public static SyncFile updateFileSyncFile(\n\t\t\tPath filePath, long syncAccountId, SyncFile syncFile)\n\t\tthrows Exception {\n\n\t\tif (Files.notExists(filePath)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Local sync file\n\n\t\tFileKeyUtil.writeFileKey(\n\t\t\tfilePath, String.valueOf(syncFile.getSyncFileId()), true);\n\n\t\tPath deltaFilePath = null;\n\n\t\tif (MSOfficeFileUtil.isLegacyExcelFile(filePath)) {\n\t\t\tsyncFile.setLocalExtraSetting(\n\t\t\t\t\"lastSavedDate\", MSOfficeFileUtil.getLastSavedDate(filePath));\n\t\t}\n\n\t\tString name = _getName(filePath, syncFile);\n\t\tString sourceChecksum = syncFile.getChecksum();\n\t\tString sourceFileName = syncFile.getName();\n\t\tlong sourceVersionId = syncFile.getVersionId();\n\t\tString targetChecksum = FileUtil.getChecksum(filePath);\n\n\t\tif (!FileUtil.checksumsEqual(sourceChecksum, targetChecksum) &&\n\t\t\t!IODeltaUtil.isIgnoredFilePatchingExtension(syncFile)) {\n\n\t\t\tdeltaFilePath = Files.createTempFile(\n\t\t\t\tString.valueOf(filePath.getFileName()), \".tmp\");\n\n\t\t\tdeltaFilePath = IODeltaUtil.delta(\n\t\t\t\tfilePath, IODeltaUtil.getChecksumsFilePath(syncFile),\n\t\t\t\tdeltaFilePath);\n\n\t\t\tIODeltaUtil.checksums(syncFile);\n\t\t}\n\n\t\tsyncFile.setChecksum(targetChecksum);\n\t\tsyncFile.setFilePathName(filePath.toString());\n\t\tsyncFile.setName(name);\n\t\tsyncFile.setSize(Files.size(filePath));\n\n\t\tupdate(syncFile);\n\n\t\t// Remote sync file\n\n\t\tif ((syncFile.getState() != SyncFile.STATE_ERROR) &&\n\t\t\t(syncFile.getState() != SyncFile.STATE_UNSYNCED)) {\n\n\t\t\tFileEventUtil.updateFile(\n\t\t\t\tfilePath, syncAccountId, syncFile, deltaFilePath, name,\n\t\t\t\tsourceChecksum, sourceFileName, sourceVersionId,\n\t\t\t\ttargetChecksum);\n\t\t}\n\n\t\treturn syncFile;\n\t}","commit_id":"391b223a959084963ddcffc7faced8bd99abd134","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SyncWatchEvent fetchByE_F_T(\n\t\t\tString eventType, String filePathName, long timestamp)\n\t\tthrows SQLException {\n\n\t\tQueryBuilder<SyncWatchEvent, Long> queryBuilder = queryBuilder();\n\n\t\tqueryBuilder.limit(1L);\n\n\t\tWhere<SyncWatchEvent, Long> where = queryBuilder.where();\n\n\t\twhere.eq(\"eventType\", eventType);\n\t\twhere.eq(\"filePathName\", new SelectArg(filePathName));\n\t\twhere.between(\"timestamp\", timestamp - 1000, timestamp + 1000);\n\n\t\twhere.and(3);\n\n\t\treturn where.queryForFirst();\n\t}","id":93049,"modified_method":"public SyncWatchEvent fetchByE_F_T_First(\n\t\t\tString eventType, String filePathName, long timestamp)\n\t\tthrows SQLException {\n\n\t\tQueryBuilder<SyncWatchEvent, Long> queryBuilder = queryBuilder();\n\n\t\tqueryBuilder.limit(1L);\n\n\t\tWhere<SyncWatchEvent, Long> where = queryBuilder.where();\n\n\t\twhere.eq(\"eventType\", eventType);\n\t\twhere.eq(\"filePathName\", new SelectArg(filePathName));\n\t\twhere.between(\"timestamp\", timestamp - 1000, timestamp + 1000);\n\n\t\twhere.and(3);\n\n\t\treturn where.queryForFirst();\n\t}","commit_id":"391b223a959084963ddcffc7faced8bd99abd134","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected synchronized void processSyncWatchEvent(\n\t\t\tSyncWatchEvent syncWatchEvent)\n\t\tthrows Exception {\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t_syncAccountId);\n\n\t\tif (syncAccount.getState() != SyncAccount.STATE_CONNECTED) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_processedSyncWatchEventIds.contains(\n\t\t\t\tsyncWatchEvent.getSyncWatchEventId())) {\n\n\t\t\tSyncWatchEventService.deleteSyncWatchEvent(\n\t\t\t\tsyncWatchEvent.getSyncWatchEventId());\n\n\t\t\treturn;\n\t\t}\n\n\t\tString eventType = syncWatchEvent.getEventType();\n\n\t\tif (eventType.equals(SyncWatchEvent.EVENT_TYPE_RENAME_FROM)) {\n\t\t\teventType = SyncWatchEvent.EVENT_TYPE_DELETE;\n\n\t\t\tsyncWatchEvent.setEventType(eventType);\n\n\t\t\tSyncWatchEventService.update(syncWatchEvent);\n\t\t}\n\n\t\tif (_logger.isDebugEnabled()) {\n\t\t\t_logger.debug(\n\t\t\t\t\"Processing sync watch event {}\", syncWatchEvent.toString());\n\t\t}\n\n\t\tString fileType = syncWatchEvent.getFileType();\n\n\t\tif (eventType.equals(SyncWatchEvent.EVENT_TYPE_CREATE)) {\n\t\t\tif (fileType.equals(SyncFile.TYPE_FILE)) {\n\t\t\t\taddFile(syncWatchEvent);\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddFolder(syncWatchEvent);\n\t\t\t}\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_DELETE)) {\n\t\t\tdeleteFile(syncWatchEvent);\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_MODIFY)) {\n\t\t\tmodifyFile(syncWatchEvent);\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_MOVE)) {\n\t\t\tmoveFile(syncWatchEvent);\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_RENAME)) {\n\t\t\trenameFile(syncWatchEvent);\n\t\t}\n\n\t\tsyncAccount = SyncAccountService.fetchSyncAccount(_syncAccountId);\n\n\t\tif (syncAccount.getState() == SyncAccount.STATE_CONNECTED) {\n\t\t\tSyncWatchEventService.deleteSyncWatchEvent(\n\t\t\t\tsyncWatchEvent.getSyncWatchEventId());\n\t\t}\n\t}","id":93050,"modified_method":"protected synchronized void processSyncWatchEvent(\n\t\t\tSyncWatchEvent syncWatchEvent)\n\t\tthrows Exception {\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t_syncAccountId);\n\n\t\tif (syncAccount.getState() != SyncAccount.STATE_CONNECTED) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_processedSyncWatchEventIds.contains(\n\t\t\t\tsyncWatchEvent.getSyncWatchEventId())) {\n\n\t\t\tSyncWatchEventService.deleteSyncWatchEvent(\n\t\t\t\tsyncWatchEvent.getSyncWatchEventId());\n\n\t\t\treturn;\n\t\t}\n\n\t\tString eventType = syncWatchEvent.getEventType();\n\n\t\tif (eventType.equals(SyncWatchEvent.EVENT_TYPE_RENAME_FROM)) {\n\t\t\teventType = SyncWatchEvent.EVENT_TYPE_DELETE;\n\n\t\t\tsyncWatchEvent.setEventType(eventType);\n\n\t\t\tSyncWatchEventService.update(syncWatchEvent);\n\t\t}\n\n\t\tif (_logger.isDebugEnabled()) {\n\t\t\t_logger.debug(\n\t\t\t\t\"Processing sync watch event {}\", syncWatchEvent.toString());\n\t\t}\n\n\t\tString fileType = syncWatchEvent.getFileType();\n\n\t\tif (eventType.equals(SyncWatchEvent.EVENT_TYPE_CREATE)) {\n\t\t\tif (fileType.equals(SyncFile.TYPE_FILE)) {\n\t\t\t\tSyncWatchEvent duplicateSyncWatchEvent = null;\n\n\t\t\t\tif (OSDetector.isApple()) {\n\t\t\t\t\tduplicateSyncWatchEvent =\n\t\t\t\t\t\tSyncWatchEventService.fetchDuplicateSyncWatchEvent(\n\t\t\t\t\t\t\tsyncWatchEvent);\n\t\t\t\t}\n\n\t\t\t\tif (duplicateSyncWatchEvent != null) {\n\t\t\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t\t\t_logger.debug(\"Skipping outdated sync watch event\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddFile(syncWatchEvent);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddFolder(syncWatchEvent);\n\t\t\t}\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_DELETE)) {\n\t\t\tdeleteFile(syncWatchEvent);\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_MODIFY)) {\n\t\t\tSyncWatchEvent duplicateSyncWatchEvent =\n\t\t\t\tSyncWatchEventService.fetchDuplicateSyncWatchEvent(\n\t\t\t\t\tsyncWatchEvent);\n\n\t\t\tif (duplicateSyncWatchEvent != null) {\n\t\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t\t_logger.debug(\"Skipping outdated sync watch event\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmodifyFile(syncWatchEvent);\n\t\t\t}\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_MOVE)) {\n\t\t\tmoveFile(syncWatchEvent);\n\t\t}\n\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_RENAME)) {\n\t\t\trenameFile(syncWatchEvent);\n\t\t}\n\n\t\tsyncAccount = SyncAccountService.fetchSyncAccount(_syncAccountId);\n\n\t\tif (syncAccount.getState() == SyncAccount.STATE_CONNECTED) {\n\t\t\tSyncWatchEventService.deleteSyncWatchEvent(\n\t\t\t\tsyncWatchEvent.getSyncWatchEventId());\n\t\t}\n\t}","commit_id":"391b223a959084963ddcffc7faced8bd99abd134","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SyncWatchEventProcessor(long syncAccountId) {\n\t\t_syncAccountId = syncAccountId;\n\n\t\tSyncFileModelListener syncFileModelListener =\n\t\t\tnew SyncFileModelListener() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onUpdate(\n\t\t\t\t\tSyncFile syncFile, Map<String, Object> originalValues) {\n\n\t\t\t\t\tif ((syncFile.getSyncAccountId() != _syncAccountId) ||\n\t\t\t\t\t\t(syncFile.getTypePK() == 0) ||\n\t\t\t\t\t\t!originalValues.containsKey(\"typePK\")) {\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tList<SyncWatchEvent> syncWatchEvents =\n\t\t\t\t\t\t_dependentSyncWatchEventsMaps.remove(\n\t\t\t\t\t\t\tsyncFile.getFilePathName());\n\n\t\t\t\t\tif (syncWatchEvents == null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t_pendingTypePKSyncFileIds.remove(syncFile.getSyncFileId());\n\n\t\t\t\t\tfor (SyncWatchEvent syncWatchEvent : syncWatchEvents) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t_logger.debug(\n\t\t\t\t\t\t\t\t\t\"Processing queued event {} {}\",\n\t\t\t\t\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\t\t\t\t\tsyncWatchEvent.getEventType());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tprocessSyncWatchEvent(syncWatchEvent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t\t_logger.error(e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\n\t\tSyncFileService.registerModelListener(syncFileModelListener);\n\t}","id":93051,"modified_method":"public SyncWatchEventProcessor(long syncAccountId) {\n\t\t_syncAccountId = syncAccountId;\n\n\t\tSyncFileModelListener syncFileModelListener =\n\t\t\tnew SyncFileModelListener() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onUpdate(\n\t\t\t\t\tSyncFile syncFile, Map<String, Object> originalValues) {\n\n\t\t\t\t\tif ((syncFile.getSyncAccountId() != _syncAccountId) ||\n\t\t\t\t\t\t(syncFile.getTypePK() == 0) ||\n\t\t\t\t\t\t(!originalValues.containsKey(\"state\") &&\n\t\t\t\t\t\t !originalValues.containsKey(\"typePK\"))) {\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tList<SyncWatchEvent> syncWatchEvents =\n\t\t\t\t\t\t_dependentSyncWatchEventsMaps.remove(\n\t\t\t\t\t\t\tsyncFile.getFilePathName());\n\n\t\t\t\t\tif (syncWatchEvents == null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (syncFile.getTypePK() > 0) {\n\t\t\t\t\t\t_pendingTypePKSyncFileIds.remove(\n\t\t\t\t\t\t\tsyncFile.getSyncFileId());\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (SyncWatchEvent syncWatchEvent : syncWatchEvents) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t_logger.debug(\n\t\t\t\t\t\t\t\t\t\"Processing queued event {} {}\",\n\t\t\t\t\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\t\t\t\t\tsyncWatchEvent.getEventType());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tprocessSyncWatchEvent(syncWatchEvent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t\t_logger.error(e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\n\t\tSyncFileService.registerModelListener(syncFileModelListener);\n\t}","commit_id":"391b223a959084963ddcffc7faced8bd99abd134","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void modifyFile(SyncWatchEvent syncWatchEvent) throws Exception {\n\t\tPath filePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(filePath.toString());\n\n\t\tif (syncFile == null) {\n\t\t\treturn;\n\t\t}\n\t\telse if (isPendingTypePK(syncFile)) {\n\t\t\tqueueSyncWatchEvent(syncFile.getFilePathName(), syncWatchEvent);\n\n\t\t\treturn;\n\t\t}\n\t\telse if (!FileUtil.isModified(syncFile)) {\n\t\t\treturn;\n\t\t}\n\n\t\tSyncFileService.updateFileSyncFile(filePath, _syncAccountId, syncFile);\n\t}","id":93052,"modified_method":"protected void modifyFile(SyncWatchEvent syncWatchEvent) throws Exception {\n\t\tPath filePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(filePath.toString());\n\n\t\tif (syncFile == null) {\n\t\t\treturn;\n\t\t}\n\t\telse if (isPendingTypePK(syncFile) ||\n\t\t\t\t (syncFile.getState() == SyncFile.STATE_IN_PROGRESS)) {\n\n\t\t\tqueueSyncWatchEvent(syncFile.getFilePathName(), syncWatchEvent);\n\n\t\t\treturn;\n\t\t}\n\t\telse if (!FileUtil.isModified(syncFile)) {\n\t\t\treturn;\n\t\t}\n\n\t\tSyncFileService.updateFileSyncFile(filePath, _syncAccountId, syncFile);\n\t}","commit_id":"391b223a959084963ddcffc7faced8bd99abd134","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addFile(SyncWatchEvent syncWatchEvent) throws Exception {\n\t\tfinal Path targetFilePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tif (Files.notExists(targetFilePath) ||\n\t\t\tsanitizeFileName(targetFilePath) ||\n\t\t\tisInErrorState(targetFilePath)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tPath parentTargetFilePath = targetFilePath.getParent();\n\n\t\tfinal SyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\tparentTargetFilePath.toString());\n\n\t\tif ((parentSyncFile == null) ||\n\t\t\t(!parentSyncFile.isSystem() && (parentSyncFile.getTypePK() == 0))) {\n\n\t\t\tqueueSyncWatchEvent(\n\t\t\t\tparentTargetFilePath.toString(), syncWatchEvent);\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetFilePath.toString());\n\n\t\tif (syncFile == null) {\n\t\t\tsyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\tFileKeyUtil.getFileKey(targetFilePath));\n\n\t\t\tif (!verifySite(syncFile, parentSyncFile)) {\n\t\t\t\tsyncFile = null;\n\t\t\t}\n\t\t}\n\n\t\tif (syncFile == null) {\n\t\t\tRunnable runnable = new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!FileUtil.checkFilePath(targetFilePath)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tThrowable throwable = e.getCause();\n\n\t\t\t\t\t\tString message = throwable.getMessage();\n\n\t\t\t\t\t\tif (!message.contains(\n\t\t\t\t\t\t\t\t\"Unique index or primary key violation\") &&\n\t\t\t\t\t\t\t_logger.isTraceEnabled()) {\n\n\t\t\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t_executorService.execute(runnable);\n\n\t\t\treturn;\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(syncFile.getFilePathName());\n\n\t\tif (targetFilePath.equals(sourceFilePath)) {\n\t\t\tif (isPendingTypePK(syncFile)) {\n\t\t\t\tqueueSyncWatchEvent(syncFile.getFilePathName(), syncWatchEvent);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (FileUtil.isModified(syncFile)) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\t\telse if (Files.exists(sourceFilePath)) {\n\t\t\ttry {\n\t\t\t\tif ((Files.size(targetFilePath) == 0) ||\n\t\t\t\t\tFileUtil.isModified(syncFile, targetFilePath) ||\n\t\t\t\t\tisInErrorState(sourceFilePath)) {\n\n\t\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSyncFileService.copySyncFile(\n\t\t\t\t\t\tsyncFile, targetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\tThrowable throwable = e.getCause();\n\n\t\t\t\t\tString message = throwable.getMessage();\n\n\t\t\t\t\tif (!message.contains(\n\t\t\t\t\t\t\t\"Unique index or primary key violation\")) {\n\n\t\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\telse if (parentTargetFilePath.equals(sourceFilePath.getParent())) {\n\t\t\tif (isPendingTypePK(syncFile)) {\n\t\t\t\tqueueSyncWatchEvent(syncFile.getFilePathName(), syncWatchEvent);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t}\n\t\telse {\n\t\t\tif (isPendingTypePK(syncFile)) {\n\t\t\t\tqueueSyncWatchEvent(syncFile.getFilePathName(), syncWatchEvent);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSyncFileService.moveFileSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(), _syncAccountId,\n\t\t\t\tsyncFile);\n\n\t\t\tPath sourceFileNameFilePath = sourceFilePath.getFileName();\n\n\t\t\tif (!sourceFileNameFilePath.equals(targetFilePath.getFileName())) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t_syncAccountId);\n\n\t\tif (syncAccount.getState() == SyncAccount.STATE_CONNECTED) {\n\t\t\tSyncWatchEvent relatedSyncWatchEvent =\n\t\t\t\tSyncWatchEventService.fetchSyncWatchEvent(\n\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_DELETE,\n\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\tsyncWatchEvent.getTimestamp());\n\n\t\t\tif (relatedSyncWatchEvent != null) {\n\t\t\t\t_processedSyncWatchEventIds.add(\n\t\t\t\t\trelatedSyncWatchEvent.getSyncWatchEventId());\n\t\t\t}\n\t\t}\n\t}","id":93053,"modified_method":"protected void addFile(SyncWatchEvent syncWatchEvent) throws Exception {\n\t\tfinal Path targetFilePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tif (Files.notExists(targetFilePath) ||\n\t\t\tsanitizeFileName(targetFilePath) ||\n\t\t\tisInErrorState(targetFilePath)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tPath parentTargetFilePath = targetFilePath.getParent();\n\n\t\tfinal SyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\tparentTargetFilePath.toString());\n\n\t\tif ((parentSyncFile == null) ||\n\t\t\t(!parentSyncFile.isSystem() && (parentSyncFile.getTypePK() == 0))) {\n\n\t\t\tqueueSyncWatchEvent(\n\t\t\t\tparentTargetFilePath.toString(), syncWatchEvent);\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetFilePath.toString());\n\n\t\tif (syncFile == null) {\n\t\t\tsyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\tFileKeyUtil.getFileKey(targetFilePath));\n\n\t\t\tif (!verifySite(syncFile, parentSyncFile)) {\n\t\t\t\tsyncFile = null;\n\t\t\t}\n\t\t}\n\n\t\tif (syncFile == null) {\n\t\t\tRunnable runnable = new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!FileUtil.checkFilePath(targetFilePath)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tThrowable throwable = e.getCause();\n\n\t\t\t\t\t\tString message = throwable.getMessage();\n\n\t\t\t\t\t\tif (!message.contains(\n\t\t\t\t\t\t\t\t\"Unique index or primary key violation\") &&\n\t\t\t\t\t\t\t_logger.isTraceEnabled()) {\n\n\t\t\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t_executorService.execute(runnable);\n\n\t\t\treturn;\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(syncFile.getFilePathName());\n\n\t\tif (targetFilePath.equals(sourceFilePath)) {\n\t\t\tif (isPendingTypePK(syncFile) ||\n\t\t\t\t(syncFile.getState() == SyncFile.STATE_IN_PROGRESS)) {\n\n\t\t\t\tqueueSyncWatchEvent(syncFile.getFilePathName(), syncWatchEvent);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (FileUtil.isModified(syncFile)) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\t\telse if (Files.exists(sourceFilePath)) {\n\t\t\ttry {\n\t\t\t\tif ((Files.size(targetFilePath) == 0) ||\n\t\t\t\t\tFileUtil.isModified(syncFile, targetFilePath) ||\n\t\t\t\t\tisInErrorState(sourceFilePath)) {\n\n\t\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSyncFileService.copySyncFile(\n\t\t\t\t\t\tsyncFile, targetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\tThrowable throwable = e.getCause();\n\n\t\t\t\t\tString message = throwable.getMessage();\n\n\t\t\t\t\tif (!message.contains(\n\t\t\t\t\t\t\t\"Unique index or primary key violation\")) {\n\n\t\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\telse if (parentTargetFilePath.equals(sourceFilePath.getParent())) {\n\t\t\tif (isPendingTypePK(syncFile) ||\n\t\t\t\t(syncFile.getState() == SyncFile.STATE_IN_PROGRESS)) {\n\n\t\t\t\tqueueSyncWatchEvent(syncFile.getFilePathName(), syncWatchEvent);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t}\n\t\telse {\n\t\t\tif (isPendingTypePK(syncFile) ||\n\t\t\t\t(syncFile.getState() == SyncFile.STATE_IN_PROGRESS)) {\n\n\t\t\t\tqueueSyncWatchEvent(syncFile.getFilePathName(), syncWatchEvent);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSyncFileService.moveFileSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(), _syncAccountId,\n\t\t\t\tsyncFile);\n\n\t\t\tPath sourceFileNameFilePath = sourceFilePath.getFileName();\n\n\t\t\tif (!sourceFileNameFilePath.equals(targetFilePath.getFileName())) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t_syncAccountId);\n\n\t\tif (syncAccount.getState() == SyncAccount.STATE_CONNECTED) {\n\t\t\tSyncWatchEvent relatedSyncWatchEvent =\n\t\t\t\tSyncWatchEventService.fetchSyncWatchEvent(\n\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_DELETE,\n\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\tsyncWatchEvent.getTimestamp());\n\n\t\t\tif (relatedSyncWatchEvent != null) {\n\t\t\t\t_processedSyncWatchEventIds.add(\n\t\t\t\t\trelatedSyncWatchEvent.getSyncWatchEventId());\n\t\t\t}\n\t\t}\n\t}","commit_id":"391b223a959084963ddcffc7faced8bd99abd134","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static SyncWatchEvent fetchSyncWatchEvent(\n\t\tString eventType, String filePathName, long timestamp) {\n\n\t\ttry {\n\t\t\treturn _syncWatchEventPersistence.fetchByE_F_T(\n\t\t\t\teventType, filePathName, timestamp);\n\t\t}\n\t\tcatch (SQLException sqle) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(sqle.getMessage(), sqle);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}","id":93054,"modified_method":"public static SyncWatchEvent fetchSyncWatchEvent(\n\t\tString eventType, String filePathName, long timestamp) {\n\n\t\ttry {\n\t\t\treturn _syncWatchEventPersistence.fetchByE_F_T_First(\n\t\t\t\teventType, filePathName, timestamp);\n\t\t}\n\t\tcatch (SQLException sqle) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(sqle.getMessage(), sqle);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"391b223a959084963ddcffc7faced8bd99abd134","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void checkResourceActions(\n\t\t\tString name, List<String> actionIds,\n\t\t\tList<ResourceAction> resourceActions, boolean addDefaultActions)\n\t\tthrows SystemException {\n\n\t\tlong lastBitwiseValue = 1;\n\n\t\tif (!resourceActions.isEmpty()) {\n\t\t\tResourceAction resourceAction = resourceActions.get(\n\t\t\t\tresourceActions.size() - 1);\n\n\t\t\tlastBitwiseValue = resourceAction.getBitwiseValue();\n\t\t}\n\n\t\tList<ResourceAction> newResourceActions =\n\t\t\tnew ArrayList<ResourceAction>();\n\n\t\tint lastBitwiseLogValue = MathUtil.base2Log(lastBitwiseValue);\n\n\t\tfor (String actionId : actionIds) {\n\t\t\tString key = encodeKey(name, actionId);\n\n\t\t\tResourceAction resourceAction = _resourceActions.get(key);\n\n\t\t\tif (resourceAction != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresourceAction = resourceActionPersistence.fetchByN_A(\n\t\t\t\tname, actionId);\n\n\t\t\tif (resourceAction != null) {\n\t\t\t\t_resourceActions.put(key, resourceAction);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlong bitwiseValue = 1;\n\n\t\t\tif (!actionId.equals(ActionKeys.VIEW)) {\n\t\t\t\tbitwiseValue = MathUtil.base2Pow(++lastBitwiseLogValue);\n\t\t\t}\n\n\t\t\tlong resourceActionId = counterLocalService.increment(\n\t\t\t\tResourceAction.class.getName());\n\n\t\t\tresourceAction = resourceActionPersistence.create(resourceActionId);\n\n\t\t\tresourceAction.setName(name);\n\t\t\tresourceAction.setActionId(actionId);\n\t\t\tresourceAction.setBitwiseValue(bitwiseValue);\n\n\t\t\tresourceActionPersistence.update(resourceAction);\n\n\t\t\t_resourceActions.put(key, resourceAction);\n\n\t\t\tnewResourceActions.add(resourceAction);\n\t\t}\n\n\t\tif (addDefaultActions) {\n\t\t\tList<String> groupDefaultActions =\n\t\t\t\tResourceActionsUtil.getModelResourceGroupDefaultActions(name);\n\n\t\t\tList<String> guestDefaultActions =\n\t\t\t\tResourceActionsUtil.getModelResourceGuestDefaultActions(name);\n\n\t\t\tfor (ResourceAction resourceAction : newResourceActions) {\n\t\t\t\tString actionId = resourceAction.getActionId();\n\n\t\t\t\tif (groupDefaultActions.contains(actionId)) {\n\t\t\t\t\tresourcePermissionLocalService.addResourcePermissions(\n\t\t\t\t\t\tname, RoleConstants.SITE_MEMBER,\n\t\t\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\t\t\t\tresourceAction.getBitwiseValue());\n\t\t\t\t}\n\n\t\t\t\tif (guestDefaultActions.contains(actionId)) {\n\t\t\t\t\tresourcePermissionLocalService.addResourcePermissions(\n\t\t\t\t\t\tname, RoleConstants.GUEST,\n\t\t\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\t\t\t\tresourceAction.getBitwiseValue());\n\t\t\t\t}\n\n\t\t\t\tresourcePermissionLocalService.addResourcePermissions(\n\t\t\t\t\tname, RoleConstants.OWNER,\n\t\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\t\t\tresourceAction.getBitwiseValue());\n\t\t\t}\n\t\t}\n\t}","id":93055,"modified_method":"protected void checkResourceActions(\n\t\t\tString name, List<String> actionIds,\n\t\t\tList<ResourceAction> resourceActions, boolean addDefaultActions)\n\t\tthrows SystemException {\n\n\t\tlong lastBitwiseValue = 1;\n\n\t\tif (!resourceActions.isEmpty()) {\n\t\t\tResourceAction resourceAction = resourceActions.get(\n\t\t\t\tresourceActions.size() - 1);\n\n\t\t\tlastBitwiseValue = resourceAction.getBitwiseValue();\n\t\t}\n\n\t\tList<ResourceAction> newResourceActions =\n\t\t\tnew ArrayList<ResourceAction>();\n\n\t\tint lastBitwiseLogValue = MathUtil.base2Log(lastBitwiseValue);\n\n\t\tfor (String actionId : actionIds) {\n\t\t\tString key = encodeKey(name, actionId);\n\n\t\t\tResourceAction resourceAction = _resourceActions.get(key);\n\n\t\t\tif (resourceAction != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresourceAction = resourceActionPersistence.fetchByN_A(\n\t\t\t\tname, actionId);\n\n\t\t\tif (resourceAction != null) {\n\t\t\t\t_resourceActions.put(key, resourceAction);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlong bitwiseValue = 1;\n\n\t\t\tif (!actionId.equals(ActionKeys.VIEW)) {\n\t\t\t\tbitwiseValue = MathUtil.base2Pow(++lastBitwiseLogValue);\n\t\t\t}\n\n\t\t\tlong resourceActionId = counterLocalService.increment(\n\t\t\t\tResourceAction.class.getName());\n\n\t\t\tresourceAction = resourceActionPersistence.create(resourceActionId);\n\n\t\t\tresourceAction.setName(name);\n\t\t\tresourceAction.setActionId(actionId);\n\t\t\tresourceAction.setBitwiseValue(bitwiseValue);\n\n\t\t\tresourceActionPersistence.update(resourceAction);\n\n\t\t\t_resourceActions.put(key, resourceAction);\n\n\t\t\tnewResourceActions.add(resourceAction);\n\t\t}\n\n\t\tif (addDefaultActions) {\n\t\t\tList<String> groupDefaultActions =\n\t\t\t\tResourceActionsUtil.getModelResourceGroupDefaultActions(name);\n\n\t\t\tList<String> guestDefaultActions =\n\t\t\t\tResourceActionsUtil.getModelResourceGuestDefaultActions(name);\n\n\t\t\tlong siteMemberBitwiseValue = 0;\n\t\t\tlong guestBitwiseValue = 0;\n\t\t\tlong ownerBitwiseValue = 0;\n\n\t\t\tfor (ResourceAction resourceAction : newResourceActions) {\n\t\t\t\tString actionId = resourceAction.getActionId();\n\n\t\t\t\tif (groupDefaultActions.contains(actionId)) {\n\t\t\t\t\tsiteMemberBitwiseValue |= resourceAction.getBitwiseValue();\n\t\t\t\t}\n\n\t\t\t\tif (guestDefaultActions.contains(actionId)) {\n\t\t\t\t\tguestBitwiseValue |= resourceAction.getBitwiseValue();\n\t\t\t\t}\n\n\t\t\t\townerBitwiseValue |= resourceAction.getBitwiseValue();\n\t\t\t}\n\n\t\t\tif (siteMemberBitwiseValue > 0) {\n\t\t\t\tresourcePermissionLocalService.addResourcePermissions(\n\t\t\t\t\tname, RoleConstants.SITE_MEMBER,\n\t\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, siteMemberBitwiseValue);\n\t\t\t}\n\n\t\t\tif (guestBitwiseValue > 0) {\n\t\t\t\tresourcePermissionLocalService.addResourcePermissions(\n\t\t\t\t\tname, RoleConstants.GUEST,\n\t\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, guestBitwiseValue);\n\t\t\t}\n\n\t\t\tif (ownerBitwiseValue > 0) {\n\t\t\t\tresourcePermissionLocalService.addResourcePermissions(\n\t\t\t\t\tname, RoleConstants.OWNER,\n\t\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, ownerBitwiseValue);\n\t\t\t}\n\t\t}\n\t}","commit_id":"f425265cb42537543f4a4f9f9616c2ae805ebd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Grants the role permissions at the scope to perform the actions on all\n\t * resources of the type. Existing actions are retained.\n\t *\n\t * <p>\n\t * This method should only be used to add default permissions to existing\n\t * resources en masse during upgrades or while verifying permissions. For\n\t * example, this method could be used to grant site members individual scope\n\t * permissions to view all blog posts.\n\t * <\/p>\n\t *\n\t * @param  resourceName the resource's name, which can be either a class\n\t *         name or a portlet ID\n\t * @param  roleName the role's name\n\t * @param  scope the scope\n\t * @param  resourceActionBitwiseValue the bitwise IDs of the actions\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic void addResourcePermissions(\n\t\t\tString resourceName, String roleName, int scope,\n\t\t\tlong resourceActionBitwiseValue)\n\t\tthrows SystemException {\n\n\t\tList<Role> roles = rolePersistence.findByName(roleName);\n\n\t\tfor (Role role : roles) {\n\t\t\tList<String> primKeys = resourcePermissionFinder.findByC_N_S(\n\t\t\t\trole.getCompanyId(), resourceName, scope);\n\n\t\t\tfor (String primKey : primKeys) {\n\t\t\t\tResourcePermission resourcePermission =\n\t\t\t\t\tresourcePermissionPersistence.fetchByC_N_S_P_R(\n\t\t\t\t\t\trole.getCompanyId(), resourceName, scope, primKey,\n\t\t\t\t\t\trole.getRoleId());\n\n\t\t\t\tif (resourcePermission == null) {\n\t\t\t\t\tlong resourcePermissionId = counterLocalService.increment(\n\t\t\t\t\t\tResourcePermission.class.getName());\n\n\t\t\t\t\tresourcePermission = resourcePermissionPersistence.create(\n\t\t\t\t\t\tresourcePermissionId);\n\n\t\t\t\t\tresourcePermission.setCompanyId(role.getCompanyId());\n\t\t\t\t\tresourcePermission.setName(resourceName);\n\t\t\t\t\tresourcePermission.setScope(scope);\n\t\t\t\t\tresourcePermission.setPrimKey(primKey);\n\t\t\t\t\tresourcePermission.setRoleId(role.getRoleId());\n\t\t\t\t}\n\n\t\t\t\tlong actionIdsLong = resourcePermission.getActionIds();\n\n\t\t\t\tactionIdsLong |= resourceActionBitwiseValue;\n\n\t\t\t\tresourcePermission.setActionIds(actionIdsLong);\n\n\t\t\t\tresourcePermissionPersistence.update(resourcePermission);\n\t\t\t}\n\t\t}\n\t}","id":93056,"modified_method":"/**\n\t * Grants the role permissions at the scope to perform the actions on all\n\t * resources of the type. Existing actions are retained.\n\t *\n\t * <p>\n\t * This method should only be used to add default permissions to existing\n\t * resources en masse during upgrades or while verifying permissions. For\n\t * example, this method could be used to grant site members individual scope\n\t * permissions to view all blog posts.\n\t * <\/p>\n\t *\n\t * @param  resourceName the resource's name, which can be either a class\n\t *         name or a portlet ID\n\t * @param  roleName the role's name\n\t * @param  scope the scope\n\t * @param  resourceActionBitwiseValue the bitwise IDs of the actions\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic void addResourcePermissions(\n\t\t\tString resourceName, String roleName, int scope,\n\t\t\tlong resourceActionBitwiseValue)\n\t\tthrows SystemException {\n\n\t\tList<Role> roles = rolePersistence.findByName(roleName);\n\n\t\tif (roles.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tSession session = resourcePermissionPersistence.openSession();\n\n\t\ttry {\n\n\t\t\t// 1) Update exist ResourcePermissions' actionIds\n\n\t\t\tString sql = CustomSQLUtil.get(_UPDATE_ACTIONIDS);\n\n\t\t\tString roleIds = ListUtil.toString(roles, Role.ROLE_ID_ACCESSOR);\n\n\t\t\tsql = StringUtil.replace(sql, \"[$ROLE_ID$]\", roleIds);\n\n\t\t\tSQLQuery sqlQuery = session.createSQLQuery(sql);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(sqlQuery);\n\n\t\t\tqPos.add(resourceActionBitwiseValue);\n\t\t\tqPos.add(resourceActionBitwiseValue);\n\t\t\tqPos.add(resourceName);\n\t\t\tqPos.add(scope);\n\n\t\t\tsqlQuery.executeUpdate();\n\n\t\t\t// 2) Add missing ResourcePermissions\n\n\t\t\tsql = CustomSQLUtil.get(_FIND_MISSING_RESOURCEPERMISSIONS);\n\n\t\t\tsqlQuery = session.createSQLQuery(sql);\n\n\t\t\tsqlQuery.addScalar(\"temp.companyId\", Type.LONG);\n\t\t\tsqlQuery.addScalar(\"temp.name\", Type.STRING);\n\t\t\tsqlQuery.addScalar(\"temp.scope\", Type.INTEGER);\n\t\t\tsqlQuery.addScalar(\"temp.primKey\", Type.STRING);\n\t\t\tsqlQuery.addScalar(\"role.roleId\", Type.LONG);\n\n\t\t\tqPos = QueryPos.getInstance(sqlQuery);\n\n\t\t\tqPos.add(resourceName);\n\t\t\tqPos.add(scope);\n\t\t\tqPos.add(roleName);\n\n\t\t\tList<Object[]> resourcePermissionKeys = sqlQuery.list(true);\n\n\t\t\tif (resourcePermissionKeys.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (Object[] resourcePermissionKey : resourcePermissionKeys) {\n\t\t\t\tLong tempCompanyId = (Long)resourcePermissionKey[0];\n\t\t\t\tString tempName = (String)resourcePermissionKey[1];\n\t\t\t\tInteger tempScope = (Integer)resourcePermissionKey[2];\n\t\t\t\tString tempPrimKey = (String)resourcePermissionKey[3];\n\t\t\t\tLong tempRoleId = (Long)resourcePermissionKey[4];\n\n\t\t\t\tlong resourcePermissionId = counterLocalService.increment(\n\t\t\t\t\tResourcePermission.class.getName());\n\n\t\t\t\tResourcePermission resourcePermission =\n\t\t\t\t\tresourcePermissionPersistence.create(resourcePermissionId);\n\n\t\t\t\tresourcePermission.setCompanyId(tempCompanyId);\n\t\t\t\tresourcePermission.setName(tempName);\n\t\t\t\tresourcePermission.setScope(tempScope);\n\t\t\t\tresourcePermission.setPrimKey(tempPrimKey);\n\t\t\t\tresourcePermission.setRoleId(tempRoleId);\n\t\t\t\tresourcePermission.setActionIds(resourceActionBitwiseValue);\n\n\t\t\t\tsession.save(resourcePermission);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tresourcePermissionPersistence.closeSession(session);\n\n\t\t\tresourcePermissionPersistence.clearCache();\n\t\t}\n\t}","commit_id":"f425265cb42537543f4a4f9f9616c2ae805ebd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void invoke() {\n    ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n      @Override\n      public void run() {\n        // add\n        List<VirtualFile> filesToAdd = new ArrayList<VirtualFile>(myAdded.size());\n        for (File f : myAdded) {\n          VirtualFile file = VFileSystem.refreshAndGetFile(f);\n          assert file != null : \"Can not find virtual file for \" + f;\n          filesToAdd.add(file);\n        }\n        VcsMigrationUtil.getHandler().addFilesToVcs(filesToAdd, false, false);\n\n        // remove\n        VcsMigrationUtil.deleteFromDiskAndRemoveFromVcs(myRemoved, false);\n\n        // refresh\n        for(Map.Entry<Project,List<File>> entry : myRefresh.entrySet()) {\n          final Project p = entry.getKey();\n          final List<VirtualFile> foldersToRefresh = new ArrayList<VirtualFile>(entry.getValue().size());\n          for (File f : entry.getValue()) {\n            VirtualFile folder = VFileSystem.refreshAndGetFile(f);\n            assert folder != null : \"Can not find virtual file for \" + f;\n            foldersToRefresh.add(folder);\n          }\n\n          RefreshSession session = RefreshQueue.getInstance().createSession(true, true, new Runnable() {\n            public void run() {\n              VcsDirtyScopeManager.getInstance(p).filesDirty(null, foldersToRefresh);\n            }\n          });\n          session.addAllFiles(foldersToRefresh);\n          session.launch();\n        }\n\n        // refresh status\n        ModelGenerationStatusManager.getInstance().invalidateData(myModels);\n      }\n    });\n  }","id":93057,"modified_method":"public void invoke() {\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            // TODO add progress indication\n            for (FileAndContent filesAndContent : myFilesAndContents) {\n              filesAndContent.save();\n            }\n\n            for (IFile file : myFilesToDelete) {\n              file.delete();\n            }\n\n            ModelGenerationStatusManager.getInstance().invalidateData(myModels);\n          }\n        });\n      }\n    });\n  }","commit_id":"30ad81ff54fe1d8c5b2ee4306e1ec940628998bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void startModule(IModule module, List<SModelDescriptor> inputModels, IOperationContext operationContext, ITaskProgressHelper progressHelper) {\n    progressHelper.setText2(\"module \" + module);\n\n    String outputFolder = module != null ? module.getGeneratorOutputPath() : null;\n    prepareOutputFolder(outputFolder);\n\n    if (containsTestModels(inputModels)) {\n      String testsOutputFolder = module != null ? module.getTestsGeneratorOutputPath() : null;\n      prepareOutputFolder(testsOutputFolder);\n    }\n\n    if (myLogger.needsInfo()) {\n      myLogger.info(\"module \" + module + \"; folder = \" + outputFolder + \"\");\n    }\n  }","id":93058,"modified_method":"public void startModule(IModule module, List<SModelDescriptor> inputModels, IOperationContext operationContext, ITaskProgressHelper progressHelper) {\n    progressHelper.setText2(\"module \" + module);\n\n    String outputFolder = module != null ? module.getGeneratorOutputPath() : null;\n\n    if (myLogger.needsInfo()) {\n      myLogger.info(\"module \" + module + \"; folder = \" + outputFolder + \"\");\n    }\n  }","commit_id":"30ad81ff54fe1d8c5b2ee4306e1ec940628998bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext invocationContext, ITaskProgressHelper progressHelper) {\n    info(\"handling output...\");\n    String targetDir = module.getOutputFor(inputModel);\n\n    long startJobTime = System.currentTimeMillis();\n\n    boolean result = false;\n    if (status.isOk()) {\n      JavaStreamHandler javaStreamHandler = new JavaStreamHandler(inputModel, new File(targetDir), invocationContext, myProcessor);\n      try {\n        result = new JavaFileGenerator(javaStreamHandler,\n          ModelGenerationStatusManager.getInstance().getCacheGenerator(),\n          BLDependenciesCache.getInstance().getGenerator(),\n          BLDebugInfoCache.getInstance().getGenerator(),\n          GenerationDependenciesCache.getInstance().getGenerator()\n        ).handleOutput(invocationContext, status);\n      } finally {\n        javaStreamHandler.dispose();\n      }\n    }\n\n    if (!result) {\n      info(\"there were errors.\");\n      return false;\n    }\n    if (myLogger.needsInfo()) {\n      myLogger.info(\"output generated in \" + (System.currentTimeMillis() - startJobTime) + \" ms\");\n    }\n    return true;\n  }","id":93059,"modified_method":"@Override\n  public boolean handleOutput(IModule module, SModelDescriptor inputModel, GenerationStatus status, IOperationContext invocationContext, ITaskProgressHelper progressHelper) {\n    info(\"handling output...\");\n    IFile targetDir = FileSystem.getInstance().getFileByPath(module.getOutputFor(inputModel));\n\n    long startJobTime = System.currentTimeMillis();\n\n    boolean result = false;\n    if (status.isOk()) {\n      JavaStreamHandler javaStreamHandler = new JavaStreamHandler(inputModel, targetDir, myProcessor);\n      try {\n        result = new JavaFileGenerator(javaStreamHandler,\n          ModelGenerationStatusManager.getInstance().getCacheGenerator(),\n          BLDependenciesCache.getInstance().getGenerator(),\n          BLDebugInfoCache.getInstance().getGenerator(),\n          GenerationDependenciesCache.getInstance().getGenerator()\n        ).handleOutput(invocationContext, status);\n      } finally {\n        javaStreamHandler.dispose();\n      }\n    }\n\n    if (!result) {\n      info(\"there were errors.\");\n      return false;\n    }\n    if (myLogger.needsInfo()) {\n      myLogger.info(\"output generated in \" + (System.currentTimeMillis() - startJobTime) + \" ms\");\n    }\n    return true;\n  }","commit_id":"30ad81ff54fe1d8c5b2ee4306e1ec940628998bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"JavaStreamHandler(SModelDescriptor modelDescriptor, File outputDir, IOperationContext context, FileProcessor processor) {\n    myModelDescriptor = modelDescriptor;\n    myOutputDir = outputDir;\n    myContext = context;\n    myCachesOutputDir = new File(FileGenerationUtil.getCachesPath(outputDir.getAbsolutePath()));\n    myProcessor = processor;\n  }","id":93060,"modified_method":"JavaStreamHandler(SModelDescriptor modelDescriptor, IFile outputDir, FileProcessor processor) {\n    myModelDescriptor = modelDescriptor;\n    myOutputDir = outputDir;\n    myCachesOutputDir = FileGenerationUtil.getCachesDir(outputDir);\n    myProcessor = processor;\n  }","commit_id":"30ad81ff54fe1d8c5b2ee4306e1ec940628998bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void saveStream(String name, String content, boolean isCache) {\n    File outputRootDir = isCache ? myCachesOutputDir : myOutputDir;\n    File folder = FileGenerationUtil.getDefaultOutputDir(myModelDescriptor, FileSystem.getInstance().getFileByPath(outputRootDir.getAbsolutePath())).toFile();\n    File file = new File(folder, name);\n    try {\n      register(file, !file.exists());\n      FileUtil.writeFile(file, content);\n    } catch (IOException e) {\n      LOG.error(e);\n    }\n  }","id":93061,"modified_method":"@Override\n  public void saveStream(String name, String content, boolean isCache) {\n    IFile outputRootDir = isCache ? myCachesOutputDir : myOutputDir;\n    IFile file = FileGenerationUtil.getDefaultOutputDir(myModelDescriptor, outputRootDir).child(name);\n    myProcessor.saveContent(file, content);\n    mySavedFiles.add(file);\n  }","commit_id":"30ad81ff54fe1d8c5b2ee4306e1ec940628998bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void dispose() {\n    Set<File> directories = new HashSet<File>();\n    directories.add(myOutputDir);\n    directories.add(myCachesOutputDir);\n    for (File f : myTouched) {\n      directories.add(f.getParentFile());\n    }\n    for (File f : myCreated) {\n      directories.add(f.getParentFile());\n    }\n\n    // clear garbage\n    final List<File> filesToDelete = new ArrayList<File>();\n    for (File dir : directories) {\n      File[] files = dir.listFiles();\n      if (files == null) continue;\n      for (File outputDirectoryFile : files) {\n        if (outputDirectoryFile.isDirectory()) continue;\n        if (myTouched.contains(outputDirectoryFile)) continue;\n        if (myCreated.contains(outputDirectoryFile)) continue;\n        filesToDelete.add(outputDirectoryFile);\n      }\n    }\n\n    myProcessor.processVCSAddition(myCreated);\n    myProcessor.processVCSDeletion(filesToDelete);\n    myProcessor.invalidateRoot(myOutputDir, myContext);\n    myProcessor.invalidateRoot(myCachesOutputDir, myContext);\n    myProcessor.invalidateModel(myModelDescriptor);\n  }","id":93062,"modified_method":"@Override\n  public void dispose() {\n    Set<IFile> directories = new HashSet<IFile>();\n    directories.add(myOutputDir);\n    directories.add(myCachesOutputDir);\n    for (IFile f : mySavedFiles) {\n      directories.add(f.getParent());\n    }\n\n    // clear garbage\n    final List<IFile> filesToDelete = new ArrayList<IFile>();\n    for (IFile dir : directories) {\n      for (IFile outputDirectoryFile : dir.list()) {\n        if (outputDirectoryFile.isDirectory()) continue;\n        if (mySavedFiles.contains(outputDirectoryFile)) continue;\n        filesToDelete.add(outputDirectoryFile);\n      }\n    }\n\n    myProcessor.filesToDelete(filesToDelete);\n    myProcessor.invalidateModel(myModelDescriptor);\n  }","commit_id":"30ad81ff54fe1d8c5b2ee4306e1ec940628998bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void saveStream(String name, Element content, boolean isCache) {\n    File outputRootDir = isCache ? myCachesOutputDir : myOutputDir;\n    File folder = FileGenerationUtil.getDefaultOutputDir(myModelDescriptor, FileSystem.getInstance().getFileByPath(outputRootDir.getAbsolutePath())).toFile();\n    File file = new File(folder, name);\n    try {\n      register(file, !file.exists());\n      JDOMUtil.writeDocument(new Document(content), file);\n    } catch (IOException e) {\n      LOG.error(e);\n    }\n  }","id":93063,"modified_method":"@Override\n  public void saveStream(String name, Element content, boolean isCache) {\n    IFile outputRootDir = isCache ? myCachesOutputDir : myOutputDir;\n    IFile file = FileGenerationUtil.getDefaultOutputDir(myModelDescriptor, outputRootDir).child(name);\n    myProcessor.saveContent(file, content);\n    mySavedFiles.add(file);\n  }","commit_id":"30ad81ff54fe1d8c5b2ee4306e1ec940628998bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean touch(String name, boolean isCache) {\n    File outputRootDir = isCache ? myCachesOutputDir : myOutputDir;\n    File folder = FileGenerationUtil.getDefaultOutputDir(myModelDescriptor, FileSystem.getInstance().getFileByPath(outputRootDir.getAbsolutePath())).toFile();\n    File file = new File(folder, name);\n    if (file.exists()) {\n      register(file, false);\n      return true;\n    }\n    return false;\n  }","id":93064,"modified_method":"@Override\n  public boolean touch(String name, boolean isCache) {\n    IFile outputRootDir = isCache ? myCachesOutputDir : myOutputDir;\n    IFile file = FileGenerationUtil.getDefaultOutputDir(myModelDescriptor, outputRootDir).child(name);\n    mySavedFiles.add(file);\n    return file.exists();\n  }","commit_id":"30ad81ff54fe1d8c5b2ee4306e1ec940628998bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"public AnnotationMetadataProvider(final ResourceStore store,\n                                      final Reporter reporter) {\n        this(store, newBindingRegistry(reporter, store), reporter);\n    }","id":93065,"modified_method":"public AnnotationMetadataProvider(final ResourceStore store,\n                                      final Reporter reporter) {\n        this(store, new CoreModuleProvider(), reporter);\n    }","commit_id":"1a1ef908e030cfbf08b2ed9b9d277a1126e58f7c","url":"https://github.com/apache/felix"},{"original_method":"public static BindingRegistry newBindingRegistry(Reporter reporter, ResourceStore store) {\n\n        // Build the registry by aggregation of the features we want\n        // TODO We can enable/disable the legacy support easily here\n        BindingRegistry registry = new DefaultBindingRegistry(reporter);\n        registry = new MetaAnnotationBindingRegistry(registry, reporter, store);\n        registry = new LegacyGenericBindingRegistry(registry, reporter);\n        registry = new IgnoreAllBindingRegistry(registry, reporter);\n\n        ServiceLoader<Module> loader = ServiceLoader.load(Module.class, classloader());\n\n        // Build each Module and add its contributed Bindings in the registry\n        for (Module module : loader) {\n            module.configure();\n            registry.addBindings(module);\n        }\n\n        return registry;\n    }","id":93066,"modified_method":"public static BindingRegistry newBindingRegistry(final Reporter reporter,\n                                                     final ResourceStore store,\n                                                     final ModuleProvider provider) {\n\n        // Build the registry by aggregation of the features we want\n        // TODO We can enable/disable the legacy support easily here\n        BindingRegistry registry = new DefaultBindingRegistry(reporter);\n        registry = new MetaAnnotationBindingRegistry(registry, reporter, store);\n        registry = new LegacyGenericBindingRegistry(registry, reporter);\n        registry = new IgnoreAllBindingRegistry(registry, reporter);\n\n        // Build each Module and add its contributed Bindings in the registry\n        for (Module module : provider.findModules()) {\n            module.load();\n            registry.addBindings(module);\n        }\n\n        return registry;\n    }","commit_id":"1a1ef908e030cfbf08b2ed9b9d277a1126e58f7c","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Opens a connection using the ipojo url handler.\n     * This methods parses the URL and manipulate the given bundle.\n     *\n     * @param url the url.\n     * @return the URL connection on the manipulated bundle\n     * @throws java.io.IOException occurs when the bundle cannot be either downloaded, or manipulated or\n     *                             installed correctly.\n     * @see org.osgi.service.url.AbstractURLStreamHandlerService#openConnection(java.net.URL)\n     */\n    public URLConnection openConnection(URL url) throws IOException {\n        System.out.println(\"Processing URL : \" + url);\n\n        // Parse the url:\n        String full = url.toExternalForm();\n        // Remote ipojo://\n        if (full.startsWith(\"ipojo:\")) {\n            full = full.substring(6);\n        }\n        // Remove '/' or '//'\n        while (full.startsWith(\"/\")) {\n            full = full.substring(1);\n        }\n\n        full = full.trim();\n\n        // Now full is like : URL,URL or URL\n        String[] urls = full.split(\"!\");\n        URL bundleURL = null;\n        URL metadataURL = null;\n        if (urls.length == 1) {\n            // URL form\n            System.out.println(\"Extracted URL : \" + urls[0]);\n            bundleURL = new URL(urls[0]);\n        } else if (urls.length == 2) {\n            // URL,URL form\n            bundleURL = new URL(urls[0]);\n            metadataURL = new URL(urls[1]);\n        } else {\n            throw new MalformedURLException(\"The iPOJO url is not formatted correctly, ipojo:bundle_url[!metadata_url] expected\");\n        }\n\n        File bundle = File.createTempFile(\"ipojo_\", \".jar\", m_temp);\n        save(bundleURL, bundle);\n        File metadata = null;\n        if (metadataURL != null) {\n            metadata = File.createTempFile(\"ipojo_\", \".xml\", m_temp);\n            save(metadataURL, metadata);\n        } else {\n            // Check that the metadata are in the jar file\n            JarFile jar = new JarFile(bundle);\n            metadata = findMetadata(jar);\n        }\n\n        // Pojoization\n        Pojoization pojoizator = new Pojoization();\n        File out = new File(m_temp, bundle.getName() + \"-ipojo.jar\");\n        try {\n            pojoizator.pojoization(bundle, out, metadata);\n        } catch (Exception e) {\n            if (!pojoizator.getErrors().isEmpty()) {\n                throw new IOException(\"Errors occurred during the manipulation : \" + pojoizator.getErrors());\n            }\n            e.printStackTrace();\n            throw new RuntimeException(e.getMessage());\n        }\n\n        if (!pojoizator.getErrors().isEmpty()) {\n            throw new IOException(\"Errors occurred during the manipulation : \" + pojoizator.getErrors());\n        }\n        if (!pojoizator.getWarnings().isEmpty()) {\n            System.err.println(\"Warnings occurred during the manipulation : \" + pojoizator.getWarnings());\n        }\n\n        System.out.println(\"Manipulation done : \" + out.exists());\n\n        // Cleanup\n        bundle.delete();\n        if (metadata != null) {\n            metadata.delete();\n        }\n        out.deleteOnExit();\n        // Returns the URL Connection\n        return out.toURI().toURL().openConnection();\n\n\n    }","id":93067,"modified_method":"/**\n     * Opens a connection using the ipojo url handler.\n     * This methods parses the URL and manipulate the given bundle.\n     *\n     * @param url the url.\n     * @return the URL connection on the manipulated bundle\n     * @throws java.io.IOException occurs when the bundle cannot be either downloaded, or manipulated or\n     *                             installed correctly.\n     * @see org.osgi.service.url.AbstractURLStreamHandlerService#openConnection(java.net.URL)\n     */\n    public URLConnection openConnection(URL url) throws IOException {\n        logger.log(LOG_DEBUG, format(\"Processing URL %s\", url));\n        String full = removeScheme(url);\n\n        // Now full is like : URL!URL or URL\n        String[] urls = full.split(\"!\");\n        URL bundleURL = null;\n        URL metadataURL = null;\n        if (urls.length == 1) {\n            // URL form\n            bundleURL = new URL(urls[0]);\n        } else if (urls.length == 2) {\n            // URL!URL form\n            bundleURL = new URL(urls[0]);\n            metadataURL = new URL(urls[1]);\n        } else {\n            throw new MalformedURLException(\"The iPOJO url is not formatted correctly, ipojo:bundle_url[!metadata_url] expected\");\n        }\n\n        logger.log(LOG_DEBUG, format(\"Extracted URL %s\", url));\n\n        // Dump the referenced bundle on disk\n        File original = File.createTempFile(\"original-\", \".jar\", m_temp);\n        dump(bundleURL.openStream(), original);\n\n        JarFile jf = new JarFile(original);\n\n        File metadata = null;\n        if (metadataURL != null) {\n            metadata = File.createTempFile(\"ipojo-\", \".xml\", m_temp);\n            dump(metadataURL, metadata);\n        } else {\n            // Check that the metadata are in the jar file\n            metadata = findMetadata(jf);\n        }\n\n        Reporter reporter = new SystemReporter();\n        File out = File.createTempFile(\"ipojo-\", \".jar\", m_temp);\n\n        ResourceStore store = new BundleAwareJarFileResourceStore(jf, out, m_context);\n\n        CompositeMetadataProvider composite = new CompositeMetadataProvider(reporter);\n        if (metadata != null) {\n            FileMetadataProvider provider = new FileMetadataProvider(metadata, reporter);\n            composite.addMetadataProvider(provider);\n        }\n\n        // Pojoization\n        Pojoization pojoizator = new Pojoization(createModuleProvider());\n        try {\n            pojoizator.pojoization(store, composite, createVisitor(store, reporter));\n        } catch (Exception e) {\n            if (!pojoizator.getErrors().isEmpty()) {\n                throw new IOException(\"Errors occurred during the manipulation : \" + pojoizator.getErrors(), e);\n            }\n            e.printStackTrace();\n            throw new IOException(\"Cannot manipulate the Url: \" + url, e);\n        }\n\n        if (!pojoizator.getErrors().isEmpty()) {\n            throw new IOException(\"Errors occurred during the manipulation : \" + pojoizator.getErrors());\n        }\n        if (!pojoizator.getWarnings().isEmpty()) {\n            logger.log(LOG_WARNING, format(\"Warnings occurred during the manipulation %s\", pojoizator.getWarnings()));\n        }\n\n        logger.log(LOG_DEBUG, format(\"Manipulation done %s\", out.exists()));\n\n        // Cleanup\n        if (metadata != null) {\n            metadata.delete();\n        }\n        original.delete();\n        out.deleteOnExit();\n\n        // Returns the URL Connection\n        return out.toURI().toURL().openConnection();\n\n\n    }","commit_id":"1a1ef908e030cfbf08b2ed9b9d277a1126e58f7c","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Looks for the metadata.xml file in the jar file.\n     * Two locations are checked:\n     * <ol>\n     * <li>the root of the jar file<\/li>\n     * <li>the META-INF directory<\/li>\n     * <\/ol>\n     *\n     * @param jar the jar file\n     * @return the founded file or <code>null<\/code> if not found.\n     * @throws java.io.IOException occurs when the Jar file cannot be read.\n     */\n    private File findMetadata(JarFile jar) throws IOException {\n        JarEntry je = jar.getJarEntry(\"metadata.xml\");\n        if (je == null) {\n            je = jar.getJarEntry(\"META-INF/metadata.xml\");\n        }\n\n        if (je == null) {\n            System.out.println(\"Metadata file not found, use annotations only.\");\n            return null; // Not Found, use annotation only\n        } else {\n            System.out.println(\"Metadata file found: \" + je.getName());\n            File metadata = File.createTempFile(\"ipojo_\", \".xml\", m_temp);\n            save(jar.getInputStream(je), metadata);\n            System.out.println(\"Metadata file saved to \" + metadata.getAbsolutePath());\n            return metadata;\n        }\n\n    }","id":93068,"modified_method":"/**\n     * Looks for the metadata.xml file in the jar file.\n     * Two locations are checked:\n     * <ol>\n     * <li>the root of the jar file<\/li>\n     * <li>the META-INF directory<\/li>\n     * <\/ol>\n     *\n     * @param jar the jar file\n     * @return the found file or <code>null<\/code> if not found.\n     * @throws java.io.IOException occurs when the Jar file cannot be read.\n     */\n    private File findMetadata(JarFile jar) throws IOException {\n        JarEntry je = jar.getJarEntry(\"metadata.xml\");\n        if (je == null) {\n            je = jar.getJarEntry(\"META-INF/metadata.xml\");\n        }\n\n        if (je == null) {\n            logger.log(LOG_DEBUG, \"Metadata file not found, use annotations only.\");\n            return null; // Not Found, use annotation only\n        } else {\n            logger.log(LOG_DEBUG, format(\"Metadata file found at  %s\", je.getName()));\n            File metadata = File.createTempFile(\"ipojo-\", \".xml\", m_temp);\n            dump(jar.getInputStream(je), metadata);\n            logger.log(LOG_DEBUG, format(\"Metadata file saved at %s\", metadata));\n            return metadata;\n        }\n\n    }","commit_id":"1a1ef908e030cfbf08b2ed9b9d277a1126e58f7c","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Creates a IPOJOURLHandler.\n     * Gets the bundle context and create the working\n     * directory.\n     *\n     * @param bc the bundle context\n     */\n    public IPOJOURLHandler(BundleContext bc) {\n        m_context = bc;\n        m_temp = m_context.getDataFile(\"temp\");\n        if (!m_temp.exists()) {\n            m_temp.mkdir();\n        }\n    }","id":93069,"modified_method":"/**\n     * Creates a IPOJOURLHandler.\n     * Gets the bundle context and create the working\n     * directory.\n     *\n     * @param bundleContext the bundle context\n     */\n    public IPOJOURLHandler(BundleContext bundleContext) {\n        this(bundleContext, bundleContext.getDataFile(\"temp\"));\n    }","commit_id":"1a1ef908e030cfbf08b2ed9b9d277a1126e58f7c","url":"https://github.com/apache/felix"},{"original_method":"@Configuration\n    public Option[] configure() throws IOException {\n        Logger root = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);\n        root.setLevel(Level.INFO);\n\n        String providerWithMetadata = providerWithMetadata();\n        String providerWithMetadataInMetaInf = providerWithMetadataInMetaInf();\n        String providerWithoutMetadata = providerWithoutMetadata();\n        String consumerWithMetadata = consumerWithMetadata();\n        String consumerWithoutMetadata = consumerWithoutMetadata();\n\n        return options(\n                cleanCaches(),\n                mavenBundle(\"org.apache.felix\", \"org.apache.felix.ipojo\").versionAsInProject(),\n                mavenBundle(\"org.ow2.chameleon.testing\", \"osgi-helpers\").versionAsInProject(),\n                mavenBundle(\"org.apache.felix\",\"org.apache.felix.ipojo.manipulator.online\").versionAsInProject(),\n                junitBundles(),\n\n                provision(\n                        TinyBundles.bundle()\n                                .add(Hello.class)\n                                .set(Constants.BUNDLE_SYMBOLICNAME, \"ServiceInterface\")\n                                .set(Constants.EXPORT_PACKAGE, \"org.apache.felix.ipojo.test.online.services\")\n                                .build()\n                ),\n\n                systemProperty(\"providerWithMetadata\").value(providerWithMetadata),\n                systemProperty(\"providerWithMetadataInMetaInf\").value(providerWithMetadataInMetaInf),\n                systemProperty(\"providerWithoutMetadata\").value(providerWithoutMetadata),\n                systemProperty(\"providerUsingAnnotations\").value(providerUsingAnnotation()),\n                systemProperty(\"consumerWithMetadata\").value(consumerWithMetadata),\n                systemProperty(\"consumerWithoutMetadata\").value(consumerWithoutMetadata),\n\n                systemProperty(\"org.knopflerfish.osgi.registerserviceurlhandler\").value(\"true\")\n        );\n\n    }","id":93070,"modified_method":"@Configuration\n    public Option[] configure() throws IOException {\n        Logger root = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);\n        root.setLevel(Level.INFO);\n\n        String providerWithMetadata = providerWithMetadata();\n        String providerWithMetadataInMetaInf = providerWithMetadataInMetaInf();\n        String providerWithoutMetadata = providerWithoutMetadata();\n        String consumerWithMetadata = consumerWithMetadata();\n        String consumerWithoutMetadata = consumerWithoutMetadata();\n        String providerUsingModules = providerUsingModules();\n        String providerUsingAnnotatedStereotype = providerUsingAnnotatedStereotype();\n\n        return options(\n                cleanCaches(),\n                mavenBundle(\"org.apache.felix\", \"org.apache.felix.ipojo\").versionAsInProject(),\n                mavenBundle(\"org.ow2.chameleon.testing\", \"osgi-helpers\").versionAsInProject(),\n                mavenBundle(\"org.apache.felix\",\"org.apache.felix.ipojo.manipulator.online\").versionAsInProject(),\n                junitBundles(),\n\n                provision(\n                        TinyBundles.bundle()\n                                .add(Hello.class)\n                                .set(Constants.BUNDLE_SYMBOLICNAME, \"ServiceInterface\")\n                                .set(Constants.EXPORT_PACKAGE, \"org.apache.felix.ipojo.test.online.services\")\n                                .build(),\n                        moduleBundle()\n                ),\n\n                systemProperty(\"providerWithMetadata\").value(providerWithMetadata),\n                systemProperty(\"providerWithMetadataInMetaInf\").value(providerWithMetadataInMetaInf),\n                systemProperty(\"providerWithoutMetadata\").value(providerWithoutMetadata),\n                systemProperty(\"providerUsingAnnotations\").value(providerUsingAnnotation()),\n                systemProperty(\"consumerWithMetadata\").value(consumerWithMetadata),\n                systemProperty(\"consumerWithoutMetadata\").value(consumerWithoutMetadata),\n                systemProperty(\"providerUsingModules\").value(providerUsingModules),\n                systemProperty(\"providerUsingAnnotatedStereotype\").value(providerUsingAnnotatedStereotype),\n\n                systemProperty(\"org.knopflerfish.osgi.registerserviceurlhandler\").value(\"true\")\n        );\n\n    }","commit_id":"1a1ef908e030cfbf08b2ed9b9d277a1126e58f7c","url":"https://github.com/apache/felix"},{"original_method":"public Pojoization(Reporter reporter) {\n        m_reporter = reporter;\n        m_reporter.info(\"Apache Felix iPOJO Manipulator - \" + Constants.getVersion());\n    }","id":93071,"modified_method":"public Pojoization(Reporter reporter) {\n        this(reporter, new ServiceLoaderModuleProvider());\n    }","commit_id":"1a1ef908e030cfbf08b2ed9b9d277a1126e58f7c","url":"https://github.com/apache/felix"},{"original_method":"public void pojoization(final ResourceStore store,\n                            final MetadataProvider metadata,\n                            final ManipulationVisitor visitor) {\n\n        ManipulationEngine engine = new ManipulationEngine();\n        engine.setResourceStore(store);\n        engine.setReporter(m_reporter);\n        engine.setManipulationVisitor(visitor);\n\n        try {\n\n            // Creates a composite to store multiple metadata providers\n            CompositeMetadataProvider composite = new CompositeMetadataProvider(m_reporter);\n            composite.addMetadataProvider(metadata);\n\n            if (!m_ignoreAnnotations) {\n                composite.addMetadataProvider(new AnnotationMetadataProvider(store, m_reporter));\n            }\n\n            // Get metadata\n            List<Element> metadatas = composite.getMetadatas();\n\n            // Construct ManipulationUnits\n            // And collect non-component metadata\n            for (Element meta : metadatas) {\n                String name = Metadatas.getComponentType(meta);\n                if (name != null) {\n                    // Only handler and component have a classname attribute\n                    String path = Strings.asResourcePath(name);\n                    engine.addManipulationUnit(new ManipulationUnit(path, meta));\n                } else {\n                    visitor.visitMetadata(meta);\n                }\n            }\n\n        } catch (IOException e) {\n            m_reporter.error(\"Cannot load metadata \" + e.getMessage());\n            return;\n        }\n\n        // Start the manipulation\n        engine.generate();\n\n        // Tell the visitor that we have finished\n        visitor.visitEnd();\n\n    }","id":93072,"modified_method":"public void pojoization(final ResourceStore store,\n                            final MetadataProvider metadata,\n                            final ManipulationVisitor visitor) {\n\n        ManipulationEngine engine = new ManipulationEngine();\n        engine.setResourceStore(store);\n        engine.setReporter(m_reporter);\n        engine.setManipulationVisitor(visitor);\n\n        try {\n\n            // Creates a composite to store multiple metadata providers\n            CompositeMetadataProvider composite = new CompositeMetadataProvider(m_reporter);\n            composite.addMetadataProvider(metadata);\n\n            if (!m_ignoreAnnotations) {\n                composite.addMetadataProvider(new AnnotationMetadataProvider(store, m_moduleProvider, m_reporter));\n            }\n\n            // Get metadata\n            List<Element> metadatas = composite.getMetadatas();\n\n            // Construct ManipulationUnits\n            // And collect non-component metadata\n            for (Element meta : metadatas) {\n                String name = Metadatas.getComponentType(meta);\n                if (name != null) {\n                    // Only handler and component have a classname attribute\n                    String path = Strings.asResourcePath(name);\n                    engine.addManipulationUnit(new ManipulationUnit(path, meta));\n                } else {\n                    visitor.visitMetadata(meta);\n                }\n            }\n\n        } catch (IOException e) {\n            m_reporter.error(\"Cannot load metadata \" + e.getMessage());\n            return;\n        }\n\n        // Start the manipulation\n        engine.generate();\n\n        // Tell the visitor that we have finished\n        visitor.visitEnd();\n\n    }","commit_id":"1a1ef908e030cfbf08b2ed9b9d277a1126e58f7c","url":"https://github.com/apache/felix"},{"original_method":"public void testSelectionOnClassNodeOnly() throws Exception {\n\n        AbsBindingModule module = new MonoBindingModule(OnTypeOnly.class);\n        module.configure();\n        registry.addBindings(module);\n\n        // Verifications\n        assertClassSelection(OnTypeOnly.class, equalTo(visitor));\n        assertFieldSelection(OnTypeOnly.class, nullValue());\n        assertMethodSelection(OnTypeOnly.class, nullValue());\n        assertParameterSelection(OnTypeOnly.class, nullValue());\n    }","id":93073,"modified_method":"public void testSelectionOnClassNodeOnly() throws Exception {\n\n        AbsBindingModule module = new MonoBindingModule(OnTypeOnly.class);\n        module.load();\n        registry.addBindings(module);\n\n        // Verifications\n        assertClassSelection(OnTypeOnly.class, equalTo(visitor));\n        assertFieldSelection(OnTypeOnly.class, nullValue());\n        assertMethodSelection(OnTypeOnly.class, nullValue());\n        assertParameterSelection(OnTypeOnly.class, nullValue());\n    }","commit_id":"1a1ef908e030cfbf08b2ed9b9d277a1126e58f7c","url":"https://github.com/apache/felix"},{"original_method":"public void testSelectionOnMethodNodeOnly() throws Exception {\n\n        AbsBindingModule module = new MonoBindingModule(OnMethodOnly.class);\n        module.configure();\n        registry.addBindings(module);\n\n        // Verifications\n        assertClassSelection(OnMethodOnly.class, nullValue());\n        assertFieldSelection(OnMethodOnly.class, nullValue());\n        assertMethodSelection(OnMethodOnly.class, equalTo(visitor));\n        assertParameterSelection(OnMethodOnly.class, nullValue());\n\n    }","id":93074,"modified_method":"public void testSelectionOnMethodNodeOnly() throws Exception {\n\n        AbsBindingModule module = new MonoBindingModule(OnMethodOnly.class);\n        module.load();\n        registry.addBindings(module);\n\n        // Verifications\n        assertClassSelection(OnMethodOnly.class, nullValue());\n        assertFieldSelection(OnMethodOnly.class, nullValue());\n        assertMethodSelection(OnMethodOnly.class, equalTo(visitor));\n        assertParameterSelection(OnMethodOnly.class, nullValue());\n\n    }","commit_id":"1a1ef908e030cfbf08b2ed9b9d277a1126e58f7c","url":"https://github.com/apache/felix"},{"original_method":"public void testSelectionOnMethodParameterOnly() throws Exception {\n\n        AbsBindingModule module = new MonoBindingModule(OnParameterOnly.class);\n        module.configure();\n        registry.addBindings(module);\n\n        // Verifications\n        assertClassSelection(OnParameterOnly.class, nullValue());\n        assertFieldSelection(OnParameterOnly.class, nullValue());\n        assertMethodSelection(OnParameterOnly.class, nullValue());\n        assertParameterSelection(OnParameterOnly.class, equalTo(visitor));\n\n    }","id":93075,"modified_method":"public void testSelectionOnMethodParameterOnly() throws Exception {\n\n        AbsBindingModule module = new MonoBindingModule(OnParameterOnly.class);\n        module.load();\n        registry.addBindings(module);\n\n        // Verifications\n        assertClassSelection(OnParameterOnly.class, nullValue());\n        assertFieldSelection(OnParameterOnly.class, nullValue());\n        assertMethodSelection(OnParameterOnly.class, nullValue());\n        assertParameterSelection(OnParameterOnly.class, equalTo(visitor));\n\n    }","commit_id":"1a1ef908e030cfbf08b2ed9b9d277a1126e58f7c","url":"https://github.com/apache/felix"},{"original_method":"public void testSelectionOBothMethodAndParameter() throws Exception {\n\n        AbsBindingModule module = new MonoBindingModule(OnBothMethodAndParameter.class);\n        module.configure();\n        registry.addBindings(module);\n\n        // Verifications\n        assertClassSelection(OnBothMethodAndParameter.class, nullValue());\n        assertFieldSelection(OnBothMethodAndParameter.class, nullValue());\n        assertMethodSelection(OnBothMethodAndParameter.class, equalTo(visitor));\n        assertParameterSelection(OnBothMethodAndParameter.class, equalTo(visitor));\n\n    }","id":93076,"modified_method":"public void testSelectionOBothMethodAndParameter() throws Exception {\n\n        AbsBindingModule module = new MonoBindingModule(OnBothMethodAndParameter.class);\n        module.load();\n        registry.addBindings(module);\n\n        // Verifications\n        assertClassSelection(OnBothMethodAndParameter.class, nullValue());\n        assertFieldSelection(OnBothMethodAndParameter.class, nullValue());\n        assertMethodSelection(OnBothMethodAndParameter.class, equalTo(visitor));\n        assertParameterSelection(OnBothMethodAndParameter.class, equalTo(visitor));\n\n    }","commit_id":"1a1ef908e030cfbf08b2ed9b9d277a1126e58f7c","url":"https://github.com/apache/felix"},{"original_method":"public void testSelectionOnFieldNodeOnly() throws Exception {\n\n        AbsBindingModule module = new MonoBindingModule(OnFieldOnly.class);\n        module.configure();\n        registry.addBindings(module);\n\n        // Verifications\n        assertClassSelection(OnFieldOnly.class, nullValue());\n        assertFieldSelection(OnFieldOnly.class, equalTo(visitor));\n        assertMethodSelection(OnFieldOnly.class, nullValue());\n        assertParameterSelection(OnFieldOnly.class, nullValue());\n\n    }","id":93077,"modified_method":"public void testSelectionOnFieldNodeOnly() throws Exception {\n\n        AbsBindingModule module = new MonoBindingModule(OnFieldOnly.class);\n        module.load();\n        registry.addBindings(module);\n\n        // Verifications\n        assertClassSelection(OnFieldOnly.class, nullValue());\n        assertFieldSelection(OnFieldOnly.class, equalTo(visitor));\n        assertMethodSelection(OnFieldOnly.class, nullValue());\n        assertParameterSelection(OnFieldOnly.class, nullValue());\n\n    }","commit_id":"1a1ef908e030cfbf08b2ed9b9d277a1126e58f7c","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Handles the installation.\n     *\n     * @param req the servlet request with the input parameters\n     * @return the installation return code\n     *\n     * @throws ServletException if a servlet error occurs.\n     * @throws IOException if an I/O error occurs.\n     */\n    public int installRepository(HttpServletRequest req)\n            throws ServletException, IOException {\n        String repHome = req.getParameter(\"repository_home\");\n        String repType = req.getParameter(\"repository_type\");\n        String repXml = req.getParameter(\"repository_xml\");\n        String mode = req.getParameter(\"mode\");\n\n        if (repHome == null || mode == null) {\n            return C_INVALID_INPUT;\n        }\n        File home = new File(repHome);\n\n        File config;\n        if (\"oak\".equals(repType)) {\n            config = null;\n            repXml = null;\n        } else if (repXml == null || repXml.length() == 0) {\n            config = new File(home, \"repository.xml\");\n            repXml = config.getPath();\n        } else {\n            config = new File(repXml);\n        }\n\n        if (\"new\".equals(mode)) {\n            // Test internal folder repository existence and not home because home is already created\n            // by org.apache.jackrabbit.server.remoting.davex.JcrRemotingServlet\n            if (new File(home, \"repository\").exists()) {\n                log.error(\"Trying to install new repository home '{}' but it already contain a repository\", repHome);\n                return C_HOME_EXISTS;\n            }\n            if (config != null && config.exists()) {\n                log.error(\"Trying to install new repository config '{}' but already exists\", repXml);\n                return C_CONFIG_EXISTS;\n            }\n            log.info(\"Creating new repository home '{}'\", repHome);\n            home.mkdirs();\n\n            if (config != null) {\n                // install repository xml for Jackrabbit Classic\n                try {\n                    installRepositoryConfig(config);\n                } catch (IOException e) {\n                    log.error(\"Error while installing new repository config '{}': {}\", repXml, e.toString());\n                    return C_BOOTSTRAP_EXISTS;\n                }\n            }\n        } else {\n            if (!home.exists()) {\n                log.error(\"Trying to use existing repository home '{}' but does not exists\", repHome);\n                return C_HOME_MISSING;\n            }\n            if (config != null && !config.exists()) {\n                log.error(\"Trying to use existing repository config '{}' but does not exists\", repXml);\n                return C_CONFIG_MISSING;\n            }\n        }\n        // install bootstrap.properties\n        try {\n            installBootstrap(bootstrapConfigFile, repHome, repXml);\n        } catch (IOException e) {\n            log.error(\"Error while installing '{}': {}\", bootstrapConfigFile.getPath(), e.toString());\n            return C_INSTALL_ERROR;\n        }\n        return C_INSTALL_OK;\n    }","id":93078,"modified_method":"/**\n     * Handles the installation.\n     *\n     * @param req the servlet request with the input parameters\n     * @return the installation return code\n     *\n     * @throws ServletException if a servlet error occurs.\n     * @throws IOException if an I/O error occurs.\n     */\n    public int installRepository(HttpServletRequest req)\n            throws ServletException, IOException {\n        String repHome = req.getParameter(\"repository_home\");\n        String mode = req.getParameter(\"mode\");\n\n        if (repHome == null || mode == null) {\n            return C_INVALID_INPUT;\n        }\n        File home = new File(repHome);\n        File config = new File(home, \"repository-config.json\");\n\n        if (\"new\".equals(mode)) {\n            // Test internal folder repository existence and not home because home is already created\n            // by org.apache.jackrabbit.server.remoting.davex.JcrRemotingServlet\n            if (config.exists()) {\n                log.error(\"Trying to install new repository config '{}' but already exists\", config);\n                return C_CONFIG_EXISTS;\n            }\n            log.info(\"Creating new repository home '{}'\", repHome);\n            home.mkdirs();\n\n            try {\n                installRepositoryConfig(config);\n            } catch (IOException e) {\n                log.error(\"Error while installing new repository config '{}': {}\", config, e.toString());\n                return C_BOOTSTRAP_EXISTS;\n            }\n        } else {\n            if (!home.exists()) {\n                log.error(\"Trying to use existing repository home '{}' but does not exists\", repHome);\n                return C_HOME_MISSING;\n            }\n            if (!config.exists()) {\n                log.error(\"Trying to use existing repository config '{}' but does not exists\", config);\n                return C_CONFIG_MISSING;\n            }\n        }\n        // install bootstrap.properties\n        try {\n            installBootstrap(bootstrapConfigFile, repHome);\n        } catch (IOException e) {\n            log.error(\"Error while installing '{}': {}\", bootstrapConfigFile.getPath(), e.toString());\n            return C_INSTALL_ERROR;\n        }\n        return C_INSTALL_OK;\n    }","commit_id":"49ce807e8e08b4170febc2ac3108e6e4494132de","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Installs the bootstrap config file from the template\n     * @param dest the destination location\n     * @param repHome the repository home location\n     * @param repXml the repository xml location\n     * @throws IOException if an I/O error occurs\n     */\n    private void installBootstrap(File dest, String repHome, String repXml)\n            throws IOException {\n        log.info(\"Creating new bootstrap properties: {}\", dest.getPath());\n        InputStream in = context.getResourceAsStream(bootstrapTemplate);\n        Properties props = new Properties();\n        props.load(in);\n        props.setProperty(\"repository.home\", repHome);\n        if (repXml != null) {\n            props.setProperty(\"repository.config\", repXml);\n        }\n        in.close();\n        if (!dest.getParentFile().exists()) {\n            dest.getParentFile().mkdirs();\n        }\n        OutputStream out = new FileOutputStream(dest);\n        props.store(out, \"bootstrap properties for the repository startup servlet.\");\n        out.close();\n    }","id":93079,"modified_method":"/**\n     * Installs the bootstrap config file from the template\n     * @param dest the destination location\n     * @param repHome the repository home location\n     * @throws IOException if an I/O error occurs\n     */\n    private void installBootstrap(File dest, String repHome)\n            throws IOException {\n        log.info(\"Creating new bootstrap properties: {}\", dest.getPath());\n        InputStream in = context.getResourceAsStream(bootstrapTemplate);\n        Properties props = new Properties();\n        props.load(in);\n        props.setProperty(\"repository.home\", repHome);\n        in.close();\n        if (!dest.getParentFile().exists()) {\n            dest.getParentFile().mkdirs();\n        }\n        OutputStream out = new FileOutputStream(dest);\n        props.store(out, \"bootstrap properties for the repository startup servlet.\");\n        out.close();\n    }","commit_id":"49ce807e8e08b4170febc2ac3108e6e4494132de","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates the repository instance for the given config and homedir.\n     * Subclasses may override this method of providing own implementations of\n     * a {@link Repository}.\n     *\n     * @param is input source of the repository config\n     * @param homedir the repository home directory\n     * @return a new jcr repository.\n     * @throws RepositoryException if an error during creation occurs.\n     */\n    protected Repository createRepository(InputSource is, File homedir)\n            throws RepositoryException {\n        RepositoryConfig config = RepositoryConfig.create(is, homedir.getAbsolutePath());\n        return RepositoryImpl.create(config);\n    }","id":93080,"modified_method":"/**\n     * Creates the repository instance for the given config and homedir.\n     * Subclasses may override this method of providing own implementations of\n     * a {@link Repository}.\n     *\n     * @param is input source of the repository config\n     * @param homedir the repository home directory\n     * @return a new jcr repository.\n     * @throws RepositoryException if an error during creation occurs.\n     */\n    protected Repository createRepository(File configJson, File homedir)\n            throws RepositoryException {\n        Map<String,String> config = new HashMap<String, String>();\n        config.put(\"org.apache.jackrabbit.repository.home\", homedir.getAbsolutePath());\n        config.put(\"org.apache.jackrabbit.oak.repository.configFile\", configJson.getAbsolutePath());\n        //TODO oak-jcr also provides a dummy RepositoryFactory. Hence this\n        //cannot be used\n        //return JcrUtils.getRepository(config);\n        return new OakOSGiRepositoryFactory().getRepository(config);\n    }","commit_id":"49ce807e8e08b4170febc2ac3108e6e4494132de","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Shuts down the repository. If the repository is an instanceof\n     * {@link JackrabbitRepository} it's {@link JackrabbitRepository#shutdown()}\n     * method is called. in any case, the {@link #repository} field is\n     * <code>nulled<\/code>.\n     */\n    private void shutdownRepository() {\n        if (store != null) {\n            store.close();\n            store = null;\n        } else if (repository instanceof JackrabbitRepository) {\n            ((JackrabbitRepository) repository).shutdown();\n        }\n        repository = null;\n    }","id":93081,"modified_method":"/**\n     * Shuts down the repository. If the repository is an instanceof\n     * {@link JackrabbitRepository} it's {@link JackrabbitRepository#shutdown()}\n     * method is called. in any case, the {@link #repository} field is\n     * <code>nulled<\/code>.\n     */\n    private void shutdownRepository() {\n        if (repository instanceof JackrabbitRepository) {\n            ((JackrabbitRepository) repository).shutdown();\n        }\n        repository = null;\n    }","commit_id":"49ce807e8e08b4170febc2ac3108e6e4494132de","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates a new Repository based on the configuration and initializes the\n     * {@link #repository} field if successful.\n     *\n     * @throws ServletException if an error occurs\n     */\n    private void initRepository() throws ServletException {\n        // get repository config\n        File repHome;\n        try {\n            repHome = new File(config.getRepositoryHome()).getCanonicalFile();\n        } catch (IOException e) {\n            throw new ServletExceptionWithCause(\n                    \"Repository configuration failure: \" + config.getRepositoryHome(), e);\n        }\n        String repConfig = config.getRepositoryConfig();\n        if (repConfig != null) { // Jackrabbit Classic\n            InputStream in = getServletContext().getResourceAsStream(repConfig);\n            if (in == null) {\n                try {\n                    in = new FileInputStream(new File(repConfig));\n                } catch (FileNotFoundException e) {\n                    // fallback to old config\n                    try {\n                        in = new FileInputStream(new File(repHome, repConfig));\n                    } catch (FileNotFoundException e1) {\n                        throw new ServletExceptionWithCause(\n                                \"Repository configuration not found: \" + repConfig, e);\n                    }\n                }\n            }\n\n            try {\n                repository = createRepository(new InputSource(in), repHome);\n            } catch (RepositoryException e) {\n                throw new ServletExceptionWithCause(\"Error while creating repository\", e);\n            }\n        } else { // Jackrabbit Oak\n            try {\n                String model = System.getProperty(\"sun.arch.data.model\", \"32\");\n                store = new FileStore(repHome, 256, \"64\".equals(model));\n                repository = new Jcr(new SegmentNodeStore(store)).createRepository();\n            } catch (IOException e) {\n                throw new ServletExceptionWithCause(\"Error while creating repository\", e);\n            }\n        }\n    }","id":93082,"modified_method":"/**\n     * Creates a new Repository based on the configuration and initializes the\n     * {@link #repository} field if successful.\n     *\n     * @throws ServletException if an error occurs\n     */\n    private void initRepository() throws ServletException {\n        // get repository config\n        File repHome;\n        try {\n            repHome = new File(config.getRepositoryHome()).getCanonicalFile();\n        } catch (IOException e) {\n            throw new ServletExceptionWithCause(\n                    \"Repository configuration failure: \" + config.getRepositoryHome(), e);\n        }\n        String repConfig = config.getRepositoryConfig();\n        if (repConfig != null) {\n            File configJson = new File(repHome, repConfig);\n            if (!configJson.exists()){\n                InputStream in = getServletContext().getResourceAsStream(repConfig);\n                if (in == null){\n                    throw new ServletException(\"No config file found in classpath \" + repConfig);\n                }\n                OutputStream os = null;\n                try {\n                    os = FileUtils.openOutputStream(configJson);\n                    IOUtils.copy(in, os);\n                } catch (IOException e1) {\n                    throw new ServletExceptionWithCause(\n                            \"Error copying the repository config json\", e1);\n                } finally {\n                    IOUtils.closeQuietly(os);\n                    IOUtils.closeQuietly(in);\n                }\n            }\n\n            try {\n                repository = createRepository(configJson, repHome);\n            } catch (RepositoryException e) {\n                throw new ServletExceptionWithCause(\"Error while creating repository\", e);\n            }\n        }\n    }","commit_id":"49ce807e8e08b4170febc2ac3108e6e4494132de","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Create an order by node as required by the statement and make it a parent of root.\n     * @param parsedStmt  Parsed statement, for context\n     * @param root        The root of the plan needing ordering\n     * @return new orderByNode (the new root) or the original root if no orderByNode was required.\n     */\n    private static AbstractPlanNode handleOrderBy(AbstractParsedStmt parsedStmt, AbstractPlanNode root) {\n        assert (parsedStmt instanceof ParsedSelectStmt || parsedStmt instanceof ParsedUnionStmt ||\n                parsedStmt instanceof ParsedDeleteStmt);\n\n        if (! isOrderByNodeRequired(parsedStmt, root)) {\n            return root;\n        }\n\n        OrderByPlanNode orderByNode = buildOrderByPlanNode(parsedStmt.orderByColumns());\n        orderByNode.addAndLinkChild(root);\n        return orderByNode;\n    }","id":93083,"modified_method":"/**\n     * Create an order by node as required by the statement and make it a parent of root.\n     * @param parsedStmt  Parsed statement, for context\n     * @param root        The root of the plan needing ordering\n     * @return new orderByNode (the new root) or the original root if no orderByNode was required.\n     */\n    private static AbstractPlanNode handleOrderBy(AbstractParsedStmt parsedStmt, AbstractPlanNode root) {\n        assert (parsedStmt instanceof ParsedSelectStmt || parsedStmt instanceof ParsedUnionStmt ||\n                parsedStmt instanceof ParsedDeleteStmt);\n\n        if (! isOrderByNodeRequired(parsedStmt, root)) {\n            return root;\n        }\n\n        // For MP queries, the coordinator's OrderBy node can be replaced with a specialized Receive node\n        // that merges individual partitions results if the they are sorted\n        // in the order matching the ORDER BY order\n        boolean canMergeReceive = false;\n        if (PlanNodeType.RECEIVE == root.getPlanNodeType()) {\n            assert(root.getChildCount() == 1);\n            assert(root.getChild(0).getChildCount() == 1);\n            AbstractPlanNode child = root.getChild(0).getChild(0);\n            if (! isOrderByNodeRequired(parsedStmt, child)) {\n                canMergeReceive = true;\n            }\n        }\n\n        OrderByPlanNode orderByNode = buildOrderByPlanNode(parsedStmt.orderByColumns());\n        if (canMergeReceive) {\n            // The root is the Receive node. We just checked it.\n            ReceivePlanNode receive = (ReceivePlanNode) root;\n            receive.setNeedMerge(true);\n            receive.addInlinePlanNode(orderByNode);\n            return receive;\n        } else {\n            orderByNode.addAndLinkChild(root);\n            return orderByNode;\n        }\n    }","commit_id":"7c33801672f2f135801e4888077b0006c6f4ed3b","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void loadFromJSONObject( JSONObject jobj, Database db ) throws JSONException {\n        helpLoadFromJSONObject(jobj, db);\n    }","id":93084,"modified_method":"@Override\n    public void loadFromJSONObject( JSONObject jobj, Database db ) throws JSONException {\n        helpLoadFromJSONObject(jobj, db);\n        if (jobj.has(Members.NEED_MERGE.name())) {\n            m_needMerge = jobj.getBoolean(Members.NEED_MERGE.name());\n        }\n    }","commit_id":"7c33801672f2f135801e4888077b0006c6f4ed3b","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void toJSONString(JSONStringer stringer) throws JSONException {\n        super.toJSONString(stringer);\n    }","id":93085,"modified_method":"@Override\n    public void toJSONString(JSONStringer stringer) throws JSONException {\n        super.toJSONString(stringer);\n        if (m_needMerge == true) {\n            stringer.key(Members.NEED_MERGE.name()).value(m_needMerge);\n        }\n    }","commit_id":"7c33801672f2f135801e4888077b0006c6f4ed3b","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void test(boolean sensitiveResourceVisible, StandardRole... roles) {\n        ModelNode operation = Util.createOperation(READ_RESOURCE_OPERATION, EMPTY_ADDRESS);\n        operation.get(RECURSIVE).set(true);\n        ModelNode result = executeWithRoles(operation, roles);\n\n        assertEquals(SUCCESS, result.get(OUTCOME).asString());\n        assertTrue(result.get(RESULT, UNCONSTRAINED_RESOURCE).has(FOO));\n        assertTrue(result.get(RESULT, UNCONSTRAINED_RESOURCE).has(BAR));\n        assertEquals(sensitiveResourceVisible, result.get(RESULT, SENSITIVE_CONSTRAINED_RESOURCE).has(FOO));\n        assertEquals(sensitiveResourceVisible, result.get(RESULT, SENSITIVE_CONSTRAINED_RESOURCE).has(BAR));\n\n        // lthon asks: is this format stable? testing it isn't that important anyway...\n        // BES 2013/07/08 Yes, it's stable and needs testing as automated clients will be relying on it\n        assertEquals(!sensitiveResourceVisible, result.get(RESPONSE_HEADERS, \"access-control\").get(0)\n                .get(\"filtered-children-types\").get(0).asString().equals(SENSITIVE_CONSTRAINED_RESOURCE));\n    }","id":93086,"modified_method":"private void test(boolean sensitiveResourceVisible, StandardRole... roles) {\n        ModelNode operation = Util.createOperation(READ_RESOURCE_OPERATION, EMPTY_ADDRESS);\n        operation.get(RECURSIVE).set(true);\n        ModelNode result = executeWithRoles(operation, roles);\n\n        assertEquals(SUCCESS, result.get(OUTCOME).asString());\n        assertTrue(result.get(RESULT, UNCONSTRAINED_RESOURCE).has(FOO));\n        assertTrue(result.get(RESULT, UNCONSTRAINED_RESOURCE).has(BAR));\n        assertEquals(sensitiveResourceVisible, result.get(RESULT, SENSITIVE_CONSTRAINED_RESOURCE).has(FOO));\n        assertEquals(sensitiveResourceVisible, result.get(RESULT, SENSITIVE_CONSTRAINED_RESOURCE).has(BAR));\n\n        // lthon asks: is this format stable? testing it isn't that important anyway...\n        // BES 2013/07/08 Yes, it's stable and needs testing as automated clients will be relying on it\n        assertEquals(!sensitiveResourceVisible, result.get(RESPONSE_HEADERS, ACCESS_CONTROL).get(0)\n                .get(\"filtered-children-types\").get(0).asString().equals(SENSITIVE_CONSTRAINED_RESOURCE));\n    }","commit_id":"75ad474c2ad5feac1b1e8dc1d781bb2bb04ab4a3","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        validator.validate(operation);\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String childType = operation.require(GlobalOperationHandlers.CHILD_TYPE.getName()).asString();\n        final Resource resource = context.readResource(PathAddress.EMPTY_ADDRESS, false);\n        ImmutableManagementResourceRegistration registry = context.getResourceRegistration();\n        Map<String, Set<String>> childAddresses = GlobalOperationHandlers.getChildAddresses(context, address, registry, resource, childType);\n        Set<String> childNames = childAddresses.get(childType);\n        if (childNames == null) {\n            throw new OperationFailedException(new ModelNode().set(MESSAGES.unknownChildType(childType)));\n        }\n        // Sort the result\n        childNames = new TreeSet<String>(childNames);\n        ModelNode result = context.getResult();\n        result.setEmptyList();\n        for (String childName : childNames) {\n            result.add(childName);\n        }\n\n        context.stepCompleted();\n    }","id":93087,"modified_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String childType = GlobalOperationHandlers.CHILD_TYPE.resolveModelAttribute(context, operation).asString();\n        final Resource resource = context.readResource(PathAddress.EMPTY_ADDRESS, false);\n        ImmutableManagementResourceRegistration registry = context.getResourceRegistration();\n        Map<String, Set<String>> childAddresses = GlobalOperationHandlers.getChildAddresses(context, address, registry, resource, childType);\n        Set<String> childNames = childAddresses.get(childType);\n        if (childNames == null) {\n            throw new OperationFailedException(new ModelNode().set(MESSAGES.unknownChildType(childType)));\n        }\n        // Sort the result\n        childNames = new TreeSet<String>(childNames);\n        ModelNode result = context.getResult();\n        result.setEmptyList();\n        PathAddress childAddress = address.append(PathElement.pathElement(childType));\n        ModelNode op = Util.createEmptyOperation(READ_RESOURCE_OPERATION, childAddress);\n        op.get(OPERATION_HEADERS).set(operation.get(OPERATION_HEADERS));\n        ModelNode opAddr = op.get(OP_ADDR);\n        ModelNode childProperty = opAddr.require(address.size());\n        Set<Action.ActionEffect> actionEffects = EnumSet.of(Action.ActionEffect.ADDRESS);\n        FilteredData fd = null;\n        for (String childName : childNames) {\n            childProperty.set(childType, new ModelNode(childName));\n            if (context.authorize(op, actionEffects).getDecision() == AuthorizationResult.Decision.PERMIT) {\n                result.add(childName);\n            } else {\n                if (fd == null) {\n                    fd = new FilteredData(address);\n                }\n                fd.addAccessRestrictedResource(PathAddress.pathAddress(opAddr));\n            }\n        }\n\n        if (fd != null) {\n            context.getResponseHeaders().get(ACCESS_CONTROL).set(fd.toModelNode());\n        }\n\n        context.stepCompleted();\n    }","commit_id":"75ad474c2ad5feac1b1e8dc1d781bb2bb04ab4a3","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n            context.addStep(new OperationStepHandler() {\n                @Override\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    Map<String, ModelNode> sortedChildren = new TreeMap<String, ModelNode>();\n                    boolean failed = false;\n                    for (Map.Entry<PathElement, ModelNode> entry : resources.entrySet()) {\n                        PathElement path = entry.getKey();\n                        ModelNode value = entry.getValue();\n                        if (!value.has(FAILURE_DESCRIPTION)) {\n                            sortedChildren.put(path.getValue(), value.get(RESULT));\n                        } else if (!failed && value.hasDefined(FAILURE_DESCRIPTION)) {\n                            context.getFailureDescription().set(value.get(FAILURE_DESCRIPTION));\n                            failed = true;\n                        }\n                    }\n                    if (!failed) {\n                        final ModelNode result = context.getResult();\n                        result.setEmptyObject();\n\n                        for (Map.Entry<String, ModelNode> entry : sortedChildren.entrySet()) {\n                            result.get(entry.getKey()).set(entry.getValue());\n                        }\n                    }\n\n                    context.stepCompleted();\n                }\n            }, OperationContext.Stage.VERIFY);\n\n            context.stepCompleted();\n        }","id":93088,"modified_method":"@Override\n        public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n            context.addStep(new OperationStepHandler() {\n                @Override\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    Map<String, ModelNode> sortedChildren = new TreeMap<String, ModelNode>();\n                    boolean failed = false;\n                    for (Map.Entry<PathElement, ModelNode> entry : resources.entrySet()) {\n                        PathElement path = entry.getKey();\n                        ModelNode value = entry.getValue();\n                        if (!value.has(FAILURE_DESCRIPTION)) {\n                            sortedChildren.put(path.getValue(), value.get(RESULT));\n                        } else if (!failed && value.hasDefined(FAILURE_DESCRIPTION)) {\n                            context.getFailureDescription().set(value.get(FAILURE_DESCRIPTION));\n                            failed = true;\n                        }\n                    }\n\n                    if (!failed) {\n                        boolean hasFilteredData = filteredData.hasFilteredData();\n                        final ModelNode result = context.getResult();\n                        result.setEmptyObject();\n\n                        for (Map.Entry<String, ModelNode> entry : sortedChildren.entrySet()) {\n                            if (!hasFilteredData || !filteredData.isAddressFiltered(address, PathElement.pathElement(childType, entry.getKey()))) {\n                                result.get(entry.getKey()).set(entry.getValue());\n                            }\n                        }\n\n                        if (hasFilteredData) {\n                            context.getResponseHeaders().get(ACCESS_CONTROL).set(filteredData.toModelNode());\n                        }\n                    }\n\n                    context.stepCompleted();\n                }\n            }, OperationContext.Stage.VERIFY);\n\n            context.stepCompleted();\n        }","commit_id":"75ad474c2ad5feac1b1e8dc1d781bb2bb04ab4a3","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * Creates a ReadResourceAssemblyHandler that will assemble the response using the contents\n         * of the given maps.\n         *\n         * @param resources read-resource response from child resources, where the key is the path of the resource\n         *                  relative to the address of the operation this handler is handling and the\n         *                  value is the full read-resource response. Will not be {@code null}\n         */\n        public ReadChildrenResourcesAssemblyHandler(final Map<PathElement, ModelNode> resources) {\n            this.resources = resources;\n        }","id":93089,"modified_method":"/**\n         * Creates a ReadResourceAssemblyHandler that will assemble the response using the contents\n         * of the given maps.\n         *\n         * @param resources read-resource response from child resources, where the key is the path of the resource\n         *                  relative to the address of the operation this handler is handling and the\n         *                  value is the full read-resource response. Will not be {@code null}\n         * @param filteredData record of any excluded data\n         * @param address    the address of the targeted resource\n         * @param childType  the type of child being read\n         */\n        private ReadChildrenResourcesAssemblyHandler(final Map<PathElement, ModelNode> resources, FilteredData filteredData,\n                                                     PathAddress address, String childType) {\n            this.resources = resources;\n            this.filteredData = filteredData;\n            this.address = address;\n            this.childType = childType;\n        }","commit_id":"75ad474c2ad5feac1b1e8dc1d781bb2bb04ab4a3","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        validator.validate(operation);\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String childType = operation.require(GlobalOperationHandlers.CHILD_TYPE.getName()).asString();\n\n        final Map<PathElement, ModelNode> resources = new HashMap<PathElement, ModelNode>();\n\n        final Resource resource = context.readResource(PathAddress.EMPTY_ADDRESS, false);\n        final ImmutableManagementResourceRegistration registry = context.getResourceRegistration();\n        Map<String, Set<String>> childAddresses = GlobalOperationHandlers.getChildAddresses(context, address, registry, resource, childType);\n        Set<String> childNames = childAddresses.get(childType);\n        if (childNames == null) {\n            throw new OperationFailedException(new ModelNode().set(MESSAGES.unknownChildType(childType)));\n        }\n        // We're going to add a bunch of steps that should immediately follow this one. We are going to add them\n        // in reverse order of how they should execute, as that is the way adding a Stage.IMMEDIATE step works\n\n        // Last to execute is the handler that assembles the overall response from the pieces created by all the other steps\n        final ReadChildrenResourcesAssemblyHandler assemblyHandler = new ReadChildrenResourcesAssemblyHandler(resources);\n        context.addStep(assemblyHandler, OperationContext.Stage.MODEL, true);\n\n        for (final String key : childNames) {\n            final PathElement childPath = PathElement.pathElement(childType, key);\n            final PathAddress childAddress = PathAddress.EMPTY_ADDRESS.append(PathElement.pathElement(childType, key));\n\n            final ModelNode readOp = new ModelNode();\n            readOp.get(OP).set(READ_RESOURCE_OPERATION);\n            readOp.get(OP_ADDR).set(PathAddress.pathAddress(address, childPath).toModelNode());\n            GlobalOperationHandlers.INCLUDE_RUNTIME.validateAndSet(operation, readOp);\n            GlobalOperationHandlers.RECURSIVE.validateAndSet(operation, readOp);\n            GlobalOperationHandlers.RECURSIVE_DEPTH.validateAndSet(operation, readOp);\n            GlobalOperationHandlers.PROXIES.validateAndSet(operation, readOp);\n            GlobalOperationHandlers.INCLUDE_DEFAULTS.validateAndSet(operation, readOp);\n\n            final OperationStepHandler handler = context.getResourceRegistration().getOperationHandler(childAddress, READ_RESOURCE_OPERATION);\n            if (handler == null) {\n                throw new OperationFailedException(new ModelNode().set(MESSAGES.noOperationHandler()));\n            }\n            final ModelNode rrRsp = new ModelNode();\n            resources.put(childPath, rrRsp);\n            context.addStep(rrRsp, readOp, handler, OperationContext.Stage.MODEL, true);\n        }\n\n        context.stepCompleted();\n    }","id":93090,"modified_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String childType = GlobalOperationHandlers.CHILD_TYPE.resolveModelAttribute(context, operation).asString();\n\n        // Build up the op we're going to repeatedly execute\n        final ModelNode readOp = new ModelNode();\n        readOp.get(OP).set(READ_RESOURCE_OPERATION);\n        GlobalOperationHandlers.INCLUDE_RUNTIME.validateAndSet(operation, readOp);\n        GlobalOperationHandlers.RECURSIVE.validateAndSet(operation, readOp);\n        GlobalOperationHandlers.RECURSIVE_DEPTH.validateAndSet(operation, readOp);\n        GlobalOperationHandlers.PROXIES.validateAndSet(operation, readOp);\n        GlobalOperationHandlers.INCLUDE_DEFAULTS.validateAndSet(operation, readOp);\n\n        final Map<PathElement, ModelNode> resources = new HashMap<PathElement, ModelNode>();\n\n        final Resource resource = context.readResource(PathAddress.EMPTY_ADDRESS, false);\n        final ImmutableManagementResourceRegistration registry = context.getResourceRegistration();\n        Map<String, Set<String>> childAddresses = GlobalOperationHandlers.getChildAddresses(context, address, registry, resource, childType);\n        Set<String> childNames = childAddresses.get(childType);\n        if (childNames == null) {\n            throw new OperationFailedException(new ModelNode().set(MESSAGES.unknownChildType(childType)));\n        }\n\n        // Track any excluded items\n        FilteredData filteredData = new FilteredData(address);\n\n        // We're going to add a bunch of steps that should immediately follow this one. We are going to add them\n        // in reverse order of how they should execute, building up a stack.\n\n        // Last to execute is the handler that assembles the overall response from the pieces created by all the other steps\n        final ReadChildrenResourcesAssemblyHandler assemblyHandler = new ReadChildrenResourcesAssemblyHandler(resources, filteredData, address, childType);\n        context.addStep(assemblyHandler, OperationContext.Stage.MODEL, true);\n\n        for (final String key : childNames) {\n            final PathElement childPath = PathElement.pathElement(childType, key);\n            final PathAddress childAddress = PathAddress.EMPTY_ADDRESS.append(PathElement.pathElement(childType, key));\n\n            final ModelNode readResOp = readOp.clone();\n            readResOp.get(OP_ADDR).set(PathAddress.pathAddress(address, childPath).toModelNode());\n\n            // See if there was an override registered for the standard :read-resource handling (unlikely!!!)\n            OperationStepHandler overrideHandler = context.getResourceRegistration().getOperationHandler(childAddress, READ_RESOURCE_OPERATION);\n            if (overrideHandler == null) {\n                throw new OperationFailedException(new ModelNode().set(MESSAGES.noOperationHandler()));\n            } else if (overrideHandler.getClass() == ReadResourceHandler.class) {\n                // not an override\n                overrideHandler = null;\n            }\n            OperationStepHandler rrHandler = new ReadResourceHandler(filteredData, overrideHandler);\n            final ModelNode rrRsp = new ModelNode();\n            resources.put(childPath, rrRsp);\n            context.addStep(rrRsp, readResOp, rrHandler, OperationContext.Stage.MODEL, true);\n        }\n\n        context.stepCompleted();\n    }","commit_id":"75ad474c2ad5feac1b1e8dc1d781bb2bb04ab4a3","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n            Map<String, ModelNode> sortedAttributes = new TreeMap<String, ModelNode>();\n            Map<String, ModelNode> sortedChildren = new TreeMap<String, ModelNode>();\n            boolean failed = false;\n            for (Map.Entry<String, ModelNode> entry : otherAttributes.entrySet()) {\n                ModelNode value = entry.getValue();\n                if (!value.has(FAILURE_DESCRIPTION)) {\n                    sortedAttributes.put(entry.getKey(), value.get(RESULT));\n                } else if (value.hasDefined(FAILURE_DESCRIPTION)) {\n                    context.getFailureDescription().set(value.get(FAILURE_DESCRIPTION));\n                    failed = true;\n                    break;\n                }\n            }\n            if (!failed) {\n                for (Map.Entry<PathElement, ModelNode> entry : childResources.entrySet()) {\n                    PathElement path = entry.getKey();\n                    ModelNode value = entry.getValue();\n                    if (!value.has(FAILURE_DESCRIPTION)) {\n                        ModelNode childTypeNode = sortedChildren.get(path.getKey());\n                        if (childTypeNode == null) {\n                            childTypeNode = new ModelNode();\n                            sortedChildren.put(path.getKey(), childTypeNode);\n                        }\n                        childTypeNode.get(path.getValue()).set(value.get(RESULT));\n                    } else if (!failed && value.hasDefined(FAILURE_DESCRIPTION)) {\n                        context.getFailureDescription().set(value.get(FAILURE_DESCRIPTION));\n                        failed = true;\n                    }\n                }\n            }\n            if (!failed) {\n                for (Map.Entry<String, ModelNode> directChild : directChildren.entrySet()) {\n                    sortedChildren.put(directChild.getKey(), directChild.getValue());\n                }\n                for (String nonExistentChildType : nonExistentChildTypes) {\n                    sortedChildren.put(nonExistentChildType, new ModelNode());\n                }\n                for (Map.Entry<String, ModelNode> metric : metrics.entrySet()) {\n                    ModelNode value = metric.getValue();\n                    if (!value.has(FAILURE_DESCRIPTION)) {\n                        sortedAttributes.put(metric.getKey(), value.get(RESULT));\n                    }\n                    // we ignore metric failures\n                    // TODO how to prevent the metric failure screwing up the overall context?\n                }\n\n                final ModelNode result = context.getResult();\n                result.setEmptyObject();\n                for (Map.Entry<String, ModelNode> entry : sortedAttributes.entrySet()) {\n                    result.get(entry.getKey()).set(entry.getValue());\n                }\n\n                for (Map.Entry<String, ModelNode> entry : sortedChildren.entrySet()) {\n                    if (!entry.getValue().isDefined()) {\n                        result.get(entry.getKey()).set(entry.getValue());\n                    } else {\n                        ModelNode childTypeNode = new ModelNode();\n                        for (Property property : entry.getValue().asPropertyList()) {\n                            PathElement pe = PathElement.pathElement(entry.getKey(), property.getName());\n                            if (!filteredData.isFilteredResource(address, pe)) {\n                                childTypeNode.get(property.getName()).set(property.getValue());\n                            }\n                        }\n                        result.get(entry.getKey()).set(childTypeNode);\n                    }\n                }\n\n                if (filteredData.hasFilteredData()) {\n                    context.getResponseHeaders().get(\"access-control\").set(filteredData.toModelNode());\n                }\n            }\n\n            context.stepCompleted();\n        }","id":93091,"modified_method":"@Override\n        public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n            Map<String, ModelNode> sortedAttributes = new TreeMap<String, ModelNode>();\n            Map<String, ModelNode> sortedChildren = new TreeMap<String, ModelNode>();\n            boolean failed = false;\n            for (Map.Entry<String, ModelNode> entry : otherAttributes.entrySet()) {\n                ModelNode value = entry.getValue();\n                if (!value.has(FAILURE_DESCRIPTION)) {\n                    sortedAttributes.put(entry.getKey(), value.get(RESULT));\n                } else if (value.hasDefined(FAILURE_DESCRIPTION)) {\n                    context.getFailureDescription().set(value.get(FAILURE_DESCRIPTION));\n                    failed = true;\n                    break;\n                }\n            }\n            if (!failed) {\n                for (Map.Entry<PathElement, ModelNode> entry : childResources.entrySet()) {\n                    PathElement path = entry.getKey();\n                    ModelNode value = entry.getValue();\n                    if (!value.has(FAILURE_DESCRIPTION)) {\n                        ModelNode childTypeNode = sortedChildren.get(path.getKey());\n                        if (childTypeNode == null) {\n                            childTypeNode = new ModelNode();\n                            sortedChildren.put(path.getKey(), childTypeNode);\n                        }\n                        childTypeNode.get(path.getValue()).set(value.get(RESULT));\n                    } else if (!failed && value.hasDefined(FAILURE_DESCRIPTION)) {\n                        context.getFailureDescription().set(value.get(FAILURE_DESCRIPTION));\n                        failed = true;\n                    }\n                }\n            }\n            if (!failed) {\n                for (Map.Entry<String, ModelNode> directChild : directChildren.entrySet()) {\n                    sortedChildren.put(directChild.getKey(), directChild.getValue());\n                }\n                for (String nonExistentChildType : nonExistentChildTypes) {\n                    sortedChildren.put(nonExistentChildType, new ModelNode());\n                }\n                for (Map.Entry<String, ModelNode> metric : metrics.entrySet()) {\n                    ModelNode value = metric.getValue();\n                    if (!value.has(FAILURE_DESCRIPTION)) {\n                        sortedAttributes.put(metric.getKey(), value.get(RESULT));\n                    }\n                    // we ignore metric failures\n                    // TODO how to prevent the metric failure screwing up the overall context?\n                }\n\n                final ModelNode result = context.getResult();\n                result.setEmptyObject();\n                for (Map.Entry<String, ModelNode> entry : sortedAttributes.entrySet()) {\n                    result.get(entry.getKey()).set(entry.getValue());\n                }\n\n                for (Map.Entry<String, ModelNode> entry : sortedChildren.entrySet()) {\n                    if (!entry.getValue().isDefined()) {\n                        result.get(entry.getKey()).set(entry.getValue());\n                    } else {\n                        ModelNode childTypeNode = new ModelNode();\n                        for (Property property : entry.getValue().asPropertyList()) {\n                            PathElement pe = PathElement.pathElement(entry.getKey(), property.getName());\n                            if (!filteredData.isFilteredResource(address, pe)) {\n                                childTypeNode.get(property.getName()).set(property.getValue());\n                            }\n                        }\n                        result.get(entry.getKey()).set(childTypeNode);\n                    }\n                }\n\n                if (filteredData.hasFilteredData()) {\n                    context.getResponseHeaders().get(ACCESS_CONTROL).set(filteredData.toModelNode());\n                }\n            }\n\n            context.stepCompleted();\n        }","commit_id":"75ad474c2ad5feac1b1e8dc1d781bb2bb04ab4a3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Map<Integer, String> getReportList() {\n        LinkedHashMap<Integer, String> reports = new LinkedHashMap<Integer, String>(m_config.getReportCount());\n\n        for (Report report : m_config.getReportCollection()) {\n            reports.put(report.getId(), report.getTitle());\n        }\n        \n        return reports;\n    }","id":93092,"modified_method":"public Map<Integer, String> getReportList() {\n        LinkedHashMap<Integer, String> reports = new LinkedHashMap<Integer, String>(m_config.getReportCount());\n\n        List<Report> reportList = m_config.getReportCollection();\n        Collections.sort(reportList, new Comparator<Report>() {\n            public int compare(Report o1, Report o2) {\n                return o1.getTitle().compareTo(o2.getTitle());\n            }\n        });\n        \n        for (Report report : reportList) {\n            reports.put(report.getId(), report.getTitle());\n        }\n        \n        return reports;\n    }","commit_id":"a3b3bf0bbbbc6299c7d3dfaa82dad31139b3c557","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the KSC_PerformanceReport.xml via the Castor classes.\n     * */\n    public synchronized void reload() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        s_configFile = ConfigFileConstants.getFile(ConfigFileConstants.KSC_REPORT_FILE_NAME);\n\n        FileReader rdr = new FileReader(s_configFile);\n        try {\n            m_config = CastorUtils.unmarshal(ReportsList.class, rdr);\n        } finally {\n            IOUtils.closeQuietly(rdr);\n        }\n        \n        setIdsOnAllReports();\n        \n        m_reportList = createReportList();\n    }","id":93093,"modified_method":"/**\n     * Parses the KSC_PerformanceReport.xml via the Castor classes.\n     * */\n    public synchronized void reload() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        s_configFile = ConfigFileConstants.getFile(ConfigFileConstants.KSC_REPORT_FILE_NAME);\n\n        m_config = CastorUtils.unmarshal(ReportsList.class, new FileSystemResource(s_configFile));\n        \n        setIdsOnAllReports();\n        \n        m_reportList = createReportList();\n    }","commit_id":"a3b3bf0bbbbc6299c7d3dfaa82dad31139b3c557","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Saves the KSC_PerformanceReport.xml data.\n     * */\n    public synchronized void saveCurrent() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        assertInitialized();\n\n        sortByTitle();\n        \n        /*\n         * Marshall to a string first, then to file. This way the original\n         * config is not lost if the XML from the marshall is hosed.\n         */\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(m_config, stringWriter);\n        if (stringWriter.toString() != null) {\n            FileWriter fileWriter = new FileWriter(s_configFile);\n            fileWriter.write(stringWriter.toString());\n            fileWriter.flush();\n            fileWriter.close();\n        }\n        \n        reload();\n    }","id":93094,"modified_method":"/**\n     * Saves the KSC_PerformanceReport.xml data.\n     * */\n    public synchronized void saveCurrent() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        assertInitialized();\n\n        sortByTitle();\n        \n        CastorUtils.marshalViaString(m_config, s_configFile);\n        \n        reload();\n    }","commit_id":"a3b3bf0bbbbc6299c7d3dfaa82dad31139b3c557","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the KSC_PerformanceReport.xml via the Castor classes.\n     * */\n    public synchronized void reload() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        s_configFile = ConfigFileConstants.getFile(ConfigFileConstants.KSC_REPORT_FILE_NAME);\n\n        FileReader rdr = new FileReader(s_configFile);\n        try {\n            m_config = CastorUtils.unmarshal(ReportsList.class, rdr);\n        } finally {\n            IOUtils.closeQuietly(rdr);\n        }\n        \n        setIdsOnAllReports();\n        \n        m_reportList = createReportList();\n    }","id":93095,"modified_method":"/**\n     * Parses the KSC_PerformanceReport.xml via the Castor classes.\n     * */\n    public synchronized void reload() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        s_configFile = ConfigFileConstants.getFile(ConfigFileConstants.KSC_REPORT_FILE_NAME);\n\n        m_config = CastorUtils.unmarshal(ReportsList.class, new FileSystemResource(s_configFile));\n        \n        setIdsOnAllReports();\n        \n        m_reportList = createReportList();\n    }","commit_id":"abaf88e60a695b6bdb3262ec4a5ceccf4cf5452c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Saves the KSC_PerformanceReport.xml data.\n     * */\n    public synchronized void saveCurrent() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        assertInitialized();\n\n        sortByTitle();\n        \n        /*\n         * Marshall to a string first, then to file. This way the original\n         * config is not lost if the XML from the marshall is hosed.\n         */\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(m_config, stringWriter);\n        if (stringWriter.toString() != null) {\n            FileWriter fileWriter = new FileWriter(s_configFile);\n            fileWriter.write(stringWriter.toString());\n            fileWriter.flush();\n            fileWriter.close();\n        }\n        \n        reload();\n    }","id":93096,"modified_method":"/**\n     * Saves the KSC_PerformanceReport.xml data.\n     * */\n    public synchronized void saveCurrent() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        assertInitialized();\n\n        sortByTitle();\n        \n        CastorUtils.marshalViaString(m_config, s_configFile);\n        \n        reload();\n    }","commit_id":"abaf88e60a695b6bdb3262ec4a5ceccf4cf5452c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Map<Integer, String> getReportList() {\n        LinkedHashMap<Integer, String> reports = new LinkedHashMap<Integer, String>(m_config.getReportCount());\n\n        for (Report report : m_config.getReportCollection()) {\n            reports.put(report.getId(), report.getTitle());\n        }\n        \n        return reports;\n    }","id":93097,"modified_method":"public Map<Integer, String> getReportList() {\n        LinkedHashMap<Integer, String> reports = new LinkedHashMap<Integer, String>(m_config.getReportCount());\n\n        List<Report> reportList = m_config.getReportCollection();\n        Collections.sort(reportList, new Comparator<Report>() {\n            public int compare(Report o1, Report o2) {\n                return o1.getTitle().compareTo(o2.getTitle());\n            }\n        });\n        \n        for (Report report : reportList) {\n            reports.put(report.getId(), report.getTitle());\n        }\n        \n        return reports;\n    }","commit_id":"abaf88e60a695b6bdb3262ec4a5ceccf4cf5452c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Map<Integer, String> getReportList() {\n        LinkedHashMap<Integer, String> reports = new LinkedHashMap<Integer, String>(m_config.getReportCount());\n\n        for (Report report : m_config.getReportCollection()) {\n            reports.put(report.getId(), report.getTitle());\n        }\n        \n        return reports;\n    }","id":93098,"modified_method":"public Map<Integer, String> getReportList() {\n        LinkedHashMap<Integer, String> reports = new LinkedHashMap<Integer, String>(m_config.getReportCount());\n\n        List<Report> reportList = m_config.getReportCollection();\n        Collections.sort(reportList, new Comparator<Report>() {\n            public int compare(Report o1, Report o2) {\n                return o1.getTitle().compareTo(o2.getTitle());\n            }\n        });\n        \n        for (Report report : reportList) {\n            reports.put(report.getId(), report.getTitle());\n        }\n        \n        return reports;\n    }","commit_id":"370b5d261aded3a3d55eb23f0276c2bc2b83a166","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Saves the KSC_PerformanceReport.xml data.\n     * */\n    public synchronized void saveCurrent() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        assertInitialized();\n\n        sortByTitle();\n        \n        /*\n         * Marshall to a string first, then to file. This way the original\n         * config is not lost if the XML from the marshall is hosed.\n         */\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(m_config, stringWriter);\n        if (stringWriter.toString() != null) {\n            FileWriter fileWriter = new FileWriter(s_configFile);\n            fileWriter.write(stringWriter.toString());\n            fileWriter.flush();\n            fileWriter.close();\n        }\n        \n        reload();\n    }","id":93099,"modified_method":"/**\n     * Saves the KSC_PerformanceReport.xml data.\n     * */\n    public synchronized void saveCurrent() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        assertInitialized();\n\n        sortByTitle();\n        \n        CastorUtils.marshalViaString(m_config, s_configFile);\n        \n        reload();\n    }","commit_id":"370b5d261aded3a3d55eb23f0276c2bc2b83a166","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the KSC_PerformanceReport.xml via the Castor classes.\n     * */\n    public synchronized void reload() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        s_configFile = ConfigFileConstants.getFile(ConfigFileConstants.KSC_REPORT_FILE_NAME);\n\n        FileReader rdr = new FileReader(s_configFile);\n        try {\n            m_config = CastorUtils.unmarshal(ReportsList.class, rdr);\n        } finally {\n            IOUtils.closeQuietly(rdr);\n        }\n        \n        setIdsOnAllReports();\n        \n        m_reportList = createReportList();\n    }","id":93100,"modified_method":"/**\n     * Parses the KSC_PerformanceReport.xml via the Castor classes.\n     * */\n    public synchronized void reload() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        s_configFile = ConfigFileConstants.getFile(ConfigFileConstants.KSC_REPORT_FILE_NAME);\n\n        m_config = CastorUtils.unmarshal(ReportsList.class, new FileSystemResource(s_configFile));\n        \n        setIdsOnAllReports();\n        \n        m_reportList = createReportList();\n    }","commit_id":"370b5d261aded3a3d55eb23f0276c2bc2b83a166","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected Destination getReplyToDestination(Message message, Session session, MuleEvent event, boolean remoteSync, boolean topic) throws JMSException, EndpointException, InitialisationException\n    {\n        Destination replyTo = null;\n\n        // Some JMS implementations might not support the ReplyTo property.\n        if (isHandleReplyTo(message, event))\n        {\n\n            Object tempReplyTo = event.getMessage().removeProperty(JmsConstants.JMS_REPLY_TO);\n            if (tempReplyTo == null)\n            {\n                //It may be a Mule URI or global endpoint Ref\n                tempReplyTo = event.getMessage().removeProperty(MuleProperties.MULE_REPLY_TO_PROPERTY);\n                if (tempReplyTo != null)\n                {\n                    if (tempReplyTo.toString().startsWith(\"jms://\"))\n                    {\n                        tempReplyTo = tempReplyTo.toString().substring(6);\n                    }\n                    else\n                    {\n                        EndpointBuilder epb = event.getMuleContext().getRegistry().lookupEndpointBuilder(tempReplyTo.toString());\n                        if (epb != null)\n                        {\n                            tempReplyTo = epb.buildOutboundEndpoint().getEndpointURI().getAddress();\n                        }\n                    }\n                }\n            }\n            if (tempReplyTo != null)\n            {\n                if (tempReplyTo instanceof Destination)\n                {\n                    replyTo = (Destination) tempReplyTo;\n                }\n                else\n                {\n                    // TODO AP should this drill-down be moved into the resolver as well?\n                    boolean replyToTopic = false;\n                    String reply = tempReplyTo.toString();\n                    int i = reply.indexOf(\":\");\n                    if (i > -1)\n                    {\n                        // TODO MULE-1409 this check will not work for ActiveMQ 4.x,\n                        // as they have temp-queue://<destination> and temp-topic://<destination> URIs\n                        // Extract to a custom resolver for ActiveMQ4.x\n                        // The code path can be exercised, e.g. by a LoanBrokerESBTestCase\n                        String qtype = reply.substring(0, i);\n                        replyToTopic = JmsConstants.TOPIC_PROPERTY.equalsIgnoreCase(qtype);\n                        reply = reply.substring(i + 1);\n                    }\n                    replyTo = connector.getJmsSupport().createDestination(session, reply, replyToTopic);\n                }\n            }\n            // Are we going to wait for a return event ?\n            if (remoteSync && replyTo == null && !disableTemporaryDestinations)\n            {\n                replyTo = connector.getJmsSupport().createTemporaryDestination(session, topic);\n            }\n        }\n        return replyTo;\n\n    }","id":93101,"modified_method":"protected Destination getReplyToDestination(Message message, Session session, MuleEvent event, boolean remoteSync, boolean topic) throws JMSException, EndpointException, InitialisationException\n    {\n        Destination replyTo = null;\n\n        // Some JMS implementations might not support the ReplyTo property.\n        if (isHandleReplyTo(message, event))\n        {\n\n            Object tempReplyTo = event.getMessage().removeProperty(JmsConstants.JMS_REPLY_TO);\n            if (tempReplyTo == null)\n            {\n                //It may be a Mule URI or global endpoint Ref\n                tempReplyTo = event.getMessage().removeProperty(MuleProperties.MULE_REPLY_TO_PROPERTY);\n                if (tempReplyTo != null)\n                {\n                    int i = tempReplyTo.toString().indexOf(\"://\");\n                    if(i > -1)\n                    {\n                        tempReplyTo = tempReplyTo.toString().substring(i+3);\n                    }\n                    else\n                    {\n                        EndpointBuilder epb = event.getMuleContext().getRegistry().lookupEndpointBuilder(tempReplyTo.toString());\n                        if (epb != null)\n                        {\n                            tempReplyTo = epb.buildOutboundEndpoint().getEndpointURI().getAddress();\n                        }\n                    }\n                }\n            }\n            if (tempReplyTo != null)\n            {\n                if (tempReplyTo instanceof Destination)\n                {\n                    replyTo = (Destination) tempReplyTo;\n                }\n                else\n                {\n                    // TODO AP should this drill-down be moved into the resolver as well?\n                    boolean replyToTopic = false;\n                    String reply = tempReplyTo.toString();\n                    int i = reply.indexOf(\":\");\n                    if (i > -1)\n                    {\n                        // TODO MULE-1409 this check will not work for ActiveMQ 4.x,\n                        // as they have temp-queue://<destination> and temp-topic://<destination> URIs\n                        // Extract to a custom resolver for ActiveMQ4.x\n                        // The code path can be exercised, e.g. by a LoanBrokerESBTestCase\n                        String qtype = reply.substring(0, i);\n                        replyToTopic = JmsConstants.TOPIC_PROPERTY.equalsIgnoreCase(qtype);\n                        reply = reply.substring(i + 1);\n                    }\n                    replyTo = connector.getJmsSupport().createDestination(session, reply, replyToTopic);\n                }\n            }\n            // Are we going to wait for a return event ?\n            if (remoteSync && replyTo == null && !disableTemporaryDestinations)\n            {\n                replyTo = connector.getJmsSupport().createTemporaryDestination(session, topic);\n            }\n        }\n        return replyTo;\n\n    }","commit_id":"d13fd2b267bbc948c369e8e01d465017b94c41b4","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * System property replacement in the given string.\n     * \n     * @param str The original string\n     * @return the modified string\n     */\n    protected String replace(String str) {\n        String result = str;\n        if (result.startsWith(\"${\")) {\n            int pos = result.indexOf('}');\n            if (pos != -1) {\n                String propName = result.substring(2, pos);\n                String replacement = System.getProperty(propName);\n                if (replacement != null) {\n                    result = replacement + result.substring(pos + 1);\n                }\n            }\n        }\n        return result;\n    }","id":93102,"modified_method":"/**\n     * System property replacement in the given string.\n     * \n     * @param str The original string\n     * @return the modified string\n     */\n    protected String replace(String str) {\n        String result = str;\n        int pos_start = result.indexOf(\"${\");\n        if (pos_start != -1) {\n            int pos_end = result.indexOf('}');\n            if (pos_end != -1) {\n                String propName = result.substring(pos_start + 2, pos_end);\n                String replacement = System.getProperty(propName);\n                if (replacement != null) {\n                    if(pos_start >0) {\n                        result = result.substring(0,pos_start) + \n                            replacement + replace(result.substring(pos_end + 1));\n                    } else {                       \n                        result = replacement + replace(result.substring(pos_end + 1));\n                    }\n                }\n            }\n        }\n        return result;\n    }","commit_id":"a6929e4e312056832888819f86fe5aac47de7e36","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n   * Aggregates and sets nagios properties on a resource.\n   * @param res the resource\n   * @param matchValue the value to match\n   * @param allAlerts all alerts from Nagios\n   * @param requestedIds the requested ids for the resource\n   */\n  private void updateAlerts(Resource res, String matchValue, List<NagiosAlert> allAlerts,\n      Set<String> requestedIds) {\n    if (null == allAlerts || 0 == allAlerts.size())\n      return;\n    \n    int ok = 0;\n    int warning = 0;\n    int critical = 0;\n    int passive = 0;\n    \n    List<Map<String, Object>> alerts = new ArrayList<Map<String, Object>>();\n    \n    for (NagiosAlert alert : allAlerts) {\n      boolean match = false;\n      \n      switch (resourceType.getInternalType()) {\n        case Service:\n          match = alert.getService().equals(matchValue);\n          if (match && null != alert.getDescription() &&\n              IGNORABLE_FOR_SERVICES.contains(alert.getDescription())) {\n            match = false;\n          }          \n          break;\n        case Host:\n          match = alert.getHost().equals(matchValue);\n          if (match && null != alert.getDescription()) {\n            String desc = alert.getDescription();\n            Iterator<String> it = IGNORABLE_FOR_HOSTS.iterator();\n            while (it.hasNext() && match) {\n              if (-1 != desc.toLowerCase().indexOf(it.next()))\n                match = false;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n      \n      if (match) {\n\n        // status = the return code from the plugin that controls\n        // whether an alert is sent out (0 when using wrapper)\n        // actual_status = the actual process result\n        \n        Map<String, Object> map = new LinkedHashMap<String, Object>();\n        \n        map.put(\"description\", alert.getDescription());\n        map.put(\"host_name\", alert.getHost());\n        map.put(\"last_status\", NagiosAlert.getStatusString(alert.getLastStatus()));\n        map.put(\"last_status_time\", Long.valueOf(alert.getLastStatusTime()));\n        map.put(\"service_name\", alert.getService());\n        map.put(\"status\", NagiosAlert.getStatusString(alert.getStatus()));\n        map.put(\"status_time\", Long.valueOf(alert.getStatusTime()));\n        map.put(\"output\", alert.getOutput());\n        map.put(\"actual_status\", NagiosAlert.getStatusString(alert.getStatus()));\n        \n        String longOut = alert.getLongPluginOutput();\n        if (null != longOut && longOut.startsWith(PASSIVE_TOKEN)) {\n          int actualStatus = 3;\n          try {\n            int len = PASSIVE_TOKEN.length();\n            actualStatus = Integer.parseInt(longOut.substring(len, len+1));\n          } catch (Exception e) {\n            // do nothing\n          }\n          \n          map.put(\"status\", \"PASSIVE\");\n          map.put(\"actual_status\", NagiosAlert.getStatusString(actualStatus));\n          passive++;\n        } else {\n          switch (alert.getStatus()) {\n          case 0:\n            ok++;\n            break;\n          case 1:\n            warning++;\n            break;\n          case 2:\n            critical++;\n            break;\n          default:\n            break;\n          }\n        }\n        \n        alerts.add(map);\n      }\n    }\n    \n    setResourceProperty(res, ALERT_SUMMARY_OK_PROPERTY_ID, Integer.valueOf(ok), requestedIds);\n    setResourceProperty(res, ALERT_SUMMARY_WARNING_PROPERTY_ID, Integer.valueOf(warning), requestedIds);\n    setResourceProperty(res, ALERT_SUMMARY_CRITICAL_PROPERTY_ID, Integer.valueOf(critical), requestedIds);\n    setResourceProperty(res, ALERT_SUMMARY_PASSIVE_PROPERTY_ID, Integer.valueOf(passive), requestedIds);\n    \n    if (!alerts.isEmpty())\n      setResourceProperty(res, ALERT_DETAIL_PROPERTY_ID, alerts, requestedIds);\n  }","id":93103,"modified_method":"/**\n   * Aggregates and sets nagios properties on a resource.\n   * @param res the resource\n   * @param matchValue the value to match\n   * @param allAlerts all alerts from Nagios\n   * @param requestedIds the requested ids for the resource\n   */\n  private void updateAlerts(Resource res, String matchValue, List<NagiosAlert> allAlerts,\n      Set<String> requestedIds) {\n    if (null == allAlerts || 0 == allAlerts.size())\n      return;\n    \n    int ok = 0;\n    int warning = 0;\n    int critical = 0;\n    int passive = 0;\n    \n    List<Map<String, Object>> alerts = new ArrayList<Map<String, Object>>();\n    \n    for (NagiosAlert alert : allAlerts) {\n      boolean match = false;\n      \n      switch (resourceType.getInternalType()) {\n        case Service:\n          match = alert.getService().equals(matchValue);\n          if (match && null != alert.getDescription() &&\n              IGNORABLE_FOR_SERVICES.contains(alert.getDescription())) {\n            match = false;\n          }          \n          break;\n        case Host:\n          match = alert.getHost().equals(matchValue);\n          if (match && null != alert.getDescription()) {\n            String desc = alert.getDescription();\n            Iterator<String> it = IGNORABLE_FOR_HOSTS.iterator();\n            while (it.hasNext() && match) {\n              if (-1 != desc.toLowerCase().indexOf(it.next()))\n                match = false;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n      \n      if (match) {\n\n        // status = the return code from the plugin that controls\n        // whether an alert is sent out (0 when using wrapper)\n        // actual_status = the actual process result\n        \n        Map<String, Object> map = new LinkedHashMap<String, Object>();\n        \n        map.put(\"description\", alert.getDescription());\n        map.put(\"host_name\", alert.getHost());\n        map.put(\"last_status\", NagiosAlert.getStatusString(alert.getLastStatus()));\n        map.put(\"last_status_time\", Long.valueOf(alert.getLastStatusTime()));\n        map.put(\"service_name\", alert.getService());\n        map.put(\"status\", NagiosAlert.getStatusString(alert.getStatus()));\n        map.put(\"status_time\", Long.valueOf(alert.getStatusTime()));\n        map.put(\"output\", alert.getOutput());\n        map.put(\"actual_status\", NagiosAlert.getStatusString(alert.getStatus()));\n        \n        String longOut = alert.getLongPluginOutput();\n        int index = (null == longOut) ? -1 : longOut.indexOf(PASSIVE_TOKEN);\n        if (-1 != index) {\n          int actualStatus = 3;\n          try {\n            int len = PASSIVE_TOKEN.length();\n            \n            actualStatus = Integer.parseInt(longOut.substring(\n                index + len, index + len+1));\n          } catch (Exception e) {\n            // do nothing\n          }\n          \n          map.put(\"status\", \"PASSIVE\");\n          map.put(\"actual_status\", NagiosAlert.getStatusString(actualStatus));\n          passive++;\n        } else {\n          switch (alert.getStatus()) {\n          case 0:\n            ok++;\n            break;\n          case 1:\n            warning++;\n            break;\n          case 2:\n            critical++;\n            break;\n          default:\n            break;\n          }\n        }\n        \n        alerts.add(map);\n      }\n    }\n    \n    setResourceProperty(res, ALERT_SUMMARY_OK_PROPERTY_ID, Integer.valueOf(ok), requestedIds);\n    setResourceProperty(res, ALERT_SUMMARY_WARNING_PROPERTY_ID, Integer.valueOf(warning), requestedIds);\n    setResourceProperty(res, ALERT_SUMMARY_CRITICAL_PROPERTY_ID, Integer.valueOf(critical), requestedIds);\n    setResourceProperty(res, ALERT_SUMMARY_PASSIVE_PROPERTY_ID, Integer.valueOf(passive), requestedIds);\n    \n    if (!alerts.isEmpty())\n      setResourceProperty(res, ALERT_DETAIL_PROPERTY_ID, alerts, requestedIds);\n  }","commit_id":"8d9b031e877f8ddc46f2443ce9bc8cb55d0007f1","url":"https://github.com/apache/ambari"},{"original_method":"public static QName getQName(\n\t\tElement qNameEl, Element nameEl, String defaultNamespace) {\n\n\t\tif ((qNameEl == null) && (nameEl == null)) {\n\t\t\t_log.error(\"both qname and name elements are null\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif (qNameEl == null) {\n\t\t\treturn new QName(defaultNamespace, nameEl.getTextTrim());\n\t\t}\n\n\t\tString localPart = qNameEl.getTextTrim();\n\n\t\tList<Namespace> namespaces = qNameEl.declaredNamespaces();\n\n\t\tif (namespaces.size() == 0) {\n\t\t\t_log.error(\"qname \" + localPart + \" does not have a namespace\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tNamespace namespace = namespaces.get(0);\n\n\t\tString uri = namespace.getURI();\n\t\tString prefix = namespace.getPrefix();\n\n\t\tif (localPart.startsWith(prefix + StringPool.COLON)) {\n\t\t\tlocalPart = localPart.substring(prefix.length() + 1);\n\t\t}\n\t\telse {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"qname \" + localPart + \" is not correctly namespaced\");\n\t\t\t}\n\t\t}\n\n\t\treturn new QName(uri, localPart, prefix);\n\t}","id":93104,"modified_method":"public static QName getQName(\n\t\tElement qNameEl, Element nameEl, String defaultNamespace) {\n\n\t\tif ((qNameEl == null) && (nameEl == null)) {\n\t\t\t_log.error(\"both qname and name elements are null\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif (qNameEl == null) {\n\t\t\treturn new QName(defaultNamespace, nameEl.getTextTrim());\n\t\t}\n\n\t\tString localPart = qNameEl.getTextTrim();\n\n\t\tint pos = localPart.indexOf(StringPool.COLON);\n\n\t\tif (pos == -1) {\n\t\t\t_log.error(\"qname \" + localPart + \" does not have a prefix\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString prefix = localPart.substring(0, pos);\n\n\t\tNamespace namespace = qNameEl.getNamespaceForPrefix(prefix);\n\n\t\tif (namespace == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"qname \" + localPart + \" does not have a valid namespace\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString uri = namespace.getURI();\n\n\t\tlocalPart = localPart.substring(prefix.length() + 1);\n\n\t\treturn new QName(uri, localPart, prefix);\n\t}","commit_id":"bb1854f2608e6435af1fcd657899d91367396936","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void execute() throws MojoExecutionException, MojoFailureException {\n        try {\n            Map<String, Feature> featuresMap = new HashMap<String, Feature>();\n            for (String uri : descriptors) {\n                Repository repo = new Repository(URI.create(translateFromMaven(uri)));\n                for (Feature f : repo.getFeatures()) {\n                    featuresMap.put(f.getName(), f);\n                }\n            }\n            Set<String> transitiveFeatures = new HashSet<String>();\n            addFeatures(features, transitiveFeatures, featuresMap);\n            Set<String> bundles = new HashSet<String>();\n            for (String feature : transitiveFeatures) {\n                bundles.addAll(featuresMap.get(feature).getBundles());\n            }\n            getLog().info(\"Base repo: \" + localRepo.getUrl());\n            for (String bundle : bundles) {\n                if (bundle.startsWith(\"wrap:\")) {\n                    bundle = bundle.substring(5);\n                }\n                if (!bundle.startsWith(\"mvn:\")) {\n                    throw new MojoExecutionException(\"Bundle url is not a maven url: \" + bundle);\n                }\n                              \n                String[] parts = bundle.substring(\"mvn:\".length()).split(\"/\");\n                String groupId = parts[0];\n                String artifactId = parts[1];\n                String version = null;\n                String classifier = null;\n                String type = \"jar\";\n                if (parts.length > 2) {\n                    version = parts[2];\n                    if (parts.length > 3) {\n                        type = parts[3];\n                        if (parts.length > 4) {\n                            classifier = parts[4];\n                        }\n                    }\n                }\n                String dir = groupId.replace('.', '/') + \"/\" + artifactId + \"/\" + version + \"/\";\n                String name = artifactId + \"-\" + version + (classifier != null ? \"-\" + classifier : \"\") + \".\" + type;\n\n                Artifact artifact;\n                try {\n                    artifact = this.factory.createArtifact(groupId, artifactId, version,\n                            (classifier != null ? classifier : \"\"), type);\n                    getLog().info(\"Copying bundle: \" + bundle);\n                    resolver.resolve(artifact, this.remoteRepos, this.localRepo);\n                    copy(new FileInputStream(artifact.getFile()),\n                         repository,\n                         name,\n                         dir,\n                         new byte[8192]);\n                } catch (ArtifactResolutionException e) {\n                    getLog().error(\"Can't resolve bundle \" + bundle, e);\n                } catch (ArtifactNotFoundException e) {\n                    getLog().error(\"Can't resolve bundle \" + bundle, e);\n                }\n\n\n            }\n        } catch (MojoExecutionException e) {\n            throw e;\n        } catch (MojoFailureException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MojoExecutionException(\"Error populating repository\", e);\n        }\n    }","id":93105,"modified_method":"public void execute() throws MojoExecutionException, MojoFailureException {\n        try {\n            Map<String, Feature> featuresMap = new HashMap<String, Feature>();\n            for (String uri : descriptors) {\n                Repository repo = new Repository(URI.create(translateFromMaven(uri)));\n                for (Feature f : repo.getFeatures()) {\n                    featuresMap.put(f.getName(), f);\n                }\n            }\n            Set<String> transitiveFeatures = new HashSet<String>();\n            addFeatures(features, transitiveFeatures, featuresMap);\n            Set<String> bundles = new HashSet<String>();\n            for (String feature : transitiveFeatures) {\n                bundles.addAll(featuresMap.get(feature).getBundles());\n            }\n            getLog().info(\"Base repo: \" + localRepo.getUrl());\n            for (String bundle : bundles) {\n                final int index = bundle.indexOf(\"mvn:\");\n                if (index < 0) {\n                    if (skipNonMavenProtocols) {\n                        continue;\n                    }\n                    throw new MojoExecutionException(\"Bundle url is not a maven url: \" + bundle);\n                }\n                else {\n                    bundle = bundle.substring(index);\n                }\n                // Truncate the URL when a '#' or a '?' is encountered\n                final int index1 = bundle.indexOf('?');\n                final int index2 = bundle.indexOf('#');\n                int endIndex = -1;\n                if (index1 > 0) {\n                     if (index2 > 0) {\n                         endIndex = Math.min(index1, index2);\n                     } else {\n                         endIndex = index1;\n                     }\n                } else if (index2 > 0) {\n                    endIndex = index2;\n                }\n                if (endIndex >= 0) {\n                    bundle = bundle.substring(0, endIndex);\n                }\n                              \n                String[] parts = bundle.substring(\"mvn:\".length()).split(\"/\");\n                String groupId = parts[0];\n                String artifactId = parts[1];\n                String version = null;\n                String classifier = null;\n                String type = \"jar\";\n                if (parts.length > 2) {\n                    version = parts[2];\n                    if (parts.length > 3) {\n                        type = parts[3];\n                        if (parts.length > 4) {\n                            classifier = parts[4];\n                        }\n                    }\n                }\n                String dir = groupId.replace('.', '/') + \"/\" + artifactId + \"/\" + version + \"/\";\n                String name = artifactId + \"-\" + version + (classifier != null ? \"-\" + classifier : \"\") + \".\" + type;\n\n                Artifact artifact;\n                try {\n                    artifact = this.factory.createArtifact(groupId, artifactId, version,\n                            (classifier != null ? classifier : \"\"), type);\n                    getLog().info(\"Copying bundle: \" + bundle);\n                    resolver.resolve(artifact, this.remoteRepos, this.localRepo);\n                    copy(new FileInputStream(artifact.getFile()),\n                         repository,\n                         name,\n                         dir,\n                         new byte[8192]);\n                } catch (ArtifactResolutionException e) {\n                    getLog().error(\"Can't resolve bundle \" + bundle, e);\n                } catch (ArtifactNotFoundException e) {\n                    getLog().error(\"Can't resolve bundle \" + bundle, e);\n                }\n\n\n            }\n        } catch (MojoExecutionException e) {\n            throw e;\n        } catch (MojoFailureException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MojoExecutionException(\"Error populating repository\", e);\n        }\n    }","commit_id":"7df63d8b9661d07b62bf28d1b377124fe2402eae","url":"https://github.com/apache/felix"},{"original_method":"public void run() {\n      while (true) {\n        if (myProject.isDisposed()) return;\n        if (myInnerIndicator.isCanceled()) return;\n\n        final FileContent fileContent = myQueue.take();\n        if (fileContent == null) {\n          myFinished.set(Boolean.TRUE);\n          return;\n        }\n\n        try {\n          final Runnable action = new Runnable() {\n            public void run() {\n              myInnerIndicator.checkCanceled();\n\n              if (myProject.isDisposed()) return;\n\n              final VirtualFile file = fileContent.getVirtualFile();\n              myProgressUpdater.consume(file);\n              mySession.processFile(fileContent);\n            }\n          };\n          if (myProcessInReadAction) {\n            myApplication.runReadAction(action);\n          }\n          else {\n            action.run();\n          }\n        }\n        catch (ProcessCanceledException e) {\n          myQueue.pushback(fileContent);\n          return;\n        }\n        finally {\n          if (fileContent != null) {\n            myQueue.release(fileContent);\n          }\n        }\n      }\n    }","id":93106,"modified_method":"public void run() {\n      while (true) {\n        if (myProject.isDisposed()) return;\n        if (myInnerIndicator.isCanceled()) return;\n\n        final FileContent fileContent = myQueue.take(myInnerIndicator);\n        if (fileContent == null) {\n          myFinished.set(Boolean.TRUE);\n          return;\n        }\n\n        try {\n          final Runnable action = new Runnable() {\n            public void run() {\n              myInnerIndicator.checkCanceled();\n\n              if (myProject.isDisposed()) return;\n\n              final VirtualFile file = fileContent.getVirtualFile();\n              myProgressUpdater.consume(file);\n              mySession.processFile(fileContent);\n            }\n          };\n          if (myProcessInReadAction) {\n            myApplication.runReadAction(action);\n          }\n          else {\n            action.run();\n          }\n        }\n        catch (ProcessCanceledException e) {\n          myQueue.pushback(fileContent);\n          return;\n        }\n        finally {\n          if (fileContent != null) {\n            myQueue.release(fileContent);\n          }\n        }\n      }\n    }","commit_id":"a71fc83df203484b98b33949bea3af69d73879c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processSomeFilesWhileUserIsInactive(final FileContentQueue queue,\n                                                      final Consumer<VirtualFile> progressUpdater,\n                                                      final boolean processInReadAction) {\n    final ProgressIndicatorBase innerIndicator = new ProgressIndicatorBase() {\n      @Override\n      protected boolean isCancelable() {\n        return true; // the inner indicator must be always cancelable\n      }\n    };\n    final ApplicationAdapter canceller = new ApplicationAdapter() {\n      @Override\n      public void beforeWriteActionStart(Object action) {\n        innerIndicator.cancel();\n      }\n    };\n    final Application application = ApplicationManager.getApplication();\n    application.addApplicationListener(canceller);\n\n    final Ref<Boolean> isFinished = new Ref<Boolean>(Boolean.FALSE);\n    try {\n      int threadsCount = Registry.intValue(\"caches.indexerThreadsCount\");\n      if (threadsCount <= 0) {\n        threadsCount = Math.min(PROC_COUNT, 4);\n      }\n      if (threadsCount == 1) {\n        Runnable process = new MyRunnable(innerIndicator, queue, isFinished, progressUpdater, processInReadAction, application);\n        ProgressManager.getInstance().runProcess(process, innerIndicator);\n      }\n      else {\n        final Ref[] finishedRefs = new Ref[threadsCount];\n        Future<?>[] futures = new Future<?>[threadsCount];\n        for (int i = 0; i < threadsCount; i++) {\n          final Ref<Boolean> ref = new Ref<Boolean>(Boolean.FALSE);\n          finishedRefs[i] = ref;\n          Runnable process = new MyRunnable(innerIndicator, queue, ref, progressUpdater, processInReadAction, application);\n          futures[i] = ApplicationManager.getApplication().executeOnPooledThread(getProcessWrapper(process));\n        }\n        try {\n          for (Future<?> future : futures) {\n            future.get();\n          }\n\n          boolean allFinished = true;\n          for (Ref ref : finishedRefs) {\n            if (!(Boolean)ref.get()) {\n              allFinished = false;\n              break;\n            }\n          }\n          isFinished.set(allFinished);\n          \n        }\n        catch (Throwable throwable) {\n          LOG.error(throwable);\n        }\n      }\n    }\n    finally {\n      application.removeApplicationListener(canceller);\n    }\n\n    return isFinished.get();\n  }","id":93107,"modified_method":"private boolean processSomeFilesWhileUserIsInactive(final FileContentQueue queue,\n                                                      final Consumer<VirtualFile> progressUpdater,\n                                                      final boolean processInReadAction) {\n    final ProgressIndicatorBase innerIndicator = new ProgressIndicatorBase() {\n      @Override\n      protected boolean isCancelable() {\n        return true; // the inner indicator must be always cancelable\n      }\n    };\n    final ApplicationAdapter canceller = new ApplicationAdapter() {\n      @Override\n      public void beforeWriteActionStart(Object action) {\n        innerIndicator.cancel();\n      }\n    };\n    final Application application = ApplicationManager.getApplication();\n    application.addApplicationListener(canceller);\n\n    final Ref<Boolean> isFinished = new Ref<Boolean>(Boolean.FALSE);\n    try {\n      int threadsCount = Registry.intValue(\"caches.indexerThreadsCount\");\n      if (threadsCount <= 0) {\n        threadsCount = Math.min(PROC_COUNT, 4);\n      }\n      if (threadsCount == 1) {\n        Runnable process = new MyRunnable(innerIndicator, queue, isFinished, progressUpdater, processInReadAction, application);\n        ProgressManager.getInstance().runProcess(process, innerIndicator);\n      }\n      else {\n        final Ref[] finishedRefs = new Ref[threadsCount];\n        Future<?>[] futures = new Future<?>[threadsCount];\n        for (int i = 0; i < threadsCount; i++) {\n          final Ref<Boolean> ref = new Ref<Boolean>(Boolean.FALSE);\n          finishedRefs[i] = ref;\n          Runnable process = new MyRunnable(innerIndicator, queue, ref, progressUpdater, processInReadAction, application);\n          futures[i] = ApplicationManager.getApplication().executeOnPooledThread(getProcessWrapper(process));\n        }\n        isFinished.set(waitForAll(finishedRefs, futures));\n      }\n    }\n    finally {\n      application.removeApplicationListener(canceller);\n    }\n\n    return isFinished.get();\n  }","commit_id":"a71fc83df203484b98b33949bea3af69d73879c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void run() {\n      if (myProject.isDisposed()) {\n        return;\n      }\n\n      ProgressManager.getInstance().run(new Task.Backgroundable(myProject, IdeBundle.message(\"progress.indexing\"), false) {\n\n        private final BlockingQueue<Ref<CacheUpdateRunner>> myActionQueue = new LinkedBlockingQueue<Ref<CacheUpdateRunner>>();\n\n        // /*no override for interfaces in jdk 1.5 */ @Override\n        public void run(@NotNull final ProgressIndicator indicator) {\n          if (indicator instanceof ProgressIndicatorEx) {\n            ((ProgressIndicatorEx)indicator).addStateDelegate(new ProgressIndicatorBase() {\n              double lastFraction;\n\n              @Override\n              public void setFraction(final double fraction) {\n                if (fraction - lastFraction < 0.01d) return;\n                lastFraction = fraction;\n                UIUtil.invokeLaterIfNeeded(new Runnable() {\n                  public void run() {\n                    AppIcon.getInstance().setProgress(myProject, \"indexUpdate\", AppIconScheme.Progress.INDEXING, fraction, true);\n                  }\n                });\n              }\n\n              @Override\n              public void finish(@NotNull TaskInfo task) {\n                UIUtil.invokeLaterIfNeeded(new Runnable() {\n                  public void run() {\n                    AppIcon appIcon = AppIcon.getInstance();\n                    if (appIcon.hideProgress(myProject, \"indexUpdate\")) {\n                      appIcon.requestAttention(myProject, false);\n                      appIcon.setOkBadge(myProject, true);\n                    }\n                  }\n                });\n              }\n            });\n          }\n\n          final ProgressIndicator proxy = new DelegatingProgressIndicator(indicator) {\n            @Override\n            public void setFraction(double fraction) {\n              super.setFraction((myProcessedItems + fraction * myCurrentBaseTotal) / myTotalItems);\n            }\n          };\n\n          final ShutDownTracker shutdownTracker = ShutDownTracker.getInstance();\n          final Thread self = Thread.currentThread();\n          try {\n            HeavyProcessLatch.INSTANCE.processStarted();\n            shutdownTracker.registerStopperThread(self);\n            runAction(proxy, myAction);\n          }\n          finally {\n            shutdownTracker.unregisterStopperThread(self);\n            HeavyProcessLatch.INSTANCE.processFinished();\n          }\n        }\n\n        private void runAction(ProgressIndicator indicator, CacheUpdateRunner updateRunner) {\n          do {\n            int count = 0;\n            try {\n              indicator.setIndeterminate(true);\n              indicator.setText(IdeBundle.message(\"progress.indexing.scanning\"));\n              count = updateRunner.queryNeededFiles(indicator);\n\n              myCurrentBaseTotal = count;\n              myTotalItems += count;\n\n              indicator.setIndeterminate(false);\n              indicator.setText(IdeBundle.message(\"progress.indexing.updating\"));\n              if (count > 0) {\n                updateRunner.processFiles(indicator, true);\n              }\n              updateRunner.updatingDone();\n            }\n            finally {\n              myProcessedItems += count;\n              UIUtil.invokeLaterIfNeeded(new DumbAwareRunnable() {\n                public void run() {\n                  IndexUpdateRunnable nextUpdateRunnable = null;\n                  try {\n                    nextUpdateRunnable = myUpdatesQueue.isEmpty()? null : myUpdatesQueue.pullFirst();\n                    if (nextUpdateRunnable == null) {\n                      // really terminate the task\n                      myActionQueue.offer(NULL_ACTION);\n                    }\n                    else {\n                      //run next dumb action\n                      // run next action under already existing progress indicator\n                      myActionQueue.offer(new Ref<CacheUpdateRunner>(nextUpdateRunnable.myAction));\n                    }\n                  }\n                  catch (Throwable e) {\n                    myActionQueue.offer(NULL_ACTION);\n                    LOG.info(e);\n                  }\n                  finally {\n                    if (nextUpdateRunnable == null) {\n                      updateFinished();\n                    }\n                  }\n                }\n              });\n\n              // try to obtain the next action or terminate if no actions left\n              Ref<CacheUpdateRunner> ref = null;\n              do {\n                try {\n                  ref = myActionQueue.poll(500, TimeUnit.MILLISECONDS);\n                }\n                catch (InterruptedException e) {\n                  LOG.info(e);\n                }\n                updateRunner = ref != null? ref.get() : null;\n                if (myProject.isDisposed()) {\n                  // just terminate the progress task\n                  break;\n                }\n              }\n              while (ref == null);\n            }\n          }\n          while (updateRunner != null);\n        }\n\n      });\n    }","id":93108,"modified_method":"public void run() {\n      if (myProject.isDisposed()) {\n        return;\n      }\n\n      ProgressManager.getInstance().run(new Task.Backgroundable(myProject, IdeBundle.message(\"progress.indexing\"), false) {\n\n        private final BlockingQueue<Ref<CacheUpdateRunner>> myActionQueue = new LinkedBlockingQueue<Ref<CacheUpdateRunner>>();\n\n        // /*no override for interfaces in jdk 1.5 */ @Override\n        public void run(@NotNull final ProgressIndicator indicator) {\n          if (indicator instanceof ProgressIndicatorEx) {\n            ((ProgressIndicatorEx)indicator).addStateDelegate(new ProgressIndicatorBase() {\n              double lastFraction;\n\n              @Override\n              public void setFraction(final double fraction) {\n                if (fraction - lastFraction < 0.01d) return;\n                lastFraction = fraction;\n                UIUtil.invokeLaterIfNeeded(new Runnable() {\n                  public void run() {\n                    AppIcon.getInstance().setProgress(myProject, \"indexUpdate\", AppIconScheme.Progress.INDEXING, fraction, true);\n                  }\n                });\n              }\n\n              @Override\n              public void finish(@NotNull TaskInfo task) {\n                UIUtil.invokeLaterIfNeeded(new Runnable() {\n                  public void run() {\n                    AppIcon appIcon = AppIcon.getInstance();\n                    if (appIcon.hideProgress(myProject, \"indexUpdate\")) {\n                      appIcon.requestAttention(myProject, false);\n                      appIcon.setOkBadge(myProject, true);\n                    }\n                  }\n                });\n              }\n            });\n          }\n\n          final ProgressIndicator proxy = new DelegatingProgressIndicator(indicator) {\n            @Override\n            public void setFraction(double fraction) {\n              super.setFraction((myProcessedItems + fraction * myCurrentBaseTotal) / myTotalItems);\n            }\n          };\n\n          final ShutDownTracker shutdownTracker = ShutDownTracker.getInstance();\n          final Thread self = Thread.currentThread();\n          try {\n            HeavyProcessLatch.INSTANCE.processStarted();\n            shutdownTracker.registerStopperThread(self);\n            runAction(proxy, myAction);\n          }\n          finally {\n            shutdownTracker.unregisterStopperThread(self);\n            HeavyProcessLatch.INSTANCE.processFinished();\n          }\n        }\n\n        private void runAction(ProgressIndicator indicator, CacheUpdateRunner updateRunner) {\n          do {\n            int count = 0;\n            try {\n              indicator.setIndeterminate(true);\n              indicator.setText(IdeBundle.message(\"progress.indexing.scanning\"));\n              count = updateRunner.queryNeededFiles(indicator);\n\n              myCurrentBaseTotal = count;\n              myTotalItems += count;\n\n              indicator.setIndeterminate(false);\n              indicator.setText(IdeBundle.message(\"progress.indexing.updating\"));\n              if (count > 0) {\n                updateRunner.processFiles(indicator, true);\n              }\n              updateRunner.updatingDone();\n            }\n            finally {\n              myProcessedItems += count;\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Scheduling checkNextUpdateFromQueue\");\n              }\n              UIUtil.invokeLaterIfNeeded(new DumbAwareRunnable() {\n                public void run() {\n                  checkNextUpdateFromQueue();\n                }\n              });\n\n              // try to obtain the next action or terminate if no actions left\n              Ref<CacheUpdateRunner> ref = null;\n              do {\n                try {\n                  ref = myActionQueue.poll(500, TimeUnit.MILLISECONDS);\n                }\n                catch (InterruptedException e) {\n                  LOG.info(e);\n                }\n                updateRunner = ref != null? ref.get() : null;\n                if (myProject.isDisposed()) {\n                  // just terminate the progress task\n                  break;\n                }\n              }\n              while (ref == null);\n            }\n          }\n          while (updateRunner != null);\n        }\n\n        private void checkNextUpdateFromQueue() {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Inside checkNextUpdateFromQueue\");\n          }\n          IndexUpdateRunnable nextUpdateRunnable = null;\n          try {\n            nextUpdateRunnable = myUpdatesQueue.isEmpty()? null : myUpdatesQueue.pullFirst();\n            if (nextUpdateRunnable == null) {\n              // really terminate the task\n              myActionQueue.offer(NULL_ACTION);\n            }\n            else {\n              //run next dumb action\n              // run next action under already existing progress indicator\n              myActionQueue.offer(new Ref<CacheUpdateRunner>(nextUpdateRunnable.myAction));\n            }\n          }\n          catch (Throwable e) {\n            myActionQueue.offer(NULL_ACTION);\n            LOG.info(e);\n          }\n          finally {\n            if (nextUpdateRunnable == null) {\n              updateFinished();\n            }\n          }\n        }\n      });\n    }","commit_id":"a71fc83df203484b98b33949bea3af69d73879c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addLast(VirtualFile file) throws InterruptedException {\n    FileContent content = new FileContent(file);\n\n    if (file.isValid() && !file.isDirectory()) {\n      if (!doLoadContent(content)) {\n        content.setEmptyContent();\n      }\n    }\n    else {\n      content.setEmptyContent();\n    }\n\n    myQueue.put(content);\n  }","id":93109,"modified_method":"private void addLast(VirtualFile file, @NotNull final ProgressIndicator indicator) throws InterruptedException {\n    FileContent content = new FileContent(file);\n\n    if (file.isValid() && !file.isDirectory()) {\n      if (!doLoadContent(content, indicator)) {\n        content.setEmptyContent();\n      }\n    }\n    else {\n      content.setEmptyContent();\n    }\n\n    myQueue.put(content);\n  }","commit_id":"a71fc83df203484b98b33949bea3af69d73879c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void queue(final Collection<VirtualFile> files, @Nullable final ProgressIndicator indicator) {\n    final Runnable contentLoadingRunnable = new Runnable() {\n      public void run() {\n        try {\n          for (VirtualFile file : files) {\n            if (indicator != null) {\n              indicator.checkCanceled();\n            }\n            addLast(file);\n          }\n\n          // put end-of-queue marker only if not canceled\n          try {\n            myQueue.put(new FileContent(null));\n          }\n          catch (InterruptedException e) {\n            LOG.error(e);\n          }\n        }\n        catch (ProcessCanceledException e) {\n          // Do nothing, exit the thread.\n        }\n        catch (InterruptedException e) {\n          LOG.error(e);\n        }\n        finally {\n          myContentLoadingThreadTerminated = true;\n        }\n      }\n    };\n\n    ApplicationManager.getApplication().executeOnPooledThread(contentLoadingRunnable);\n  }","id":93110,"modified_method":"public void queue(final Collection<VirtualFile> files, @NotNull final ProgressIndicator indicator) {\n    final Runnable contentLoadingRunnable = new Runnable() {\n      public void run() {\n        try {\n          for (VirtualFile file : files) {\n            if (indicator != null) {\n              indicator.checkCanceled();\n            }\n            addLast(file, indicator);\n          }\n\n          // put end-of-queue marker only if not canceled\n          try {\n            myQueue.put(new FileContent(null));\n          }\n          catch (InterruptedException e) {\n            LOG.error(e);\n          }\n        }\n        catch (ProcessCanceledException e) {\n          // Do nothing, exit the thread.\n        }\n        catch (InterruptedException e) {\n          LOG.error(e);\n        }\n        finally {\n          myContentLoadingThreadTerminated = true;\n        }\n      }\n    };\n\n    ApplicationManager.getApplication().executeOnPooledThread(contentLoadingRunnable);\n  }","commit_id":"a71fc83df203484b98b33949bea3af69d73879c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean doLoadContent(final FileContent content) throws InterruptedException {\n    final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    final long contentLength = content.getLength();\n\n    boolean counterUpdated = false;\n    try {\n      synchronized (this) {\n        while (myTotalSize > SIZE_THRESHOLD) {\n          if (indicator != null) {\n            indicator.checkCanceled();\n          }\n          wait(300L);\n        }\n        myTotalSize += contentLength;\n        counterUpdated = true;\n      }\n\n      content.getBytes(); // Reads the content bytes and caches them.\n\n      return true;\n    }\n    catch (Throwable e) {\n      if (counterUpdated) {\n        synchronized (this) {\n          myTotalSize -= contentLength;   // revert size counter\n          notifyAll();\n        }\n      }\n      if (e instanceof ProcessCanceledException) throw (ProcessCanceledException)e;\n      if (e instanceof InterruptedException) throw (InterruptedException)e;\n\n      if (e instanceof IOException || e instanceof InvalidVirtualFileAccessException) LOG.info(e);\n      else if (ApplicationManager.getApplication().isUnitTestMode()) {\n        e.printStackTrace();\n      }\n      else {\n        LOG.error(e);\n      }\n\n      return false;\n    }\n  }","id":93111,"modified_method":"private boolean doLoadContent(final FileContent content, @NotNull final ProgressIndicator indicator) throws InterruptedException {\n    final long contentLength = content.getLength();\n\n    boolean counterUpdated = false;\n    try {\n      synchronized (this) {\n        while (myTotalSize > SIZE_THRESHOLD) {\n          indicator.checkCanceled();\n          wait(300L);\n        }\n        myTotalSize += contentLength;\n        counterUpdated = true;\n      }\n\n      content.getBytes(); // Reads the content bytes and caches them.\n\n      return true;\n    }\n    catch (Throwable e) {\n      if (counterUpdated) {\n        synchronized (this) {\n          myTotalSize -= contentLength;   // revert size counter\n          notifyAll();\n        }\n      }\n      if (e instanceof ProcessCanceledException) throw (ProcessCanceledException)e;\n      if (e instanceof InterruptedException) throw (InterruptedException)e;\n\n      if (e instanceof IOException || e instanceof InvalidVirtualFileAccessException) LOG.info(e);\n      else if (ApplicationManager.getApplication().isUnitTestMode()) {\n        e.printStackTrace();\n      }\n      else {\n        LOG.error(e);\n      }\n\n      return false;\n    }\n  }","commit_id":"a71fc83df203484b98b33949bea3af69d73879c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addClassesUsages(PsiPackage aPackage, final Processor<UsageInfo> results, final JavaPackageFindUsagesOptions options) {\n    final HashSet<PsiFile> filesSet = new HashSet<PsiFile>();\n    final ArrayList<PsiFile> files = new ArrayList<PsiFile>();\n    ReferencesSearch.search(new ReferencesSearch.SearchParameters(aPackage, options.searchScope, false, options.fastTrack)).forEach(new ReadActionProcessor<PsiReference>() {\n      public boolean processInReadAction(final PsiReference psiReference) {\n        PsiElement ref = psiReference.getElement();\n        PsiFile file = ref.getContainingFile();\n        if (filesSet.add(file)) {\n          files.add(file);\n        }\n        return true;\n      }\n    });\n\n    ProgressIndicator progress = ProgressManager.getInstance().getProgressIndicator();\n    if (progress != null){\n      progress.pushState();\n    }\n\n    ArrayList<PsiClass> classes = new ArrayList<PsiClass>();\n    addClassesInPackage(aPackage, options.isIncludeSubpackages, classes);\n    for (final PsiClass aClass : classes) {\n      if (progress != null) {\n        progress.setText(FindBundle.message(\"find.searching.for.references.to.class.progress\", ApplicationManager.getApplication().runReadAction(new Computable<String>(){\n          @Override\n          public String compute() {\n            return aClass.getName();\n          }\n        })));\n      }\n      for (PsiFile file : files) {\n        if (progress != null) {\n          progress.checkCanceled();\n        }\n        ReferencesSearch.search(new ReferencesSearch.SearchParameters(aClass, new LocalSearchScope(file), false, options.fastTrack)).forEach(new ReadActionProcessor<PsiReference>() {\n          public boolean processInReadAction(final PsiReference psiReference) {\n            return addResult(results, psiReference, options);\n          }\n        });\n      }\n    }\n\n    if (progress != null){\n      progress.popState();\n    }\n  }","id":93112,"modified_method":"private static void addClassesUsages(PsiPackage aPackage, final Processor<UsageInfo> results, final JavaPackageFindUsagesOptions options) {\n    ProgressIndicator progress = ProgressManager.getInstance().getProgressIndicator();\n    if (progress != null){\n      progress.pushState();\n    }\n\n    ArrayList<PsiClass> classes = new ArrayList<PsiClass>();\n    addClassesInPackage(aPackage, options.isIncludeSubpackages, classes);\n    for (final PsiClass aClass : classes) {\n      if (progress != null) {\n        progress.setText(FindBundle.message(\"find.searching.for.references.to.class.progress\", ApplicationManager.getApplication().runReadAction(new Computable<String>(){\n          @Override\n          public String compute() {\n            return aClass.getName();\n          }\n        })));\n        progress.checkCanceled();\n      }\n      ReferencesSearch.search(new ReferencesSearch.SearchParameters(aClass, options.searchScope, false, options.fastTrack)).forEach(new ReadActionProcessor<PsiReference>() {\n        public boolean processInReadAction(final PsiReference psiReference) {\n          return addResult(results, psiReference, options);\n        }\n      });\n    }\n\n    if (progress != null){\n      progress.popState();\n    }\n  }","commit_id":"c9412e967855182b808d2fa1c836adee27d61159","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return null to stop or last found TreeElement\n   * to be reused via <code>lastElement<code/> param in subsequent calls to avoid full tree rescan (n^2->n).\n   */\n  private static TreeElement processTreeUp(@NotNull Project project,\n                                           @NotNull TextOccurenceProcessor processor,\n                                           @NotNull PsiElement scope,\n                                           @NotNull StringSearcher searcher,\n                                           final int offset,\n                                           final boolean processInjectedPsi,\n                                           ProgressIndicator progress,\n                                           TreeElement lastElement) {\n    if (scope instanceof PsiCompiledElement) {\n      throw new IllegalArgumentException(\"Scope is compiled, can't scan: \"+scope);\n    }\n    final int scopeStartOffset = scope.getTextRange().getStartOffset();\n    final int patternLength = searcher.getPatternLength();\n    ASTNode scopeNode = scope.getNode();\n    boolean useTree = scopeNode != null;\n    assert scope.isValid();\n\n    int start;\n    TreeElement leafNode = null;\n    PsiElement leafElement = null;\n    if (useTree) {\n      leafNode = findNextLeafElementAt(scopeNode, lastElement, offset);\n      if (leafNode == null) return lastElement;\n      start = offset - leafNode.getStartOffset() + scopeStartOffset;\n    }\n    else {\n      if (scope instanceof PsiFile) {\n        leafElement = ((PsiFile)scope).getViewProvider().findElementAt(offset, scope.getLanguage());\n      }\n      else {\n        leafElement = scope.findElementAt(offset);\n      }\n      if (leafElement == null) return lastElement;\n      assert leafElement.isValid();\n      start = offset - leafElement.getTextRange().getStartOffset() + scopeStartOffset;\n    }\n    if (start < 0) {\n      throw new AssertionError(\"offset=\" + offset + \"; scopeStartOffset=\" + scopeStartOffset + \"; leafElement=\" + leafElement + \";  scope=\" + scope+\"; leafElement.isValid(): \"+ (leafElement == null ? null : leafElement.isValid()));\n    }\n    InjectedLanguageManager injectedLanguageManager = InjectedLanguageManager.getInstance(project);\n    lastElement = leafNode;\n    boolean contains = false;\n    PsiElement prev = null;\n    TreeElement prevNode = null;\n    PsiElement run = null;\n    while (run != scope) {\n      if (progress != null) progress.checkCanceled();\n      if (useTree) {\n        start += prevNode == null ? 0 : prevNode.getStartOffsetInParent();\n        prevNode = leafNode;\n        run = leafNode.getPsi();\n      }\n      else {\n        start += prev == null ? 0 : prev.getStartOffsetInParent();\n        prev = run;\n        run = leafElement;\n      }\n      if (!contains) contains = run.getTextLength() - start >= patternLength;  //do not compute if already contains\n      if (contains) {\n        if (processInjectedPsi) {\n          Boolean result = processInjectedFile(run, processor, searcher, progress, injectedLanguageManager);\n          if (result != null) {\n            return result.booleanValue() ? lastElement : null;\n          }\n        }\n        if (!processor.execute(run, start)) {\n          return null;\n        }\n      }\n      if (useTree) {\n        leafNode = leafNode.getTreeParent();\n        if (leafNode == null) break;\n      }\n      else {\n        leafElement = leafElement.getParent();\n        if (leafElement == null) break;\n      }\n    }\n    assert run == scope: \"Malbuilt PSI; scopeNode: \"+scope+\"; containingFile:\" + PsiTreeUtil.getParentOfType(scope, PsiFile.class, false) +\n                         \"; leafNode: \"+run+\"; isAncestor=\"+ PsiTreeUtil.isAncestor(scope, run, false)+\"; in same file: \"+(PsiTreeUtil.getParentOfType(scope, PsiFile.class, false) == PsiTreeUtil.getParentOfType(run, PsiFile.class, false));\n\n    return lastElement;\n  }","id":93113,"modified_method":"/**\n   * @return null to stop or last found TreeElement\n   * to be reused via <code>lastElement<code/> param in subsequent calls to avoid full tree rescan (n^2->n).\n   */\n  private static TreeElement processTreeUp(@NotNull Project project,\n                                           @NotNull TextOccurenceProcessor processor,\n                                           @NotNull PsiElement scope,\n                                           @NotNull StringSearcher searcher,\n                                           final int offset,\n                                           final boolean processInjectedPsi,\n                                           @NotNull ProgressIndicator progress,\n                                           TreeElement lastElement) {\n    if (scope instanceof PsiCompiledElement) {\n      throw new IllegalArgumentException(\"Scope is compiled, can't scan: \"+scope);\n    }\n    final int scopeStartOffset = scope.getTextRange().getStartOffset();\n    final int patternLength = searcher.getPatternLength();\n    ASTNode scopeNode = scope.getNode();\n    boolean useTree = scopeNode != null;\n    assert scope.isValid();\n\n    int start;\n    TreeElement leafNode = null;\n    PsiElement leafElement = null;\n    if (useTree) {\n      leafNode = findNextLeafElementAt(scopeNode, lastElement, offset);\n      if (leafNode == null) return lastElement;\n      start = offset - leafNode.getStartOffset() + scopeStartOffset;\n    }\n    else {\n      if (scope instanceof PsiFile) {\n        leafElement = ((PsiFile)scope).getViewProvider().findElementAt(offset, scope.getLanguage());\n      }\n      else {\n        leafElement = scope.findElementAt(offset);\n      }\n      if (leafElement == null) return lastElement;\n      assert leafElement.isValid();\n      start = offset - leafElement.getTextRange().getStartOffset() + scopeStartOffset;\n    }\n    if (start < 0) {\n      throw new AssertionError(\"offset=\" + offset + \"; scopeStartOffset=\" + scopeStartOffset + \"; leafElement=\" + leafElement + \";  scope=\" + scope+\"; leafElement.isValid(): \"+ (leafElement == null ? null : leafElement.isValid()));\n    }\n    InjectedLanguageManager injectedLanguageManager = InjectedLanguageManager.getInstance(project);\n    lastElement = leafNode;\n    boolean contains = false;\n    PsiElement prev = null;\n    TreeElement prevNode = null;\n    PsiElement run = null;\n    while (run != scope) {\n      progress.checkCanceled();\n      if (useTree) {\n        start += prevNode == null ? 0 : prevNode.getStartOffsetInParent();\n        prevNode = leafNode;\n        run = leafNode.getPsi();\n      }\n      else {\n        start += prev == null ? 0 : prev.getStartOffsetInParent();\n        prev = run;\n        run = leafElement;\n      }\n      if (!contains) contains = run.getTextLength() - start >= patternLength;  //do not compute if already contains\n      if (contains) {\n        if (processInjectedPsi) {\n          Boolean result = processInjectedFile(run, processor, searcher, progress, injectedLanguageManager);\n          if (result != null) {\n            return result.booleanValue() ? lastElement : null;\n          }\n        }\n        if (!processor.execute(run, start)) {\n          return null;\n        }\n      }\n      if (useTree) {\n        leafNode = leafNode.getTreeParent();\n        if (leafNode == null) break;\n      }\n      else {\n        leafElement = leafElement.getParent();\n        if (leafElement == null) break;\n      }\n    }\n    assert run == scope: \"Malbuilt PSI; scopeNode: \"+scope+\"; containingFile:\" + PsiTreeUtil.getParentOfType(scope, PsiFile.class, false) +\n                         \"; leafNode: \"+run+\"; isAncestor=\"+ PsiTreeUtil.isAncestor(scope, run, false)+\"; in same file: \"+(PsiTreeUtil.getParentOfType(scope, PsiFile.class, false) == PsiTreeUtil.getParentOfType(run, PsiFile.class, false));\n\n    return lastElement;\n  }","commit_id":"e8c0586d822345f43ca1a6a839d8e370cfc004cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean processElementsContainingWordInElement(@NotNull final TextOccurenceProcessor processor,\n                                                               @NotNull final PsiElement scope,\n                                                               @NotNull final StringSearcher searcher,\n                                                               final boolean processInjectedPsi,\n                                                               final ProgressIndicator progress) {\n    if (progress != null) progress.checkCanceled();\n\n    PsiFile file = scope.getContainingFile();\n    FileViewProvider viewProvider = file.getViewProvider();\n    final CharSequence buffer = viewProvider.getContents();\n\n    TextRange range = scope.getTextRange();\n    if (range == null) {\n      LOG.error(\"Element \" + scope + \" of class \" + scope.getClass() + \" has null range\");\n      return true;\n    }\n\n    final int scopeStart = range.getStartOffset();\n    final int startOffset = scopeStart;\n    int endOffset = range.getEndOffset();\n    if (endOffset > buffer.length()) {\n      diagnoseInvalidRange(scope, file, viewProvider, buffer, range);\n      return true;\n    }\n\n    final Project project = file.getProject();\n    final TreeElement[] lastElement = {null};\n    return processTextOccurrences(buffer, startOffset, endOffset, searcher, progress, offset -> {\n      if (progress != null) progress.checkCanceled();\n      lastElement[0] = processTreeUp(project, processor, scope, searcher, offset - scopeStart, processInjectedPsi, progress,\n                                     lastElement[0]);\n      return lastElement[0] != null;\n    });\n  }","id":93114,"modified_method":"public static boolean processElementsContainingWordInElement(@NotNull final TextOccurenceProcessor processor,\n                                                               @NotNull final PsiElement scope,\n                                                               @NotNull final StringSearcher searcher,\n                                                               boolean processInjectedPsi,\n                                                               @NotNull  ProgressIndicator progress) {\n    int[] occurrences = getTextOccurrencesInScope(scope, searcher, progress);\n    return processElementsAtOffsets(scope, searcher, processInjectedPsi, progress, occurrences, processor);\n  }","commit_id":"e8c0586d822345f43ca1a6a839d8e370cfc004cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean processTextOccurrences(@NotNull CharSequence text,\n                                               int startOffset,\n                                               int endOffset,\n                                               @NotNull StringSearcher searcher,\n                                               @Nullable ProgressIndicator progress,\n                                               @NotNull TIntProcedure processor) {\n    if (endOffset > text.length()) {\n      throw new IllegalArgumentException(\"end: \" + endOffset + \" > length: \"+text.length());\n    }\n    Map<StringSearcher, int[]> cachedMap = cache.get(text);\n    int[] cachedOccurrences = cachedMap == null ? null : cachedMap.get(searcher);\n    boolean hasCachedOccurrences = cachedOccurrences != null && cachedOccurrences[0] <= startOffset && cachedOccurrences[1] >= endOffset;\n    if (!hasCachedOccurrences) {\n      TIntArrayList occurrences = new TIntArrayList();\n      int newStart = Math.min(startOffset, cachedOccurrences == null ? startOffset : cachedOccurrences[0]);\n      int newEnd = Math.max(endOffset, cachedOccurrences == null ? endOffset : cachedOccurrences[1]);\n      occurrences.add(newStart);\n      occurrences.add(newEnd);\n      for (int index = newStart; index < newEnd; index++) {\n        if (progress != null) progress.checkCanceled();\n        //noinspection AssignmentToForLoopParameter\n        index = searcher.scan(text, index, newEnd);\n        if (index < 0) break;\n        if (checkJavaIdentifier(text, 0, text.length(), searcher, index)) {\n          occurrences.add(index);\n        }\n      }\n      cachedOccurrences = occurrences.toNativeArray();\n      if (cachedMap == null) {\n        cachedMap = ConcurrencyUtil.cacheOrGet(cache, text, ContainerUtil.createConcurrentSoftMap());\n      }\n      cachedMap.put(searcher, cachedOccurrences);\n    }\n    for (int i = 2; i < cachedOccurrences.length; i++) {\n      int occurrence = cachedOccurrences[i];\n      if (occurrence > endOffset - searcher.getPatternLength()) break;\n      if (occurrence >= startOffset && !processor.execute(occurrence)) {\n        return false;\n      }\n    }\n    return true;\n  }","id":93115,"modified_method":"public static boolean processTextOccurrences(@NotNull CharSequence text,\n                                               int startOffset,\n                                               int endOffset,\n                                               @NotNull StringSearcher searcher,\n                                               @Nullable ProgressIndicator progress,\n                                               @NotNull TIntProcedure processor) {\n    for (int offset : getTextOccurrences(text, startOffset, endOffset, searcher, progress)) {\n      if (!processor.execute(offset)) {\n        return false;\n      }\n    }\n    return true;\n  }","commit_id":"e8c0586d822345f43ca1a6a839d8e370cfc004cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static Processor<PsiElement> localProcessor(@NotNull final TextOccurenceProcessor processor,\n                                                      @NotNull final ProgressIndicator progress,\n                                                      final boolean processInjectedPsi,\n                                                      @NotNull final StringSearcher searcher) {\n    return new ReadActionProcessor<PsiElement>() {\n      @Override\n      public boolean processInReadAction(PsiElement scopeElement) {\n        return scopeElement.isValid() &&\n               LowLevelSearchUtil.processElementsContainingWordInElement(processor, scopeElement, searcher, processInjectedPsi, progress);\n      }\n\n      @Override\n      public String toString() {\n        return processor.toString();\n      }\n    };\n  }","id":93116,"modified_method":"@NotNull\n  private static Processor<PsiElement> localProcessor(@NotNull final BulkOccurrenceProcessor processor,\n                                                      @NotNull final ProgressIndicator progress,\n                                                      @NotNull final StringSearcher searcher) {\n    return new ReadActionProcessor<PsiElement>() {\n      @Override\n      public boolean processInReadAction(PsiElement scopeElement) {\n        return scopeElement.isValid() &&\n               processor.execute(scopeElement, LowLevelSearchUtil.getTextOccurrencesInScope(scopeElement, searcher, progress), searcher);\n      }\n\n      @Override\n      public String toString() {\n        return processor.toString();\n      }\n    };\n  }","commit_id":"e8c0586d822345f43ca1a6a839d8e370cfc004cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processSingleRequest(@NotNull PsiSearchRequest single, @NotNull Processor<PsiReference> consumer) {\n    final EnumSet<Options> options = EnumSet.of(Options.PROCESS_ONLY_JAVA_IDENTIFIERS_IF_POSSIBLE);\n    if (single.caseSensitive) options.add(Options.CASE_SENSITIVE_SEARCH);\n    if (shouldProcessInjectedPsi(single.searchScope)) options.add(Options.PROCESS_INJECTED_PSI);\n    \n    return processElementsWithWord(adaptProcessor(single, consumer), single.searchScope, single.word, single.searchContext, options, \n                                   single.containerName);\n  }","id":93117,"modified_method":"private boolean processSingleRequest(@NotNull PsiSearchRequest single, @NotNull Processor<PsiReference> consumer) {\n    final EnumSet<Options> options = EnumSet.of(Options.PROCESS_ONLY_JAVA_IDENTIFIERS_IF_POSSIBLE);\n    if (single.caseSensitive) options.add(Options.CASE_SENSITIVE_SEARCH);\n    if (shouldProcessInjectedPsi(single.searchScope)) options.add(Options.PROCESS_INJECTED_PSI);\n    \n    return bulkProcessElementsWithWord(single.searchScope, single.word, single.searchContext, options, single.containerName,\n                                       adaptProcessor(single, consumer)\n    );\n  }","commit_id":"e8c0586d822345f43ca1a6a839d8e370cfc004cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processElementsWithTextInGlobalScope(@NotNull final TextOccurenceProcessor processor,\n                                                       @NotNull final GlobalSearchScope scope,\n                                                       @NotNull final StringSearcher searcher,\n                                                       final short searchContext,\n                                                       final boolean caseSensitively,\n                                                       @Nullable String containerName,\n                                                       @NotNull ProgressIndicator progress,\n                                                       final boolean processInjectedPsi) {\n    if (Thread.holdsLock(PsiLock.LOCK)) {\n      throw new AssertionError(\"You must not run search from within updating PSI activity. Please consider invokeLatering it instead.\");\n    }\n    progress.pushState();\n    boolean result;\n    try {\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n\n      String text = searcher.getPattern();\n      Set<VirtualFile> fileSet = new THashSet<>();\n      getFilesWithText(scope, searchContext, caseSensitively, text, fileSet);\n\n      progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", text));\n\n      final Processor<PsiElement> localProcessor = localProcessor(processor, progress, processInjectedPsi, searcher);\n      if (containerName != null) {\n        List<VirtualFile> intersectionWithContainerFiles = new ArrayList<>();\n        // intersectionWithContainerFiles holds files containing words from both `text` and `containerName`\n        getFilesWithText(scope, searchContext, caseSensitively, text+\" \"+containerName, intersectionWithContainerFiles);\n        if (!intersectionWithContainerFiles.isEmpty()) {\n          int totalSize = fileSet.size();\n          result = processPsiFileRoots(intersectionWithContainerFiles, totalSize, 0, progress, localProcessor);\n\n          if (result) {\n            fileSet.removeAll(intersectionWithContainerFiles);\n            if (!fileSet.isEmpty()) {\n              result = processPsiFileRoots(new ArrayList<>(fileSet), totalSize, intersectionWithContainerFiles.size(), progress, localProcessor);\n            }\n          }\n          return result;\n        }\n      }\n      result = fileSet.isEmpty() || processPsiFileRoots(new ArrayList<>(fileSet), fileSet.size(), 0, progress, localProcessor);\n    }\n    finally {\n      progress.popState();\n    }\n    return result;\n  }","id":93118,"modified_method":"private boolean processElementsWithTextInGlobalScope(@NotNull final BulkOccurrenceProcessor processor,\n                                                       @NotNull final GlobalSearchScope scope,\n                                                       @NotNull final StringSearcher searcher,\n                                                       final short searchContext,\n                                                       final boolean caseSensitively,\n                                                       @Nullable String containerName,\n                                                       @NotNull ProgressIndicator progress) {\n    if (Thread.holdsLock(PsiLock.LOCK)) {\n      throw new AssertionError(\"You must not run search from within updating PSI activity. Please consider invokeLatering it instead.\");\n    }\n    progress.pushState();\n    boolean result;\n    try {\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n\n      String text = searcher.getPattern();\n      Set<VirtualFile> fileSet = new THashSet<>();\n      getFilesWithText(scope, searchContext, caseSensitively, text, fileSet);\n\n      progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", text));\n\n      final Processor<PsiElement> localProcessor = localProcessor(processor, progress, searcher);\n      if (containerName != null) {\n        List<VirtualFile> intersectionWithContainerFiles = new ArrayList<>();\n        // intersectionWithContainerFiles holds files containing words from both `text` and `containerName`\n        getFilesWithText(scope, searchContext, caseSensitively, text+\" \"+containerName, intersectionWithContainerFiles);\n        if (!intersectionWithContainerFiles.isEmpty()) {\n          int totalSize = fileSet.size();\n          result = processPsiFileRoots(intersectionWithContainerFiles, totalSize, 0, progress, localProcessor);\n\n          if (result) {\n            fileSet.removeAll(intersectionWithContainerFiles);\n            if (!fileSet.isEmpty()) {\n              result = processPsiFileRoots(new ArrayList<>(fileSet), totalSize, intersectionWithContainerFiles.size(), progress, localProcessor);\n            }\n          }\n          return result;\n        }\n      }\n      result = fileSet.isEmpty() || processPsiFileRoots(new ArrayList<>(fileSet), fileSet.size(), 0, progress, localProcessor);\n    }\n    finally {\n      progress.popState();\n    }\n    return result;\n  }","commit_id":"e8c0586d822345f43ca1a6a839d8e370cfc004cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean processElementsWithWord(@NotNull final TextOccurenceProcessor processor,\n                                         @NotNull SearchScope searchScope,\n                                         @NotNull final String text,\n                                         final short searchContext,\n                                         @NotNull EnumSet<Options> options,\n                                         @Nullable String containerName) {\n    if (text.isEmpty()) {\n      throw new IllegalArgumentException(\"Cannot search for elements with empty text\");\n    }\n    final ProgressIndicator progress = getOrCreateIndicator();\n    final boolean processInjectedPsi = options.contains(Options.PROCESS_INJECTED_PSI);\n    if (searchScope instanceof GlobalSearchScope) {\n      StringSearcher searcher = new StringSearcher(text, options.contains(Options.CASE_SENSITIVE_SEARCH), true,\n                                                   searchContext == UsageSearchContext.IN_STRINGS,\n                                                   options.contains(Options.PROCESS_ONLY_JAVA_IDENTIFIERS_IF_POSSIBLE));\n\n      return processElementsWithTextInGlobalScope(processor,\n                                                  (GlobalSearchScope)searchScope,\n                                                  searcher,\n                                                  searchContext, options.contains(Options.CASE_SENSITIVE_SEARCH), containerName, progress,\n                                                  processInjectedPsi);\n    }\n    LocalSearchScope scope = (LocalSearchScope)searchScope;\n    PsiElement[] scopeElements = scope.getScope();\n    final StringSearcher searcher = new StringSearcher(text, options.contains(Options.CASE_SENSITIVE_SEARCH), true,\n                                                       searchContext == UsageSearchContext.IN_STRINGS,\n                                                       options.contains(Options.PROCESS_ONLY_JAVA_IDENTIFIERS_IF_POSSIBLE));\n    ReadActionProcessor<PsiElement> localProcessor = new ReadActionProcessor<PsiElement>() {\n      @Override\n      public boolean processInReadAction(PsiElement scopeElement) {\n        if (!scopeElement.isValid()) return true;\n        if (!scopeElement.isPhysical()) {\n          scopeElement = scopeElement.getNavigationElement();\n        }\n        if (scopeElement.getTextRange() == null) {\n          // clients can put whatever they want to the LocalSearchScope. Skip what we can't process.\n          LOG.debug(\"Element \" + scopeElement + \" of class \" + scopeElement.getClass() + \" has null range\");\n          return true;\n        }\n        return LowLevelSearchUtil.processElementsContainingWordInElement(processor, scopeElement, searcher, processInjectedPsi, progress);\n      }\n\n      @Override\n      public String toString() {\n        return processor.toString();\n      }\n    };\n    return JobLauncher.getInstance().invokeConcurrentlyUnderProgress(Arrays.asList(scopeElements), progress, true, true, localProcessor);\n  }","id":93119,"modified_method":"public boolean processElementsWithWord(@NotNull final TextOccurenceProcessor processor,\n                                         @NotNull SearchScope searchScope,\n                                         @NotNull final String text,\n                                         final short searchContext,\n                                         @NotNull EnumSet<Options> options,\n                                         @Nullable String containerName) {\n    return bulkProcessElementsWithWord(searchScope, text, searchContext, options, containerName, (scope, offsetsInScope, searcher) ->\n      LowLevelSearchUtil.processElementsAtOffsets(scope, searcher, options.contains(Options.PROCESS_INJECTED_PSI), getOrCreateIndicator(),\n                                                  offsetsInScope, processor));\n  }","commit_id":"e8c0586d822345f43ca1a6a839d8e370cfc004cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void distributePrimitives(@NotNull Map<SearchRequestCollector, Processor<PsiReference>> collectors,\n                                           @NotNull Set<RequestWithProcessor> locals,\n                                           @NotNull MultiMap<Set<IdIndexEntry>, RequestWithProcessor> singles,\n                                           @NotNull List<Computable<Boolean>> customs,\n                                           @NotNull Map<RequestWithProcessor, Processor<PsiElement>> localProcessors,\n                                           @NotNull ProgressIndicator progress) {\n    for (final Map.Entry<SearchRequestCollector, Processor<PsiReference>> entry : collectors.entrySet()) {\n      final Processor<PsiReference> processor = entry.getValue();\n      SearchRequestCollector collector = entry.getKey();\n      for (final PsiSearchRequest primitive : collector.takeSearchRequests()) {\n        final SearchScope scope = primitive.searchScope;\n        if (scope instanceof LocalSearchScope) {\n          registerRequest(locals, primitive, processor);\n        }\n        else {\n          Set<IdIndexEntry> key = new HashSet<>(getWordEntries(primitive.word, primitive.caseSensitive));\n          registerRequest(singles.getModifiable(key), primitive, processor);\n        }\n      }\n      for (final Processor<Processor<PsiReference>> customAction : collector.takeCustomSearchActions()) {\n        customs.add(() -> customAction.process(processor));\n      }\n    }\n\n    for (Map.Entry<Set<IdIndexEntry>, Collection<RequestWithProcessor>> entry : singles.entrySet()) {\n      for (RequestWithProcessor singleRequest : entry.getValue()) {\n        PsiSearchRequest primitive = singleRequest.request;\n        StringSearcher searcher = new StringSearcher(primitive.word, primitive.caseSensitive, true, false);\n        final TextOccurenceProcessor adapted = adaptProcessor(primitive, singleRequest.refProcessor);\n\n        Processor<PsiElement> localProcessor = localProcessor(adapted, progress, true, searcher);\n\n        assert !localProcessors.containsKey(singleRequest) || localProcessors.get(singleRequest) == localProcessor;\n        localProcessors.put(singleRequest, localProcessor);\n      }\n    }\n  }","id":93120,"modified_method":"private static void distributePrimitives(@NotNull Map<SearchRequestCollector, Processor<PsiReference>> collectors,\n                                           @NotNull Set<RequestWithProcessor> locals,\n                                           @NotNull MultiMap<Set<IdIndexEntry>, RequestWithProcessor> singles,\n                                           @NotNull List<Computable<Boolean>> customs,\n                                           @NotNull Map<RequestWithProcessor, Processor<PsiElement>> localProcessors,\n                                           @NotNull ProgressIndicator progress) {\n    for (final Map.Entry<SearchRequestCollector, Processor<PsiReference>> entry : collectors.entrySet()) {\n      final Processor<PsiReference> processor = entry.getValue();\n      SearchRequestCollector collector = entry.getKey();\n      for (final PsiSearchRequest primitive : collector.takeSearchRequests()) {\n        final SearchScope scope = primitive.searchScope;\n        if (scope instanceof LocalSearchScope) {\n          registerRequest(locals, primitive, processor);\n        }\n        else {\n          Set<IdIndexEntry> key = new HashSet<>(getWordEntries(primitive.word, primitive.caseSensitive));\n          registerRequest(singles.getModifiable(key), primitive, processor);\n        }\n      }\n      for (final Processor<Processor<PsiReference>> customAction : collector.takeCustomSearchActions()) {\n        customs.add(() -> customAction.process(processor));\n      }\n    }\n\n    for (Map.Entry<Set<IdIndexEntry>, Collection<RequestWithProcessor>> entry : singles.entrySet()) {\n      for (RequestWithProcessor singleRequest : entry.getValue()) {\n        PsiSearchRequest primitive = singleRequest.request;\n        StringSearcher searcher = new StringSearcher(primitive.word, primitive.caseSensitive, true, false);\n        BulkOccurrenceProcessor adapted = adaptProcessor(primitive, singleRequest.refProcessor);\n\n        Processor<PsiElement> localProcessor = localProcessor(adapted, progress, searcher);\n\n        assert !localProcessors.containsKey(singleRequest) || localProcessors.get(singleRequest) == localProcessor;\n        localProcessors.put(singleRequest, localProcessor);\n      }\n    }\n  }","commit_id":"e8c0586d822345f43ca1a6a839d8e370cfc004cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static TextOccurenceProcessor adaptProcessor(@NotNull PsiSearchRequest singleRequest,\n                                                       @NotNull final Processor<PsiReference> consumer) {\n    final SearchScope searchScope = singleRequest.searchScope;\n    final boolean ignoreInjectedPsi = searchScope instanceof LocalSearchScope && ((LocalSearchScope)searchScope).isIgnoreInjectedPsi();\n    final RequestResultProcessor wrapped = singleRequest.processor;\n    return new TextOccurenceProcessor() {\n      @Override\n      public boolean execute(@NotNull PsiElement element, int offsetInElement) {\n        if (ignoreInjectedPsi && element instanceof PsiLanguageInjectionHost) return true;\n\n        try {\n          return wrapped.processTextOccurrence(element, offsetInElement, consumer);\n        }\n        catch (ProcessCanceledException e) {\n          throw e;\n        }\n        catch (Exception | Error e) {\n          LOG.error(e);\n          return true;\n        }\n      }\n\n      @Override\n      public String toString() {\n        return consumer.toString();\n      }\n    };\n  }","id":93121,"modified_method":"@NotNull\n  private static BulkOccurrenceProcessor adaptProcessor(@NotNull PsiSearchRequest singleRequest,\n                                                       @NotNull Processor<PsiReference> consumer) {\n    final SearchScope searchScope = singleRequest.searchScope;\n    final boolean ignoreInjectedPsi = searchScope instanceof LocalSearchScope && ((LocalSearchScope)searchScope).isIgnoreInjectedPsi();\n    final RequestResultProcessor wrapped = singleRequest.processor;\n    return new BulkOccurrenceProcessor() {\n      @Override\n      public boolean execute(@NotNull PsiElement scope, int[] offsetsInScope, @NotNull StringSearcher searcher) {\n        try {\n          if (wrapped instanceof RequestResultProcessor.BulkResultProcessor) {\n            return ((RequestResultProcessor.BulkResultProcessor)wrapped).processTextOccurrences(scope, offsetsInScope, consumer);\n          }\n\n          return LowLevelSearchUtil.processElementsAtOffsets(scope, searcher, !ignoreInjectedPsi,\n                                                             getOrCreateIndicator(), offsetsInScope,\n                                                             (element, offsetInElement) -> {\n            if (ignoreInjectedPsi && element instanceof PsiLanguageInjectionHost) return true;\n            return wrapped.processTextOccurrence(element, offsetInElement, consumer);\n          });\n        }\n        catch (ProcessCanceledException e) {\n          throw e;\n        }\n        catch (Exception | Error e) {\n          LOG.error(e);\n          return true;\n        }\n      }\n\n      @Override\n      public String toString() {\n        return consumer.toString();\n      }\n    };\n  }","commit_id":"e8c0586d822345f43ca1a6a839d8e370cfc004cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected RequestResultProcessor(@NotNull Object... equality) {\n    myEquality = Arrays.asList(equality);\n  }","id":93122,"modified_method":"/**\n   * @param equality this processor's equals/hashCode will delegate to this object\n   */\n  protected RequestResultProcessor(@NotNull Object... equality) {\n    myEquality = Arrays.asList(equality);\n  }","commit_id":"e8c0586d822345f43ca1a6a839d8e370cfc004cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public abstract boolean processTextOccurrence(@NotNull PsiElement element, int offsetInElement, @NotNull Processor<PsiReference> consumer);","id":93123,"modified_method":"/**\n   * For every occurrence of the search string in the search scope, the infrastructure invokes this method for every PSI element having that\n   * occurrence inside, from leaf elements up the tree until file element. The implementation is supposed to search for references\n   * inside the given element at the given offset, and feed them to <code>consumer<\/code>.<p/>\n   *\n   * If you wish to process all offsets in the scope (e.g. file) at once, extend {@link BulkResultProcessor}.\n   *\n   * @return whether the consumer has returned false for any of the references (and thus stopped searching), false otherwise.\n   */\n  public abstract boolean processTextOccurrence(@NotNull PsiElement element, int offsetInElement, @NotNull Processor<PsiReference> consumer);","commit_id":"e8c0586d822345f43ca1a6a839d8e370cfc004cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void defineAssignAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"assign\")\n      .setDescription(\"Assign/Unassign an issue. Requires authentication and Browse permission on project.\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"issue\")\n      .setDescription(\"Key of the issue.\")\n      .setRequired(true)\n      .setExampleValue(\"5bccd6e8-f525-43a2-8d76-fcb13dde79ef\");\n    action.createParam(\"assignee\")\n      .setDescription(\"Login of the assignee.\")\n      .setExampleValue(\"admin\");\n  }","id":93124,"modified_method":"private void defineAssignAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"assign\")\n      .setDescription(\"Assign/Unassign an issue. Requires authentication and Browse permission on project\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"issue\")\n      .setDescription(\"Key of the issue\")\n      .setRequired(true)\n      .setExampleValue(\"5bccd6e8-f525-43a2-8d76-fcb13dde79ef\");\n    action.createParam(\"assignee\")\n      .setDescription(\"Login of the assignee\")\n      .setExampleValue(\"admin\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineCreateAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"create\")\n      .setDescription(\"Create a manual issue. Requires authentication and Browse permission on project.\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"component\")\n      .setDescription(\"Key of the component on which to log the issue.\")\n      .setRequired(true)\n      .setExampleValue(\"org.apache.struts:struts:org.apache.struts.Action\");\n    action.createParam(\"rule\")\n      .setDescription(\"Manual rule key.\")\n      .setRequired(true)\n      .setExampleValue(\"manual:performance\");\n    action.createParam(\"severity\")\n      .setDescription(\"Severity of the issue.\")\n      .setExampleValue(Severity.BLOCKER + \",\" + Severity.CRITICAL)\n      .setPossibleValues(Severity.ALL);\n    action.createParam(\"line\")\n      .setDescription(\"Line on which to log the issue.\\n\" +\n        \"If no line is specified, the issue is attached to the component and not to a specific line.\")\n      .setExampleValue(\"15\");\n    action.createParam(\"message\")\n      .setDescription(\"Description of the issue.\")\n      .setExampleValue(\"blabla...\");\n  }","id":93125,"modified_method":"private void defineCreateAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"create\")\n      .setDescription(\"Create a manual issue. Requires authentication and Browse permission on project\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"component\")\n      .setDescription(\"Key of the component on which to log the issue\")\n      .setRequired(true)\n      .setExampleValue(\"org.apache.struts:struts:org.apache.struts.Action\");\n    action.createParam(\"rule\")\n      .setDescription(\"Manual rule key\")\n      .setRequired(true)\n      .setExampleValue(\"manual:performance\");\n    action.createParam(\"severity\")\n      .setDescription(\"Severity of the issue\")\n      .setExampleValue(Severity.BLOCKER + \",\" + Severity.CRITICAL)\n      .setPossibleValues(Severity.ALL);\n    action.createParam(\"line\")\n      .setDescription(\"Line on which to log the issue. \" +\n        \"If no line is specified, the issue is attached to the component and not to a specific line\")\n      .setExampleValue(\"15\");\n    action.createParam(\"message\")\n      .setDescription(\"Description of the issue\")\n      .setExampleValue(\"blabla...\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineAddCommentAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"add_comment\")\n      .setDescription(\"Add a comment. Requires authentication and Browse permission on project.\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"issue\")\n      .setDescription(\"Key of the issue.\")\n      .setRequired(true)\n      .setExampleValue(\"5bccd6e8-f525-43a2-8d76-fcb13dde79ef\");\n    action.createParam(\"text\")\n      .setDescription(\"Comment.\")\n      .setExampleValue(\"blabla...\");\n  }","id":93126,"modified_method":"private void defineAddCommentAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"add_comment\")\n      .setDescription(\"Add a comment. Requires authentication and Browse permission on project\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"issue\")\n      .setDescription(\"Key of the issue\")\n      .setRequired(true)\n      .setExampleValue(\"5bccd6e8-f525-43a2-8d76-fcb13dde79ef\");\n    action.createParam(\"text\")\n      .setDescription(\"Comment\")\n      .setExampleValue(\"blabla...\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineDoTransitionAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"do_transition\")\n      .setDescription(\"Do workflow transition on an issue. Requires authentication and Browse permission on project.\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"issue\")\n      .setDescription(\"Key of the issue.\")\n      .setRequired(true)\n      .setExampleValue(\"5bccd6e8-f525-43a2-8d76-fcb13dde79ef\");\n    action.createParam(\"transition\")\n      .setDescription(\"Transition.\")\n      .setExampleValue(\"reopen\")\n      .setPossibleValues(DefaultTransitions.ALL);\n  }","id":93127,"modified_method":"private void defineDoTransitionAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"do_transition\")\n      .setDescription(\"Do workflow transition on an issue. Requires authentication and Browse permission on project\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"issue\")\n      .setDescription(\"Key of the issue\")\n      .setRequired(true)\n      .setExampleValue(\"5bccd6e8-f525-43a2-8d76-fcb13dde79ef\");\n    action.createParam(\"transition\")\n      .setDescription(\"Transition\")\n      .setExampleValue(\"reopen\")\n      .setPossibleValues(DefaultTransitions.ALL);\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void definePlanAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"plan\")\n      .setDescription(\"Plan/Unplan an issue. Requires authentication and Browse permission on project.\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"issue\")\n      .setDescription(\"Key of the issue.\")\n      .setRequired(true)\n      .setExampleValue(\"5bccd6e8-f525-43a2-8d76-fcb13dde79ef\");\n    action.createParam(\"plan\")\n      .setDescription(\"Key of the action plan.\")\n      .setExampleValue(\"3f19de90-1521-4482-a737-a311758ff513\");\n  }","id":93128,"modified_method":"private void definePlanAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"plan\")\n      .setDescription(\"Plan/Unplan an issue. Requires authentication and Browse permission on project\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"issue\")\n      .setDescription(\"Key of the issue\")\n      .setRequired(true)\n      .setExampleValue(\"5bccd6e8-f525-43a2-8d76-fcb13dde79ef\");\n    action.createParam(\"plan\")\n      .setDescription(\"Key of the action plan\")\n      .setExampleValue(\"3f19de90-1521-4482-a737-a311758ff513\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineSearchAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"search\")\n      .setDescription(\"Get a list of issues. If the number of issues is greater than 10,000, only the first 10,000 ones are returned by the web service. \" +\n        \"Requires Browse permission on project(s).\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"example-search.json\"));\n\n    action.createParam(\"issues\")\n      .setDescription(\"Comma-separated list of issue keys.\")\n      .setExampleValue(\"5bccd6e8-f525-43a2-8d76-fcb13dde79ef\");\n    action.createParam(\"severities\")\n      .setDescription(\"Comma-separated list of severities.\")\n      .setExampleValue(Severity.BLOCKER + \",\" + Severity.CRITICAL)\n      .setPossibleValues(Severity.ALL);\n    action.createParam(\"statuses\")\n      .setDescription(\"Comma-separated list of statuses.\")\n      .setExampleValue(Issue.STATUS_OPEN + \",\" + Issue.STATUS_REOPENED)\n      .setPossibleValues(Issue.STATUSES);\n    action.createParam(\"resolutions\")\n      .setDescription(\"Comma-separated list of resolutions.\")\n      .setExampleValue(Issue.RESOLUTION_FIXED + \",\" + Issue.RESOLUTION_REMOVED)\n      .setPossibleValues(Issue.RESOLUTIONS);\n    action.createParam(\"resolved\")\n      .setDescription(\"To match resolved or unresolved issues.\")\n      .setExampleValue(\"true\")\n      .setPossibleValues(\"true\", \"false\");\n    action.createParam(\"components\")\n      .setDescription(\"To retrieve issues associated to a specific list of components (comma-separated list of component keys). \" +\n        \"Note that if you set the value to a project key, only issues associated to this project are retrieved. \" +\n        \"Issues associated to its sub-components (such as files, packages, etc.) are not retrieved. See also componentRoots.\")\n      .setExampleValue(\"org.apache.struts:struts:org.apache.struts.Action\");\n    action.createParam(\"componentRoots\")\n      .setDescription(\"To retrieve issues associated to a specific list of components and their sub-components (comma-separated list of component keys). \" +\n        \"Views are not supported.\")\n      .setExampleValue(\"org.apache.struts:struts\");\n    action.createParam(\"rules\")\n      .setDescription(\"Comma-separated list of coding rule keys. Format is <repository>:<rule>.\")\n      .setExampleValue(\"squid:AvoidCycles\");\n    action.createParam(\"actionPlans\")\n      .setDescription(\"Comma-separated list of action plan keys (not names).\")\n      .setExampleValue(\"3f19de90-1521-4482-a737-a311758ff513\");\n    action.createParam(\"planned\")\n      .setDescription(\"To retrieve issues associated to an action plan or not.\")\n      .setExampleValue(\"true\")\n      .setPossibleValues(\"true\", \"false\");\n    action.createParam(\"reporters\")\n      .setDescription(\"Comma-separated list of reporter logins.\")\n      .setExampleValue(\"admin\");\n    action.createParam(\"assignees\")\n      .setDescription(\"Comma-separated list of assignee logins.\")\n      .setExampleValue(\"admin,usera\");\n    action.createParam(\"assigned\")\n      .setDescription(\"To retrieve assigned or unassigned issues.\")\n      .setExampleValue(\"true\")\n      .setPossibleValues(\"true\", \"false\");\n    action.createParam(\"createdAfter\")\n      .setDescription(\"To retrieve issues created after the given date (inclusive). Format: date or datetime ISO formats.\")\n      .setExampleValue(\"2013-05-01 (or 2013-05-01T13:00:00+0100)\");\n    action.createParam(\"createdBefore\")\n      .setDescription(\"To retrieve issues created before the given date (exclusive). Format: date or datetime ISO formats.\")\n      .setExampleValue(\"2013-05-01 (or 2013-05-01T13:00:00+0100)\");\n    action.createParam(\"pageSize\")\n      .setDescription(\"Maximum number of results per page.\\n\" +\n        \"Default value: 100 (except when the 'components' parameter is set, value is set to \\\"-1\\\" in this case)\\n\" +\n        \"If set to \\\"-1\\\", the max possible value is used.\")\n      .setExampleValue(\"50\");\n    action.createParam(\"pageIndex\")\n      .setDescription(\"Index of the selected page\")\n      .setDefaultValue(\"1\")\n      .setExampleValue(\"2\");\n  }","id":93129,"modified_method":"private void defineSearchAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"search\")\n      .setDescription(\"Get a list of issues. If the number of issues is greater than 10,000, only the first 10,000 ones are returned by the web service. \" +\n        \"Requires Browse permission on project(s)\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"example-search.json\"));\n\n    action.createParam(\"issues\")\n      .setDescription(\"Comma-separated list of issue keys\")\n      .setExampleValue(\"5bccd6e8-f525-43a2-8d76-fcb13dde79ef\");\n    action.createParam(\"severities\")\n      .setDescription(\"Comma-separated list of severities\")\n      .setExampleValue(Severity.BLOCKER + \",\" + Severity.CRITICAL)\n      .setPossibleValues(Severity.ALL);\n    action.createParam(\"statuses\")\n      .setDescription(\"Comma-separated list of statuses\")\n      .setExampleValue(Issue.STATUS_OPEN + \",\" + Issue.STATUS_REOPENED)\n      .setPossibleValues(Issue.STATUSES);\n    action.createParam(\"resolutions\")\n      .setDescription(\"Comma-separated list of resolutions\")\n      .setExampleValue(Issue.RESOLUTION_FIXED + \",\" + Issue.RESOLUTION_REMOVED)\n      .setPossibleValues(Issue.RESOLUTIONS);\n    action.createParam(\"resolved\")\n      .setDescription(\"To match resolved or unresolved issues\")\n      .setBooleanPossibleValues();\n    action.createParam(\"components\")\n      .setDescription(\"To retrieve issues associated to a specific list of components (comma-separated list of component keys). \" +\n        \"Note that if you set the value to a project key, only issues associated to this project are retrieved. \" +\n        \"Issues associated to its sub-components (such as files, packages, etc.) are not retrieved. See also componentRoots\")\n      .setExampleValue(\"org.apache.struts:struts:org.apache.struts.Action\");\n    action.createParam(\"componentRoots\")\n      .setDescription(\"To retrieve issues associated to a specific list of components and their sub-components (comma-separated list of component keys). \" +\n        \"Views are not supported\")\n      .setExampleValue(\"org.apache.struts:struts\");\n    action.createParam(\"rules\")\n      .setDescription(\"Comma-separated list of coding rule keys. Format is <repository>:<rule>\")\n      .setExampleValue(\"squid:AvoidCycles\");\n    action.createParam(\"actionPlans\")\n      .setDescription(\"Comma-separated list of action plan keys (not names)\")\n      .setExampleValue(\"3f19de90-1521-4482-a737-a311758ff513\");\n    action.createParam(\"planned\")\n      .setDescription(\"To retrieve issues associated to an action plan or not\")\n      .setBooleanPossibleValues();\n    action.createParam(\"reporters\")\n      .setDescription(\"Comma-separated list of reporter logins\")\n      .setExampleValue(\"admin\");\n    action.createParam(\"assignees\")\n      .setDescription(\"Comma-separated list of assignee logins\")\n      .setExampleValue(\"admin,usera\");\n    action.createParam(\"assigned\")\n      .setDescription(\"To retrieve assigned or unassigned issues\")\n      .setBooleanPossibleValues();\n    action.createParam(\"createdAfter\")\n      .setDescription(\"To retrieve issues created after the given date (inclusive). Format: date or datetime ISO formats\")\n      .setExampleValue(\"2013-05-01 (or 2013-05-01T13:00:00+0100)\");\n    action.createParam(\"createdBefore\")\n      .setDescription(\"To retrieve issues created before the given date (exclusive). Format: date or datetime ISO formats\")\n      .setExampleValue(\"2013-05-01 (or 2013-05-01T13:00:00+0100)\");\n    action.createParam(\"pageSize\")\n      .setDescription(\"Maximum number of results per page. \" +\n        \"Default value: 100 (except when the 'components' parameter is set, value is set to \\\"-1\\\" in this case). \" +\n        \"If set to \\\"-1\\\", the max possible value is used\")\n      .setExampleValue(\"50\");\n    action.createParam(\"pageIndex\")\n      .setDescription(\"Index of the selected page\")\n      .setDefaultValue(\"1\")\n      .setExampleValue(\"2\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineChangeSeverityAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"set_severity\")\n      .setDescription(\"Change severity. Requires authentication and Browse permission on project.\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"issue\")\n      .setDescription(\"Key of the issue.\")\n      .setRequired(true)\n      .setExampleValue(\"5bccd6e8-f525-43a2-8d76-fcb13dde79ef\");\n    action.createParam(\"severity\")\n      .setDescription(\"New severity.\")\n      .setExampleValue(Severity.BLOCKER)\n      .setPossibleValues(Severity.ALL);\n  }","id":93130,"modified_method":"private void defineChangeSeverityAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"set_severity\")\n      .setDescription(\"Change severity. Requires authentication and Browse permission on project\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"issue\")\n      .setDescription(\"Key of the issue\")\n      .setRequired(true)\n      .setExampleValue(\"5bccd6e8-f525-43a2-8d76-fcb13dde79ef\");\n    action.createParam(\"severity\")\n      .setDescription(\"New severity\")\n      .setExampleValue(Severity.BLOCKER)\n      .setPossibleValues(Severity.ALL);\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineEditCommentAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"edit_comment\")\n      .setDescription(\"Edit a comment. Requires authentication and User role on project.\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"key\")\n      .setDescription(\"Key of the comment.\")\n      .setRequired(true)\n      .setExampleValue(\"392160d3-a4f2-4c52-a565-e4542cfa2096\");\n    action.createParam(\"text\")\n      .setDescription(\"New comment.\")\n      .setExampleValue(\"blabla2...\");\n  }","id":93131,"modified_method":"private void defineEditCommentAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"edit_comment\")\n      .setDescription(\"Edit a comment. Requires authentication and User role on project\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"key\")\n      .setDescription(\"Key of the comment\")\n      .setRequired(true)\n      .setExampleValue(\"392160d3-a4f2-4c52-a565-e4542cfa2096\");\n    action.createParam(\"text\")\n      .setDescription(\"New comment\")\n      .setExampleValue(\"blabla2...\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineBulkChangeAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"bulk_change\")\n      .setDescription(\"Bulk change on issues. Requires authentication and User role on project(s).\")\n      .setSince(\"3.7\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"issues\")\n      .setDescription(\"Comma-separated list of issue keys.\")\n      .setRequired(true)\n      .setExampleValue(\"01fc972e-2a3c-433e-bcae-0bd7f88f5123,01fc972e-2a3c-433e-bcae-0bd7f88f9999\");\n    action.createParam(\"actions\")\n      .setDescription(\"Comma-separated list of actions to perform. Possible values: assign | set_severity | plan | do_transition.\")\n      .setRequired(true)\n      .setExampleValue(\"assign,plan\");\n    action.createParam(\"assign.assignee\")\n      .setDescription(\"To assign the list of issues to a specific user (login), or unassign all the issues.\")\n      .setExampleValue(\"sbrandhof\");\n    action.createParam(\"set_severity.severity\")\n      .setDescription(\"To change the severity of the list of issues.\")\n      .setExampleValue(Severity.BLOCKER)\n      .setPossibleValues(Severity.ALL);\n    action.createParam(\"plan.plan\")\n      .setDescription(\"To plan the list of issues to a specific action plan (key), or unlink all the issues from an action plan.\")\n      .setExampleValue(\"3f19de90-1521-4482-a737-a311758ff513\");\n    action.createParam(\"do_transition.transition\")\n      .setDescription(\"Transition.\")\n      .setExampleValue(\"reopen\")\n      .setPossibleValues(DefaultTransitions.ALL);\n    action.createParam(\"comment\")\n      .setDescription(\"To add a comment to a list of issues.\")\n      .setExampleValue(\"blabla...\");\n    action.createParam(\"sendNotifications\")\n      .setDescription(\"Available since version 4.0.\")\n      .setDefaultValue(\"false\")\n      .setExampleValue(\"true\")\n      .setPossibleValues(\"true\", \"false\");\n  }","id":93132,"modified_method":"private void defineBulkChangeAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"bulk_change\")\n      .setDescription(\"Bulk change on issues. Requires authentication and User role on project(s)\")\n      .setSince(\"3.7\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"issues\")\n      .setDescription(\"Comma-separated list of issue keys\")\n      .setRequired(true)\n      .setExampleValue(\"01fc972e-2a3c-433e-bcae-0bd7f88f5123,01fc972e-2a3c-433e-bcae-0bd7f88f9999\");\n    action.createParam(\"actions\")\n      .setDescription(\"Comma-separated list of actions to perform. Possible values: assign | set_severity | plan | do_transition\")\n      .setRequired(true)\n      .setExampleValue(\"assign,plan\");\n    action.createParam(\"assign.assignee\")\n      .setDescription(\"To assign the list of issues to a specific user (login), or unassign all the issues\")\n      .setExampleValue(\"sbrandhof\");\n    action.createParam(\"set_severity.severity\")\n      .setDescription(\"To change the severity of the list of issues\")\n      .setExampleValue(Severity.BLOCKER)\n      .setPossibleValues(Severity.ALL);\n    action.createParam(\"plan.plan\")\n      .setDescription(\"To plan the list of issues to a specific action plan (key), or unlink all the issues from an action plan\")\n      .setExampleValue(\"3f19de90-1521-4482-a737-a311758ff513\");\n    action.createParam(\"do_transition.transition\")\n      .setDescription(\"Transition\")\n      .setExampleValue(\"reopen\")\n      .setPossibleValues(DefaultTransitions.ALL);\n    action.createParam(\"comment\")\n      .setDescription(\"To add a comment to a list of issues\")\n      .setExampleValue(\"blabla...\");\n    action.createParam(\"sendNotifications\")\n      .setDescription(\"Available since version 4.0\")\n      .setDefaultValue(\"false\")\n      .setBooleanPossibleValues();\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineDeleteCommentAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"delete_comment\")\n      .setDescription(\"Delete a comment. Requires authentication and Browse permission on project.\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"key\")\n      .setDescription(\"Key of the comment.\")\n      .setRequired(true)\n      .setExampleValue(\"392160d3-a4f2-4c52-a565-e4542cfa2096\");\n  }","id":93133,"modified_method":"private void defineDeleteCommentAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"delete_comment\")\n      .setDescription(\"Delete a comment. Requires authentication and Browse permission on project\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"key\")\n      .setDescription(\"Key of the comment\")\n      .setRequired(true)\n      .setExampleValue(\"392160d3-a4f2-4c52-a565-e4542cfa2096\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineTransitionsAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"transitions\")\n      .setDescription(\"Get Possible Workflow Transitions for an Issue. Requires Browse permission on project.\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"example-transitions.json\"));\n\n    action.createParam(\"issue\")\n      .setDescription(\"Key of the issue.\")\n      .setRequired(true)\n      .setExampleValue(\"5bccd6e8-f525-43a2-8d76-fcb13dde79ef\");\n  }","id":93134,"modified_method":"private void defineTransitionsAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"transitions\")\n      .setDescription(\"Get Possible Workflow Transitions for an Issue. Requires Browse permission on project\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"example-transitions.json\"));\n\n    action.createParam(\"issue\")\n      .setDescription(\"Key of the issue\")\n      .setRequired(true)\n      .setExampleValue(\"5bccd6e8-f525-43a2-8d76-fcb13dde79ef\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineList(final Context context, NewController controller) {\n    NewAction action = controller\n      .createAction(\"list\")\n      .setSince(\"4.2\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          handleList(context.controllers(), request, response);\n        }\n      });\n    action\n      .createParam(\"include_internals\")\n      .setDescription(\"Include web services that are implemented for internal use only. Their forward-compatibility is \" +\n        \"not assured.\")\n      .setPossibleValues(\"false\", \"true\")\n      .setDefaultValue(\"false\");\n  }","id":93135,"modified_method":"private void defineList(final Context context, NewController controller) {\n    NewAction action = controller\n      .createAction(\"list\")\n      .setSince(\"4.2\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          handleList(context.controllers(), request, response);\n        }\n      });\n    action\n      .createParam(\"include_internals\")\n      .setDescription(\"Include web services that are implemented for internal use only. Their forward-compatibility is \" +\n        \"not assured\")\n      .setBooleanPossibleValues()\n      .setDefaultValue(\"false\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineRemoveAction(NewController controller) {\n    NewAction action = controller.createAction(\"remove\")\n      .setDescription(\"Remove a global or a project permission. Requires Administer System permission for global permissions, \\n\" +\n        \"requires Administer permission on project for project permissions.\")\n      .setSince(\"3.7\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n\n    action.createParam(\"permission\")\n      .setDescription(\"Key of the permission to remove.\")\n      .setRequired(true)\n      .setPossibleValues(ImmutableSet.<String>builder().addAll(GlobalPermissions.ALL).addAll(ComponentPermissions.ALL).build())\n      .setExampleValue(\"shareDashboard\");\n    action.createParam(\"user\")\n      .setDescription(\"User login. Required if group is not set.\")\n      .setExampleValue(\"myuser\");\n    action.createParam(\"group\")\n      .setDescription(\"Group name or \\\"\" + DefaultGroups.ANYONE + \"\\\". Required if user is not set.\")\n      .setExampleValue(DefaultGroups.ADMINISTRATORS);\n    action.createParam(\"component\")\n      .setDescription(\"Key of the project. Required if a project permission is set. Available since version 4.0.\")\n      .setExampleValue(\"org.codehaus.sonar\");\n  }","id":93136,"modified_method":"private void defineRemoveAction(NewController controller) {\n    NewAction action = controller.createAction(\"remove\")\n      .setDescription(\"Remove a global or a project permission. Requires Administer System permission for global permissions, \" +\n        \"requires Administer permission on project for project permissions\")\n      .setSince(\"3.7\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n\n    action.createParam(\"permission\")\n      .setDescription(\"Key of the permission to remove\")\n      .setRequired(true)\n      .setPossibleValues(ImmutableSet.<String>builder().addAll(GlobalPermissions.ALL).addAll(ComponentPermissions.ALL).build())\n      .setExampleValue(\"shareDashboard\");\n    action.createParam(\"user\")\n      .setDescription(\"User login. Required if group is not set\")\n      .setExampleValue(\"myuser\");\n    action.createParam(\"group\")\n      .setDescription(\"Group name or \\\"\" + DefaultGroups.ANYONE + \"\\\". Required if user is not set\")\n      .setExampleValue(DefaultGroups.ADMINISTRATORS);\n    action.createParam(\"component\")\n      .setDescription(\"Key of the project. Required if a project permission is set. Available since version 4.0\")\n      .setExampleValue(\"org.codehaus.sonar\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineAddAction(NewController controller) {\n    NewAction action = controller.createAction(\"add\")\n      .setDescription(\"Add a global or a project permission. Requires Administer System permission for global permissions, \\n\" +\n        \"requires Administer permission on project for project permissions.\")\n      .setSince(\"3.7\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n    action.createParam(\"permission\")\n      .setDescription(\"Key of the permission to add.\")\n      .setRequired(true)\n      .setPossibleValues(ImmutableSet.<String>builder().addAll(GlobalPermissions.ALL).addAll(ComponentPermissions.ALL).build())\n      .setExampleValue(\"shareDashboard\");\n    action.createParam(\"user\")\n      .setDescription(\"User login. Required if group is not set.\")\n      .setExampleValue(\"myuser\");\n    action.createParam(\"group\")\n      .setDescription(\"Group name or \\\"\" + DefaultGroups.ANYONE + \"\\\". Required if user is not set.\")\n      .setExampleValue(DefaultGroups.ADMINISTRATORS);\n    action.createParam(\"component\")\n      .setDescription(\"Key of the project. Required if a project permission is set. Available since version 4.0.\")\n      .setExampleValue(\"org.codehaus.sonar\");\n  }","id":93137,"modified_method":"private void defineAddAction(NewController controller) {\n    NewAction action = controller.createAction(\"add\")\n      .setDescription(\"Add a global or a project permission. Requires Administer System permission for global permissions, \" +\n        \"requires Administer permission on project for project permissions\")\n      .setSince(\"3.7\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n    action.createParam(\"permission\")\n      .setDescription(\"Key of the permission to add\")\n      .setRequired(true)\n      .setPossibleValues(ImmutableSet.<String>builder().addAll(GlobalPermissions.ALL).addAll(ComponentPermissions.ALL).build())\n      .setExampleValue(\"shareDashboard\");\n    action.createParam(\"user\")\n      .setDescription(\"User login. Required if group is not set\")\n      .setExampleValue(\"myuser\");\n    action.createParam(\"group\")\n      .setDescription(\"Group name or \\\"\" + DefaultGroups.ANYONE + \"\\\". Required if user is not set\")\n      .setExampleValue(DefaultGroups.ADMINISTRATORS);\n    action.createParam(\"component\")\n      .setDescription(\"Key of the project. Required if a project permission is set. Available since version 4.0\")\n      .setExampleValue(\"org.codehaus.sonar\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineDestroyAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"destroy\")\n      .setDescription(\"Delete a quality profile. Requires Administer Quality Profiles permission.\")\n      .setSince(\"3.3\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n\n    action.createParam(\"language\")\n      .setDescription(\"Profile language.\")\n      .setRequired(true)\n      .setExampleValue(\"java\");\n    action.createParam(\"name\")\n      .setDescription(\"Profile name.\")\n      .setRequired(true)\n      .setExampleValue(\"Sonar way\");\n  }","id":93138,"modified_method":"private void defineDestroyAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"destroy\")\n      .setDescription(\"Delete a quality profile. Requires Administer Quality Profiles permission\")\n      .setSince(\"3.3\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n\n    action.createParam(\"language\")\n      .setDescription(\"Profile language\")\n      .setRequired(true)\n      .setExampleValue(\"java\");\n    action.createParam(\"name\")\n      .setDescription(\"Profile name\")\n      .setRequired(true)\n      .setExampleValue(\"Sonar way\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineBackupAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"backup\")\n      .setDescription(\"Backup a quality profile. Requires Administer Quality Profiles permission.\")\n      .setSince(\"3.1\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n\n    action.createParam(\"language\")\n      .setDescription(\"Profile language.\")\n      .setRequired(true)\n      .setExampleValue(\"java\");\n    action.createParam(\"name\")\n      .setDescription(\"Profile name. If not set, the default profile for the selected language is used.\")\n      .setExampleValue(\"Sonar way\");\n  }","id":93139,"modified_method":"private void defineBackupAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"backup\")\n      .setDescription(\"Backup a quality profile. Requires Administer Quality Profiles permission\")\n      .setSince(\"3.1\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n\n    action.createParam(\"language\")\n      .setDescription(\"Profile language\")\n      .setRequired(true)\n      .setExampleValue(\"java\");\n    action.createParam(\"name\")\n      .setDescription(\"Profile name. If not set, the default profile for the selected language is used\")\n      .setExampleValue(\"Sonar way\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineListAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"list\")\n      .setDescription(\"Get a list of profiles.\")\n      .setSince(\"3.3\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"example-list.json\"));\n\n    action.createParam(\"language\")\n      .setDescription(\"Profile language.\")\n      .setRequired(true)\n      .setExampleValue(\"java\");\n    action.createParam(\"project\")\n      .setDescription(\"Project key or id.\")\n      .setExampleValue(\"org.codehaus.sonar:sonar\");\n  }","id":93140,"modified_method":"private void defineListAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"list\")\n      .setDescription(\"Get a list of profiles\")\n      .setSince(\"3.3\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"example-list.json\"));\n\n    action.createParam(\"language\")\n      .setDescription(\"Profile language\")\n      .setRequired(true)\n      .setExampleValue(\"java\");\n    action.createParam(\"project\")\n      .setDescription(\"Project key or id\")\n      .setExampleValue(\"org.codehaus.sonar:sonar\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineSetAsDefaultAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"set_as_default\")\n      .setDescription(\"Set a quality profile as Default. Requires Administer Quality Profiles permission.\")\n      .setSince(\"3.3\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n\n    action.createParam(\"language\")\n      .setDescription(\"Profile language.\")\n      .setRequired(true)\n      .setExampleValue(\"java\");\n    action.createParam(\"name\")\n      .setDescription(\"Profile name.\")\n      .setRequired(true)\n      .setExampleValue(\"Sonar way\");\n  }","id":93141,"modified_method":"private void defineSetAsDefaultAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"set_as_default\")\n      .setDescription(\"Set a quality profile as Default. Requires Administer Quality Profiles permission\")\n      .setSince(\"3.3\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n\n    action.createParam(\"language\")\n      .setDescription(\"Profile language\")\n      .setRequired(true)\n      .setExampleValue(\"java\");\n    action.createParam(\"name\")\n      .setDescription(\"Profile name\")\n      .setRequired(true)\n      .setExampleValue(\"Sonar way\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineRestoreAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"restore\")\n      .setDescription(\"Restore a quality profile backup. Requires Administer Quality Profiles permission.\")\n      .setSince(\"3.1\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n\n    action.createParam(\"backup\")\n      .setRequired(true)\n      .setDescription(\"Path to the file containing the backup (HTML format)\");\n  }","id":93142,"modified_method":"private void defineRestoreAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"restore\")\n      .setDescription(\"Restore a quality profile backup. Requires Administer Quality Profiles permission\")\n      .setSince(\"3.1\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n\n    action.createParam(\"backup\")\n      .setRequired(true)\n      .setDescription(\"Path to the file containing the backup (HTML format)\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void define(WebService.NewController controller) {\n    controller.createAction(\"app\")\n      .setInternal(true)\n      .setDescription(\"Get initialization items for the admin UI. For internal use.\")\n      .setSince(\"4.3\")\n      .setHandler(this);\n  }","id":93143,"modified_method":"void define(WebService.NewController controller) {\n    controller.createAction(\"app\")\n      .setInternal(true)\n      .setDescription(\"Get initialization items for the admin UI. For internal use\")\n      .setSince(\"4.3\")\n      .setHandler(this);\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"search\")\n      .setDescription(\"Search for projects associated (or not) to a quality gate\")\n      .setSince(\"4.3\")\n      .setResponseExample(Resources.getResource(this.getClass(), \"example-search.json\"))\n      .setHandler(this);\n\n    action.createParam(QGatesWs.PARAM_GATE_ID)\n      .setDescription(\"Quality Gate ID\")\n      .setRequired(true)\n      .setExampleValue(\"1\");\n\n    action.createParam(QGatesWs.PARAM_QUERY)\n      .setDescription(\"To search for projects containing this string\")\n      .setExampleValue(\"abc\");\n\n    action.createParam(QGatesWs.PARAM_SELECTED)\n      .setDescription(\"If \\\"selected\\\", search for projects associated to the quality gate.\")\n      .setDefaultValue(\"selected\")\n      .setPossibleValues(\"selected\", \"deselected\")\n      .setExampleValue(\"deselected\");\n\n    action.createParam(QGatesWs.PARAM_PAGE)\n      .setDescription(\"Page number\")\n      .setDefaultValue(\"1\")\n      .setExampleValue(\"2\");\n\n    action.createParam(QGatesWs.PARAM_PAGE_SIZE)\n      .setDescription(\"Page size\")\n      .setExampleValue(\"10\");\n  }","id":93144,"modified_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"search\")\n      .setDescription(\"Search for projects associated (or not) to a quality gate\")\n      .setSince(\"4.3\")\n      .setResponseExample(Resources.getResource(this.getClass(), \"example-search.json\"))\n      .setHandler(this);\n\n    action.createParam(QGatesWs.PARAM_GATE_ID)\n      .setDescription(\"Quality Gate ID\")\n      .setRequired(true)\n      .setExampleValue(\"1\");\n\n    action.createParam(QGatesWs.PARAM_QUERY)\n      .setDescription(\"To search for projects containing this string\")\n      .setExampleValue(\"abc\");\n\n    action.createParam(QGatesWs.PARAM_SELECTED)\n      .setDescription(\"If \\\"selected\\\", search for projects associated to the quality gate\")\n      .setDefaultValue(\"selected\")\n      .setPossibleValues(\"selected\", \"deselected\")\n      .setExampleValue(\"deselected\");\n\n    action.createParam(QGatesWs.PARAM_PAGE)\n      .setDescription(\"Page number\")\n      .setDefaultValue(\"1\")\n      .setExampleValue(\"2\");\n\n    action.createParam(QGatesWs.PARAM_PAGE_SIZE)\n      .setDescription(\"Page size\")\n      .setExampleValue(\"10\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineSearchAction(NewController controller) {\n    NewAction action = controller.createAction(\"search\")\n      .setDescription(\"Search for components\")\n      .setSince(\"3.3\")\n      .setInternal(true)\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"resources-example-search.json\"));\n\n    action.createParam(\"s\")\n      .setDescription(\"To filter on resources containing a specified text in their key\")\n      .setExampleValue(\"sonar\");\n\n    action.createParam(\"display_key\")\n      .setDescription(\"Return the resource key instead of the resource id\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\")\n      .setExampleValue(\"true\");\n\n    action.createParam(\"q\")\n      .setDescription(\"Comma-separated list of qualifiers\")\n      .setExampleValue(\"TRK,BRC\");\n\n    action.createParam(\"qp\")\n      .setDescription(\"Resource Property\")\n      .setExampleValue(\"supportsMeasureFilters\");\n\n    action.createParam(\"f\")\n      .setDescription(\"If 's2', then it will return a select2 compatible format\")\n      .setExampleValue(\"s2\");\n\n    action.createParam(\"p\")\n      .setDescription(\"Page index\")\n      .setDefaultValue(\"1\")\n      .setExampleValue(\"2\");\n\n    action.createParam(\"ps\")\n      .setDescription(\"Page size\")\n      .setDefaultValue(\"10\")\n      .setExampleValue(\"15\");\n  }","id":93145,"modified_method":"private void defineSearchAction(NewController controller) {\n    NewAction action = controller.createAction(\"search\")\n      .setDescription(\"Search for components\")\n      .setSince(\"3.3\")\n      .setInternal(true)\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"resources-example-search.json\"));\n\n    action.createParam(\"s\")\n      .setDescription(\"To filter on resources containing a specified text in their key\")\n      .setExampleValue(\"sonar\");\n\n    action.createParam(\"display_key\")\n      .setDescription(\"Return the resource key instead of the resource id\")\n      .setDefaultValue(\"false\")\n      .setBooleanPossibleValues();\n\n    action.createParam(\"q\")\n      .setDescription(\"Comma-separated list of qualifiers\")\n      .setExampleValue(\"TRK,BRC\");\n\n    action.createParam(\"qp\")\n      .setDescription(\"Resource Property\")\n      .setExampleValue(\"supportsMeasureFilters\");\n\n    action.createParam(\"f\")\n      .setDescription(\"If 's2', then it will return a select2 compatible format\")\n      .setExampleValue(\"s2\");\n\n    action.createParam(\"p\")\n      .setDescription(\"Page index\")\n      .setDefaultValue(\"1\")\n      .setExampleValue(\"2\");\n\n    action.createParam(\"ps\")\n      .setDescription(\"Page size\")\n      .setDefaultValue(\"10\")\n      .setExampleValue(\"15\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineSystemAction(NewController controller) {\n    NewAction action = controller.createAction(\"index\")\n      .setDescription(\"Get a list of components. Requires Browse permission on resource\")\n      .setSince(\"2.10\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"resources-example-index.json\"));\n\n    action.createParam(\"resource\")\n      .setDescription(\"id or key of the resource\")\n      .setExampleValue(\"org.codehaus.sonar:sonar\");\n\n    action.createParam(\"metrics\")\n      .setDescription(\"Comma-separated list of <a href=\\\"http://docs.codehaus.org/display/SONAR/Metric+definitions\\\">metric keys/ids<\/a>. \" +\n        \"Load measures on selected metrics. If only one metric is set, then measures are ordered by value.\")\n      .setExampleValue(\"lines,blocker_violations\");\n\n    action.createParam(\"depth\")\n      .setDescription(\"Used only when resource is set.<br/>\" +\n        \"<ul>\" +\n        \"<li>0: only selected resource<\/li>\" +\n        \"<li>-1: all children, including selected resource<\/li>\" +\n        \"<li>>0: depth toward the selected resource<\/li>\" +\n        \"<\/ul>\")\n      .setDefaultValue(\"0\")\n      .setExampleValue(\"-1\");\n\n    action.createParam(\"scopes\")\n      .setDescription(\"Comma-separated list of scopes:<br/>\" +\n        \"<ul>\" +\n        \"<li>PRJ: project/module<\/li>\" +\n        \"<li>DIR: directory (like Java package)<\/li>\" +\n        \"<li>FIL: file<\/li>\" +\n        \"<\/ul>\")\n      .setExampleValue(\"PRJ,DIR\");\n\n    action.createParam(\"qualifiers\")\n      .setDescription(\"Comma-separated list of qualifiers:<br/>\" +\n        \"<ul>\" +\n        \"<li>VW: view<\/li>\" +\n        \"<li>SVW: sub-view<\/li>\" +\n        \"<li>TRK: project<\/li>\" +\n        \"<li>BRC: module<\/li>\" +\n        \"<li>UTS: unit test<\/li>\" +\n        \"<li>DIR: directory<\/li>\" +\n        \"<li>FIL: file<\/li>\" +\n        \"<li>DEV: developer<\/li>\" +\n        \"<\/ul>\")\n      .setExampleValue(\"TRK,BRC\");\n\n    action.createParam(\"verbose\")\n      .setDescription(\"Add some data to response\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\")\n      .setExampleValue(\"true\");\n\n    action.createParam(\"limit\")\n      .setDescription(\"Limit the number of results. Only used if one metric, and only one, is set\")\n      .setExampleValue(\"10\");\n\n    action.createParam(\"includetrends\")\n      .setDescription(\"Include trends and period variations in response: add <trend> (1 if better, else worse), <var> (1 if measure value increases) \" +\n        \"and nodes <p*> for period variations\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\")\n      .setExampleValue(\"true\");\n\n    action.createParam(\"includealerts\")\n      .setDescription(\"Include alerts data: add nodes <alert> (ERROR, WARN, OK) and <alert_text>\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\")\n      .setExampleValue(\"true\");\n\n    action.createParam(\"rules\")\n      .setDescription(\"Filter on rules: setting it to true will return rules id and rule name for measure having such info \" +\n        \"(such as 'blocker_violations', 'critical_violations', ..., 'new_blocker_violations', ...). Possible values: true | false | list of rule ids\")\n      .setDefaultValue(\"false\")\n      .setExampleValue(\"true\");\n  }","id":93146,"modified_method":"private void defineSystemAction(NewController controller) {\n    NewAction action = controller.createAction(\"index\")\n      .setDescription(\"Get a list of components. Requires Browse permission on resource\")\n      .setSince(\"2.10\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"resources-example-index.json\"));\n\n    action.createParam(\"resource\")\n      .setDescription(\"id or key of the resource\")\n      .setExampleValue(\"org.codehaus.sonar:sonar\");\n\n    action.createParam(\"metrics\")\n      .setDescription(\"Comma-separated list of <a href=\\\"http://docs.codehaus.org/display/SONAR/Metric+definitions\\\">metric keys/ids<\/a>. \" +\n        \"Load measures on selected metrics. If only one metric is set, then measures are ordered by value\")\n      .setExampleValue(\"lines,blocker_violations\");\n\n    action.createParam(\"depth\")\n      .setDescription(\"Used only when resource is set:<br/>\" +\n        \"<ul>\" +\n        \"<li>0: only selected resource<\/li>\" +\n        \"<li>-1: all children, including selected resource<\/li>\" +\n        \"<li>>0: depth toward the selected resource<\/li>\" +\n        \"<\/ul>\")\n      .setDefaultValue(\"0\")\n      .setExampleValue(\"-1\");\n\n    action.createParam(\"scopes\")\n      .setDescription(\"Comma-separated list of scopes:<br/>\" +\n        \"<ul>\" +\n        \"<li>PRJ: project/module<\/li>\" +\n        \"<li>DIR: directory (like Java package)<\/li>\" +\n        \"<li>FIL: file<\/li>\" +\n        \"<\/ul>\")\n      .setExampleValue(\"PRJ,DIR\");\n\n    action.createParam(\"qualifiers\")\n      .setDescription(\"Comma-separated list of qualifiers:<br/>\" +\n        \"<ul>\" +\n        \"<li>VW: view<\/li>\" +\n        \"<li>SVW: sub-view<\/li>\" +\n        \"<li>TRK: project<\/li>\" +\n        \"<li>BRC: module<\/li>\" +\n        \"<li>UTS: unit test<\/li>\" +\n        \"<li>DIR: directory<\/li>\" +\n        \"<li>FIL: file<\/li>\" +\n        \"<li>DEV: developer<\/li>\" +\n        \"<\/ul>\")\n      .setExampleValue(\"TRK,BRC\");\n\n    action.createParam(\"verbose\")\n      .setDescription(\"Add some data to response\")\n      .setDefaultValue(\"false\")\n      .setBooleanPossibleValues();\n\n    action.createParam(\"limit\")\n      .setDescription(\"Limit the number of results. Only used if one metric, and only one, is set\")\n      .setExampleValue(\"10\");\n\n    action.createParam(\"includetrends\")\n      .setDescription(\"Include trends and period variations in response: add <trend> (1 if better, else worse), <var> (1 if measure value increases) \" +\n        \"and nodes <p*> for period variations\")\n      .setDefaultValue(\"false\")\n      .setBooleanPossibleValues();\n\n    action.createParam(\"includealerts\")\n      .setDescription(\"Include alerts data: add nodes <alert> (ERROR, WARN, OK) and <alert_text>\")\n      .setDefaultValue(\"false\")\n      .setBooleanPossibleValues();\n\n    action.createParam(\"rules\")\n      .setDescription(\"Filter on rules: setting it to true will return rules id and rule name for measure having such info \" +\n        \"(such as 'blocker_violations', 'critical_violations', ..., 'new_blocker_violations', ...). Possible values: true | false | list of rule ids\")\n      .setDefaultValue(\"false\")\n      .setExampleValue(\"true\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void define(WebService.NewController controller) {\n    controller.createAction(\"restart\")\n      .setDescription(\"Restart server. Available only on development mode (sonar.dev=true), except when using Java 6 \" +\n        \"on MS Windows. Ruby on Rails extensions are not reloaded.\")\n      .setSince(\"4.3\")\n      .setPost(true)\n      .setHandler(this);\n  }","id":93147,"modified_method":"void define(WebService.NewController controller) {\n    controller.createAction(\"restart\")\n      .setDescription(\"Restart server. Available only on development mode (sonar.dev=true), except when using Java 6 \" +\n        \"on MS Windows. Ruby on Rails extensions are not reloaded\")\n      .setSince(\"4.3\")\n      .setPost(true)\n      .setHandler(this);\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"scm\")\n      .setDescription(\"Get SCM information of source files\")\n      .setSince(\"4.4\")\n      .setHandler(this);\n\n    action\n      .createParam(\"key\")\n      .setRequired(true)\n      .setDescription(\"File key\")\n      .setExampleValue(\"my_project:/src/foo/Bar.php\");\n\n    action\n      .createParam(\"from\")\n      .setDescription(\"First line to return. Starts at 1.\")\n      .setExampleValue(\"10\")\n      .setDefaultValue(\"1\");\n\n    action\n      .createParam(\"to\")\n      .setDescription(\"Last line to return (inclusive)\")\n      .setExampleValue(\"20\");\n\n    action\n      .createParam(\"group_commits\")\n      .setDescription(\"Group lines by SCM commit\")\n      .setPossibleValues(\"false\", \"true\")\n      .setDefaultValue(\"true\");\n  }","id":93148,"modified_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"scm\")\n      .setDescription(\"Get SCM information of source files\")\n      .setSince(\"4.4\")\n      .setHandler(this);\n\n    action\n      .createParam(\"key\")\n      .setRequired(true)\n      .setDescription(\"File key\")\n      .setExampleValue(\"my_project:/src/foo/Bar.php\");\n\n    action\n      .createParam(\"from\")\n      .setDescription(\"First line to return. Starts at 1.\")\n      .setExampleValue(\"10\")\n      .setDefaultValue(\"1\");\n\n    action\n      .createParam(\"to\")\n      .setDescription(\"Last line to return (inclusive)\")\n      .setExampleValue(\"20\");\n\n    action\n      .createParam(\"group_commits\")\n      .setDescription(\"Group lines by SCM commit\")\n      .setBooleanPossibleValues()\n      .setDefaultValue(\"true\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller\n      .createAction(\"search\")\n      .setDescription(\"Search for a collection of relevant rules matching a specified query\")\n      .setSince(\"4.4\")\n      .setHandler(this);\n\n    action\n      .createParam(PARAM_TEXT_QUERY)\n      .setDescription(\"UTF-8 search query\")\n      .setExampleValue(\"null pointer\");\n\n    action\n      .createParam(PARAM_REPOSITORIES)\n      .setDescription(\"Comma-separated list of repositories\")\n      .setExampleValue(\"checkstyle,findbugs\");\n\n    action\n      .createParam(PARAM_SEVERITIES)\n      .setDescription(\"Comma-separated list of default severities. Not the same than severity of rules in Quality profiles.\")\n      .setPossibleValues(Severity.ALL)\n      .setExampleValue(\"CRITICAL,BLOCKER\");\n\n    action\n      .createParam(PARAM_LANGUAGES)\n      .setDescription(\"Comma-separated list of languages\")\n      .setExampleValue(\"java,js\");\n\n    action\n      .createParam(PARAM_STATUSES)\n      .setDescription(\"Comma-separated list of status codes\")\n      .setPossibleValues(RuleStatus.values())\n      .setExampleValue(RuleStatus.READY.toString());\n\n    action\n      .createParam(PARAM_DEBT_CHARACTERISTICS)\n      .setDescription(\"Comma-separated list of technical debt characteristics or sub-characteristics\")\n      .setExampleValue(\"RELIABILITY\");\n\n    action\n      .createParam(PARAM_HAS_DEBT_CHARACTERISTIC)\n      .setDescription(\"Filter rules that have a technical debt characteristic\")\n      .setPossibleValues(\"false\", \"true\");\n\n    action\n      .createParam(PARAM_TAGS)\n      .setDescription(\"Comma-separated list of tags. Returned rules match any of the tags (OR operator)\")\n      .setExampleValue(\"security,java8\");\n\n    action\n      .createParam(PARAM_ALL_OF_TAGS)\n      .setDescription(\"Comma-separated list of tags. Returned rules match all the tags (AND operator)\")\n      .setExampleValue(\"security,java8\");\n\n    action\n      .createParam(\"qprofile\")\n      .setDescription(\"Key of Quality profile\")\n      .setExampleValue(\"java:Sonar way\");\n\n    action\n      .createParam(\"activation\")\n      .setDescription(\"Used only if 'qprofile' is set\")\n      .setExampleValue(\"java:Sonar way\")\n      .setPossibleValues(\"false\", \"true\", \"all\");\n\n    action\n      .createParam(PARAM_FIELDS)\n      .setDescription(\"Comma-separated list of the fields to be returned in response. All the fields are returned by default.\")\n      .setPossibleValues(RuleIndex.PUBLIC_FIELDS)\n      .setExampleValue(String.format(\"%s,%s,%s\", RuleNormalizer.RuleField.KEY, RuleNormalizer.RuleField.REPOSITORY, RuleNormalizer.RuleField.LANGUAGE));\n\n    action\n      .createParam(PARAM_PAGE)\n      .setDescription(\"1-based page number\")\n      .setExampleValue(\"42\")\n      .setDefaultValue(\"1\");\n\n    action\n      .createParam(PARAM_PAGE_SIZE)\n      .setDescription(\"Page size. Must be greater than 0.\")\n      .setExampleValue(\"10\")\n      .setDefaultValue(\"25\");\n\n    // TODO limit the fields to sort on + document possible values + default value ?\n    action\n      .createParam(PARAM_SORT)\n      .setDescription(\"Sort field\")\n      .setExampleValue(RuleNormalizer.RuleField.LANGUAGE.key());\n\n    action\n      .createParam(PARAM_ASCENDING)\n      .setDescription(\"Ascending sort\")\n      .setPossibleValues(\"false\", \"true\")\n      .setDefaultValue(\"true\");\n  }","id":93149,"modified_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller\n      .createAction(\"search\")\n      .setDescription(\"Search for a collection of relevant rules matching a specified query\")\n      .setSince(\"4.4\")\n      .setHandler(this);\n\n    action\n      .createParam(PARAM_TEXT_QUERY)\n      .setDescription(\"UTF-8 search query\")\n      .setExampleValue(\"null pointer\");\n\n    action\n      .createParam(PARAM_REPOSITORIES)\n      .setDescription(\"Comma-separated list of repositories\")\n      .setExampleValue(\"checkstyle,findbugs\");\n\n    action\n      .createParam(PARAM_SEVERITIES)\n      .setDescription(\"Comma-separated list of default severities. Not the same than severity of rules in Quality profiles.\")\n      .setPossibleValues(Severity.ALL)\n      .setExampleValue(\"CRITICAL,BLOCKER\");\n\n    action\n      .createParam(PARAM_LANGUAGES)\n      .setDescription(\"Comma-separated list of languages\")\n      .setExampleValue(\"java,js\");\n\n    action\n      .createParam(PARAM_STATUSES)\n      .setDescription(\"Comma-separated list of status codes\")\n      .setPossibleValues(RuleStatus.values())\n      .setExampleValue(RuleStatus.READY.toString());\n\n    action\n      .createParam(PARAM_DEBT_CHARACTERISTICS)\n      .setDescription(\"Comma-separated list of technical debt characteristics or sub-characteristics\")\n      .setExampleValue(\"RELIABILITY\");\n\n    action\n      .createParam(PARAM_HAS_DEBT_CHARACTERISTIC)\n      .setDescription(\"Filter rules that have a technical debt characteristic\")\n      .setBooleanPossibleValues();\n\n    action\n      .createParam(PARAM_TAGS)\n      .setDescription(\"Comma-separated list of tags. Returned rules match any of the tags (OR operator)\")\n      .setExampleValue(\"security,java8\");\n\n    action\n      .createParam(PARAM_ALL_OF_TAGS)\n      .setDescription(\"Comma-separated list of tags. Returned rules match all the tags (AND operator)\")\n      .setExampleValue(\"security,java8\");\n\n    action\n      .createParam(\"qprofile\")\n      .setDescription(\"Key of Quality profile\")\n      .setExampleValue(\"java:Sonar way\");\n\n    action\n      .createParam(\"activation\")\n      .setDescription(\"Used only if 'qprofile' is set\")\n      .setExampleValue(\"java:Sonar way\")\n      .setPossibleValues(\"false\", \"true\", \"all\");\n\n    action\n      .createParam(PARAM_FIELDS)\n      .setDescription(\"Comma-separated list of the fields to be returned in response. All the fields are returned by default.\")\n      .setPossibleValues(RuleIndex.PUBLIC_FIELDS)\n      .setExampleValue(String.format(\"%s,%s,%s\", RuleNormalizer.RuleField.KEY, RuleNormalizer.RuleField.REPOSITORY, RuleNormalizer.RuleField.LANGUAGE));\n\n    action\n      .createParam(PARAM_PAGE)\n      .setDescription(\"1-based page number\")\n      .setExampleValue(\"42\")\n      .setDefaultValue(\"1\");\n\n    action\n      .createParam(PARAM_PAGE_SIZE)\n      .setDescription(\"Page size. Must be greater than 0.\")\n      .setExampleValue(\"10\")\n      .setDefaultValue(\"25\");\n\n    // TODO limit the fields to sort on + document possible values + default value ?\n    action\n      .createParam(PARAM_SORT)\n      .setDescription(\"Sort field\")\n      .setExampleValue(RuleNormalizer.RuleField.LANGUAGE.key());\n\n    action\n      .createParam(PARAM_ASCENDING)\n      .setDescription(\"Ascending sort\")\n      .setBooleanPossibleValues()\n      .setDefaultValue(\"true\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"show\")\n      .setDescription(\"Get source code. Parameter 'output' with value 'raw' is missing before being marked as a public WS.\")\n      .setSince(\"4.2\")\n      .setInternal(true)\n      .setResponseExample(Resources.getResource(getClass(), \"example-show.json\"))\n      .setHandler(this);\n\n    action\n      .createParam(\"key\")\n      .setRequired(true)\n      .setDescription(\"File key\")\n      .setExampleValue(\"my_project:/src/foo/Bar.php\");\n\n    action\n      .createParam(\"from\")\n      .setDescription(\"First line to return. Starts at 1.\")\n      .setExampleValue(\"10\")\n      .setDefaultValue(\"1\");\n\n    action\n      .createParam(\"to\")\n      .setDescription(\"Last line to return (inclusive)\")\n      .setExampleValue(\"20\");\n\n    action\n      .createParam(\"scm\")\n      .setDescription(\"Enable loading of SCM information per line\")\n      .setPossibleValues(\"true\", \"false\")\n      .setDefaultValue(\"false\");\n\n    action\n      .createParam(\"group_commits\")\n      .setDescription(\"Group lines by SCM commit. Used only if 'scm' is 'true'\")\n      .setPossibleValues(\"false\", \"true\")\n      .setDefaultValue(\"true\");\n  }","id":93150,"modified_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"show\")\n      .setDescription(\"Get source code. Parameter 'output' with value 'raw' is missing before being marked as a public WS\")\n      .setSince(\"4.2\")\n      .setInternal(true)\n      .setResponseExample(Resources.getResource(getClass(), \"example-show.json\"))\n      .setHandler(this);\n\n    action\n      .createParam(\"key\")\n      .setRequired(true)\n      .setDescription(\"File key\")\n      .setExampleValue(\"my_project:/src/foo/Bar.php\");\n\n    action\n      .createParam(\"from\")\n      .setDescription(\"First line to return. Starts at 1\")\n      .setExampleValue(\"10\")\n      .setDefaultValue(\"1\");\n\n    action\n      .createParam(\"to\")\n      .setDescription(\"Last line to return (inclusive)\")\n      .setExampleValue(\"20\");\n\n    action\n      .createParam(\"scm\")\n      .setDescription(\"Enable loading of SCM information per line\")\n      .setBooleanPossibleValues();\n\n    action\n      .createParam(\"group_commits\")\n      .setDescription(\"Group lines by SCM commit. Used only if 'scm' is 'true'\")\n      .setBooleanPossibleValues()\n      .setDefaultValue(\"true\");\n  }","commit_id":"d54dee624fae870d8079539823447713a1db6e65","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void doPartitionDetectionActivities(Set<Integer> failedHostIds)\n    {\n        if (m_shuttingDown) {\n            return;\n        }\n\n        // We should never re-enter here once we've decided we're partitioned and doomed\n        Preconditions.checkState(!m_partitionDetected, \"Partition detection triggered twice.\");\n\n        // figure out previous and current cluster memberships\n        Set<Integer> previousHosts = getLiveHostIds();\n        Set<Integer> currentHosts = new HashSet<>(previousHosts);\n        currentHosts.removeAll(failedHostIds);\n\n        // sanity!\n        Preconditions.checkState(previousHosts.contains(m_localHostId));\n        Preconditions.checkState(currentHosts.contains(m_localHostId));\n\n        // decide if we're partitioned\n        // this will print out warnings if we are\n        if (makePPDDecision(m_localHostId, previousHosts, currentHosts, m_partitionDetectionEnabled.get())) {\n            // record here so we can ensure this only happens once for this node\n            m_partitionDetected = true;\n            VoltDB.crashGlobalVoltDB(\"Partition detection logic will stop this process to ensure against split brains.\",\n                        false, null);\n        }\n    }","id":93151,"modified_method":"private void doPartitionDetectionActivities(Set<Integer> failedHostIds)\n    {\n        if (m_shuttingDown) {\n            return;\n        }\n\n        // We should never re-enter here once we've decided we're partitioned and doomed\n        Preconditions.checkState(!m_partitionDetected, \"Partition detection triggered twice.\");\n\n        // figure out previous and current cluster memberships\n        Set<Integer> previousHosts = getLiveHostIds();\n        Set<Integer> currentHosts = new HashSet<>(previousHosts);\n        currentHosts.removeAll(failedHostIds);\n\n        // sanity!\n        Preconditions.checkState(previousHosts.contains(m_localHostId));\n        Preconditions.checkState(currentHosts.contains(m_localHostId));\n\n        // decide if we're partitioned\n        // this will print out warnings if we are\n        if (makePPDDecision(m_localHostId, previousHosts, currentHosts, m_partitionDetectionEnabled.get())) {\n            // record here so we can ensure this only happens once for this node\n            m_partitionDetected = true;\n            VoltDB.crashLocalVoltDB(\"Partition detection logic will stop this process to ensure against split brains.\",\n                        false, null);\n        }\n    }","commit_id":"f2c65b99c7d7fda48556d15f4ba9fae158861e54","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Cut the network connection between two hostids immediately\n     * Useful for simulating network partitions\n     */\n    public void cutLink(int hostIdA, int hostIdB) {\n        if (m_localHostId == hostIdA) {\n            ForeignHost fh = m_foreignHosts.get(hostIdB);\n            fh.cutLink();\n        }\n        if (m_localHostId == hostIdB) {\n            ForeignHost fh = m_foreignHosts.get(hostIdA);\n            fh.cutLink();\n        }\n    }","id":93152,"modified_method":"/**\n     * Cut the network connection between two hostids immediately\n     * Useful for simulating network partitions\n     */\n    public void cutLink(int hostIdA, int hostIdB) {\n        if (m_localHostId == hostIdA) {\n            ForeignHost fh = m_foreignHosts.get(hostIdB);\n            if (fh != null) {\n                fh.cutLink();\n            }\n        }\n        if (m_localHostId == hostIdB) {\n            ForeignHost fh = m_foreignHosts.get(hostIdA);\n            if (fh != null) {\n                fh.cutLink();\n            }\n        }\n    }","commit_id":"f2c65b99c7d7fda48556d15f4ba9fae158861e54","url":"https://github.com/VoltDB/voltdb"},{"original_method":"protected void clearInTrouble(Set<Long> decision) {\n        m_forwardCandidates.clear();\n        m_failedSitesLedger.clear();\n        m_inTrouble.clear();\n        m_inTroubleCount = 0;\n    }","id":93153,"modified_method":"protected void clearInTrouble(Set<Long> decision) {\n        m_forwardCandidates.clear();\n        m_failedSitesLedger.clear();\n        m_decidedSurvivors.clear();\n        m_localHistoricDecisions.clear();\n        m_inTrouble.clear();\n        m_inTroubleCount = 0;\n    }","commit_id":"f2c65b99c7d7fda48556d15f4ba9fae158861e54","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Notify all survivors when you are closing links to nodes\n     * @param decision map where the keys contain the kill sites\n     *   and its values are their last known safe transaction ids\n     */\n    protected void notifyOnKill(Set<Long> hsIds, Map<Long, Long> decision) {\n\n        SiteFailureMessage.Builder sfmb = SiteFailureMessage.\n                builder()\n                .decisions(decision.keySet())\n                .failures(decision.keySet());\n\n        Set<Long> dests = Sets.filter(m_seeker.getSurvivors(), not(equalTo(m_hsId)));\n        if (dests.isEmpty()) return;\n\n        sfmb.survivors(Sets.difference(m_seeker.getSurvivors(), decision.keySet()));\n        sfmb.safeTxnIds(getSafeTxnIdsForSites(hsIds));\n\n        SiteFailureMessage sfm = sfmb.build();\n        m_mailbox.send(Longs.toArray(dests), sfm);\n\n        m_recoveryLog.info(\"Agreement, Sending [\"\n                + CoreUtils.hsIdCollectionToString(dests) + \"]  \" + sfm);\n    }","id":93154,"modified_method":"/**\n     * Notify all survivors when you are closing links to nodes\n     * @param decision map where the keys contain the kill sites\n     *   and its values are their last known safe transaction ids\n     * @return true if successfully confirmed that all survivors\n     * agree on the decision, false otherwise.\n     */\n    protected boolean notifyOnKill(Set<Long> hsIds, Map<Long, Long> decision) {\n\n        SiteFailureMessage.Builder sfmb = SiteFailureMessage.\n                builder()\n                .decisions(decision.keySet())\n                .failures(decision.keySet());\n\n        Set<Long> dests = Sets.filter(m_seeker.getSurvivors(), not(equalTo(m_hsId)));\n        if (dests.isEmpty()) return true;\n\n        sfmb.survivors(Sets.difference(m_seeker.getSurvivors(), decision.keySet()));\n        sfmb.safeTxnIds(getSafeTxnIdsForSites(hsIds));\n\n        SiteFailureMessage sfm = sfmb.build();\n        m_mailbox.send(Longs.toArray(dests), sfm);\n\n        m_recoveryLog.info(\"Agreement, Sending [\"\n                + CoreUtils.hsIdCollectionToString(dests) + \"]  \" + sfm);\n\n        // Check to see we've made the same decision before, if so, it's likely\n        // that we've entered a loop, exit here.\n        if (m_localHistoricDecisions.size() >= 100) {\n            // Too many decisions have been made without converging\n            RateLimitedLogger.tryLogForMessage(System.currentTimeMillis(),\n                                               10, TimeUnit.SECONDS,\n                                               m_recoveryLog,\n                                               Level.WARN,\n                                               \"Agreement, %d local decisions have been made without converging\",\n                                               m_localHistoricDecisions.size());\n        }\n        for (SiteFailureMessage lhd : m_localHistoricDecisions) {\n            if (lhd.m_survivors.equals(sfm.m_survivors)) {\n                m_recoveryLog.info(\"Agreement, detected decision loop. Exiting\");\n                return true;\n            }\n        }\n        m_localHistoricDecisions.add(sfm);\n\n        // Wait for all survivors in the local decision to send their decisions over.\n        // If one of the host's decision conflicts with ours, remove that host's link\n        // and repeat the decision process.\n        final Set<Long> expectedSurvivors = Sets.filter(sfm.m_survivors, not(equalTo(m_hsId)));\n        m_recoveryLog.info(\"Agreement, Waiting for agreement on decision from survivors \" +\n                           CoreUtils.hsIdCollectionToString(expectedSurvivors));\n\n        final Iterator<SiteFailureMessage> iter = m_decidedSurvivors.values().iterator();\n        while (iter.hasNext()) {\n            final SiteFailureMessage remoteDecision = iter.next();\n            if (expectedSurvivors.contains(remoteDecision.m_sourceHSId)) {\n                if (remoteDecision.m_decision.contains(m_hsId)) {\n                    iter.remove();\n                    m_recoveryLog.info(\"Agreement, Received inconsistent decision from \" +\n                                       CoreUtils.hsIdToString(remoteDecision.m_sourceHSId) + \", \" + remoteDecision);\n                    final FaultMessage localFault = new FaultMessage(m_hsId, remoteDecision.m_sourceHSId);\n                    localFault.m_sourceHSId = m_hsId;\n                    m_mailbox.deliverFront(localFault);\n                    return false;\n                }\n            }\n        }\n\n        long start = System.currentTimeMillis();\n        boolean allDecisionsMatch = true;\n        do {\n            final VoltMessage msg = m_mailbox.recvBlocking(receiveSubjects, 5);\n            if (msg == null) {\n                // Send a heartbeat to keep the dead host timeout active.\n                m_meshAide.sendHeartbeats(m_seeker.getSurvivors());\n                final long duration = System.currentTimeMillis() - start;\n                if (duration > 20000) {\n                    m_recoveryLog.error(\"Agreement, Still waiting for decisions from \" +\n                                        CoreUtils.hsIdCollectionToString(Sets.difference(expectedSurvivors, m_decidedSurvivors.keySet())) +\n                                        \" after \" + TimeUnit.MILLISECONDS.toSeconds(duration) + \" seconds\");\n                    start = System.currentTimeMillis();\n                }\n                continue;\n            }\n\n            if (m_hsId != msg.m_sourceHSId && !expectedSurvivors.contains(msg.m_sourceHSId)) {\n                // Ignore messages from failed sites\n                continue;\n            }\n\n            if (msg.getSubject() == Subject.SITE_FAILURE_UPDATE.getId()) {\n                final SiteFailureMessage fm = (SiteFailureMessage) msg;\n                if (!fm.m_decision.isEmpty()) {\n                    if (expectedSurvivors.contains(fm.m_sourceHSId)) {\n                        if (fm.m_decision.contains(m_hsId)) {\n                            m_decidedSurvivors.remove(fm.m_sourceHSId);\n                            // The remote host has decided that we are gone, remove the remote host\n                            final FaultMessage localFault = new FaultMessage(m_hsId, fm.m_sourceHSId);\n                            localFault.m_sourceHSId = m_hsId;\n                            m_mailbox.deliverFront(localFault);\n                            return false;\n                        } else {\n                            m_decidedSurvivors.put(fm.m_sourceHSId, fm);\n                        }\n                    }\n                } else {\n                    m_mailbox.deliverFront(fm);\n                    return false;\n                }\n            } else if (msg.getSubject() == Subject.FAILURE.getId()) {\n                final FaultMessage fm = (FaultMessage) msg;\n                if (!fm.decided) {\n                    // In case of concurrent fault, handle it\n                    m_mailbox.deliverFront(msg);\n                    return false;\n                } else if (mayIgnore(hsIds, fm) == Discard.DoNot) {\n                    m_mailbox.deliverFront(msg);\n                    return false;\n                }\n            }\n\n            for (SiteFailureMessage remoteDecision : m_decidedSurvivors.values()) {\n                if (!sfm.m_survivors.equals(remoteDecision.m_survivors)) {\n                    allDecisionsMatch = false;\n                }\n            }\n        } while (!m_decidedSurvivors.keySet().containsAll(expectedSurvivors) && allDecisionsMatch);\n\n        return true;\n    }","commit_id":"f2c65b99c7d7fda48556d15f4ba9fae158861e54","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Collect the failure site update messages from all sites This site sent\n     * its own mailbox the above broadcast the maximum is local to this site.\n     * This also ensures at least one response.\n     *\n     * Concurrent failures can be detected by additional reports from the FaultDistributor\n     * or a mismatch in the set of failed hosts reported in a message from another site\n     */\n    private boolean discoverGlobalFaultData_rcv(Set<Long> hsIds) {\n\n        long blockedOnReceiveStart = System.currentTimeMillis();\n        long lastReportTime = 0;\n        boolean haveEnough = false;\n        int [] forwardStallCount = new int[] {FORWARD_STALL_COUNT};\n\n        do {\n            VoltMessage m = m_mailbox.recvBlocking(receiveSubjects, 5);\n\n            /*\n             * If fault resolution takes longer then 10 seconds start logging\n             */\n            final long now = System.currentTimeMillis();\n            if (now - blockedOnReceiveStart > 10000) {\n                if (now - lastReportTime > 60000) {\n                    lastReportTime = System.currentTimeMillis();\n                    haveNecessaryFaultInfo(m_seeker.getSurvivors(), true);\n                }\n            }\n\n            if (m == null) {\n                // Send a heartbeat to keep the dead host timeout active.  Needed because IV2 doesn't\n                // generate its own heartbeats to keep this running.\n                m_meshAide.sendHeartbeats(m_seeker.getSurvivors());\n\n            } else if (m.getSubject() == Subject.SITE_FAILURE_UPDATE.getId()) {\n\n                SiteFailureMessage sfm = (SiteFailureMessage) m;\n\n                if (  !m_seeker.getSurvivors().contains(m.m_sourceHSId)\n                    || m_failedSites.contains(m.m_sourceHSId)\n                    || m_failedSites.containsAll(sfm.getFailedSites())) continue;\n\n                updateFailedSitesLedger(hsIds, sfm);\n\n                m_seeker.add(sfm);\n                addForwardCandidate(new SiteFailureForwardMessage(sfm));\n\n                m_recoveryLog.info(\"Agreement, Received \" + sfm);\n\n            } else if (m.getSubject() == Subject.SITE_FAILURE_FORWARD.getId()) {\n\n                SiteFailureForwardMessage fsfm = (SiteFailureForwardMessage) m;\n\n                addForwardCandidate(fsfm);\n\n                if (   !hsIds.contains(fsfm.m_sourceHSId)\n                    || m_seeker.getSurvivors().contains(fsfm.m_reportingHSId)\n                    || m_failedSites.contains(fsfm.m_reportingHSId)\n                    || m_failedSites.containsAll(fsfm.getFailedSites())) continue;\n\n                m_seeker.add(fsfm);\n\n                m_recoveryLog.info(\"Agreement, Received forward \" + fsfm);\n\n                forwardStallCount[0] = FORWARD_STALL_COUNT;\n\n            } else if (m.getSubject() == Subject.FAILURE.getId()) {\n                /*\n                 * If the fault distributor reports a new fault, ignore it if it is known , otherwise\n                 * re-deliver the message to ourself and then abort so that the process can restart.\n                 */\n                FaultMessage fm = (FaultMessage) m;\n\n                Discard ignoreIt = mayIgnore(hsIds, fm);\n                if (Discard.DoNot == ignoreIt) {\n                    m_mailbox.deliverFront(m);\n                    m_recoveryLog.info(\"Agreement, Detected a concurrent failure from FaultDistributor, new failed site \"\n                            + CoreUtils.hsIdToString(fm.failedSite));\n                    return false;\n                } else {\n                    if (m_recoveryLog.isDebugEnabled()) {\n                        ignoreIt.log(fm);\n                    }\n                }\n            }\n\n            haveEnough = haveEnough || haveNecessaryFaultInfo(m_seeker.getSurvivors(), false);\n            if (haveEnough) {\n\n                Iterator<Map.Entry<Long, SiteFailureForwardMessage>> itr =\n                        m_forwardCandidates.entrySet().iterator();\n\n                while (itr.hasNext()) {\n                    Map.Entry<Long, SiteFailureForwardMessage> e = itr.next();\n                    Set<Long> unseenBy = m_seeker.forWhomSiteIsDead(e.getKey());\n                    if (unseenBy.size() > 0) {\n                        m_mailbox.send(Longs.toArray(unseenBy), e.getValue());\n                        m_recoveryLog.info(\"Agreement, fowarding to \"\n                                + CoreUtils.hsIdCollectionToString(unseenBy)\n                                + \" \" + e.getValue());\n                    }\n                    itr.remove();\n                }\n            }\n\n        } while (!haveEnough || m_seeker.needForward(forwardStallCount));\n\n        return true;\n    }","id":93155,"modified_method":"/**\n     * Collect the failure site update messages from all sites This site sent\n     * its own mailbox the above broadcast the maximum is local to this site.\n     * This also ensures at least one response.\n     *\n     * Concurrent failures can be detected by additional reports from the FaultDistributor\n     * or a mismatch in the set of failed hosts reported in a message from another site\n     */\n    private boolean discoverGlobalFaultData_rcv(Set<Long> hsIds) {\n\n        long blockedOnReceiveStart = System.currentTimeMillis();\n        long lastReportTime = 0;\n        boolean haveEnough = false;\n        int [] forwardStallCount = new int[] {FORWARD_STALL_COUNT};\n\n        do {\n            VoltMessage m = m_mailbox.recvBlocking(receiveSubjects, 5);\n\n            /*\n             * If fault resolution takes longer then 10 seconds start logging\n             */\n            final long now = System.currentTimeMillis();\n            if (now - blockedOnReceiveStart > 10000) {\n                if (now - lastReportTime > 60000) {\n                    lastReportTime = System.currentTimeMillis();\n                    haveNecessaryFaultInfo(m_seeker.getSurvivors(), true);\n                }\n            }\n\n            if (m == null) {\n                // Send a heartbeat to keep the dead host timeout active.  Needed because IV2 doesn't\n                // generate its own heartbeats to keep this running.\n                m_meshAide.sendHeartbeats(m_seeker.getSurvivors());\n\n            } else if (m.getSubject() == Subject.SITE_FAILURE_UPDATE.getId()) {\n\n                SiteFailureMessage sfm = (SiteFailureMessage) m;\n\n                if (  !m_seeker.getSurvivors().contains(m.m_sourceHSId)\n                    || m_failedSites.contains(m.m_sourceHSId)\n                    || m_failedSites.containsAll(sfm.getFailedSites())) continue;\n\n                if (!sfm.m_decision.isEmpty()) {\n                    m_decidedSurvivors.put(sfm.m_sourceHSId, sfm);\n                }\n\n                updateFailedSitesLedger(hsIds, sfm);\n\n                m_seeker.add(sfm);\n                addForwardCandidate(new SiteFailureForwardMessage(sfm));\n\n                m_recoveryLog.info(\"Agreement, Received \" + sfm);\n\n            } else if (m.getSubject() == Subject.SITE_FAILURE_FORWARD.getId()) {\n\n                SiteFailureForwardMessage fsfm = (SiteFailureForwardMessage) m;\n\n                addForwardCandidate(fsfm);\n\n                if (   !hsIds.contains(fsfm.m_sourceHSId)\n                    || m_seeker.getSurvivors().contains(fsfm.m_reportingHSId)\n                    || m_failedSites.contains(fsfm.m_reportingHSId)\n                    || m_failedSites.containsAll(fsfm.getFailedSites())) continue;\n\n                m_seeker.add(fsfm);\n\n                m_recoveryLog.info(\"Agreement, Received forward \" + fsfm);\n\n                forwardStallCount[0] = FORWARD_STALL_COUNT;\n\n            } else if (m.getSubject() == Subject.FAILURE.getId()) {\n                /*\n                 * If the fault distributor reports a new fault, ignore it if it is known , otherwise\n                 * re-deliver the message to ourself and then abort so that the process can restart.\n                 */\n                FaultMessage fm = (FaultMessage) m;\n\n                Discard ignoreIt = mayIgnore(hsIds, fm);\n                if (Discard.DoNot == ignoreIt) {\n                    m_mailbox.deliverFront(m);\n                    m_recoveryLog.info(\"Agreement, Detected a concurrent failure from FaultDistributor, new failed site \"\n                            + CoreUtils.hsIdToString(fm.failedSite));\n                    return false;\n                } else {\n                    if (m_recoveryLog.isDebugEnabled()) {\n                        ignoreIt.log(fm);\n                    }\n                }\n            }\n\n            haveEnough = haveEnough || haveNecessaryFaultInfo(m_seeker.getSurvivors(), false);\n            if (haveEnough) {\n\n                Iterator<Map.Entry<Long, SiteFailureForwardMessage>> itr =\n                        m_forwardCandidates.entrySet().iterator();\n\n                while (itr.hasNext()) {\n                    Map.Entry<Long, SiteFailureForwardMessage> e = itr.next();\n                    Set<Long> unseenBy = m_seeker.forWhomSiteIsDead(e.getKey());\n                    if (unseenBy.size() > 0) {\n                        m_mailbox.send(Longs.toArray(unseenBy), e.getValue());\n                        m_recoveryLog.info(\"Agreement, fowarding to \"\n                                + CoreUtils.hsIdCollectionToString(unseenBy)\n                                + \" \" + e.getValue());\n                    }\n                    itr.remove();\n                }\n            }\n\n        } while (!haveEnough || m_seeker.needForward(forwardStallCount));\n\n        return true;\n    }","commit_id":"f2c65b99c7d7fda48556d15f4ba9fae158861e54","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Process the fault message, and if necessary start arbitration.\n     * @param hsIds pre-failure mesh ids\n     * @param fm a {@link FaultMessage}\n     * @param unknownFaultedSites Sites that we don't know about, but are informed\n     * have failed; tracked here so that we can remove the associated hosts\n     * @return a map where the keys are the sites we need to disconnect from, and\n     *   the values the last know safe zookeeper transaction ids for the sites\n     *   we need to disconnect from. A map with entries indicate that an\n     *   arbitration resolutions has been reached, while a map without entries\n     *   indicate either a stale message, or that an agreement has not been\n     *   reached\n     */\n    public Map<Long, Long> reconfigureOnFault(Set<Long> hsIds, FaultMessage fm, Set<Long> unknownFaultedSites) {\n        boolean proceed = false;\n        do {\n            Discard ignoreIt = mayIgnore(hsIds, fm);\n            if (Discard.DoNot == ignoreIt) {\n                m_inTrouble.put(fm.failedSite, fm.witnessed || fm.decided);\n                m_recoveryLog.info(\"Agreement, Processing \" + fm);\n                proceed = true;\n            } else {\n                ignoreIt.log(fm);\n            }\n\n            if (Discard.Unknown == ignoreIt) {\n                unknownFaultedSites.add(fm.failedSite);\n            }\n            fm = (FaultMessage) m_mailbox.recv(justFailures);\n        } while (fm != null);\n\n        if (!proceed) {\n            return ImmutableMap.of();\n        }\n\n        m_inTroubleCount = m_inTrouble.size();\n\n        // we are here if failed site was not previously recorded\n        // or it was previously recorded but it became witnessed from unwitnessed\n        m_seeker.startSeekingFor(Sets.difference(hsIds, m_failedSites), m_inTrouble);\n\n        discoverGlobalFaultData_send(hsIds);\n\n        if (discoverGlobalFaultData_rcv(hsIds)) {\n            Map<Long, Long> lastTxnIdByFailedSite = extractGlobalFaultData(hsIds);\n            if (lastTxnIdByFailedSite.isEmpty()) {\n                return ImmutableMap.of();\n            }\n\n            Set<Long> witnessed = Maps.filterValues(m_inTrouble, equalTo(Boolean.TRUE)).keySet();\n            Set<Long> notClosed = Sets.difference(witnessed, lastTxnIdByFailedSite.keySet());\n            if ( !notClosed.isEmpty()) {\n                m_recoveryLog.warn(\"Agreement, witnessed but not decided: [\"\n                        + CoreUtils.hsIdCollectionToString(notClosed)\n                        + \"] seeker: \" + m_seeker);\n            }\n\n            notifyOnKill(hsIds, lastTxnIdByFailedSite);\n\n            m_failedSites.addAll( lastTxnIdByFailedSite.keySet());\n            m_failedSitesCount = m_failedSites.size();\n\n            m_recoveryLog.info(\n                    \"Agreement, Adding \"\n                  + CoreUtils.hsIdCollectionToString(lastTxnIdByFailedSite.keySet())\n                  + \" to failed sites history\");\n\n            clearInTrouble(lastTxnIdByFailedSite.keySet());\n            m_seeker.clear();\n\n            return lastTxnIdByFailedSite;\n        } else {\n            return ImmutableMap.of();\n        }\n    }","id":93156,"modified_method":"/**\n     * Process the fault message, and if necessary start arbitration.\n     * @param hsIds pre-failure mesh ids\n     * @param fm a {@link FaultMessage}\n     * @param unknownFaultedSites Sites that we don't know about, but are informed\n     * have failed; tracked here so that we can remove the associated hosts\n     * @return a map where the keys are the sites we need to disconnect from, and\n     *   the values the last know safe zookeeper transaction ids for the sites\n     *   we need to disconnect from. A map with entries indicate that an\n     *   arbitration resolutions has been reached, while a map without entries\n     *   indicate either a stale message, or that an agreement has not been\n     *   reached\n     */\n    public Map<Long, Long> reconfigureOnFault(Set<Long> hsIds, FaultMessage fm, Set<Long> unknownFaultedSites) {\n        boolean proceed = false;\n        do {\n            Discard ignoreIt = mayIgnore(hsIds, fm);\n            if (Discard.DoNot == ignoreIt) {\n                m_inTrouble.put(fm.failedSite, fm.witnessed || fm.decided);\n                m_recoveryLog.info(\"Agreement, Processing \" + fm);\n                proceed = true;\n            } else {\n                ignoreIt.log(fm);\n            }\n\n            if (Discard.Unknown == ignoreIt) {\n                unknownFaultedSites.add(fm.failedSite);\n            }\n            fm = (FaultMessage) m_mailbox.recv(justFailures);\n        } while (fm != null);\n\n        if (!proceed) {\n            return ImmutableMap.of();\n        }\n\n        m_inTroubleCount = m_inTrouble.size();\n\n        // we are here if failed site was not previously recorded\n        // or it was previously recorded but it became witnessed from unwitnessed\n        m_seeker.startSeekingFor(Sets.difference(hsIds, m_failedSites), m_inTrouble);\n\n        discoverGlobalFaultData_send(hsIds);\n\n        while (discoverGlobalFaultData_rcv(hsIds)) {\n            Map<Long, Long> lastTxnIdByFailedSite = extractGlobalFaultData(hsIds);\n            if (lastTxnIdByFailedSite.isEmpty()) {\n                return ImmutableMap.of();\n            }\n\n            Set<Long> witnessed = Maps.filterValues(m_inTrouble, equalTo(Boolean.TRUE)).keySet();\n            Set<Long> notClosed = Sets.difference(witnessed, lastTxnIdByFailedSite.keySet());\n            if ( !notClosed.isEmpty()) {\n                m_recoveryLog.warn(\"Agreement, witnessed but not decided: [\"\n                        + CoreUtils.hsIdCollectionToString(notClosed)\n                        + \"] seeker: \" + m_seeker);\n            }\n\n            if (!notifyOnKill(hsIds, lastTxnIdByFailedSite)) {\n                continue;\n            }\n\n            m_failedSites.addAll( lastTxnIdByFailedSite.keySet());\n            m_failedSitesCount = m_failedSites.size();\n\n            m_recoveryLog.info(\n                    \"Agreement, Adding \"\n                  + CoreUtils.hsIdCollectionToString(lastTxnIdByFailedSite.keySet())\n                  + \" to failed sites history\");\n\n            clearInTrouble(lastTxnIdByFailedSite.keySet());\n            m_seeker.clear();\n\n            return lastTxnIdByFailedSite;\n        }\n\n        return ImmutableMap.of();\n    }","commit_id":"f2c65b99c7d7fda48556d15f4ba9fae158861e54","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Cut the network connection between two hostids immediately\n     * Useful for simulating network partitions\n     */\n    public void cutLink(int hostIdA, int hostIdB) {\n        if (m_localHostId == hostIdA) {\n            ForeignHost fh = m_foreignHosts.get(hostIdB);\n            fh.cutLink();\n        }\n        if (m_localHostId == hostIdB) {\n            ForeignHost fh = m_foreignHosts.get(hostIdA);\n            fh.cutLink();\n        }\n    }","id":93157,"modified_method":"/**\n     * Cut the network connection between two hostids immediately\n     * Useful for simulating network partitions\n     */\n    public void cutLink(int hostIdA, int hostIdB) {\n        if (m_localHostId == hostIdA) {\n            ForeignHost fh = m_foreignHosts.get(hostIdB);\n            if (fh != null) {\n                fh.cutLink();\n            }\n        }\n        if (m_localHostId == hostIdB) {\n            ForeignHost fh = m_foreignHosts.get(hostIdA);\n            if (fh != null) {\n                fh.cutLink();\n            }\n        }\n    }","commit_id":"3fbcc46d6fa6e6c8d3f57da62dd1a7cf1b536886","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void doPartitionDetectionActivities(Set<Integer> failedHostIds)\n    {\n        if (m_shuttingDown) {\n            return;\n        }\n\n        // We should never re-enter here once we've decided we're partitioned and doomed\n        Preconditions.checkState(!m_partitionDetected, \"Partition detection triggered twice.\");\n\n        // figure out previous and current cluster memberships\n        Set<Integer> previousHosts = getLiveHostIds();\n        Set<Integer> currentHosts = new HashSet<>(previousHosts);\n        currentHosts.removeAll(failedHostIds);\n\n        // sanity!\n        Preconditions.checkState(previousHosts.contains(m_localHostId));\n        Preconditions.checkState(currentHosts.contains(m_localHostId));\n\n        // decide if we're partitioned\n        // this will print out warnings if we are\n        if (makePPDDecision(m_localHostId, previousHosts, currentHosts, m_partitionDetectionEnabled.get())) {\n            // record here so we can ensure this only happens once for this node\n            m_partitionDetected = true;\n            VoltDB.crashGlobalVoltDB(\"Partition detection logic will stop this process to ensure against split brains.\",\n                        false, null);\n        }\n    }","id":93158,"modified_method":"private void doPartitionDetectionActivities(Set<Integer> failedHostIds)\n    {\n        if (m_shuttingDown) {\n            return;\n        }\n\n        // We should never re-enter here once we've decided we're partitioned and doomed\n        Preconditions.checkState(!m_partitionDetected, \"Partition detection triggered twice.\");\n\n        // figure out previous and current cluster memberships\n        Set<Integer> previousHosts = getLiveHostIds();\n        Set<Integer> currentHosts = new HashSet<>(previousHosts);\n        currentHosts.removeAll(failedHostIds);\n\n        // sanity!\n        Preconditions.checkState(previousHosts.contains(m_localHostId));\n        Preconditions.checkState(currentHosts.contains(m_localHostId));\n\n        // decide if we're partitioned\n        // this will print out warnings if we are\n        if (makePPDDecision(m_localHostId, previousHosts, currentHosts, m_partitionDetectionEnabled.get())) {\n            // record here so we can ensure this only happens once for this node\n            m_partitionDetected = true;\n            VoltDB.crashLocalVoltDB(\"Partition detection logic will stop this process to ensure against split brains.\",\n                        false, null);\n        }\n    }","commit_id":"3fbcc46d6fa6e6c8d3f57da62dd1a7cf1b536886","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Collect the failure site update messages from all sites This site sent\n     * its own mailbox the above broadcast the maximum is local to this site.\n     * This also ensures at least one response.\n     *\n     * Concurrent failures can be detected by additional reports from the FaultDistributor\n     * or a mismatch in the set of failed hosts reported in a message from another site\n     */\n    private boolean discoverGlobalFaultData_rcv(Set<Long> hsIds) {\n\n        long blockedOnReceiveStart = System.currentTimeMillis();\n        long lastReportTime = 0;\n        boolean haveEnough = false;\n        int [] forwardStallCount = new int[] {FORWARD_STALL_COUNT};\n\n        do {\n            VoltMessage m = m_mailbox.recvBlocking(receiveSubjects, 5);\n\n            /*\n             * If fault resolution takes longer then 10 seconds start logging\n             */\n            final long now = System.currentTimeMillis();\n            if (now - blockedOnReceiveStart > 10000) {\n                if (now - lastReportTime > 60000) {\n                    lastReportTime = System.currentTimeMillis();\n                    haveNecessaryFaultInfo(m_seeker.getSurvivors(), true);\n                }\n            }\n\n            if (m == null) {\n                // Send a heartbeat to keep the dead host timeout active.  Needed because IV2 doesn't\n                // generate its own heartbeats to keep this running.\n                m_meshAide.sendHeartbeats(m_seeker.getSurvivors());\n\n            } else if (m.getSubject() == Subject.SITE_FAILURE_UPDATE.getId()) {\n\n                SiteFailureMessage sfm = (SiteFailureMessage) m;\n\n                if (  !m_seeker.getSurvivors().contains(m.m_sourceHSId)\n                    || m_failedSites.contains(m.m_sourceHSId)\n                    || m_failedSites.containsAll(sfm.getFailedSites())) continue;\n\n                updateFailedSitesLedger(hsIds, sfm);\n\n                m_seeker.add(sfm);\n                addForwardCandidate(new SiteFailureForwardMessage(sfm));\n\n                m_recoveryLog.info(\"Agreement, Received \" + sfm);\n\n            } else if (m.getSubject() == Subject.SITE_FAILURE_FORWARD.getId()) {\n\n                SiteFailureForwardMessage fsfm = (SiteFailureForwardMessage) m;\n\n                addForwardCandidate(fsfm);\n\n                if (   !hsIds.contains(fsfm.m_sourceHSId)\n                    || m_seeker.getSurvivors().contains(fsfm.m_reportingHSId)\n                    || m_failedSites.contains(fsfm.m_reportingHSId)\n                    || m_failedSites.containsAll(fsfm.getFailedSites())) continue;\n\n                m_seeker.add(fsfm);\n\n                m_recoveryLog.info(\"Agreement, Received forward \" + fsfm);\n\n                forwardStallCount[0] = FORWARD_STALL_COUNT;\n\n            } else if (m.getSubject() == Subject.FAILURE.getId()) {\n                /*\n                 * If the fault distributor reports a new fault, ignore it if it is known , otherwise\n                 * re-deliver the message to ourself and then abort so that the process can restart.\n                 */\n                FaultMessage fm = (FaultMessage) m;\n\n                Discard ignoreIt = mayIgnore(hsIds, fm);\n                if (Discard.DoNot == ignoreIt) {\n                    m_mailbox.deliverFront(m);\n                    m_recoveryLog.info(\"Agreement, Detected a concurrent failure from FaultDistributor, new failed site \"\n                            + CoreUtils.hsIdToString(fm.failedSite));\n                    return false;\n                } else {\n                    if (m_recoveryLog.isDebugEnabled()) {\n                        ignoreIt.log(fm);\n                    }\n                }\n            }\n\n            haveEnough = haveEnough || haveNecessaryFaultInfo(m_seeker.getSurvivors(), false);\n            if (haveEnough) {\n\n                Iterator<Map.Entry<Long, SiteFailureForwardMessage>> itr =\n                        m_forwardCandidates.entrySet().iterator();\n\n                while (itr.hasNext()) {\n                    Map.Entry<Long, SiteFailureForwardMessage> e = itr.next();\n                    Set<Long> unseenBy = m_seeker.forWhomSiteIsDead(e.getKey());\n                    if (unseenBy.size() > 0) {\n                        m_mailbox.send(Longs.toArray(unseenBy), e.getValue());\n                        m_recoveryLog.info(\"Agreement, fowarding to \"\n                                + CoreUtils.hsIdCollectionToString(unseenBy)\n                                + \" \" + e.getValue());\n                    }\n                    itr.remove();\n                }\n            }\n\n        } while (!haveEnough || m_seeker.needForward(forwardStallCount));\n\n        return true;\n    }","id":93159,"modified_method":"/**\n     * Collect the failure site update messages from all sites This site sent\n     * its own mailbox the above broadcast the maximum is local to this site.\n     * This also ensures at least one response.\n     *\n     * Concurrent failures can be detected by additional reports from the FaultDistributor\n     * or a mismatch in the set of failed hosts reported in a message from another site\n     */\n    private boolean discoverGlobalFaultData_rcv(Set<Long> hsIds) {\n\n        long blockedOnReceiveStart = System.currentTimeMillis();\n        long lastReportTime = 0;\n        boolean haveEnough = false;\n        int [] forwardStallCount = new int[] {FORWARD_STALL_COUNT};\n\n        do {\n            VoltMessage m = m_mailbox.recvBlocking(receiveSubjects, 5);\n\n            /*\n             * If fault resolution takes longer then 10 seconds start logging\n             */\n            final long now = System.currentTimeMillis();\n            if (now - blockedOnReceiveStart > 10000) {\n                if (now - lastReportTime > 60000) {\n                    lastReportTime = System.currentTimeMillis();\n                    haveNecessaryFaultInfo(m_seeker.getSurvivors(), true);\n                }\n            }\n\n            if (m == null) {\n                // Send a heartbeat to keep the dead host timeout active.  Needed because IV2 doesn't\n                // generate its own heartbeats to keep this running.\n                m_meshAide.sendHeartbeats(m_seeker.getSurvivors());\n\n            } else if (m.getSubject() == Subject.SITE_FAILURE_UPDATE.getId()) {\n\n                SiteFailureMessage sfm = (SiteFailureMessage) m;\n\n                if (  !m_seeker.getSurvivors().contains(m.m_sourceHSId)\n                    || m_failedSites.contains(m.m_sourceHSId)\n                    || m_failedSites.containsAll(sfm.getFailedSites())) continue;\n\n                if (!sfm.m_decision.isEmpty()) {\n                    m_decidedSurvivors.put(sfm.m_sourceHSId, sfm);\n                }\n\n                updateFailedSitesLedger(hsIds, sfm);\n\n                m_seeker.add(sfm);\n                addForwardCandidate(new SiteFailureForwardMessage(sfm));\n\n                m_recoveryLog.info(\"Agreement, Received \" + sfm);\n\n            } else if (m.getSubject() == Subject.SITE_FAILURE_FORWARD.getId()) {\n\n                SiteFailureForwardMessage fsfm = (SiteFailureForwardMessage) m;\n\n                addForwardCandidate(fsfm);\n\n                if (   !hsIds.contains(fsfm.m_sourceHSId)\n                    || m_seeker.getSurvivors().contains(fsfm.m_reportingHSId)\n                    || m_failedSites.contains(fsfm.m_reportingHSId)\n                    || m_failedSites.containsAll(fsfm.getFailedSites())) continue;\n\n                m_seeker.add(fsfm);\n\n                m_recoveryLog.info(\"Agreement, Received forward \" + fsfm);\n\n                forwardStallCount[0] = FORWARD_STALL_COUNT;\n\n            } else if (m.getSubject() == Subject.FAILURE.getId()) {\n                /*\n                 * If the fault distributor reports a new fault, ignore it if it is known , otherwise\n                 * re-deliver the message to ourself and then abort so that the process can restart.\n                 */\n                FaultMessage fm = (FaultMessage) m;\n\n                Discard ignoreIt = mayIgnore(hsIds, fm);\n                if (Discard.DoNot == ignoreIt) {\n                    m_mailbox.deliverFront(m);\n                    m_recoveryLog.info(\"Agreement, Detected a concurrent failure from FaultDistributor, new failed site \"\n                            + CoreUtils.hsIdToString(fm.failedSite));\n                    return false;\n                } else {\n                    if (m_recoveryLog.isDebugEnabled()) {\n                        ignoreIt.log(fm);\n                    }\n                }\n            }\n\n            haveEnough = haveEnough || haveNecessaryFaultInfo(m_seeker.getSurvivors(), false);\n            if (haveEnough) {\n\n                Iterator<Map.Entry<Long, SiteFailureForwardMessage>> itr =\n                        m_forwardCandidates.entrySet().iterator();\n\n                while (itr.hasNext()) {\n                    Map.Entry<Long, SiteFailureForwardMessage> e = itr.next();\n                    Set<Long> unseenBy = m_seeker.forWhomSiteIsDead(e.getKey());\n                    if (unseenBy.size() > 0) {\n                        m_mailbox.send(Longs.toArray(unseenBy), e.getValue());\n                        m_recoveryLog.info(\"Agreement, fowarding to \"\n                                + CoreUtils.hsIdCollectionToString(unseenBy)\n                                + \" \" + e.getValue());\n                    }\n                    itr.remove();\n                }\n            }\n\n        } while (!haveEnough || m_seeker.needForward(forwardStallCount));\n\n        return true;\n    }","commit_id":"3fbcc46d6fa6e6c8d3f57da62dd1a7cf1b536886","url":"https://github.com/VoltDB/voltdb"},{"original_method":"protected void clearInTrouble(Set<Long> decision) {\n        m_forwardCandidates.clear();\n        m_failedSitesLedger.clear();\n        m_inTrouble.clear();\n        m_inTroubleCount = 0;\n    }","id":93160,"modified_method":"protected void clearInTrouble(Set<Long> decision) {\n        m_forwardCandidates.clear();\n        m_failedSitesLedger.clear();\n        m_decidedSurvivors.clear();\n        m_localHistoricDecisions.clear();\n        m_inTrouble.clear();\n        m_inTroubleCount = 0;\n    }","commit_id":"3fbcc46d6fa6e6c8d3f57da62dd1a7cf1b536886","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Notify all survivors when you are closing links to nodes\n     * @param decision map where the keys contain the kill sites\n     *   and its values are their last known safe transaction ids\n     */\n    protected void notifyOnKill(Set<Long> hsIds, Map<Long, Long> decision) {\n\n        SiteFailureMessage.Builder sfmb = SiteFailureMessage.\n                builder()\n                .decisions(decision.keySet())\n                .failures(decision.keySet());\n\n        Set<Long> dests = Sets.filter(m_seeker.getSurvivors(), not(equalTo(m_hsId)));\n        if (dests.isEmpty()) return;\n\n        sfmb.survivors(Sets.difference(m_seeker.getSurvivors(), decision.keySet()));\n        sfmb.safeTxnIds(getSafeTxnIdsForSites(hsIds));\n\n        SiteFailureMessage sfm = sfmb.build();\n        m_mailbox.send(Longs.toArray(dests), sfm);\n\n        m_recoveryLog.info(\"Agreement, Sending [\"\n                + CoreUtils.hsIdCollectionToString(dests) + \"]  \" + sfm);\n    }","id":93161,"modified_method":"/**\n     * Notify all survivors when you are closing links to nodes\n     * @param decision map where the keys contain the kill sites\n     *   and its values are their last known safe transaction ids\n     * @return true if successfully confirmed that all survivors\n     * agree on the decision, false otherwise.\n     */\n    protected boolean notifyOnKill(Set<Long> hsIds, Map<Long, Long> decision) {\n\n        SiteFailureMessage.Builder sfmb = SiteFailureMessage.\n                builder()\n                .decisions(decision.keySet())\n                .failures(decision.keySet());\n\n        Set<Long> dests = Sets.filter(m_seeker.getSurvivors(), not(equalTo(m_hsId)));\n        if (dests.isEmpty()) return true;\n\n        sfmb.survivors(Sets.difference(m_seeker.getSurvivors(), decision.keySet()));\n        sfmb.safeTxnIds(getSafeTxnIdsForSites(hsIds));\n\n        SiteFailureMessage sfm = sfmb.build();\n        m_mailbox.send(Longs.toArray(dests), sfm);\n\n        m_recoveryLog.info(\"Agreement, Sending [\"\n                + CoreUtils.hsIdCollectionToString(dests) + \"]  \" + sfm);\n\n        // Check to see we've made the same decision before, if so, it's likely\n        // that we've entered a loop, exit here.\n        if (m_localHistoricDecisions.size() >= 100) {\n            // Too many decisions have been made without converging\n            RateLimitedLogger.tryLogForMessage(System.currentTimeMillis(),\n                                               10, TimeUnit.SECONDS,\n                                               m_recoveryLog,\n                                               Level.WARN,\n                                               \"Agreement, %d local decisions have been made without converging\",\n                                               m_localHistoricDecisions.size());\n        }\n        for (SiteFailureMessage lhd : m_localHistoricDecisions) {\n            if (lhd.m_survivors.equals(sfm.m_survivors)) {\n                m_recoveryLog.info(\"Agreement, detected decision loop. Exiting\");\n                return true;\n            }\n        }\n        m_localHistoricDecisions.add(sfm);\n\n        // Wait for all survivors in the local decision to send their decisions over.\n        // If one of the host's decision conflicts with ours, remove that host's link\n        // and repeat the decision process.\n        final Set<Long> expectedSurvivors = Sets.filter(sfm.m_survivors, not(equalTo(m_hsId)));\n        m_recoveryLog.info(\"Agreement, Waiting for agreement on decision from survivors \" +\n                           CoreUtils.hsIdCollectionToString(expectedSurvivors));\n\n        final Iterator<SiteFailureMessage> iter = m_decidedSurvivors.values().iterator();\n        while (iter.hasNext()) {\n            final SiteFailureMessage remoteDecision = iter.next();\n            if (expectedSurvivors.contains(remoteDecision.m_sourceHSId)) {\n                if (remoteDecision.m_decision.contains(m_hsId)) {\n                    iter.remove();\n                    m_recoveryLog.info(\"Agreement, Received inconsistent decision from \" +\n                                       CoreUtils.hsIdToString(remoteDecision.m_sourceHSId) + \", \" + remoteDecision);\n                    final FaultMessage localFault = new FaultMessage(m_hsId, remoteDecision.m_sourceHSId);\n                    localFault.m_sourceHSId = m_hsId;\n                    m_mailbox.deliverFront(localFault);\n                    return false;\n                }\n            }\n        }\n\n        long start = System.currentTimeMillis();\n        boolean allDecisionsMatch = true;\n        do {\n            final VoltMessage msg = m_mailbox.recvBlocking(receiveSubjects, 5);\n            if (msg == null) {\n                // Send a heartbeat to keep the dead host timeout active.\n                m_meshAide.sendHeartbeats(m_seeker.getSurvivors());\n                final long duration = System.currentTimeMillis() - start;\n                if (duration > 20000) {\n                    m_recoveryLog.error(\"Agreement, Still waiting for decisions from \" +\n                                        CoreUtils.hsIdCollectionToString(Sets.difference(expectedSurvivors, m_decidedSurvivors.keySet())) +\n                                        \" after \" + TimeUnit.MILLISECONDS.toSeconds(duration) + \" seconds\");\n                    start = System.currentTimeMillis();\n                }\n                continue;\n            }\n\n            if (m_hsId != msg.m_sourceHSId && !expectedSurvivors.contains(msg.m_sourceHSId)) {\n                // Ignore messages from failed sites\n                continue;\n            }\n\n            if (msg.getSubject() == Subject.SITE_FAILURE_UPDATE.getId()) {\n                final SiteFailureMessage fm = (SiteFailureMessage) msg;\n                if (!fm.m_decision.isEmpty()) {\n                    if (expectedSurvivors.contains(fm.m_sourceHSId)) {\n                        if (fm.m_decision.contains(m_hsId)) {\n                            m_decidedSurvivors.remove(fm.m_sourceHSId);\n                            // The remote host has decided that we are gone, remove the remote host\n                            final FaultMessage localFault = new FaultMessage(m_hsId, fm.m_sourceHSId);\n                            localFault.m_sourceHSId = m_hsId;\n                            m_mailbox.deliverFront(localFault);\n                            return false;\n                        } else {\n                            m_decidedSurvivors.put(fm.m_sourceHSId, fm);\n                        }\n                    }\n                } else {\n                    m_mailbox.deliverFront(fm);\n                    return false;\n                }\n            } else if (msg.getSubject() == Subject.FAILURE.getId()) {\n                final FaultMessage fm = (FaultMessage) msg;\n                if (!fm.decided) {\n                    // In case of concurrent fault, handle it\n                    m_mailbox.deliverFront(msg);\n                    return false;\n                } else if (mayIgnore(hsIds, fm) == Discard.DoNot) {\n                    m_mailbox.deliverFront(msg);\n                    return false;\n                }\n            }\n\n            for (SiteFailureMessage remoteDecision : m_decidedSurvivors.values()) {\n                if (!sfm.m_survivors.equals(remoteDecision.m_survivors)) {\n                    allDecisionsMatch = false;\n                }\n            }\n        } while (!m_decidedSurvivors.keySet().containsAll(expectedSurvivors) && allDecisionsMatch);\n\n        return true;\n    }","commit_id":"3fbcc46d6fa6e6c8d3f57da62dd1a7cf1b536886","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Process the fault message, and if necessary start arbitration.\n     * @param hsIds pre-failure mesh ids\n     * @param fm a {@link FaultMessage}\n     * @param unknownFaultedSites Sites that we don't know about, but are informed\n     * have failed; tracked here so that we can remove the associated hosts\n     * @return a map where the keys are the sites we need to disconnect from, and\n     *   the values the last know safe zookeeper transaction ids for the sites\n     *   we need to disconnect from. A map with entries indicate that an\n     *   arbitration resolutions has been reached, while a map without entries\n     *   indicate either a stale message, or that an agreement has not been\n     *   reached\n     */\n    public Map<Long, Long> reconfigureOnFault(Set<Long> hsIds, FaultMessage fm, Set<Long> unknownFaultedSites) {\n        boolean proceed = false;\n        do {\n            Discard ignoreIt = mayIgnore(hsIds, fm);\n            if (Discard.DoNot == ignoreIt) {\n                m_inTrouble.put(fm.failedSite, fm.witnessed || fm.decided);\n                m_recoveryLog.info(\"Agreement, Processing \" + fm);\n                proceed = true;\n            } else {\n                ignoreIt.log(fm);\n            }\n\n            if (Discard.Unknown == ignoreIt) {\n                unknownFaultedSites.add(fm.failedSite);\n            }\n            fm = (FaultMessage) m_mailbox.recv(justFailures);\n        } while (fm != null);\n\n        if (!proceed) {\n            return ImmutableMap.of();\n        }\n\n        m_inTroubleCount = m_inTrouble.size();\n\n        // we are here if failed site was not previously recorded\n        // or it was previously recorded but it became witnessed from unwitnessed\n        m_seeker.startSeekingFor(Sets.difference(hsIds, m_failedSites), m_inTrouble);\n\n        discoverGlobalFaultData_send(hsIds);\n\n        if (discoverGlobalFaultData_rcv(hsIds)) {\n            Map<Long, Long> lastTxnIdByFailedSite = extractGlobalFaultData(hsIds);\n            if (lastTxnIdByFailedSite.isEmpty()) {\n                return ImmutableMap.of();\n            }\n\n            Set<Long> witnessed = Maps.filterValues(m_inTrouble, equalTo(Boolean.TRUE)).keySet();\n            Set<Long> notClosed = Sets.difference(witnessed, lastTxnIdByFailedSite.keySet());\n            if ( !notClosed.isEmpty()) {\n                m_recoveryLog.warn(\"Agreement, witnessed but not decided: [\"\n                        + CoreUtils.hsIdCollectionToString(notClosed)\n                        + \"] seeker: \" + m_seeker);\n            }\n\n            notifyOnKill(hsIds, lastTxnIdByFailedSite);\n\n            m_failedSites.addAll( lastTxnIdByFailedSite.keySet());\n            m_failedSitesCount = m_failedSites.size();\n\n            m_recoveryLog.info(\n                    \"Agreement, Adding \"\n                  + CoreUtils.hsIdCollectionToString(lastTxnIdByFailedSite.keySet())\n                  + \" to failed sites history\");\n\n            clearInTrouble(lastTxnIdByFailedSite.keySet());\n            m_seeker.clear();\n\n            return lastTxnIdByFailedSite;\n        } else {\n            return ImmutableMap.of();\n        }\n    }","id":93162,"modified_method":"/**\n     * Process the fault message, and if necessary start arbitration.\n     * @param hsIds pre-failure mesh ids\n     * @param fm a {@link FaultMessage}\n     * @param unknownFaultedSites Sites that we don't know about, but are informed\n     * have failed; tracked here so that we can remove the associated hosts\n     * @return a map where the keys are the sites we need to disconnect from, and\n     *   the values the last know safe zookeeper transaction ids for the sites\n     *   we need to disconnect from. A map with entries indicate that an\n     *   arbitration resolutions has been reached, while a map without entries\n     *   indicate either a stale message, or that an agreement has not been\n     *   reached\n     */\n    public Map<Long, Long> reconfigureOnFault(Set<Long> hsIds, FaultMessage fm, Set<Long> unknownFaultedSites) {\n        boolean proceed = false;\n        do {\n            Discard ignoreIt = mayIgnore(hsIds, fm);\n            if (Discard.DoNot == ignoreIt) {\n                m_inTrouble.put(fm.failedSite, fm.witnessed || fm.decided);\n                m_recoveryLog.info(\"Agreement, Processing \" + fm);\n                proceed = true;\n            } else {\n                ignoreIt.log(fm);\n            }\n\n            if (Discard.Unknown == ignoreIt) {\n                unknownFaultedSites.add(fm.failedSite);\n            }\n            fm = (FaultMessage) m_mailbox.recv(justFailures);\n        } while (fm != null);\n\n        if (!proceed) {\n            return ImmutableMap.of();\n        }\n\n        m_inTroubleCount = m_inTrouble.size();\n\n        // we are here if failed site was not previously recorded\n        // or it was previously recorded but it became witnessed from unwitnessed\n        m_seeker.startSeekingFor(Sets.difference(hsIds, m_failedSites), m_inTrouble);\n\n        discoverGlobalFaultData_send(hsIds);\n\n        while (discoverGlobalFaultData_rcv(hsIds)) {\n            Map<Long, Long> lastTxnIdByFailedSite = extractGlobalFaultData(hsIds);\n            if (lastTxnIdByFailedSite.isEmpty()) {\n                return ImmutableMap.of();\n            }\n\n            Set<Long> witnessed = Maps.filterValues(m_inTrouble, equalTo(Boolean.TRUE)).keySet();\n            Set<Long> notClosed = Sets.difference(witnessed, lastTxnIdByFailedSite.keySet());\n            if ( !notClosed.isEmpty()) {\n                m_recoveryLog.warn(\"Agreement, witnessed but not decided: [\"\n                        + CoreUtils.hsIdCollectionToString(notClosed)\n                        + \"] seeker: \" + m_seeker);\n            }\n\n            if (!notifyOnKill(hsIds, lastTxnIdByFailedSite)) {\n                continue;\n            }\n\n            m_failedSites.addAll( lastTxnIdByFailedSite.keySet());\n            m_failedSitesCount = m_failedSites.size();\n\n            m_recoveryLog.info(\n                    \"Agreement, Adding \"\n                  + CoreUtils.hsIdCollectionToString(lastTxnIdByFailedSite.keySet())\n                  + \" to failed sites history\");\n\n            clearInTrouble(lastTxnIdByFailedSite.keySet());\n            m_seeker.clear();\n\n            return lastTxnIdByFailedSite;\n        }\n\n        return ImmutableMap.of();\n    }","commit_id":"3fbcc46d6fa6e6c8d3f57da62dd1a7cf1b536886","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(CANDIDATE);\n            visitor.candidate(\"Any number or boolean.\");\n        }","id":93163,"modified_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"A String or CharSequence or Character\");\n            visitor.candidate(\"Any Number\");\n            visitor.candidate(\"A Boolean\");\n            visitor.candidate(\"A File\");\n        }","commit_id":"03a89d085c11180031ca7b9200cc5c04dc5bcfff","url":"https://github.com/gradle/gradle"},{"original_method":"protected abstract void convertNumberToNumber(Number n, NotationConvertResult<? super T> result);","id":93164,"modified_method":"protected abstract void convertNumberToNumber(BigDecimal n, NotationConvertResult<? super T> result);","commit_id":"03a89d085c11180031ca7b9200cc5c04dc5bcfff","url":"https://github.com/gradle/gradle"},{"original_method":"public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(CANDIDATE);\n        }","id":93165,"modified_method":"public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"A String or CharSequence\");\n            visitor.candidate(\"A \" + type.getSimpleName());\n        }","commit_id":"03a89d085c11180031ca7b9200cc5c04dc5bcfff","url":"https://github.com/gradle/gradle"},{"original_method":"public Object convert(Object notation, Class<?> type, boolean primitive) throws TypeConversionException {\n\n        if (notation == null) {\n            if (primitive) {\n                throw new UnsupportedNotationException(notation,\n                    String.format(\"Cannot assign null value to primitive type %s.\", UNBOXED_TYPES.get(type).getSimpleName()), null, CANDIDATES);\n            }\n\n            return null;\n        }\n        if (type.isInstance(notation)) {\n            return notation;\n        }\n\n        if (type.isEnum()) {\n            Class<? extends Enum> enumType = Cast.uncheckedCast(type);\n            return convertEnum(enumType, notation);\n        }\n\n        NotationParser<Object, ?> parser;\n        if (File.class.equals(type)) {\n            parser = fileParser;\n        } else {\n            parser = parsers.get(primitive ? UNBOXED_TYPES.get(type) : type);\n            if (parser == null) {\n                throw new UnsupportedNotationException(notation, \"Unsupported type\", null, CANDIDATES);\n            }\n        }\n\n        return parser.parseNotation(notation);\n    }","id":93166,"modified_method":"public Object convert(Object notation, Class<?> type, boolean primitive) throws TypeConversionException {\n        if (type.isInstance(notation)) {\n            return notation;\n        }\n        if (!primitive && notation == null) {\n            return null;\n        }\n\n        if (type.isEnum()) {\n            Class<? extends Enum> enumType = Cast.uncheckedCast(type);\n            return convertEnum(enumType, notation);\n        }\n\n        NotationParser<Object, ?> parser;\n        parser = parsers.get(primitive ? UNBOXED_TYPES.get(type) : type);\n        if (parser == null) {\n            throw new IllegalArgumentException(\"Don't know how to convert to type \" + type.getName());\n        }\n\n        return parser.parseNotation(notation);\n    }","commit_id":"03a89d085c11180031ca7b9200cc5c04dc5bcfff","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultTypeConverter(final FileResolver fileResolver) {\n        fileParser = build(new CharSequenceNotationConverter<Object, File>(new CharSequenceConverter<File>() {\n            public void convert(String notation, NotationConvertResult<? super File> result) throws TypeConversionException {\n                result.converted(fileResolver.resolve(notation));\n            }\n        }), File.class);\n        registerConverters();\n    }","id":93167,"modified_method":"public DefaultTypeConverter(final FileResolver fileResolver) {\n        registerConverter(new CharSequenceNotationConverter<Object, File>(new CharSequenceConverter<File>(File.class) {\n            public void convert(String notation, NotationConvertResult<? super File> result) throws TypeConversionException {\n                result.converted(fileResolver.resolve(notation));\n            }\n        }), File.class);\n        registerConverters();\n    }","commit_id":"03a89d085c11180031ca7b9200cc5c04dc5bcfff","url":"https://github.com/gradle/gradle"},{"original_method":"private void convertToCharacter(String notation, NotationConvertResult<? super Character> result, Class<?> type) throws TypeConversionException {\n        if (notation.length() != 1) {\n            throw new TypeConversionException(String.format(\"Cannot coerce string value '%s' with length %d to type %s\",\n                    notation, notation.length(), type.getSimpleName()));\n        }\n\n        result.converted(notation.charAt(0));\n    }","id":93168,"modified_method":"private void convertToCharacter(String notation, NotationConvertResult<? super Character> result, Class<?> type) throws TypeConversionException {\n        if (notation.length() != 1) {\n            throw new TypeConversionException(String.format(\"Cannot convert string value '%s' with length %d to type %s\",\n                    notation, notation.length(), type.getSimpleName()));\n        }\n\n        result.converted(notation.charAt(0));\n    }","commit_id":"03a89d085c11180031ca7b9200cc5c04dc5bcfff","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(CANDIDATE);\n            visitor.candidate(\"Number instances.\");\n        }","id":93169,"modified_method":"@Override\n        public void describe(DiagnosticsVisitor visitor) {\n            visitor.candidate(\"A String or CharSequence\");\n            visitor.candidate(\"Any Number\");\n        }","commit_id":"03a89d085c11180031ca7b9200cc5c04dc5bcfff","url":"https://github.com/gradle/gradle"},{"original_method":"private void registerConverters() {\n        registerConverter(new NumberConverter<Double>(Double.class) {\n            protected void convertStringToNumber(String notation, NotationConvertResult<? super Double> result) throws TypeConversionException {\n                result.converted(Double.valueOf(notation));\n            }\n            protected void convertNumberToNumber(Number n, NotationConvertResult<? super Double> result) {\n                result.converted(n.doubleValue());\n            }\n        }, Double.class);\n        registerConverter(new NumberConverter<Double>(double.class) {\n            protected void convertStringToNumber(String notation, NotationConvertResult<? super Double> result) throws TypeConversionException {\n                result.converted(Double.valueOf(notation));\n            }\n            protected void convertNumberToNumber(Number n, NotationConvertResult<? super Double> result) {\n                result.converted(n.doubleValue());\n            }\n        }, double.class);\n\n        registerConverter(new NumberConverter<Float>(Float.class) {\n            protected void convertStringToNumber(String notation, NotationConvertResult<? super Float> result) throws TypeConversionException {\n                result.converted(Float.valueOf(notation));\n            }\n            protected void convertNumberToNumber(Number n, NotationConvertResult<? super Float> result) {\n                result.converted(n.floatValue());\n            }\n        }, Float.class);\n        registerConverter(new NumberConverter<Float>(float.class) {\n            protected void convertStringToNumber(String notation, NotationConvertResult<? super Float> result) throws TypeConversionException {\n                result.converted(Float.valueOf(notation));\n            }\n            protected void convertNumberToNumber(Number n, NotationConvertResult<? super Float> result) {\n                result.converted(n.floatValue());\n            }\n        }, float.class);\n\n        registerConverter(new NumberConverter<Integer>(Integer.class) {\n            protected void convertStringToNumber(String notation, NotationConvertResult<? super Integer> result) throws TypeConversionException {\n                result.converted(Integer.valueOf(notation));\n            }\n            protected void convertNumberToNumber(Number n, NotationConvertResult<? super Integer> result) {\n                result.converted(n.intValue());\n            }\n        }, Integer.class);\n        registerConverter(new NumberConverter<Integer>(int.class) {\n            protected void convertStringToNumber(String s, NotationConvertResult<? super Integer> result) throws TypeConversionException {\n                result.converted(Integer.valueOf(s));\n            }\n            protected void convertNumberToNumber(Number n, NotationConvertResult<? super Integer> result) {\n                result.converted(n.intValue());\n            }\n        }, int.class);\n\n        registerConverter(new NumberConverter<Long>(Long.class) {\n            protected void convertStringToNumber(String notation, NotationConvertResult<? super Long> result) throws TypeConversionException {\n                result.converted(Long.valueOf(notation));\n            }\n            protected void convertNumberToNumber(Number n, NotationConvertResult<? super Long> result) {\n                result.converted(n.longValue());\n            }\n        }, Long.class);\n        registerConverter(new NumberConverter<Long>(long.class) {\n            protected void convertStringToNumber(String notation, NotationConvertResult<? super Long> result) throws TypeConversionException {\n                result.converted(Long.valueOf(notation));\n            }\n            protected void convertNumberToNumber(Number n, NotationConvertResult<? super Long> result) {\n                result.converted(n.longValue());\n            }\n        }, long.class);\n\n        registerConverter(new NumberConverter<Short>(Short.class) {\n            protected void convertStringToNumber(String notation, NotationConvertResult<? super Short> result) throws TypeConversionException {\n                result.converted(Short.valueOf(notation));\n            }\n            protected void convertNumberToNumber(Number n, NotationConvertResult<? super Short> result) {\n                result.converted(n.shortValue());\n            }\n        }, Short.class);\n        registerConverter(new NumberConverter<Short>(short.class) {\n            protected void convertStringToNumber(String s, NotationConvertResult<? super Short> result) throws TypeConversionException {\n                result.converted(Short.valueOf(s));\n            }\n            protected void convertNumberToNumber(Number n, NotationConvertResult<? super Short> result) {\n                result.converted(n.shortValue());\n            }\n        }, short.class);\n\n        registerConverter(new NumberConverter<Byte>(Byte.class) {\n            protected void convertStringToNumber(String notation, NotationConvertResult<? super Byte> result) throws TypeConversionException {\n                result.converted(Byte.valueOf(notation));\n            }\n            protected void convertNumberToNumber(Number n, NotationConvertResult<? super Byte> result) {\n                result.converted(n.byteValue());\n            }\n        }, Byte.class);\n        registerConverter(new NumberConverter<Byte>(byte.class) {\n            protected void convertStringToNumber(String notation, NotationConvertResult<? super Byte> result) throws TypeConversionException {\n                result.converted(Byte.valueOf(notation));\n            }\n            protected void convertNumberToNumber(Number n, NotationConvertResult<? super Byte> result) {\n                result.converted(n.byteValue());\n            }\n        }, byte.class);\n\n        registerConverter(new NumberConverter<BigDecimal>(BigDecimal.class) {\n            protected void convertStringToNumber(String notation, NotationConvertResult<? super BigDecimal> result) throws TypeConversionException {\n                result.converted(new BigDecimal(notation));\n            }\n            protected void convertNumberToNumber(Number n, NotationConvertResult<? super BigDecimal> result) {\n                if (n instanceof BigDecimal) {\n                    result.converted((BigDecimal)n);\n                } else if (n instanceof BigInteger) {\n                    result.converted(new BigDecimal((BigInteger)n));\n                }\n            }\n        }, BigDecimal.class);\n\n        registerConverter(new NumberConverter<BigInteger>(BigInteger.class) {\n            protected void convertStringToNumber(String notation, NotationConvertResult<? super BigInteger> result) throws TypeConversionException {\n                result.converted(new BigInteger(notation));\n            }\n            protected void convertNumberToNumber(Number n, NotationConvertResult<? super BigInteger> result) {\n                if (n instanceof BigInteger) {\n                    result.converted((BigInteger)n);\n                }\n            }\n        }, BigInteger.class);\n\n        CharSequenceConverter<Boolean> booleanConverter = new CharSequenceConverter<Boolean>() {\n            public void convert(String notation, NotationConvertResult<? super Boolean> result) throws TypeConversionException {\n                result.converted(\"true\".equals(notation));\n            }\n        };\n        registerStringConverter(booleanConverter, Boolean.class);\n        registerStringConverter(booleanConverter, boolean.class);\n\n        registerStringConverter(new CharSequenceConverter<Character>() {\n            public void convert(String notation, NotationConvertResult<? super Character> result) throws TypeConversionException {\n                convertToCharacter(notation, result, Character.class);\n            }\n        }, Character.class);\n        registerStringConverter(new CharSequenceConverter<Character>() {\n            public void convert(String notation, NotationConvertResult<? super Character> result) throws TypeConversionException {\n                convertToCharacter(notation, result, char.class);\n            }\n        }, char.class);\n\n        registerConverter(new StringConverter(), String.class);\n    }","id":93170,"modified_method":"public CharSequenceConverter(Class<T> type) {\n            this.type = type;\n        }","commit_id":"03a89d085c11180031ca7b9200cc5c04dc5bcfff","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void convert(Object notation, NotationConvertResult<? super String> result) throws TypeConversionException {\n            if (notation instanceof CharSequence || notation instanceof Number || notation instanceof Boolean) {\n                result.converted(notation.toString());\n            }\n        }","id":93171,"modified_method":"@Override\n        public void convert(Object notation, NotationConvertResult<? super String> result) throws TypeConversionException {\n            if (notation instanceof CharSequence || notation instanceof Number || notation instanceof Boolean || notation instanceof Character || notation instanceof File) {\n                result.converted(notation.toString());\n            }\n        }","commit_id":"03a89d085c11180031ca7b9200cc5c04dc5bcfff","url":"https://github.com/gradle/gradle"},{"original_method":"public void convert(Object notation, NotationConvertResult<? super T> result) throws TypeConversionException {\n            if (notation instanceof CharSequence) {\n                try {\n                    convertStringToNumber(notation.toString().trim(), result);\n                } catch (NumberFormatException e) {\n                    throw new TypeConversionException(String.format(\"Cannot coerce string value '%s' to type %s\",\n                        notation, type.getSimpleName()));\n                }\n            } else if (notation instanceof Number) {\n                try {\n                    convertNumberToNumber((Number)notation, result);\n                } catch (NumberFormatException e) {\n                    throw new TypeConversionException(String.format(\"Cannot coerce numeric value '%s' to type %s\",\n                        notation, type.getSimpleName()));\n                }\n            }\n        }","id":93172,"modified_method":"public void convert(Object notation, NotationConvertResult<? super T> result) throws TypeConversionException {\n            if (notation instanceof CharSequence) {\n                try {\n                    convertNumberToNumber(new BigDecimal(notation.toString().trim()), result);\n                } catch (ArithmeticException e) {\n                    throw new TypeConversionException(String.format(\"Cannot convert value '%s' to type %s\",\n                        notation, type.getSimpleName()), e);\n                } catch (NumberFormatException e) {\n                    throw new TypeConversionException(String.format(\"Cannot convert value '%s' to type %s\",\n                        notation, type.getSimpleName()), e);\n                }\n            } else if (notation instanceof Number) {\n                try {\n                    convertNumberToNumber(toBigDecimal(notation), result);\n                } catch (ArithmeticException e) {\n                    throw new TypeConversionException(String.format(\"Cannot convert value '%s' to type %s\",\n                        notation, type.getSimpleName()), e);\n                }\n            }\n        }","commit_id":"03a89d085c11180031ca7b9200cc5c04dc5bcfff","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void convert(CharSequence notation, NotationConvertResult<? super T> result) throws TypeConversionException {\n        final String enumString = notation.toString();\n        List<? extends T> enumConstants = Arrays.asList(type.getEnumConstants());\n        T match = CollectionUtils.findFirst(enumConstants, new Spec<T>() {\n            public boolean isSatisfiedBy(T enumValue) {\n                return enumValue.name().equalsIgnoreCase(enumString);\n            }\n        });\n        if (match == null) {\n            throw new TypeConversionException(\n                    String.format(\"Cannot coerce string value '%s' to an enum value of type '%s' (valid case insensitive values: %s)\",\n                            enumString, type.getName(), CollectionUtils.toStringList(Arrays.asList(type.getEnumConstants()))\n                    )\n            );\n        }\n        result.converted(match);\n    }","id":93173,"modified_method":"@Override\n    public void convert(CharSequence notation, NotationConvertResult<? super T> result) throws TypeConversionException {\n        final String enumString = notation.toString();\n        List<? extends T> enumConstants = Arrays.asList(type.getEnumConstants());\n        T match = CollectionUtils.findFirst(enumConstants, new Spec<T>() {\n            public boolean isSatisfiedBy(T enumValue) {\n                return enumValue.name().equalsIgnoreCase(enumString);\n            }\n        });\n        if (match == null) {\n            throw new TypeConversionException(\n                    String.format(\"Cannot convert string value '%s' to an enum value of type '%s' (valid case insensitive values: %s)\",\n                            enumString, type.getName(), CollectionUtils.toStringList(Arrays.asList(type.getEnumConstants()))\n                    )\n            );\n        }\n        result.converted(match);\n    }","commit_id":"03a89d085c11180031ca7b9200cc5c04dc5bcfff","url":"https://github.com/gradle/gradle"},{"original_method":"protected void importEntry(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tBookmarksEntry entry)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(entry.getUserUuid());\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, entry.getFolderId(), entry.getFolderId());\n\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tBookmarksEntry.class, entry.getEntryId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\tif ((folderId != BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == entry.getFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, folderId);\n\n\t\t\tBookmarksFolder folder =\n\t\t\t\t(BookmarksFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, entry.getFolderId(), entry.getFolderId());\n\t\t}\n\n\t\tBookmarksEntry existingEntry = null;\n\n\t\ttry {\n\t\t\tlong groupId = context.getGroupId();\n\n\t\t\tif (folderId != BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\tBookmarksFolder folder = BookmarksFolderUtil.findByPrimaryKey(\n\t\t\t\t\tfolderId);\n\n\t\t\t\tgroupId = folder.getGroupId();\n\t\t\t}\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingEntry = BookmarksEntryUtil.findByUUID_G(\n\t\t\t\t\t\tentry.getUuid(), context.getGroupId());\n\n\t\t\t\t\tBookmarksEntryLocalServiceUtil.updateEntry(\n\t\t\t\t\t\tuserId, existingEntry.getEntryId(), groupId, folderId,\n\t\t\t\t\t\tentry.getName(), entry.getUrl(), entry.getComments(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t\t\tBookmarksEntryLocalServiceUtil.addEntry(\n\t\t\t\t\t\tentry.getUuid(), userId, groupId, folderId,\n\t\t\t\t\t\tentry.getName(), entry.getUrl(), entry.getComments(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tBookmarksEntryLocalServiceUtil.addEntry(\n\t\t\t\t\tnull, userId, groupId, folderId, entry.getName(),\n\t\t\t\t\tentry.getUrl(), entry.getComments(), serviceContext);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for entry \" +\n\t\t\t\t\tentry.getEntryId());\n\t\t}\n\t}","id":93174,"modified_method":"protected void importEntry(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tBookmarksEntry entry)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(entry.getUserUuid());\n\t\tlong groupId = context.getGroupId();\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, entry.getFolderId(), entry.getFolderId());\n\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tBookmarksEntry.class, entry.getEntryId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\tif ((folderId != BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == entry.getFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, folderId);\n\n\t\t\tBookmarksFolder folder =\n\t\t\t\t(BookmarksFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, entry.getFolderId(), entry.getFolderId());\n\t\t}\n\n\t\tBookmarksEntry existingEntry = null;\n\n\t\ttry {\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingEntry = BookmarksEntryUtil.findByUUID_G(\n\t\t\t\t\t\tentry.getUuid(), groupId);\n\n\t\t\t\t\tBookmarksEntryLocalServiceUtil.updateEntry(\n\t\t\t\t\t\tuserId, existingEntry.getEntryId(), groupId, folderId,\n\t\t\t\t\t\tentry.getName(), entry.getUrl(), entry.getComments(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t\t\tBookmarksEntryLocalServiceUtil.addEntry(\n\t\t\t\t\t\tentry.getUuid(), userId, groupId, folderId,\n\t\t\t\t\t\tentry.getName(), entry.getUrl(), entry.getComments(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tBookmarksEntryLocalServiceUtil.addEntry(\n\t\t\t\t\tnull, userId, groupId, folderId, entry.getName(),\n\t\t\t\t\tentry.getUrl(), entry.getComments(), serviceContext);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for entry \" +\n\t\t\t\t\tentry.getEntryId());\n\t\t}\n\t}","commit_id":"abdc00228023690c30795ba3c9eda07290ace637","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences preferences)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tDocument doc = SAXReaderUtil.createDocument();\n\n\t\t\tElement root = doc.addElement(\"documentlibrary-data\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\tElement foldersEl = root.addElement(\"folders\");\n\t\t\tElement fileEntriesEl = root.addElement(\"file-entries\");\n\t\t\tElement fileShortcutsEl = root.addElement(\"file-shortcuts\");\n\t\t\tElement fileRanksEl = root.addElement(\"file-ranks\");\n\n\t\t\tList<DLFileEntry> rootFilesEntries = DLFileEntryUtil.findByG_F(\n\t\t\t\tcontext.getGroupId(),\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID);\n\n\t\t\tfor (DLFileEntry fileEntry : rootFilesEntries) {\n\t\t\t\texportFileEntry(\n\t\t\t\t\tcontext, foldersEl, fileEntriesEl, fileRanksEl, fileEntry);\n\t\t\t}\n\n\t\t\tList<DLFolder> folders = DLFolderUtil.findByGroupId(\n\t\t\t\tcontext.getGroupId());\n\n\t\t\tfor (DLFolder folder : folders) {\n\t\t\t\texportFolder(\n\t\t\t\t\tcontext, foldersEl, fileEntriesEl, fileShortcutsEl,\n\t\t\t\t\tfileRanksEl, folder);\n\t\t\t}\n\n\t\t\treturn doc.formattedString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":93175,"modified_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences preferences)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tDocument doc = SAXReaderUtil.createDocument();\n\n\t\t\tElement root = doc.addElement(\"documentlibrary-data\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\tElement foldersEl = root.addElement(\"folders\");\n\t\t\tElement fileEntriesEl = root.addElement(\"file-entries\");\n\t\t\tElement fileShortcutsEl = root.addElement(\"file-shortcuts\");\n\t\t\tElement fileRanksEl = root.addElement(\"file-ranks\");\n\n\t\t\tList<DLFolder> folders = DLFolderUtil.findByGroupId(\n\t\t\t\tcontext.getGroupId());\n\n\t\t\tfor (DLFolder folder : folders) {\n\t\t\t\texportFolder(\n\t\t\t\t\tcontext, foldersEl, fileEntriesEl, fileShortcutsEl,\n\t\t\t\t\tfileRanksEl, folder);\n\t\t\t}\n\n\t\t\tList<DLFileEntry> fileEntries = DLFileEntryUtil.findByG_F(\n\t\t\t\tcontext.getGroupId(),\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID);\n\n\t\t\tfor (DLFileEntry fileEntry : fileEntries) {\n\t\t\t\texportFileEntry(\n\t\t\t\t\tcontext, foldersEl, fileEntriesEl, fileRanksEl, fileEntry);\n\t\t\t}\n\n\t\t\treturn doc.formattedString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"abdc00228023690c30795ba3c9eda07290ace637","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void exportFileEntry(\n\t\t\tPortletDataContext context, Element foldersEl,\n\t\t\tElement fileEntriesEl, Element fileRanksEl, DLFileEntry fileEntry)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!context.isWithinDateRange(fileEntry.getModifiedDate())) {\n\t\t\treturn;\n\t\t}\n\n\t\texportParentFolder(context, foldersEl, fileEntry.getFolderId());\n\n\t\tString path = getFileEntryPath(context, fileEntry);\n\n\t\tif (context.isPathNotProcessed(path)) {\n\t\t\tElement fileEntryEl = fileEntriesEl.addElement(\"file-entry\");\n\n\t\t\tfileEntryEl.addAttribute(\"path\", path);\n\n\t\t\tString binPath = getFileEntryBinPath(context, fileEntry);\n\n\t\t\tfileEntryEl.addAttribute(\"bin-path\", binPath);\n\n\t\t\tfileEntry.setUserUuid(fileEntry.getUserUuid());\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\t\tcontext.addAssetCategories(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\t\tcontext.addComments(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tcontext.addRatingsEntries(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\tcontext.addAssetTags(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tlong repositoryId = getRepositoryId(\n\t\t\t\tfileEntry.getGroupId(), fileEntry.getFolderId());\n\n\t\t\tInputStream is = DLLocalServiceUtil.getFileAsStream(\n\t\t\t\tfileEntry.getCompanyId(), repositoryId, fileEntry.getName(),\n\t\t\t\tfileEntry.getVersion());\n\n\t\t\tif (is == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"No file found for file entry \" +\n\t\t\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t\t}\n\n\t\t\t\tfileEntryEl.detach();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcontext.addZipEntry(\n\t\t\t\t\tgetFileEntryBinPath(context, fileEntry), is);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tis.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t_log.error(ioe, ioe);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.addZipEntry(path, fileEntry);\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ranks\")) {\n\t\t\t\tList<DLFileRank> fileRanks = DLFileRankUtil.findByF_N(\n\t\t\t\t\tfileEntry.getFolderId(), fileEntry.getName());\n\n\t\t\t\tfor (DLFileRank fileRank : fileRanks) {\n\t\t\t\t\texportFileRank(context, fileRanksEl, fileRank);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":93176,"modified_method":"public static void exportFileEntry(\n\t\t\tPortletDataContext context, Element foldersEl,\n\t\t\tElement fileEntriesEl, Element fileRanksEl, DLFileEntry fileEntry)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!context.isWithinDateRange(fileEntry.getModifiedDate())) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (foldersEl != null) {\n\t\t\texportParentFolder(context, foldersEl, fileEntry.getFolderId());\n\t\t}\n\n\t\tString path = getFileEntryPath(context, fileEntry);\n\n\t\tif (context.isPathNotProcessed(path)) {\n\t\t\tElement fileEntryEl = fileEntriesEl.addElement(\"file-entry\");\n\n\t\t\tfileEntryEl.addAttribute(\"path\", path);\n\n\t\t\tString binPath = getFileEntryBinPath(context, fileEntry);\n\n\t\t\tfileEntryEl.addAttribute(\"bin-path\", binPath);\n\n\t\t\tfileEntry.setUserUuid(fileEntry.getUserUuid());\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\t\tcontext.addAssetCategories(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\t\tcontext.addComments(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tcontext.addRatingsEntries(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\tcontext.addAssetTags(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tlong repositoryId = getRepositoryId(\n\t\t\t\tfileEntry.getGroupId(), fileEntry.getFolderId());\n\n\t\t\tInputStream is = DLLocalServiceUtil.getFileAsStream(\n\t\t\t\tfileEntry.getCompanyId(), repositoryId, fileEntry.getName(),\n\t\t\t\tfileEntry.getVersion());\n\n\t\t\tif (is == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"No file found for file entry \" +\n\t\t\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t\t}\n\n\t\t\t\tfileEntryEl.detach();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcontext.addZipEntry(\n\t\t\t\t\tgetFileEntryBinPath(context, fileEntry), is);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tis.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t_log.error(ioe, ioe);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.addZipEntry(path, fileEntry);\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ranks\")) {\n\t\t\t\tList<DLFileRank> fileRanks = DLFileRankUtil.findByF_N(\n\t\t\t\t\tfileEntry.getFolderId(), fileEntry.getName());\n\n\t\t\t\tfor (DLFileRank fileRank : fileRanks) {\n\t\t\t\t\texportFileRank(context, fileRanksEl, fileRank);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"abdc00228023690c30795ba3c9eda07290ace637","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void exportImage(\n\t\t\tPortletDataContext context, Element foldersEl, Element imagesEl,\n\t\t\tIGImage image)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!context.isWithinDateRange(image.getModifiedDate())) {\n\t\t\treturn;\n\t\t}\n\n\t\texportParentFolder(context, foldersEl, image.getFolderId());\n\n\t\tString path = getImagePath(context, image);\n\n\t\tif (context.isPathNotProcessed(path)) {\n\t\t\tElement imageEl = imagesEl.addElement(\"image\");\n\n\t\t\timageEl.addAttribute(\"path\", path);\n\t\t\timageEl.addAttribute(\"bin-path\", getImageBinPath(context, image));\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\tcontext.addAssetTags(IGImage.class, image.getImageId());\n\t\t\t}\n\n\t\t\timage.setUserUuid(image.getUserUuid());\n\n\t\t\tImage largeImage = ImageUtil.findByPrimaryKey(\n\t\t\t\timage.getLargeImageId());\n\n\t\t\timage.setImageType(largeImage.getType());\n\n\t\t\tcontext.addZipEntry(\n\t\t\t\tgetImageBinPath(context, image), largeImage.getTextObj());\n\n\t\t\tcontext.addZipEntry(path, image);\n\t\t}\n\t}","id":93177,"modified_method":"public static void exportImage(\n\t\t\tPortletDataContext context, Element foldersEl, Element imagesEl,\n\t\t\tIGImage image)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!context.isWithinDateRange(image.getModifiedDate())) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (foldersEl != null) {\n\t\t\texportParentFolder(context, foldersEl, image.getFolderId());\n\t\t}\n\n\t\tString path = getImagePath(context, image);\n\n\t\tif (context.isPathNotProcessed(path)) {\n\t\t\tElement imageEl = imagesEl.addElement(\"image\");\n\n\t\t\timageEl.addAttribute(\"path\", path);\n\t\t\timageEl.addAttribute(\"bin-path\", getImageBinPath(context, image));\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\tcontext.addAssetTags(IGImage.class, image.getImageId());\n\t\t\t}\n\n\t\t\timage.setUserUuid(image.getUserUuid());\n\n\t\t\tImage largeImage = ImageUtil.findByPrimaryKey(\n\t\t\t\timage.getLargeImageId());\n\n\t\t\timage.setImageType(largeImage.getType());\n\n\t\t\tcontext.addZipEntry(\n\t\t\t\tgetImageBinPath(context, image), largeImage.getTextObj());\n\n\t\t\tcontext.addZipEntry(path, image);\n\t\t}\n\t}","commit_id":"abdc00228023690c30795ba3c9eda07290ace637","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences preferences)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tDocument doc = SAXReaderUtil.createDocument();\n\n\t\t\tElement root = doc.addElement(\"image-gallery\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\tElement foldersEl = root.addElement(\"folders\");\n\t\t\tElement imagesEl = root.addElement(\"images\");\n\n\t\t\tList<IGFolder> folders = IGFolderUtil.findByGroupId(\n\t\t\t\tcontext.getGroupId());\n\n\t\t\tfor (IGFolder folder : folders) {\n\t\t\t\texportFolder(context, foldersEl, imagesEl, folder);\n\t\t\t}\n\n\t\t\treturn doc.formattedString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":93178,"modified_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences preferences)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tDocument doc = SAXReaderUtil.createDocument();\n\n\t\t\tElement root = doc.addElement(\"image-gallery\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\tElement foldersEl = root.addElement(\"folders\");\n\t\t\tElement imagesEl = root.addElement(\"images\");\n\n\t\t\tList<IGFolder> folders = IGFolderUtil.findByGroupId(\n\t\t\t\tcontext.getGroupId());\n\n\t\t\tfor (IGFolder folder : folders) {\n\t\t\t\texportFolder(context, foldersEl, imagesEl, folder);\n\t\t\t}\n\n\t\t\tList<IGImage> images = IGImageUtil.findByG_F(\n\t\t\t\tcontext.getGroupId(),\n\t\t\t\tIGFolderConstants.DEFAULT_PARENT_FOLDER_ID);\n\n\t\t\tfor (IGImage image : images) {\n\t\t\t\texportImage(context, null, imagesEl, image);\n\t\t\t}\n\n\t\t\treturn doc.formattedString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"abdc00228023690c30795ba3c9eda07290ace637","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void importImage(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tIGImage image, String binPath)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(image.getUserUuid());\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, image.getFolderId(), image.getFolderId());\n\n\t\tFile imageFile = null;\n\n\t\tbyte[] bytes = context.getZipEntryAsByteArray(binPath);\n\n\t\tif (bytes == null) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find image file for image \" + image.getImageId());\n\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\timageFile = File.createTempFile(\n\t\t\t\tString.valueOf(image.getPrimaryKey()),\n\t\t\t\tStringPool.PERIOD + image.getImageType());\n\n\t\t\tFileUtil.write(imageFile, bytes);\n\t\t}\n\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tIGImage.class, image.getImageId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\tif ((folderId != IGFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == image.getFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, folderId);\n\n\t\t\tIGFolder folder = (IGFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, image.getFolderId(), image.getFolderId());\n\t\t}\n\n\t\tIGImage existingImage = null;\n\n\t\ttry {\n\t\t\tIGFolderUtil.findByPrimaryKey(folderId);\n\n\t\t\tlong groupId = image.getGroupId();\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingImage = IGImageUtil.findByUUID_G(\n\t\t\t\t\t\timage.getUuid(), context.getGroupId());\n\n\t\t\t\t\tIGImageLocalServiceUtil.updateImage(\n\t\t\t\t\t\tuserId, existingImage.getImageId(), groupId, folderId,\n\t\t\t\t\t\timage.getName(), image.getDescription(), imageFile,\n\t\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchImageException nsie) {\n\t\t\t\t\tIGImageLocalServiceUtil.addImage(\n\t\t\t\t\t\timage.getUuid(), userId, groupId, folderId,\n\t\t\t\t\t\timage.getName(), image.getDescription(), imageFile,\n\t\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tIGImageLocalServiceUtil.addImage(\n\t\t\t\t\tnull, userId, groupId, folderId, image.getName(),\n\t\t\t\t\timage.getDescription(), imageFile, image.getImageType(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for image \" +\n\t\t\t\t\timage.getImageId());\n\t\t}\n\t}","id":93179,"modified_method":"public static void importImage(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tIGImage image, String binPath)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(image.getUserUuid());\n\t\tlong groupId = context.getGroupId();\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, image.getFolderId(), image.getFolderId());\n\n\t\tFile imageFile = null;\n\n\t\tbyte[] bytes = context.getZipEntryAsByteArray(binPath);\n\n\t\tif (bytes == null) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find image file for image \" + image.getImageId());\n\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\timageFile = File.createTempFile(\n\t\t\t\tString.valueOf(image.getPrimaryKey()),\n\t\t\t\tStringPool.PERIOD + image.getImageType());\n\n\t\t\tFileUtil.write(imageFile, bytes);\n\t\t}\n\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tIGImage.class, image.getImageId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\tif ((folderId != IGFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == image.getFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, folderId);\n\n\t\t\tIGFolder folder = (IGFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, image.getFolderId(), image.getFolderId());\n\t\t}\n\n\t\tIGImage existingImage = null;\n\n\t\ttry {\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingImage = IGImageUtil.findByUUID_G(\n\t\t\t\t\t\timage.getUuid(), groupId);\n\n\t\t\t\t\tIGImageLocalServiceUtil.updateImage(\n\t\t\t\t\t\tuserId, existingImage.getImageId(), groupId, folderId,\n\t\t\t\t\t\timage.getName(), image.getDescription(), imageFile,\n\t\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchImageException nsie) {\n\t\t\t\t\tIGImageLocalServiceUtil.addImage(\n\t\t\t\t\t\timage.getUuid(), userId, groupId, folderId,\n\t\t\t\t\t\timage.getName(), image.getDescription(), imageFile,\n\t\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tIGImageLocalServiceUtil.addImage(\n\t\t\t\t\tnull, userId, groupId, folderId, image.getName(),\n\t\t\t\t\timage.getDescription(), imageFile, image.getImageType(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for image \" +\n\t\t\t\t\timage.getImageId());\n\t\t}\n\t}","commit_id":"abdc00228023690c30795ba3c9eda07290ace637","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences preferences)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tDocument doc = SAXReaderUtil.createDocument();\n\n\t\t\tElement root = doc.addElement(\"bookmarks-data\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\tElement foldersEl = root.addElement(\"folders\");\n\t\t\tElement entriesEl = root.addElement(\"entries\");\n\n\t\t\tList<BookmarksFolder> folders = BookmarksFolderUtil.findByGroupId(\n\t\t\t\tcontext.getGroupId());\n\n\t\t\tfor (BookmarksFolder folder : folders) {\n\t\t\t\texportFolder(context, foldersEl, entriesEl, folder);\n\t\t\t}\n\n\t\t\treturn doc.formattedString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":93180,"modified_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences preferences)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tDocument doc = SAXReaderUtil.createDocument();\n\n\t\t\tElement root = doc.addElement(\"bookmarks-data\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\tElement foldersEl = root.addElement(\"folders\");\n\t\t\tElement entriesEl = root.addElement(\"entries\");\n\n\t\t\tList<BookmarksFolder> folders = BookmarksFolderUtil.findByGroupId(\n\t\t\t\tcontext.getGroupId());\n\n\t\t\tfor (BookmarksFolder folder : folders) {\n\t\t\t\texportFolder(context, foldersEl, entriesEl, folder);\n\t\t\t}\n\n\t\t\tList<BookmarksEntry> entries = BookmarksEntryUtil.findByG_F(\n\t\t\t\tcontext.getGroupId(),\n\t\t\t\tBookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID);\n\n\t\t\tfor (BookmarksEntry entry : entries) {\n\t\t\t\texportEntry(context, null, entriesEl, entry);\n\t\t\t}\n\n\t\t\treturn doc.formattedString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"5c23f76585a709c85a27f0e8164adbdf5cc7343d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportEntry(\n\t\t\tPortletDataContext context, Element foldersEl, Element entriesEl,\n\t\t\tBookmarksEntry entry)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!context.isWithinDateRange(entry.getModifiedDate())) {\n\t\t\treturn;\n\t\t}\n\n\t\texportParentFolder(context, foldersEl, entry.getFolderId());\n\n\t\tString path = getEntryPath(context, entry);\n\n\t\tif (context.isPathNotProcessed(path)) {\n\t\t\tElement entryEl = entriesEl.addElement(\"entry\");\n\n\t\t\tentryEl.addAttribute(\"path\", path);\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\tcontext.addAssetTags(BookmarksEntry.class, entry.getEntryId());\n\t\t\t}\n\n\t\t\tentry.setUserUuid(entry.getUserUuid());\n\n\t\t\tcontext.addZipEntry(path, entry);\n\t\t}\n\t}","id":93181,"modified_method":"protected void exportEntry(\n\t\t\tPortletDataContext context, Element foldersEl, Element entriesEl,\n\t\t\tBookmarksEntry entry)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!context.isWithinDateRange(entry.getModifiedDate())) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (foldersEl != null) {\n\t\t\texportParentFolder(context, foldersEl, entry.getFolderId());\n\t\t}\n\n\t\tString path = getEntryPath(context, entry);\n\n\t\tif (context.isPathNotProcessed(path)) {\n\t\t\tElement entryEl = entriesEl.addElement(\"entry\");\n\n\t\t\tentryEl.addAttribute(\"path\", path);\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\tcontext.addAssetTags(BookmarksEntry.class, entry.getEntryId());\n\t\t\t}\n\n\t\t\tentry.setUserUuid(entry.getUserUuid());\n\n\t\t\tcontext.addZipEntry(path, entry);\n\t\t}\n\t}","commit_id":"5c23f76585a709c85a27f0e8164adbdf5cc7343d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importEntry(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tBookmarksEntry entry)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(entry.getUserUuid());\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, entry.getFolderId(), entry.getFolderId());\n\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tBookmarksEntry.class, entry.getEntryId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\tif ((folderId != BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == entry.getFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, folderId);\n\n\t\t\tBookmarksFolder folder =\n\t\t\t\t(BookmarksFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, entry.getFolderId(), entry.getFolderId());\n\t\t}\n\n\t\tBookmarksEntry existingEntry = null;\n\n\t\ttry {\n\t\t\tBookmarksFolder folder = BookmarksFolderUtil.findByPrimaryKey(\n\t\t\t\tfolderId);\n\n\t\t\tlong groupId = folder.getGroupId();\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingEntry = BookmarksEntryUtil.findByUUID_G(\n\t\t\t\t\t\tentry.getUuid(), context.getGroupId());\n\n\t\t\t\t\tBookmarksEntryLocalServiceUtil.updateEntry(\n\t\t\t\t\t\tuserId, existingEntry.getEntryId(), groupId, folderId,\n\t\t\t\t\t\tentry.getName(), entry.getUrl(), entry.getComments(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t\t\tBookmarksEntryLocalServiceUtil.addEntry(\n\t\t\t\t\t\tentry.getUuid(), userId, groupId, folderId,\n\t\t\t\t\t\tentry.getName(), entry.getUrl(), entry.getComments(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tBookmarksEntryLocalServiceUtil.addEntry(\n\t\t\t\t\tnull, userId, groupId, folderId, entry.getName(),\n\t\t\t\t\tentry.getUrl(), entry.getComments(), serviceContext);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for entry \" +\n\t\t\t\t\tentry.getEntryId());\n\t\t}\n\t}","id":93182,"modified_method":"protected void importEntry(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tBookmarksEntry entry)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(entry.getUserUuid());\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, entry.getFolderId(), entry.getFolderId());\n\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tBookmarksEntry.class, entry.getEntryId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\tif ((folderId != BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == entry.getFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, folderId);\n\n\t\t\tBookmarksFolder folder =\n\t\t\t\t(BookmarksFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, entry.getFolderId(), entry.getFolderId());\n\t\t}\n\n\t\tBookmarksEntry existingEntry = null;\n\n\t\ttry {\n\t\t\tlong groupId = context.getGroupId();\n\n\t\t\tif (folderId != BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\tBookmarksFolder folder = BookmarksFolderUtil.findByPrimaryKey(\n\t\t\t\t\tfolderId);\n\n\t\t\t\tgroupId = folder.getGroupId();\n\t\t\t}\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingEntry = BookmarksEntryUtil.findByUUID_G(\n\t\t\t\t\t\tentry.getUuid(), context.getGroupId());\n\n\t\t\t\t\tBookmarksEntryLocalServiceUtil.updateEntry(\n\t\t\t\t\t\tuserId, existingEntry.getEntryId(), groupId, folderId,\n\t\t\t\t\t\tentry.getName(), entry.getUrl(), entry.getComments(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t\t\tBookmarksEntryLocalServiceUtil.addEntry(\n\t\t\t\t\t\tentry.getUuid(), userId, groupId, folderId,\n\t\t\t\t\t\tentry.getName(), entry.getUrl(), entry.getComments(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tBookmarksEntryLocalServiceUtil.addEntry(\n\t\t\t\t\tnull, userId, groupId, folderId, entry.getName(),\n\t\t\t\t\tentry.getUrl(), entry.getComments(), serviceContext);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for entry \" +\n\t\t\t\t\tentry.getEntryId());\n\t\t}\n\t}","commit_id":"5c23f76585a709c85a27f0e8164adbdf5cc7343d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void checkEventStateTransferSequence(PushChannelApplication receiver) {\n        \n        List<Object> events = receiver.getEvents();\n        String eventString = \"[\" + receiver.getName() + \",events:\" + events;\n        log.info(eventString);        \n        assertNotNull(events);\n        assertTrue(events.size()>1);\n        assertTrue(\"First event is not block but \" + events.get(0),events.get(0) instanceof BlockEvent);\n        assertTrue(\"Last event not unblock but \" + events.get(events.size()-1),events.get(events.size()-1) instanceof UnblockEvent);\n        int size = events.size();\n        for(int i = 0;i < size;i++){\n            Object event = events.get(i);\n            if(event instanceof BlockEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After Block should be state|unblock|view, but it is \" + o.getClass() + \",events= \"+ eventString,\n                               o instanceof SetStateEvent || o instanceof GetStateEvent\n                                       || o instanceof UnblockEvent\n                                       || o instanceof View);\n                }\n                if(i > 0){\n                    Object o = events.get(i - 1);\n                    assertTrue(\"Before Block should be state or Unblock , but it is \" + o.getClass() + \",events= \" + eventString, \n                               o instanceof UnblockEvent);\n                }\n            }\n            else if(event instanceof SetStateEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After setstate should be unblock , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof UnblockEvent);\n                }\n                Object o = events.get(i - 1);\n                assertTrue(\"Before setstate should be block|view, but it is \" + o.getClass() + \",events= \" + eventString,\n                           o instanceof BlockEvent || o instanceof View);\n            }\n            else if(event instanceof GetStateEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After getstate should be getstate/unblock , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof UnblockEvent || o instanceof GetStateEvent); \n                }\n                Object o = events.get(i - 1);\n                assertTrue(\"Before state should be block/view/getstate , but it is \" + o.getClass() + \",events= \" + eventString,\n                           o instanceof BlockEvent || o instanceof View || o instanceof GetStateEvent);\n            }\n            else if(event instanceof UnblockEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After UnBlock should be Block , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof BlockEvent);\n                }\n                if(i > 0){\n                    Object o = events.get(i - 1);\n                    assertTrue(\"Before UnBlock should be block|state|view , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof SetStateEvent || o instanceof GetStateEvent\n                                       || o instanceof BlockEvent\n                                       || o instanceof View);\n                }\n            }\n\n        }        \n    }","id":93183,"modified_method":"protected void checkEventStateTransferSequence(EventSequence receiver) {\n        \n        List<Object> events = receiver.getEvents();\n        String eventString = \"[\" + receiver.getName() + \",events:\" + events;\n        log.info(eventString);        \n        assertNotNull(events);\n        assertTrue(events.size()>1);\n        assertTrue(\"First event is not block but \" + events.get(0),events.get(0) instanceof BlockEvent);\n        assertTrue(\"Last event not unblock but \" + events.get(events.size()-1),events.get(events.size()-1) instanceof UnblockEvent);\n        int size = events.size();\n        for(int i = 0;i < size;i++){\n            Object event = events.get(i);\n            if(event instanceof BlockEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After Block should be state|unblock|view, but it is \" + o.getClass() + \",events= \"+ eventString,\n                               o instanceof SetStateEvent || o instanceof GetStateEvent\n                                       || o instanceof UnblockEvent\n                                       || o instanceof View);\n                }\n                if(i > 0){\n                    Object o = events.get(i - 1);\n                    assertTrue(\"Before Block should be state or Unblock , but it is \" + o.getClass() + \",events= \" + eventString, \n                               o instanceof UnblockEvent);\n                }\n            }\n            else if(event instanceof SetStateEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After setstate should be unblock , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof UnblockEvent);\n                }\n                Object o = events.get(i - 1);\n                assertTrue(\"Before setstate should be block|view, but it is \" + o.getClass() + \",events= \" + eventString,\n                           o instanceof BlockEvent || o instanceof View);\n            }\n            else if(event instanceof GetStateEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After getstate should be getstate/unblock , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof UnblockEvent || o instanceof GetStateEvent); \n                }\n                Object o = events.get(i - 1);\n                assertTrue(\"Before state should be block/view/getstate , but it is \" + o.getClass() + \",events= \" + eventString,\n                           o instanceof BlockEvent || o instanceof View || o instanceof GetStateEvent);\n            }\n            else if(event instanceof UnblockEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After UnBlock should be Block , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof BlockEvent);\n                }\n                if(i > 0){\n                    Object o = events.get(i - 1);\n                    assertTrue(\"Before UnBlock should be block|state|view , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof SetStateEvent || o instanceof GetStateEvent\n                                       || o instanceof BlockEvent\n                                       || o instanceof View);\n                }\n            }\n\n        }        \n    }","commit_id":"f883209257ec162a66b61778c9d01d74fbe938dd","url":"https://github.com/belaban/JGroups"},{"original_method":"public Receiver(String name, JChannel channel) {\n            this.name=name;\n            this.channel=channel;\n        }","id":93184,"modified_method":"public Receiver(String name, Channel channel) {\n            this.name=name;\n            this.channel=channel;\n            this.events=new LinkedList<Object>();\n        }","commit_id":"f883209257ec162a66b61778c9d01d74fbe938dd","url":"https://github.com/belaban/JGroups"},{"original_method":"public void testFlushStartedByOneButCompletedByOther() throws Exception {\n        r1=new Receiver(\"C1\", c1);\n        r2=new Receiver(\"C2\", c2);\n        r3=new Receiver(\"C3\", c3);\n        c1.setReceiver(r1);\n        c2.setReceiver(r2);\n        c3.setReceiver(r3);\n\n        Util.sleep(1000);\n\n        System.out.println(\"starting flush at C1\");\n        boolean rc=c1.startFlush(TIMEOUT, false);\n        assertTrue(rc);\n        Util.sleep(500);\n        System.out.println(\"starting flush at C2\");\n        rc=c2.startFlush(TIMEOUT, false);\n        assertTrue(rc);\n\n        Util.sleep(1000);\n        System.out.println(\"Stopping flush at C2\");\n        c2.stopFlush();\n\n        Util.sleep(1000);\n        System.out.println(\"Stopping flush at C1\");\n        c1.stopFlush();\n\n        System.out.println(\"events for C1: \" + r1.getEvents());\n        System.out.println(\"events for C2: \" + r2.getEvents());\n        System.out.println(\"events for C3: \" + r3.getEvents());\n\n        assertEquals(4, r1.getEvents().size());\n        assertEquals(4, r2.getEvents().size());\n        assertEquals(4, r3.getEvents().size());\n        ensureOrdering(r1.getEvents(), BlockEvent.class, UnblockEvent.class, BlockEvent.class, UnblockEvent.class);\n        ensureOrdering(r2.getEvents(), BlockEvent.class, UnblockEvent.class, BlockEvent.class, UnblockEvent.class);\n        ensureOrdering(r3.getEvents(), BlockEvent.class, UnblockEvent.class, BlockEvent.class, UnblockEvent.class);\n    }","id":93185,"modified_method":"public void testFlushStartedByOneButCompletedByOther() throws Exception {\n        c1 = createChannel();\n        r1=new Receiver(\"C1\", c1);\n        c2 = createChannel();\n        r2=new Receiver(\"C2\", c2);\n        c3 = createChannel();\n        r3=new Receiver(\"C3\", c3);\n        c1.setReceiver(r1);\n        c2.setReceiver(r2);\n        c3.setReceiver(r3);\n        \n        c1.connect(\"test\");\n        c2.connect(\"test\");\n        c3.connect(\"test\");\n\n        Util.sleep(1000);\n\n        System.out.println(\"starting flush at C1\");\n        boolean rc=c1.startFlush(TIMEOUT, false);\n        assertTrue(rc);\n        Util.sleep(500);\n        \n        Util.sleep(1000);\n        System.out.println(\"Stopping flush at C2\");\n        c2.stopFlush();\n        \n        System.out.println(\"starting flush at C2\");\n        rc=c2.startFlush(TIMEOUT, false);\n        assertTrue(rc);\n        \n\n        Util.sleep(1000);\n        System.out.println(\"Stopping flush at C1\");\n        c1.stopFlush();\n\n        //let async events propagate up\n        Util.sleep(500);\n        System.out.println(\"events for C1: \" + r1.getEvents());\n        System.out.println(\"events for C2: \" + r2.getEvents());\n        System.out.println(\"events for C3: \" + r3.getEvents());\n        \n        checkEventStateTransferSequence(r1);\n        checkEventStateTransferSequence(r2);\n        checkEventStateTransferSequence(r3);\n    }","commit_id":"f883209257ec162a66b61778c9d01d74fbe938dd","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void tearDown() throws Exception {\n        if(c3 != null)\n            c3.close();\n        if(c2 != null)\n            c2.close();\n        if(c1 != null)\n            c1.close();\n        super.tearDown();\n    }","id":93186,"modified_method":"protected void tearDown() throws Exception {       \n        super.tearDown();\n        c3.close();\n        c2.close();\n        c1.close();\n    }","commit_id":"f883209257ec162a66b61778c9d01d74fbe938dd","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void setUp() throws Exception {\n        super.setUp();\n        c1=new JChannel(\"flush-udp.xml\"); c1.setOpt(Channel.BLOCK, true);\n        c2=new JChannel(\"flush-udp.xml\"); c2.setOpt(Channel.BLOCK, true);\n        c3=new JChannel(\"flush-udp.xml\"); c3.setOpt(Channel.BLOCK, true);\n\n        c1.connect(\"x\");\n        c2.connect(\"x\");\n        c3.connect(\"x\");\n    }","id":93187,"modified_method":"protected void setUp() throws Exception {\n        super.setUp();      \n        CHANNEL_CONFIG = System.getProperty(\"channel.conf.flush\", \"flush-udp.xml\");\n    }","commit_id":"f883209257ec162a66b61778c9d01d74fbe938dd","url":"https://github.com/belaban/JGroups"},{"original_method":"public Flusher(JChannel channel, CyclicBarrier barrier) {\n            this.channel=channel;\n            this.barrier=barrier;\n        }","id":93188,"modified_method":"public Flusher(Channel channel, CyclicBarrier barrier) {\n            this.channel=channel;\n            this.barrier=barrier;\n        }","commit_id":"f883209257ec162a66b61778c9d01d74fbe938dd","url":"https://github.com/belaban/JGroups"},{"original_method":"public void testSimpleFlush() throws Exception {\n        CyclicBarrier barrier=new CyclicBarrier(2);\n        r1=new Receiver(\"C1\", c1);\n        r2=new Receiver(\"C2\", c2);\n        r3=new Receiver(\"C3\", c3);\n        c1.setReceiver(r1);\n        c2.setReceiver(r2);\n        c3.setReceiver(r3);\n\n        Flusher flusher_one=new Flusher(c1, barrier);\n\n        flusher_one.start();\n        Util.sleep(1000);\n\n        System.out.println(\"starting flush at C1\");\n        barrier.await();\n        flusher_one.join();\n\n        System.out.println(\"events for C1: \" + r1.getEvents());\n        System.out.println(\"events for C2: \" + r2.getEvents());\n        System.out.println(\"events for C3: \" + r3.getEvents());\n        assertEquals(2, r1.getEvents().size());\n        assertEquals(2, r2.getEvents().size());\n        assertEquals(2, r3.getEvents().size());\n        ensureOrdering(r1.getEvents(), BlockEvent.class, UnblockEvent.class);\n        ensureOrdering(r2.getEvents(), BlockEvent.class, UnblockEvent.class);\n        ensureOrdering(r3.getEvents(), BlockEvent.class, UnblockEvent.class);\n    }","id":93189,"modified_method":"public void testSimpleFlush() throws Exception {\n        CyclicBarrier barrier=new CyclicBarrier(2);\n        c1 = createChannel();\n        r1=new Receiver(\"C1\", c1);\n        c2 = createChannel();\n        r2=new Receiver(\"C2\", c2);\n        c3 = createChannel();\n        r3=new Receiver(\"C3\", c3);\n        c1.setReceiver(r1);\n        c2.setReceiver(r2);\n        c3.setReceiver(r3);\n        \n        c1.connect(\"test\");\n        c2.connect(\"test\");\n        c3.connect(\"test\");\n\n        Flusher flusher_one=new Flusher(c1, barrier);\n\n        flusher_one.start();\n        Util.sleep(1000);\n\n        System.out.println(\"starting flush at C1\");\n        barrier.await();\n        flusher_one.join();\n\n        //let async events propagate up\n        Util.sleep(500);\n        \n        System.out.println(\"events for C1: \" + r1.getEvents());\n        System.out.println(\"events for C2: \" + r2.getEvents());\n        System.out.println(\"events for C3: \" + r3.getEvents());\n        \n        checkEventStateTransferSequence(r1);\n        checkEventStateTransferSequence(r2);\n        checkEventStateTransferSequence(r3);\n        \n\n    }","commit_id":"f883209257ec162a66b61778c9d01d74fbe938dd","url":"https://github.com/belaban/JGroups"},{"original_method":"public void testConcurrentFlush() throws Exception {\n        CyclicBarrier barrier=new CyclicBarrier(3);\n        r1=new Receiver(\"C1\", c1);\n        r2=new Receiver(\"C2\", c2);\n        r3=new Receiver(\"C3\", c3);\n        c1.setReceiver(r1);\n        c2.setReceiver(r2);\n        c3.setReceiver(r3);\n\n        Flusher flusher_one=new Flusher(c1, barrier);\n        Flusher flusher_three=new Flusher(c3, barrier);\n\n        flusher_one.start();\n        flusher_three.start();\n        Util.sleep(1000);\n\n        System.out.println(\"starting concurrent flush at C1 and C3\");\n        barrier.await();\n        flusher_one.join();\n        flusher_three.join();\n\n        System.out.println(\"events for C1: \" + r1.getEvents());\n        System.out.println(\"events for C2: \" + r2.getEvents());\n        System.out.println(\"events for C3: \" + r3.getEvents());\n        assertEquals(4, r1.getEvents().size());\n        assertEquals(4, r2.getEvents().size());\n        assertEquals(4, r3.getEvents().size());\n        ensureOrdering(r1.getEvents(), BlockEvent.class, UnblockEvent.class, BlockEvent.class, UnblockEvent.class);\n        ensureOrdering(r2.getEvents(), BlockEvent.class, UnblockEvent.class, BlockEvent.class, UnblockEvent.class);\n        ensureOrdering(r3.getEvents(), BlockEvent.class, UnblockEvent.class, BlockEvent.class, UnblockEvent.class);\n    }","id":93190,"modified_method":"public void testConcurrentFlush() throws Exception {\n        CyclicBarrier barrier=new CyclicBarrier(3);\n        c1 = createChannel();\n        r1=new Receiver(\"C1\", c1);\n        c2 = createChannel();\n        r2=new Receiver(\"C2\", c2);\n        c3 = createChannel();\n        r3=new Receiver(\"C3\", c3);\n        c1.setReceiver(r1);\n        c2.setReceiver(r2);\n        c3.setReceiver(r3);\n        \n        c1.connect(\"test\");\n        c2.connect(\"test\");\n        c3.connect(\"test\");\n\n        Flusher flusher_one=new Flusher(c1, barrier);\n        Flusher flusher_three=new Flusher(c3, barrier);\n\n        flusher_one.start();\n        flusher_three.start();\n        Util.sleep(1000);\n\n        System.out.println(\"starting concurrent flush at C1 and C3\");\n        barrier.await();\n        flusher_one.join();\n        flusher_three.join();\n\n        //let async events propagate up\n        Util.sleep(500);\n        \n        System.out.println(\"events for C1: \" + r1.getEvents());\n        System.out.println(\"events for C2: \" + r2.getEvents());\n        System.out.println(\"events for C3: \" + r3.getEvents());\n        \n        checkEventStateTransferSequence(r1);\n        checkEventStateTransferSequence(r2);\n        checkEventStateTransferSequence(r3);\n    }","commit_id":"f883209257ec162a66b61778c9d01d74fbe938dd","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void checkEventStateTransferSequence(PushChannelApplication receiver) {\n        \n        List<Object> events = receiver.getEvents();\n        String eventString = \"[\" + receiver.getName() + \",events:\" + events;\n        log.info(eventString);        \n        assertNotNull(events);\n        assertTrue(events.size()>1);\n        assertTrue(\"First event is not block but \" + events.get(0),events.get(0) instanceof BlockEvent);\n        assertTrue(\"Last event not unblock but \" + events.get(events.size()-1),events.get(events.size()-1) instanceof UnblockEvent);\n        int size = events.size();\n        for(int i = 0;i < size;i++){\n            Object event = events.get(i);\n            if(event instanceof BlockEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After Block should be state|unblock|view, but it is \" + o.getClass() + \",events= \"+ eventString,\n                               o instanceof SetStateEvent || o instanceof GetStateEvent\n                                       || o instanceof UnblockEvent\n                                       || o instanceof View);\n                }\n                if(i > 0){\n                    Object o = events.get(i - 1);\n                    assertTrue(\"Before Block should be state or Unblock , but it is \" + o.getClass() + \",events= \" + eventString, \n                               o instanceof UnblockEvent);\n                }\n            }\n            else if(event instanceof SetStateEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After setstate should be unblock , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof UnblockEvent);\n                }\n                Object o = events.get(i - 1);\n                assertTrue(\"Before setstate should be block|view, but it is \" + o.getClass() + \",events= \" + eventString,\n                           o instanceof BlockEvent || o instanceof View);\n            }\n            else if(event instanceof GetStateEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After getstate should be getstate/unblock , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof UnblockEvent || o instanceof GetStateEvent); \n                }\n                Object o = events.get(i - 1);\n                assertTrue(\"Before state should be block/view/getstate , but it is \" + o.getClass() + \",events= \" + eventString,\n                           o instanceof BlockEvent || o instanceof View || o instanceof GetStateEvent);\n            }\n            else if(event instanceof UnblockEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After UnBlock should be Block , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof BlockEvent);\n                }\n                if(i > 0){\n                    Object o = events.get(i - 1);\n                    assertTrue(\"Before UnBlock should be block|state|view , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof SetStateEvent || o instanceof GetStateEvent\n                                       || o instanceof BlockEvent\n                                       || o instanceof View);\n                }\n            }\n\n        }        \n    }","id":93191,"modified_method":"protected void checkEventStateTransferSequence(EventSequence receiver) {\n        \n        List<Object> events = receiver.getEvents();\n        String eventString = \"[\" + receiver.getName() + \",events:\" + events;\n        log.info(eventString);        \n        assertNotNull(events);\n        assertTrue(events.size()>1);\n        assertTrue(\"First event is not block but \" + events.get(0),events.get(0) instanceof BlockEvent);\n        assertTrue(\"Last event not unblock but \" + events.get(events.size()-1),events.get(events.size()-1) instanceof UnblockEvent);\n        int size = events.size();\n        for(int i = 0;i < size;i++){\n            Object event = events.get(i);\n            if(event instanceof BlockEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After Block should be state|unblock|view, but it is \" + o.getClass() + \",events= \"+ eventString,\n                               o instanceof SetStateEvent || o instanceof GetStateEvent\n                                       || o instanceof UnblockEvent\n                                       || o instanceof View);\n                }\n                if(i > 0){\n                    Object o = events.get(i - 1);\n                    assertTrue(\"Before Block should be state or Unblock , but it is \" + o.getClass() + \",events= \" + eventString, \n                               o instanceof UnblockEvent);\n                }\n            }\n            else if(event instanceof SetStateEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After setstate should be unblock , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof UnblockEvent);\n                }\n                Object o = events.get(i - 1);\n                assertTrue(\"Before setstate should be block|view, but it is \" + o.getClass() + \",events= \" + eventString,\n                           o instanceof BlockEvent || o instanceof View);\n            }\n            else if(event instanceof GetStateEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After getstate should be getstate/unblock , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof UnblockEvent || o instanceof GetStateEvent); \n                }\n                Object o = events.get(i - 1);\n                assertTrue(\"Before state should be block/view/getstate , but it is \" + o.getClass() + \",events= \" + eventString,\n                           o instanceof BlockEvent || o instanceof View || o instanceof GetStateEvent);\n            }\n            else if(event instanceof UnblockEvent){\n                if(i + 1 < size){\n                    Object o = events.get(i + 1);\n                    assertTrue(\"After UnBlock should be Block , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof BlockEvent);\n                }\n                if(i > 0){\n                    Object o = events.get(i - 1);\n                    assertTrue(\"Before UnBlock should be block|state|view , but it is \" + o.getClass() + \",events= \" + eventString,\n                               o instanceof SetStateEvent || o instanceof GetStateEvent\n                                       || o instanceof BlockEvent\n                                       || o instanceof View);\n                }\n            }\n\n        }        \n    }","commit_id":"490eb8542c68449b271cd545dd2373859af0fbca","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void setUp() throws Exception {\n        super.setUp();\n        c1=new JChannel(\"flush-udp.xml\"); c1.setOpt(Channel.BLOCK, true);\n        c2=new JChannel(\"flush-udp.xml\"); c2.setOpt(Channel.BLOCK, true);\n        c3=new JChannel(\"flush-udp.xml\"); c3.setOpt(Channel.BLOCK, true);\n\n        c1.connect(\"x\");\n        c2.connect(\"x\");\n        c3.connect(\"x\");\n    }","id":93192,"modified_method":"protected void setUp() throws Exception {\n        super.setUp();      \n        CHANNEL_CONFIG = System.getProperty(\"channel.conf.flush\", \"flush-udp.xml\");\n    }","commit_id":"490eb8542c68449b271cd545dd2373859af0fbca","url":"https://github.com/belaban/JGroups"},{"original_method":"public Flusher(JChannel channel, CyclicBarrier barrier) {\n            this.channel=channel;\n            this.barrier=barrier;\n        }","id":93193,"modified_method":"public Flusher(Channel channel, CyclicBarrier barrier) {\n            this.channel=channel;\n            this.barrier=barrier;\n        }","commit_id":"490eb8542c68449b271cd545dd2373859af0fbca","url":"https://github.com/belaban/JGroups"},{"original_method":"public void testSimpleFlush() throws Exception {\n        CyclicBarrier barrier=new CyclicBarrier(2);\n        r1=new Receiver(\"C1\", c1);\n        r2=new Receiver(\"C2\", c2);\n        r3=new Receiver(\"C3\", c3);\n        c1.setReceiver(r1);\n        c2.setReceiver(r2);\n        c3.setReceiver(r3);\n\n        Flusher flusher_one=new Flusher(c1, barrier);\n\n        flusher_one.start();\n        Util.sleep(1000);\n\n        System.out.println(\"starting flush at C1\");\n        barrier.await();\n        flusher_one.join();\n\n        System.out.println(\"events for C1: \" + r1.getEvents());\n        System.out.println(\"events for C2: \" + r2.getEvents());\n        System.out.println(\"events for C3: \" + r3.getEvents());\n        assertEquals(2, r1.getEvents().size());\n        assertEquals(2, r2.getEvents().size());\n        assertEquals(2, r3.getEvents().size());\n        ensureOrdering(r1.getEvents(), BlockEvent.class, UnblockEvent.class);\n        ensureOrdering(r2.getEvents(), BlockEvent.class, UnblockEvent.class);\n        ensureOrdering(r3.getEvents(), BlockEvent.class, UnblockEvent.class);\n    }","id":93194,"modified_method":"public void testSimpleFlush() throws Exception {\n        CyclicBarrier barrier=new CyclicBarrier(2);\n        c1 = createChannel();\n        r1=new Receiver(\"C1\", c1);\n        c2 = createChannel();\n        r2=new Receiver(\"C2\", c2);\n        c3 = createChannel();\n        r3=new Receiver(\"C3\", c3);\n        c1.setReceiver(r1);\n        c2.setReceiver(r2);\n        c3.setReceiver(r3);\n        \n        c1.connect(\"test\");\n        c2.connect(\"test\");\n        c3.connect(\"test\");\n\n        Flusher flusher_one=new Flusher(c1, barrier);\n\n        flusher_one.start();\n        Util.sleep(1000);\n\n        System.out.println(\"starting flush at C1\");\n        barrier.await();\n        flusher_one.join();\n\n        //let async events propagate up\n        Util.sleep(500);\n        \n        System.out.println(\"events for C1: \" + r1.getEvents());\n        System.out.println(\"events for C2: \" + r2.getEvents());\n        System.out.println(\"events for C3: \" + r3.getEvents());\n        \n        checkEventStateTransferSequence(r1);\n        checkEventStateTransferSequence(r2);\n        checkEventStateTransferSequence(r3);\n        \n\n    }","commit_id":"490eb8542c68449b271cd545dd2373859af0fbca","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void tearDown() throws Exception {\n        if(c3 != null)\n            c3.close();\n        if(c2 != null)\n            c2.close();\n        if(c1 != null)\n            c1.close();\n        super.tearDown();\n    }","id":93195,"modified_method":"protected void tearDown() throws Exception {       \n        super.tearDown();\n        c3.close();\n        c2.close();\n        c1.close();\n    }","commit_id":"490eb8542c68449b271cd545dd2373859af0fbca","url":"https://github.com/belaban/JGroups"},{"original_method":"public void testConcurrentFlush() throws Exception {\n        CyclicBarrier barrier=new CyclicBarrier(3);\n        r1=new Receiver(\"C1\", c1);\n        r2=new Receiver(\"C2\", c2);\n        r3=new Receiver(\"C3\", c3);\n        c1.setReceiver(r1);\n        c2.setReceiver(r2);\n        c3.setReceiver(r3);\n\n        Flusher flusher_one=new Flusher(c1, barrier);\n        Flusher flusher_three=new Flusher(c3, barrier);\n\n        flusher_one.start();\n        flusher_three.start();\n        Util.sleep(1000);\n\n        System.out.println(\"starting concurrent flush at C1 and C3\");\n        barrier.await();\n        flusher_one.join();\n        flusher_three.join();\n\n        System.out.println(\"events for C1: \" + r1.getEvents());\n        System.out.println(\"events for C2: \" + r2.getEvents());\n        System.out.println(\"events for C3: \" + r3.getEvents());\n        assertEquals(4, r1.getEvents().size());\n        assertEquals(4, r2.getEvents().size());\n        assertEquals(4, r3.getEvents().size());\n        ensureOrdering(r1.getEvents(), BlockEvent.class, UnblockEvent.class, BlockEvent.class, UnblockEvent.class);\n        ensureOrdering(r2.getEvents(), BlockEvent.class, UnblockEvent.class, BlockEvent.class, UnblockEvent.class);\n        ensureOrdering(r3.getEvents(), BlockEvent.class, UnblockEvent.class, BlockEvent.class, UnblockEvent.class);\n    }","id":93196,"modified_method":"public void testConcurrentFlush() throws Exception {\n        CyclicBarrier barrier=new CyclicBarrier(3);\n        c1 = createChannel();\n        r1=new Receiver(\"C1\", c1);\n        c2 = createChannel();\n        r2=new Receiver(\"C2\", c2);\n        c3 = createChannel();\n        r3=new Receiver(\"C3\", c3);\n        c1.setReceiver(r1);\n        c2.setReceiver(r2);\n        c3.setReceiver(r3);\n        \n        c1.connect(\"test\");\n        c2.connect(\"test\");\n        c3.connect(\"test\");\n\n        Flusher flusher_one=new Flusher(c1, barrier);\n        Flusher flusher_three=new Flusher(c3, barrier);\n\n        flusher_one.start();\n        flusher_three.start();\n        Util.sleep(1000);\n\n        System.out.println(\"starting concurrent flush at C1 and C3\");\n        barrier.await();\n        flusher_one.join();\n        flusher_three.join();\n\n        //let async events propagate up\n        Util.sleep(500);\n        \n        System.out.println(\"events for C1: \" + r1.getEvents());\n        System.out.println(\"events for C2: \" + r2.getEvents());\n        System.out.println(\"events for C3: \" + r3.getEvents());\n        \n        checkEventStateTransferSequence(r1);\n        checkEventStateTransferSequence(r2);\n        checkEventStateTransferSequence(r3);\n    }","commit_id":"490eb8542c68449b271cd545dd2373859af0fbca","url":"https://github.com/belaban/JGroups"},{"original_method":"public void testFlushStartedByOneButCompletedByOther() throws Exception {\n        r1=new Receiver(\"C1\", c1);\n        r2=new Receiver(\"C2\", c2);\n        r3=new Receiver(\"C3\", c3);\n        c1.setReceiver(r1);\n        c2.setReceiver(r2);\n        c3.setReceiver(r3);\n\n        Util.sleep(1000);\n\n        System.out.println(\"starting flush at C1\");\n        boolean rc=c1.startFlush(TIMEOUT, false);\n        assertTrue(rc);\n        Util.sleep(500);\n        System.out.println(\"starting flush at C2\");\n        rc=c2.startFlush(TIMEOUT, false);\n        assertTrue(rc);\n\n        Util.sleep(1000);\n        System.out.println(\"Stopping flush at C2\");\n        c2.stopFlush();\n\n        Util.sleep(1000);\n        System.out.println(\"Stopping flush at C1\");\n        c1.stopFlush();\n\n        System.out.println(\"events for C1: \" + r1.getEvents());\n        System.out.println(\"events for C2: \" + r2.getEvents());\n        System.out.println(\"events for C3: \" + r3.getEvents());\n\n        assertEquals(4, r1.getEvents().size());\n        assertEquals(4, r2.getEvents().size());\n        assertEquals(4, r3.getEvents().size());\n        ensureOrdering(r1.getEvents(), BlockEvent.class, UnblockEvent.class, BlockEvent.class, UnblockEvent.class);\n        ensureOrdering(r2.getEvents(), BlockEvent.class, UnblockEvent.class, BlockEvent.class, UnblockEvent.class);\n        ensureOrdering(r3.getEvents(), BlockEvent.class, UnblockEvent.class, BlockEvent.class, UnblockEvent.class);\n    }","id":93197,"modified_method":"public void testFlushStartedByOneButCompletedByOther() throws Exception {\n        c1 = createChannel();\n        r1=new Receiver(\"C1\", c1);\n        c2 = createChannel();\n        r2=new Receiver(\"C2\", c2);\n        c3 = createChannel();\n        r3=new Receiver(\"C3\", c3);\n        c1.setReceiver(r1);\n        c2.setReceiver(r2);\n        c3.setReceiver(r3);\n        \n        c1.connect(\"test\");\n        c2.connect(\"test\");\n        c3.connect(\"test\");\n\n        Util.sleep(1000);\n\n        System.out.println(\"starting flush at C1\");\n        boolean rc=c1.startFlush(TIMEOUT, false);\n        assertTrue(rc);\n        Util.sleep(500);\n        \n        Util.sleep(1000);\n        System.out.println(\"Stopping flush at C2\");\n        c2.stopFlush();\n        \n        System.out.println(\"starting flush at C2\");\n        rc=c2.startFlush(TIMEOUT, false);\n        assertTrue(rc);\n        \n\n        Util.sleep(1000);\n        System.out.println(\"Stopping flush at C1\");\n        c1.stopFlush();\n\n        //let async events propagate up\n        Util.sleep(500);\n        System.out.println(\"events for C1: \" + r1.getEvents());\n        System.out.println(\"events for C2: \" + r2.getEvents());\n        System.out.println(\"events for C3: \" + r3.getEvents());\n        \n        checkEventStateTransferSequence(r1);\n        checkEventStateTransferSequence(r2);\n        checkEventStateTransferSequence(r3);\n    }","commit_id":"490eb8542c68449b271cd545dd2373859af0fbca","url":"https://github.com/belaban/JGroups"},{"original_method":"public Receiver(String name, JChannel channel) {\n            this.name=name;\n            this.channel=channel;\n        }","id":93198,"modified_method":"public Receiver(String name, Channel channel) {\n            this.name=name;\n            this.channel=channel;\n            this.events=new LinkedList<Object>();\n        }","commit_id":"490eb8542c68449b271cd545dd2373859af0fbca","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n   public void testAndLoop() throws Exception {\n      ClusterSrv srv1 = new ClusterSrv();\n      ClusterSrv srv2 = new ClusterSrv();\n\n      for (int i = 1;i<=5; i++) {\n         srv1.start();\n         srv2.start(); \n         srv1.sendMessage(\"msg1\"); \n         srv2.sendMessage(\"msg2\"); \n\n         srv1.flush();\n         assertCount(srv1, 2, srv2, 2);\n         srv1.stopFlush();\n\n         srv1.stop();\n         srv1.start(); \n         srv2.sendMessage(\"msg3\"); \n\n         srv2.flush();\n         assertCount(srv1, 3, srv2, 3);\n         srv2.stopFlush();\n\n         srv2.stop();\n         srv2.start(); \n\n         srv2.sendMessage(\"msg4\");\n         srv2.flush();\n         srv2.stopFlush();\n         assertCount(srv1, 4, srv2, 4);\n\n         srv1.stop();\n         srv2.stop();\n         srv1.receiveCount.set(0);\n         srv2.receiveCount.set(0);\n         System.out.println(\"***** Round \" + i + \" done *****\");\n      }\n   }","id":93199,"modified_method":"@Test\n   public void testAndLoop() throws Exception {\n\n      for (int i = 1; i <= 5; i++) {\n         Channel channel = createChannel(true, 2);\n         ReceiverImpl receiver = new ReceiverImpl();\n         channel.setReceiver(receiver);\n         channel.connect(\"testClust\");\n\n         Channel channel2 = createChannel((JChannel) channel);\n         ReceiverImpl receiver2 = new ReceiverImpl();\n         channel2.setReceiver(receiver2);\n         channel2.connect(\"testClust\");\n\n         sendMessage(channel, \"msg1\");\n         sendMessage(channel2, \"msg2\");\n\n         channel.startFlush(false);\n         assertCount(receiver, 2, receiver2, 2);\n         channel.stopFlush();\n\n         channel.close();\n         channel = createChannel((JChannel) channel);\n         channel.setReceiver(receiver);\n         channel.connect(\"testClust\");\n         sendMessage(channel2, \"msg3\");\n\n         channel2.startFlush(false);\n         assertCount(receiver, 3, receiver2, 3);\n         channel.stopFlush();\n         channel2.disconnect();\n         channel2.connect(\"testClust\");\n\n         sendMessage(channel2, \"msg4\");\n         channel2.startFlush(true);\n         assertCount(receiver, 4, receiver2, 4);\n\n         channel.close();\n         channel2.close();\n         receiver.receiveCount.set(0);\n         receiver2.receiveCount.set(0);\n         System.out.println(\"***** Round \" + i + \" done *****\");\n      }\n   }","commit_id":"22113c50e7702c4821e06c262f9925aaf34c82e3","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n   public void testAndLoop() throws Exception {\n      ClusterSrv srv1 = new ClusterSrv();\n      ClusterSrv srv2 = new ClusterSrv();\n\n      for (int i = 1;i<=5; i++) {\n         srv1.start();\n         srv2.start(); \n         srv1.sendMessage(\"msg1\"); \n         srv2.sendMessage(\"msg2\"); \n\n         srv1.flush();\n         assertCount(srv1, 2, srv2, 2);\n         srv1.stopFlush();\n\n         srv1.stop();\n         srv1.start(); \n         srv2.sendMessage(\"msg3\"); \n\n         srv2.flush();\n         assertCount(srv1, 3, srv2, 3);\n         srv2.stopFlush();\n\n         srv2.stop();\n         srv2.start(); \n\n         srv2.sendMessage(\"msg4\");\n         srv2.flush();\n         srv2.stopFlush();\n         assertCount(srv1, 4, srv2, 4);\n\n         srv1.stop();\n         srv2.stop();\n         srv1.receiveCount.set(0);\n         srv2.receiveCount.set(0);\n         System.out.println(\"***** Round \" + i + \" done *****\");\n      }\n   }","id":93200,"modified_method":"@Test\n   public void testAndLoop() throws Exception {\n\n      for (int i = 1; i <= 5; i++) {\n         Channel channel = createChannel(true, 2);\n         ReceiverImpl receiver = new ReceiverImpl();\n         channel.setReceiver(receiver);\n         channel.connect(\"testClust\");\n\n         Channel channel2 = createChannel((JChannel) channel);\n         ReceiverImpl receiver2 = new ReceiverImpl();\n         channel2.setReceiver(receiver2);\n         channel2.connect(\"testClust\");\n\n         sendMessage(channel, \"msg1\");\n         sendMessage(channel2, \"msg2\");\n\n         channel.startFlush(false);\n         assertCount(receiver, 2, receiver2, 2);\n         channel.stopFlush();\n\n         channel.close();\n         channel = createChannel((JChannel) channel);\n         channel.setReceiver(receiver);\n         channel.connect(\"testClust\");\n         sendMessage(channel2, \"msg3\");\n\n         channel2.startFlush(false);\n         assertCount(receiver, 3, receiver2, 3);\n         channel.stopFlush();\n         channel2.disconnect();\n         channel2.connect(\"testClust\");\n\n         sendMessage(channel2, \"msg4\");\n         channel2.startFlush(true);\n         assertCount(receiver, 4, receiver2, 4);\n\n         channel.close();\n         channel2.close();\n         receiver.receiveCount.set(0);\n         receiver2.receiveCount.set(0);\n         System.out.println(\"***** Round \" + i + \" done *****\");\n      }\n   }","commit_id":"5e80ac7213526970fedf06298d64ba3bdfd802a8","url":"https://github.com/belaban/JGroups"},{"original_method":"private static void writeLiteralExpression(JSLiteralExpression expression, PrimitiveAmfOutputStream out, BaseWriter writer) {\n    if (expression.isNumericLiteral()) {\n      out.writeAmfDouble(expression.getText());\n    }\n    else {\n      writer.string(StringUtil.stripQuotesAroundValue(expression.getText()));\n    }\n  }","id":93201,"modified_method":"private static void writeLiteralExpression(JSLiteralExpression expression, PrimitiveAmfOutputStream out, BaseWriter writer) {\n    if (expression.isNumericLiteral()) {\n      out.writeAmfDouble(expression.getText());\n    }\n    else {\n      final PsiElement firstChild = expression.getFirstChild();\n      if (firstChild == null) {\n        writer.string(XmlTextValueProvider.EMPTY);\n        return;\n      }\n\n      final IElementType elementType = firstChild.getNode().getElementType();\n      if (elementType == JSTokenTypes.TRUE_KEYWORD) {\n        writer.getOut().write(Amf3Types.TRUE);\n      }\n      else if (elementType == JSTokenTypes.FALSE_KEYWORD) {\n        writer.getOut().write(Amf3Types.FALSE);\n      }\n      else if (elementType == JSTokenTypes.NULL_KEYWORD) {\n        writer.getOut().write(Amf3Types.NULL);\n      }\n      else {\n        writer.string(StringUtil.stripQuotesAroundValue(expression.getText()));\n      }\n    }\n  }","commit_id":"f30210b2dbe6703c835ccdbfe4870a09bbac8d4c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"boolean writeProperty(XmlAttribute attribute, AnnotationBackedDescriptor descriptor, @Nullable Context context,\n                                boolean cssRulesetDefined, boolean isMxmlProperty) {\n    final int beforePosition = out.size();\n    final PropertyKind propertyKind = writeMxmlOrSimpleProperty(attribute, valueProviderFactory.create(attribute), descriptor,\n                                                                cssRulesetDefined, context, isMxmlProperty);\n    if (propertyKind != PropertyKind.IGNORE) {\n      if (propertyProcessor.isStyle()) {\n        cssRulesetDefined = true;\n      }\n      if (propertyKind.isComplex()) {\n        writer.getBlockOut().setPosition(beforePosition);\n        addProblem(attribute, \"error.unknown.attribute.value.type\", descriptor.getType());\n      }\n    }\n    return cssRulesetDefined;\n  }","id":93202,"modified_method":"private boolean writeProperty(XmlAttribute attribute, AnnotationBackedDescriptor descriptor, @Nullable Context context,\n                                boolean cssRulesetDefined, boolean isMxmlProperty) {\n    final int beforePosition = out.size();\n    final PropertyKind propertyKind = writeMxmlOrSimpleProperty(attribute, valueProviderFactory.create(attribute), descriptor,\n                                                                cssRulesetDefined, context, isMxmlProperty);\n    if (propertyKind != PropertyKind.IGNORE) {\n      if (propertyProcessor.isStyle()) {\n        cssRulesetDefined = true;\n      }\n      if (propertyKind.isComplex()) {\n        writer.getBlockOut().setPosition(beforePosition);\n        addProblem(attribute, \"error.unknown.attribute.value.type\", descriptor.getType());\n      }\n    }\n    return cssRulesetDefined;\n  }","commit_id":"f30210b2dbe6703c835ccdbfe4870a09bbac8d4c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private boolean processFxModelTagChildren(final XmlTag parent) {\n    writer.objectHeader(\"mx.utils.ObjectProxy\");\n\n    final XmlTag[] parentSubTags = parent.getSubTags();\n    for (XmlTag tag : parentSubTags) {\n      final String tagLocalName = tag.getLocalName();\n      final XmlTag[] subTags = parent.findSubTags(tagLocalName, tag.getNamespace());\n      if (subTags.length > 1) {\n        writer.property(tagLocalName);\n        final int lengthPosition = writer.arrayHeader();\n        int length = 0;\n        for (XmlTag subTag : subTags) {\n          if (writeFxModelTagIfContainsXmlText(subTag, tagLocalName) || processFxModelTagChildren(subTag)) {\n            length++;\n          }\n        }\n\n        writer.getOut().putShort(length, lengthPosition);\n      }\n      else if (!writeFxModelTagIfContainsXmlText(tag, tagLocalName)) {\n        writer.property(tagLocalName);\n        processFxModelTagChildren(tag);\n      }\n    }\n\n    for (final XmlAttribute attribute : parent.getAttributes()) {\n      mxmlWriter.writeProperty(attribute, new AnyXmlAttributeDescriptorWrapper(attribute.getDescriptor()), null, false, true);\n    }\n\n    injectedASWriter.lastMxmlObjectReference = null;\n    writer.endObject();\n    return true;\n  }","id":93203,"modified_method":"private boolean processFxModelTagChildren(final XmlTag parent) {\n    writer.objectHeader(\"mx.utils.ObjectProxy\");\n\n    final XmlTag[] parentSubTags = parent.getSubTags();\n    for (XmlTag tag : parentSubTags) {\n      final String tagLocalName = tag.getLocalName();\n      final XmlTag[] subTags = parent.findSubTags(tagLocalName, tag.getNamespace());\n      if (subTags.length > 1) {\n        writer.property(tagLocalName);\n        final int lengthPosition = writer.arrayHeader();\n        int length = 0;\n        for (XmlTag subTag : subTags) {\n          if (writeFxModelTagIfContainsXmlText(subTag, null) || processFxModelTagChildren(subTag)) {\n            length++;\n          }\n        }\n\n        writer.getOut().putShort(length, lengthPosition);\n      }\n      else if (!writeFxModelTagIfContainsXmlText(tag, tagLocalName)) {\n        writer.property(tagLocalName);\n        processFxModelTagChildren(tag);\n      }\n    }\n\n    for (final XmlAttribute attribute : parent.getAttributes()) {\n      mxmlWriter.writeSimplProperty(attribute, new AnyXmlAttributeDescriptorWrapper(attribute.getDescriptor()));\n    }\n\n    injectedASWriter.lastMxmlObjectReference = null;\n    writer.endObject();\n    return true;\n  }","commit_id":"f30210b2dbe6703c835ccdbfe4870a09bbac8d4c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void writeUntypedPrimitiveValue(PrimitiveAmfOutputStream out, CharSequence charSequence) {\n    final String value = charSequence.toString();\n    try {\n      out.writeAmfInt(Integer.parseInt(value));\n    }\n    catch (NumberFormatException e) {\n      try {\n        out.writeAmfDouble(Double.parseDouble(value));\n      }\n      catch (NumberFormatException ignored) {\n        writer.string(charSequence);\n      }\n    }\n  }","id":93204,"modified_method":"private void writeUntypedPrimitiveValue(PrimitiveAmfOutputStream out, CharSequence charSequence) {\n    final String s = CharMatcher.WHITESPACE.trimFrom(charSequence);\n    if (s.equals(\"true\")) {\n      out.write(Amf3Types.TRUE);\n      return;\n    }\n    if (s.equals(\"false\")) {\n      out.write(Amf3Types.FALSE);\n      return;\n    }\n\n    try {\n      out.writeAmfInt(Integer.parseInt(s));\n    }\n    catch (NumberFormatException e) {\n      try {\n        out.writeAmfDouble(Double.parseDouble(s));\n      }\n      catch (NumberFormatException ignored) {\n        // write untrimmed string\n        writer.string(charSequence);\n      }\n    }\n  }","commit_id":"f30210b2dbe6703c835ccdbfe4870a09bbac8d4c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private boolean writeFxModelTagIfContainsXmlText(XmlTag parent, String tagLocalName) {\n    for (XmlTagChild child : parent.getValue().getChildren()) {\n      // ignore any subtags if XmlText presents, according to flex compiler behavior\n      if (child instanceof XmlText && !MxmlUtil.containsOnlyWhitespace(child)) {\n        final ValueWriter valueWriter;\n        final boolean referenceIdAssigned = injectedASWriter.lastMxmlObjectReference != null;\n        try {\n          valueWriter = injectedASWriter.processProperty(child, tagLocalName, null, false, null);\n        }\n        catch (InvalidPropertyException e) {\n          injectedASWriter.lastMxmlObjectReference = null;\n          writer.resetPreallocatedId();\n          // we don't need any out rollback \u2014 nothing is written yet\n          mxmlWriter.problemsHolder.add(e);\n          return true;\n        }\n\n        if (valueWriter == InjectedASWriter.IGNORE) {\n          if (!referenceIdAssigned) {\n            writer.property(\"2\");\n            writer.getOut().writeUInt29(injectedASWriter.lastMxmlObjectReference.id);\n          }\n        }\n        else {\n          if (valueWriter != null) {\n            throw new IllegalStateException(\"What?\");\n          }\n          else {\n            writer.property(tagLocalName);\n            writeUntypedPrimitiveValue(writer.getOut(), ((XmlText)child).getValue());\n          }\n        }\n\n        // ignore any attributes\n        return true;\n      }\n      else if (child instanceof XmlTag) {\n        return false;\n      }\n    }\n\n    return false;\n  }","id":93205,"modified_method":"private boolean writeFxModelTagIfContainsXmlText(XmlTag parent, @Nullable String tagLocalName) {\n    for (XmlTagChild child : parent.getValue().getChildren()) {\n      // ignore any subtags if XmlText presents, according to flex compiler behavior\n      if (child instanceof XmlText && !MxmlUtil.containsOnlyWhitespace(child)) {\n        final ValueWriter valueWriter;\n        final boolean referenceIdAssigned = injectedASWriter.lastMxmlObjectReference != null;\n        try {\n          valueWriter = injectedASWriter.processProperty(child, tagLocalName, null, false, null);\n        }\n        catch (InvalidPropertyException e) {\n          injectedASWriter.lastMxmlObjectReference = null;\n          writer.resetPreallocatedId();\n          // we don't need any out rollback \u2014 nothing is written yet\n          mxmlWriter.problemsHolder.add(e);\n          return true;\n        }\n\n        if (valueWriter == InjectedASWriter.IGNORE) {\n          if (!referenceIdAssigned) {\n            writer.property(\"2\");\n            writer.getOut().writeUInt29(injectedASWriter.lastMxmlObjectReference.id);\n          }\n        }\n        else {\n          if (valueWriter != null) {\n            throw new IllegalStateException(\"What?\");\n          }\n          else {\n            if (tagLocalName != null) {\n              writer.property(tagLocalName);\n            }\n            writeUntypedPrimitiveValue(writer.getOut(), ((XmlText)child).getValue());\n          }\n        }\n\n        // ignore any attributes\n        return true;\n      }\n      else if (child instanceof XmlTag) {\n        return false;\n      }\n    }\n\n    return false;\n  }","commit_id":"f30210b2dbe6703c835ccdbfe4870a09bbac8d4c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n     * Escapes the content and title parameters to display them in the editor form.<p>\n     * \n     * This method has to be called on the JSP right before the form display html is created.<p>     *\n     */\n    public void escapeParams() {\n        // escape the title string to be printed as text content in an input field\n        setParamPagetitle(Encoder.escapeXml(getParamPagetitle()));\n        // escape the content\n        setParamContent(Encoder.escapeWBlanks(getParamContent(), Encoder.C_UTF8_ENCODING));\n    }","id":93206,"modified_method":"/**\n     * Escapes the content and title parameters to display them in the editor form.<p>\n     * \n     * This method has to be called on the JSP right before the form display html is created.<p>     *\n     */\n    public void escapeParams() {\n        // escape the content\n        setParamContent(Encoder.escapeWBlanks(getParamContent(), Encoder.C_UTF8_ENCODING));\n    }","commit_id":"80ea027ce5e4488b9ef79cc51f4c6285bb4f1e86","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.workplace.editor.CmsEditor#actionSave()\n     */\n    public void actionSave() throws JspException { \n        try {\n            // write the modified title to the temporary file\n            String title = getParamPagetitle();\n            if (title != null && !\"null\".equals(title)) {\n                getCms().writeProperty(getParamTempfile(), I_CmsConstants.C_PROPERTY_TITLE, title);\n            }\n            // save content to temporary file\n            performSaveContent(getParamBodyname(), getParamBodylanguage());\n            // copy the temporary file content back to the original file\n            commitTempFile();\n        } catch (CmsException e) {\n            // error during saving, show error dialog\n            showErrorPage(this, e, \"save\");\n        }\n    }","id":93207,"modified_method":"/**\n     * @see org.opencms.workplace.editor.CmsEditor#actionSave()\n     */\n    public void actionSave() throws JspException { \n        try {\n            // save content to temporary file\n            performSaveContent(getParamBodyname(), getParamBodylanguage());\n            // copy the temporary file content back to the original file\n            commitTempFile();\n        } catch (CmsException e) {\n            // error during saving, show error dialog\n            showErrorPage(this, e, \"save\");\n        }\n    }","commit_id":"80ea027ce5e4488b9ef79cc51f4c6285bb4f1e86","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a list of possible elements of a template from the template property \"template-elements\".<p>\n     * \n     * @return the list of elements in a String array with element name, nice name (if present) and mandatory flag\n     * @throws CmsException if reading the property fails\n     */\n    public List computeElements() throws CmsException {\n        if (m_elementList == null) {\n            m_elementList = new ArrayList();\n            // read the property from the template file\n            String elements = getCms().readProperty(getParamPagetemplate(), \"template-elements\", false, null);\n            if (elements == null) {\n                // no elements defined on template file, don't create list\n                return null;\n            }\n            StringTokenizer T = new StringTokenizer(elements, \",\");\n            while (T.hasMoreTokens()) {\n                String currentElement = T.nextToken();\n                String niceName = \"\";\n                String mandatory = \"0\";\n                int sepIndex = currentElement.indexOf(\"|\");\n                if (sepIndex != -1) {\n                    // nice name found for current element, extract it\n                    niceName = currentElement.substring(sepIndex + 1);\n                    currentElement = currentElement.substring(0, sepIndex);\n                }\n                if (currentElement.endsWith(\"*\")) {\n                    // element is mandatory\n                    mandatory = \"1\";\n                    currentElement = currentElement.substring(0, currentElement.length() - 1);\n                }\n                if (\"\".equals(niceName)) {\n                    // no nice name found, use element name as nice name\n                    niceName = currentElement;\n                }\n                m_elementList.add(new String[] {currentElement, niceName, mandatory});\n            }\n        }\n        return m_elementList;\n    }","id":93208,"modified_method":"/**\n     * Creates a list of possible elements of a template from the template property \"template-elements\".<p>\n     * \n     * @return the list of elements in a String array with element name, nice name (if present) and mandatory flag\n     * @throws CmsException if reading the property fails\n     */\n    public List computeElements() throws CmsException {\n        if (m_elementList == null) {\n            m_elementList = new ArrayList();\n            String currentTemplate = null;\n            try {\n                currentTemplate = getCms().readProperty(getParamTempfile(), I_CmsConstants.C_PROPERTY_TEMPLATE, true);\n            } catch (CmsException e) {\n                // ignore this exception\n            }\n            if (currentTemplate == null) {\n                currentTemplate = \"\";\n            }      \n            // read the property from the template file\n            String elements = getCms().readProperty(currentTemplate, \"template-elements\", false, null);\n            if (elements == null) {\n                // no elements defined on template file, don't create list\n                return null;\n            }\n            StringTokenizer T = new StringTokenizer(elements, \",\");\n            while (T.hasMoreTokens()) {\n                String currentElement = T.nextToken();\n                String niceName = \"\";\n                String mandatory = \"0\";\n                int sepIndex = currentElement.indexOf(\"|\");\n                if (sepIndex != -1) {\n                    // nice name found for current element, extract it\n                    niceName = currentElement.substring(sepIndex + 1);\n                    currentElement = currentElement.substring(0, sepIndex);\n                }\n                if (currentElement.endsWith(\"*\")) {\n                    // element is mandatory\n                    mandatory = \"1\";\n                    currentElement = currentElement.substring(0, currentElement.length() - 1);\n                }\n                if (\"\".equals(niceName)) {\n                    // no nice name found, use element name as nice name\n                    niceName = currentElement;\n                }\n                m_elementList.add(new String[] {currentElement, niceName, mandatory});\n            }\n        }\n        return m_elementList;\n    }","commit_id":"80ea027ce5e4488b9ef79cc51f4c6285bb4f1e86","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Performs the editing of the resources properties.<p>\n     * \n     * @param request the HttpServletRequest\n     * @return true, if the properties were successfully changed, otherwise false\n     * @throws CmsException if editing is not successful\n     */\n    private boolean performEditOperation(HttpServletRequest request) throws CmsException {\n        Map activeProperties = getCms().readProperties(getParamResource());\n        boolean useTempfileProject = \"true\".equals(getParamUsetempfileproject());\n        try {\n            if (useTempfileProject) {\n                switchToTempProject();\n            }\n            // write the common properties defined by the String array\n            for (int i=0; i<PROPERTIES.length; i++) {\n                String paramValue = request.getParameter(PREFIX_VALUE + PROPERTIES[i]);\n                String oldValue = request.getParameter(PREFIX_HIDDEN + PROPERTIES[i]);\n                writeProperty(PROPERTIES[i], paramValue, oldValue, activeProperties);\n            }\n                \n            // write special file properties\n            \n            // get the navigation enabled parameter\n            String paramValue = request.getParameter(\"enablenav\");\n            String oldValue = null;\n            if (\"true\".equals(paramValue)) {\n                // navigation enabled, update params\n                paramValue = request.getParameter(\"navpos\");\n                oldValue = request.getParameter(PREFIX_HIDDEN + I_CmsConstants.C_PROPERTY_NAVPOS);\n                writeProperty(I_CmsConstants.C_PROPERTY_NAVPOS, paramValue, oldValue, activeProperties);\n                paramValue = request.getParameter(PREFIX_VALUE + I_CmsConstants.C_PROPERTY_NAVTEXT);\n                oldValue = request.getParameter(PREFIX_HIDDEN + I_CmsConstants.C_PROPERTY_NAVTEXT);\n                writeProperty(I_CmsConstants.C_PROPERTY_NAVTEXT, paramValue, oldValue, activeProperties);\n            } else {\n                // navigation disabled, delete property values\n                writeProperty(I_CmsConstants.C_PROPERTY_NAVPOS, null, null, activeProperties);\n                writeProperty(I_CmsConstants.C_PROPERTY_NAVTEXT, null, null, activeProperties);\n            }\n            \n            // get the template parameter\n            paramValue = request.getParameter(I_CmsConstants.C_PROPERTY_TEMPLATE);\n            oldValue = request.getParameter(PREFIX_HIDDEN + I_CmsConstants.C_PROPERTY_TEMPLATE);\n            writeProperty(I_CmsConstants.C_PROPERTY_TEMPLATE, paramValue, oldValue, activeProperties);\n            if (paramValue != null && !paramValue.equals(oldValue)) {\n                // template has changed, refresh editor window\n                if (getParamOkFunctions() != null && getParamOkFunctions().startsWith(\"window.close()\")) {\n                    setParamOkFunctions(\"window.opener.EDITOR.pagetemplate.value='\"+paramValue+\"';window.opener.doTemplSubmit(3);\");\n                }\n            }\n                  \n        } finally {\n            if (useTempfileProject) {\n                switchToCurrentProject();\n            }\n        }\n        return true;\n    }","id":93209,"modified_method":"/**\n     * Performs the editing of the resources properties.<p>\n     * \n     * @param request the HttpServletRequest\n     * @return true, if the properties were successfully changed, otherwise false\n     * @throws CmsException if editing is not successful\n     */\n    private boolean performEditOperation(HttpServletRequest request) throws CmsException {\n        Map activeProperties = getCms().readProperties(getParamResource());\n        boolean useTempfileProject = \"true\".equals(getParamUsetempfileproject());\n        try {\n            if (useTempfileProject) {\n                switchToTempProject();\n            }\n            // write the common properties defined by the String array\n            for (int i=0; i<PROPERTIES.length; i++) {\n                String paramValue = request.getParameter(PREFIX_VALUE + PROPERTIES[i]);\n                String oldValue = request.getParameter(PREFIX_HIDDEN + PROPERTIES[i]);\n                writeProperty(PROPERTIES[i], paramValue, oldValue, activeProperties);\n            }\n                \n            // write special file properties\n            \n            // get the navigation enabled parameter\n            String paramValue = request.getParameter(\"enablenav\");\n            String oldValue = null;\n            if (\"true\".equals(paramValue)) {\n                // navigation enabled, update params\n                paramValue = request.getParameter(\"navpos\");\n                oldValue = request.getParameter(PREFIX_HIDDEN + I_CmsConstants.C_PROPERTY_NAVPOS);\n                writeProperty(I_CmsConstants.C_PROPERTY_NAVPOS, paramValue, oldValue, activeProperties);\n                paramValue = request.getParameter(PREFIX_VALUE + I_CmsConstants.C_PROPERTY_NAVTEXT);\n                oldValue = request.getParameter(PREFIX_HIDDEN + I_CmsConstants.C_PROPERTY_NAVTEXT);\n                writeProperty(I_CmsConstants.C_PROPERTY_NAVTEXT, paramValue, oldValue, activeProperties);\n            } else {\n                // navigation disabled, delete property values\n                writeProperty(I_CmsConstants.C_PROPERTY_NAVPOS, null, null, activeProperties);\n                writeProperty(I_CmsConstants.C_PROPERTY_NAVTEXT, null, null, activeProperties);\n            }\n            \n            // get the template parameter\n            paramValue = request.getParameter(I_CmsConstants.C_PROPERTY_TEMPLATE);\n            oldValue = request.getParameter(PREFIX_HIDDEN + I_CmsConstants.C_PROPERTY_TEMPLATE);\n            writeProperty(I_CmsConstants.C_PROPERTY_TEMPLATE, paramValue, oldValue, activeProperties);\n            if (paramValue != null && !paramValue.equals(oldValue)) {\n                // template has changed, refresh editor window\n                if (getParamOkFunctions() != null && getParamOkFunctions().startsWith(\"window.close()\")) {\n                    setParamOkFunctions(\"window.opener.doTemplSubmit(1);\");\n                }\n            }\n                  \n        } finally {\n            if (useTempfileProject) {\n                switchToCurrentProject();\n            }\n        }\n        return true;\n    }","commit_id":"80ea027ce5e4488b9ef79cc51f4c6285bb4f1e86","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.workplace.CmsWorkplace#initWorkplaceRequestValues(org.opencms.workplace.CmsWorkplaceSettings, javax.servlet.http.HttpServletRequest)\n     */\n    protected void initWorkplaceRequestValues(CmsWorkplaceSettings settings, HttpServletRequest request) {\n        // fill the parameter values in the get/set methods\n        fillParamValues(request);\n        // set the dialog type\n        setParamDialogtype(DIALOG_TYPE);\n        // set the action for the JSP switch \n        if (DIALOG_SHOW_DEFAULT.equals(getParamAction())) {\n            // redirect to the default OpenCms dialog\n            setAction(ACTION_DEFAULT);\n            try {\n                getCms().getRequestContext().getResponse().sendCmsRedirect(CmsProperty.URI_PROPERTY_DIALOG + \"?\" + paramsAsRequest());\n            } catch (Exception e) {\n                // ignore this exception\n            }          \n        } else if (DIALOG_SAVE_EDIT.equals(getParamAction())) {\n            // save the edited properties\n            setAction(ACTION_SAVE_EDIT);\n        } else {                   \n            setAction(ACTION_EDIT); \n            setParamTitle(key(\"title.property\") + \": \" + CmsResource.getName(getParamResource()));\n        }         \n    }","id":93210,"modified_method":"/**\n     * @see org.opencms.workplace.CmsWorkplace#initWorkplaceRequestValues(org.opencms.workplace.CmsWorkplaceSettings, javax.servlet.http.HttpServletRequest)\n     */\n    protected void initWorkplaceRequestValues(CmsWorkplaceSettings settings, HttpServletRequest request) {\n        // fill the parameter values in the get/set methods\n        fillParamValues(request);\n        // set the dialog type\n        setParamDialogtype(DIALOG_TYPE);\n        // set the action for the JSP switch \n        if (DIALOG_SHOW_DEFAULT.equals(getParamAction())) {\n            // redirect to the default OpenCms dialog\n            setAction(ACTION_DEFAULT);\n            try {\n                getCms().getRequestContext().getResponse().sendCmsRedirect(CmsProperty.URI_PROPERTY_DIALOG + \"?\" + paramsAsRequest());\n            } catch (Exception e) {\n                // ignore this exception\n            }          \n        } else if (DIALOG_SAVE_EDIT.equals(getParamAction())) {\n            // save the edited properties\n            setAction(ACTION_SAVE_EDIT);\n        } else {                   \n            setAction(ACTION_EDIT); \n            String resName = CmsResource.getName(getParamResource());\n            if (resName.startsWith(I_CmsConstants.C_TEMP_PREFIX)) {\n                resName = resName.substring(1);\n            }\n            setParamTitle(key(\"title.property\") + \": \" + resName);\n        }         \n    }","commit_id":"80ea027ce5e4488b9ef79cc51f4c6285bb4f1e86","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Manipulates the content String for the different editor views and the save operation.<p>\n     * \n     * @param save if set to true, the content parameter is not updated\n     * @return the prepared content String\n     */\n    protected String prepareContent(boolean save) {\n        String content = getParamContent();\n        String contentLowerCase = content.toLowerCase();\n        int indexBodyStart = contentLowerCase.indexOf(\"<body>\");\n        boolean isBrowserNS = BROWSER_NS.equals(getBrowserType());\n        if (\"edit\".equals(getParamEditormode()) || isBrowserNS || save) {\n            // editor is in text mode or content should be saved\n            if (indexBodyStart != -1) {\n                // cut tags which are unwanted for text editor\n                content = content.substring(indexBodyStart + 6);\n                contentLowerCase = contentLowerCase.substring(indexBodyStart + 6);\n                content = content.substring(0, contentLowerCase.indexOf(\"<\/body>\"));\n            }           \n        } else {\n            // editor is in html mode, add tags for stylesheet\n            String stylesheet = getJsp().property(I_CmsConstants.C_PROPERTY_TEMPLATE, getParamPagetemplate(), \"\");\n            if (indexBodyStart != -1) {\n                // first delete the old tags\n                content = content.substring(indexBodyStart + 6);\n                contentLowerCase = contentLowerCase.substring(indexBodyStart + 6);\n                content = content.substring(0, contentLowerCase.indexOf(\"<\/body>\"));\n            }      \n            \n            // create a head with stylesheet for template and base URL to display images correctly\n            String server = getJsp().getRequest().getScheme() + \"://\" + getJsp().getRequest().getServerName() + \":\" + getJsp().getRequest().getServerPort();\n            String head = \"<html><head>\";\n            if (!\"\".equals(stylesheet)) {\n                stylesheet = getJsp().link(stylesheet);\n                head += \"<link href=\\\"\" + server + stylesheet + \"\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\";\n            }            \n            head += \"<base href=\\\"\" + server + OpenCms.getOpenCmsContext() + \"\\\"><\/base><\/head><body>\";\n            content =  head + content + \"<\/body><\/html>\";             \n        }\n        if (!save) {\n            // set the content parameter to the modified content\n            setParamContent(content);\n        }\n        return content.trim();\n    }","id":93211,"modified_method":"/**\n     * Manipulates the content String for the different editor views and the save operation.<p>\n     * \n     * @param save if set to true, the content parameter is not updated\n     * @return the prepared content String\n     */\n    protected String prepareContent(boolean save) {\n        String content = getParamContent();\n        String contentLowerCase = content.toLowerCase();\n        int indexBodyStart = contentLowerCase.indexOf(\"<body>\");\n        boolean isBrowserNS = BROWSER_NS.equals(getBrowserType());\n        if (\"edit\".equals(getParamEditormode()) || isBrowserNS || save) {\n            // editor is in text mode or content should be saved\n            if (indexBodyStart != -1) {\n                // cut tags which are unwanted for text editor\n                content = content.substring(indexBodyStart + 6);\n                contentLowerCase = contentLowerCase.substring(indexBodyStart + 6);\n                content = content.substring(0, contentLowerCase.indexOf(\"<\/body>\"));\n            }           \n        } else {\n            // editor is in html mode, add tags for stylesheet\n            String currentTemplate = null;\n            String stylesheet = \"\";\n            try {\n                currentTemplate = getCms().readProperty(getParamResource(), I_CmsConstants.C_PROPERTY_TEMPLATE, true);\n            } catch (CmsException e) {\n                // ignore this exception\n            }\n            if (currentTemplate == null) {\n                currentTemplate = \"\";\n            } else {      \n                stylesheet = getJsp().property(I_CmsConstants.C_PROPERTY_TEMPLATE, currentTemplate, \"\");\n            }\n            if (indexBodyStart != -1) {\n                // first delete the old tags\n                content = content.substring(indexBodyStart + 6);\n                contentLowerCase = contentLowerCase.substring(indexBodyStart + 6);\n                content = content.substring(0, contentLowerCase.indexOf(\"<\/body>\"));\n            }      \n            \n            // create a head with stylesheet for template and base URL to display images correctly\n            String server = getJsp().getRequest().getScheme() + \"://\" + getJsp().getRequest().getServerName() + \":\" + getJsp().getRequest().getServerPort();\n            String head = \"<html><head>\";\n            if (!\"\".equals(stylesheet)) {\n                stylesheet = getJsp().link(stylesheet);\n                head += \"<link href=\\\"\" + server + stylesheet + \"\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\";\n            }            \n            head += \"<base href=\\\"\" + server + OpenCms.getOpenCmsContext() + \"\\\"><\/base><\/head><body>\";\n            content =  head + content + \"<\/body><\/html>\";             \n        }\n        if (!save) {\n            // set the content parameter to the modified content\n            setParamContent(content);\n        }\n        return content.trim();\n    }","commit_id":"80ea027ce5e4488b9ef79cc51f4c6285bb4f1e86","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.workplace.CmsWorkplace#initWorkplaceRequestValues(org.opencms.workplace.CmsWorkplaceSettings, javax.servlet.http.HttpServletRequest)\n     */\n    protected void initWorkplaceRequestValues(CmsWorkplaceSettings settings, HttpServletRequest request) {\n        // fill the parameter values in the get/set methods\n        fillParamValues(request);\n        // set the dialog type\n        setParamDialogtype(EDITOR_TYPE);\n        \n        // Initialize a page object from the temporary file\n        if (getParamTempfile() != null && !\"null\".equals(getParamTempfile())) {\n            try {\n                m_file = getCms().readFile(this.getParamTempfile());\n                m_page = CmsXmlPage.read(getCms(), m_file);\n            } catch (CmsException e) {\n                // error during initialization\n                try {\n                    showErrorPage(this, e, \"read\");\n                } catch (JspException exc) {\n                    // ignore this exception\n                }\n            }\n        }\n\n        // set the action for the JSP switch \n        if (EDITOR_SAVE.equals(getParamAction())) {\n            setAction(ACTION_SAVE);\n        } else if (EDITOR_SAVEEXIT.equals(getParamAction())) {\n            setAction(ACTION_SAVEEXIT);\n        } else if (EDITOR_SAVEACTION.equals(getParamAction())) {\n            setAction(ACTION_SAVEACTION);\n            try {\n                actionDirectEdit();\n            } catch (Exception e) {\n                // ignore this exception\n            }\n        } else if (EDITOR_EXIT.equals(getParamAction())) {\n            setAction(ACTION_EXIT);\n        } else if (EDITOR_CHANGE_BODY.equals(getParamAction())) {\n            setAction(ACTION_SHOW);\n            actionChangeBodyElement();\n        } else if (EDITOR_CHANGE_TEMPLATE.equals(getParamAction())) {\n            setAction(ACTION_SHOW);\n            actionChangeTemplate();\n        } else if (EDITOR_NEW_BODY.equals(getParamAction())) {\n            setAction(ACTION_SHOW);            \n            actionNewBody();\n        } else if (EDITOR_SHOW.equals(getParamAction())) {\n            setAction(ACTION_SHOW);\n        } else if (EDITOR_PREVIEW.equals(getParamAction())) {\n            setAction(ACTION_PREVIEW);\n        } else {\n            // initial call of editor, initialize page and page parameters\n            setAction(ACTION_DEFAULT);\n            try {\n                // lock resource if autolock is enabled in configuration\n                if (\"true\".equals(getParamDirectedit())) {\n                    // set a temporary lock in direct edit mode\n                    checkLock(getParamResource(), CmsLock.C_MODE_TEMP);\n                } else {\n                    // set common lock\n                    checkLock(getParamResource());\n                }\n                // create the temporary file\n                setParamTempfile(createTempFile());\n                // initialize a page object from the created temporary file\n                m_file =  getCms().readFile(this.getParamTempfile());\n                m_page = CmsXmlPage.read(getCms(), m_file);\n            } catch (CmsException e) {\n                // error during initialization\n                try {\n                    showErrorPage(this, e, \"read\");\n                } catch (JspException exc) {\n                    // ignore this exception\n                }\n            }\n            // set the initial body language & name if not given in request parameters\n            if (getParamBodylanguage() == null) {\n                initBodyElementLanguage();\n            }\n            if (getParamBodyname() == null) {\n                initBodyElementName();\n            }\n            // initialize the editor content\n            initContent();\n            // set template\n            // setParamPagetemplate(getJsp().property(I_CmsConstants.C_PROPERTY_TEMPLATE, getParamTempfile(), \"\"));\n            try {\n                setParamPagetemplate(getCms().readProperty(getParamTempfile(), I_CmsConstants.C_PROPERTY_TEMPLATE, true, \"\"));\n            } catch (CmsException exc) {\n                setParamPagetemplate(\"\");\n            }\n            // set page title\n            setParamPagetitle(getJsp().property(I_CmsConstants.C_PROPERTY_TITLE, getParamTempfile(), \"\"));\n        } \n        \n        // prepare the content String for the editor\n        prepareContent(false);\n    }","id":93212,"modified_method":"/**\n     * @see org.opencms.workplace.CmsWorkplace#initWorkplaceRequestValues(org.opencms.workplace.CmsWorkplaceSettings, javax.servlet.http.HttpServletRequest)\n     */\n    protected void initWorkplaceRequestValues(CmsWorkplaceSettings settings, HttpServletRequest request) {\n        // fill the parameter values in the get/set methods\n        fillParamValues(request);\n        // set the dialog type\n        setParamDialogtype(EDITOR_TYPE);\n        \n        // Initialize a page object from the temporary file\n        if (getParamTempfile() != null && !\"null\".equals(getParamTempfile())) {\n            try {\n                m_file = getCms().readFile(this.getParamTempfile());\n                m_page = CmsXmlPage.read(getCms(), m_file);\n            } catch (CmsException e) {\n                // error during initialization\n                try {\n                    showErrorPage(this, e, \"read\");\n                } catch (JspException exc) {\n                    // ignore this exception\n                }\n            }\n        }\n\n        // set the action for the JSP switch \n        if (EDITOR_SAVE.equals(getParamAction())) {\n            setAction(ACTION_SAVE);\n        } else if (EDITOR_SAVEEXIT.equals(getParamAction())) {\n            setAction(ACTION_SAVEEXIT);\n        } else if (EDITOR_SAVEACTION.equals(getParamAction())) {\n            setAction(ACTION_SAVEACTION);\n            try {\n                actionDirectEdit();\n            } catch (Exception e) {\n                // ignore this exception\n            }\n        } else if (EDITOR_EXIT.equals(getParamAction())) {\n            setAction(ACTION_EXIT);\n        } else if (EDITOR_CHANGE_BODY.equals(getParamAction())) {\n            setAction(ACTION_SHOW);\n            actionChangeBodyElement();\n        } else if (EDITOR_SHOW.equals(getParamAction())) {\n            setAction(ACTION_SHOW);\n        } else if (EDITOR_PREVIEW.equals(getParamAction())) {\n            setAction(ACTION_PREVIEW);\n        } else {\n            // initial call of editor, initialize page and page parameters\n            setAction(ACTION_DEFAULT);\n            try {\n                // lock resource if autolock is enabled in configuration\n                if (\"true\".equals(getParamDirectedit())) {\n                    // set a temporary lock in direct edit mode\n                    checkLock(getParamResource(), CmsLock.C_MODE_TEMP);\n                } else {\n                    // set common lock\n                    checkLock(getParamResource());\n                }\n                // create the temporary file\n                setParamTempfile(createTempFile());\n                // initialize a page object from the created temporary file\n                m_file =  getCms().readFile(this.getParamTempfile());\n                m_page = CmsXmlPage.read(getCms(), m_file);\n            } catch (CmsException e) {\n                // error during initialization\n                try {\n                    showErrorPage(this, e, \"read\");\n                } catch (JspException exc) {\n                    // ignore this exception\n                }\n            }\n            // set the initial body language & name if not given in request parameters\n            if (getParamBodylanguage() == null) {\n                initBodyElementLanguage();\n            }\n            if (getParamBodyname() == null) {\n                initBodyElementName();\n            }\n            // initialize the editor content\n            initContent();\n        } \n        \n        // prepare the content String for the editor\n        prepareContent(false);\n    }","commit_id":"80ea027ce5e4488b9ef79cc51f4c6285bb4f1e86","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void initJSONConfiguration() {\n        LOG.debug(\"Initializing default JSON Converters Configuration...\");\n\n        List<ObjectMarshaller<JSON>> marshallers = new ArrayList<ObjectMarshaller<JSON>>();\n        marshallers.addAll(getPreviouslyConfiguredMarshallers(JSON.class));\n        marshallers.add(new org.grails.web.converters.marshaller.json.ArrayMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.json.ByteArrayMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.json.CollectionMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.json.MapMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.json.EnumMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.ProxyUnwrappingMarshaller<JSON>());\n\n        DeprecatedGrailsConfig grailsConfig = new DeprecatedGrailsConfig(grailsApplication);\n        if (\"javascript\".equals(grailsConfig.get(\"grails.converters.json.date\", \"default\", Arrays.asList(\"javascript\", \"default\")))) {\n            LOG.debug(\"Using Javascript JSON Date Marshaller.\");\n            marshallers.add(new org.grails.web.converters.marshaller.json.JavascriptDateMarshaller());\n        }\n        else {\n            LOG.debug(\"Using default JSON Date Marshaller\");\n            marshallers.add(new org.grails.web.converters.marshaller.json.DateMarshaller());\n        }\n        marshallers.add(new org.grails.web.converters.marshaller.json.ToStringBeanMarshaller());\n\n        boolean includeDomainVersion = includeDomainVersionProperty(grailsConfig,\"json\");\n        ProxyHandler proxyHandler = getProxyHandler();\n        if (grailsConfig.get(\"grails.converters.json.default.deep\", false)) {\n            LOG.debug(\"Using DeepDomainClassMarshaller as default.\");\n            marshallers.add(new org.grails.web.converters.marshaller.json.DeepDomainClassMarshaller(includeDomainVersion, proxyHandler, grailsApplication));\n        }\n        else {\n            marshallers.add(new org.grails.web.converters.marshaller.json.DomainClassMarshaller(includeDomainVersion, proxyHandler, grailsApplication));\n        }\n        marshallers.add(new org.grails.web.converters.marshaller.json.GroovyBeanMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.json.GenericJavaBeanMarshaller());\n\n        DefaultConverterConfiguration<JSON> cfg = new DefaultConverterConfiguration<JSON>(marshallers, proxyHandler);\n        cfg.setEncoding(grailsConfig.get(\"grails.converters.encoding\", \"UTF-8\"));\n        String defaultCirRefBehaviour = grailsConfig.get(\"grails.converters.default.circular.reference.behaviour\", \"DEFAULT\");\n        cfg.setCircularReferenceBehaviour(Converter.CircularReferenceBehaviour.valueOf(\n                grailsConfig.get(\"grails.converters.json.circular.reference.behaviour\",\n                      defaultCirRefBehaviour, Converter.CircularReferenceBehaviour.allowedValues())));\n\n        Boolean defaultPrettyPrint = grailsConfig.get(\"grails.converters.default.pretty.print\", false);\n        Boolean prettyPrint = grailsConfig.get(\"grails.converters.json.pretty.print\", defaultPrettyPrint);\n        cfg.setPrettyPrint(prettyPrint);\n        cfg.setCacheObjectMarshallerByClass(grailsConfig.get(\"grails.converters.json.cacheObjectMarshallerSelectionByClass\", true));\n\n        registerObjectMarshallersFromApplicationContext(cfg, JSON.class);\n\n        ConvertersConfigurationHolder.setDefaultConfiguration(JSON.class, new ChainedConverterConfiguration<JSON>(cfg, proxyHandler));\n    }","id":93213,"modified_method":"private void initJSONConfiguration() {\n        if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Initializing default JSON Converters Configuration...\");\n        }\n\n        List<ObjectMarshaller<JSON>> marshallers = new ArrayList<ObjectMarshaller<JSON>>();\n        marshallers.addAll(getPreviouslyConfiguredMarshallers(JSON.class));\n        marshallers.add(new org.grails.web.converters.marshaller.json.ArrayMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.json.ByteArrayMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.json.CollectionMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.json.MapMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.json.EnumMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.ProxyUnwrappingMarshaller<JSON>());\n\n        Config grailsConfig = grailsApplication.getConfig();\n        if (\"javascript\".equals(grailsConfig.getProperty(SETTING_CONVERTERS_JSON_DATE, String.class, \"default\",Arrays.asList(\"javascript\", \"default\")))) {\n            if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Using Javascript JSON Date Marshaller.\");\n            }\n            marshallers.add(new org.grails.web.converters.marshaller.json.JavascriptDateMarshaller());\n        }\n        else {\n            if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Using default JSON Date Marshaller\");\n            }\n            marshallers.add(new org.grails.web.converters.marshaller.json.DateMarshaller());\n        }\n        marshallers.add(new org.grails.web.converters.marshaller.json.ToStringBeanMarshaller());\n\n        boolean includeDomainVersion = includeDomainVersionProperty(grailsConfig,\"json\");\n        boolean includeDomainClassName = includeDomainClassProperty(grailsConfig,\"json\");\n        ProxyHandler proxyHandler = getProxyHandler();\n        if (grailsConfig.getProperty(SETTING_CONVERTERS_JSON_DEFAULT_DEEP, Boolean.class, false)) {\n            LOG.debug(\"Using DeepDomainClassMarshaller as default.\");\n            marshallers.add(new org.grails.web.converters.marshaller.json.DeepDomainClassMarshaller(includeDomainVersion, includeDomainClassName, proxyHandler, grailsApplication));\n        }\n        else {\n            marshallers.add(new org.grails.web.converters.marshaller.json.DomainClassMarshaller(includeDomainVersion, includeDomainClassName, proxyHandler, grailsApplication));\n        }\n        marshallers.add(new org.grails.web.converters.marshaller.json.GroovyBeanMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.json.GenericJavaBeanMarshaller());\n\n        DefaultConverterConfiguration<JSON> cfg = new DefaultConverterConfiguration<JSON>(marshallers, proxyHandler);\n        cfg.setEncoding(grailsConfig.getProperty(SETTING_CONVERTERS_ENCODING, \"UTF-8\"));\n        String defaultCirRefBehaviour = grailsConfig.getProperty(SETTING_CONVERTERS_CIRCULAR_REFERENCE_BEHAVIOUR, \"DEFAULT\");\n        cfg.setCircularReferenceBehaviour(Converter.CircularReferenceBehaviour.valueOf(\n                grailsConfig.getProperty(SETTING_CONVERTERS_JSON_CIRCULAR_REFERENCE_BEHAVIOUR,String.class,\n                      defaultCirRefBehaviour, Converter.CircularReferenceBehaviour.allowedValues())));\n\n        Boolean defaultPrettyPrint = grailsConfig.getProperty(SETTING_CONVERTERS_PRETTY_PRINT, Boolean.class, false);\n        Boolean prettyPrint = grailsConfig.getProperty(SETTING_CONVERTERS_JSON_PRETTY_PRINT, Boolean.class, defaultPrettyPrint);\n        cfg.setPrettyPrint(prettyPrint);\n        cfg.setCacheObjectMarshallerByClass(grailsConfig.getProperty(SETTING_CONVERTERS_JSON_CACHE_OBJECTS, Boolean.class, true));\n\n        registerObjectMarshallersFromApplicationContext(cfg, JSON.class);\n\n        ConvertersConfigurationHolder.setDefaultConfiguration(JSON.class, new ChainedConverterConfiguration<JSON>(cfg, proxyHandler));\n    }","commit_id":"fea97e8624b9428d7e987dce41a037d12004d409","url":"https://github.com/grails/grails-core"},{"original_method":"public void initialize() {\n        LOG.debug(\"Initializing Converters Default Configurations...\");\n        initJSONConfiguration();\n        initXMLConfiguration();\n        initDeepJSONConfiguration();\n        initDeepXMLConfiguration();\n    }","id":93214,"modified_method":"public void initialize() {\n        if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Initializing Converters Default Configurations...\");\n        }\n        initJSONConfiguration();\n        initXMLConfiguration();\n        initDeepJSONConfiguration();\n        initDeepXMLConfiguration();\n    }","commit_id":"fea97e8624b9428d7e987dce41a037d12004d409","url":"https://github.com/grails/grails-core"},{"original_method":"private void initDeepXMLConfiguration() {\n        DeprecatedGrailsConfig grailsConfig = new DeprecatedGrailsConfig(grailsApplication);\n        DefaultConverterConfiguration<XML> deepConfig = new DefaultConverterConfiguration<XML>(ConvertersConfigurationHolder.getConverterConfiguration(XML.class), getProxyHandler());\n        deepConfig.registerObjectMarshaller(new org.grails.web.converters.marshaller.xml.DeepDomainClassMarshaller(includeDomainVersionProperty(grailsConfig, \"xml\"), getProxyHandler(), grailsApplication));\n        ConvertersConfigurationHolder.setNamedConverterConfiguration(XML.class, \"deep\", deepConfig);\n    }","id":93215,"modified_method":"private void initDeepXMLConfiguration() {\n        DefaultConverterConfiguration<XML> deepConfig = new DefaultConverterConfiguration<XML>(ConvertersConfigurationHolder.getConverterConfiguration(XML.class), getProxyHandler());\n        deepConfig.registerObjectMarshaller(new org.grails.web.converters.marshaller.xml.DeepDomainClassMarshaller(includeDomainVersionProperty(grailsApplication.getConfig(), \"xml\"), getProxyHandler(), grailsApplication));\n        ConvertersConfigurationHolder.setNamedConverterConfiguration(XML.class, \"deep\", deepConfig);\n    }","commit_id":"fea97e8624b9428d7e987dce41a037d12004d409","url":"https://github.com/grails/grails-core"},{"original_method":"private void initDeepJSONConfiguration() {\n        DeprecatedGrailsConfig grailsConfig = new DeprecatedGrailsConfig(grailsApplication);\n        DefaultConverterConfiguration<JSON> deepConfig = new DefaultConverterConfiguration<JSON>(ConvertersConfigurationHolder.getConverterConfiguration(JSON.class), getProxyHandler());\n        deepConfig.registerObjectMarshaller(new org.grails.web.converters.marshaller.json.DeepDomainClassMarshaller(includeDomainVersionProperty(grailsConfig, \"json\"), getProxyHandler(), grailsApplication));\n        ConvertersConfigurationHolder.setNamedConverterConfiguration(JSON.class, \"deep\", deepConfig);\n    }","id":93216,"modified_method":"private void initDeepJSONConfiguration() {\n        DefaultConverterConfiguration<JSON> deepConfig = new DefaultConverterConfiguration<JSON>(ConvertersConfigurationHolder.getConverterConfiguration(JSON.class), getProxyHandler());\n        deepConfig.registerObjectMarshaller(new org.grails.web.converters.marshaller.json.DeepDomainClassMarshaller(includeDomainVersionProperty(grailsApplication.getConfig(), \"json\"), getProxyHandler(), grailsApplication));\n        ConvertersConfigurationHolder.setNamedConverterConfiguration(JSON.class, \"deep\", deepConfig);\n    }","commit_id":"fea97e8624b9428d7e987dce41a037d12004d409","url":"https://github.com/grails/grails-core"},{"original_method":"private void initXMLConfiguration() {\n        LOG.debug(\"Initializing default XML Converters Configuration...\");\n\n        List<ObjectMarshaller<XML>> marshallers = new ArrayList<ObjectMarshaller<XML>>();\n        marshallers.addAll(getPreviouslyConfiguredMarshallers(XML.class));\n        marshallers.add(new org.grails.web.converters.marshaller.xml.Base64ByteArrayMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.xml.ArrayMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.xml.CollectionMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.xml.MapMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.xml.EnumMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.xml.DateMarshaller());\n        marshallers.add(new ProxyUnwrappingMarshaller<XML>());\n        marshallers.add(new org.grails.web.converters.marshaller.xml.ToStringBeanMarshaller());\n        ProxyHandler proxyHandler = getProxyHandler();\n\n        DeprecatedGrailsConfig grailsConfig = new DeprecatedGrailsConfig(grailsApplication);\n        boolean includeDomainVersion = includeDomainVersionProperty(grailsConfig, \"xml\");\n        if (grailsConfig.get(\"grails.converters.xml.default.deep\", false)) {\n            marshallers.add(new org.grails.web.converters.marshaller.xml.DeepDomainClassMarshaller(includeDomainVersion, proxyHandler, grailsApplication));\n        }\n        else {\n            marshallers.add(new org.grails.web.converters.marshaller.xml.DomainClassMarshaller(includeDomainVersion, proxyHandler, grailsApplication));\n        }\n        marshallers.add(new org.grails.web.converters.marshaller.xml.GroovyBeanMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.xml.GenericJavaBeanMarshaller());\n\n        DefaultConverterConfiguration<XML> cfg = new DefaultConverterConfiguration<XML>(marshallers,proxyHandler);\n        cfg.setEncoding(grailsConfig.get(\"grails.converters.encoding\", \"UTF-8\"));\n        String defaultCirRefBehaviour = grailsConfig.get(\"grails.converters.default.circular.reference.behaviour\", \"DEFAULT\");\n        cfg.setCircularReferenceBehaviour(Converter.CircularReferenceBehaviour.valueOf(\n                grailsConfig.get(\"grails.converters.xml.circular.reference.behaviour\",\n                      defaultCirRefBehaviour, Converter.CircularReferenceBehaviour.allowedValues())));\n\n        Boolean defaultPrettyPrint = grailsConfig.get(\"grails.converters.default.pretty.print\", false);\n        Boolean prettyPrint = grailsConfig.get(\"grails.converters.xml.pretty.print\", defaultPrettyPrint);\n        cfg.setPrettyPrint(prettyPrint);\n        cfg.setCacheObjectMarshallerByClass(grailsConfig.get(\"grails.converters.xml.cacheObjectMarshallerSelectionByClass\", true));\n        registerObjectMarshallersFromApplicationContext(cfg, XML.class);\n        ConvertersConfigurationHolder.setDefaultConfiguration(XML.class, new ChainedConverterConfiguration<XML>(cfg,proxyHandler));\n    }","id":93217,"modified_method":"private void initXMLConfiguration() {\n        LOG.debug(\"Initializing default XML Converters Configuration...\");\n\n        List<ObjectMarshaller<XML>> marshallers = new ArrayList<ObjectMarshaller<XML>>();\n        marshallers.addAll(getPreviouslyConfiguredMarshallers(XML.class));\n        marshallers.add(new org.grails.web.converters.marshaller.xml.Base64ByteArrayMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.xml.ArrayMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.xml.CollectionMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.xml.MapMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.xml.EnumMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.xml.DateMarshaller());\n        marshallers.add(new ProxyUnwrappingMarshaller<XML>());\n        marshallers.add(new org.grails.web.converters.marshaller.xml.ToStringBeanMarshaller());\n        ProxyHandler proxyHandler = getProxyHandler();\n\n        Config grailsConfig = grailsApplication.getConfig();\n        boolean includeDomainVersion = includeDomainVersionProperty(grailsConfig, \"xml\");\n        if (grailsConfig.getProperty(SETTING_CONVERTERS_XML_DEEP, Boolean.class, false)) {\n            marshallers.add(new org.grails.web.converters.marshaller.xml.DeepDomainClassMarshaller(includeDomainVersion, proxyHandler, grailsApplication));\n        }\n        else {\n            marshallers.add(new org.grails.web.converters.marshaller.xml.DomainClassMarshaller(includeDomainVersion, proxyHandler, grailsApplication));\n        }\n        marshallers.add(new org.grails.web.converters.marshaller.xml.GroovyBeanMarshaller());\n        marshallers.add(new org.grails.web.converters.marshaller.xml.GenericJavaBeanMarshaller());\n\n        DefaultConverterConfiguration<XML> cfg = new DefaultConverterConfiguration<XML>(marshallers,proxyHandler);\n        cfg.setEncoding(grailsConfig.getProperty(SETTING_CONVERTERS_ENCODING, \"UTF-8\"));\n        String defaultCirRefBehaviour = grailsConfig.getProperty(SETTING_CONVERTERS_CIRCULAR_REFERENCE_BEHAVIOUR, \"DEFAULT\");\n        cfg.setCircularReferenceBehaviour(Converter.CircularReferenceBehaviour.valueOf(\n                grailsConfig.getProperty(\"grails.converters.xml.circular.reference.behaviour\",String.class,\n                      defaultCirRefBehaviour, Converter.CircularReferenceBehaviour.allowedValues())));\n\n        Boolean defaultPrettyPrint = grailsConfig.getProperty(SETTING_CONVERTERS_PRETTY_PRINT, Boolean.class, false);\n        Boolean prettyPrint = grailsConfig.getProperty(\"grails.converters.xml.pretty.print\", Boolean.class, defaultPrettyPrint);\n        cfg.setPrettyPrint(prettyPrint);\n        cfg.setCacheObjectMarshallerByClass(grailsConfig.getProperty(\"grails.converters.xml.cacheObjectMarshallerSelectionByClass\", Boolean.class, true));\n        registerObjectMarshallersFromApplicationContext(cfg, XML.class);\n        ConvertersConfigurationHolder.setDefaultConfiguration(XML.class, new ChainedConverterConfiguration<XML>(cfg,proxyHandler));\n    }","commit_id":"fea97e8624b9428d7e987dce41a037d12004d409","url":"https://github.com/grails/grails-core"},{"original_method":"private boolean includeDomainVersionProperty(DeprecatedGrailsConfig grailsConfig, String converterType) {\n        return grailsConfig.get(String.format(\"grails.converters.%s.domain.include.version\", converterType),\n                grailsConfig.get(\"grails.converters.domain.include.version\", false));\n    }","id":93218,"modified_method":"private boolean includeDomainVersionProperty(Config grailsConfig, String converterType) {\n        return grailsConfig.getProperty(String.format(\"grails.converters.%s.domain.include.version\", converterType), Boolean.class, grailsConfig.getProperty(\"grails.converters.domain.include.version\", Boolean.class, false));\n    }","commit_id":"fea97e8624b9428d7e987dce41a037d12004d409","url":"https://github.com/grails/grails-core"},{"original_method":"public DomainClassMarshaller(boolean includeVersion, ProxyHandler proxyHandler, GrailsApplication application) {\n        this.includeVersion = includeVersion;\n        this.proxyHandler = proxyHandler;\n        this.application = application;\n    }","id":93219,"modified_method":"public DomainClassMarshaller(boolean includeVersion, ProxyHandler proxyHandler, GrailsApplication application) {\n        this(includeVersion, false, proxyHandler, application);\n    }","commit_id":"fea97e8624b9428d7e987dce41a037d12004d409","url":"https://github.com/grails/grails-core"},{"original_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public void marshalObject(Object value, JSON json) throws ConverterException {\n        JSONWriter writer = json.getWriter();\n        value = proxyHandler.unwrapIfProxy(value);\n        Class<?> clazz = value.getClass();\n\n        List<String> excludes = json.getExcludes(clazz);\n        List<String> includes = json.getIncludes(clazz);\n        IncludeExcludeSupport<String> includeExcludeSupport = new IncludeExcludeSupport<String>();\n\n        GrailsDomainClass domainClass = (GrailsDomainClass)application.getArtefact(\n              DomainClassArtefactHandler.TYPE, ConverterUtil.trimProxySuffix(clazz.getName()));\n        BeanWrapper beanWrapper = new BeanWrapperImpl(value);\n\n        writer.object();\n\n        if(shouldInclude(includeExcludeSupport, includes, excludes, value, \"class\")) {\n            writer.key(\"class\").value(domainClass.getClazz().getName());\n        }\n\n\n        GrailsDomainClassProperty id = domainClass.getIdentifier();\n\n        if(shouldInclude(includeExcludeSupport, includes, excludes, value, id.getName())) {\n            Object idValue = extractValue(value, id);\n            json.property(GrailsDomainClassProperty.IDENTITY, idValue);\n        }\n\n        if (shouldInclude(includeExcludeSupport, includes, excludes, value, GrailsDomainClassProperty.VERSION) && isIncludeVersion()) {\n            GrailsDomainClassProperty versionProperty = domainClass.getVersion();\n            Object version = extractValue(value, versionProperty);\n            json.property(GrailsDomainClassProperty.VERSION, version);\n        }\n\n        GrailsDomainClassProperty[] properties = domainClass.getPersistentProperties();\n\n        for (GrailsDomainClassProperty property : properties) {\n            if(!shouldInclude(includeExcludeSupport, includes, excludes, value, property.getName())) continue;\n\n            writer.key(property.getName());\n            if (!property.isAssociation()) {\n                // Write non-relation property\n                Object val = beanWrapper.getPropertyValue(property.getName());\n                json.convertAnother(val);\n            }\n            else {\n                Object referenceObject = beanWrapper.getPropertyValue(property.getName());\n                if (isRenderDomainClassRelations()) {\n                    if (referenceObject == null) {\n                        writer.valueNull();\n                    }\n                    else {\n                        referenceObject = proxyHandler.unwrapIfProxy(referenceObject);\n                        if (referenceObject instanceof SortedMap) {\n                            referenceObject = new TreeMap((SortedMap) referenceObject);\n                        }\n                        else if (referenceObject instanceof SortedSet) {\n                            referenceObject = new TreeSet((SortedSet) referenceObject);\n                        }\n                        else if (referenceObject instanceof Set) {\n                            referenceObject = new HashSet((Set) referenceObject);\n                        }\n                        else if (referenceObject instanceof Map) {\n                            referenceObject = new HashMap((Map) referenceObject);\n                        }\n                        else if (referenceObject instanceof Collection) {\n                            referenceObject = new ArrayList((Collection) referenceObject);\n                        }\n                        json.convertAnother(referenceObject);\n                    }\n                }\n                else {\n                    if (referenceObject == null) {\n                        json.value(null);\n                    }\n                    else {\n                        GrailsDomainClass referencedDomainClass = property.getReferencedDomainClass();\n\n                        // Embedded are now always fully rendered\n                        if (referencedDomainClass == null || property.isEmbedded() || property.getType().isEnum()) {\n                            json.convertAnother(referenceObject);\n                        }\n                        else if (property.isOneToOne() || property.isManyToOne() || property.isEmbedded()) {\n                            asShortObject(referenceObject, json, referencedDomainClass.getIdentifier(), referencedDomainClass);\n                        }\n                        else {\n                            GrailsDomainClassProperty referencedIdProperty = referencedDomainClass.getIdentifier();\n                            @SuppressWarnings(\"unused\")\n                            String refPropertyName = referencedDomainClass.getPropertyName();\n                            if (referenceObject instanceof Collection) {\n                                Collection o = (Collection) referenceObject;\n                                writer.array();\n                                for (Object el : o) {\n                                    asShortObject(el, json, referencedIdProperty, referencedDomainClass);\n                                }\n                                writer.endArray();\n                            }\n                            else if (referenceObject instanceof Map) {\n                                Map<Object, Object> map = (Map<Object, Object>) referenceObject;\n                                for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                                    String key = String.valueOf(entry.getKey());\n                                    Object o = entry.getValue();\n                                    writer.object();\n                                    writer.key(key);\n                                    asShortObject(o, json, referencedIdProperty, referencedDomainClass);\n                                    writer.endObject();\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        writer.endObject();\n    }","id":93220,"modified_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public void marshalObject(Object value, JSON json) throws ConverterException {\n        JSONWriter writer = json.getWriter();\n        value = proxyHandler.unwrapIfProxy(value);\n        Class<?> clazz = value.getClass();\n\n        List<String> excludes = json.getExcludes(clazz);\n        List<String> includes = json.getIncludes(clazz);\n        IncludeExcludeSupport<String> includeExcludeSupport = new IncludeExcludeSupport<String>();\n\n        GrailsDomainClass domainClass = (GrailsDomainClass)application.getArtefact(\n              DomainClassArtefactHandler.TYPE, ConverterUtil.trimProxySuffix(clazz.getName()));\n        BeanWrapper beanWrapper = new BeanWrapperImpl(value);\n\n        writer.object();\n\n        if(includeClass && shouldInclude(includeExcludeSupport, includes, excludes, value, \"class\")) {\n            writer.key(\"class\").value(domainClass.getClazz().getName());\n        }\n\n\n        GrailsDomainClassProperty id = domainClass.getIdentifier();\n\n        if(shouldInclude(includeExcludeSupport, includes, excludes, value, id.getName())) {\n            Object idValue = extractValue(value, id);\n            if(idValue != null) {\n                json.property(GrailsDomainClassProperty.IDENTITY, idValue);\n            }\n        }\n\n        if (shouldInclude(includeExcludeSupport, includes, excludes, value, GrailsDomainClassProperty.VERSION) && isIncludeVersion()) {\n            GrailsDomainClassProperty versionProperty = domainClass.getVersion();\n            Object version = extractValue(value, versionProperty);\n            if(version != null) {\n                json.property(GrailsDomainClassProperty.VERSION, version);\n            }\n        }\n\n        GrailsDomainClassProperty[] properties = domainClass.getPersistentProperties();\n\n        for (GrailsDomainClassProperty property : properties) {\n            if(!shouldInclude(includeExcludeSupport, includes, excludes, value, property.getName())) continue;\n\n            writer.key(property.getName());\n            if (!property.isAssociation()) {\n                // Write non-relation property\n                Object val = beanWrapper.getPropertyValue(property.getName());\n                json.convertAnother(val);\n            }\n            else {\n                Object referenceObject = beanWrapper.getPropertyValue(property.getName());\n                if (isRenderDomainClassRelations()) {\n                    if (referenceObject == null) {\n                        writer.valueNull();\n                    }\n                    else {\n                        referenceObject = proxyHandler.unwrapIfProxy(referenceObject);\n                        if (referenceObject instanceof SortedMap) {\n                            referenceObject = new TreeMap((SortedMap) referenceObject);\n                        }\n                        else if (referenceObject instanceof SortedSet) {\n                            referenceObject = new TreeSet((SortedSet) referenceObject);\n                        }\n                        else if (referenceObject instanceof Set) {\n                            referenceObject = new HashSet((Set) referenceObject);\n                        }\n                        else if (referenceObject instanceof Map) {\n                            referenceObject = new HashMap((Map) referenceObject);\n                        }\n                        else if (referenceObject instanceof Collection) {\n                            referenceObject = new ArrayList((Collection) referenceObject);\n                        }\n                        json.convertAnother(referenceObject);\n                    }\n                }\n                else {\n                    if (referenceObject == null) {\n                        json.value(null);\n                    }\n                    else {\n                        GrailsDomainClass referencedDomainClass = property.getReferencedDomainClass();\n\n                        // Embedded are now always fully rendered\n                        if (referencedDomainClass == null || property.isEmbedded() || property.getType().isEnum()) {\n                            json.convertAnother(referenceObject);\n                        }\n                        else if (property.isOneToOne() || property.isManyToOne() || property.isEmbedded()) {\n                            asShortObject(referenceObject, json, referencedDomainClass.getIdentifier(), referencedDomainClass);\n                        }\n                        else {\n                            GrailsDomainClassProperty referencedIdProperty = referencedDomainClass.getIdentifier();\n                            @SuppressWarnings(\"unused\")\n                            String refPropertyName = referencedDomainClass.getPropertyName();\n                            if (referenceObject instanceof Collection) {\n                                Collection o = (Collection) referenceObject;\n                                writer.array();\n                                for (Object el : o) {\n                                    asShortObject(el, json, referencedIdProperty, referencedDomainClass);\n                                }\n                                writer.endArray();\n                            }\n                            else if (referenceObject instanceof Map) {\n                                Map<Object, Object> map = (Map<Object, Object>) referenceObject;\n                                for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                                    String key = String.valueOf(entry.getKey());\n                                    Object o = entry.getValue();\n                                    writer.object();\n                                    writer.key(key);\n                                    asShortObject(o, json, referencedIdProperty, referencedDomainClass);\n                                    writer.endObject();\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        writer.endObject();\n    }","commit_id":"fea97e8624b9428d7e987dce41a037d12004d409","url":"https://github.com/grails/grails-core"},{"original_method":"protected void asShortObject(Object refObj, JSON json, GrailsDomainClassProperty idProperty, GrailsDomainClass referencedDomainClass) throws ConverterException {\n\n        Object idValue;\n\n        if (proxyHandler instanceof EntityProxyHandler) {\n            idValue = ((EntityProxyHandler) proxyHandler).getProxyIdentifier(refObj);\n            if (idValue == null) {\n                idValue = extractValue(refObj, idProperty);\n            }\n        }\n        else {\n            idValue = extractValue(refObj, idProperty);\n        }\n        JSONWriter writer = json.getWriter();\n        writer.object();\n        writer.key(\"class\").value(referencedDomainClass.getFullName());\n        writer.key(\"id\").value(idValue);\n        writer.endObject();\n    }","id":93221,"modified_method":"protected void asShortObject(Object refObj, JSON json, GrailsDomainClassProperty idProperty, GrailsDomainClass referencedDomainClass) throws ConverterException {\n\n        Object idValue;\n\n        if (proxyHandler instanceof EntityProxyHandler) {\n            idValue = ((EntityProxyHandler) proxyHandler).getProxyIdentifier(refObj);\n            if (idValue == null) {\n                idValue = extractValue(refObj, idProperty);\n            }\n        }\n        else {\n            idValue = extractValue(refObj, idProperty);\n        }\n        JSONWriter writer = json.getWriter();\n        writer.object();\n        if(isIncludeClass()) {\n            writer.key(\"class\").value(referencedDomainClass.getFullName());\n        }\n        if(idValue != null) {\n            writer.key(\"id\").value(idValue);\n        }\n        writer.endObject();\n    }","commit_id":"fea97e8624b9428d7e987dce41a037d12004d409","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Not all methods make sense when shown in drop downs. Like toArray, hashCode, size. \n     * Methods can only be called or used to set something. Reasonable methods examples: clean, set, add.\n     * \n     * @param clazz\n     * @param methodName\n     * @return\n     */\n    private boolean isReasonableMethod(Class< ? > clazz,\n                                       String methodName) {\n        if ( \"hashCode\".equals( methodName ) || \"equals\".equals( methodName ) ) {\n            return false;\n        }\n\n        List interfaces = Arrays.asList( clazz.getInterfaces() );\n\n        if ( clazz.equals( Collection.class ) || interfaces.contains( Collection.class ) ) {\n            if ( checkCollectionMethods( methodName ) ) {\n                return false;\n            }\n        }\n\n        if ( clazz.equals( Set.class ) || interfaces.contains( Set.class ) ) {\n            if ( checkCollectionMethods( methodName ) ) {\n                return false;\n            }\n        }\n\n        if ( clazz.equals( List.class ) || interfaces.contains( List.class ) ) {\n\n            if ( checkCollectionMethods( methodName ) || \"listIterator\".equals( methodName ) || \"lastIndexOf\".equals( methodName ) || \"indexOf\".equals( methodName ) || \"subList\".equals( methodName ) ) {\n                return false;\n            }\n        }\n\n        if ( clazz.equals( Map.class ) || interfaces.contains( Map.class ) ) {\n            if ( \"get\".equals( methodName ) || \"isEmpty\".equals( methodName ) || \"containsKey\".equals( methodName ) || \"values\".equals( methodName ) || \"entrySet\".equals( methodName ) || \"containsValue\".equals( methodName )\n                 || \"keySet\".equals( methodName ) || \"size\".equals( methodName ) ) {\n                return false;\n            }\n        }\n\n        return true;\n    }","id":93222,"modified_method":"/**\n     * Not all methods make sense when shown in drop downs. Like toArray, hashCode, size. \n     * Methods can only be called or used to set something. Reasonable methods examples: clean, set, add.\n     * \n     * @param clazz\n     * @param methodName\n     * @return\n     */\n    private boolean isReasonableMethod(Class< ? > clazz,\n                                       String methodName) {\n        if ( \"hashCode\".equals( methodName ) || \"equals\".equals( methodName ) ) {\n            return false;\n        }\n\n\n        if ( Collection.class.isAssignableFrom( clazz ) ) {\n            if ( checkCollectionMethods( methodName ) ) {\n                return false;\n            }\n        }\n\n        if ( Set.class.isAssignableFrom( clazz ) ) {\n            if ( checkCollectionMethods( methodName ) ) {\n                return false;\n            }\n        }\n\n        if ( List.class.isAssignableFrom( clazz ) ) {\n\n            if ( checkCollectionMethods( methodName ) || \"listIterator\".equals( methodName ) || \"lastIndexOf\".equals( methodName ) || \"indexOf\".equals( methodName ) || \"subList\".equals( methodName ) ) {\n                return false;\n            }\n        }\n\n        if ( Map.class.isAssignableFrom( clazz ) ) {\n            if ( \"get\".equals( methodName ) || \"isEmpty\".equals( methodName ) || \"containsKey\".equals( methodName ) || \"values\".equals( methodName ) || \"entrySet\".equals( methodName ) || \"containsValue\".equals( methodName )\n                 || \"keySet\".equals( methodName ) || \"size\".equals( methodName ) ) {\n                return false;\n            }\n        }\n\n        return true;\n    }","commit_id":"e5e87931d6aba539682282399038c548fac8eb4f","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Creates the next alignment context from the given state.  Note that this is implemented as a lazy load method.\n     * nextAlignmentContext MUST BE null in order for this method to advance to the next entry.\n     */\n    private void lazyLoadNextAlignmentContext() {\n        while (nextAlignmentContext == null && readStates.hasNext()) {\n            // this call will set hasExtendedEvents to true if it picks up a read with indel right before the current position on the ref:\n            readStates.collectPendingReads();\n\n            int size = 0;\n            int nDeletions = 0;\n            int nInsertions = 0;\n            int nMQ0Reads = 0;\n\n\n            // if extended events are requested, and if previous traversal step brought us over an indel in\n            // at least one read, we emit extended pileup (making sure that it is associated with the previous base,\n            // i.e. the one right *before* the indel) and do NOT shift the current position on the ref.\n            // In this case, the subsequent call to next() will emit the normal pileup at the current base\n            // and shift the position.\n            if (readInfo.generateExtendedEvents() && hasExtendedEvents) {\n                Map<String, ReadBackedExtendedEventPileupImpl> fullExtendedEventPileup = new HashMap<String, ReadBackedExtendedEventPileupImpl>();\n\n                // get current location on the reference and decrement it by 1: the indels we just stepped over\n                // are associated with the *previous* reference base\n                GenomeLoc loc = genomeLocParser.incPos(getLocation(), -1);\n\n                boolean hasBeenSampled = false;\n                for (final String sample : samples) {\n                    Iterator<SAMRecordState> iterator = readStates.iterator(sample);\n                    List<ExtendedEventPileupElement> indelPile = new ArrayList<ExtendedEventPileupElement>(readStates.size(sample));\n                    hasBeenSampled |= loc.getStart() <= readStates.getDownsamplingExtent(sample);\n\n                    size = 0;\n                    nDeletions = 0;\n                    nInsertions = 0;\n                    nMQ0Reads = 0;\n                    int maxDeletionLength = 0;\n\n                    while (iterator.hasNext()) {\n                        final SAMRecordState state = iterator.next();\n                        final GATKSAMRecord read = (GATKSAMRecord) state.getRead();   // the actual read\n                        final CigarOperator op = state.getCurrentCigarOperator();     // current cigar operator\n                        final int readOffset = state.getReadOffset();                 // the base offset on this read\n                        final int eventStartOffset = state.getReadEventStartOffset(); // this will be -1 if base is not a deletion, or if base is the first deletion in the event. Otherwise, it will give the last base before the deletion began.\n                        final int eventLength = state.getEventLength();\n\n                        if (op == CigarOperator.N)                                    // N's are never added to any pileup\n                                continue;\n\n                        if (state.hadIndel()) {                                       // this read has an indel associated with the previous position on the ref\n                            size++;\n                            ExtendedEventPileupElement pileupElement;\n                            if (state.getEventBases() == null) {                      // Deletion event\n                                nDeletions++;\n                                maxDeletionLength = Math.max(maxDeletionLength, state.getEventLength());\n                                pileupElement = new ExtendedEventPileupElement(read, eventStartOffset, eventLength);\n                            }\n                            else {                                                    // Insertion event\n                                nInsertions++;\n                                pileupElement = new ExtendedEventPileupElement(read, eventStartOffset, eventLength, state.getEventBases());\n                            }\n                            if (read.getMappingQuality() == 0)\n                                nMQ0Reads++;\n\n                            indelPile.add(pileupElement);\n                        }\n\n                        // this read has no indel so add it to the pileup as a NOEVENT:\n                        //   a deletion that didn't start here (therefore, not an extended event)\n                        //   we add (mis)matches as no events.\n                        else if (op != CigarOperator.D || readInfo.includeReadsWithDeletionAtLoci()) {\n                            size++;\n                            indelPile.add(new ExtendedEventPileupElement((GATKSAMRecord) state.getRead(), readOffset));\n                            if (read.getMappingQuality() == 0)\n                                nMQ0Reads++;\n                        }\n                    }\n\n                    if (indelPile.size() != 0)\n                        fullExtendedEventPileup.put(sample, new ReadBackedExtendedEventPileupImpl(loc, indelPile, size, maxDeletionLength, nInsertions, nDeletions, nMQ0Reads));\n                }\n                hasExtendedEvents = false;                                            // we are done with extended events prior to current ref base\n                nextAlignmentContext = new AlignmentContext(loc, new ReadBackedExtendedEventPileupImpl(loc, fullExtendedEventPileup), hasBeenSampled);\n            }\n            else {                                                                    // this is a regular event pileup (not extended)\n                GenomeLoc location = getLocation();\n                Map<String, ReadBackedPileupImpl> fullPileup = new HashMap<String, ReadBackedPileupImpl>();\n                boolean hasBeenSampled = false;\n                for (final String sample : samples) {\n                    Iterator<SAMRecordState> iterator = readStates.iterator(sample);\n                    List<PileupElement> pile = new ArrayList<PileupElement>(readStates.size(sample));\n                    hasBeenSampled |= location.getStart() <= readStates.getDownsamplingExtent(sample);\n\n                    size = 0;                                                         // number of elements in this sample's pileup\n                    nDeletions = 0;                                                   // number of deletions in this sample's pileup\n                    nMQ0Reads = 0;                                                    // number of MQ0 reads in this sample's pileup (warning: current implementation includes N bases that are MQ0)\n\n                    while (iterator.hasNext()) {\n                        final SAMRecordState state = iterator.next();                 // state object with the read/offset information\n                        final GATKSAMRecord read = (GATKSAMRecord) state.getRead();   // the actual read\n                        final CigarOperator op = state.getCurrentCigarOperator();     // current cigar operator\n                        final CigarElement nextElement = state.peekForwardOnGenome();     // next cigar element\n                        final CigarOperator nextOp = nextElement.getOperator();\n                        final int readOffset = state.getReadOffset();                 // the base offset on this read\n                        byte[] insertedBases = Arrays.copyOfRange(read.getReadBases(), readOffset + 1, readOffset + 1 + nextElement.getLength());\n                        int nextElementLength = nextElement.getLength();\n\n                        if (op == CigarOperator.N)                                    // N's are never added to any pileup\n                            continue;\n\n                        if (op == CigarOperator.D) {\n                            if (readInfo.includeReadsWithDeletionAtLoci()) {          // only add deletions to the pileup if we are authorized to do so\n                                pile.add(new PileupElement(read, readOffset, true, nextOp == CigarOperator.D, nextOp == CigarOperator.I, nextOp == CigarOperator.S || (state.getGenomeOffset() == 0 && read.getSoftStart() != read.getAlignmentStart()),\n                                        null,nextOp == CigarOperator.D? nextElementLength:-1));\n                                size++;\n                                nDeletions++;\n                                if (read.getMappingQuality() == 0)\n                                    nMQ0Reads++;\n                            }\n                        }\n                        else {\n                            if (!filterBaseInRead(read, location.getStart())) {\n                                pile.add(new PileupElement(read, readOffset, false, nextOp == CigarOperator.D, nextOp == CigarOperator.I, nextOp == CigarOperator.S || (state.getGenomeOffset() == 0 && read.getSoftStart() != read.getAlignmentStart()),\n                                        new String(insertedBases),nextElementLength));\n                                size++;\n                                if (read.getMappingQuality() == 0)\n                                    nMQ0Reads++;\n                            }\n                        }\n                    }\n\n                    if (pile.size() != 0)                                             // if this pileup added at least one base, add it to the full pileup\n                        fullPileup.put(sample, new ReadBackedPileupImpl(location, pile, size, nDeletions, nMQ0Reads));\n                }\n\n                updateReadStates();                                                   // critical - must be called after we get the current state offsets and location\n                if (!fullPileup.isEmpty())                                            // if we got reads with non-D/N over the current position, we are done\n                    nextAlignmentContext = new AlignmentContext(location, new ReadBackedPileupImpl(location, fullPileup), hasBeenSampled);\n            }\n        }\n    }","id":93223,"modified_method":"/**\n     * Creates the next alignment context from the given state.  Note that this is implemented as a lazy load method.\n     * nextAlignmentContext MUST BE null in order for this method to advance to the next entry.\n     */\n    private void lazyLoadNextAlignmentContext() {\n        while (nextAlignmentContext == null && readStates.hasNext()) {\n            // this call will set hasExtendedEvents to true if it picks up a read with indel right before the current position on the ref:\n            readStates.collectPendingReads();\n\n            int size = 0;\n            int nDeletions = 0;\n            int nInsertions = 0;\n            int nMQ0Reads = 0;\n\n\n            // if extended events are requested, and if previous traversal step brought us over an indel in\n            // at least one read, we emit extended pileup (making sure that it is associated with the previous base,\n            // i.e. the one right *before* the indel) and do NOT shift the current position on the ref.\n            // In this case, the subsequent call to next() will emit the normal pileup at the current base\n            // and shift the position.\n            if (readInfo.generateExtendedEvents() && hasExtendedEvents) {\n                Map<String, ReadBackedExtendedEventPileupImpl> fullExtendedEventPileup = new HashMap<String, ReadBackedExtendedEventPileupImpl>();\n\n                // get current location on the reference and decrement it by 1: the indels we just stepped over\n                // are associated with the *previous* reference base\n                GenomeLoc loc = genomeLocParser.incPos(getLocation(), -1);\n\n                boolean hasBeenSampled = false;\n                for (final String sample : samples) {\n                    Iterator<SAMRecordState> iterator = readStates.iterator(sample);\n                    List<ExtendedEventPileupElement> indelPile = new ArrayList<ExtendedEventPileupElement>(readStates.size(sample));\n                    hasBeenSampled |= loc.getStart() <= readStates.getDownsamplingExtent(sample);\n\n                    size = 0;\n                    nDeletions = 0;\n                    nInsertions = 0;\n                    nMQ0Reads = 0;\n                    int maxDeletionLength = 0;\n\n                    while (iterator.hasNext()) {\n                        final SAMRecordState state = iterator.next();\n                        final GATKSAMRecord read = (GATKSAMRecord) state.getRead();   // the actual read\n                        final CigarOperator op = state.getCurrentCigarOperator();     // current cigar operator\n                        final int readOffset = state.getReadOffset();                 // the base offset on this read\n                        final int eventStartOffset = state.getReadEventStartOffset(); // this will be -1 if base is not a deletion, or if base is the first deletion in the event. Otherwise, it will give the last base before the deletion began.\n                        final int eventLength = state.getEventLength();\n\n                        if (op == CigarOperator.N)                                    // N's are never added to any pileup\n                                continue;\n\n                        if (state.hadIndel()) {                                       // this read has an indel associated with the previous position on the ref\n                            size++;\n                            ExtendedEventPileupElement pileupElement;\n                            if (state.getEventBases() == null) {                      // Deletion event\n                                nDeletions++;\n                                maxDeletionLength = Math.max(maxDeletionLength, state.getEventLength());\n                                pileupElement = new ExtendedEventPileupElement(read, eventStartOffset, eventLength);\n                            }\n                            else {                                                    // Insertion event\n                                nInsertions++;\n                                pileupElement = new ExtendedEventPileupElement(read, eventStartOffset, eventLength, state.getEventBases());\n                            }\n                            if (read.getMappingQuality() == 0)\n                                nMQ0Reads++;\n\n                            indelPile.add(pileupElement);\n                        }\n\n                        // this read has no indel so add it to the pileup as a NOEVENT:\n                        //   a deletion that didn't start here (therefore, not an extended event)\n                        //   we add (mis)matches as no events.\n                        else if (op != CigarOperator.D || readInfo.includeReadsWithDeletionAtLoci()) {\n                            size++;\n                            indelPile.add(new ExtendedEventPileupElement((GATKSAMRecord) state.getRead(), readOffset));\n                            if (read.getMappingQuality() == 0)\n                                nMQ0Reads++;\n                        }\n                    }\n\n                    if (indelPile.size() != 0)\n                        fullExtendedEventPileup.put(sample, new ReadBackedExtendedEventPileupImpl(loc, indelPile, size, maxDeletionLength, nInsertions, nDeletions, nMQ0Reads));\n                }\n                hasExtendedEvents = false;                                            // we are done with extended events prior to current ref base\n                nextAlignmentContext = new AlignmentContext(loc, new ReadBackedExtendedEventPileupImpl(loc, fullExtendedEventPileup), hasBeenSampled);\n            }\n            else {                                                                    // this is a regular event pileup (not extended)\n                GenomeLoc location = getLocation();\n                Map<String, ReadBackedPileupImpl> fullPileup = new HashMap<String, ReadBackedPileupImpl>();\n                boolean hasBeenSampled = false;\n                for (final String sample : samples) {\n                    Iterator<SAMRecordState> iterator = readStates.iterator(sample);\n                    List<PileupElement> pile = new ArrayList<PileupElement>(readStates.size(sample));\n                    hasBeenSampled |= location.getStart() <= readStates.getDownsamplingExtent(sample);\n\n                    size = 0;                                                         // number of elements in this sample's pileup\n                    nDeletions = 0;                                                   // number of deletions in this sample's pileup\n                    nMQ0Reads = 0;                                                    // number of MQ0 reads in this sample's pileup (warning: current implementation includes N bases that are MQ0)\n\n                    while (iterator.hasNext()) {\n                        final SAMRecordState state = iterator.next();                 // state object with the read/offset information\n                        final GATKSAMRecord read = (GATKSAMRecord) state.getRead();   // the actual read\n                        final CigarOperator op = state.getCurrentCigarOperator();     // current cigar operator\n                        final CigarElement nextElement = state.peekForwardOnGenome();     // next cigar element\n                        final CigarOperator nextOp = nextElement.getOperator();\n                        final int readOffset = state.getReadOffset();                 // the base offset on this read\n\n                        int nextElementLength = nextElement.getLength();\n\n                        if (op == CigarOperator.N)                                    // N's are never added to any pileup\n                            continue;\n\n                        if (op == CigarOperator.D) {\n                            if (readInfo.includeReadsWithDeletionAtLoci()) {          // only add deletions to the pileup if we are authorized to do so\n                                pile.add(new PileupElement(read, readOffset, true, nextOp == CigarOperator.D, nextOp == CigarOperator.I, nextOp == CigarOperator.S || (state.getGenomeOffset() == 0 && read.getSoftStart() != read.getAlignmentStart()),\n                                        null,nextOp == CigarOperator.D? nextElementLength:-1));\n                                size++;\n                                nDeletions++;\n                                if (read.getMappingQuality() == 0)\n                                    nMQ0Reads++;\n                            }\n                        }\n                        else {\n                            if (!filterBaseInRead(read, location.getStart())) {\n                                String insertedBaseString = null;\n                                if (nextOp == CigarOperator.I) {\n                                    insertedBaseString = new String(Arrays.copyOfRange(read.getReadBases(), readOffset + 1, readOffset + 1 + nextElement.getLength()));\n                                }\n                                pile.add(new PileupElement(read, readOffset, false, nextOp == CigarOperator.D, nextOp == CigarOperator.I, nextOp == CigarOperator.S || (state.getGenomeOffset() == 0 && read.getSoftStart() != read.getAlignmentStart()),\n                                        insertedBaseString,nextElementLength));\n                                size++;\n                                if (read.getMappingQuality() == 0)\n                                    nMQ0Reads++;\n                            }\n                        }\n                    }\n\n                    if (pile.size() != 0)                                             // if this pileup added at least one base, add it to the full pileup\n                        fullPileup.put(sample, new ReadBackedPileupImpl(location, pile, size, nDeletions, nMQ0Reads));\n                }\n\n                updateReadStates();                                                   // critical - must be called after we get the current state offsets and location\n                if (!fullPileup.isEmpty())                                            // if we got reads with non-D/N over the current position, we are done\n                    nextAlignmentContext = new AlignmentContext(location, new ReadBackedPileupImpl(location, fullPileup), hasBeenSampled);\n            }\n        }\n    }","commit_id":"dea35943d17830496645dcab9cd59a063b258e34","url":"https://github.com/broadgsa/gatk"},{"original_method":"@NotNull\n  static StringBuilder generateStream(PsiExpression iteratedValue, List<Operation> intermediateOps) {\n    return generateStream(iteratedValue, intermediateOps, false);\n  }","id":93224,"modified_method":"@NotNull\n  static StringBuilder generateStream(PsiExpression iteratedValue, @Nullable Operation lastOperation) {\n    return generateStream(iteratedValue, lastOperation, false);\n  }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  static StringBuilder generateStream(PsiExpression iteratedValue, List<Operation> intermediateOps, boolean noStreamForEmpty) {\n    StringBuilder buffer = new StringBuilder();\n    final PsiType iteratedValueType = iteratedValue.getType();\n    if (iteratedValueType instanceof PsiArrayType) {\n      buffer.append(\"java.util.Arrays.stream(\").append(iteratedValue.getText()).append(\")\");\n    }\n    else {\n      buffer.append(getIteratedValueText(iteratedValue));\n      if (!(noStreamForEmpty && intermediateOps.isEmpty())) {\n        buffer.append(\".stream()\");\n      }\n    }\n    PsiElementFactory factory = JavaPsiFacade.getElementFactory(iteratedValue.getProject());\n    intermediateOps.stream().map(op -> op.createReplacement(factory)).forEach(buffer::append);\n    return buffer;\n  }","id":93225,"modified_method":"@NotNull\n  static StringBuilder generateStream(PsiExpression iteratedValue, @Nullable Operation lastOperation, boolean noStreamForEmpty) {\n    StringBuilder buffer = new StringBuilder();\n    final PsiType iteratedValueType = iteratedValue.getType();\n    if (iteratedValueType instanceof PsiArrayType) {\n      buffer.append(\"java.util.Arrays.stream(\").append(iteratedValue.getText()).append(\")\");\n    }\n    else {\n      buffer.append(getIteratedValueText(iteratedValue));\n      if (!noStreamForEmpty || lastOperation != null) {\n        buffer.append(\".stream()\");\n      }\n    }\n    PsiElementFactory factory = JavaPsiFacade.getElementFactory(iteratedValue.getProject());\n    List<String> replacements =\n      StreamEx.iterate(lastOperation, Objects::nonNull, Operation::getPreviousOp).map(op -> op.createReplacement(factory)).toList();\n    for(ListIterator<String> it = replacements.listIterator(replacements.size()); it.hasPrevious(); ) {\n      buffer.append(it.previous());\n    }\n    return buffer;\n  }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"abstract void migrate(@NotNull Project project,\n                        @NotNull ProblemDescriptor descriptor,\n                        @NotNull PsiForeachStatement foreachStatement,\n                        @NotNull PsiExpression iteratedValue,\n                        @NotNull PsiStatement body,\n                        @NotNull StreamApiMigrationInspection.TerminalBlock tb,\n                        @NotNull List<Operation> operations);","id":93226,"modified_method":"abstract void migrate(@NotNull Project project,\n                        @NotNull ProblemDescriptor descriptor,\n                        @NotNull PsiForeachStatement foreachStatement,\n                        @NotNull PsiExpression iteratedValue,\n                        @NotNull PsiStatement body,\n                        @NotNull TerminalBlock tb);","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    PsiElement element = descriptor.getPsiElement();\n    if (element instanceof PsiForeachStatement) {\n      PsiForeachStatement foreachStatement = (PsiForeachStatement)element;\n      PsiStatement body = foreachStatement.getBody();\n      final PsiExpression iteratedValue = foreachStatement.getIteratedValue();\n      if (body != null && iteratedValue != null) {\n        final PsiParameter parameter = foreachStatement.getIterationParameter();\n        StreamApiMigrationInspection.TerminalBlock tb = StreamApiMigrationInspection.TerminalBlock.from(parameter, body);\n        if (!FileModificationService.getInstance().preparePsiElementForWrite(foreachStatement)) return;\n        List<Operation> operations = tb.extractOperations();\n        migrate(project, descriptor, foreachStatement, iteratedValue, body, tb, operations);\n      }\n    }\n  }","id":93227,"modified_method":"@Override\n  public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    PsiElement element = descriptor.getPsiElement();\n    if (element instanceof PsiForeachStatement) {\n      PsiForeachStatement foreachStatement = (PsiForeachStatement)element;\n      PsiStatement body = foreachStatement.getBody();\n      final PsiExpression iteratedValue = foreachStatement.getIteratedValue();\n      if (body != null && iteratedValue != null) {\n        final PsiParameter parameter = foreachStatement.getIterationParameter();\n        TerminalBlock tb = TerminalBlock.from(parameter, body);\n        if (!FileModificationService.getInstance().preparePsiElementForWrite(foreachStatement)) return;\n        migrate(project, descriptor, foreachStatement, iteratedValue, body, tb);\n      }\n    }\n  }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb,\n               @NotNull List<Operation> operations) {\n    final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    final PsiType iteratedValueType = iteratedValue.getType();\n    final PsiMethodCallExpression methodCallExpression = tb.getSingleMethodCall();\n\n    if (methodCallExpression == null) return;\n\n    restoreComments(foreachStatement, body);\n    if (operations.isEmpty() && StreamApiMigrationInspection.isAddAllCall(tb)) {\n      final PsiExpression qualifierExpression = methodCallExpression.getMethodExpression().getQualifierExpression();\n      final String qualifierText = qualifierExpression != null ? qualifierExpression.getText() : \"\";\n      final String collectionText =\n        iteratedValueType instanceof PsiArrayType ? \"java.util.Arrays.asList(\" + iteratedValue.getText() + \")\" :\n        getIteratedValueText(iteratedValue);\n      final String callText = StringUtil.getQualifiedName(qualifierText, \"addAll(\" + collectionText + \");\");\n      PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(callText, foreachStatement));\n      simplifyAndFormat(project, result);\n      return;\n    }\n    PsiExpression itemToAdd = methodCallExpression.getArgumentList().getExpressions()[0];\n    PsiType addedType = getAddedElementType(methodCallExpression);\n    if (addedType == null) addedType = itemToAdd.getType();\n    operations.add(new StreamApiMigrationInspection.MapOp(itemToAdd, tb.getVariable(), addedType));\n    final StringBuilder builder = generateStream(iteratedValue, operations);\n\n    final PsiExpression qualifierExpression = methodCallExpression.getMethodExpression().getQualifierExpression();\n    final PsiLocalVariable variable = StreamApiMigrationInspection.extractCollectionVariable(qualifierExpression);\n    if (variable != null) {\n      InitializerUsageStatus status = StreamApiMigrationInspection.getInitializerUsageStatus(variable, foreachStatement);\n      if(status != InitializerUsageStatus.UNKNOWN) {\n        PsiExpression initializer = variable.getInitializer();\n        LOG.assertTrue(initializer != null);\n        PsiMethodCallExpression toArrayExpression =\n          StreamApiMigrationInspection.extractToArrayExpression(foreachStatement, methodCallExpression);\n        if(toArrayExpression != null) {\n          PsiType type = initializer.getType();\n          if(type instanceof PsiClassType) {\n            String replacement = StreamApiMigrationInspection.COLLECTION_TO_ARRAY.get(((PsiClassType)type).rawType().getCanonicalText());\n            if(replacement != null) {\n              builder.append(\".\").append(replacement);\n              PsiExpression[] args = toArrayExpression.getArgumentList().getExpressions();\n              if(args.length == 0) {\n                builder.append(\"()\");\n              } else {\n                if(args.length != 1 || !(args[0] instanceof PsiNewExpression)) return;\n                PsiNewExpression newArray = (PsiNewExpression)args[0];\n                PsiType arrayType = newArray.getType();\n                if(arrayType == null) return;\n                String name = arrayType.getCanonicalText();\n                builder.append('(').append(name).append(\"::new)\");\n              }\n              PsiElement result =\n                toArrayExpression.replace(elementFactory.createExpressionFromText(builder.toString(), toArrayExpression));\n              removeLoop(foreachStatement);\n              if(status != InitializerUsageStatus.AT_WANTED_PLACE) {\n                variable.delete();\n              }\n              simplifyAndFormat(project, result);\n              return;\n            }\n          }\n        }\n        String callText = builder.append(\".collect(java.util.stream.Collectors.\")\n          .append(createInitializerReplacementText(qualifierExpression.getType(), initializer))\n          .append(\")\").toString();\n        replaceInitializer(foreachStatement, variable, initializer, callText, status);\n        return;\n      }\n    }\n    final String qualifierText = qualifierExpression != null ? qualifierExpression.getText() + \".\" : \"\";\n\n    JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(project);\n    SuggestedNameInfo suggestedNameInfo =\n      codeStyleManager.suggestVariableName(VariableKind.LOCAL_VARIABLE, null, null, addedType, false);\n    if (suggestedNameInfo.names.length == 0) {\n      suggestedNameInfo = codeStyleManager.suggestVariableName(VariableKind.LOCAL_VARIABLE, \"item\", null, itemToAdd.getType(), false);\n    }\n    String varName = codeStyleManager.suggestUniqueVariableName(suggestedNameInfo, methodCallExpression, false).names[0];\n\n    PsiExpression forEachBody =\n      elementFactory.createExpressionFromText(qualifierText + \"add(\" + varName + \")\", qualifierExpression);\n    final String callText =\n      builder.append(\".forEach(\").append(varName).append(\"->\").append(forEachBody.getText()).append(\");\").toString();\n    PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(callText, foreachStatement));\n    simplifyAndFormat(project, result);\n  }","id":93228,"modified_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    final PsiType iteratedValueType = iteratedValue.getType();\n    final PsiMethodCallExpression methodCallExpression = tb.getSingleMethodCall();\n\n    if (methodCallExpression == null) return;\n\n    restoreComments(foreachStatement, body);\n    if (!tb.hasOperations() && StreamApiMigrationInspection.isAddAllCall(tb)) {\n      final PsiExpression qualifierExpression = methodCallExpression.getMethodExpression().getQualifierExpression();\n      final String qualifierText = qualifierExpression != null ? qualifierExpression.getText() : \"\";\n      final String collectionText =\n        iteratedValueType instanceof PsiArrayType ? \"java.util.Arrays.asList(\" + iteratedValue.getText() + \")\" :\n        getIteratedValueText(iteratedValue);\n      final String callText = StringUtil.getQualifiedName(qualifierText, \"addAll(\" + collectionText + \");\");\n      PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(callText, foreachStatement));\n      simplifyAndFormat(project, result);\n      return;\n    }\n    PsiExpression itemToAdd = methodCallExpression.getArgumentList().getExpressions()[0];\n    PsiType addedType = getAddedElementType(methodCallExpression);\n    if (addedType == null) addedType = itemToAdd.getType();\n    final StringBuilder builder =\n      generateStream(iteratedValue, new StreamApiMigrationInspection.MapOp(tb.getLastOperation(), itemToAdd, tb.getVariable(), addedType));\n\n    final PsiExpression qualifierExpression = methodCallExpression.getMethodExpression().getQualifierExpression();\n    final PsiLocalVariable variable = StreamApiMigrationInspection.extractCollectionVariable(qualifierExpression);\n    if (variable != null) {\n      InitializerUsageStatus status = StreamApiMigrationInspection.getInitializerUsageStatus(variable, foreachStatement);\n      if(status != InitializerUsageStatus.UNKNOWN) {\n        PsiExpression initializer = variable.getInitializer();\n        LOG.assertTrue(initializer != null);\n        PsiMethodCallExpression toArrayExpression =\n          StreamApiMigrationInspection.extractToArrayExpression(foreachStatement, methodCallExpression);\n        if(toArrayExpression != null) {\n          PsiType type = initializer.getType();\n          if(type instanceof PsiClassType) {\n            String replacement = StreamApiMigrationInspection.COLLECTION_TO_ARRAY.get(((PsiClassType)type).rawType().getCanonicalText());\n            if(replacement != null) {\n              builder.append(\".\").append(replacement);\n              PsiExpression[] args = toArrayExpression.getArgumentList().getExpressions();\n              if(args.length == 0) {\n                builder.append(\"()\");\n              } else {\n                if(args.length != 1 || !(args[0] instanceof PsiNewExpression)) return;\n                PsiNewExpression newArray = (PsiNewExpression)args[0];\n                PsiType arrayType = newArray.getType();\n                if(arrayType == null) return;\n                String name = arrayType.getCanonicalText();\n                builder.append('(').append(name).append(\"::new)\");\n              }\n              PsiElement result =\n                toArrayExpression.replace(elementFactory.createExpressionFromText(builder.toString(), toArrayExpression));\n              removeLoop(foreachStatement);\n              if(status != InitializerUsageStatus.AT_WANTED_PLACE) {\n                variable.delete();\n              }\n              simplifyAndFormat(project, result);\n              return;\n            }\n          }\n        }\n        String callText = builder.append(\".collect(java.util.stream.Collectors.\")\n          .append(createInitializerReplacementText(qualifierExpression.getType(), initializer))\n          .append(\")\").toString();\n        replaceInitializer(foreachStatement, variable, initializer, callText, status);\n        return;\n      }\n    }\n    final String qualifierText = qualifierExpression != null ? qualifierExpression.getText() + \".\" : \"\";\n\n    JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(project);\n    SuggestedNameInfo suggestedNameInfo =\n      codeStyleManager.suggestVariableName(VariableKind.LOCAL_VARIABLE, null, null, addedType, false);\n    if (suggestedNameInfo.names.length == 0) {\n      suggestedNameInfo = codeStyleManager.suggestVariableName(VariableKind.LOCAL_VARIABLE, \"item\", null, itemToAdd.getType(), false);\n    }\n    String varName = codeStyleManager.suggestUniqueVariableName(suggestedNameInfo, methodCallExpression, false).names[0];\n\n    PsiExpression forEachBody =\n      elementFactory.createExpressionFromText(qualifierText + \"add(\" + varName + \")\", qualifierExpression);\n    final String callText =\n      builder.append(\".forEach(\").append(varName).append(\"->\").append(forEachBody.getText()).append(\");\").toString();\n    PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(callText, foreachStatement));\n    simplifyAndFormat(project, result);\n  }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb,\n               @NotNull List<Operation> operations) {\n    PsiExpression operand = StreamApiMigrationInspection.extractIncrementedLValue(tb.getSingleExpression(PsiExpression.class));\n    if (!(operand instanceof PsiReferenceExpression)) return;\n    PsiElement element = ((PsiReferenceExpression)operand).resolve();\n    if (!(element instanceof PsiLocalVariable)) return;\n    PsiLocalVariable var = (PsiLocalVariable)element;\n    final StringBuilder builder = generateStream(iteratedValue, operations);\n    builder.append(\".count()\");\n    replaceWithNumericAddition(project, foreachStatement, var, builder, PsiType.LONG);\n  }","id":93229,"modified_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    PsiExpression operand = StreamApiMigrationInspection.extractIncrementedLValue(tb.getSingleExpression(PsiExpression.class));\n    if (!(operand instanceof PsiReferenceExpression)) return;\n    PsiElement element = ((PsiReferenceExpression)operand).resolve();\n    if (!(element instanceof PsiLocalVariable)) return;\n    PsiLocalVariable var = (PsiLocalVariable)element;\n    final StringBuilder builder = generateStream(iteratedValue, tb.getLastOperation());\n    builder.append(\".count()\");\n    replaceWithNumericAddition(project, foreachStatement, var, builder, PsiType.LONG);\n  }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb,\n               @NotNull List<Operation> operations) {\n    PsiStatement statement = tb.getSingleStatement();\n    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    String stream = generateStream(iteratedValue, operations).append(\".findFirst()\").toString();\n    if (statement instanceof PsiReturnStatement) {\n      PsiReturnStatement returnStatement = (PsiReturnStatement)statement;\n      PsiExpression value = returnStatement.getReturnValue();\n      if (value == null) return;\n      PsiReturnStatement nextReturnStatement = StreamApiMigrationInspection.getNextReturnStatement(foreachStatement);\n      if (nextReturnStatement == null) return;\n      PsiExpression orElseExpression = nextReturnStatement.getReturnValue();\n      if (!ExpressionUtils.isSimpleExpression(orElseExpression)) return;\n      stream = generateOptionalUnwrap(stream, tb, value, orElseExpression, null);\n      restoreComments(foreachStatement, body);\n      boolean siblings = nextReturnStatement.getParent() == foreachStatement.getParent();\n      PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(\"return \" + stream + \";\", foreachStatement));\n      if (siblings) {\n        nextReturnStatement.delete();\n      }\n      simplifyAndFormat(project, result);\n    }\n    else {\n      PsiStatement[] statements = tb.getStatements();\n      if (statements.length != 2) return;\n      PsiAssignmentExpression assignment = ExpressionUtils.getAssignment(statements[0]);\n      if (assignment == null) return;\n      PsiExpression lValue = assignment.getLExpression();\n      if (!(lValue instanceof PsiReferenceExpression)) return;\n      PsiElement element = ((PsiReferenceExpression)lValue).resolve();\n      if (!(element instanceof PsiVariable)) return;\n      PsiVariable var = (PsiVariable)element;\n      PsiExpression value = assignment.getRExpression();\n      if (value == null) return;\n      restoreComments(foreachStatement, body);\n      InitializerUsageStatus status = StreamApiMigrationInspection.getInitializerUsageStatus(var, foreachStatement);\n      if (status != InitializerUsageStatus.UNKNOWN) {\n        PsiExpression initializer = var.getInitializer();\n        if (initializer != null) {\n          String replacementText = generateOptionalUnwrap(stream, tb, value, initializer, var.getType());\n          replaceInitializer(foreachStatement, var, initializer, replacementText, status);\n          return;\n        }\n      }\n      PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(\n        var.getName() + \" = \" + generateOptionalUnwrap(stream, tb, value, lValue, var.getType()) + \";\", foreachStatement));\n      simplifyAndFormat(project, result);\n    }\n  }","id":93230,"modified_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    PsiStatement statement = tb.getSingleStatement();\n    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    String stream = generateStream(iteratedValue, tb.getLastOperation()).append(\".findFirst()\").toString();\n    if (statement instanceof PsiReturnStatement) {\n      PsiReturnStatement returnStatement = (PsiReturnStatement)statement;\n      PsiExpression value = returnStatement.getReturnValue();\n      if (value == null) return;\n      PsiReturnStatement nextReturnStatement = StreamApiMigrationInspection.getNextReturnStatement(foreachStatement);\n      if (nextReturnStatement == null) return;\n      PsiExpression orElseExpression = nextReturnStatement.getReturnValue();\n      if (!ExpressionUtils.isSimpleExpression(orElseExpression)) return;\n      stream = generateOptionalUnwrap(stream, tb, value, orElseExpression, null);\n      restoreComments(foreachStatement, body);\n      boolean siblings = nextReturnStatement.getParent() == foreachStatement.getParent();\n      PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(\"return \" + stream + \";\", foreachStatement));\n      if (siblings) {\n        nextReturnStatement.delete();\n      }\n      simplifyAndFormat(project, result);\n    }\n    else {\n      PsiStatement[] statements = tb.getStatements();\n      if (statements.length != 2) return;\n      PsiAssignmentExpression assignment = ExpressionUtils.getAssignment(statements[0]);\n      if (assignment == null) return;\n      PsiExpression lValue = assignment.getLExpression();\n      if (!(lValue instanceof PsiReferenceExpression)) return;\n      PsiElement element = ((PsiReferenceExpression)lValue).resolve();\n      if (!(element instanceof PsiVariable)) return;\n      PsiVariable var = (PsiVariable)element;\n      PsiExpression value = assignment.getRExpression();\n      if (value == null) return;\n      restoreComments(foreachStatement, body);\n      InitializerUsageStatus status = StreamApiMigrationInspection.getInitializerUsageStatus(var, foreachStatement);\n      if (status != InitializerUsageStatus.UNKNOWN) {\n        PsiExpression initializer = var.getInitializer();\n        if (initializer != null) {\n          String replacementText = generateOptionalUnwrap(stream, tb, value, initializer, var.getType());\n          replaceInitializer(foreachStatement, var, initializer, replacementText, status);\n          return;\n        }\n      }\n      PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(\n        var.getName() + \" = \" + generateOptionalUnwrap(stream, tb, value, lValue, var.getType()) + \";\", foreachStatement));\n      simplifyAndFormat(project, result);\n    }\n  }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb,\n               @NotNull List<Operation> operations) {\n    restoreComments(foreachStatement, body);\n\n    final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n\n    StringBuilder buffer = generateStream(iteratedValue, operations, true);\n    PsiElement block = tb.convertToElement(elementFactory);\n\n    buffer.append(\".\").append(myForEachMethodName).append(\"(\");\n\n    final String functionalExpressionText = tb.getVariable().getName() + \" -> \" + wrapInBlock(block);\n    PsiExpressionStatement callStatement = (PsiExpressionStatement)elementFactory\n      .createStatementFromText(buffer.toString() + functionalExpressionText + \");\", foreachStatement);\n    callStatement = (PsiExpressionStatement)foreachStatement.replace(callStatement);\n\n    final PsiExpressionList argumentList = ((PsiCallExpression)callStatement.getExpression()).getArgumentList();\n    LOG.assertTrue(argumentList != null, callStatement.getText());\n    final PsiExpression[] expressions = argumentList.getExpressions();\n    LOG.assertTrue(expressions.length == 1);\n\n    if (expressions[0] instanceof PsiFunctionalExpression &&\n        ((PsiFunctionalExpression)expressions[0]).getFunctionalInterfaceType() == null) {\n      callStatement =\n        (PsiExpressionStatement)callStatement.replace(elementFactory.createStatementFromText(\n          buffer.toString() + \"(\" + tb.getVariable().getText() + \") -> \" + wrapInBlock(block) + \");\", callStatement));\n    }\n\n    simplifyAndFormat(project, callStatement);\n  }","id":93231,"modified_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    restoreComments(foreachStatement, body);\n\n    final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n\n    StringBuilder buffer = generateStream(iteratedValue, tb.getLastOperation(), true);\n    PsiElement block = tb.convertToElement(elementFactory);\n\n    buffer.append(\".\").append(myForEachMethodName).append(\"(\");\n\n    final String functionalExpressionText = tb.getVariable().getName() + \" -> \" + wrapInBlock(block);\n    PsiExpressionStatement callStatement = (PsiExpressionStatement)elementFactory\n      .createStatementFromText(buffer.toString() + functionalExpressionText + \");\", foreachStatement);\n    callStatement = (PsiExpressionStatement)foreachStatement.replace(callStatement);\n\n    final PsiExpressionList argumentList = ((PsiCallExpression)callStatement.getExpression()).getArgumentList();\n    LOG.assertTrue(argumentList != null, callStatement.getText());\n    final PsiExpression[] expressions = argumentList.getExpressions();\n    LOG.assertTrue(expressions.length == 1);\n\n    if (expressions[0] instanceof PsiFunctionalExpression &&\n        ((PsiFunctionalExpression)expressions[0]).getFunctionalInterfaceType() == null) {\n      callStatement =\n        (PsiExpressionStatement)callStatement.replace(elementFactory.createStatementFromText(\n          buffer.toString() + \"(\" + tb.getVariable().getText() + \") -> \" + wrapInBlock(block) + \");\", callStatement));\n    }\n\n    simplifyAndFormat(project, callStatement);\n  }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb,\n               @NotNull List<Operation> operations) {\n    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    if(tb.getSingleStatement() instanceof PsiReturnStatement) {\n      PsiReturnStatement returnStatement = (PsiReturnStatement)tb.getSingleStatement();\n      PsiExpression value = returnStatement.getReturnValue();\n      if (ExpressionUtils.isLiteral(value, Boolean.TRUE) || ExpressionUtils.isLiteral(value, Boolean.FALSE)) {\n        boolean foundResult = (boolean)((PsiLiteralExpression)value).getValue();\n        PsiReturnStatement nextReturnStatement = StreamApiMigrationInspection.getNextReturnStatement(foreachStatement);\n        if (nextReturnStatement != null && ExpressionUtils.isLiteral(nextReturnStatement.getReturnValue(), !foundResult)) {\n          String methodName = foundResult ? \"anyMatch\" : \"noneMatch\";\n          String streamText = generateStream(iteratedValue, operations).toString();\n          streamText = addTerminalOperation(streamText, methodName, foreachStatement, tb);\n          restoreComments(foreachStatement, body);\n          boolean siblings = nextReturnStatement.getParent() == foreachStatement.getParent();\n          PsiElement result =\n            foreachStatement.replace(elementFactory.createStatementFromText(\"return \" + streamText + \";\", foreachStatement));\n          if (siblings) {\n            nextReturnStatement.delete();\n          }\n          simplifyAndFormat(project, result);\n          return;\n        }\n      }\n    }\n    PsiStatement[] statements = tb.getStatements();\n    if(statements.length == 1 || (statements.length == 2 && statements[1] instanceof PsiBreakStatement)) {\n      restoreComments(foreachStatement, body);\n      String streamText = generateStream(iteratedValue, operations).toString();\n      streamText = addTerminalOperation(streamText, \"anyMatch\", foreachStatement, tb);\n      PsiStatement statement = statements[0];\n      PsiAssignmentExpression assignment = ExpressionUtils.getAssignment(statement);\n      if(assignment != null) {\n        PsiExpression lValue = assignment.getLExpression();\n        PsiExpression rValue = assignment.getRExpression();\n        if (!(lValue instanceof PsiReferenceExpression) || rValue == null) return;\n        PsiElement maybeVar = ((PsiReferenceExpression)lValue).resolve();\n        if(maybeVar instanceof PsiVariable) {\n          // Simplify single assignments like this:\n          // boolean flag = false;\n          // for(....) if(...) {flag = true; break;}\n          PsiVariable var = (PsiVariable)maybeVar;\n          PsiExpression initializer = var.getInitializer();\n          InitializerUsageStatus status = StreamApiMigrationInspection.getInitializerUsageStatus(var, foreachStatement);\n          if(initializer != null && status != InitializerUsageStatus.UNKNOWN) {\n            String replacement;\n            if(ExpressionUtils.isLiteral(initializer, Boolean.FALSE) &&\n               ExpressionUtils.isLiteral(rValue, Boolean.TRUE)) {\n              replacement = streamText;\n            } else if(ExpressionUtils.isLiteral(initializer, Boolean.TRUE) &&\n                      ExpressionUtils.isLiteral(rValue, Boolean.FALSE)) {\n              replacement = \"!\"+streamText;\n            } else {\n              replacement = streamText + \"?\" + rValue.getText() + \":\" + initializer.getText();\n            }\n            replaceInitializer(foreachStatement, var, initializer, replacement, status);\n            return;\n          }\n        }\n      }\n      String replacement = \"if(\" + streamText + \"){\" + statement.getText() + \"}\";\n      PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(replacement, foreachStatement));\n      simplifyAndFormat(project, result);\n    }\n  }","id":93232,"modified_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    if(tb.getSingleStatement() instanceof PsiReturnStatement) {\n      PsiReturnStatement returnStatement = (PsiReturnStatement)tb.getSingleStatement();\n      PsiExpression value = returnStatement.getReturnValue();\n      if (ExpressionUtils.isLiteral(value, Boolean.TRUE) || ExpressionUtils.isLiteral(value, Boolean.FALSE)) {\n        boolean foundResult = (boolean)((PsiLiteralExpression)value).getValue();\n        PsiReturnStatement nextReturnStatement = StreamApiMigrationInspection.getNextReturnStatement(foreachStatement);\n        if (nextReturnStatement != null && ExpressionUtils.isLiteral(nextReturnStatement.getReturnValue(), !foundResult)) {\n          String methodName = foundResult ? \"anyMatch\" : \"noneMatch\";\n          String streamText = generateStream(iteratedValue, tb.getLastOperation()).toString();\n          streamText = addTerminalOperation(streamText, methodName, foreachStatement, tb);\n          restoreComments(foreachStatement, body);\n          boolean siblings = nextReturnStatement.getParent() == foreachStatement.getParent();\n          PsiElement result =\n            foreachStatement.replace(elementFactory.createStatementFromText(\"return \" + streamText + \";\", foreachStatement));\n          if (siblings) {\n            nextReturnStatement.delete();\n          }\n          simplifyAndFormat(project, result);\n          return;\n        }\n      }\n    }\n    PsiStatement[] statements = tb.getStatements();\n    if(statements.length == 1 || (statements.length == 2 && statements[1] instanceof PsiBreakStatement)) {\n      restoreComments(foreachStatement, body);\n      String streamText = generateStream(iteratedValue, tb.getLastOperation()).toString();\n      streamText = addTerminalOperation(streamText, \"anyMatch\", foreachStatement, tb);\n      PsiStatement statement = statements[0];\n      PsiAssignmentExpression assignment = ExpressionUtils.getAssignment(statement);\n      if(assignment != null) {\n        PsiExpression lValue = assignment.getLExpression();\n        PsiExpression rValue = assignment.getRExpression();\n        if (!(lValue instanceof PsiReferenceExpression) || rValue == null) return;\n        PsiElement maybeVar = ((PsiReferenceExpression)lValue).resolve();\n        if(maybeVar instanceof PsiVariable) {\n          // Simplify single assignments like this:\n          // boolean flag = false;\n          // for(....) if(...) {flag = true; break;}\n          PsiVariable var = (PsiVariable)maybeVar;\n          PsiExpression initializer = var.getInitializer();\n          InitializerUsageStatus status = StreamApiMigrationInspection.getInitializerUsageStatus(var, foreachStatement);\n          if(initializer != null && status != InitializerUsageStatus.UNKNOWN) {\n            String replacement;\n            if(ExpressionUtils.isLiteral(initializer, Boolean.FALSE) &&\n               ExpressionUtils.isLiteral(rValue, Boolean.TRUE)) {\n              replacement = streamText;\n            } else if(ExpressionUtils.isLiteral(initializer, Boolean.TRUE) &&\n                      ExpressionUtils.isLiteral(rValue, Boolean.FALSE)) {\n              replacement = \"!\"+streamText;\n            } else {\n              replacement = streamText + \"?\" + rValue.getText() + \":\" + initializer.getText();\n            }\n            replaceInitializer(foreachStatement, var, initializer, replacement, status);\n            return;\n          }\n        }\n      }\n      String replacement = \"if(\" + streamText + \"){\" + statement.getText() + \"}\";\n      PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(replacement, foreachStatement));\n      simplifyAndFormat(project, result);\n    }\n  }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb,\n               @NotNull List<Operation> operations) {\n    PsiAssignmentExpression assignment = tb.getSingleExpression(PsiAssignmentExpression.class);\n    if (assignment == null) return;\n    PsiVariable var = StreamApiMigrationInspection.extractAccumulator(assignment);\n    if (var == null) return;\n\n    PsiExpression addend = StreamApiMigrationInspection.extractAddend(assignment);\n    if (addend == null) return;\n    PsiType type = var.getType();\n    if (!(type instanceof PsiPrimitiveType) || type.equals(PsiType.FLOAT)) return;\n    if (!type.equals(PsiType.DOUBLE) && !type.equals(PsiType.LONG)) {\n      type = PsiType.INT;\n    }\n    operations.add(new StreamApiMigrationInspection.MapOp(addend, tb.getVariable(), type));\n    final StringBuilder builder = generateStream(iteratedValue, operations);\n    builder.append(\".sum()\");\n    replaceWithNumericAddition(project, foreachStatement, var, builder, type);\n  }","id":93233,"modified_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    PsiAssignmentExpression assignment = tb.getSingleExpression(PsiAssignmentExpression.class);\n    if (assignment == null) return;\n    PsiVariable var = StreamApiMigrationInspection.extractAccumulator(assignment);\n    if (var == null) return;\n\n    PsiExpression addend = StreamApiMigrationInspection.extractAddend(assignment);\n    if (addend == null) return;\n    PsiType type = var.getType();\n    if (!(type instanceof PsiPrimitiveType) || type.equals(PsiType.FLOAT)) return;\n    if (!type.equals(PsiType.DOUBLE) && !type.equals(PsiType.LONG)) {\n      type = PsiType.INT;\n    }\n    final StringBuilder builder =\n      generateStream(iteratedValue, new StreamApiMigrationInspection.MapOp(tb.getLastOperation(), addend, tb.getVariable(), type));\n    builder.append(\".sum()\");\n    replaceWithNumericAddition(project, foreachStatement, var, builder, type);\n  }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiVariable getAccumulatedVariable(TerminalBlock tb,\n                                                         List<Operation> operations,\n                                                         List<PsiVariable> variables) {\n    // have only one non-final variable\n    if(variables.size() != 1) return null;\n\n    PsiAssignmentExpression assignment = tb.getSingleExpression(PsiAssignmentExpression.class);\n    if(assignment == null) return null;\n    PsiVariable var = extractAccumulator(assignment);\n\n    // the referred variable is the same as non-final variable\n    if(var == null || !variables.contains(var)) return null;\n    if (!(var.getType() instanceof PsiPrimitiveType) || var.getType().equalsToText(\"float\")) return null;\n\n    // the referred variable is not used in intermediate operations\n    for(Operation operation : operations) {\n      if(ReferencesSearch.search(var, new LocalSearchScope(operation.getExpression())).findFirst() != null) return null;\n    }\n    PsiExpression addend = extractAddend(assignment);\n    LOG.assertTrue(addend != null);\n    if(ReferencesSearch.search(var, new LocalSearchScope(addend)).findFirst() != null) return null;\n    return var;\n  }","id":93234,"modified_method":"@Nullable\n  private static PsiVariable getAccumulatedVariable(TerminalBlock tb, List<PsiVariable> variables) {\n    // have only one non-final variable\n    if(variables.size() != 1) return null;\n\n    PsiAssignmentExpression assignment = tb.getSingleExpression(PsiAssignmentExpression.class);\n    if(assignment == null) return null;\n    PsiVariable var = extractAccumulator(assignment);\n\n    // the referred variable is the same as non-final variable\n    if(var == null || !variables.contains(var)) return null;\n    if (!(var.getType() instanceof PsiPrimitiveType) || var.getType().equalsToText(\"float\")) return null;\n\n    // the referred variable is not used in intermediate operations\n    if(isReferencedInOperations(var, tb)) return null;\n    PsiExpression addend = extractAddend(assignment);\n    LOG.assertTrue(addend != null);\n    if(ReferencesSearch.search(var, new LocalSearchScope(addend)).findFirst() != null) return null;\n    return var;\n  }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiLocalVariable getIncrementedVariable(TerminalBlock tb,\n                                                         List<Operation> operations,\n                                                         List<PsiVariable> variables) {\n    // have only one non-final variable\n    if(variables.size() != 1) return null;\n\n    // have single expression which is either ++x or x++ or x+=1 or x=x+1\n    PsiExpression operand = extractIncrementedLValue(tb.getSingleExpression(PsiExpression.class));\n    if(!(operand instanceof PsiReferenceExpression)) return null;\n    PsiElement element = ((PsiReferenceExpression)operand).resolve();\n\n    // the referred variable is the same as non-final variable and not used in intermediate operations\n    if(!(element instanceof PsiLocalVariable) || !variables.contains(element) || isReferencedInOperations(element, operations)) return null;\n\n    return (PsiLocalVariable)element;\n  }","id":93235,"modified_method":"@Nullable\n  private static PsiLocalVariable getIncrementedVariable(TerminalBlock tb, List<PsiVariable> variables) {\n    // have only one non-final variable\n    if(variables.size() != 1) return null;\n\n    // have single expression which is either ++x or x++ or x+=1 or x=x+1\n    PsiExpression operand = extractIncrementedLValue(tb.getSingleExpression(PsiExpression.class));\n    if(!(operand instanceof PsiReferenceExpression)) return null;\n    PsiElement element = ((PsiReferenceExpression)operand).resolve();\n\n    // the referred variable is the same as non-final variable and not used in intermediate operations\n    if(!(element instanceof PsiLocalVariable) || !variables.contains(element) || isReferencedInOperations(element, tb)) return null;\n\n    return (PsiLocalVariable)element;\n  }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"ArrayFlatMapOp(PsiExpression expression, PsiVariable variable, PsiLoopStatement loop) {\n      super(expression, variable, loop);\n    }","id":93236,"modified_method":"ArrayFlatMapOp(@Nullable Operation previousOp, PsiExpression expression, PsiVariable variable, PsiLoopStatement loop) {\n      super(previousOp, expression, variable, loop);\n    }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    List<Operation> extractOperations() {\n      List<Operation> result = new ArrayList<>();\n      while(true) {\n        Operation op = extractOperation();\n        if(op == null) return result;\n        result.add(op);\n      }\n    }","id":93237,"modified_method":"/**\n     * Extract all possible intermediate operations\n     * @return the terminal block with all possible terminal operations extracted (may return this if no operations could be extracted)\n     */\n    @NotNull\n    TerminalBlock extractOperations() {\n      return StreamEx.iterate(this, Objects::nonNull, TerminalBlock::extractOperation).reduce((a, b) -> b).orElse(this);\n    }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static boolean isReferencedInOperations(PsiElement element, List<Operation> operations) {\n    return ReferencesSearch\n             .search(element, new LocalSearchScope(operations.stream().map(Operation::getExpression).toArray(PsiElement[]::new)))\n             .findFirst() != null;\n  }","id":93238,"modified_method":"static boolean isReferencedInOperations(PsiElement element, TerminalBlock tb) {\n    return ReferencesSearch.search(element, new LocalSearchScope(tb.intermediateExpressions().toArray(PsiElement[]::new)))\n             .findFirst() != null;\n  }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Contract(\"_, _ -> !null\")\n    static TerminalBlock from(PsiVariable variable, PsiStatement statement) {\n      return new TerminalBlock(variable, new PsiStatement[] {statement});\n    }","id":93239,"modified_method":"@NotNull\n    public static TerminalBlock from(PsiVariable variable, PsiStatement statement) {\n      return new TerminalBlock(null, variable, statement).extractOperations();\n    }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isCollectCall(TerminalBlock tb, final List<Operation> operations) {\n    final PsiMethodCallExpression methodCallExpression = tb.getSingleMethodCall();\n    if (methodCallExpression != null) {\n      final PsiReferenceExpression methodExpression = methodCallExpression.getMethodExpression();\n      final PsiExpression qualifierExpression = methodExpression.getQualifierExpression();\n      PsiClass qualifierClass = null;\n      if (qualifierExpression instanceof PsiReferenceExpression) {\n        if (ReferencesSearch.search(tb.getVariable(), new LocalSearchScope(qualifierExpression)).findFirst() != null) {\n          return false;\n        }\n        final PsiElement resolve = ((PsiReferenceExpression)qualifierExpression).resolve();\n        if (resolve instanceof PsiVariable) {\n          if (ReferencesSearch.search(resolve, new LocalSearchScope(methodCallExpression.getArgumentList())).findFirst() != null) {\n            return false;\n          }\n        }\n        qualifierClass = PsiUtil.resolveClassInType(qualifierExpression.getType());\n      }\n      else if (qualifierExpression == null) {\n        final PsiClass enclosingClass = PsiTreeUtil.getParentOfType(methodCallExpression, PsiClass.class);\n        if (PsiUtil.getEnclosingStaticElement(methodCallExpression, enclosingClass) == null) {\n          qualifierClass = enclosingClass;\n        }\n      }\n\n      if (qualifierClass != null && \n          InheritanceUtil.isInheritor(qualifierClass, false, CommonClassNames.JAVA_UTIL_COLLECTION)) {\n\n        for(Operation op : operations) {\n          final PsiExpression expression = op.getExpression();\n          if (expression != null && isExpressionDependsOnUpdatedCollections(expression, qualifierExpression)) return false;\n        }\n\n        final PsiElement resolve = methodExpression.resolve();\n        if (resolve instanceof PsiMethod &&\n            \"add\".equals(((PsiMethod)resolve).getName()) &&\n            ((PsiMethod)resolve).getParameterList().getParametersCount() == 1) {\n          final PsiExpression[] args = methodCallExpression.getArgumentList().getExpressions();\n          if (args.length == 1) {\n            if (args[0] instanceof PsiCallExpression) {\n              final PsiMethod method = ((PsiCallExpression)args[0]).resolveMethod();\n              return method != null && !method.hasTypeParameters() && !isThrowsCompatible(method);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }","id":93240,"modified_method":"private static boolean isCollectCall(TerminalBlock tb) {\n    final PsiMethodCallExpression methodCallExpression = tb.getSingleMethodCall();\n    if (methodCallExpression != null) {\n      final PsiReferenceExpression methodExpression = methodCallExpression.getMethodExpression();\n      final PsiExpression qualifierExpression = methodExpression.getQualifierExpression();\n      PsiClass qualifierClass = null;\n      if (qualifierExpression instanceof PsiReferenceExpression) {\n        if (ReferencesSearch.search(tb.getVariable(), new LocalSearchScope(qualifierExpression)).findFirst() != null) {\n          return false;\n        }\n        final PsiElement resolve = ((PsiReferenceExpression)qualifierExpression).resolve();\n        if (resolve instanceof PsiVariable) {\n          if (ReferencesSearch.search(resolve, new LocalSearchScope(methodCallExpression.getArgumentList())).findFirst() != null) {\n            return false;\n          }\n        }\n        qualifierClass = PsiUtil.resolveClassInType(qualifierExpression.getType());\n      }\n      else if (qualifierExpression == null) {\n        final PsiClass enclosingClass = PsiTreeUtil.getParentOfType(methodCallExpression, PsiClass.class);\n        if (PsiUtil.getEnclosingStaticElement(methodCallExpression, enclosingClass) == null) {\n          qualifierClass = enclosingClass;\n        }\n      }\n\n      if (qualifierClass != null && \n          InheritanceUtil.isInheritor(qualifierClass, false, CommonClassNames.JAVA_UTIL_COLLECTION)) {\n\n        if (tb.intermediateExpressions().anyMatch(expression -> isExpressionDependsOnUpdatedCollections(expression, qualifierExpression))) {\n          return false;\n        }\n\n        final PsiElement resolve = methodExpression.resolve();\n        if (resolve instanceof PsiMethod &&\n            \"add\".equals(((PsiMethod)resolve).getName()) &&\n            ((PsiMethod)resolve).getParameterList().getParametersCount() == 1) {\n          final PsiExpression[] args = methodCallExpression.getArgumentList().getExpressions();\n          if (args.length == 1) {\n            if (args[0] instanceof PsiCallExpression) {\n              final PsiMethod method = ((PsiCallExpression)args[0]).resolveMethod();\n              return method != null && !method.hasTypeParameters() && !isThrowsCompatible(method);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"MapOp(PsiExpression expression, PsiVariable variable, @Nullable PsiType targetType) {\n      super(expression, variable);\n      myType = targetType;\n    }","id":93241,"modified_method":"MapOp(@Nullable Operation previousOp, PsiExpression expression, PsiVariable variable, @Nullable PsiType targetType) {\n      super(previousOp, expression, variable);\n      myType = targetType;\n    }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"FlatMapOp(PsiExpression expression, PsiVariable variable, PsiLoopStatement loop) {\n      super(expression, variable);\n      myLoop = loop;\n    }","id":93242,"modified_method":"FlatMapOp(@Nullable Operation previousOp, PsiExpression expression, PsiVariable variable, PsiLoopStatement loop) {\n      super(previousOp, expression, variable);\n      myLoop = loop;\n    }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"FilterOp(PsiExpression condition, PsiVariable variable, boolean negated) {\n      super(condition, variable);\n      myNegated = negated;\n    }","id":93243,"modified_method":"FilterOp(@Nullable Operation previousOp, PsiExpression condition, PsiVariable variable, boolean negated) {\n      super(previousOp, condition, variable);\n      myNegated = negated;\n    }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    private FilterOp extractFilter() {\n      if(getSingleStatement() instanceof PsiIfStatement) {\n        PsiIfStatement ifStatement = (PsiIfStatement)getSingleStatement();\n        if(ifStatement.getElseBranch() == null && ifStatement.getCondition() != null) {\n          replaceWith(ifStatement.getThenBranch());\n          return new FilterOp(ifStatement.getCondition(), myVariable, false);\n        }\n      }\n      if(myStatements.length >= 1) {\n        PsiStatement first = myStatements[0];\n        // extract filter with negation\n        if(first instanceof PsiIfStatement) {\n          PsiIfStatement ifStatement = (PsiIfStatement)first;\n          if(ifStatement.getCondition() == null) return null;\n          PsiStatement branch = ifStatement.getThenBranch();\n          if(branch instanceof PsiBlockStatement) {\n            PsiStatement[] statements = ((PsiBlockStatement)branch).getCodeBlock().getStatements();\n            if(statements.length == 1)\n              branch = statements[0];\n          }\n          if(!(branch instanceof PsiContinueStatement) || ((PsiContinueStatement)branch).getLabelIdentifier() != null) return null;\n          if(ifStatement.getElseBranch() != null) {\n            myStatements[0] = ifStatement.getElseBranch();\n          } else {\n            myStatements = Arrays.copyOfRange(myStatements, 1, myStatements.length);\n          }\n          flatten();\n          return new FilterOp(ifStatement.getCondition(), myVariable, true);\n        }\n      }\n      return null;\n    }","id":93244,"modified_method":"@Nullable\n    private TerminalBlock extractFilter() {\n      if(getSingleStatement() instanceof PsiIfStatement) {\n        PsiIfStatement ifStatement = (PsiIfStatement)getSingleStatement();\n        if(ifStatement.getElseBranch() == null && ifStatement.getCondition() != null) {\n          return new TerminalBlock(new FilterOp(myPreviousOp, ifStatement.getCondition(), myVariable, false),\n                                   myVariable, ifStatement.getThenBranch());\n        }\n      }\n      if(myStatements.length >= 1) {\n        PsiStatement first = myStatements[0];\n        // extract filter with negation\n        if(first instanceof PsiIfStatement) {\n          PsiIfStatement ifStatement = (PsiIfStatement)first;\n          if(ifStatement.getCondition() == null) return null;\n          PsiStatement branch = ifStatement.getThenBranch();\n          if(branch instanceof PsiBlockStatement) {\n            PsiStatement[] statements = ((PsiBlockStatement)branch).getCodeBlock().getStatements();\n            if(statements.length == 1)\n              branch = statements[0];\n          }\n          if(!(branch instanceof PsiContinueStatement) || ((PsiContinueStatement)branch).getLabelIdentifier() != null) return null;\n          PsiStatement[] statements;\n          if(ifStatement.getElseBranch() != null) {\n            statements = myStatements.clone();\n            statements[0] = ifStatement.getElseBranch();\n          } else {\n            statements = Arrays.copyOfRange(myStatements, 1, myStatements.length);\n          }\n          return new TerminalBlock(new FilterOp(myPreviousOp, ifStatement.getCondition(), myVariable, true),\n                                   myVariable, statements);\n        }\n      }\n      return null;\n    }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitForeachStatement(PsiForeachStatement statement) {\n      super.visitForeachStatement(statement);\n      final PsiExpression iteratedValue = statement.getIteratedValue();\n      final PsiStatement body = statement.getBody();\n      if (iteratedValue == null || body == null) return;\n\n      final PsiType iteratedValueType = iteratedValue.getType();\n      final PsiClass iteratorClass = PsiUtil.resolveClassInClassTypeOnly(iteratedValueType);\n      PsiClass collectionClass = null;\n      final boolean isArray;\n      if(iteratedValueType instanceof PsiArrayType) {\n        if(!isSupported(((PsiArrayType)iteratedValueType).getComponentType())) return;\n        isArray = true;\n      } else {\n        collectionClass = JavaPsiFacade.getInstance(body.getProject()).findClass(CommonClassNames.JAVA_UTIL_COLLECTION, statement.getResolveScope());\n        if (collectionClass != null && InheritanceUtil.isInheritorOrSelf(iteratorClass, collectionClass, true)) {\n          isArray = false;\n        } else return;\n      }\n      if (!ExceptionUtil.getThrownCheckedExceptions(body).isEmpty()) return;\n\n      TerminalBlock tb = TerminalBlock.from(statement.getIterationParameter(), body);\n      List<Operation> operations = tb.extractOperations();\n      if(tb.isEmpty()) return;\n\n      final ControlFlow controlFlow;\n      try {\n        controlFlow = ControlFlowFactory.getInstance(myHolder.getProject())\n          .getControlFlow(body, LocalsOrMyInstanceFieldsControlFlowPolicy.getInstance());\n      }\n      catch (AnalysisCanceledException ignored) {\n        return;\n      }\n      final Collection<PsiStatement> exitPoints = ControlFlowUtil\n        .findExitPointsAndStatements(controlFlow, tb.getStartOffset(controlFlow), tb.getEndOffset(controlFlow),\n                                     new IntArrayList(), PsiContinueStatement.class,\n                                     PsiBreakStatement.class, PsiReturnStatement.class, PsiThrowStatement.class);\n      int startOffset = controlFlow.getStartOffset(body);\n      int endOffset = controlFlow.getEndOffset(body);\n      final List<PsiVariable> nonFinalVariables = StreamEx.of(ControlFlowUtil.getUsedVariables(controlFlow, startOffset, endOffset))\n        .remove(variable -> HighlightControlFlowUtil.isEffectivelyFinal(variable, body, null)).toList();\n\n      if (exitPoints.isEmpty()) {\n        if(getIncrementedVariable(tb, operations, nonFinalVariables) != null) {\n          registerProblem(statement, \"count\", new ReplaceWithCountFix());\n        }\n        if(getAccumulatedVariable(tb, operations, nonFinalVariables) != null) {\n          registerProblem(statement, \"sum\", new ReplaceWithSumFix());\n        }\n        if(!nonFinalVariables.isEmpty()) {\n          return;\n        }\n        if ((isArray || !isRawSubstitution(iteratedValueType, collectionClass)) && isCollectCall(tb, operations)) {\n          boolean addAll = operations.isEmpty() && isAddAllCall(tb);\n          String methodName;\n          if(addAll) {\n            methodName = \"addAll\";\n          } else {\n            PsiMethodCallExpression methodCallExpression = tb.getSingleMethodCall();\n            if(canCollect(statement, methodCallExpression)) {\n              if(extractToArrayExpression(statement, methodCallExpression) != null)\n                methodName = \"toArray\";\n              else\n                methodName = \"collect\";\n            } else {\n              if (!SUGGEST_FOREACH) return;\n              methodName = \"forEach\";\n            }\n          }\n          registerProblem(statement, methodName, new ReplaceWithCollectFix(methodName));\n        }\n        // do not replace for(T e : arr) {} with Arrays.stream(arr).forEach(e -> {}) even if flag is set\n        else if (SUGGEST_FOREACH && (!operations.isEmpty() ||\n                                     (!isArray && (REPLACE_TRIVIAL_FOREACH || !isTrivial(body, statement.getIterationParameter()))))) {\n          ReplaceWithForeachCallFix forEachFix = new ReplaceWithForeachCallFix(\"forEach\");\n          LocalQuickFix[] fixes = {forEachFix};\n          if (!operations.isEmpty()) { //for .stream()\n            fixes = new LocalQuickFix[] {forEachFix, new ReplaceWithForeachCallFix(\"forEachOrdered\")};\n          }\n          registerProblem(statement, \"forEach\", fixes);\n        }\n      } else {\n        if (operations.isEmpty() && !REPLACE_TRIVIAL_FOREACH) return;\n        if (nonFinalVariables.isEmpty() && tb.getSingleStatement() instanceof PsiReturnStatement) {\n          handleSingleReturn(statement, tb, operations);\n        }\n        // Intermediate ops should not refer to non-final variables\n        if (StreamEx.of(operations).map(Operation::getExpression)\n          .flatCollection(expr -> PsiTreeUtil.collectElementsOfType(expr, PsiReferenceExpression.class))\n          .map(PsiReferenceExpression::resolve).anyMatch(nonFinalVariables::contains)) {\n          return;\n        }\n        PsiStatement[] statements = tb.getStatements();\n        if (statements.length == 2) {\n          PsiStatement breakStatement = statements[1];\n          if (!(breakStatement instanceof PsiBreakStatement) ||\n              ((PsiBreakStatement)breakStatement).findExitedStatement() != statement) {\n            return;\n          }\n          if (ReferencesSearch.search(tb.getVariable(), new LocalSearchScope(statements)).findFirst() == null\n            && exitPoints.size() == 1 && exitPoints.contains(breakStatement)) {\n            registerProblem(statement, \"anyMatch\", new ReplaceWithMatchFix(\"anyMatch\"));\n            return;\n          }\n          if (nonFinalVariables.size() == 1) {\n            PsiAssignmentExpression assignment = ExpressionUtils.getAssignment(statements[0]);\n            if(assignment == null) return;\n            PsiExpression lValue = assignment.getLExpression();\n            if (!(lValue instanceof PsiReferenceExpression)) return;\n            PsiElement var = ((PsiReferenceExpression)lValue).resolve();\n            if(!(var instanceof PsiVariable) || !nonFinalVariables.contains(var)) return;\n            PsiExpression rValue = assignment.getRExpression();\n            if(rValue == null || isVariableReferenced((PsiVariable)var, rValue)) return;\n            if(tb.getVariable().getType() instanceof PsiPrimitiveType && !isIdentityMapping(tb.getVariable(), rValue)) return;\n            registerProblem(statement, \"findFirst\", new ReplaceWithFindFirstFix());\n          }\n        }\n      }\n    }","id":93245,"modified_method":"@Override\n    public void visitForeachStatement(PsiForeachStatement statement) {\n      super.visitForeachStatement(statement);\n      final PsiExpression iteratedValue = statement.getIteratedValue();\n      final PsiStatement body = statement.getBody();\n      if (iteratedValue == null || body == null) return;\n\n      final PsiType iteratedValueType = iteratedValue.getType();\n      final PsiClass iteratorClass = PsiUtil.resolveClassInClassTypeOnly(iteratedValueType);\n      PsiClass collectionClass = null;\n      final boolean isArray;\n      if(iteratedValueType instanceof PsiArrayType) {\n        if(!isSupported(((PsiArrayType)iteratedValueType).getComponentType())) return;\n        isArray = true;\n      } else {\n        collectionClass = JavaPsiFacade.getInstance(body.getProject()).findClass(CommonClassNames.JAVA_UTIL_COLLECTION, statement.getResolveScope());\n        if (collectionClass != null && InheritanceUtil.isInheritorOrSelf(iteratorClass, collectionClass, true)) {\n          isArray = false;\n        } else return;\n      }\n      if (!ExceptionUtil.getThrownCheckedExceptions(body).isEmpty()) return;\n\n      TerminalBlock tb = TerminalBlock.from(statement.getIterationParameter(), body);\n      if(tb.isEmpty()) return;\n\n      final ControlFlow controlFlow;\n      try {\n        controlFlow = ControlFlowFactory.getInstance(myHolder.getProject())\n          .getControlFlow(body, LocalsOrMyInstanceFieldsControlFlowPolicy.getInstance());\n      }\n      catch (AnalysisCanceledException ignored) {\n        return;\n      }\n      final Collection<PsiStatement> exitPoints = ControlFlowUtil\n        .findExitPointsAndStatements(controlFlow, tb.getStartOffset(controlFlow), tb.getEndOffset(controlFlow),\n                                     new IntArrayList(), PsiContinueStatement.class,\n                                     PsiBreakStatement.class, PsiReturnStatement.class, PsiThrowStatement.class);\n      int startOffset = controlFlow.getStartOffset(body);\n      int endOffset = controlFlow.getEndOffset(body);\n      final List<PsiVariable> nonFinalVariables = StreamEx.of(ControlFlowUtil.getUsedVariables(controlFlow, startOffset, endOffset))\n        .remove(variable -> HighlightControlFlowUtil.isEffectivelyFinal(variable, body, null)).toList();\n\n      if (exitPoints.isEmpty()) {\n        if(getIncrementedVariable(tb, nonFinalVariables) != null) {\n          registerProblem(statement, \"count\", new ReplaceWithCountFix());\n        }\n        if(getAccumulatedVariable(tb, nonFinalVariables) != null) {\n          registerProblem(statement, \"sum\", new ReplaceWithSumFix());\n        }\n        if(!nonFinalVariables.isEmpty()) {\n          return;\n        }\n        if ((isArray || !isRawSubstitution(iteratedValueType, collectionClass)) && isCollectCall(tb)) {\n          boolean addAll = !tb.hasOperations() && isAddAllCall(tb);\n          String methodName;\n          if(addAll) {\n            methodName = \"addAll\";\n          } else {\n            PsiMethodCallExpression methodCallExpression = tb.getSingleMethodCall();\n            if(canCollect(statement, methodCallExpression)) {\n              if(extractToArrayExpression(statement, methodCallExpression) != null)\n                methodName = \"toArray\";\n              else\n                methodName = \"collect\";\n            } else {\n              if (!SUGGEST_FOREACH) return;\n              methodName = \"forEach\";\n            }\n          }\n          registerProblem(statement, methodName, new ReplaceWithCollectFix(methodName));\n        }\n        // do not replace for(T e : arr) {} with Arrays.stream(arr).forEach(e -> {}) even if flag is set\n        else if (SUGGEST_FOREACH &&\n                 (tb.hasOperations() || (!isArray && (REPLACE_TRIVIAL_FOREACH || !isTrivial(body, statement.getIterationParameter()))))) {\n          ReplaceWithForeachCallFix forEachFix = new ReplaceWithForeachCallFix(\"forEach\");\n          LocalQuickFix[] fixes = {forEachFix};\n          if (tb.hasOperations()) { //for .stream()\n            fixes = new LocalQuickFix[] {forEachFix, new ReplaceWithForeachCallFix(\"forEachOrdered\")};\n          }\n          registerProblem(statement, \"forEach\", fixes);\n        }\n      } else {\n        if (!tb.hasOperations() && !REPLACE_TRIVIAL_FOREACH) return;\n        if (nonFinalVariables.isEmpty() && tb.getSingleStatement() instanceof PsiReturnStatement) {\n          handleSingleReturn(statement, tb);\n        }\n        // Intermediate ops should not refer to non-final variables\n        if (tb.intermediateExpressions()\n          .flatCollection(expr -> PsiTreeUtil.collectElementsOfType(expr, PsiReferenceExpression.class))\n          .map(PsiReferenceExpression::resolve).anyMatch(nonFinalVariables::contains)) {\n          return;\n        }\n        PsiStatement[] statements = tb.getStatements();\n        if (statements.length == 2) {\n          PsiStatement breakStatement = statements[1];\n          if (!(breakStatement instanceof PsiBreakStatement) ||\n              ((PsiBreakStatement)breakStatement).findExitedStatement() != statement) {\n            return;\n          }\n          if (ReferencesSearch.search(tb.getVariable(), new LocalSearchScope(statements)).findFirst() == null\n            && exitPoints.size() == 1 && exitPoints.contains(breakStatement)) {\n            registerProblem(statement, \"anyMatch\", new ReplaceWithMatchFix(\"anyMatch\"));\n            return;\n          }\n          if (nonFinalVariables.size() == 1) {\n            PsiAssignmentExpression assignment = ExpressionUtils.getAssignment(statements[0]);\n            if(assignment == null) return;\n            PsiExpression lValue = assignment.getLExpression();\n            if (!(lValue instanceof PsiReferenceExpression)) return;\n            PsiElement var = ((PsiReferenceExpression)lValue).resolve();\n            if(!(var instanceof PsiVariable) || !nonFinalVariables.contains(var)) return;\n            PsiExpression rValue = assignment.getRExpression();\n            if(rValue == null || isVariableReferenced((PsiVariable)var, rValue)) return;\n            if(tb.getVariable().getType() instanceof PsiPrimitiveType && !isIdentityMapping(tb.getVariable(), rValue)) return;\n            registerProblem(statement, \"findFirst\", new ReplaceWithFindFirstFix());\n          }\n        }\n      }\n    }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"CompoundFilterOp(FilterOp source, FlatMapOp flatMapOp) {\n      super(source.getExpression(), flatMapOp.myVariable, source.myNegated);\n      myMatchVariable = source.myVariable;\n      myFlatMapOp = flatMapOp;\n    }","id":93246,"modified_method":"CompoundFilterOp(FilterOp source, FlatMapOp flatMapOp) {\n      super(flatMapOp.myPreviousOp, source.getExpression(), flatMapOp.myVariable, source.myNegated);\n      myMatchVariable = source.myVariable;\n      myFlatMapOp = flatMapOp;\n    }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private TerminalBlock(PsiVariable variable, PsiStatement[] statements) {\n      myVariable = variable;\n      myStatements = statements;\n      flatten();\n    }","id":93247,"modified_method":"private TerminalBlock(@Nullable Operation previousOp, @NotNull PsiVariable variable, @NotNull PsiStatement... statements) {\n      myVariable = variable;\n      while(true) {\n        if(statements.length == 1 && statements[0] instanceof PsiBlockStatement) {\n          statements = ((PsiBlockStatement)statements[0]).getCodeBlock().getStatements();\n        } else if(statements.length == 1 && statements[0] instanceof PsiLabeledStatement) {\n          statements = new PsiStatement[] {((PsiLabeledStatement)statements[0]).getStatement()};\n        } else break;\n      }\n      myStatements = statements;\n      myPreviousOp = previousOp;\n    }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void handleSingleReturn(PsiForeachStatement statement, TerminalBlock tb, List<Operation> operations) {\n      PsiReturnStatement returnStatement = (PsiReturnStatement)tb.getSingleStatement();\n      PsiExpression value = returnStatement.getReturnValue();\n      PsiReturnStatement nextReturnStatement = getNextReturnStatement(statement);\n      if (nextReturnStatement != null &&\n          (ExpressionUtils.isLiteral(value, Boolean.TRUE) || ExpressionUtils.isLiteral(value, Boolean.FALSE))) {\n        boolean foundResult = (boolean)((PsiLiteralExpression)value).getValue();\n        if(ExpressionUtils.isLiteral(nextReturnStatement.getReturnValue(), !foundResult)) {\n          String methodName;\n          if (foundResult) {\n            methodName = \"anyMatch\";\n          }\n          else {\n            methodName = \"noneMatch\";\n            if(!operations.isEmpty()) {\n              Operation lastOp = operations.get(operations.size() - 1);\n              if(lastOp instanceof FilterOp && (((FilterOp)lastOp).isNegated() ^ BoolUtils.isNegation(lastOp.getExpression()))) {\n                methodName = \"allMatch\";\n              }\n            }\n          }\n          registerProblem(statement, methodName, new ReplaceWithMatchFix(methodName));\n          return;\n        }\n      }\n      if (!isVariableReferenced(tb.getVariable(), value)) {\n        if(!REPLACE_TRIVIAL_FOREACH && operations.isEmpty() || (operations.size() == 1 && operations.get(0) instanceof FilterOp)) {\n          return;\n        }\n        registerProblem(statement, \"anyMatch\", new ReplaceWithMatchFix(\"anyMatch\"));\n      }\n      if(nextReturnStatement != null && ExpressionUtils.isSimpleExpression(nextReturnStatement.getReturnValue())\n         && (!(tb.getVariable().getType() instanceof PsiPrimitiveType) || isIdentityMapping(tb.getVariable(), value))) {\n        registerProblem(statement, \"findFirst\", new ReplaceWithFindFirstFix());\n      }\n    }","id":93248,"modified_method":"void handleSingleReturn(PsiForeachStatement statement, TerminalBlock tb) {\n      PsiReturnStatement returnStatement = (PsiReturnStatement)tb.getSingleStatement();\n      PsiExpression value = returnStatement.getReturnValue();\n      PsiReturnStatement nextReturnStatement = getNextReturnStatement(statement);\n      if (nextReturnStatement != null &&\n          (ExpressionUtils.isLiteral(value, Boolean.TRUE) || ExpressionUtils.isLiteral(value, Boolean.FALSE))) {\n        boolean foundResult = (boolean)((PsiLiteralExpression)value).getValue();\n        if(ExpressionUtils.isLiteral(nextReturnStatement.getReturnValue(), !foundResult)) {\n          String methodName;\n          if (foundResult) {\n            methodName = \"anyMatch\";\n          }\n          else {\n            methodName = \"noneMatch\";\n            Operation lastOp = tb.getLastOperation();\n            if(lastOp instanceof FilterOp && (((FilterOp)lastOp).isNegated() ^ BoolUtils.isNegation(lastOp.getExpression()))) {\n              methodName = \"allMatch\";\n            }\n          }\n          registerProblem(statement, methodName, new ReplaceWithMatchFix(methodName));\n          return;\n        }\n      }\n      if (!isVariableReferenced(tb.getVariable(), value)) {\n        Operation lastOp = tb.getLastOperation();\n        if(!REPLACE_TRIVIAL_FOREACH && lastOp == null || (lastOp instanceof FilterOp && lastOp.getPreviousOp() == null)) return;\n        registerProblem(statement, \"anyMatch\", new ReplaceWithMatchFix(\"anyMatch\"));\n      }\n      if(nextReturnStatement != null && ExpressionUtils.isSimpleExpression(nextReturnStatement.getReturnValue())\n         && (!(tb.getVariable().getType() instanceof PsiPrimitiveType) || isIdentityMapping(tb.getVariable(), value))) {\n        registerProblem(statement, \"findFirst\", new ReplaceWithFindFirstFix());\n      }\n    }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * If possible, extract single intermediate stream operation from this\n     * {@code TerminalBlock} changing the TerminalBlock itself to exclude this operation\n     *\n     * @return extracted operation or null if extraction is not possible\n     */\n    @Nullable\n    Operation extractOperation() {\n      FilterOp filter = extractFilter();\n      if(filter != null) return filter;\n      // extract flatMap\n      if(getSingleStatement() instanceof PsiForeachStatement) {\n        // flatMapping of primitive variable is not supported yet\n        if(myVariable.getType() instanceof PsiPrimitiveType) return null;\n        PsiForeachStatement foreachStatement = (PsiForeachStatement)getSingleStatement();\n        final PsiExpression iteratedValue = foreachStatement.getIteratedValue();\n        final PsiStatement body = foreachStatement.getBody();\n        if (iteratedValue != null && body != null) {\n          final PsiType iteratedValueType = iteratedValue.getType();\n          FlatMapOp op = null;\n          if(iteratedValueType instanceof PsiArrayType) {\n            if (!isSupported(((PsiArrayType)iteratedValueType).getComponentType())) return null;\n            op = new ArrayFlatMapOp(iteratedValue, myVariable, foreachStatement);\n          } else {\n            final PsiClass iteratorClass = PsiUtil.resolveClassInClassTypeOnly(iteratedValueType);\n            final PsiClass collectionClass =\n              JavaPsiFacade.getInstance(body.getProject())\n                .findClass(CommonClassNames.JAVA_UTIL_COLLECTION, foreachStatement.getResolveScope());\n            if (collectionClass != null && InheritanceUtil.isInheritorOrSelf(iteratorClass, collectionClass, true)) {\n              op = new FlatMapOp(iteratedValue, myVariable, foreachStatement);\n            }\n          }\n          if(op != null) {\n            if(ReferencesSearch.search(myVariable, new LocalSearchScope(body)).findFirst() == null) {\n              myVariable = foreachStatement.getIterationParameter();\n              replaceWith(body);\n              return op;\n            } else {\n              PsiStatement[] statements = myStatements;\n              myVariable = foreachStatement.getIterationParameter();\n              replaceWith(body);\n              FilterOp nextFilter = extractFilter();\n              myVariable = op.myVariable;\n              if(nextFilter != null) {\n                PsiStatement lastStatement = myStatements[myStatements.length - 1];\n                if(lastStatement instanceof PsiBreakStatement && op.breaksMe((PsiBreakStatement)lastStatement) &&\n                   ReferencesSearch.search(nextFilter.myVariable, new LocalSearchScope(myStatements)).findFirst() == null) {\n                  myStatements = Arrays.copyOfRange(myStatements, 0, myStatements.length-1);\n                  return new CompoundFilterOp(nextFilter, op);\n                }\n              }\n              myStatements = statements;\n            }\n          }\n        }\n      }\n      if(myStatements.length >= 1) {\n        PsiStatement first = myStatements[0];\n        // extract map\n        if(first instanceof PsiDeclarationStatement) {\n          PsiDeclarationStatement decl = (PsiDeclarationStatement)first;\n          PsiElement[] elements = decl.getDeclaredElements();\n          if(elements.length == 1) {\n            PsiElement element = elements[0];\n            if(element instanceof PsiLocalVariable) {\n              PsiLocalVariable declaredVar = (PsiLocalVariable)element;\n              if(isSupported(declaredVar.getType())) {\n                PsiExpression initializer = declaredVar.getInitializer();\n                PsiStatement[] leftOver = Arrays.copyOfRange(myStatements, 1, myStatements.length);\n                if (initializer != null &&\n                    ReferencesSearch.search(myVariable, new LocalSearchScope(leftOver))\n                      .findFirst() == null) {\n                  MapOp op = new MapOp(initializer, myVariable, declaredVar.getType());\n                  myVariable = declaredVar;\n                  myStatements = leftOver;\n                  flatten();\n                  return op;\n                }\n              }\n            }\n          }\n        }\n      }\n      return null;\n    }","id":93249,"modified_method":"/**\n     * Returns an equivalent {@code TerminalBlock} with one more intermediate operation extracted\n     * or null if extraction is not possible.\n     *\n     * @return extracted operation or null if extraction is not possible\n     */\n    @Nullable\n    TerminalBlock extractOperation() {\n      TerminalBlock withFilter = extractFilter();\n      if(withFilter != null) return withFilter;\n      // extract flatMap\n      if(getSingleStatement() instanceof PsiForeachStatement) {\n        // flatMapping of primitive variable is not supported yet\n        if(myVariable.getType() instanceof PsiPrimitiveType) return null;\n        PsiForeachStatement foreachStatement = (PsiForeachStatement)getSingleStatement();\n        final PsiExpression iteratedValue = foreachStatement.getIteratedValue();\n        final PsiStatement body = foreachStatement.getBody();\n        if (iteratedValue != null && body != null) {\n          final PsiType iteratedValueType = iteratedValue.getType();\n          FlatMapOp op = null;\n          if(iteratedValueType instanceof PsiArrayType) {\n            if (!isSupported(((PsiArrayType)iteratedValueType).getComponentType())) return null;\n            op = new ArrayFlatMapOp(myPreviousOp, iteratedValue, myVariable, foreachStatement);\n          } else {\n            final PsiClass iteratorClass = PsiUtil.resolveClassInClassTypeOnly(iteratedValueType);\n            final PsiClass collectionClass =\n              JavaPsiFacade.getInstance(body.getProject())\n                .findClass(CommonClassNames.JAVA_UTIL_COLLECTION, foreachStatement.getResolveScope());\n            if (collectionClass != null && InheritanceUtil.isInheritorOrSelf(iteratorClass, collectionClass, true)) {\n              op = new FlatMapOp(myPreviousOp, iteratedValue, myVariable, foreachStatement);\n            }\n          }\n          if(op != null) {\n            TerminalBlock withFlatMap = new TerminalBlock(op, foreachStatement.getIterationParameter(), body);\n            if(ReferencesSearch.search(myVariable, new LocalSearchScope(body)).findFirst() == null) {\n              return withFlatMap;\n            } else {\n              // Try extract nested filter like this:\n              // for(List subList : list) for(T t : subList) if(condition.test(t)) { ...; break; }\n              // if t is not used in \"...\", then this could be converted to\n              // list.stream().filter(subList -> subList.stream().anyMatch(condition)).forEach(subList -> ...)\n              TerminalBlock withFlatMapFilter = withFlatMap.extractFilter();\n              if(withFlatMapFilter != null && !withFlatMapFilter.isEmpty()) {\n                PsiStatement[] statements = withFlatMapFilter.getStatements();\n                PsiStatement lastStatement = statements[statements.length-1];\n                if (lastStatement instanceof PsiBreakStatement && op.breaksMe((PsiBreakStatement)lastStatement) &&\n                    ReferencesSearch.search(withFlatMapFilter.getVariable(), new LocalSearchScope(statements)).findFirst() == null) {\n                  return new TerminalBlock(new CompoundFilterOp((FilterOp)withFlatMapFilter.getLastOperation(), op),\n                                           myVariable, Arrays.copyOfRange(statements, 0, statements.length-1));\n                }\n              }\n            }\n          }\n        }\n      }\n      if(myStatements.length >= 1) {\n        PsiStatement first = myStatements[0];\n        // extract map\n        if(first instanceof PsiDeclarationStatement) {\n          PsiDeclarationStatement decl = (PsiDeclarationStatement)first;\n          PsiElement[] elements = decl.getDeclaredElements();\n          if(elements.length == 1) {\n            PsiElement element = elements[0];\n            if(element instanceof PsiLocalVariable) {\n              PsiLocalVariable declaredVar = (PsiLocalVariable)element;\n              if(isSupported(declaredVar.getType())) {\n                PsiExpression initializer = declaredVar.getInitializer();\n                PsiStatement[] leftOver = Arrays.copyOfRange(myStatements, 1, myStatements.length);\n                if (initializer != null && ReferencesSearch.search(myVariable, new LocalSearchScope(leftOver)).findFirst() == null) {\n                  MapOp op = new MapOp(myPreviousOp, initializer, myVariable, declaredVar.getType());\n                  return new TerminalBlock(op, declaredVar, leftOver);\n                }\n              }\n            }\n          }\n        }\n      }\n      return null;\n    }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Operation(PsiExpression expression, PsiVariable variable) {\n      myExpression = expression;\n      myVariable = variable;\n    }","id":93250,"modified_method":"protected Operation(@Nullable Operation previousOp, PsiExpression expression, PsiVariable variable) {\n      myExpression = expression;\n      myVariable = variable;\n      myPreviousOp = previousOp;\n    }","commit_id":"50a618dfb230cf4461cb9bebfd3465a92b7c7327","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int compareTo(byte[] value, int offset, int length) {\n    // See HBASE-9428. Make a copy of the relevant part of the byte[],\n    // or the JDK will copy the entire byte[] during String decode\n    byte[] tmp = Arrays.copyOfRange(value, offset, offset+length);\n    // Use find() for subsequence match instead of matches() (full sequence\n    // match) to adhere to the principle of least surprise.\n    return pattern.matcher(new String(tmp, charset)).find() ? 0 : 1;\n  }","id":93251,"modified_method":"@Override\n  public int compareTo(byte[] value, int offset, int length) {\n    // Use find() for subsequence match instead of matches() (full sequence\n    // match) to adhere to the principle of least surprise.\n    String tmp;\n    if (length < value.length / 2) {\n      // See HBASE-9428. Make a copy of the relevant part of the byte[],\n      // or the JDK will copy the entire byte[] during String decode\n      tmp = new String(Arrays.copyOfRange(value, offset, offset + length), charset);\n    } else {\n      tmp = new String(value, offset, length, charset);\n    }\n    return pattern.matcher(tmp).find() ? 0 : 1;\n  }","commit_id":"c28b58f28089cc50ad2070afd759dc29742b5d1d","url":"https://github.com/apache/hbase"},{"original_method":"private void cleanAllNetworks() throws OpenstackException {\n\n\t\t// Clean external router\n\t\tif (!this.networkHelper.skipExternalNetworking()) {\n\t\t\tfinal Router router;\n\t\t\tif (this.networkHelper.isCreateExternalRouter()) {\n\t\t\t\t// The driver has created an external router\n\t\t\t\trouter = networkApi.getRouterByName(this.securityGroupNames.getPrefix()\n\t\t\t\t\t\t+ MANAGEMENT_PUBLIC_ROUTER_NAME);\n\t\t\t} else {\n\t\t\t\t// User has specified an external router to use\n\t\t\t\trouter = networkApi.getRouterByName(this.networkHelper.getExternalRouterName());\n\t\t\t}\n\n\t\t\tif (router != null) {\n\t\t\t\t// Get a network without the prefix name.\n\t\t\t\ttry {\n\t\t\t\t\tfinal String privateIpNetworkName = this.networkHelper.getPrivateIpNetworkName();\n\t\t\t\t\tfinal Network privateIpNetwork = this.getNetworkByNameThenPrefix(privateIpNetworkName);\n\t\t\t\t\tnetworkApi.deleteRouterInterface(router.getId(), privateIpNetwork.getSubnets()[0]);\n\t\t\t\t} catch (CloudProvisioningException e) {\n\t\t\t\t\t// If the private network doesn't exist there is no consequences:\n\t\t\t\t\t// we can't detached a network which doesn't exist anymore.\n\t\t\t\t}\n\n\t\t\t\tif (this.networkHelper.isCreateExternalRouter()) {\n\t\t\t\t\tnetworkApi.deleteRouter(router.getId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Delete all remaining application networks\n\t\tfinal List<Network> appliNetworks = networkApi.getNetworkByPrefix(this.securityGroupNames.getPrefix());\n\t\tfor (final Network n : appliNetworks) {\n\t\t\tnetworkApi.deleteNetwork(n.getId());\n\n\t\t}\n\t}","id":93252,"modified_method":"private void cleanAllNetworks() throws OpenstackException {\n\n\t\t// Clean external router\n\t\tif (!this.networkHelper.skipExternalNetworking()) {\n\t\t\tfinal Router router;\n\t\t\tif (this.networkHelper.isCreateExternalRouter()) {\n\t\t\t\t// The driver has created an external router\n\t\t\t\trouter = networkApi.getRouterByName(this.securityGroupNames.getPrefix()\n\t\t\t\t\t\t+ MANAGEMENT_PUBLIC_ROUTER_NAME);\n\t\t\t} else {\n\t\t\t\t// User has specified an external router to use\n\t\t\t\trouter = networkApi.getRouterByName(this.networkHelper.getExternalRouterName());\n\t\t\t}\n\n\t\t\tif (router != null) {\n\t\t\t\ttry {\n\t\t\t\t\tfinal String privateIpNetworkName = this.networkHelper.getPrivateIpNetworkName();\n\t\t\t\t\tNetwork privateNetwork = this.getNetworkByNameThenPrefix(privateIpNetworkName);\n\t\t\t\t\tString[] privateNetSubnetIds = privateNetwork.getSubnets();\n\n\t\t\t\t\tfinal List<Port> ports = networkApi.getPortsByDeviceId(router.getId());\n\t\t\t\t\tfor (final Port port : ports) {\n\t\t\t\t\t\tfor (final RouteFixedIp fixedIp : port.getFixedIps()) {\n\t\t\t\t\t\t\tfor (final String id : privateNetSubnetIds) {\n\t\t\t\t\t\t\t\tif (id.equals(fixedIp.getSubnetId())) {\n\t\t\t\t\t\t\t\t\tnetworkApi.deleteRouterInterface(router.getId(), fixedIp.getSubnetId());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (final Exception e) {\n\t\t\t\t\t// If the private network doesn't exist there is no consequences:\n\t\t\t\t\t// we can't detached a network which doesn't exist anymore.\n\t\t\t\t\tlogger.log(Level.WARNING, \"Could not remove an interface from external router\", e);\n\t\t\t\t}\n\n\t\t\t\tif (this.networkHelper.isCreateExternalRouter()) {\n\t\t\t\t\tnetworkApi.deleteRouter(router.getId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Delete all remaining application networks\n\t\tfinal List<Network> appliNetworks = networkApi.getNetworkByPrefix(this.securityGroupNames.getPrefix());\n\t\tfor (final Network n : appliNetworks) {\n\t\t\tnetworkApi.deleteNetwork(n.getId());\n\n\t\t}\n\t}","commit_id":"4117a92c8df9379d568beb5dc74a41c9772b862b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void createManagementNetworkAndSubnets() throws CloudProvisioningException {\n\t\ttry {\n\t\t\t// Clear existing network\n\t\t\tthis.cleanAllNetworks();\n\n\t\t\tfinal NetworkConfiguration networkConfiguration = this.networkHelper.getNetworkConfiguration();\n\n\t\t\t// Network\n\t\t\tfinal Network network = this.getOrCreateNetwork(networkConfiguration);\n\n\t\t\t// FIXME should be able to create multiple subnets\n\t\t\tfinal Subnet subnet;\n\t\t\tif (networkConfiguration.getSubnets() == null || networkConfiguration.getSubnets().isEmpty()) {\n\t\t\t\tsubnet = this.getOrCreateSubnet(null, network);\n\t\t\t} else {\n\t\t\t\tsubnet = this.getOrCreateSubnet(networkConfiguration.getSubnets().get(0), network);\n\t\t\t}\n\n\t\t\tif (!this.networkHelper.skipExternalNetworking()) {\n\t\t\t\tthis.createExternalNetworking(network, subnet);\n\t\t\t}\n\t\t} catch (final Exception e) {\n\t\t\ttry {\n\t\t\t\tthis.cleanAllNetworks();\n\t\t\t} catch (OpenstackException e1) {\n\t\t\t\tlogger.warning(\"Couldn't clean all networks: \" + e1.getMessage());\n\t\t\t}\n\t\t\tthrow new CloudProvisioningException(e);\n\t\t}\n\t}","id":93253,"modified_method":"private void createManagementNetworkAndSubnets() throws CloudProvisioningException {\n\t\ttry {\n\t\t\t// Clear existing network\n\t\t\tthis.cleanAllNetworks();\n\n\t\t\tfinal NetworkConfiguration networkConfiguration = this.networkHelper.getNetworkConfiguration();\n\n\t\t\t// Network\n\t\t\tfinal Network network = this.getOrCreateNetwork(networkConfiguration);\n\n\t\t\tfinal List<Subnet> subnets = new ArrayList<Subnet>();\n\t\t\tif (networkConfiguration.getSubnets() != null) {\n\t\t\t\tfor (org.cloudifysource.domain.cloud.network.Subnet subnetConfig : networkConfiguration.getSubnets()) {\n\t\t\t\t\tSubnet subnet = this.getOrCreateSubnet(subnetConfig, network);\n\t\t\t\t\tsubnets.add(subnet);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.networkHelper.skipExternalNetworking()) {\n\t\t\t\tthis.createExternalNetworking(network, subnets.get(0));\n\t\t\t}\n\t\t} catch (final Exception e) {\n\t\t\ttry {\n\t\t\t\tthis.cleanAllNetworks();\n\t\t\t} catch (OpenstackException e1) {\n\t\t\t\tlogger.warning(\"Couldn't clean all networks: \" + e1.getMessage());\n\t\t\t}\n\t\t\tthrow new CloudProvisioningException(e);\n\t\t}\n\t}","commit_id":"4117a92c8df9379d568beb5dc74a41c9772b862b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tprotected MachineDetails createServer(final String serverName, final long endTime, final ComputeTemplate template)\n\t\t\tthrows CloudProvisioningException, TimeoutException {\n\n\t\tfinal String imageId = template.getImageId().split(\"/\")[1];\n\t\tfinal String hardwareId = template.getHardwareId().split(\"/\")[1];\n\t\tfinal String keyName = (String) template.getOptions().get(OPT_KEY_PAIR);\n\n\t\tString serverId = null;\n\t\tfinal List<String> reservedPortIds = new ArrayList<String>();\n\n\t\ttry {\n\n\t\t\tfinal NovaServerResquest request = new NovaServerResquest();\n\t\t\trequest.setName(serverName);\n\t\t\trequest.setKeyName(keyName);\n\t\t\trequest.setImageRef(imageId);\n\t\t\trequest.setFlavorRef(hardwareId);\n\n\t\t\t// Add management network if exists\n\t\t\tif (this.networkHelper.useManagementNetwork()) {\n\t\t\t\tfinal String managementNetworkName = this.networkHelper.getManagementNetworkName();\n\t\t\t\tfinal Network managementNetwork = this.getNetworkByNameThenPrefix(managementNetworkName);\n\t\t\t\tfor (final String subnetId : managementNetwork.getSubnets()) {\n\t\t\t\t\tfinal Port port = this.addPortToRequest(request, managementNetwork.getId(), subnetId);\n\t\t\t\t\treservedPortIds.add(port.getId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add compute networks\n\t\t\tfor (final String networkName : this.networkHelper.getComputeNetworks()) {\n\t\t\t\tfinal Network network = this.networkApi.getNetworkByName(networkName);\n\t\t\t\tif (network == null) {\n\t\t\t\t\tthrow new CloudProvisioningException(\"Couldn't find network '\" + networkName + \"'\");\n\t\t\t\t}\n\t\t\t\tfor (final String subnetId : network.getSubnets()) {\n\t\t\t\t\tfinal Port port = this.addPortToRequest(request, network.getId(), subnetId);\n\t\t\t\t\treservedPortIds.add(port.getId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add template networks\n\t\t\tif (!management && this.networkHelper.useServiceNetworkTemplate()) {\n\t\t\t\tfinal NetworkConfiguration netConfig = this.networkHelper.getNetworkConfiguration();\n\t\t\t\tfinal Network templateNetwork = this.getNetworkByNameThenPrefix(netConfig.getName());\n\t\t\t\tfor (final String subnetId : templateNetwork.getSubnets()) {\n\t\t\t\t\tfinal Port port = this.addPortToRequest(request, templateNetwork.getId(), subnetId);\n\t\t\t\t\treservedPortIds.add(port.getId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tNovaServer newServer = computeApi.createServer(request);\n\t\t\tserverId = newServer.getId();\n\t\t\tnewServer = this.waitForServerToBecomeReady(serverId, endTime);\n\n\t\t\t// Add security groups to all ports\n\t\t\tif (management) {\n\t\t\t\tthis.addSecurityGroupsToServer(serverId,\n\t\t\t\t\t\tthis.securityGroupNames.getManagementName(),\n\t\t\t\t\t\tthis.securityGroupNames.getClusterName());\n\t\t\t} else {\n\t\t\t\tthis.addSecurityGroupsToServer(serverId,\n\t\t\t\t\t\tthis.securityGroupNames.getAgentName(),\n\t\t\t\t\t\tthis.securityGroupNames.getClusterName(),\n\t\t\t\t\t\tthis.securityGroupNames.getApplicationName(),\n\t\t\t\t\t\tthis.securityGroupNames.getServiceName());\n\t\t\t}\n\n\t\t\t// Associate floating ips if configured\n\t\t\tif (this.networkHelper.associateFloatingIp()) {\n\t\t\t\tfinal String privateIPNetworkName = this.networkHelper.getPrivateIpNetworkName();\n\t\t\t\tfinal Network privateIpNetwork = this.getNetworkByNameThenPrefix(privateIPNetworkName);\n\t\t\t\tnetworkApi.createAndAssociateFloatingIp(serverId, privateIpNetwork.getId());\n\t\t\t}\n\n\t\t\tfinal MachineDetails md = this.createMachineDetails(template, newServer);\n\n\t\t\treturn md;\n\t\t} catch (final Exception e) {\n\t\t\tlogger.log(Level.SEVERE, \"An error occured during initialization.\"\n\t\t\t\t\t+ \" Shutting down machine and cleaning openstack resources\", e);\n\t\t\tif (serverId != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcomputeApi.deleteServer(serverId);\n\t\t\t\t} catch (final OpenstackException e1) {\n\t\t\t\t\tlogger.log(Level.WARNING, \"Cleaning after error. Could not delete server.\", e1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (final String portId : reservedPortIds) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Application port are created before the VM.\n\t\t\t\t\t\t// So it can happen that port is created but an error occurs on VM instantiation.\n\t\t\t\t\t\t// In this case, we have to clear the port.\n\t\t\t\t\t\t// * Note: Port is deleted with server deletion, so no need to handle port deletion once the\n\t\t\t\t\t\t// server has been associated to the port.\n\t\t\t\t\t\tnetworkApi.deletePort(portId);\n\t\t\t\t\t} catch (final OpenstackException e1) {\n\t\t\t\t\t\tlogger.log(Level.WARNING, \"Cleaning after error. Could not delete server.\", e1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new CloudProvisioningException(e);\n\t\t}\n\t}","id":93254,"modified_method":"@Override\n\tprotected MachineDetails createServer(final String serverName, final long endTime, final ComputeTemplate template)\n\t\t\tthrows CloudProvisioningException, TimeoutException {\n\n\t\tfinal String imageId = template.getImageId().split(\"/\")[1];\n\t\tfinal String hardwareId = template.getHardwareId().split(\"/\")[1];\n\t\tfinal String keyName = (String) template.getOptions().get(OPT_KEY_PAIR);\n\n\t\tString serverId = null;\n\t\tfinal List<String> reservedPortIds = new ArrayList<String>();\n\n\t\ttry {\n\n\t\t\tfinal NovaServerResquest request = new NovaServerResquest();\n\t\t\trequest.setName(serverName);\n\t\t\trequest.setKeyName(keyName);\n\t\t\trequest.setImageRef(imageId);\n\t\t\trequest.setFlavorRef(hardwareId);\n\n\t\t\t// Add management network if exists\n\t\t\tif (this.networkHelper.useManagementNetwork()) {\n\t\t\t\tfinal String managementNetworkName = this.networkHelper.getManagementNetworkName();\n\t\t\t\tfinal Network managementNetwork = this.getNetworkByNameThenPrefix(managementNetworkName);\n\n\t\t\t\tfinal Port port = this.addPortToRequest(request,\n\t\t\t\t\t\tmanagementNetwork.getId(), managementNetwork.getSubnets());\n\n\t\t\t\treservedPortIds.add(port.getId());\n\t\t\t}\n\n\t\t\t// Add compute networks\n\t\t\tfor (final String networkName : this.networkHelper.getComputeNetworks()) {\n\t\t\t\tfinal Network network = this.networkApi.getNetworkByName(networkName);\n\t\t\t\tif (network == null) {\n\t\t\t\t\tthrow new CloudProvisioningException(\"Couldn't find network '\" + networkName + \"'\");\n\t\t\t\t}\n\n\t\t\t\tfinal Port port = this.addPortToRequest(request, network.getId(), network.getSubnets());\n\t\t\t\treservedPortIds.add(port.getId());\n\t\t\t}\n\n\t\t\t// Add template networks\n\t\t\tif (!management && this.networkHelper.useServiceNetworkTemplate()) {\n\t\t\t\tfinal NetworkConfiguration netConfig = this.networkHelper.getNetworkConfiguration();\n\t\t\t\tfinal Network templateNetwork = this.getNetworkByNameThenPrefix(netConfig.getName());\n\n\t\t\t\tfinal Port port = this.addPortToRequest(request,\n\t\t\t\t\t\ttemplateNetwork.getId(), templateNetwork.getSubnets());\n\t\t\t\treservedPortIds.add(port.getId());\n\t\t\t}\n\n\t\t\tNovaServer newServer = computeApi.createServer(request);\n\t\t\tserverId = newServer.getId();\n\t\t\tnewServer = this.waitForServerToBecomeReady(serverId, endTime);\n\n\t\t\t// Add security groups to all ports\n\t\t\tif (management) {\n\t\t\t\tthis.addSecurityGroupsToServer(serverId,\n\t\t\t\t\t\tthis.securityGroupNames.getManagementName(),\n\t\t\t\t\t\tthis.securityGroupNames.getClusterName());\n\t\t\t} else {\n\t\t\t\tthis.addSecurityGroupsToServer(serverId,\n\t\t\t\t\t\tthis.securityGroupNames.getAgentName(),\n\t\t\t\t\t\tthis.securityGroupNames.getClusterName(),\n\t\t\t\t\t\tthis.securityGroupNames.getApplicationName(),\n\t\t\t\t\t\tthis.securityGroupNames.getServiceName());\n\t\t\t}\n\n\t\t\t// Associate floating ips if configured\n\t\t\tif (this.networkHelper.associateFloatingIp()) {\n\t\t\t\tfinal String privateIPNetworkName = this.networkHelper.getPrivateIpNetworkName();\n\t\t\t\tfinal Network privateIpNetwork = this.getNetworkByNameThenPrefix(privateIPNetworkName);\n\t\t\t\tnetworkApi.createAndAssociateFloatingIp(serverId, privateIpNetwork.getId());\n\t\t\t}\n\n\t\t\tfinal MachineDetails md = this.createMachineDetails(template, newServer);\n\n\t\t\treturn md;\n\t\t} catch (final Exception e) {\n\t\t\tlogger.log(Level.SEVERE, \"An error occured during initialization.\"\n\t\t\t\t\t+ \" Shutting down machine and cleaning openstack resources\", e);\n\t\t\tif (serverId != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcomputeApi.deleteServer(serverId);\n\t\t\t\t} catch (final OpenstackException e1) {\n\t\t\t\t\tlogger.log(Level.WARNING, \"Cleaning after error. Could not delete server.\", e1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (final String portId : reservedPortIds) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Application port are created before the VM.\n\t\t\t\t\t\t// So it can happen that port is created but an error occurs on VM instantiation.\n\t\t\t\t\t\t// In this case, we have to clear the port.\n\t\t\t\t\t\t// * Note: Port is deleted with server deletion, so no need to handle port deletion once the\n\t\t\t\t\t\t// server has been associated to the port.\n\t\t\t\t\t\tnetworkApi.deletePort(portId);\n\t\t\t\t\t} catch (final OpenstackException e1) {\n\t\t\t\t\t\tlogger.log(Level.WARNING, \"Cleaning after error. Could not delete server.\", e1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new CloudProvisioningException(e);\n\t\t}\n\t}","commit_id":"4117a92c8df9379d568beb5dc74a41c9772b862b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * Create a port to attached to the VM. <br />\n\t * If several subnets exist in the network, use the first subnet of the network.\n\t */\n\tprivate Port addPortToRequest(final NovaServerResquest request, final String networkId, final String subnetId)\n\t\t\tthrows OpenstackException {\n\t\tfinal RouteFixedIp fixedIp = new RouteFixedIp();\n\t\tfixedIp.setSubnetId(subnetId);\n\t\tfinal Port port = new Port();\n\t\tport.addFixedIp(fixedIp);\n\t\tport.setNetworkId(networkId);\n\t\tfinal Port createdPort = this.networkApi.createPort(port);\n\n\t\tfinal NovaServerNetwork nsn = new NovaServerNetwork();\n\t\tnsn.setPort(createdPort.getId());\n\t\trequest.addNetworks(nsn);\n\n\t\treturn createdPort;\n\t}","id":93255,"modified_method":"/**\n\t * Create a port to attached to the VM and add it to the request. <br />\n\t */\n\tprivate Port addPortToRequest(final NovaServerResquest request, final String networkId, final String[] subnetIds)\n\t\t\tthrows OpenstackException {\n\t\tfinal Port port = new Port();\n\t\tfor (String subnetId : subnetIds) {\n\t\t\tfinal RouteFixedIp fixedIp = new RouteFixedIp();\n\t\t\tfixedIp.setSubnetId(subnetId);\n\t\t\tport.addFixedIp(fixedIp);\n\t\t}\n\t\tport.setNetworkId(networkId);\n\t\tfinal Port createdPort = this.networkApi.createPort(port);\n\n\t\tfinal NovaServerNetwork nsn = new NovaServerNetwork();\n\t\tnsn.setPort(createdPort.getId());\n\t\trequest.addNetworks(nsn);\n\n\t\treturn createdPort;\n\t}","commit_id":"4117a92c8df9379d568beb5dc74a41c9772b862b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * Allocate a floating from the pool and associate it to the given instance and network.\n\t * \n\t * @param deviceId\n\t *            The server id.\n\t * @param networkId\n\t *            The network id.\n\t * @return The floating ip address.\n\t * @throws OpenstackException\n\t *             Thrown when something went wrong with the request.\n\t */\n\tpublic String createAndAssociateFloatingIp(final String deviceId, final String networkId)\n\t\t\tthrows OpenstackException {\n\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\tlogger.fine(\"Create and associate floating ip for devideId=\" + deviceId + \"/networkId=\" + networkId);\n\t\t}\n\t\tif (networkId == null) {\n\t\t\tthrow new OpenstackException(\"Public network not found for deviceId=\" + deviceId);\n\t\t}\n\n\t\tfinal String floatingNetworkId = this.getPublicNetworkId();\n\t\tfinal Port port = this.getPort(deviceId, networkId);\n\t\tif (port == null) {\n\t\t\tthrow new OpenstackException(\"Port not found for deviceId=\" + deviceId);\n\t\t}\n\n\t\ttry {\n\t\t\tfinal String input = String.format(\"{\\\"floatingip\\\":{\\\"floating_network_id\\\":\\\"%s\\\",\\\"port_id\\\":\\\"%s\\\"}}\",\n\t\t\t\t\tfloatingNetworkId, port.getId());\n\t\t\tfinal String response = this.doPost(\"floatingips\", input);\n\t\t\tfinal FloatingIp floatingIp = JsonUtils.unwrapRootToObject(FloatingIp.class, response);\n\t\t\treturn floatingIp.getFloatingIpAddress();\n\t\t} catch (final UniformInterfaceException e) {\n\t\t\tthrow this.createOpenstackServerException(e);\n\t\t}\n\n\t}","id":93256,"modified_method":"/**\n\t * Allocate a floating from the pool and associate it to the given instance and network.\n\t * \n\t * @param deviceId\n\t *            The server id.\n\t * @param networkId\n\t *            The network id.\n\t * @return The floating ip address.\n\t * @throws OpenstackException\n\t *             Thrown when something went wrong with the request.\n\t */\n\tpublic String createAndAssociateFloatingIp(final String deviceId, final String networkId)\n\t\t\tthrows OpenstackException {\n\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\tlogger.fine(\"Create and associate floating ip for devideId=\" + deviceId + \"/networkId=\" + networkId);\n\t\t}\n\t\tif (networkId == null) {\n\t\t\tthrow new OpenstackException(\"Public network not found for deviceId=\" + deviceId);\n\t\t}\n\n\t\tfinal String floatingNetworkId = this.getPublicNetworkId();\n\t\tfinal Port port = this.getPort(deviceId, networkId);\n\t\tif (port == null) {\n\t\t\tthrow new OpenstackException(\"Port not found for deviceId=\" + deviceId);\n\t\t}\n\n\t\ttry {\n\t\t\tfinal String input =\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\"{\\\"floatingip\\\":{\\\"floating_network_id\\\":\\\"%s\\\",\"\n\t\t\t\t\t\t\t\t\t+ \"\\\"port_id\\\":\\\"%s\\\", \\\"fixed_ip_address\\\":\\\"%s\\\"}}\",\n\t\t\t\t\t\t\tfloatingNetworkId, port.getId(), port.getFixedIps().get(0).getIpAddress());\n\t\t\tfinal String response = this.doPost(\"floatingips\", input);\n\t\t\tfinal FloatingIp floatingIp = JsonUtils.unwrapRootToObject(FloatingIp.class, response);\n\t\t\treturn floatingIp.getFloatingIpAddress();\n\t\t} catch (final UniformInterfaceException e) {\n\t\t\tthrow this.createOpenstackServerException(e);\n\t\t}\n\n\t}","commit_id":"4117a92c8df9379d568beb5dc74a41c9772b862b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * Initialize properties for management network configuration.<br />\n\t * A network must be provided for management either it is configured in <code>cloudNetwork<\/code> template or in the\n\t * <code>computeNetwork<\/code> of the cloudCompute.\n\t * \n\t * @param configuration\n\t *            The configuration.\n\t * @throws CloudProvisioningException\n\t *             Thrown if no networks defined for the management machine.\n\t * \n\t */\n\tprivate void initManagementNetworkConfig(final ComputeDriverConfiguration configuration)\n\t\t\tthrows CloudProvisioningException {\n\t\tfinal Cloud cloud = configuration.getCloud();\n\t\tfinal String template = cloud.getConfiguration().getManagementMachineTemplate();\n\n\t\t// Init management computeNetworks. Check if there is any.\n\t\tfinal ComputeTemplate computeTemplate = cloud.getCloudCompute().getTemplates().get(template);\n\t\tif (computeTemplate != null) {\n\t\t\tfinal ComputeTemplateNetwork computeNetwork = computeTemplate.getComputeNetwork();\n\t\t\tif (computeNetwork != null) {\n\t\t\t\tthis.managementComputeNetworks = computeNetwork.getNetworks();\n\t\t\t}\n\t\t\tthis.managementNetworkOptions = computeTemplate.getOptions();\n\t\t}\n\n\t\tif (managementComputeNetworks == null) {\n\t\t\tthis.managementComputeNetworks = new ArrayList<String>();\n\t\t}\n\n\t\t// Figure out if there is a management network.\n\t\tfinal NetworkConfiguration mngConfig = cloud.getCloudNetwork().getManagement().getNetworkConfiguration();\n\t\tif (mngConfig != null && mngConfig.getName() != null && mngConfig.getSubnets() != null\n\t\t\t\t&& !mngConfig.getSubnets().isEmpty()) {\n\t\t\tthis.managementNetworkConfiguration = mngConfig;\n\t\t}\n\n\t\tif (this.managementNetworkConfiguration == null && managementComputeNetworks.isEmpty()) {\n\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\"A network must be provided to the management machines \"\n\t\t\t\t\t\t\t+ \"(use either cloudNetwork templates or computeNetwork configuration).\");\n\t\t}\n\t}","id":93257,"modified_method":"/**\n\t * Initialize properties for management network configuration.<br />\n\t * A network must be provided for management either it is configured in <code>cloudNetwork<\/code> template or in the\n\t * <code>computeNetwork<\/code> of the cloudCompute.\n\t * \n\t * @param configuration\n\t *            The configuration.\n\t * @throws CloudProvisioningException\n\t *             Thrown if no networks defined for the management machine.\n\t * \n\t */\n\tprivate void initManagementNetworkConfig(final ComputeDriverConfiguration configuration)\n\t\t\tthrows CloudProvisioningException {\n\t\tfinal Cloud cloud = configuration.getCloud();\n\t\tfinal String templateName = cloud.getConfiguration().getManagementMachineTemplate();\n\n\t\t// Init management computeNetworks. Check if there is any.\n\t\tfinal ComputeTemplate computeTemplate = cloud.getCloudCompute().getTemplates().get(templateName);\n\t\tif (computeTemplate != null) {\n\t\t\tfinal ComputeTemplateNetwork computeNetwork = computeTemplate.getComputeNetwork();\n\t\t\tif (computeNetwork != null) {\n\t\t\t\tthis.managementComputeNetworks = computeNetwork.getNetworks();\n\t\t\t}\n\t\t\tthis.managementNetworkOptions = computeTemplate.getOptions();\n\t\t}\n\n\t\tif (managementComputeNetworks == null) {\n\t\t\tthis.managementComputeNetworks = new ArrayList<String>();\n\t\t}\n\n\t\t// Figure out if there is a management network.\n\t\tfinal NetworkConfiguration mngConfig = cloud.getCloudNetwork().getManagement().getNetworkConfiguration();\n\t\tif (mngConfig != null && mngConfig.getName() != null && mngConfig.getSubnets() != null\n\t\t\t\t&& !mngConfig.getSubnets().isEmpty()) {\n\t\t\tthis.managementNetworkConfiguration = mngConfig;\n\t\t}\n\n\t\tif (this.managementNetworkConfiguration == null && managementComputeNetworks.isEmpty()) {\n\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\"A network must be provided to the management machines \"\n\t\t\t\t\t\t\t+ \"(use either cloudNetwork templates or computeNetwork configuration).\");\n\t\t}\n\n\t\tif (this.useManagementNetwork()) {\n\t\t\tlogger.info(\"Using management network : \" + this.managementNetworkConfiguration.getName());\n\t\t} else {\n\t\t\tlogger.info(\"Using computeNetwork of template '\" + templateName + \"' : \" + this.managementComputeNetworks);\n\t\t}\n\t}","commit_id":"4117a92c8df9379d568beb5dc74a41c9772b862b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public OpenStackNetworkConfigurationHelper(final ComputeDriverConfiguration configuration)\n\t\t\tthrows CloudProvisioningException {\n\n\t\tthis.validateNetworkNames(configuration.getCloud().getCloudNetwork());\n\t\tthis.initManagementNetworkConfig(configuration);\n\t\tthis.management = configuration.isManagement();\n\t\tif (!this.management) {\n\t\t\tthis.initServiceNetworkConfig(configuration);\n\t\t}\n\n\t}","id":93258,"modified_method":"public OpenStackNetworkConfigurationHelper(final ComputeDriverConfiguration configuration)\n\t\t\tthrows CloudProvisioningException {\n\n\t\tString name = configuration.isManagement() ? \"managers\" : configuration.getServiceName();\n\t\tlogger.info(\"Setup network configuration for \" + name);\n\n\t\tthis.validateNetworkNames(configuration.getCloud().getCloudNetwork());\n\t\tthis.initManagementNetworkConfig(configuration);\n\t\tthis.management = configuration.isManagement();\n\t\tif (!this.management) {\n\t\t\tthis.initServiceNetworkConfig(configuration);\n\t\t}\n\n\t}","commit_id":"4117a92c8df9379d568beb5dc74a41c9772b862b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * Initialize properties for service network configuration.<br />\n\t * \n\t * @param configuration\n\t *            The configuration.\n\t * @throws CloudProvisioningException\n\t *             Thrown if the service declared a network template which do not exist in the list of templates.\n\t */\n\tprivate void initServiceNetworkConfig(final ComputeDriverConfiguration configuration)\n\t\t\tthrows CloudProvisioningException {\n\n\t\t// Init management computeNetworks. Check if there is any.\n\t\tfinal Map<String, ComputeTemplate> computeTemplates = configuration.getCloud().getCloudCompute().getTemplates();\n\t\tfinal ComputeTemplate computeTemplate = computeTemplates.get(configuration.getCloudTemplate());\n\t\tif (computeTemplate != null) {\n\t\t\tfinal ComputeTemplateNetwork computeNetwork = computeTemplate.getComputeNetwork();\n\t\t\tif (computeNetwork != null) {\n\t\t\t\tthis.serviceComputeNetworks = computeNetwork.getNetworks();\n\t\t\t}\n\t\t}\n\t\tif (this.serviceComputeNetworks == null) {\n\t\t\tthis.serviceComputeNetworks = new ArrayList<String>();\n\t\t}\n\n\t\t// Figure out the application network to use\n\t\tfinal ServiceNetwork serviceNetwork = configuration.getNetwork();\n\t\tif (serviceNetwork != null) {\n\t\t\tthis.serviceAccessRules = serviceNetwork.getAccessRules();\n\t\t}\n\t\tfinal CloudNetwork cloudNetwork = configuration.getCloud().getCloudNetwork();\n\n\t\tif (cloudNetwork != null && serviceNetwork != null && serviceNetwork.getTemplate() != null) {\n\t\t\t// The service specified a network template to use.\n\t\t\tfinal Map<String, NetworkConfiguration> templates = cloudNetwork.getTemplates();\n\t\t\tthis.serviceNetworkConfiguration = templates.get(serviceNetwork.getTemplate());\n\t\t\tthis.serviceUseNetworkTemplate = true;\n\t\t\tif (this.serviceNetworkConfiguration == null) {\n\t\t\t\tthrow new CloudProvisioningException(\"Service network template not found '\"\n\t\t\t\t\t\t+ serviceNetwork.getTemplate() + \"'\");\n\t\t\t}\n\t\t} else if (this.serviceComputeNetworks.isEmpty()) {\n\t\t\t// The service did not specified a computeNetworks to use.\n\t\t\t// So try to get the first application network.\n\t\t\tif (cloudNetwork != null\n\t\t\t\t\t&& cloudNetwork.getTemplates() != null\n\t\t\t\t\t&& !cloudNetwork.getTemplates().isEmpty()) {\n\t\t\t\t// There is an application network template\n\t\t\t\tthis.serviceUseNetworkTemplate = true;\n\t\t\t\tthis.serviceNetworkConfiguration = cloudNetwork.getTemplates().values().iterator().next();\n\t\t\t} else {\n\t\t\t\t// if no application network template, use the management network.\n\t\t\t\tif (this.useManagementNetwork()) {\n\t\t\t\t\t// use the management network template if exists.\n\t\t\t\t\tthis.serviceNetworkConfiguration = this.managementNetworkConfiguration;\n\t\t\t\t} else {\n\t\t\t\t\t// Or use the management computeNetwork\n\t\t\t\t\tthis.serviceComputeNetworks = this.managementComputeNetworks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":93259,"modified_method":"/**\n\t * Initialize properties for service network configuration.<br />\n\t * \n\t * @param configuration\n\t *            The configuration.\n\t * @throws CloudProvisioningException\n\t *             Thrown if the service declared a network template which do not exist in the list of templates.\n\t */\n\tprivate void initServiceNetworkConfig(final ComputeDriverConfiguration configuration)\n\t\t\tthrows CloudProvisioningException {\n\n\t\t// Init management computeNetworks. Check if there is any.\n\t\tfinal Map<String, ComputeTemplate> computeTemplates = configuration.getCloud().getCloudCompute().getTemplates();\n\t\tfinal ComputeTemplate computeTemplate = computeTemplates.get(configuration.getCloudTemplate());\n\t\tif (computeTemplate != null) {\n\t\t\tfinal ComputeTemplateNetwork computeNetwork = computeTemplate.getComputeNetwork();\n\t\t\tif (computeNetwork != null) {\n\t\t\t\tthis.serviceComputeNetworks = computeNetwork.getNetworks();\n\t\t\t}\n\t\t}\n\t\tif (this.serviceComputeNetworks == null) {\n\t\t\tthis.serviceComputeNetworks = new ArrayList<String>();\n\t\t}\n\n\t\t// Figure out the application network to use\n\t\tfinal ServiceNetwork serviceNetwork = configuration.getNetwork();\n\t\tif (serviceNetwork != null) {\n\t\t\tthis.serviceAccessRules = serviceNetwork.getAccessRules();\n\t\t}\n\t\tfinal CloudNetwork cloudNetwork = configuration.getCloud().getCloudNetwork();\n\n\t\tif (cloudNetwork != null && serviceNetwork != null && serviceNetwork.getTemplate() != null) {\n\t\t\t// The service specified a network template to use.\n\t\t\tfinal Map<String, NetworkConfiguration> templates = cloudNetwork.getTemplates();\n\t\t\tthis.serviceNetworkConfiguration = templates.get(serviceNetwork.getTemplate());\n\t\t\tthis.serviceUseNetworkTemplate = true;\n\t\t\tif (this.serviceNetworkConfiguration == null) {\n\t\t\t\tthrow new CloudProvisioningException(\"Service network template not found '\"\n\t\t\t\t\t\t+ serviceNetwork.getTemplate() + \"'\");\n\t\t\t}\n\t\t} else if (this.serviceComputeNetworks.isEmpty()) {\n\t\t\t// The service did not specified a computeNetworks to use.\n\t\t\t// So try to get the first application network.\n\t\t\tif (cloudNetwork != null\n\t\t\t\t\t&& cloudNetwork.getTemplates() != null\n\t\t\t\t\t&& !cloudNetwork.getTemplates().isEmpty()) {\n\t\t\t\t// There is an application network template\n\t\t\t\tthis.serviceUseNetworkTemplate = true;\n\t\t\t\tthis.serviceNetworkConfiguration = cloudNetwork.getTemplates().values().iterator().next();\n\t\t\t} else {\n\t\t\t\t// if no application network template, use the management network.\n\t\t\t\tif (this.useManagementNetwork()) {\n\t\t\t\t\t// use the management network template if exists.\n\t\t\t\t\tthis.serviceNetworkConfiguration = this.managementNetworkConfiguration;\n\t\t\t\t} else {\n\t\t\t\t\t// Or use the management computeNetwork\n\t\t\t\t\tthis.serviceComputeNetworks = this.managementComputeNetworks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Log private ip network\n\t\tlogger.info(\"Service '\" + configuration.getServiceName() + \"' using network '\" + this.getPrivateIpNetworkName()\n\t\t\t\t+ \"' for private ip\");\n\t}","commit_id":"4117a92c8df9379d568beb5dc74a41c9772b862b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private AtomicReference<LookupElement[]> startCompletionThread(final CompletionParameters parameters,\n                                                                        final CompletionProgressIndicator indicator,\n                                                                        final CompletionInitializationContext initContext) {\n\n    final ApplicationAdapter listener = new ApplicationAdapter() {\n      @Override\n      public void beforeWriteActionStart(Object action) {\n        indicator.scheduleRestart();\n      }\n    };\n    ApplicationManager.getApplication().addApplicationListener(listener);\n\n    final Semaphore startSemaphore = new Semaphore();\n    startSemaphore.down();\n    startSemaphore.down();\n\n    spawnProcess(ProgressWrapper.wrap(indicator), new Runnable() {\n      public void run() {\n        try {\n          ApplicationManager.getApplication().runReadAction(new Runnable() {\n            public void run() {\n              startSemaphore.up();\n              indicator.setFocusLookupWhenDone(autopopup && shouldFocusLookup(parameters));\n              indicator.duringCompletion(initContext);\n            }\n          });\n        }\n        finally {\n          indicator.duringCompletionPassed();\n        }\n      }\n    });\n\n    final AtomicReference<LookupElement[]> data = new AtomicReference<LookupElement[]>(null);\n    spawnProcess(indicator, new Runnable() {\n      public void run() {\n        try {\n          ApplicationManager.getApplication().runReadAction(new Runnable() {\n            public void run() {\n              try {\n                startSemaphore.up();\n                ProgressManager.checkCanceled();\n\n                final LookupElement[] result = CompletionService.getCompletionService().performCompletion(parameters, new Consumer<LookupElement>() {\n                    public void consume(final LookupElement lookupElement) {\n                      indicator.addItem(lookupElement);\n                    }\n                  });\n\n                indicator.ensureDuringCompletionPassed();\n\n                data.set(result);\n              }\n              finally {\n                ApplicationManager.getApplication().removeApplicationListener(listener);\n              }\n            }\n          });\n        }\n        catch (ProcessCanceledException ignored) {\n        }\n      }\n    });\n\n    startSemaphore.waitFor();\n    return data;\n  }","id":93260,"modified_method":"private AtomicReference<LookupElement[]> startCompletionThread(final CompletionParameters parameters,\n                                                                        final CompletionProgressIndicator indicator,\n                                                                        final CompletionInitializationContext initContext) {\n\n    final ApplicationAdapter listener = new ApplicationAdapter() {\n      @Override\n      public void beforeWriteActionStart(Object action) {\n        indicator.scheduleRestart();\n      }\n    };\n    ApplicationManager.getApplication().addApplicationListener(listener);\n\n    final Semaphore startSemaphore = new Semaphore();\n    startSemaphore.down();\n    startSemaphore.down();\n\n    spawnProcess(ProgressWrapper.wrap(indicator), new Runnable() {\n      public void run() {\n        try {\n          ApplicationManager.getApplication().runReadAction(new Runnable() {\n            public void run() {\n              startSemaphore.up();\n              if (autopopup) {\n                indicator.setFocusLookupWhenDone(shouldFocusLookup(parameters));\n              }\n              indicator.duringCompletion(initContext);\n            }\n          });\n        }\n        finally {\n          indicator.duringCompletionPassed();\n        }\n      }\n    });\n\n    final AtomicReference<LookupElement[]> data = new AtomicReference<LookupElement[]>(null);\n    spawnProcess(indicator, new Runnable() {\n      public void run() {\n        try {\n          ApplicationManager.getApplication().runReadAction(new Runnable() {\n            public void run() {\n              try {\n                startSemaphore.up();\n                ProgressManager.checkCanceled();\n\n                final LookupElement[] result = CompletionService.getCompletionService().performCompletion(parameters, new Consumer<LookupElement>() {\n                    public void consume(final LookupElement lookupElement) {\n                      indicator.addItem(lookupElement);\n                    }\n                  });\n\n                indicator.ensureDuringCompletionPassed();\n\n                data.set(result);\n              }\n              finally {\n                ApplicationManager.getApplication().removeApplicationListener(listener);\n              }\n            }\n          });\n        }\n        catch (ProcessCanceledException ignored) {\n        }\n      }\n    });\n\n    startSemaphore.waitFor();\n    return data;\n  }","commit_id":"4e1d945e64e026db45d99131b0f6bb385575eab5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doComplete(final int invocationCount, CompletionInitializationContext initContext) {\n    final Editor editor = initContext.getEditor();\n\n    final CompletionParameters parameters = createCompletionParameters(invocationCount, initContext);\n\n    final LookupImpl lookup = obtainLookup(editor);\n\n    final Semaphore freezeSemaphore = new Semaphore();\n    freezeSemaphore.down();\n    final CompletionProgressIndicator indicator = new CompletionProgressIndicator(editor, parameters, this, freezeSemaphore,\n                                                                                  initContext.getOffsetMap(), lookup);\n\n    CompletionServiceImpl.setCompletionPhase(new CompletionPhase.Synchronous(indicator));\n\n    final AtomicReference<LookupElement[]> data = startCompletionThread(parameters, indicator, initContext);\n\n    if ((!invokedExplicitly && !ApplicationManager.getApplication().isUnitTestMode()) || CompletionAutoPopupHandler.ourTestingAutopopup) {\n      CompletionServiceImpl.setCompletionPhase(new CompletionPhase.BgCalculation(indicator));\n      return;\n    }\n\n    if (freezeSemaphore.waitFor(2000)) {\n      final LookupElement[] allItems = data.get();\n      if (allItems != null) { // the completion is really finished, now we may auto-insert or show lookup\n        completionFinished(initContext.getStartOffset(), initContext.getSelectionEndOffset(), indicator, allItems);\n        return;\n      }\n    }\n\n    CompletionServiceImpl.setCompletionPhase(new CompletionPhase.BgCalculation(indicator));\n    indicator.showLookup();\n  }","id":93261,"modified_method":"private void doComplete(final int invocationCount, CompletionInitializationContext initContext) {\n    final Editor editor = initContext.getEditor();\n\n    final CompletionParameters parameters = createCompletionParameters(invocationCount, initContext);\n\n    final LookupImpl lookup = obtainLookup(editor);\n\n    final Semaphore freezeSemaphore = new Semaphore();\n    freezeSemaphore.down();\n    final CompletionProgressIndicator indicator = new CompletionProgressIndicator(editor, parameters, this, freezeSemaphore,\n                                                                                  initContext.getOffsetMap(), lookup);\n\n    boolean sync =\n      (invokedExplicitly || ApplicationManager.getApplication().isUnitTestMode()) && !CompletionAutoPopupHandler.ourTestingAutopopup;\n\n    CompletionServiceImpl.setCompletionPhase(sync ? new CompletionPhase.Synchronous(indicator) : new CompletionPhase.BgCalculation(indicator));\n\n    final AtomicReference<LookupElement[]> data = startCompletionThread(parameters, indicator, initContext);\n\n    if (!sync) {\n      return;\n    }\n\n    if (freezeSemaphore.waitFor(2000)) {\n      final LookupElement[] allItems = data.get();\n      if (allItems != null) { // the completion is really finished, now we may auto-insert or show lookup\n        completionFinished(initContext.getStartOffset(), initContext.getSelectionEndOffset(), indicator, allItems);\n        return;\n      }\n    }\n\n    CompletionServiceImpl.setCompletionPhase(new CompletionPhase.BgCalculation(indicator));\n    indicator.showLookup();\n  }","commit_id":"4e1d945e64e026db45d99131b0f6bb385575eab5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void stop() {\n    super.stop();\n\n    myQueue.cancelAllUpdates();\n    myFreezeSemaphore.up();\n\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        final CompletionPhase phase = CompletionServiceImpl.getCompletionPhase();\n        if (!(phase instanceof CompletionPhase.BgCalculation) || phase.indicator != CompletionProgressIndicator.this) return;\n\n        myLookup.setCalculating(false);\n\n        if (hideAutopopupIfMeaningless()) {\n          return;\n        }\n\n        if (myState.hasNoVariants()) {\n          if (!isAutopopupCompletion()) {\n            LookupManager.getInstance(getProject()).hideActiveLookup();\n\n            final CompletionProgressIndicator current = CompletionServiceImpl.getCompletionService().getCurrentCompletion();\n            LOG.assertTrue(current == null, current + \"!=\" + CompletionProgressIndicator.this);\n\n            handleEmptyLookup();\n          }\n        }\n        else {\n          if (myState.isFocusLookupWhenDone()) {\n            myLookup.setFocused(true);\n          }\n          updateLookup();\n          CompletionServiceImpl.setCompletionPhase(new CompletionPhase.ItemsCalculated(CompletionProgressIndicator.this));\n        }\n      }\n    }, myQueue.getModalityState());\n  }","id":93262,"modified_method":"public void stop() {\n    super.stop();\n\n    myQueue.cancelAllUpdates();\n    myFreezeSemaphore.up();\n\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        final CompletionPhase phase = CompletionServiceImpl.getCompletionPhase();\n        if (!(phase instanceof CompletionPhase.BgCalculation) || phase.indicator != CompletionProgressIndicator.this) return;\n\n        myLookup.setCalculating(false);\n\n        if (hideAutopopupIfMeaningless()) {\n          return;\n        }\n\n        if (myState.hasNoVariants()) {\n          if (!isAutopopupCompletion()) {\n            LookupManager.getInstance(getProject()).hideActiveLookup();\n\n            final CompletionProgressIndicator current = CompletionServiceImpl.getCompletionService().getCurrentCompletion();\n            LOG.assertTrue(current == null, current + \"!=\" + CompletionProgressIndicator.this);\n\n            handleEmptyLookup();\n          }\n        }\n        else {\n          CompletionServiceImpl.setCompletionPhase(new CompletionPhase.ItemsCalculated(CompletionProgressIndicator.this));\n          updateLookup();\n        }\n      }\n    }, myQueue.getModalityState());\n  }","commit_id":"4e1d945e64e026db45d99131b0f6bb385575eab5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setFocusLookupWhenDone(boolean focusLookup) {\n    myState.setFocusLookupWhenDone(focusLookup);\n    if (!focusLookup && isAutopopupCompletion()) {\n      myLookup.setAdvertisementText(\"Press \" + CompletionContributor.getActionShortcut(IdeActions.ACTION_CHOOSE_LOOKUP_ITEM_REPLACE) + \" to choose the first suggestion\");\n    }\n  }","id":93263,"modified_method":"public void setFocusLookupWhenDone(boolean focusLookup) {\n    LOG.assertTrue(isAutopopupCompletion());\n    if (focusLookup) {\n      ((CompletionPhase.BgCalculation)CompletionServiceImpl.getCompletionPhase()).focusLookupWhenDone();\n    } else {\n      myLookup.setAdvertisementText(\"Press \" +\n                                    CompletionContributor.getActionShortcut(IdeActions.ACTION_CHOOSE_LOOKUP_ITEM_REPLACE) +\n                                    \" to choose the first suggestion\");\n    }\n  }","commit_id":"4e1d945e64e026db45d99131b0f6bb385575eab5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String toString() {\n    return \"CompletionState{\" +\n           \"phase=\" + CompletionServiceImpl.getCompletionPhase() +\n           \", myCompletionDisposed=\" + myCompletionDisposed +\n           \", myShownLookup=\" + myShownLookup +\n           \", myModifiersReleased=\" + myModifiersChanged +\n           \", myFocusLookupWhenDone=\" + myFocusLookupWhenDone +\n           \", myCount=\" + myCount +\n           '}';\n  }","id":93264,"modified_method":"@Override\n  public String toString() {\n    return \"CompletionState{\" +\n           \"phase=\" + CompletionServiceImpl.getCompletionPhase() +\n           \", myCompletionDisposed=\" + myCompletionDisposed +\n           \", myShownLookup=\" + myShownLookup +\n           \", myModifiersReleased=\" + myModifiersChanged +\n           \", myCount=\" + myCount +\n           '}';\n  }","commit_id":"4e1d945e64e026db45d99131b0f6bb385575eab5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void checkAccessStaticMemberViaInstanceReference(PsiReferenceExpression expr, ProblemsHolder holder, boolean onTheFly) {\n    JavaResolveResult result = expr.advancedResolve(false);\n    PsiElement resolved = result.getElement();\n\n    if (!(resolved instanceof PsiMember)) return;\n    PsiExpression qualifierExpression = expr.getQualifierExpression();\n    if (qualifierExpression == null) return;\n\n    if (qualifierExpression instanceof PsiReferenceExpression) {\n      final PsiElement qualifierResolved = ((PsiReferenceExpression)qualifierExpression).resolve();\n      if (qualifierResolved instanceof PsiClass || qualifierResolved instanceof PsiPackage) {\n        return;\n      }\n    }\n    if (!((PsiMember)resolved).hasModifierProperty(PsiModifier.STATIC)) return;\n\n    String description = JavaErrorMessages.message(\"static.member.accessed.via.instance.reference\",\n                                                   JavaHighlightUtil.formatType(qualifierExpression.getType()),\n                                                   HighlightMessageUtil.getSymbolName(resolved, result.getSubstitutor()));\n    if (!onTheFly) {\n      if (RemoveUnusedVariableUtil.checkSideEffects(qualifierExpression, null, new ArrayList<PsiElement>())) {\n        holder.registerProblem(expr, description);\n        return;\n      }\n    }\n    holder.registerProblem(expr, description, new AccessStaticViaInstanceFix(expr, result, onTheFly));\n  }","id":93265,"modified_method":"@Override\n  protected AccessStaticViaInstanceFix createAccessStaticViaInstanceFix(PsiReferenceExpression expr,\n                                                                        boolean onTheFly,\n                                                                        JavaResolveResult result) {\n    return new AccessStaticViaInstanceFix(expr, result, onTheFly);\n  }","commit_id":"853c6c22e62d45a0f3a157635cd0da0f06ed9c01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean checkSideEffects(final Project project, PsiClass containingClass, final PsiExpression qualifierExpression,\n                                   PsiElementFactory factory, final PsiElement myExpression) {\n    final List<PsiElement> sideEffects = new ArrayList<PsiElement>();\n    boolean hasSideEffects = RemoveUnusedVariableUtil.checkSideEffects(qualifierExpression, null, sideEffects);\n    if (hasSideEffects && !myOnTheFly) return false;\n    if (hasSideEffects && !ApplicationManager.getApplication().isUnitTestMode()) {\n      final TextAttributes attributes = EditorColorsManager.getInstance().getGlobalScheme().getAttributes(EditorColors.SEARCH_RESULT_ATTRIBUTES);\n      final Editor editor = PlatformDataKeys.EDITOR.getData(DataManager.getInstance().getDataContext());\n      if (editor == null) {\n        return false;\n      }\n      HighlightManager.getInstance(project).addOccurrenceHighlights(editor, PsiUtilCore.toPsiElementArray(sideEffects), attributes, true,\n                                                                    null);\n      try {\n        hasSideEffects = PsiUtil.isStatement(factory.createStatementFromText(qualifierExpression.getText(), qualifierExpression));\n      }\n      catch (IncorrectOperationException e) {\n        hasSideEffects = false;\n      }\n      final PsiReferenceExpression qualifiedWithClassName = (PsiReferenceExpression)myExpression.copy();\n      qualifiedWithClassName.setQualifierExpression(factory.createReferenceExpression(containingClass));\n      final boolean canCopeWithSideEffects = hasSideEffects;\n      final SideEffectWarningDialog dialog =\n        new SideEffectWarningDialog(project, false, null, sideEffects.get(0).getText(), PsiExpressionTrimRenderer.render(qualifierExpression),\n                                    canCopeWithSideEffects){\n          @Override\n          protected String sideEffectsDescription() {\n            if (canCopeWithSideEffects) {\n              return \"<html><body>\" +\n                     \"  There are possible side effects found in expression '\" +\n                     qualifierExpression.getText() +\n                     \"'<br>\" +\n                     \"  You can:<ul><li><b>Remove<\/b> class reference along with whole expressions involved, or<\/li>\" +\n                     \"  <li><b>Transform<\/b> qualified expression into the statement on its own.<br>\" +\n                     \"  That is,<br>\" +\n                     \"  <table border=1><tr><td><code>\" +\n                     myExpression.getText() +\n                     \"<\/code><\/td><\/tr><\/table><br> becomes: <br>\" +\n                     \"  <table border=1><tr><td><code>\" +\n                     qualifierExpression.getText() +\n                     \";<br>\" +\n                     qualifiedWithClassName.getText() +\n                     \"       <\/code><\/td><\/tr><\/table><\/li>\" +\n                     \"  <\/body><\/html>\";\n            } else {\n              return \"<html><body>  There are possible side effects found in expression '\" + qualifierExpression.getText() + \"'<br>\" +\n                     \"You can:<ul><li><b>Remove<\/b> class reference along with whole expressions involved, or<\/li><\/body><\/html>\";\n            }\n          }\n        };\n      dialog.show();\n      int res = dialog.getExitCode();\n      if (res == RemoveUnusedVariableUtil.CANCEL) return false;\n      try {\n        if (res == RemoveUnusedVariableUtil.MAKE_STATEMENT) {\n          final PsiStatement statementFromText = factory.createStatementFromText(qualifierExpression.getText() + \";\", null);\n          final PsiStatement statement = PsiTreeUtil.getParentOfType(myExpression, PsiStatement.class);\n          statement.getParent().addBefore(statementFromText, statement);\n        }\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n    }\n    return true;\n  }","id":93266,"modified_method":"private boolean checkSideEffects(final Project project,\n                                   PsiClass containingClass,\n                                   final PsiExpression qualifierExpression,\n                                   PsiElementFactory factory,\n                                   final PsiElement myExpression,\n                                   Editor editor) {\n    final List<PsiElement> sideEffects = new ArrayList<PsiElement>();\n    boolean hasSideEffects = RemoveUnusedVariableUtil.checkSideEffects(qualifierExpression, null, sideEffects);\n    if (hasSideEffects && !myOnTheFly) return false;\n    if (!hasSideEffects || ApplicationManager.getApplication().isUnitTestMode()) {\n      return true;\n    }\n    if (editor == null) {\n      return false;\n    }\n    TextAttributes attributes = EditorColorsManager.getInstance().getGlobalScheme().getAttributes(EditorColors.SEARCH_RESULT_ATTRIBUTES);\n    HighlightManager.getInstance(project).addOccurrenceHighlights(editor, PsiUtilCore.toPsiElementArray(sideEffects), attributes, true, null);\n    try {\n      hasSideEffects = PsiUtil.isStatement(factory.createStatementFromText(qualifierExpression.getText(), qualifierExpression));\n    }\n    catch (IncorrectOperationException e) {\n      hasSideEffects = false;\n    }\n    final PsiReferenceExpression qualifiedWithClassName = (PsiReferenceExpression)myExpression.copy();\n    qualifiedWithClassName.setQualifierExpression(factory.createReferenceExpression(containingClass));\n    final boolean canCopeWithSideEffects = hasSideEffects;\n    final SideEffectWarningDialog dialog =\n      new SideEffectWarningDialog(project, false, null, sideEffects.get(0).getText(), PsiExpressionTrimRenderer.render(qualifierExpression),\n                                  canCopeWithSideEffects){\n        @Override\n        protected String sideEffectsDescription() {\n          if (canCopeWithSideEffects) {\n            return \"<html><body>\" +\n                   \"  There are possible side effects found in expression '\" +\n                   qualifierExpression.getText() +\n                   \"'<br>\" +\n                   \"  You can:<ul><li><b>Remove<\/b> class reference along with whole expressions involved, or<\/li>\" +\n                   \"  <li><b>Transform<\/b> qualified expression into the statement on its own.<br>\" +\n                   \"  That is,<br>\" +\n                   \"  <table border=1><tr><td><code>\" +\n                   myExpression.getText() +\n                   \"<\/code><\/td><\/tr><\/table><br> becomes: <br>\" +\n                   \"  <table border=1><tr><td><code>\" +\n                   qualifierExpression.getText() +\n                   \";<br>\" +\n                   qualifiedWithClassName.getText() +\n                   \"       <\/code><\/td><\/tr><\/table><\/li>\" +\n                   \"  <\/body><\/html>\";\n          }\n          return \"<html><body>  There are possible side effects found in expression '\" + qualifierExpression.getText() + \"'<br>\" +\n                 \"You can:<ul><li><b>Remove<\/b> class reference along with whole expressions involved, or<\/li><\/body><\/html>\";\n        }\n      };\n    dialog.show();\n    int res = dialog.getExitCode();\n    if (res == RemoveUnusedVariableUtil.CANCEL) return false;\n    try {\n      if (res == RemoveUnusedVariableUtil.MAKE_STATEMENT) {\n        final PsiStatement statementFromText = factory.createStatementFromText(qualifierExpression.getText() + \";\", null);\n        final PsiStatement statement = PsiTreeUtil.getParentOfType(myExpression, PsiStatement.class);\n        statement.getParent().addBefore(statementFromText, statement);\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    return true;\n  }","commit_id":"853c6c22e62d45a0f3a157635cd0da0f06ed9c01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateResults(boolean allowedToChangedEditorSelection) {\n    removeCurrentHighlights();\n    myMatchInfoLabel.setFont(myMatchInfoLabel.getFont().deriveFont(Font.PLAIN));\n    String text = mySearchField.getText();\n    if (text.length() == 0) {\n      setRegularBackground();\n      myMatchInfoLabel.setText(\"\");\n      myClickToHighlightLabel.setVisible(false);\n      myOkToSearch = false;\n    }\n    else {\n      myOkToSearch = true;\n      FindManager findManager = FindManager.getInstance(myProject);\n      FindModel model = new FindModel();\n      model.setCaseSensitive(isCaseSensitive());\n      model.setInCommentsOnly(isInComments());\n      model.setInStringLiteralsOnly(isInLiterals());\n\n      if (isRegexp()) {\n        model.setWholeWordsOnly(false);\n        model.setRegularExpressions(true);\n        try {\n          Pattern.compile(text);\n        }\n        catch (Exception e) {\n          myOkToSearch = false;\n          setNotFoundBackground();\n          myClickToHighlightLabel.setVisible(false);\n          myMatchInfoLabel.setText(\"Incorrect regular expression\");\n          boldMatchInfo();\n          return;\n        }\n      }\n      else {\n        model.setWholeWordsOnly(isWholeWords());\n        model.setRegularExpressions(false);\n      }\n\n      model.setFromCursor(false);\n      model.setStringToFind(text);\n      model.setSearchHighlighters(true);\n      int offset = 0;\n      VirtualFile virtualFile = FindUtil.getVirtualFile(myEditor);\n      ArrayList<FindResult> results = new ArrayList<FindResult>();\n\n      while (true) {\n        FindResult result = findManager.findString(myEditor.getDocument().getCharsSequence(), offset, model, virtualFile);\n        if (!result.isStringFound()) break;\n        int newOffset = result.getEndOffset();\n        if (offset == newOffset) break;\n        offset = newOffset;\n        results.add(result);\n\n        if (results.size() > myMatchesLimit) break;\n      }\n\n      if (allowedToChangedEditorSelection) {\n        int currentOffset = myEditor.getCaretModel().getOffset();\n        if (myEditor.getSelectionModel().hasSelection()) {\n          currentOffset = Math.min(currentOffset, myEditor.getSelectionModel().getSelectionStart());\n        }\n\n        if (!findAndSelectFirstUsage(findManager, model, currentOffset, virtualFile)) {\n          findAndSelectFirstUsage(findManager, model, 0, virtualFile);\n        }\n      }\n\n      final int count = results.size();\n      if (count <= myMatchesLimit) {\n        myClickToHighlightLabel.setVisible(false);\n        highlightResults(text, results);\n\n        if (count > 0) {\n          setRegularBackground();\n          if (count > 1) {\n            myMatchInfoLabel.setText(count + \" matches\");\n          }\n          else {\n            myMatchInfoLabel.setText(\"1 match\");\n          }\n        }\n        else {\n          setNotFoundBackground();\n          myMatchInfoLabel.setText(\"No matches\");\n        }\n      }\n      else {\n        setRegularBackground();\n        myMatchInfoLabel.setText(\"More than 100 matches\");\n        myClickToHighlightLabel.setVisible(true);\n        boldMatchInfo();\n      }\n\n      if (allowedToChangedEditorSelection) {\n        findManager.setFindWasPerformed();\n        findManager.setFindNextModel(model);\n      }\n    }\n  }","id":93267,"modified_method":"private void updateResults(boolean allowedToChangedEditorSelection) {\n    removeCurrentHighlights();\n    myMatchInfoLabel.setFont(myMatchInfoLabel.getFont().deriveFont(Font.PLAIN));\n    String text = mySearchField.getText();\n    if (text.length() == 0) {\n      setRegularBackground();\n      myMatchInfoLabel.setText(\"\");\n      myClickToHighlightLabel.setVisible(false);\n      myOkToSearch = false;\n    }\n    else {\n      myOkToSearch = true;\n      FindManager findManager = FindManager.getInstance(myProject);\n      FindModel model = new FindModel();\n      model.setCaseSensitive(isCaseSensitive());\n      model.setInCommentsOnly(isInComments());\n      model.setInStringLiteralsOnly(isInLiterals());\n\n      if (isRegexp()) {\n        model.setWholeWordsOnly(false);\n        model.setRegularExpressions(true);\n        try {\n          Pattern.compile(text);\n        }\n        catch (Exception e) {\n          myOkToSearch = false;\n          setNotFoundBackground();\n          myClickToHighlightLabel.setVisible(false);\n          myMatchInfoLabel.setText(\"Incorrect regular expression\");\n          boldMatchInfo();\n          return;\n        }\n      }\n      else {\n        model.setWholeWordsOnly(isWholeWords());\n        model.setRegularExpressions(false);\n      }\n\n      model.setFromCursor(false);\n      model.setStringToFind(text);\n      model.setSearchHighlighters(true);\n      int offset = 0;\n      VirtualFile virtualFile = FindUtil.getVirtualFile(myEditor);\n      ArrayList<FindResult> results = new ArrayList<FindResult>();\n\n      CharSequence charsSequence = myEditor.getDocument().getCharsSequence();\n      while (true) {\n        FindResult result = findManager.findString(charsSequence, offset, model, virtualFile);\n        if (!result.isStringFound()) break;\n        int newOffset = result.getEndOffset();\n        if (offset == newOffset) {\n          ++offset;\n          if (offset == charsSequence.length()) break;\n        }\n        else {\n          offset = newOffset;\n          results.add(result);\n        }\n\n        if (results.size() > myMatchesLimit) break;\n      }\n\n      if (allowedToChangedEditorSelection) {\n        int currentOffset = myEditor.getCaretModel().getOffset();\n        if (myEditor.getSelectionModel().hasSelection()) {\n          currentOffset = Math.min(currentOffset, myEditor.getSelectionModel().getSelectionStart());\n        }\n\n        if (!findAndSelectFirstUsage(findManager, model, currentOffset, virtualFile)) {\n          findAndSelectFirstUsage(findManager, model, 0, virtualFile);\n        }\n      }\n\n      final int count = results.size();\n      if (count <= myMatchesLimit) {\n        myClickToHighlightLabel.setVisible(false);\n        highlightResults(text, results);\n\n        if (count > 0) {\n          setRegularBackground();\n          if (count > 1) {\n            myMatchInfoLabel.setText(count + \" matches\");\n          }\n          else {\n            myMatchInfoLabel.setText(\"1 match\");\n          }\n        }\n        else {\n          setNotFoundBackground();\n          myMatchInfoLabel.setText(\"No matches\");\n        }\n      }\n      else {\n        setRegularBackground();\n        myMatchInfoLabel.setText(\"More than 100 matches\");\n        myClickToHighlightLabel.setVisible(true);\n        boldMatchInfo();\n      }\n\n      if (allowedToChangedEditorSelection) {\n        findManager.setFindWasPerformed();\n        findManager.setFindNextModel(model);\n      }\n    }\n  }","commit_id":"86fbb384fbd545189b38466d4fe7f98656e046c1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void highlightUsages() {\n    if (mySearchResults.getEditor() == null) return;\n    if (mySearchResults.getMatchesCount() >= mySearchResults.getMatchesLimit())\n      return;\n    for (LiveOccurrence o : mySearchResults.getOccurrences()) {\n      for (TextRange textRange : o.getSecondaryRanges()) {\n        highlightRange(textRange, OTHER_TARGETS_ATTRIBUTES, myHighlighters);\n      }\n      final TextRange range = o.getPrimaryRange();\n\n      TextAttributes attributes = EditorColorsManager.getInstance().getGlobalScheme().getAttributes(EditorColors.TEXT_SEARCH_RESULT_ATTRIBUTES);\n\n      if (mySearchResults.isExcluded(o)) {\n        highlightRange(range, strikout(attributes), myHighlighters);\n      } else {\n        highlightRange(range, attributes, myHighlighters);\n      }\n    }\n    updateInSelectionHighlighters();\n    if (!myListeningSelection) {\n      mySearchResults.getEditor().getSelectionModel().addSelectionListener(this);\n      myListeningSelection = true;\n    }\n\n  }","id":93268,"modified_method":"private void highlightUsages() {\n    if (mySearchResults.getEditor() == null) return;\n    if (mySearchResults.getMatchesCount() >= mySearchResults.getMatchesLimit())\n      return;\n    for (LiveOccurrence o : mySearchResults.getOccurrences()) {\n      for (TextRange textRange : o.getSecondaryRanges()) {\n        highlightRange(textRange, OTHER_TARGETS_ATTRIBUTES, myHighlighters);\n      }\n      final TextRange range = o.getPrimaryRange();\n\n      TextAttributes attributes = EditorColorsManager.getInstance().getGlobalScheme().getAttributes(EditorColors.TEXT_SEARCH_RESULT_ATTRIBUTES);\n      if (range.getLength() == 0) {\n        attributes = attributes.clone();\n        attributes.setEffectType(EffectType.BOXED);\n        attributes.setEffectColor(attributes.getBackgroundColor());\n      }\n      if (mySearchResults.isExcluded(o)) {\n        highlightRange(range, strikout(attributes), myHighlighters);\n      } else {\n        highlightRange(range, attributes, myHighlighters);\n      }\n    }\n    updateInSelectionHighlighters();\n    if (!myListeningSelection) {\n      mySearchResults.getEditor().getSelectionModel().addSelectionListener(this);\n      myListeningSelection = true;\n    }\n\n  }","commit_id":"afde44c719e55fff86f4a536add705e311fe739b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void findInRange(TextRange r, Editor editor, FindModel findModel, ArrayList<FindResult> results) {\n    VirtualFile virtualFile = FileDocumentManager.getInstance().getFile(editor.getDocument());\n\n    int offset = r.getStartOffset();\n\n    while (true) {\n      FindManager findManager = FindManager.getInstance(getProject());\n      FindResult result;\n      try {\n        CharSequence bombedCharSequence = StringUtil.newBombedCharSequence(editor.getDocument().getCharsSequence(), 3000);\n        result = findManager.findString(bombedCharSequence, offset, findModel, virtualFile);\n      } catch(PatternSyntaxException e) {\n        result = null;\n      } catch (ProcessCanceledException e) {\n        result = null;\n      }\n      if (result == null || !result.isStringFound()) break;\n      int newOffset = result.getEndOffset();\n      if (offset == newOffset || result.getEndOffset() > r.getEndOffset()) break;\n      offset = newOffset;\n      results.add(result);\n    }\n  }","id":93269,"modified_method":"private void findInRange(TextRange r, Editor editor, FindModel findModel, ArrayList<FindResult> results) {\n    VirtualFile virtualFile = FileDocumentManager.getInstance().getFile(editor.getDocument());\n\n    CharSequence charSequence = editor.getDocument().getCharsSequence();\n\n    int offset = r.getStartOffset();\n    int maxOffset = Math.min(r.getEndOffset(), charSequence.length());\n    FindManager findManager = FindManager.getInstance(getProject());\n\n    while (true) {\n      FindResult result;\n      try {\n        CharSequence bombedCharSequence = StringUtil.newBombedCharSequence(charSequence, 3000);\n        result = findManager.findString(bombedCharSequence, offset, findModel, virtualFile);\n      } catch(PatternSyntaxException e) {\n        result = null;\n      } catch (ProcessCanceledException e) {\n        result = null;\n      }\n      if (result == null || !result.isStringFound()) break;\n      int newOffset = result.getEndOffset();\n      if (result.getEndOffset() > maxOffset) break;\n      if (offset == newOffset) {\n        if (offset < maxOffset - 1) {\n          offset++;\n        } else {\n          results.add(result);\n          break;\n        }\n      } else {\n        offset = newOffset;\n      }\n      results.add(result);\n    }\n  }","commit_id":"afde44c719e55fff86f4a536add705e311fe739b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private LiveOccurrence firstOccurrenceAfterOffset(int offset) {\n    LiveOccurrence afterCaret = null;\n    for (LiveOccurrence occurrence : getOccurrences()) {\n      if (occurrence.getPrimaryRange().getStartOffset() >= offset) {\n        if (afterCaret == null || occurrence.getPrimaryRange().getStartOffset() < afterCaret.getPrimaryRange().getStartOffset() ) {\n          afterCaret = occurrence;\n        }\n      }\n    }\n    return afterCaret;\n  }","id":93270,"modified_method":"@Nullable\n  private LiveOccurrence firstOccurrenceAfterOffset(int offset) {\n    LiveOccurrence afterCaret = null;\n    for (LiveOccurrence occurrence : getOccurrences()) {\n      if (occurrence.getPrimaryRange().getStartOffset() >= offset && occurrence.getPrimaryRange().getEndOffset() > offset) {\n        if (afterCaret == null || occurrence.getPrimaryRange().getStartOffset() < afterCaret.getPrimaryRange().getStartOffset() ) {\n          afterCaret = occurrence;\n        }\n      }\n    }\n    return afterCaret;\n  }","commit_id":"afde44c719e55fff86f4a536add705e311fe739b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean handleRParen(Editor editor, FileType fileType, char charTyped) {\n    if (!CodeInsightSettings.getInstance().AUTOINSERT_PAIR_BRACKET) return false;\n\n    int offset = editor.getCaretModel().getOffset();\n\n    if (offset == editor.getDocument().getTextLength()) return false;\n\n    HighlighterIterator iterator = ((EditorEx) editor).getHighlighter().createIterator(offset);\n    if (iterator.atEnd()) return false;\n\n    Language language = iterator.getTokenType().getLanguage();\n    final ParserDefinition definition = LanguageParserDefinitions.INSTANCE.forLanguage(language);\n    if (definition != null && !(language instanceof TemplateLanguage)) {\n      final Lexer lexer = definition.createLexer(editor.getProject());\n      lexer.start(Character.toString(charTyped));\n      final IElementType tokenType = lexer.getTokenType();\n      if (tokenType != iterator.getTokenType()) {\n        return false;        \n      }\n    }\n\n    BraceMatcher braceMatcher = BraceMatchingUtil.getBraceMatcher(fileType, iterator);\n    if (!braceMatcher.isRBraceToken(iterator, editor.getDocument().getCharsSequence(), fileType)) {\n      return false;\n    }\n\n    IElementType tokenType = iterator.getTokenType();\n    \n    iterator.retreat();\n\n    int lparenthOffset = BraceMatchingUtil.findLeftmostLParen(iterator, braceMatcher.getOppositeBraceTokenType(tokenType),  editor.getDocument().getCharsSequence(),fileType);\n    if (lparenthOffset < 0) return false;\n\n    iterator = ((EditorEx) editor).getHighlighter().createIterator(lparenthOffset);\n    boolean matched = BraceMatchingUtil.matchBrace(editor.getDocument().getCharsSequence(), fileType, iterator, true);\n\n    if (!matched) return false;\n\n    editor.getCaretModel().moveToOffset(offset + 1);\n    editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    return true;\n  }","id":93271,"modified_method":"public static boolean handleRParen(Editor editor, FileType fileType, char charTyped) {\n    if (!CodeInsightSettings.getInstance().AUTOINSERT_PAIR_BRACKET) return false;\n\n    int offset = editor.getCaretModel().getOffset();\n\n    if (offset == editor.getDocument().getTextLength()) return false;\n\n    HighlighterIterator iterator = ((EditorEx) editor).getHighlighter().createIterator(offset);\n    if (iterator.atEnd()) return false;\n\n    Language language = iterator.getTokenType().getLanguage();\n    final ParserDefinition definition = LanguageParserDefinitions.INSTANCE.forLanguage(language);\n    if (definition != null && !(language instanceof TemplateLanguage)) {\n      final Lexer lexer = definition.createLexer(editor.getProject());\n      lexer.start(Character.toString(charTyped));\n      final IElementType tokenType = lexer.getTokenType();\n      if (tokenType != iterator.getTokenType()) {\n        return false;        \n      }\n    }\n\n    BraceMatcher braceMatcher = BraceMatchingUtil.getBraceMatcher(fileType, iterator);\n    CharSequence text = editor.getDocument().getCharsSequence();\n    if (!braceMatcher.isRBraceToken(iterator, text, fileType)) {\n      return false;\n    }\n\n    IElementType tokenType = iterator.getTokenType();\n    \n    iterator.retreat();\n\n    IElementType lparenTokenType = braceMatcher.getOppositeBraceTokenType(tokenType);\n    int lparenthOffset = BraceMatchingUtil.findLeftmostLParen(\n      iterator,\n      lparenTokenType,\n      text,\n      fileType\n    );\n\n    if (lparenthOffset < 0) {\n      if (braceMatcher instanceof NontrivialBraceMatcher) {\n        for(IElementType t:((NontrivialBraceMatcher)braceMatcher).getOppositeBraceTokenTypes(tokenType)) {\n          if (t == lparenTokenType) continue;\n          lparenthOffset = BraceMatchingUtil.findLeftmostLParen(\n            iterator,\n            t, text,\n            fileType\n          );\n          if (lparenthOffset >= 0) break;\n        }\n      }\n      if (lparenthOffset < 0) return false;\n    }\n\n    iterator = ((EditorEx) editor).getHighlighter().createIterator(lparenthOffset);\n    boolean matched = BraceMatchingUtil.matchBrace(text, fileType, iterator, true);\n\n    if (!matched) return false;\n\n    editor.getCaretModel().moveToOffset(offset + 1);\n    editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    return true;\n  }","commit_id":"c644170251e3148637b1032d718f0dec2fe36236","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Tests writing of request content when @src is set.\n   * @throws IOException I/O Exception\n   */\n  @Test\n  public void writeFromResource() throws IOException {\n    // Create a file form which will be read\n    final IOFile file = new IOFile(Prop.TMP, Util.className(FnHttpTest.class));\n    file.write(token(\"test\"));\n\n    // Request\n    final HttpRequest req = new HttpRequest();\n    req.payloadAttrs.put(\"src\", file.url());\n    req.payloadAttrs.put(\"method\", \"binary\");\n    // HTTP connection\n    final FakeHttpConnection fakeConn = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    HttpClient.setRequestContent(fakeConn.getOutputStream(), req);\n\n    // Delete file\n    file.delete();\n\n    assertEquals(fakeConn.out.toString(Strings.UTF8), \"test\");\n  }","id":93272,"modified_method":"/**\n   * Tests writing of request content when @src is set.\n   * @throws IOException I/O Exception\n   */\n  @Test\n  public void writeFromResource() throws IOException {\n    // Create a file form which will be read\n    final IOFile file = new IOFile(Prop.TMP, Util.className(FnHttpTest.class));\n    file.write(token(\"test\"));\n\n    // Request\n    final HttpRequest req = new HttpRequest();\n    req.payloadAtts.put(\"src\", file.url());\n    req.payloadAtts.put(\"method\", \"binary\");\n    // HTTP connection\n    final FakeHttpConnection fakeConn = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    HttpClient.setRequestContent(fakeConn.getOutputStream(), req);\n\n    // Delete file\n    file.delete();\n\n    assertEquals(fakeConn.out.toString(Strings.UTF8), \"test\");\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests writing of body content when @method is raw and output is xs:base64Binary.\n   * @throws IOException I/O Exception\n   */\n  @Test\n  public void writeBase64() throws IOException {\n    // Case 1: content is xs:base64Binary\n    final HttpRequest req1 = new HttpRequest();\n    req1.payloadAttrs.put(\"method\", SerialMethod.BASEX.toString());\n    req1.bodyContent.add(new B64(token(\"test\")));\n    final FakeHttpConnection fakeConn1 = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    HttpClient.setRequestContent(fakeConn1.getOutputStream(), req1);\n    assertEquals(fakeConn1.out.toString(Strings.UTF8), \"test\");\n\n    // Case 2: content is a node\n    final HttpRequest req2 = new HttpRequest();\n    req2.payloadAttrs.put(\"method\", SerialMethod.BASEX.toString());\n    final FElem e3 = new FElem(\"a\").add(\"test\");\n    req2.bodyContent.add(e3);\n    final FakeHttpConnection fakeConn2 = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    HttpClient.setRequestContent(fakeConn2.getOutputStream(), req2);\n    assertEquals(\"<a>test<\/a>\", fakeConn2.out.toString());\n  }","id":93273,"modified_method":"/**\n   * Tests writing of body content when @method is raw and output is xs:base64Binary.\n   * @throws IOException I/O Exception\n   */\n  @Test\n  public void writeBase64() throws IOException {\n    // Case 1: content is xs:base64Binary\n    final HttpRequest req1 = new HttpRequest();\n    req1.payloadAtts.put(\"method\", SerialMethod.BASEX.toString());\n    req1.bodyContent.add(new B64(token(\"test\")));\n    final FakeHttpConnection fakeConn1 = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    HttpClient.setRequestContent(fakeConn1.getOutputStream(), req1);\n    assertEquals(fakeConn1.out.toString(Strings.UTF8), \"test\");\n\n    // Case 2: content is a node\n    final HttpRequest req2 = new HttpRequest();\n    req2.payloadAtts.put(\"method\", SerialMethod.BASEX.toString());\n    final FElem e3 = new FElem(\"a\").add(\"test\");\n    req2.bodyContent.add(e3);\n    final FakeHttpConnection fakeConn2 = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    HttpClient.setRequestContent(fakeConn2.getOutputStream(), req2);\n    assertEquals(\"<a>test<\/a>\", fakeConn2.out.toString());\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests writing of body content when @method is raw and output is xs:hexBinary.\n   * @throws IOException I/O Exception\n   */\n  @Test\n  public void writeHex() throws IOException {\n    // Case 1: content is xs:hexBinary\n    final HttpRequest req1 = new HttpRequest();\n    req1.payloadAttrs.put(\"method\", SerialMethod.BASEX.toString());\n    req1.bodyContent.add(new Hex(token(\"test\")));\n    final FakeHttpConnection fakeConn1 = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    HttpClient.setRequestContent(fakeConn1.getOutputStream(), req1);\n    assertEquals(fakeConn1.out.toString(Strings.UTF8), \"test\");\n\n    // Case 2: content is a node\n    final HttpRequest req2 = new HttpRequest();\n    req2.payloadAttrs.put(\"method\", SerialMethod.BASEX.toString());\n    final FElem e3 = new FElem(\"a\").add(\"test\");\n    req2.bodyContent.add(e3);\n    final FakeHttpConnection fakeConn2 = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    HttpClient.setRequestContent(fakeConn2.getOutputStream(), req2);\n    assertEquals(\"<a>test<\/a>\", fakeConn2.out.toString());\n  }","id":93274,"modified_method":"/**\n   * Tests writing of body content when @method is raw and output is xs:hexBinary.\n   * @throws IOException I/O Exception\n   */\n  @Test\n  public void writeHex() throws IOException {\n    // Case 1: content is xs:hexBinary\n    final HttpRequest req1 = new HttpRequest();\n    req1.payloadAtts.put(\"method\", SerialMethod.BASEX.toString());\n    req1.bodyContent.add(new Hex(token(\"test\")));\n    final FakeHttpConnection fakeConn1 = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    HttpClient.setRequestContent(fakeConn1.getOutputStream(), req1);\n    assertEquals(fakeConn1.out.toString(Strings.UTF8), \"test\");\n\n    // Case 2: content is a node\n    final HttpRequest req2 = new HttpRequest();\n    req2.payloadAtts.put(\"method\", SerialMethod.BASEX.toString());\n    final FElem e3 = new FElem(\"a\").add(\"test\");\n    req2.bodyContent.add(e3);\n    final FakeHttpConnection fakeConn2 = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    HttpClient.setRequestContent(fakeConn2.getOutputStream(), req2);\n    assertEquals(\"<a>test<\/a>\", fakeConn2.out.toString());\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests ResponseHandler.getResponse() with multipart response having preamble and epilogue.\n   * @throws IOException I/O Exception\n   * @throws Exception exception\n   */\n  @Test\n  public void multipartRespPreamble() throws Exception {\n    // Create fake HTTP connection\n    final FakeHttpConnection conn = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    final Map<String, List<String>> hdrs = new HashMap<>();\n    final List<String> fromVal = new ArrayList<>();\n    fromVal.add(\"Nathaniel Borenstein <nsb@bellcore.com>\");\n    // From: Nathaniel Borenstein <nsb@bellcore.com>\n    hdrs.put(\"From\", fromVal);\n    final List<String> mimeVal = new ArrayList<>();\n    mimeVal.add(\"1.0\");\n    final List<String> toVal = new ArrayList<>();\n    toVal.add(\"Ned Freed <ned@innosoft.com>\");\n    // To: Ned Freed <ned@innosoft.com>\n    hdrs.put(\"To\", toVal);\n    // MIME-Version: 1.0\n    hdrs.put(\"MIME-version\", mimeVal);\n    final List<String> subjVal = new ArrayList<>();\n    subjVal.add(\"Formatted text mail\");\n    // Subject: Formatted text mail\n    hdrs.put(\"Subject\", subjVal);\n    final List<String> contTypeVal = new ArrayList<>();\n    contTypeVal.add(\"multipart/mixed\");\n    contTypeVal.add(\"boundary=\\\"simple boundary\\\"\");\n    // Content-Type: multipart/alternative; boundary=boundary42\n    hdrs.put(\"Content-Type\", contTypeVal);\n    conn.headers = hdrs;\n    conn.contentType = \"multipart/mixed; boundary=\\\"simple boundary\\\"\";\n    // Response to be read\n    conn.content = token(\"This is the preamble.  \"\n        + \"It is to be ignored, though it\" + NL\n        + \"is a handy place for mail composers to include an\" + CRLF\n        + \"explanatory note to non-MIME compliant readers.\" + CRLF\n        + \"--simple boundary\" + CRLF + CRLF\n        + \"This is implicitly typed plain ASCII text.\" + CRLF\n        + \"It does NOT end with a linebreak.\"\n        +  CRLF + \"--simple boundary\" + CRLF\n        + \"Content-type: text/plain; charset=us-ascii\" + CRLF + CRLF\n        + \"This is explicitly typed plain ASCII text.\" + CRLF\n        + \"It DOES end with a linebreak.\" + CRLF\n        +  CRLF + \"--simple boundary--\" + CRLF\n        + \"This is the epilogue.  It is also to be ignored.\");\n    // Get response as sequence of XQuery items\n    final ItemList returned = new HttpResponse(null, ctx.options).getResponse(conn, true, null);\n\n    // Construct expected result\n    final ItemList expected = new ItemList();\n    final String response = \"<http:response \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"status='200' message='OK'>\"\n        + \"<http:header name='Subject' value='Formatted text mail'/>\"\n        + \"<http:header name='To' value='Ned \"\n        + \"Freed &lt;ned@innosoft.com&gt;'/>\"\n        + \"<http:header name='Content-Type' value='multipart/mixed;\"\n        + \"boundary=&quot;simple boundary&quot;'/>\"\n        + \"<http:header name='MIME-version' value='1.0'/>\"\n        + \"<http:header name='From' value='Nathaniel Borenstein \"\n        + \"&lt;nsb@bellcore.com&gt;'/>\"\n        + \"<http:multipart media-type='multipart/mixed' \"\n        + \"boundary='simple boundary'>\"\n        + \"<http:body media-type='text/plain'/>\"\n        + \"<http:header name='Content-type' value='text/plain; \"\n        + \"charset=us-ascii'/>\"\n        + \"<http:body media-type='text/plain; charset=us-ascii'/>\"\n        + \"<\/http:multipart>\" + \"<\/http:response>\";\n    expected.add(new DBNode(new IOContent(response)).children().next());\n    expected.add(Str.get(\"This is implicitly typed plain ASCII text.\\n\"\n        + \"It does NOT end with a linebreak.\\n\"));\n    expected.add(Str.get(\"This is explicitly typed plain ASCII text.\\n\"\n        + \"It DOES end with a linebreak.\\n\\n\"));\n\n    compare(expected, returned);\n  }","id":93275,"modified_method":"/**\n   * Tests ResponseHandler.getResponse() with multipart response having preamble and epilogue.\n   * @throws IOException I/O Exception\n   * @throws Exception exception\n   */\n  @Test\n  public void multipartRespPreamble() throws Exception {\n    // Create fake HTTP connection\n    final FakeHttpConnection conn = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    final Map<String, List<String>> hdrs = new HashMap<>();\n    final List<String> fromVal = new ArrayList<>();\n    fromVal.add(\"Nathaniel Borenstein <nsb@bellcore.com>\");\n    // From: Nathaniel Borenstein <nsb@bellcore.com>\n    hdrs.put(\"From\", fromVal);\n    final List<String> mimeVal = new ArrayList<>();\n    mimeVal.add(\"1.0\");\n    final List<String> toVal = new ArrayList<>();\n    toVal.add(\"Ned Freed <ned@innosoft.com>\");\n    // To: Ned Freed <ned@innosoft.com>\n    hdrs.put(\"To\", toVal);\n    // MIME-Version: 1.0\n    hdrs.put(\"MIME-version\", mimeVal);\n    final List<String> subjVal = new ArrayList<>();\n    subjVal.add(\"Formatted text mail\");\n    // Subject: Formatted text mail\n    hdrs.put(\"Subject\", subjVal);\n    final List<String> contTypeVal = new ArrayList<>();\n    contTypeVal.add(\"multipart/mixed\");\n    contTypeVal.add(\"boundary=\\\"simple boundary\\\"\");\n    // Content-Type: multipart/alternative; boundary=boundary42\n    hdrs.put(\"Content-Type\", contTypeVal);\n    conn.headers = hdrs;\n    conn.contentType = \"multipart/mixed; boundary=\\\"simple boundary\\\"\";\n    // Response to be read\n    conn.content = token(\"This is the preamble.  \"\n        + \"It is to be ignored, though it\" + NL\n        + \"is a handy place for mail composers to include an\" + CRLF\n        + \"explanatory note to non-MIME compliant readers.\" + CRLF\n        + \"--simple boundary\" + CRLF + CRLF\n        + \"This is implicitly typed plain ASCII text.\" + CRLF\n        + \"It does NOT end with a linebreak.\"\n        +  CRLF + \"--simple boundary\" + CRLF\n        + \"Content-type: text/plain; charset=us-ascii\" + CRLF + CRLF\n        + \"This is explicitly typed plain ASCII text.\" + CRLF\n        + \"It DOES end with a linebreak.\" + CRLF\n        +  CRLF + \"--simple boundary--\" + CRLF\n        + \"This is the epilogue.  It is also to be ignored.\");\n    // Get response as sequence of XQuery items\n    final Value returned = new HttpResponse(null, ctx.options).getResponse(conn, true, null);\n\n    // Construct expected result\n    final ValueBuilder expected = new ValueBuilder();\n    final String response = \"<http:response \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"status='200' message='OK'>\"\n        + \"<http:header name='Subject' value='Formatted text mail'/>\"\n        + \"<http:header name='To' value='Ned \"\n        + \"Freed &lt;ned@innosoft.com&gt;'/>\"\n        + \"<http:header name='Content-Type' value='multipart/mixed;\"\n        + \"boundary=&quot;simple boundary&quot;'/>\"\n        + \"<http:header name='MIME-version' value='1.0'/>\"\n        + \"<http:header name='From' value='Nathaniel Borenstein \"\n        + \"&lt;nsb@bellcore.com&gt;'/>\"\n        + \"<http:multipart media-type='multipart/mixed' \"\n        + \"boundary='simple boundary'>\"\n        + \"<http:body media-type='text/plain'/>\"\n        + \"<http:header name='Content-type' value='text/plain; \"\n        + \"charset=us-ascii'/>\"\n        + \"<http:body media-type='text/plain; charset=us-ascii'/>\"\n        + \"<\/http:multipart>\" + \"<\/http:response>\";\n    expected.add(new DBNode(new IOContent(response)).children().next());\n    expected.add(Str.get(\"This is implicitly typed plain ASCII text.\\n\"\n        + \"It does NOT end with a linebreak.\\n\"));\n    expected.add(Str.get(\"This is explicitly typed plain ASCII text.\\n\"\n        + \"It DOES end with a linebreak.\\n\\n\"));\n\n    compare(expected.value(), returned);\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests if errors are thrown when some mandatory attributes are missing in a\n   * <http:request/>, <http:body/> or <http:multipart/>.\n   * @throws IOException I/O Exception\n   */\n  @Test\n  public void errors() throws IOException {\n\n    // Incorrect requests\n    final List<byte[]> falseReqs = new ArrayList<>();\n\n    // Request without method\n    final byte[] falseReq1 = token(\"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"href='\" + REST_ROOT + \"'/>\");\n    falseReqs.add(falseReq1);\n\n    // Request with send-authorization and no credentials\n    final byte[] falseReq2 = token(\"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"method='GET' href='\" + REST_ROOT + \"' \"\n        + \"send-authorization='true'/>\");\n    falseReqs.add(falseReq2);\n\n    // Request with send-authorization and only username\n    final byte[] falseReq3 = token(\"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"method='GET' href='\" + REST_ROOT + \"' \"\n        + \"send-authorization='true' username='test'/>\");\n    falseReqs.add(falseReq3);\n\n    // Request with body that has no media-type\n    final byte[] falseReq4 = token(\"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"method='POST' href='\" + REST_ROOT + \"'>\" + \"<http:body>\"\n        + \"<\/http:body>\" + \"<\/http:request>\");\n    falseReqs.add(falseReq4);\n\n    // Request with multipart that has no media-type\n    final byte[] falseReq5 = token(\"<http:request method='POST' \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"href='\" + REST_ROOT + \"'>\" + \"<http:multipart boundary='xxx'>\"\n        + \"<\/http:multipart>\" + \"<\/http:request>\");\n    falseReqs.add(falseReq5);\n\n    // Request with multipart with part that has a body without media-type\n    final byte[] falseReq6 = token(\"<http:request method='POST' \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"href='\" + REST_ROOT + \"'>\" + \"<http:multipart boundary='xxx'>\"\n        + \"<http:header name='hdr1' value-='val1'/>\"\n        + \"<http:body media-type='text/plain'>\" + \"Part1\" + \"<\/http:body>\"\n        + \"<http:header name='hdr1' value-='val1'/>\"\n        + \"<http:body>\" + \"Part1\" + \"<\/http:body>\"\n        + \"<\/http:multipart>\" + \"<\/http:request>\");\n    falseReqs.add(falseReq6);\n\n    // Request with schema different from http\n    final byte[] falseReq7 = token(\"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"href='ftp://basex.org'/>\");\n    falseReqs.add(falseReq7);\n\n    // Request with content and method which must be empty\n    final byte[] falseReq8 = token(\"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"method='DELETE' href='\" + REST_ROOT + \"'>\"\n        + \"<http:body media-type='text/plain'>\" + \"<\/http:body>\"\n        + \"<\/http:request>\");\n    falseReqs.add(falseReq8);\n\n    for(final byte[] falseReq : falseReqs) {\n      final DBNode dbNode = new DBNode(new IOContent(falseReq));\n      try {\n        final HttpRequestParser rp = new HttpRequestParser(null);\n        rp.parse(dbNode.children().next(), null);\n        fail(\"Exception not thrown\");\n      } catch (final QueryException ex) {\n        assertTrue(ex.getMessage().contains(ErrType.HC.toString()));\n      }\n    }\n\n  }","id":93276,"modified_method":"/**\n   * Tests if errors are thrown when some mandatory attributes are missing in a\n   * <http:request/>, <http:body/> or <http:multipart/>.\n   * @throws IOException I/O Exception\n   */\n  @Test\n  public void errors() throws IOException {\n\n    // Incorrect requests\n    final List<byte[]> falseReqs = new ArrayList<>();\n\n    // Request without method\n    final byte[] falseReq1 = token(\"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"href='\" + REST_ROOT + \"'/>\");\n    falseReqs.add(falseReq1);\n\n    // Request with send-authorization and no credentials\n    final byte[] falseReq2 = token(\"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"method='GET' href='\" + REST_ROOT + \"' \"\n        + \"send-authorization='true'/>\");\n    falseReqs.add(falseReq2);\n\n    // Request with send-authorization and only username\n    final byte[] falseReq3 = token(\"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"method='GET' href='\" + REST_ROOT + \"' \"\n        + \"send-authorization='true' username='test'/>\");\n    falseReqs.add(falseReq3);\n\n    // Request with body that has no media-type\n    final byte[] falseReq4 = token(\"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"method='POST' href='\" + REST_ROOT + \"'>\" + \"<http:body>\"\n        + \"<\/http:body>\" + \"<\/http:request>\");\n    falseReqs.add(falseReq4);\n\n    // Request with multipart that has no media-type\n    final byte[] falseReq5 = token(\"<http:request method='POST' \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"href='\" + REST_ROOT + \"'>\" + \"<http:multipart boundary='xxx'>\"\n        + \"<\/http:multipart>\" + \"<\/http:request>\");\n    falseReqs.add(falseReq5);\n\n    // Request with multipart with part that has a body without media-type\n    final byte[] falseReq6 = token(\"<http:request method='POST' \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"href='\" + REST_ROOT + \"'>\" + \"<http:multipart boundary='xxx'>\"\n        + \"<http:header name='hdr1' value-='val1'/>\"\n        + \"<http:body media-type='text/plain'>\" + \"Part1\" + \"<\/http:body>\"\n        + \"<http:header name='hdr1' value-='val1'/>\"\n        + \"<http:body>\" + \"Part1\" + \"<\/http:body>\"\n        + \"<\/http:multipart>\" + \"<\/http:request>\");\n    falseReqs.add(falseReq6);\n\n    // Request with schema different from http\n    final byte[] falseReq7 = token(\"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"href='ftp://basex.org'/>\");\n    falseReqs.add(falseReq7);\n\n    // Request with content and method which must be empty\n    final byte[] falseReq8 = token(\"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"method='DELETE' href='\" + REST_ROOT + \"'>\"\n        + \"<http:body media-type='text/plain'>\" + \"<\/http:body>\"\n        + \"<\/http:request>\");\n    falseReqs.add(falseReq8);\n\n    for(final byte[] falseReq : falseReqs) {\n      final DBNode dbNode = new DBNode(new IOContent(falseReq));\n      try {\n        final HttpRequestParser rp = new HttpRequestParser(null);\n        rp.parse(dbNode.children().next());\n        fail(\"Exception not thrown\");\n      } catch (final QueryException ex) {\n        assertTrue(ex.getMessage().contains(ErrType.HC.toString()));\n      }\n    }\n\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests parsing of multipart request when the contents for each part are set\n   * from the $bodies parameter.\n   * @throws IOException I/O Exception\n   * @throws QueryException query exception\n   */\n  @Test\n  public void parseMultipartReqBodies() throws IOException, QueryException {\n    final String multiReq = \"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"method='POST' href='\" + REST_ROOT + \"'>\"\n        + \"<http:header name='hdr1' value='hdr1val'/>\"\n        + \"<http:header name='hdr2' value='hdr2val'/>\"\n        + \"<http:multipart media-type='multipart/mixed' boundary='xxxx'>\"\n        + \"<http:header name='p1hdr1' value='p1hdr1val'/>\"\n        + \"<http:header name='p1hdr2' value='p1hdr2val'/>\"\n        + \"<http:body media-type='text/plain'/>\"\n        + \"<http:header name='p2hdr1' value='p2hdr1val'/>\"\n        + \"<http:body media-type='text/plain'/>\"\n        + \"<http:body media-type='text/plain'/>\"\n        + \"<\/http:multipart>\" + \"<\/http:request>\";\n\n    final DBNode dbNode1 = new DBNode(new IOContent(multiReq));\n    final ItemList bodies = new ItemList();\n    bodies.add(Str.get(\"Part1\"));\n    bodies.add(Str.get(\"Part2\"));\n    bodies.add(Str.get(\"Part3\"));\n\n    final HttpRequestParser rp = new HttpRequestParser(null);\n    final HttpRequest r = rp.parse(dbNode1.children().next(), bodies.iter());\n\n    assertEquals(2, r.attributes.size());\n    assertEquals(2, r.headers.size());\n    assertTrue(r.isMultipart);\n    assertEquals(3, r.parts.size());\n\n    // check parts\n    final Iterator<Part> i = r.parts.iterator();\n    Part part = i.next();\n    assertEquals(2, part.headers.size());\n    assertEquals(1, part.bodyContent.size());\n    assertEquals(1, part.bodyAttrs.size());\n\n    part = i.next();\n    assertEquals(1, part.headers.size());\n    assertEquals(1, part.bodyContent.size());\n    assertEquals(1, part.bodyAttrs.size());\n\n    part = i.next();\n    assertEquals(0, part.headers.size());\n    assertEquals(1, part.bodyContent.size());\n    assertEquals(1, part.bodyAttrs.size());\n  }","id":93277,"modified_method":"/**\n   * Tests parsing of multipart request when the contents for each part are set\n   * from the $bodies parameter.\n   * @throws IOException I/O Exception\n   * @throws QueryException query exception\n   */\n  @Test\n  public void parseMultipartReqBodies() throws IOException, QueryException {\n    final String multiReq = \"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"method='POST' href='\" + REST_ROOT + \"'>\"\n        + \"<http:header name='hdr1' value='hdr1val'/>\"\n        + \"<http:header name='hdr2' value='hdr2val'/>\"\n        + \"<http:multipart media-type='multipart/mixed' boundary='xxxx'>\"\n        + \"<http:header name='p1hdr1' value='p1hdr1val'/>\"\n        + \"<http:header name='p1hdr2' value='p1hdr2val'/>\"\n        + \"<http:body media-type='text/plain'/>\"\n        + \"<http:header name='p2hdr1' value='p2hdr1val'/>\"\n        + \"<http:body media-type='text/plain'/>\"\n        + \"<http:body media-type='text/plain'/>\"\n        + \"<\/http:multipart>\" + \"<\/http:request>\";\n\n    final DBNode dbNode1 = new DBNode(new IOContent(multiReq));\n    final ValueBuilder bodies = new ValueBuilder();\n    bodies.add(Str.get(\"Part1\"));\n    bodies.add(Str.get(\"Part2\"));\n    bodies.add(Str.get(\"Part3\"));\n\n    final HttpRequestParser rp = new HttpRequestParser(null);\n    final HttpRequest r = rp.parse(dbNode1.children().next(), bodies.value().iter());\n\n    assertEquals(2, r.attributes.size());\n    assertEquals(2, r.headers.size());\n    assertTrue(r.isMultipart);\n    assertEquals(3, r.parts.size());\n\n    // check parts\n    final Iterator<Part> i = r.parts.iterator();\n    Part part = i.next();\n    assertEquals(2, part.headers.size());\n    assertEquals(1, part.bodyContent.size());\n    assertEquals(1, part.bodyAtts.size());\n\n    part = i.next();\n    assertEquals(1, part.headers.size());\n    assertEquals(1, part.bodyContent.size());\n    assertEquals(1, part.bodyAtts.size());\n\n    part = i.next();\n    assertEquals(0, part.headers.size());\n    assertEquals(1, part.bodyContent.size());\n    assertEquals(1, part.bodyAtts.size());\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests RequestParser.parse() with multipart request.\n   * @throws IOException I/O Exception\n   * @throws QueryException query exception\n   */\n  @Test\n  public void parseMultipartReq() throws IOException, QueryException {\n    final String multiReq = \"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"method='POST' href='\" + REST_ROOT + \"'>\"\n        + \"<http:header name='hdr1' value='hdr1val'/>\"\n        + \"<http:header name='hdr2' value='hdr2val'/>\"\n        + \"<http:multipart media-type='multipart/mixed' boundary='xxxx'>\"\n        + \"<http:header name='p1hdr1' value='p1hdr1val'/>\"\n        + \"<http:header name='p1hdr2' value='p1hdr2val'/>\"\n        + \"<http:body media-type='text/plain'>\" + \"Part1\" + \"<\/http:body>\"\n        + \"<http:header name='p2hdr1' value='p2hdr1val'/>\"\n        + \"<http:body media-type='text/plain'>\" + \"Part2\" + \"<\/http:body>\"\n        + \"<http:body media-type='text/plain'>\"\n        + \"Part3\" + \"<\/http:body>\" + \"<\/http:multipart>\"\n        + \"<\/http:request>\";\n\n    final DBNode dbNode1 = new DBNode(new IOContent(multiReq));\n    final HttpRequestParser rp = new HttpRequestParser(null);\n    final HttpRequest r = rp.parse(dbNode1.children().next(), null);\n\n    assertEquals(2, r.attributes.size());\n    assertEquals(2, r.headers.size());\n    assertTrue(r.isMultipart);\n    assertEquals(3, r.parts.size());\n\n    // check parts\n    final Iterator<Part> i = r.parts.iterator();\n    Part part = i.next();\n    assertEquals(2, part.headers.size());\n    assertEquals(1, part.bodyContent.size());\n    assertEquals(1, part.bodyAttrs.size());\n\n    part = i.next();\n    assertEquals(1, part.headers.size());\n    assertEquals(1, part.bodyContent.size());\n    assertEquals(1, part.bodyAttrs.size());\n\n    part = i.next();\n    assertEquals(0, part.headers.size());\n    assertEquals(1, part.bodyContent.size());\n    assertEquals(1, part.bodyAttrs.size());\n  }","id":93278,"modified_method":"/**\n   * Tests RequestParser.parse() with multipart request.\n   * @throws IOException I/O Exception\n   * @throws QueryException query exception\n   */\n  @Test\n  public void parseMultipartReq() throws IOException, QueryException {\n    final String multiReq = \"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"method='POST' href='\" + REST_ROOT + \"'>\"\n        + \"<http:header name='hdr1' value='hdr1val'/>\"\n        + \"<http:header name='hdr2' value='hdr2val'/>\"\n        + \"<http:multipart media-type='multipart/mixed' boundary='xxxx'>\"\n        + \"<http:header name='p1hdr1' value='p1hdr1val'/>\"\n        + \"<http:header name='p1hdr2' value='p1hdr2val'/>\"\n        + \"<http:body media-type='text/plain'>\" + \"Part1\" + \"<\/http:body>\"\n        + \"<http:header name='p2hdr1' value='p2hdr1val'/>\"\n        + \"<http:body media-type='text/plain'>\" + \"Part2\" + \"<\/http:body>\"\n        + \"<http:body media-type='text/plain'>\"\n        + \"Part3\" + \"<\/http:body>\" + \"<\/http:multipart>\"\n        + \"<\/http:request>\";\n\n    final DBNode dbNode1 = new DBNode(new IOContent(multiReq));\n    final HttpRequestParser rp = new HttpRequestParser(null);\n    final HttpRequest r = rp.parse(dbNode1.children().next());\n\n    assertEquals(2, r.attributes.size());\n    assertEquals(2, r.headers.size());\n    assertTrue(r.isMultipart);\n    assertEquals(3, r.parts.size());\n\n    // check parts\n    final Iterator<Part> i = r.parts.iterator();\n    Part part = i.next();\n    assertEquals(2, part.headers.size());\n    assertEquals(1, part.bodyContent.size());\n    assertEquals(1, part.bodyAtts.size());\n\n    part = i.next();\n    assertEquals(1, part.headers.size());\n    assertEquals(1, part.bodyContent.size());\n    assertEquals(1, part.bodyAtts.size());\n\n    part = i.next();\n    assertEquals(0, part.headers.size());\n    assertEquals(1, part.bodyContent.size());\n    assertEquals(1, part.bodyAtts.size());\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests method setRequestContent of HttpClient.\n   * @throws IOException I/O Exception\n   */\n  @Test\n  public void writeMultipartMessage() throws IOException {\n    final HttpRequest req = new HttpRequest();\n    req.isMultipart = true;\n    req.payloadAttrs.put(\"media-type\", \"multipart/alternative\");\n    req.payloadAttrs.put(\"boundary\", \"boundary42\");\n    final Part p1 = new Part();\n    p1.headers.put(\"Content-Type\", \"text/plain; charset=us-ascii\");\n    p1.bodyAttrs.put(\"media-type\", \"text/plain\");\n    final String plain = \"...plain text....\";\n    p1.bodyContent.add(Str.get(plain + '\\n'));\n\n    final Part p2 = new Part();\n    p2.headers.put(\"Content-Type\", \"text/richtext\");\n    p2.bodyAttrs.put(\"media-type\", \"text/richtext\");\n    final String rich = \".... richtext version...\";\n    p2.bodyContent.add(Str.get(rich));\n\n    final Part p3 = new Part();\n    p3.headers.put(\"Content-Type\", \"text/x-whatever\");\n    p3.bodyAttrs.put(\"media-type\", \"text/x-whatever\");\n    final String fancy = \".... fanciest formatted version...\";\n    p3.bodyContent.add(Str.get(fancy));\n\n    req.parts.add(p1);\n    req.parts.add(p2);\n    req.parts.add(p3);\n\n    final FakeHttpConnection fakeConn = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    HttpClient.setRequestContent(fakeConn.getOutputStream(), req);\n    final String expResult = \"--boundary42\" + CRLF\n        + \"Content-Type: text/plain; charset=us-ascii\" + CRLF + CRLF\n        + plain + Prop.NL + CRLF\n        + \"--boundary42\" + CRLF + \"Content-Type: text/richtext\" + CRLF + CRLF\n        + rich + CRLF\n        + \"--boundary42\" + CRLF + \"Content-Type: text/x-whatever\" + CRLF + CRLF\n        + fancy + CRLF\n        + \"--boundary42--\" + CRLF;\n\n    // Compare results\n    assertEquals(expResult, fakeConn.getOutputStream().toString());\n  }","id":93279,"modified_method":"/**\n   * Tests method setRequestContent of HttpClient.\n   * @throws IOException I/O Exception\n   */\n  @Test\n  public void writeMultipartMessage() throws IOException {\n    final HttpRequest req = new HttpRequest();\n    req.isMultipart = true;\n    req.payloadAtts.put(\"media-type\", \"multipart/alternative\");\n    req.payloadAtts.put(\"boundary\", \"boundary42\");\n    final Part p1 = new Part();\n    p1.headers.put(\"Content-Type\", \"text/plain; charset=us-ascii\");\n    p1.bodyAtts.put(\"media-type\", \"text/plain\");\n    final String plain = \"...plain text....\";\n    p1.bodyContent.add(Str.get(plain + '\\n'));\n\n    final Part p2 = new Part();\n    p2.headers.put(\"Content-Type\", \"text/richtext\");\n    p2.bodyAtts.put(\"media-type\", \"text/richtext\");\n    final String rich = \".... richtext version...\";\n    p2.bodyContent.add(Str.get(rich));\n\n    final Part p3 = new Part();\n    p3.headers.put(\"Content-Type\", \"text/x-whatever\");\n    p3.bodyAtts.put(\"media-type\", \"text/x-whatever\");\n    final String fancy = \".... fanciest formatted version...\";\n    p3.bodyContent.add(Str.get(fancy));\n\n    req.parts.add(p1);\n    req.parts.add(p2);\n    req.parts.add(p3);\n\n    final FakeHttpConnection fakeConn = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    HttpClient.setRequestContent(fakeConn.getOutputStream(), req);\n    final String expResult = \"--boundary42\" + CRLF\n        + \"Content-Type: text/plain; charset=us-ascii\" + CRLF + CRLF\n        + plain + Prop.NL + CRLF\n        + \"--boundary42\" + CRLF + \"Content-Type: text/richtext\" + CRLF + CRLF\n        + rich + CRLF\n        + \"--boundary42\" + CRLF + \"Content-Type: text/x-whatever\" + CRLF + CRLF\n        + fancy + CRLF\n        + \"--boundary42--\" + CRLF;\n\n    // Compare results\n    assertEquals(expResult, fakeConn.getOutputStream().toString());\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests response handling with specified charset in the header\n   * 'Content-Type'.\n   * @throws IOException I/O Exception\n   * @throws QueryException query exception\n   */\n  @Test\n  public void responseWithCharset() throws IOException, QueryException {\n    // Create fake HTTP connection\n    final FakeHttpConnection conn = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    // Set content type\n    conn.contentType = \"text/plain; charset=CP1251\";\n    // set content encoded in CP1251\n    final String test = \"\\u0442\\u0435\\u0441\\u0442\";\n    conn.content = Charset.forName(\"CP1251\").encode(test).array();\n    final ItemList res = new HttpResponse(null, ctx.options).getResponse(conn, true, null);\n    // compare results\n    assertEquals(test, string(res.get(1).string(null)));\n  }","id":93280,"modified_method":"/**\n   * Tests response handling with specified charset in the header\n   * 'Content-Type'.\n   * @throws IOException I/O Exception\n   * @throws QueryException query exception\n   */\n  @Test\n  public void responseWithCharset() throws IOException, QueryException {\n    // Create fake HTTP connection\n    final FakeHttpConnection conn = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    // Set content type\n    conn.contentType = \"text/plain; charset=CP1251\";\n    // set content encoded in CP1251\n    final String test = \"\\u0442\\u0435\\u0441\\u0442\";\n    conn.content = Charset.forName(\"CP1251\").encode(test).array();\n    final Value res = new HttpResponse(null, ctx.options).getResponse(conn, true, null);\n    // compare results\n    assertEquals(test, string(res.itemAt(1).string(null)));\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests ResponseHandler.getResponse() with multipart response.\n   * @throws IOException I/O Exception\n   * @throws Exception exception\n   */\n  @Test\n  public void multipartResponse() throws Exception {\n    // Create fake HTTP connection\n    final FakeHttpConnection conn = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    final Map<String, List<String>> hdrs = new HashMap<>();\n    final List<String> fromVal = new ArrayList<>();\n    fromVal.add(\"Nathaniel Borenstein <nsb@bellcore.com>\");\n    // From: Nathaniel Borenstein <nsb@bellcore.com>\n    hdrs.put(\"From\", fromVal);\n    final List<String> mimeVal = new ArrayList<>();\n    mimeVal.add(\"1.0\");\n    // MIME-Version: 1.0\n    hdrs.put(\"MIME-version\", mimeVal);\n    final List<String> subjVal = new ArrayList<>();\n    subjVal.add(\"Formatted text mail\");\n    // Subject: Formatted text mail\n    hdrs.put(\"Subject\", subjVal);\n    final List<String> contTypeVal = new ArrayList<>();\n    contTypeVal.add(\"multipart/alternative\");\n    contTypeVal.add(\"boundary=\\\"boundary42\\\"\");\n    // Content-Type: multipart/alternative; boundary=boundary42\n    hdrs.put(\"Content-Type\", contTypeVal);\n\n    conn.headers = hdrs;\n    conn.contentType = \"multipart/alternative; boundary=\\\"boundary42\\\"\";\n    conn.content = token(\"--boundary42\" + CRLF\n        + \"Content-Type: text/plain; charset=us-ascii\" + CRLF + CRLF\n        + \"...plain text....\" + CRLF + CRLF\n        + \"--boundary42\" + CRLF + \"Content-Type: text/richtext\" + CRLF + CRLF\n        + \".... richtext...\" + CRLF\n        + \"--boundary42\" + CRLF + \"Content-Type: text/x-whatever\" + CRLF + CRLF\n        + \".... fanciest formatted version  \" + CRLF + \"...\"  + CRLF + \"--boundary42--\");\n    final ItemList returned = new HttpResponse(null, ctx.options).getResponse(conn, true, null);\n\n    // Construct expected result\n    final ItemList expected = new ItemList();\n    final String response = \"<http:response \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"status='200' message='OK'>\"\n        + \"<http:header name='Subject' value='Formatted text mail'/>\"\n        + \"<http:header name='Content-Type' \"\n        + \"value='multipart/alternative;boundary=&quot;boundary42&quot;'/>\"\n        + \"<http:header name='MIME-version' value='1.0'/>\"\n        + \"<http:header name='From' value='Nathaniel Borenstein \"\n        + \"&lt;nsb@bellcore.com&gt;'/>\"\n        + \"<http:multipart media-type='multipart/alternative' \"\n        + \"boundary='boundary42'>\"\n        + \"<http:header name='Content-Type' \"\n        + \"value='text/plain; charset=us-ascii'/>\"\n        + \"<http:body media-type='text/plain; charset=us-ascii'/>\"\n        + \"<http:header name='Content-Type' value='text/richtext'/>\"\n        + \"<http:body media-type='text/richtext'/>\"\n        + \"<http:header name='Content-Type' value='text/x-whatever'/>\"\n        + \"<http:body media-type='text/x-whatever'/>\"\n        + \"<\/http:multipart>\" + \"<\/http:response> \";\n    expected.add(new DBNode(new IOContent(response)).children().next());\n    expected.add(Str.get(\"...plain text....\\n\\n\"));\n    expected.add(Str.get(\".... richtext...\\n\"));\n    expected.add(Str.get(\".... fanciest formatted version  \\n...\\n\"));\n    compare(expected, returned);\n  }","id":93281,"modified_method":"/**\n   * Tests ResponseHandler.getResponse() with multipart response.\n   * @throws IOException I/O Exception\n   * @throws Exception exception\n   */\n  @Test\n  public void multipartResponse() throws Exception {\n    // Create fake HTTP connection\n    final FakeHttpConnection conn = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    final Map<String, List<String>> hdrs = new HashMap<>();\n    final List<String> fromVal = new ArrayList<>();\n    fromVal.add(\"Nathaniel Borenstein <nsb@bellcore.com>\");\n    // From: Nathaniel Borenstein <nsb@bellcore.com>\n    hdrs.put(\"From\", fromVal);\n    final List<String> mimeVal = new ArrayList<>();\n    mimeVal.add(\"1.0\");\n    // MIME-Version: 1.0\n    hdrs.put(\"MIME-version\", mimeVal);\n    final List<String> subjVal = new ArrayList<>();\n    subjVal.add(\"Formatted text mail\");\n    // Subject: Formatted text mail\n    hdrs.put(\"Subject\", subjVal);\n    final List<String> contTypeVal = new ArrayList<>();\n    contTypeVal.add(\"multipart/alternative\");\n    contTypeVal.add(\"boundary=\\\"boundary42\\\"\");\n    // Content-Type: multipart/alternative; boundary=boundary42\n    hdrs.put(\"Content-Type\", contTypeVal);\n\n    conn.headers = hdrs;\n    conn.contentType = \"multipart/alternative; boundary=\\\"boundary42\\\"\";\n    conn.content = token(\"--boundary42\" + CRLF\n        + \"Content-Type: text/plain; charset=us-ascii\" + CRLF + CRLF\n        + \"...plain text....\" + CRLF + CRLF\n        + \"--boundary42\" + CRLF + \"Content-Type: text/richtext\" + CRLF + CRLF\n        + \".... richtext...\" + CRLF\n        + \"--boundary42\" + CRLF + \"Content-Type: text/x-whatever\" + CRLF + CRLF\n        + \".... fanciest formatted version  \" + CRLF + \"...\"  + CRLF + \"--boundary42--\");\n    final Value returned = new HttpResponse(null, ctx.options).getResponse(conn, true, null);\n\n    // Construct expected result\n    final ValueBuilder expected = new ValueBuilder();\n    final String response = \"<http:response \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"status='200' message='OK'>\"\n        + \"<http:header name='Subject' value='Formatted text mail'/>\"\n        + \"<http:header name='Content-Type' \"\n        + \"value='multipart/alternative;boundary=&quot;boundary42&quot;'/>\"\n        + \"<http:header name='MIME-version' value='1.0'/>\"\n        + \"<http:header name='From' value='Nathaniel Borenstein \"\n        + \"&lt;nsb@bellcore.com&gt;'/>\"\n        + \"<http:multipart media-type='multipart/alternative' \"\n        + \"boundary='boundary42'>\"\n        + \"<http:header name='Content-Type' \"\n        + \"value='text/plain; charset=us-ascii'/>\"\n        + \"<http:body media-type='text/plain; charset=us-ascii'/>\"\n        + \"<http:header name='Content-Type' value='text/richtext'/>\"\n        + \"<http:body media-type='text/richtext'/>\"\n        + \"<http:header name='Content-Type' value='text/x-whatever'/>\"\n        + \"<http:body media-type='text/x-whatever'/>\"\n        + \"<\/http:multipart>\" + \"<\/http:response> \";\n    expected.add(new DBNode(new IOContent(response)).children().next());\n    expected.add(Str.get(\"...plain text....\\n\\n\"));\n    expected.add(Str.get(\".... richtext...\\n\"));\n    expected.add(Str.get(\".... fanciest formatted version  \\n...\\n\"));\n    compare(expected.value(), returned);\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests RequestParser.parse() with normal (not multipart) request.\n   * @throws IOException I/O Exception\n   * @throws QueryException query exception\n   */\n  @Test\n  public void parseRequest() throws IOException, QueryException {\n    // Simple HTTP request with no errors\n    final String req = \"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"method='POST' href='\" + REST_ROOT + \"'>\"\n        + \"<http:header name='hdr1' value='hdr1val'/>\"\n        + \"<http:header name='hdr2' value='hdr2val'/>\"\n        + \"<http:body media-type='text/xml'>\" + \"Test body content\"\n        + \"<\/http:body>\" + \"<\/http:request>\";\n    final DBNode dbNode = new DBNode(new IOContent(req));\n    final HttpRequestParser rp = new HttpRequestParser(null);\n    final HttpRequest r = rp.parse(dbNode.children().next(), null);\n\n    assertEquals(2, r.attributes.size());\n    assertEquals(2, r.headers.size());\n    assertTrue(r.bodyContent.size() != 0);\n    assertEquals(1, r.payloadAttrs.size());\n  }","id":93282,"modified_method":"/**\n   * Tests RequestParser.parse() with normal (not multipart) request.\n   * @throws IOException I/O Exception\n   * @throws QueryException query exception\n   */\n  @Test\n  public void parseRequest() throws IOException, QueryException {\n    // Simple HTTP request with no errors\n    final String req = \"<http:request \"\n        + \"xmlns:http='http://expath.org/ns/http-client' \"\n        + \"method='POST' href='\" + REST_ROOT + \"'>\"\n        + \"<http:header name='hdr1' value='hdr1val'/>\"\n        + \"<http:header name='hdr2' value='hdr2val'/>\"\n        + \"<http:body media-type='text/xml'>\" + \"Test body content\"\n        + \"<\/http:body>\" + \"<\/http:request>\";\n    final DBNode dbNode = new DBNode(new IOContent(req));\n    final HttpRequestParser rp = new HttpRequestParser(null);\n    final HttpRequest r = rp.parse(dbNode.children().next());\n\n    assertEquals(2, r.attributes.size());\n    assertEquals(2, r.headers.size());\n    assertFalse(r.bodyContent.isEmpty());\n    assertEquals(1, r.payloadAtts.size());\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Tests writing of request content with different combinations of the body\n   * attributes media-type and method.\n   * @throws IOException IO exception\n   */\n  @Test\n  public void writeMessage() throws IOException {\n    // Case 1: No method, media-type='text/xml'\n    final HttpRequest req1 = new HttpRequest();\n    final FakeHttpConnection fakeConn1 = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    req1.payloadAttrs.put(SerializerOptions.MEDIA_TYPE.name(), \"text/xml\");\n    // Node child\n    final FElem e1 = new FElem(\"a\").add(\"a\");\n    req1.bodyContent.add(e1);\n    // String item child\n    req1.bodyContent.add(Str.get(\"<b>b<\/b>\"));\n    HttpClient.setRequestContent(fakeConn1.getOutputStream(), req1);\n    assertEquals(\"<a>a<\/a>&lt;b&gt;b&lt;/b&gt;\", fakeConn1.out.toString(Strings.UTF8));\n\n    // Case 2: No method, media-type='text/plain'\n    final HttpRequest req2 = new HttpRequest();\n    final FakeHttpConnection fakeConn2 = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    req2.payloadAttrs.put(SerializerOptions.MEDIA_TYPE.name(), \"text/plain\");\n    // Node child\n    final FElem e2 = new FElem(\"a\").add(\"a\");\n    req2.bodyContent.add(e2);\n    // String item child\n    req2.bodyContent.add(Str.get(\"<b>b<\/b>\"));\n    HttpClient.setRequestContent(fakeConn2.getOutputStream(), req2);\n    assertEquals(\"a<b>b<\/b>\", fakeConn2.out.toString());\n\n    // Case 3: method='text', media-type='text/xml'\n    final HttpRequest req3 = new HttpRequest();\n    final FakeHttpConnection fakeConn3 = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    req3.payloadAttrs.put(SerializerOptions.MEDIA_TYPE.name(), \"text/xml\");\n    req3.payloadAttrs.put(\"method\", \"text\");\n    // Node child\n    final FElem e3 = new FElem(\"a\").add(\"a\");\n    req3.bodyContent.add(e3);\n    // String item child\n    req3.bodyContent.add(Str.get(\"<b>b<\/b>\"));\n    HttpClient.setRequestContent(fakeConn3.getOutputStream(), req3);\n    assertEquals(\"a<b>b<\/b>\", fakeConn3.out.toString());\n  }","id":93283,"modified_method":"/**\n   * Tests writing of request content with different combinations of the body\n   * attributes media-type and method.\n   * @throws IOException IO exception\n   */\n  @Test\n  public void writeMessage() throws IOException {\n    // Case 1: No method, media-type='text/xml'\n    final HttpRequest req1 = new HttpRequest();\n    final FakeHttpConnection fakeConn1 = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    req1.payloadAtts.put(SerializerOptions.MEDIA_TYPE.name(), \"text/xml\");\n    // Node child\n    final FElem e1 = new FElem(\"a\").add(\"a\");\n    req1.bodyContent.add(e1);\n    // String item child\n    req1.bodyContent.add(Str.get(\"<b>b<\/b>\"));\n    HttpClient.setRequestContent(fakeConn1.getOutputStream(), req1);\n    assertEquals(\"<a>a<\/a>&lt;b&gt;b&lt;/b&gt;\", fakeConn1.out.toString(Strings.UTF8));\n\n    // Case 2: No method, media-type='text/plain'\n    final HttpRequest req2 = new HttpRequest();\n    final FakeHttpConnection fakeConn2 = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    req2.payloadAtts.put(SerializerOptions.MEDIA_TYPE.name(), \"text/plain\");\n    // Node child\n    final FElem e2 = new FElem(\"a\").add(\"a\");\n    req2.bodyContent.add(e2);\n    // String item child\n    req2.bodyContent.add(Str.get(\"<b>b<\/b>\"));\n    HttpClient.setRequestContent(fakeConn2.getOutputStream(), req2);\n    assertEquals(\"a<b>b<\/b>\", fakeConn2.out.toString());\n\n    // Case 3: method='text', media-type='text/xml'\n    final HttpRequest req3 = new HttpRequest();\n    final FakeHttpConnection fakeConn3 = new FakeHttpConnection(new URL(\"http://www.test.com\"));\n    req3.payloadAtts.put(SerializerOptions.MEDIA_TYPE.name(), \"text/xml\");\n    req3.payloadAtts.put(\"method\", \"text\");\n    // Node child\n    final FElem e3 = new FElem(\"a\").add(\"a\");\n    req3.bodyContent.add(e3);\n    // String item child\n    req3.bodyContent.add(Str.get(\"<b>b<\/b>\"));\n    HttpClient.setRequestContent(fakeConn3.getOutputStream(), req3);\n    assertEquals(\"a<b>b<\/b>\", fakeConn3.out.toString());\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Writes the payload of a body or part in the output stream of the connection.\n   * @param payload body/part payload\n   * @param atts payload attributes\n   * @param out output stream\n   * @throws IOException I/O exception\n   */\n  private static void writePayload(final ItemList payload, final HashMap<String, String> atts,\n      final OutputStream out) throws IOException {\n\n    // detect method (specified by @method or derived from @media-type)\n    String method = atts.get(SerializerOptions.METHOD.name());\n    if(method == null) {\n      final MediaType type = new MediaType(atts.get(SerializerOptions.MEDIA_TYPE.name()));\n      if(type.is(MediaType.APPLICATION_HTML_XML)) {\n        method = SerialMethod.XHTML.toString();\n      } else if(type.is(MediaType.TEXT_HTML)) {\n        method = SerialMethod.HTML.toString();\n      } else if(type.isXML()) {\n        method = SerialMethod.XML.toString();\n      } else if(type.isText()) {\n        method = SerialMethod.TEXT.toString();\n      } else {\n        // default serialization method is XML\n        method = SerialMethod.XML.toString();\n      }\n    }\n\n    // write content depending on the method\n    final String src = atts.get(SRC);\n    if(src == null) {\n      write(payload, atts, method, out);\n    } else {\n      final IOUrl io = new IOUrl(src);\n      if(Strings.eq(method, BINARY)) {\n        out.write(io.read());\n      } else {\n        final ItemList buffer = new ItemList().add(Str.get(new TextInput(io).content()));\n        write(buffer, atts, method, out);\n      }\n    }\n  }","id":93284,"modified_method":"/**\n   * Writes the payload of a body or part in the output stream of the connection.\n   * @param payload body/part payload\n   * @param atts payload attributes\n   * @param out output stream\n   * @throws IOException I/O exception\n   */\n  private static void writePayload(final ItemList payload, final HashMap<String, String> atts,\n      final OutputStream out) throws IOException {\n\n    // choose serialization parameters\n    final SerializerOptions sopts = new SerializerOptions();\n    sopts.set(SerializerOptions.INDENT, YesNo.NO);\n\n    String src = null, method = null;\n    for(final Entry<String, String> entry : atts.entrySet()) {\n      final String key = entry.getKey(), value = entry.getValue();\n      if(key.equals(SRC)) {\n        src = value;\n      } else if(key.equals(SerializerOptions.METHOD.name())) {\n        method = value.equals(BINARY) ? SerialMethod.BASEX.toString() : value;\n      } else {\n        sopts.assign(key, value);\n        // no method specified (yet): choose method based on media type\n        if(method == null && key.equals(SerializerOptions.MEDIA_TYPE.name())) {\n          final MediaType type = new MediaType(value);\n          if(type.is(MediaType.APPLICATION_HTML_XML)) {\n            method = SerialMethod.XHTML.toString();\n          } else if(type.is(MediaType.TEXT_HTML)) {\n            method = SerialMethod.HTML.toString();\n          } else if(type.isXML()) {\n            method = SerialMethod.XML.toString();\n          } else if(type.isText()) {\n            method = SerialMethod.TEXT.toString();\n          } else {\n            method = SerialMethod.BASEX.toString();\n          }\n        }\n      }\n    }\n    sopts.assign(SerializerOptions.METHOD.name(), method);\n\n    // serialize payload\n    if(src != null) {\n      out.write(IO.get(src).read());\n    } else {\n      try(final Serializer ser = Serializer.get(out, sopts)) {\n        for(final Item it : payload) ser.serialize(it);\n      }\n    }\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Writes a single part of a multipart message.\n   * @param part part\n   * @param out connection output stream\n   * @param boundary boundary\n   * @throws IOException I/O exception\n   */\n  private static void writePart(final Part part, final OutputStream out, final String boundary)\n      throws IOException {\n\n    // write boundary preceded by \"--\"\n    final TokenBuilder boundTb = new TokenBuilder();\n    boundTb.add(\"--\").add(boundary).add(CRLF);\n    out.write(boundTb.finish());\n\n    // write headers\n    for(final Entry<String, String> header : part.headers.entrySet()) {\n      final TokenBuilder hdrTb = new TokenBuilder();\n      hdrTb.add(header.getKey()).add(\": \").add(header.getValue()).add(CRLF);\n      out.write(hdrTb.finish());\n    }\n    out.write(CRLF);\n\n    // write content\n    writePayload(part.bodyContent, part.bodyAttrs, out);\n    out.write(CRLF);\n  }","id":93285,"modified_method":"/**\n   * Writes a single part of a multipart message.\n   * @param part part\n   * @param out connection output stream\n   * @param boundary boundary\n   * @throws IOException I/O exception\n   */\n  private static void writePart(final Part part, final OutputStream out, final String boundary)\n      throws IOException {\n\n    // write boundary preceded by \"--\"\n    final TokenBuilder boundTb = new TokenBuilder();\n    boundTb.add(\"--\").add(boundary).add(CRLF);\n    out.write(boundTb.finish());\n\n    final HashMap<String, String> bodyAtts = part.bodyAtts;\n    final String mt = bodyAtts.get(SerializerOptions.MEDIA_TYPE.name());\n    if(!part.headers.containsKey(CONTENT_TYPE)) part.headers.put(CONTENT_TYPE, mt);\n\n    // write headers\n    for(final Entry<String, String> header : part.headers.entrySet()) {\n      final TokenBuilder hdrTb = new TokenBuilder();\n      hdrTb.add(header.getKey()).add(\": \").add(header.getValue()).add(CRLF);\n      out.write(hdrTb.finish());\n    }\n    out.write(CRLF);\n\n    // write content\n    writePayload(part.bodyContent, bodyAtts, out);\n    out.write(CRLF);\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Set HTTP request content.\n   * @param out output stream\n   * @param request request data\n   * @throws IOException I/O exception\n   */\n  public static void setRequestContent(final OutputStream out, final HttpRequest request)\n      throws IOException {\n\n    if(request.isMultipart) {\n      writeMultipart(request, out);\n    } else {\n      writePayload(request.bodyContent, request.payloadAttrs, out);\n    }\n    out.close();\n  }","id":93286,"modified_method":"/**\n   * Set HTTP request content.\n   * @param out output stream\n   * @param request request data\n   * @throws IOException I/O exception\n   */\n  public static void setRequestContent(final OutputStream out, final HttpRequest request)\n      throws IOException {\n\n    if(request.isMultipart) {\n      writeMultipart(request, out);\n    } else {\n      writePayload(request.bodyContent, request.payloadAtts, out);\n    }\n    out.close();\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Writes parts of multipart message in the output stream of the HTTP\n   * connection.\n   * @param request request data\n   * @param out output stream\n   * @throws IOException I/O exception\n   */\n  private static void writeMultipart(final HttpRequest request, final OutputStream out)\n      throws IOException {\n    final String boundary = request.payloadAttrs.get(BOUNDARY);\n    for(final Part part : request.parts) writePart(part, out, boundary);\n    out.write(new TokenBuilder(\"--\").add(boundary).add(\"--\").add(CRLF).finish());\n  }","id":93287,"modified_method":"/**\n   * Writes parts of multipart message in the output stream of the HTTP\n   * connection.\n   * @param request request data\n   * @param out output stream\n   * @throws IOException I/O exception\n   */\n  private static void writeMultipart(final HttpRequest request, final OutputStream out)\n      throws IOException {\n    final String boundary = request.payloadAtts.get(BOUNDARY);\n    for(final Part part : request.parts) writePart(part, out, boundary);\n    out.write(new TokenBuilder(\"--\").add(boundary).add(\"--\").add(CRLF).finish());\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Sends an HTTP request and returns the response.\n   * @param href URL to send the request to\n   * @param request request data\n   * @param bodies content items\n   * @return HTTP response\n   * @throws QueryException query exception\n   */\n  public Iter sendRequest(final byte[] href, final ANode request, final Iter bodies)\n      throws QueryException {\n\n    final HttpRequest req = new HttpRequestParser(info).parse(request, bodies);\n    HttpURLConnection conn = null;\n    try {\n      // parse request data, set properties\n      final String mediaType = req.attribute(OVERRIDE_MEDIA_TYPE);\n      final String status = req.attribute(STATUS_ONLY);\n      final boolean body = status == null || !Strings.yes(status);\n      final String url = href == null || href.length == 0 ? req.attribute(HREF) : string(href);\n\n      if(url == null || url.isEmpty()) throw HC_URL.get(info);\n      conn = connect(url, req);\n\n      if(req.bodyContent.size() != 0 || !req.parts.isEmpty()) {\n        setContentType(conn, req);\n        setRequestContent(conn.getOutputStream(), req);\n      }\n\n      return new HttpResponse(info, options).getResponse(conn, body, mediaType).iter();\n\n    } catch(final IOException ex) {\n      throw HC_ERROR_X.get(info, ex);\n    } finally {\n      if(conn != null) conn.disconnect();\n    }\n  }","id":93288,"modified_method":"/**\n   * Sends an HTTP request and returns the response.\n   * @param href URL to send the request to\n   * @param request request data\n   * @param bodies content items\n   * @return HTTP response\n   * @throws QueryException query exception\n   */\n  public ValueIter sendRequest(final byte[] href, final ANode request, final Iter bodies)\n      throws QueryException {\n\n    final HttpRequest req = new HttpRequestParser(info).parse(request, bodies);\n    HttpURLConnection conn = null;\n    try {\n      // parse request data, set properties\n      final String mediaType = req.attribute(OVERRIDE_MEDIA_TYPE);\n      final String status = req.attribute(STATUS_ONLY);\n      final boolean body = status == null || !Strings.yes(status);\n      final String url = href == null || href.length == 0 ? req.attribute(HREF) : string(href);\n\n      if(url == null || url.isEmpty()) throw HC_URL.get(info);\n      conn = connect(url, req);\n\n      if(!req.bodyContent.isEmpty() || !req.parts.isEmpty()) {\n        setContentType(conn, req);\n        setRequestContent(conn.getOutputStream(), req);\n      }\n\n      return new HttpResponse(info, options).getResponse(conn, body, mediaType).iter();\n\n    } catch(final IOException ex) {\n      throw HC_ERROR_X.get(info, ex);\n    } finally {\n      if(conn != null) conn.disconnect();\n    }\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Sets content type of HTTP request.\n   * @param conn HTTP connection\n   * @param request request data\n   */\n  private static void setContentType(final HttpURLConnection conn, final HttpRequest request) {\n    String ct;\n    final String contType = request.headers.get(CONTENT_TYPE.toLowerCase(Locale.ENGLISH));\n    if(contType != null) {\n      // if content type is set in the header, its value is used\n      ct = contType;\n    } else {\n      // otherwise @media-type of <http:body/> is considered\n      ct = request.payloadAttrs.get(SerializerOptions.MEDIA_TYPE.name());\n      if(request.isMultipart) {\n        final String b = request.payloadAttrs.get(BOUNDARY);\n        ct = new TokenBuilder().add(ct).add(\"; \").add(BOUNDARY).add('=').\n            add(b.isEmpty() ? DEFAULT_BOUNDARY : b).toString();\n      }\n    }\n    conn.setRequestProperty(CONTENT_TYPE, ct);\n  }","id":93289,"modified_method":"/**\n   * Sets the content type of the HTTP request.\n   * @param conn HTTP connection\n   * @param request request data\n   */\n  private static void setContentType(final HttpURLConnection conn, final HttpRequest request) {\n    String ct;\n    final String contType = request.headers.get(CONTENT_TYPE.toLowerCase(Locale.ENGLISH));\n    if(contType != null) {\n      // if content type is set in the header, its value is used\n      ct = contType;\n    } else {\n      // otherwise @media-type of <http:body/> is considered\n      ct = request.payloadAtts.get(SerializerOptions.MEDIA_TYPE.name());\n      if(request.isMultipart) {\n        final String b = request.payloadAtts.get(BOUNDARY);\n        ct = new TokenBuilder().add(ct).add(\"; \").add(BOUNDARY).add('=').\n            add(b.isEmpty() ? DEFAULT_BOUNDARY : b).toString();\n      }\n    }\n    conn.setRequestProperty(CONTENT_TYPE, ct);\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns an XQuery value for the specified content type.\n   * @param input input source\n   * @param options database options\n   * @param type media type\n   * @return xml parser\n   * @throws IOException I/O exception\n   * @throws QueryException query exception\n   */\n  public static Value value(final IO input, final MainOptions options, final MediaType type)\n      throws IOException, QueryException {\n\n    Value val = null;\n    if(type.is(MediaType.APPLICATION_JSON)) {\n      final JsonParserOptions opts = new JsonParserOptions(options.get(MainOptions.JSONPARSER));\n      opts.assign(type);\n      val = JsonConverter.get(opts).convert(input);\n    } else if(type.is(MediaType.TEXT_CSV)) {\n      final CsvParserOptions opts = new CsvParserOptions(options.get(MainOptions.CSVPARSER));\n      opts.assign(type);\n      val = CsvConverter.get(opts).convert(input);\n    } else if(type.is(MediaType.TEXT_HTML)) {\n      final HtmlOptions opts = new HtmlOptions(options.get(MainOptions.HTMLPARSER));\n      opts.assign(type);\n      val = new DBNode(new HtmlParser(input, options, opts));\n    } else if(type.is(MediaType.APPLICATION_X_WWW_FORM_URLENCODED)) {\n      final String enc = type.parameters().get(CHARSET);\n      val = Str.get(URLDecoder.decode(string(input.read()), enc == null ? Strings.UTF8 : enc));\n    } else if(type.isXML()) {\n      val = new DBNode(input);\n    } else if(type.isText()) {\n      val = Str.get(new NewlineInput(input).content());\n    } else if(type.isMultipart()) {\n      try(final InputStream is = input.inputStream()) {\n        final HttpPayload hp = new HttpPayload(is, true, null, options);\n        hp.extractParts(concat(DASHES, hp.boundary(type)), null);\n        val = hp.payloads();\n      }\n    }\n    return val == null ? new B64(input.read()) : val;\n  }","id":93290,"modified_method":"/**\n   * Returns an XQuery value for the specified content type.\n   * @param input input source\n   * @param options database options\n   * @param type media type\n   * @return xml parser\n   * @throws IOException I/O exception\n   * @throws QueryException query exception\n   */\n  public static Value value(final IO input, final MainOptions options, final MediaType type)\n      throws IOException, QueryException {\n\n    Value value = null;\n    if(type.is(MediaType.APPLICATION_JSON)) {\n      final JsonParserOptions opts = new JsonParserOptions(options.get(MainOptions.JSONPARSER));\n      opts.assign(type);\n      value = JsonConverter.get(opts).convert(input);\n    } else if(type.is(MediaType.TEXT_CSV)) {\n      final CsvParserOptions opts = new CsvParserOptions(options.get(MainOptions.CSVPARSER));\n      opts.assign(type);\n      value = CsvConverter.get(opts).convert(input);\n    } else if(type.is(MediaType.TEXT_HTML)) {\n      final HtmlOptions opts = new HtmlOptions(options.get(MainOptions.HTMLPARSER));\n      opts.assign(type);\n      value = new DBNode(new HtmlParser(input, options, opts));\n    } else if(type.is(MediaType.APPLICATION_X_WWW_FORM_URLENCODED)) {\n      final String enc = type.parameters().get(CHARSET);\n      value = Str.get(URLDecoder.decode(string(input.read()), enc == null ? Strings.UTF8 : enc));\n    } else if(type.isXML()) {\n      value = new DBNode(input);\n    } else if(type.isText()) {\n      value = Str.get(new NewlineInput(input).content());\n    } else if(type.isMultipart()) {\n      try(final InputStream is = input.inputStream()) {\n        final HttpPayload hp = new HttpPayload(is, true, null, options);\n        hp.extractParts(concat(DASHES, hp.boundary(type)), null);\n        value = hp.payloads();\n      }\n    }\n    return value == null ? new B64(input.read()) : value;\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Extracts a part from a multipart message.\n   * @param sep separation boundary\n   * @param end closing boundary\n   * @param parts list with all parts (may be {@code null})\n   * @return success flag\n   * @throws IOException I/O Exception\n   * @throws QueryException query exception\n   */\n  private boolean extractPart(final byte[] sep, final byte[] end, final ANodeList parts)\n      throws IOException, QueryException {\n\n    // check if last line is reached\n    final byte[] line = readLine();\n    if(line == null || eq(line, end)) return false;\n\n    // content type of part payload - if not defined by header 'Content-Type',\n    // it is equal to 'text/plain' (RFC 1341)\n    MediaType mt = MediaType.TEXT_PLAIN;\n\n    // extract headers\n    for(byte[] l = line; l != null && l.length > 0;) {\n      final int pos = indexOf(l, ':');\n      if(pos > 0) {\n        final byte[] key = substring(l, 0, pos);\n        final byte[] val = trim(substring(l, pos + 1));\n        if(eq(lc(key), CONTENT_TYPE_LC)) mt = new MediaType(string(val));\n        if(val.length != 0 && parts != null)\n          parts.add(new FElem(Q_HEADER).add(NAME, key).add(VALUE, val));\n      }\n      l = readLine();\n    }\n    if(parts != null) {\n      parts.add(new FElem(Q_BODY).add(SerializerOptions.MEDIA_TYPE.name(), mt.toString()));\n    }\n\n    final byte[] pl = extractPart(sep, end, mt.parameters().get(CHARSET));\n    if(payloads != null) payloads.add(parse(pl, mt));\n    return true;\n  }","id":93291,"modified_method":"/**\n   * Extracts a part from a multipart message.\n   * @param sep separation boundary\n   * @param end closing boundary\n   * @param parts list with all parts (may be {@code null})\n   * @return success flag\n   * @throws IOException I/O Exception\n   * @throws QueryException query exception\n   */\n  private boolean extractPart(final byte[] sep, final byte[] end, final ANodeList parts)\n      throws IOException, QueryException {\n\n    // check if last line is reached\n    final byte[] line = readLine();\n    if(line == null || eq(line, end)) return false;\n\n    // content type of part payload - if not defined by header 'Content-Type',\n    // it is equal to 'text/plain' (RFC 1341)\n    MediaType type = MediaType.TEXT_PLAIN;\n\n    // extract headers\n    for(byte[] l = line; l != null && l.length > 0;) {\n      final int pos = indexOf(l, ':');\n      if(pos > 0) {\n        final byte[] key = substring(l, 0, pos);\n        final byte[] val = trim(substring(l, pos + 1));\n        if(eq(lc(key), CONTENT_TYPE_LC)) type = new MediaType(string(val));\n        if(val.length != 0 && parts != null)\n          parts.add(new FElem(Q_HEADER).add(NAME, key).add(VALUE, val));\n      }\n      l = readLine();\n    }\n    if(parts != null) {\n      parts.add(new FElem(Q_BODY).add(SerializerOptions.MEDIA_TYPE.name(), type.toString()));\n    }\n\n    final byte[] payload = extractPart(sep, end, type.parameters().get(CHARSET));\n    if(payloads != null) payloads.add(parse(payload, type));\n    return true;\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Parses the attributes of an element.\n   * @param element element\n   * @param attrs map for parsed attributes\n   */\n  private static void parseAttrs(final ANode element, final HashMap<String, String> attrs) {\n    for(final ANode attr : element.attributes()) {\n      attrs.put(string(attr.name()), string(attr.string()));\n    }\n  }","id":93292,"modified_method":"/**\n   * Parses the attributes of an element.\n   * @param element element\n   * @param atts map for parsed attributes\n   */\n  private static void parseAtts(final ANode element, final HashMap<String, String> atts) {\n    for(final ANode attr : element.attributes()) {\n      atts.put(string(attr.name()), string(attr.string()));\n    }\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Parses an <http:request/> element.\n   * @param request request element (can be {@code null})\n   * @param bodies content items\n   * @return parsed request\n   * @throws QueryException query exception\n   */\n  public HttpRequest parse(final ANode request, final Iter bodies) throws QueryException {\n    final HttpRequest req = new HttpRequest();\n\n    if(request != null) {\n      for(final ANode attr : request.attributes()) {\n        final String key = string(attr.name());\n        final Request r = Request.get(key);\n        if(r == null) throw HC_REQ_X.get(info, \"Unknown attribute: \" + key);\n        req.attributes.put(r, string(attr.string()));\n      }\n      checkRequest(req);\n\n      // it is an error if content is set for HTTP verbs which must be empty\n      final ANode payload = parseHdrs(request.children(), req.headers);\n      final String method = req.attribute(Request.METHOD);\n      if(Strings.eq(method, TRACE, DELETE) && (payload != null || bodies != null))\n        throw HC_REQ_X.get(info, \"Body not expected for method \" + method);\n\n      if(payload != null) {\n        final QNm pl = payload.qname();\n        // single part request\n        if(pl.eq(Q_BODY)) {\n          final Item it = bodies != null ? bodies.next() : null;\n          parseBody(payload, it, req.payloadAttrs, req.bodyContent);\n          req.isMultipart = false;\n          // multipart request\n        } else if(pl.eq(Q_MULTIPART)) {\n          parseMultipart(payload, bodies, req.payloadAttrs, req.parts);\n          req.isMultipart = true;\n        } else {\n          throw HC_REQ_X.get(info, \"Unknown payload element: \" + payload.qname());\n        }\n      }\n    }\n    return req;\n  }","id":93293,"modified_method":"/**\n   * Parses an <http:request/> element.\n   * @param request request element (can be {@code null})\n   * @param bodies content items\n   * @return parsed request\n   * @throws QueryException query exception\n   */\n  public HttpRequest parse(final ANode request, final Iter bodies) throws QueryException {\n    final HttpRequest req = new HttpRequest();\n\n    if(request != null) {\n      for(final ANode attr : request.attributes()) {\n        final String key = string(attr.name());\n        final Request r = Request.get(key);\n        if(r == null) throw HC_REQ_X.get(info, \"Unknown attribute: \" + key);\n        req.attributes.put(r, string(attr.string()));\n      }\n      checkRequest(req);\n\n      // it is an error if content is set for HTTP verbs which must be empty\n      final ANode payload = parseHeaders(request.children(), req.headers);\n      final String method = req.attribute(Request.METHOD);\n      if(Strings.eq(method, TRACE, DELETE) && (payload != null || bodies != null))\n        throw HC_REQ_X.get(info, \"Body not expected for method \" + method);\n\n      if(payload != null) {\n        final QNm pl = payload.qname();\n        // single part request\n        if(pl.eq(Q_BODY)) {\n          final Item it = bodies != null ? bodies.next() : null;\n          parseBody(payload, it, req.payloadAtts, req.bodyContent);\n          req.isMultipart = false;\n          // multipart request\n        } else if(pl.eq(Q_MULTIPART)) {\n          parseMultipart(payload, bodies, req.payloadAtts, req.parts);\n          req.isMultipart = true;\n        } else {\n          throw HC_REQ_X.get(info, \"Unknown payload element: \" + payload.qname());\n        }\n      }\n    }\n    return req;\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Parses <http:body/> element.\n   * @param body body element\n   * @param contItem content item\n   * @param attrs map for parsed body attributes\n   * @param bodyContent item cache for parsed body content\n   * @throws QueryException query exception\n   */\n  private void parseBody(final ANode body, final Item contItem, final HashMap<String, String> attrs,\n      final ItemList bodyContent) throws QueryException {\n\n    parseAttrs(body, attrs);\n    checkBody(body, attrs);\n\n    if(attrs.get(SRC) == null) {\n      // no linked resource for setting request content\n      if(contItem == null) {\n        // content is set from <http:body/> children\n        for(final ANode n : body.children()) bodyContent.add(n);\n      } else {\n        // content is set from $bodies parameter\n        bodyContent.add(contItem);\n      }\n    }\n  }","id":93294,"modified_method":"/**\n   * Parses <http:body/> element.\n   * @param body body element\n   * @param contItem content item\n   * @param atts map for parsed body attributes\n   * @param bodyContent item cache for parsed body content\n   * @throws QueryException query exception\n   */\n  private void parseBody(final ANode body, final Item contItem, final HashMap<String, String> atts,\n      final ItemList bodyContent) throws QueryException {\n\n    parseAtts(body, atts);\n    checkBody(body, atts);\n\n    if(atts.get(SRC) == null) {\n      // no linked resource for setting request content\n      if(contItem == null) {\n        // content is set from <http:body/> children\n        for(final ANode n : body.children()) bodyContent.add(n);\n      } else {\n        // content is set from $bodies parameter\n        bodyContent.add(contItem);\n      }\n    }\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Parses a <http:multipart/> element.\n   * @param multipart multipart element\n   * @param contItems content items\n   * @param attrs map for multipart attributes\n   * @param parts list for multipart parts\n   * @throws QueryException query exception\n   */\n  private void parseMultipart(final ANode multipart, final Iter contItems,\n      final HashMap<String, String> attrs, final ArrayList<Part> parts) throws QueryException {\n\n    parseAttrs(multipart, attrs);\n    if(attrs.get(SerializerOptions.MEDIA_TYPE.name()) == null)\n      throw HC_REQ_X.get(info, \"Attribute media-type of http:multipart is mandatory\");\n\n    final BasicNodeIter prts = multipart.children();\n    while(true) {\n      final Part p = new Part();\n      final ANode partBody = parseHdrs(prts, p.headers);\n      if(partBody == null) break;\n      // content is set from <http:body/> children or from $bodies parameter\n      final Item ci = contItems == null ? null : contItems.next();\n      parseBody(partBody, ci, p.bodyAttrs, p.bodyContent);\n      parts.add(p);\n    }\n  }","id":93295,"modified_method":"/**\n   * Parses a <http:multipart/> element.\n   * @param multipart multipart element\n   * @param contItems content items\n   * @param atts map for multipart attributes\n   * @param parts list for multipart parts\n   * @throws QueryException query exception\n   */\n  private void parseMultipart(final ANode multipart, final Iter contItems,\n      final HashMap<String, String> atts, final ArrayList<Part> parts) throws QueryException {\n\n    parseAtts(multipart, atts);\n    if(atts.get(SerializerOptions.MEDIA_TYPE.name()) == null)\n      throw HC_REQ_X.get(info, \"Attribute media-type of http:multipart is mandatory\");\n\n    final BasicNodeIter prts = multipart.children();\n    while(true) {\n      final Part p = new Part();\n      final ANode partBody = parseHeaders(prts, p.headers);\n      if(partBody == null) break;\n      // content is set from <http:body/> children or from $bodies parameter\n      final Item ci = contItems == null ? null : contItems.next();\n      parseBody(partBody, ci, p.bodyAtts, p.bodyContent);\n      parts.add(p);\n    }\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Checks consistency of attributes for <http:body/>.\n   * @param body body\n   * @param bodyAttrs body attributes\n   * @throws QueryException query exception\n   */\n  private void checkBody(final ANode body, final HashMap<String, String> bodyAttrs)\n      throws QueryException {\n\n    // @media-type is mandatory\n    if(bodyAttrs.get(SerializerOptions.MEDIA_TYPE.name()) == null)\n      throw HC_REQ_X.get(info, \"Attribute media-type of http:body is mandatory\");\n\n    // if src attribute is used to set the content of the body, no\n    // other attributes must be specified and no content must be present\n    if(bodyAttrs.get(SRC) != null && (bodyAttrs.size() > 2 || body.children().next() != null))\n      throw HC_ATTR.get(info);\n\n  }","id":93296,"modified_method":"/**\n   * Checks consistency of attributes for <http:body/>.\n   * @param body body\n   * @param bodyAtts body attributes\n   * @throws QueryException query exception\n   */\n  private void checkBody(final ANode body, final HashMap<String, String> bodyAtts)\n      throws QueryException {\n\n    // @media-type is mandatory\n    if(bodyAtts.get(SerializerOptions.MEDIA_TYPE.name()) == null)\n      throw HC_REQ_X.get(info, \"Attribute media-type of http:body is mandatory\");\n\n    // if src attribute is used to set the content of the body, no\n    // other attributes must be specified and no content must be present\n    if(bodyAtts.get(SRC) != null && (bodyAtts.size() > 2 || body.children().next() != null))\n      throw HC_ATTR.get(info);\n\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Parses <http:header/> children of requests and parts.\n   * @param iter iterator on request/part children\n   * @param hdrs map for parsed headers\n   * @return body or multipart\n   */\n  private static ANode parseHdrs(final BasicNodeIter iter, final HashMap<String, String> hdrs) {\n    for(final ANode node : iter) {\n      final QNm nm = node.qname();\n      if(nm == null) continue;\n      if(!nm.eq(Q_HEADER)) return node;\n\n      String name = null, value = null;\n      for(final ANode attr : node.attributes()) {\n        final String qn = string(attr.qname().local());\n        if(qn.equals(NAME)) name = string(attr.string());\n        else if(qn.equals(VALUE)) value = string(attr.string());\n      }\n      if(name != null && !name.isEmpty() && value != null && !value.isEmpty()) {\n        hdrs.put(name, value);\n      }\n    }\n    return null;\n  }","id":93297,"modified_method":"/**\n   * Parses <http:header/> children of requests and parts.\n   * @param iter iterator on request/part children\n   * @param hdrs map for parsed headers\n   * @return body or multipart\n   */\n  private static ANode parseHeaders(final BasicNodeIter iter, final HashMap<String, String> hdrs) {\n    for(final ANode node : iter) {\n      final QNm nm = node.qname();\n      if(nm == null) continue;\n      if(!nm.eq(Q_HEADER)) return node;\n\n      String name = null, value = null;\n      for(final ANode attr : node.attributes()) {\n        final String qn = string(attr.qname().local());\n        if(qn.equals(NAME)) name = string(attr.string());\n        else if(qn.equals(VALUE)) value = string(attr.string());\n      }\n      if(name != null && !name.isEmpty() && value != null && !value.isEmpty()) {\n        hdrs.put(name, value);\n      }\n    }\n    return null;\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructs http:response element and reads HTTP response content.\n   * @param conn HTTP connection\n   * @param body also return body\n   * @param mtype media type provided by the user (can be {@code null})\n   * @return result sequence of <http:response/> and content items\n   * @throws IOException I/O Exception\n   * @throws QueryException query exception\n   */\n  @SuppressWarnings(\"resource\")\n  public ItemList getResponse(final HttpURLConnection conn, final boolean body, final String mtype)\n      throws IOException, QueryException {\n\n    // check content type\n    boolean error = false;\n    InputStream is;\n    try {\n      is = conn.getInputStream();\n    } catch(final IOException ex) {\n      Util.debug(ex);\n      is = conn.getErrorStream();\n      error = true;\n    }\n\n    // result\n    final ItemList res = new ItemList();\n\n    // construct <http:response/>\n    final FElem response = new FElem(Q_RESPONSE).declareNS();\n    res.add(response);\n\n    final String msg = conn.getResponseMessage();\n    response.add(STATUS, token(conn.getResponseCode()));\n    response.add(MESSAGE, msg == null ? \"\" : msg);\n    // add <http:header/> elements\n    for(final String header : conn.getHeaderFields().keySet()) {\n      if(header != null) {\n        final FElem hdr = new FElem(Q_HEADER);\n        hdr.add(NAME, header);\n        hdr.add(VALUE, conn.getHeaderField(header));\n        response.add(hdr);\n      }\n    }\n    // construct <http:body/>\n    if(is != null) {\n      try {\n        final HttpPayload hp = new HttpPayload(is, body, info, options);\n        final String ctype = conn.getContentType();\n        // error: adopt original type as content type\n        final MediaType type = error || mtype == null ? ctype == null ? MediaType.TEXT_PLAIN :\n          new MediaType(ctype) : new MediaType(mtype);\n        response.add(hp.parse(type));\n        if(body) res.add(hp.payloads());\n      } finally {\n        is.close();\n      }\n    }\n    return res;\n  }","id":93298,"modified_method":"/**\n   * Constructs http:response element and reads HTTP response content.\n   * @param conn HTTP connection\n   * @param body also return body\n   * @param mtype media type provided by the user (can be {@code null})\n   * @return result sequence of <http:response/> and content items\n   * @throws IOException I/O Exception\n   * @throws QueryException query exception\n   */\n  @SuppressWarnings(\"resource\")\n  public Value getResponse(final HttpURLConnection conn, final boolean body, final String mtype)\n      throws IOException, QueryException {\n\n    // check content type\n    boolean error = false;\n    InputStream is;\n    try {\n      is = conn.getInputStream();\n    } catch(final IOException ex) {\n      Util.debug(ex);\n      is = conn.getErrorStream();\n      error = true;\n    }\n\n    // result\n    final ValueBuilder res = new ValueBuilder();\n\n    // construct <http:response/>\n    final FElem response = new FElem(Q_RESPONSE).declareNS();\n    res.add(response);\n\n    final String msg = conn.getResponseMessage();\n    response.add(STATUS, token(conn.getResponseCode()));\n    response.add(MESSAGE, msg == null ? \"\" : msg);\n    // add <http:header/> elements\n    for(final String header : conn.getHeaderFields().keySet()) {\n      if(header != null) {\n        final FElem hdr = new FElem(Q_HEADER);\n        hdr.add(NAME, header);\n        hdr.add(VALUE, conn.getHeaderField(header));\n        response.add(hdr);\n      }\n    }\n    // construct <http:body/>\n    if(is != null) {\n      try {\n        final HttpPayload hp = new HttpPayload(is, body, info, options);\n        final String ctype = conn.getContentType();\n        // error: adopt original type as content type\n        final MediaType type = error || mtype == null ? ctype == null ? MediaType.TEXT_PLAIN :\n          new MediaType(ctype) : new MediaType(mtype);\n        response.add(hp.parse(type));\n        if(body) res.add(hp.payloads());\n      } finally {\n        is.close();\n      }\n    }\n    return res.value();\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Iter iter(final QueryContext qc) throws QueryException {\n    checkCreate(qc);\n\n    // get request node\n    final ANode request = toEmptyNode(exprs[0], qc);\n\n    // get HTTP URI\n    final byte[] href = exprs.length >= 2 ? toEmptyToken(exprs[1], qc) : null;\n    // get parameter $bodies\n    Iter iter = null;\n    if(exprs.length == 3) {\n      final Iter bodies = exprs[2].iter(qc);\n      final ItemList cache = new ItemList();\n      for(Item body; (body = bodies.next()) != null;) cache.add(body);\n      iter = cache.iter();\n    }\n    // send HTTP request\n    return new HttpClient(info, qc.context.options).sendRequest(href, request, iter);\n  }","id":93299,"modified_method":"@Override\n  public Iter iter(final QueryContext qc) throws QueryException {\n    checkCreate(qc);\n\n    // get request node\n    final ANode request = toEmptyNode(exprs[0], qc);\n\n    // get HTTP URI\n    final byte[] href = exprs.length >= 2 ? toEmptyToken(exprs[1], qc) : null;\n    // get parameter $bodies\n    Iter iter = null;\n    if(exprs.length == 3) {\n      final Iter bodies = exprs[2].iter(qc);\n      final ValueBuilder cache = new ValueBuilder();\n      for(Item body; (body = bodies.next()) != null;) cache.add(body);\n      iter = cache.value().iter();\n    }\n    // send HTTP request\n    return new HttpClient(info, qc.context.options).sendRequest(href, request, iter);\n  }","commit_id":"04957eb1de30cb2f76cbb4fded31027e162860b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Nullable\n  public synchronized List<PyPackage> getPackages(boolean cachedOnly) throws PyExternalProcessException {\n    if (myPackagesCache == null) {\n      if (myExceptionCache != null) {\n        throw myExceptionCache;\n      }\n      if (cachedOnly) {\n        return null;\n      }\n      loadPackages();\n    }\n    return myPackagesCache;\n  }","id":93300,"modified_method":"@Nullable\n  public List<PyPackage> getPackages(boolean cachedOnly) throws PyExternalProcessException {\n    synchronized (myCacheLock) {\n      if (myPackagesCache != null) {\n        return myPackagesCache;\n      }\n      if (myExceptionCache != null) {\n        throw myExceptionCache;\n      }\n      if (cachedOnly) {\n        return null;\n      }\n    }\n    try {\n      final String output = getHelperResult(PACKAGING_TOOL, Arrays.asList(\"list\"), false, false, null);\n      final List<PyPackage> packages = parsePackagingToolOutput(output);\n      synchronized (myCacheLock) {\n        myPackagesCache = packages;\n      }\n      return packages;\n    }\n    catch (PyExternalProcessException e) {\n      synchronized (myCacheLock) {\n        myExceptionCache = e;\n      }\n      throw e;\n    }\n  }","commit_id":"4daff37220d32ef001fe8ded2c2597170505ea87","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected synchronized void clearCaches() {\n    myPackagesCache = null;\n    myDependenciesCache = null;\n    myExceptionCache = null;\n  }","id":93301,"modified_method":"protected void clearCaches() {\n    synchronized (myCacheLock) {\n      myPackagesCache = null;\n      myExceptionCache = null;\n    }\n  }","commit_id":"4daff37220d32ef001fe8ded2c2597170505ea87","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public synchronized Set<PyPackage> getDependents(@NotNull PyPackage pkg) throws PyExternalProcessException {\n    if (myDependenciesCache == null) {\n      if (myExceptionCache != null) {\n        throw myExceptionCache;\n      }\n\n      loadPackages();\n    }\n    return myDependenciesCache.get(pkg.getName());\n  }","id":93302,"modified_method":"@Nullable\n  public Set<PyPackage> getDependents(@NotNull PyPackage pkg) throws PyExternalProcessException {\n    final List<PyPackage> packages = getPackages(false);\n    if (packages != null) {\n      final Set<PyPackage> dependents = new HashSet<PyPackage>();\n      for (PyPackage p : packages) {\n        final List<PyRequirement> requirements = p.getRequirements();\n        for (PyRequirement requirement : requirements) {\n          if (requirement.getName().equals(pkg.getName())) {\n            dependents.add(p);\n          }\n        }\n      }\n      return dependents;\n    }\n    return null;\n  }","commit_id":"4daff37220d32ef001fe8ded2c2597170505ea87","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void defineBulkChangeAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(BULK_CHANGE_ACTION)\n      .setDescription(\"Bulk change on issues. Requires authentication and User role on project(s)\")\n      .setSince(\"3.7\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"issues\")\n      .setDescription(\"Comma-separated list of issue keys\")\n      .setRequired(true)\n      .setExampleValue(\"01fc972e-2a3c-433e-bcae-0bd7f88f5123,01fc972e-2a3c-433e-bcae-0bd7f88f9999\");\n    action.createParam(\"actions\")\n      .setDescription(\"Comma-separated list of actions to perform. Possible values: assign | set_severity | plan | do_transition\")\n      .setRequired(true)\n      .setExampleValue(\"assign,plan\");\n    action.createParam(\"assign.assignee\")\n      .setDescription(\"To assign the list of issues to a specific user (login), or unassign all the issues\")\n      .setExampleValue(\"sbrandhof\");\n    action.createParam(\"set_severity.severity\")\n      .setDescription(\"To change the severity of the list of issues\")\n      .setExampleValue(Severity.BLOCKER)\n      .setPossibleValues(Severity.ALL);\n    action.createParam(\"plan.plan\")\n      .setDescription(\"To plan the list of issues to a specific action plan (key), or unlink all the issues from an action plan\")\n      .setExampleValue(\"3f19de90-1521-4482-a737-a311758ff513\");\n    action.createParam(\"do_transition.transition\")\n      .setDescription(\"Transition\")\n      .setExampleValue(\"reopen\")\n      .setPossibleValues(DefaultTransitions.ALL);\n    action.createParam(\"comment\")\n      .setDescription(\"To add a comment to a list of issues\")\n      .setExampleValue(\"blabla...\");\n    action.createParam(\"sendNotifications\")\n      .setDescription(\"Available since version 4.0\")\n      .setDefaultValue(\"false\")\n      .setBooleanPossibleValues();\n    RailsHandler.addFormatParam(action);\n  }","id":93303,"modified_method":"private void defineBulkChangeAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(BULK_CHANGE_ACTION)\n      .setDescription(\"Bulk change on issues. Requires authentication and User role on project(s)\")\n      .setSince(\"3.7\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setPost(true);\n\n    action.createParam(\"issues\")\n      .setDescription(\"Comma-separated list of issue keys\")\n      .setRequired(true)\n      .setExampleValue(\"01fc972e-2a3c-433e-bcae-0bd7f88f5123,01fc972e-2a3c-433e-bcae-0bd7f88f9999\");\n    action.createParam(\"actions\")\n      .setDescription(\"Comma-separated list of actions to perform. Possible values: assign | set_severity | plan | do_transition\")\n      .setRequired(true)\n      .setExampleValue(\"assign,plan\");\n    action.createParam(\"assign.assignee\")\n      .setDescription(\"To assign the list of issues to a specific user (login), or un-assign all the issues\")\n      .setExampleValue(\"john.smith\");\n    action.createParam(\"set_severity.severity\")\n      .setDescription(\"To change the severity of the list of issues\")\n      .setExampleValue(Severity.BLOCKER)\n      .setPossibleValues(Severity.ALL);\n    action.createParam(\"plan.plan\")\n      .setDescription(\"To plan the list of issues to a specific action plan (key), or unlink all the issues from an action plan\")\n      .setExampleValue(\"3f19de90-1521-4482-a737-a311758ff513\");\n    action.createParam(\"do_transition.transition\")\n      .setDescription(\"Transition\")\n      .setExampleValue(\"reopen\")\n      .setPossibleValues(DefaultTransitions.ALL);\n    action.createParam(\"comment\")\n      .setDescription(\"To add a comment to a list of issues\")\n      .setExampleValue(\"Here is my comment\");\n    action.createParam(\"sendNotifications\")\n      .setDescription(\"Available since version 4.0\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\");\n    RailsHandler.addFormatParam(action);\n  }","commit_id":"c3265ba39c8b6646b6e4dab69cf20af3b9865b45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineIndexAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"index\")\n      .setDescription(\"Search for projects\")\n      .setSince(\"2.10\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"projects-example-index.json\"));\n\n    action.createParam(\"key\")\n      .setDescription(\"id or key of the project\")\n      .setExampleValue(\"org.codehaus.sonar:sonar\");\n\n    action.createParam(\"search\")\n      .setDescription(\"Substring of project name, case insensitive\")\n      .setExampleValue(\"Sonar\");\n\n    action.createParam(\"desc\")\n      .setDescription(\"Load project description\")\n      .setDefaultValue(\"true\")\n      .setBooleanPossibleValues();\n\n    action.createParam(\"subprojects\")\n      .setDescription(\"Load sub-projects. Ignored if the parameter key is set\")\n      .setDefaultValue(\"false\")\n      .setBooleanPossibleValues();\n\n    action.createParam(\"views\")\n      .setDescription(\"Load views and sub-views. Ignored if the parameter key is set\")\n      .setDefaultValue(\"false\")\n      .setBooleanPossibleValues();\n\n    action.createParam(\"libs\")\n      .setDescription(\"Load libraries. Ignored if the parameter key is set\")\n      .setDefaultValue(\"false\")\n      .setBooleanPossibleValues();\n\n    action.createParam(\"versions\")\n      .setDescription(\"Load version\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\", \"last\");\n\n    RailsHandler.addFormatParam(action);\n  }","id":93304,"modified_method":"private void defineIndexAction(NewController controller) {\n    WebService.NewAction action = controller.createAction(\"index\")\n      .setDescription(\"Search for projects\")\n      .setSince(\"2.10\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"projects-example-index.json\"));\n\n    action.createParam(\"key\")\n      .setDescription(\"id or key of the project\")\n      .setExampleValue(\"org.codehaus.sonar:sonar\");\n\n    action.createParam(\"search\")\n      .setDescription(\"Substring of project name, case insensitive\")\n      .setExampleValue(\"Sonar\");\n\n    action.createParam(\"desc\")\n      .setDescription(\"Load project description\")\n      .setDefaultValue(\"true\")\n      .setPossibleValues(\"true\", \"false\");\n\n    action.createParam(\"subprojects\")\n      .setDescription(\"Load sub-projects. Ignored if the parameter key is set\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\");\n\n    action.createParam(\"views\")\n      .setDescription(\"Load views and sub-views. Ignored if the parameter key is set\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\");\n\n    action.createParam(\"libs\")\n      .setDescription(\"Load libraries. Ignored if the parameter key is set\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\");\n\n    action.createParam(\"versions\")\n      .setDescription(\"Load version\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\", \"last\");\n\n    RailsHandler.addFormatParam(action);\n  }","commit_id":"c3265ba39c8b6646b6e4dab69cf20af3b9865b45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineSearchAction(NewController controller) {\n    NewAction action = controller.createAction(\"search\")\n      .setDescription(\"Search for components\")\n      .setSince(\"3.3\")\n      .setInternal(true)\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"resources-example-search.json\"));\n\n    action.createParam(\"s\")\n      .setDescription(\"To filter on resources containing a specified text in their key\")\n      .setExampleValue(\"sonar\");\n\n    action.createParam(\"display_key\")\n      .setDescription(\"Return the resource key instead of the resource id\")\n      .setDefaultValue(\"false\")\n      .setBooleanPossibleValues();\n\n    action.createParam(\"q\")\n      .setDescription(\"Comma-separated list of qualifiers\")\n      .setExampleValue(\"TRK,BRC\");\n\n    action.createParam(\"qp\")\n      .setDescription(\"Resource Property\")\n      .setExampleValue(\"supportsMeasureFilters\");\n\n    action.createParam(\"f\")\n      .setDescription(\"If 's2', then it will return a select2 compatible format\")\n      .setExampleValue(\"s2\");\n\n    action.createParam(\"p\")\n      .setDescription(\"Page index\")\n      .setDefaultValue(\"1\")\n      .setExampleValue(\"2\");\n\n    action.createParam(\"ps\")\n      .setDescription(\"Page size\")\n      .setDefaultValue(\"10\")\n      .setExampleValue(\"15\");\n\n    RailsHandler.addJsonOnlyFormatParam(action);\n  }","id":93305,"modified_method":"private void defineSearchAction(NewController controller) {\n    NewAction action = controller.createAction(\"search\")\n      .setDescription(\"Search for components\")\n      .setSince(\"3.3\")\n      .setInternal(true)\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"resources-example-search.json\"));\n\n    action.createParam(\"s\")\n      .setDescription(\"To filter on resources containing a specified text in their key\")\n      .setExampleValue(\"sonar\");\n\n    action.createParam(\"display_key\")\n      .setDescription(\"Return the resource key instead of the resource id\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\");\n\n    action.createParam(\"q\")\n      .setDescription(\"Comma-separated list of qualifiers\")\n      .setExampleValue(\"TRK,BRC\");\n\n    action.createParam(\"qp\")\n      .setDescription(\"Resource Property\")\n      .setExampleValue(\"supportsMeasureFilters\");\n\n    action.createParam(\"f\")\n      .setDescription(\"If 's2', then it will return a select2 compatible format\")\n      .setExampleValue(\"s2\");\n\n    action.createParam(\"p\")\n      .setDescription(\"Page index\")\n      .setDefaultValue(\"1\")\n      .setExampleValue(\"2\");\n\n    action.createParam(\"ps\")\n      .setDescription(\"Page size\")\n      .setDefaultValue(\"10\")\n      .setExampleValue(\"15\");\n\n    RailsHandler.addJsonOnlyFormatParam(action);\n  }","commit_id":"c3265ba39c8b6646b6e4dab69cf20af3b9865b45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineIndexAction(NewController controller) {\n    NewAction action = controller.createAction(\"index\")\n      .setDescription(\"Get a list of components. Requires Browse permission on resource\")\n      .setSince(\"2.10\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"resources-example-index.json\"));\n\n    action.createParam(\"resource\")\n      .setDescription(\"id or key of the resource\")\n      .setExampleValue(\"org.codehaus.sonar:sonar\");\n\n    action.createParam(\"metrics\")\n      .setDescription(\"Comma-separated list of <a href=\\\"http://docs.codehaus.org/display/SONAR/Metric+definitions\\\">metric keys/ids<\/a>. \" +\n        \"Load measures on selected metrics. If only one metric is set, then measures are ordered by value\")\n      .setExampleValue(\"lines,blocker_violations\");\n\n    action.createParam(\"depth\")\n      .setDescription(\"Used only when resource is set:<br/>\" +\n        \"<ul>\" +\n        \"<li>0: only selected resource<\/li>\" +\n        \"<li>-1: all children, including selected resource<\/li>\" +\n        \"<li>>0: depth toward the selected resource<\/li>\" +\n        \"<\/ul>\")\n      .setDefaultValue(\"0\")\n      .setExampleValue(\"-1\");\n\n    action.createParam(\"scopes\")\n      .setDescription(\"Comma-separated list of scopes:<br/>\" +\n        \"<ul>\" +\n        \"<li>PRJ: project/module<\/li>\" +\n        \"<li>DIR: directory (like Java package)<\/li>\" +\n        \"<li>FIL: file<\/li>\" +\n        \"<\/ul>\")\n      .setExampleValue(\"PRJ,DIR\");\n\n    action.createParam(\"qualifiers\")\n      .setDescription(\"Comma-separated list of qualifiers:<br/>\" +\n        \"<ul>\" +\n        \"<li>VW: view<\/li>\" +\n        \"<li>SVW: sub-view<\/li>\" +\n        \"<li>TRK: project<\/li>\" +\n        \"<li>BRC: module<\/li>\" +\n        \"<li>UTS: unit test<\/li>\" +\n        \"<li>DIR: directory<\/li>\" +\n        \"<li>FIL: file<\/li>\" +\n        \"<li>DEV: developer<\/li>\" +\n        \"<\/ul>\")\n      .setExampleValue(\"TRK,BRC\");\n\n    action.createParam(\"verbose\")\n      .setDescription(\"Add some data to response\")\n      .setDefaultValue(\"false\")\n      .setBooleanPossibleValues();\n\n    action.createParam(\"limit\")\n      .setDescription(\"Limit the number of results. Only used if one metric, and only one, is set\")\n      .setExampleValue(\"10\");\n\n    action.createParam(\"includetrends\")\n      .setDescription(\"Include trends and period variations in response: add &lttrend&gt (1 if better, else worse), &ltvar&gt (1 if measure value increases) \" +\n        \"and nodes &ltp*&gt for period variations\")\n      .setDefaultValue(\"false\")\n      .setBooleanPossibleValues();\n\n    action.createParam(\"includealerts\")\n      .setDescription(\"Include alerts data: add nodes &ltalert&gt (ERROR, WARN, OK) and &ltalert_text&gt\")\n      .setDefaultValue(\"false\")\n      .setBooleanPossibleValues();\n\n    action.createParam(\"rules\")\n      .setDescription(\"Filter on rules: setting it to true will return rules id and rule name for measure having such info \" +\n        \"(such as 'blocker_violations', 'critical_violations', ..., 'new_blocker_violations', ...). Possible values: true | false | list of rule ids\")\n      .setDefaultValue(\"false\")\n      .setExampleValue(\"true\");\n\n    RailsHandler.addFormatParam(action);\n  }","id":93306,"modified_method":"private void defineIndexAction(NewController controller) {\n    NewAction action = controller.createAction(\"index\")\n      .setDescription(\"Get a list of components. Requires Browse permission on resource\")\n      .setSince(\"2.10\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"resources-example-index.json\"));\n\n    action.createParam(\"resource\")\n      .setDescription(\"id or key of the resource\")\n      .setExampleValue(\"org.codehaus.sonar:sonar\");\n\n    action.createParam(\"metrics\")\n      .setDescription(\"Comma-separated list of <a href=\\\"http://docs.codehaus.org/display/SONAR/Metric+definitions\\\">metric keys/ids<\/a>. \" +\n        \"Load measures on selected metrics. If only one metric is set, then measures are ordered by value\")\n      .setExampleValue(\"lines,blocker_violations\");\n\n    action.createParam(\"depth\")\n      .setDescription(\"Used only when resource is set:<br/>\" +\n        \"<ul>\" +\n        \"<li>0: only selected resource<\/li>\" +\n        \"<li>-1: all children, including selected resource<\/li>\" +\n        \"<li>>0: depth toward the selected resource<\/li>\" +\n        \"<\/ul>\")\n      .setDefaultValue(\"0\")\n      .setExampleValue(\"-1\");\n\n    action.createParam(\"scopes\")\n      .setDescription(\"Comma-separated list of scopes:<br/>\" +\n        \"<ul>\" +\n        \"<li>PRJ: project/module<\/li>\" +\n        \"<li>DIR: directory (like Java package)<\/li>\" +\n        \"<li>FIL: file<\/li>\" +\n        \"<\/ul>\")\n      .setExampleValue(\"PRJ,DIR\");\n\n    action.createParam(\"qualifiers\")\n      .setDescription(\"Comma-separated list of qualifiers:<br/>\" +\n        \"<ul>\" +\n        \"<li>VW: view<\/li>\" +\n        \"<li>SVW: sub-view<\/li>\" +\n        \"<li>TRK: project<\/li>\" +\n        \"<li>BRC: module<\/li>\" +\n        \"<li>UTS: unit test<\/li>\" +\n        \"<li>DIR: directory<\/li>\" +\n        \"<li>FIL: file<\/li>\" +\n        \"<li>DEV: developer<\/li>\" +\n        \"<\/ul>\")\n      .setExampleValue(\"TRK,BRC\");\n\n    action.createParam(\"verbose\")\n      .setDescription(\"Add some data to response\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\");\n\n    action.createParam(\"limit\")\n      .setDescription(\"Limit the number of results. Only used if one metric, and only one, is set\")\n      .setExampleValue(\"10\");\n\n    action.createParam(\"includetrends\")\n      .setDescription(\"Include trends and period variations in response: add &lttrend&gt (1 if better, else worse), &ltvar&gt (1 if measure value increases) \" +\n        \"and nodes &ltp*&gt for period variations\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\");\n\n    action.createParam(\"includealerts\")\n      .setDescription(\"Include alerts data: add nodes &ltalert&gt (ERROR, WARN, OK) and &ltalert_text&gt\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\");\n\n    action.createParam(\"rules\")\n      .setDescription(\"Filter on rules: setting it to true will return rules id and rule name for measure having such info \" +\n        \"(such as 'blocker_violations', 'critical_violations', ..., 'new_blocker_violations', ...). Possible values: true | false | list of rule ids\")\n      .setDefaultValue(\"false\")\n      .setExampleValue(\"true\");\n\n    RailsHandler.addFormatParam(action);\n  }","commit_id":"c3265ba39c8b6646b6e4dab69cf20af3b9865b45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineSearchAction(NewController controller) {\n    NewAction action = controller.createAction(\"search\")\n      .setDescription(\"Get a list of users\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"example-search.json\"));\n\n    action.createParam(\"includeDeactivated\")\n      .setDescription(\"Include deactivated users\")\n      .setDefaultValue(\"false\")\n      .setBooleanPossibleValues();\n\n    action.createParam(\"logins\")\n      .setDescription(\"Comma-separated list of user logins\")\n      .setExampleValue(\"admin,sbrandhof\");\n\n    RailsHandler.addFormatParam(action);\n  }","id":93307,"modified_method":"private void defineSearchAction(NewController controller) {\n    NewAction action = controller.createAction(\"search\")\n      .setDescription(\"Get a list of users\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"example-search.json\"));\n\n    action.createParam(\"includeDeactivated\")\n      .setDescription(\"Include deactivated users\")\n      .setDefaultValue(\"false\")\n      .setPossibleValues(\"true\", \"false\");\n\n    action.createParam(\"logins\")\n      .setDescription(\"Comma-separated list of user logins\")\n      .setExampleValue(\"admin,sbrandhof\");\n\n    RailsHandler.addFormatParam(action);\n  }","commit_id":"c3265ba39c8b6646b6e4dab69cf20af3b9865b45","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Endpoint resolveEndpoint(RouteContext context) {\n        if (endpoint == null) {\n            endpoint = context.resolveEndpoint(getUri(), getRef());\n        }\n        return endpoint;\n    }","id":93308,"modified_method":"public Endpoint resolveEndpoint(RouteContext context) {\n        if (endpoint == null) {\n            return context.resolveEndpoint(getUri(), getRef());\n        } else {\n            return endpoint;\n        }\n        \n    }","commit_id":"4c9af35929281149f8a08445514c2b6daa436e80","url":"https://github.com/apache/camel"},{"original_method":"public void testInvalidFrom() throws Exception {\n        try {\n            context.addRoutes(new RouteBuilder() {\n                @Override\n                public void configure() throws Exception {\n                    from(\"direct:start?foo=bar\").routeId(\"route1\").to(\"mock:result\");\n                }\n            });\n            context.start();\n            fail();\n        } catch (FailedToCreateRouteException e) {\n            assertTrue(e.getMessage().startsWith(\"Failed to create route route1: Route[[From[direct:start?foo=bar]]\"));\n        }\n    }","id":93309,"modified_method":"public void testInvalidFrom() throws Exception {\n        try {\n            context.addRoutes(new RouteBuilder() {\n                @Override\n                public void configure() throws Exception {\n                    from(\"direct:start?foo=bar\").routeId(\"route1\").to(\"mock:result\");\n                }\n            });\n            context.start();\n            fail();\n        } catch (FailedToCreateRouteException e) {\n            assertTrue(e.getMessage().startsWith(\"Failed to create route route1: Route[[From[direct:start?foo=bar]] -> [To[mock:result]]] because of\"));\n        }\n    }","commit_id":"4c9af35929281149f8a08445514c2b6daa436e80","url":"https://github.com/apache/camel"},{"original_method":"public void testInvalidTo() throws Exception {\n        try {\n            context.addRoutes(new RouteBuilder() {\n                @Override\n                public void configure() throws Exception {\n                    from(\"direct:start\").routeId(\"route2\").to(\"mock:result?foo=bar\");\n                }\n            });\n            context.start();\n            fail();\n        } catch (FailedToCreateRouteException e) {\n            assertTrue(e.getMessage(), e.getMessage().startsWith(\"Failed to create route route2 at: >>> To[mock:result?foo=bar]\"));\n        }\n    }","id":93310,"modified_method":"public void testInvalidTo() throws Exception {\n        try {\n            context.addRoutes(new RouteBuilder() {\n                @Override\n                public void configure() throws Exception {\n                    from(\"direct:start\").routeId(\"route2\").to(\"mock:result?foo=bar\");\n                }\n            });\n            context.start();\n            fail();\n        } catch (FailedToCreateRouteException e) {\n            assertTrue(e.getMessage().startsWith(\"Failed to create route route2 at: >>> To[mock:result?foo=bar] <<< in route: Route[[From[direct:start]] -> [To[mock:result?foo=bar]]] because of\"));\n        }\n    }","commit_id":"4c9af35929281149f8a08445514c2b6daa436e80","url":"https://github.com/apache/camel"},{"original_method":"public void testInvalidBean() throws Exception {\n        try {\n            context.addRoutes(new RouteBuilder() {\n                @Override\n                public void configure() throws Exception {\n                    from(\"direct:start\").routeId(\"route3\")\n                        .to(\"mock:foo\")\n                        .beanRef(\"\");\n                }\n            });\n            context.start();\n        } catch (FailedToCreateRouteException e) {\n            assertTrue(e.getMessage(), e.getMessage().startsWith(\"Failed to create route route3 at: >>> Bean[ref:] <<< in route: Route[[From[direct://start]] -> [To[mock:foo], Bean[ref:]]] because of\"));\n        }\n    }","id":93311,"modified_method":"public void testInvalidBean() throws Exception {\n        try {\n            context.addRoutes(new RouteBuilder() {\n                @Override\n                public void configure() throws Exception {\n                    from(\"direct:start\").routeId(\"route3\")\n                        .to(\"mock:foo\")\n                        .beanRef(\"\");\n                }\n            });\n            context.start();\n        } catch (FailedToCreateRouteException e) {\n            assertTrue(e.getMessage().startsWith(\"Failed to create route route3 at: >>> Bean[ref:] <<< in route: Route[[From[direct:start]] -> [To[mock:foo], Bean[ref:]]] because of\"));\n        }\n    }","commit_id":"4c9af35929281149f8a08445514c2b6daa436e80","url":"https://github.com/apache/camel"},{"original_method":"public void testDualPipeline() throws Exception {\n        getMockEndpoint(\"mock:a\").expectedBodiesReceived(\"Hello World\");\n        getMockEndpoint(\"mock:b\").expectedBodiesReceived(\"After A\");\n        getMockEndpoint(\"mock:c\").expectedBodiesReceived(\"Hello World\");\n        getMockEndpoint(\"mock:d\").expectedBodiesReceived(\"After C\");\n        getMockEndpoint(\"mock:e\").expectedBodiesReceived(\"After C\");\n        getMockEndpoint(\"mock:result\").expectedMessageCount(1);\n\n        template.sendBody(\"direct:start\", \"Hello World\");\n\n        assertMockEndpointsSatisfied();\n\n        // now check the route\n        MulticastDefinition mc = assertIsInstanceOf(MulticastDefinition.class, context.getRouteDefinitions().get(0).getOutputs().get(0));\n        PipelineDefinition pd1 = assertIsInstanceOf(PipelineDefinition.class, mc.getOutputs().get(0));\n        PipelineDefinition pd2 = assertIsInstanceOf(PipelineDefinition.class, mc.getOutputs().get(1));\n\n        assertEquals(3, pd1.getOutputs().size());\n        assertEquals(4, pd2.getOutputs().size());\n\n        SendDefinition send1 = assertIsInstanceOf(SendDefinition.class, pd1.getOutputs().get(2));\n        assertEquals(\"mock://b\", send1.getEndpoint().getEndpointUri());\n\n        SendDefinition send2 = assertIsInstanceOf(SendDefinition.class, pd2.getOutputs().get(3));\n        assertEquals(\"mock://e\", send2.getEndpoint().getEndpointUri());\n\n        SendDefinition send = assertIsInstanceOf(SendDefinition.class, context.getRouteDefinitions().get(0).getOutputs().get(1));\n        assertEquals(\"mock://result\", send.getEndpoint().getEndpointUri());\n    }","id":93312,"modified_method":"public void testDualPipeline() throws Exception {\n        getMockEndpoint(\"mock:a\").expectedBodiesReceived(\"Hello World\");\n        getMockEndpoint(\"mock:b\").expectedBodiesReceived(\"After A\");\n        getMockEndpoint(\"mock:c\").expectedBodiesReceived(\"Hello World\");\n        getMockEndpoint(\"mock:d\").expectedBodiesReceived(\"After C\");\n        getMockEndpoint(\"mock:e\").expectedBodiesReceived(\"After C\");\n        getMockEndpoint(\"mock:result\").expectedMessageCount(1);\n\n        template.sendBody(\"direct:start\", \"Hello World\");\n\n        assertMockEndpointsSatisfied();\n\n        // now check the route\n        MulticastDefinition mc = assertIsInstanceOf(MulticastDefinition.class, context.getRouteDefinitions().get(0).getOutputs().get(0));\n        PipelineDefinition pd1 = assertIsInstanceOf(PipelineDefinition.class, mc.getOutputs().get(0));\n        PipelineDefinition pd2 = assertIsInstanceOf(PipelineDefinition.class, mc.getOutputs().get(1));\n\n        assertEquals(3, pd1.getOutputs().size());\n        assertEquals(4, pd2.getOutputs().size());\n\n        SendDefinition send1 = assertIsInstanceOf(SendDefinition.class, pd1.getOutputs().get(2));\n        assertEquals(\"mock:b\", send1.getUri());\n\n        SendDefinition send2 = assertIsInstanceOf(SendDefinition.class, pd2.getOutputs().get(3));\n        assertEquals(\"mock:e\", send2.getUri());\n\n        SendDefinition send = assertIsInstanceOf(SendDefinition.class, context.getRouteDefinitions().get(0).getOutputs().get(1));\n        assertEquals(\"mock:result\", send.getUri());\n    }","commit_id":"78ae888c0095059467d42df85548b58b0a08625c","url":"https://github.com/apache/camel"},{"original_method":"public Endpoint resolveEndpoint(RouteContext context) {\n        if (endpoint == null) {\n            endpoint = context.resolveEndpoint(getUri(), getRef());\n        }\n        return endpoint;\n    }","id":93313,"modified_method":"public Endpoint resolveEndpoint(RouteContext context) {\n        if (endpoint == null) {\n            return context.resolveEndpoint(getUri(), getRef());\n        } else {\n            return endpoint;\n        }\n        \n    }","commit_id":"78ae888c0095059467d42df85548b58b0a08625c","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    private void navigateDefinition(ProcessorDefinition<?> def, StringBuilder sb) {\n\n        // must do this ugly cast to avoid compiler error on HP-UX\n        ProcessorDefinition defn = (ProcessorDefinition) def;\n\n        if (defn instanceof LoadBalanceDefinition) {\n            sb.append(\".loadBalance()\");\n\n            LoadBalanceDefinition lbd = (LoadBalanceDefinition) defn;\n            LoadBalancer balancer = lbd.getLoadBalancerType().getLoadBalancer(null);\n            if (balancer instanceof RandomLoadBalancer) {\n                sb.append(\".random()\");\n            }\n        }\n\n        if (defn instanceof SendDefinition) {\n            SendDefinition send = (SendDefinition) defn;\n            sb.append(\".to(\\\"\" + send.getEndpoint().getEndpointUri() + \"\\\")\");\n        }\n\n        List<ProcessorDefinition> children = defn.getOutputs();\n        if (children == null || children.isEmpty()) {\n            return;\n        }\n\n        for (ProcessorDefinition child : children) {\n            navigateDefinition(child, sb);\n        }\n    }","id":93314,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private void navigateDefinition(ProcessorDefinition<?> def, StringBuilder sb) {\n\n        // must do this ugly cast to avoid compiler error on HP-UX\n        ProcessorDefinition defn = (ProcessorDefinition) def;\n\n        if (defn instanceof LoadBalanceDefinition) {\n            sb.append(\".loadBalance()\");\n\n            LoadBalanceDefinition lbd = (LoadBalanceDefinition) defn;\n            LoadBalancer balancer = lbd.getLoadBalancerType().getLoadBalancer(null);\n            if (balancer instanceof RandomLoadBalancer) {\n                sb.append(\".random()\");\n            }\n        }\n\n        if (defn instanceof SendDefinition) {\n            SendDefinition send = (SendDefinition) defn;\n            sb.append(\".to(\\\"\" + send.getUri() + \"\\\")\");\n        }\n\n        List<ProcessorDefinition> children = defn.getOutputs();\n        if (children == null || children.isEmpty()) {\n            return;\n        }\n\n        for (ProcessorDefinition child : children) {\n            navigateDefinition(child, sb);\n        }\n    }","commit_id":"78ae888c0095059467d42df85548b58b0a08625c","url":"https://github.com/apache/camel"},{"original_method":"public void testNavigateRouteAsJavaDSL() throws Exception {\n        // this one navigate using the route definition\n\n        StringBuilder sb = new StringBuilder();\n\n        RouteDefinition route = context.getRouteDefinitions().get(0);\n\n        // the start of the route\n        sb.append(\"from(\\\"\" + route.getInputs().get(0).getEndpoint().getEndpointUri() + \"\\\")\");\n\n        // navigate the route and add Java DSL to the sb\n        navigateDefinition(route, sb);\n\n        // output the Java DSL\n        assertEquals(\"from(\\\"direct://start\\\").loadBalance().random().to(\\\"mock://x\\\").to(\\\"mock://y\\\").to(\\\"mock://z\\\")\", sb.toString());\n    }","id":93315,"modified_method":"public void testNavigateRouteAsJavaDSL() throws Exception {\n        // this one navigate using the route definition\n\n        StringBuilder sb = new StringBuilder();\n\n        RouteDefinition route = context.getRouteDefinitions().get(0);\n\n        // the start of the route\n        sb.append(\"from(\\\"\" + route.getInputs().get(0).getUri() + \"\\\")\");\n\n        // navigate the route and add Java DSL to the sb\n        navigateDefinition(route, sb);\n\n        // output the Java DSL\n        assertEquals(\"from(\\\"direct://start\\\").loadBalance().random().to(\\\"mock://x\\\").to(\\\"mock://y\\\").to(\\\"mock://z\\\")\", sb.toString());\n    }","commit_id":"78ae888c0095059467d42df85548b58b0a08625c","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n\n        x = getMockEndpoint(\"mock:x\");\n        y = getMockEndpoint(\"mock:y\");\n        z = getMockEndpoint(\"mock:z\");\n    }","id":93316,"modified_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n\n        x = getMockEndpoint(\"mock://x\");\n        y = getMockEndpoint(\"mock://y\");\n        z = getMockEndpoint(\"mock://z\");\n    }","commit_id":"78ae888c0095059467d42df85548b58b0a08625c","url":"https://github.com/apache/camel"},{"original_method":"protected RouteBuilder createRouteBuilder() {\n        return new RouteBuilder() {\n            public void configure() {\n                from(\"direct:start\").loadBalance().\n                random().to(\"mock:x\", \"mock:y\", \"mock:z\");\n            }\n        };\n    }","id":93317,"modified_method":"protected RouteBuilder createRouteBuilder() {\n        return new RouteBuilder() {\n            public void configure() {\n                from(\"direct://start\").loadBalance().\n                random().to(\"mock://x\", \"mock://y\", \"mock://z\");\n            }\n        };\n    }","commit_id":"78ae888c0095059467d42df85548b58b0a08625c","url":"https://github.com/apache/camel"},{"original_method":"public Endpoint resolveEndpoint(RouteContext context) {\n        if (endpoint == null) {\n            endpoint = context.resolveEndpoint(getUri(), getRef());\n        }\n        return endpoint;\n    }","id":93318,"modified_method":"public Endpoint resolveEndpoint(RouteContext context) {\n        if (endpoint == null) {\n            return context.resolveEndpoint(getUri(), getRef());\n        } else {\n            return endpoint;\n        }\n    }","commit_id":"78ae888c0095059467d42df85548b58b0a08625c","url":"https://github.com/apache/camel"},{"original_method":"public void testInvalidBean() throws Exception {\n        try {\n            context.addRoutes(new RouteBuilder() {\n                @Override\n                public void configure() throws Exception {\n                    from(\"direct:start\").routeId(\"route3\")\n                        .to(\"mock:foo\")\n                        .beanRef(\"\");\n                }\n            });\n            context.start();\n        } catch (FailedToCreateRouteException e) {\n            assertTrue(e.getMessage().startsWith(\"Failed to create route route3 at: >>> Bean[ref:] <<< in route: Route[[From[direct://start]] -> [To[mock://foo], Bean[ref:]]... because of\"));\n        }\n    }","id":93319,"modified_method":"public void testInvalidBean() throws Exception {\n        try {\n            context.addRoutes(new RouteBuilder() {\n                @Override\n                public void configure() throws Exception {\n                    from(\"direct:start\").routeId(\"route3\")\n                        .to(\"mock:foo\")\n                        .beanRef(\"\");\n                }\n            });\n            context.start();\n        } catch (FailedToCreateRouteException e) {\n            assertTrue(e.getMessage().startsWith(\"Failed to create route route3 at: >>> Bean[ref:] <<< in route: Route[[From[direct:start]] -> [To[mock:foo], Bean[ref:]]] because of\"));\n        }\n    }","commit_id":"78ae888c0095059467d42df85548b58b0a08625c","url":"https://github.com/apache/camel"},{"original_method":"public void testInvalidTo() throws Exception {\n        try {\n            context.addRoutes(new RouteBuilder() {\n                @Override\n                public void configure() throws Exception {\n                    from(\"direct:start\").routeId(\"route2\").to(\"mock:result?foo=bar\");\n                }\n            });\n            context.start();\n            fail();\n        } catch (FailedToCreateRouteException e) {\n            assertTrue(e.getMessage().startsWith(\"Failed to create route route2 at: >>> To[mock:result?foo=bar] <<< in route: Route[[From[direct://start]] -> [To[mock:result?foo=bar]]] because of\"));\n        }\n    }","id":93320,"modified_method":"public void testInvalidTo() throws Exception {\n        try {\n            context.addRoutes(new RouteBuilder() {\n                @Override\n                public void configure() throws Exception {\n                    from(\"direct:start\").routeId(\"route2\").to(\"mock:result?foo=bar\");\n                }\n            });\n            context.start();\n            fail();\n        } catch (FailedToCreateRouteException e) {\n            assertTrue(e.getMessage().startsWith(\"Failed to create route route2 at: >>> To[mock:result?foo=bar] <<< in route: Route[[From[direct:start]] -> [To[mock:result?foo=bar]]] because of\"));\n        }\n    }","commit_id":"78ae888c0095059467d42df85548b58b0a08625c","url":"https://github.com/apache/camel"},{"original_method":"protected void assertValidContext(CamelContext context) {\n        assertNotNull(\"No context found!\", context);\n\n        List<RouteDefinition> routes = context.getRouteDefinitions();\n        LOG.debug(\"Found routes: \" + routes);\n\n        assertEquals(\"One Route should be found\", 1, routes.size());\n\n        for (RouteDefinition route : routes) {\n            List<FromDefinition> inputs = route.getInputs();\n            assertEquals(\"Number of inputs\", 1, inputs.size());\n            FromDefinition fromType = inputs.get(0);\n            assertEquals(\"from URI\", \"seda://test.a\", fromType.getEndpoint().getEndpointUri());\n\n            List<ProcessorDefinition> outputs = route.getOutputs();\n            assertEquals(\"Number of outputs\", 1, outputs.size());\n        }\n    }","id":93321,"modified_method":"protected void assertValidContext(CamelContext context) {\n        assertNotNull(\"No context found!\", context);\n\n        List<RouteDefinition> routes = context.getRouteDefinitions();\n        LOG.debug(\"Found routes: \" + routes);\n\n        assertEquals(\"One Route should be found\", 1, routes.size());\n\n        for (RouteDefinition route : routes) {\n            List<FromDefinition> inputs = route.getInputs();\n            assertEquals(\"Number of inputs\", 1, inputs.size());\n            FromDefinition fromType = inputs.get(0);\n            assertEquals(\"from URI\", \"seda:test.a\", fromType.getUri());\n\n            List<ProcessorDefinition> outputs = route.getOutputs();\n            assertEquals(\"Number of outputs\", 1, outputs.size());\n        }\n    }","commit_id":"78ae888c0095059467d42df85548b58b0a08625c","url":"https://github.com/apache/camel"},{"original_method":"private void printDescriptionsAndURLs( DependencyNode node )\n    {\n        Artifact artifact = node.getArtifact();\n        String id = artifact.getDependencyConflictId();\n\n        String unknownLicenseMessage = getReportString( \"report.dependencies.graph.tables.unknown\" );\n\n        if ( !Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )\n        {\n            try\n            {\n                MavenProject artifactProject = repoUtils.getMavenProjectFromRepository( artifact, repoUtils\n                    .getLocalRepository() );\n                String artifactDescription = artifactProject.getDescription();\n                String artifactUrl = artifactProject.getUrl();\n                String artifactName = artifactProject.getName();\n                List licenses = artifactProject.getLicenses();\n\n                sink.paragraph();\n                if ( id != null )\n                {\n                    sink.anchor( id );\n                }\n                // startSection( artifactName );\n                sink.bold();\n                sink.text( artifactName );\n                sink.bold_();\n                if ( id != null )\n                {\n                    sink.anchor_();\n                }\n                sink.paragraph_();\n\n                if ( artifactDescription != null )\n                {\n                    sink.paragraph();\n                    sink.text( artifactDescription );\n                    sink.paragraph_();\n                }\n\n                if ( artifactUrl != null )\n                {\n                    sink.paragraph();\n                    sink.link( artifactUrl );\n                    sink.text( artifactUrl );\n                    sink.link_();\n                    sink.paragraph_();\n                }\n\n                sink.paragraph();\n                sink.text( getReportString( \"report.license.title\" ) + \": \" );\n                if ( !licenses.isEmpty() )\n                {\n                    for ( Iterator iter = licenses.iterator(); iter.hasNext(); )\n                    {\n                        License element = (License) iter.next();\n                        String licenseName = element.getName();\n                        String licenseUrl = element.getUrl();\n\n                        if ( licenseUrl != null )\n                        {\n                            sink.link( licenseUrl );\n                        }\n                        sink.text( licenseName );\n\n                        if ( licenseUrl != null )\n                        {\n                            sink.link_();\n                        }\n\n                        licenseMap.put( licenseName, artifactName );\n\n                    }\n                }\n                else\n                {\n                    sink.text( getReportString( \"report.license.nolicense\" ) );\n\n                    licenseMap.put( unknownLicenseMessage, artifactName );\n\n                }\n                sink.paragraph_();\n\n                // endSection();\n                sink.horizontalRule();\n            }\n            catch ( ProjectBuildingException e )\n            {\n                log.error( \"ProjectBuildingException error : \", e );\n            }\n\n            for ( Iterator deps = node.getChildren().iterator(); deps.hasNext(); )\n            {\n                DependencyNode dep = (DependencyNode) deps.next();\n                printDescriptionsAndURLs( dep );\n            }\n        }\n        else\n        {\n            sink.paragraph();\n            sink.anchor( id );\n            sink.bold();\n            sink.text( id );\n            sink.bold_();\n            sink.anchor_();\n            sink.paragraph_();\n\n            sink.paragraph();\n            sink.text( artifact.getFile().toString() );\n            sink.paragraph_();\n        }\n    }","id":93322,"modified_method":"private void printDescriptionsAndURLs( DependencyNode node )\n    {\n        Artifact artifact = node.getArtifact();\n        String id = artifact.getId();\n\n        String unknownLicenseMessage = getReportString( \"report.dependencies.graph.tables.unknown\" );\n\n        if ( !Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )\n        {\n            try\n            {\n                MavenProject artifactProject = repoUtils.getMavenProjectFromRepository( artifact, repoUtils\n                    .getLocalRepository() );\n                String artifactDescription = artifactProject.getDescription();\n                String artifactUrl = artifactProject.getUrl();\n                String artifactName = artifactProject.getName();\n                List licenses = artifactProject.getLicenses();\n\n                sink.paragraph();\n                if ( id != null )\n                {\n                    sink.anchor( id );\n                }\n                // startSection( artifactName );\n                sink.bold();\n                sink.text( artifactName );\n                sink.bold_();\n                if ( id != null )\n                {\n                    sink.anchor_();\n                }\n                sink.paragraph_();\n\n                if ( artifactDescription != null )\n                {\n                    sink.paragraph();\n                    sink.text( artifactDescription );\n                    sink.paragraph_();\n                }\n\n                if ( artifactUrl != null )\n                {\n                    sink.paragraph();\n                    sink.link( artifactUrl );\n                    sink.text( artifactUrl );\n                    sink.link_();\n                    sink.paragraph_();\n                }\n\n                sink.paragraph();\n                sink.text( getReportString( \"report.license.title\" ) + \": \" );\n                if ( !licenses.isEmpty() )\n                {\n                    for ( Iterator iter = licenses.iterator(); iter.hasNext(); )\n                    {\n                        License element = (License) iter.next();\n                        String licenseName = element.getName();\n                        String licenseUrl = element.getUrl();\n\n                        if ( licenseUrl != null )\n                        {\n                            sink.link( licenseUrl );\n                        }\n                        sink.text( licenseName );\n\n                        if ( licenseUrl != null )\n                        {\n                            sink.link_();\n                        }\n\n                        licenseMap.put( licenseName, artifactName );\n\n                    }\n                }\n                else\n                {\n                    sink.text( getReportString( \"report.license.nolicense\" ) );\n\n                    licenseMap.put( unknownLicenseMessage, artifactName );\n\n                }\n                sink.paragraph_();\n\n                // endSection();\n                sink.horizontalRule();\n            }\n            catch ( ProjectBuildingException e )\n            {\n                log.error( \"ProjectBuildingException error : \", e );\n            }\n\n            for ( Iterator deps = node.getChildren().iterator(); deps.hasNext(); )\n            {\n                DependencyNode dep = (DependencyNode) deps.next();\n                printDescriptionsAndURLs( dep );\n            }\n        }\n        else\n        {\n            sink.paragraph();\n            sink.anchor( id );\n            sink.bold();\n            sink.text( id );\n            sink.bold_();\n            sink.anchor_();\n            sink.paragraph_();\n\n            sink.paragraph();\n            sink.text( artifact.getFile().toString() );\n            sink.paragraph_();\n        }\n    }","commit_id":"d6c385ca23bdab9db4512ecf77b82d1becb5ae13","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void printDependencyListing( DependencyNode node )\n    {\n        Artifact artifact = node.getArtifact();\n        String id = artifact.getDependencyConflictId();\n\n        sink.listItem();\n        sink.paragraph();\n\n        sink.link( \"#\" + id );\n        sink.text( id );\n        sink.link_();\n\n        if ( !node.getChildren().isEmpty() )\n        {\n            sink.list();\n            for ( Iterator deps = node.getChildren().iterator(); deps.hasNext(); )\n            {\n                DependencyNode dep = (DependencyNode) deps.next();\n                printDependencyListing( dep );\n            }\n            sink.list_();\n        }\n\n        sink.paragraph_();\n        sink.listItem_();\n    }","id":93323,"modified_method":"private void printDependencyListing( DependencyNode node )\n    {\n        Artifact artifact = node.getArtifact();\n        String id = artifact.getId();\n\n        sink.listItem();\n        sink.paragraph();\n\n        if ( id != null )\n        {\n            sink.link( \"#\" + id );\n        }\n        sink.text( id );\n        if ( id != null )\n        {\n            sink.link_();\n        }\n\n        if ( !node.getChildren().isEmpty() )\n        {\n            sink.list();\n            for ( Iterator deps = node.getChildren().iterator(); deps.hasNext(); )\n            {\n                DependencyNode dep = (DependencyNode) deps.next();\n                printDependencyListing( dep );\n            }\n            sink.list_();\n        }\n\n        sink.paragraph_();\n        sink.listItem_();\n    }","commit_id":"d6c385ca23bdab9db4512ecf77b82d1becb5ae13","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void generateHTML(String title, StringBuilder sb) {\n    if(title != null && !title.isEmpty()) DocGen.HTML.title(sb, title);\n    DocGen.HTML.paragraph(sb, \"Model Key: \" + _key);\n\n    sb.append(\"<script type=\\\"text/javascript\\\" src='/h2o/js/d3.v3.min.js'><\/script>\");\n    sb.append(\"<div class='alert'>Actions: \" + PCAScore.link(_key, \"Score on dataset\") + \", \"\n        + PCA.link(_dataKey, \"Compute new model\") + \"<\/div>\");\n    screevarString(sb);\n    sb.append(\"<span style='display: inline-block;'>\");\n    sb.append(\"<table class='table table-striped table-bordered'>\");\n    sb.append(\"<tr>\");\n    sb.append(\"<th>Feature<\/th>\");\n\n    for(int i = 0; i < num_pc; i++)\n      sb.append(\"<th>\").append(\"PC\" + i).append(\"<\/th>\");\n    sb.append(\"<\/tr>\");\n\n    // Row of standard deviation values\n    sb.append(\"<tr class='warning'>\");\n    // sb.append(\"<td>\").append(\"&sigma;\").append(\"<\/td>\");\n    sb.append(\"<td>\").append(\"Std Dev\").append(\"<\/td>\");\n    for(int c = 0; c < num_pc; c++)\n      sb.append(\"<td>\").append(ElementBuilder.format(sdev[c])).append(\"<\/td>\");\n    sb.append(\"<\/tr>\");\n\n    // Row with proportion of variance\n    sb.append(\"<tr class='warning'>\");\n    sb.append(\"<td>\").append(\"Prop Var\").append(\"<\/td>\");\n    for(int c = 0; c < num_pc; c++)\n      sb.append(\"<td>\").append(ElementBuilder.format(propVar[c])).append(\"<\/td>\");\n    sb.append(\"<\/tr>\");\n\n    // Row with cumulative proportion of variance\n    sb.append(\"<tr class='warning'>\");\n    sb.append(\"<td>\").append(\"Cum Prop Var\").append(\"<\/td>\");\n    for(int c = 0; c < num_pc; c++)\n      sb.append(\"<td>\").append(ElementBuilder.format(cumVar[c])).append(\"<\/td>\");\n    sb.append(\"<\/tr>\");\n\n    // Each row is component of eigenvector\n    for(int r = 0; r < eigVec.length; r++) {\n      sb.append(\"<tr>\");\n      sb.append(\"<th>\").append(namesExp[r]).append(\"<\/th>\");\n      for( int c = 0; c < num_pc; c++ ) {\n        double e = eigVec[r][c];\n        sb.append(\"<td>\").append(ElementBuilder.format(e)).append(\"<\/td>\");\n      }\n      sb.append(\"<\/tr>\");\n    }\n    sb.append(\"<\/table><\/span>\");\n  }","id":93324,"modified_method":"public void generateHTML(String title, StringBuilder sb) {\n    if(title != null && !title.isEmpty()) DocGen.HTML.title(sb, title);\n    DocGen.HTML.paragraph(sb, \"Model Key: \" + _key);\n\n    sb.append(\"<script type=\\\"text/javascript\\\" src='/h2o/js/d3.v3.min.js'><\/script>\");\n    sb.append(\"<div class='alert'>Actions: \" + PCAScore.link(_key, \"Score on dataset\") + (_dataKey != null ? (\", \" + PCA.link(_dataKey, \"Compute new model\")):\"\") + \"<\/div>\");\n    screevarString(sb);\n    sb.append(\"<span style='display: inline-block;'>\");\n    sb.append(\"<table class='table table-striped table-bordered'>\");\n    sb.append(\"<tr>\");\n    sb.append(\"<th>Feature<\/th>\");\n\n    for(int i = 0; i < num_pc; i++)\n      sb.append(\"<th>\").append(\"PC\" + i).append(\"<\/th>\");\n    sb.append(\"<\/tr>\");\n\n    // Row of standard deviation values\n    sb.append(\"<tr class='warning'>\");\n    // sb.append(\"<td>\").append(\"&sigma;\").append(\"<\/td>\");\n    sb.append(\"<td>\").append(\"Std Dev\").append(\"<\/td>\");\n    for(int c = 0; c < num_pc; c++)\n      sb.append(\"<td>\").append(ElementBuilder.format(sdev[c])).append(\"<\/td>\");\n    sb.append(\"<\/tr>\");\n\n    // Row with proportion of variance\n    sb.append(\"<tr class='warning'>\");\n    sb.append(\"<td>\").append(\"Prop Var\").append(\"<\/td>\");\n    for(int c = 0; c < num_pc; c++)\n      sb.append(\"<td>\").append(ElementBuilder.format(propVar[c])).append(\"<\/td>\");\n    sb.append(\"<\/tr>\");\n\n    // Row with cumulative proportion of variance\n    sb.append(\"<tr class='warning'>\");\n    sb.append(\"<td>\").append(\"Cum Prop Var\").append(\"<\/td>\");\n    for(int c = 0; c < num_pc; c++)\n      sb.append(\"<td>\").append(ElementBuilder.format(cumVar[c])).append(\"<\/td>\");\n    sb.append(\"<\/tr>\");\n\n    // Each row is component of eigenvector\n    for(int r = 0; r < eigVec.length; r++) {\n      sb.append(\"<tr>\");\n      sb.append(\"<th>\").append(namesExp[r]).append(\"<\/th>\");\n      for( int c = 0; c < num_pc; c++ ) {\n        double e = eigVec[r][c];\n        sb.append(\"<td>\").append(ElementBuilder.format(e)).append(\"<\/td>\");\n      }\n      sb.append(\"<\/tr>\");\n    }\n    sb.append(\"<\/table><\/span>\");\n  }","commit_id":"ad51155336b27404b9fbd89f20fa38a602c1e7ea","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test public void testLinDep() throws InterruptedException, ExecutionException {\n    Key kdata = Key.make(\"depdata.hex\");\n    PCAModel model = null;\n    Frame fr = null;\n    double[] sdev_R = {1.414214, 0};\n\n    try {\n      Key kraw = Key.make(\"depdata.raw\");\n      FVecTest.makeByteVec(kraw, \"x1,x2\\n0,0\\n1,2\\n2,4\\n3,6\\n4,8\\n5,10\");\n      fr = ParseDataset2.parse(kdata, new Key[]{kraw});\n\n      Key kpca = Key.make(\"depdata.pca\");\n      new PCA(\"PCA on data with dependent cols\", kpca, fr, 0.0, true).invoke();\n      model = DKV.get(kpca).get();\n\n      for(int i = 0; i < model.sdev().length; i++)\n        Assert.assertEquals(sdev_R[i], model.sdev()[i], threshold);\n    } finally {\n      if( fr    != null ) fr   .delete();\n      if( model != null ) model.delete();\n    }\n  }","id":93325,"modified_method":"@Test public void testLinDep() throws InterruptedException, ExecutionException {\n    Key kdata = Key.make(\"depdata.hex\");\n    PCAModel model = null;\n    Frame fr = null;\n    double[] sdev_R = {1.414214, 0};\n\n    try {\n      Key kraw = Key.make(\"depdata.raw\");\n      FVecTest.makeByteVec(kraw, \"x1,x2\\n0,0\\n1,2\\n2,4\\n3,6\\n4,8\\n5,10\");\n      fr = ParseDataset2.parse(kdata, new Key[]{kraw});\n\n      Key kpca = Key.make(\"depdata.pca\");\n      new PCA(\"PCA on data with dependent cols\", kpca, fr, 0.0, true).invoke();\n      model = DKV.get(kpca).get();\n      testHTML(model);\n\n      for(int i = 0; i < model.sdev().length; i++)\n        Assert.assertEquals(sdev_R[i], model.sdev()[i], threshold);\n    } finally {\n      if( fr    != null ) fr   .delete();\n      if( model != null ) model.delete();\n    }\n  }","commit_id":"ad51155336b27404b9fbd89f20fa38a602c1e7ea","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test public void testArrests() throws InterruptedException, ExecutionException {\n    double tol = 0.25;\n    boolean standardize = true;\n    PCAModel model = null;\n    Frame fr = null;\n    double[] sdev_R = {1.5748783, 0.9948694, 0.5971291, 0.4164494};\n    double[][] eigv_R = {{-0.5358995, 0.4181809, -0.3412327, 0.64922780},\n                         {-0.5831836, 0.1879856, -0.2681484, -0.74340748},\n                         {-0.2781909, -0.8728062, -0.3780158, 0.13387773},\n                         {-0.5434321, -0.1673186, 0.8177779, 0.08902432}};\n\n    try {\n      Key ksrc = Key.make(\"arrests.hex\");\n      fr = getFrameForFile(ksrc, \"smalldata/pca_test/USArrests.csv\", null);\n\n      // Build PCA model on all columns\n      Key kdst = Key.make(\"arrests.pca\");\n      new PCA(\"PCA test on USArrests\", kdst, fr, tol, standardize).invoke();\n      model = DKV.get(kdst).get();\n\n      // Compare standard deviation and eigenvectors to R results\n      checkSdev(sdev_R, model.sdev());\n      checkEigvec(eigv_R, model.eigVec());\n\n      // Score original data set using PCA model\n      // Key kscore = Key.make(\"arrests.score\");\n      // Frame score = PCAScoreTask.score(df, model._eigVec, kscore);\n    } finally {\n      if( fr    != null ) fr   .delete();\n      if( model != null ) model.delete();\n    }\n  }","id":93326,"modified_method":"@Test public void testArrests() throws InterruptedException, ExecutionException {\n    double tol = 0.25;\n    boolean standardize = true;\n    PCAModel model = null;\n    Frame fr = null;\n    double[] sdev_R = {1.5748783, 0.9948694, 0.5971291, 0.4164494};\n    double[][] eigv_R = {{-0.5358995, 0.4181809, -0.3412327, 0.64922780},\n                         {-0.5831836, 0.1879856, -0.2681484, -0.74340748},\n                         {-0.2781909, -0.8728062, -0.3780158, 0.13387773},\n                         {-0.5434321, -0.1673186, 0.8177779, 0.08902432}};\n\n    try {\n      Key ksrc = Key.make(\"arrests.hex\");\n      fr = getFrameForFile(ksrc, \"smalldata/pca_test/USArrests.csv\", null);\n\n      // Build PCA model on all columns\n      Key kdst = Key.make(\"arrests.pca\");\n      new PCA(\"PCA test on USArrests\", kdst, fr, tol, standardize).invoke();\n      model = DKV.get(kdst).get();\n      testHTML(model);\n\n      // Compare standard deviation and eigenvectors to R results\n      checkSdev(sdev_R, model.sdev());\n      checkEigvec(eigv_R, model.eigVec());\n\n      // Score original data set using PCA model\n      // Key kscore = Key.make(\"arrests.score\");\n      // Frame score = PCAScoreTask.score(df, model._eigVec, kscore);\n    } finally {\n      if( fr    != null ) fr   .delete();\n      if( model != null ) model.delete();\n    }\n  }","commit_id":"ad51155336b27404b9fbd89f20fa38a602c1e7ea","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test public void testBasic() throws InterruptedException, ExecutionException{\n    boolean standardize = true;\n    PCAModel model = null;\n    Frame fr = null;\n\n    try {\n    Key kraw = Key.make(\"basicdata.raw\");\n    FVecTest.makeByteVec(kraw, \"x1,x2,x3\\n0,1.0,-120.4\\n1,0.5,89.3\\n2,0.3333333,291.0\\n3,0.25,-2.5\\n4,0.20,-2.5\\n5,0.1666667,-123.4\\n6,0.1428571,-0.1\\n7,0.1250000,18.3\");\n    fr = ParseDataset2.parse(Key.make(\"basicdata.hex\"), new Key[]{kraw});\n\n    Key kpca = Key.make(\"basicdata.pca\");\n    new PCA(\"PCA on basic small dataset\", kpca, fr, 0.0, standardize).invoke();\n    model = DKV.get(kpca).get();\n\n    } finally {\n      if( fr    != null ) fr   .delete();\n      if( model != null ) model.delete();\n    }\n  }","id":93327,"modified_method":"@Test public void testBasic() throws InterruptedException, ExecutionException{\n    boolean standardize = true;\n    PCAModel model = null;\n    Frame fr = null;\n\n    try {\n    Key kraw = Key.make(\"basicdata.raw\");\n    FVecTest.makeByteVec(kraw, \"x1,x2,x3\\n0,1.0,-120.4\\n1,0.5,89.3\\n2,0.3333333,291.0\\n3,0.25,-2.5\\n4,0.20,-2.5\\n5,0.1666667,-123.4\\n6,0.1428571,-0.1\\n7,0.1250000,18.3\");\n    fr = ParseDataset2.parse(Key.make(\"basicdata.hex\"), new Key[]{kraw});\n\n    Key kpca = Key.make(\"basicdata.pca\");\n    new PCA(\"PCA on basic small dataset\", kpca, fr, 0.0, standardize).invoke();\n    model = DKV.get(kpca).get();\n    testHTML(model);\n    } finally {\n      if( fr    != null ) fr   .delete();\n      if( model != null ) model.delete();\n    }\n  }","commit_id":"ad51155336b27404b9fbd89f20fa38a602c1e7ea","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void generateHTML(String title, StringBuilder sb) {\n    if(title != null && !title.isEmpty()) DocGen.HTML.title(sb, title);\n    DocGen.HTML.paragraph(sb, \"Model Key: \" + _key);\n\n    sb.append(\"<script type=\\\"text/javascript\\\" src='/h2o/js/d3.v3.min.js'><\/script>\");\n    sb.append(\"<div class='alert'>Actions: \" + PCAScore.link(_key, \"Score on dataset\") + \", \"\n        + PCA.link(_dataKey, \"Compute new model\") + \"<\/div>\");\n    screevarString(sb);\n    sb.append(\"<span style='display: inline-block;'>\");\n    sb.append(\"<table class='table table-striped table-bordered'>\");\n    sb.append(\"<tr>\");\n    sb.append(\"<th>Feature<\/th>\");\n\n    for(int i = 0; i < num_pc; i++)\n      sb.append(\"<th>\").append(\"PC\" + i).append(\"<\/th>\");\n    sb.append(\"<\/tr>\");\n\n    // Row of standard deviation values\n    sb.append(\"<tr class='warning'>\");\n    // sb.append(\"<td>\").append(\"&sigma;\").append(\"<\/td>\");\n    sb.append(\"<td>\").append(\"Std Dev\").append(\"<\/td>\");\n    for(int c = 0; c < num_pc; c++)\n      sb.append(\"<td>\").append(ElementBuilder.format(sdev[c])).append(\"<\/td>\");\n    sb.append(\"<\/tr>\");\n\n    // Row with proportion of variance\n    sb.append(\"<tr class='warning'>\");\n    sb.append(\"<td>\").append(\"Prop Var\").append(\"<\/td>\");\n    for(int c = 0; c < num_pc; c++)\n      sb.append(\"<td>\").append(ElementBuilder.format(propVar[c])).append(\"<\/td>\");\n    sb.append(\"<\/tr>\");\n\n    // Row with cumulative proportion of variance\n    sb.append(\"<tr class='warning'>\");\n    sb.append(\"<td>\").append(\"Cum Prop Var\").append(\"<\/td>\");\n    for(int c = 0; c < num_pc; c++)\n      sb.append(\"<td>\").append(ElementBuilder.format(cumVar[c])).append(\"<\/td>\");\n    sb.append(\"<\/tr>\");\n\n    // Each row is component of eigenvector\n    for(int r = 0; r < eigVec.length; r++) {\n      sb.append(\"<tr>\");\n      sb.append(\"<th>\").append(namesExp[r]).append(\"<\/th>\");\n      for( int c = 0; c < num_pc; c++ ) {\n        double e = eigVec[r][c];\n        sb.append(\"<td>\").append(ElementBuilder.format(e)).append(\"<\/td>\");\n      }\n      sb.append(\"<\/tr>\");\n    }\n    sb.append(\"<\/table><\/span>\");\n  }","id":93328,"modified_method":"public void generateHTML(String title, StringBuilder sb) {\n    if(title != null && !title.isEmpty()) DocGen.HTML.title(sb, title);\n    DocGen.HTML.paragraph(sb, \"Model Key: \" + _key);\n\n    sb.append(\"<script type=\\\"text/javascript\\\" src='/h2o/js/d3.v3.min.js'><\/script>\");\n    sb.append(\"<div class='alert'>Actions: \" + PCAScore.link(_key, \"Score on dataset\") + (_dataKey != null ? (\", \" + PCA.link(_dataKey, \"Compute new model\")):\"\") + \"<\/div>\");\n    screevarString(sb);\n    sb.append(\"<span style='display: inline-block;'>\");\n    sb.append(\"<table class='table table-striped table-bordered'>\");\n    sb.append(\"<tr>\");\n    sb.append(\"<th>Feature<\/th>\");\n\n    for(int i = 0; i < num_pc; i++)\n      sb.append(\"<th>\").append(\"PC\" + i).append(\"<\/th>\");\n    sb.append(\"<\/tr>\");\n\n    // Row of standard deviation values\n    sb.append(\"<tr class='warning'>\");\n    // sb.append(\"<td>\").append(\"&sigma;\").append(\"<\/td>\");\n    sb.append(\"<td>\").append(\"Std Dev\").append(\"<\/td>\");\n    for(int c = 0; c < num_pc; c++)\n      sb.append(\"<td>\").append(ElementBuilder.format(sdev[c])).append(\"<\/td>\");\n    sb.append(\"<\/tr>\");\n\n    // Row with proportion of variance\n    sb.append(\"<tr class='warning'>\");\n    sb.append(\"<td>\").append(\"Prop Var\").append(\"<\/td>\");\n    for(int c = 0; c < num_pc; c++)\n      sb.append(\"<td>\").append(ElementBuilder.format(propVar[c])).append(\"<\/td>\");\n    sb.append(\"<\/tr>\");\n\n    // Row with cumulative proportion of variance\n    sb.append(\"<tr class='warning'>\");\n    sb.append(\"<td>\").append(\"Cum Prop Var\").append(\"<\/td>\");\n    for(int c = 0; c < num_pc; c++)\n      sb.append(\"<td>\").append(ElementBuilder.format(cumVar[c])).append(\"<\/td>\");\n    sb.append(\"<\/tr>\");\n\n    // Each row is component of eigenvector\n    for(int r = 0; r < eigVec.length; r++) {\n      sb.append(\"<tr>\");\n      sb.append(\"<th>\").append(namesExp[r]).append(\"<\/th>\");\n      for( int c = 0; c < num_pc; c++ ) {\n        double e = eigVec[r][c];\n        sb.append(\"<td>\").append(ElementBuilder.format(e)).append(\"<\/td>\");\n      }\n      sb.append(\"<\/tr>\");\n    }\n    sb.append(\"<\/table><\/span>\");\n  }","commit_id":"54a1f4053be22ed49b602e90555a4295fd81776c","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test public void testLinDep() throws InterruptedException, ExecutionException {\n    Key kdata = Key.make(\"depdata.hex\");\n    PCAModel model = null;\n    Frame fr = null;\n    double[] sdev_R = {1.414214, 0};\n\n    try {\n      Key kraw = Key.make(\"depdata.raw\");\n      FVecTest.makeByteVec(kraw, \"x1,x2\\n0,0\\n1,2\\n2,4\\n3,6\\n4,8\\n5,10\");\n      fr = ParseDataset2.parse(kdata, new Key[]{kraw});\n\n      Key kpca = Key.make(\"depdata.pca\");\n      new PCA(\"PCA on data with dependent cols\", kpca, fr, 0.0, true).invoke();\n      model = DKV.get(kpca).get();\n\n      for(int i = 0; i < model.sdev().length; i++)\n        Assert.assertEquals(sdev_R[i], model.sdev()[i], threshold);\n    } finally {\n      if( fr    != null ) fr   .delete();\n      if( model != null ) model.delete();\n    }\n  }","id":93329,"modified_method":"@Test public void testLinDep() throws InterruptedException, ExecutionException {\n    Key kdata = Key.make(\"depdata.hex\");\n    PCAModel model = null;\n    Frame fr = null;\n    double[] sdev_R = {1.414214, 0};\n\n    try {\n      Key kraw = Key.make(\"depdata.raw\");\n      FVecTest.makeByteVec(kraw, \"x1,x2\\n0,0\\n1,2\\n2,4\\n3,6\\n4,8\\n5,10\");\n      fr = ParseDataset2.parse(kdata, new Key[]{kraw});\n\n      Key kpca = Key.make(\"depdata.pca\");\n      new PCA(\"PCA on data with dependent cols\", kpca, fr, 0.0, true).invoke();\n      model = DKV.get(kpca).get();\n      testHTML(model);\n\n      for(int i = 0; i < model.sdev().length; i++)\n        Assert.assertEquals(sdev_R[i], model.sdev()[i], threshold);\n    } finally {\n      if( fr    != null ) fr   .delete();\n      if( model != null ) model.delete();\n    }\n  }","commit_id":"54a1f4053be22ed49b602e90555a4295fd81776c","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test public void testBasic() throws InterruptedException, ExecutionException{\n    boolean standardize = true;\n    PCAModel model = null;\n    Frame fr = null;\n\n    try {\n    Key kraw = Key.make(\"basicdata.raw\");\n    FVecTest.makeByteVec(kraw, \"x1,x2,x3\\n0,1.0,-120.4\\n1,0.5,89.3\\n2,0.3333333,291.0\\n3,0.25,-2.5\\n4,0.20,-2.5\\n5,0.1666667,-123.4\\n6,0.1428571,-0.1\\n7,0.1250000,18.3\");\n    fr = ParseDataset2.parse(Key.make(\"basicdata.hex\"), new Key[]{kraw});\n\n    Key kpca = Key.make(\"basicdata.pca\");\n    new PCA(\"PCA on basic small dataset\", kpca, fr, 0.0, standardize).invoke();\n    model = DKV.get(kpca).get();\n\n    } finally {\n      if( fr    != null ) fr   .delete();\n      if( model != null ) model.delete();\n    }\n  }","id":93330,"modified_method":"@Test public void testBasic() throws InterruptedException, ExecutionException{\n    boolean standardize = true;\n    PCAModel model = null;\n    Frame fr = null;\n\n    try {\n    Key kraw = Key.make(\"basicdata.raw\");\n    FVecTest.makeByteVec(kraw, \"x1,x2,x3\\n0,1.0,-120.4\\n1,0.5,89.3\\n2,0.3333333,291.0\\n3,0.25,-2.5\\n4,0.20,-2.5\\n5,0.1666667,-123.4\\n6,0.1428571,-0.1\\n7,0.1250000,18.3\");\n    fr = ParseDataset2.parse(Key.make(\"basicdata.hex\"), new Key[]{kraw});\n\n    Key kpca = Key.make(\"basicdata.pca\");\n    new PCA(\"PCA on basic small dataset\", kpca, fr, 0.0, standardize).invoke();\n    model = DKV.get(kpca).get();\n    testHTML(model);\n    } finally {\n      if( fr    != null ) fr   .delete();\n      if( model != null ) model.delete();\n    }\n  }","commit_id":"54a1f4053be22ed49b602e90555a4295fd81776c","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test public void testArrests() throws InterruptedException, ExecutionException {\n    double tol = 0.25;\n    boolean standardize = true;\n    PCAModel model = null;\n    Frame fr = null;\n    double[] sdev_R = {1.5748783, 0.9948694, 0.5971291, 0.4164494};\n    double[][] eigv_R = {{-0.5358995, 0.4181809, -0.3412327, 0.64922780},\n                         {-0.5831836, 0.1879856, -0.2681484, -0.74340748},\n                         {-0.2781909, -0.8728062, -0.3780158, 0.13387773},\n                         {-0.5434321, -0.1673186, 0.8177779, 0.08902432}};\n\n    try {\n      Key ksrc = Key.make(\"arrests.hex\");\n      fr = getFrameForFile(ksrc, \"smalldata/pca_test/USArrests.csv\", null);\n\n      // Build PCA model on all columns\n      Key kdst = Key.make(\"arrests.pca\");\n      new PCA(\"PCA test on USArrests\", kdst, fr, tol, standardize).invoke();\n      model = DKV.get(kdst).get();\n\n      // Compare standard deviation and eigenvectors to R results\n      checkSdev(sdev_R, model.sdev());\n      checkEigvec(eigv_R, model.eigVec());\n\n      // Score original data set using PCA model\n      // Key kscore = Key.make(\"arrests.score\");\n      // Frame score = PCAScoreTask.score(df, model._eigVec, kscore);\n    } finally {\n      if( fr    != null ) fr   .delete();\n      if( model != null ) model.delete();\n    }\n  }","id":93331,"modified_method":"@Test public void testArrests() throws InterruptedException, ExecutionException {\n    double tol = 0.25;\n    boolean standardize = true;\n    PCAModel model = null;\n    Frame fr = null;\n    double[] sdev_R = {1.5748783, 0.9948694, 0.5971291, 0.4164494};\n    double[][] eigv_R = {{-0.5358995, 0.4181809, -0.3412327, 0.64922780},\n                         {-0.5831836, 0.1879856, -0.2681484, -0.74340748},\n                         {-0.2781909, -0.8728062, -0.3780158, 0.13387773},\n                         {-0.5434321, -0.1673186, 0.8177779, 0.08902432}};\n\n    try {\n      Key ksrc = Key.make(\"arrests.hex\");\n      fr = getFrameForFile(ksrc, \"smalldata/pca_test/USArrests.csv\", null);\n\n      // Build PCA model on all columns\n      Key kdst = Key.make(\"arrests.pca\");\n      new PCA(\"PCA test on USArrests\", kdst, fr, tol, standardize).invoke();\n      model = DKV.get(kdst).get();\n      testHTML(model);\n\n      // Compare standard deviation and eigenvectors to R results\n      checkSdev(sdev_R, model.sdev());\n      checkEigvec(eigv_R, model.eigVec());\n\n      // Score original data set using PCA model\n      // Key kscore = Key.make(\"arrests.score\");\n      // Frame score = PCAScoreTask.score(df, model._eigVec, kscore);\n    } finally {\n      if( fr    != null ) fr   .delete();\n      if( model != null ) model.delete();\n    }\n  }","commit_id":"54a1f4053be22ed49b602e90555a4295fd81776c","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public SolrFacetFieldCollector(String fieldName, FacetField facetField) {\n\t\t_fieldName = fieldName;\n\n\t\t_countMap = new HashMap<String,Count>();\n\n\t\tif (facetField.getValues() != null) {\n\t\t\tfor (Count count : facetField.getValues()) {\n\t\t\t\t_countMap.put(count.getName(), count);\n\t\t\t}\n\t\t}\n\t}","id":93332,"modified_method":"public SolrFacetFieldCollector(String fieldName, FacetField facetField) {\n\t\t_fieldName = fieldName;\n\n\t\tList<Count> counts = facetField.getValues();\n\n\t\tif (counts != null) {\n\t\t\tfor (Count count : counts) {\n\t\t\t\t_counts.put(count.getName(), count);\n\t\t\t}\n\t\t}\n\t}","commit_id":"a7b710a043ced55da40022fb7c9e3fa84fceafa7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<TermCollector> getTermCollectors() {\n\t\tif (_termCollectors == null) {\n\t\t\tList<TermCollector> list = new ArrayList<TermCollector>();\n\n\t\t\tfor (Map.Entry<String, Count> entry : _countMap.entrySet()) {\n\t\t\t\tlist.add(\n\t\t\t\t\tnew SolrTermCollector(\n\t\t\t\t\t\tentry.getKey(), (int)entry.getValue().getCount()));\n\t\t\t}\n\n\t\t\t_termCollectors = list;\n\t\t}\n\n\t\treturn _termCollectors;\n\t}","id":93333,"modified_method":"public List<TermCollector> getTermCollectors() {\n\t\tif (_termCollectors != null) {\n\t\t\treturn _termCollectors;\n\t\t}\n\n\t\tList<TermCollector> termCollectors = new ArrayList<TermCollector>();\n\n\t\tfor (Map.Entry<String, Count> entry : _counts.entrySet()) {\n\t\t\tCount count = entry.getValue();\n\n\t\t\tTermCollector termCollector = new SolrTermCollector(\n\t\t\t\tentry.getKey(), (int)count.getCount());\n\n\t\t\ttermCollectors.add(termCollector);\n\t\t}\n\n\t\t_termCollectors = termCollectors;\n\n\t\treturn _termCollectors;\n\t}","commit_id":"a7b710a043ced55da40022fb7c9e3fa84fceafa7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public TermCollector getTermCollector(String term) {\n\t\treturn new SolrTermCollector(term, (int)_countMap.get(term).getCount());\n\t}","id":93334,"modified_method":"public TermCollector getTermCollector(String term) {\n\t\tCount count = _counts.get(term);\n\n\t\treturn new SolrTermCollector(term, (int)count.getCount());\n\t}","commit_id":"a7b710a043ced55da40022fb7c9e3fa84fceafa7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public TermCollector getTermCollector(String term) {\n\t\treturn new SolrTermCollector(term, _termMap.get(term).intValue());\n\t}","id":93335,"modified_method":"public TermCollector getTermCollector(String term) {\n\t\tInteger count = _counts.get(term);\n\n\t\treturn new SolrTermCollector(term, count.intValue());\n\t}","commit_id":"a7b710a043ced55da40022fb7c9e3fa84fceafa7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<TermCollector> getTermCollectors() {\n\t\tif (_termCollectors == null) {\n\t\t\tList<TermCollector> list = new ArrayList<TermCollector>();\n\n\t\t\tfor (Map.Entry<String, Integer> entry : _termMap.entrySet()) {\n\t\t\t\tlist.add(\n\t\t\t\t\tnew SolrTermCollector(\n\t\t\t\t\t\tentry.getKey(), entry.getValue().intValue()));\n\t\t\t}\n\n\t\t\t_termCollectors = list;\n\t\t}\n\n\t\treturn _termCollectors;\n\t}","id":93336,"modified_method":"public List<TermCollector> getTermCollectors() {\n\t\tif (_termCollectors != null) {\n\t\t\treturn _termCollectors;\n\t\t}\n\n\t\tList<TermCollector> termCollectors = new ArrayList<TermCollector>();\n\n\t\tfor (Map.Entry<String, Integer> entry : _counts.entrySet()) {\n\t\t\tInteger count = entry.getValue();\n\n\t\t\tTermCollector termCollector = new SolrTermCollector(\n\t\t\t\tentry.getKey(), count.intValue());\n\n\t\t\ttermCollectors.add(termCollector);\n\t\t}\n\n\t\t_termCollectors = termCollectors;\n\n\t\treturn _termCollectors;\n\t}","commit_id":"a7b710a043ced55da40022fb7c9e3fa84fceafa7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public SolrFacetQueryCollector(\n\t\tString fieldName, Map<String, Integer> facetQueries) {\n\n\t\t_fieldName = fieldName;\n\t\t_termMap = new HashMap<String,Integer>();\n\n\t\tif (!facetQueries.isEmpty()) {\n\t\t\tfor (Map.Entry<String,Integer> entry : facetQueries.entrySet()) {\n\t\t\t\t_termMap.put(_getTerm(entry.getKey()), entry.getValue());\n\t\t\t}\n\t\t}\n\t}","id":93337,"modified_method":"public SolrFacetQueryCollector(\n\t\tString fieldName, Map<String, Integer> facetQueries) {\n\n\t\t_fieldName = fieldName;\n\n\t\tfor (Map.Entry<String, Integer> entry : facetQueries.entrySet()) {\n\t\t\tString term = _getTerm(entry.getKey());\n\t\t\tInteger count = entry.getValue();\n\n\t\t\t_counts.put(term, count);\n\t\t}\n\t}","commit_id":"a7b710a043ced55da40022fb7c9e3fa84fceafa7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected SolrQuery translateQuery(\n\t\t\tlong companyId, Query query, Sort[] sorts, int start, int end)\n\t\tthrows SearchException {\n\n\t\ttry {\n\t\t\tQueryTranslatorUtil.translateForSolr(query);\n\n\t\t\tString queryString = query.toString();\n\n\t\t\tQueryConfig queryConfig = query.getQueryConfig();\n\n\t\t\tSolrQuery solrQuery = new SolrQuery();\n\n\t\t\tsolrQuery.setHighlight(queryConfig.isHighlightEnabled());\n\t\t\tsolrQuery.setHighlightFragsize(\n\t\t\t\tqueryConfig.getHighlightFragmentSize());\n\t\t\tsolrQuery.setHighlightSnippets(\n\t\t\t\tqueryConfig.getHighlightSnippetSize());\n\t\t\tsolrQuery.setIncludeScore(queryConfig.isScoreEnabled());\n\n\t\t\tsolrQuery.setQuery(queryString);\n\n\t\t\tif ((start == QueryUtil.ALL_POS) && (end == QueryUtil.ALL_POS)) {\n\t\t\t\tsolrQuery.setRows(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsolrQuery.setRows(end - start);\n\t\t\t\tsolrQuery.setStart(start);\n\t\t\t}\n\n\t\t\tif ((sorts != null) && (sorts.length > 0)) {\n\t\t\t\tfor (Sort sortField : sorts) {\n\t\t\t\t\tif (sortField == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tString sortFieldName = sortField.getFieldName();\n\n\t\t\t\t\tORDER order = ORDER.asc;\n\n\t\t\t\t\tif (sortFieldName == null) {\n\t\t\t\t\t\tsortFieldName = \"score\";\n\n\t\t\t\t\t\torder = ORDER.desc;\n\t\t\t\t\t}\n\t\t\t\t\telse if (sortField.isReverse()) {\n\t\t\t\t\t\torder = ORDER.desc;\n\t\t\t\t\t}\n\n\t\t\t\t\tsolrQuery.addSortField(sortFieldName, order);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn solrQuery;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow new SearchException(e.getMessage());\n\t\t}\n\t}","id":93338,"modified_method":"protected SolrQuery translateQuery(\n\t\t\tlong companyId, Query query, Sort[] sorts, int start, int end)\n\t\tthrows Exception {\n\n\t\tQueryTranslatorUtil.translateForSolr(query);\n\n\t\tString queryString = query.toString();\n\n\t\tQueryConfig queryConfig = query.getQueryConfig();\n\n\t\tSolrQuery solrQuery = new SolrQuery();\n\n\t\tsolrQuery.setHighlight(queryConfig.isHighlightEnabled());\n\t\tsolrQuery.setHighlightFragsize(\n\t\t\tqueryConfig.getHighlightFragmentSize());\n\t\tsolrQuery.setHighlightSnippets(\n\t\t\tqueryConfig.getHighlightSnippetSize());\n\t\tsolrQuery.setIncludeScore(queryConfig.isScoreEnabled());\n\t\tsolrQuery.setQuery(queryString);\n\n\t\tif ((start == QueryUtil.ALL_POS) && (end == QueryUtil.ALL_POS)) {\n\t\t\tsolrQuery.setRows(0);\n\t\t}\n\t\telse {\n\t\t\tsolrQuery.setRows(end - start);\n\t\t\tsolrQuery.setStart(start);\n\t\t}\n\n\t\tif ((sorts != null) && (sorts.length > 0)) {\n\t\t\tfor (Sort sort : sorts) {\n\t\t\t\tif (sort == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString sortFieldName = sort.getFieldName();\n\n\t\t\t\tORDER order = ORDER.asc;\n\n\t\t\t\tif (sortFieldName == null) {\n\t\t\t\t\tsortFieldName = \"score\";\n\n\t\t\t\t\torder = ORDER.desc;\n\t\t\t\t}\n\t\t\t\telse if (sort.isReverse()) {\n\t\t\t\t\torder = ORDER.desc;\n\t\t\t\t}\n\n\t\t\t\tsolrQuery.addSortField(sortFieldName, order);\n\t\t\t}\n\t\t}\n\n\t\treturn solrQuery;\n\t}","commit_id":"a7b710a043ced55da40022fb7c9e3fa84fceafa7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected Hits subset(\n\t\t\tSolrQuery solrQuery, Query query, QueryConfig queryConfig,\n\t\t\tQueryResponse queryResponse, boolean allResults)\n\t\tthrows Exception {\n\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tHits subset = new HitsImpl();\n\n\t\tSolrDocumentList results = queryResponse.getResults();\n\n\t\tlong length = results.getNumFound();\n\n\t\tif (allResults && (length > 0)) {\n\t\t\tsolrQuery.setRows((int)length);\n\n\t\t\tqueryResponse = _solrServer.query(solrQuery);\n\n\t\t\treturn subset(solrQuery, query, queryConfig, queryResponse, false);\n\t\t}\n\n\t\tfloat maxScore = 1;\n\n\t\tboolean scoreEnabled = queryConfig.isScoreEnabled();\n\n\t\tif (scoreEnabled) {\n\t\t\tmaxScore = results.getMaxScore();\n\t\t}\n\n\t\tint subsetTotal = results.size();\n\n\t\tDocument[] subsetDocs = new DocumentImpl[subsetTotal];\n\t\tString[] subsetSnippets = new String[subsetTotal];\n\t\tfloat[] subsetScores = new float[subsetTotal];\n\n\t\tint j = 0;\n\n\t\tboolean highlightEnabled = queryConfig.isHighlightEnabled();\n\n\t\tSet<String> queryTerms = new HashSet<String>();\n\n\t\tMap<String, Map<String, List<String>>> highlights =\n\t\t\tqueryResponse.getHighlighting();\n\n\t\tfor (SolrDocument solrDocument : results) {\n\t\t\tDocument document = new DocumentImpl();\n\n\t\t\tCollection<String> names = solrDocument.getFieldNames();\n\n\t\t\tfor (String name : names) {\n\t\t\t\tField field = new Field(\n\t\t\t\t\tname,\n\t\t\t\t\tArrayUtil.toStringArray(\n\t\t\t\t\t\tsolrDocument.getFieldValues(name).toArray()));\n\n\t\t\t\tdocument.add(field);\n\t\t\t}\n\n\t\t\tfloat score = 1;\n\n\t\t\tif (scoreEnabled) {\n\t\t\t\tscore = GetterUtil.getFloat(\n\t\t\t\t\tsolrDocument.getFieldValue(\"score\").toString());\n\t\t\t}\n\n\t\t\tsubsetDocs[j] = document;\n\n\t\t\tif (highlightEnabled) {\n\t\t\t\tsubsetSnippets[j] = getSnippet(\n\t\t\t\t\tsolrDocument, queryTerms, highlights);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsubsetSnippets[j] = StringPool.BLANK;\n\t\t\t}\n\n\t\t\tsubsetScores[j] = score / maxScore;\n\n\t\t\tj++;\n\t\t}\n\n\t\tfloat searchTime =\n\t\t\t(float)(System.currentTimeMillis() - startTime) / Time.SECOND;\n\n\t\tsubset.setDocs(subsetDocs);\n\t\tsubset.setLength((int)length);\n\t\tsubset.setQuery(query);\n\t\tsubset.setQueryTerms(queryTerms.toArray(new String[queryTerms.size()]));\n\t\tsubset.setScores(subsetScores);\n\t\tsubset.setSearchTime(searchTime);\n\t\tsubset.setSnippets(subsetSnippets);\n\t\tsubset.setStart(startTime);\n\n\t\treturn subset;\n\t}","id":93339,"modified_method":"protected Hits subset(\n\t\t\tSolrQuery solrQuery, Query query, QueryConfig queryConfig,\n\t\t\tQueryResponse queryResponse, boolean allResults)\n\t\tthrows Exception {\n\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tHits subset = new HitsImpl();\n\n\t\tSolrDocumentList results = queryResponse.getResults();\n\n\t\tlong length = results.getNumFound();\n\n\t\tif (allResults && (length > 0)) {\n\t\t\tsolrQuery.setRows((int)length);\n\n\t\t\tqueryResponse = _solrServer.query(solrQuery);\n\n\t\t\treturn subset(solrQuery, query, queryConfig, queryResponse, false);\n\t\t}\n\n\t\tfloat maxScore = 1;\n\n\t\tboolean scoreEnabled = queryConfig.isScoreEnabled();\n\n\t\tif (scoreEnabled) {\n\t\t\tmaxScore = results.getMaxScore();\n\t\t}\n\n\t\tint subsetTotal = results.size();\n\n\t\tDocument[] subsetDocs = new DocumentImpl[subsetTotal];\n\t\tString[] subsetSnippets = new String[subsetTotal];\n\t\tfloat[] subsetScores = new float[subsetTotal];\n\n\t\tint j = 0;\n\n\t\tboolean highlightEnabled = queryConfig.isHighlightEnabled();\n\n\t\tSet<String> queryTerms = new HashSet<String>();\n\n\t\tMap<String, Map<String, List<String>>> highlights =\n\t\t\tqueryResponse.getHighlighting();\n\n\t\tfor (SolrDocument solrDocument : results) {\n\t\t\tDocument document = new DocumentImpl();\n\n\t\t\tCollection<String> names = solrDocument.getFieldNames();\n\n\t\t\tfor (String name : names) {\n\t\t\t\tCollection<Object> fieldValues = solrDocument.getFieldValues(\n\t\t\t\t\tname);\n\n\t\t\t\tField field = new Field(\n\t\t\t\t\tname,\n\t\t\t\t\tArrayUtil.toStringArray(\n\t\t\t\t\t\tfieldValues.toArray(new Object[fieldValues.size()])));\n\n\t\t\t\tdocument.add(field);\n\t\t\t}\n\n\t\t\tfloat score = 1;\n\n\t\t\tif (scoreEnabled) {\n\t\t\t\tscore = GetterUtil.getFloat(\n\t\t\t\t\tsolrDocument.getFieldValue(\"score\").toString());\n\t\t\t}\n\n\t\t\tsubsetDocs[j] = document;\n\n\t\t\tif (highlightEnabled) {\n\t\t\t\tsubsetSnippets[j] = getSnippet(\n\t\t\t\t\tsolrDocument, queryTerms, highlights);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsubsetSnippets[j] = StringPool.BLANK;\n\t\t\t}\n\n\t\t\tsubsetScores[j] = score / maxScore;\n\n\t\t\tj++;\n\t\t}\n\n\t\tfloat searchTime =\n\t\t\t(float)(System.currentTimeMillis() - startTime) / Time.SECOND;\n\n\t\tsubset.setDocs(subsetDocs);\n\t\tsubset.setLength((int)length);\n\t\tsubset.setQuery(query);\n\t\tsubset.setQueryTerms(queryTerms.toArray(new String[queryTerms.size()]));\n\t\tsubset.setScores(subsetScores);\n\t\tsubset.setSearchTime(searchTime);\n\t\tsubset.setSnippets(subsetSnippets);\n\t\tsubset.setStart(startTime);\n\n\t\treturn subset;\n\t}","commit_id":"a7b710a043ced55da40022fb7c9e3fa84fceafa7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public Hits search(SearchContext searchContext, Query query)\n\t\tthrows SearchException {\n\n\t\tlong companyId = searchContext.getCompanyId();\n\t\tSort[] sorts = searchContext.getSorts();\n\t\tint start = searchContext.getStart();\n\t\tint end = searchContext.getEnd();\n\n\t\tMap<String, Facet> facets = null;\n\n\t\ttry {\n\t\t\tSolrQuery solrQuery = translateQuery(\n\t\t\t\tcompanyId, query, sorts, start, end);\n\n\t\t\tfacets = searchContext.getFacets();\n\n\t\t\tfor (Facet facet : facets.values()) {\n\t\t\t\tif (facet.isStatic()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tFacetConfiguration facetConfiguration =\n\t\t\t\t\tfacet.getFacetConfiguration();\n\n\t\t\t\tif (facet instanceof RangeFacet) {\n\t\t\t\t\tJSONArray rangesJSONArray =\n\t\t\t\t\t\tfacetConfiguration.getData().getJSONArray(\"ranges\");\n\n\t\t\t\t\tsolrQuery.addFacetField(facetConfiguration.getFieldName());\n\n\t\t\t\t\tif (rangesJSONArray != null) {\n\t\t\t\t\t\tfor (int i = 0; i < rangesJSONArray.length(); i++) {\n\t\t\t\t\t\t\tJSONObject rangeJSONObject =\n\t\t\t\t\t\t\t\trangesJSONArray.getJSONObject(i);\n\n\t\t\t\t\t\t\tString facetQuery =\n\t\t\t\t\t\t\t\tfacetConfiguration.getFieldName().concat(\n\t\t\t\t\t\t\t\t\tStringPool.COLON).concat(\n\t\t\t\t\t\t\t\t\t\trangeJSONObject.getString(\"range\"));\n\n\t\t\t\t\t\t\tsolrQuery.addFacetQuery(facetQuery);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsolrQuery.addFacetField(facetConfiguration.getFieldName());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsolrQuery.setFacetLimit(-1);\n\n\t\t\tQueryResponse queryResponse = _solrServer.query(solrQuery);\n\n\t\t\tboolean allResults = false;\n\n\t\t\tif (solrQuery.getRows() == 0) {\n\t\t\t\tallResults = true;\n\t\t\t}\n\n\t\t\tfor (FacetField facetField : queryResponse.getFacetFields()) {\n\t\t\t\tFacet facet = facets.get(facetField.getName());\n\n\t\t\t\tif (facet instanceof RangeFacet) {\n\t\t\t\t\tfacet.setFacetCollector(\n\t\t\t\t\t\tnew SolrFacetQueryCollector(\n\t\t\t\t\t\t\tfacetField.getName(),\n\t\t\t\t\t\t\tqueryResponse.getFacetQuery()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfacet.setFacetCollector(\n\t\t\t\t\t\tnew SolrFacetFieldCollector(\n\t\t\t\t\t\t\tfacetField.getName(), facetField));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn subset(\n\t\t\t\tsolrQuery, query, query.getQueryConfig(), queryResponse,\n\t\t\t\tallResults);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow new SearchException(e.getMessage());\n\t\t}\n\t}","id":93340,"modified_method":"public Hits search(SearchContext searchContext, Query query)\n\t\tthrows SearchException {\n\n\t\ttry {\n\t\t\tSolrQuery solrQuery = translateQuery(\n\t\t\t\tsearchContext.getCompanyId(), query, searchContext.getSorts(),\n\t\t\t\tsearchContext.getStart(), searchContext.getEnd());\n\n\t\t\tMap<String, Facet> facets = searchContext.getFacets();\n\n\t\t\tfor (Facet facet : facets.values()) {\n\t\t\t\tif (facet.isStatic()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tFacetConfiguration facetConfiguration =\n\t\t\t\t\tfacet.getFacetConfiguration();\n\n\t\t\t\tif (facet instanceof RangeFacet) {\n\t\t\t\t\tsolrQuery.addFacetField(facetConfiguration.getFieldName());\n\n\t\t\t\t\tJSONObject dataJSONObject = facetConfiguration.getData();\n\n\t\t\t\t\tJSONArray rangesJSONArray = dataJSONObject.getJSONArray(\n\t\t\t\t\t\t\"ranges\");\n\n\t\t\t\t\tif (rangesJSONArray != null) {\n\t\t\t\t\t\tfor (int i = 0; i < rangesJSONArray.length(); i++) {\n\t\t\t\t\t\t\tJSONObject rangeJSONObject =\n\t\t\t\t\t\t\t\trangesJSONArray.getJSONObject(i);\n\n\t\t\t\t\t\t\tString range = rangeJSONObject.getString(\"range\");\n\n\t\t\t\t\t\t\tString facetQuery =\n\t\t\t\t\t\t\t\tfacetConfiguration.getFieldName() +\n\t\t\t\t\t\t\t\t\tStringPool.COLON + range;\n\n\t\t\t\t\t\t\tsolrQuery.addFacetQuery(facetQuery);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsolrQuery.addFacetField(facetConfiguration.getFieldName());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsolrQuery.setFacetLimit(-1);\n\n\t\t\tQueryResponse queryResponse = _solrServer.query(solrQuery);\n\n\t\t\tboolean allResults = false;\n\n\t\t\tif (solrQuery.getRows() == 0) {\n\t\t\t\tallResults = true;\n\t\t\t}\n\n\t\t\tfor (FacetField facetField : queryResponse.getFacetFields()) {\n\t\t\t\tFacet facet = facets.get(facetField.getName());\n\n\t\t\t\tFacetCollector facetCollector = null;\n\n\t\t\t\tif (facet instanceof RangeFacet) {\n\t\t\t\t\tfacetCollector = new SolrFacetQueryCollector(\n\t\t\t\t\t\tfacetField.getName(),\n\t\t\t\t\t\tqueryResponse.getFacetQuery());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfacetCollector = new SolrFacetFieldCollector(\n\t\t\t\t\t\tfacetField.getName(), facetField);\n\t\t\t\t}\n\n\t\t\t\tfacet.setFacetCollector(facetCollector);\n\t\t\t}\n\n\t\t\treturn subset(\n\t\t\t\tsolrQuery, query, query.getQueryConfig(), queryResponse,\n\t\t\t\tallResults);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow new SearchException(e.getMessage());\n\t\t}\n\t}","commit_id":"a7b710a043ced55da40022fb7c9e3fa84fceafa7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic void processFacet(\n\t\tSearchRequestBuilder searchRequestBuilder, Facet facet) {\n\n\t\tFacetConfiguration facetConfiguration = facet.getFacetConfiguration();\n\n\t\tString fieldName = facetConfiguration.getFieldName();\n\n\t\tTermsFacetBuilder facetBuilder = new TermsFacetBuilder(fieldName);\n\n\t\tfacetBuilder.field(fieldName);\n\n\t\tsearchRequestBuilder.addFacet(facetBuilder);\n\t}","id":93341,"modified_method":"@Override\n\tpublic void processFacet(\n\t\tSearchRequestBuilder searchRequestBuilder, Facet facet) {\n\n\t\tFacetConfiguration facetConfiguration = facet.getFacetConfiguration();\n\n\t\tString fieldName = facetConfiguration.getFieldName();\n\n\t\tTermsFacetBuilder termsFacetBuilder = new TermsFacetBuilder(fieldName);\n\n\t\ttermsFacetBuilder.field(fieldName);\n\n\t\tsearchRequestBuilder.addFacet(termsFacetBuilder);\n\t}","commit_id":"08777e197ce9d4e58fb21fd924a9996f055386ae","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addHighlights(\n\t\tSearchRequestBuilder searchRequestBuilder, QueryConfig queryConfig) {\n\n\t\tif (!queryConfig.isHighlightEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString localizedContentName = DocumentImpl.getLocalizedName(\n\t\t\tqueryConfig.getLocale(), Field.CONTENT);\n\n\t\tString localizedTitleName = DocumentImpl.getLocalizedName(\n\t\t\tqueryConfig.getLocale(), Field.TITLE);\n\n\t\tsearchRequestBuilder.addHighlightedField(\n\t\t\tlocalizedContentName, queryConfig.getHighlightFragmentSize(),\n\t\t\tqueryConfig.getHighlightSnippetSize());\n\n\t\tsearchRequestBuilder.addHighlightedField(\n\t\t\tlocalizedTitleName, queryConfig.getHighlightFragmentSize(),\n\t\t\tqueryConfig.getHighlightSnippetSize());\n\t}","id":93342,"modified_method":"protected void addHighlights(\n\t\tSearchRequestBuilder searchRequestBuilder, QueryConfig queryConfig) {\n\n\t\tif (!queryConfig.isHighlightEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString localizedContentName = DocumentImpl.getLocalizedName(\n\t\t\tqueryConfig.getLocale(), Field.CONTENT);\n\n\t\tsearchRequestBuilder.addHighlightedField(\n\t\t\tlocalizedContentName, queryConfig.getHighlightFragmentSize(),\n\t\t\tqueryConfig.getHighlightSnippetSize());\n\n\t\tString localizedTitleName = DocumentImpl.getLocalizedName(\n\t\t\tqueryConfig.getLocale(), Field.TITLE);\n\n\t\tsearchRequestBuilder.addHighlightedField(\n\t\t\tlocalizedTitleName, queryConfig.getHighlightFragmentSize(),\n\t\t\tqueryConfig.getHighlightSnippetSize());\n\t}","commit_id":"08777e197ce9d4e58fb21fd924a9996f055386ae","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic Hits search(SearchContext searchContext, Query query)\n\t\tthrows SearchException {\n\n\t\tElasticsearchConnectionManager elasticsearchConnectionManager =\n\t\t\tElasticsearchConnectionManager.getInstance();\n\n\t\tClient client = elasticsearchConnectionManager.getClient();\n\n\t\tQueryConfig queryConfig = query.getQueryConfig();\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\tSearchRequestBuilder searchRequestBuilder = client.prepareSearch(\n\t\t\tString.valueOf(searchContext.getCompanyId()));\n\n\t\taddFacets(searchRequestBuilder, searchContext);\n\t\taddHighlights(searchRequestBuilder, queryConfig);\n\t\taddPagination(\n\t\t\tsearchRequestBuilder, searchContext.getStart(),\n\t\t\tsearchContext.getEnd());\n\t\taddSelectedFields(searchRequestBuilder, queryConfig);\n\t\taddSort(searchRequestBuilder, searchContext.getSorts());\n\n\t\tQueryBuilder queryBuilder = QueryBuilders.queryString(query.toString());\n\n\t\tsearchRequestBuilder.setQuery(queryBuilder);\n\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tSearchRequest searchRequest = searchRequestBuilder.request();\n\n\t\tActionFuture<SearchResponse> future = client.search(searchRequest);\n\n\t\tSearchResponse searchResponse = future.actionGet();\n\n\t\tupdateFacetCollectors(searchContext, searchResponse);\n\n\t\tHits hits = processSearchHits(searchResponse.getHits(), queryConfig);\n\n\t\thits.setQuery(query);\n\n\t\tTimeValue timeValue = searchResponse.getTook();\n\t\thits.setSearchTime((float)timeValue.getSecondsFrac());\n\n\t\thits.setStart(startTime);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch.stop();\n\n\t\t\t_log.info(\n\t\t\t\t\"Search: \" + queryBuilder.toString() + \" consumed: \" +\n\t\t\t\t\tstopWatch.getTime() + \"ms. Search engine took: \" +\n\t\t\t\t\thits.getSearchTime() + \"s\");\n\t\t}\n\n\t\treturn hits;\n\t}","id":93343,"modified_method":"@Override\n\tpublic Hits search(SearchContext searchContext, Query query) {\n\t\tStopWatch stopWatch = new StopWatch();\n\n\t\tstopWatch.start();\n\n\t\tElasticsearchConnectionManager elasticsearchConnectionManager =\n\t\t\tElasticsearchConnectionManager.getInstance();\n\n\t\tClient client = elasticsearchConnectionManager.getClient();\n\n\t\tSearchRequestBuilder searchRequestBuilder = client.prepareSearch(\n\t\t\tString.valueOf(searchContext.getCompanyId()));\n\n\t\taddFacets(searchRequestBuilder, searchContext);\n\t\taddHighlights(searchRequestBuilder, query.getQueryConfig());\n\t\taddPagination(\n\t\t\tsearchRequestBuilder, searchContext.getStart(),\n\t\t\tsearchContext.getEnd());\n\t\taddSelectedFields(searchRequestBuilder, query.getQueryConfig());\n\t\taddSort(searchRequestBuilder, searchContext.getSorts());\n\n\t\tQueryBuilder queryBuilder = QueryBuilders.queryString(query.toString());\n\n\t\tsearchRequestBuilder.setQuery(queryBuilder);\n\n\t\tSearchRequest searchRequest = searchRequestBuilder.request();\n\n\t\tActionFuture<SearchResponse> future = client.search(searchRequest);\n\n\t\tSearchResponse searchResponse = future.actionGet();\n\n\t\tupdateFacetCollectors(searchContext, searchResponse);\n\n\t\tHits hits = processSearchHits(\n\t\t\tsearchResponse.getHits(), query.getQueryConfig());\n\n\t\thits.setQuery(query);\n\n\t\tTimeValue timeValue = searchResponse.getTook();\n\n\t\thits.setSearchTime((float)timeValue.getSecondsFrac());\n\n\t\thits.setStart(stopWatch.getStartTime());\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch.stop();\n\n\t\t\t_log.info(\n\t\t\t\t\"Searching \" + queryBuilder.toString() + \" took \" +\n\t\t\t\t\tstopWatch.getTime() + \" ms with the search engine using \" +\n\t\t\t\t\t\thits.getSearchTime() + \" s\");\n\t\t}\n\n\t\treturn hits;\n\t}","commit_id":"08777e197ce9d4e58fb21fd924a9996f055386ae","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addPagination(\n\t\tSearchRequestBuilder searchRequestBuilder, int start, int end) {\n\n\t\tif ((start == QueryUtil.ALL_POS) && (end == QueryUtil.ALL_POS)) {\n\t\t\tsearchRequestBuilder.setSize(0);\n\t\t}\n\t\telse {\n\t\t\tsearchRequestBuilder.setSize(end - start);\n\t\t\tsearchRequestBuilder.setFrom(start);\n\t\t}\n\t}","id":93344,"modified_method":"protected void addPagination(\n\t\tSearchRequestBuilder searchRequestBuilder, int start, int end) {\n\n\t\tif ((start == QueryUtil.ALL_POS) && (end == QueryUtil.ALL_POS)) {\n\t\t\tsearchRequestBuilder.setSize(0);\n\t\t}\n\t\telse {\n\t\t\tsearchRequestBuilder.setFrom(start);\n\t\t\tsearchRequestBuilder.setSize(end - start);\n\t\t}\n\t}","commit_id":"08777e197ce9d4e58fb21fd924a9996f055386ae","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected Hits processSearchHits(\n\t\tSearchHits searchHits, QueryConfig queryConfig) {\n\n\t\tHits hits = new HitsImpl();\n\t\tList<Document> documents = new ArrayList<Document>();\n\t\tSet<String> queryTerms = new HashSet<String>();\n\t\tList<Float> scores = new ArrayList<Float>();\n\t\tList<String> snippets = new ArrayList<String>();\n\n\t\tif (searchHits.totalHits() > 0) {\n\t\t\tSearchHit[] returnedHits = searchHits.getHits();\n\n\t\t\tfor (SearchHit hit : returnedHits) {\n\t\t\t\tDocument document = processSearchHit(hit);\n\t\t\t\tdocuments.add(document);\n\n\t\t\t\tString snippet = getSnippet(hit, queryConfig);\n\n\t\t\t\tqueryTerms.add(snippet);\n\t\t\t\tsnippets.add(snippet);\n\n\t\t\t\tscores.add(hit.getScore());\n\t\t\t}\n\t\t}\n\n\t\thits.setDocs(documents.toArray(new Document[documents.size()]));\n\t\thits.setLength((int)searchHits.getTotalHits());\n\t\thits.setQueryTerms(queryTerms.toArray(new String[queryTerms.size()]));\n\t\thits.setScores(scores.toArray(new Float[scores.size()]));\n\t\thits.setSnippets(snippets.toArray(new String[snippets.size()]));\n\n\t\treturn hits;\n\t}","id":93345,"modified_method":"protected Hits processSearchHits(\n\t\tSearchHits searchHits, QueryConfig queryConfig) {\n\n\t\tHits hits = new HitsImpl();\n\n\t\tList<Document> documents = new ArrayList<Document>();\n\t\tSet<String> queryTerms = new HashSet<String>();\n\t\tList<Float> scores = new ArrayList<Float>();\n\t\tList<String> snippets = new ArrayList<String>();\n\n\t\tif (searchHits.totalHits() > 0) {\n\t\t\tSearchHit[] searchHitsArray = searchHits.getHits();\n\n\t\t\tfor (SearchHit searchHit : searchHitsArray) {\n\t\t\t\tDocument document = processSearchHit(searchHit);\n\n\t\t\t\tdocuments.add(document);\n\n\t\t\t\tString snippet = getSnippet(searchHit, queryConfig);\n\n\t\t\t\tqueryTerms.add(snippet);\n\n\t\t\t\tscores.add(searchHit.getScore());\n\n\t\t\t\tsnippets.add(snippet);\n\t\t\t}\n\t\t}\n\n\t\thits.setDocs(documents.toArray(new Document[documents.size()]));\n\t\thits.setLength((int)searchHits.getTotalHits());\n\t\thits.setQueryTerms(queryTerms.toArray(new String[queryTerms.size()]));\n\t\thits.setScores(scores.toArray(new Float[scores.size()]));\n\t\thits.setSnippets(snippets.toArray(new String[snippets.size()]));\n\n\t\treturn hits;\n\t}","commit_id":"08777e197ce9d4e58fb21fd924a9996f055386ae","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void updateFacetCollectors(\n\t\tSearchContext searchContext, SearchResponse searchResponse) {\n\n\t\tfor (Facet searchRequestFacet : searchContext.getFacets().values()) {\n\t\t\tif (searchRequestFacet.isStatic()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFacets searchResponseFacets = searchResponse.getFacets();\n\n\t\t\torg.elasticsearch.search.facet.Facet searchResponseFacet =\n\t\t\t\tsearchResponseFacets.facet(searchRequestFacet.getFieldName());\n\n\t\t\tFacetCollector facetCollector =\n\t\t\t\tnew ElasticsearchFacetFieldCollector(searchResponseFacet);\n\n\t\t\tsearchRequestFacet.setFacetCollector(facetCollector);\n\t\t}\n\t}","id":93346,"modified_method":"protected void updateFacetCollectors(\n\t\tSearchContext searchContext, SearchResponse searchResponse) {\n\n\t\tMap<String, Facet> facetsMap = searchContext.getFacets();\n\n\t\tfor (Facet facet : facetsMap.values()) {\n\t\t\tif (facet.isStatic()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFacets facets = searchResponse.getFacets();\n\n\t\t\torg.elasticsearch.search.facet.Facet elasticsearchFacet =\n\t\t\t\tfacets.facet(facet.getFieldName());\n\n\t\t\tFacetCollector facetCollector =\n\t\t\t\tnew ElasticsearchFacetFieldCollector(elasticsearchFacet);\n\n\t\t\tfacet.setFacetCollector(facetCollector);\n\t\t}\n\t}","commit_id":"08777e197ce9d4e58fb21fd924a9996f055386ae","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addFacets(\n\t\tSearchRequestBuilder searchRequestBuilder,\n\t\tSearchContext searchContext) {\n\n\t\tMap<String, Facet> facets = searchContext.getFacets();\n\n\t\tfor (Facet facet : facets.values()) {\n\t\t\tif (facet.isStatic()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFacetProcessorUtil.processFacet(searchRequestBuilder, facet);\n\t\t}\n\t}","id":93347,"modified_method":"protected void addFacets(\n\t\tSearchRequestBuilder searchRequestBuilder,\n\t\tSearchContext searchContext) {\n\n\t\tMap<String, Facet> facetsMap = searchContext.getFacets();\n\n\t\tfor (Facet facet : facetsMap.values()) {\n\t\t\tif (facet.isStatic()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFacetProcessorUtil.processFacet(searchRequestBuilder, facet);\n\t\t}\n\t}","commit_id":"08777e197ce9d4e58fb21fd924a9996f055386ae","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getSnippet(SearchHit hit, QueryConfig queryConfig) {\n\t\tString localizedContentName = DocumentImpl.getLocalizedName(\n\t\t\tqueryConfig.getLocale(), Field.CONTENT);\n\n\t\tString localizedTitleName = DocumentImpl.getLocalizedName(\n\t\t\tqueryConfig.getLocale(), Field.TITLE);\n\n\t\tString snippet = null;\n\n\t\tMap<String, HighlightField> highlightFields = hit.getHighlightFields();\n\n\t\tif ((highlightFields == null) || highlightFields.isEmpty()) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tif (localizedContentName != null) {\n\t\t\tHighlightField highlightField = highlightFields.get(\n\t\t\t\tlocalizedContentName);\n\n\t\t\tif (highlightField != null) {\n\t\t\t\tText[] texts = highlightField.fragments();\n\n\t\t\t\tif ((texts != null) && (texts.length > 0)) {\n\t\t\t\t\tsnippet = texts[0].string();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((snippet == null) && (localizedTitleName != null)) {\n\t\t\tHighlightField highlightField = highlightFields.get(\n\t\t\t\tlocalizedContentName);\n\n\t\t\tif (highlightField != null) {\n\t\t\t\tText[] texts = highlightField.fragments();\n\n\t\t\t\tif ((texts != null) && (texts.length > 0)) {\n\t\t\t\t\tsnippet = texts[0].string();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (snippet == null) {\n\t\t\tsnippet = StringPool.BLANK;\n\t\t}\n\n\t\treturn snippet;\n\t}","id":93348,"modified_method":"protected String getSnippet(SearchHit hit, QueryConfig queryConfig) {\n\t\tString snippet = null;\n\n\t\tMap<String, HighlightField> highlightFields = hit.getHighlightFields();\n\n\t\tif ((highlightFields == null) || highlightFields.isEmpty()) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tString localizedContentName = DocumentImpl.getLocalizedName(\n\t\t\tqueryConfig.getLocale(), Field.CONTENT);\n\n\t\tif (localizedContentName != null) {\n\t\t\tHighlightField highlightField = highlightFields.get(\n\t\t\t\tlocalizedContentName);\n\n\t\t\tif (highlightField != null) {\n\t\t\t\tText[] texts = highlightField.fragments();\n\n\t\t\t\tif ((texts != null) && (texts.length > 0)) {\n\t\t\t\t\tsnippet = texts[0].string();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString localizedTitleName = DocumentImpl.getLocalizedName(\n\t\t\tqueryConfig.getLocale(), Field.TITLE);\n\n\t\tif ((snippet == null) && (localizedTitleName != null)) {\n\t\t\tHighlightField highlightField = highlightFields.get(\n\t\t\t\tlocalizedContentName);\n\n\t\t\tif (highlightField != null) {\n\t\t\t\tText[] texts = highlightField.fragments();\n\n\t\t\t\tif ((texts != null) && (texts.length > 0)) {\n\t\t\t\t\tsnippet = texts[0].string();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (snippet == null) {\n\t\t\tsnippet = StringPool.BLANK;\n\t\t}\n\n\t\treturn snippet;\n\t}","commit_id":"08777e197ce9d4e58fb21fd924a9996f055386ae","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected Document processSearchHit(SearchHit hit) {\n\t\tDocument document = new DocumentImpl();\n\n\t\tMap<String, SearchHitField> hitFields = hit.getFields();\n\n\t\tfor (Map.Entry<String, SearchHitField> entry : hitFields.entrySet()) {\n\t\t\tCollection<Object> fieldValues = entry.getValue().getValues();\n\n\t\t\tField field = new Field(\n\t\t\t\tentry.getKey(),\n\t\t\t\tArrayUtil.toStringArray(\n\t\t\t\t\tfieldValues.toArray(new Object[fieldValues.size()])));\n\n\t\t\tdocument.add(field);\n\t\t}\n\n\t\treturn document;\n\t}","id":93349,"modified_method":"protected Document processSearchHit(SearchHit hit) {\n\t\tDocument document = new DocumentImpl();\n\n\t\tMap<String, SearchHitField> searchHitFields = hit.getFields();\n\n\t\tfor (Map.Entry<String, SearchHitField> entry :\n\t\t\t\tsearchHitFields.entrySet()) {\n\n\t\t\tSearchHitField searchHitField = entry.getValue();\n\n\t\t\tCollection<Object> fieldValues = searchHitField.getValues();\n\n\t\t\tField field = new Field(\n\t\t\t\tentry.getKey(),\n\t\t\t\tArrayUtil.toStringArray(\n\t\t\t\t\tfieldValues.toArray(new Object[fieldValues.size()])));\n\n\t\t\tdocument.add(field);\n\t\t}\n\n\t\treturn document;\n\t}","commit_id":"08777e197ce9d4e58fb21fd924a9996f055386ae","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void setDefaultFacetProcessor(FacetProcessor defaultFacetProcessor) {\n\t\t_defaultFacetProcessor = defaultFacetProcessor;\n\t}","id":93350,"modified_method":"public void setDefaultFacetProcessor(\n\t\tFacetProcessor<Facet> defaultFacetProcessor) {\n\n\t\t_defaultFacetProcessor = defaultFacetProcessor;\n\t}","commit_id":"08777e197ce9d4e58fb21fd924a9996f055386ae","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static void processFacet(\n\t\tSearchRequestBuilder searchRequestBuilder, Facet facet) {\n\n\t\tFacetProcessor facetProcessor = _facetProcessors.get(\n\t\t\tfacet.getClass().getName());\n\n\t\tif (facetProcessor == null) {\n\t\t\tfacetProcessor = _defaultFacetProcessor;\n\t\t}\n\n\t\tfacetProcessor.processFacet(searchRequestBuilder, facet);\n\t}","id":93351,"modified_method":"public static void processFacet(\n\t\tSearchRequestBuilder searchRequestBuilder, Facet facet) {\n\n\t\tFacetProcessor<Facet> facetProcessor = _facetProcessors.get(\n\t\t\tfacet.getClass().getName());\n\n\t\tif (facetProcessor == null) {\n\t\t\tfacetProcessor = _defaultFacetProcessor;\n\t\t}\n\n\t\tfacetProcessor.processFacet(searchRequestBuilder, facet);\n\t}","commit_id":"08777e197ce9d4e58fb21fd924a9996f055386ae","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void setFacetProcessors(\n\t\tMap<String, FacetProcessor> facetProcessors) {\n\n\t\t_facetProcessors = facetProcessors;\n\t}","id":93352,"modified_method":"public void setFacetProcessors(\n\t\tMap<String, FacetProcessor<Facet>> facetProcessors) {\n\n\t\t_facetProcessors = facetProcessors;\n\t}","commit_id":"08777e197ce9d4e58fb21fd924a9996f055386ae","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic void processFacet(\n\t\tSearchRequestBuilder searchRequestBuilder, RangeFacet facet) {\n\n\t\tFacetConfiguration facetConfiguration = facet.getFacetConfiguration();\n\n\t\tJSONObject jsonObject = facetConfiguration.getData();\n\t\tJSONArray jsonArray = jsonObject.getJSONArray(\"ranges\");\n\n\t\tif (jsonArray == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tRangeFacetBuilder rangeFacetBuilder = new RangeFacetBuilder(\n\t\t\tfacetConfiguration.getFieldName());\n\n\t\trangeFacetBuilder.field(facetConfiguration.getFieldName());\n\n\t\tfor (int i = 0; i < jsonArray.length(); i++) {\n\t\t\tJSONObject rangeJSONObject = jsonArray.getJSONObject(i);\n\n\t\t\tString range = rangeJSONObject.getString(\"range\");\n\n\t\t\trange = range.replace(StringPool.OPEN_BRACKET, StringPool.BLANK);\n\n\t\t\trange = range.replace(StringPool.CLOSE_BRACKET, StringPool.BLANK);\n\n\t\t\tString[] rangeArray = range.split(StringPool.SPACE);\n\n\t\t\trangeFacetBuilder.addRange(rangeArray[0], rangeArray[2]);\n\t\t}\n\n\t\tsearchRequestBuilder.addFacet(rangeFacetBuilder);\n\t}","id":93353,"modified_method":"@Override\n\tpublic void processFacet(\n\t\tSearchRequestBuilder searchRequestBuilder, RangeFacet rangeFacet) {\n\n\t\tFacetConfiguration facetConfiguration =\n\t\t\trangeFacet.getFacetConfiguration();\n\n\t\tJSONObject jsonObject = facetConfiguration.getData();\n\n\t\tJSONArray jsonArray = jsonObject.getJSONArray(\"ranges\");\n\n\t\tif (jsonArray == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tRangeFacetBuilder rangeFacetBuilder = new RangeFacetBuilder(\n\t\t\tfacetConfiguration.getFieldName());\n\n\t\trangeFacetBuilder.field(facetConfiguration.getFieldName());\n\n\t\tfor (int i = 0; i < jsonArray.length(); i++) {\n\t\t\tJSONObject rangeJSONObject = jsonArray.getJSONObject(i);\n\n\t\t\tString range = rangeJSONObject.getString(\"range\");\n\n\t\t\trange = range.replace(StringPool.OPEN_BRACKET, StringPool.BLANK);\n\t\t\trange = range.replace(StringPool.CLOSE_BRACKET, StringPool.BLANK);\n\n\t\t\tString[] rangeParts = range.split(StringPool.SPACE);\n\n\t\t\trangeFacetBuilder.addRange(rangeParts[0], rangeParts[2]);\n\t\t}\n\n\t\tsearchRequestBuilder.addFacet(rangeFacetBuilder);\n\t}","commit_id":"08777e197ce9d4e58fb21fd924a9996f055386ae","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addFacetSelectedFieldNames(\n\t\tSearchContext searchContext, QueryConfig queryConfig) {\n\n\t\tString[] selectedFieldNames = queryConfig.getSelectedFieldNames();\n\n\t\tif (ArrayUtil.isEmpty(selectedFieldNames) ||\n\t\t\t(selectedFieldNames.length == 1) &&\n\t\t\tselectedFieldNames[0].equals(Field.ANY)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tSet<String> selectedFieldNameSet = SetUtil.fromArray(\n\t\t\tselectedFieldNames);\n\n\t\tSet<String> facetNames = searchContext.getFacets().keySet();\n\n\t\tselectedFieldNameSet.addAll(facetNames);\n\n\t\tselectedFieldNames = selectedFieldNameSet.toArray(\n\t\t\tnew String[selectedFieldNameSet.size()]);\n\n\t\tqueryConfig.setSelectedFieldNames(selectedFieldNames);\n\t}","id":93354,"modified_method":"protected void addFacetSelectedFieldNames(\n\t\tSearchContext searchContext, QueryConfig queryConfig) {\n\n\t\tString[] selectedFieldNames = queryConfig.getSelectedFieldNames();\n\n\t\tif (ArrayUtil.isEmpty(selectedFieldNames) ||\n\t\t\t(selectedFieldNames.length == 1) &&\n\t\t\tselectedFieldNames[0].equals(Field.ANY)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tSet<String> selectedFieldNameSet = SetUtil.fromArray(\n\t\t\tselectedFieldNames);\n\t\t\t\n\t\tMap<String, Facet> facets = searchContext.getFacets();\n\n\t\tselectedFieldNameSet.addAll(facets.keySet());\n\n\t\tselectedFieldNames = selectedFieldNameSet.toArray(\n\t\t\tnew String[selectedFieldNameSet.size()]);\n\n\t\tqueryConfig.setSelectedFieldNames(selectedFieldNames);\n\t}","commit_id":"942fddc04b0cc82fb34ca1d6d4861f26bd9c6172","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void doView(RenderRequest req, RenderResponse res)\n\t\tthrows IOException, PortletException {\n\n\t\tPortletRequestDispatcher prd =\n\t\t\tgetPortletContext().getRequestDispatcher(\"/view.jsp\");\n\n\t\tif (prd == null) {\n\t\t\t_log.error(\"/view.jsp is not a valid include\");\n\t\t}\n\n\t\tprd.include(req, res);\n\t}","id":93355,"modified_method":"public void doView(RenderRequest req, RenderResponse res)\n\t\tthrows IOException, PortletException {\n\n\t\tPortletContext ctx = getPortletContext();\n\n\t\tPortletRequestDispatcher prd = ctx.getRequestDispatcher(\"/view.jsp\");\n\n\t\tif (prd == null) {\n\t\t\t_log.error(\"/view.jsp is not a valid include\");\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tprd.include(req, res);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tprd = ctx.getRequestDispatcher(\"/error.jsp\");\n\n\t\t\t\tif (prd == null) {\n\t\t\t\t\t_log.error(\"/error.jsp is not a valid include\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprd.include(req, res);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"f081bb84ace12d1aafe7921fdde702bcf2cd5085","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void serveResource(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tString path = \"/html/portlet/journal/editor_taglib.jsp\";\n\n\t\tPortletRequestDispatcher portletRequestDispatcher =\n\t\t\tportletConfig.getPortletContext().getRequestDispatcher(path);\n\n\t\tportletRequestDispatcher.include(resourceRequest, resourceResponse);\n\t}","id":93356,"modified_method":"public void serveResource(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tPortletContext portletContext = portletConfig.getPortletContext();\n\n\t\tPortletRequestDispatcher portletRequestDispatcher =\n\t\t\tportletContext.getRequestDispatcher(\n\t\t\t\t\"/html/portlet/journal/editor.jsp\");\n\n\t\tportletRequestDispatcher.include(resourceRequest, resourceResponse);\n\t}","commit_id":"27d33d9aec3d3a7707d5d53c078602f25b84622d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getPage() {\n\t\treturn _PAGE;\n\t}","id":93357,"modified_method":"protected String getPage() {\n\t\treturn _page;\n\t}","commit_id":"27d33d9aec3d3a7707d5d53c078602f25b84622d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void setAttributes(HttpServletRequest request) {\n\t\tString editorImpl = _editorImpl;\n\n\t\tif (Validator.isNotNull(editorImpl)) {\n\t\t\teditorImpl = PropsUtil.get(editorImpl);\n\t\t}\n\n\t\tif (!BrowserSnifferUtil.isRtf(request)) {\n\t\t\tif (BrowserSnifferUtil.isSafari(request) &&\n\t\t\t\tBrowserSnifferUtil.isMobile(request)) {\n\n\t\t\t\teditorImpl = \"simple\";\n\t\t\t}\n\t\t\telse if (BrowserSnifferUtil.isSafari(request) &&\n\t\t\t\t(editorImpl.indexOf(\"simple\") == -1)) {\n\n\t\t\t\teditorImpl = \"tinymce_simple\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\teditorImpl = \"simple\";\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNull(editorImpl)) {\n\t\t\teditorImpl = PropsValues.EDITOR_WYSIWYG_DEFAULT;\n\t\t}\n\n\t\t_PAGE = \"/html/js/editor/\" + editorImpl + \".jsp\";\n\n\t\tString cssClasses = \"portlet \";\n\n\t\tPortlet portlet = (Portlet)request.getAttribute(WebKeys.RENDER_PORTLET);\n\n\t\tif (portlet != null) {\n\t\t\tcssClasses += portlet.getCssClassWrapper();\n\t\t}\n\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:input-editor:configParams\", _configParams);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:cssClass\", _cssClass);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:cssClasses\", cssClasses);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:editorImpl\", editorImpl);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:height\", _height);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:initMethod\", _initMethod);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:name\", _name);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:input-editor:onChangeMethod\", _onChangeMethod);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:toolbarSet\", _toolbarSet);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:width\", _width);\n\t}","id":93358,"modified_method":"protected void setAttributes(HttpServletRequest request) {\n\t\tString cssClasses = \"portlet \";\n\n\t\tPortlet portlet = (Portlet)request.getAttribute(WebKeys.RENDER_PORTLET);\n\n\t\tif (portlet != null) {\n\t\t\tcssClasses += portlet.getCssClassWrapper();\n\t\t}\n\n\t\tString editorImpl = _editorImpl;\n\n\t\tif (Validator.isNotNull(editorImpl)) {\n\t\t\teditorImpl = PropsUtil.get(editorImpl);\n\t\t}\n\n\t\tif (!BrowserSnifferUtil.isRtf(request)) {\n\t\t\tif (BrowserSnifferUtil.isSafari(request) &&\n\t\t\t\tBrowserSnifferUtil.isMobile(request)) {\n\n\t\t\t\teditorImpl = \"simple\";\n\t\t\t}\n\t\t\telse if (BrowserSnifferUtil.isSafari(request) &&\n\t\t\t\t(editorImpl.indexOf(\"simple\") == -1)) {\n\n\t\t\t\teditorImpl = \"tinymce_simple\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\teditorImpl = \"simple\";\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNull(editorImpl)) {\n\t\t\teditorImpl = PropsValues.EDITOR_WYSIWYG_DEFAULT;\n\t\t}\n\n\t\t_page = \"/html/js/editor/\" + editorImpl + \".jsp\";\n\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:input-editor:configParams\", _configParams);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:cssClass\", _cssClass);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:cssClasses\", cssClasses);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:editorImpl\", editorImpl);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:height\", _height);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:initMethod\", _initMethod);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:name\", _name);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:input-editor:onChangeMethod\", _onChangeMethod);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:toolbarSet\", _toolbarSet);\n\t\trequest.setAttribute(\"liferay-ui:input-editor:width\", _width);\n\t}","commit_id":"27d33d9aec3d3a7707d5d53c078602f25b84622d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void cleanUp() {\n\t\t_configParams = null;\n\t\t_cssClass = null;\n\t\t_editorImpl = null;\n\t\t_height = null;\n\t\t_initMethod = \"initEditor\";\n\t\t_name = \"editor\";\n\t\t_onChangeMethod = null;\n\t\t_PAGE = null;\n\t\t_toolbarSet = \"liferay\";\n\t\t_width = null;\n\t}","id":93359,"modified_method":"protected void cleanUp() {\n\t\t_configParams = null;\n\t\t_cssClass = null;\n\t\t_editorImpl = null;\n\t\t_height = null;\n\t\t_initMethod = \"initEditor\";\n\t\t_name = \"editor\";\n\t\t_onChangeMethod = null;\n\t\t_page = null;\n\t\t_toolbarSet = \"liferay\";\n\t\t_width = null;\n\t}","commit_id":"27d33d9aec3d3a7707d5d53c078602f25b84622d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static OrderByComparator getEntryOrderByComparator(\n\t\tString orderByCol, String orderByType) {\n\n\t\tboolean orderByAsc = true;\n\n\t\tif (orderByType.equals(\"desc\")) {\n\t\t\torderByAsc = false;\n\t\t}\n\n\t\tOrderByComparator orderByComparator = null;\n\n\t\tif (orderByCol.equals(\"creationDate\")) {\n\t\t\torderByComparator = new RepositoryModelCreateDateComparator(\n\t\t\t\torderByAsc);\n\t\t}\n\t\telse if (orderByCol.equals(\"modifiedDate\")) {\n\t\t\torderByComparator = new RepositoryModelModifiedDateComparator(\n\t\t\t\torderByAsc);\n\t\t}\n\t\telse if (orderByCol.equals(\"readCount\")) {\n\t\t\torderByComparator = new RepositoryModelReadCountComparator(\n\t\t\t\torderByAsc);\n\t\t}\n\t\telse if (orderByCol.equals(\"size\")) {\n\t\t\torderByComparator = new RepositoryModelSizeComparator(orderByAsc);\n\t\t}\n\t\telse {\n\t\t\torderByComparator = new RepositoryModelNameComparator(orderByAsc);\n\t\t}\n\n\t\treturn orderByComparator;\n\t}","id":93360,"modified_method":"public static OrderByComparator getRepositoryModelOrderByComparator(\n\t\tString orderByCol, String orderByType) {\n\n\t\tboolean orderByAsc = true;\n\n\t\tif (orderByType.equals(\"desc\")) {\n\t\t\torderByAsc = false;\n\t\t}\n\n\t\tOrderByComparator orderByComparator = null;\n\n\t\tif (orderByCol.equals(\"creationDate\")) {\n\t\t\torderByComparator = new RepositoryModelCreateDateComparator(\n\t\t\t\torderByAsc);\n\t\t}\n\t\telse if (orderByCol.equals(\"modifiedDate\")) {\n\t\t\torderByComparator = new RepositoryModelModifiedDateComparator(\n\t\t\t\torderByAsc);\n\t\t}\n\t\telse if (orderByCol.equals(\"readCount\")) {\n\t\t\torderByComparator = new RepositoryModelReadCountComparator(\n\t\t\t\torderByAsc);\n\t\t}\n\t\telse if (orderByCol.equals(\"size\")) {\n\t\t\torderByComparator = new RepositoryModelSizeComparator(orderByAsc);\n\t\t}\n\t\telse {\n\t\t\torderByComparator = new RepositoryModelNameComparator(orderByAsc);\n\t\t}\n\n\t\treturn orderByComparator;\n\t}","commit_id":"05b657b9d1f4a587836c99b5d49d20d78c510962","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateFileEntry(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tUploadPortletRequest uploadRequest = PortalUtil.getUploadPortletRequest(\n\t\t\tactionRequest);\n\n\t\tString cmd = ParamUtil.getString(uploadRequest, Constants.CMD);\n\n\t\tlong fileEntryId = ParamUtil.getLong(uploadRequest, \"fileEntryId\");\n\n\t\tlong repositoryId = ParamUtil.getLong(uploadRequest, \"repositoryId\");\n\t\tlong folderId = ParamUtil.getLong(uploadRequest, \"folderId\");\n\t\tString sourceFileName = uploadRequest.getFileName(\"file\");\n\t\tString title = ParamUtil.getString(uploadRequest, \"title\");\n\t\tString description = ParamUtil.getString(uploadRequest, \"description\");\n\t\tString changeLog = ParamUtil.getString(uploadRequest, \"changeLog\");\n\t\tboolean majorVersion = ParamUtil.getBoolean(\n\t\t\tuploadRequest, \"majorVersion\");\n\n\t\tFile file = uploadRequest.getFile(\"file\");\n\t\tString contentType = uploadRequest.getContentType(\"file\");\n\n\t\tif (Validator.isNotNull(sourceFileName) && !file.exists()) {\n\t\t\tfile.createNewFile();\n\t\t}\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tDLFileEntry.class.getName(), actionRequest);\n\n\t\tif (cmd.equals(Constants.ADD)) {\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle = sourceFileName;\n\t\t\t}\n\n\t\t\tString extension = FileUtil.getExtension(sourceFileName);\n\n\t\t\tserviceContext.setAttribute(\"contentType\", contentType);\n\t\t\tserviceContext.setAttribute(\"sourceFileName\", sourceFileName);\n\t\t\tserviceContext.setAttribute(\"extension\", extension);\n\n\t\t\t// Add file entry\n\n\t\t\tFileEntry fileEntry = DLAppServiceUtil.addFileEntry(\n\t\t\t\trepositoryId, folderId, title, description, changeLog, file,\n\t\t\t\tserviceContext);\n\n\t\t\tAssetPublisherUtil.addAndStoreSelection(\n\t\t\t\tactionRequest, DLFileEntry.class.getName(),\n\t\t\t\tfileEntry.getFileEntryId(), -1);\n\t\t}\n\t\telse {\n\t\t\tif (Validator.isNotNull(sourceFileName)) {\n\t\t\t\tString extension = FileUtil.getExtension(sourceFileName);\n\n\t\t\t\tserviceContext.setAttribute(\"contentType\", contentType);\n\t\t\t\tserviceContext.setAttribute(\"sourceFileName\", sourceFileName);\n\t\t\t\tserviceContext.setAttribute(\"extension\", extension);\n\t\t\t}\n\n\t\t\t// Update file entry\n\n\t\t\tDLAppServiceUtil.updateFileEntry(\n\t\t\t\tfileEntryId, sourceFileName, title, description, changeLog,\n\t\t\t\tmajorVersion, file, serviceContext);\n\t\t}\n\n\t\tAssetPublisherUtil.addRecentFolderId(\n\t\t\tactionRequest, DLFileEntry.class.getName(), folderId);\n\t}","id":93361,"modified_method":"protected void updateFileEntry(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tUploadPortletRequest uploadRequest = PortalUtil.getUploadPortletRequest(\n\t\t\tactionRequest);\n\n\t\tString cmd = ParamUtil.getString(uploadRequest, Constants.CMD);\n\n\t\tlong fileEntryId = ParamUtil.getLong(uploadRequest, \"fileEntryId\");\n\n\t\tlong repositoryId = ParamUtil.getLong(uploadRequest, \"repositoryId\");\n\t\tlong folderId = ParamUtil.getLong(uploadRequest, \"folderId\");\n\t\tString sourceFileName = uploadRequest.getFileName(\"file\");\n\t\tString title = ParamUtil.getString(uploadRequest, \"title\");\n\t\tString description = ParamUtil.getString(uploadRequest, \"description\");\n\t\tString changeLog = ParamUtil.getString(uploadRequest, \"changeLog\");\n\t\tboolean majorVersion = ParamUtil.getBoolean(\n\t\t\tuploadRequest, \"majorVersion\");\n\n\t\tFile file = uploadRequest.getFile(\"file\");\n\n\t\tif (Validator.isNotNull(sourceFileName) && !file.exists()) {\n\t\t\tfile.createNewFile();\n\t\t}\n\n\t\tString contentType = uploadRequest.getContentType(\"file\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tDLFileEntry.class.getName(), actionRequest);\n\n\t\tif (cmd.equals(Constants.ADD)) {\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle = sourceFileName;\n\t\t\t}\n\n\t\t\tserviceContext.setAttribute(\"contentType\", contentType);\n\n\t\t\tString extension = FileUtil.getExtension(sourceFileName);\n\n\t\t\tserviceContext.setAttribute(\"extension\", extension);\n\n\t\t\tserviceContext.setAttribute(\"sourceFileName\", sourceFileName);\n\n\t\t\t// Add file entry\n\n\t\t\tFileEntry fileEntry = DLAppServiceUtil.addFileEntry(\n\t\t\t\trepositoryId, folderId, title, description, changeLog, file,\n\t\t\t\tserviceContext);\n\n\t\t\tAssetPublisherUtil.addAndStoreSelection(\n\t\t\t\tactionRequest, DLFileEntry.class.getName(),\n\t\t\t\tfileEntry.getFileEntryId(), -1);\n\t\t}\n\t\telse {\n\t\t\tif (Validator.isNotNull(sourceFileName)) {\n\t\t\t\tserviceContext.setAttribute(\"contentType\", contentType);\n\n\t\t\t\tString extension = FileUtil.getExtension(sourceFileName);\n\n\t\t\t\tserviceContext.setAttribute(\"extension\", extension);\n\n\t\t\t\tserviceContext.setAttribute(\"sourceFileName\", sourceFileName);\n\t\t\t}\n\n\t\t\t// Update file entry\n\n\t\t\tDLAppServiceUtil.updateFileEntry(\n\t\t\t\tfileEntryId, sourceFileName, title, description, changeLog,\n\t\t\t\tmajorVersion, file, serviceContext);\n\t\t}\n\n\t\tAssetPublisherUtil.addRecentFolderId(\n\t\t\tactionRequest, DLFileEntry.class.getName(), folderId);\n\t}","commit_id":"05b657b9d1f4a587836c99b5d49d20d78c510962","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void serveResource(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tPortletRequestDispatcher portletRequestDispatcher =\n\t\t\tportletConfig.getPortletContext().getRequestDispatcher(\n\t\t\t\t\"/html/portlet/library_admin/library_entries.jsp\");\n\n\t\tportletRequestDispatcher.include(resourceRequest, resourceResponse);\n\t}","id":93362,"modified_method":"public void serveResource(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tPortletContext portletContext = portletConfig.getPortletContext();\n\n\t\tPortletRequestDispatcher portletRequestDispatcher =\n\t\t\tportletContext.getRequestDispatcher(\n\t\t\t\t\"/html/portlet/library_admin/library_entries.jsp\");\n\n\t\tportletRequestDispatcher.include(resourceRequest, resourceResponse);\n\t}","commit_id":"05b657b9d1f4a587836c99b5d49d20d78c510962","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/** new style requests need to fill in the tunnel IDs before hand */\n    private static void prepare(RouterContext ctx, PooledTunnelCreatorConfig cfg) {\n        int len = cfg.getLength();\n        boolean isIB = cfg.isInbound();\n        for (int i = 0; i < len; i++) {\n            if ( (!isIB) && (i == 0) ) {\n                // outbound gateway (us) doesn't receive on a tunnel id\n                if (len <= 1)  { // zero hop, pretend to have a send id\n                    long id = ctx.tunnelDispatcher().getNewOBGWID();\n                    cfg.getConfig(i).setSendTunnelId(DataHelper.toLong(4, id));\n                }\n            } else {\n                long id;\n                if (isIB && len == 1)\n                    id = ctx.tunnelDispatcher().getNewIBZeroHopID();\n                else if (isIB && i == len - 1)\n                    id = ctx.tunnelDispatcher().getNewIBEPID();\n                else\n                    id = ctx.random().nextLong(TunnelId.MAX_ID_VALUE);\n                cfg.getConfig(i).setReceiveTunnelId(DataHelper.toLong(4, id));\n            }\n            \n            if (i > 0)\n                cfg.getConfig(i-1).setSendTunnelId(cfg.getConfig(i).getReceiveTunnelId());\n            byte iv[] = new byte[16];\n            ctx.random().nextBytes(iv);\n            cfg.getConfig(i).setReplyIV(iv);\n            cfg.getConfig(i).setReplyKey(ctx.keyGenerator().generateSessionKey());\n        }\n        // This is in BuildExecutor.buildTunnel() now\n        // And it was overwritten by the one in createTunnelBuildMessage() anyway!\n        //cfg.setReplyMessageId(ctx.random().nextLong(I2NPMessage.MAX_ID_VALUE));\n    }","id":93363,"modified_method":"/** new style requests need to fill in the tunnel IDs before hand */\n    private static void prepare(RouterContext ctx, PooledTunnelCreatorConfig cfg) {\n        int len = cfg.getLength();\n        boolean isIB = cfg.isInbound();\n        for (int i = 0; i < len; i++) {\n            if ( (!isIB) && (i == 0) ) {\n                // outbound gateway (us) doesn't receive on a tunnel id\n                if (len <= 1)  { // zero hop, pretend to have a send id\n                    long id = ctx.tunnelDispatcher().getNewOBGWID();\n                    cfg.getConfig(i).setSendTunnelId(DataHelper.toLong(4, id));\n                }\n            } else {\n                long id;\n                if (isIB && len == 1)\n                    id = ctx.tunnelDispatcher().getNewIBZeroHopID();\n                else if (isIB && i == len - 1)\n                    id = ctx.tunnelDispatcher().getNewIBEPID();\n                else\n                    id = 1 + ctx.random().nextLong(TunnelId.MAX_ID_VALUE - 1);\n                cfg.getConfig(i).setReceiveTunnelId(DataHelper.toLong(4, id));\n            }\n            \n            if (i > 0)\n                cfg.getConfig(i-1).setSendTunnelId(cfg.getConfig(i).getReceiveTunnelId());\n            byte iv[] = new byte[16];\n            ctx.random().nextBytes(iv);\n            cfg.getConfig(i).setReplyIV(iv);\n            cfg.getConfig(i).setReplyKey(ctx.keyGenerator().generateSessionKey());\n        }\n        // This is in BuildExecutor.buildTunnel() now\n        // And it was overwritten by the one in createTunnelBuildMessage() anyway!\n        //cfg.setReplyMessageId(ctx.random().nextLong(I2NPMessage.MAX_ID_VALUE));\n    }","commit_id":"5bf515441ee23545e04de39ef3e5dc51044f15a5","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Get a new random receive tunnel ID that isn't a dup.\n     *  For zero hop tunnels only.\n     *  Note that we do not keep track of IDs for pending builds so this\n     *  does not fully prevent joinInbound() from failing later.\n     *  @since 0.9.5\n     */\n    public long getNewIBZeroHopID() {\n        long rv;\n        TunnelId tid;\n        do {\n            rv = _context.random().nextLong(TunnelId.MAX_ID_VALUE);\n            tid = new TunnelId(rv);\n        } while (_inboundGateways.containsKey(tid));\n        return rv;\n    }","id":93364,"modified_method":"/**\n     *  Get a new random receive tunnel ID that isn't a dup.\n     *  For zero hop tunnels only.\n     *  Note that we do not keep track of IDs for pending builds so this\n     *  does not fully prevent joinInbound() from failing later.\n     *  @since 0.9.5\n     */\n    public long getNewIBZeroHopID() {\n        long rv;\n        TunnelId tid;\n        do {\n            rv = 1 + _context.random().nextLong(TunnelId.MAX_ID_VALUE - 1);\n            tid = new TunnelId(rv);\n        } while (_inboundGateways.containsKey(tid));\n        return rv;\n    }","commit_id":"5bf515441ee23545e04de39ef3e5dc51044f15a5","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Get a new random receive tunnel ID that isn't a dup.\n     *  Not for zero hop tunnels.\n     *  Note that we do not keep track of IDs for pending builds so this\n     *  does not fully prevent joinInbound() from failing later.\n     *  @since 0.9.5\n     */\n    public long getNewIBEPID() {\n        long rv;\n        TunnelId tid;\n        do {\n            rv = _context.random().nextLong(TunnelId.MAX_ID_VALUE);\n            tid = new TunnelId(rv);\n        } while (_participants.containsKey(tid));\n        return rv;\n    }","id":93365,"modified_method":"/**\n     *  Get a new random receive tunnel ID that isn't a dup.\n     *  Not for zero hop tunnels.\n     *  Note that we do not keep track of IDs for pending builds so this\n     *  does not fully prevent joinInbound() from failing later.\n     *  @since 0.9.5\n     */\n    public long getNewIBEPID() {\n        long rv;\n        TunnelId tid;\n        do {\n            rv = 1 + _context.random().nextLong(TunnelId.MAX_ID_VALUE - 1);\n            tid = new TunnelId(rv);\n        } while (_participants.containsKey(tid));\n        return rv;\n    }","commit_id":"5bf515441ee23545e04de39ef3e5dc51044f15a5","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Get a new random send tunnel ID that isn't a dup.\n     *  Note that we do not keep track of IDs for pending builds so this\n     *  does not fully prevent joinOutbound() from failing later.\n     *  @since 0.9.5\n     */\n    public long getNewOBGWID() {\n        long rv;\n        TunnelId tid;\n        do {\n            rv = _context.random().nextLong(TunnelId.MAX_ID_VALUE);\n            tid = new TunnelId(rv);\n        } while (_outboundGateways.containsKey(tid));\n        return rv;\n    }","id":93366,"modified_method":"/**\n     *  Get a new random send tunnel ID that isn't a dup.\n     *  Note that we do not keep track of IDs for pending builds so this\n     *  does not fully prevent joinOutbound() from failing later.\n     *  @since 0.9.5\n     */\n    public long getNewOBGWID() {\n        long rv;\n        TunnelId tid;\n        do {\n            rv = 1 + _context.random().nextLong(TunnelId.MAX_ID_VALUE - 1);\n            tid = new TunnelId(rv);\n        } while (_outboundGateways.containsKey(tid));\n        return rv;\n    }","commit_id":"5bf515441ee23545e04de39ef3e5dc51044f15a5","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public TunnelId(long id) { \n        if (id <= 0) throw new IllegalArgumentException(\"wtf, tunnelId \" + id);\n        _tunnelId = id;\n    }","id":93367,"modified_method":"/**\n     *  @param id 1 to 0xffffffff\n     *  @throws IllegalArgumentException if less than or equal to zero\n     */\n    public TunnelId(long id) { \n        if (id <= 0) throw new IllegalArgumentException(\"wtf, tunnelId \" + id);\n        _tunnelId = id;\n    }","commit_id":"5bf515441ee23545e04de39ef3e5dc51044f15a5","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void setTunnelId(long id) { \n        _tunnelId = id; \n        if (id <= 0) throw new IllegalArgumentException(\"wtf, tunnelId \" + id);\n    }","id":93368,"modified_method":"/**\n     *  @param id 1 to 0xffffffff\n     *  @throws IllegalArgumentException if less than or equal to zero\n     */\n    public void setTunnelId(long id) { \n        _tunnelId = id; \n        if (id <= 0) throw new IllegalArgumentException(\"wtf, tunnelId \" + id);\n    }","commit_id":"5bf515441ee23545e04de39ef3e5dc51044f15a5","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void runJob() {\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"Handling database store message\");\n\n        long recvBegin = System.currentTimeMillis();\n        \n        String invalidMessage = null;\n        // set if invalid store but not his fault\n        boolean dontBlamePeer = false;\n        boolean wasNew = false;\n        RouterInfo prevNetDb = null;\n        Hash key = _message.getKey();\n        DatabaseEntry entry = _message.getEntry();\n        if (entry.getType() == DatabaseEntry.KEY_TYPE_LEASESET) {\n            getContext().statManager().addRateData(\"netDb.storeLeaseSetHandled\", 1);\n            if (_log.shouldLog(Log.INFO))\n                _log.info(\"Handling dbStore of leaseset \" + _message);\n                //_log.info(\"Handling dbStore of leasset \" + key + \" with expiration of \" \n                //          + new Date(_message.getLeaseSet().getEarliestLeaseDate()));\n   \n            try {\n                // Never store a leaseSet for a local dest received from somebody else.\n                // This generally happens from a FloodfillVerifyStoreJob.\n                // If it is valid, it shouldn't be newer than what we have - unless\n                // somebody has our keys... \n                // This could happen with multihoming - where it's really important to prevent\n                // storing the other guy's leaseset, it will confuse us badly.\n                if (getContext().clientManager().isLocal(key)) {\n                    //getContext().statManager().addRateData(\"netDb.storeLocalLeaseSetAttempt\", 1, 0);\n                    // throw rather than return, so that we send the ack below (prevent easy attack)\n                    dontBlamePeer = true;\n                    throw new IllegalArgumentException(\"Peer attempted to store local leaseSet: \" +\n                                                       key.toBase64().substring(0, 4));\n                }\n                LeaseSet ls = (LeaseSet) entry;\n                //boolean oldrar = ls.getReceivedAsReply();\n                //boolean oldrap = ls.getReceivedAsPublished();\n                // If this was received as a response to a query,\n                // FloodOnlyLookupMatchJob called setReceivedAsReply(),\n                // and we are seeing this only as a duplicate,\n                // so we don't set the receivedAsPublished() flag.\n                // Otherwise, mark it as something we received unsolicited, so we'll answer queries \n                // for it.  This flag must NOT get set on entries that we \n                // receive in response to our own lookups.\n                // See ../HDLMJ for more info\n                if (!ls.getReceivedAsReply())\n                    ls.setReceivedAsPublished(true);\n                //boolean rap = ls.getReceivedAsPublished();\n                //if (_log.shouldLog(Log.INFO))\n                //    _log.info(\"oldrap? \" + oldrap + \" oldrar? \" + oldrar + \" newrap? \" + rap);\n                LeaseSet match = getContext().netDb().store(key, ls);\n                if (match == null) {\n                    wasNew = true;\n                } else if (match.getEarliestLeaseDate() < ls.getEarliestLeaseDate()) {\n                    wasNew = true;\n                    // If it is in our keyspace and we are talking to it\n\n\n                    if (match.getReceivedAsPublished())\n                        ls.setReceivedAsPublished(true);\n                } else {\n                    wasNew = false;\n                    // The FloodOnlyLookupSelector goes away after the first good reply\n                    // So on the second reply, FloodOnlyMatchJob is not called to set ReceivedAsReply.\n                    // So then we think it's an unsolicited store.\n                    // So we should skip this.\n                    // If the 2nd reply is newer than the first, ReceivedAsPublished will be set incorrectly,\n                    // that will hopefully be rare.\n                    // A more elaborate solution would be a List of recent ReceivedAsReply LeaseSets, with receive time ?\n                    // A real unsolicited store is likely to be new - hopefully...\n                    //if (!ls.getReceivedAsReply())\n                    //    match.setReceivedAsPublished(true);\n                }\n            } catch (UnsupportedCryptoException uce) {\n                invalidMessage = uce.getMessage();\n                dontBlamePeer = true;\n            } catch (IllegalArgumentException iae) {\n                invalidMessage = iae.getMessage();\n            }\n        } else if (entry.getType() == DatabaseEntry.KEY_TYPE_ROUTERINFO) {\n            RouterInfo ri = (RouterInfo) entry;\n            getContext().statManager().addRateData(\"netDb.storeRouterInfoHandled\", 1);\n            if (_log.shouldLog(Log.INFO))\n                _log.info(\"Handling dbStore of router \" + key + \" with publishDate of \" \n                          + new Date(ri.getPublished()));\n            try {\n                // Never store our RouterInfo received from somebody else.\n                // This generally happens from a FloodfillVerifyStoreJob.\n                // If it is valid, it shouldn't be newer than what we have - unless\n                // somebody has our keys... \n                if (getContext().routerHash().equals(key)) {\n                    //getContext().statManager().addRateData(\"netDb.storeLocalRouterInfoAttempt\", 1, 0);\n                    // throw rather than return, so that we send the ack below (prevent easy attack)\n                    dontBlamePeer = true;\n                    throw new IllegalArgumentException(\"Peer attempted to store our RouterInfo\");\n                }\n                getContext().profileManager().heardAbout(key);\n                prevNetDb = getContext().netDb().store(key, ri);\n                wasNew = ((null == prevNetDb) || (prevNetDb.getPublished() < ri.getPublished()));\n                // Check new routerinfo address against blocklist\n                if (wasNew) {\n                    if (prevNetDb == null) {\n                        if ((!getContext().banlist().isBanlistedForever(key)) &&\n                            getContext().blocklist().isBlocklisted(key) &&\n                            _log.shouldLog(Log.WARN))\n                                _log.warn(\"Blocklisting new peer \" + key + ' ' + ri);\n                    } else {\n                        Collection<RouterAddress> oldAddr = prevNetDb.getAddresses();\n                        Collection<RouterAddress> newAddr = ri.getAddresses();\n                        if ((!newAddr.equals(oldAddr)) &&\n                            (!getContext().banlist().isBanlistedForever(key)) &&\n                            getContext().blocklist().isBlocklisted(key) &&\n                            _log.shouldLog(Log.WARN))\n                                _log.warn(\"New address received, Blocklisting old peer \" + key + ' ' + ri);\n                    }\n                }\n            } catch (UnsupportedCryptoException uce) {\n                invalidMessage = uce.getMessage();\n                dontBlamePeer = true;\n            } catch (IllegalArgumentException iae) {\n                invalidMessage = iae.getMessage();\n            }\n        } else {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"Invalid DatabaseStoreMessage data type - \" + entry.getType() \n                           + \": \" + _message);\n        }\n        \n        long recvEnd = System.currentTimeMillis();\n        getContext().statManager().addRateData(\"netDb.storeRecvTime\", recvEnd-recvBegin);\n        \n        // ack even if invalid or unsupported\n        // TODO any cases where we shouldn't?\n        if (_message.getReplyToken() > 0)\n            sendAck();\n        long ackEnd = System.currentTimeMillis();\n        \n        if (_from != null)\n            _fromHash = _from.getHash();\n        if (_fromHash != null) {\n            if (invalidMessage == null || dontBlamePeer) {\n                getContext().profileManager().dbStoreReceived(_fromHash, wasNew);\n                getContext().statManager().addRateData(\"netDb.storeHandled\", ackEnd-recvEnd);\n            } else {\n                // Should we record in the profile?\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Peer \" + _fromHash.toBase64() + \" sent bad data: \" + invalidMessage);\n            }\n        } else if (invalidMessage != null && !dontBlamePeer) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Unknown peer sent bad data: \" + invalidMessage);\n        }\n\n        // flood it\n        if (invalidMessage == null &&\n            getContext().netDb().floodfillEnabled() &&\n            _message.getReplyToken() > 0) {\n            if (wasNew) {\n                // DOS prevention\n                // Note this does not throttle the ack above\n                if (_facade.shouldThrottleFlood(key)) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"Too many recent stores, not flooding key: \" + key);\n                    getContext().statManager().addRateData(\"netDb.floodThrottled\", 1);\n                    return;\n                }\n                long floodBegin = System.currentTimeMillis();\n                _facade.flood(_message.getEntry());\n                // ERR: see comment in HandleDatabaseLookupMessageJob regarding hidden mode\n                //else if (!_message.getRouterInfo().isHidden())\n                long floodEnd = System.currentTimeMillis();\n                getContext().statManager().addRateData(\"netDb.storeFloodNew\", floodEnd-floodBegin, 60*1000);\n            } else {\n                // don't flood it *again*\n                getContext().statManager().addRateData(\"netDb.storeFloodOld\", 1);\n            }\n        }\n    }","id":93369,"modified_method":"public void runJob() {\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"Handling database store message\");\n\n        long recvBegin = System.currentTimeMillis();\n        \n        String invalidMessage = null;\n        // set if invalid store but not his fault\n        boolean dontBlamePeer = false;\n        boolean wasNew = false;\n        RouterInfo prevNetDb = null;\n        Hash key = _message.getKey();\n        DatabaseEntry entry = _message.getEntry();\n        if (entry.getType() == DatabaseEntry.KEY_TYPE_LEASESET) {\n            getContext().statManager().addRateData(\"netDb.storeLeaseSetHandled\", 1);\n            if (_log.shouldLog(Log.INFO))\n                _log.info(\"Handling dbStore of leaseset \" + _message);\n                //_log.info(\"Handling dbStore of leasset \" + key + \" with expiration of \" \n                //          + new Date(_message.getLeaseSet().getEarliestLeaseDate()));\n   \n            try {\n                // Never store a leaseSet for a local dest received from somebody else.\n                // This generally happens from a FloodfillVerifyStoreJob.\n                // If it is valid, it shouldn't be newer than what we have - unless\n                // somebody has our keys... \n                // This could happen with multihoming - where it's really important to prevent\n                // storing the other guy's leaseset, it will confuse us badly.\n                if (getContext().clientManager().isLocal(key)) {\n                    //getContext().statManager().addRateData(\"netDb.storeLocalLeaseSetAttempt\", 1, 0);\n                    // throw rather than return, so that we send the ack below (prevent easy attack)\n                    dontBlamePeer = true;\n                    throw new IllegalArgumentException(\"Peer attempted to store local leaseSet: \" +\n                                                       key.toBase64().substring(0, 4));\n                }\n                LeaseSet ls = (LeaseSet) entry;\n                //boolean oldrar = ls.getReceivedAsReply();\n                //boolean oldrap = ls.getReceivedAsPublished();\n                // If this was received as a response to a query,\n                // FloodOnlyLookupMatchJob called setReceivedAsReply(),\n                // and we are seeing this only as a duplicate,\n                // so we don't set the receivedAsPublished() flag.\n                // Otherwise, mark it as something we received unsolicited, so we'll answer queries \n                // for it.  This flag must NOT get set on entries that we \n                // receive in response to our own lookups.\n                // See ../HDLMJ for more info\n                if (!ls.getReceivedAsReply())\n                    ls.setReceivedAsPublished(true);\n                //boolean rap = ls.getReceivedAsPublished();\n                //if (_log.shouldLog(Log.INFO))\n                //    _log.info(\"oldrap? \" + oldrap + \" oldrar? \" + oldrar + \" newrap? \" + rap);\n                LeaseSet match = getContext().netDb().store(key, ls);\n                if (match == null) {\n                    wasNew = true;\n                } else if (match.getEarliestLeaseDate() < ls.getEarliestLeaseDate()) {\n                    wasNew = true;\n                    // If it is in our keyspace and we are talking to it\n\n\n                    if (match.getReceivedAsPublished())\n                        ls.setReceivedAsPublished(true);\n                } else {\n                    wasNew = false;\n                    // The FloodOnlyLookupSelector goes away after the first good reply\n                    // So on the second reply, FloodOnlyMatchJob is not called to set ReceivedAsReply.\n                    // So then we think it's an unsolicited store.\n                    // So we should skip this.\n                    // If the 2nd reply is newer than the first, ReceivedAsPublished will be set incorrectly,\n                    // that will hopefully be rare.\n                    // A more elaborate solution would be a List of recent ReceivedAsReply LeaseSets, with receive time ?\n                    // A real unsolicited store is likely to be new - hopefully...\n                    //if (!ls.getReceivedAsReply())\n                    //    match.setReceivedAsPublished(true);\n                }\n            } catch (UnsupportedCryptoException uce) {\n                invalidMessage = uce.getMessage();\n                dontBlamePeer = true;\n            } catch (IllegalArgumentException iae) {\n                invalidMessage = iae.getMessage();\n            }\n        } else if (entry.getType() == DatabaseEntry.KEY_TYPE_ROUTERINFO) {\n            RouterInfo ri = (RouterInfo) entry;\n            getContext().statManager().addRateData(\"netDb.storeRouterInfoHandled\", 1);\n            if (_log.shouldLog(Log.INFO))\n                _log.info(\"Handling dbStore of router \" + key + \" with publishDate of \" \n                          + new Date(ri.getPublished()));\n            try {\n                // Never store our RouterInfo received from somebody else.\n                // This generally happens from a FloodfillVerifyStoreJob.\n                // If it is valid, it shouldn't be newer than what we have - unless\n                // somebody has our keys... \n                if (getContext().routerHash().equals(key)) {\n                    //getContext().statManager().addRateData(\"netDb.storeLocalRouterInfoAttempt\", 1, 0);\n                    // This is initiated by PeerTestJob from another peer\n                    // throw rather than return, so that we send the ack below (prevent easy attack)\n                    dontBlamePeer = true;\n                    throw new IllegalArgumentException(\"Peer attempted to store our RouterInfo\");\n                }\n                getContext().profileManager().heardAbout(key);\n                prevNetDb = getContext().netDb().store(key, ri);\n                wasNew = ((null == prevNetDb) || (prevNetDb.getPublished() < ri.getPublished()));\n                // Check new routerinfo address against blocklist\n                if (wasNew) {\n                    if (prevNetDb == null) {\n                        if ((!getContext().banlist().isBanlistedForever(key)) &&\n                            getContext().blocklist().isBlocklisted(key) &&\n                            _log.shouldLog(Log.WARN))\n                                _log.warn(\"Blocklisting new peer \" + key + ' ' + ri);\n                    } else {\n                        Collection<RouterAddress> oldAddr = prevNetDb.getAddresses();\n                        Collection<RouterAddress> newAddr = ri.getAddresses();\n                        if ((!newAddr.equals(oldAddr)) &&\n                            (!getContext().banlist().isBanlistedForever(key)) &&\n                            getContext().blocklist().isBlocklisted(key) &&\n                            _log.shouldLog(Log.WARN))\n                                _log.warn(\"New address received, Blocklisting old peer \" + key + ' ' + ri);\n                    }\n                }\n            } catch (UnsupportedCryptoException uce) {\n                invalidMessage = uce.getMessage();\n                dontBlamePeer = true;\n            } catch (IllegalArgumentException iae) {\n                invalidMessage = iae.getMessage();\n            }\n        } else {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"Invalid DatabaseStoreMessage data type - \" + entry.getType() \n                           + \": \" + _message);\n            // don't ack or flood\n            return;\n        }\n        \n        long recvEnd = System.currentTimeMillis();\n        getContext().statManager().addRateData(\"netDb.storeRecvTime\", recvEnd-recvBegin);\n        \n        // ack even if invalid\n        // in particular, ack our own RI (from PeerTestJob)\n        // TODO any cases where we shouldn't?\n        if (_message.getReplyToken() > 0)\n            sendAck(key);\n        long ackEnd = System.currentTimeMillis();\n        \n        if (_from != null)\n            _fromHash = _from.getHash();\n        if (_fromHash != null) {\n            if (invalidMessage == null || dontBlamePeer) {\n                getContext().profileManager().dbStoreReceived(_fromHash, wasNew);\n                getContext().statManager().addRateData(\"netDb.storeHandled\", ackEnd-recvEnd);\n            } else {\n                // Should we record in the profile?\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Peer \" + _fromHash.toBase64() + \" sent bad data: \" + invalidMessage);\n            }\n        } else if (invalidMessage != null && !dontBlamePeer) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Unknown peer sent bad data: \" + invalidMessage);\n        }\n\n        // flood it\n        if (invalidMessage == null &&\n            getContext().netDb().floodfillEnabled() &&\n            _message.getReplyToken() > 0) {\n            if (wasNew) {\n                // DOS prevention\n                // Note this does not throttle the ack above\n                if (_facade.shouldThrottleFlood(key)) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"Too many recent stores, not flooding key: \" + key);\n                    getContext().statManager().addRateData(\"netDb.floodThrottled\", 1);\n                    return;\n                }\n                long floodBegin = System.currentTimeMillis();\n                _facade.flood(_message.getEntry());\n                // ERR: see comment in HandleDatabaseLookupMessageJob regarding hidden mode\n                //else if (!_message.getRouterInfo().isHidden())\n                long floodEnd = System.currentTimeMillis();\n                getContext().statManager().addRateData(\"netDb.storeFloodNew\", floodEnd-floodBegin, 60*1000);\n            } else {\n                // don't flood it *again*\n                getContext().statManager().addRateData(\"netDb.storeFloodOld\", 1);\n            }\n        }\n    }","commit_id":"93c7860d2be3038c44d9343e749322b644c1281c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void sendAck() {\n        DeliveryStatusMessage msg = new DeliveryStatusMessage(getContext());\n        msg.setMessageId(_message.getReplyToken());\n        // Randomize for a little protection against clock-skew fingerprinting.\n        // But the \"arrival\" isn't used for anything, right?\n        // TODO just set to 0?\n        // TODO we have no session to garlic wrap this with, needs new message\n        msg.setArrival(getContext().clock().now() - getContext().random().nextInt(3*1000));\n        /*\n        if (FloodfillNetworkDatabaseFacade.floodfillEnabled(getContext())) {\n            // no need to do anything but send it where they ask\n            TunnelGatewayMessage tgm = new TunnelGatewayMessage(getContext());\n            tgm.setMessage(msg);\n            tgm.setTunnelId(_message.getReplyTunnel());\n            tgm.setMessageExpiration(msg.getMessageExpiration());\n            \n            getContext().jobQueue().addJob(new SendMessageDirectJob(getContext(), tgm, _message.getReplyGateway(), 10*1000, 200));\n        } else {\n         */\n            TunnelInfo outTunnel = selectOutboundTunnel();\n            if (outTunnel == null) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"No outbound tunnel could be found\");\n                return;\n            } else {\n                getContext().tunnelDispatcher().dispatchOutbound(msg, outTunnel.getSendTunnelId(0),\n                                                                 _message.getReplyTunnel(), _message.getReplyGateway());\n            }\n        //}\n    }","id":93370,"modified_method":"private void sendAck(Hash storedKey) {\n        DeliveryStatusMessage msg = new DeliveryStatusMessage(getContext());\n        msg.setMessageId(_message.getReplyToken());\n        // Randomize for a little protection against clock-skew fingerprinting.\n        // But the \"arrival\" isn't used for anything, right?\n        // TODO just set to 0?\n        // TODO we have no session to garlic wrap this with, needs new message\n        msg.setArrival(getContext().clock().now() - getContext().random().nextInt(3*1000));\n        // may be null\n        TunnelId replyTunnel = _message.getReplyTunnel();\n        // A store of our own RI, only if we are not FF\n        DatabaseStoreMessage msg2;\n        if (getContext().netDb().floodfillEnabled() ||\n            storedKey.equals(getContext().routerHash())) {\n            // don't send our RI if the store was our RI (from PeerTestJob)\n            msg2 = null;\n        } else {\n            // we aren't ff, send a go-away message\n            msg2 = new DatabaseStoreMessage(getContext());\n            RouterInfo me = getContext().router().getRouterInfo();\n            msg2.setEntry(me);\n            if (_log.shouldWarn())\n                _log.warn(\"Got a store w/ reply token, but we aren't ff: from: \" + _from +\n                          \" fromHash: \" + _fromHash + \" msg: \" + _message, new Exception());\n        }\n        Hash toPeer = _message.getReplyGateway();\n        boolean toUs = getContext().routerHash().equals(toPeer);\n        // to reduce connection congestion, send directly if connected already,\n        // else through an exploratory tunnel.\n        if (toUs && replyTunnel != null) {\n            // if we are the gateway, act as if we received it\n            TunnelGatewayMessage tgm = new TunnelGatewayMessage(getContext());\n            tgm.setMessage(msg);\n            tgm.setTunnelId(replyTunnel);\n            tgm.setMessageExpiration(msg.getMessageExpiration());\n            getContext().tunnelDispatcher().dispatch(tgm);\n            if (msg2 != null) {\n                TunnelGatewayMessage tgm2 = new TunnelGatewayMessage(getContext());\n                tgm2.setMessage(msg2);\n                tgm2.setTunnelId(replyTunnel);\n                tgm2.setMessageExpiration(msg.getMessageExpiration());\n                getContext().tunnelDispatcher().dispatch(tgm2);\n            }\n        } else if (toUs || getContext().commSystem().isEstablished(toPeer)) {\n            Job send = new SendMessageDirectJob(getContext(), msg, toPeer, REPLY_TIMEOUT, MESSAGE_PRIORITY);\n            send.runJob();\n            if (msg2 != null) {\n                Job send2 = new SendMessageDirectJob(getContext(), msg2, toPeer, REPLY_TIMEOUT, MESSAGE_PRIORITY);\n                send2.runJob();\n            }\n        } else {\n            // pick tunnel with endpoint closest to toPeer\n            TunnelInfo outTunnel = getContext().tunnelManager().selectOutboundExploratoryTunnel(toPeer);\n            if (outTunnel == null) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"No outbound tunnel could be found\");\n                return;\n            }\n            getContext().tunnelDispatcher().dispatchOutbound(msg, outTunnel.getSendTunnelId(0),\n                                                             replyTunnel, toPeer);\n            if (msg2 != null)\n                getContext().tunnelDispatcher().dispatchOutbound(msg2, outTunnel.getSendTunnelId(0),\n                                                                 replyTunnel, toPeer);\n        }\n    }","commit_id":"93c7860d2be3038c44d9343e749322b644c1281c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public HandleFloodfillDatabaseStoreMessageJob(RouterContext ctx, DatabaseStoreMessage receivedMessage, RouterIdentity from, Hash fromHash, FloodfillNetworkDatabaseFacade facade) {\n        super(ctx);\n        _log = ctx.logManager().getLog(getClass());\n        _message = receivedMessage;\n        _from = from;\n        _fromHash = fromHash;\n        _facade = facade;\n    }","id":93371,"modified_method":"/**\n     * @param receivedMessage must never have reply token set if it came down a tunnel\n     */\n    public HandleFloodfillDatabaseStoreMessageJob(RouterContext ctx, DatabaseStoreMessage receivedMessage,\n                                                  RouterIdentity from, Hash fromHash,\n                                                  FloodfillNetworkDatabaseFacade facade) {\n        super(ctx);\n        _log = ctx.logManager().getLog(getClass());\n        _message = receivedMessage;\n        _from = from;\n        _fromHash = fromHash;\n        _facade = facade;\n    }","commit_id":"93c7860d2be3038c44d9343e749322b644c1281c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void distribute(I2NPMessage msg, Hash target, TunnelId tunnel) {\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"IBMD for \" + _client + \" to \" + target + \" / \" + tunnel + \" : \" + msg);\n\n        // allow messages on client tunnels even after client disconnection, as it may\n        // include e.g. test messages, etc.  DataMessages will be dropped anyway\n        /*\n        if ( (_client != null) && (!_context.clientManager().isLocal(_client)) ) {\n            if (_log.shouldLog(Log.INFO))\n                _log.info(\"Not distributing a message, as it came down a client's tunnel (\" \n                          + _client.toBase64() + \") after the client disconnected: \" + msg);\n            return;\n        }\n        */\n        \n        int type = msg.getType();\n\n        // if the message came down a client tunnel:\n        if (_client != null) {\n            switch (type) {\n                 case DatabaseSearchReplyMessage.MESSAGE_TYPE:\n                     // FVSJ or client lookups could also result in a DSRM.\n                     // Since there's some code that replies directly to this to gather new ff RouterInfos,\n                     // sanitize it\n\n                     // TODO: Strip in IterativeLookupJob etc. instead, depending on\n                     // LS or RI and client or expl., so that we can safely follow references\n                     // in a reply to a LS lookup over client tunnels.\n                     // ILJ would also have to follow references via client tunnels\n                  /****\n                     DatabaseSearchReplyMessage orig = (DatabaseSearchReplyMessage) msg;\n                     if (orig.getNumReplies() > 0) {\n                         if (_log.shouldLog(Log.INFO))\n                             _log.info(\"Removing replies from a DSRM down a tunnel for \" + _client + \": \" + msg);\n                         DatabaseSearchReplyMessage newMsg = new DatabaseSearchReplyMessage(_context);\n                         newMsg.setFromHash(orig.getFromHash());\n                         newMsg.setSearchKey(orig.getSearchKey());\n                         msg = newMsg;\n                     }\n                   ****/\n                     break;\n\n                case DatabaseStoreMessage.MESSAGE_TYPE:\n                    DatabaseStoreMessage dsm = (DatabaseStoreMessage) msg;\n                    if (dsm.getEntry().getType() == DatabaseEntry.KEY_TYPE_ROUTERINFO) {\n                        // FVSJ may result in an unsolicited RI store if the peer went non-ff.\n                        // We handle this safely, so we don't ask him again.\n                        // Todo: if peer was ff and RI is not ff, queue for exploration in netdb (but that isn't part of the facade now)\n                        if (_log.shouldLog(Log.WARN))\n                            _log.warn(\"Dropping DSM down a tunnel for \" + _client + \": \" + msg);\n                        // Handle safely by just updating the caps table, after doing basic validation\n                        Hash key = dsm.getKey();\n                        if (_context.routerHash().equals(key))\n                            return;\n                        RouterInfo ri = (RouterInfo) dsm.getEntry();\n                        if (!key.equals(ri.getIdentity().getHash()))\n                            return;\n                        if (!ri.isValid())\n                            return;\n                        RouterInfo oldri = _context.netDb().lookupRouterInfoLocally(key);\n                        // only update if RI is newer and non-ff\n                        if (oldri != null && oldri.getPublished() < ri.getPublished() &&\n                            !FloodfillNetworkDatabaseFacade.isFloodfill(ri)) {\n                            if (_log.shouldLog(Log.WARN))\n                                _log.warn(\"Updating caps for RI \" + key + \" from \\\"\" +\n                                          oldri.getCapabilities() + \"\\\" to \\\"\" + ri.getCapabilities() + '\"');\n                            _context.peerManager().setCapabilities(key, ri.getCapabilities());\n                        }\n                        return;\n                    } else if (dsm.getReplyToken() != 0) {\n                        if (_log.shouldLog(Log.WARN))\n                            _log.warn(\"Dropping LS DSM w/ reply token down a tunnel for \" + _client + \": \" + msg);\n                        return;\n                    } else {\n                        // allow DSM of our own key (used by FloodfillVerifyStoreJob)\n                        // or other keys (used by IterativeSearchJob)\n                        // as long as there's no reply token (we will never set a reply token but an attacker might)\n                        ((LeaseSet)dsm.getEntry()).setReceivedAsReply();\n                    }\n                    break;\n\n                case DeliveryStatusMessage.MESSAGE_TYPE:\n                case GarlicMessage.MESSAGE_TYPE:\n                case TunnelBuildReplyMessage.MESSAGE_TYPE:\n                case VariableTunnelBuildReplyMessage.MESSAGE_TYPE:\n                    // these are safe, handled below\n                    break;\n\n                default:\n                    // drop it, since we should only get the above message types down\n                    // client tunnels\n                    _context.statManager().addRateData(\"tunnel.dropDangerousClientTunnelMessage\", 1, type);\n                    _log.error(\"Dropped dangerous message down a tunnel for \" + _client + \": \" + msg, new Exception(\"cause\"));\n                    return;\n\n            } // switch\n        } // client != null\n\n        if ( (target == null) || ( (tunnel == null) && (_context.routerHash().equals(target) ) ) ) {\n            // targetting us either implicitly (no target) or explicitly (no tunnel)\n            // make sure we don't honor any remote requests directly (garlic instructions, etc)\n            if (type == GarlicMessage.MESSAGE_TYPE) {\n                // in case we're looking for replies to a garlic message (cough load tests cough)\n                _context.inNetMessagePool().handleReplies(msg);\n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(\"received garlic message in the tunnel, parse it out\");\n                _receiver.receive((GarlicMessage)msg);\n            } else {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(\"distributing inbound tunnel message into our inNetMessagePool: \" + msg);\n                _context.inNetMessagePool().add(msg, null, null);\n            }\n/****** latency measuring attack?\n        } else if (_context.routerHash().equals(target)) {\n            // the want to send it to a tunnel, except we are also that tunnel's gateway\n            // dispatch it directly\n            if (_log.shouldLog(Log.INFO))\n                _log.info(\"distributing inbound tunnel message back out, except we are the gateway\");\n            TunnelGatewayMessage gw = new TunnelGatewayMessage(_context);\n            gw.setMessage(msg);\n            gw.setTunnelId(tunnel);\n            gw.setMessageExpiration(_context.clock().now()+10*1000);\n            gw.setUniqueId(_context.random().nextLong(I2NPMessage.MAX_ID_VALUE));\n            _context.tunnelDispatcher().dispatch(gw);\n******/\n        } else {\n            // ok, they want us to send it remotely, but that'd bust our anonymity,\n            // so we send it out a tunnel first\n            // TODO use the OCMOSJ cache to pick OB tunnel we are already using?\n            TunnelInfo out = _context.tunnelManager().selectOutboundTunnel(_client, target);\n            if (out == null) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"no outbound tunnel to send the client message for \" + _client + \": \" + msg);\n                return;\n            }\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(\"distributing IB tunnel msg type \" + type + \" back out \" + out\n                          + \" targetting \" + target);\n            TunnelId outId = out.getSendTunnelId(0);\n            if (outId == null) {\n                if (_log.shouldLog(Log.ERROR))\n                    _log.error(\"strange? outbound tunnel has no outboundId? \" + out \n                               + \" failing to distribute \" + msg);\n                return;\n            }\n            long exp = _context.clock().now() + 20*1000;\n            if (msg.getMessageExpiration() < exp)\n                msg.setMessageExpiration(exp);\n            _context.tunnelDispatcher().dispatchOutbound(msg, outId, tunnel, target);\n        }\n    }","id":93372,"modified_method":"public void distribute(I2NPMessage msg, Hash target, TunnelId tunnel) {\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"IBMD for \" + _client + \" to \" + target + \" / \" + tunnel + \" : \" + msg);\n\n        // allow messages on client tunnels even after client disconnection, as it may\n        // include e.g. test messages, etc.  DataMessages will be dropped anyway\n        /*\n        if ( (_client != null) && (!_context.clientManager().isLocal(_client)) ) {\n            if (_log.shouldLog(Log.INFO))\n                _log.info(\"Not distributing a message, as it came down a client's tunnel (\" \n                          + _client.toBase64() + \") after the client disconnected: \" + msg);\n            return;\n        }\n        */\n        \n        int type = msg.getType();\n\n        // if the message came down a client tunnel:\n        if (_client != null) {\n            switch (type) {\n                 case DatabaseSearchReplyMessage.MESSAGE_TYPE:\n                     // FVSJ or client lookups could also result in a DSRM.\n                     // Since there's some code that replies directly to this to gather new ff RouterInfos,\n                     // sanitize it\n\n                     // TODO: Strip in IterativeLookupJob etc. instead, depending on\n                     // LS or RI and client or expl., so that we can safely follow references\n                     // in a reply to a LS lookup over client tunnels.\n                     // ILJ would also have to follow references via client tunnels\n                  /****\n                     DatabaseSearchReplyMessage orig = (DatabaseSearchReplyMessage) msg;\n                     if (orig.getNumReplies() > 0) {\n                         if (_log.shouldLog(Log.INFO))\n                             _log.info(\"Removing replies from a DSRM down a tunnel for \" + _client + \": \" + msg);\n                         DatabaseSearchReplyMessage newMsg = new DatabaseSearchReplyMessage(_context);\n                         newMsg.setFromHash(orig.getFromHash());\n                         newMsg.setSearchKey(orig.getSearchKey());\n                         msg = newMsg;\n                     }\n                   ****/\n                     break;\n\n                case DatabaseStoreMessage.MESSAGE_TYPE:\n                    DatabaseStoreMessage dsm = (DatabaseStoreMessage) msg;\n                    if (dsm.getEntry().getType() == DatabaseEntry.KEY_TYPE_ROUTERINFO) {\n                        // FVSJ may result in an unsolicited RI store if the peer went non-ff.\n                        // We handle this safely, so we don't ask him again.\n                        // Todo: if peer was ff and RI is not ff, queue for exploration in netdb (but that isn't part of the facade now)\n                        if (_log.shouldLog(Log.WARN))\n                            _log.warn(\"Dropping DSM down a tunnel for \" + _client + \": \" + msg);\n                        // Handle safely by just updating the caps table, after doing basic validation\n                        Hash key = dsm.getKey();\n                        if (_context.routerHash().equals(key))\n                            return;\n                        RouterInfo ri = (RouterInfo) dsm.getEntry();\n                        if (!key.equals(ri.getIdentity().getHash()))\n                            return;\n                        if (!ri.isValid())\n                            return;\n                        RouterInfo oldri = _context.netDb().lookupRouterInfoLocally(key);\n                        // only update if RI is newer and non-ff\n                        if (oldri != null && oldri.getPublished() < ri.getPublished() &&\n                            !FloodfillNetworkDatabaseFacade.isFloodfill(ri)) {\n                            if (_log.shouldLog(Log.WARN))\n                                _log.warn(\"Updating caps for RI \" + key + \" from \\\"\" +\n                                          oldri.getCapabilities() + \"\\\" to \\\"\" + ri.getCapabilities() + '\"');\n                            _context.peerManager().setCapabilities(key, ri.getCapabilities());\n                        }\n                        return;\n                    } else if (dsm.getReplyToken() != 0) {\n                        _context.statManager().addRateData(\"tunnel.dropDangerousClientTunnelMessage\", 1, type);\n                        _log.error(\"Dropping LS DSM w/ reply token down a tunnel for \" + _client + \": \" + msg);\n                        return;\n                    } else {\n                        // allow DSM of our own key (used by FloodfillVerifyStoreJob)\n                        // or other keys (used by IterativeSearchJob)\n                        // as long as there's no reply token (we will never set a reply token but an attacker might)\n                        ((LeaseSet)dsm.getEntry()).setReceivedAsReply();\n                    }\n                    break;\n\n                case DeliveryStatusMessage.MESSAGE_TYPE:\n                case GarlicMessage.MESSAGE_TYPE:\n                case TunnelBuildReplyMessage.MESSAGE_TYPE:\n                case VariableTunnelBuildReplyMessage.MESSAGE_TYPE:\n                    // these are safe, handled below\n                    break;\n\n                default:\n                    // drop it, since we should only get the above message types down\n                    // client tunnels\n                    _context.statManager().addRateData(\"tunnel.dropDangerousClientTunnelMessage\", 1, type);\n                    _log.error(\"Dropped dangerous message down a tunnel for \" + _client + \": \" + msg, new Exception(\"cause\"));\n                    return;\n\n            } // switch\n        } else {\n            // expl. tunnel\n            switch (type) {\n                case DatabaseStoreMessage.MESSAGE_TYPE:\n                    DatabaseStoreMessage dsm = (DatabaseStoreMessage) msg;\n                    if (dsm.getReplyToken() != 0) {\n                        _context.statManager().addRateData(\"tunnel.dropDangerousExplTunnelMessage\", 1, type);\n                        _log.error(\"Dropping DSM w/ reply token down a expl. tunnel: \" + msg);\n                        return;\n                    }\n                    if (dsm.getEntry().getType() == DatabaseEntry.KEY_TYPE_LEASESET)\n                        ((LeaseSet)dsm.getEntry()).setReceivedAsReply();\n                    break;\n\n                case DatabaseSearchReplyMessage.MESSAGE_TYPE:\n                case DeliveryStatusMessage.MESSAGE_TYPE:\n                case GarlicMessage.MESSAGE_TYPE:\n                case TunnelBuildReplyMessage.MESSAGE_TYPE:\n                case VariableTunnelBuildReplyMessage.MESSAGE_TYPE:\n                    // these are safe, handled below\n                    break;\n\n                default:\n                    _context.statManager().addRateData(\"tunnel.dropDangerousExplTunnelMessage\", 1, type);\n                    _log.error(\"Dropped dangerous message down expl tunnel: \" + msg, new Exception(\"cause\"));\n                    return;\n            } // switch\n        } // client != null\n\n        if ( (target == null) || ( (tunnel == null) && (_context.routerHash().equals(target) ) ) ) {\n            // targetting us either implicitly (no target) or explicitly (no tunnel)\n            // make sure we don't honor any remote requests directly (garlic instructions, etc)\n            if (type == GarlicMessage.MESSAGE_TYPE) {\n                // in case we're looking for replies to a garlic message (cough load tests cough)\n                _context.inNetMessagePool().handleReplies(msg);\n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(\"received garlic message in the tunnel, parse it out\");\n                _receiver.receive((GarlicMessage)msg);\n            } else {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(\"distributing inbound tunnel message into our inNetMessagePool: \" + msg);\n                _context.inNetMessagePool().add(msg, null, null);\n            }\n/****** latency measuring attack?\n        } else if (_context.routerHash().equals(target)) {\n            // the want to send it to a tunnel, except we are also that tunnel's gateway\n            // dispatch it directly\n            if (_log.shouldLog(Log.INFO))\n                _log.info(\"distributing inbound tunnel message back out, except we are the gateway\");\n            TunnelGatewayMessage gw = new TunnelGatewayMessage(_context);\n            gw.setMessage(msg);\n            gw.setTunnelId(tunnel);\n            gw.setMessageExpiration(_context.clock().now()+10*1000);\n            gw.setUniqueId(_context.random().nextLong(I2NPMessage.MAX_ID_VALUE));\n            _context.tunnelDispatcher().dispatch(gw);\n******/\n        } else {\n            // ok, they want us to send it remotely, but that'd bust our anonymity,\n            // so we send it out a tunnel first\n            // TODO use the OCMOSJ cache to pick OB tunnel we are already using?\n            TunnelInfo out = _context.tunnelManager().selectOutboundTunnel(_client, target);\n            if (out == null) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"no outbound tunnel to send the client message for \" + _client + \": \" + msg);\n                return;\n            }\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(\"distributing IB tunnel msg type \" + type + \" back out \" + out\n                          + \" targetting \" + target);\n            TunnelId outId = out.getSendTunnelId(0);\n            if (outId == null) {\n                if (_log.shouldLog(Log.ERROR))\n                    _log.error(\"strange? outbound tunnel has no outboundId? \" + out \n                               + \" failing to distribute \" + msg);\n                return;\n            }\n            long exp = _context.clock().now() + 20*1000;\n            if (msg.getMessageExpiration() < exp)\n                msg.setMessageExpiration(exp);\n            _context.tunnelDispatcher().dispatchOutbound(msg, outId, tunnel, target);\n        }\n    }","commit_id":"93c7860d2be3038c44d9343e749322b644c1281c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Fire off the necessary jobs and messages to test the given peer\n     *\n     */\n    private void testPeer(RouterInfo peer) {\n        TunnelInfo inTunnel = getInboundTunnelId(); \n        if (inTunnel == null) {\n            _log.warn(\"No tunnels to get peer test replies through!\");\n            return;\n        }\n        TunnelId inTunnelId = inTunnel.getReceiveTunnelId(0);\n\t\n        RouterInfo inGateway = getContext().netDb().lookupRouterInfoLocally(inTunnel.getPeer(0));\n        if (inGateway == null) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"We can't find the gateway to our inbound tunnel?! Impossible?\");\n            return;\n        }\n\t\n        int timeoutMs = getTestTimeout();\n        long expiration = getContext().clock().now() + timeoutMs;\n\n        long nonce = getContext().random().nextLong(I2NPMessage.MAX_ID_VALUE);\n        DatabaseStoreMessage msg = buildMessage(peer, inTunnelId, inGateway.getIdentity().getHash(), nonce, expiration);\n\t\n        TunnelInfo outTunnel = getOutboundTunnelId();\n        if (outTunnel == null) {\n            _log.warn(\"No tunnels to send search out through! Something is wrong...\");\n            return;\n        }\n        \n        TunnelId outTunnelId = outTunnel.getSendTunnelId(0);\n\t\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(getJobId() + \": Sending peer test to \" + peer.getIdentity().getHash().toBase64() \n                       + \" out \" + outTunnel + \" w/ replies through \" + inTunnel);\n\n        ReplySelector sel = new ReplySelector(peer.getIdentity().getHash(), nonce, expiration);\n        PeerReplyFoundJob reply = new PeerReplyFoundJob(getContext(), peer, inTunnel, outTunnel);\n        PeerReplyTimeoutJob timeoutJob = new PeerReplyTimeoutJob(getContext(), peer, inTunnel, outTunnel, sel);\n        \n        getContext().messageRegistry().registerPending(sel, reply, timeoutJob);\n        getContext().tunnelDispatcher().dispatchOutbound(msg, outTunnelId, null, peer.getIdentity().getHash());\n    }","id":93373,"modified_method":"/**\n     * Fire off the necessary jobs and messages to test the given peer\n     * The message is a store of the peer's RI to itself,\n     * with a reply token.\n     */\n    private void testPeer(RouterInfo peer) {\n        TunnelInfo inTunnel = getInboundTunnelId(); \n        if (inTunnel == null) {\n            _log.warn(\"No tunnels to get peer test replies through!\");\n            return;\n        }\n        TunnelId inTunnelId = inTunnel.getReceiveTunnelId(0);\n\t\n        RouterInfo inGateway = getContext().netDb().lookupRouterInfoLocally(inTunnel.getPeer(0));\n        if (inGateway == null) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"We can't find the gateway to our inbound tunnel?! Impossible?\");\n            return;\n        }\n\t\n        int timeoutMs = getTestTimeout();\n        long expiration = getContext().clock().now() + timeoutMs;\n\n        long nonce = 1 + getContext().random().nextLong(I2NPMessage.MAX_ID_VALUE - 1);\n        DatabaseStoreMessage msg = buildMessage(peer, inTunnelId, inGateway.getIdentity().getHash(), nonce, expiration);\n\t\n        TunnelInfo outTunnel = getOutboundTunnelId();\n        if (outTunnel == null) {\n            _log.warn(\"No tunnels to send search out through! Something is wrong...\");\n            return;\n        }\n        \n        TunnelId outTunnelId = outTunnel.getSendTunnelId(0);\n\t\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(getJobId() + \": Sending peer test to \" + peer.getIdentity().getHash().toBase64() \n                       + \" out \" + outTunnel + \" w/ replies through \" + inTunnel);\n\n        ReplySelector sel = new ReplySelector(peer.getIdentity().getHash(), nonce, expiration);\n        PeerReplyFoundJob reply = new PeerReplyFoundJob(getContext(), peer, inTunnel, outTunnel);\n        PeerReplyTimeoutJob timeoutJob = new PeerReplyTimeoutJob(getContext(), peer, inTunnel, outTunnel, sel);\n        \n        getContext().messageRegistry().registerPending(sel, reply, timeoutJob);\n        getContext().tunnelDispatcher().dispatchOutbound(msg, outTunnelId, null, peer.getIdentity().getHash());\n    }","commit_id":"93c7860d2be3038c44d9343e749322b644c1281c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public SendMessageDirectJob(RouterContext ctx, I2NPMessage message, Hash toPeer, Job onSend, ReplyJob onSuccess, Job onFail, MessageSelector selector, int timeoutMs, int priority) {\n        super(ctx);\n        _log = getContext().logManager().getLog(SendMessageDirectJob.class);\n        _message = message;\n        _targetHash = toPeer;\n        if (timeoutMs < 10*1000) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Very little time given [\" + timeoutMs + \"], resetting to 5s\", new Exception(\"stingy caller!\"));\n            _expiration = ctx.clock().now() + 10*1000;\n        } else {\n            _expiration = timeoutMs + ctx.clock().now();\n        }\n        _priority = priority;\n        _onSend = onSend;\n        _onSuccess = onSuccess;\n        _onFail = onFail;\n        _selector = selector;\n        if (message == null)\n            throw new IllegalArgumentException(\"Attempt to send a null message\");\n        if (_targetHash == null)\n            throw new IllegalArgumentException(\"Attempt to send a message to a null peer\");\n    }","id":93374,"modified_method":"/**\n     * @param toPeer may be ourselves\n     * @param onSend may be null\n     * @param onSuccess may be null\n     * @param onFail may be null\n     * @param selector be null\n     */\n    public SendMessageDirectJob(RouterContext ctx, I2NPMessage message, Hash toPeer, Job onSend, ReplyJob onSuccess,\n                                Job onFail, MessageSelector selector, int timeoutMs, int priority) {\n        super(ctx);\n        _log = getContext().logManager().getLog(SendMessageDirectJob.class);\n        _message = message;\n        _targetHash = toPeer;\n        if (timeoutMs < 10*1000) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Very little time given [\" + timeoutMs + \"], resetting to 5s\", new Exception(\"stingy caller!\"));\n            _expiration = ctx.clock().now() + 10*1000;\n        } else {\n            _expiration = timeoutMs + ctx.clock().now();\n        }\n        _priority = priority;\n        _onSend = onSend;\n        _onSuccess = onSuccess;\n        _onFail = onFail;\n        _selector = selector;\n        if (message == null)\n            throw new IllegalArgumentException(\"Attempt to send a null message\");\n        if (_targetHash == null)\n            throw new IllegalArgumentException(\"Attempt to send a message to a null peer\");\n    }","commit_id":"93c7860d2be3038c44d9343e749322b644c1281c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public SendMessageDirectJob(RouterContext ctx, I2NPMessage message, Hash toPeer, int timeoutMs, int priority) {\n        this(ctx, message, toPeer, null, null, null, null, timeoutMs, priority);\n    }","id":93375,"modified_method":"/**\n     * @param toPeer may be ourselves\n     */\n    public SendMessageDirectJob(RouterContext ctx, I2NPMessage message, Hash toPeer, int timeoutMs, int priority) {\n        this(ctx, message, toPeer, null, null, null, null, timeoutMs, priority);\n    }","commit_id":"93c7860d2be3038c44d9343e749322b644c1281c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public SendMessageDirectJob(RouterContext ctx, I2NPMessage message, Hash toPeer, ReplyJob onSuccess, Job onFail, MessageSelector selector, int timeoutMs, int priority) {\n        this(ctx, message, toPeer, null, onSuccess, onFail, selector, timeoutMs, priority);\n    }","id":93376,"modified_method":"/**\n     * @param toPeer may be ourselves\n     * @param onSuccess may be null\n     * @param onFail may be null\n     * @param selector be null\n     */\n    public SendMessageDirectJob(RouterContext ctx, I2NPMessage message, Hash toPeer, ReplyJob onSuccess,\n                                Job onFail, MessageSelector selector, int timeoutMs, int priority) {\n        this(ctx, message, toPeer, null, onSuccess, onFail, selector, timeoutMs, priority);\n    }","commit_id":"93c7860d2be3038c44d9343e749322b644c1281c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** Creates a new instance of TunnelDispatcher */\n    public TunnelDispatcher(RouterContext ctx) {\n        _context = ctx;\n        _log = ctx.logManager().getLog(TunnelDispatcher.class);\n        _outboundGateways = new ConcurrentHashMap<TunnelId, TunnelGateway>();\n        _outboundEndpoints = new ConcurrentHashMap<TunnelId, OutboundTunnelEndpoint>();\n        _participants = new ConcurrentHashMap<TunnelId, TunnelParticipant>();\n        _inboundGateways = new ConcurrentHashMap<TunnelId, TunnelGateway>();\n        _participatingConfig = new ConcurrentHashMap<TunnelId, HopConfig>();\n        _pumper = new TunnelGatewayPumper(ctx);\n        _leaveJob = new LeaveTunnel(ctx);\n        ctx.statManager().createRequiredRateStat(\"tunnel.participatingTunnels\", \n                                         \"Tunnels routed for others\", \"Tunnels\", \n                                         new long[] { 60*1000, 10*60*1000l, 60*60*1000l, 3*60*60*1000l, 24*60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.dispatchOutboundPeer\", \n                                         \"How many messages we send out a tunnel targetting a peer?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.dispatchOutboundTunnel\", \n                                         \"How many messages we send out a tunnel targetting a tunnel?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.dispatchInbound\", \n                                         \"How many messages we send through our tunnel gateway?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.dispatchParticipant\", \n                                         \"How many messages we send through a tunnel we are participating in?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.dispatchEndpoint\", \n                                         \"How many messages we receive as the outbound endpoint of a tunnel?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.joinOutboundGateway\", \n                                         \"How many tunnels we join as the outbound gateway?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.joinOutboundGatewayZeroHop\", \n                                         \"How many zero hop tunnels we join as the outbound gateway?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.joinInboundEndpoint\", \n                                         \"How many tunnels we join as the inbound endpoint?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.joinInboundEndpointZeroHop\", \n                                         \"How many zero hop tunnels we join as the inbound endpoint?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.joinParticipant\", \n                                         \"How many tunnels we join as a participant?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.joinOutboundEndpoint\", \n                                         \"How many tunnels we join as the outbound endpoint?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.joinInboundGateway\", \n                                         \"How many tunnels we join as the inbound gateway?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        //ctx.statManager().createRateStat(\"tunnel.dispatchGatewayTime\", \n        //                                 \"How long it takes to dispatch a TunnelGatewayMessage\", \"Tunnels\", \n        //                                 new long[] { 60*1000l, 60*60*1000l });\n        //ctx.statManager().createRateStat(\"tunnel.dispatchDataTime\", \n        //                                 \"How long it takes to dispatch a TunnelDataMessage\", \"Tunnels\", \n        //                                 new long[] { 60*1000l, 60*60*1000l });\n        //ctx.statManager().createRateStat(\"tunnel.dispatchOutboundTime\", \n        //                                 \"How long it takes to dispatch an outbound message\", \"Tunnels\", \n        //                                 new long[] { 60*1000l, 60*60*1000l });\n        //ctx.statManager().createRateStat(\"tunnel.dispatchOutboundZeroHopTime\", \n        //                                 \"How long it takes to dispatch an outbound message through a zero hop tunnel\", \"Tunnels\", \n        //                                 new long[] { 60*60*1000l });\n        ctx.statManager().createRequiredRateStat(\"tunnel.participatingBandwidth\", \n                                         \"Participating traffic received (Bytes/sec)\", \"Tunnels\", \n                                         new long[] { 60*1000l, 60*10*1000l });\n        ctx.statManager().createRequiredRateStat(\"tunnel.participatingBandwidthOut\", \n                                         \"Participating traffic sent (Bytes/sec)\", \"Tunnels\", \n                                         new long[] { 60*1000l, 60*10*1000l });\n        ctx.statManager().createRateStat(\"tunnel.participatingMessageDropped\", \n                                         \"Dropped for exceeding share limit\", \"Tunnels\", \n                                         new long[] { 60*1000l, 60*10*1000l });\n        ctx.statManager().createRequiredRateStat(\"tunnel.participatingMessageCount\", \n                                         \"Number of 1KB participating messages\", \"Tunnels\", \n                                         new long[] { 60*1000l, 60*10*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.ownedMessageCount\", \n                                         \"How many messages are sent through a tunnel we created (period == failures)?\", \"Tunnels\", \n                                         new long[] { 60*1000l, 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.failedCompletelyMessages\", \n                                         \"How many messages are sent through a tunnel that failed prematurely (period == failures)?\", \"Tunnels\", \n                                         new long[] { 60*1000l, 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.failedPartially\", \n                                         \"How many messages are sent through a tunnel that only failed partially (period == failures)?\", \"Tunnels\", \n                                         new long[] { 60*1000l, 10*60*1000l, 60*60*1000l });\n        // following are for BatchedPreprocessor\n        ctx.statManager().createRateStat(\"tunnel.batchMultipleCount\", \"How many messages are batched into a tunnel message\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.batchDelay\", \"How many messages were pending when the batching waited\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.batchDelaySent\", \"How many messages were flushed when the batching delay completed\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.batchCount\", \"How many groups of messages were flushed together\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.batchDelayAmount\", \"How long we should wait before flushing the batch\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.batchFlushRemaining\", \"How many messages remain after flushing\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.writeDelay\", \"How long after a message reaches the gateway is it processed (lifetime is size)\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.batchSmallFragments\", \"How many outgoing pad bytes are in small fragments?\", \n                                         \"Tunnels\", new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.batchFullFragments\", \"How many outgoing tunnel messages use the full data area?\", \n                                         \"Tunnels\", new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.batchFragmentation\", \"Avg. number of fragments per msg\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        // following is for OutboundMessageDistributor\n        ctx.statManager().createRateStat(\"tunnel.distributeLookupSuccess\", \"Was a deferred lookup successful?\", \"Tunnels\", new long[] { 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.dropAtOBEP\", \"New conn throttle\", \"Tunnels\", new long[] { 60*60*1000 });\n        // following is for OutboundReceiver\n        ctx.statManager().createRateStat(\"tunnel.outboundLookupSuccess\", \"Was a deferred lookup successful?\", \"Tunnels\", new long[] { 60*60*1000 });\n        // following is for InboundGatewayReceiver\n        ctx.statManager().createRateStat(\"tunnel.inboundLookupSuccess\", \"Was a deferred lookup successful?\", \"Tunnels\", new long[] { 60*60*1000 });\n        // following is for TunnelParticipant\n        ctx.statManager().createRateStat(\"tunnel.participantLookupSuccess\", \"Was a deferred lookup successful?\", \"Tunnels\", new long[] { 60*60*1000 });\n        // following is for BuildMessageProcessor\n        ctx.statManager().createRateStat(\"tunnel.buildRequestDup\", \"How frequently we get dup build request messages\", \"Tunnels\", new long[] { 60*60*1000 });\n        // following are for FragmentHandler\n        ctx.statManager().createRateStat(\"tunnel.smallFragments\", \"How many pad bytes are in small fragments?\", \n                                              \"Tunnels\", RATES);\n        ctx.statManager().createRateStat(\"tunnel.fullFragments\", \"How many tunnel messages use the full data area?\", \n                                              \"Tunnels\", RATES);\n        ctx.statManager().createRateStat(\"tunnel.fragmentedComplete\", \"How many fragments were in a completely received message?\", \n                                              \"Tunnels\", RATES);\n        ctx.statManager().createRequiredRateStat(\"tunnel.fragmentedDropped\", \"Number of dropped fragments\", \n                                              \"Tunnels\", RATES);\n        ctx.statManager().createRequiredRateStat(\"tunnel.corruptMessage\", \"Corrupt messages received\", \n                                              \"Tunnels\", RATES);\n        // following are for InboundMessageDistributor\n        ctx.statManager().createRateStat(\"tunnel.dropDangerousClientTunnelMessage\", \"How many tunnel messages come down a client tunnel that we shouldn't expect (lifetime is the 'I2NP type')\", \"Tunnels\", new long[] { 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.handleLoadClove\", \"When do we receive load test cloves\", \"Tunnels\", new long[] { 60*60*1000 });\n        // following is for PumpedTunnelGateway\n        ctx.statManager().createRateStat(\"tunnel.dropGatewayOverflow\", \"Dropped message at GW, queue full\", \"Tunnels\", new long[] { 60*60*1000 });\n    }","id":93377,"modified_method":"/** Creates a new instance of TunnelDispatcher */\n    public TunnelDispatcher(RouterContext ctx) {\n        _context = ctx;\n        _log = ctx.logManager().getLog(TunnelDispatcher.class);\n        _outboundGateways = new ConcurrentHashMap<TunnelId, TunnelGateway>();\n        _outboundEndpoints = new ConcurrentHashMap<TunnelId, OutboundTunnelEndpoint>();\n        _participants = new ConcurrentHashMap<TunnelId, TunnelParticipant>();\n        _inboundGateways = new ConcurrentHashMap<TunnelId, TunnelGateway>();\n        _participatingConfig = new ConcurrentHashMap<TunnelId, HopConfig>();\n        _pumper = new TunnelGatewayPumper(ctx);\n        _leaveJob = new LeaveTunnel(ctx);\n        ctx.statManager().createRequiredRateStat(\"tunnel.participatingTunnels\", \n                                         \"Tunnels routed for others\", \"Tunnels\", \n                                         new long[] { 60*1000, 10*60*1000l, 60*60*1000l, 3*60*60*1000l, 24*60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.dispatchOutboundPeer\", \n                                         \"How many messages we send out a tunnel targetting a peer?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.dispatchOutboundTunnel\", \n                                         \"How many messages we send out a tunnel targetting a tunnel?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.dispatchInbound\", \n                                         \"How many messages we send through our tunnel gateway?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.dispatchParticipant\", \n                                         \"How many messages we send through a tunnel we are participating in?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.dispatchEndpoint\", \n                                         \"How many messages we receive as the outbound endpoint of a tunnel?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.joinOutboundGateway\", \n                                         \"How many tunnels we join as the outbound gateway?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.joinOutboundGatewayZeroHop\", \n                                         \"How many zero hop tunnels we join as the outbound gateway?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.joinInboundEndpoint\", \n                                         \"How many tunnels we join as the inbound endpoint?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.joinInboundEndpointZeroHop\", \n                                         \"How many zero hop tunnels we join as the inbound endpoint?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.joinParticipant\", \n                                         \"How many tunnels we join as a participant?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.joinOutboundEndpoint\", \n                                         \"How many tunnels we join as the outbound endpoint?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.joinInboundGateway\", \n                                         \"How many tunnels we join as the inbound gateway?\", \"Tunnels\", \n                                         new long[] { 10*60*1000l, 60*60*1000l });\n        //ctx.statManager().createRateStat(\"tunnel.dispatchGatewayTime\", \n        //                                 \"How long it takes to dispatch a TunnelGatewayMessage\", \"Tunnels\", \n        //                                 new long[] { 60*1000l, 60*60*1000l });\n        //ctx.statManager().createRateStat(\"tunnel.dispatchDataTime\", \n        //                                 \"How long it takes to dispatch a TunnelDataMessage\", \"Tunnels\", \n        //                                 new long[] { 60*1000l, 60*60*1000l });\n        //ctx.statManager().createRateStat(\"tunnel.dispatchOutboundTime\", \n        //                                 \"How long it takes to dispatch an outbound message\", \"Tunnels\", \n        //                                 new long[] { 60*1000l, 60*60*1000l });\n        //ctx.statManager().createRateStat(\"tunnel.dispatchOutboundZeroHopTime\", \n        //                                 \"How long it takes to dispatch an outbound message through a zero hop tunnel\", \"Tunnels\", \n        //                                 new long[] { 60*60*1000l });\n        ctx.statManager().createRequiredRateStat(\"tunnel.participatingBandwidth\", \n                                         \"Participating traffic received (Bytes/sec)\", \"Tunnels\", \n                                         new long[] { 60*1000l, 60*10*1000l });\n        ctx.statManager().createRequiredRateStat(\"tunnel.participatingBandwidthOut\", \n                                         \"Participating traffic sent (Bytes/sec)\", \"Tunnels\", \n                                         new long[] { 60*1000l, 60*10*1000l });\n        ctx.statManager().createRateStat(\"tunnel.participatingMessageDropped\", \n                                         \"Dropped for exceeding share limit\", \"Tunnels\", \n                                         new long[] { 60*1000l, 60*10*1000l });\n        ctx.statManager().createRequiredRateStat(\"tunnel.participatingMessageCount\", \n                                         \"Number of 1KB participating messages\", \"Tunnels\", \n                                         new long[] { 60*1000l, 60*10*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.ownedMessageCount\", \n                                         \"How many messages are sent through a tunnel we created (period == failures)?\", \"Tunnels\", \n                                         new long[] { 60*1000l, 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.failedCompletelyMessages\", \n                                         \"How many messages are sent through a tunnel that failed prematurely (period == failures)?\", \"Tunnels\", \n                                         new long[] { 60*1000l, 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.failedPartially\", \n                                         \"How many messages are sent through a tunnel that only failed partially (period == failures)?\", \"Tunnels\", \n                                         new long[] { 60*1000l, 10*60*1000l, 60*60*1000l });\n        // following are for BatchedPreprocessor\n        ctx.statManager().createRateStat(\"tunnel.batchMultipleCount\", \"How many messages are batched into a tunnel message\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.batchDelay\", \"How many messages were pending when the batching waited\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.batchDelaySent\", \"How many messages were flushed when the batching delay completed\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.batchCount\", \"How many groups of messages were flushed together\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.batchDelayAmount\", \"How long we should wait before flushing the batch\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.batchFlushRemaining\", \"How many messages remain after flushing\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.writeDelay\", \"How long after a message reaches the gateway is it processed (lifetime is size)\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.batchSmallFragments\", \"How many outgoing pad bytes are in small fragments?\", \n                                         \"Tunnels\", new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.batchFullFragments\", \"How many outgoing tunnel messages use the full data area?\", \n                                         \"Tunnels\", new long[] { 10*60*1000l, 60*60*1000l });\n        ctx.statManager().createRateStat(\"tunnel.batchFragmentation\", \"Avg. number of fragments per msg\", \"Tunnels\", new long[] { 10*60*1000, 60*60*1000 });\n        // following is for OutboundMessageDistributor\n        ctx.statManager().createRateStat(\"tunnel.distributeLookupSuccess\", \"Was a deferred lookup successful?\", \"Tunnels\", new long[] { 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.dropAtOBEP\", \"New conn throttle\", \"Tunnels\", new long[] { 60*60*1000 });\n        // following is for OutboundReceiver\n        ctx.statManager().createRateStat(\"tunnel.outboundLookupSuccess\", \"Was a deferred lookup successful?\", \"Tunnels\", new long[] { 60*60*1000 });\n        // following is for InboundGatewayReceiver\n        ctx.statManager().createRateStat(\"tunnel.inboundLookupSuccess\", \"Was a deferred lookup successful?\", \"Tunnels\", new long[] { 60*60*1000 });\n        // following is for TunnelParticipant\n        ctx.statManager().createRateStat(\"tunnel.participantLookupSuccess\", \"Was a deferred lookup successful?\", \"Tunnels\", new long[] { 60*60*1000 });\n        // following is for BuildMessageProcessor\n        ctx.statManager().createRateStat(\"tunnel.buildRequestDup\", \"How frequently we get dup build request messages\", \"Tunnels\", new long[] { 60*60*1000 });\n        // following are for FragmentHandler\n        ctx.statManager().createRateStat(\"tunnel.smallFragments\", \"How many pad bytes are in small fragments?\", \n                                              \"Tunnels\", RATES);\n        ctx.statManager().createRateStat(\"tunnel.fullFragments\", \"How many tunnel messages use the full data area?\", \n                                              \"Tunnels\", RATES);\n        ctx.statManager().createRateStat(\"tunnel.fragmentedComplete\", \"How many fragments were in a completely received message?\", \n                                              \"Tunnels\", RATES);\n        ctx.statManager().createRequiredRateStat(\"tunnel.fragmentedDropped\", \"Number of dropped fragments\", \n                                              \"Tunnels\", RATES);\n        ctx.statManager().createRequiredRateStat(\"tunnel.corruptMessage\", \"Corrupt messages received\", \n                                              \"Tunnels\", RATES);\n        // following are for InboundMessageDistributor\n        ctx.statManager().createRateStat(\"tunnel.dropDangerousClientTunnelMessage\", \"(lifetime is the I2NP type)\", \"Tunnels\", new long[] { 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.dropDangerousExplTunnelMessage\", \"(lifetime is the I2NP type)\", \"Tunnels\", new long[] { 60*60*1000 });\n        ctx.statManager().createRateStat(\"tunnel.handleLoadClove\", \"When do we receive load test cloves\", \"Tunnels\", new long[] { 60*60*1000 });\n        // following is for PumpedTunnelGateway\n        ctx.statManager().createRateStat(\"tunnel.dropGatewayOverflow\", \"Dropped message at GW, queue full\", \"Tunnels\", new long[] { 60*60*1000 });\n    }","commit_id":"93c7860d2be3038c44d9343e749322b644c1281c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"ConnThrottler(int max, int totalMax, long period) {\n        _max = max;\n        _totalMax = totalMax;\n        this.counter = new ObjectCounter<Hash>();\n        _currentTotal = new AtomicInteger();\n        // shorten the initial period by a random amount,mpleScheduler.getInstance().addPeriodicEvent(new Cleaner(),\n        // to prevent correlation across destinations\n        // and identification of router startup time\n        SimpleScheduler.getInstance().addPeriodicEvent(new Cleaner(),\n                                                       RandomSource.getInstance().nextLong(period),\n                                                       period);\n    }","id":93378,"modified_method":"ConnThrottler(int max, int totalMax, long period) {\n        _max = max;\n        _totalMax = totalMax;\n        this.counter = new ObjectCounter<Hash>();\n        _currentTotal = new AtomicInteger();\n        // shorten the initial period by a random amount,mpleScheduler.getInstance().addPeriodicEvent(new Cleaner(),\n        // to prevent correlation across destinations\n        // and identification of router startup time\n        SimpleScheduler.getInstance().addPeriodicEvent(new Cleaner(),\n                                                       (period / 2) + RandomSource.getInstance().nextLong(period / 2),\n                                                       period);\n    }","commit_id":"a92913da4c253e2a14e18c4af1c920f482ddef35","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  @return reason string or null if not rejected\n     */\n    private String shouldRejectConnection(Packet syn) {\n        // unfortunately we don't have access to the router client manager here,\n        // so we can't whitelist local access\n        Destination from = syn.getOptionalFrom();\n        if (from == null)\n            return \"null\";\n        Hash h = from.calculateHash();\n\n        // As of 0.9.9, run the blacklist checks BEFORE the port counters,\n        // so blacklisted dests will not increment the counters and\n        // possibly trigger total-counter blocks for others.\n\n        // if the sig is absent or bad it will be caught later (in CPH)\n        if (_defaultOptions.isAccessListEnabled() &&\n            !_defaultOptions.getAccessList().contains(h))\n            return \"not whitelisted\";\n        if (_defaultOptions.isBlacklistEnabled() &&\n            _defaultOptions.getBlacklist().contains(h))\n            return \"blacklisted\";\n        String hashes = _context.getProperty(PROP_BLACKLIST, \"\");\n        if (!_currentBlacklist.equals(hashes)) {\n            // rebuild _globalBlacklist when property changes\n            synchronized(_globalBlacklist) {\n                if (hashes.length() > 0) {\n                    Set<Hash> newSet = new HashSet<Hash>();\n                    StringTokenizer tok = new StringTokenizer(hashes, \",; \");\n                    while (tok.hasMoreTokens()) {\n                        String hashstr = tok.nextToken();\n                        Hash hh = ConvertToHash.getHash(hashstr);\n                        if (hh != null)\n                            newSet.add(hh);\n                        else\n                            _log.error(\"Bad blacklist entry: \" + hashstr);\n                    }\n                    _globalBlacklist.addAll(newSet);\n                    _globalBlacklist.retainAll(newSet);\n                    _currentBlacklist = hashes;\n                } else {\n                    _globalBlacklist.clear();\n                    _currentBlacklist = \"\";\n                }\n            }\n        }\n        if (hashes.length() > 0 && _globalBlacklist.contains(h))\n            return \"blacklisted globally\";\n\n\n        String throttled = null;\n        // always call all 3 to increment all counters\n        if (_minuteThrottler != null && _minuteThrottler.shouldThrottle(h)) {\n            _context.statManager().addRateData(\"stream.con.throttledMinute\", 1, 0);\n            if (_defaultOptions.getMaxConnsPerMinute() <= 0)\n                throttled = \"throttled by\" +\n                        \" total limit of \" + _defaultOptions.getMaxTotalConnsPerMinute() +\n                        \" per minute\";\n            else if (_defaultOptions.getMaxTotalConnsPerMinute() <= 0)\n                throttled = \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerMinute() +\n                        \" per minute\";\n            else\n                throttled = \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerMinute() +\n                        \" or total limit of \" + _defaultOptions.getMaxTotalConnsPerMinute() +\n                        \" per minute\";\n        }\n        if (_hourThrottler != null && _hourThrottler.shouldThrottle(h)) {\n            _context.statManager().addRateData(\"stream.con.throttledHour\", 1, 0);\n            if (_defaultOptions.getMaxConnsPerHour() <= 0)\n                throttled = \"throttled by\" +\n                        \" total limit of \" + _defaultOptions.getMaxTotalConnsPerHour() +\n                        \" per hour\";\n            else if (_defaultOptions.getMaxTotalConnsPerHour() <= 0)\n                throttled = \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerHour() +\n                        \" per hour\";\n            else\n                throttled = \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerHour() +\n                        \" or total limit of \" + _defaultOptions.getMaxTotalConnsPerHour() +\n                        \" per hour\";\n        }\n        if (_dayThrottler != null && _dayThrottler.shouldThrottle(h)) {\n            _context.statManager().addRateData(\"stream.con.throttledDay\", 1, 0);\n            if (_defaultOptions.getMaxConnsPerDay() <= 0)\n                throttled = \"throttled by\" +\n                        \" total limit of \" + _defaultOptions.getMaxTotalConnsPerDay() +\n                        \" per day\";\n            else if (_defaultOptions.getMaxTotalConnsPerDay() <= 0)\n                throttled = \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerDay() +\n                        \" per day\";\n            else\n                throttled = \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerDay() +\n                        \" or total limit of \" + _defaultOptions.getMaxTotalConnsPerDay() +\n                        \" per day\";\n        }\n\n        return throttled;\n    }","id":93379,"modified_method":"/**\n     *  @return reason string or null if not rejected\n     */\n    private String shouldRejectConnection(Packet syn) {\n        // unfortunately we don't have access to the router client manager here,\n        // so we can't whitelist local access\n        Destination from = syn.getOptionalFrom();\n        if (from == null)\n            return \"null\";\n        Hash h = from.calculateHash();\n\n        // As of 0.9.9, run the blacklist checks BEFORE the port counters,\n        // so blacklisted dests will not increment the counters and\n        // possibly trigger total-counter blocks for others.\n\n        // if the sig is absent or bad it will be caught later (in CPH)\n        String hashes = _context.getProperty(PROP_BLACKLIST, \"\");\n        if (!_currentBlacklist.equals(hashes)) {\n            // rebuild _globalBlacklist when property changes\n            synchronized(_globalBlacklist) {\n                if (hashes.length() > 0) {\n                    Set<Hash> newSet = new HashSet<Hash>();\n                    StringTokenizer tok = new StringTokenizer(hashes, \",; \");\n                    while (tok.hasMoreTokens()) {\n                        String hashstr = tok.nextToken();\n                        Hash hh = ConvertToHash.getHash(hashstr);\n                        if (hh != null)\n                            newSet.add(hh);\n                        else\n                            _log.error(\"Bad blacklist entry: \" + hashstr);\n                    }\n                    _globalBlacklist.addAll(newSet);\n                    _globalBlacklist.retainAll(newSet);\n                    _currentBlacklist = hashes;\n                } else {\n                    _globalBlacklist.clear();\n                    _currentBlacklist = \"\";\n                }\n            }\n        }\n        if (hashes.length() > 0 && _globalBlacklist.contains(h))\n            return \"blacklisted globally\";\n\n        if (_defaultOptions.isAccessListEnabled() &&\n            !_defaultOptions.getAccessList().contains(h))\n            return \"not whitelisted\";\n        if (_defaultOptions.isBlacklistEnabled() &&\n            _defaultOptions.getBlacklist().contains(h))\n            return \"blacklisted\";\n\n\n        if (_dayThrottler != null && _dayThrottler.shouldThrottle(h)) {\n            _context.statManager().addRateData(\"stream.con.throttledDay\", 1, 0);\n            if (_defaultOptions.getMaxConnsPerDay() <= 0)\n                return \"throttled by\" +\n                        \" total limit of \" + _defaultOptions.getMaxTotalConnsPerDay() +\n                        \" per day\";\n            else if (_defaultOptions.getMaxTotalConnsPerDay() <= 0)\n                return \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerDay() +\n                        \" per day\";\n            else\n                return \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerDay() +\n                        \" or total limit of \" + _defaultOptions.getMaxTotalConnsPerDay() +\n                        \" per day\";\n        }\n        if (_hourThrottler != null && _hourThrottler.shouldThrottle(h)) {\n            _context.statManager().addRateData(\"stream.con.throttledHour\", 1, 0);\n            if (_defaultOptions.getMaxConnsPerHour() <= 0)\n                return \"throttled by\" +\n                        \" total limit of \" + _defaultOptions.getMaxTotalConnsPerHour() +\n                        \" per hour\";\n            else if (_defaultOptions.getMaxTotalConnsPerHour() <= 0)\n                return \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerHour() +\n                        \" per hour\";\n            else\n                return \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerHour() +\n                        \" or total limit of \" + _defaultOptions.getMaxTotalConnsPerHour() +\n                        \" per hour\";\n        }\n        if (_minuteThrottler != null && _minuteThrottler.shouldThrottle(h)) {\n            _context.statManager().addRateData(\"stream.con.throttledMinute\", 1, 0);\n            if (_defaultOptions.getMaxConnsPerMinute() <= 0)\n                return \"throttled by\" +\n                        \" total limit of \" + _defaultOptions.getMaxTotalConnsPerMinute() +\n                        \" per minute\";\n            else if (_defaultOptions.getMaxTotalConnsPerMinute() <= 0)\n                return \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerMinute() +\n                        \" per minute\";\n            else\n                return \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerMinute() +\n                        \" or total limit of \" + _defaultOptions.getMaxTotalConnsPerMinute() +\n                        \" per minute\";\n        }\n\n        return null;\n    }","commit_id":"a92913da4c253e2a14e18c4af1c920f482ddef35","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    public <T extends Script> CompiledScript<T> compile(ScriptSource source, ClassLoader classLoader, Transformer transformer, Class<T> scriptBaseClass, Action<? super ClassNode> verifier) {\n        List<Object> key = Arrays.asList(source.getClassName(), classLoader, transformer.getId(), scriptBaseClass.getName());\n        CompiledScript<T> compiledScript = Cast.uncheckedCast(cachedCompiledScripts.get(key));\n        if (compiledScript == null) {\n            compiledScript = scriptClassCompiler.compile(source, classLoader, transformer, scriptBaseClass, verifier);\n            cachedCompiledScripts.put(key, compiledScript);\n        }\n        return compiledScript;\n    }","id":93380,"modified_method":"@Override\n    public <T extends Script> CompiledScript<T> compile(ScriptSource source, ClassLoader classLoader, Transformer transformer, String classpathClosureName, Class<T> scriptBaseClass, Action<? super ClassNode> verifier) {\n        List<Object> key = Arrays.asList(source.getClassName(), classLoader, transformer.getId(), scriptBaseClass.getName());\n        CompiledScript<T> compiledScript = Cast.uncheckedCast(cachedCompiledScripts.get(key));\n        if (compiledScript == null) {\n            compiledScript = scriptClassCompiler.compile(source, classLoader, transformer, classpathClosureName, scriptBaseClass, verifier);\n            cachedCompiledScripts.put(key, compiledScript);\n        }\n        return compiledScript;\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"private boolean isEmpty(SourceUnit source) {\n            if (!source.getAST().getMethods().isEmpty()) {\n                return false;\n            }\n            List<Statement> statements = source.getAST().getStatementBlock().getStatements();\n            if (statements.size() > 1) {\n                return false;\n            }\n            if (statements.isEmpty()) {\n                return true;\n            }\n\n            Statement statement = statements.get(0);\n            if (statement instanceof ReturnStatement) {\n                ReturnStatement returnStatement = (ReturnStatement) statement;\n                if (returnStatement.getExpression() instanceof ConstantExpression) {\n                    ConstantExpression constantExpression = (ConstantExpression) returnStatement.getExpression();\n                    if (constantExpression.getValue() == null) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }","id":93381,"modified_method":"private boolean isEmpty(SourceUnit source) {\n            if (!source.getAST().getMethods().isEmpty()) {\n                return false;\n            }\n            List<Statement> statements = source.getAST().getStatementBlock().getStatements();\n            if (statements.size() > 1) {\n                return false;\n            }\n            if (statements.isEmpty()) {\n                return true;\n            }\n\n            return AstUtils.isReturnNullStatement(statements.get(0));\n        }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public void compileToDir(ScriptSource source, ClassLoader classLoader, File classesDir,\n                             Transformer transformer, Class<? extends Script> scriptBaseClass, Action<? super ClassNode> verifier) {\n        Clock clock = new Clock();\n        GFileUtils.deleteDirectory(classesDir);\n        GFileUtils.mkdirs(classesDir);\n        CompilerConfiguration configuration = createBaseCompilerConfiguration(scriptBaseClass);\n        configuration.setTargetDirectory(classesDir);\n        try {\n            compileScript(source, classLoader, configuration, classesDir, transformer, verifier);\n        } catch (GradleException e) {\n            GFileUtils.deleteDirectory(classesDir);\n            throw e;\n        }\n\n        logger.debug(\"Timing: Writing script to cache at {} took: {}\", classesDir.getAbsolutePath(),\n                clock.getTime());\n    }","id":93382,"modified_method":"public void compileToDir(ScriptSource source, ClassLoader classLoader, File classesDir, Transformer transformer, String classpathClosureName, Class<? extends Script> scriptBaseClass,\n                             Action<? super ClassNode> verifier) {\n        Clock clock = new Clock();\n        GFileUtils.deleteDirectory(classesDir);\n        GFileUtils.mkdirs(classesDir);\n        CompilerConfiguration configuration = createBaseCompilerConfiguration(scriptBaseClass);\n        configuration.setTargetDirectory(classesDir);\n        try {\n            compileScript(source, classLoader, configuration, classesDir, transformer, verifier, classpathClosureName);\n        } catch (GradleException e) {\n            GFileUtils.deleteDirectory(classesDir);\n            throw e;\n        }\n\n        logger.debug(\"Timing: Writing script to cache at {} took: {}\", classesDir.getAbsolutePath(),\n                clock.getTime());\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public <T extends Script> Class<? extends T> loadFromDir(ScriptSource source, ClassLoader classLoader, File scriptCacheDir,\n                                                             Class<T> scriptBaseClass) {\n        if (new File(scriptCacheDir, EMPTY_SCRIPT_MARKER_FILE_NAME).isFile()) {\n            return emptyScriptGenerator.generate(scriptBaseClass);\n        }\n\n        try {\n            ClassLoader loader = this.classLoaderCache.get(ClassLoaderIds.buildScript(source.getFileName()), new DefaultClassPath(scriptCacheDir), classLoader, null);\n            return loader.loadClass(source.getClassName()).asSubclass(scriptBaseClass);\n        } catch (Exception e) {\n            File expectedClassFile = new File(scriptCacheDir, source.getClassName() + \".class\");\n            if (!expectedClassFile.exists()) {\n                throw new GradleException(String.format(\"Could not load compiled classes for %s from cache. Expected class file %s does not exist.\", source.getDisplayName(), expectedClassFile.getAbsolutePath()), e);\n            }\n            throw new GradleException(String.format(\"Could not load compiled classes for %s from cache.\", source.getDisplayName()), e);\n        }\n    }","id":93383,"modified_method":"public <T extends Script> CompiledScript<T> loadFromDir(final ScriptSource source, final ClassLoader classLoader, final File scriptCacheDir,\n                                                            final Class<T> scriptBaseClass) {\n        final boolean hasImperativeStatements = new File(scriptCacheDir, IMPERATIVE_STATEMENTS_MARKER_FILE_NAME).isFile();\n\n        return new ClassCachingCompiledScript<T>(new CompiledScript<T>() {\n\n            public boolean hasImperativeStatements() {\n                return hasImperativeStatements;\n            }\n\n            @Override\n            public Class<? extends T> loadClass() {\n                if (new File(scriptCacheDir, EMPTY_SCRIPT_MARKER_FILE_NAME).isFile()) {\n                    return emptyScriptGenerator.generate(scriptBaseClass);\n                }\n\n                try {\n                    ClassLoader loader = classLoaderCache.get(ClassLoaderIds.buildScript(source.getFileName()), new DefaultClassPath(scriptCacheDir), classLoader, null);\n                    return loader.loadClass(source.getClassName()).asSubclass(scriptBaseClass);\n                } catch (Exception e) {\n                    File expectedClassFile = new File(scriptCacheDir, source.getClassName() + \".class\");\n                    if (!expectedClassFile.exists()) {\n                        throw new GradleException(String.format(\"Could not load compiled classes for %s from cache. Expected class file %s does not exist.\", source.getDisplayName(), expectedClassFile.getAbsolutePath()), e);\n                    }\n                    throw new GradleException(String.format(\"Could not load compiled classes for %s from cache.\", source.getDisplayName()), e);\n                }\n            }\n        });\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"private void compileScript(final ScriptSource source, ClassLoader classLoader, CompilerConfiguration configuration,\n                               File classesDir, final Transformer transformer, final Action<? super ClassNode> customVerifier) {\n        logger.info(\"Compiling {} using {}.\", source.getDisplayName(), transformer != null ? transformer.getClass().getSimpleName() : \"no transformer\");\n\n        final EmptyScriptDetector emptyScriptDetector = new EmptyScriptDetector();\n        final PackageStatementDetector packageDetector = new PackageStatementDetector();\n        GroovyClassLoader groovyClassLoader = new GroovyClassLoader(classLoader, configuration, false) {\n            @Override\n            protected CompilationUnit createCompilationUnit(CompilerConfiguration compilerConfiguration,\n                                                            CodeSource codeSource) {\n                CompilationUnit compilationUnit = new CustomCompilationUnit(compilerConfiguration, codeSource, customVerifier, source, this);\n\n                if (transformer != null) {\n                    transformer.register(compilationUnit);\n                }\n\n                compilationUnit.addPhaseOperation(packageDetector, Phases.CANONICALIZATION);\n                compilationUnit.addPhaseOperation(emptyScriptDetector, Phases.CANONICALIZATION);\n                return compilationUnit;\n            }\n        };\n        String scriptText = source.getResource().getText();\n        String scriptName = source.getClassName();\n        GroovyCodeSource codeSource = new GroovyCodeSource(scriptText == null ? \"\" : scriptText, scriptName, \"/groovy/script\");\n        try {\n            groovyClassLoader.parseClass(codeSource, false);\n        } catch (MultipleCompilationErrorsException e) {\n            wrapCompilationFailure(source, e);\n        } catch (CompilationFailedException e) {\n            throw new GradleException(String.format(\"Could not compile %s.\", source.getDisplayName()), e);\n        }\n\n        if (packageDetector.hasPackageStatement) {\n            throw new UnsupportedOperationException(String.format(\"%s should not contain a package statement.\",\n                    StringUtils.capitalize(source.getDisplayName())));\n        }\n        if (emptyScriptDetector.isEmptyScript()) {\n            GFileUtils.touch(new File(classesDir, EMPTY_SCRIPT_MARKER_FILE_NAME));\n        }\n    }","id":93384,"modified_method":"private void compileScript(final ScriptSource source, ClassLoader classLoader, CompilerConfiguration configuration,\n                               File classesDir, final Transformer transformer, final Action<? super ClassNode> customVerifier, String classpathClosureName) {\n        logger.info(\"Compiling {} using {}.\", source.getDisplayName(), transformer != null ? transformer.getClass().getSimpleName() : \"no transformer\");\n\n        final EmptyScriptDetector emptyScriptDetector = new EmptyScriptDetector();\n        final PackageStatementDetector packageDetector = new PackageStatementDetector();\n        final ImperativeStatementDetector imperativeStatementDetector = new ImperativeStatementDetector(classpathClosureName);\n        GroovyClassLoader groovyClassLoader = new GroovyClassLoader(classLoader, configuration, false) {\n            @Override\n            protected CompilationUnit createCompilationUnit(CompilerConfiguration compilerConfiguration,\n                                                            CodeSource codeSource) {\n                CompilationUnit compilationUnit = new CustomCompilationUnit(compilerConfiguration, codeSource, customVerifier, source, this);\n\n                if (transformer != null) {\n                    transformer.register(compilationUnit);\n                }\n\n                compilationUnit.addPhaseOperation(packageDetector, Phases.CANONICALIZATION);\n                compilationUnit.addPhaseOperation(emptyScriptDetector, Phases.CANONICALIZATION);\n                compilationUnit.addPhaseOperation(imperativeStatementDetector, Phases.CANONICALIZATION);\n                return compilationUnit;\n            }\n        };\n        String scriptText = source.getResource().getText();\n        String scriptName = source.getClassName();\n        GroovyCodeSource codeSource = new GroovyCodeSource(scriptText == null ? \"\" : scriptText, scriptName, \"/groovy/script\");\n        try {\n            groovyClassLoader.parseClass(codeSource, false);\n        } catch (MultipleCompilationErrorsException e) {\n            wrapCompilationFailure(source, e);\n        } catch (CompilationFailedException e) {\n            throw new GradleException(String.format(\"Could not compile %s.\", source.getDisplayName()), e);\n        }\n\n        if (packageDetector.hasPackageStatement) {\n            throw new UnsupportedOperationException(String.format(\"%s should not contain a package statement.\",\n                    StringUtils.capitalize(source.getDisplayName())));\n        }\n        if (emptyScriptDetector.isEmptyScript()) {\n            GFileUtils.touch(new File(classesDir, EMPTY_SCRIPT_MARKER_FILE_NAME));\n        }\n        if(imperativeStatementDetector.hasImperativeStatements) {\n            GFileUtils.touch(new File(classesDir, IMPERATIVE_STATEMENTS_MARKER_FILE_NAME));\n        }\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testCompileScriptToDirWithPropertiesOnlyScript() throws Exception {\n        final ScriptSource scriptSource = scriptSource(\"String a\");\n        scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, expectedScriptClass, verifier);\n\n        checkScriptClassesInCache();\n\n        Script script = scriptCompilationHandler.loadFromDir(scriptSource, classLoader, scriptCacheDir,\n                expectedScriptClass).newInstance();\n        assertThat(script, isA(expectedScriptClass));\n    }","id":93385,"modified_method":"@Test\n    public void testCompileScriptToDirWithPropertiesOnlyScript() throws Exception {\n        final ScriptSource scriptSource = scriptSource(\"String a\");\n        scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, classpathClosureName, expectedScriptClass, verifier);\n\n        checkScriptClassesInCache();\n        checkHasImperativeStatementsMarkerInCache();\n\n        CompiledScript<? extends Script> compiledScript = scriptCompilationHandler.loadFromDir(scriptSource, classLoader, scriptCacheDir,\n                expectedScriptClass);\n        assertThat(compiledScript.hasImperativeStatements(), is(true));\n\n        Script script = compiledScript.loadClass().newInstance();\n        assertThat(script, isA(expectedScriptClass));\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testCompileScriptToDir() throws Exception {\n        scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, expectedScriptClass, verifier);\n\n        checkScriptClassesInCache();\n\n        Script script = scriptCompilationHandler.loadFromDir(scriptSource, classLoader, scriptCacheDir,\n                expectedScriptClass).newInstance();\n        evaluateScript(script);\n    }","id":93386,"modified_method":"@Test\n    public void testCompileScriptToDir() throws Exception {\n        scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, classpathClosureName, expectedScriptClass, verifier);\n\n        checkScriptClassesInCache();\n        checkHasImperativeStatementsMarkerInCache();\n\n        CompiledScript<? extends Script> compiledScript = scriptCompilationHandler.loadFromDir(scriptSource, classLoader, scriptCacheDir,\n                expectedScriptClass);\n        assertThat(compiledScript.hasImperativeStatements(), is(true));\n\n        Script script = compiledScript.loadClass().newInstance();\n        evaluateScript(script);\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testCompileScriptToDirWithMethodOnlyScript() throws Exception {\n        final ScriptSource scriptSource = scriptSource(\"def method() { println 'hi' }\");\n        scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, expectedScriptClass, verifier);\n\n        checkScriptClassesInCache();\n\n        Script script = scriptCompilationHandler.loadFromDir(scriptSource, classLoader, scriptCacheDir,\n                expectedScriptClass).newInstance();\n        assertThat(script, isA(expectedScriptClass));\n    }","id":93387,"modified_method":"@Test\n    public void testCompileScriptToDirWithMethodOnlyScript() throws Exception {\n        final ScriptSource scriptSource = scriptSource(\"def method() { println 'hi' }\");\n        scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, classpathClosureName, expectedScriptClass, verifier);\n\n        checkScriptClassesInCache();\n        checkHasImperativeStatementsMarkerInCache();\n\n        CompiledScript<? extends Script> compiledScript = scriptCompilationHandler.loadFromDir(scriptSource, classLoader, scriptCacheDir,\n                expectedScriptClass);\n        assertThat(compiledScript.hasImperativeStatements(), is(true));\n\n        Script script = compiledScript.loadClass().newInstance();\n        assertThat(script, isA(expectedScriptClass));\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testCompileScriptToDirWithWhitespaceOnly() throws Exception {\n        final ScriptSource scriptSource = scriptSource(\"// ignore me\\n\");\n        scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, expectedScriptClass, verifier);\n\n        checkEmptyScriptInCache();\n\n        Script script = scriptCompilationHandler.loadFromDir(scriptSource, classLoader, scriptCacheDir,\n                expectedScriptClass).newInstance();\n        assertThat(script, isA(expectedScriptClass));\n    }","id":93388,"modified_method":"@Test\n    public void testCompileScriptToDirWithWhitespaceOnly() throws Exception {\n        final ScriptSource scriptSource = scriptSource(\"// ignore me\\n\");\n        scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, classpathClosureName, expectedScriptClass, verifier);\n\n        checkEmptyScriptInCache();\n        checkHasNoImperativeStatementsMarkerInCache();\n\n        CompiledScript<? extends Script> compiledScript = scriptCompilationHandler.loadFromDir(scriptSource, classLoader, scriptCacheDir,\n                expectedScriptClass);\n        assertThat(compiledScript.hasImperativeStatements(), is(false));\n\n        Script script = compiledScript.loadClass().newInstance();\n        assertThat(script, isA(expectedScriptClass));\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testCanVisitAndTransformGeneratedClasses() throws Exception {\n        final Action<ClassNode> verifier = context.mock(Action.class);\n        context.checking(new Expectations() {{\n            one(verifier).execute(with(notNullValue(ClassNode.class)));\n        }});\n\n        ScriptSource source = scriptSource(\"transformMe()\");\n        scriptCompilationHandler.compileToDir(source, classLoader, scriptCacheDir, null, expectedScriptClass, verifier);\n    }","id":93389,"modified_method":"@Test\n    public void testCanVisitAndTransformGeneratedClasses() throws Exception {\n        final Action<ClassNode> verifier = context.mock(Action.class);\n        context.checking(new Expectations() {{\n            one(verifier).execute(with(notNullValue(ClassNode.class)));\n        }});\n\n        ScriptSource source = scriptSource(\"transformMe()\");\n        scriptCompilationHandler.compileToDir(source, classLoader, scriptCacheDir, null, classpathClosureName, expectedScriptClass, verifier);\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testCompileScriptToDirWithPackageDeclaration() throws Exception {\n        final ScriptSource scriptSource = scriptSource(\"package org.gradle.test\\n\" + scriptText);\n\n        try {\n            scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, expectedScriptClass, verifier);\n            fail();\n        } catch (UnsupportedOperationException e) {\n            assertThat(e.getMessage(), equalTo(\"Script-display-name should not contain a package statement.\"));\n        }\n    }","id":93390,"modified_method":"@Test\n    public void testCompileScriptToDirWithPackageDeclaration() throws Exception {\n        final ScriptSource scriptSource = scriptSource(\"package org.gradle.test\\n\" + scriptText);\n\n        try {\n            scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, classpathClosureName, expectedScriptClass, verifier);\n            fail();\n        } catch (UnsupportedOperationException e) {\n            assertThat(e.getMessage(), equalTo(\"Script-display-name should not contain a package statement.\"));\n        }\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testCompileToDirWithSyntaxError() {\n        ScriptSource source = new StringScriptSource(\"script.gradle\", \"\\n\\nnew HHHHJSJSJ jsj\");\n        try {\n            scriptCompilationHandler.compileToDir(source, classLoader, scriptCacheDir, null, expectedScriptClass, verifier);\n            fail();\n        } catch (ScriptCompilationException e) {\n            assertThat(e.getScriptSource(), sameInstance(source));\n            assertThat(e.getLineNumber(), equalTo(3));\n            assertThat(e.getCause().getMessage(), containsLine(startsWith(\"script.gradle: 3: unexpected token: jsj\")));\n        }\n\n        checkScriptCacheEmpty();\n    }","id":93391,"modified_method":"@Test\n    public void testCompileToDirWithSyntaxError() {\n        ScriptSource source = new StringScriptSource(\"script.gradle\", \"\\n\\nnew HHHHJSJSJ jsj\");\n        try {\n            scriptCompilationHandler.compileToDir(source, classLoader, scriptCacheDir, null, classpathClosureName, expectedScriptClass, verifier);\n            fail();\n        } catch (ScriptCompilationException e) {\n            assertThat(e.getScriptSource(), sameInstance(source));\n            assertThat(e.getLineNumber(), equalTo(3));\n            assertThat(e.getCause().getMessage(), containsLine(startsWith(\"script.gradle: 3: unexpected token: jsj\")));\n        }\n\n        checkScriptCacheEmpty();\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testCompileScriptToDirWithEmptyScript() throws Exception {\n        final ScriptSource scriptSource = scriptSource(\"\");\n        scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, expectedScriptClass, verifier);\n\n        checkEmptyScriptInCache();\n\n        Script script = scriptCompilationHandler.loadFromDir(scriptSource, classLoader, scriptCacheDir,\n                expectedScriptClass).newInstance();\n        assertThat(script, isA(expectedScriptClass));\n    }","id":93392,"modified_method":"@Test\n    public void testCompileScriptToDirWithEmptyScript() throws Exception {\n        final ScriptSource scriptSource = scriptSource(\"\");\n        scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, classpathClosureName, expectedScriptClass, verifier);\n\n        checkEmptyScriptInCache();\n        checkHasNoImperativeStatementsMarkerInCache();\n\n        CompiledScript<? extends Script> compiledScript = scriptCompilationHandler.loadFromDir(scriptSource, classLoader, scriptCacheDir,\n                expectedScriptClass);\n        assertThat(compiledScript.hasImperativeStatements(), is(false));\n\n        Script script = compiledScript.loadClass().newInstance();\n        assertThat(script, isA(expectedScriptClass));\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Before\n    public void setUp() throws IOException, ClassNotFoundException {\n        File testProjectDir = tmpDir.createDir(\"projectDir\");\n        classLoader = getClass().getClassLoader();\n        scriptCompilationHandler = new DefaultScriptCompilationHandler(new AsmBackedEmptyScriptGenerator(), new DummyClassLoaderCache());\n        scriptCacheDir = new File(testProjectDir, \"cache\");\n        scriptText = \"System.setProperty('\" + TEST_EXPECTED_SYSTEMPROP_KEY + \"', '\" + TEST_EXPECTED_SYSTEMPROP_VALUE\n                + \"')\";\n\n        scriptClassName = \"ScriptClassName\";\n        scriptFileName = \"script-file-name\";\n        scriptSource = scriptSource();\n        cachedFile = new File(scriptCacheDir, scriptClassName + \".class\");\n        expectedScriptClass = TestBaseScript.class;\n    }","id":93393,"modified_method":"@Before\n    public void setUp() throws IOException, ClassNotFoundException {\n        File testProjectDir = tmpDir.createDir(\"projectDir\");\n        classLoader = getClass().getClassLoader();\n        scriptCompilationHandler = new DefaultScriptCompilationHandler(new AsmBackedEmptyScriptGenerator(), new DummyClassLoaderCache());\n        scriptCacheDir = new File(testProjectDir, \"cache\");\n        scriptText = \"System.setProperty('\" + TEST_EXPECTED_SYSTEMPROP_KEY + \"', '\" + TEST_EXPECTED_SYSTEMPROP_VALUE\n                + \"')\";\n\n        scriptClassName = \"ScriptClassName\";\n        scriptFileName = \"script-file-name\";\n        classpathClosureName = \"buildscript\";\n        scriptSource = scriptSource();\n        cachedFile = new File(scriptCacheDir, scriptClassName + \".class\");\n        expectedScriptClass = TestBaseScript.class;\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testCanVisitAndTransformScriptClass() throws Exception {\n        Transformer visitor = new AbstractScriptTransformer() {\n            public String getId() {\n                return \"id\";\n            }\n\n            protected int getPhase() {\n                return Phases.CANONICALIZATION;\n            }\n\n            @Override\n            public void call(SourceUnit source) throws CompilationFailedException {\n                source.getAST().getStatementBlock().visit(new CodeVisitorSupport() {\n                    @Override\n                    public void visitMethodCallExpression(MethodCallExpression call) {\n                        call.setObjectExpression(new ClassExpression(ClassHelper.make(System.class)));\n                        call.setMethod(new ConstantExpression(\"setProperty\"));\n                        ArgumentListExpression arguments = (ArgumentListExpression) call.getArguments();\n                        arguments.addExpression(new ConstantExpression(TEST_EXPECTED_SYSTEMPROP_KEY));\n                        arguments.addExpression(new ConstantExpression(TEST_EXPECTED_SYSTEMPROP_VALUE));\n                    }\n                });\n            }\n        };\n\n        ScriptSource source = scriptSource(\"transformMe()\");\n        scriptCompilationHandler.compileToDir(source, classLoader, scriptCacheDir, visitor, expectedScriptClass, verifier);\n        Script script = scriptCompilationHandler.loadFromDir(source, classLoader, scriptCacheDir, expectedScriptClass).newInstance();\n        evaluateScript(script);\n    }","id":93394,"modified_method":"@Test\n    public void testCanVisitAndTransformScriptClass() throws Exception {\n        Transformer visitor = new AbstractScriptTransformer() {\n            public String getId() {\n                return \"id\";\n            }\n\n            protected int getPhase() {\n                return Phases.CANONICALIZATION;\n            }\n\n            @Override\n            public void call(SourceUnit source) throws CompilationFailedException {\n                source.getAST().getStatementBlock().visit(new CodeVisitorSupport() {\n                    @Override\n                    public void visitMethodCallExpression(MethodCallExpression call) {\n                        call.setObjectExpression(new ClassExpression(ClassHelper.make(System.class)));\n                        call.setMethod(new ConstantExpression(\"setProperty\"));\n                        ArgumentListExpression arguments = (ArgumentListExpression) call.getArguments();\n                        arguments.addExpression(new ConstantExpression(TEST_EXPECTED_SYSTEMPROP_KEY));\n                        arguments.addExpression(new ConstantExpression(TEST_EXPECTED_SYSTEMPROP_VALUE));\n                    }\n                });\n            }\n        };\n\n        ScriptSource source = scriptSource(\"transformMe()\");\n        scriptCompilationHandler.compileToDir(source, classLoader, scriptCacheDir, visitor, classpathClosureName, expectedScriptClass, verifier);\n        Script script = scriptCompilationHandler.loadFromDir(source, classLoader, scriptCacheDir, expectedScriptClass).loadClass().newInstance();\n        evaluateScript(script);\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testCompileScriptToDirWithClassDefinitionOnlyScript() throws Exception {\n        final ScriptSource scriptSource = scriptSource(\"class SomeClass {}\");\n        scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, expectedScriptClass, verifier);\n\n        checkEmptyScriptInCache();\n\n        Script script = scriptCompilationHandler.loadFromDir(scriptSource, classLoader, scriptCacheDir,\n                expectedScriptClass).newInstance();\n        assertThat(script, isA(expectedScriptClass));\n    }","id":93395,"modified_method":"@Test\n    public void testCompileScriptToDirWithClassDefinitionOnlyScript() throws Exception {\n        final ScriptSource scriptSource = scriptSource(\"class SomeClass {}\");\n        scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, classpathClosureName, expectedScriptClass, verifier);\n\n        checkEmptyScriptInCache();\n        checkHasNoImperativeStatementsMarkerInCache();\n\n        CompiledScript<? extends Script> compiledScript = scriptCompilationHandler.loadFromDir(scriptSource, classLoader, scriptCacheDir,\n                expectedScriptClass);\n        assertThat(compiledScript.hasImperativeStatements(), is(false));\n\n        Script script = compiledScript.loadClass().newInstance();\n        assertThat(script, isA(expectedScriptClass));\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testLoadFromDirWhenNotAssignableToBaseClass() {\n        scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, Script.class, verifier);\n        try {\n            scriptCompilationHandler.loadFromDir(scriptSource, classLoader, scriptCacheDir,\n                    expectedScriptClass);\n            fail();\n        } catch (GradleException e) {\n            assertThat(e.getMessage(), containsString(\"Could not load compiled classes for script-display-name from cache.\"));\n            assertThat(e.getCause(), instanceOf(ClassCastException.class));\n        }\n    }","id":93396,"modified_method":"@Test\n    public void testLoadFromDirWhenNotAssignableToBaseClass() {\n        scriptCompilationHandler.compileToDir(scriptSource, classLoader, scriptCacheDir, null, classpathClosureName, Script.class, verifier);\n        try {\n            scriptCompilationHandler.loadFromDir(scriptSource, classLoader, scriptCacheDir,\n                    expectedScriptClass).loadClass();\n            fail();\n        } catch (GradleException e) {\n            assertThat(e.getMessage(), containsString(\"Could not load compiled classes for script-display-name from cache.\"));\n            assertThat(e.getCause(), instanceOf(ClassCastException.class));\n        }\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public <T extends Script> ScriptRunner<T> compile(Class<T> scriptType) {\n            CompiledScript<T> scriptClass = scriptClassCompiler.compile(source, classloader, transformer, scriptType, verifier);\n            return scriptRunnerFactory.create(scriptClass, source, classloader);\n        }","id":93397,"modified_method":"@Override\n        public <T extends Script> ScriptRunner<T> compile(Class<T> scriptType) {\n            CompiledScript<T> scriptClass = scriptClassCompiler.compile(source, classloader, transformer, classpathClosureName, scriptType, verifier);\n            return scriptRunnerFactory.create(scriptClass, source, classloader);\n        }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(final Object target) {\n            DefaultServiceRegistry services = new DefaultServiceRegistry();\n            services.add(ScriptPluginFactory.class, DefaultScriptPluginFactory.this);\n            services.add(ScriptHandlerFactory.class, scriptHandlerFactory);\n            services.add(ClassLoaderScope.class, targetScope);\n            services.add(LoggingManagerInternal.class, loggingManagerFactory.create());\n            services.add(Instantiator.class, instantiator);\n            services.add(ScriptHandler.class, scriptHandler);\n            services.add(FileLookup.class, fileLookup);\n            services.add(ModelRuleSourceDetector.class, modelRuleSourceDetector);\n\n            ScriptSource withImports = importsReader.withImports(scriptSource);\n\n            PluginDependenciesService pluginDependenciesService = new PluginDependenciesService(getSource());\n            services.add(PluginDependenciesService.class, pluginDependenciesService);\n\n            ScriptCompiler compiler = scriptCompilerFactory.createCompiler(withImports);\n            compiler.setClassloader(baseScope.getExportClassLoader());\n\n            boolean supportsPluginsBlock = ProjectScript.class.isAssignableFrom(scriptType);\n            String onPluginBlockError = supportsPluginsBlock ? null : \"Only Project build scripts can contain plugins {} blocks\";\n\n            PluginsAndBuildscriptTransformer scriptBlockTransformer = new PluginsAndBuildscriptTransformer(classpathClosureName, onPluginBlockError, documentationRegistry);\n\n            StatementExtractingScriptTransformer classpathScriptTransformer = new StatementExtractingScriptTransformer(classpathClosureName, scriptBlockTransformer);\n\n            compiler.setTransformer(classpathScriptTransformer);\n\n            ScriptRunner<? extends BasicScript> classPathScriptRunner = compiler.compile(scriptType);\n            classPathScriptRunner.getScript().init(target, services);\n            classPathScriptRunner.run();\n\n            List<PluginRequest> pluginRequests = pluginDependenciesService.getRequests();\n            PluginManagerInternal pluginManager = target instanceof PluginAwareInternal ? ((PluginAwareInternal) target).getPluginManager() : null;\n            pluginRequestApplicator.applyPlugins(pluginRequests, scriptHandler, pluginManager, targetScope);\n\n            compiler.setClassloader(targetScope.getLocalClassLoader());\n\n            BuildScriptTransformer transformer = new BuildScriptTransformer(\"no_\" + classpathScriptTransformer.getId(), classpathScriptTransformer.invert(), scriptSource);\n            compiler.setTransformer(transformer);\n\n            // TODO - find a less tangled way of getting this in here, see the verifier impl for why it's needed\n            compiler.setVerifier(new ClosureCreationInterceptingVerifier());\n\n            ScriptRunner<? extends BasicScript> runner = compiler.compile(scriptType);\n\n            BasicScript script = runner.getScript();\n            script.init(target, services);\n            if (ownerScript && target instanceof ScriptAware) {\n                ((ScriptAware) target).setScript(script);\n            }\n            runner.run();\n        }","id":93398,"modified_method":"public void apply(final Object target) {\n            DefaultServiceRegistry services = new DefaultServiceRegistry();\n            services.add(ScriptPluginFactory.class, DefaultScriptPluginFactory.this);\n            services.add(ScriptHandlerFactory.class, scriptHandlerFactory);\n            services.add(ClassLoaderScope.class, targetScope);\n            services.add(LoggingManagerInternal.class, loggingManagerFactory.create());\n            services.add(Instantiator.class, instantiator);\n            services.add(ScriptHandler.class, scriptHandler);\n            services.add(FileLookup.class, fileLookup);\n            services.add(ModelRuleSourceDetector.class, modelRuleSourceDetector);\n\n            ScriptSource withImports = importsReader.withImports(scriptSource);\n\n            PluginDependenciesService pluginDependenciesService = new PluginDependenciesService(getSource());\n            services.add(PluginDependenciesService.class, pluginDependenciesService);\n\n            ScriptCompiler compiler = scriptCompilerFactory.createCompiler(withImports);\n            compiler.setClassloader(baseScope.getExportClassLoader());\n\n            boolean supportsPluginsBlock = ProjectScript.class.isAssignableFrom(scriptType);\n            String onPluginBlockError = supportsPluginsBlock ? null : \"Only Project build scripts can contain plugins {} blocks\";\n\n            PluginsAndBuildscriptTransformer scriptBlockTransformer = new PluginsAndBuildscriptTransformer(classpathClosureName, onPluginBlockError, documentationRegistry);\n\n            StatementExtractingScriptTransformer classpathScriptTransformer = new StatementExtractingScriptTransformer(classpathClosureName, scriptBlockTransformer);\n\n            compiler.setTransformer(classpathScriptTransformer);\n            compiler.setClasspathClosureName(classpathClosureName);\n\n            ScriptRunner<? extends BasicScript> classPathScriptRunner = compiler.compile(scriptType);\n            classPathScriptRunner.getScript().init(target, services);\n            classPathScriptRunner.run();\n\n            List<PluginRequest> pluginRequests = pluginDependenciesService.getRequests();\n            PluginManagerInternal pluginManager = target instanceof PluginAwareInternal ? ((PluginAwareInternal) target).getPluginManager() : null;\n            pluginRequestApplicator.applyPlugins(pluginRequests, scriptHandler, pluginManager, targetScope);\n\n            compiler.setClassloader(targetScope.getLocalClassLoader());\n\n            BuildScriptTransformer transformer = new BuildScriptTransformer(\"no_\" + classpathScriptTransformer.getId(), classpathScriptTransformer.invert(), scriptSource);\n            compiler.setTransformer(transformer);\n\n            // TODO - find a less tangled way of getting this in here, see the verifier impl for why it's needed\n            compiler.setVerifier(new ClosureCreationInterceptingVerifier());\n\n            ScriptRunner<? extends BasicScript> runner = compiler.compile(scriptType);\n\n            BasicScript script = runner.getScript();\n            script.init(target, services);\n            if (ownerScript && target instanceof ScriptAware) {\n                ((ScriptAware) target).setScript(script);\n            }\n            runner.run();\n        }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"private CacheInitializer(ScriptSource source, ClassLoader classLoader, Transformer transformer, Action<? super ClassNode> verifier, Class<? extends Script> scriptBaseClass) {\n            this.source = source;\n            this.classLoader = classLoader;\n            this.transformer = transformer;\n            this.verifier = verifier;\n            this.scriptBaseClass = scriptBaseClass;\n        }","id":93399,"modified_method":"private CacheInitializer(ScriptSource source, ClassLoader classLoader, Transformer transformer, String classpathClosureName, Action<? super ClassNode> verifier, Class<? extends Script> scriptBaseClass) {\n            this.source = source;\n            this.classLoader = classLoader;\n            this.transformer = transformer;\n            this.classpathClosureName = classpathClosureName;\n            this.verifier = verifier;\n            this.scriptBaseClass = scriptBaseClass;\n        }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public void execute(PersistentCache cache) {\n            File classesDir = classesDir(cache);\n            scriptCompilationHandler.compileToDir(source, classLoader, classesDir, transformer, scriptBaseClass, verifier);\n        }","id":93400,"modified_method":"public void execute(PersistentCache cache) {\n            File classesDir = classesDir(cache);\n            scriptCompilationHandler.compileToDir(source, classLoader, classesDir, transformer, classpathClosureName, scriptBaseClass, verifier);\n        }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public <T extends Script> CompiledScript<T> compile(final ScriptSource source, final ClassLoader classLoader, Transformer transformer, final Class<T> scriptBaseClass, Action<? super ClassNode> verifier) {\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"source.filename\", source.getFileName());\n        properties.put(\"source.hash\", HashUtil.createCompactMD5(source.getResource().getText()));\n\n        String cacheName = String.format(\"scripts/%s/%s/%s\", source.getClassName(), scriptBaseClass.getSimpleName(), transformer.getId());\n        PersistentCache cache = cacheRepository.cache(cacheName)\n                .withProperties(properties)\n                .withValidator(validator)\n                .withDisplayName(String.format(\"%s class cache for %s\", transformer.getId(), source.getDisplayName()))\n                .withInitializer(new ProgressReportingInitializer(progressLoggerFactory, new CacheInitializer(source, classLoader, transformer, verifier, scriptBaseClass)))\n                .open();\n\n        // This isn't quite right. The cache will be closed at the end of the build, releasing the shared lock on the classes. Instead, the cache for a script should be\n        // closed once we no longer require the script classes. This may be earlier than the end of the current build, or it may used across multiple builds\n        caches.add(cache);\n\n        final File classesDir = classesDir(cache);\n\n        return new ClassCachingCompiledScript<T>(new CompiledScript<T>() {\n            public Class<? extends T> loadClass() {\n                return scriptCompilationHandler.loadFromDir(source, classLoader, classesDir, scriptBaseClass);\n            }\n        });\n    }","id":93401,"modified_method":"public <T extends Script> CompiledScript<T> compile(final ScriptSource source, final ClassLoader classLoader, Transformer transformer, String classpathClosureName, final Class<T> scriptBaseClass,\n                                                        Action<? super ClassNode> verifier) {\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"source.filename\", source.getFileName());\n        properties.put(\"source.hash\", HashUtil.createCompactMD5(source.getResource().getText()));\n\n        String cacheName = String.format(\"scripts/%s/%s/%s\", source.getClassName(), scriptBaseClass.getSimpleName(), transformer.getId());\n        PersistentCache cache = cacheRepository.cache(cacheName)\n                .withProperties(properties)\n                .withValidator(validator)\n                .withDisplayName(String.format(\"%s class cache for %s\", transformer.getId(), source.getDisplayName()))\n                .withInitializer(new ProgressReportingInitializer(progressLoggerFactory, new CacheInitializer(source, classLoader, transformer, classpathClosureName, verifier, scriptBaseClass)))\n                .open();\n\n        // This isn't quite right. The cache will be closed at the end of the build, releasing the shared lock on the classes. Instead, the cache for a script should be\n        // closed once we no longer require the script classes. This may be earlier than the end of the current build, or it may used across multiple builds\n        caches.add(cache);\n\n        final File classesDir = classesDir(cache);\n\n        return scriptCompilationHandler.loadFromDir(source, classLoader, classesDir, scriptBaseClass);\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public <T extends Script> CompiledScript<T> compile(ScriptSource source, ClassLoader classLoader, Transformer transformer, final Class<T> scriptBaseClass, Action<? super ClassNode> verifier) {\n        if (source.getResource().getText().matches(\"\\\\s*\")) {\n            return new ClassCachingCompiledScript<T>(new CompiledScript<T>() {\n                public Class<? extends T> loadClass() {\n                    return emptyScriptGenerator.generate(scriptBaseClass);\n                }\n            });\n        }\n        return compiler.compile(source, classLoader, transformer, scriptBaseClass, verifier);\n    }","id":93402,"modified_method":"@Override\n    public <T extends Script> CompiledScript<T> compile(ScriptSource source, ClassLoader classLoader, Transformer transformer, String classpathClosureName, final Class<T> scriptBaseClass, Action<? super ClassNode> verifier) {\n        if (source.getResource().getText().matches(\"\\\\s*\")) {\n            return new ClassCachingCompiledScript<T>(new CompiledScript<T>() {\n                @Override\n                public boolean hasImperativeStatements() {\n                    return false;\n                }\n\n                public Class<? extends T> loadClass() {\n                    return emptyScriptGenerator.generate(scriptBaseClass);\n                }\n            });\n        }\n        return compiler.compile(source, classLoader, transformer, classpathClosureName, scriptBaseClass, verifier);\n    }","commit_id":"233c71f34580ae0c3f8b3154ab5f096207333e9f","url":"https://github.com/gradle/gradle"},{"original_method":"public void filter( Collection dependencies )\n        {\n            for ( Iterator i = dependencies.iterator(); i.hasNext(); )\n            {\n                if ( false == matches( ( Artifact ) i.next() ) )\n                {\n                    i.remove();\n                }\n            }\n        }","id":93403,"modified_method":"public void filter( Collection<Artifact> dependencies )\n        {\n            for ( Iterator<Artifact> i = dependencies.iterator(); i.hasNext(); )\n            {\n                if ( false == matches( i.next() ) )\n                {\n                    i.remove();\n                }\n            }\n        }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"public AbstractDependencyFilter( Collection dependencyArtifacts )\n    {\n        m_dependencyArtifacts = dependencyArtifacts;\n    }","id":93404,"modified_method":"public AbstractDependencyFilter( Collection<Artifact> dependencyArtifacts )\n    {\n        m_dependencyArtifacts = dependencyArtifacts;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected final void processInstructions( String header ) throws MojoExecutionException\n    {\n        Map instructions = OSGiHeader.parseHeader( MISSING_KEY_PATTERN.matcher( header ).replaceAll( \"$1$2*;$3\" ) );\n\n        Collection availableDependencies = new LinkedHashSet( m_dependencyArtifacts );\n\n        DependencyFilter filter;\n        for ( Iterator clauseIterator = instructions.entrySet().iterator(); clauseIterator.hasNext(); )\n        {\n            String inline = \"false\";\n\n            // always start with a fresh *modifiable* collection for each unique clause\n            Collection filteredDependencies = new LinkedHashSet( availableDependencies );\n\n            // CLAUSE: REGEXP --> { ATTRIBUTE MAP }\n            Map.Entry clause = ( Map.Entry ) clauseIterator.next();\n            String primaryKey = ( ( String ) clause.getKey() ).replaceFirst( \"~+$\", \"\" );\n            boolean isNegative = primaryKey.startsWith( \"!\" );\n            if ( isNegative )\n            {\n                primaryKey = primaryKey.substring( 1 );\n            }\n\n            if ( !\"*\".equals( primaryKey ) )\n            {\n                filter = new DependencyFilter( primaryKey )\n                {\n                    boolean matches( Artifact dependency )\n                    {\n                        return super.matches( dependency.getArtifactId() );\n                    }\n                };\n                // FILTER ON MAIN CLAUSE\n                filter.filter( filteredDependencies );\n            }\n\n            for ( Iterator attrIterator = ( ( Map ) clause.getValue() ).entrySet().iterator(); attrIterator.hasNext(); )\n            {\n                // ATTRIBUTE: KEY --> REGEXP\n                Map.Entry attr = ( Map.Entry ) attrIterator.next();\n                if ( \"groupId\".equals( attr.getKey() ) )\n                {\n                    filter = new DependencyFilter( ( String ) attr.getValue() )\n                    {\n                        boolean matches( Artifact dependency )\n                        {\n                            return super.matches( dependency.getGroupId() );\n                        }\n                    };\n                }\n                else if ( \"artifactId\".equals( attr.getKey() ) )\n                {\n                    filter = new DependencyFilter( ( String ) attr.getValue() )\n                    {\n                        boolean matches( Artifact dependency )\n                        {\n                            return super.matches( dependency.getArtifactId() );\n                        }\n                    };\n                }\n                else if ( \"version\".equals( attr.getKey() ) )\n                {\n                    filter = new DependencyFilter( ( String ) attr.getValue() )\n                    {\n                        boolean matches( Artifact dependency )\n                        {\n                            try\n                            {\n                                // use the symbolic version if available (ie. 1.0.0-SNAPSHOT)\n                                return super.matches( dependency.getSelectedVersion().toString() );\n                            }\n                            catch ( Exception e )\n                            {\n                                return super.matches( dependency.getVersion() );\n                            }\n                        }\n                    };\n                }\n                else if ( \"scope\".equals( attr.getKey() ) )\n                {\n                    filter = new DependencyFilter( ( String ) attr.getValue(), \"compile\" )\n                    {\n                        boolean matches( Artifact dependency )\n                        {\n                            return super.matches( dependency.getScope() );\n                        }\n                    };\n                }\n                else if ( \"type\".equals( attr.getKey() ) )\n                {\n                    filter = new DependencyFilter( ( String ) attr.getValue(), \"jar\" )\n                    {\n                        boolean matches( Artifact dependency )\n                        {\n                            return super.matches( dependency.getType() );\n                        }\n                    };\n                }\n                else if ( \"classifier\".equals( attr.getKey() ) )\n                {\n                    filter = new DependencyFilter( ( String ) attr.getValue() )\n                    {\n                        boolean matches( Artifact dependency )\n                        {\n                            return super.matches( dependency.getClassifier() );\n                        }\n                    };\n                }\n                else if ( \"optional\".equals( attr.getKey() ) )\n                {\n                    filter = new DependencyFilter( ( String ) attr.getValue(), \"false\" )\n                    {\n                        boolean matches( Artifact dependency )\n                        {\n                            return super.matches( \"\" + dependency.isOptional() );\n                        }\n                    };\n                }\n                else if ( \"inline\".equals( attr.getKey() ) )\n                {\n                    inline = ( String ) attr.getValue();\n                    continue;\n                }\n                else\n                {\n                    throw new MojoExecutionException( \"Unexpected attribute \" + attr.getKey() );\n                }\n\n                // FILTER ON EACH ATTRIBUTE\n                filter.filter( filteredDependencies );\n            }\n\n            if ( isNegative )\n            {\n                // negative clauses reduce the set of available artifacts\n                availableDependencies.removeAll( filteredDependencies );\n                if ( !clauseIterator.hasNext() )\n                {\n                    // assume there's an implicit * missing at the end\n                    processDependencies( availableDependencies, inline );\n                }\n            }\n            else\n            {\n                // positive clause; doesn't alter the available artifacts\n                processDependencies( filteredDependencies, inline );\n            }\n        }\n    }","id":93405,"modified_method":"protected final void processInstructions( String header ) throws MojoExecutionException\n    {\n        Map<String,Attrs> instructions = OSGiHeader.parseHeader( MISSING_KEY_PATTERN.matcher( header ).replaceAll( \"$1$2*;$3\" ) );\n\n        Collection<Artifact> availableDependencies = new LinkedHashSet<Artifact>( m_dependencyArtifacts );\n\n        DependencyFilter filter;\n        for ( Iterator<Map.Entry<String,Attrs>> clauseIterator = instructions.entrySet().iterator(); clauseIterator.hasNext(); )\n        {\n            String inline = \"false\";\n\n            // always start with a fresh *modifiable* collection for each unique clause\n            Collection<Artifact> filteredDependencies = new LinkedHashSet<Artifact>( availableDependencies );\n\n            // CLAUSE: REGEXP --> { ATTRIBUTE MAP }\n            Map.Entry<String,Attrs> clause = clauseIterator.next();\n            String primaryKey = clause.getKey().replaceFirst( \"~+$\", \"\" );\n            boolean isNegative = primaryKey.startsWith( \"!\" );\n            if ( isNegative )\n            {\n                primaryKey = primaryKey.substring( 1 );\n            }\n\n            if ( !\"*\".equals( primaryKey ) )\n            {\n                filter = new DependencyFilter( primaryKey )\n                {\n                    @Override\n                    boolean matches( Artifact dependency )\n                    {\n                        return super.matches( dependency.getArtifactId() );\n                    }\n                };\n                // FILTER ON MAIN CLAUSE\n                filter.filter( filteredDependencies );\n            }\n\n            for ( Iterator<Map.Entry<String,String>> attrIterator = clause.getValue().entrySet().iterator(); attrIterator.hasNext(); )\n            {\n                // ATTRIBUTE: KEY --> REGEXP\n                Map.Entry<String,String> attr = attrIterator.next();\n                if ( \"groupId\".equals( attr.getKey() ) )\n                {\n                    filter = new DependencyFilter( attr.getValue() )\n                    {\n                        @Override\n                        boolean matches( Artifact dependency )\n                        {\n                            return super.matches( dependency.getGroupId() );\n                        }\n                    };\n                }\n                else if ( \"artifactId\".equals( attr.getKey() ) )\n                {\n                    filter = new DependencyFilter( attr.getValue() )\n                    {\n                        @Override\n                        boolean matches( Artifact dependency )\n                        {\n                            return super.matches( dependency.getArtifactId() );\n                        }\n                    };\n                }\n                else if ( \"version\".equals( attr.getKey() ) )\n                {\n                    filter = new DependencyFilter( attr.getValue() )\n                    {\n                        @Override\n                        boolean matches( Artifact dependency )\n                        {\n                            try\n                            {\n                                // use the symbolic version if available (ie. 1.0.0-SNAPSHOT)\n                                return super.matches( dependency.getSelectedVersion().toString() );\n                            }\n                            catch ( Exception e )\n                            {\n                                return super.matches( dependency.getVersion() );\n                            }\n                        }\n                    };\n                }\n                else if ( \"scope\".equals( attr.getKey() ) )\n                {\n                    filter = new DependencyFilter( attr.getValue(), \"compile\" )\n                    {\n                        @Override\n                        boolean matches( Artifact dependency )\n                        {\n                            return super.matches( dependency.getScope() );\n                        }\n                    };\n                }\n                else if ( \"type\".equals( attr.getKey() ) )\n                {\n                    filter = new DependencyFilter( attr.getValue(), \"jar\" )\n                    {\n                        @Override\n                        boolean matches( Artifact dependency )\n                        {\n                            return super.matches( dependency.getType() );\n                        }\n                    };\n                }\n                else if ( \"classifier\".equals( attr.getKey() ) )\n                {\n                    filter = new DependencyFilter( attr.getValue() )\n                    {\n                        @Override\n                        boolean matches( Artifact dependency )\n                        {\n                            return super.matches( dependency.getClassifier() );\n                        }\n                    };\n                }\n                else if ( \"optional\".equals( attr.getKey() ) )\n                {\n                    filter = new DependencyFilter( attr.getValue(), \"false\" )\n                    {\n                        @Override\n                        boolean matches( Artifact dependency )\n                        {\n                            return super.matches( \"\" + dependency.isOptional() );\n                        }\n                    };\n                }\n                else if ( \"inline\".equals( attr.getKey() ) )\n                {\n                    inline = attr.getValue();\n                    continue;\n                }\n                else\n                {\n                    throw new MojoExecutionException( \"Unexpected attribute \" + attr.getKey() );\n                }\n\n                // FILTER ON EACH ATTRIBUTE\n                filter.filter( filteredDependencies );\n            }\n\n            if ( isNegative )\n            {\n                // negative clauses reduce the set of available artifacts\n                availableDependencies.removeAll( filteredDependencies );\n                if ( !clauseIterator.hasNext() )\n                {\n                    // assume there's an implicit * missing at the end\n                    processDependencies( availableDependencies, inline );\n                }\n            }\n            else\n            {\n                // positive clause; doesn't alter the available artifacts\n                processDependencies( filteredDependencies, inline );\n            }\n        }\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected abstract void processDependencies( Collection dependencies, String inline );","id":93406,"modified_method":"protected abstract void processDependencies( Collection<Artifact> dependencies, String inline );","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected void execute( MavenProject currentProject, Map originalInstructions, Properties properties,\n        Jar[] classpath ) throws MojoExecutionException\n    {\n        final String artifactId = getProject().getArtifactId();\n        final String baseDir = getProject().getBasedir().getPath();\n\n        try\n        {\n            // assemble bundle as usual, but don't save it - this way we have all the instructions we need\n            Builder builder = buildOSGiBundle( currentProject, originalInstructions, properties, classpath );\n            Properties bndProperties = builder.getProperties();\n\n            // cleanup and remove all non-strings from the builder properties\n            for ( Iterator i = bndProperties.values().iterator(); i.hasNext(); )\n            {\n                if ( !( i.next() instanceof String ) )\n                {\n                    i.remove();\n                }\n            }\n\n            // save the BND generated bundle to the same output directory that maven uses\n            bndProperties.setProperty( \"-output\", \"${maven.build.dir}/${maven.build.finalName}.jar\" );\n\n            OutputStream out = new FileOutputStream( baseDir + BUILD_BND );\n            bndProperties.store( out, \" Merged BND Instructions\" );\n            IOUtil.close( out );\n\n            // modify build template\n            String buildXml = IOUtil.toString( getClass().getResourceAsStream( BUILD_XML ) );\n            buildXml = StringUtils.replace( buildXml, \"BND_VERSION\", builder.getVersion() );\n            buildXml = StringUtils.replace( buildXml, \"ARTIFACT_ID\", artifactId );\n\n            FileUtils.fileWrite( baseDir + BUILD_XML, buildXml );\n\n            // cleanup...\n            builder.close();\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Problem creating Ant script\", e );\n        }\n\n        getLog().info( \"Wrote Ant bundle project for \" + artifactId + \" to \" + baseDir );\n    }","id":93407,"modified_method":"@Override\n    protected void execute( MavenProject currentProject, Map<String, String> originalInstructions, Properties properties,\n        Jar[] classpath ) throws MojoExecutionException\n    {\n        final String artifactId = getProject().getArtifactId();\n        final String baseDir = getProject().getBasedir().getPath();\n\n        try\n        {\n            // assemble bundle as usual, but don't save it - this way we have all the instructions we need\n            Builder builder = buildOSGiBundle( currentProject, originalInstructions, properties, classpath );\n            Properties bndProperties = builder.getProperties();\n\n            // cleanup and remove all non-strings from the builder properties\n            for ( Iterator i = bndProperties.values().iterator(); i.hasNext(); )\n            {\n                if ( !( i.next() instanceof String ) )\n                {\n                    i.remove();\n                }\n            }\n\n            // save the BND generated bundle to the same output directory that maven uses\n            bndProperties.setProperty( \"-output\", \"${maven.build.dir}/${maven.build.finalName}.jar\" );\n\n            OutputStream out = new FileOutputStream( baseDir + BUILD_BND );\n            bndProperties.store( out, \" Merged BND Instructions\" );\n            IOUtil.close( out );\n\n            // modify build template\n            String buildXml = IOUtil.toString( getClass().getResourceAsStream( BUILD_XML ) );\n            buildXml = StringUtils.replace( buildXml, \"BND_VERSION\", builder.getVersion() );\n            buildXml = StringUtils.replace( buildXml, \"ARTIFACT_ID\", artifactId );\n\n            FileUtils.fileWrite( baseDir + BUILD_XML, buildXml );\n\n            // cleanup...\n            builder.close();\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Problem creating Ant script\", e );\n        }\n\n        getLog().info( \"Wrote Ant bundle project for \" + artifactId + \" to \" + baseDir );\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"public void addExportedPackage( String packageName, Artifact artifact )\n    {\n        Set artifacts = ( Set ) getExportedPackages().get( packageName );\n        if ( artifacts == null )\n        {\n            artifacts = new HashSet();\n            m_exportedPackages.put( packageName, artifacts );\n        }\n        artifacts.add( artifact );\n    }","id":93408,"modified_method":"public void addExportedPackage( String packageName, Artifact artifact )\n    {\n        Set<Artifact> artifacts = getExportedPackages().get( packageName );\n        if ( artifacts == null )\n        {\n            artifacts = new HashSet<Artifact>();\n            m_exportedPackages.put( packageName, artifacts );\n        }\n        artifacts.add( artifact );\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"public void merge( BundleInfo bundleInfo )\n    {\n        for ( Iterator it = bundleInfo.getExportedPackages().entrySet().iterator(); it.hasNext(); )\n        {\n            Map.Entry entry = ( Map.Entry ) it.next();\n            String packageName = ( String ) entry.getKey();\n            Collection artifacts = ( Collection ) entry.getValue();\n\n            Collection artifactsWithPackage = ( Collection ) getExportedPackages().get( packageName );\n            if ( artifactsWithPackage == null )\n            {\n                artifactsWithPackage = new HashSet();\n                getExportedPackages().put( packageName, artifactsWithPackage );\n            }\n            artifactsWithPackage.addAll( artifacts );\n        }\n    }","id":93409,"modified_method":"public void merge( BundleInfo bundleInfo )\n    {\n        for ( Iterator<Map.Entry<String, Set<Artifact>>> it = bundleInfo.getExportedPackages().entrySet().iterator(); it.hasNext(); )\n        {\n            Map.Entry<String, Set<Artifact>> entry = it.next();\n            String packageName = entry.getKey();\n            Set<Artifact> artifacts = entry.getValue();\n\n            Set<Artifact> artifactsWithPackage = getExportedPackages().get( packageName );\n            if ( artifactsWithPackage == null )\n            {\n                artifactsWithPackage = new HashSet<Artifact>();\n                getExportedPackages().put( packageName, artifactsWithPackage );\n            }\n            artifactsWithPackage.addAll( artifacts );\n        }\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Get a list of packages that are exported in more than one bundle.\n     * Key is package name and value list of artifacts where it's exported.\n     * @return {@link Map} &lt; {@link String}, {@link Set} &lt; {@link Artifact} > >\n     */\n    public Map getDuplicatedExports()\n    {\n        Map duplicatedExports = new HashMap();\n\n        for ( Iterator it = getExportedPackages().entrySet().iterator(); it.hasNext(); )\n        {\n            Map.Entry entry = ( Map.Entry ) it.next();\n            Set artifacts = ( Set ) entry.getValue();\n            if ( artifacts.size() > 1 )\n            {\n                /* remove warnings caused by different versions of same artifact */\n                Set artifactKeys = new HashSet();\n\n                String packageName = ( String ) entry.getKey();\n                for ( Iterator it2 = artifacts.iterator(); it2.hasNext(); )\n                {\n                    Artifact artifact = ( Artifact ) it2.next();\n                    artifactKeys.add( artifact.getGroupId() + \".\" + artifact.getArtifactId() );\n                }\n\n                if ( artifactKeys.size() > 1 )\n                {\n                    duplicatedExports.put( packageName, artifacts );\n                }\n            }\n        }\n\n        return duplicatedExports;\n    }","id":93410,"modified_method":"/**\n     * Get a list of packages that are exported in more than one bundle.\n     * Key is package name and value list of artifacts where it's exported.\n     * @return {@link Map} &lt; {@link String}, {@link Set} &lt; {@link Artifact} > >\n     */\n    public Map<String, Set<Artifact>> getDuplicatedExports()\n    {\n        Map<String, Set<Artifact>> duplicatedExports = new HashMap<String, Set<Artifact>>();\n\n        for ( Iterator<Map.Entry<String, Set<Artifact>>> it = getExportedPackages().entrySet().iterator(); it.hasNext(); )\n        {\n            Map.Entry<String, Set<Artifact>> entry = it.next();\n            Set<Artifact> artifacts = entry.getValue();\n            if ( artifacts.size() > 1 )\n            {\n                /* remove warnings caused by different versions of same artifact */\n                Set<String> artifactKeys = new HashSet<String>();\n\n                String packageName = entry.getKey();\n                for ( Iterator<Artifact> it2 = artifacts.iterator(); it2.hasNext(); )\n                {\n                    Artifact artifact = it2.next();\n                    artifactKeys.add( artifact.getGroupId() + \".\" + artifact.getArtifactId() );\n                }\n\n                if ( artifactKeys.size() > 1 )\n                {\n                    duplicatedExports.put( packageName, artifacts );\n                }\n            }\n        }\n\n        return duplicatedExports;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected Set getOptionalPackages( MavenProject currentProject ) throws IOException, MojoExecutionException\n    {\n        ArrayList inscope = new ArrayList();\n        final Collection artifacts = getSelectedDependencies( currentProject.getArtifacts() );\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = ( Artifact ) it.next();\n            if ( artifact.getArtifactHandler().isAddedToClasspath() )\n            {\n                if ( !Artifact.SCOPE_TEST.equals( artifact.getScope() ) )\n                {\n                    inscope.add( artifact );\n                }\n            }\n        }\n\n        HashSet optionalArtifactIds = new HashSet();\n        for ( Iterator it = inscope.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = ( Artifact ) it.next();\n            if ( artifact.isOptional() )\n            {\n                String id = artifact.toString();\n                if ( artifact.getScope() != null )\n                {\n                    // strip the scope...\n                    id = id.replaceFirst( \":[^:]*$\", \"\" );\n                }\n                optionalArtifactIds.add( id );\n            }\n\n        }\n\n        HashSet required = new HashSet();\n        HashSet optional = new HashSet();\n        for ( Iterator it = inscope.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = ( Artifact ) it.next();\n            File file = getFile( artifact );\n            if ( file == null )\n            {\n                continue;\n            }\n\n            Jar jar = new Jar( artifact.getArtifactId(), file );\n            if ( isTransitivelyOptional( optionalArtifactIds, artifact ) )\n            {\n                optional.addAll( jar.getPackages() );\n            }\n            else\n            {\n                required.addAll( jar.getPackages() );\n            }\n            jar.close();\n        }\n\n        optional.removeAll( required );\n        return optional;\n    }","id":93411,"modified_method":"protected Set<String> getOptionalPackages( MavenProject currentProject ) throws IOException, MojoExecutionException\n    {\n        ArrayList<Artifact> inscope = new ArrayList<Artifact>();\n        final Collection<Artifact> artifacts = getSelectedDependencies( currentProject.getArtifacts() );\n        for ( Iterator<Artifact> it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = it.next();\n            if ( artifact.getArtifactHandler().isAddedToClasspath() )\n            {\n                if ( !Artifact.SCOPE_TEST.equals( artifact.getScope() ) )\n                {\n                    inscope.add( artifact );\n                }\n            }\n        }\n\n        HashSet<String> optionalArtifactIds = new HashSet<String>();\n        for ( Iterator<Artifact> it = inscope.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = it.next();\n            if ( artifact.isOptional() )\n            {\n                String id = artifact.toString();\n                if ( artifact.getScope() != null )\n                {\n                    // strip the scope...\n                    id = id.replaceFirst( \":[^:]*$\", \"\" );\n                }\n                optionalArtifactIds.add( id );\n            }\n\n        }\n\n        HashSet<String> required = new HashSet<String>();\n        HashSet<String> optional = new HashSet<String>();\n        for ( Iterator<Artifact> it = inscope.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = it.next();\n            File file = getFile( artifact );\n            if ( file == null )\n            {\n                continue;\n            }\n\n            Jar jar = new Jar( artifact.getArtifactId(), file );\n            if ( isTransitivelyOptional( optionalArtifactIds, artifact ) )\n            {\n                optional.addAll( jar.getPackages() );\n            }\n            else\n            {\n                required.addAll( jar.getPackages() );\n            }\n            jar.close();\n        }\n\n        optional.removeAll( required );\n        return optional;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected Builder buildOSGiBundle( MavenProject currentProject, Map originalInstructions, Properties properties,\n        Jar[] classpath ) throws Exception\n    {\n        Builder builder = getOSGiBuilder( currentProject, originalInstructions, properties, classpath );\n\n        addMavenInstructions( currentProject, builder );\n\n        builder.build();\n\n        mergeMavenManifest( currentProject, builder );\n\n        return builder;\n    }","id":93412,"modified_method":"protected Builder buildOSGiBundle( MavenProject currentProject, Map<String, String> originalInstructions, Properties properties,\n        Jar[] classpath ) throws Exception\n    {\n        Builder builder = getOSGiBuilder( currentProject, originalInstructions, properties, classpath );\n\n        addMavenInstructions( currentProject, builder );\n\n        builder.build();\n\n        mergeMavenManifest( currentProject, builder );\n\n        return builder;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected Builder getOSGiBuilder( MavenProject currentProject, Map originalInstructions, Properties properties,\n        Jar[] classpath ) throws Exception\n    {\n        properties.putAll( getDefaultProperties( currentProject ) );\n        properties.putAll( transformDirectives( originalInstructions ) );\n\n        // process overrides from project\n        final Map addProps = new HashMap();\n        final Iterator iter = currentProject.getProperties().entrySet().iterator();\n        while ( iter.hasNext() )\n        {\n            final Map.Entry entry = (Entry) iter.next();\n            final String key = entry.getKey().toString();\n            if ( key.startsWith(BUNDLE_PLUGIN_EXTENSION) )\n            {\n                final String oKey = key.substring(BUNDLE_PLUGIN_EXTENSION.length());\n                final String currentValue = properties.getProperty(oKey);\n                if ( currentValue == null )\n                {\n                    addProps.put(oKey, entry.getValue());\n                }\n                else\n                {\n                    addProps.put(oKey, currentValue + ',' + entry.getValue());\n                }\n            }\n            if ( key.startsWith(BUNDLE_PLUGIN_PREPEND_EXTENSION) )\n            {\n                final String oKey = key.substring(BUNDLE_PLUGIN_PREPEND_EXTENSION.length());\n                final String currentValue = properties.getProperty(oKey);\n                if ( currentValue == null )\n                {\n                    addProps.put(oKey, entry.getValue());\n                }\n                else\n                {\n                    addProps.put(oKey, entry.getValue() + \",\" + currentValue);\n                }\n            }\n        }\n        properties.putAll( addProps );\n        final Iterator keyIter = addProps.keySet().iterator();\n        while ( keyIter.hasNext() )\n        {\n            Object key = keyIter.next();\n            properties.remove(BUNDLE_PLUGIN_EXTENSION + key);\n            properties.remove(BUNDLE_PLUGIN_PREPEND_EXTENSION + key);\n        }\n\n        if (properties.getProperty(\"Bundle-Activator\") != null\n                && properties.getProperty(\"Bundle-Activator\").isEmpty())\n        {\n            properties.remove(\"Bundle-Activator\");\n        }\n        if (properties.containsKey(\"-disable-plugin\"))\n        {\n            String[] disabled = properties.remove(\"-disable-plugin\").toString().replaceAll(\" \", \"\").split(\",\");\n            String[] enabled = properties.getProperty(Analyzer.PLUGIN, \"\").replaceAll(\" \", \"\").split(\",\");\n            Set<String> plugin = new LinkedHashSet<String>();\n            plugin.addAll(Arrays.asList(enabled));\n            plugin.removeAll(Arrays.asList(disabled));\n            StringBuilder sb = new StringBuilder();\n            for (String s : plugin)\n            {\n                if (sb.length() > 0)\n                {\n                    sb.append(\",\");\n                }\n                sb.append(s);\n            }\n            properties.setProperty(Analyzer.PLUGIN, sb.toString());\n        }\n\n        Builder builder = new Builder();\n        synchronized ( BundlePlugin.class ) // protect setBase...getBndLastModified which uses static DateFormat\n        {\n            builder.setBase( getBase( currentProject ) );\n        }\n        builder.setProperties( sanitize( properties ) );\n        if ( classpath != null )\n        {\n            builder.setClasspath( classpath );\n        }\n\n        return builder;\n    }","id":93413,"modified_method":"protected Builder getOSGiBuilder( MavenProject currentProject, Map<String, String> originalInstructions, Properties properties,\n        Jar[] classpath ) throws Exception\n    {\n        properties.putAll( getDefaultProperties( currentProject ) );\n        properties.putAll( transformDirectives( originalInstructions ) );\n\n        // process overrides from project\n        final Map<String, String> addProps = new HashMap<String, String>();\n        final Iterator<Map.Entry<Object, Object>> iter = currentProject.getProperties().entrySet().iterator();\n        while ( iter.hasNext() )\n        {\n            final Map.Entry<Object, Object> entry = iter.next();\n            final String key = entry.getKey().toString();\n            if ( key.startsWith(BUNDLE_PLUGIN_EXTENSION) )\n            {\n                final String oKey = key.substring(BUNDLE_PLUGIN_EXTENSION.length());\n                final String currentValue = properties.getProperty(oKey);\n                if ( currentValue == null )\n                {\n                    addProps.put(oKey, entry.getValue().toString());\n                }\n                else\n                {\n                    addProps.put(oKey, currentValue + ',' + entry.getValue());\n                }\n            }\n            if ( key.startsWith(BUNDLE_PLUGIN_PREPEND_EXTENSION) )\n            {\n                final String oKey = key.substring(BUNDLE_PLUGIN_PREPEND_EXTENSION.length());\n                final String currentValue = properties.getProperty(oKey);\n                if ( currentValue == null )\n                {\n                    addProps.put(oKey, entry.getValue().toString());\n                }\n                else\n                {\n                    addProps.put(oKey, entry.getValue() + \",\" + currentValue);\n                }\n            }\n        }\n        properties.putAll( addProps );\n        final Iterator<String> keyIter = addProps.keySet().iterator();\n        while ( keyIter.hasNext() )\n        {\n            Object key = keyIter.next();\n            properties.remove(BUNDLE_PLUGIN_EXTENSION + key);\n            properties.remove(BUNDLE_PLUGIN_PREPEND_EXTENSION + key);\n        }\n\n        if (properties.getProperty(\"Bundle-Activator\") != null\n                && properties.getProperty(\"Bundle-Activator\").isEmpty())\n        {\n            properties.remove(\"Bundle-Activator\");\n        }\n        if (properties.containsKey(\"-disable-plugin\"))\n        {\n            String[] disabled = properties.remove(\"-disable-plugin\").toString().replaceAll(\" \", \"\").split(\",\");\n            String[] enabled = properties.getProperty(Analyzer.PLUGIN, \"\").replaceAll(\" \", \"\").split(\",\");\n            Set<String> plugin = new LinkedHashSet<String>();\n            plugin.addAll(Arrays.asList(enabled));\n            plugin.removeAll(Arrays.asList(disabled));\n            StringBuilder sb = new StringBuilder();\n            for (String s : plugin)\n            {\n                if (sb.length() > 0)\n                {\n                    sb.append(\",\");\n                }\n                sb.append(s);\n            }\n            properties.setProperty(Analyzer.PLUGIN, sb.toString());\n        }\n\n        Builder builder = new Builder();\n        synchronized ( BundlePlugin.class ) // protect setBase...getBndLastModified which uses static DateFormat\n        {\n            builder.setBase( getBase( currentProject ) );\n        }\n        builder.setProperties( sanitize( properties ) );\n        if ( classpath != null )\n        {\n            builder.setClasspath( classpath );\n        }\n\n        return builder;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"private static StringBuffer printLicenses( List licenses )\n    {\n        if ( licenses == null || licenses.size() == 0 )\n            return null;\n        StringBuffer sb = new StringBuffer();\n        String del = \"\";\n        for ( Iterator i = licenses.iterator(); i.hasNext(); )\n        {\n            License l = ( License ) i.next();\n            String url = l.getUrl();\n            if ( url == null )\n                continue;\n            sb.append( del );\n            sb.append( url );\n            del = \", \";\n        }\n        if ( sb.length() == 0 )\n            return null;\n        return sb;\n    }","id":93414,"modified_method":"private static StringBuffer printLicenses( List<License> licenses )\n    {\n        if ( licenses == null || licenses.size() == 0 )\n            return null;\n        StringBuffer sb = new StringBuffer();\n        String del = \"\";\n        for ( Iterator<License> i = licenses.iterator(); i.hasNext(); )\n        {\n            License l = i.next();\n            String url = l.getUrl();\n            if ( url == null )\n                continue;\n            sb.append( del );\n            sb.append( url );\n            del = \", \";\n        }\n        if ( sb.length() == 0 )\n            return null;\n        return sb;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected void mergeMavenManifest( MavenProject currentProject, Builder builder ) throws Exception\n    {\n        Jar jar = builder.getJar();\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"BND Manifest:\" + NL + dumpManifest( jar.getManifest(), new StringBuilder() ) );\n        }\n\n        boolean addMavenDescriptor = currentProject.getBasedir() != null;\n\n        try\n        {\n            /*\n             * Grab customized manifest entries from the maven-jar-plugin configuration\n             */\n            MavenArchiveConfiguration archiveConfig = JarPluginConfiguration.getArchiveConfiguration( currentProject );\n            String mavenManifestText = new MavenArchiver().getManifest( currentProject, archiveConfig ).toString();\n            addMavenDescriptor = addMavenDescriptor && archiveConfig.isAddMavenDescriptor();\n\n            Manifest mavenManifest = new Manifest();\n\n            // First grab the external manifest file (if specified and different to target location)\n            File externalManifestFile = archiveConfig.getManifestFile();\n            if ( null != externalManifestFile )\n            {\n                if ( !externalManifestFile.isAbsolute() )\n                {\n                    externalManifestFile = new File( currentProject.getBasedir(), externalManifestFile.getPath() );\n                }\n                if ( externalManifestFile.exists() && !externalManifestFile.equals( new File( manifestLocation, \"MANIFEST.MF\" ) ) )\n                {\n                    InputStream mis = new FileInputStream( externalManifestFile );\n                    mavenManifest.read( mis );\n                    mis.close();\n                }\n            }\n\n            // Then apply customized entries from the jar plugin; note: manifest encoding is UTF8\n            mavenManifest.read( new ByteArrayInputStream( mavenManifestText.getBytes( \"UTF8\" ) ) );\n\n            if ( !archiveConfig.isManifestSectionsEmpty() )\n            {\n                /*\n                 * Add customized manifest sections (for some reason MavenArchiver doesn't do this for us)\n                 */\n                List sections = archiveConfig.getManifestSections();\n                for ( Iterator i = sections.iterator(); i.hasNext(); )\n                {\n                    ManifestSection section = ( ManifestSection ) i.next();\n                    Attributes attributes = new Attributes();\n\n                    if ( !section.isManifestEntriesEmpty() )\n                    {\n                        Map entries = section.getManifestEntries();\n                        for ( Iterator j = entries.entrySet().iterator(); j.hasNext(); )\n                        {\n                            Map.Entry entry = ( Map.Entry ) j.next();\n                            attributes.putValue( ( String ) entry.getKey(), ( String ) entry.getValue() );\n                        }\n                    }\n\n                    mavenManifest.getEntries().put( section.getName(), attributes );\n                }\n            }\n\n            Attributes mainMavenAttributes = mavenManifest.getMainAttributes();\n            mainMavenAttributes.putValue( \"Created-By\", \"Apache Maven Bundle Plugin\" );\n\n            String[] removeHeaders = builder.getProperty( Constants.REMOVEHEADERS, \"\" ).split( \",\" );\n\n            // apply -removeheaders to the custom manifest\n            for ( int i = 0; i < removeHeaders.length; i++ )\n            {\n                for ( Iterator j = mainMavenAttributes.keySet().iterator(); j.hasNext(); )\n                {\n                    if ( j.next().toString().matches( removeHeaders[i].trim() ) )\n                    {\n                        j.remove();\n                    }\n                }\n            }\n\n            /*\n             * Overlay generated bundle manifest with customized entries\n             */\n            Manifest bundleManifest = jar.getManifest();\n            bundleManifest.getMainAttributes().putAll( mainMavenAttributes );\n            bundleManifest.getEntries().putAll( mavenManifest.getEntries() );\n\n            // adjust the import package attributes so that optional dependencies use\n            // optional resolution.\n            String importPackages = bundleManifest.getMainAttributes().getValue( \"Import-Package\" );\n            if ( importPackages != null )\n            {\n                Set optionalPackages = getOptionalPackages( currentProject );\n\n                Map<String, ? extends Map<String, String>> values = new Analyzer().parseHeader( importPackages );\n                for ( Map.Entry<String, ? extends Map<String, String>> entry : values.entrySet() )\n                {\n                    String pkg = entry.getKey();\n                    Map<String, String> options = entry.getValue();\n                    if ( !options.containsKey( \"resolution:\" ) && optionalPackages.contains( pkg ) )\n                    {\n                        options.put( \"resolution:\", \"optional\" );\n                    }\n                }\n                String result = Processor.printClauses( values );\n                bundleManifest.getMainAttributes().putValue( \"Import-Package\", result );\n            }\n\n            jar.setManifest( bundleManifest );\n        }\n        catch ( Exception e )\n        {\n            getLog().warn( \"Unable to merge Maven manifest: \" + e.getLocalizedMessage() );\n        }\n\n        if ( addMavenDescriptor )\n        {\n            doMavenMetadata( currentProject, jar );\n        }\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"Final Manifest:\" + NL + dumpManifest( jar.getManifest(), new StringBuilder() ) );\n        }\n\n        builder.setJar( jar );\n    }","id":93415,"modified_method":"protected void mergeMavenManifest( MavenProject currentProject, Builder builder ) throws Exception\n    {\n        Jar jar = builder.getJar();\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"BND Manifest:\" + NL + dumpManifest( jar.getManifest(), new StringBuilder() ) );\n        }\n\n        boolean addMavenDescriptor = currentProject.getBasedir() != null;\n\n        try\n        {\n            /*\n             * Grab customized manifest entries from the maven-jar-plugin configuration\n             */\n            MavenArchiveConfiguration archiveConfig = JarPluginConfiguration.getArchiveConfiguration( currentProject );\n            String mavenManifestText = new MavenArchiver().getManifest( currentProject, archiveConfig ).toString();\n            addMavenDescriptor = addMavenDescriptor && archiveConfig.isAddMavenDescriptor();\n\n            Manifest mavenManifest = new Manifest();\n\n            // First grab the external manifest file (if specified and different to target location)\n            File externalManifestFile = archiveConfig.getManifestFile();\n            if ( null != externalManifestFile )\n            {\n                if ( !externalManifestFile.isAbsolute() )\n                {\n                    externalManifestFile = new File( currentProject.getBasedir(), externalManifestFile.getPath() );\n                }\n                if ( externalManifestFile.exists() && !externalManifestFile.equals( new File( manifestLocation, \"MANIFEST.MF\" ) ) )\n                {\n                    InputStream mis = new FileInputStream( externalManifestFile );\n                    mavenManifest.read( mis );\n                    mis.close();\n                }\n            }\n\n            // Then apply customized entries from the jar plugin; note: manifest encoding is UTF8\n            mavenManifest.read( new ByteArrayInputStream( mavenManifestText.getBytes( \"UTF8\" ) ) );\n\n            if ( !archiveConfig.isManifestSectionsEmpty() )\n            {\n                /*\n                 * Add customized manifest sections (for some reason MavenArchiver doesn't do this for us)\n                 */\n                List<ManifestSection> sections = archiveConfig.getManifestSections();\n                for ( Iterator<ManifestSection> i = sections.iterator(); i.hasNext(); )\n                {\n                    ManifestSection section = i.next();\n                    Attributes attributes = new Attributes();\n\n                    if ( !section.isManifestEntriesEmpty() )\n                    {\n                        Map<String, String> entries = section.getManifestEntries();\n                        for ( Iterator<Map.Entry<String, String>> j = entries.entrySet().iterator(); j.hasNext(); )\n                        {\n                            Map.Entry<String, String> entry = j.next();\n                            attributes.putValue( entry.getKey(), entry.getValue() );\n                        }\n                    }\n\n                    mavenManifest.getEntries().put( section.getName(), attributes );\n                }\n            }\n\n            Attributes mainMavenAttributes = mavenManifest.getMainAttributes();\n            mainMavenAttributes.putValue( \"Created-By\", \"Apache Maven Bundle Plugin\" );\n\n            String[] removeHeaders = builder.getProperty( Constants.REMOVEHEADERS, \"\" ).split( \",\" );\n\n            // apply -removeheaders to the custom manifest\n            for ( int i = 0; i < removeHeaders.length; i++ )\n            {\n                for ( Iterator<Object> j = mainMavenAttributes.keySet().iterator(); j.hasNext(); )\n                {\n                    if ( j.next().toString().matches( removeHeaders[i].trim() ) )\n                    {\n                        j.remove();\n                    }\n                }\n            }\n\n            /*\n             * Overlay generated bundle manifest with customized entries\n             */\n            Manifest bundleManifest = jar.getManifest();\n            bundleManifest.getMainAttributes().putAll( mainMavenAttributes );\n            bundleManifest.getEntries().putAll( mavenManifest.getEntries() );\n\n            // adjust the import package attributes so that optional dependencies use\n            // optional resolution.\n            String importPackages = bundleManifest.getMainAttributes().getValue( \"Import-Package\" );\n            if ( importPackages != null )\n            {\n                Set optionalPackages = getOptionalPackages( currentProject );\n\n                Map<String, ? extends Map<String, String>> values = new Analyzer().parseHeader( importPackages );\n                for ( Map.Entry<String, ? extends Map<String, String>> entry : values.entrySet() )\n                {\n                    String pkg = entry.getKey();\n                    Map<String, String> options = entry.getValue();\n                    if ( !options.containsKey( \"resolution:\" ) && optionalPackages.contains( pkg ) )\n                    {\n                        options.put( \"resolution:\", \"optional\" );\n                    }\n                }\n                String result = Processor.printClauses( values );\n                bundleManifest.getMainAttributes().putValue( \"Import-Package\", result );\n            }\n\n            jar.setManifest( bundleManifest );\n        }\n        catch ( Exception e )\n        {\n            getLog().warn( \"Unable to merge Maven manifest: \" + e.getLocalizedMessage() );\n        }\n\n        if ( addMavenDescriptor )\n        {\n            doMavenMetadata( currentProject, jar );\n        }\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"Final Manifest:\" + NL + dumpManifest( jar.getManifest(), new StringBuilder() ) );\n        }\n\n        builder.setJar( jar );\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected Jar[] getClasspath( MavenProject currentProject ) throws IOException, MojoExecutionException\n    {\n        List list = new ArrayList();\n\n        if ( getOutputDirectory() != null && getOutputDirectory().exists() )\n        {\n            list.add( new Jar( \".\", getOutputDirectory() ) );\n        }\n\n        final Collection artifacts = getSelectedDependencies( currentProject.getArtifacts() );\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = ( Artifact ) it.next();\n            if ( artifact.getArtifactHandler().isAddedToClasspath() )\n            {\n                if ( !Artifact.SCOPE_TEST.equals( artifact.getScope() ) )\n                {\n                    File file = getFile( artifact );\n                    if ( file == null )\n                    {\n                        getLog().warn(\n                            \"File is not available for artifact \" + artifact + \" in project \"\n                                + currentProject.getArtifact() );\n                        continue;\n                    }\n                    Jar jar = new Jar( artifact.getArtifactId(), file );\n                    list.add( jar );\n                }\n            }\n        }\n        Jar[] cp = new Jar[list.size()];\n        list.toArray( cp );\n        return cp;\n    }","id":93416,"modified_method":"protected Jar[] getClasspath( MavenProject currentProject ) throws IOException, MojoExecutionException\n    {\n        List<Jar> list = new ArrayList<Jar>();\n\n        if ( getOutputDirectory() != null && getOutputDirectory().exists() )\n        {\n            list.add( new Jar( \".\", getOutputDirectory() ) );\n        }\n\n        final Collection<Artifact> artifacts = getSelectedDependencies( currentProject.getArtifacts() );\n        for ( Iterator<Artifact> it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = it.next();\n            if ( artifact.getArtifactHandler().isAddedToClasspath() )\n            {\n                if ( !Artifact.SCOPE_TEST.equals( artifact.getScope() ) )\n                {\n                    File file = getFile( artifact );\n                    if ( file == null )\n                    {\n                        getLog().warn(\n                            \"File is not available for artifact \" + artifact + \" in project \"\n                                + currentProject.getArtifact() );\n                        continue;\n                    }\n                    Jar jar = new Jar( artifact.getArtifactId(), file );\n                    list.add( jar );\n                }\n            }\n        }\n        Jar[] cp = new Jar[list.size()];\n        list.toArray( cp );\n        return cp;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Check to see if any dependency along the dependency trail of\n     * the artifact is optional.\n     *\n     * @param artifact\n     */\n    protected boolean isTransitivelyOptional( HashSet optionalArtifactIds, Artifact artifact )\n    {\n        List trail = artifact.getDependencyTrail();\n        for ( Iterator iterator = trail.iterator(); iterator.hasNext(); )\n        {\n            String next = ( String ) iterator.next();\n            if ( optionalArtifactIds.contains( next ) )\n            {\n                return true;\n            }\n        }\n        return false;\n    }","id":93417,"modified_method":"/**\n     * Check to see if any dependency along the dependency trail of\n     * the artifact is optional.\n     *\n     * @param artifact\n     */\n    protected boolean isTransitivelyOptional( HashSet<String> optionalArtifactIds, Artifact artifact )\n    {\n        List<String> trail = artifact.getDependencyTrail();\n        for ( Iterator<String> iterator = trail.iterator(); iterator.hasNext(); )\n        {\n            String next = iterator.next();\n            if ( optionalArtifactIds.contains( next ) )\n            {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected boolean reportErrors( String prefix, Analyzer analyzer )\n    {\n        List errors = analyzer.getErrors();\n        List warnings = analyzer.getWarnings();\n\n        for ( Iterator w = warnings.iterator(); w.hasNext(); )\n        {\n            String msg = ( String ) w.next();\n            getLog().warn( prefix + \" : \" + msg );\n        }\n\n        boolean hasErrors = false;\n        String fileNotFound = \"Input file does not exist: \";\n        for ( Iterator e = errors.iterator(); e.hasNext(); )\n        {\n            String msg = ( String ) e.next();\n            if ( msg.startsWith( fileNotFound ) && msg.endsWith( \"~\" ) )\n            {\n                // treat as warning; this error happens when you have duplicate entries in Include-Resource\n                String duplicate = Processor.removeDuplicateMarker( msg.substring( fileNotFound.length() ) );\n                getLog().warn( prefix + \" : Duplicate path '\" + duplicate + \"' in Include-Resource\" );\n            }\n            else\n            {\n                getLog().error( prefix + \" : \" + msg );\n                hasErrors = true;\n            }\n        }\n        return hasErrors;\n    }","id":93418,"modified_method":"protected boolean reportErrors( String prefix, Analyzer analyzer )\n    {\n        List<String> errors = analyzer.getErrors();\n        List<String> warnings = analyzer.getWarnings();\n\n        for ( Iterator<String> w = warnings.iterator(); w.hasNext(); )\n        {\n            String msg = w.next();\n            getLog().warn( prefix + \" : \" + msg );\n        }\n\n        boolean hasErrors = false;\n        String fileNotFound = \"Input file does not exist: \";\n        for ( Iterator<String> e = errors.iterator(); e.hasNext(); )\n        {\n            String msg = e.next();\n            if ( msg.startsWith( fileNotFound ) && msg.endsWith( \"~\" ) )\n            {\n                // treat as warning; this error happens when you have duplicate entries in Include-Resource\n                String duplicate = Processor.removeDuplicateMarker( msg.substring( fileNotFound.length() ) );\n                getLog().warn( prefix + \" : Duplicate path '\" + duplicate + \"' in Include-Resource\" );\n            }\n            else\n            {\n                getLog().error( prefix + \" : \" + msg );\n                hasErrors = true;\n            }\n        }\n        return hasErrors;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected static Properties sanitize( Properties properties )\n    {\n        // convert any non-String keys/values to Strings\n        Properties sanitizedEntries = new Properties();\n        for ( Iterator itr = properties.entrySet().iterator(); itr.hasNext(); )\n        {\n            Map.Entry entry = ( Map.Entry ) itr.next();\n            if ( entry.getKey() instanceof String == false )\n            {\n                String key = sanitize( entry.getKey() );\n                if ( !properties.containsKey( key ) )\n                {\n                    sanitizedEntries.setProperty( key, sanitize( entry.getValue() ) );\n                }\n                itr.remove();\n            }\n            else if ( entry.getValue() instanceof String == false )\n            {\n                entry.setValue( sanitize( entry.getValue() ) );\n            }\n        }\n        properties.putAll( sanitizedEntries );\n        return properties;\n    }","id":93419,"modified_method":"protected static Properties sanitize( Properties properties )\n    {\n        // convert any non-String keys/values to Strings\n        Properties sanitizedEntries = new Properties();\n        for ( Iterator<Map.Entry<Object,Object>> itr = properties.entrySet().iterator(); itr.hasNext(); )\n        {\n            Map.Entry<Object,Object> entry = itr.next();\n            if ( entry.getKey() instanceof String == false )\n            {\n                String key = sanitize( entry.getKey() );\n                if ( !properties.containsKey( key ) )\n                {\n                    sanitizedEntries.setProperty( key, sanitize( entry.getValue() ) );\n                }\n                itr.remove();\n            }\n            else if ( entry.getValue() instanceof String == false )\n            {\n                entry.setValue( sanitize( entry.getValue() ) );\n            }\n        }\n        properties.putAll( sanitizedEntries );\n        return properties;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected static StringBuilder dumpInstructions( Properties properties, StringBuilder buf )\n    {\n        try\n        {\n            buf.append( \"#-----------------------------------------------------------------------\" + NL );\n            Properties stringProperties = new Properties();\n            for ( Enumeration e = properties.propertyNames(); e.hasMoreElements(); )\n            {\n                // we can only store String properties\n                String key = ( String ) e.nextElement();\n                String value = properties.getProperty( key );\n                if ( value != null )\n                {\n                    stringProperties.setProperty( key, value );\n                }\n            }\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            stringProperties.store( out, null ); // properties encoding is 8859_1\n            buf.append( out.toString( \"8859_1\" ) );\n            buf.append( \"#-----------------------------------------------------------------------\" + NL );\n        }\n        catch ( Throwable e )\n        {\n            // ignore...\n        }\n        return buf;\n    }","id":93420,"modified_method":"protected static StringBuilder dumpInstructions( Properties properties, StringBuilder buf )\n    {\n        try\n        {\n            buf.append( \"#-----------------------------------------------------------------------\" + NL );\n            Properties stringProperties = new Properties();\n            for ( Enumeration<String> e = (Enumeration<String>) properties.propertyNames(); e.hasMoreElements(); )\n            {\n                // we can only store String properties\n                String key = e.nextElement();\n                String value = properties.getProperty( key );\n                if ( value != null )\n                {\n                    stringProperties.setProperty( key, value );\n                }\n            }\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            stringProperties.store( out, null ); // properties encoding is 8859_1\n            buf.append( out.toString( \"8859_1\" ) );\n            buf.append( \"#-----------------------------------------------------------------------\" + NL );\n        }\n        catch ( Throwable e )\n        {\n            // ignore...\n        }\n        return buf;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected static Map transformDirectives( Map originalInstructions )\n    {\n        Map transformedInstructions = new LinkedHashMap();\n        for ( Iterator i = originalInstructions.entrySet().iterator(); i.hasNext(); )\n        {\n            Map.Entry e = ( Map.Entry ) i.next();\n\n            String key = ( String ) e.getKey();\n            if ( key.startsWith( \"_\" ) )\n            {\n                key = \"-\" + key.substring( 1 );\n            }\n\n            String value = ( String ) e.getValue();\n            if ( null == value )\n            {\n                value = \"\";\n            }\n            else\n            {\n                value = value.replaceAll( \"\\\\p{Blank}*[\\r\\n]\\\\p{Blank}*\", \"\" );\n            }\n\n            if ( Analyzer.WAB.equals( key ) && value.length() == 0 )\n            {\n                // provide useful default\n                value = \"src/main/webapp/\";\n            }\n\n            transformedInstructions.put( key, value );\n        }\n        return transformedInstructions;\n    }","id":93421,"modified_method":"protected static Map<String, String> transformDirectives( Map<String, String> originalInstructions )\n    {\n        Map<String, String> transformedInstructions = new LinkedHashMap<String, String>();\n        for ( Iterator<Map.Entry<String, String>> i = originalInstructions.entrySet().iterator(); i.hasNext(); )\n        {\n            Map.Entry<String, String> e = i.next();\n\n            String key = e.getKey();\n            if ( key.startsWith( \"_\" ) )\n            {\n                key = \"-\" + key.substring( 1 );\n            }\n\n            String value = e.getValue();\n            if ( null == value )\n            {\n                value = \"\";\n            }\n            else\n            {\n                value = value.replaceAll( \"\\\\p{Blank}*[\\r\\n]\\\\p{Blank}*\", \"\" );\n            }\n\n            if ( Analyzer.WAB.equals( key ) && value.length() == 0 )\n            {\n                // provide useful default\n                value = \"src/main/webapp/\";\n            }\n\n            transformedInstructions.put( key, value );\n        }\n        return transformedInstructions;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected void addMavenInstructions( MavenProject currentProject, Builder builder ) throws Exception\n    {\n        if ( currentProject.getBasedir() != null )\n        {\n            // update BND instructions to add included Maven resources\n            includeMavenResources( currentProject, builder, getLog() );\n\n            // calculate default export/private settings based on sources\n            addLocalPackages( outputDirectory, builder );\n\n            // tell BND where the current project source resides\n            addMavenSourcePath( currentProject, builder, getLog() );\n        }\n\n        // update BND instructions to embed selected Maven dependencies\n        Collection embeddableArtifacts = getEmbeddableArtifacts( currentProject, builder );\n        new DependencyEmbedder( getLog(), embeddableArtifacts ).processHeaders( builder );\n\n        if ( dumpInstructions != null || getLog().isDebugEnabled() )\n        {\n            StringBuilder buf = new StringBuilder();\n            getLog().debug( \"BND Instructions:\" + NL + dumpInstructions( builder.getProperties(), buf ) );\n            if ( dumpInstructions != null )\n            {\n                getLog().info( \"Writing BND instructions to \" + dumpInstructions );\n                dumpInstructions.getParentFile().mkdirs();\n                FileUtils.fileWrite( dumpInstructions, \"# BND instructions\" + NL + buf );\n            }\n        }\n\n        if ( dumpClasspath != null || getLog().isDebugEnabled() )\n        {\n            StringBuilder buf = new StringBuilder();\n            getLog().debug( \"BND Classpath:\" + NL + dumpClasspath( builder.getClasspath(), buf ) );\n            if ( dumpClasspath != null )\n            {\n                getLog().info( \"Writing BND classpath to \" + dumpClasspath );\n                dumpClasspath.getParentFile().mkdirs();\n                FileUtils.fileWrite( dumpClasspath, \"# BND classpath\" + NL + buf );\n            }\n        }\n    }","id":93422,"modified_method":"protected void addMavenInstructions( MavenProject currentProject, Builder builder ) throws Exception\n    {\n        if ( currentProject.getBasedir() != null )\n        {\n            // update BND instructions to add included Maven resources\n            includeMavenResources( currentProject, builder, getLog() );\n\n            // calculate default export/private settings based on sources\n            addLocalPackages( outputDirectory, builder );\n\n            // tell BND where the current project source resides\n            addMavenSourcePath( currentProject, builder, getLog() );\n        }\n\n        // update BND instructions to embed selected Maven dependencies\n        Collection<Artifact> embeddableArtifacts = getEmbeddableArtifacts( currentProject, builder );\n        new DependencyEmbedder( getLog(), embeddableArtifacts ).processHeaders( builder );\n\n        if ( dumpInstructions != null || getLog().isDebugEnabled() )\n        {\n            StringBuilder buf = new StringBuilder();\n            getLog().debug( \"BND Instructions:\" + NL + dumpInstructions( builder.getProperties(), buf ) );\n            if ( dumpInstructions != null )\n            {\n                getLog().info( \"Writing BND instructions to \" + dumpInstructions );\n                dumpInstructions.getParentFile().mkdirs();\n                FileUtils.fileWrite( dumpInstructions, \"# BND instructions\" + NL + buf );\n            }\n        }\n\n        if ( dumpClasspath != null || getLog().isDebugEnabled() )\n        {\n            StringBuilder buf = new StringBuilder();\n            getLog().debug( \"BND Classpath:\" + NL + dumpClasspath( builder.getClasspath(), buf ) );\n            if ( dumpClasspath != null )\n            {\n                getLog().info( \"Writing BND classpath to \" + dumpClasspath );\n                dumpClasspath.getParentFile().mkdirs();\n                FileUtils.fileWrite( dumpClasspath, \"# BND classpath\" + NL + buf );\n            }\n        }\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected static StringBuilder dumpClasspath( List classpath, StringBuilder buf )\n    {\n        try\n        {\n            buf.append( \"#-----------------------------------------------------------------------\" + NL );\n            buf.append( \"-classpath:\\\\\" + NL );\n            for ( Iterator i = classpath.iterator(); i.hasNext(); )\n            {\n                File path = ( ( Jar ) i.next() ).getSource();\n                if ( path != null )\n                {\n                    buf.append( ' ' + path.toString() + ( i.hasNext() ? \",\\\\\" : \"\" ) + NL );\n                }\n            }\n            buf.append( \"#-----------------------------------------------------------------------\" + NL );\n        }\n        catch ( Throwable e )\n        {\n            // ignore...\n        }\n        return buf;\n    }","id":93423,"modified_method":"protected static StringBuilder dumpClasspath( List<Jar> classpath, StringBuilder buf )\n    {\n        try\n        {\n            buf.append( \"#-----------------------------------------------------------------------\" + NL );\n            buf.append( \"-classpath:\\\\\" + NL );\n            for ( Iterator<Jar> i = classpath.iterator(); i.hasNext(); )\n            {\n                File path = i.next().getSource();\n                if ( path != null )\n                {\n                    buf.append( ' ' + path.toString() + ( i.hasNext() ? \",\\\\\" : \"\" ) + NL );\n                }\n            }\n            buf.append( \"#-----------------------------------------------------------------------\" + NL );\n        }\n        catch ( Throwable e )\n        {\n            // ignore...\n        }\n        return buf;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected static String getMavenResourcePaths( MavenProject currentProject, boolean test )\n    {\n        final String basePath = currentProject.getBasedir().getAbsolutePath();\n\n        Set pathSet = new LinkedHashSet();\n        for ( Iterator i = getMavenResources( currentProject, test ).iterator(); i.hasNext(); )\n        {\n            Resource resource = ( Resource ) i.next();\n\n            final String sourcePath = resource.getDirectory();\n            final String targetPath = resource.getTargetPath();\n\n            // ignore empty or non-local resources\n            if ( new File( sourcePath ).exists() && ( ( targetPath == null ) || ( targetPath.indexOf( \"..\" ) < 0 ) ) )\n            {\n                DirectoryScanner scanner = new DirectoryScanner();\n\n                scanner.setBasedir( sourcePath );\n                if ( resource.getIncludes() != null && !resource.getIncludes().isEmpty() )\n                {\n                    scanner.setIncludes( ( String[] ) resource.getIncludes().toArray( EMPTY_STRING_ARRAY ) );\n                }\n                else\n                {\n                    scanner.setIncludes( DEFAULT_INCLUDES );\n                }\n\n                if ( resource.getExcludes() != null && !resource.getExcludes().isEmpty() )\n                {\n                    scanner.setExcludes( ( String[] ) resource.getExcludes().toArray( EMPTY_STRING_ARRAY ) );\n                }\n\n                scanner.addDefaultExcludes();\n                scanner.scan();\n\n                List includedFiles = Arrays.asList( scanner.getIncludedFiles() );\n\n                for ( Iterator j = includedFiles.iterator(); j.hasNext(); )\n                {\n                    String name = ( String ) j.next();\n                    String path = sourcePath + '/' + name;\n\n                    // make relative to project\n                    if ( path.startsWith( basePath ) )\n                    {\n                        if ( path.length() == basePath.length() )\n                        {\n                            path = \".\";\n                        }\n                        else\n                        {\n                            path = path.substring( basePath.length() + 1 );\n                        }\n                    }\n\n                    // replace windows backslash with a slash\n                    // this is a workaround for a problem with bnd 0.0.189\n                    if ( File.separatorChar != '/' )\n                    {\n                        name = name.replace( File.separatorChar, '/' );\n                        path = path.replace( File.separatorChar, '/' );\n                    }\n\n                    // copy to correct place\n                    path = name + '=' + path;\n                    if ( targetPath != null )\n                    {\n                        path = targetPath + '/' + path;\n                    }\n\n                    // use Bnd filtering?\n                    if ( resource.isFiltering() )\n                    {\n                        path = '{' + path + '}';\n                    }\n\n                    pathSet.add( path );\n                }\n            }\n        }\n\n        StringBuffer resourcePaths = new StringBuffer();\n        for ( Iterator i = pathSet.iterator(); i.hasNext(); )\n        {\n            resourcePaths.append( i.next() );\n            if ( i.hasNext() )\n            {\n                resourcePaths.append( ',' );\n            }\n        }\n\n        return resourcePaths.toString();\n    }","id":93424,"modified_method":"protected static String getMavenResourcePaths( MavenProject currentProject, boolean test )\n    {\n        final String basePath = currentProject.getBasedir().getAbsolutePath();\n\n        Set<String> pathSet = new LinkedHashSet<String>();\n        for ( Iterator<Resource> i = getMavenResources( currentProject, test ).iterator(); i.hasNext(); )\n        {\n            Resource resource = i.next();\n\n            final String sourcePath = resource.getDirectory();\n            final String targetPath = resource.getTargetPath();\n\n            // ignore empty or non-local resources\n            if ( new File( sourcePath ).exists() && ( ( targetPath == null ) || ( targetPath.indexOf( \"..\" ) < 0 ) ) )\n            {\n                DirectoryScanner scanner = new DirectoryScanner();\n\n                scanner.setBasedir( sourcePath );\n                if ( resource.getIncludes() != null && !resource.getIncludes().isEmpty() )\n                {\n                    scanner.setIncludes( ( String[] ) resource.getIncludes().toArray( EMPTY_STRING_ARRAY ) );\n                }\n                else\n                {\n                    scanner.setIncludes( DEFAULT_INCLUDES );\n                }\n\n                if ( resource.getExcludes() != null && !resource.getExcludes().isEmpty() )\n                {\n                    scanner.setExcludes( ( String[] ) resource.getExcludes().toArray( EMPTY_STRING_ARRAY ) );\n                }\n\n                scanner.addDefaultExcludes();\n                scanner.scan();\n\n                List<String> includedFiles = Arrays.asList( scanner.getIncludedFiles() );\n\n                for ( Iterator<String> j = includedFiles.iterator(); j.hasNext(); )\n                {\n                    String name = j.next();\n                    String path = sourcePath + '/' + name;\n\n                    // make relative to project\n                    if ( path.startsWith( basePath ) )\n                    {\n                        if ( path.length() == basePath.length() )\n                        {\n                            path = \".\";\n                        }\n                        else\n                        {\n                            path = path.substring( basePath.length() + 1 );\n                        }\n                    }\n\n                    // replace windows backslash with a slash\n                    // this is a workaround for a problem with bnd 0.0.189\n                    if ( File.separatorChar != '/' )\n                    {\n                        name = name.replace( File.separatorChar, '/' );\n                        path = path.replace( File.separatorChar, '/' );\n                    }\n\n                    // copy to correct place\n                    path = name + '=' + path;\n                    if ( targetPath != null )\n                    {\n                        path = targetPath + '/' + path;\n                    }\n\n                    // use Bnd filtering?\n                    if ( resource.isFiltering() )\n                    {\n                        path = '{' + path + '}';\n                    }\n\n                    pathSet.add( path );\n                }\n            }\n        }\n\n        StringBuffer resourcePaths = new StringBuffer();\n        for ( Iterator<String> i = pathSet.iterator(); i.hasNext(); )\n        {\n            resourcePaths.append( i.next() );\n            if ( i.hasNext() )\n            {\n                resourcePaths.append( ',' );\n            }\n        }\n\n        return resourcePaths.toString();\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"private static Map getProperties( Model projectModel, String prefix )\n    {\n        Map properties = new LinkedHashMap();\n        Method methods[] = Model.class.getDeclaredMethods();\n        for ( int i = 0; i < methods.length; i++ )\n        {\n            String name = methods[i].getName();\n            if ( name.startsWith( \"get\" ) )\n            {\n                try\n                {\n                    Object v = methods[i].invoke( projectModel, null );\n                    if ( v != null )\n                    {\n                        name = prefix + Character.toLowerCase( name.charAt( 3 ) ) + name.substring( 4 );\n                        if ( v.getClass().isArray() )\n                            properties.put( name, Arrays.asList( ( Object[] ) v ).toString() );\n                        else\n                            properties.put( name, v );\n\n                    }\n                }\n                catch ( Exception e )\n                {\n                    // too bad\n                }\n            }\n        }\n        return properties;\n    }","id":93425,"modified_method":"private static Map<String, String> getProperties( Model projectModel, String prefix )\n    {\n        Map<String, String> properties = new LinkedHashMap<String, String>();\n        Method methods[] = Model.class.getDeclaredMethods();\n        for ( int i = 0; i < methods.length; i++ )\n        {\n            String name = methods[i].getName();\n            if ( name.startsWith( \"get\" ) )\n            {\n                try\n                {\n                    Object v = methods[i].invoke( projectModel, null );\n                    if ( v != null )\n                    {\n                        name = prefix + Character.toLowerCase( name.charAt( 3 ) ) + name.substring( 4 );\n                        if ( v.getClass().isArray() )\n                            properties.put( name, Arrays.asList( ( Object[] ) v ).toString() );\n                        else\n                            properties.put( name, v.toString() );\n\n                    }\n                }\n                catch ( Exception e )\n                {\n                    // too bad\n                }\n            }\n        }\n        return properties;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected Properties getDefaultProperties( MavenProject currentProject )\n    {\n        Properties properties = new Properties();\n\n        String bsn;\n        try\n        {\n            bsn = getMaven2OsgiConverter().getBundleSymbolicName( currentProject.getArtifact() );\n        }\n        catch ( Exception e )\n        {\n            bsn = currentProject.getGroupId() + \".\" + currentProject.getArtifactId();\n        }\n\n        // Setup defaults\n        properties.put( MAVEN_SYMBOLICNAME, bsn );\n        properties.put( Analyzer.BUNDLE_SYMBOLICNAME, bsn );\n        properties.put( Analyzer.IMPORT_PACKAGE, \"*\" );\n        properties.put( Analyzer.BUNDLE_VERSION, getMaven2OsgiConverter().getVersion( currentProject.getVersion() ) );\n\n        // remove the extraneous Include-Resource and Private-Package entries from generated manifest\n        properties.put( Constants.REMOVEHEADERS, Analyzer.INCLUDE_RESOURCE + ',' + Analyzer.PRIVATE_PACKAGE );\n\n        header( properties, Analyzer.BUNDLE_DESCRIPTION, currentProject.getDescription() );\n        StringBuffer licenseText = printLicenses( currentProject.getLicenses() );\n        if ( licenseText != null )\n        {\n            header( properties, Analyzer.BUNDLE_LICENSE, licenseText );\n        }\n        header( properties, Analyzer.BUNDLE_NAME, currentProject.getName() );\n\n        if ( currentProject.getOrganization() != null )\n        {\n            if ( currentProject.getOrganization().getName() != null )\n            {\n                String organizationName = currentProject.getOrganization().getName();\n                header( properties, Analyzer.BUNDLE_VENDOR, organizationName );\n                properties.put( \"project.organization.name\", organizationName );\n                properties.put( \"pom.organization.name\", organizationName );\n            }\n            if ( currentProject.getOrganization().getUrl() != null )\n            {\n                String organizationUrl = currentProject.getOrganization().getUrl();\n                header( properties, Analyzer.BUNDLE_DOCURL, organizationUrl );\n                properties.put( \"project.organization.url\", organizationUrl );\n                properties.put( \"pom.organization.url\", organizationUrl );\n            }\n        }\n\n        properties.putAll( currentProject.getProperties() );\n        properties.putAll( currentProject.getModel().getProperties() );\n\n        for ( Iterator i = currentProject.getFilters().iterator(); i.hasNext(); )\n        {\n            File filterFile = new File( ( String ) i.next() );\n            if ( filterFile.isFile() )\n            {\n                properties.putAll( PropertyUtils.loadProperties( filterFile ) );\n            }\n        }\n\n        if ( m_mavenSession != null )\n        {\n            try\n            {\n                // don't pass upper-case session settings to bnd as they end up in the manifest\n                Properties sessionProperties = m_mavenSession.getExecutionProperties();\n                for ( Enumeration e = sessionProperties.propertyNames(); e.hasMoreElements(); )\n                {\n                    String key = ( String ) e.nextElement();\n                    if ( key.length() > 0 && !Character.isUpperCase( key.charAt( 0 ) ) )\n                    {\n                        properties.put( key, sessionProperties.getProperty( key ) );\n                    }\n                }\n            }\n            catch ( Exception e )\n            {\n                getLog().warn( \"Problem with Maven session properties: \" + e.getLocalizedMessage() );\n            }\n        }\n\n        properties.putAll( getProperties( currentProject.getModel(), \"project.build.\" ) );\n        properties.putAll( getProperties( currentProject.getModel(), \"pom.\" ) );\n        properties.putAll( getProperties( currentProject.getModel(), \"project.\" ) );\n\n        properties.put( \"project.baseDir\", getBase( currentProject ) );\n        properties.put( \"project.build.directory\", getBuildDirectory() );\n        properties.put( \"project.build.outputdirectory\", getOutputDirectory() );\n\n        properties.put( \"classifier\", classifier == null ? \"\" : classifier );\n\n        // Add default plugins\n        header( properties, Analyzer.PLUGIN, ScrPlugin.class.getName() + \",\"\n                                           + BlueprintPlugin.class.getName() + \",\"\n                                           + SpringXMLType.class.getName() );\n\n        return properties;\n    }","id":93426,"modified_method":"protected Properties getDefaultProperties( MavenProject currentProject )\n    {\n        Properties properties = new Properties();\n\n        String bsn;\n        try\n        {\n            bsn = getMaven2OsgiConverter().getBundleSymbolicName( currentProject.getArtifact() );\n        }\n        catch ( Exception e )\n        {\n            bsn = currentProject.getGroupId() + \".\" + currentProject.getArtifactId();\n        }\n\n        // Setup defaults\n        properties.put( MAVEN_SYMBOLICNAME, bsn );\n        properties.put( Analyzer.BUNDLE_SYMBOLICNAME, bsn );\n        properties.put( Analyzer.IMPORT_PACKAGE, \"*\" );\n        properties.put( Analyzer.BUNDLE_VERSION, getMaven2OsgiConverter().getVersion( currentProject.getVersion() ) );\n\n        // remove the extraneous Include-Resource and Private-Package entries from generated manifest\n        properties.put( Constants.REMOVEHEADERS, Analyzer.INCLUDE_RESOURCE + ',' + Analyzer.PRIVATE_PACKAGE );\n\n        header( properties, Analyzer.BUNDLE_DESCRIPTION, currentProject.getDescription() );\n        StringBuffer licenseText = printLicenses( currentProject.getLicenses() );\n        if ( licenseText != null )\n        {\n            header( properties, Analyzer.BUNDLE_LICENSE, licenseText );\n        }\n        header( properties, Analyzer.BUNDLE_NAME, currentProject.getName() );\n\n        if ( currentProject.getOrganization() != null )\n        {\n            if ( currentProject.getOrganization().getName() != null )\n            {\n                String organizationName = currentProject.getOrganization().getName();\n                header( properties, Analyzer.BUNDLE_VENDOR, organizationName );\n                properties.put( \"project.organization.name\", organizationName );\n                properties.put( \"pom.organization.name\", organizationName );\n            }\n            if ( currentProject.getOrganization().getUrl() != null )\n            {\n                String organizationUrl = currentProject.getOrganization().getUrl();\n                header( properties, Analyzer.BUNDLE_DOCURL, organizationUrl );\n                properties.put( \"project.organization.url\", organizationUrl );\n                properties.put( \"pom.organization.url\", organizationUrl );\n            }\n        }\n\n        properties.putAll( currentProject.getProperties() );\n        properties.putAll( currentProject.getModel().getProperties() );\n\n        for ( Iterator<String> i = currentProject.getFilters().iterator(); i.hasNext(); )\n        {\n            File filterFile = new File( i.next() );\n            if ( filterFile.isFile() )\n            {\n                properties.putAll( PropertyUtils.loadProperties( filterFile ) );\n            }\n        }\n\n        if ( m_mavenSession != null )\n        {\n            try\n            {\n                // don't pass upper-case session settings to bnd as they end up in the manifest\n                Properties sessionProperties = m_mavenSession.getExecutionProperties();\n                for ( Enumeration<String> e = (Enumeration<String>) sessionProperties.propertyNames(); e.hasMoreElements(); )\n                {\n                    String key = e.nextElement();\n                    if ( key.length() > 0 && !Character.isUpperCase( key.charAt( 0 ) ) )\n                    {\n                        properties.put( key, sessionProperties.getProperty( key ) );\n                    }\n                }\n            }\n            catch ( Exception e )\n            {\n                getLog().warn( \"Problem with Maven session properties: \" + e.getLocalizedMessage() );\n            }\n        }\n\n        properties.putAll( getProperties( currentProject.getModel(), \"project.build.\" ) );\n        properties.putAll( getProperties( currentProject.getModel(), \"pom.\" ) );\n        properties.putAll( getProperties( currentProject.getModel(), \"project.\" ) );\n\n        properties.put( \"project.baseDir\", getBase( currentProject ) );\n        properties.put( \"project.build.directory\", getBuildDirectory() );\n        properties.put( \"project.build.outputdirectory\", getOutputDirectory() );\n\n        properties.put( \"classifier\", classifier == null ? \"\" : classifier );\n\n        // Add default plugins\n        header( properties, Analyzer.PLUGIN, ScrPlugin.class.getName() + \",\"\n                                           + BlueprintPlugin.class.getName() + \",\"\n                                           + SpringXMLType.class.getName() );\n\n        return properties;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected Collection getEmbeddableArtifacts( MavenProject currentProject, Analyzer analyzer )\n        throws MojoExecutionException\n    {\n        final Collection artifacts;\n\n        String embedTransitive = analyzer.getProperty( DependencyEmbedder.EMBED_TRANSITIVE );\n        if ( Boolean.valueOf( embedTransitive ).booleanValue() )\n        {\n            // includes transitive dependencies\n            artifacts = currentProject.getArtifacts();\n        }\n        else\n        {\n            // only includes direct dependencies\n            artifacts = currentProject.getDependencyArtifacts();\n        }\n\n        return getSelectedDependencies( artifacts );\n    }","id":93427,"modified_method":"protected Collection<Artifact> getEmbeddableArtifacts( MavenProject currentProject, Analyzer analyzer )\n        throws MojoExecutionException\n    {\n        final Collection<Artifact> artifacts;\n\n        String embedTransitive = analyzer.getProperty( DependencyEmbedder.EMBED_TRANSITIVE );\n        if ( Boolean.valueOf( embedTransitive ).booleanValue() )\n        {\n            // includes transitive dependencies\n            artifacts = currentProject.getArtifacts();\n        }\n        else\n        {\n            // only includes direct dependencies\n            artifacts = currentProject.getDependencyArtifacts();\n        }\n\n        return getSelectedDependencies( artifacts );\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected static void addMavenSourcePath( MavenProject currentProject, Analyzer analyzer, Log log )\n    {\n        // pass maven source paths onto BND analyzer\n        StringBuilder mavenSourcePaths = new StringBuilder();\n        StringBuilder mavenTestSourcePaths = new StringBuilder();\n        Map<StringBuilder, List<?>> map = new HashMap<StringBuilder, List<?>>(2);\n        map.put(mavenSourcePaths, currentProject.getCompileSourceRoots() );\n        map.put(mavenTestSourcePaths, currentProject.getTestCompileSourceRoots() );\n        for ( Map.Entry<StringBuilder, List<?>> entry : map.entrySet() )\n        {\n            List<?> compileSourceRoots = entry.getValue();\n            if ( compileSourceRoots != null )\n            {\n                StringBuilder sourcePaths = entry.getKey();\n                for ( Iterator i = compileSourceRoots.iterator(); i.hasNext(); )\n                {\n                    if ( sourcePaths.length() > 0 )\n                    {\n                        sourcePaths.append( ',' );\n                    }\n                    sourcePaths.append( ( String ) i.next() );\n                }\n            }\n        }\n        final String sourcePath = analyzer.getProperty( Analyzer.SOURCEPATH );\n        if ( sourcePath != null )\n        {\n            if ( sourcePath.contains(MAVEN_SOURCES) || sourcePath.contains(MAVEN_TEST_RESOURCES) )\n            {\n                String combinedSource = StringUtils.replace( sourcePath, MAVEN_SOURCES, mavenSourcePaths.toString() );\n                combinedSource = StringUtils.replace( combinedSource, MAVEN_TEST_SOURCES, mavenTestSourcePaths.toString() );\n                if ( combinedSource.length() > 0 )\n                {\n                    analyzer.setProperty( Analyzer.SOURCEPATH, combinedSource );\n                }\n                else\n                {\n                    analyzer.unsetProperty( Analyzer.SOURCEPATH );\n                }\n            }\n            else if ( mavenSourcePaths.length() > 0 )\n            {\n                log.warn( Analyzer.SOURCEPATH + \": overriding \" + mavenSourcePaths + \" with \" + sourcePath + \" (add \"\n                    + MAVEN_SOURCES + \" if you want to include the maven sources)\" );\n            }\n            else if ( mavenTestSourcePaths.length() > 0 )\n            {\n                log.warn( Analyzer.SOURCEPATH + \": overriding \" + mavenTestSourcePaths + \" with \" + sourcePath + \" (add \"\n                        + MAVEN_TEST_SOURCES + \" if you want to include the maven sources)\" );\n            }\n        }\n        else if ( mavenSourcePaths.length() > 0 )\n        {\n            analyzer.setProperty( Analyzer.SOURCEPATH, mavenSourcePaths.toString() );\n        }\n    }","id":93428,"modified_method":"protected static void addMavenSourcePath( MavenProject currentProject, Analyzer analyzer, Log log )\n    {\n        // pass maven source paths onto BND analyzer\n        StringBuilder mavenSourcePaths = new StringBuilder();\n        StringBuilder mavenTestSourcePaths = new StringBuilder();\n        Map<StringBuilder, List<String>> map = new HashMap<StringBuilder, List<String>>(2);\n        map.put(mavenSourcePaths, currentProject.getCompileSourceRoots() );\n        map.put(mavenTestSourcePaths, currentProject.getTestCompileSourceRoots() );\n        for ( Map.Entry<StringBuilder, List<String>> entry : map.entrySet() )\n        {\n            List<String> compileSourceRoots = entry.getValue();\n            if ( compileSourceRoots != null )\n            {\n                StringBuilder sourcePaths = entry.getKey();\n                for ( Iterator<String> i = compileSourceRoots.iterator(); i.hasNext(); )\n                {\n                    if ( sourcePaths.length() > 0 )\n                    {\n                        sourcePaths.append( ',' );\n                    }\n                    sourcePaths.append( i.next() );\n                }\n            }\n        }\n        final String sourcePath = analyzer.getProperty( Analyzer.SOURCEPATH );\n        if ( sourcePath != null )\n        {\n            if ( sourcePath.contains(MAVEN_SOURCES) || sourcePath.contains(MAVEN_TEST_RESOURCES) )\n            {\n                String combinedSource = StringUtils.replace( sourcePath, MAVEN_SOURCES, mavenSourcePaths.toString() );\n                combinedSource = StringUtils.replace( combinedSource, MAVEN_TEST_SOURCES, mavenTestSourcePaths.toString() );\n                if ( combinedSource.length() > 0 )\n                {\n                    analyzer.setProperty( Analyzer.SOURCEPATH, combinedSource );\n                }\n                else\n                {\n                    analyzer.unsetProperty( Analyzer.SOURCEPATH );\n                }\n            }\n            else if ( mavenSourcePaths.length() > 0 )\n            {\n                log.warn( Analyzer.SOURCEPATH + \": overriding \" + mavenSourcePaths + \" with \" + sourcePath + \" (add \"\n                    + MAVEN_SOURCES + \" if you want to include the maven sources)\" );\n            }\n            else if ( mavenTestSourcePaths.length() > 0 )\n            {\n                log.warn( Analyzer.SOURCEPATH + \": overriding \" + mavenTestSourcePaths + \" with \" + sourcePath + \" (add \"\n                        + MAVEN_TEST_SOURCES + \" if you want to include the maven sources)\" );\n            }\n        }\n        else if ( mavenSourcePaths.length() > 0 )\n        {\n            analyzer.setProperty( Analyzer.SOURCEPATH, mavenSourcePaths.toString() );\n        }\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected void execute( MavenProject currentProject, Map originalInstructions, Properties properties,\n        Jar[] classpath ) throws MojoExecutionException\n    {\n        try\n        {\n            File jarFile = new File( getBuildDirectory(), getBundleName( currentProject ) );\n            Builder builder = buildOSGiBundle( currentProject, originalInstructions, properties, classpath );\n            boolean hasErrors = reportErrors( \"Bundle \" + currentProject.getArtifact(), builder );\n            if ( hasErrors )\n            {\n                String failok = builder.getProperty( \"-failok\" );\n                if ( null == failok || \"false\".equalsIgnoreCase( failok ) )\n                {\n                    jarFile.delete();\n\n                    throw new MojoFailureException( \"Error(s) found in bundle configuration\" );\n                }\n            }\n\n            // attach bundle to maven project\n            jarFile.getParentFile().mkdirs();\n            builder.getJar().write( jarFile );\n\n            Artifact mainArtifact = currentProject.getArtifact();\n\n            if ( \"bundle\".equals( mainArtifact.getType() ) )\n            {\n                // workaround for MNG-1682: force maven to install artifact using the \"jar\" handler\n                mainArtifact.setArtifactHandler( m_artifactHandlerManager.getArtifactHandler( \"jar\" ) );\n            }\n\n            boolean customClassifier = null != classifier && classifier.trim().length() > 0;\n            boolean customPackaging = null != packaging && packaging.trim().length() > 0;\n\n            if ( customClassifier && customPackaging )\n            {\n                m_projectHelper.attachArtifact( currentProject, packaging, classifier, jarFile );\n            }\n            else if ( customClassifier )\n            {\n                m_projectHelper.attachArtifact( currentProject, jarFile, classifier );\n            }\n            else if ( customPackaging )\n            {\n                m_projectHelper.attachArtifact( currentProject, packaging, jarFile );\n            }\n            else\n            {\n                mainArtifact.setFile( jarFile );\n            }\n\n            if ( unpackBundle )\n            {\n                unpackBundle( jarFile );\n            }\n\n            if ( manifestLocation != null )\n            {\n                File outputFile = new File( manifestLocation, \"MANIFEST.MF\" );\n\n                try\n                {\n                    Manifest manifest = builder.getJar().getManifest();\n                    ManifestPlugin.writeManifest( manifest, outputFile, niceManifest );\n                }\n                catch ( IOException e )\n                {\n                    getLog().error( \"Error trying to write Manifest to file \" + outputFile, e );\n                }\n            }\n\n            // cleanup...\n            builder.close();\n        }\n        catch ( MojoFailureException e )\n        {\n            getLog().error( e.getLocalizedMessage() );\n            throw new MojoExecutionException( \"Error(s) found in bundle configuration\", e );\n        }\n        catch ( Exception e )\n        {\n            getLog().error( \"An internal error occurred\", e );\n            throw new MojoExecutionException( \"Internal error in maven-bundle-plugin\", e );\n        }\n    }","id":93429,"modified_method":"protected void execute( MavenProject currentProject, Map<String, String> originalInstructions, Properties properties,\n        Jar[] classpath ) throws MojoExecutionException\n    {\n        try\n        {\n            File jarFile = new File( getBuildDirectory(), getBundleName( currentProject ) );\n            Builder builder = buildOSGiBundle( currentProject, originalInstructions, properties, classpath );\n            boolean hasErrors = reportErrors( \"Bundle \" + currentProject.getArtifact(), builder );\n            if ( hasErrors )\n            {\n                String failok = builder.getProperty( \"-failok\" );\n                if ( null == failok || \"false\".equalsIgnoreCase( failok ) )\n                {\n                    jarFile.delete();\n\n                    throw new MojoFailureException( \"Error(s) found in bundle configuration\" );\n                }\n            }\n\n            // attach bundle to maven project\n            jarFile.getParentFile().mkdirs();\n            builder.getJar().write( jarFile );\n\n            Artifact mainArtifact = currentProject.getArtifact();\n\n            if ( \"bundle\".equals( mainArtifact.getType() ) )\n            {\n                // workaround for MNG-1682: force maven to install artifact using the \"jar\" handler\n                mainArtifact.setArtifactHandler( m_artifactHandlerManager.getArtifactHandler( \"jar\" ) );\n            }\n\n            boolean customClassifier = null != classifier && classifier.trim().length() > 0;\n            boolean customPackaging = null != packaging && packaging.trim().length() > 0;\n\n            if ( customClassifier && customPackaging )\n            {\n                m_projectHelper.attachArtifact( currentProject, packaging, classifier, jarFile );\n            }\n            else if ( customClassifier )\n            {\n                m_projectHelper.attachArtifact( currentProject, jarFile, classifier );\n            }\n            else if ( customPackaging )\n            {\n                m_projectHelper.attachArtifact( currentProject, packaging, jarFile );\n            }\n            else\n            {\n                mainArtifact.setFile( jarFile );\n            }\n\n            if ( unpackBundle )\n            {\n                unpackBundle( jarFile );\n            }\n\n            if ( manifestLocation != null )\n            {\n                File outputFile = new File( manifestLocation, \"MANIFEST.MF\" );\n\n                try\n                {\n                    Manifest manifest = builder.getJar().getManifest();\n                    ManifestPlugin.writeManifest( manifest, outputFile, niceManifest );\n                }\n                catch ( IOException e )\n                {\n                    getLog().error( \"Error trying to write Manifest to file \" + outputFile, e );\n                }\n            }\n\n            // cleanup...\n            builder.close();\n        }\n        catch ( MojoFailureException e )\n        {\n            getLog().error( e.getLocalizedMessage() );\n            throw new MojoExecutionException( \"Error(s) found in bundle configuration\", e );\n        }\n        catch ( Exception e )\n        {\n            getLog().error( \"An internal error occurred\", e );\n            throw new MojoExecutionException( \"Internal error in maven-bundle-plugin\", e );\n        }\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected void execute( MavenProject currentProject, Map originalInstructions, Properties properties )\n        throws MojoExecutionException\n    {\n        try\n        {\n            execute( currentProject, originalInstructions, properties, getClasspath( currentProject ) );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error calculating classpath for project \" + currentProject, e );\n        }\n    }","id":93430,"modified_method":"protected void execute( MavenProject currentProject, Map<String, String> originalInstructions, Properties properties )\n        throws MojoExecutionException\n    {\n        try\n        {\n            execute( currentProject, originalInstructions, properties, getClasspath( currentProject ) );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error calculating classpath for project \" + currentProject, e );\n        }\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"private static List getMavenResources( MavenProject currentProject, boolean test )\n    {\n        List resources = new ArrayList( test ? currentProject.getTestResources() : currentProject.getResources() );\n\n        if ( currentProject.getCompileSourceRoots() != null )\n        {\n            // also scan for any \"packageinfo\" files lurking in the source folders\n            List packageInfoIncludes = Collections.singletonList( \"**/packageinfo\" );\n            for ( Iterator i = currentProject.getCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String sourceRoot = ( String ) i.next();\n                Resource packageInfoResource = new Resource();\n                packageInfoResource.setDirectory( sourceRoot );\n                packageInfoResource.setIncludes( packageInfoIncludes );\n                resources.add( packageInfoResource );\n            }\n        }\n\n        return resources;\n    }","id":93431,"modified_method":"private static List<Resource> getMavenResources( MavenProject currentProject, boolean test )\n    {\n        List<Resource> resources = new ArrayList<Resource>( test ? currentProject.getTestResources() : currentProject.getResources() );\n\n        if ( currentProject.getCompileSourceRoots() != null )\n        {\n            // also scan for any \"packageinfo\" files lurking in the source folders\n            final List<String> packageInfoIncludes = Collections.singletonList( \"**/packageinfo\" );\n            for ( Iterator<String> i = currentProject.getCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String sourceRoot = i.next();\n                Resource packageInfoResource = new Resource();\n                packageInfoResource.setDirectory( sourceRoot );\n                packageInfoResource.setIncludes( packageInfoIncludes );\n                resources.add( packageInfoResource );\n            }\n        }\n\n        return resources;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"private Collection getSelectedDependencies( Collection artifacts ) throws MojoExecutionException\n    {\n        if ( null == excludeDependencies || excludeDependencies.length() == 0 )\n        {\n            return artifacts;\n        }\n        else if ( \"true\".equalsIgnoreCase( excludeDependencies ) )\n        {\n            return Collections.EMPTY_LIST;\n        }\n\n        Collection selectedDependencies = new LinkedHashSet( artifacts );\n        DependencyExcluder excluder = new DependencyExcluder( artifacts );\n        excluder.processHeaders( excludeDependencies );\n        selectedDependencies.removeAll( excluder.getExcludedArtifacts() );\n\n        return selectedDependencies;\n    }","id":93432,"modified_method":"private Collection<Artifact> getSelectedDependencies( Collection<Artifact> artifacts ) throws MojoExecutionException\n    {\n        if ( null == excludeDependencies || excludeDependencies.length() == 0 )\n        {\n            return artifacts;\n        }\n        else if ( \"true\".equalsIgnoreCase( excludeDependencies ) )\n        {\n            return Collections.emptyList();\n        }\n\n        Collection<Artifact> selectedDependencies = new LinkedHashSet<Artifact>( artifacts );\n        DependencyExcluder excluder = new DependencyExcluder( artifacts );\n        excluder.processHeaders( excludeDependencies );\n        selectedDependencies.removeAll( excluder.getExcludedArtifacts() );\n\n        return selectedDependencies;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"public void processHeaders( Analyzer analyzer ) throws MojoExecutionException\n    {\n        StringBuffer includeResource = new StringBuffer();\n        StringBuffer bundleClassPath = new StringBuffer();\n        StringBuffer embeddedArtifacts = new StringBuffer();\n\n        m_inlinedPaths.clear();\n        m_embeddedArtifacts.clear();\n\n        String embedDependencyHeader = analyzer.getProperty( EMBED_DEPENDENCY );\n        if ( StringUtils.isNotEmpty( embedDependencyHeader ) )\n        {\n            m_embedDirectory = analyzer.getProperty( EMBED_DIRECTORY );\n            m_embedStripGroup = analyzer.getProperty( EMBED_STRIP_GROUP, \"true\" );\n            m_embedStripVersion = analyzer.getProperty( EMBED_STRIP_VERSION );\n\n            processInstructions( embedDependencyHeader );\n\n            for ( Iterator i = m_inlinedPaths.iterator(); i.hasNext(); )\n            {\n                inlineDependency( ( String ) i.next(), includeResource );\n            }\n            for ( Iterator i = m_embeddedArtifacts.iterator(); i.hasNext(); )\n            {\n                embedDependency( ( Artifact ) i.next(), includeResource, bundleClassPath, embeddedArtifacts );\n            }\n        }\n\n        if ( analyzer.getProperty( Analyzer.WAB ) == null && bundleClassPath.length() > 0 )\n        {\n            // set explicit default before merging dependency classpath\n            if ( analyzer.getProperty( Analyzer.BUNDLE_CLASSPATH ) == null )\n            {\n                analyzer.setProperty( Analyzer.BUNDLE_CLASSPATH, \".\" );\n            }\n        }\n\n        appendDependencies( analyzer, Analyzer.INCLUDE_RESOURCE, includeResource.toString() );\n        appendDependencies( analyzer, Analyzer.BUNDLE_CLASSPATH, bundleClassPath.toString() );\n        appendDependencies( analyzer, EMBEDDED_ARTIFACTS, embeddedArtifacts.toString() );\n    }","id":93433,"modified_method":"public void processHeaders( Analyzer analyzer ) throws MojoExecutionException\n    {\n        StringBuffer includeResource = new StringBuffer();\n        StringBuffer bundleClassPath = new StringBuffer();\n        StringBuffer embeddedArtifacts = new StringBuffer();\n\n        m_inlinedPaths.clear();\n        m_embeddedArtifacts.clear();\n\n        String embedDependencyHeader = analyzer.getProperty( EMBED_DEPENDENCY );\n        if ( StringUtils.isNotEmpty( embedDependencyHeader ) )\n        {\n            m_embedDirectory = analyzer.getProperty( EMBED_DIRECTORY );\n            m_embedStripGroup = analyzer.getProperty( EMBED_STRIP_GROUP, \"true\" );\n            m_embedStripVersion = analyzer.getProperty( EMBED_STRIP_VERSION );\n\n            processInstructions( embedDependencyHeader );\n\n            for ( Iterator<String> i = m_inlinedPaths.iterator(); i.hasNext(); )\n            {\n                inlineDependency( i.next(), includeResource );\n            }\n            for ( Iterator<Artifact> i = m_embeddedArtifacts.iterator(); i.hasNext(); )\n            {\n                embedDependency( i.next(), includeResource, bundleClassPath, embeddedArtifacts );\n            }\n        }\n\n        if ( analyzer.getProperty( Analyzer.WAB ) == null && bundleClassPath.length() > 0 )\n        {\n            // set explicit default before merging dependency classpath\n            if ( analyzer.getProperty( Analyzer.BUNDLE_CLASSPATH ) == null )\n            {\n                analyzer.setProperty( Analyzer.BUNDLE_CLASSPATH, \".\" );\n            }\n        }\n\n        appendDependencies( analyzer, Analyzer.INCLUDE_RESOURCE, includeResource.toString() );\n        appendDependencies( analyzer, Analyzer.BUNDLE_CLASSPATH, bundleClassPath.toString() );\n        appendDependencies( analyzer, EMBEDDED_ARTIFACTS, embeddedArtifacts.toString() );\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"public DependencyEmbedder( Log log, Collection dependencyArtifacts )\n    {\n        super( dependencyArtifacts );\n\n        m_log = log;\n\n        m_inlinedPaths = new LinkedHashSet();\n        m_embeddedArtifacts = new LinkedHashSet();\n    }","id":93434,"modified_method":"public DependencyEmbedder( Log log, Collection<Artifact> dependencyArtifacts )\n    {\n        super( dependencyArtifacts );\n\n        m_inlinedPaths = new LinkedHashSet<String>();\n        m_embeddedArtifacts = new LinkedHashSet<Artifact>();\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"private static void addInlinedPaths( Artifact dependency, String inline, Collection inlinedPaths )\n    {\n        File path = dependency.getFile();\n        if ( null != path && path.exists() )\n        {\n            if ( \"true\".equalsIgnoreCase( inline ) || inline.length() == 0 )\n            {\n                inlinedPaths.add( path.getPath() );\n            }\n            else\n            {\n                String[] filters = inline.split( \"\\\\|\" );\n                for ( int i = 0; i < filters.length; i++ )\n                {\n                    if ( filters[i].length() > 0 )\n                    {\n                        inlinedPaths.add( path + \"!/\" + filters[i] );\n                    }\n                }\n            }\n        }\n    }","id":93435,"modified_method":"private static void addInlinedPaths( Artifact dependency, String inline, Collection<String> inlinedPaths )\n    {\n        File path = dependency.getFile();\n        if ( null != path && path.exists() )\n        {\n            if ( \"true\".equalsIgnoreCase( inline ) || inline.length() == 0 )\n            {\n                inlinedPaths.add( path.getPath() );\n            }\n            else\n            {\n                String[] filters = inline.split( \"\\\\|\" );\n                for ( int i = 0; i < filters.length; i++ )\n                {\n                    if ( filters[i].length() > 0 )\n                    {\n                        inlinedPaths.add( path + \"!/\" + filters[i] );\n                    }\n                }\n            }\n        }\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    protected void processDependencies( Collection dependencies, String inline )\n    {\n        if ( null == inline || \"false\".equalsIgnoreCase( inline ) )\n        {\n            m_embeddedArtifacts.addAll( dependencies );\n        }\n        else\n        {\n            for ( Iterator i = dependencies.iterator(); i.hasNext(); )\n            {\n                addInlinedPaths( ( Artifact ) i.next(), inline, m_inlinedPaths );\n            }\n        }\n    }","id":93436,"modified_method":"@Override\n    protected void processDependencies( Collection<Artifact> dependencies, String inline )\n    {\n        if ( null == inline || \"false\".equalsIgnoreCase( inline ) )\n        {\n            m_embeddedArtifacts.addAll( dependencies );\n        }\n        else\n        {\n            for ( Iterator<Artifact> i = dependencies.iterator(); i.hasNext(); )\n            {\n                addInlinedPaths( i.next(), inline, m_inlinedPaths );\n            }\n        }\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"public DependencyExcluder( Collection dependencyArtifacts )\n    {\n        super( dependencyArtifacts );\n\n        m_excludedArtifacts = new HashSet();\n    }","id":93437,"modified_method":"public DependencyExcluder( Collection<Artifact> dependencyArtifacts )\n    {\n        super( dependencyArtifacts );\n\n        m_excludedArtifacts = new HashSet<Artifact>();\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    protected void processDependencies( Collection dependencies, String inline )\n    {\n        m_excludedArtifacts.addAll( dependencies );\n    }","id":93438,"modified_method":"@Override\n    protected void processDependencies( Collection<Artifact> dependencies, String inline )\n    {\n        m_excludedArtifacts.addAll( dependencies );\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected void execute( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws MojoExecutionException\n    {\n        if ( dumpInstructions == null )\n        {\n            dumpInstructions = new File( getBuildDirectory(), \"instructions.bnd\" );\n        }\n\n        try\n        {\n            addMavenInstructions( project, getOSGiBuilder( project, instructions, properties, classpath ) );\n        }\n        catch ( FileNotFoundException e )\n        {\n            throw new MojoExecutionException( \"Cannot find \" + e.getMessage(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error trying to generate instructions\", e );\n        }\n        catch ( MojoFailureException e )\n        {\n            getLog().error( e.getLocalizedMessage() );\n            throw new MojoExecutionException( \"Error(s) found in instructions\", e );\n        }\n        catch ( Exception e )\n        {\n            getLog().error( \"An internal error occurred\", e );\n            throw new MojoExecutionException( \"Internal error in maven-bundle-plugin\", e );\n        }\n    }","id":93439,"modified_method":"@Override\n    protected void execute( MavenProject project, Map<String, String> instructions, Properties properties, Jar[] classpath )\n        throws MojoExecutionException\n    {\n        if ( dumpInstructions == null )\n        {\n            dumpInstructions = new File( getBuildDirectory(), \"instructions.bnd\" );\n        }\n\n        try\n        {\n            addMavenInstructions( project, getOSGiBuilder( project, instructions, properties, classpath ) );\n        }\n        catch ( FileNotFoundException e )\n        {\n            throw new MojoExecutionException( \"Cannot find \" + e.getMessage(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error trying to generate instructions\", e );\n        }\n        catch ( MojoFailureException e )\n        {\n            getLog().error( e.getLocalizedMessage() );\n            throw new MojoExecutionException( \"Error(s) found in instructions\", e );\n        }\n        catch ( Exception e )\n        {\n            getLog().error( \"An internal error occurred\", e );\n            throw new MojoExecutionException( \"Internal error in maven-bundle-plugin\", e );\n        }\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected Analyzer getAnalyzer( MavenProject project, Jar[] classpath ) throws IOException, MojoExecutionException,\n        Exception\n    {\n        return getAnalyzer( project, new LinkedHashMap(), new Properties(), classpath );\n    }","id":93440,"modified_method":"protected Analyzer getAnalyzer( MavenProject project, Jar[] classpath ) throws IOException, MojoExecutionException,\n        Exception\n    {\n        return getAnalyzer( project, new LinkedHashMap<String, String>(), new Properties(), classpath );\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"public Manifest getManifest( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoFailureException, MojoExecutionException, Exception\n    {\n        Analyzer analyzer = getAnalyzer( project, instructions, properties, classpath );\n        boolean hasErrors = reportErrors( \"Manifest \" + project.getArtifact(), analyzer );\n        if ( hasErrors )\n        {\n            String failok = analyzer.getProperty( \"-failok\" );\n            if ( null == failok || \"false\".equalsIgnoreCase( failok ) )\n            {\n                throw new MojoFailureException( \"Error(s) found in manifest configuration\" );\n            }\n        }\n\n        Jar jar = analyzer.getJar();\n\n        if ( unpackBundle )\n        {\n            File outputFile = getOutputDirectory();\n            for ( Entry<String, Resource> entry : jar.getResources().entrySet() )\n            {\n                File entryFile = new File( outputFile, entry.getKey() );\n                if ( !entryFile.exists() || entry.getValue().lastModified() == 0 )\n                {\n                    entryFile.getParentFile().mkdirs();\n                    OutputStream os = new FileOutputStream( entryFile );\n                    entry.getValue().write( os );\n                    os.close();\n                }\n            }\n        }\n\n        Manifest manifest = jar.getManifest();\n\n        // cleanup...\n        analyzer.close();\n\n        return manifest;\n    }","id":93441,"modified_method":"public Manifest getManifest( MavenProject project, Map<String, String> instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoFailureException, MojoExecutionException, Exception\n    {\n        Analyzer analyzer = getAnalyzer( project, instructions, properties, classpath );\n        boolean hasErrors = reportErrors( \"Manifest \" + project.getArtifact(), analyzer );\n        if ( hasErrors )\n        {\n            String failok = analyzer.getProperty( \"-failok\" );\n            if ( null == failok || \"false\".equalsIgnoreCase( failok ) )\n            {\n                throw new MojoFailureException( \"Error(s) found in manifest configuration\" );\n            }\n        }\n\n        Jar jar = analyzer.getJar();\n\n        if ( unpackBundle )\n        {\n            File outputFile = getOutputDirectory();\n            for ( Entry<String, Resource> entry : jar.getResources().entrySet() )\n            {\n                File entryFile = new File( outputFile, entry.getKey() );\n                if ( !entryFile.exists() || entry.getValue().lastModified() == 0 )\n                {\n                    entryFile.getParentFile().mkdirs();\n                    OutputStream os = new FileOutputStream( entryFile );\n                    entry.getValue().write( os );\n                    os.close();\n                }\n            }\n        }\n\n        Manifest manifest = jar.getManifest();\n\n        // cleanup...\n        analyzer.close();\n\n        return manifest;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"public Manifest getManifest( MavenProject project, Jar[] classpath ) throws IOException, MojoFailureException,\n        MojoExecutionException, Exception\n    {\n        return getManifest( project, new LinkedHashMap(), new Properties(), classpath );\n    }","id":93442,"modified_method":"public Manifest getManifest( MavenProject project, Jar[] classpath ) throws IOException, MojoFailureException,\n        MojoExecutionException, Exception\n    {\n        return getManifest( project, new LinkedHashMap<String, String>(), new Properties(), classpath );\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    protected void execute( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws MojoExecutionException\n    {\n        Manifest manifest;\n        try\n        {\n            manifest = getManifest( project, instructions, properties, classpath );\n        }\n        catch ( FileNotFoundException e )\n        {\n            throw new MojoExecutionException( \"Cannot find \" + e.getMessage()\n                + \" (manifest goal must be run after compile phase)\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error trying to generate Manifest\", e );\n        }\n        catch ( MojoFailureException e )\n        {\n            getLog().error( e.getLocalizedMessage() );\n            throw new MojoExecutionException( \"Error(s) found in manifest configuration\", e );\n        }\n        catch ( Exception e )\n        {\n            getLog().error( \"An internal error occurred\", e );\n            throw new MojoExecutionException( \"Internal error in maven-bundle-plugin\", e );\n        }\n\n        File outputFile = new File( manifestLocation, \"MANIFEST.MF\" );\n\n        try\n        {\n            writeManifest( manifest, outputFile, niceManifest );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error trying to write Manifest to file \" + outputFile, e );\n        }\n    }","id":93443,"modified_method":"@Override\n    protected void execute( MavenProject project, Map<String, String> instructions, Properties properties, Jar[] classpath )\n        throws MojoExecutionException\n    {\n        Manifest manifest;\n        try\n        {\n            manifest = getManifest( project, instructions, properties, classpath );\n        }\n        catch ( FileNotFoundException e )\n        {\n            throw new MojoExecutionException( \"Cannot find \" + e.getMessage()\n                + \" (manifest goal must be run after compile phase)\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error trying to generate Manifest\", e );\n        }\n        catch ( MojoFailureException e )\n        {\n            getLog().error( e.getLocalizedMessage() );\n            throw new MojoExecutionException( \"Error(s) found in manifest configuration\", e );\n        }\n        catch ( Exception e )\n        {\n            getLog().error( \"An internal error occurred\", e );\n            throw new MojoExecutionException( \"Internal error in maven-bundle-plugin\", e );\n        }\n\n        File outputFile = new File( manifestLocation, \"MANIFEST.MF\" );\n\n        try\n        {\n            writeManifest( manifest, outputFile, niceManifest );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error trying to write Manifest to file \" + outputFile, e );\n        }\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"protected Analyzer getAnalyzer( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoExecutionException, Exception\n    {\n        if ( rebuildBundle && supportedProjectTypes.contains( project.getArtifact().getType() ) )\n        {\n            return buildOSGiBundle( project, instructions, properties, classpath );\n        }\n\n        File file = getOutputDirectory();\n        if ( file == null )\n        {\n            file = project.getArtifact().getFile();\n        }\n\n        if ( !file.exists() )\n        {\n            if ( file.equals( getOutputDirectory() ) )\n            {\n                file.mkdirs();\n            }\n            else\n            {\n                throw new FileNotFoundException( file.getPath() );\n            }\n        }\n\n        Builder analyzer = getOSGiBuilder( project, instructions, properties, classpath );\n\n        analyzer.setJar( file );\n\n        // calculateExportsFromContents when we have no explicit instructions defining\n        // the contents of the bundle *and* we are not analyzing the output directory,\n        // otherwise fall-back to addMavenInstructions approach\n\n        boolean isOutputDirectory = file.equals( getOutputDirectory() );\n\n        if ( analyzer.getProperty( Analyzer.EXPORT_PACKAGE ) == null\n            && analyzer.getProperty( Analyzer.EXPORT_CONTENTS ) == null\n            && analyzer.getProperty( Analyzer.PRIVATE_PACKAGE ) == null && !isOutputDirectory )\n        {\n            String export = calculateExportsFromContents( analyzer.getJar() );\n            analyzer.setProperty( Analyzer.EXPORT_PACKAGE, export );\n        }\n\n        addMavenInstructions( project, analyzer );\n\n        // if we spot Embed-Dependency and the bundle is \"target/classes\", assume we need to rebuild\n        if ( analyzer.getProperty( DependencyEmbedder.EMBED_DEPENDENCY ) != null && isOutputDirectory )\n        {\n            analyzer.build();\n        }\n        else\n        {\n            analyzer.mergeManifest( analyzer.getJar().getManifest() );\n            analyzer.getJar().setManifest( analyzer.calcManifest() );\n        }\n\n        mergeMavenManifest( project, analyzer );\n\n        return analyzer;\n    }","id":93444,"modified_method":"protected Analyzer getAnalyzer( MavenProject project, Map<String, String> instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoExecutionException, Exception\n    {\n        if ( rebuildBundle && supportedProjectTypes.contains( project.getArtifact().getType() ) )\n        {\n            return buildOSGiBundle( project, instructions, properties, classpath );\n        }\n\n        File file = getOutputDirectory();\n        if ( file == null )\n        {\n            file = project.getArtifact().getFile();\n        }\n\n        if ( !file.exists() )\n        {\n            if ( file.equals( getOutputDirectory() ) )\n            {\n                file.mkdirs();\n            }\n            else\n            {\n                throw new FileNotFoundException( file.getPath() );\n            }\n        }\n\n        Builder analyzer = getOSGiBuilder( project, instructions, properties, classpath );\n\n        analyzer.setJar( file );\n\n        // calculateExportsFromContents when we have no explicit instructions defining\n        // the contents of the bundle *and* we are not analyzing the output directory,\n        // otherwise fall-back to addMavenInstructions approach\n\n        boolean isOutputDirectory = file.equals( getOutputDirectory() );\n\n        if ( analyzer.getProperty( Analyzer.EXPORT_PACKAGE ) == null\n            && analyzer.getProperty( Analyzer.EXPORT_CONTENTS ) == null\n            && analyzer.getProperty( Analyzer.PRIVATE_PACKAGE ) == null && !isOutputDirectory )\n        {\n            String export = calculateExportsFromContents( analyzer.getJar() );\n            analyzer.setProperty( Analyzer.EXPORT_PACKAGE, export );\n        }\n\n        addMavenInstructions( project, analyzer );\n\n        // if we spot Embed-Dependency and the bundle is \"target/classes\", assume we need to rebuild\n        if ( analyzer.getProperty( DependencyEmbedder.EMBED_DEPENDENCY ) != null && isOutputDirectory )\n        {\n            analyzer.build();\n        }\n        else\n        {\n            analyzer.mergeManifest( analyzer.getJar().getManifest() );\n            analyzer.getJar().setManifest( analyzer.calcManifest() );\n        }\n\n        mergeMavenManifest( project, analyzer );\n\n        return analyzer;\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"public void execute() throws MojoExecutionException, MojoFailureException\n    {\n        for ( Object key : versions.keySet() )\n        {\n            String name = ( String ) key;\n            String version = ( String ) versions.get( key );\n            String osgi = maven2OsgiConverter.getVersion( version );\n            project.getProperties().put( name, osgi );\n        }\n    }","id":93445,"modified_method":"public void execute() throws MojoExecutionException, MojoFailureException\n    {\n        for ( String name : versions.keySet() )\n        {\n            String version = versions.get( name );\n            String osgi = maven2OsgiConverter.getVersion( version );\n            project.getProperties().put( name, osgi );\n        }\n    }","commit_id":"82d87406db6da686c39142ca5100066fc8f869a0","url":"https://github.com/apache/felix"},{"original_method":"public static void load(Properties p, String s) throws IOException {\n\t\tif (Validator.isNotNull(s)) {\n\t\t\ts = UnicodeFormatter.toString(s);\n\n\t\t\ts = StringUtil.replace(s, \"\\\\u003d\", \"=\");\n\t\t\ts = StringUtil.replace(s, \"\\\\u000a\", \"\\n\");\n\t\t\ts = StringUtil.replace(s, \"\\\\u0021\", \"!\");\n\t\t\ts = StringUtil.replace(s, \"\\\\u0023\", \"#\");\n\t\t\ts = StringUtil.replace(s, \"\\\\u0020\", \" \");\n\t\t\ts = StringUtil.replace(s, \"\\\\u005c\", \"\\\\\");\n\n\t\t\tp.load(new ByteArrayInputStream(s.getBytes()));\n\n\t\t\tList propertyNames = Collections.list(p.propertyNames());\n\n\t\t\tfor (int i = 0; i < propertyNames.size(); i++) {\n\t\t\t\tString key = (String)propertyNames.get(i);\n\n\t\t\t\tString value = p.getProperty(key);\n\n\t\t\t\t// Trim values because it may leave a trailing \\r in certain\n\t\t\t\t// Windows environments. This is a known case for loading SQL\n\t\t\t\t// scripts in SQL Server.\n\n\t\t\t\tif (value != null) {\n\t\t\t\t\tvalue = value.trim();\n\n\t\t\t\t\tp.setProperty(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":93446,"modified_method":"public static void load(Properties p, String s) throws IOException {\n\t\tif (Validator.isNotNull(s)) {\n\t\t\ts = UnicodeFormatter.toString(s);\n\n\t\t\ts = StringUtil.replace(s, \"\\\\u003d\", \"=\");\n\t\t\ts = StringUtil.replace(s, \"\\\\u000a\", \"\\n\");\n\t\t\ts = StringUtil.replace(s, \"\\\\u0021\", \"!\");\n\t\t\ts = StringUtil.replace(s, \"\\\\u0023\", \"#\");\n\t\t\ts = StringUtil.replace(s, \"\\\\u0020\", \" \");\n\t\t\ts = StringUtil.replace(s, \"\\\\u005c\", \"\\\\\");\n\n\t\t\tp.load(new ByteArrayInputStream(s.getBytes()));\n\n\t\t\tList<String> propertyNames = Collections.list(\n\t\t\t\t(Enumeration<String>)p.propertyNames());\n\n\t\t\tfor (int i = 0; i < propertyNames.size(); i++) {\n\t\t\t\tString key = propertyNames.get(i);\n\n\t\t\t\tString value = p.getProperty(key);\n\n\t\t\t\t// Trim values because it may leave a trailing \\r in certain\n\t\t\t\t// Windows environments. This is a known case for loading SQL\n\t\t\t\t// scripts in SQL Server.\n\n\t\t\t\tif (value != null) {\n\t\t\t\t\tvalue = value.trim();\n\n\t\t\t\t\tp.setProperty(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"7ae5f3079d16231b2546695ae09565b724e66661","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void merge(Properties p1, Properties p2) {\n\t\tEnumeration enu = p2.propertyNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString key = (String)enu.nextElement();\n\t\t\tString value = p2.getProperty(key);\n\n\t\t\tp1.setProperty(key, value);\n\t\t}\n\t}","id":93447,"modified_method":"public static void merge(Properties p1, Properties p2) {\n\t\tEnumeration<String> enu = (Enumeration<String>)p2.propertyNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString key = enu.nextElement();\n\t\t\tString value = p2.getProperty(key);\n\n\t\t\tp1.setProperty(key, value);\n\t\t}\n\t}","commit_id":"7ae5f3079d16231b2546695ae09565b724e66661","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String toString(Properties p) {\n\t\tSafeProperties safeProperties = null;\n\n\t\tif (p instanceof SafeProperties) {\n\t\t\tsafeProperties = (SafeProperties)p;\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tEnumeration enu = p.propertyNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString key = (String)enu.nextElement();\n\n\t\t\tsb.append(key);\n\t\t\tsb.append(StringPool.EQUAL);\n\n\t\t\tif (safeProperties != null) {\n\t\t\t\tsb.append(safeProperties.getEncodedProperty(key));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(p.getProperty(key));\n\t\t\t}\n\n\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":93448,"modified_method":"public static String toString(Properties p) {\n\t\tSafeProperties safeProperties = null;\n\n\t\tif (p instanceof SafeProperties) {\n\t\t\tsafeProperties = (SafeProperties)p;\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tEnumeration<String> enu = (Enumeration<String>)p.propertyNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString key = enu.nextElement();\n\n\t\t\tsb.append(key);\n\t\t\tsb.append(StringPool.EQUAL);\n\n\t\t\tif (safeProperties != null) {\n\t\t\t\tsb.append(safeProperties.getEncodedProperty(key));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(p.getProperty(key));\n\t\t\t}\n\n\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"7ae5f3079d16231b2546695ae09565b724e66661","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void trimKeys(Properties p) {\n\t\tEnumeration enu = p.propertyNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString key = (String)enu.nextElement();\n\t\t\tString value = p.getProperty(key);\n\n\t\t\tString trimmedKey = key.trim();\n\n\t\t\tif (!key.equals(trimmedKey)) {\n\t\t\t\tp.remove(key);\n\t\t\t\tp.setProperty(trimmedKey, value);\n\t\t\t}\n\t\t}\n\t}","id":93449,"modified_method":"public static void trimKeys(Properties p) {\n\t\tEnumeration<String> enu = (Enumeration<String>)p.propertyNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString key = enu.nextElement();\n\t\t\tString value = p.getProperty(key);\n\n\t\t\tString trimmedKey = key.trim();\n\n\t\t\tif (!key.equals(trimmedKey)) {\n\t\t\t\tp.remove(key);\n\t\t\t\tp.setProperty(trimmedKey, value);\n\t\t\t}\n\t\t}\n\t}","commit_id":"7ae5f3079d16231b2546695ae09565b724e66661","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void copyProperties(Properties from, Properties to) {\n\t\tIterator itr = from.entrySet().iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tMap.Entry entry = (Map.Entry)itr.next();\n\n\t\t\tto.setProperty((String)entry.getKey(), (String)entry.getValue());\n\t\t}\n\t}","id":93450,"modified_method":"public static void copyProperties(Properties from, Properties to) {\n\t\tIterator<Map.Entry<Object, Object>> itr = from.entrySet().iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tMap.Entry<Object, Object> entry = itr.next();\n\n\t\t\tto.setProperty((String)entry.getKey(), (String)entry.getValue());\n\t\t}\n\t}","commit_id":"7ae5f3079d16231b2546695ae09565b724e66661","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void list(Map map, PrintStream out) {\n\t\tProperties props = fromMap(map);\n\n\t\tprops.list(out);\n\t}","id":93451,"modified_method":"public static void list(Map<String, String> map, PrintStream out) {\n\t\tProperties properties = fromMap(map);\n\n\t\tproperties.list(out);\n\t}","commit_id":"7ae5f3079d16231b2546695ae09565b724e66661","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void list(Map map, PrintWriter out) {\n\t\tProperties props = fromMap(map);\n\n\t\tprops.list(out);\n\t}","id":93452,"modified_method":"public static void list(Map<String, String> map, PrintWriter out) {\n\t\tProperties properties = fromMap(map);\n\n\t\tproperties.list(out);\n\t}","commit_id":"7ae5f3079d16231b2546695ae09565b724e66661","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void fromProperties(Properties p, Map map) {\n\t\tmap.clear();\n\n\t\tIterator itr = p.entrySet().iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tMap.Entry entry = (Map.Entry)itr.next();\n\n\t\t\tmap.put(entry.getKey(), entry.getValue());\n\t\t}\n\t}","id":93453,"modified_method":"public static Properties fromMap(Properties properties) {\n\t\treturn properties;\n\t}","commit_id":"7ae5f3079d16231b2546695ae09565b724e66661","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * completely rebuilds the sketch file\n\t * \n\t * this code is essentially a translation of the processing.core sketch\n\t * code to the Eclipse platform. The same code cannot just be reused\n\t * because we need to use the Eclipse virtual file system to access files\n\t * from inside Eclipse.\n\t * \n\t * @param monitor let the user know things are happening\n\t * @throws CoreException if there are problems accessing the files\n\t */\n\tprivate void fullBuild(IProgressMonitor monitor) throws CoreException {\n\t\t\n\t\tmonitor.beginTask(\"Full Project Build\", 4); // no idea how much 'work' to do here\n\t\tIProject proj = getProject(); // get the project\n\n\t\tif(checkCancel(monitor))\n\t\t\treturn;\n\t\t\n\t\tif(!deleteProblemMarkers(proj))\n\t\t\treturn;\n\t\t\n\t\t// IResource.members() doesn't return the files in a consistent order\n\t\t// so we get the list at the beginning of each build and use folderContents\n\t\t// whenever we need to get access to the source files during the build.\n\t\tIResource[] folderContents = proj.members(); //TODO make this location a preference, link to sketchbook\n\t\t\n\t\t// 1. concatenate all .pde files to the 'main' pde\n\t\t\n\t\tStringBuffer bigCode = new StringBuffer(); // this will hold the program\n\t\tint bigCount = 0; // how many lines are we talking about here?\n\t\t\n\t\t// without a SketchCode object, this field needs to be tracked independently\n\t\tint[] preprocOffsets = new int[folderContents.length];\n\t\t\n\t\tfor(int i = 0; i < folderContents.length; i++){\n\t\t\tIResource file = folderContents[i];\n\t\t\tif(file.getFileExtension() == \"pde\"){ // filters out only .pde files\n\t\t\t\tString content = readFile((IFile) file);\n\t\t\t\tpreprocOffsets[i] = bigCount;\n\t\t\t\tbigCode.append(content);\n\t\t\t\tbigCode.append(\"\\n\");\n\t\t\t\tbigCount += getLineCount(content);\n\t\t\t}\n\t\t}\n\n\t\tmonitor.worked(1);\n\t\tif(checkCancel(monitor))\n\t\t\treturn;\n\t\t\n\t\tspoof_preferences();// fake the preferences object.\n\t\tPdePreprocessor preproc = new PdePreprocessor(proj.getName(), 4); //TODO make tab size a preference?\n\t\t\n\t\t//final File java = new File(buildPath, name + \".java\");\n\t\tIFolder outputFolder = proj.getFolder(\"bin\"); // just a handle to the resource //TODO make the derived resources folder a preference\n\t\tif (!outputFolder.exists())\n\t\t\toutputFolder.create(IResource.NONE, true, null);\n\t\t\n\t\tPreprocessResult result = null;\n\t\ttry{\n\t\t\tIFile outputFile = outputFolder.getFile(proj.getName() + \".java\"); \n\t\t\t\t\n\t\t\tStringWriter outputFileContents = new StringWriter();\n\t\t\tresult = preproc.write(outputFileContents, bigCode.toString());\n\t\t\t\n\t\t\t// Ugh. It wants an InputStream\n\t\t\tByteArrayInputStream inStream = new ByteArrayInputStream(outputFileContents.toString().getBytes());\n\t\t\t\n\t\t\toutputFile.create(inStream, true, monitor); // force flag = true means this should overwrite any existing files\n\t\t\toutputFile.setDerived(true); // let the platform know this is a generated file\n\t\t\t\n\t\t}catch(antlr.RecognitionException re){\n\t\t\t//TODO define the RecognitionException problem marker \n\t\t\t\n\t\t\t// first assume that it's the main file\n\t\t\tint errorFile = 0;\n\t\t\tint errorLine = re.getLine() - 1;\n\t\t\t\n\t\t\t// then search through for anyone else whose preprocName is null,\n\t\t\t// since they've also been combined into the main pde\n\t\t\tfor(int i = 1; i < folderContents.length; i++){\n\t\t\t\tIResource file = folderContents[i];\n\t\t\t\tif(file.getFileExtension() == \"pde\" && (preprocOffsets[i] < errorLine)){ \n\t\t\t\t\terrorFile = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\terrorLine -= preprocOffsets[errorFile];\n\t\t\t\t\t\t\n\t\t\t//DEBUG\n\t\t\tSystem.out.println(\"error line - error file - offset\");\n\t      \tSystem.out.println(errorLine + \" - \" + errorFile + \" - \" + preprocOffsets[errorFile]);\n\t\t\t\n\t\t\tString msg = re.getMessage();\t\t\n\t\t\t\n\t\t\tif (msg.equals(\"expecting RCURLY, found 'null'\")) {\n\t\t        // This can be a problem since the error is sometimes listed as a line\n\t\t        // that's actually past the number of lines. For instance, it might\n\t\t        // report \"line 15\" of a 14 line program. Added code to highlightLine()\n\t\t        // inside Editor to deal with this situation (since that code is also\n\t\t        // useful for other similar situations).\n\t\t        msg = \"Found one too many { characters without a } to match it.\";\n\t\t    }\n\t\t    if (msg.indexOf(\"expecting RBRACK\") != -1) {\n\t\t    \tmsg = \"Syntax error, maybe a missing right ] character?\";\n\t\t\t}\n\t\t    if (msg.indexOf(\"expecting SEMI\") != -1) {\n\t\t        msg = \"Syntax error, maybe a missing semicolon?\";\n\t\t    }\n\t\t    if (msg.indexOf(\"expecting RPAREN\") != -1) {\n\t\t        msg = \"Syntax error, maybe a missing right parenthesis?\";\n\t\t    }\n\t\t    if (msg.indexOf(\"preproc.web_colors\") != -1) {\n\t\t        msg = \"A web color (such as #ffcc00) must be six digits.\";\n\t\t    }\n\t\t    \n\t\t    // if there is no friendly translation, just report what you can\n  \t\t\treportProblem(msg, (IFile) folderContents[errorFile], errorLine, true);\n\t\t\n\t\t} catch (Exception e){\n\t\t\tProcessingLog.logError(e);\n\t\t}\n\t\t\n\t\tmonitor.worked(1);\n\t\tif(checkCancel(monitor))\n\t\t\treturn;\n\t\t\n\t\t// copy any .java files to the output directory\n\t\tfor(int i = 0; i < folderContents.length; i++){\n\t\t\tIResource file = folderContents[i];\n\t\t\tif(file.getFileExtension() == \"java\"){ // copy .java files into the build directory\n\t\t\t\tfolderContents[i].copy(outputFolder.getProjectRelativePath(), IResource.DERIVED, monitor);\n\t\t\t} else if (file.getFileExtension() == \"pde\"){\n\t\t\t\t// The compiler and runner will need this to have a proper offset\n\t\t\t\tpreprocOffsets[i] += result.headerOffset;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean foundMain = preproc.getFoundMain(); // is this still necessary?\n\t\t\n\t\t\n\t\tmonitor.worked(1);\n\t\tif(checkCancel(monitor))\n\t\t\treturn;\n\t\t\n\t\t//to the java batch compiler!\n\t\t//org.eclipse.jdt.core.compiler.CompilationProgress progress = null;\n\t\t\n//\t\tString baseCommand[] = new String[]{\n//\t\t\t\t\"-Xemacs\",\n//\t\t\t    //\"-noExit\",  // not necessary for ecj\n//\t\t\t    \"-source\", \"1.5\",\n//\t\t\t    \"-target\", \"1.5\",\n//\t\t\t    \"-classpath\", sketch.getClassPath(),\n//\t\t\t    \"-nowarn\", // we're not currently interested in warnings (works in ecj)\n//\t\t\t    \"-d\", buildPath // output the classes in the buildPath\t\t\t\t\t\n//\t\t};\n\t\t\n\t\t//org.eclipse.jdt.core.compiler.batch.BatchCompiler.compile(\"-verbose\", new PrintWriter(System.out), new PrintWriter(System.err), progress);\n\t\t// do something with it\n\t\t\n\t\t// finally, let the monitor know things are done\n\t\tmonitor.done();\n\t}","id":93454,"modified_method":"/**\n\t * completely rebuilds the sketch file\n\t * \n\t * this code is essentially a translation of the processing.core sketch\n\t * code to the Eclipse platform. The same code cannot just be reused\n\t * because we need to use the Eclipse virtual file system to access files\n\t * from inside Eclipse.\n\t * \n\t * @param monitor let the user know things are happening\n\t * @throws CoreException if there are problems accessing the files\n\t */\n\tprivate void fullBuild(IProgressMonitor monitor) throws CoreException {\n\t\t\n\t\tmonitor.beginTask(\"Full Project Build\", 4); // no idea how much 'work' to do here\n\t\tIProject proj = getProject(); // get the project\n\n\t\tif(checkCancel(monitor))\n\t\t\treturn;\n\t\t\n\t\tif(!deleteProblemMarkers(proj))\n\t\t\treturn;\n\t\t\n\t\t// IResource.members() doesn't return the files in a consistent order\n\t\t// so we get the list at the beginning of each build and use folderContents\n\t\t// whenever we need to get access to the source files during the build.\n\t\tIResource[] folderContents = proj.members(); //TODO make this location a preference, link to sketchbook\n\n\t\t// 1. concatenate all .pde files to the 'main' pde\n\t\t\n\t\tStringBuffer bigCode = new StringBuffer(); // this will hold the program\n\t\tint bigCount = 0; // how many lines are we talking about here?\n\t\t\n\t\t// without a SketchCode object, this field needs to be tracked independently\n\t\tint[] preprocOffsets = new int[folderContents.length];\n\t\t\n\t\tfor(int i = 0; i < folderContents.length; i++){\n\t\t\tIResource file = folderContents[i];\n\t\t\tif(file instanceof IFile && file.getFileExtension().equalsIgnoreCase(\"pde\")){ // filters out only .pde files\n\t\t\t\tSystem.out.println(\"win\");\n\t\t\t\tString content = readFile((IFile) file);\n\t\t\t\tpreprocOffsets[i] = bigCount;\n\t\t\t\tbigCode.append(content);\n\t\t\t\tbigCode.append(\"\\n\");\n\t\t\t\tbigCount += getLineCount(content);\n\t\t\t}\n\t\t}\n\n\t\tmonitor.worked(1);\n\t\tif(checkCancel(monitor))\n\t\t\treturn;\n\t\t\n\t\tspoof_preferences();// fake the preferences object.\n\t\tPdePreprocessor preproc = new PdePreprocessor(proj.getName(), 4); //TODO make tab size a preference?\n\t\t\n\t\t//final File java = new File(buildPath, name + \".java\");\n\t\tIFolder outputFolder = proj.getFolder(\"bin\"); // just a handle to the resource //TODO make the derived resources folder a preference\n\t\tif (!outputFolder.exists())\n\t\t\toutputFolder.create(IResource.NONE, true, null);\n\t\t\n\t\tPreprocessResult result = null;\n\t\ttry{\n\t\t\tIFile outputFile = outputFolder.getFile(proj.getName() + \".java\"); \n\t\t\t\t\n\t\t\tStringWriter outputFileContents = new StringWriter();\n\t\t\tresult = preproc.write(outputFileContents, bigCode.toString());\n\t\t\t\n\t\t\t// Ugh. It wants an InputStream\n\t\t\tByteArrayInputStream inStream = new ByteArrayInputStream(outputFileContents.toString().getBytes());\n\t\t\t\n\t\t\toutputFile.create(inStream, true, monitor); // force flag = true means this should overwrite any existing files\n\t\t\toutputFile.setDerived(true); // let the platform know this is a generated file\n\t\t\t\n\t\t}catch(antlr.RecognitionException re){\n\t\t\t//TODO define the RecognitionException problem marker \n\t\t\t\t\t\t\n\t\t\t// first assume that it's the main file\n\t\t\tint errorFile = 0;\n\t\t\tint errorLine = re.getLine() - 1;\n\t\t\t\n\t\t\t// then search through for anyone else whose preprocName is null,\n\t\t\t// since they've also been combined into the main pde\n\t\t\tfor(int i = 1; i < folderContents.length; i++){\n\t\t\t\tIResource file = folderContents[i];\n\t\t\t\tif(file instanceof IFile && file.getFileExtension().equalsIgnoreCase(\"pde\") && (preprocOffsets[i] < errorLine)){ \n\t\t\t\t\terrorFile = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\terrorLine -= preprocOffsets[errorFile];\n\t\t\t\t\t\t\n\t\t\t//DEBUG\n\t\t\tSystem.out.println(\"error line - error file - offset\");\n\t      \tSystem.out.println(errorLine + \" - \" + errorFile + \" - \" + preprocOffsets[errorFile]);\n\t\t\t\n\t\t\tString msg = re.getMessage();\t\t\n\t\t\t\n\t\t\tif (msg.equals(\"expecting RCURLY, found 'null'\")) {\n\t\t        // This can be a problem since the error is sometimes listed as a line\n\t\t        // that's actually past the number of lines. For instance, it might\n\t\t        // report \"line 15\" of a 14 line program. Added code to highlightLine()\n\t\t        // inside Editor to deal with this situation (since that code is also\n\t\t        // useful for other similar situations).\n\t\t        msg = \"Found one too many { characters without a } to match it.\";\n\t\t    }\n\t\t    if (msg.indexOf(\"expecting RBRACK\") != -1) {\n\t\t    \tmsg = \"Syntax error, maybe a missing right ] character?\";\n\t\t\t}\n\t\t    if (msg.indexOf(\"expecting SEMI\") != -1) {\n\t\t        msg = \"Syntax error, maybe a missing semicolon?\";\n\t\t    }\n\t\t    if (msg.indexOf(\"expecting RPAREN\") != -1) {\n\t\t        msg = \"Syntax error, maybe a missing right parenthesis?\";\n\t\t    }\n\t\t    if (msg.indexOf(\"preproc.web_colors\") != -1) {\n\t\t        msg = \"A web color (such as #ffcc00) must be six digits.\";\n\t\t    }\n\t\t    \n\t\t    // if there is no friendly translation, just report what you can\n  \t\t\treportProblem(msg, (IFile) folderContents[errorFile], errorLine, true);\n\t\t\n\t\t} catch (Exception e){\n\t\t\tProcessingLog.logError(e);\n\t\t}\n\t\t\n\t\tmonitor.worked(1);\n\t\tif(checkCancel(monitor))\n\t\t\treturn;\n\t\t\n\t\t// copy any .java files to the output directory\n\t\tfor(int i = 0; i < folderContents.length; i++){\n\t\t\tIResource file = folderContents[i];\n\t\t\tif(file instanceof IFile && file.getFileExtension().equalsIgnoreCase(\"java\")){ // copy .java files into the build directory\n\t\t\t\tfolderContents[i].copy(outputFolder.getProjectRelativePath(), IResource.DERIVED, monitor);\n\t\t\t} else if (file instanceof IFile && file.getFileExtension().equalsIgnoreCase(\"pde\")){\n\t\t\t\t// The compiler and runner will need this to have a proper offset\n\t\t\t\tpreprocOffsets[i] += result.headerOffset;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean foundMain = preproc.getFoundMain(); // is this still necessary?\n\t\t\n\t\t\n\t\tmonitor.worked(1);\n\t\tif(checkCancel(monitor))\n\t\t\treturn;\n\t\t\n\t\t//to the java batch compiler!\n\t\t//org.eclipse.jdt.core.compiler.CompilationProgress progress = null;\n\t\t\n//\t\tString baseCommand[] = new String[]{\n//\t\t\t\t\"-Xemacs\",\n//\t\t\t    //\"-noExit\",  // not necessary for ecj\n//\t\t\t    \"-source\", \"1.5\",\n//\t\t\t    \"-target\", \"1.5\",\n//\t\t\t    \"-classpath\", sketch.getClassPath(),\n//\t\t\t    \"-nowarn\", // we're not currently interested in warnings (works in ecj)\n//\t\t\t    \"-d\", buildPath // output the classes in the buildPath\t\t\t\t\t\n//\t\t};\n\t\t\n\t\t//org.eclipse.jdt.core.compiler.batch.BatchCompiler.compile(\"-verbose\", new PrintWriter(System.out), new PrintWriter(System.err), progress);\n\t\t// do something with it\n\t\t\n\t\t// finally, let the monitor know things are done\n\t\tmonitor.done();\n\t}","commit_id":"4a64b32861f689ccaac72d328edfca0923ccde51","url":"https://github.com/processing/processing"},{"original_method":"public StreamResultFuture stream(Set<InetAddress> toIgnore, StreamEventHandler... listeners)\n    {\n        client.init(keyspace);\n        outputHandler.output(\"Established connection to initial hosts\");\n\n        StreamPlan plan = new StreamPlan(\"Bulk Load\");\n\n        Map<InetAddress, Collection<Range<Token>>> endpointToRanges = client.getEndpointToRangesMap();\n        openSSTables(endpointToRanges);\n        if (sstables.isEmpty())\n        {\n            // return empty result\n            return plan.execute();\n        }\n\n        outputHandler.output(String.format(\"Streaming relevant part of %sto %s\", names(sstables), endpointToRanges.keySet()));\n\n        for (Map.Entry<InetAddress, Collection<Range<Token>>> entry : endpointToRanges.entrySet())\n        {\n            InetAddress remote = entry.getKey();\n            if (toIgnore.contains(remote))\n                continue;\n\n            Collection<StreamSession.SSTableStreamingSections> endpointDetails = streamingDetails.get(remote);\n\n            // transferSSTables assumes references have been acquired\n            for (StreamSession.SSTableStreamingSections details : endpointDetails)\n                details.sstable.acquireReference();\n\n            plan.transferFiles(remote, streamingDetails.get(remote));\n        }\n        plan.listeners(this, listeners);\n        return plan.execute();\n    }","id":93455,"modified_method":"public StreamResultFuture stream(Set<InetAddress> toIgnore, StreamEventHandler... listeners)\n    {\n        client.init(keyspace);\n        outputHandler.output(\"Established connection to initial hosts\");\n\n        StreamPlan plan = new StreamPlan(\"Bulk Load\");\n\n        Map<InetAddress, Collection<Range<Token>>> endpointToRanges = client.getEndpointToRangesMap();\n        openSSTables(endpointToRanges);\n        if (sstables.isEmpty())\n        {\n            // return empty result\n            return plan.execute();\n        }\n\n        outputHandler.output(String.format(\"Streaming relevant part of %sto %s\", names(sstables), endpointToRanges.keySet()));\n\n        for (Map.Entry<InetAddress, Collection<Range<Token>>> entry : endpointToRanges.entrySet())\n        {\n            InetAddress remote = entry.getKey();\n            if (toIgnore.contains(remote))\n                continue;\n\n            List<StreamSession.SSTableStreamingSections> endpointDetails = new LinkedList<>();\n\n            try\n            {\n                // transferSSTables assumes references have been acquired\n                for (StreamSession.SSTableStreamingSections details : streamingDetails.get(remote))\n                {\n                    if (!details.sstable.acquireReference())\n                        throw new IllegalStateException();\n\n                    endpointDetails.add(details);\n                }\n\n                plan.transferFiles(remote, endpointDetails);\n            }\n            finally\n            {\n                for (StreamSession.SSTableStreamingSections details : endpointDetails)\n                    details.sstable.releaseReference();\n            }\n        }\n        plan.listeners(this, listeners);\n        return plan.execute();\n    }","commit_id":"24e71dbff4e08878c94ad8cadaf9c5c6de8ae658","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Set up transfer for specific keyspace/ranges/CFs\n     *\n     * Used in repair - a streamed sstable in repair will be marked with the given repairedAt time\n     *\n     * @param keyspace Transfer keyspace\n     * @param ranges Transfer ranges\n     * @param columnFamilies Transfer ColumnFamilies\n     * @param flushTables flush tables?\n     * @param repairedAt the time the repair started.\n     */\n    public void addTransferRanges(String keyspace, Collection<Range<Token>> ranges, Collection<String> columnFamilies, boolean flushTables, long repairedAt)\n    {\n        Collection<ColumnFamilyStore> stores = getColumnFamilyStores(keyspace, columnFamilies);\n        if (flushTables)\n            flushSSTables(stores);\n\n        List<Range<Token>> normalizedRanges = Range.normalize(ranges);\n        List<SSTableReader> sstables = getSSTablesForRanges(normalizedRanges, stores);\n        addTransferFiles(normalizedRanges, sstables, repairedAt);\n    }","id":93456,"modified_method":"/**\n     * Set up transfer for specific keyspace/ranges/CFs\n     *\n     * Used in repair - a streamed sstable in repair will be marked with the given repairedAt time\n     *\n     * @param keyspace Transfer keyspace\n     * @param ranges Transfer ranges\n     * @param columnFamilies Transfer ColumnFamilies\n     * @param flushTables flush tables?\n     * @param repairedAt the time the repair started.\n     */\n    public void addTransferRanges(String keyspace, Collection<Range<Token>> ranges, Collection<String> columnFamilies, boolean flushTables, long repairedAt)\n    {\n        Collection<ColumnFamilyStore> stores = getColumnFamilyStores(keyspace, columnFamilies);\n        if (flushTables)\n            flushSSTables(stores);\n\n        List<Range<Token>> normalizedRanges = Range.normalize(ranges);\n        List<SSTableStreamingSections> sections = getSSTableSectionsForRanges(normalizedRanges, stores, repairedAt);\n        try\n        {\n            addTransferFiles(sections);\n        }\n        finally\n        {\n            for (SSTableStreamingSections release : sections)\n                release.sstable.releaseReference();\n        }\n    }","commit_id":"24e71dbff4e08878c94ad8cadaf9c5c6de8ae658","url":"https://github.com/apache/cassandra"},{"original_method":"public void addTransferFiles(Collection<SSTableStreamingSections> sstableDetails)\n    {\n        for (SSTableStreamingSections details : sstableDetails)\n        {\n            if (details.sections.isEmpty())\n            {\n                // A reference was acquired on the sstable and we won't stream it\n                details.sstable.releaseReference();\n                continue;\n            }\n\n            UUID cfId = details.sstable.metadata.cfId;\n            StreamTransferTask task = transfers.get(cfId);\n            if (task == null)\n            {\n                task = new StreamTransferTask(this, cfId);\n                transfers.put(cfId, task);\n            }\n            task.addTransferFile(details.sstable, details.estimatedKeys, details.sections, details.repairedAt);\n        }\n    }","id":93457,"modified_method":"public void addTransferFiles(Collection<SSTableStreamingSections> sstableDetails)\n    {\n        Iterator<SSTableStreamingSections> iter = sstableDetails.iterator();\n        while (iter.hasNext())\n        {\n            SSTableStreamingSections details = iter.next();\n            if (details.sections.isEmpty())\n            {\n                // A reference was acquired on the sstable and we won't stream it\n                details.sstable.releaseReference();\n                iter.remove();\n                continue;\n            }\n\n            UUID cfId = details.sstable.metadata.cfId;\n            StreamTransferTask task = transfers.get(cfId);\n            if (task == null)\n            {\n                task = new StreamTransferTask(this, cfId);\n                transfers.put(cfId, task);\n            }\n            task.addTransferFile(details.sstable, details.estimatedKeys, details.sections, details.repairedAt);\n            iter.remove();\n        }\n    }","commit_id":"24e71dbff4e08878c94ad8cadaf9c5c6de8ae658","url":"https://github.com/apache/cassandra"},{"original_method":"private List<SSTableReader> getSSTablesForRanges(Collection<Range<Token>> normalizedRanges, Collection<ColumnFamilyStore> stores)\n    {\n        List<SSTableReader> sstables = Lists.newLinkedList();\n        for (ColumnFamilyStore cfStore : stores)\n        {\n            List<AbstractBounds<RowPosition>> rowBoundsList = Lists.newLinkedList();\n            for (Range<Token> range : normalizedRanges)\n                rowBoundsList.add(range.toRowBounds());\n            ColumnFamilyStore.ViewFragment view = cfStore.selectAndReference(cfStore.viewFilter(rowBoundsList));\n            sstables.addAll(view.sstables);\n        }\n        return sstables;\n    }","id":93458,"modified_method":"private List<SSTableStreamingSections> getSSTableSectionsForRanges(Collection<Range<Token>> ranges, Collection<ColumnFamilyStore> stores, long overriddenRepairedAt)\n    {\n        List<SSTableReader> sstables = new ArrayList<>();\n        try\n        {\n            for (ColumnFamilyStore cfStore : stores)\n            {\n                List<AbstractBounds<RowPosition>> rowBoundsList = new ArrayList<>(ranges.size());\n                for (Range<Token> range : ranges)\n                    rowBoundsList.add(range.toRowBounds());\n                ColumnFamilyStore.ViewFragment view = cfStore.selectAndReference(cfStore.viewFilter(rowBoundsList));\n                sstables.addAll(view.sstables);\n            }\n\n            List<SSTableStreamingSections> sections = new ArrayList<>(sstables.size());\n            for (SSTableReader sstable : sstables)\n            {\n                long repairedAt = overriddenRepairedAt;\n                if (overriddenRepairedAt == ActiveRepairService.UNREPAIRED_SSTABLE)\n                    repairedAt = sstable.getSSTableMetadata().repairedAt;\n                sections.add(new SSTableStreamingSections(sstable,\n                                                          sstable.getPositionsForRanges(ranges),\n                                                          sstable.estimatedKeysForRanges(ranges),\n                                                          repairedAt));\n            }\n            return sections;\n        }\n        catch (Throwable t)\n        {\n            SSTableReader.releaseReferences(sstables);\n            throw t;\n        }\n    }","commit_id":"24e71dbff4e08878c94ad8cadaf9c5c6de8ae658","url":"https://github.com/apache/cassandra"},{"original_method":"public StreamResultFuture stream(Set<InetAddress> toIgnore, StreamEventHandler... listeners)\n    {\n        client.init(keyspace);\n        outputHandler.output(\"Established connection to initial hosts\");\n\n        StreamPlan plan = new StreamPlan(\"Bulk Load\");\n\n        Map<InetAddress, Collection<Range<Token>>> endpointToRanges = client.getEndpointToRangesMap();\n        openSSTables(endpointToRanges);\n        if (sstables.isEmpty())\n        {\n            // return empty result\n            return plan.execute();\n        }\n\n        outputHandler.output(String.format(\"Streaming relevant part of %sto %s\", names(sstables), endpointToRanges.keySet()));\n\n        for (Map.Entry<InetAddress, Collection<Range<Token>>> entry : endpointToRanges.entrySet())\n        {\n            InetAddress remote = entry.getKey();\n            if (toIgnore.contains(remote))\n                continue;\n\n            Collection<StreamSession.SSTableStreamingSections> endpointDetails = streamingDetails.get(remote);\n\n            // transferSSTables assumes references have been acquired\n            for (StreamSession.SSTableStreamingSections details : endpointDetails)\n                details.sstable.acquireReference();\n\n            plan.transferFiles(remote, streamingDetails.get(remote));\n        }\n        plan.listeners(this, listeners);\n        return plan.execute();\n    }","id":93459,"modified_method":"public StreamResultFuture stream(Set<InetAddress> toIgnore, StreamEventHandler... listeners)\n    {\n        client.init(keyspace);\n        outputHandler.output(\"Established connection to initial hosts\");\n\n        StreamPlan plan = new StreamPlan(\"Bulk Load\");\n\n        Map<InetAddress, Collection<Range<Token>>> endpointToRanges = client.getEndpointToRangesMap();\n        openSSTables(endpointToRanges);\n        if (sstables.isEmpty())\n        {\n            // return empty result\n            return plan.execute();\n        }\n\n        outputHandler.output(String.format(\"Streaming relevant part of %sto %s\", names(sstables), endpointToRanges.keySet()));\n\n        for (Map.Entry<InetAddress, Collection<Range<Token>>> entry : endpointToRanges.entrySet())\n        {\n            InetAddress remote = entry.getKey();\n            if (toIgnore.contains(remote))\n                continue;\n\n            List<StreamSession.SSTableStreamingSections> endpointDetails = new LinkedList<>();\n\n            try\n            {\n                // transferSSTables assumes references have been acquired\n                for (StreamSession.SSTableStreamingSections details : streamingDetails.get(remote))\n                {\n                    if (!details.sstable.acquireReference())\n                        throw new IllegalStateException();\n\n                    endpointDetails.add(details);\n                }\n\n                plan.transferFiles(remote, endpointDetails);\n            }\n            finally\n            {\n                for (StreamSession.SSTableStreamingSections details : endpointDetails)\n                    details.sstable.releaseReference();\n            }\n        }\n        plan.listeners(this, listeners);\n        return plan.execute();\n    }","commit_id":"95e09f262ce8d448e8bbbd17aa9c77f6546d5ed1","url":"https://github.com/apache/cassandra"},{"original_method":"public void addTransferFiles(Collection<SSTableStreamingSections> sstableDetails)\n    {\n        for (SSTableStreamingSections details : sstableDetails)\n        {\n            if (details.sections.isEmpty())\n            {\n                // A reference was acquired on the sstable and we won't stream it\n                details.sstable.releaseReference();\n                continue;\n            }\n\n            UUID cfId = details.sstable.metadata.cfId;\n            StreamTransferTask task = transfers.get(cfId);\n            if (task == null)\n            {\n                task = new StreamTransferTask(this, cfId);\n                transfers.put(cfId, task);\n            }\n            task.addTransferFile(details.sstable, details.estimatedKeys, details.sections);\n        }\n    }","id":93460,"modified_method":"public void addTransferFiles(Collection<SSTableStreamingSections> sstableDetails)\n    {\n        Iterator<SSTableStreamingSections> iter = sstableDetails.iterator();\n        while (iter.hasNext())\n        {\n            SSTableStreamingSections details = iter.next();\n            if (details.sections.isEmpty())\n            {\n                // A reference was acquired on the sstable and we won't stream it\n                details.sstable.releaseReference();\n                iter.remove();\n                continue;\n            }\n\n            UUID cfId = details.sstable.metadata.cfId;\n            StreamTransferTask task = transfers.get(cfId);\n            if (task == null)\n            {\n                task = new StreamTransferTask(this, cfId);\n                transfers.put(cfId, task);\n            }\n            task.addTransferFile(details.sstable, details.estimatedKeys, details.sections);\n            iter.remove();\n        }\n    }","commit_id":"95e09f262ce8d448e8bbbd17aa9c77f6546d5ed1","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Set up transfer of the specific SSTables.\n     * {@code sstables} must be marked as referenced so that not get deleted until transfer completes.\n     *\n     * @param ranges Transfer ranges\n     * @param sstables Transfer files\n     */\n    public void addTransferFiles(Collection<Range<Token>> ranges, Collection<SSTableReader> sstables)\n    {\n        List<SSTableStreamingSections> sstableDetails = new ArrayList<>(sstables.size());\n        for (SSTableReader sstable : sstables)\n            sstableDetails.add(new SSTableStreamingSections(sstable, sstable.getPositionsForRanges(ranges), sstable.estimatedKeysForRanges(ranges)));\n\n        addTransferFiles(sstableDetails);\n    }","id":93461,"modified_method":"private List<SSTableStreamingSections> getSSTableSectionsForRanges(Collection<Range<Token>> ranges, Collection<ColumnFamilyStore> stores)\n    {\n        List<SSTableReader> sstables = new ArrayList<>();\n        try\n        {\n            for (ColumnFamilyStore cfStore : stores)\n            {\n                List<AbstractBounds<RowPosition>> rowBoundsList = new ArrayList<>(ranges.size());\n                for (Range<Token> range : ranges)\n                    rowBoundsList.add(range.toRowBounds());\n                ColumnFamilyStore.ViewFragment view = cfStore.markReferenced(rowBoundsList);\n                sstables.addAll(view.sstables);\n            }\n\n            List<SSTableStreamingSections> sections = new ArrayList<>(sstables.size());\n            for (SSTableReader sstable : sstables)\n            {\n                sections.add(new SSTableStreamingSections(sstable,\n                                                          sstable.getPositionsForRanges(ranges),\n                                                          sstable.estimatedKeysForRanges(ranges)));\n            }\n            return sections;\n        }\n        catch (Throwable t)\n        {\n            SSTableReader.releaseReferences(sstables);\n            throw t;\n        }\n    }","commit_id":"95e09f262ce8d448e8bbbd17aa9c77f6546d5ed1","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Set up transfer for specific keyspace/ranges/CFs\n     *\n     * @param keyspace Transfer keyspace\n     * @param ranges Transfer ranges\n     * @param columnFamilies Transfer ColumnFamilies\n     */\n    public void addTransferRanges(String keyspace, Collection<Range<Token>> ranges, Collection<String> columnFamilies, boolean flushTables)\n    {\n        Collection<ColumnFamilyStore> stores = new HashSet<>();\n        // if columnfamilies are not specified, we add all cf under the keyspace\n        if (columnFamilies.isEmpty())\n        {\n            stores.addAll(Keyspace.open(keyspace).getColumnFamilyStores());\n        }\n        else\n        {\n            for (String cf : columnFamilies)\n                stores.add(Keyspace.open(keyspace).getColumnFamilyStore(cf));\n        }\n\n        if (flushTables)\n            flushSSTables(stores);\n\n        List<Range<Token>> normalizedRanges = Range.normalize(ranges);\n        List<SSTableReader> sstables = Lists.newLinkedList();\n        for (ColumnFamilyStore cfStore : stores)\n        {\n            List<AbstractBounds<RowPosition>> rowBoundsList = Lists.newLinkedList();\n            for (Range<Token> range : normalizedRanges)\n                rowBoundsList.add(range.toRowBounds());\n            ColumnFamilyStore.ViewFragment view = cfStore.markReferenced(rowBoundsList);\n            sstables.addAll(view.sstables);\n        }\n        addTransferFiles(normalizedRanges, sstables);\n    }","id":93462,"modified_method":"/**\n     * Set up transfer for specific keyspace/ranges/CFs\n     *\n     * @param keyspace Transfer keyspace\n     * @param ranges Transfer ranges\n     * @param columnFamilies Transfer ColumnFamilies\n     */\n    public void addTransferRanges(String keyspace, Collection<Range<Token>> ranges, Collection<String> columnFamilies, boolean flushTables)\n    {\n        Collection<ColumnFamilyStore> stores = new HashSet<>();\n        // if columnfamilies are not specified, we add all cf under the keyspace\n        if (columnFamilies.isEmpty())\n        {\n            stores.addAll(Keyspace.open(keyspace).getColumnFamilyStores());\n        }\n        else\n        {\n            for (String cf : columnFamilies)\n                stores.add(Keyspace.open(keyspace).getColumnFamilyStore(cf));\n        }\n\n        if (flushTables)\n            flushSSTables(stores);\n\n        List<Range<Token>> normalizedRanges = Range.normalize(ranges);\n        List<SSTableStreamingSections> sections = getSSTableSectionsForRanges(normalizedRanges, stores);\n        try\n        {\n            addTransferFiles(sections);\n        }\n        finally\n        {\n            for (SSTableStreamingSections release : sections)\n                release.sstable.releaseReference();\n        }\n    }","commit_id":"95e09f262ce8d448e8bbbd17aa9c77f6546d5ed1","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Collects data in order of recency, using the sstable maxtimestamp data.\n     * Once we have data for all requests columns that is newer than the newest remaining maxtimestamp,\n     * we stop.\n     */\n    private ColumnFamily collectTimeOrderedData()\n    {\n        logger.debug(\"collectTimeOrderedData\");\n\n        ColumnFamily container = ColumnFamily.create(cfs.metadata, factory, filter.filter.isReversed());\n        List<IColumnIterator> iterators = new ArrayList<IColumnIterator>();\n        ColumnFamilyStore.ViewFragment view = cfs.markReferenced(filter.key);\n        try\n        {\n            for (Memtable memtable : view.memtables)\n            {\n                IColumnIterator iter = filter.getMemtableColumnIterator(memtable, cfs.metadata.comparator);\n                if (iter != null)\n                {\n                    iterators.add(iter);\n                    container.delete(iter.getColumnFamily());\n                    while (iter.hasNext())\n                        container.addColumn(iter.next());\n                }\n            }\n\n            // avoid changing the filter columns of the original filter\n            // (reduceNameFilter removes columns that are known to be irrelevant)\n            TreeSet<ByteBuffer> filterColumns = new TreeSet<ByteBuffer>(cfs.metadata.comparator);\n            filterColumns.addAll(((NamesQueryFilter) filter.filter).columns);\n            QueryFilter reducedFilter = new QueryFilter(filter.key, filter.path, new NamesQueryFilter(filterColumns));\n\n            /* add the SSTables on disk */\n            Collections.sort(view.sstables, SSTable.maxTimestampComparator);\n\n            // read sorted sstables\n            for (SSTableReader sstable : view.sstables)\n            {\n                long currentMaxTs = sstable.getMaxTimestamp();\n                reduceNameFilter(reducedFilter, container, currentMaxTs);\n                if (((NamesQueryFilter) reducedFilter.filter).columns.isEmpty())\n                    break;\n\n                IColumnIterator iter = reducedFilter.getSSTableColumnIterator(sstable);\n                iterators.add(iter);\n                if (iter.getColumnFamily() != null)\n                {\n                    container.delete(iter.getColumnFamily());\n                    sstablesIterated++;\n                    while (iter.hasNext())\n                        container.addColumn(iter.next());\n                }\n            }\n\n            // we need to distinguish between \"there is no data at all for this row\" (BF will let us rebuild that efficiently)\n            // and \"there used to be data, but it's gone now\" (we should cache the empty CF so we don't need to rebuild that slower)\n            if (iterators.isEmpty())\n                return null;\n\n            // do a final collate.  toCollate is boilerplate required to provide a CloseableIterator\n            final ColumnFamily c2 = container;\n            CloseableIterator<IColumn> toCollate = new SimpleAbstractColumnIterator()\n            {\n                final Iterator<IColumn> iter = c2.iterator();\n\n                protected IColumn computeNext()\n                {\n                    return iter.hasNext() ? iter.next() : endOfData();\n                }\n\n                public ColumnFamily getColumnFamily()\n                {\n                    return c2;\n                }\n\n                public DecoratedKey getKey()\n                {\n                    return filter.key;\n                }\n            };\n            ColumnFamily returnCF = container.cloneMeShallow();\n            filter.collateColumns(returnCF, Collections.singletonList(toCollate), cfs.metadata.comparator, gcBefore);\n\n            // Caller is responsible for final removeDeletedCF.  This is important for cacheRow to work correctly:\n            return returnCF;\n        }\n        finally\n        {\n            SSTableReader.releaseReferences(view.sstables);\n            for (IColumnIterator iter : iterators)\n                FileUtils.closeQuietly(iter);\n        }\n    }","id":93463,"modified_method":"/**\n     * Collects data in order of recency, using the sstable maxtimestamp data.\n     * Once we have data for all requests columns that is newer than the newest remaining maxtimestamp,\n     * we stop.\n     */\n    private ColumnFamily collectTimeOrderedData()\n    {\n        logger.debug(\"collectTimeOrderedData\");\n\n        ColumnFamily container = ColumnFamily.create(cfs.metadata, factory, filter.filter.isReversed());\n        List<IColumnIterator> iterators = new ArrayList<IColumnIterator>();\n        ColumnFamilyStore.ViewFragment view = cfs.markReferenced(filter.key);\n        try\n        {\n            for (Memtable memtable : view.memtables)\n            {\n                IColumnIterator iter = filter.getMemtableColumnIterator(memtable, cfs.metadata.comparator);\n                if (iter != null)\n                {\n                    iterators.add(iter);\n                    container.delete(iter.getColumnFamily());\n                    while (iter.hasNext())\n                        container.addColumn(iter.next());\n                }\n            }\n\n            // avoid changing the filter columns of the original filter\n            // (reduceNameFilter removes columns that are known to be irrelevant)\n            TreeSet<ByteBuffer> filterColumns = new TreeSet<ByteBuffer>(cfs.metadata.comparator);\n            filterColumns.addAll(((NamesQueryFilter) filter.filter).columns);\n            QueryFilter reducedFilter = new QueryFilter(filter.key, filter.path, new NamesQueryFilter(filterColumns));\n\n            /* add the SSTables on disk */\n            Collections.sort(view.sstables, SSTable.maxTimestampComparator);\n\n            // read sorted sstables\n            for (SSTableReader sstable : view.sstables)\n            {\n                long currentMaxTs = sstable.getMaxTimestamp();\n                reduceNameFilter(reducedFilter, container, currentMaxTs);\n                if (((NamesQueryFilter) reducedFilter.filter).columns.isEmpty())\n                    break;\n\n                IColumnIterator iter = reducedFilter.getSSTableColumnIterator(sstable);\n                iterators.add(iter);\n                if (iter.getColumnFamily() != null)\n                {\n                    container.delete(iter.getColumnFamily());\n                    sstablesIterated++;\n                    while (iter.hasNext())\n                        container.addColumn(iter.next());\n                }\n            }\n\n            // we need to distinguish between \"there is no data at all for this row\" (BF will let us rebuild that efficiently)\n            // and \"there used to be data, but it's gone now\" (we should cache the empty CF so we don't need to rebuild that slower)\n            if (iterators.isEmpty())\n                return null;\n\n            // do a final collate.  toCollate is boilerplate required to provide a CloseableIterator\n            final ColumnFamily c2 = container;\n            CloseableIterator<IColumn> toCollate = new SimpleAbstractColumnIterator()\n            {\n                final Iterator<IColumn> iter = c2.iterator();\n\n                protected IColumn computeNext()\n                {\n                    return iter.hasNext() ? iter.next() : endOfData();\n                }\n\n                public ColumnFamily getColumnFamily()\n                {\n                    return c2;\n                }\n\n                public DecoratedKey getKey()\n                {\n                    return filter.key;\n                }\n            };\n            ColumnFamily returnCF = container.cloneMeShallow();\n            filter.collateColumns(returnCF, Collections.singletonList(toCollate), cfs.metadata.comparator, gcBefore);\n\n            // Caller is responsible for final removeDeletedCF.  This is important for cacheRow to work correctly:\n            return returnCF;\n        }\n        finally\n        {\n            for (IColumnIterator iter : iterators)\n                FileUtils.closeQuietly(iter);\n            SSTableReader.releaseReferences(view.sstables);\n        }\n    }","commit_id":"0d37eb1b6161c2231df16f3454a6c61819536107","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Collects data the brute-force way: gets an iterator for the filter in question\n     * from every memtable and sstable, then merges them together.\n     */\n    private ColumnFamily collectAllData()\n    {\n        logger.debug(\"collectAllData\");\n        List<IColumnIterator> iterators = new ArrayList<IColumnIterator>();\n        ColumnFamily returnCF = ColumnFamily.create(cfs.metadata, factory, filter.filter.isReversed());\n\n        ColumnFamilyStore.ViewFragment view = cfs.markReferenced(filter.key);\n        try\n        {\n            for (Memtable memtable : view.memtables)\n            {\n                IColumnIterator iter = filter.getMemtableColumnIterator(memtable, cfs.metadata.comparator);\n                if (iter != null)\n                {\n                    returnCF.delete(iter.getColumnFamily());\n                    iterators.add(iter);\n                }\n            }\n\n            for (SSTableReader sstable : view.sstables)\n            {\n                IColumnIterator iter = filter.getSSTableColumnIterator(sstable);\n                iterators.add(iter);\n                if (iter.getColumnFamily() != null)\n                {\n                    returnCF.delete(iter.getColumnFamily());\n                    sstablesIterated++;\n                }\n            }\n\n            // we need to distinguish between \"there is no data at all for this row\" (BF will let us rebuild that efficiently)\n            // and \"there used to be data, but it's gone now\" (we should cache the empty CF so we don't need to rebuild that slower)\n            if (iterators.isEmpty())\n                return null;\n\n            filter.collateColumns(returnCF, iterators, cfs.metadata.comparator, gcBefore);\n\n            // Caller is responsible for final removeDeletedCF.  This is important for cacheRow to work correctly:\n            return returnCF;\n        }\n        finally\n        {\n            SSTableReader.releaseReferences(view.sstables);\n            for (IColumnIterator iter : iterators)\n                FileUtils.closeQuietly(iter);\n        }\n    }","id":93464,"modified_method":"/**\n     * Collects data the brute-force way: gets an iterator for the filter in question\n     * from every memtable and sstable, then merges them together.\n     */\n    private ColumnFamily collectAllData()\n    {\n        logger.debug(\"collectAllData\");\n        List<IColumnIterator> iterators = new ArrayList<IColumnIterator>();\n        ColumnFamily returnCF = ColumnFamily.create(cfs.metadata, factory, filter.filter.isReversed());\n\n        ColumnFamilyStore.ViewFragment view = cfs.markReferenced(filter.key);\n        try\n        {\n            for (Memtable memtable : view.memtables)\n            {\n                IColumnIterator iter = filter.getMemtableColumnIterator(memtable, cfs.metadata.comparator);\n                if (iter != null)\n                {\n                    returnCF.delete(iter.getColumnFamily());\n                    iterators.add(iter);\n                }\n            }\n\n            for (SSTableReader sstable : view.sstables)\n            {\n                IColumnIterator iter = filter.getSSTableColumnIterator(sstable);\n                iterators.add(iter);\n                if (iter.getColumnFamily() != null)\n                {\n                    returnCF.delete(iter.getColumnFamily());\n                    sstablesIterated++;\n                }\n            }\n\n            // we need to distinguish between \"there is no data at all for this row\" (BF will let us rebuild that efficiently)\n            // and \"there used to be data, but it's gone now\" (we should cache the empty CF so we don't need to rebuild that slower)\n            if (iterators.isEmpty())\n                return null;\n\n            filter.collateColumns(returnCF, iterators, cfs.metadata.comparator, gcBefore);\n\n            // Caller is responsible for final removeDeletedCF.  This is important for cacheRow to work correctly:\n            return returnCF;\n        }\n        finally\n        {\n            for (IColumnIterator iter : iterators)\n                FileUtils.closeQuietly(iter);\n            SSTableReader.releaseReferences(view.sstables);\n        }\n    }","commit_id":"0d37eb1b6161c2231df16f3454a6c61819536107","url":"https://github.com/apache/cassandra"},{"original_method":"public void closeIfFinished() throws IOException\n    {\n        if (files.isEmpty())\n        {\n            HashMap <ColumnFamilyStore, List<SSTableReader>> cfstores = new HashMap<ColumnFamilyStore, List<SSTableReader>>();\n            List<SSTableReader> referenced = new LinkedList<SSTableReader>();\n            try\n            {\n                for (SSTableReader sstable : readers)\n                {\n                    assert sstable.getTableName().equals(table);\n\n                    // Acquiring the reference (for secondary index building) before adding it makes sure we don't have to care about races\n                    sstable.acquireReference();\n                    referenced.add(sstable);\n\n                    ColumnFamilyStore cfs = Table.open(sstable.getTableName()).getColumnFamilyStore(sstable.getColumnFamilyName());\n                    cfs.addSSTable(sstable);\n                    if (!cfstores.containsKey(cfs))\n                        cfstores.put(cfs, new ArrayList<SSTableReader>());\n                    cfstores.get(cfs).add(sstable);\n                }\n\n                // build secondary indexes\n                for (Map.Entry<ColumnFamilyStore, List<SSTableReader>> entry : cfstores.entrySet())\n                {\n                    if (entry.getKey() != null)\n                        entry.getKey().indexManager.maybeBuildSecondaryIndexes(entry.getValue(), entry.getKey().indexManager.getIndexedColumns());\n                }\n            }\n            finally\n            {\n                SSTableReader.releaseReferences(referenced);\n            }\n\n            // send reply to source that we're done\n            StreamReply reply = new StreamReply(\"\", getSessionId(), StreamReply.Status.SESSION_FINISHED);\n            logger.info(\"Finished streaming session {} from {}\", getSessionId(), getHost());\n            MessagingService.instance().sendOneWay(reply.getMessage(Gossiper.instance.getVersion(getHost())), getHost());\n\n            if (callback != null)\n                callback.run();\n            sessions.remove(context);\n        }\n    }","id":93465,"modified_method":"public void closeIfFinished() throws IOException\n    {\n        if (files.isEmpty())\n        {\n            HashMap <ColumnFamilyStore, List<SSTableReader>> cfstores = new HashMap<ColumnFamilyStore, List<SSTableReader>>();\n            List<SSTableReader> referenced = new LinkedList<SSTableReader>();\n            try\n            {\n                for (SSTableReader sstable : readers)\n                {\n                    assert sstable.getTableName().equals(table);\n\n                    // Acquiring the reference (for secondary index building) before adding it makes sure we don't have to care about races\n                    if (!sstable.acquireReference())\n                        throw new RuntimeException(\"We shouldn't fail acquiring a reference on a sstable that has just been transfered\");\n\n                    referenced.add(sstable);\n\n                    ColumnFamilyStore cfs = Table.open(sstable.getTableName()).getColumnFamilyStore(sstable.getColumnFamilyName());\n                    cfs.addSSTable(sstable);\n                    if (!cfstores.containsKey(cfs))\n                        cfstores.put(cfs, new ArrayList<SSTableReader>());\n                    cfstores.get(cfs).add(sstable);\n                }\n\n                // build secondary indexes\n                for (Map.Entry<ColumnFamilyStore, List<SSTableReader>> entry : cfstores.entrySet())\n                {\n                    if (entry.getKey() != null)\n                        entry.getKey().indexManager.maybeBuildSecondaryIndexes(entry.getValue(), entry.getKey().indexManager.getIndexedColumns());\n                }\n            }\n            finally\n            {\n                SSTableReader.releaseReferences(referenced);\n            }\n\n            // send reply to source that we're done\n            StreamReply reply = new StreamReply(\"\", getSessionId(), StreamReply.Status.SESSION_FINISHED);\n            logger.info(\"Finished streaming session {} from {}\", getSessionId(), getHost());\n            MessagingService.instance().sendOneWay(reply.getMessage(Gossiper.instance.getVersion(getHost())), getHost());\n\n            if (callback != null)\n                callback.run();\n            sessions.remove(context);\n        }\n    }","commit_id":"0d37eb1b6161c2231df16f3454a6c61819536107","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Collects data in order of recency, using the sstable maxtimestamp data.\n     * Once we have data for all requests columns that is newer than the newest remaining maxtimestamp,\n     * we stop.\n     */\n    private ColumnFamily collectTimeOrderedData()\n    {\n        logger.debug(\"collectTimeOrderedData\");\n\n        ColumnFamily container = ColumnFamily.create(cfs.metadata, factory, filter.filter.isReversed());\n        List<IColumnIterator> iterators = new ArrayList<IColumnIterator>();\n        ColumnFamilyStore.ViewFragment view = cfs.markReferenced(filter.key);\n        try\n        {\n            for (Memtable memtable : view.memtables)\n            {\n                IColumnIterator iter = filter.getMemtableColumnIterator(memtable, cfs.metadata.comparator);\n                if (iter != null)\n                {\n                    iterators.add(iter);\n                    container.delete(iter.getColumnFamily());\n                    while (iter.hasNext())\n                        container.addColumn(iter.next());\n                }\n            }\n\n            // avoid changing the filter columns of the original filter\n            // (reduceNameFilter removes columns that are known to be irrelevant)\n            TreeSet<ByteBuffer> filterColumns = new TreeSet<ByteBuffer>(cfs.metadata.comparator);\n            filterColumns.addAll(((NamesQueryFilter) filter.filter).columns);\n            QueryFilter reducedFilter = new QueryFilter(filter.key, filter.path, new NamesQueryFilter(filterColumns));\n\n            /* add the SSTables on disk */\n            Collections.sort(view.sstables, SSTable.maxTimestampComparator);\n\n            // read sorted sstables\n            for (SSTableReader sstable : view.sstables)\n            {\n                long currentMaxTs = sstable.getMaxTimestamp();\n                reduceNameFilter(reducedFilter, container, currentMaxTs);\n                if (((NamesQueryFilter) reducedFilter.filter).columns.isEmpty())\n                    break;\n\n                IColumnIterator iter = reducedFilter.getSSTableColumnIterator(sstable);\n                iterators.add(iter);\n                if (iter.getColumnFamily() != null)\n                {\n                    container.delete(iter.getColumnFamily());\n                    sstablesIterated++;\n                    while (iter.hasNext())\n                        container.addColumn(iter.next());\n                }\n            }\n\n            // we need to distinguish between \"there is no data at all for this row\" (BF will let us rebuild that efficiently)\n            // and \"there used to be data, but it's gone now\" (we should cache the empty CF so we don't need to rebuild that slower)\n            if (iterators.isEmpty())\n                return null;\n\n            // do a final collate.  toCollate is boilerplate required to provide a CloseableIterator\n            final ColumnFamily c2 = container;\n            CloseableIterator<IColumn> toCollate = new SimpleAbstractColumnIterator()\n            {\n                final Iterator<IColumn> iter = c2.iterator();\n\n                protected IColumn computeNext()\n                {\n                    return iter.hasNext() ? iter.next() : endOfData();\n                }\n\n                public ColumnFamily getColumnFamily()\n                {\n                    return c2;\n                }\n\n                public DecoratedKey getKey()\n                {\n                    return filter.key;\n                }\n            };\n            ColumnFamily returnCF = container.cloneMeShallow();\n            filter.collateColumns(returnCF, Collections.singletonList(toCollate), cfs.metadata.comparator, gcBefore);\n\n            // Caller is responsible for final removeDeletedCF.  This is important for cacheRow to work correctly:\n            return returnCF;\n        }\n        finally\n        {\n            SSTableReader.releaseReferences(view.sstables);\n            for (IColumnIterator iter : iterators)\n                FileUtils.closeQuietly(iter);\n        }\n    }","id":93466,"modified_method":"/**\n     * Collects data in order of recency, using the sstable maxtimestamp data.\n     * Once we have data for all requests columns that is newer than the newest remaining maxtimestamp,\n     * we stop.\n     */\n    private ColumnFamily collectTimeOrderedData()\n    {\n        logger.debug(\"collectTimeOrderedData\");\n\n        ColumnFamily container = ColumnFamily.create(cfs.metadata, factory, filter.filter.isReversed());\n        List<IColumnIterator> iterators = new ArrayList<IColumnIterator>();\n        ColumnFamilyStore.ViewFragment view = cfs.markReferenced(filter.key);\n        try\n        {\n            for (Memtable memtable : view.memtables)\n            {\n                IColumnIterator iter = filter.getMemtableColumnIterator(memtable, cfs.metadata.comparator);\n                if (iter != null)\n                {\n                    iterators.add(iter);\n                    container.delete(iter.getColumnFamily());\n                    while (iter.hasNext())\n                        container.addColumn(iter.next());\n                }\n            }\n\n            // avoid changing the filter columns of the original filter\n            // (reduceNameFilter removes columns that are known to be irrelevant)\n            TreeSet<ByteBuffer> filterColumns = new TreeSet<ByteBuffer>(cfs.metadata.comparator);\n            filterColumns.addAll(((NamesQueryFilter) filter.filter).columns);\n            QueryFilter reducedFilter = new QueryFilter(filter.key, filter.path, new NamesQueryFilter(filterColumns));\n\n            /* add the SSTables on disk */\n            Collections.sort(view.sstables, SSTable.maxTimestampComparator);\n\n            // read sorted sstables\n            for (SSTableReader sstable : view.sstables)\n            {\n                long currentMaxTs = sstable.getMaxTimestamp();\n                reduceNameFilter(reducedFilter, container, currentMaxTs);\n                if (((NamesQueryFilter) reducedFilter.filter).columns.isEmpty())\n                    break;\n\n                IColumnIterator iter = reducedFilter.getSSTableColumnIterator(sstable);\n                iterators.add(iter);\n                if (iter.getColumnFamily() != null)\n                {\n                    container.delete(iter.getColumnFamily());\n                    sstablesIterated++;\n                    while (iter.hasNext())\n                        container.addColumn(iter.next());\n                }\n            }\n\n            // we need to distinguish between \"there is no data at all for this row\" (BF will let us rebuild that efficiently)\n            // and \"there used to be data, but it's gone now\" (we should cache the empty CF so we don't need to rebuild that slower)\n            if (iterators.isEmpty())\n                return null;\n\n            // do a final collate.  toCollate is boilerplate required to provide a CloseableIterator\n            final ColumnFamily c2 = container;\n            CloseableIterator<IColumn> toCollate = new SimpleAbstractColumnIterator()\n            {\n                final Iterator<IColumn> iter = c2.iterator();\n\n                protected IColumn computeNext()\n                {\n                    return iter.hasNext() ? iter.next() : endOfData();\n                }\n\n                public ColumnFamily getColumnFamily()\n                {\n                    return c2;\n                }\n\n                public DecoratedKey getKey()\n                {\n                    return filter.key;\n                }\n            };\n            ColumnFamily returnCF = container.cloneMeShallow();\n            filter.collateColumns(returnCF, Collections.singletonList(toCollate), cfs.metadata.comparator, gcBefore);\n\n            // Caller is responsible for final removeDeletedCF.  This is important for cacheRow to work correctly:\n            return returnCF;\n        }\n        finally\n        {\n            for (IColumnIterator iter : iterators)\n                FileUtils.closeQuietly(iter);\n            SSTableReader.releaseReferences(view.sstables);\n        }\n    }","commit_id":"471938238e56b52e8291c537655092fd8bfe47c9","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Collects data the brute-force way: gets an iterator for the filter in question\n     * from every memtable and sstable, then merges them together.\n     */\n    private ColumnFamily collectAllData()\n    {\n        logger.debug(\"collectAllData\");\n        List<IColumnIterator> iterators = new ArrayList<IColumnIterator>();\n        ColumnFamily returnCF = ColumnFamily.create(cfs.metadata, factory, filter.filter.isReversed());\n\n        ColumnFamilyStore.ViewFragment view = cfs.markReferenced(filter.key);\n        try\n        {\n            for (Memtable memtable : view.memtables)\n            {\n                IColumnIterator iter = filter.getMemtableColumnIterator(memtable, cfs.metadata.comparator);\n                if (iter != null)\n                {\n                    returnCF.delete(iter.getColumnFamily());\n                    iterators.add(iter);\n                }\n            }\n\n            for (SSTableReader sstable : view.sstables)\n            {\n                IColumnIterator iter = filter.getSSTableColumnIterator(sstable);\n                iterators.add(iter);\n                if (iter.getColumnFamily() != null)\n                {\n                    returnCF.delete(iter.getColumnFamily());\n                    sstablesIterated++;\n                }\n            }\n\n            // we need to distinguish between \"there is no data at all for this row\" (BF will let us rebuild that efficiently)\n            // and \"there used to be data, but it's gone now\" (we should cache the empty CF so we don't need to rebuild that slower)\n            if (iterators.isEmpty())\n                return null;\n\n            filter.collateColumns(returnCF, iterators, cfs.metadata.comparator, gcBefore);\n\n            // Caller is responsible for final removeDeletedCF.  This is important for cacheRow to work correctly:\n            return returnCF;\n        }\n        finally\n        {\n            SSTableReader.releaseReferences(view.sstables);\n            for (IColumnIterator iter : iterators)\n                FileUtils.closeQuietly(iter);\n        }\n    }","id":93467,"modified_method":"/**\n     * Collects data the brute-force way: gets an iterator for the filter in question\n     * from every memtable and sstable, then merges them together.\n     */\n    private ColumnFamily collectAllData()\n    {\n        logger.debug(\"collectAllData\");\n        List<IColumnIterator> iterators = new ArrayList<IColumnIterator>();\n        ColumnFamily returnCF = ColumnFamily.create(cfs.metadata, factory, filter.filter.isReversed());\n\n        ColumnFamilyStore.ViewFragment view = cfs.markReferenced(filter.key);\n        try\n        {\n            for (Memtable memtable : view.memtables)\n            {\n                IColumnIterator iter = filter.getMemtableColumnIterator(memtable, cfs.metadata.comparator);\n                if (iter != null)\n                {\n                    returnCF.delete(iter.getColumnFamily());\n                    iterators.add(iter);\n                }\n            }\n\n            for (SSTableReader sstable : view.sstables)\n            {\n                IColumnIterator iter = filter.getSSTableColumnIterator(sstable);\n                iterators.add(iter);\n                if (iter.getColumnFamily() != null)\n                {\n                    returnCF.delete(iter.getColumnFamily());\n                    sstablesIterated++;\n                }\n            }\n\n            // we need to distinguish between \"there is no data at all for this row\" (BF will let us rebuild that efficiently)\n            // and \"there used to be data, but it's gone now\" (we should cache the empty CF so we don't need to rebuild that slower)\n            if (iterators.isEmpty())\n                return null;\n\n            filter.collateColumns(returnCF, iterators, cfs.metadata.comparator, gcBefore);\n\n            // Caller is responsible for final removeDeletedCF.  This is important for cacheRow to work correctly:\n            return returnCF;\n        }\n        finally\n        {\n            for (IColumnIterator iter : iterators)\n                FileUtils.closeQuietly(iter);\n            SSTableReader.releaseReferences(view.sstables);\n        }\n    }","commit_id":"471938238e56b52e8291c537655092fd8bfe47c9","url":"https://github.com/apache/cassandra"},{"original_method":"public void closeIfFinished() throws IOException\n    {\n        if (files.isEmpty())\n        {\n            HashMap <ColumnFamilyStore, List<SSTableReader>> cfstores = new HashMap<ColumnFamilyStore, List<SSTableReader>>();\n            List<SSTableReader> referenced = new LinkedList<SSTableReader>();\n            try\n            {\n                for (SSTableReader sstable : readers)\n                {\n                    assert sstable.getTableName().equals(table);\n\n                    // Acquiring the reference (for secondary index building) before adding it makes sure we don't have to care about races\n                    sstable.acquireReference();\n                    referenced.add(sstable);\n\n                    ColumnFamilyStore cfs = Table.open(sstable.getTableName()).getColumnFamilyStore(sstable.getColumnFamilyName());\n                    cfs.addSSTable(sstable);\n                    if (!cfstores.containsKey(cfs))\n                        cfstores.put(cfs, new ArrayList<SSTableReader>());\n                    cfstores.get(cfs).add(sstable);\n                }\n\n                // build secondary indexes\n                for (Map.Entry<ColumnFamilyStore, List<SSTableReader>> entry : cfstores.entrySet())\n                {\n                    if (entry.getKey() != null)\n                        entry.getKey().indexManager.maybeBuildSecondaryIndexes(entry.getValue(), entry.getKey().indexManager.getIndexedColumns());\n                }\n            }\n            finally\n            {\n                SSTableReader.releaseReferences(referenced);\n            }\n\n            // send reply to source that we're done\n            StreamReply reply = new StreamReply(\"\", getSessionId(), StreamReply.Status.SESSION_FINISHED);\n            logger.info(\"Finished streaming session {} from {}\", getSessionId(), getHost());\n            MessagingService.instance().sendOneWay(reply.getMessage(Gossiper.instance.getVersion(getHost())), getHost());\n\n            if (callback != null)\n                callback.run();\n            sessions.remove(context);\n        }\n    }","id":93468,"modified_method":"public void closeIfFinished() throws IOException\n    {\n        if (files.isEmpty())\n        {\n            HashMap <ColumnFamilyStore, List<SSTableReader>> cfstores = new HashMap<ColumnFamilyStore, List<SSTableReader>>();\n            List<SSTableReader> referenced = new LinkedList<SSTableReader>();\n            try\n            {\n                for (SSTableReader sstable : readers)\n                {\n                    assert sstable.getTableName().equals(table);\n\n                    // Acquiring the reference (for secondary index building) before adding it makes sure we don't have to care about races\n                    if (!sstable.acquireReference())\n                        throw new RuntimeException(\"We shouldn't fail acquiring a reference on a sstable that has just been transfered\");\n\n                    referenced.add(sstable);\n\n                    ColumnFamilyStore cfs = Table.open(sstable.getTableName()).getColumnFamilyStore(sstable.getColumnFamilyName());\n                    cfs.addSSTable(sstable);\n                    if (!cfstores.containsKey(cfs))\n                        cfstores.put(cfs, new ArrayList<SSTableReader>());\n                    cfstores.get(cfs).add(sstable);\n                }\n\n                // build secondary indexes\n                for (Map.Entry<ColumnFamilyStore, List<SSTableReader>> entry : cfstores.entrySet())\n                {\n                    if (entry.getKey() != null)\n                        entry.getKey().indexManager.maybeBuildSecondaryIndexes(entry.getValue(), entry.getKey().indexManager.getIndexedColumns());\n                }\n            }\n            finally\n            {\n                SSTableReader.releaseReferences(referenced);\n            }\n\n            // send reply to source that we're done\n            StreamReply reply = new StreamReply(\"\", getSessionId(), StreamReply.Status.SESSION_FINISHED);\n            logger.info(\"Finished streaming session {} from {}\", getSessionId(), getHost());\n            MessagingService.instance().sendOneWay(reply.getMessage(Gossiper.instance.getVersion(getHost())), getHost());\n\n            if (callback != null)\n                callback.run();\n            sessions.remove(context);\n        }\n    }","commit_id":"471938238e56b52e8291c537655092fd8bfe47c9","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n\tpublic void txManagerIsResolvedOnInvocationOfTransactionalMethod() {\n\t\tAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n\t\tctx.register(EnableTxConfig.class, TxManagerConfig.class);\n\t\tctx.refresh();\n\t\tTransactionalTestBean bean = ctx.getBean(TransactionalTestBean.class);\n\n\t\t// invoke a transactional method, causing the PlatformTransactionManager bean to be resolved.\n\t\tbean.findAllFoos();\n\t}","id":93469,"modified_method":"@Test\n\tpublic void txManagerIsResolvedOnInvocationOfTransactionalMethod() {\n\t\tAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(EnableTxConfig.class, TxManagerConfig.class);\n\t\tTransactionalTestBean bean = ctx.getBean(TransactionalTestBean.class);\n\n\t\t// invoke a transactional method, causing the PlatformTransactionManager bean to be resolved.\n\t\tbean.findAllFoos();\n\t\tctx.close();\n\t}","commit_id":"6b7c1d72e855fcee2ba1edb852af3d9f472dc551","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void transactionalEventListenerRegisteredProperly() {\n\t\tAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n\t\tctx.register(EnableTxConfig.class);\n\t\tctx.refresh();\n\t\tassertTrue(ctx.containsBean(TransactionManagementConfigUtils\n\t\t\t\t.TRANSACTIONAL_EVENT_LISTENER_FACTORY_BEAN_NAME));\n\t\tassertEquals(1, ctx.getBeansOfType(TransactionalEventListenerFactory.class).size());\n\t}","id":93470,"modified_method":"@Test\n\tpublic void transactionalEventListenerRegisteredProperly() {\n\t\tAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(EnableTxConfig.class);\n\t\tassertTrue(ctx.containsBean(TransactionManagementConfigUtils.TRANSACTIONAL_EVENT_LISTENER_FACTORY_BEAN_NAME));\n\t\tassertEquals(1, ctx.getBeansOfType(TransactionalEventListenerFactory.class).size());\n\t\tctx.close();\n\t}","commit_id":"6b7c1d72e855fcee2ba1edb852af3d9f472dc551","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void txManagerIsResolvedCorrectlyWhenMultipleManagersArePresent() {\n\t\tAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n\t\tctx.register(EnableTxConfig.class, MultiTxManagerConfig.class);\n\t\tctx.refresh();\n\t\tTransactionalTestBean bean = ctx.getBean(TransactionalTestBean.class);\n\n\t\t// invoke a transactional method, causing the PlatformTransactionManager bean to be resolved.\n\t\tbean.findAllFoos();\n\t}","id":93471,"modified_method":"@Test\n\tpublic void txManagerIsResolvedCorrectlyWhenMultipleManagersArePresent() {\n\t\tAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(EnableTxConfig.class, MultiTxManagerConfig.class);\n\t\tTransactionalTestBean bean = ctx.getBean(TransactionalTestBean.class);\n\n\t\t// invoke a transactional method, causing the PlatformTransactionManager bean to be resolved.\n\t\tbean.findAllFoos();\n\t\tctx.close();\n\t}","commit_id":"6b7c1d72e855fcee2ba1edb852af3d9f472dc551","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void transactionProxyIsCreated() {\n\t\tAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n\t\tctx.register(EnableTxConfig.class, TxManagerConfig.class);\n\t\tctx.refresh();\n\t\tTransactionalTestBean bean = ctx.getBean(TransactionalTestBean.class);\n\t\tassertThat(\"testBean is not a proxy\", AopUtils.isAopProxy(bean), is(true));\n\t\tMap<?,?> services = ctx.getBeansWithAnnotation(Service.class);\n\t\tassertThat(\"Stereotype annotation not visible\", services.containsKey(\"testBean\"), is(true));\n\t}","id":93472,"modified_method":"@Test\n\tpublic void transactionProxyIsCreated() {\n\t\tAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(EnableTxConfig.class, TxManagerConfig.class);\n\t\tTransactionalTestBean bean = ctx.getBean(TransactionalTestBean.class);\n\t\tassertTrue(\"testBean is not a proxy\", AopUtils.isAopProxy(bean));\n\t\tMap<?,?> services = ctx.getBeansWithAnnotation(Service.class);\n\t\tassertTrue(\"Stereotype annotation not visible\", services.containsKey(\"testBean\"));\n\t\tctx.close();\n\t}","commit_id":"6b7c1d72e855fcee2ba1edb852af3d9f472dc551","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void spr11915() {\n\t\tAnnotationConfigApplicationContext ctx =\n\t\t\t\tnew AnnotationConfigApplicationContext(Spr11915Config.class);\n\n\t\tTransactionalTestBean bean = ctx.getBean(TransactionalTestBean.class);\n\t\tbean.saveQualifiedFoo();\n\n\t\tCallCountingTransactionManager txManager = ctx\n\t\t\t\t.getBean(\"qualifiedTransactionManager\", CallCountingTransactionManager.class);\n\t\tassertThat(txManager.begun, equalTo(1));\n\t\tassertThat(txManager.commits, equalTo(1));\n\t\tassertThat(txManager.rollbacks, equalTo(0));\n\t}","id":93473,"modified_method":"@Test\n\tpublic void spr11915() {\n\t\tAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(Spr11915Config.class);\n\t\tTransactionalTestBean bean = ctx.getBean(TransactionalTestBean.class);\n\t\tCallCountingTransactionManager txManager = ctx.getBean(\"qualifiedTransactionManager\", CallCountingTransactionManager.class);\n\n\t\tbean.saveQualifiedFoo();\n\t\tassertThat(txManager.begun, equalTo(1));\n\t\tassertThat(txManager.commits, equalTo(1));\n\t\tassertThat(txManager.rollbacks, equalTo(0));\n\n\t\tbean.saveQualifiedFooWithAttributeAlias();\n\t\tassertThat(txManager.begun, equalTo(2));\n\t\tassertThat(txManager.commits, equalTo(2));\n\t\tassertThat(txManager.rollbacks, equalTo(0));\n\n\t\tctx.close();\n\t}","commit_id":"6b7c1d72e855fcee2ba1edb852af3d9f472dc551","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void transactionProxyIsCreatedWithEnableOnSuperclass() {\n\t\tAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n\t\tctx.register(InheritedEnableTxConfig.class, TxManagerConfig.class);\n\t\tctx.refresh();\n\t\tTransactionalTestBean bean = ctx.getBean(TransactionalTestBean.class);\n\t\tassertThat(\"testBean is not a proxy\", AopUtils.isAopProxy(bean), is(true));\n\t\tMap<?,?> services = ctx.getBeansWithAnnotation(Service.class);\n\t\tassertThat(\"Stereotype annotation not visible\", services.containsKey(\"testBean\"), is(true));\n\t}","id":93474,"modified_method":"@Test\n\tpublic void transactionProxyIsCreatedWithEnableOnSuperclass() {\n\t\tAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(InheritedEnableTxConfig.class, TxManagerConfig.class);\n\t\tTransactionalTestBean bean = ctx.getBean(TransactionalTestBean.class);\n\t\tassertTrue(\"testBean is not a proxy\", AopUtils.isAopProxy(bean));\n\t\tMap<?,?> services = ctx.getBeansWithAnnotation(Service.class);\n\t\tassertTrue(\"Stereotype annotation not visible\", services.containsKey(\"testBean\"));\n\t\tctx.close();\n\t}","commit_id":"6b7c1d72e855fcee2ba1edb852af3d9f472dc551","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * A cheap test just to prove that in ASPECTJ mode, the AnnotationTransactionAspect does indeed\n\t * get loaded -- or in this case, attempted to be loaded at which point the test fails.\n\t */\n\t@Test\n\tpublic void proxyTypeAspectJCausesRegistrationOfAnnotationTransactionAspect() {\n\t\ttry {\n\t\t\tnew AnnotationConfigApplicationContext(EnableAspectJTxConfig.class, TxManagerConfig.class);\n\t\t\tfail(\"should have thrown CNFE when trying to load AnnotationTransactionAspect. \" +\n\t\t\t\t\t\"Do you actually have org.springframework.aspects on the classpath?\");\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tassertThat(ex.getMessage().contains(\"AspectJTransactionManagementConfiguration\"), is(true));\n\t\t}\n\t}","id":93475,"modified_method":"/**\n\t * A cheap test just to prove that in ASPECTJ mode, the AnnotationTransactionAspect does indeed\n\t * get loaded -- or in this case, attempted to be loaded at which point the test fails.\n\t */\n\t@Test\n\tpublic void proxyTypeAspectJCausesRegistrationOfAnnotationTransactionAspect() {\n\t\ttry {\n\t\t\tnew AnnotationConfigApplicationContext(EnableAspectJTxConfig.class, TxManagerConfig.class);\n\t\t\tfail(\"should have thrown CNFE when trying to load AnnotationTransactionAspect. \" +\n\t\t\t\t\t\"Do you actually have org.springframework.aspects on the classpath?\");\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tassertThat(ex.getMessage(), containsString(\"AspectJTransactionManagementConfiguration\"));\n\t\t}\n\t}","commit_id":"6b7c1d72e855fcee2ba1edb852af3d9f472dc551","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    e.getPresentation().setVisible(!SystemInfo.isMacSystemMenu || !ActionPlaces.MAIN_MENU.equals(e.getPlace()));\n  }","id":93476,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    final String place = e.getPlace();\n    if (ActionPlaces.WELCOME_SCREEN.equals(place) && FlatWelcomeFrameProvider.isAvailable()) {\n      e.getPresentation().setEnabledAndVisible(true);\n    } else {\n      e.getPresentation().setVisible(!SystemInfo.isMacSystemMenu || !ActionPlaces.MAIN_MENU.equals(place));\n    }\n  }","commit_id":"e3c397416ad34977e32152c36d8a5ecba6d06870","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JComponent createActionLink(final String text, final String groupId, Icon icon, boolean focusListOnLeft) {\n      final Ref<ActionLink> ref = new Ref<ActionLink>(null);\n      AnAction action = new AnAction() {\n        @Override\n        public void actionPerformed(@NotNull AnActionEvent e) {\n          ActionGroup configureGroup = (ActionGroup)ActionManager.getInstance().getAction(groupId);\n          final PopupFactoryImpl.ActionGroupPopup popup = (PopupFactoryImpl.ActionGroupPopup)JBPopupFactory.getInstance()\n            .createActionGroupPopup(null, new IconsFreeActionGroup(configureGroup), e.getDataContext(), false, false, false, null,\n                                    10, null);\n          popup.showUnderneathOfLabel(ref.get());\n        }\n      };\n      ref.set(new ActionLink(text, icon, action));\n      ref.get().setPaintUnderline(false);\n      ref.get().setNormalColor(getLinkNormalColor());\n      NonOpaquePanel panel = new NonOpaquePanel(new BorderLayout());\n      panel.setBorder(new EmptyBorder(4, 10, 4, 10));\n      panel.add(ref.get());\n      panel.add(createArrow(ref.get()), BorderLayout.EAST);\n      installFocusable(panel, action, KeyEvent.VK_UP, KeyEvent.VK_DOWN, focusListOnLeft);\n      return panel;\n    }","id":93477,"modified_method":"private JComponent createActionLink(final String text, final String groupId, Icon icon, boolean focusListOnLeft) {\n      final Ref<ActionLink> ref = new Ref<ActionLink>(null);\n      AnAction action = new AnAction() {\n        @Override\n        public void actionPerformed(@NotNull AnActionEvent e) {\n          ActionGroup configureGroup = (ActionGroup)ActionManager.getInstance().getAction(groupId);\n          final PopupFactoryImpl.ActionGroupPopup popup = (PopupFactoryImpl.ActionGroupPopup)JBPopupFactory.getInstance()\n            .createActionGroupPopup(null, new IconsFreeActionGroup(configureGroup), e.getDataContext(), JBPopupFactory.ActionSelectionAid.SPEEDSEARCH, false, ActionPlaces.WELCOME_SCREEN);\n          popup.showUnderneathOfLabel(ref.get());\n        }\n      };\n      ref.set(new ActionLink(text, icon, action));\n      ref.get().setPaintUnderline(false);\n      ref.get().setNormalColor(getLinkNormalColor());\n      NonOpaquePanel panel = new NonOpaquePanel(new BorderLayout());\n      panel.setBorder(new EmptyBorder(4, 10, 4, 10));\n      panel.add(ref.get());\n      panel.add(createArrow(ref.get()), BorderLayout.EAST);\n      installFocusable(panel, action, KeyEvent.VK_UP, KeyEvent.VK_DOWN, focusListOnLeft);\n      return panel;\n    }","commit_id":"e3c397416ad34977e32152c36d8a5ecba6d06870","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(AnActionEvent e) {\n    PsiFile file = e.getData(CommonDataKeys.PSI_FILE);\n    Presentation presentation = e.getPresentation();\n    boolean enabled = file instanceof PsiClassOwner && e.getPlace() != ActionPlaces.EDITOR_POPUP && e.getData(CommonDataKeys.PROJECT) != null;\n    presentation.setEnabled(enabled);\n    presentation.setVisible(enabled);\n    if (enabled) {\n      presentation.setText(RENAME_FILE);\n      presentation.setDescription(\"Rename selected file\");\n    }\n  }","id":93478,"modified_method":"public void update(AnActionEvent e) {\n    PsiFile file = e.getData(CommonDataKeys.PSI_FILE);\n    Presentation presentation = e.getPresentation();\n    String place = e.getPlace();\n    boolean enabled = (file instanceof PsiClassOwner || ActionPlaces.EDITOR_TAB_POPUP.equals(place)) && place != ActionPlaces.EDITOR_POPUP && e.getData(CommonDataKeys.PROJECT) != null;\n    presentation.setEnabled(enabled);\n    presentation.setVisible(enabled);\n    if (enabled) {\n      presentation.setText(RENAME_FILE);\n      presentation.setDescription(\"Rename selected file\");\n    }\n  }","commit_id":"58de0c83c364703b19d44202b327b108c654b560","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getRequiredData(CommonDataKeys.PROJECT);\n    if (ChangeListManager.getInstance(project).isFreezedWithNotification(\"Can not apply patch now\")) return;\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    if (isProjectOrScopeView(e.getPlace())) {\n      VirtualFile vFile = e.getRequiredData(CommonDataKeys.VIRTUAL_FILE);\n      showApplyPatch(project, vFile);\n    }\n    else {\n      final FileChooserDescriptor descriptor = ApplyPatchDifferentiatedDialog.createSelectPatchDescriptor();\n      final VcsApplicationSettings settings = VcsApplicationSettings.getInstance();\n      final VirtualFile toSelect = settings.PATCH_STORAGE_LOCATION == null ? null :\n                                   LocalFileSystem.getInstance().refreshAndFindFileByIoFile(new File(settings.PATCH_STORAGE_LOCATION));\n\n      FileChooser.chooseFile(descriptor, project, toSelect, new Consumer<VirtualFile>() {\n        @Override\n        public void consume(VirtualFile file) {\n          final VirtualFile parent = file.getParent();\n          if (parent != null) {\n            settings.PATCH_STORAGE_LOCATION = FileUtil.toSystemDependentName(parent.getPath());\n          }\n          showApplyPatch(project, file);\n        }\n      });\n    }\n  }","id":93479,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getRequiredData(CommonDataKeys.PROJECT);\n    if (ChangeListManager.getInstance(project).isFreezedWithNotification(\"Can not apply patch now\")) return;\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    VirtualFile vFile = null;\n    final String place = e.getPlace();\n    if (isProjectOrScopeView(place) || ActionPlaces.MAIN_MENU.equals(place)) {\n      vFile = e.getData(CommonDataKeys.VIRTUAL_FILE);\n    }\n    if (isPatchFile(vFile)) {\n      showApplyPatch(project, vFile);\n    }\n    else {\n      final FileChooserDescriptor descriptor = ApplyPatchDifferentiatedDialog.createSelectPatchDescriptor();\n      final VcsApplicationSettings settings = VcsApplicationSettings.getInstance();\n      final VirtualFile toSelect = settings.PATCH_STORAGE_LOCATION == null ? null :\n                                   LocalFileSystem.getInstance().refreshAndFindFileByIoFile(new File(settings.PATCH_STORAGE_LOCATION));\n\n      FileChooser.chooseFile(descriptor, project, toSelect, new Consumer<VirtualFile>() {\n        @Override\n        public void consume(VirtualFile file) {\n          final VirtualFile parent = file.getParent();\n          if (parent != null) {\n            settings.PATCH_STORAGE_LOCATION = FileUtil.toSystemDependentName(parent.getPath());\n          }\n          showApplyPatch(project, file);\n        }\n      });\n    }\n  }","commit_id":"4965a05b748373221698fbe1cd087bcb9b0b6098","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    Project project = e.getData(CommonDataKeys.PROJECT);\n    if (isProjectOrScopeView(e.getPlace())) {\n      VirtualFile vFile = e.getData(CommonDataKeys.VIRTUAL_FILE);\n      e.getPresentation().setEnabledAndVisible(project != null && vFile != null && vFile.getFileType() == StdFileTypes.PATCH);\n    }\n    else {\n      e.getPresentation().setVisible(true);\n      e.getPresentation().setEnabled(project != null);\n    }\n  }","id":93480,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    Project project = e.getData(CommonDataKeys.PROJECT);\n    if (isProjectOrScopeView(e.getPlace())) {\n      VirtualFile vFile = e.getData(CommonDataKeys.VIRTUAL_FILE);\n      e.getPresentation().setEnabledAndVisible(project != null && isPatchFile(vFile));\n    }\n    else {\n      e.getPresentation().setVisible(true);\n      e.getPresentation().setEnabled(project != null);\n    }\n  }","commit_id":"4965a05b748373221698fbe1cd087bcb9b0b6098","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InterceptingChainCompositeMessageProcessor(InterceptingMessageProcessor firstInChain,\n                                                      List<MessageProcessor> allProcessors,\n                                                      String name)\n    {\n        this.name = name;\n        this.firstInChain = firstInChain;\n        this.allProcessors = allProcessors;\n        // TODO You a custom categories?\n        log = LogFactory.getLog(InterceptingChainCompositeMessageProcessor.class);\n    }","id":93481,"modified_method":"public InterceptingChainCompositeMessageProcessor(InterceptingMessageProcessor chain,\n                                                      List<MessageProcessor> processors,\n                                                      String name)\n    {\n        super(name, processors);\n        this.chain = chain;\n    }","commit_id":"f8c616627b8e9d7e4626e201a5fee3e516447a71","url":"https://github.com/mulesoft/mule"},{"original_method":"public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        if (log.isDebugEnabled())\n        {\n            log.debug(\"Invoking \" + this + \" with event \" + event);\n        }\n        return firstInChain.process(event);\n    }","id":93482,"modified_method":"protected MuleEvent doProcess(MuleEvent event) throws MuleException\n    {\n        return chain.process(event);\n    }","commit_id":"f8c616627b8e9d7e4626e201a5fee3e516447a71","url":"https://github.com/mulesoft/mule"},{"original_method":"public MessageProcessor build() throws MuleException\n    {\n        if (processors.isEmpty())\n        {\n            return new NullMessageProcessor();\n        }\n\n        InterceptingMessageProcessor first = createInterceptingMessageProcessor(initializeMessageProcessor(processors.get(0)));\n        MessageProcessor composite = new InterceptingChainCompositeMessageProcessor(first, processors, name);\n        InterceptingMessageProcessor current = first;\n\n        for (int i = 1; i < processors.size(); i++)\n        {\n            InterceptingMessageProcessor mp = createInterceptingMessageProcessor(initializeMessageProcessor(processors.get(i)));\n            current.setListener(mp);\n            current = mp;\n        }\n        return composite;\n    }","id":93483,"modified_method":"public MessageProcessor build() throws MuleException\n    {\n        LinkedList<MessageProcessor> tempList = new LinkedList<MessageProcessor>();\n\n        // Start from last but one message processor and work backwards\n        for (int i = processors.size() - 1; i >= 0; i--)\n        {\n            MessageProcessor processor = initializeMessageProcessor(processors.get(i));\n            if ((processors.get(i)) instanceof InterceptingMessageProcessor)\n            {\n                if (i + 1 < processors.size())\n                {\n                    if (tempList.isEmpty())\n                    {\n                        ((InterceptingMessageProcessor) processor).setListener(initializeMessageProcessor(processors.get(i + 1)));\n                    }\n                    else\n                    {\n                        ((InterceptingMessageProcessor) processor).setListener(new IteratingListCompositeMessageProcessor(\n                            new ArrayList<MessageProcessor>(tempList)));\n                    }\n                }\n                tempList = new LinkedList<MessageProcessor>(Collections.singletonList(processor));\n            }\n            else\n            {\n                tempList.addFirst(initializeMessageProcessor(processor));\n            }\n        }\n        return new InterceptingChainCompositeMessageProcessor(new IteratingListCompositeMessageProcessor(\n            new ArrayList<MessageProcessor>(tempList)), processors, \"\");\n    }","commit_id":"f8c616627b8e9d7e4626e201a5fee3e516447a71","url":"https://github.com/mulesoft/mule"},{"original_method":"public MessageProcessor build() throws MuleException\n    {\n        if (processors.isEmpty())\n        {\n            return new NullMessageProcessor();\n        }\n        return new IteratingListCompositeMessageProcessor(processors, name);\n    }","id":93484,"modified_method":"public MessageProcessor build() throws MuleException\n    {\n        if (processors.isEmpty())\n        {\n            return new NullMessageProcessor();\n        }\n        return new IteratingListCompositeMessageProcessor(name, processors);\n    }","commit_id":"f8c616627b8e9d7e4626e201a5fee3e516447a71","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * This builder supports the chaining together of message processors that intercept and also those that\n     * don't. While one can iterate over message processor intercepting message processors need to be chained\n     * together. One solution is make all message processors intercepting (via adaption) and chain them all\n     * together, this results in huge stack traces and recursive calls with adaptor. The alternative is to\n     * build the chain in such a way that we iterate when we can and chain where we need to. <br>\n     * We iterate over the list of message processor to be chained together in reverse order collecting up\n     * those that can be iterated over in a temporary list, as soon as we have an intercepting message\n     * processor we create a DefaultMessageProcessorChain using the temporary list and set it as a listener of\n     * the intercepting message processor and then we continue with the algorithm\n     */\n    public MessageProcessorChain build() throws MuleException\n    {\n        LinkedList<MessageProcessor> tempList = new LinkedList<MessageProcessor>();\n\n        // Start from last but one message processor and work backwards\n        for (int i = processors.size() - 1; i >= 0; i--)\n        {\n            MessageProcessor processor = initializeMessageProcessor(processors.get(i));\n            if ((processors.get(i)) instanceof InterceptingMessageProcessor)\n            {\n                // Processor is intercepting so we can't simply iterate\n                if (i + 1 < processors.size())\n                {\n                    // The current processor is not the last in the list\n                    if (tempList.isEmpty())\n                    {\n                        ((InterceptingMessageProcessor) processor).setListener(initializeMessageProcessor(processors.get(i + 1)));\n                    }\n                    else\n                    {\n                        final DefaultMessageProcessorChain chain = new DefaultMessageProcessorChain(\n                            new ArrayList<MessageProcessor>(tempList));\n                        ((InterceptingMessageProcessor) processor).setListener(chain);\n                    }\n                }\n                tempList = new LinkedList<MessageProcessor>(Collections.singletonList(processor));\n            }\n            else\n            {\n                // Processor is not intercepting so we can invoke it using iteration (add to temp list)\n                tempList.addFirst(initializeMessageProcessor(processor));\n            }\n        }\n        // Create the final chain using the current tempList after reserve iteration is complete. This temp\n        // list contains the first n processors in the chain that are not intercepting.. with processor n+1\n        // having been injected as the listener of processor n\n        final DefaultMessageProcessorChain chain = new DefaultMessageProcessorChain(\n            new ArrayList<MessageProcessor>(tempList));\n\n        // Wrap with something that can apply lifecycle to all processors which are otherwise not visable from\n        // DefaultMessageProcessorChain\n        return new InterceptingChainLifecycleWrapper(chain, processors, \"\");\n    }","id":93485,"modified_method":"/**\n     * This builder supports the chaining together of message processors that intercept and also those that\n     * don't. While one can iterate over message processor intercepting message processors need to be chained\n     * together. One solution is make all message processors intercepting (via adaption) and chain them all\n     * together, this results in huge stack traces and recursive calls with adaptor. The alternative is to\n     * build the chain in such a way that we iterate when we can and chain where we need to. <br>\n     * We iterate over the list of message processor to be chained together in reverse order collecting up\n     * those that can be iterated over in a temporary list, as soon as we have an intercepting message\n     * processor we create a DefaultMessageProcessorChain using the temporary list and set it as a listener of\n     * the intercepting message processor and then we continue with the algorithm\n     */\n    public MessageProcessorChain build() throws MuleException\n    {\n        InterceptingMessageProcessorChain finalChain = new InterceptingMessageProcessorChain(null, null, \"\");\n\n        LinkedList<MessageProcessor> tempList = new LinkedList<MessageProcessor>();\n\n        // Start from last but one message processor and work backwards\n        for (int i = processors.size() - 1; i >= 0; i--)\n        {\n            MessageProcessor processor = decorateMessageProcessorForCallbacks(\n                initializeMessageProcessor(processors.get(i)), finalChain);\n            if ((processors.get(i)) instanceof InterceptingMessageProcessor)\n            {\n                // Processor is intercepting so we can't simply iterate\n                if (i + 1 < processors.size())\n                {\n                    // The current processor is not the last in the list\n                    if (tempList.isEmpty())\n                    {\n                        ((InterceptingMessageProcessor) processor).setListener(decorateMessageProcessorForCallbacks(\n                            initializeMessageProcessor(processors.get(i + 1)), finalChain));\n                    }\n                    else\n                    {\n                        final IteratingCompositeMessageProcessor chain = new IteratingCompositeMessageProcessor(\n                            new ArrayList<MessageProcessor>(tempList));\n                        ((InterceptingMessageProcessor) processor).setListener(chain);\n                    }\n                }\n                tempList = new LinkedList<MessageProcessor>(Collections.singletonList(processor));\n            }\n            else\n            {\n                // Processor is not intercepting so we can invoke it using iteration (add to temp list)\n                tempList.addFirst(processor);\n            }\n        }\n        // Create the final chain using the current tempList after reserve iteration is complete. This temp\n        // list contains the first n processors in the chain that are not intercepting.. with processor n+1\n        // having been injected as the listener of processor n\n        final IteratingCompositeMessageProcessor chain = new IteratingCompositeMessageProcessor(\n            new ArrayList<MessageProcessor>(tempList));\n\n        // Wrap with something that can apply lifecycle to all processors which are otherwise not visable from\n        // DefaultMessageProcessorChain\n        finalChain.setFirstInChain(chain);\n        finalChain.setMessageProcessors(processors);\n        return finalChain;\n    }","commit_id":"a1fffd31ab520894f28c2cc251e84ac5bc3bad9a","url":"https://github.com/mulesoft/mule"},{"original_method":"public static MessageProcessorChain singletonChain(MessageProcessor mp)\r\n    {\r\n        return new DefaultMessageProcessorChain(mp);\r\n    }","id":93486,"modified_method":"public static MessageProcessorChain singletonChain(MessageProcessor mp)\r\n    {\r\n        return new InterceptingMessageProcessorChain(mp, Collections.singletonList(mp), \"\");\r\n    }","commit_id":"a1fffd31ab520894f28c2cc251e84ac5bc3bad9a","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testMultiplePolicies() throws Exception\r\n    {\r\n\r\n        // this is our regular chain that should get a policy applied\r\n        DefaultMessageProcessorChain chain = new DefaultMessageProcessorChain(\r\n                                                             new StringAppendTransformer(\"first\"),\r\n                                                             new StringAppendTransformer(\" second\"));\r\n        initialiseObject(chain);\r\n\r\n        // test registration\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n        AroundPolicy policy1 = new TestPolicy(\"test around policy 1\");\r\n        chain.getPolicies().add(policy1);\r\n        // add another policy\r\n        final TestPolicy policy2 = new TestPolicy(\"test around policy 2\");\r\n        chain.getPolicies().add(policy2);\r\n        assertEquals(\"Wrong policies count.\", 2, chain.getPolicies().list().size());\r\n\r\n        System.out.println(chain);\r\n\r\n        // invoke\r\n        final MuleEvent result = chain.process(getTestEvent(\"payload \"));\r\n        assertNotNull(result);\r\n        final MuleMessage message = result.getMessage();\r\n        assertNotNull(message);\r\n        assertEquals(\"payload {before} {before} first second {after} {after}\", message.getPayload());\r\n\r\n        // test cleanup\r\n        final AroundPolicy policy = chain.getPolicies().remove(policy1.getName());\r\n        assertSame(\"Wrong policy returned?\", policy1, policy);\r\n        chain.getPolicies().remove(policy2.getName());\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n    }","id":93487,"modified_method":"public void testMultiplePolicies() throws Exception\r\n    {\r\n\r\n        // this is our regular chain that should get a policy applied\r\n        MessageProcessorChain chain = new DefaultMessageProcessorChainBuilder().chain(\r\n            new StringAppendTransformer(\"first\"), new StringAppendTransformer(\" second\")).build();\r\n\r\n        initialiseObject(chain);\r\n\r\n        // test registration\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n        AroundPolicy policy1 = new TestPolicy(\"test around policy 1\");\r\n        chain.getPolicies().add(policy1);\r\n        // add another policy\r\n        final TestPolicy policy2 = new TestPolicy(\"test around policy 2\");\r\n        chain.getPolicies().add(policy2);\r\n        assertEquals(\"Wrong policies count.\", 2, chain.getPolicies().list().size());\r\n\r\n        System.out.println(chain);\r\n\r\n        // invoke\r\n        final MuleEvent result = chain.process(getTestEvent(\"payload \"));\r\n        assertNotNull(result);\r\n        final MuleMessage message = result.getMessage();\r\n        assertNotNull(message);\r\n        assertEquals(\"payload {before} {before} first second {after} {after}\", message.getPayload());\r\n\r\n        // test cleanup\r\n        final AroundPolicy policy = chain.getPolicies().remove(policy1.getName());\r\n        assertSame(\"Wrong policy returned?\", policy1, policy);\r\n        chain.getPolicies().remove(policy2.getName());\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n    }","commit_id":"a1fffd31ab520894f28c2cc251e84ac5bc3bad9a","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testSinglePolicy() throws Exception\r\n    {\r\n        AroundPolicy ap = new TestPolicy(\"test around policy\");\r\n\r\n        // this is our regular chain that should get a policy applied\r\n        DefaultMessageProcessorChain chain = new DefaultMessageProcessorChain(\r\n                                                             new StringAppendTransformer(\"first\"),\r\n                                                             new StringAppendTransformer(\" second\"));\r\n        initialiseObject(chain);\r\n\r\n        // test registration\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n        chain.getPolicies().add(ap);\r\n        assertSame(\"Policy has not been registered.\", ap, chain.getPolicies().list().iterator().next());\r\n\r\n        System.out.println(chain);\r\n\r\n        // invoke\r\n        final MuleEvent result = chain.process(getTestEvent(\"payload \"));\r\n        assertNotNull(result);\r\n        final MuleMessage message = result.getMessage();\r\n        assertNotNull(message);\r\n        assertEquals(\"payload {before} first second {after}\", message.getPayload());\r\n\r\n        // test cleanup\r\n        final AroundPolicy policy = chain.getPolicies().remove(ap.getName());\r\n        assertSame(\"Wrong policy returned?\", ap, policy);\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n    }","id":93488,"modified_method":"public void testSinglePolicy() throws Exception\r\n    {\r\n        AroundPolicy ap = new TestPolicy(\"test around policy\");\r\n\r\n        \r\n        \r\n        // this is our regular chain that should get a policy applied\r\n        MessageProcessorChain chain = new DefaultMessageProcessorChainBuilder().chain(\r\n            new StringAppendTransformer(\"first\"), new StringAppendTransformer(\" second\")).build();\r\n\r\n        initialiseObject(chain);\r\n\r\n        // test registration\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n        chain.getPolicies().add(ap);\r\n        assertSame(\"Policy has not been registered.\", ap, chain.getPolicies().list().iterator().next());\r\n\r\n        System.out.println(chain);\r\n\r\n        // invoke\r\n        final MuleEvent result = chain.process(getTestEvent(\"payload \"));\r\n        assertNotNull(result);\r\n        final MuleMessage message = result.getMessage();\r\n        assertNotNull(message);\r\n        assertEquals(\"payload {before} first second {after}\", message.getPayload());\r\n\r\n        // test cleanup\r\n        final AroundPolicy policy = chain.getPolicies().remove(ap.getName());\r\n        assertSame(\"Wrong policy returned?\", ap, policy);\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n    }","commit_id":"a1fffd31ab520894f28c2cc251e84ac5bc3bad9a","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testDuplicateName() throws Exception\r\n    {\r\n        DefaultMessageProcessorChain chain = new DefaultMessageProcessorChain();\r\n        chain.getPolicies().add(new TestPolicy(\"test\"));\r\n        try\r\n        {\r\n            chain.getPolicies().add(new TestPolicy(\"test\"));\r\n            fail(\"Should've thrown an exception, no duplicates allowed\");\r\n        }\r\n        catch (IllegalArgumentException e)\r\n        {\r\n            System.out.println(e);\r\n            // expected\r\n        }\r\n    }","id":93489,"modified_method":"public void testDuplicateName() throws Exception\r\n    {\r\n        MessageProcessorChain chain = new DefaultMessageProcessorChainBuilder().build();\r\n\r\n        chain.getPolicies().add(new TestPolicy(\"test\"));\r\n        try\r\n        {\r\n            chain.getPolicies().add(new TestPolicy(\"test\"));\r\n            fail(\"Should've thrown an exception, no duplicates allowed\");\r\n        }\r\n        catch (IllegalArgumentException e)\r\n        {\r\n            System.out.println(e);\r\n            // expected\r\n        }\r\n    }","commit_id":"a1fffd31ab520894f28c2cc251e84ac5bc3bad9a","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * This builder supports the chaining together of message processors that intercept and also those that\n     * don't. While one can iterate over message processor intercepting message processors need to be chained\n     * together. One solution is make all message processors intercepting (via adaption) and chain them all\n     * together, this results in huge stack traces and recursive calls with adaptor. The alternative is to\n     * build the chain in such a way that we iterate when we can and chain where we need to. <br>\n     * We iterate over the list of message processor to be chained together in reverse order collecting up\n     * those that can be iterated over in a temporary list, as soon as we have an intercepting message\n     * processor we create a DefaultMessageProcessorChain using the temporary list and set it as a listener of\n     * the intercepting message processor and then we continue with the algorithm\n     */\n    public MessageProcessorChain build() throws MuleException\n    {\n        InterceptingMessageProcessorChain finalChain = new InterceptingMessageProcessorChain(null, null, \"\");\n\n        LinkedList<MessageProcessor> tempList = new LinkedList<MessageProcessor>();\n\n        // Start from last but one message processor and work backwards\n        for (int i = processors.size() - 1; i >= 0; i--)\n        {\n            MessageProcessor processor = decorateMessageProcessorForCallbacks(\n                initializeMessageProcessor(processors.get(i)), finalChain);\n            if ((processors.get(i)) instanceof InterceptingMessageProcessor)\n            {\n                // Processor is intercepting so we can't simply iterate\n                if (i + 1 < processors.size())\n                {\n                    // The current processor is not the last in the list\n                    if (tempList.isEmpty())\n                    {\n                        ((InterceptingMessageProcessor) processor).setListener(decorateMessageProcessorForCallbacks(\n                            initializeMessageProcessor(processors.get(i + 1)), finalChain));\n                    }\n                    else\n                    {\n                        final IteratingCompositeMessageProcessor chain = new IteratingCompositeMessageProcessor(\n                            new ArrayList<MessageProcessor>(tempList));\n                        ((InterceptingMessageProcessor) processor).setListener(chain);\n                    }\n                }\n                tempList = new LinkedList<MessageProcessor>(Collections.singletonList(processor));\n            }\n            else\n            {\n                // Processor is not intercepting so we can invoke it using iteration (add to temp list)\n                tempList.addFirst(processor);\n            }\n        }\n        // Create the final chain using the current tempList after reserve iteration is complete. This temp\n        // list contains the first n processors in the chain that are not intercepting.. with processor n+1\n        // having been injected as the listener of processor n\n        final IteratingCompositeMessageProcessor chain = new IteratingCompositeMessageProcessor(\n            new ArrayList<MessageProcessor>(tempList));\n\n        // Wrap with something that can apply lifecycle to all processors which are otherwise not visable from\n        // DefaultMessageProcessorChain\n        finalChain.setFirstInChain(chain);\n        finalChain.setMessageProcessors(processors);\n        return finalChain;\n    }","id":93490,"modified_method":"/**\n     * This builder supports the chaining together of message processors that intercept and also those that\n     * don't. While one can iterate over message processor intercepting message processors need to be chained\n     * together. One solution is make all message processors intercepting (via adaption) and chain them all\n     * together, this results in huge stack traces and recursive calls with adaptor. The alternative is to\n     * build the chain in such a way that we iterate when we can and chain where we need to. <br>\n     * We iterate over the list of message processor to be chained together in reverse order collecting up\n     * those that can be iterated over in a temporary list, as soon as we have an intercepting message\n     * processor we create a DefaultMessageProcessorChain using the temporary list and set it as a listener of\n     * the intercepting message processor and then we continue with the algorithm\n     */\n    public MessageProcessorChain build() throws MuleException\n    {\n        LinkedList<MessageProcessor> tempList = new LinkedList<MessageProcessor>();\n\n        // Start from last but one message processor and work backwards\n        for (int i = processors.size() - 1; i >= 0; i--)\n        {\n            MessageProcessor processor = initializeMessageProcessor(processors.get(i));\n            if ((processors.get(i)) instanceof InterceptingMessageProcessor)\n            {\n                // Processor is intercepting so we can't simply iterate\n                if (i + 1 < processors.size())\n                {\n                    // The current processor is not the last in the list\n                    if (tempList.isEmpty())\n                    {\n                        ((InterceptingMessageProcessor) processor).setListener(initializeMessageProcessor(processors.get(i + 1)));\n                    }\n                    else\n                    {\n                        final DefaultMessageProcessorChain chain = new DefaultMessageProcessorChain(\n                            new ArrayList<MessageProcessor>(tempList));\n                        ((InterceptingMessageProcessor) processor).setListener(chain);\n                    }\n                }\n                tempList = new LinkedList<MessageProcessor>(Collections.singletonList(processor));\n            }\n            else\n            {\n                // Processor is not intercepting so we can invoke it using iteration (add to temp list)\n                tempList.addFirst(initializeMessageProcessor(processor));\n            }\n        }\n        // Create the final chain using the current tempList after reserve iteration is complete. This temp\n        // list contains the first n processors in the chain that are not intercepting.. with processor n+1\n        // having been injected as the listener of processor n\n        final DefaultMessageProcessorChain chain = new DefaultMessageProcessorChain(\n            new ArrayList<MessageProcessor>(tempList));\n\n        // Wrap with something that can apply lifecycle to all processors which are otherwise not visable from\n        // DefaultMessageProcessorChain\n        return new InterceptingChainLifecycleWrapper(chain, processors, \"\");\n    }","commit_id":"5aef9c8a94802f8219adc4056d9221fed1b26734","url":"https://github.com/mulesoft/mule"},{"original_method":"public static MessageProcessorChain singletonChain(MessageProcessor mp)\r\n    {\r\n        return new InterceptingMessageProcessorChain(mp, Collections.singletonList(mp), \"\");\r\n    }","id":93491,"modified_method":"public static MessageProcessorChain singletonChain(MessageProcessor mp)\r\n    {\r\n        return new DefaultMessageProcessorChain(mp);\r\n    }","commit_id":"5aef9c8a94802f8219adc4056d9221fed1b26734","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testSinglePolicy() throws Exception\r\n    {\r\n        AroundPolicy ap = new TestPolicy(\"test around policy\");\r\n\r\n        \r\n        \r\n        // this is our regular chain that should get a policy applied\r\n        MessageProcessorChain chain = new DefaultMessageProcessorChainBuilder().chain(\r\n            new StringAppendTransformer(\"first\"), new StringAppendTransformer(\" second\")).build();\r\n\r\n        initialiseObject(chain);\r\n\r\n        // test registration\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n        chain.getPolicies().add(ap);\r\n        assertSame(\"Policy has not been registered.\", ap, chain.getPolicies().list().iterator().next());\r\n\r\n        System.out.println(chain);\r\n\r\n        // invoke\r\n        final MuleEvent result = chain.process(getTestEvent(\"payload \"));\r\n        assertNotNull(result);\r\n        final MuleMessage message = result.getMessage();\r\n        assertNotNull(message);\r\n        assertEquals(\"payload {before} first second {after}\", message.getPayload());\r\n\r\n        // test cleanup\r\n        final AroundPolicy policy = chain.getPolicies().remove(ap.getName());\r\n        assertSame(\"Wrong policy returned?\", ap, policy);\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n    }","id":93492,"modified_method":"public void testSinglePolicy() throws Exception\r\n    {\r\n        AroundPolicy ap = new TestPolicy(\"test around policy\");\r\n\r\n        // this is our regular chain that should get a policy applied\r\n        DefaultMessageProcessorChain chain = new DefaultMessageProcessorChain(\r\n                                                             new StringAppendTransformer(\"first\"),\r\n                                                             new StringAppendTransformer(\" second\"));\r\n        initialiseObject(chain);\r\n\r\n        // test registration\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n        chain.getPolicies().add(ap);\r\n        assertSame(\"Policy has not been registered.\", ap, chain.getPolicies().list().iterator().next());\r\n\r\n        System.out.println(chain);\r\n\r\n        // invoke\r\n        final MuleEvent result = chain.process(getTestEvent(\"payload \"));\r\n        assertNotNull(result);\r\n        final MuleMessage message = result.getMessage();\r\n        assertNotNull(message);\r\n        assertEquals(\"payload {before} first second {after}\", message.getPayload());\r\n\r\n        // test cleanup\r\n        final AroundPolicy policy = chain.getPolicies().remove(ap.getName());\r\n        assertSame(\"Wrong policy returned?\", ap, policy);\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n    }","commit_id":"5aef9c8a94802f8219adc4056d9221fed1b26734","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testMultiplePolicies() throws Exception\r\n    {\r\n\r\n        // this is our regular chain that should get a policy applied\r\n        MessageProcessorChain chain = new DefaultMessageProcessorChainBuilder().chain(\r\n            new StringAppendTransformer(\"first\"), new StringAppendTransformer(\" second\")).build();\r\n\r\n        initialiseObject(chain);\r\n\r\n        // test registration\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n        AroundPolicy policy1 = new TestPolicy(\"test around policy 1\");\r\n        chain.getPolicies().add(policy1);\r\n        // add another policy\r\n        final TestPolicy policy2 = new TestPolicy(\"test around policy 2\");\r\n        chain.getPolicies().add(policy2);\r\n        assertEquals(\"Wrong policies count.\", 2, chain.getPolicies().list().size());\r\n\r\n        System.out.println(chain);\r\n\r\n        // invoke\r\n        final MuleEvent result = chain.process(getTestEvent(\"payload \"));\r\n        assertNotNull(result);\r\n        final MuleMessage message = result.getMessage();\r\n        assertNotNull(message);\r\n        assertEquals(\"payload {before} {before} first second {after} {after}\", message.getPayload());\r\n\r\n        // test cleanup\r\n        final AroundPolicy policy = chain.getPolicies().remove(policy1.getName());\r\n        assertSame(\"Wrong policy returned?\", policy1, policy);\r\n        chain.getPolicies().remove(policy2.getName());\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n    }","id":93493,"modified_method":"public void testMultiplePolicies() throws Exception\r\n    {\r\n\r\n        // this is our regular chain that should get a policy applied\r\n        DefaultMessageProcessorChain chain = new DefaultMessageProcessorChain(\r\n                                                             new StringAppendTransformer(\"first\"),\r\n                                                             new StringAppendTransformer(\" second\"));\r\n        initialiseObject(chain);\r\n\r\n        // test registration\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n        AroundPolicy policy1 = new TestPolicy(\"test around policy 1\");\r\n        chain.getPolicies().add(policy1);\r\n        // add another policy\r\n        final TestPolicy policy2 = new TestPolicy(\"test around policy 2\");\r\n        chain.getPolicies().add(policy2);\r\n        assertEquals(\"Wrong policies count.\", 2, chain.getPolicies().list().size());\r\n\r\n        System.out.println(chain);\r\n\r\n        // invoke\r\n        final MuleEvent result = chain.process(getTestEvent(\"payload \"));\r\n        assertNotNull(result);\r\n        final MuleMessage message = result.getMessage();\r\n        assertNotNull(message);\r\n        assertEquals(\"payload {before} {before} first second {after} {after}\", message.getPayload());\r\n\r\n        // test cleanup\r\n        final AroundPolicy policy = chain.getPolicies().remove(policy1.getName());\r\n        assertSame(\"Wrong policy returned?\", policy1, policy);\r\n        chain.getPolicies().remove(policy2.getName());\r\n        assertEquals(\"No policies should have been registered.\", 0, chain.getPolicies().list().size());\r\n    }","commit_id":"5aef9c8a94802f8219adc4056d9221fed1b26734","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testDuplicateName() throws Exception\r\n    {\r\n        MessageProcessorChain chain = new DefaultMessageProcessorChainBuilder().build();\r\n\r\n        chain.getPolicies().add(new TestPolicy(\"test\"));\r\n        try\r\n        {\r\n            chain.getPolicies().add(new TestPolicy(\"test\"));\r\n            fail(\"Should've thrown an exception, no duplicates allowed\");\r\n        }\r\n        catch (IllegalArgumentException e)\r\n        {\r\n            System.out.println(e);\r\n            // expected\r\n        }\r\n    }","id":93494,"modified_method":"public void testDuplicateName() throws Exception\r\n    {\r\n        DefaultMessageProcessorChain chain = new DefaultMessageProcessorChain();\r\n        chain.getPolicies().add(new TestPolicy(\"test\"));\r\n        try\r\n        {\r\n            chain.getPolicies().add(new TestPolicy(\"test\"));\r\n            fail(\"Should've thrown an exception, no duplicates allowed\");\r\n        }\r\n        catch (IllegalArgumentException e)\r\n        {\r\n            System.out.println(e);\r\n            // expected\r\n        }\r\n    }","commit_id":"5aef9c8a94802f8219adc4056d9221fed1b26734","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Train a Deep Learning neural net model\n     * @param model Input model (e.g., from initModel(), or from a previous training run)\n     * @return Trained model\n     */\n    public final DeepLearningModel trainModel(DeepLearningModel model) {\n      Frame validScoreFrame = null;\n      Frame train, trainScoreFrame;\n      try {\n//      if (checkpoint == null && !quiet_mode) logStart(); //if checkpoint is given, some Job's params might be uninitialized (but the restarted model's parameters are correct)\n        if (model == null) {\n          model = DKV.get(dest()).get();\n        }\n        model.write_lock(self());\n        final DeepLearningModel.DeepLearningParameters mp = model._parms;\n        Frame tra_fr = new Frame(mp.train()._key, _train.names(), _train.vecs());\n        Frame val_fr = _valid != null ? new Frame(mp.valid()._key, _valid.names(), _valid.vecs()) : null;\n\n        final long model_size = model.model_info().size();\n        if (!_parms._quiet_mode) Log.info(\"Number of model parameters (weights/biases): \" + String.format(\"%,d\", model_size));\n        train = tra_fr;\n        if (mp._force_load_balance) train = reBalance(train, mp._replicate_training_data /*rebalance into only 4*cores per node*/, mp._train.toString() + \".\" + model._key.toString() + \".train\");\n        if (model._output.isClassifier() && mp._balance_classes) {\n          float[] trainSamplingFactors = new float[train.lastVec().domain().length]; //leave initialized to 0 -> will be filled up below\n          if (mp._class_sampling_factors != null) {\n            if (mp._class_sampling_factors.length != train.lastVec().domain().length)\n              throw new IllegalArgumentException(\"class_sampling_factors must have \" + train.lastVec().domain().length + \" elements\");\n            trainSamplingFactors = mp._class_sampling_factors.clone(); //clone: don't modify the original\n          }\n\n          train = sampleFrameStratified(\n                  train, train.lastVec(), trainSamplingFactors, (long)(mp._max_after_balance_size*train.numRows()), mp._seed, true, false);\n          model._output._modelClassDist = new MRUtils.ClassDist(train.lastVec()).doAll(train.lastVec()).rel_dist();\n        }\n        model._output.autoencoder = _parms._autoencoder;\n        model.training_rows = train.numRows();\n        trainScoreFrame = sampleFrame(train, mp._score_training_samples, mp._seed); //training scoring dataset is always sampled uniformly from the training dataset\n\n        if (!_parms._quiet_mode) Log.info(\"Number of chunks of the training data: \" + train.anyVec().nChunks());\n        if (val_fr != null) {\n          model.validation_rows = val_fr.numRows();\n          // validation scoring dataset can be sampled in multiple ways from the given validation dataset\n          if (model._output.isClassifier() && mp._balance_classes && mp._score_validation_sampling == DeepLearningModel.DeepLearningParameters.ClassSamplingMethod.Stratified) {\n            validScoreFrame = sampleFrameStratified(val_fr, val_fr.lastVec(), null,\n                    mp._score_validation_samples > 0 ? mp._score_validation_samples : val_fr.numRows(), mp._seed +1, false /* no oversampling */, false);\n          } else {\n            validScoreFrame = sampleFrame(val_fr, mp._score_validation_samples, mp._seed +1);\n          }\n          if (mp._force_load_balance) validScoreFrame = reBalance(validScoreFrame, false /*always split up globally since scoring should be distributed*/, mp._valid.toString() + \".\" + model._key.toString() + \".valid\");\n          if (!_parms._quiet_mode) Log.info(\"Number of chunks of the validation data: \" + validScoreFrame.anyVec().nChunks());\n        }\n\n        // Set train_samples_per_iteration size (cannot be done earlier since this depends on whether stratified sampling is done)\n        model.actual_train_samples_per_iteration = computeTrainSamplesPerIteration(mp, train.numRows(), model);\n        // Determine whether shuffling is enforced\n        if(mp._replicate_training_data && (model.actual_train_samples_per_iteration == train.numRows()*(mp._single_node_mode ?1:H2O.CLOUD.size())) && !mp._shuffle_training_data && H2O.CLOUD.size() > 1 && !mp._reproducible) {\n          Log.warn(\"Enabling training data shuffling, because all nodes train on the full dataset (replicated training data).\");\n          mp._shuffle_training_data = true;\n        }\n\n        model._timeLastScoreEnter = System.currentTimeMillis(); //to keep track of time per iteration, must be called before first call to doScoring\n\n        if (!mp._quiet_mode) Log.info(\"Initial model:\\n\" + model.model_info());\n        if (_parms._autoencoder) model.doScoring(trainScoreFrame, validScoreFrame, self()); //get the null model reconstruction error\n        // put the initial version of the model into DKV\n        model.update(self());\n        Log.info(\"Starting to train the Deep Learning model.\");\n\n        //main loop\n        do {\n          model.set_model_info(mp._epochs == 0 ? model.model_info() : H2O.CLOUD.size() > 1 && mp._replicate_training_data ? (mp._single_node_mode ?\n                  new DeepLearningTask2(self(), train, model.model_info(), rowFraction(train, mp, model)).doAll(Key.make()).model_info() : //replicated data + single node mode\n                  new DeepLearningTask2(self(), train, model.model_info(), rowFraction(train, mp, model)).doAllNodes().model_info()) : //replicated data + multi-node mode\n                  new DeepLearningTask(self(), model.model_info(), rowFraction(train, mp, model)).doAll(train).model_info()); //distributed data (always in multi-node mode)\n          update(model.actual_train_samples_per_iteration); //update progress\n        }\n        while (model.doScoring(trainScoreFrame, validScoreFrame, self()));\n\n        // replace the model with the best model so far (if it's better)\n        if (!isCancelledOrCrashed() && _parms._override_with_best_model && model.actual_best_model_key != null && _parms._n_folds == 0) {\n          DeepLearningModel best_model = DKV.getGet(model.actual_best_model_key);\n          if (best_model != null && best_model.error() < model.error() && Arrays.equals(best_model.model_info().units, model.model_info().units)) {\n            Log.info(\"Setting the model to be the best model so far (based on scoring history).\");\n            DeepLearningModel.DeepLearningModelInfo mi = best_model.model_info().deep_clone();\n            // Don't cheat - count full amount of training samples, since that's the amount of training it took to train (without finding anything better)\n            mi.set_processed_global(model.model_info().get_processed_global());\n            mi.set_processed_local(model.model_info().get_processed_local());\n            model.set_model_info(mi);\n            model.update(self());\n            model.doScoring(trainScoreFrame, validScoreFrame, self());\n            assert(best_model.error() == model.error());\n          }\n        }\n\n        Log.info(model);\n        Log.info(\"Finished training the Deep Learning model.\");\n      }\n      catch(RuntimeException ex) {\n        model = DKV.get(dest()).get();\n        _state = JobState.CANCELLED; //for JSON REST response\n        Log.info(\"Deep Learning model building was cancelled.\");\n        throw ex;\n      }\n      finally {\n        if (model != null) model.unlock(self());\n        for (Frame f : _delete_me) f.delete(); //delete internally rebalanced frames\n      }\n      return model;\n    }","id":93495,"modified_method":"/**\n     * Train a Deep Learning neural net model\n     * @param model Input model (e.g., from initModel(), or from a previous training run)\n     * @return Trained model\n     */\n    public final DeepLearningModel trainModel(DeepLearningModel model) {\n      Frame validScoreFrame = null;\n      Frame train, trainScoreFrame;\n      try {\n//      if (checkpoint == null && !quiet_mode) logStart(); //if checkpoint is given, some Job's params might be uninitialized (but the restarted model's parameters are correct)\n        if (model == null) {\n          model = DKV.get(dest()).get();\n        }\n        model.write_lock(self());\n        final DeepLearningModel.DeepLearningParameters mp = model._parms;\n        Frame tra_fr = new Frame(mp.train()._key, _train.names(), _train.vecs());\n        Frame val_fr = _valid != null ? new Frame(mp.valid()._key, _valid.names(), _valid.vecs()) : null;\n\n        final long model_size = model.model_info().size();\n        if (!_parms._quiet_mode) Log.info(\"Number of model parameters (weights/biases): \" + String.format(\"%,d\", model_size));\n        train = tra_fr;\n        if (mp._force_load_balance) train = reBalance(train, mp._replicate_training_data /*rebalance into only 4*cores per node*/, mp._train.toString() + \".\" + model._key.toString() + \".train\");\n        if (model._output.isClassifier() && mp._balance_classes) {\n          float[] trainSamplingFactors = new float[train.lastVec().domain().length]; //leave initialized to 0 -> will be filled up below\n          if (mp._class_sampling_factors != null) {\n            if (mp._class_sampling_factors.length != train.lastVec().domain().length)\n              throw new IllegalArgumentException(\"class_sampling_factors must have \" + train.lastVec().domain().length + \" elements\");\n            trainSamplingFactors = mp._class_sampling_factors.clone(); //clone: don't modify the original\n          }\n\n          train = sampleFrameStratified(\n                  train, train.lastVec(), trainSamplingFactors, (long)(mp._max_after_balance_size*train.numRows()), mp._seed, true, false);\n          model._output._modelClassDist = new MRUtils.ClassDist(train.lastVec()).doAll(train.lastVec()).rel_dist();\n        }\n        model._output.autoencoder = _parms._autoencoder;\n        model.training_rows = train.numRows();\n        trainScoreFrame = sampleFrame(train, mp._score_training_samples, mp._seed); //training scoring dataset is always sampled uniformly from the training dataset\n\n        if (!_parms._quiet_mode) Log.info(\"Number of chunks of the training data: \" + train.anyVec().nChunks());\n        if (val_fr != null) {\n          model.validation_rows = val_fr.numRows();\n          // validation scoring dataset can be sampled in multiple ways from the given validation dataset\n          if (model._output.isClassifier() && mp._balance_classes && mp._score_validation_sampling == DeepLearningModel.DeepLearningParameters.ClassSamplingMethod.Stratified) {\n            validScoreFrame = sampleFrameStratified(val_fr, val_fr.lastVec(), null,\n                    mp._score_validation_samples > 0 ? mp._score_validation_samples : val_fr.numRows(), mp._seed +1, false /* no oversampling */, false);\n          } else {\n            validScoreFrame = sampleFrame(val_fr, mp._score_validation_samples, mp._seed +1);\n          }\n          if (mp._force_load_balance) validScoreFrame = reBalance(validScoreFrame, false /*always split up globally since scoring should be distributed*/, mp._valid.toString() + \".\" + model._key.toString() + \".valid\");\n          if (!_parms._quiet_mode) Log.info(\"Number of chunks of the validation data: \" + validScoreFrame.anyVec().nChunks());\n        }\n\n        // Set train_samples_per_iteration size (cannot be done earlier since this depends on whether stratified sampling is done)\n        model.actual_train_samples_per_iteration = computeTrainSamplesPerIteration(mp, train.numRows(), model);\n        // Determine whether shuffling is enforced\n        if(mp._replicate_training_data && (model.actual_train_samples_per_iteration == train.numRows()*(mp._single_node_mode ?1:H2O.CLOUD.size())) && !mp._shuffle_training_data && H2O.CLOUD.size() > 1 && !mp._reproducible) {\n          Log.warn(\"Enabling training data shuffling, because all nodes train on the full dataset (replicated training data).\");\n          mp._shuffle_training_data = true;\n        }\n\n        model._timeLastScoreEnter = System.currentTimeMillis(); //to keep track of time per iteration, must be called before first call to doScoring\n\n        if (!mp._quiet_mode) Log.info(\"Initial model:\\n\" + model.model_info());\n        if (_parms._autoencoder) model.doScoring(trainScoreFrame, validScoreFrame, self()); //get the null model reconstruction error\n        // put the initial version of the model into DKV\n        model.update(self());\n        Log.info(\"Starting to train the Deep Learning model.\");\n\n        //main loop\n        do {\n          model.set_model_info(mp._epochs == 0 ? model.model_info() : H2O.CLOUD.size() > 1 && mp._replicate_training_data ? (mp._single_node_mode ?\n                  new DeepLearningTask2(self(), train, model.model_info(), rowFraction(train, mp, model)).doAll(Key.make()).model_info() : //replicated data + single node mode\n                  new DeepLearningTask2(self(), train, model.model_info(), rowFraction(train, mp, model)).doAllNodes().model_info()) : //replicated data + multi-node mode\n                  new DeepLearningTask(self(), model.model_info(), rowFraction(train, mp, model)).doAll(train).model_info()); //distributed data (always in multi-node mode)\n          update(model.actual_train_samples_per_iteration); //update progress\n        }\n        while (model.doScoring(trainScoreFrame, validScoreFrame, self()));\n\n        // replace the model with the best model so far (if it's better)\n        if (!isCancelledOrCrashed() && _parms._override_with_best_model && model.actual_best_model_key != null && _parms._n_folds == 0) {\n          DeepLearningModel best_model = DKV.getGet(model.actual_best_model_key);\n          if (best_model != null && best_model.error() < model.error() && Arrays.equals(best_model.model_info().units, model.model_info().units)) {\n            Log.info(\"Setting the model to be the best model so far (based on scoring history).\");\n            DeepLearningModel.DeepLearningModelInfo mi = best_model.model_info().deep_clone();\n            // Don't cheat - count full amount of training samples, since that's the amount of training it took to train (without finding anything better)\n            mi.set_processed_global(model.model_info().get_processed_global());\n            mi.set_processed_local(model.model_info().get_processed_local());\n            model.set_model_info(mi);\n            model.update(self());\n            model.doScoring(trainScoreFrame, validScoreFrame, self());\n            assert(best_model.error() == model.error());\n          }\n        }\n\n        Log.info(\"==============================================================================================\");\n        Log.info(\"Finished training the Deep Learning model.\");\n        Log.info(model);\n        Log.info(\"==============================================================================================\");\n      }\n      catch(RuntimeException ex) {\n        model = DKV.get(dest()).get();\n        _state = JobState.CANCELLED; //for JSON REST response\n        Log.info(\"Deep Learning model building was cancelled.\");\n        throw ex;\n      }\n      finally {\n        if (model != null) model.unlock(self());\n        for (Frame f : _delete_me) f.delete(); //delete internally rebalanced frames\n      }\n      return model;\n    }","commit_id":"f532a8b0d7807ac08ba3502c02db221c25f2a135","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(model_info.toString());\n    sb.append(last_scored().toString());\n    return sb.toString();\n  }","id":93496,"modified_method":"@Override public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Training time: \" + PrettyPrint.msecs(run_time, true)\n            + \". Processed \" + String.format(\"%,d\", training_rows) + \" samples\" + \" (\" + String.format(\"%.3f\", epoch_counter) + \" epochs).\"\n            + \" Speed: \" + String.format(\"%.3f\", 1000.*training_rows/run_time) + \" samples/sec.\\n\");\n    sb.append(model_info.toString());\n    sb.append(last_scored().toString());\n    return sb.toString();\n  }","commit_id":"f532a8b0d7807ac08ba3502c02db221c25f2a135","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   *\n   * @param ftrain potentially downsampled training data for scoring\n   * @param ftest  potentially downsampled validation data for scoring\n   * @param job_key key of the owning job\n   * @return true if model building is ongoing\n   */\n  boolean doScoring(Frame ftrain, Frame ftest, Key job_key) {\n    boolean keep_running;\n    try {\n      final long now = System.currentTimeMillis();\n      epoch_counter = (float)model_info().get_processed_total()/training_rows;\n      final double time_last_iter_millis = Math.max(5,now-_timeLastScoreEnter);\n\n      // Auto-tuning\n      // if multi-node and auto-tuning and at least 10 ms for communication (to avoid doing thins on multi-JVM on same node),\n      // then adjust the auto-tuning parameter 'actual_train_samples_per_iteration' such that the targeted ratio of comm to comp is achieved\n      // Note: actual communication time is estimated by the NetworkTest's collective test.\n      if (H2O.CLOUD.size() > 1 && get_params()._train_samples_per_iteration == -2 && time_for_communication_us > 1e4) {\n//        Log.info(\"Time taken for communication: \" + PrettyPrint.usecs((long)time_for_communication_us));\n//        Log.info(\"Time taken for Map/Reduce iteration: \" + PrettyPrint.msecs((long)time_last_iter_millis, true));\n        final double comm_to_work_ratio = (time_for_communication_us *1e-3) / time_last_iter_millis;\n//        Log.info(\"Ratio of network communication to computation: \" + String.format(\"%.3f\", comm_to_work_ratio));\n//        Log.info(\"target_comm_to_work: \" + get_params().target_ratio_comm_to_comp);\n        final double correction = get_params()._target_ratio_comm_to_comp / comm_to_work_ratio;\n//        Log.warn(\"Suggested value for train_samples_per_iteration: \" + get_params().actual_train_samples_per_iteration/correction);\n        actual_train_samples_per_iteration /= correction;\n        actual_train_samples_per_iteration = Math.max(1, actual_train_samples_per_iteration);\n      }\n\n      run_time += time_last_iter_millis;\n      _timeLastScoreEnter = now;\n      keep_running = (epoch_counter < get_params()._epochs);\n      final long sinceLastScore = now -_timeLastScoreStart;\n      final long sinceLastPrint = now -_timeLastPrintStart;\n      final long samples = model_info().get_processed_total();\n      if (!keep_running || sinceLastPrint > get_params()._score_interval *1000) {\n        _timeLastPrintStart = now;\n        Log.info(\"Training time: \" + PrettyPrint.msecs(run_time, true)\n                + \". Processed \" + String.format(\"%,d\", samples) + \" samples\" + \" (\" + String.format(\"%.3f\", epoch_counter) + \" epochs).\"\n                + \" Speed: \" + String.format(\"%.3f\", 1000.*samples/run_time) + \" samples/sec.\");\n      }\n\n      // this is potentially slow - only do every so often\n      if( !keep_running ||\n              (sinceLastScore > get_params()._score_interval *1000 //don't score too often\n                      &&(double)(_timeLastScoreEnd-_timeLastScoreStart)/sinceLastScore < get_params()._score_duty_cycle) ) { //duty cycle\n        final boolean printme = !get_params()._quiet_mode;\n        _timeLastScoreStart = now;\n        if (get_params()._diagnostics) model_info().computeStats();\n        DeepLearningScoring err = new DeepLearningScoring();\n        err.training_time_ms = run_time;\n        err.epoch_counter = epoch_counter;\n        err.training_samples = model_info().get_processed_total();\n        err.validation = ftest != null;\n        err.score_training_samples = ftrain.numRows();\n        err.classification = _output.isClassifier();\n\n        if (get_params()._autoencoder) {\n          if (printme) Log.info(\"Scoring the auto-encoder.\");\n          // training\n          {\n            final Frame mse_frame = scoreAutoEncoder(ftrain);\n            final Vec l2 = mse_frame.anyVec();\n            Log.info(\"Mean reconstruction error on training data: \" + l2.mean() + \"\\n\");\n            err.train_mse = l2.mean();\n            mse_frame.delete();\n          }\n        } else {\n          if (printme) Log.info(\"Scoring the model.\");\n          // compute errors\n          final String m = model_info().toString();\n          if (m.length() > 0) Log.info(m);\n          final Frame trainPredict = score(ftrain);\n          trainPredict.delete();\n\n          hex.ModelMetrics mm1 = hex.ModelMetrics.getFromDKV(this,ftrain);\n          if (mm1 instanceof ModelMetricsBinomial) {\n            ModelMetricsBinomial mm = (ModelMetricsBinomial)(mm1);\n            err.trainAUC = mm._aucdata;\n            err.train_confusion_matrix = mm._cm;\n            err.train_err = mm._cm.err();\n          }\n          else if (mm1 instanceof ModelMetricsMultinomial) {\n            ModelMetricsMultinomial mm = (ModelMetricsMultinomial)(mm1);\n            err.train_confusion_matrix = mm._cm;\n            err.train_err = mm._cm.err();\n            err.train_hitratio = mm._hr;\n          }\n          else if (mm1 instanceof ModelMetricsRegression) {\n            ModelMetricsRegression mm = (ModelMetricsRegression)(mm1);\n            err.train_mse = mm._mse;\n          }\n          _output.trainMetrics = mm1;\n\n          if (ftest != null) {\n            Frame validPred = score(ftest);\n            validPred.delete();\n            hex.ModelMetrics mm2 = hex.ModelMetrics.getFromDKV(this, ftest);\n            if (mm2 != null) {\n              if (mm2 instanceof ModelMetricsBinomial) {\n                ModelMetricsBinomial mm = (ModelMetricsBinomial) (mm2);\n                err.validAUC = mm._aucdata;\n                err.valid_confusion_matrix = mm._cm;\n                err.valid_err = mm._cm.err();\n              } else if (mm2 instanceof ModelMetricsMultinomial) {\n                ModelMetricsMultinomial mm = (ModelMetricsMultinomial) (mm2);\n                err.valid_confusion_matrix = mm._cm;\n                err.valid_err = mm._cm.err();\n                err.valid_hitratio = mm._hr;\n              } else if (mm2 instanceof ModelMetricsRegression) {\n                ModelMetricsRegression mm = (ModelMetricsRegression) (mm2);\n                err.valid_mse = mm._mse;\n              }\n              _output.validMetrics = mm2;\n            }\n          }\n\n          if (get_params()._variable_importances) {\n            if (!get_params()._quiet_mode) Log.info(\"Computing variable importances.\");\n            final float[] vi = model_info().computeVariableImportances();\n            err.variable_importances = new VarImp(vi, Arrays.copyOfRange(model_info().data_info().coefNames(), 0, vi.length));\n          }\n        }\n\n        _timeLastScoreEnd = System.currentTimeMillis();\n        err.scoring_time = System.currentTimeMillis() - now;\n        // enlarge the error array by one, push latest score back\n        if (errors == null) {\n          errors = new DeepLearningScoring[]{err};\n        } else {\n          DeepLearningScoring[] err2 = new DeepLearningScoring[errors.length + 1];\n          System.arraycopy(errors, 0, err2, 0, errors.length);\n          err2[err2.length - 1] = err;\n          errors = err2;\n        }\n        _output.scoringHistory = null; //createScoringHistoryTable(errors);\n        if (_output.modelSummary == null)\n          _output.modelSummary = model_info.createSummaryTable();\n\n        if (!get_params()._autoencoder) {\n          // always keep a copy of the best model so far (based on the following criterion)\n          if (actual_best_model_key != null && (\n                  // if we have a best_model in DKV, then compare against its error() (unless it's a different model as judged by the network size)\n                  (DKV.get(actual_best_model_key) != null && (error() < DKV.get(actual_best_model_key).<DeepLearningModel>get().error() || !Arrays.equals(model_info().units, DKV.get(actual_best_model_key).<DeepLearningModel>get().model_info().units)))\n                          ||\n                          // otherwise, compare against our own _bestError\n                          (DKV.get(actual_best_model_key) == null && error() < _bestError)\n          ) ) {\n            if (!get_params()._quiet_mode)\n              Log.info(\"Error reduced from \" + _bestError + \" to \" + error() + \". Storing best model so far under key \" + actual_best_model_key.toString() + \".\");\n            _bestError = error();\n            putMeAsBestModel(actual_best_model_key);\n\n            // debugging check\n            //if (false) {\n            //  DeepLearningModel bestModel = DKV.get(actual_best_model_key).get();\n            //  final Frame fr = ftest != null ? ftest : ftrain;\n            //  final Frame bestPredict = bestModel.score(fr);\n            //  final Frame hitRatio_bestPredict = new Frame(bestPredict);\n            //  final double err3 = calcError(fr, fr.lastVec(), bestPredict, hitRatio_bestPredict, \"cross-check\",\n            //    printme, get_params()._max_confusion_matrix_size, new hex.ConfusionMatrix2(), _output.isClassifier() && _output.nclasses() == 2 ? new AUC(null,null) : null, null);\n            //  if (_output.isClassifier())\n            //    assert (ftest != null ? Math.abs(err.valid_err - err3) < 1e-5 : Math.abs(err.train_err - err3) < 1e-5);\n            //  else\n            //    assert (ftest != null ? Math.abs(err.valid_mse - err3) < 1e-5 : Math.abs(err.train_mse - err3) < 1e-5);\n            //  bestPredict.delete();\n            //}\n          }\n//        else {\n//          // keep output JSON small\n//          if (errors.length > 1) {\n//            if (last_scored().trainAUC != null) last_scored().trainAUC.clear();\n//            if (last_scored().validAUC != null) last_scored().validAUC.clear();\n//            last_scored().variable_importances = null;\n//          }\n//        }\n\n          // print the freshly scored model to ASCII\n          for (String s : toString().split(\"\\n\")) Log.info(s);\n          if (printme) Log.info(\"Time taken for scoring and diagnostics: \" + PrettyPrint.msecs(err.scoring_time, true));\n        }\n      }\n      if (model_info().unstable()) {\n        Log.warn(unstable_msg);\n        keep_running = false;\n      } else if ( (_output.isClassifier() && last_scored().train_err <= get_params()._classification_stop)\n              || (!_output.isClassifier() && last_scored().train_mse <= get_params()._regression_stop) ) {\n        Log.info(\"Achieved requested predictive accuracy on the training data. Model building completed.\");\n        keep_running = false;\n      }\n      update(job_key);\n    }\n    catch (Exception ex) {\n      //ex.printStackTrace();\n      //throw new RuntimeException(ex);\n      return false;\n    }\n    return keep_running;\n }","id":93497,"modified_method":"/**\n   *\n   * @param ftrain potentially downsampled training data for scoring\n   * @param ftest  potentially downsampled validation data for scoring\n   * @param job_key key of the owning job\n   * @return true if model building is ongoing\n   */\n  boolean doScoring(Frame ftrain, Frame ftest, Key job_key) {\n    boolean keep_running;\n    try {\n      final long now = System.currentTimeMillis();\n      epoch_counter = (float)model_info().get_processed_total()/training_rows;\n      final double time_last_iter_millis = Math.max(5,now-_timeLastScoreEnter);\n\n      // Auto-tuning\n      // if multi-node and auto-tuning and at least 10 ms for communication (to avoid doing thins on multi-JVM on same node),\n      // then adjust the auto-tuning parameter 'actual_train_samples_per_iteration' such that the targeted ratio of comm to comp is achieved\n      // Note: actual communication time is estimated by the NetworkTest's collective test.\n      if (H2O.CLOUD.size() > 1 && get_params()._train_samples_per_iteration == -2 && time_for_communication_us > 1e4) {\n//        Log.info(\"Time taken for communication: \" + PrettyPrint.usecs((long)time_for_communication_us));\n//        Log.info(\"Time taken for Map/Reduce iteration: \" + PrettyPrint.msecs((long)time_last_iter_millis, true));\n        final double comm_to_work_ratio = (time_for_communication_us *1e-3) / time_last_iter_millis;\n//        Log.info(\"Ratio of network communication to computation: \" + String.format(\"%.3f\", comm_to_work_ratio));\n//        Log.info(\"target_comm_to_work: \" + get_params().target_ratio_comm_to_comp);\n        final double correction = get_params()._target_ratio_comm_to_comp / comm_to_work_ratio;\n//        Log.warn(\"Suggested value for train_samples_per_iteration: \" + get_params().actual_train_samples_per_iteration/correction);\n        actual_train_samples_per_iteration /= correction;\n        actual_train_samples_per_iteration = Math.max(1, actual_train_samples_per_iteration);\n      }\n\n      run_time += time_last_iter_millis;\n      _timeLastScoreEnter = now;\n      keep_running = (epoch_counter < get_params()._epochs);\n      final long sinceLastScore = now -_timeLastScoreStart;\n      final long sinceLastPrint = now -_timeLastPrintStart;\n      final long samples = model_info().get_processed_total();\n      if (!keep_running || sinceLastPrint > get_params()._score_interval *1000) {\n        _timeLastPrintStart = now;\n//        Log.info(\"Training time: \" + PrettyPrint.msecs(run_time, true)\n//                + \". Processed \" + String.format(\"%,d\", samples) + \" samples\" + \" (\" + String.format(\"%.3f\", epoch_counter) + \" epochs).\"\n//                + \" Speed: \" + String.format(\"%.3f\", 1000.*samples/run_time) + \" samples/sec.\");\n      }\n\n      // this is potentially slow - only do every so often\n      if( !keep_running ||\n              (sinceLastScore > get_params()._score_interval *1000 //don't score too often\n                      &&(double)(_timeLastScoreEnd-_timeLastScoreStart)/sinceLastScore < get_params()._score_duty_cycle) ) { //duty cycle\n        final boolean printme = !get_params()._quiet_mode;\n        _timeLastScoreStart = now;\n        if (get_params()._diagnostics) model_info().computeStats();\n        DeepLearningScoring err = new DeepLearningScoring();\n        err.training_time_ms = run_time;\n        err.epoch_counter = epoch_counter;\n        err.training_samples = model_info().get_processed_total();\n        err.validation = ftest != null;\n        err.score_training_samples = ftrain.numRows();\n        err.classification = _output.isClassifier();\n\n        if (get_params()._autoencoder) {\n          if (printme) Log.info(\"Scoring the auto-encoder.\");\n          // training\n          {\n            final Frame mse_frame = scoreAutoEncoder(ftrain);\n            final Vec l2 = mse_frame.anyVec();\n            Log.info(\"Mean reconstruction error on training data: \" + l2.mean() + \"\\n\");\n            err.train_mse = l2.mean();\n            mse_frame.delete();\n          }\n        } else {\n          if (printme) Log.info(\"Scoring the model.\");\n          // compute errors\n          final String m = model_info().toString();\n          if (m.length() > 0) Log.info(m);\n          final Frame trainPredict = score(ftrain);\n          trainPredict.delete();\n\n          hex.ModelMetricsSupervised mm1 = (ModelMetricsSupervised)ModelMetrics.getFromDKV(this,ftrain);\n          if (mm1 instanceof ModelMetricsBinomial) {\n            ModelMetricsBinomial mm = (ModelMetricsBinomial)(mm1);\n            err.trainAUC = mm._aucdata;\n            err.train_confusion_matrix = mm._cm;\n            err.train_err = mm._cm.err();\n          }\n          else if (mm1 instanceof ModelMetricsMultinomial) {\n            ModelMetricsMultinomial mm = (ModelMetricsMultinomial)(mm1);\n            err.train_confusion_matrix = mm._cm;\n            err.train_err = mm._cm.err();\n            err.train_hitratio = mm._hr;\n          }\n          err.train_mse = mm1._mse;\n          err.train_r2 = mm1.r2();\n          _output.trainMetrics = mm1;\n\n          if (ftest != null) {\n            Frame validPred = score(ftest);\n            validPred.delete();\n            hex.ModelMetricsSupervised mm2 = (ModelMetricsSupervised)hex.ModelMetrics.getFromDKV(this, ftest);\n            if (mm2 != null) {\n              if (mm2 instanceof ModelMetricsBinomial) {\n                ModelMetricsBinomial mm = (ModelMetricsBinomial) (mm2);\n                err.validAUC = mm._aucdata;\n                err.valid_confusion_matrix = mm._cm;\n                err.valid_err = mm._cm.err();\n              } else if (mm2 instanceof ModelMetricsMultinomial) {\n                ModelMetricsMultinomial mm = (ModelMetricsMultinomial) (mm2);\n                err.valid_confusion_matrix = mm._cm;\n                err.valid_err = mm._cm.err();\n                err.valid_hitratio = mm._hr;\n              }\n              err.valid_mse = mm2._mse;\n              err.valid_r2 = mm2.r2();\n              _output.validMetrics = mm2;\n            }\n          }\n\n          if (get_params()._variable_importances) {\n            if (!get_params()._quiet_mode) Log.info(\"Computing variable importances.\");\n            final float[] vi = model_info().computeVariableImportances();\n            err.variable_importances = new VarImp(vi, Arrays.copyOfRange(model_info().data_info().coefNames(), 0, vi.length));\n          }\n        }\n\n        _timeLastScoreEnd = System.currentTimeMillis();\n        err.scoring_time = System.currentTimeMillis() - now;\n        // enlarge the error array by one, push latest score back\n        if (errors == null) {\n          errors = new DeepLearningScoring[]{err};\n        } else {\n          DeepLearningScoring[] err2 = new DeepLearningScoring[errors.length + 1];\n          System.arraycopy(errors, 0, err2, 0, errors.length);\n          err2[err2.length - 1] = err;\n          errors = err2;\n        }\n        _output.scoringHistory = null; //createScoringHistoryTable(errors);\n        if (_output.modelSummary == null)\n          _output.modelSummary = model_info.createSummaryTable();\n\n        if (!get_params()._autoencoder) {\n          // always keep a copy of the best model so far (based on the following criterion)\n          if (actual_best_model_key != null && (\n                  // if we have a best_model in DKV, then compare against its error() (unless it's a different model as judged by the network size)\n                  (DKV.get(actual_best_model_key) != null && (error() < DKV.get(actual_best_model_key).<DeepLearningModel>get().error() || !Arrays.equals(model_info().units, DKV.get(actual_best_model_key).<DeepLearningModel>get().model_info().units)))\n                          ||\n                          // otherwise, compare against our own _bestError\n                          (DKV.get(actual_best_model_key) == null && error() < _bestError)\n          ) ) {\n            if (!get_params()._quiet_mode)\n              Log.info(\"Error reduced from \" + _bestError + \" to \" + error() + \". Storing best model so far under key \" + actual_best_model_key.toString() + \".\");\n            _bestError = error();\n            putMeAsBestModel(actual_best_model_key);\n\n            // debugging check\n            //if (false) {\n            //  DeepLearningModel bestModel = DKV.get(actual_best_model_key).get();\n            //  final Frame fr = ftest != null ? ftest : ftrain;\n            //  final Frame bestPredict = bestModel.score(fr);\n            //  final Frame hitRatio_bestPredict = new Frame(bestPredict);\n            //  final double err3 = calcError(fr, fr.lastVec(), bestPredict, hitRatio_bestPredict, \"cross-check\",\n            //    printme, get_params()._max_confusion_matrix_size, new hex.ConfusionMatrix2(), _output.isClassifier() && _output.nclasses() == 2 ? new AUC(null,null) : null, null);\n            //  if (_output.isClassifier())\n            //    assert (ftest != null ? Math.abs(err.valid_err - err3) < 1e-5 : Math.abs(err.train_err - err3) < 1e-5);\n            //  else\n            //    assert (ftest != null ? Math.abs(err.valid_mse - err3) < 1e-5 : Math.abs(err.train_mse - err3) < 1e-5);\n            //  bestPredict.delete();\n            //}\n          }\n//        else {\n//          // keep output JSON small\n//          if (errors.length > 1) {\n//            if (last_scored().trainAUC != null) last_scored().trainAUC.clear();\n//            if (last_scored().validAUC != null) last_scored().validAUC.clear();\n//            last_scored().variable_importances = null;\n//          }\n//        }\n\n          // print the freshly scored model to ASCII\n          for (String s : toString().split(\"\\n\")) Log.info(s);\n          if (printme) Log.info(\"Time taken for scoring and diagnostics: \" + PrettyPrint.msecs(err.scoring_time, true));\n        }\n      }\n      if (model_info().unstable()) {\n        Log.warn(unstable_msg);\n        keep_running = false;\n      } else if ( (_output.isClassifier() && last_scored().train_err <= get_params()._classification_stop)\n              || (!_output.isClassifier() && last_scored().train_mse <= get_params()._regression_stop) ) {\n        Log.info(\"Achieved requested predictive accuracy on the training data. Model building completed.\");\n        keep_running = false;\n      }\n      update(job_key);\n    }\n    catch (Exception ex) {\n      //ex.printStackTrace();\n      //throw new RuntimeException(ex);\n      return false;\n    }\n    return keep_running;\n }","commit_id":"f532a8b0d7807ac08ba3502c02db221c25f2a135","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public DeepLearningModelInfo(final DeepLearningParameters params, final DataInfo dinfo, boolean classification, Frame train, Frame valid) {\n      _classification = classification;\n      _train = train;\n      _valid = valid;\n      data_info = dinfo;\n      parameters = params;\n      final int num_input = dinfo.fullN();\n      final int num_output = get_params()._autoencoder ? num_input : (_classification ? train.lastVec().cardinality() : 1);\n      assert(num_input > 0);\n      assert(num_output > 0);\n      if (has_momenta() && adaDelta()) throw new IllegalArgumentException(\"Cannot have non-zero momentum and adaptive rate at the same time.\");\n      final int layers=get_params()._hidden.length;\n      // units (# neurons for each layer)\n      units = new int[layers+2];\n      if (get_params()._max_categorical_features <= Integer.MAX_VALUE - dinfo._nums)\n        units[0] = Math.min(dinfo._nums + get_params()._max_categorical_features, num_input);\n      else\n        units[0] = num_input;\n      System.arraycopy(get_params()._hidden, 0, units, 1, layers);\n      units[layers+1] = num_output;\n\n      if ((long)units[0] > 100000L) {\n        final String[][] domains = dinfo._adaptedFrame.domains();\n        int[] levels = new int[domains.length];\n        for (int i=0; i<levels.length; ++i) {\n          levels[i] = domains[i] != null ? domains[i].length : 0;\n        }\n        Arrays.sort(levels);\n        Log.warn(\"===================================================================================================================================\");\n        Log.warn(num_input + \" input features\" + (dinfo._cats > 0 ? \" (after categorical one-hot encoding)\" : \"\") + \". Can be slow and require a lot of memory.\");\n        if (levels[levels.length-1] > 0) {\n          int levelcutoff = levels[levels.length-1-Math.min(10, levels.length)];\n          int count = 0;\n          for (int i=0; i<dinfo._adaptedFrame.numCols() - (get_params()._autoencoder ? 0 : 1) && count < 10; ++i) {\n            if (dinfo._adaptedFrame.domains()[i] != null && dinfo._adaptedFrame.domains()[i].length >= levelcutoff) {\n              Log.warn(\"Categorical feature '\" + dinfo._adaptedFrame._names[i] + \"' has cardinality \" + dinfo._adaptedFrame.domains()[i].length + \".\");\n            }\n          }\n        }\n        Log.warn(\"Suggestions:\");\n        Log.warn(\" *) Limit the size of the first hidden layer\");\n        if (dinfo._cats > 0) {\n          Log.warn(\" *) Limit the total number of one-hot encoded features with the parameter 'max_categorical_features'\");\n          Log.warn(\" *) Run h2o.interaction(...,pairwise=F) on high-cardinality categorical columns to limit the factor count, see http://learn.h2o.ai\");\n        }\n        Log.warn(\"===================================================================================================================================\");\n      }\n\n      // weights (to connect layers)\n      dense_row_weights = new Neurons.DenseRowMatrix[layers+1];\n      dense_col_weights = new Neurons.DenseColMatrix[layers+1];\n\n      // decide format of weight matrices row-major or col-major\n      if (get_params()._col_major) dense_col_weights[0] = new Neurons.DenseColMatrix(units[1], units[0]);\n      else dense_row_weights[0] = new Neurons.DenseRowMatrix(units[1], units[0]);\n      for (int i = 1; i <= layers; ++i)\n        dense_row_weights[i] = new Neurons.DenseRowMatrix(units[i + 1] /*rows*/, units[i] /*cols*/);\n\n      // biases (only for hidden layers and output layer)\n      biases = new Neurons.DenseVector[layers+1];\n      for (int i=0; i<=layers; ++i) biases[i] = new Neurons.DenseVector(units[i+1]);\n      // average activation (only for hidden layers)\n      if (get_params()._autoencoder && get_params()._sparsity_beta > 0) {\n        avg_activations = new Neurons.DenseVector[layers];\n        mean_a = new float[layers];\n        for (int i = 0; i < layers; ++i) avg_activations[i] = new Neurons.DenseVector(units[i + 1]);\n      }\n      fillHelpers();\n      // for diagnostics\n      mean_rate = new float[units.length];\n      rms_rate = new float[units.length];\n      mean_bias = new float[units.length];\n      rms_bias = new float[units.length];\n      mean_weight = new float[units.length];\n      rms_weight = new float[units.length];\n    }","id":93498,"modified_method":"public DeepLearningModelInfo(final DeepLearningParameters params, final DataInfo dinfo, boolean classification, Frame train, Frame valid) {\n      _classification = classification;\n      _train = train;\n      _valid = valid;\n      data_info = dinfo;\n      parameters = params;\n      final int num_input = dinfo.fullN();\n      final int num_output = get_params()._autoencoder ? num_input : (_classification ? train.lastVec().cardinality() : 1);\n      assert(num_input > 0);\n      assert(num_output > 0);\n      if (has_momenta() && adaDelta()) throw new IllegalArgumentException(\"Cannot have non-zero momentum and adaptive rate at the same time.\");\n      final int layers=get_params()._hidden.length;\n      // units (# neurons for each layer)\n      units = new int[layers+2];\n      if (get_params()._max_categorical_features <= Integer.MAX_VALUE - dinfo._nums)\n        units[0] = Math.min(dinfo._nums + get_params()._max_categorical_features, num_input);\n      else\n        units[0] = num_input;\n      System.arraycopy(get_params()._hidden, 0, units, 1, layers);\n      units[layers+1] = num_output;\n\n      if ((long)units[0] > 100000L) {\n        final String[][] domains = dinfo._adaptedFrame.domains();\n        int[] levels = new int[domains.length];\n        for (int i=0; i<levels.length; ++i) {\n          levels[i] = domains[i] != null ? domains[i].length : 0;\n        }\n        Arrays.sort(levels);\n        Log.warn(\"===================================================================================================================================\");\n        Log.warn(num_input + \" input features\" + (dinfo._cats > 0 ? \" (after categorical one-hot encoding)\" : \"\") + \". Can be slow and require a lot of memory.\");\n        if (levels[levels.length-1] > 0) {\n          int levelcutoff = levels[levels.length-1-Math.min(10, levels.length)];\n          int count = 0;\n          for (int i=0; i<dinfo._adaptedFrame.numCols() - (get_params()._autoencoder ? 0 : 1) && count < 10; ++i) {\n            if (dinfo._adaptedFrame.domains()[i] != null && dinfo._adaptedFrame.domains()[i].length >= levelcutoff) {\n              Log.warn(\"Categorical feature '\" + dinfo._adaptedFrame._names[i] + \"' has cardinality \" + dinfo._adaptedFrame.domains()[i].length + \".\");\n            }\n            count++;\n          }\n        }\n        Log.warn(\"Suggestions:\");\n        Log.warn(\" *) Limit the size of the first hidden layer\");\n        if (dinfo._cats > 0) {\n          Log.warn(\" *) Limit the total number of one-hot encoded features with the parameter 'max_categorical_features'\");\n          Log.warn(\" *) Run h2o.interaction(...,pairwise=F) on high-cardinality categorical columns to limit the factor count, see http://learn.h2o.ai\");\n        }\n        Log.warn(\"===================================================================================================================================\");\n      }\n\n      // weights (to connect layers)\n      dense_row_weights = new Neurons.DenseRowMatrix[layers+1];\n      dense_col_weights = new Neurons.DenseColMatrix[layers+1];\n\n      // decide format of weight matrices row-major or col-major\n      if (get_params()._col_major) dense_col_weights[0] = new Neurons.DenseColMatrix(units[1], units[0]);\n      else dense_row_weights[0] = new Neurons.DenseRowMatrix(units[1], units[0]);\n      for (int i = 1; i <= layers; ++i)\n        dense_row_weights[i] = new Neurons.DenseRowMatrix(units[i + 1] /*rows*/, units[i] /*cols*/);\n\n      // biases (only for hidden layers and output layer)\n      biases = new Neurons.DenseVector[layers+1];\n      for (int i=0; i<=layers; ++i) biases[i] = new Neurons.DenseVector(units[i+1]);\n      // average activation (only for hidden layers)\n      if (get_params()._autoencoder && get_params()._sparsity_beta > 0) {\n        avg_activations = new Neurons.DenseVector[layers];\n        mean_a = new float[layers];\n        for (int i = 0; i < layers; ++i) avg_activations[i] = new Neurons.DenseVector(units[i + 1]);\n      }\n      fillHelpers();\n      // for diagnostics\n      mean_rate = new float[units.length];\n      rms_rate = new float[units.length];\n      mean_bias = new float[units.length];\n      rms_bias = new float[units.length];\n      mean_weight = new float[units.length];\n      rms_weight = new float[units.length];\n    }","commit_id":"f532a8b0d7807ac08ba3502c02db221c25f2a135","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public String toString() {\n      StringBuilder sb = new StringBuilder();\n      if (classification) {\n        sb.append(\"Error on training data (misclassification)\"\n                + (trainAUC != null ? \" [using threshold for \" + trainAUC.threshold_criterion.toString().replace(\"_\",\" \") +\"]: \": \": \")\n                + String.format(\"%.2f\", 100*train_err) + \"%\");\n\n        if (trainAUC != null) sb.append(\", AUC on training data: \" + String.format(\"%.4f\", 100*trainAUC.AUC) + \"%\");\n        if (validation || num_folds>0)\n          sb.append(\"\\nError on \" + (num_folds>0 ? num_folds + \"-fold cross-\":\"\")+ \"validation data (misclassification)\"\n                + (validAUC != null ? \" [using threshold for \" + validAUC.threshold_criterion.toString().replace(\"_\",\" \") +\"]: \": \": \")\n                + String.format(\"%.2f\", (100*valid_err)) + \"%\");\n        if (validAUC != null) sb.append(\", AUC on validation data: \" + String.format(\"%.4f\", 100*validAUC.AUC) + \"%\");\n      } else if (!Double.isInfinite(train_mse)) {\n        sb.append(\"Error on training data (MSE): \" + train_mse);\n        if (validation || num_folds>0)\n          sb.append(\"\\nError on \"+ (num_folds>0 ? num_folds + \"-fold cross-\":\"\")+ \"validation data (MSE): \" + valid_mse);\n      }\n      return sb.toString();\n    }","id":93499,"modified_method":"@Override public String toString() {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Training MSE: \" + train_mse + \"\\n\");\n      sb.append(\"Training R^2: \" + train_r2 + \"\\n\");\n      if (classification) {\n        sb.append(\"Training \" + train_confusion_matrix.table.toString(1));\n        sb.append(\"Training Misclassification\"\n                + (trainAUC != null ? \" [using threshold for \" + trainAUC.threshold_criterion.toString().replace(\"_\", \" \") + \"]: \" : \": \")\n                + String.format(\"%.2f\", 100 * train_err) + \"%\");\n        if (trainAUC != null) sb.append(\", AUC: \" + String.format(\"%.4f\", 100 * trainAUC.AUC) + \"%\");\n      }\n      if (validation || num_folds>0) {\n        sb.append(\"\\nValidation data metrics\" + (num_folds > 0 ? (\" (using \" + num_folds + \"-fold cross-validation):\") : \":\"));\n        sb.append(\"\\nValidation MSE: \" + valid_mse + \"\\n\");\n        sb.append(\"Validation R^2: \" + valid_r2 + \"\\n\");\n        if (classification) {\n          sb.append(\"Validation \" + valid_confusion_matrix.table.toString(1));\n          sb.append(\"Validation Misclassification\"\n                  + (validAUC != null ? \" [using threshold for \" + validAUC.threshold_criterion.toString().replace(\"_\", \" \") + \"]: \" : \": \")\n                  + String.format(\"%.2f\", (100 * valid_err)) + \"%\");\n          if (validAUC != null) sb.append(\", AUC: \" + String.format(\"%.4f\", 100 * validAUC.AUC) + \"%\");\n        }\n      }\n      sb.append(\"\\n\");\n      return sb.toString();\n    }","commit_id":"f532a8b0d7807ac08ba3502c02db221c25f2a135","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public String toStringAll() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(model_info.toStringAll());\n    sb.append(last_scored().toString());\n    return sb.toString();\n  }","id":93500,"modified_method":"public String toStringAll() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Training time: \" + PrettyPrint.msecs(run_time, true)\n            + \". Processed \" + String.format(\"%,d\", training_rows) + \" samples\" + \" (\" + String.format(\"%.3f\", epoch_counter) + \" epochs).\"\n            + \" Speed: \" + String.format(\"%.3f\", 1000.*training_rows/run_time) + \" samples/sec.\\n\");\n    sb.append(model_info.toStringAll());\n    sb.append(last_scored().toString());\n    return sb.toString();\n  }","commit_id":"f532a8b0d7807ac08ba3502c02db221c25f2a135","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   *\n   * @param ftrain potentially downsampled training data for scoring\n   * @param ftest  potentially downsampled validation data for scoring\n   * @param job_key key of the owning job\n   * @param progressKey key of the progress\n   * @return true if model building is ongoing\n   */\n  boolean doScoring(Frame ftrain, Frame ftest, Key job_key, Key progressKey) {\n    boolean keep_running;\n    try {\n      final long now = System.currentTimeMillis();\n      epoch_counter = (float)model_info().get_processed_total()/training_rows;\n      final double time_last_iter_millis = Math.max(5,now-_timeLastScoreEnter);\n\n      // Auto-tuning\n      // if multi-node and auto-tuning and at least 10 ms for communication (to avoid doing thins on multi-JVM on same node),\n      // then adjust the auto-tuning parameter 'actual_train_samples_per_iteration' such that the targeted ratio of comm to comp is achieved\n      // Note: actual communication time is estimated by the NetworkTest's collective test.\n      if (H2O.CLOUD.size() > 1 && get_params()._train_samples_per_iteration == -2 && time_for_communication_us > 1e4) {\n//        Log.info(\"Time taken for communication: \" + PrettyPrint.usecs((long)time_for_communication_us));\n//        Log.info(\"Time taken for Map/Reduce iteration: \" + PrettyPrint.msecs((long)time_last_iter_millis, true));\n        final double comm_to_work_ratio = (time_for_communication_us *1e-3) / time_last_iter_millis;\n//        Log.info(\"Ratio of network communication to computation: \" + String.format(\"%.3f\", comm_to_work_ratio));\n//        Log.info(\"target_comm_to_work: \" + get_params().target_ratio_comm_to_comp);\n        final double correction = get_params()._target_ratio_comm_to_comp / comm_to_work_ratio;\n//        Log.warn(\"Suggested value for train_samples_per_iteration: \" + get_params().actual_train_samples_per_iteration/correction);\n        actual_train_samples_per_iteration /= correction;\n        actual_train_samples_per_iteration = Math.max(1, actual_train_samples_per_iteration);\n      }\n\n      run_time += time_last_iter_millis;\n      _timeLastScoreEnter = now;\n      keep_running = (epoch_counter < model_info().get_params()._epochs);\n      final long sinceLastScore = now -_timeLastScoreStart;\n      final long sinceLastPrint = now -_timeLastPrintStart;\n      if (!keep_running || sinceLastPrint > get_params()._score_interval * 1000) { //print this after every score_interval, not considering duty cycle\n        _timeLastPrintStart = now;\n        if (!get_params()._quiet_mode) {\n          Log.info(\"Training time: \" + PrettyPrint.msecs(run_time, true)\n                  + \". Processed \" + String.format(\"%,d\", model_info().get_processed_total()) + \" samples\" + \" (\" + String.format(\"%.3f\", epoch_counter) + \" epochs).\"\n                  + \" Speed: \" + String.format(\"%.3f\", 1000. * model_info().get_processed_total() / run_time) + \" samples/sec.\\n\");\n        }\n      }\n\n      // this is potentially slow - only do every so often\n      if( !keep_running ||\n              (sinceLastScore > get_params()._score_interval *1000 //don't score too often\n                      &&(double)(_timeLastScoreEnd-_timeLastScoreStart)/sinceLastScore < get_params()._score_duty_cycle) ) { //duty cycle\n        if (progressKey != null) {\n          new Job.ProgressUpdate(\"Scoring on \" + ftrain.numRows() + \" training samples\" +\n                  (ftest != null ? (\", \" + ftest.numRows() + \" validation samples)\") : \")\")\n          ).fork(progressKey);\n        }\n        final boolean printme = !get_params()._quiet_mode;\n        _timeLastScoreStart = now;\n        if (get_params()._diagnostics) model_info().computeStats();\n        DeepLearningScoring err = new DeepLearningScoring();\n        err.training_time_ms = run_time;\n        err.epoch_counter = epoch_counter;\n        err.training_samples = model_info().get_processed_total();\n        err.validation = ftest != null;\n        err.score_training_samples = ftrain.numRows();\n        err.classification = _output.isClassifier();\n\n        hex.ModelMetrics mtrain = ModelMetrics.getFromDKV(this,ftrain);\n        err.scored_train = new ScoredClassifierRegressor(mtrain);\n\n        if (get_params()._autoencoder) {\n          if (printme) Log.info(\"Scoring the auto-encoder.\");\n          // training\n          {\n            final Frame mse_frame = scoreAutoEncoder(ftrain, Key.make());\n            final Vec l2 = mse_frame.anyVec();\n            Log.info(\"Mean reconstruction error on training data: \" + l2.mean() + \"\\n\");\n            mse_frame.delete();\n\n            hex.ModelMetricsAutoEncoder mm1 = (ModelMetricsAutoEncoder)ModelMetrics.getFromDKV(this,ftrain);\n            assert(err.scored_train._mse == l2.mean());\n            _output._training_metrics = mm1;\n          }\n          if (ftest != null) {\n            final Frame mse_frame = scoreAutoEncoder(ftest, Key.make());\n            final Vec l2 = mse_frame.anyVec();\n            Log.info(\"Mean reconstruction error on validation data: \" + l2.mean() + \"\\n\");\n            mse_frame.delete();\n\n            hex.ModelMetricsAutoEncoder mm1 = (ModelMetricsAutoEncoder)ModelMetrics.getFromDKV(this,ftest);\n            assert(err.scored_valid._mse == l2.mean());\n            _output._validation_metrics = mm1;\n          }\n        } else {\n          if (printme) Log.info(\"Scoring the model.\");\n          // compute errors\n          final String m = model_info().toString();\n          if (m.length() > 0) Log.info(m);\n          final Frame trainPredict = score(ftrain);\n          trainPredict.delete();\n\n          hex.ModelMetricsSupervised mm1 = (ModelMetricsSupervised)ModelMetrics.getFromDKV(this,ftrain);\n          _output._training_metrics = mm1;\n          if (mm1 instanceof ModelMetricsBinomial) {\n            ModelMetricsBinomial mm = (ModelMetricsBinomial)(mm1);\n            err.train_confusion_matrix = mm.cm();\n          }\n          else if (mm1 instanceof ModelMetricsMultinomial) {\n            ModelMetricsMultinomial mm = (ModelMetricsMultinomial)(mm1);\n            err.train_confusion_matrix = mm.cm();\n            err.train_hitratio = mm._hit_ratios;\n          }\n          if (get_params()._score_training_samples != 0 && get_params()._score_training_samples < ftrain.numRows()) {\n            _output._training_metrics._description = \"Metrics reported on \" + ftrain.numRows() + \" training set samples\";\n          }\n\n          if (ftest != null) {\n            Frame validPred = score(ftest);\n            validPred.delete();\n            hex.ModelMetrics mtest = hex.ModelMetrics.getFromDKV(this, ftest);\n            err.scored_valid = new ScoredClassifierRegressor(mtest);\n            if (mtest != null) {\n              _output._validation_metrics = mtest;\n              if (mtest instanceof ModelMetricsBinomial) {\n                ModelMetricsBinomial mm = (ModelMetricsBinomial)mtest;\n                err.validation_AUC = mm._auc;\n                err.valid_confusion_matrix = mm.cm();\n              } else if (mtest instanceof ModelMetricsMultinomial) {\n                ModelMetricsMultinomial mm = (ModelMetricsMultinomial)mtest;\n                err.valid_confusion_matrix = mm.cm();\n                err.valid_hitratio = mm._hit_ratios;\n              }\n              if (get_params()._score_validation_samples != 0 && get_params()._score_validation_samples != ftest.numRows()) {\n                _output._validation_metrics._description = \"Metrics reported on \" + ftest.numRows() + \" validation set samples\";\n                if (get_params()._score_validation_sampling == DeepLearningParameters.ClassSamplingMethod.Stratified) {\n                  _output._validation_metrics._description += \" (stratified sampling)\";\n                }\n              }\n            }\n          }\n        }\n        if (get_params()._variable_importances) {\n          if (!get_params()._quiet_mode) Log.info(\"Computing variable importances.\");\n          final float[] vi = model_info().computeVariableImportances();\n          err.variable_importances = new VarImp(vi, Arrays.copyOfRange(model_info().data_info().coefNames(), 0, vi.length));\n        }\n\n        _timeLastScoreEnd = System.currentTimeMillis();\n        err.scoring_time = System.currentTimeMillis() - now;\n        // enlarge the error array by one, push latest score back\n        if (errors == null) {\n          errors = new DeepLearningScoring[]{err};\n        } else {\n          DeepLearningScoring[] err2 = new DeepLearningScoring[errors.length + 1];\n          System.arraycopy(errors, 0, err2, 0, errors.length);\n          err2[err2.length - 1] = err;\n          errors = err2;\n        }\n        _output.errors = last_scored();\n        water.util.Timer t = new Timer();\n        // store weights and matrices to Frames\n        if (_output.weights != null && _output.biases != null) {\n          for (int i = 0; i < _output.weights.length; ++i) {\n            model_info.get_weights(i).toFrame(_output.weights[i]);\n          }\n          for (int i = 0; i < _output.biases.length; ++i) {\n            model_info.get_biases(i).toFrame(_output.biases[i]);\n          }\n          Log.info(\"Writing weights and biases to Frames took \" + t.time()/1000. + \" seconds.\");\n        }\n        _output._scoring_history = createScoringHistoryTable(errors);\n        _output._variable_importances = calcVarImp(last_scored().variable_importances);\n        _output._model_summary = model_info.createSummaryTable();\n\n        if (!get_params()._autoencoder) {\n          // always keep a copy of the best model so far (based on the following criterion)\n          if (actual_best_model_key != null && get_params()._overwrite_with_best_model && (\n                  // if we have a best_model in DKV, then compare against its error() (unless it's a different model as judged by the network size)\n                  (DKV.get(actual_best_model_key) != null && (error() < DKV.get(actual_best_model_key).<DeepLearningModel>get().error() || !Arrays.equals(model_info().units, DKV.get(actual_best_model_key).<DeepLearningModel>get().model_info().units)))\n                          ||\n                          // otherwise, compare against our own _bestError\n                          (DKV.get(actual_best_model_key) == null && error() < _bestError)\n          ) ) {\n            if (!get_params()._quiet_mode)\n              Log.info(\"Error reduced from \" + _bestError + \" to \" + error() + \".\");\n            _bestError = error();\n            putMeAsBestModel(actual_best_model_key);\n\n            // debugging check\n            //if (false) {\n            //  DeepLearningModel bestModel = DKV.get(actual_best_model_key).get();\n            //  final Frame fr = ftest != null ? ftest : ftrain;\n            //  final Frame bestPredict = bestModel.score(fr);\n            //  final Frame hitRatio_bestPredict = new Frame(bestPredict);\n            //  final double err3 = calcError(fr, fr.lastVec(), bestPredict, hitRatio_bestPredict, \"cross-check\",\n            //    printme, get_params()._max_confusion_matrix_size, new hex.ConfusionMatrix2(), _output.isClassifier() && _output.nclasses() == 2 ? new AUC(null,null) : null, null);\n            //  if (_output.isClassifier())\n            //    assert (ftest != null ? Math.abs(err.valid_err - err3) < 1e-5 : Math.abs(err.train_err - err3) < 1e-5);\n            //  else\n            //    assert (ftest != null ? Math.abs(err.validation_MSE - err3) < 1e-5 : Math.abs(err.training_MSE - err3) < 1e-5);\n            //  bestPredict.delete();\n            //}\n          }\n//        else {\n//          // keep output JSON small\n//          if (errors.length > 1) {\n//            if (last_scored().training_AUC != null) last_scored().training_AUC.clear();\n//            if (last_scored().validation_AUC != null) last_scored().validation_AUC.clear();\n//            last_scored()._variable_importances = null;\n//          }\n//        }\n\n          // print the freshly scored model to ASCII\n          if (keep_running)\n            for (String s : toString().split(\"\\n\")) Log.info(s);\n          if (printme) Log.info(\"Time taken for scoring and diagnostics: \" + PrettyPrint.msecs(err.scoring_time, true));\n        }\n      }\n      if (model_info().unstable()) {\n        Log.warn(unstable_msg);\n        keep_running = false;\n      } else if ( (_output.isClassifier() && last_scored().scored_train._classError <= get_params()._classification_stop)\n              || (!_output.isClassifier() && last_scored().scored_train._mse <= get_params()._regression_stop) ) {\n        Log.info(\"Achieved requested predictive accuracy on the training data. Model building completed.\");\n        keep_running = false;\n      }\n      update(job_key);\n    }\n    catch (Exception ex) {\n      //ex.printStackTrace();\n      throw new RuntimeException(ex);\n//      return false;\n    }\n    return keep_running;\n }","id":93501,"modified_method":"/**\n   *\n   * @param ftrain potentially downsampled training data for scoring\n   * @param ftest  potentially downsampled validation data for scoring\n   * @param job_key key of the owning job\n   * @param progressKey key of the progress\n   * @return true if model building is ongoing\n   */\n  boolean doScoring(Frame ftrain, Frame ftest, Key job_key, Key progressKey) {\n    boolean keep_running;\n    try {\n      final long now = System.currentTimeMillis();\n      epoch_counter = (float)model_info().get_processed_total()/training_rows;\n      final double time_last_iter_millis = Math.max(5,now-_timeLastScoreEnter);\n\n      // Auto-tuning\n      // if multi-node and auto-tuning and at least 10 ms for communication (to avoid doing thins on multi-JVM on same node),\n      // then adjust the auto-tuning parameter 'actual_train_samples_per_iteration' such that the targeted ratio of comm to comp is achieved\n      // Note: actual communication time is estimated by the NetworkTest's collective test.\n      if (H2O.CLOUD.size() > 1 && get_params()._train_samples_per_iteration == -2 && time_for_communication_us > 1e4) {\n//        Log.info(\"Time taken for communication: \" + PrettyPrint.usecs((long)time_for_communication_us));\n//        Log.info(\"Time taken for Map/Reduce iteration: \" + PrettyPrint.msecs((long)time_last_iter_millis, true));\n        final double comm_to_work_ratio = (time_for_communication_us *1e-3) / time_last_iter_millis;\n//        Log.info(\"Ratio of network communication to computation: \" + String.format(\"%.3f\", comm_to_work_ratio));\n//        Log.info(\"target_comm_to_work: \" + get_params().target_ratio_comm_to_comp);\n        final double correction = get_params()._target_ratio_comm_to_comp / comm_to_work_ratio;\n//        Log.warn(\"Suggested value for train_samples_per_iteration: \" + get_params().actual_train_samples_per_iteration/correction);\n        actual_train_samples_per_iteration /= correction;\n        actual_train_samples_per_iteration = Math.max(1, actual_train_samples_per_iteration);\n      }\n\n      run_time += time_last_iter_millis;\n      _timeLastScoreEnter = now;\n      keep_running = (epoch_counter < model_info().get_params()._epochs);\n      final long sinceLastScore = now -_timeLastScoreStart;\n      final long sinceLastPrint = now -_timeLastPrintStart;\n      if (!keep_running || sinceLastPrint > get_params()._score_interval * 1000) { //print this after every score_interval, not considering duty cycle\n        _timeLastPrintStart = now;\n        if (!get_params()._quiet_mode) {\n          Log.info(\"Training time: \" + PrettyPrint.msecs(run_time, true)\n                  + \". Processed \" + String.format(\"%,d\", model_info().get_processed_total()) + \" samples\" + \" (\" + String.format(\"%.3f\", epoch_counter) + \" epochs).\"\n                  + \" Speed: \" + String.format(\"%.3f\", 1000. * model_info().get_processed_total() / run_time) + \" samples/sec.\\n\");\n        }\n      }\n\n      // this is potentially slow - only do every so often\n      if( !keep_running ||\n              (sinceLastScore > get_params()._score_interval *1000 //don't score too often\n                      &&(double)(_timeLastScoreEnd-_timeLastScoreStart)/sinceLastScore < get_params()._score_duty_cycle) ) { //duty cycle\n        if (progressKey != null) {\n          new Job.ProgressUpdate(\"Scoring on \" + ftrain.numRows() + \" training samples\" +\n                  (ftest != null ? (\", \" + ftest.numRows() + \" validation samples)\") : \")\")\n          ).fork(progressKey);\n        }\n        final boolean printme = !get_params()._quiet_mode;\n        _timeLastScoreStart = now;\n        if (get_params()._diagnostics) model_info().computeStats();\n        DeepLearningScoring err = new DeepLearningScoring();\n        err.training_time_ms = run_time;\n        err.epoch_counter = epoch_counter;\n        err.training_samples = model_info().get_processed_total();\n        err.validation = ftest != null;\n        err.score_training_samples = ftrain.numRows();\n        err.classification = _output.isClassifier();\n\n        if (get_params()._autoencoder) {\n          if (printme) Log.info(\"Scoring the auto-encoder.\");\n          // training\n          {\n            final Frame mse_frame = scoreAutoEncoder(ftrain, Key.make());\n            final Vec l2 = mse_frame.anyVec();\n            Log.info(\"Mean reconstruction error on training data: \" + l2.mean() + \"\\n\");\n            mse_frame.delete();\n            ModelMetrics mtrain = ModelMetrics.getFromDKV(this,ftrain); //updated by model.score\n            _output._training_metrics = mtrain;\n            err.scored_train = new ScoredClassifierRegressor(mtrain);\n          }\n          if (ftest != null) {\n            final Frame mse_frame = scoreAutoEncoder(ftest, Key.make());\n            final Vec l2 = mse_frame.anyVec();\n            Log.info(\"Mean reconstruction error on validation data: \" + l2.mean() + \"\\n\");\n            mse_frame.delete();\n            ModelMetrics mtest = ModelMetrics.getFromDKV(this,ftest); //updated by model.score\n            _output._validation_metrics = mtest;\n            err.scored_valid = new ScoredClassifierRegressor(mtest);\n          }\n        } else {\n          if (printme) Log.info(\"Scoring the model.\");\n          // compute errors\n          final String m = model_info().toString();\n          if (m.length() > 0) Log.info(m);\n          final Frame trainPredict = score(ftrain);\n          trainPredict.delete();\n\n          hex.ModelMetrics mtrain = ModelMetrics.getFromDKV(this,ftrain);\n          _output._training_metrics = mtrain;\n          err.scored_train = new ScoredClassifierRegressor(mtrain);\n          hex.ModelMetrics mtest = null;\n\n          hex.ModelMetricsSupervised mm1 = (ModelMetricsSupervised)ModelMetrics.getFromDKV(this,ftrain);\n          if (mm1 instanceof ModelMetricsBinomial) {\n            ModelMetricsBinomial mm = (ModelMetricsBinomial)(mm1);\n            err.train_confusion_matrix = mm.cm();\n          }\n          else if (mm1 instanceof ModelMetricsMultinomial) {\n            ModelMetricsMultinomial mm = (ModelMetricsMultinomial)(mm1);\n            err.train_confusion_matrix = mm.cm();\n            err.train_hitratio = mm._hit_ratios;\n          }\n          if (get_params()._score_training_samples != 0 && get_params()._score_training_samples < ftrain.numRows()) {\n            _output._training_metrics._description = \"Metrics reported on \" + ftrain.numRows() + \" training set samples\";\n          }\n\n          if (ftest != null) {\n            Frame validPred = score(ftest);\n            validPred.delete();\n            if (ftest != null) {\n              mtest = ModelMetrics.getFromDKV(this, ftest);\n              _output._validation_metrics = mtest;\n              err.scored_valid = new ScoredClassifierRegressor(mtest);\n            }\n            if (mtest != null) {\n              if (mtest instanceof ModelMetricsBinomial) {\n                ModelMetricsBinomial mm = (ModelMetricsBinomial)mtest;\n                err.validation_AUC = mm._auc;\n                err.valid_confusion_matrix = mm.cm();\n              } else if (mtest instanceof ModelMetricsMultinomial) {\n                ModelMetricsMultinomial mm = (ModelMetricsMultinomial)mtest;\n                err.valid_confusion_matrix = mm.cm();\n                err.valid_hitratio = mm._hit_ratios;\n              }\n              if (get_params()._score_validation_samples != 0 && get_params()._score_validation_samples != ftest.numRows()) {\n                _output._validation_metrics._description = \"Metrics reported on \" + ftest.numRows() + \" validation set samples\";\n                if (get_params()._score_validation_sampling == DeepLearningParameters.ClassSamplingMethod.Stratified) {\n                  _output._validation_metrics._description += \" (stratified sampling)\";\n                }\n              }\n            }\n          }\n        }\n        if (get_params()._variable_importances) {\n          if (!get_params()._quiet_mode) Log.info(\"Computing variable importances.\");\n          final float[] vi = model_info().computeVariableImportances();\n          err.variable_importances = new VarImp(vi, Arrays.copyOfRange(model_info().data_info().coefNames(), 0, vi.length));\n        }\n\n        _timeLastScoreEnd = System.currentTimeMillis();\n        err.scoring_time = System.currentTimeMillis() - now;\n        // enlarge the error array by one, push latest score back\n        if (errors == null) {\n          errors = new DeepLearningScoring[]{err};\n        } else {\n          DeepLearningScoring[] err2 = new DeepLearningScoring[errors.length + 1];\n          System.arraycopy(errors, 0, err2, 0, errors.length);\n          err2[err2.length - 1] = err;\n          errors = err2;\n        }\n        _output.errors = last_scored();\n        water.util.Timer t = new Timer();\n        // store weights and matrices to Frames\n        if (_output.weights != null && _output.biases != null) {\n          for (int i = 0; i < _output.weights.length; ++i) {\n            model_info.get_weights(i).toFrame(_output.weights[i]);\n          }\n          for (int i = 0; i < _output.biases.length; ++i) {\n            model_info.get_biases(i).toFrame(_output.biases[i]);\n          }\n          Log.info(\"Writing weights and biases to Frames took \" + t.time()/1000. + \" seconds.\");\n        }\n        _output._scoring_history = createScoringHistoryTable(errors);\n        _output._variable_importances = calcVarImp(last_scored().variable_importances);\n        _output._model_summary = model_info.createSummaryTable();\n\n        if (!get_params()._autoencoder) {\n          // always keep a copy of the best model so far (based on the following criterion)\n          if (actual_best_model_key != null && get_params()._overwrite_with_best_model && (\n                  // if we have a best_model in DKV, then compare against its error() (unless it's a different model as judged by the network size)\n                  (DKV.get(actual_best_model_key) != null && (error() < DKV.get(actual_best_model_key).<DeepLearningModel>get().error() || !Arrays.equals(model_info().units, DKV.get(actual_best_model_key).<DeepLearningModel>get().model_info().units)))\n                          ||\n                          // otherwise, compare against our own _bestError\n                          (DKV.get(actual_best_model_key) == null && error() < _bestError)\n          ) ) {\n            if (!get_params()._quiet_mode)\n              Log.info(\"Error reduced from \" + _bestError + \" to \" + error() + \".\");\n            _bestError = error();\n            putMeAsBestModel(actual_best_model_key);\n\n            // debugging check\n            //if (false) {\n            //  DeepLearningModel bestModel = DKV.get(actual_best_model_key).get();\n            //  final Frame fr = ftest != null ? ftest : ftrain;\n            //  final Frame bestPredict = bestModel.score(fr);\n            //  final Frame hitRatio_bestPredict = new Frame(bestPredict);\n            //  final double err3 = calcError(fr, fr.lastVec(), bestPredict, hitRatio_bestPredict, \"cross-check\",\n            //    printme, get_params()._max_confusion_matrix_size, new hex.ConfusionMatrix2(), _output.isClassifier() && _output.nclasses() == 2 ? new AUC(null,null) : null, null);\n            //  if (_output.isClassifier())\n            //    assert (ftest != null ? Math.abs(err.valid_err - err3) < 1e-5 : Math.abs(err.train_err - err3) < 1e-5);\n            //  else\n            //    assert (ftest != null ? Math.abs(err.validation_MSE - err3) < 1e-5 : Math.abs(err.training_MSE - err3) < 1e-5);\n            //  bestPredict.delete();\n            //}\n          }\n//        else {\n//          // keep output JSON small\n//          if (errors.length > 1) {\n//            if (last_scored().training_AUC != null) last_scored().training_AUC.clear();\n//            if (last_scored().validation_AUC != null) last_scored().validation_AUC.clear();\n//            last_scored()._variable_importances = null;\n//          }\n//        }\n\n          // print the freshly scored model to ASCII\n          if (keep_running)\n            for (String s : toString().split(\"\\n\")) Log.info(s);\n          if (printme) Log.info(\"Time taken for scoring and diagnostics: \" + PrettyPrint.msecs(err.scoring_time, true));\n        }\n      }\n      if (model_info().unstable()) {\n        Log.warn(unstable_msg);\n        keep_running = false;\n      } else if ( (_output.isClassifier() && last_scored().scored_train._classError <= get_params()._classification_stop)\n              || (!_output.isClassifier() && last_scored().scored_train._mse <= get_params()._regression_stop) ) {\n        Log.info(\"Achieved requested predictive accuracy on the training data. Model building completed.\");\n        keep_running = false;\n      }\n      update(job_key);\n    }\n    catch (Exception ex) {\n      //ex.printStackTrace();\n      throw new RuntimeException(ex);\n//      return false;\n    }\n    return keep_running;\n }","commit_id":"4ca00f9f3dda302fa0671560d1915a233c84e78c","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Recursively splits rectangles.\n   * @param r parent rectangle\n   * @param l children array\n   * @param ns start array position\n   * @param ne end array position\n   * @param level indicates level which is calculated\n   */\n  void makeMap(final MapRect r, final MapList l, final int ns, final int ne, \n      final int level) {\n    if(ne - ns <= 1) {\n      // one rectangle left, add it and go deeper\n      r.pre = l.list[ns];\n      putRect(r, level);\n    } else {\n      ArrayList<MapRect> rects;\n      if(level == 0) {\n        rects = splitUniformly(r, l, ns, ne);\n      } else {\n        int nn = l.list[ne] - l.list[ns];\n        long parsize = data.fs != null ? addSizes(l, ns, ne) : 0;\n        // init weights of nodes and sort\n        l.initWeights(parsize, nn, data);\n        rects = algo.calcMap(r, l, l.weights, ns, ne, level);\n      }\n      // call recursion for next deeper levels\n      for(MapRect rect : rects) putRect(rect, rect.level);\n    }\n  }","id":93502,"modified_method":"/**\n   * Recursively splits rectangles.\n   * @param r parent rectangle\n   * @param l children array\n   * @param ns start array position\n   * @param ne end array position\n   * @param level indicates level which is calculated\n   */\n  void makeMap(final MapRect r, final MapList l, final int ns, final int ne, \n      final int level) {\n    if(ne - ns <= 1) {\n      // one rectangle left, add it and go deeper\n      r.pre = l.list[ns];\n      putRect(r, level);\n    } else {\n      long parsize = data.fs != null ? addSizes(l, ns, ne) : 0;\n      int nn;\n      ArrayList<MapRect> rects;\n      if(level == 0) {\n        // [JH] use this for all instances\n        if(data.fs != null) {\n          rects = splitUniformly(r, l, ns, ne);\n        } else {\n          nn = l.list[ne - 1] - l.list[ns];\n          l.initWeights(parsize, nn, data);\n          \n          MapAlgo tmp = new SplitAlgo();\n          rects = tmp.calcMap(r, l, l.weights, ns, ne - 1, level);\n        }\n      } else {\n        nn = l.list[ne] - l.list[ns];\n        // init weights of nodes and sort\n        l.initWeights(parsize, nn, data);\n        rects = algo.calcMap(r, l, l.weights, ns, ne, level);\n      }\n      // call recursion for next deeper levels\n      for(MapRect rect : rects) putRect(rect, rect.level);\n    }\n  }","commit_id":"6811b3f8f6f0c804a9fbe757736efe939d0c93a0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Recursively splits rectangles.\n   * @param r parent rectangle\n   * @param l children array\n   * @param ns start array position\n   * @param ne end array position\n   * @param level indicates level which is calculated\n   */\n  void makeMap(final MapRect r, final MapList l, final int ns, final int ne, \n      final int level) {\n    if(ne - ns == 0) {\n      // one rectangle left, add it and go deeper\n      r.pre = l.list[ns];\n      putRect(r, level);  \n    } else {\n      final long parsize = data.fs != null ? addSizes(l) : 0;\n      int nn;\n      ArrayList<MapRect> rects;\n      if(level == 0) {\n        // [JH] may first level layout should not be defined to splitalgo\n        // [JH] use textLen\n        nn = 0;\n        for (int i = 0; i < l.size; i++) {\n          nn += data.size(l.list[i], data.kind(l.list[i]));\n        }\n        l.initWeights(parsize, nn, data);\n        \n        final MapAlgo tmp = new SplitAlgo();\n        rects = tmp.calcMap(r, l, l.weight, ns, ne, level);\n      } else {\n        nn = l.list[ne] - l.list[ns] + \n            data.size(l.list[ne], data.kind(l.list[ne]));\n        \n        // init weights of nodes\n        if(GUIProp.mapsimple) {\n          l.initWeights();\n        } else if(GUIProp.usetextlength && data.fs == null) {\n          l.initWeights(textLen, nn, data);\n        } else l.initWeights(parsize, nn, data);\n        rects = algo.calcMap(r, l, l.weight, ns, ne, level);\n      }\n      // call recursion for next deeper levels\n      for(final MapRect rect : rects) putRect(rect, rect.level);\n    }\n  }","id":93503,"modified_method":"/**\n   * Recursively splits rectangles.\n   * @param r parent rectangle\n   * @param l children array\n   * @param ns start array position\n   * @param ne end array position\n   * @param level indicates level which is calculated\n   */\n  void makeMap(final MapRect r, final MapList l, final int ns, final int ne, \n      final int level) {\n    if(ne - ns == 0) {\n      // one rectangle left, add it and go deeper\n      r.pre = l.list[ns];\n      putRect(r, level);  \n    } else {\n      final long parsize = data.fs != null ? addSizes(l) : 0;\n      int nn;\n      ArrayList<MapRect> rects;\n      if(level == 0) {\n        // [JH] may first level layout should not be defined to splitalgo\n        // [JH] use textLen\n        nn = 0;\n        for (int i = 0; i < l.size; i++) {\n          nn += data.size(l.list[i], data.kind(l.list[i]));\n        }\n        if(GUIProp.mapsimple) {\n          l.initWeights();\n        } else if(GUIProp.usetextlength && data.fs == null) {\n          l.initWeights(textLen, nn, data);\n        } else l.initWeights(parsize, nn, data);\n        \n        final MapAlgo tmp = new SplitAlgo();\n        rects = tmp.calcMap(r, l, l.weight, 0, l.size - 1, level);\n      } else {\n        nn = l.list[ne] - l.list[ns] + \n            data.size(l.list[ne], data.kind(l.list[ne]));\n        \n        // init weights of nodes\n        if(GUIProp.mapsimple) {\n          l.initWeights();\n        } else if(GUIProp.usetextlength && data.fs == null) {\n          l.initWeights(textLen, nn, data);\n        } else l.initWeights(parsize, nn, data);\n        \n        rects = algo.calcMap(r, l, l.weight, ns, ne, level);\n      }\n      // call recursion for next deeper levels\n      for(final MapRect rect : rects) putRect(rect, rect.level);\n    }\n  }","commit_id":"4e1135c0aa486815160715fe8bde2a929b6e9a19","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Uses recursive SplitLayout algorithm to divide rectangles on one level.\n   * \n   * @param r parent rectangle\n   * @param ml children array\n   * @param w weights array\n   * @param ns start array position\n   * @param ne end array position\n   * @param l indicates level which is calculated\n   * @param sumweight weight of this recursion level\n   * @return ArrayList containing rectangles\n   */\n  private ArrayList<MapRect> calcMap(final MapRect r, final MapList ml, \n      final double[] w, final int ns, final int ne, final int l,\n      final double sumweight) {\n    if(ne - ns == 0) {\n      final ArrayList<MapRect> rects = new ArrayList<MapRect>();\n      rects.add(new MapRect(r, ml.list[ns], l));\n      return rects;\n    } else {\n      final ArrayList<MapRect> rects = new ArrayList<MapRect>();\n      double weight;\n      int ni = ns - 1;\n  \n      // increment pivot until left rectangle contains more or equal\n      // than half the weight or leave with just setting it to ne - 1\n      weight = 0;\n      for(; ni < ne;) {\n        weight += w[++ni];\n        if(weight >= sumweight / 2 || ni == ne - 1) break;\n      }\n      \n      int xx = r.x;\n      int yy = r.y;\n      int ww = !(r.w > r.h) ? r.w : (int) (r.w * 1 / sumweight * weight);\n      int hh = r.w > r.h ? r.h : (int) (r.h * 1 / sumweight * weight);\n      // paint both rectangles if enough space is left\n      if(ww > 0 && hh > 0 && weight > 0) rects.addAll(calcMap(\n          new MapRect(xx, yy, ww, hh, 0, r.level), \n          ml, w, ns, ni, l, weight));\n      if(r.w > r.h) {\n        xx += ww;\n        ww = r.w - ww;\n      } else {\n        yy += hh;\n        hh = r.h - hh;\n      }\n      if(ww > 0 && hh > 0 && sumweight - weight > 0) rects.addAll(calcMap(\n          new MapRect(xx, yy, ww, hh, 0, r.level), \n          ml, w, ni + 1, ne, l, sumweight - weight));\n      \n      return rects;\n    }\n  }","id":93504,"modified_method":"/**\n   * Uses recursive SplitLayout algorithm to divide rectangles on one level.\n   * \n   * @param r parent rectangle\n   * @param ml children array\n   * @param w weights array\n   * @param ns start array position\n   * @param ne end array position\n   * @param l indicates level which is calculated\n   * @param sumweight weight of this recursion level\n   * @return ArrayList containing rectangles\n   */\n  private ArrayList<MapRect> calcMap(final MapRect r, final MapList ml, \n      final double[] w, final int ns, final int ne, final int l,\n      final double sumweight) {\n    if(ne - ns == 0) {\n      final ArrayList<MapRect> rects = new ArrayList<MapRect>();\n      rects.add(new MapRect(r, ml.list[ns], l));\n      return rects;\n    } else {\n      final ArrayList<MapRect> rects = new ArrayList<MapRect>();\n      double weight;\n      int ni = ns - 1;\n  \n      // increment pivot until left rectangle contains more or equal\n      // than half the weight or leave with just setting it to ne - 1\n      weight = 0;\n      for(; ni < ne;) {\n        weight += w[++ni];\n        if(weight >= sumweight / 2 || ni == ne - 1) break;\n      }\n      \n      int xx = r.x;\n      int yy = r.y;\n      int ww = !(r.w > r.h) ? r.w : (int) (r.w * 1 / sumweight * weight);\n      int hh = r.w > r.h ? r.h : (int) (r.h * 1 / sumweight * weight);\n      // paint both rectangles if enough space is left\n      if(ww > 0 && hh > 0 && weight > 0) rects.addAll(calcMap(\n          new MapRect(xx, yy, ww, hh, 0, r.level), \n          ml, w, ns, ni, l, weight));\n      if(r.w > r.h) {\n        xx += ww;\n        ww = r.w - ww;\n      } else {\n        yy += hh;\n        hh = r.h - hh;\n      }\n//      System.out.println(ml.toString() + \";\" + ni + \";\" + ne);\n      if(ww > 0 && hh > 0 && sumweight - weight > 0 && ni + 1 <= ne)\n          rects.addAll(calcMap(new MapRect(xx, yy, ww, hh, 0, r.level), \n          ml, w, ni + 1, ne, l, sumweight - weight));\n      \n      return rects;\n    }\n  }","commit_id":"4e1135c0aa486815160715fe8bde2a929b6e9a19","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Recursively splits rectangles.\n   * @param r parent rectangle\n   * @param l children array\n   * @param ns start array position\n   * @param ne end array position\n   * @param level indicates level which is calculated\n   */\n  void makeMap(final MapRect r, final MapList l, final int ns, final int ne, \n      final int level) {\n    if(ne - ns <= 1) {\n      // one rectangle left, add it and go deeper\n      r.pre = l.list[ns];\n      putRect(r, level);  \n    } else {\n      final long parsize = data.fs != null ? addSizes(l, ns, ne) : 0;\n      int nn;\n      ArrayList<MapRect> rects;\n      if(level == 0) {\n        // [JH] may first level layout should not be defined to splitalgo\n        nn = l.list[ne - 1] - l.list[ns] + \n            data.size(l.list[ne - 1], data.kind(l.list[ne - 1]));\n        l.initWeights(parsize, nn, data);\n        \n        final MapAlgo tmp = new SplitAlgo();\n        rects = tmp.calcMap(r, l, l.weight, ns, ne, level);\n      } else {\n        nn = l.list[ne] - l.list[ns];\n        // init weights of nodes and sort\n        l.initWeights(parsize, nn, data);\n        rects = algo.calcMap(r, l, l.weight, ns, ne, level);\n      }\n      // call recursion for next deeper levels\n      for(final MapRect rect : rects) putRect(rect, rect.level);\n    }\n  }","id":93505,"modified_method":"/**\n   * Recursively splits rectangles.\n   * @param r parent rectangle\n   * @param l children array\n   * @param ns start array position\n   * @param ne end array position\n   * @param level indicates level which is calculated\n   */\n  void makeMap(final MapRect r, final MapList l, final int ns, final int ne, \n      final int level) {\n    if(ne - ns <= 1) {\n      // one rectangle left, add it and go deeper\n      r.pre = l.list[ns];\n      putRect(r, level);  \n    } else {\n      final long parsize = data.fs != null ? addSizes(l, ns, ne) : 0;\n      int nn;\n      ArrayList<MapRect> rects;\n      if(level == 0) {\n        // [JH] may first level layout should not be defined to splitalgo\n        nn = l.list[ne - 1] - l.list[ns] + \n            data.size(l.list[ne - 1], data.kind(l.list[ne - 1]));\n        l.initWeights(parsize, nn, data);\n        \n        final MapAlgo tmp = new SplitAlgo();\n        rects = tmp.calcMap(r, l, l.weight, ns, ne, level);\n      } else {\n        nn = l.list[ne] - l.list[ns];\n        // init weights of nodes\n        if(GUIProp.usetextlength) {\n          l.initWeights(textLen, nn);\n        } else l.initWeights(parsize, nn, data);\n        rects = algo.calcMap(r, l, l.weight, ns, ne, level);\n      }\n      // call recursion for next deeper levels\n      for(final MapRect rect : rects) putRect(rect, rect.level);\n    }\n  }","commit_id":"8e531a51cf2e34c813c7d01e9a295788b3811c1d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param d data reference to use in this maplayout\n   */\n  MapLayout(final Data d) {\n    data = d;\n    rectangles = new ArrayList<MapRect>();\n    \n    switch(GUIProp.mapoffsets) {\n      case 1 : layout = new MapRect(1, 1, 2, 2); break;\n      case 2 : layout = new MapRect(0, o, 0, o); break;\n      case 3 : layout = new MapRect(2, o - 1, 4, o + 1); break;\n      case 4 : layout = new MapRect(o >> 2, o, o >> 1, o + (o >> 2)); break;\n      case 5 : layout = new MapRect(o >> 1, o, o, o + (o >> 1)); break;\n      default: layout = new MapRect(0, 0, 0, 0); break;\n    }\n    \n    switch(GUIProp.mapalgo) {\n      // select method to construct this treemap\n      // may should be placed in makeMap to define different method for \n      // different levels\n      case 1 : algo = new StripAlgo(); break;\n      case 2 : algo = new SquarifiedAlgo(); break;\n      case 3 : algo = new SliceDiceAlgo(); break;\n      default: algo = new SplitAlgo(); break;\n    }\n    \n//    if (GUIProp.mapweight == 0 || data.fs == null) initLen();\n  }","id":93506,"modified_method":"/**\n   * Constructor.\n   * @param d data reference to use in this maplayout\n   */\n  MapLayout(final Data d) {\n    data = d;\n    rectangles = new ArrayList<MapRect>();\n    \n    switch(GUIProp.mapoffsets) {\n      case 1 : layout = new MapRect(1, 1, 2, 2); break;\n      case 2 : layout = new MapRect(0, o, 0, o); break;\n      case 3 : layout = new MapRect(2, o - 1, 4, o + 1); break;\n      case 4 : layout = new MapRect(o >> 2, o, o >> 1, o + (o >> 2)); break;\n      case 5 : layout = new MapRect(o >> 1, o, o, o + (o >> 1)); break;\n      default: layout = new MapRect(0, 0, 0, 0); break;\n    }\n    \n    switch(GUIProp.mapalgo) {\n      // select method to construct this treemap\n      // may should be placed in makeMap to define different method for \n      // different levels\n      case 1 : algo = new StripAlgo(); break;\n      case 2 : algo = new SquarifiedAlgo(); break;\n      case 3 : algo = new SliceDiceAlgo(); break;\n      default: algo = new SplitAlgo(); break;\n    }\n    \n    if (data.fs == null && GUIProp.usetextlength) initLen();\n  }","commit_id":"8e531a51cf2e34c813c7d01e9a295788b3811c1d","url":"https://github.com/BaseXdb/basex"},{"original_method":"public PsiElement bindToElement(PsiElement element) throws IncorrectOperationException{\n    return chooseReference().bindToElement(element);\n  }","id":93507,"modified_method":"public PsiElement bindToElement(PsiElement element) throws IncorrectOperationException{\n    final PsiReference reference = chooseReference();\n    if (reference != null) {\n      return reference.bindToElement(element);\n    }\n    return myElement;\n  }","commit_id":"5ccccae5c608b2e8592ff322a7ed0de280d23391","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getCanonicalText(){\n    return chooseReference().getCanonicalText();\n  }","id":93508,"modified_method":"public String getCanonicalText(){\n    final PsiReference reference = chooseReference();\n    return reference == null ? myReferences.get(0).getCanonicalText() : reference.getCanonicalText();\n  }","commit_id":"5ccccae5c608b2e8592ff322a7ed0de280d23391","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException{\n    return chooseReference().handleElementRename(newElementName);\n  }","id":93509,"modified_method":"public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException{\n    final PsiReference reference = chooseReference();\n    if (reference != null) {\n      return reference.handleElementRename(newElementName);\n    }\n    return myElement;\n  }","commit_id":"5ccccae5c608b2e8592ff322a7ed0de280d23391","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private PsiReference chooseReference(){\n    if(myChoosenOne != -1){\n      return myReferences.get(myChoosenOne);\n    }\n    boolean flag = false;\n    myChoosenOne = 0;\n    for(int i = 0; i < myReferences.size(); i++){\n      final PsiReference reference = myReferences.get(i);\n      if(reference.isSoft() && flag) continue;\n      if(!reference.isSoft() && !flag){\n        myChoosenOne = i;\n        flag = true;\n        continue;\n      }\n      if(reference.resolve() != null){\n        myChoosenOne = i;\n      }\n    }\n    return myReferences.get(myChoosenOne);\n  }","id":93510,"modified_method":"@Nullable\n  private PsiReference chooseReference(){\n    if(myChoosenOne != -1){\n      return myReferences.get(myChoosenOne);\n    }\n    boolean flag = false;\n    for(int i = 0; i < myReferences.size(); i++){\n      final PsiReference reference = myReferences.get(i);\n      if(reference.isSoft() && flag) continue;\n      if(!reference.isSoft() && !flag){\n        myChoosenOne = i;\n        flag = true;\n        continue;\n      }\n      if(reference.resolve() != null){\n        myChoosenOne = i;\n      }\n    }\n    return myChoosenOne >= 0 ? myReferences.get(myChoosenOne) : null;\n  }","commit_id":"5ccccae5c608b2e8592ff322a7ed0de280d23391","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JournalArticle updateArticle(\n\t\t\tlong userId, long groupId, String articleId, double version,\n\t\t\tString title, String description, String content, String type,\n\t\t\tString structureId, String templateId, int displayDateMonth,\n\t\t\tint displayDateDay, int displayDateYear, int displayDateHour,\n\t\t\tint displayDateMinute, int expirationDateMonth,\n\t\t\tint expirationDateDay, int expirationDateYear,\n\t\t\tint expirationDateHour, int expirationDateMinute,\n\t\t\tboolean neverExpire, int reviewDateMonth, int reviewDateDay,\n\t\t\tint reviewDateYear, int reviewDateHour, int reviewDateMinute,\n\t\t\tboolean neverReview, boolean indexable, boolean smallImage,\n\t\t\tString smallImageURL, File smallFile, Map<String, byte[]> images,\n\t\t\tString articleURL, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tarticleId = articleId.trim().toUpperCase();\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\tdisplayDateHour, displayDateMinute, user.getTimeZone(),\n\t\t\tnew ArticleDisplayDateException());\n\n\t\tDate expirationDate = null;\n\n\t\tif (!neverExpire) {\n\t\t\texpirationDate = PortalUtil.getDate(\n\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\texpirationDateHour, expirationDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleExpirationDateException());\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tboolean expired = false;\n\n\t\tif ((expirationDate != null) && expirationDate.before(now)) {\n\t\t\texpired = true;\n\t\t}\n\n\t\tDate reviewDate = null;\n\n\t\tif (!neverReview) {\n\t\t\treviewDate = PortalUtil.getDate(\n\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\treviewDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleReviewDateException());\n\t\t}\n\n\t\tbyte[] smallBytes = null;\n\n\t\ttry {\n\t\t\tsmallBytes = FileUtil.getBytes(smallFile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t}\n\n\t\tvalidate(\n\t\t\tuser.getCompanyId(), groupId, title, content, type, structureId,\n\t\t\ttemplateId, smallImage, smallImageURL, smallFile, smallBytes);\n\n\t\tJournalArticle oldArticle = null;\n\t\tdouble oldVersion = 0;\n\n\t\tboolean incrementVersion = false;\n\n\t\tboolean imported = GetterUtil.getBoolean(\n\t\t\tserviceContext.getAttribute(\"imported\"));\n\n\t\tif (imported) {\n\t\t\toldArticle = getArticle(groupId, articleId, version);\n\t\t\toldVersion = version;\n\n\t\t\tif (!expired) {\n\t\t\t\tincrementVersion = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn expireArticle(\n\t\t\t\t\tuserId, groupId, articleId, version, articleURL,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\toldArticle = getLatestArticle(\n\t\t\t\tgroupId, articleId, WorkflowConstants.STATUS_ANY);\n\n\t\t\toldVersion = oldArticle.getVersion();\n\n\t\t\tif ((version > 0) && (version != oldVersion)) {\n\t\t\t\tthrow new ArticleVersionException();\n\t\t\t}\n\n\t\t\tif (oldArticle.isApproved() || oldArticle.isExpired()) {\n\t\t\t\tincrementVersion = true;\n\t\t\t}\n\t\t}\n\n\t\tJournalArticle article = null;\n\n\t\tif (incrementVersion) {\n\t\t\tdouble newVersion = MathUtil.format(oldVersion + 0.1, 1, 1);\n\n\t\t\tlong id = counterLocalService.increment();\n\n\t\t\tarticle = journalArticlePersistence.create(id);\n\n\t\t\tarticle.setResourcePrimKey(oldArticle.getResourcePrimKey());\n\t\t\tarticle.setGroupId(oldArticle.getGroupId());\n\t\t\tarticle.setCompanyId(user.getCompanyId());\n\t\t\tarticle.setUserId(user.getUserId());\n\t\t\tarticle.setUserName(user.getFullName());\n\t\t\tarticle.setCreateDate(serviceContext.getModifiedDate(now));\n\t\t\tarticle.setArticleId(articleId);\n\t\t\tarticle.setVersion(newVersion);\n\t\t\tarticle.setSmallImageId(oldArticle.getSmallImageId());\n\t\t}\n\t\telse {\n\t\t\tarticle = oldArticle;\n\t\t}\n\n\t\tcontent = format(\n\t\t\tgroupId, articleId, article.getVersion(), incrementVersion,\n\t\t\tcontent, structureId, images);\n\n\t\tarticle.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tarticle.setTitle(title);\n\t\tarticle.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(article.getId(), groupId, articleId, title));\n\t\tarticle.setDescription(description);\n\t\tarticle.setContent(content);\n\t\tarticle.setType(type);\n\t\tarticle.setStructureId(structureId);\n\t\tarticle.setTemplateId(templateId);\n\t\tarticle.setDisplayDate(displayDate);\n\n\t\tif (oldArticle.isPending()) {\n\t\t\tarticle.setStatus(oldArticle.getStatus());\n\t\t}\n\t\telse if (!expired) {\n\t\t\tarticle.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\t\telse {\n\t\t\tarticle.setStatus(WorkflowConstants.STATUS_EXPIRED);\n\t\t}\n\n\t\tarticle.setExpirationDate(expirationDate);\n\t\tarticle.setReviewDate(reviewDate);\n\t\tarticle.setIndexable(indexable);\n\t\tarticle.setSmallImage(smallImage);\n\n\t\tif (article.getSmallImageId() == 0) {\n\t\t\tarticle.setSmallImageId(counterLocalService.increment());\n\t\t}\n\n\t\tarticle.setSmallImageURL(smallImageURL);\n\n\t\tjournalArticlePersistence.update(article, false);\n\n\t\t// Asset\n\n\t\tlong[] assetCategoryIds = serviceContext.getAssetCategoryIds();\n\t\tString[] assetTagNames = serviceContext.getAssetTagNames();\n\n\t\tupdateAsset(userId, article, assetCategoryIds, assetTagNames);\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = article.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Small image\n\n\t\tsaveImages(\n\t\t\tsmallImage, article.getSmallImageId(), smallFile, smallBytes);\n\n\t\t// Email\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\t// Workflow\n\n\t\tif (serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) {\n\n\t\t\ttry {\n\t\t\t\tsendEmail(article, articleURL, preferences, \"requested\");\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tthrow new SystemException(ioe);\n\t\t\t}\n\n\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey(),\n\t\t\t\tarticle, serviceContext);\n\t\t}\n\n\t\treturn article;\n\t}","id":93511,"modified_method":"public JournalArticle updateArticle(\n\t\t\tlong userId, long groupId, String articleId, double version,\n\t\t\tString title, String description, String content, String type,\n\t\t\tString structureId, String templateId, int displayDateMonth,\n\t\t\tint displayDateDay, int displayDateYear, int displayDateHour,\n\t\t\tint displayDateMinute, int expirationDateMonth,\n\t\t\tint expirationDateDay, int expirationDateYear,\n\t\t\tint expirationDateHour, int expirationDateMinute,\n\t\t\tboolean neverExpire, int reviewDateMonth, int reviewDateDay,\n\t\t\tint reviewDateYear, int reviewDateHour, int reviewDateMinute,\n\t\t\tboolean neverReview, boolean indexable, boolean smallImage,\n\t\t\tString smallImageURL, File smallFile, Map<String, byte[]> images,\n\t\t\tString articleURL, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tarticleId = articleId.trim().toUpperCase();\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\tdisplayDateHour, displayDateMinute, user.getTimeZone(),\n\t\t\tnew ArticleDisplayDateException());\n\n\t\tDate expirationDate = null;\n\n\t\tif (!neverExpire) {\n\t\t\texpirationDate = PortalUtil.getDate(\n\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\texpirationDateHour, expirationDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleExpirationDateException());\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tboolean expired = false;\n\n\t\tif ((expirationDate != null) && expirationDate.before(now)) {\n\t\t\texpired = true;\n\t\t}\n\n\t\tDate reviewDate = null;\n\n\t\tif (!neverReview) {\n\t\t\treviewDate = PortalUtil.getDate(\n\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\treviewDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleReviewDateException());\n\t\t}\n\n\t\tbyte[] smallBytes = null;\n\n\t\ttry {\n\t\t\tsmallBytes = FileUtil.getBytes(smallFile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t}\n\n\t\tvalidate(\n\t\t\tuser.getCompanyId(), groupId, title, content, type, structureId,\n\t\t\ttemplateId, smallImage, smallImageURL, smallFile, smallBytes);\n\n\t\tJournalArticle oldArticle = null;\n\t\tdouble oldVersion = 0;\n\n\t\tboolean incrementVersion = false;\n\n\t\tboolean imported = GetterUtil.getBoolean(\n\t\t\tserviceContext.getAttribute(\"imported\"));\n\n\t\tif (imported) {\n\t\t\toldArticle = getArticle(groupId, articleId, version);\n\t\t\toldVersion = version;\n\n\t\t\tif (!expired) {\n\t\t\t\tincrementVersion = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn expireArticle(\n\t\t\t\t\tuserId, groupId, articleId, version, articleURL,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\toldArticle = getLatestArticle(\n\t\t\t\tgroupId, articleId, WorkflowConstants.STATUS_ANY);\n\n\t\t\toldVersion = oldArticle.getVersion();\n\n\t\t\tif ((version > 0) && (version != oldVersion)) {\n\t\t\t\tthrow new ArticleVersionException();\n\t\t\t}\n\n\t\t\tif (oldArticle.isApproved() || oldArticle.isExpired()) {\n\t\t\t\tincrementVersion = true;\n\t\t\t}\n\t\t}\n\n\t\tJournalArticle article = null;\n\n\t\tif (incrementVersion) {\n\t\t\tdouble newVersion = MathUtil.format(oldVersion + 0.1, 1, 1);\n\n\t\t\tlong id = counterLocalService.increment();\n\n\t\t\tarticle = journalArticlePersistence.create(id);\n\n\t\t\tarticle.setResourcePrimKey(oldArticle.getResourcePrimKey());\n\t\t\tarticle.setGroupId(oldArticle.getGroupId());\n\t\t\tarticle.setCompanyId(user.getCompanyId());\n\t\t\tarticle.setUserId(user.getUserId());\n\t\t\tarticle.setUserName(user.getFullName());\n\t\t\tarticle.setCreateDate(serviceContext.getModifiedDate(now));\n\t\t\tarticle.setArticleId(articleId);\n\t\t\tarticle.setVersion(newVersion);\n\t\t\tarticle.setSmallImageId(oldArticle.getSmallImageId());\n\t\t}\n\t\telse {\n\t\t\tarticle = oldArticle;\n\t\t}\n\n\t\tcontent = format(\n\t\t\tgroupId, articleId, article.getVersion(), incrementVersion,\n\t\t\tcontent, structureId, images);\n\n\t\tarticle.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tarticle.setTitle(title);\n\t\tarticle.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(article.getId(), groupId, articleId, title));\n\t\tarticle.setDescription(description);\n\t\tarticle.setContent(content);\n\t\tarticle.setType(type);\n\t\tarticle.setStructureId(structureId);\n\t\tarticle.setTemplateId(templateId);\n\t\tarticle.setDisplayDate(displayDate);\n\t\tarticle.setExpirationDate(expirationDate);\n\t\tarticle.setReviewDate(reviewDate);\n\t\tarticle.setIndexable(indexable);\n\t\tarticle.setSmallImage(smallImage);\n\n\t\tif (article.getSmallImageId() == 0) {\n\t\t\tarticle.setSmallImageId(counterLocalService.increment());\n\t\t}\n\n\t\tarticle.setSmallImageURL(smallImageURL);\n\n\t\tif (oldArticle.isPending()) {\n\t\t\tarticle.setStatus(oldArticle.getStatus());\n\t\t}\n\t\telse if (!expired) {\n\t\t\tarticle.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\t\telse {\n\t\t\tarticle.setStatus(WorkflowConstants.STATUS_EXPIRED);\n\t\t}\n\n\t\tjournalArticlePersistence.update(article, false);\n\n\t\t// Asset\n\n\t\tlong[] assetCategoryIds = serviceContext.getAssetCategoryIds();\n\t\tString[] assetTagNames = serviceContext.getAssetTagNames();\n\n\t\tupdateAsset(userId, article, assetCategoryIds, assetTagNames);\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = article.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Small image\n\n\t\tsaveImages(\n\t\t\tsmallImage, article.getSmallImageId(), smallFile, smallBytes);\n\n\t\t// Email\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\t// Workflow\n\n\t\tif (serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) {\n\n\t\t\ttry {\n\t\t\t\tsendEmail(article, articleURL, preferences, \"requested\");\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tthrow new SystemException(ioe);\n\t\t\t}\n\n\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey(),\n\t\t\t\tarticle, serviceContext);\n\t\t}\n\n\t\treturn article;\n\t}","commit_id":"9326c1de52324c1bee3641dc97adcac35a684c3f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public JournalArticle copyArticle(\n\t\t\tlong userId, long groupId, String oldArticleId, String newArticleId,\n\t\t\tboolean autoArticleId, double version)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\toldArticleId = oldArticleId.trim().toUpperCase();\n\t\tnewArticleId = newArticleId.trim().toUpperCase();\n\t\tDate now = new Date();\n\n\t\tJournalArticle oldArticle = journalArticlePersistence.findByG_A_V(\n\t\t\tgroupId, oldArticleId, version);\n\n\t\tif (autoArticleId) {\n\t\t\tnewArticleId = String.valueOf(counterLocalService.increment());\n\t\t}\n\t\telse {\n\t\t\tvalidate(newArticleId);\n\n\t\t\tJournalArticle newArticle = journalArticlePersistence.fetchByG_A_V(\n\t\t\t\tgroupId, newArticleId, version);\n\n\t\t\tif (newArticle != null) {\n\t\t\t\tthrow new DuplicateArticleIdException();\n\t\t\t}\n\t\t}\n\n\t\tlong id = counterLocalService.increment();\n\n\t\tlong resourcePrimKey =\n\t\t\tjournalArticleResourceLocalService.getArticleResourcePrimKey(\n\t\t\t\tgroupId, newArticleId);\n\n\t\tJournalArticle newArticle = journalArticlePersistence.create(id);\n\n\t\tnewArticle.setResourcePrimKey(resourcePrimKey);\n\t\tnewArticle.setGroupId(groupId);\n\t\tnewArticle.setCompanyId(user.getCompanyId());\n\t\tnewArticle.setUserId(user.getUserId());\n\t\tnewArticle.setUserName(user.getFullName());\n\t\tnewArticle.setCreateDate(now);\n\t\tnewArticle.setModifiedDate(now);\n\t\tnewArticle.setArticleId(newArticleId);\n\t\tnewArticle.setVersion(JournalArticleConstants.DEFAULT_VERSION);\n\t\tnewArticle.setTitle(oldArticle.getTitle());\n\t\tnewArticle.setDescription(oldArticle.getDescription());\n\n\t\ttry {\n\t\t\tcopyArticleImages(oldArticle, newArticle);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tnewArticle.setContent(oldArticle.getContent());\n\t\t}\n\n\t\tnewArticle.setType(oldArticle.getType());\n\t\tnewArticle.setStructureId(oldArticle.getStructureId());\n\t\tnewArticle.setTemplateId(oldArticle.getTemplateId());\n\t\tnewArticle.setDisplayDate(oldArticle.getDisplayDate());\n\t\tnewArticle.setStatus(oldArticle.getStatus());\n\t\tnewArticle.setExpirationDate(oldArticle.getExpirationDate());\n\t\tnewArticle.setReviewDate(oldArticle.getReviewDate());\n\t\tnewArticle.setIndexable(oldArticle.isIndexable());\n\t\tnewArticle.setSmallImage(oldArticle.isSmallImage());\n\t\tnewArticle.setSmallImageId(counterLocalService.increment());\n\t\tnewArticle.setSmallImageURL(oldArticle.getSmallImageURL());\n\n\t\tjournalArticlePersistence.update(newArticle, false);\n\n\t\t// Resources\n\n\t\taddArticleResources(newArticle, true, true);\n\n\t\t// Small image\n\n\t\tif (oldArticle.getSmallImage()) {\n\t\t\tImage image = imageLocalService.getImage(\n\t\t\t\toldArticle.getSmallImageId());\n\n\t\t\tbyte[] smallBytes = image.getTextObj();\n\n\t\t\timageLocalService.updateImage(\n\t\t\t\tnewArticle.getSmallImageId(), smallBytes);\n\t\t}\n\n\t\t// Asset\n\n\t\tString[] assetTagNames = assetTagLocalService.getTagNames(\n\t\t\tJournalArticle.class.getName(), oldArticle.getResourcePrimKey());\n\n\t\tupdateAsset(userId, newArticle, null, assetTagNames);\n\n\t\treturn newArticle;\n\t}","id":93512,"modified_method":"public JournalArticle copyArticle(\n\t\t\tlong userId, long groupId, String oldArticleId, String newArticleId,\n\t\t\tboolean autoArticleId, double version)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\toldArticleId = oldArticleId.trim().toUpperCase();\n\t\tnewArticleId = newArticleId.trim().toUpperCase();\n\t\tDate now = new Date();\n\n\t\tJournalArticle oldArticle = journalArticlePersistence.findByG_A_V(\n\t\t\tgroupId, oldArticleId, version);\n\n\t\tif (autoArticleId) {\n\t\t\tnewArticleId = String.valueOf(counterLocalService.increment());\n\t\t}\n\t\telse {\n\t\t\tvalidate(newArticleId);\n\n\t\t\tJournalArticle newArticle = journalArticlePersistence.fetchByG_A_V(\n\t\t\t\tgroupId, newArticleId, version);\n\n\t\t\tif (newArticle != null) {\n\t\t\t\tthrow new DuplicateArticleIdException();\n\t\t\t}\n\t\t}\n\n\t\tlong id = counterLocalService.increment();\n\n\t\tlong resourcePrimKey =\n\t\t\tjournalArticleResourceLocalService.getArticleResourcePrimKey(\n\t\t\t\tgroupId, newArticleId);\n\n\t\tJournalArticle newArticle = journalArticlePersistence.create(id);\n\n\t\tnewArticle.setResourcePrimKey(resourcePrimKey);\n\t\tnewArticle.setGroupId(groupId);\n\t\tnewArticle.setCompanyId(user.getCompanyId());\n\t\tnewArticle.setUserId(user.getUserId());\n\t\tnewArticle.setUserName(user.getFullName());\n\t\tnewArticle.setCreateDate(now);\n\t\tnewArticle.setModifiedDate(now);\n\t\tnewArticle.setArticleId(newArticleId);\n\t\tnewArticle.setVersion(JournalArticleConstants.DEFAULT_VERSION);\n\t\tnewArticle.setTitle(oldArticle.getTitle());\n\t\tnewArticle.setDescription(oldArticle.getDescription());\n\n\t\ttry {\n\t\t\tcopyArticleImages(oldArticle, newArticle);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tnewArticle.setContent(oldArticle.getContent());\n\t\t}\n\n\t\tnewArticle.setType(oldArticle.getType());\n\t\tnewArticle.setStructureId(oldArticle.getStructureId());\n\t\tnewArticle.setTemplateId(oldArticle.getTemplateId());\n\t\tnewArticle.setDisplayDate(oldArticle.getDisplayDate());\n\t\tnewArticle.setExpirationDate(oldArticle.getExpirationDate());\n\t\tnewArticle.setReviewDate(oldArticle.getReviewDate());\n\t\tnewArticle.setIndexable(oldArticle.isIndexable());\n\t\tnewArticle.setSmallImage(oldArticle.isSmallImage());\n\t\tnewArticle.setSmallImageId(counterLocalService.increment());\n\t\tnewArticle.setSmallImageURL(oldArticle.getSmallImageURL());\n\t\tnewArticle.setStatus(oldArticle.getStatus());\n\n\t\tjournalArticlePersistence.update(newArticle, false);\n\n\t\t// Resources\n\n\t\taddArticleResources(newArticle, true, true);\n\n\t\t// Small image\n\n\t\tif (oldArticle.getSmallImage()) {\n\t\t\tImage image = imageLocalService.getImage(\n\t\t\t\toldArticle.getSmallImageId());\n\n\t\t\tbyte[] smallBytes = image.getTextObj();\n\n\t\t\timageLocalService.updateImage(\n\t\t\t\tnewArticle.getSmallImageId(), smallBytes);\n\t\t}\n\n\t\t// Asset\n\n\t\tString[] assetTagNames = assetTagLocalService.getTagNames(\n\t\t\tJournalArticle.class.getName(), oldArticle.getResourcePrimKey());\n\n\t\tupdateAsset(userId, newArticle, null, assetTagNames);\n\n\t\treturn newArticle;\n\t}","commit_id":"9326c1de52324c1bee3641dc97adcac35a684c3f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public JournalArticle updateStatus(\n\t\t\tlong userId, JournalArticle article, int status, String articleURL,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tint oldStatus = article.getStatus();\n\n\t\t// Article\n\n\t\tarticle.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tarticle.setStatus(status);\n\t\tarticle.setStatusByUserId(user.getUserId());\n\t\tarticle.setStatusByUserName(user.getFullName());\n\t\tarticle.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tif ((status == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t(article.getExpirationDate() != null) &&\n\t\t\t(article.getExpirationDate().before(now))) {\n\n\t\t\tarticle.setExpirationDate(null);\n\t\t}\n\n\t\tif (status == WorkflowConstants.STATUS_EXPIRED) {\n\t\t\tarticle.setExpirationDate(now);\n\t\t}\n\n\t\tjournalArticlePersistence.update(article, false);\n\n\t\tif (isLatestVersion(\n\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\tarticle.getVersion())) {\n\n\t\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\t\tupdateUrlTitles(\n\t\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\t\tarticle.getUrlTitle());\n\n\t\t\t\t// Asset\n\n\t\t\t\tif ((oldStatus != WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t\t(article.getVersion() !=\n\t\t\t\t\t\tJournalArticleConstants.DEFAULT_VERSION)) {\n\n\t\t\t\t\tAssetEntry draftAssetEntry = null;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdraftAssetEntry = assetEntryLocalService.getEntry(\n\t\t\t\t\t\t\tJournalArticle.class.getName(),\n\t\t\t\t\t\t\tarticle.getPrimaryKey());\n\n\t\t\t\t\t\tDate[] dateInterval = getDateInterval(\n\t\t\t\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\t\t\t\tarticle.getDisplayDate(),\n\t\t\t\t\t\t\tarticle.getExpirationDate());\n\n\t\t\t\t\t\tDate displayDate = dateInterval[0];\n\t\t\t\t\t\tDate expirationDate = dateInterval[1];\n\n\t\t\t\t\t\tlong[] assetCategoryIds =\n\t\t\t\t\t\t\tdraftAssetEntry.getCategoryIds();\n\t\t\t\t\t\tString[] assetTagNames = draftAssetEntry.getTagNames();\n\n\t\t\t\t\t\tassetEntryLocalService.updateEntry(\n\t\t\t\t\t\t\tuserId, article.getGroupId(),\n\t\t\t\t\t\t\tJournalArticle.class.getName(),\n\t\t\t\t\t\t\tarticle.getResourcePrimKey(), article.getUuid(),\n\t\t\t\t\t\t\tassetCategoryIds, assetTagNames, true, null, null,\n\t\t\t\t\t\t\tdisplayDate, expirationDate, ContentTypes.TEXT_HTML,\n\t\t\t\t\t\t\tarticle.getTitle(), article.getDescription(), null,\n\t\t\t\t\t\t\tnull, 0, 0, null, false);\n\n\t\t\t\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\t\t\t\tJournalArticle.class.getName(),\n\t\t\t\t\t\t\tarticle.getPrimaryKey());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\tJournalArticle.class.getName(),\n\t\t\t\t\tarticle.getResourcePrimKey(), true);\n\n\t\t\t\t// Expando\n\n\t\t\t\tExpandoBridge expandoBridge = article.getExpandoBridge();\n\n\t\t\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t\t\t// Indexer\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tJournalArticle.class);\n\n\t\t\t\tindexer.reindex(article);\n\t\t\t}\n\t\t\telse if (oldStatus == WorkflowConstants.STATUS_APPROVED) {\n\t\t\t\tupdatePreviousApprovedArticle(article);\n\t\t\t}\n\t\t}\n\n\t\t// Social\n\n\t\tif ((oldStatus != WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t(status == WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\tuserId, JournalArticle.class.getName(),\n\t\t\t\tarticle.getResourcePrimKey(), ActionKeys.ADD_ARTICLE,\n\t\t\t\tStringPool.BLANK);\n\t\t}\n\n\t\t// Email\n\n\t\tif ((oldStatus == WorkflowConstants.STATUS_PENDING) &&\n\t\t\t((status == WorkflowConstants.STATUS_APPROVED) ||\n\t\t\t (status == WorkflowConstants.STATUS_DENIED))) {\n\n\t\t\tString msg = \"granted\";\n\n\t\t\tif (status == WorkflowConstants.STATUS_DENIED) {\n\t\t\t\tmsg = \"denied\";\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tPortletPreferences preferences =\n\t\t\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\t\t\tsendEmail(article, articleURL, preferences, msg);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Unable to send email to notify the change of status \" +\n\t\t\t\t\t\t\" to \" + msg + \" for article \" + article.getId() +\n\t\t\t\t\t\t\t\": \" + e.getMessage());\n\t\t\t}\n\t\t}\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(article, serviceContext);\n\n\t\treturn article;\n\t}","id":93513,"modified_method":"public JournalArticle updateStatus(\n\t\t\tlong userId, JournalArticle article, int status, String articleURL,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tint oldStatus = article.getStatus();\n\n\t\t// Article\n\n\t\tarticle.setModifiedDate(serviceContext.getModifiedDate(now));\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tDate expirationDate = article.getExpirationDate();\n\n\t\t\tif ((expirationDate != null) && expirationDate.before(now)) {\n\t\t\t\tarticle.setExpirationDate(null);\n\t\t\t}\n\t\t}\n\n\t\tif (status == WorkflowConstants.STATUS_EXPIRED) {\n\t\t\tarticle.setExpirationDate(now);\n\t\t}\n\n\t\tarticle.setStatus(status);\n\t\tarticle.setStatusByUserId(user.getUserId());\n\t\tarticle.setStatusByUserName(user.getFullName());\n\t\tarticle.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tjournalArticlePersistence.update(article, false);\n\n\t\tif (isLatestVersion(\n\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\tarticle.getVersion())) {\n\n\t\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\t\tupdateUrlTitles(\n\t\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\t\tarticle.getUrlTitle());\n\n\t\t\t\t// Asset\n\n\t\t\t\tif ((oldStatus != WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t\t(article.getVersion() !=\n\t\t\t\t\t\tJournalArticleConstants.DEFAULT_VERSION)) {\n\n\t\t\t\t\tAssetEntry draftAssetEntry = null;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdraftAssetEntry = assetEntryLocalService.getEntry(\n\t\t\t\t\t\t\tJournalArticle.class.getName(),\n\t\t\t\t\t\t\tarticle.getPrimaryKey());\n\n\t\t\t\t\t\tDate[] dateInterval = getDateInterval(\n\t\t\t\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\t\t\t\tarticle.getDisplayDate(),\n\t\t\t\t\t\t\tarticle.getExpirationDate());\n\n\t\t\t\t\t\tDate displayDate = dateInterval[0];\n\t\t\t\t\t\tDate expirationDate = dateInterval[1];\n\n\t\t\t\t\t\tlong[] assetCategoryIds =\n\t\t\t\t\t\t\tdraftAssetEntry.getCategoryIds();\n\t\t\t\t\t\tString[] assetTagNames = draftAssetEntry.getTagNames();\n\n\t\t\t\t\t\tassetEntryLocalService.updateEntry(\n\t\t\t\t\t\t\tuserId, article.getGroupId(),\n\t\t\t\t\t\t\tJournalArticle.class.getName(),\n\t\t\t\t\t\t\tarticle.getResourcePrimKey(), article.getUuid(),\n\t\t\t\t\t\t\tassetCategoryIds, assetTagNames, true, null, null,\n\t\t\t\t\t\t\tdisplayDate, expirationDate, ContentTypes.TEXT_HTML,\n\t\t\t\t\t\t\tarticle.getTitle(), article.getDescription(), null,\n\t\t\t\t\t\t\tnull, 0, 0, null, false);\n\n\t\t\t\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\t\t\t\tJournalArticle.class.getName(),\n\t\t\t\t\t\t\tarticle.getPrimaryKey());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\tJournalArticle.class.getName(),\n\t\t\t\t\tarticle.getResourcePrimKey(), true);\n\n\t\t\t\t// Expando\n\n\t\t\t\tExpandoBridge expandoBridge = article.getExpandoBridge();\n\n\t\t\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t\t\t// Indexer\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tJournalArticle.class);\n\n\t\t\t\tindexer.reindex(article);\n\t\t\t}\n\t\t\telse if (oldStatus == WorkflowConstants.STATUS_APPROVED) {\n\t\t\t\tupdatePreviousApprovedArticle(article);\n\t\t\t}\n\t\t}\n\n\t\t// Social\n\n\t\tif ((oldStatus != WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t(status == WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\tuserId, JournalArticle.class.getName(),\n\t\t\t\tarticle.getResourcePrimKey(), ActionKeys.ADD_ARTICLE,\n\t\t\t\tStringPool.BLANK);\n\t\t}\n\n\t\t// Email\n\n\t\tif ((oldStatus == WorkflowConstants.STATUS_PENDING) &&\n\t\t\t((status == WorkflowConstants.STATUS_APPROVED) ||\n\t\t\t (status == WorkflowConstants.STATUS_DENIED))) {\n\n\t\t\tString msg = \"granted\";\n\n\t\t\tif (status == WorkflowConstants.STATUS_DENIED) {\n\t\t\t\tmsg = \"denied\";\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tPortletPreferences preferences =\n\t\t\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\t\t\tsendEmail(article, articleURL, preferences, msg);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Unable to send email to notify the change of status \" +\n\t\t\t\t\t\t\" to \" + msg + \" for article \" + article.getId() +\n\t\t\t\t\t\t\t\": \" + e.getMessage());\n\t\t\t}\n\t\t}\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(article, serviceContext);\n\n\t\treturn article;\n\t}","commit_id":"9326c1de52324c1bee3641dc97adcac35a684c3f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public JournalArticle addArticle(\n\t\t\tlong userId, long groupId, String articleId, boolean autoArticleId,\n\t\t\tdouble version, String title, String description, String content,\n\t\t\tString type, String structureId, String templateId,\n\t\t\tint displayDateMonth, int displayDateDay, int displayDateYear,\n\t\t\tint displayDateHour, int displayDateMinute, int expirationDateMonth,\n\t\t\tint expirationDateDay, int expirationDateYear,\n\t\t\tint expirationDateHour, int expirationDateMinute,\n\t\t\tboolean neverExpire, int reviewDateMonth, int reviewDateDay,\n\t\t\tint reviewDateYear, int reviewDateHour, int reviewDateMinute,\n\t\t\tboolean neverReview, boolean indexable, boolean smallImage,\n\t\t\tString smallImageURL, File smallFile, Map<String, byte[]> images,\n\t\t\tString articleURL, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tarticleId = articleId.trim().toUpperCase();\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\tdisplayDateHour, displayDateMinute, user.getTimeZone(),\n\t\t\tnew ArticleDisplayDateException());\n\n\t\tDate expirationDate = null;\n\n\t\tif (!neverExpire) {\n\t\t\texpirationDate = PortalUtil.getDate(\n\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\texpirationDateHour, expirationDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleExpirationDateException());\n\t\t}\n\n\t\tDate reviewDate = null;\n\n\t\tif (!neverReview) {\n\t\t\treviewDate = PortalUtil.getDate(\n\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\treviewDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleReviewDateException());\n\t\t}\n\n\t\tbyte[] smallBytes = null;\n\n\t\ttry {\n\t\t\tsmallBytes = FileUtil.getBytes(smallFile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(\n\t\t\tuser.getCompanyId(), groupId, articleId, autoArticleId, version,\n\t\t\ttitle, content, type, structureId, templateId, smallImage,\n\t\t\tsmallImageURL, smallFile, smallBytes);\n\n\t\tif (autoArticleId) {\n\t\t\tarticleId = String.valueOf(counterLocalService.increment());\n\t\t}\n\n\t\tlong id = counterLocalService.increment();\n\n\t\tlong resourcePrimKey =\n\t\t\tjournalArticleResourceLocalService.getArticleResourcePrimKey(\n\t\t\t\tserviceContext.getUuid(), groupId, articleId);\n\n\t\tJournalArticle article = journalArticlePersistence.create(id);\n\n\t\tcontent = format(\n\t\t\tgroupId, articleId, version, false, content, structureId, images);\n\n\t\tarticle.setResourcePrimKey(resourcePrimKey);\n\t\tarticle.setGroupId(groupId);\n\t\tarticle.setCompanyId(user.getCompanyId());\n\t\tarticle.setUserId(user.getUserId());\n\t\tarticle.setUserName(user.getFullName());\n\t\tarticle.setCreateDate(serviceContext.getCreateDate(now));\n\t\tarticle.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tarticle.setArticleId(articleId);\n\t\tarticle.setVersion(version);\n\t\tarticle.setTitle(title);\n\t\tarticle.setUrlTitle(getUniqueUrlTitle(id, groupId, articleId, title));\n\t\tarticle.setDescription(description);\n\t\tarticle.setContent(content);\n\t\tarticle.setType(type);\n\t\tarticle.setStructureId(structureId);\n\t\tarticle.setTemplateId(templateId);\n\t\tarticle.setDisplayDate(displayDate);\n\n\t\tif ((expirationDate == null) || expirationDate.after(now)) {\n\t\t\tarticle.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\t\telse {\n\t\t\tarticle.setStatus(WorkflowConstants.STATUS_EXPIRED);\n\t\t}\n\n\t\tarticle.setExpirationDate(expirationDate);\n\t\tarticle.setReviewDate(reviewDate);\n\t\tarticle.setIndexable(indexable);\n\t\tarticle.setSmallImage(smallImage);\n\t\tarticle.setSmallImageId(counterLocalService.increment());\n\t\tarticle.setSmallImageURL(smallImageURL);\n\n\t\tjournalArticlePersistence.update(article, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddArticleResources(\n\t\t\t\tarticle, serviceContext.getAddCommunityPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddArticleResources(\n\t\t\t\tarticle, serviceContext.getCommunityPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = article.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Small image\n\n\t\tsaveImages(\n\t\t\tsmallImage, article.getSmallImageId(), smallFile, smallBytes);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, article, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Message boards\n\n\t\tif (PropsValues.JOURNAL_ARTICLE_COMMENTS_ENABLED) {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, article.getUserName(), groupId,\n\t\t\t\tJournalArticle.class.getName(), resourcePrimKey,\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH);\n\t\t}\n\n\t\t// Email\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\ttry {\n\t\t\tsendEmail(article, articleURL, preferences, \"requested\");\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey(),\n\t\t\tarticle, serviceContext);\n\n\t\treturn article;\n\t}","id":93514,"modified_method":"public JournalArticle addArticle(\n\t\t\tlong userId, long groupId, String articleId, boolean autoArticleId,\n\t\t\tdouble version, String title, String description, String content,\n\t\t\tString type, String structureId, String templateId,\n\t\t\tint displayDateMonth, int displayDateDay, int displayDateYear,\n\t\t\tint displayDateHour, int displayDateMinute, int expirationDateMonth,\n\t\t\tint expirationDateDay, int expirationDateYear,\n\t\t\tint expirationDateHour, int expirationDateMinute,\n\t\t\tboolean neverExpire, int reviewDateMonth, int reviewDateDay,\n\t\t\tint reviewDateYear, int reviewDateHour, int reviewDateMinute,\n\t\t\tboolean neverReview, boolean indexable, boolean smallImage,\n\t\t\tString smallImageURL, File smallFile, Map<String, byte[]> images,\n\t\t\tString articleURL, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tarticleId = articleId.trim().toUpperCase();\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\tdisplayDateHour, displayDateMinute, user.getTimeZone(),\n\t\t\tnew ArticleDisplayDateException());\n\n\t\tDate expirationDate = null;\n\n\t\tif (!neverExpire) {\n\t\t\texpirationDate = PortalUtil.getDate(\n\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\texpirationDateHour, expirationDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleExpirationDateException());\n\t\t}\n\n\t\tDate reviewDate = null;\n\n\t\tif (!neverReview) {\n\t\t\treviewDate = PortalUtil.getDate(\n\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\treviewDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleReviewDateException());\n\t\t}\n\n\t\tbyte[] smallBytes = null;\n\n\t\ttry {\n\t\t\tsmallBytes = FileUtil.getBytes(smallFile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(\n\t\t\tuser.getCompanyId(), groupId, articleId, autoArticleId, version,\n\t\t\ttitle, content, type, structureId, templateId, smallImage,\n\t\t\tsmallImageURL, smallFile, smallBytes);\n\n\t\tif (autoArticleId) {\n\t\t\tarticleId = String.valueOf(counterLocalService.increment());\n\t\t}\n\n\t\tlong id = counterLocalService.increment();\n\n\t\tlong resourcePrimKey =\n\t\t\tjournalArticleResourceLocalService.getArticleResourcePrimKey(\n\t\t\t\tserviceContext.getUuid(), groupId, articleId);\n\n\t\tJournalArticle article = journalArticlePersistence.create(id);\n\n\t\tcontent = format(\n\t\t\tgroupId, articleId, version, false, content, structureId, images);\n\n\t\tarticle.setResourcePrimKey(resourcePrimKey);\n\t\tarticle.setGroupId(groupId);\n\t\tarticle.setCompanyId(user.getCompanyId());\n\t\tarticle.setUserId(user.getUserId());\n\t\tarticle.setUserName(user.getFullName());\n\t\tarticle.setCreateDate(serviceContext.getCreateDate(now));\n\t\tarticle.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tarticle.setArticleId(articleId);\n\t\tarticle.setVersion(version);\n\t\tarticle.setTitle(title);\n\t\tarticle.setUrlTitle(getUniqueUrlTitle(id, groupId, articleId, title));\n\t\tarticle.setDescription(description);\n\t\tarticle.setContent(content);\n\t\tarticle.setType(type);\n\t\tarticle.setStructureId(structureId);\n\t\tarticle.setTemplateId(templateId);\n\t\tarticle.setDisplayDate(displayDate);\n\t\tarticle.setExpirationDate(expirationDate);\n\t\tarticle.setReviewDate(reviewDate);\n\t\tarticle.setIndexable(indexable);\n\t\tarticle.setSmallImage(smallImage);\n\t\tarticle.setSmallImageId(counterLocalService.increment());\n\t\tarticle.setSmallImageURL(smallImageURL);\n\n\t\tif ((expirationDate == null) || expirationDate.after(now)) {\n\t\t\tarticle.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\t\telse {\n\t\t\tarticle.setStatus(WorkflowConstants.STATUS_EXPIRED);\n\t\t}\n\n\t\tjournalArticlePersistence.update(article, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddArticleResources(\n\t\t\t\tarticle, serviceContext.getAddCommunityPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddArticleResources(\n\t\t\t\tarticle, serviceContext.getCommunityPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = article.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Small image\n\n\t\tsaveImages(\n\t\t\tsmallImage, article.getSmallImageId(), smallFile, smallBytes);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, article, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Message boards\n\n\t\tif (PropsValues.JOURNAL_ARTICLE_COMMENTS_ENABLED) {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, article.getUserName(), groupId,\n\t\t\t\tJournalArticle.class.getName(), resourcePrimKey,\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH);\n\t\t}\n\n\t\t// Email\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\ttry {\n\t\t\tsendEmail(article, articleURL, preferences, \"requested\");\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey(),\n\t\t\tarticle, serviceContext);\n\n\t\treturn article;\n\t}","commit_id":"9326c1de52324c1bee3641dc97adcac35a684c3f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public long getInterval() {\n\t\treturn _interval;\n\t}","id":93515,"modified_method":"public long getInterval() {\n\t\treturn INTERVAL;\n\t}","commit_id":"cf1f8e1fb85a5ea8e80dfed7a223800d6305506b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List findByE_E(Boolean expired, Date expirationDateLT, \n\t\t\tDate expirationDateGT)\n\t\tthrows SystemException {\n\n\t\tTimestamp expirationDateLT_TS = CalendarUtil.getTimestamp(expirationDateLT);\n\t\tTimestamp expirationDateGT_TS = CalendarUtil.getTimestamp(expirationDateGT);\n\n\t\tSession session = null;\n\t\ttry {\n\t\t\tsession = HibernateUtil.openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_E_E);\n\n\t\t\tif (expired == null) {\n\t\t\t\tsql = StringUtil.replace(sql, \"(expired = ?) AND\", \"\");\n\t\t\t}\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.setCacheable(false);\n\n\t\t\tq.addEntity(\"JournalArticle\", JournalArticleImpl.class);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tif (expired != null) {\n\t\t\t\tqPos.add(expired);\n\t\t\t}\n\n\t\t\tqPos.add(expirationDateGT_TS);\n\t\t\tqPos.add(expirationDateLT_TS);\n\n\t\t\treturn q.list();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tHibernateUtil.closeSession(session);\n\t\t}\n\t}","id":93516,"modified_method":"public static List findByExpirationDate(\n\t\t\tBoolean expired, Date expirationDateLT, Date expirationDateGT)\n\t\tthrows SystemException {\n\n\t\tTimestamp expirationDateLT_TS = CalendarUtil.getTimestamp(\n\t\t\texpirationDateLT);\n\t\tTimestamp expirationDateGT_TS = CalendarUtil.getTimestamp(\n\t\t\texpirationDateGT);\n\n\t\tSession session = null;\n\t\ttry {\n\t\t\tsession = HibernateUtil.openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_EXPIRATION_DATE);\n\n\t\t\tif (expired == null) {\n\t\t\t\tsql = StringUtil.replace(sql, \"(expired = ?) AND\", \"\");\n\t\t\t}\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.setCacheable(false);\n\n\t\t\tq.addEntity(\"JournalArticle\", JournalArticleImpl.class);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tif (expired != null) {\n\t\t\t\tqPos.add(expired);\n\t\t\t}\n\n\t\t\tqPos.add(expirationDateGT_TS);\n\t\t\tqPos.add(expirationDateLT_TS);\n\n\t\t\treturn q.list();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tHibernateUtil.closeSession(session);\n\t\t}\n\t}","commit_id":"cf1f8e1fb85a5ea8e80dfed7a223800d6305506b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List findByR(Date reviewDateLT, Date reviewDateGT)\n\t\tthrows SystemException {\n\n\t\tTimestamp reviewDateLT_TS = CalendarUtil.getTimestamp(reviewDateLT);\n\t\tTimestamp reviewDateGT_TS = CalendarUtil.getTimestamp(reviewDateGT);\n\n\t\tSession session = null;\n\t\ttry {\n\t\t\tsession = HibernateUtil.openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_R);\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.setCacheable(false);\n\n\t\t\tq.addEntity(\"JournalArticle\", JournalArticleImpl.class);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tqPos.add(reviewDateGT_TS);\n\t\t\tqPos.add(reviewDateLT_TS);\n\n\t\t\treturn q.list();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tHibernateUtil.closeSession(session);\n\t\t}\n\t}","id":93517,"modified_method":"public static List findByReviewDate(Date reviewDateLT, Date reviewDateGT)\n\t\tthrows SystemException {\n\n\t\tTimestamp reviewDateLT_TS = CalendarUtil.getTimestamp(reviewDateLT);\n\t\tTimestamp reviewDateGT_TS = CalendarUtil.getTimestamp(reviewDateGT);\n\n\t\tSession session = null;\n\t\ttry {\n\t\t\tsession = HibernateUtil.openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_REVIEW_DATE);\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.setCacheable(false);\n\n\t\t\tq.addEntity(\"JournalArticle\", JournalArticleImpl.class);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tqPos.add(reviewDateGT_TS);\n\t\t\tqPos.add(reviewDateLT_TS);\n\n\t\t\treturn q.list();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tHibernateUtil.closeSession(session);\n\t\t}\n\t}","commit_id":"cf1f8e1fb85a5ea8e80dfed7a223800d6305506b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getArticleContent(\n\t\t\tlong groupId, String articleId, double version, String templateId,\n\t\t\tString languageId, ThemeDisplay themeDisplay)\n\t\tthrows PortalException, SystemException {\n\n\t\tJournalArticle article = JournalArticleUtil.findByG_A_V(\n\t\t\tgroupId, articleId, version);\n\t\t\n\t\tDate now = new Date();\n\t\t\n\t\tif (article.isExpired() || article.getExpirationDate().before(now)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/*if (!article.isTemplateDriven()) {\n\t\t\treturn article.getContent();\n\t\t}*/\n\n\t\tMap tokens = JournalUtil.getTokens(groupId, themeDisplay);\n\n\t\tString xml = article.getContent();\n\n\t\ttry {\n\t\t\tDocument doc = null;\n\n\t\t\tElement root = null;\n\n\t\t\tif (article.isTemplateDriven()) {\n\t\t\t\tSAXReader reader = new SAXReader();\n\n\t\t\t\tdoc = reader.read(new StringReader(xml));\n\n\t\t\t\troot = doc.getRootElement();\n\t\t\t}\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens, JournalStructureImpl.RESERVED_ARTICLE_ID,\n\t\t\t\tarticle.getArticleId());\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens, JournalStructureImpl.RESERVED_ARTICLE_VERSION,\n\t\t\t\tDouble.toString(article.getVersion()));\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens, JournalStructureImpl.RESERVED_ARTICLE_TITLE,\n\t\t\t\tarticle.getTitle());\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens, JournalStructureImpl.RESERVED_ARTICLE_DESCRIPTION,\n\t\t\t\tarticle.getDescription());\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens, JournalStructureImpl.RESERVED_ARTICLE_CREATE_DATE,\n\t\t\t\tarticle.getCreateDate().toString());\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens,\n\t\t\t\tJournalStructureImpl.RESERVED_ARTICLE_MODIFIED_DATE,\n\t\t\t\tarticle.getModifiedDate().toString());\n\n\t\t\tif (article.getDisplayDate() != null) {\n\t\t\t\tJournalUtil.addReservedEl(\n\t\t\t\t\troot, tokens,\n\t\t\t\t\tJournalStructureImpl.RESERVED_ARTICLE_DISPLAY_DATE,\n\t\t\t\t\tarticle.getDisplayDate().toString());\n\t\t\t}\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens, JournalStructureImpl.RESERVED_ARTICLE_AUTHOR_ID,\n\t\t\t\tString.valueOf(article.getUserId()));\n\n\t\t\tString userName = StringPool.BLANK;\n\t\t\tString userEmailAddress = StringPool.BLANK;\n\n\t\t\tUser user = null;\n\n\t\t\ttry {\n\t\t\t\tuser = UserLocalServiceUtil.getUserById(article.getUserId());\n\n\t\t\t\tuserName = user.getFullName();\n\t\t\t\tuserEmailAddress = user.getEmailAddress();\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\t\t\t}\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens, JournalStructureImpl.RESERVED_ARTICLE_AUTHOR_NAME,\n\t\t\t\tuserName);\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens,\n\t\t\t\tJournalStructureImpl.RESERVED_ARTICLE_AUTHOR_EMAIL_ADDRESS,\n\t\t\t\tuserEmailAddress);\n\n\t\t\tif (article.isTemplateDriven()) {\n\t\t\t\txml = JournalUtil.formatXML(doc);\n\t\t\t}\n\t\t}\n\t\tcatch (DocumentException de) {\n\t\t\tthrow new SystemException(de);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\n\t\ttry {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Transforming \" + articleId + \" \" + version + \" \" +\n\t\t\t\t\t\tlanguageId);\n\t\t\t}\n\n\t\t\tString script = null;\n\t\t\tString langType = null;\n\n\t\t\tif (article.isTemplateDriven()) {\n\n\t\t\t\t// Try with specified template first. If a template is not\n\t\t\t\t// specified, use the default one. If the specified template\n\t\t\t\t// does not exit, use the default one. If the default one does\n\t\t\t\t// not exist, throw an exception.\n\n\t\t\t\tString defaultTemplateId = article.getTemplateId();\n\n\t\t\t\tif (Validator.isNull(templateId)) {\n\t\t\t\t\ttemplateId = defaultTemplateId;\n\t\t\t\t}\n\n\t\t\t\tJournalTemplate template = null;\n\n\t\t\t\ttry {\n\t\t\t\t\ttemplate = JournalTemplateUtil.findByG_T(\n\t\t\t\t\t\tgroupId, templateId);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchTemplateException nste) {\n\t\t\t\t\tif (!defaultTemplateId.equals(templateId)) {\n\t\t\t\t\t\ttemplate = JournalTemplateUtil.findByG_T(\n\t\t\t\t\t\t\tgroupId, defaultTemplateId);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow nste;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tscript = template.getXsl();\n\t\t\t\tlangType = template.getLangType();\n\t\t\t}\n\n\t\t\treturn JournalUtil.transform(\n\t\t\t\ttokens, languageId, xml, script, langType);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t}","id":93518,"modified_method":"public String getArticleContent(\n\t\t\tlong groupId, String articleId, double version, String templateId,\n\t\t\tString languageId, ThemeDisplay themeDisplay)\n\t\tthrows PortalException, SystemException {\n\n\t\tJournalArticle article = JournalArticleUtil.findByG_A_V(\n\t\t\tgroupId, articleId, version);\n\n\t\tif (article.isExpired()) {\n\t\t\tDate expirationDate = article.getExpirationDate();\n\n\t\t\tif ((expirationDate != null) && expirationDate.before(new Date())) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t/*if (!article.isTemplateDriven()) {\n\t\t\treturn article.getContent();\n\t\t}*/\n\n\t\tMap tokens = JournalUtil.getTokens(groupId, themeDisplay);\n\n\t\tString xml = article.getContent();\n\n\t\ttry {\n\t\t\tDocument doc = null;\n\n\t\t\tElement root = null;\n\n\t\t\tif (article.isTemplateDriven()) {\n\t\t\t\tSAXReader reader = new SAXReader();\n\n\t\t\t\tdoc = reader.read(new StringReader(xml));\n\n\t\t\t\troot = doc.getRootElement();\n\t\t\t}\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens, JournalStructureImpl.RESERVED_ARTICLE_ID,\n\t\t\t\tarticle.getArticleId());\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens, JournalStructureImpl.RESERVED_ARTICLE_VERSION,\n\t\t\t\tDouble.toString(article.getVersion()));\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens, JournalStructureImpl.RESERVED_ARTICLE_TITLE,\n\t\t\t\tarticle.getTitle());\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens, JournalStructureImpl.RESERVED_ARTICLE_DESCRIPTION,\n\t\t\t\tarticle.getDescription());\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens, JournalStructureImpl.RESERVED_ARTICLE_CREATE_DATE,\n\t\t\t\tarticle.getCreateDate().toString());\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens,\n\t\t\t\tJournalStructureImpl.RESERVED_ARTICLE_MODIFIED_DATE,\n\t\t\t\tarticle.getModifiedDate().toString());\n\n\t\t\tif (article.getDisplayDate() != null) {\n\t\t\t\tJournalUtil.addReservedEl(\n\t\t\t\t\troot, tokens,\n\t\t\t\t\tJournalStructureImpl.RESERVED_ARTICLE_DISPLAY_DATE,\n\t\t\t\t\tarticle.getDisplayDate().toString());\n\t\t\t}\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens, JournalStructureImpl.RESERVED_ARTICLE_AUTHOR_ID,\n\t\t\t\tString.valueOf(article.getUserId()));\n\n\t\t\tString userName = StringPool.BLANK;\n\t\t\tString userEmailAddress = StringPool.BLANK;\n\n\t\t\tUser user = null;\n\n\t\t\ttry {\n\t\t\t\tuser = UserLocalServiceUtil.getUserById(article.getUserId());\n\n\t\t\t\tuserName = user.getFullName();\n\t\t\t\tuserEmailAddress = user.getEmailAddress();\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\t\t\t}\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens, JournalStructureImpl.RESERVED_ARTICLE_AUTHOR_NAME,\n\t\t\t\tuserName);\n\n\t\t\tJournalUtil.addReservedEl(\n\t\t\t\troot, tokens,\n\t\t\t\tJournalStructureImpl.RESERVED_ARTICLE_AUTHOR_EMAIL_ADDRESS,\n\t\t\t\tuserEmailAddress);\n\n\t\t\tif (article.isTemplateDriven()) {\n\t\t\t\txml = JournalUtil.formatXML(doc);\n\t\t\t}\n\t\t}\n\t\tcatch (DocumentException de) {\n\t\t\tthrow new SystemException(de);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\n\t\ttry {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Transforming \" + articleId + \" \" + version + \" \" +\n\t\t\t\t\t\tlanguageId);\n\t\t\t}\n\n\t\t\tString script = null;\n\t\t\tString langType = null;\n\n\t\t\tif (article.isTemplateDriven()) {\n\n\t\t\t\t// Try with specified template first. If a template is not\n\t\t\t\t// specified, use the default one. If the specified template\n\t\t\t\t// does not exit, use the default one. If the default one does\n\t\t\t\t// not exist, throw an exception.\n\n\t\t\t\tString defaultTemplateId = article.getTemplateId();\n\n\t\t\t\tif (Validator.isNull(templateId)) {\n\t\t\t\t\ttemplateId = defaultTemplateId;\n\t\t\t\t}\n\n\t\t\t\tJournalTemplate template = null;\n\n\t\t\t\ttry {\n\t\t\t\t\ttemplate = JournalTemplateUtil.findByG_T(\n\t\t\t\t\t\tgroupId, templateId);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchTemplateException nste) {\n\t\t\t\t\tif (!defaultTemplateId.equals(templateId)) {\n\t\t\t\t\t\ttemplate = JournalTemplateUtil.findByG_T(\n\t\t\t\t\t\t\tgroupId, defaultTemplateId);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow nste;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tscript = template.getXsl();\n\t\t\t\tlangType = template.getLangType();\n\t\t\t}\n\n\t\t\treturn JournalUtil.transform(\n\t\t\t\ttokens, languageId, xml, script, langType);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t}","commit_id":"cf1f8e1fb85a5ea8e80dfed7a223800d6305506b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public JournalArticle updateArticle(\n\t\t\tlong userId, long groupId, String articleId, double version,\n\t\t\tboolean incrementVersion, String title, String description,\n\t\t\tString content, String type, String structureId, String templateId,\n\t\t\tint displayDateMonth, int displayDateDay, int displayDateYear,\n\t\t\tint displayDateHour, int displayDateMinute, int expirationDateMonth,\n\t\t\tint expirationDateDay, int expirationDateYear,\n\t\t\tint expirationDateHour, int expirationDateMinute,\n\t\t\tboolean neverExpire, int reviewDateMonth, int reviewDateDay,\n\t\t\tint reviewDateYear, int reviewDateHour, int reviewDateMinute,\n\t\t\tboolean neverReview, Map images, String articleURL,\n\t\t\tPortletPreferences prefs, String[] tagsEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tUser user = UserUtil.findByPrimaryKey(userId);\n\t\tarticleId = articleId.trim().toUpperCase();\n\t\tDate now = new Date();\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\tdisplayDateHour, displayDateMinute, user.getTimeZone(),\n\t\t\tnew ArticleDisplayDateException());\n\n\t\tDate expirationDate = null;\n\n\t\tif (!neverExpire) {\n\t\t\texpirationDate = PortalUtil.getDate(\n\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\texpirationDateHour, expirationDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleExpirationDateException());\n\t\t}\n\n\t\tDate reviewDate = null;\n\n\t\tif (!neverReview) {\n\t\t\treviewDate = PortalUtil.getDate(\n\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\treviewDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleReviewDateException());\n\t\t}\n\n\t\tvalidate(title, content, groupId, structureId, templateId);\n\n\t\tJournalArticle oldArticle = JournalArticleUtil.findByG_A_V(\n\t\t\tgroupId, articleId, version);\n\n\t\tJournalArticle article = null;\n\n\t\tif (incrementVersion) {\n\t\t\tdouble latestVersion = getLatestVersion(groupId, articleId);\n\n\t\t\tlong id = CounterLocalServiceUtil.increment();\n\n\t\t\tarticle = JournalArticleUtil.create(id);\n\n\t\t\tarticle.setGroupId(oldArticle.getGroupId());\n\t\t\tarticle.setCompanyId(user.getCompanyId());\n\t\t\tarticle.setUserId(user.getUserId());\n\t\t\tarticle.setUserName(user.getFullName());\n\t\t\tarticle.setCreateDate(now);\n\t\t\tarticle.setArticleId(articleId);\n\t\t\tarticle.setVersion(MathUtil.format(latestVersion + 0.1, 1, 1));\n\t\t}\n\t\telse {\n\t\t\tarticle = oldArticle;\n\t\t}\n\n\t\tcontent = format(\n\t\t\tgroupId, articleId, article.getVersion(), incrementVersion, content,\n\t\t\tstructureId, images);\n\n\t\tboolean approved = oldArticle.isApproved();\n\n\t\tif (incrementVersion) {\n\t\t\tapproved = false;\n\t\t}\n\n\t\tboolean expired = oldArticle.isExpired();\n\n\t\tif (incrementVersion) {\n\t\t\texpired = false;\n\t\t}\n\n\t\tarticle.setModifiedDate(now);\n\t\tarticle.setTitle(title);\n\t\tarticle.setDescription(description);\n\t\tarticle.setContent(content);\n\t\tarticle.setType(type);\n\t\tarticle.setStructureId(structureId);\n\t\tarticle.setTemplateId(templateId);\n\t\tarticle.setDisplayDate(displayDate);\n\t\tarticle.setApproved(approved);\n\t\t\n\t\tif (expirationDate == null || expirationDate.after(now)) {\n\t\t\tarticle.setExpired(false);\n\t\t}\n\t\telse {\n\t\t\tarticle.setExpired(expired);\n\t\t}\n\t\t\n\t\tarticle.setExpirationDate(expirationDate);\n\t\tarticle.setReviewDate(reviewDate);\n\n\t\tJournalArticleUtil.update(article);\n\n\t\t// Tags\n\n\t\tTagsAssetLocalServiceUtil.updateAsset(\n\t\t\tuserId, JournalArticle.class.getName(),\n\t\t\tarticle.getResourcePrimKey(), tagsEntries);\n\n\t\t// Email\n\n\t\tif (incrementVersion) {\n\t\t\tsendEmail(article, articleURL, prefs, \"requested\");\n\t\t}\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tif (article.isApproved()) {\n\t\t\t\tIndexer.updateArticle(\n\t\t\t\t\tarticle.getCompanyId(), article.getGroupId(),\n\t\t\t\t\tarticle.getArticleId(), article.getVersion(),\n\t\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\t\tarticle.getContent(), article.getType(),\n\t\t\t\t\tarticle.getDisplayDate());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(\"Indexing \" + article.getPrimaryKey(), ioe);\n\t\t}\n\n\t\treturn article;\n\t}","id":93519,"modified_method":"public JournalArticle updateArticle(\n\t\t\tlong userId, long groupId, String articleId, double version,\n\t\t\tboolean incrementVersion, String title, String description,\n\t\t\tString content, String type, String structureId, String templateId,\n\t\t\tint displayDateMonth, int displayDateDay, int displayDateYear,\n\t\t\tint displayDateHour, int displayDateMinute, int expirationDateMonth,\n\t\t\tint expirationDateDay, int expirationDateYear,\n\t\t\tint expirationDateHour, int expirationDateMinute,\n\t\t\tboolean neverExpire, int reviewDateMonth, int reviewDateDay,\n\t\t\tint reviewDateYear, int reviewDateHour, int reviewDateMinute,\n\t\t\tboolean neverReview, Map images, String articleURL,\n\t\t\tPortletPreferences prefs, String[] tagsEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tUser user = UserUtil.findByPrimaryKey(userId);\n\t\tarticleId = articleId.trim().toUpperCase();\n\t\tDate now = new Date();\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\tdisplayDateHour, displayDateMinute, user.getTimeZone(),\n\t\t\tnew ArticleDisplayDateException());\n\n\t\tDate expirationDate = null;\n\n\t\tif (!neverExpire) {\n\t\t\texpirationDate = PortalUtil.getDate(\n\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\texpirationDateHour, expirationDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleExpirationDateException());\n\t\t}\n\n\t\tDate reviewDate = null;\n\n\t\tif (!neverReview) {\n\t\t\treviewDate = PortalUtil.getDate(\n\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\treviewDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleReviewDateException());\n\t\t}\n\n\t\tvalidate(title, content, groupId, structureId, templateId);\n\n\t\tJournalArticle oldArticle = JournalArticleUtil.findByG_A_V(\n\t\t\tgroupId, articleId, version);\n\n\t\tJournalArticle article = null;\n\n\t\tif (incrementVersion) {\n\t\t\tdouble latestVersion = getLatestVersion(groupId, articleId);\n\n\t\t\tlong id = CounterLocalServiceUtil.increment();\n\n\t\t\tarticle = JournalArticleUtil.create(id);\n\n\t\t\tarticle.setGroupId(oldArticle.getGroupId());\n\t\t\tarticle.setCompanyId(user.getCompanyId());\n\t\t\tarticle.setUserId(user.getUserId());\n\t\t\tarticle.setUserName(user.getFullName());\n\t\t\tarticle.setCreateDate(now);\n\t\t\tarticle.setArticleId(articleId);\n\t\t\tarticle.setVersion(MathUtil.format(latestVersion + 0.1, 1, 1));\n\t\t}\n\t\telse {\n\t\t\tarticle = oldArticle;\n\t\t}\n\n\t\tcontent = format(\n\t\t\tgroupId, articleId, article.getVersion(), incrementVersion, content,\n\t\t\tstructureId, images);\n\n\t\tboolean approved = oldArticle.isApproved();\n\n\t\tif (incrementVersion) {\n\t\t\tapproved = false;\n\t\t}\n\n\t\tboolean expired = oldArticle.isExpired();\n\n\t\tif (incrementVersion) {\n\t\t\texpired = false;\n\t\t}\n\n\t\tarticle.setModifiedDate(now);\n\t\tarticle.setTitle(title);\n\t\tarticle.setDescription(description);\n\t\tarticle.setContent(content);\n\t\tarticle.setType(type);\n\t\tarticle.setStructureId(structureId);\n\t\tarticle.setTemplateId(templateId);\n\t\tarticle.setDisplayDate(displayDate);\n\t\tarticle.setApproved(approved);\n\n\t\tif ((expirationDate == null) || expirationDate.after(now)) {\n\t\t\tarticle.setExpired(false);\n\t\t}\n\t\telse {\n\t\t\tarticle.setExpired(true);\n\t\t}\n\n\t\tarticle.setExpirationDate(expirationDate);\n\t\tarticle.setReviewDate(reviewDate);\n\n\t\tJournalArticleUtil.update(article);\n\n\t\t// Tags\n\n\t\tTagsAssetLocalServiceUtil.updateAsset(\n\t\t\tuserId, JournalArticle.class.getName(),\n\t\t\tarticle.getResourcePrimKey(), tagsEntries);\n\n\t\t// Email\n\n\t\tif (incrementVersion) {\n\t\t\tsendEmail(article, articleURL, prefs, \"requested\");\n\t\t}\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tif (article.isApproved()) {\n\t\t\t\tIndexer.updateArticle(\n\t\t\t\t\tarticle.getCompanyId(), article.getGroupId(),\n\t\t\t\t\tarticle.getArticleId(), article.getVersion(),\n\t\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\t\tarticle.getContent(), article.getType(),\n\t\t\t\t\tarticle.getDisplayDate());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(\"Indexing \" + article.getPrimaryKey(), ioe);\n\t\t}\n\n\t\treturn article;\n\t}","commit_id":"cf1f8e1fb85a5ea8e80dfed7a223800d6305506b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void checkArticles() throws PortalException, SystemException {\n\t\tDate now = new Date();\n\n\t\tList articles = JournalArticleFinder.findByE_E(Boolean.FALSE, \n\t\t\t\tnow, new Date(now.getTime() - CheckArticleJob.INTERVAL));\n\t\t\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Expiring \" + articles.size() + \" JournalArticles\");\n\t\t}\n\t\t\n\t\tList companies = new ArrayList();\n\t\t\n\t\tfor (int i = 0; i < articles.size(); i++) {\n\t\t\tJournalArticle article = (JournalArticle)articles.get(i);\n\n\t\t\tarticle.setApproved(false);\n\t\t\tarticle.setExpired(true);\n\n\t\t\tJournalArticleUtil.update(article);\n\t\t\t\n\t\t\tJournalContentUtil.clearArticleGroupCache(article.getGroupId(), \n\t\t\t\t\tarticle.getArticleId(), article.getTemplateId());\n\t\t\t\n\t\t\tcompanies.add(new Long(article.getCompanyId()));\n\t\t}\t\t\n\n\t\tIterator companyItr = companies.iterator();\n\t\t\n\t\twhile (companyItr.hasNext()) {\n\t\t\tlong companyId = ((Long)companyItr.next()).longValue();\n\t\t\tLayoutCacheUtil.clearCache(companyId);\n\t\t}\n\n\t\t\n\t\tarticles = JournalArticleFinder.findByR( \n\t\t\t\tnow, new Date(now.getTime() - CheckArticleJob.INTERVAL));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Sending \" + articles.size() + \" JournalArticle review emails\");\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < articles.size(); i++) {\n\t\t\tJournalArticle article = (JournalArticle)articles.get(i);\n\n\t\t\tDate reviewDate = article.getReviewDate();\n\n\t\t\tif (reviewDate != null) {\n\n\t\t\t\t// Check in *INTERVAL* minute intervals because of \n\t\t\t\t// CheckArticleJob\n\n\t\t\t\tlong diff = reviewDate.getTime() - now.getTime();\n\n\t\t\t\tif ((diff > 0) && (diff < CheckArticleJob.INTERVAL)) {\n\t\t\t\t\tString articleURL = StringPool.BLANK;\n\n\t\t\t\t\tlong ownerId = article.getGroupId();\n\t\t\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\t\t\tString portletId = PortletKeys.JOURNAL;\n\n\t\t\t\t\tPortletPreferences prefs =\n\t\t\t\t\t\tPortletPreferencesLocalServiceUtil.getPreferences(\n\t\t\t\t\t\t\tarticle.getCompanyId(), ownerId, ownerType, plid,\n\t\t\t\t\t\t\tportletId);\n\n\t\t\t\t\tsendEmail(article, articleURL, prefs, \"review\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":93520,"modified_method":"public void checkArticles() throws PortalException, SystemException {\n\t\tDate now = new Date();\n\n\t\tList articles = JournalArticleFinder.findByExpirationDate(\n\t\t\tBoolean.FALSE, now,\n\t\t\tnew Date(now.getTime() - CheckArticleJob.INTERVAL));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Expiring \" + articles.size() + \" articles\");\n\t\t}\n\n\t\tSet companies = new HashSet();\n\n\t\tfor (int i = 0; i < articles.size(); i++) {\n\t\t\tJournalArticle article = (JournalArticle)articles.get(i);\n\n\t\t\tarticle.setApproved(false);\n\t\t\tarticle.setExpired(true);\n\n\t\t\tJournalArticleUtil.update(article);\n\n\t\t\tJournalContentUtil.clearCache(\n\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\tarticle.getTemplateId());\n\n\t\t\tcompanies.add(new Long(article.getCompanyId()));\n\t\t}\n\n\t\tIterator itr = companies.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tlong companyId = ((Long)itr.next()).longValue();\n\n\t\t\tLayoutCacheUtil.clearCache(companyId);\n\t\t}\n\n\t\tarticles = JournalArticleFinder.findByReviewDate(\n\t\t\tnow, new Date(now.getTime() - CheckArticleJob.INTERVAL));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Sending review notifications for \" + articles.size() +\n\t\t\t\t\t\" articles\");\n\t\t}\n\n\t\tfor (int i = 0; i < articles.size(); i++) {\n\t\t\tJournalArticle article = (JournalArticle)articles.get(i);\n\n\t\t\tDate reviewDate = article.getReviewDate();\n\n\t\t\tif (reviewDate != null) {\n\t\t\t\tlong diff = reviewDate.getTime() - now.getTime();\n\n\t\t\t\tif ((diff > 0) && (diff < CheckArticleJob.INTERVAL)) {\n\t\t\t\t\tString articleURL = StringPool.BLANK;\n\n\t\t\t\t\tlong ownerId = article.getGroupId();\n\t\t\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\t\t\tString portletId = PortletKeys.JOURNAL;\n\n\t\t\t\t\tPortletPreferences prefs =\n\t\t\t\t\t\tPortletPreferencesLocalServiceUtil.getPreferences(\n\t\t\t\t\t\t\tarticle.getCompanyId(), ownerId, ownerType, plid,\n\t\t\t\t\t\t\tportletId);\n\n\t\t\t\t\tsendEmail(article, articleURL, prefs, \"review\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"cf1f8e1fb85a5ea8e80dfed7a223800d6305506b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\n\t\ttestSuite.addTestSuite(AccountPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AddressPersistenceTest.class);\n\t\ttestSuite.addTestSuite(BrowserTrackerPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ClassNamePersistenceTest.class);\n\t\ttestSuite.addTestSuite(CompanyPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ContactPersistenceTest.class);\n\t\ttestSuite.addTestSuite(CountryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(EmailAddressPersistenceTest.class);\n\t\ttestSuite.addTestSuite(GroupPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ImagePersistenceTest.class);\n\t\ttestSuite.addTestSuite(LayoutPersistenceTest.class);\n\t\ttestSuite.addTestSuite(LayoutPrototypePersistenceTest.class);\n\t\ttestSuite.addTestSuite(LayoutSetPersistenceTest.class);\n\t\ttestSuite.addTestSuite(LayoutSetPrototypePersistenceTest.class);\n\t\ttestSuite.addTestSuite(ListTypePersistenceTest.class);\n\t\ttestSuite.addTestSuite(LockPersistenceTest.class);\n\t\ttestSuite.addTestSuite(MembershipRequestPersistenceTest.class);\n\t\ttestSuite.addTestSuite(OrganizationPersistenceTest.class);\n\t\ttestSuite.addTestSuite(OrgGroupPermissionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(OrgGroupRolePersistenceTest.class);\n\t\ttestSuite.addTestSuite(OrgLaborPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PasswordPolicyPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PasswordPolicyRelPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PasswordTrackerPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PermissionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PhonePersistenceTest.class);\n\t\ttestSuite.addTestSuite(PluginSettingPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PortletItemPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PortletPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PortletPreferencesPersistenceTest.class);\n\t\ttestSuite.addTestSuite(RegionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ReleasePersistenceTest.class);\n\t\ttestSuite.addTestSuite(ResourceActionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ResourceCodePersistenceTest.class);\n\t\ttestSuite.addTestSuite(ResourcePermissionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ResourcePersistenceTest.class);\n\t\ttestSuite.addTestSuite(RolePersistenceTest.class);\n\t\ttestSuite.addTestSuite(ServiceComponentPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShardPersistenceTest.class);\n\t\ttestSuite.addTestSuite(SubscriptionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(TeamPersistenceTest.class);\n\t\ttestSuite.addTestSuite(UserGroupGroupRolePersistenceTest.class);\n\t\ttestSuite.addTestSuite(UserGroupPersistenceTest.class);\n\t\ttestSuite.addTestSuite(UserGroupRolePersistenceTest.class);\n\t\ttestSuite.addTestSuite(UserIdMapperPersistenceTest.class);\n\t\ttestSuite.addTestSuite(UserPersistenceTest.class);\n\t\ttestSuite.addTestSuite(UserTrackerPathPersistenceTest.class);\n\t\ttestSuite.addTestSuite(UserTrackerPersistenceTest.class);\n\t\ttestSuite.addTestSuite(WebDAVPropsPersistenceTest.class);\n\t\ttestSuite.addTestSuite(WebsitePersistenceTest.class);\n\t\ttestSuite.addTestSuite(WorkflowDefinitionLinkPersistenceTest.class);\n\t\ttestSuite.addTestSuite(WorkflowInstanceLinkPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(AnnouncementsDeliveryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AnnouncementsEntryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AnnouncementsFlagPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(AssetCategoryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AssetCategoryPropertyPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AssetEntryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AssetLinkPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AssetTagPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AssetTagPropertyPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AssetTagStatsPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AssetVocabularyPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(BlogsEntryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(BlogsStatsUserPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(BookmarksEntryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(BookmarksFolderPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(CalEventPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(DLFileEntryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(DLFileRankPersistenceTest.class);\n\t\ttestSuite.addTestSuite(DLFileShortcutPersistenceTest.class);\n\t\ttestSuite.addTestSuite(DLFileVersionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(DLFolderPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(ExpandoColumnPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ExpandoRowPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ExpandoTablePersistenceTest.class);\n\t\ttestSuite.addTestSuite(ExpandoValuePersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(IGFolderPersistenceTest.class);\n\t\ttestSuite.addTestSuite(IGImagePersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(JournalArticleImagePersistenceTest.class);\n\t\ttestSuite.addTestSuite(JournalArticlePersistenceTest.class);\n\t\ttestSuite.addTestSuite(JournalArticleResourcePersistenceTest.class);\n\t\ttestSuite.addTestSuite(JournalContentSearchPersistenceTest.class);\n\t\ttestSuite.addTestSuite(JournalFeedPersistenceTest.class);\n\t\ttestSuite.addTestSuite(JournalStructurePersistenceTest.class);\n\t\ttestSuite.addTestSuite(JournalTemplatePersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(MBBanPersistenceTest.class);\n\t\ttestSuite.addTestSuite(MBCategoryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(MBDiscussionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(MBMailingListPersistenceTest.class);\n\t\ttestSuite.addTestSuite(MBMessageFlagPersistenceTest.class);\n\t\ttestSuite.addTestSuite(MBMessagePersistenceTest.class);\n\t\ttestSuite.addTestSuite(MBStatsUserPersistenceTest.class);\n\t\ttestSuite.addTestSuite(MBThreadPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(PollsChoicePersistenceTest.class);\n\t\ttestSuite.addTestSuite(PollsQuestionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PollsVotePersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(RatingsEntryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(RatingsStatsPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(ShoppingCartPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShoppingCategoryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShoppingCouponPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShoppingItemFieldPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShoppingItemPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShoppingItemPricePersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShoppingOrderItemPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShoppingOrderPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(SocialActivityPersistenceTest.class);\n\t\ttestSuite.addTestSuite(SocialRelationPersistenceTest.class);\n\t\ttestSuite.addTestSuite(SocialRequestPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(SCFrameworkVersionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(SCLicensePersistenceTest.class);\n\t\ttestSuite.addTestSuite(SCProductEntryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(SCProductScreenshotPersistenceTest.class);\n\t\ttestSuite.addTestSuite(SCProductVersionPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(TasksProposalPersistenceTest.class);\n\t\ttestSuite.addTestSuite(TasksReviewPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(WikiNodePersistenceTest.class);\n\t\ttestSuite.addTestSuite(WikiPagePersistenceTest.class);\n\t\ttestSuite.addTestSuite(WikiPageResourcePersistenceTest.class);\n\n\t\treturn testSuite;\n\t}","id":93521,"modified_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\n\t\ttestSuite.addTestSuite(AccountPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AddressPersistenceTest.class);\n\t\ttestSuite.addTestSuite(BrowserTrackerPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ClassNamePersistenceTest.class);\n\t\ttestSuite.addTestSuite(CompanyPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ContactPersistenceTest.class);\n\t\ttestSuite.addTestSuite(CountryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(EmailAddressPersistenceTest.class);\n\t\ttestSuite.addTestSuite(GroupPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ImagePersistenceTest.class);\n\t\ttestSuite.addTestSuite(LayoutPersistenceTest.class);\n\t\ttestSuite.addTestSuite(LayoutPrototypePersistenceTest.class);\n\t\ttestSuite.addTestSuite(LayoutSetPersistenceTest.class);\n\t\ttestSuite.addTestSuite(LayoutSetPrototypePersistenceTest.class);\n\t\ttestSuite.addTestSuite(ListTypePersistenceTest.class);\n\t\ttestSuite.addTestSuite(LockPersistenceTest.class);\n\t\ttestSuite.addTestSuite(MembershipRequestPersistenceTest.class);\n\t\ttestSuite.addTestSuite(OrganizationPersistenceTest.class);\n\t\ttestSuite.addTestSuite(OrgGroupPermissionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(OrgGroupRolePersistenceTest.class);\n\t\ttestSuite.addTestSuite(OrgLaborPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PasswordPolicyPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PasswordPolicyRelPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PasswordTrackerPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PermissionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PhonePersistenceTest.class);\n\t\ttestSuite.addTestSuite(PluginSettingPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PortletItemPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PortletPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PortletPreferencesPersistenceTest.class);\n\t\ttestSuite.addTestSuite(RegionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ReleasePersistenceTest.class);\n\t\ttestSuite.addTestSuite(ResourceActionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ResourceCodePersistenceTest.class);\n\t\ttestSuite.addTestSuite(ResourcePermissionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ResourcePersistenceTest.class);\n\t\ttestSuite.addTestSuite(RolePersistenceTest.class);\n\t\ttestSuite.addTestSuite(ServiceComponentPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShardPersistenceTest.class);\n\t\ttestSuite.addTestSuite(SubscriptionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(TeamPersistenceTest.class);\n\t\ttestSuite.addTestSuite(TicketPersistenceTest.class);\n\t\ttestSuite.addTestSuite(UserGroupGroupRolePersistenceTest.class);\n\t\ttestSuite.addTestSuite(UserGroupPersistenceTest.class);\n\t\ttestSuite.addTestSuite(UserGroupRolePersistenceTest.class);\n\t\ttestSuite.addTestSuite(UserIdMapperPersistenceTest.class);\n\t\ttestSuite.addTestSuite(UserPersistenceTest.class);\n\t\ttestSuite.addTestSuite(UserTrackerPathPersistenceTest.class);\n\t\ttestSuite.addTestSuite(UserTrackerPersistenceTest.class);\n\t\ttestSuite.addTestSuite(WebDAVPropsPersistenceTest.class);\n\t\ttestSuite.addTestSuite(WebsitePersistenceTest.class);\n\t\ttestSuite.addTestSuite(WorkflowDefinitionLinkPersistenceTest.class);\n\t\ttestSuite.addTestSuite(WorkflowInstanceLinkPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(AnnouncementsDeliveryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AnnouncementsEntryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AnnouncementsFlagPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(AssetCategoryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AssetCategoryPropertyPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AssetEntryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AssetLinkPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AssetTagPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AssetTagPropertyPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AssetTagStatsPersistenceTest.class);\n\t\ttestSuite.addTestSuite(AssetVocabularyPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(BlogsEntryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(BlogsStatsUserPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(BookmarksEntryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(BookmarksFolderPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(CalEventPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(DLFileEntryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(DLFileRankPersistenceTest.class);\n\t\ttestSuite.addTestSuite(DLFileShortcutPersistenceTest.class);\n\t\ttestSuite.addTestSuite(DLFileVersionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(DLFolderPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(ExpandoColumnPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ExpandoRowPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ExpandoTablePersistenceTest.class);\n\t\ttestSuite.addTestSuite(ExpandoValuePersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(IGFolderPersistenceTest.class);\n\t\ttestSuite.addTestSuite(IGImagePersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(JournalArticleImagePersistenceTest.class);\n\t\ttestSuite.addTestSuite(JournalArticlePersistenceTest.class);\n\t\ttestSuite.addTestSuite(JournalArticleResourcePersistenceTest.class);\n\t\ttestSuite.addTestSuite(JournalContentSearchPersistenceTest.class);\n\t\ttestSuite.addTestSuite(JournalFeedPersistenceTest.class);\n\t\ttestSuite.addTestSuite(JournalStructurePersistenceTest.class);\n\t\ttestSuite.addTestSuite(JournalTemplatePersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(MBBanPersistenceTest.class);\n\t\ttestSuite.addTestSuite(MBCategoryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(MBDiscussionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(MBMailingListPersistenceTest.class);\n\t\ttestSuite.addTestSuite(MBMessageFlagPersistenceTest.class);\n\t\ttestSuite.addTestSuite(MBMessagePersistenceTest.class);\n\t\ttestSuite.addTestSuite(MBStatsUserPersistenceTest.class);\n\t\ttestSuite.addTestSuite(MBThreadPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(PollsChoicePersistenceTest.class);\n\t\ttestSuite.addTestSuite(PollsQuestionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(PollsVotePersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(RatingsEntryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(RatingsStatsPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(ShoppingCartPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShoppingCategoryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShoppingCouponPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShoppingItemFieldPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShoppingItemPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShoppingItemPricePersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShoppingOrderItemPersistenceTest.class);\n\t\ttestSuite.addTestSuite(ShoppingOrderPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(SocialActivityPersistenceTest.class);\n\t\ttestSuite.addTestSuite(SocialRelationPersistenceTest.class);\n\t\ttestSuite.addTestSuite(SocialRequestPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(SCFrameworkVersionPersistenceTest.class);\n\t\ttestSuite.addTestSuite(SCLicensePersistenceTest.class);\n\t\ttestSuite.addTestSuite(SCProductEntryPersistenceTest.class);\n\t\ttestSuite.addTestSuite(SCProductScreenshotPersistenceTest.class);\n\t\ttestSuite.addTestSuite(SCProductVersionPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(TasksProposalPersistenceTest.class);\n\t\ttestSuite.addTestSuite(TasksReviewPersistenceTest.class);\n\n\t\ttestSuite.addTestSuite(WikiNodePersistenceTest.class);\n\t\ttestSuite.addTestSuite(WikiPagePersistenceTest.class);\n\t\ttestSuite.addTestSuite(WikiPageResourcePersistenceTest.class);\n\n\t\treturn testSuite;\n\t}","commit_id":"4f0520c9ee6272c23fdc7168e05b44c41a70aec7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isExpired() {\n\t\tif ((System.currentTimeMillis() > getExpirationDate()) &&\n\t\t\t(getExpirationDate() > 0)) {\n\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","id":93522,"modified_method":"public boolean isExpired() {\n\t\tDate expirationDate = getExpirationDate();\n\n\t\tif ((expirationDate != null) && (expirationDate.before(new Date()))) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"4f0520c9ee6272c23fdc7168e05b44c41a70aec7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Ticket addTicket(\n\t\tlong expirationTime, String className, long classPK,\n\t\tServiceContext serviceContext) throws SystemException {\n\n\t\tlong ticketId = counterLocalService.increment(Ticket.class.getName());\n\t\tlong classNameId = classNameLocalService.getClassNameId(className);\n\t\tDate now = new Date();\n\n\t\tTicket ticket = ticketPersistence.create(ticketId);\n\n\t\tticket.setCompanyId(serviceContext.getCompanyId());\n\t\tticket.setCreateDate(now);\n\t\tif (expirationTime == 0) {\n\t\t\tticket.setExpirationDate(expirationTime);\n\t\t}\n\t\telse {\n\t\t\tticket.setExpirationDate(now.getTime() + expirationTime);\n\t\t}\n\n\t\tticket.setClassNameId(classNameId);\n\t\tticket.setClassPK(classPK);\n\t\tticket.setKey(UUID.randomUUID().toString());\n\n\t\tticketPersistence.update(ticket, false);\n\n\t\treturn ticket;\n\t}","id":93523,"modified_method":"public Ticket addTicket(\n\t\t\tlong companyId, String className, long classPK, Date expirationDate,\n\t\t\tServiceContext serviceContext)\n\t\tthrows SystemException {\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tDate now = new Date();\n\n\t\tlong ticketId = counterLocalService.increment();\n\n\t\tTicket ticket = ticketPersistence.create(ticketId);\n\n\t\tticket.setCompanyId(companyId);\n\t\tticket.setCreateDate(now);\n\t\tticket.setClassNameId(classNameId);\n\t\tticket.setClassPK(classPK);\n\t\tticket.setKey(PortalUUIDUtil.generate());\n\t\tticket.setExpirationDate(expirationDate);\n\n\t\tticketPersistence.update(ticket, false);\n\n\t\treturn ticket;\n\t}","commit_id":"4f0520c9ee6272c23fdc7168e05b44c41a70aec7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Reverter(@NotNull SvnVcs vcs, ProgressTracker handler, List<VcsException> exceptions) {\n      myVcs = vcs;\n      myHandler = handler;\n      myExceptions = exceptions;\n    }","id":93524,"modified_method":"private Reverter(@NotNull SvnVcs vcs, @NotNull RollbackProgressListener listener, @NotNull List<VcsException> exceptions) {\n      myVcs = vcs;\n      myHandler = createRevertHandler(exceptions, listener);\n      myExceptions = exceptions;\n      myFromToModified = ContainerUtil.newArrayList();\n      myProperties = ContainerUtil.newHashMap();\n    }","commit_id":"fe4aae530f91e86ed9b3a16f6ee26683c03ca9eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void rollbackChanges(List<Change> changes, final List<VcsException> exceptions, @NotNull final RollbackProgressListener listener) {\n    listener.indeterminate();\n\n    final Collection<List<Change>> collections = SvnUtil.splitChangesIntoWc(mySvnVcs, changes);\n    for (List<Change> collection : collections) {\n      // to be more sure about nested changes, being or being not reverted\n      final List<Change> innerChanges = new ArrayList<Change>(collection);\n      Collections.sort(innerChanges, ChangesAfterPathComparator.getInstance());\n      //for (Change change : innerChanges) {\n        rollbackGroupForWc(innerChanges, exceptions, listener);\n      //}\n    }\n  }","id":93525,"modified_method":"public void rollbackChanges(@NotNull List<Change> changes,\n                              @NotNull List<VcsException> exceptions,\n                              @NotNull RollbackProgressListener listener) {\n    listener.indeterminate();\n\n    for (List<Change> collection : SvnUtil.splitChangesIntoWc(mySvnVcs, changes)) {\n      // to be more sure about nested changes, being or being not reverted\n      List<Change> sortedChanges = ContainerUtil.sorted(collection, ChangesAfterPathComparator.getInstance());\n\n      rollbackGroupForWc(sortedChanges, exceptions, listener);\n    }\n  }","commit_id":"fe4aae530f91e86ed9b3a16f6ee26683c03ca9eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void gather(final List<Change> changes) {\n      final TreeMap<String, File> renames = new TreeMap<String, File>();\n      final Set<String> alsoReverted = new HashSet<String>();\n      final Map<String, FilePath> files = new HashMap<String, FilePath>();\n      for (Change change : changes) {\n        final ContentRevision beforeRevision = change.getBeforeRevision();\n        final ContentRevision afterRevision = change.getAfterRevision();\n        final String key = afterRevision == null ? null : FilePathsHelper.convertWithLastSeparator(afterRevision.getFile());\n        if (MoveRenameReplaceCheck.check(change)) {\n          final File beforeFile = beforeRevision.getFile().getIOFile();\n          renames.put(key, beforeFile);\n          files.put(key, afterRevision.getFile());\n          myCollector.markRename(beforeFile, afterRevision.getFile().getIOFile());\n        } else if (afterRevision != null) {\n          alsoReverted.add(key);\n        }\n      }\n      if (! renames.isEmpty()) {\n        final ArrayList<String> paths = new ArrayList<String>(renames.keySet());\n        if (paths.size() > 1) {\n          FilterFilePathStrings.getInstance().doFilter(paths);\n        }\n        myCollector.setRenamesMap(renames);\n        myCollector.setAlsoReverted(alsoReverted);\n        for (String path : paths) {\n          try {\n            myChangeProvider.getChanges(files.get(path), true, myCollector);\n          }\n          catch (SVNException e) {\n            myExceptions.add(new VcsException(e));\n          }\n          catch (SvnBindException e) {\n            myExceptions.add(e);\n          }\n        }\n      }\n\n      for (Change change : changes) {\n        final ContentRevision afterRevision = change.getAfterRevision();\n\n        boolean checked = myForAdds.accept(change);\n        checked |= myForDeletes.accept(change);\n\n        if (! checked) {\n          myForEdits.add(afterRevision.getFile().getIOFile());\n        }\n      }\n    }","id":93526,"modified_method":"public void gather(final List<Change> changes) {\n      final TreeMap<String, File> renames = new TreeMap<String, File>();\n      final Set<String> alsoReverted = new HashSet<String>();\n      final Map<String, FilePath> files = new HashMap<String, FilePath>();\n      for (Change change : changes) {\n        final ContentRevision beforeRevision = change.getBeforeRevision();\n        final ContentRevision afterRevision = change.getAfterRevision();\n        final String key = afterRevision == null ? null : FilePathsHelper.convertWithLastSeparator(afterRevision.getFile());\n        if (isMoveRenameReplace(change)) {\n          final File beforeFile = beforeRevision.getFile().getIOFile();\n          renames.put(key, beforeFile);\n          files.put(key, afterRevision.getFile());\n          myCollector.markRename(beforeFile, afterRevision.getFile().getIOFile());\n        } else if (afterRevision != null) {\n          alsoReverted.add(key);\n        }\n      }\n      if (! renames.isEmpty()) {\n        final ArrayList<String> paths = new ArrayList<String>(renames.keySet());\n        if (paths.size() > 1) {\n          FilterFilePathStrings.getInstance().doFilter(paths);\n        }\n        myCollector.setRenamesMap(renames);\n        myCollector.setAlsoReverted(alsoReverted);\n        for (String path : paths) {\n          try {\n            myChangeProvider.getChanges(files.get(path), true, myCollector);\n          }\n          catch (SVNException e) {\n            myExceptions.add(new VcsException(e));\n          }\n          catch (SvnBindException e) {\n            myExceptions.add(e);\n          }\n        }\n      }\n\n      for (Change change : changes) {\n        final ContentRevision afterRevision = change.getAfterRevision();\n\n        boolean checked = myForAdds.accept(change);\n        checked |= myForDeletes.accept(change);\n\n        if (! checked) {\n          myForEdits.add(afterRevision.getFile().getIOFile());\n        }\n      }\n    }","commit_id":"fe4aae530f91e86ed9b3a16f6ee26683c03ca9eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean accept(@NotNull Change change) {\n      ContentRevision mainRevision = myCheckBefore ? change.getBeforeRevision() : change.getAfterRevision();\n      ContentRevision otherRevision = !myCheckBefore ? change.getBeforeRevision() : change.getAfterRevision();\n\n      if (mainRevision == null || MoveRenameReplaceCheck.check(change)) {\n        check(otherRevision.getFile().getIOFile());\n        return true;\n      }\n\n      return false;\n    }","id":93527,"modified_method":"protected boolean accept(@NotNull Change change) {\n      ContentRevision mainRevision = myCheckBefore ? change.getBeforeRevision() : change.getAfterRevision();\n      ContentRevision otherRevision = !myCheckBefore ? change.getBeforeRevision() : change.getAfterRevision();\n\n      if (mainRevision == null || isMoveRenameReplace(change)) {\n        check(otherRevision.getFile().getIOFile());\n        return true;\n      }\n\n      return false;\n    }","commit_id":"fe4aae530f91e86ed9b3a16f6ee26683c03ca9eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void rollbackMissingFileDeletion(List<FilePath> filePaths, final List<VcsException> exceptions,\n                                                        final RollbackProgressListener listener) {\n    List<File> files = ChangesUtil.filePathsToFiles(filePaths);\n    for (File file : files) {\n      listener.accept(file);\n      try {\n        revertFileOrDir(file);\n      } catch (VcsException e) {\n        exceptions.add(e);\n      } catch (SVNException e) {\n        exceptions.add(new VcsException(e));\n      }\n    }\n  }","id":93528,"modified_method":"public void rollbackMissingFileDeletion(@NotNull List<FilePath> filePaths,\n                                          @NotNull List<VcsException> exceptions,\n                                          @NotNull RollbackProgressListener listener) {\n    for (FilePath filePath : filePaths) {\n      listener.accept(filePath);\n      try {\n        revertFileOrDir(filePath);\n      }\n      catch (VcsException e) {\n        exceptions.add(e);\n      }\n      catch (SVNException e) {\n        exceptions.add(new VcsException(e));\n      }\n    }\n  }","commit_id":"fe4aae530f91e86ed9b3a16f6ee26683c03ca9eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean is17OrGreaterCopy(final File file, final Info info) throws VcsException {\n    final RootsToWorkingCopies copies = mySvnVcs.getRootsToWorkingCopies();\n    WorkingCopy copy = copies.getMatchingCopy(info.getURL());\n\n    if (copy == null) {\n      WorkingCopyFormat format = mySvnVcs.getWorkingCopyFormat(file);\n\n      return format.isOrGreater(WorkingCopyFormat.ONE_DOT_SEVEN);\n    } else {\n      return copy.is17Copy();\n    }\n  }","id":93529,"modified_method":"private boolean is17OrGreaterCopy(@NotNull File file, @NotNull Info info) throws VcsException {\n    WorkingCopy copy = mySvnVcs.getRootsToWorkingCopies().getMatchingCopy(info.getURL());\n\n    return copy != null ? copy.is17Copy() : mySvnVcs.getWorkingCopyFormat(file).isOrGreater(WorkingCopyFormat.ONE_DOT_SEVEN);\n  }","commit_id":"fe4aae530f91e86ed9b3a16f6ee26683c03ca9eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void rollbackGroupForWc(@NotNull List<Change> changes,\n                                  @NotNull final List<VcsException> exceptions,\n                                  @NotNull final RollbackProgressListener listener) {\n    final UnversionedAndNotTouchedFilesGroupCollector collector = new UnversionedAndNotTouchedFilesGroupCollector();\n    final ChangesChecker checker = new ChangesChecker(mySvnVcs, collector);\n\n    checker.gather(changes);\n    exceptions.addAll(checker.getExceptions());\n\n    ProgressTracker revertHandler = new ProgressTracker() {\n      public void consume(ProgressEvent event) {\n        if (event.getAction() == EventAction.REVERT) {\n          final File file = event.getFile();\n          if (file != null) {\n            listener.accept(file);\n          }\n        }\n        if (event.getAction() == EventAction.FAILED_REVERT) {\n          exceptions.add(new VcsException(\"Revert failed\"));\n        }\n      }\n\n      public void checkCancelled() {\n        listener.checkCanceled();\n      }\n    };\n\n    final List<CopiedAsideInfo> fromToModified = new ArrayList<CopiedAsideInfo>();\n    final Map<File, PropertiesMap> properties = ContainerUtil.newHashMap();\n    moveRenamesToTmp(exceptions, fromToModified, properties, collector);\n    // adds (deletes)\n    // deletes (adds)\n    // modifications\n    final Reverter reverter = new Reverter(mySvnVcs, revertHandler, exceptions);\n    reverter.revert(checker.getForAdds(), true);\n    reverter.revert(checker.getForDeletes(), true);\n    reverter.revert(checker.getForEdits(), false);\n\n    moveGroup(exceptions, fromToModified, properties);\n\n    final List<Couple<File>> toBeDeleted = collector.getToBeDeleted();\n    for (Couple<File> pair : toBeDeleted) {\n      if (pair.getFirst().exists()) {\n        FileUtil.delete(pair.getSecond());\n      }\n    }\n  }","id":93530,"modified_method":"private void rollbackGroupForWc(@NotNull List<Change> changes,\n                                  @NotNull List<VcsException> exceptions,\n                                  @NotNull RollbackProgressListener listener) {\n    final UnversionedAndNotTouchedFilesGroupCollector collector = new UnversionedAndNotTouchedFilesGroupCollector();\n    final ChangesChecker checker = new ChangesChecker(mySvnVcs, collector);\n\n    checker.gather(changes);\n    exceptions.addAll(checker.getExceptions());\n\n    final Reverter reverter = new Reverter(mySvnVcs, listener, exceptions);\n    reverter.moveRenamesToTmp(collector);\n    reverter.revert(checker.getForAdds(), true);\n    reverter.revert(checker.getForDeletes(), true);\n    reverter.revert(checker.getForEdits(), false);\n    reverter.moveGroup();\n\n    for (Couple<File> pair : collector.getToBeDeleted()) {\n      if (pair.getFirst().exists()) {\n        FileUtil.delete(pair.getSecond());\n      }\n    }\n  }","commit_id":"fe4aae530f91e86ed9b3a16f6ee26683c03ca9eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void revertFileOrDir(File file) throws SVNException, VcsException {\n    Info info = mySvnVcs.getInfo(file);\n    if (info != null) {\n      if (info.isFile()) {\n        doRevert(file, false);\n      } else {\n        if (Info.SCHEDULE_ADD.equals(info.getSchedule())) {\n          doRevert(file, true);\n        } else {\n          boolean is17OrGreater = is17OrGreaterCopy(file, info);\n          if (is17OrGreater) {\n            doRevert(file, true);\n          } else {\n            // do update to restore missing directory.\n            mySvnVcs.getSvnKitManager().createUpdateClient().doUpdate(file, SVNRevision.HEAD, true);\n          }\n        }\n      }\n    } else {\n      throw new VcsException(\"Can not get 'svn info' for \" + file.getPath());\n    }\n  }","id":93531,"modified_method":"private void revertFileOrDir(@NotNull FilePath filePath) throws SVNException, VcsException {\n    File file = filePath.getIOFile();\n    Info info = mySvnVcs.getInfo(file);\n    if (info != null) {\n      if (info.isFile()) {\n        doRevert(file, false);\n      }\n      else if (Info.SCHEDULE_ADD.equals(info.getSchedule()) || is17OrGreaterCopy(file, info)) {\n        doRevert(file, true);\n      }\n      else {\n        // do update to restore missing directory.\n        mySvnVcs.getSvnKitManager().createUpdateClient().doUpdate(file, SVNRevision.HEAD, true);\n      }\n    }\n    else {\n      throw new VcsException(\"Can not get 'svn info' for \" + file.getPath());\n    }\n  }","commit_id":"fe4aae530f91e86ed9b3a16f6ee26683c03ca9eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private CherryPickData updateChangeListManager(@NotNull final VcsFullCommitDetails commit) {\n    final Collection<FilePath> paths = ChangesUtil.getPaths(commit.getChanges());\n    refreshChangedFiles(paths);\n    final String commitMessage = createCommitMessage(commit);\n    LocalChangeList changeList = createChangeListAfterUpdate(commit, paths, commitMessage);\n    return changeList == null ? null : new CherryPickData(changeList, commitMessage);\n  }","id":93532,"modified_method":"@Nullable\n  private CherryPickData updateChangeListManager(@NotNull final VcsFullCommitDetails commit) {\n    Collection<Change> changes = commit.getChanges();\n    RefreshVFsSynchronously.updateChanges(changes);\n    final String commitMessage = createCommitMessage(commit);\n    final Collection<FilePath> paths = ChangesUtil.getPaths(changes);\n    LocalChangeList changeList = createChangeListAfterUpdate(commit, paths, commitMessage);\n    return changeList == null ? null : new CherryPickData(changeList, commitMessage);\n  }","commit_id":"b9d2a2b1689381da61dc595a243ea4ecb91e40e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Parse changes from lines\n   *\n   *\n   * @param root    the git root\n   * @return a set of unmerged files\n   * @throws com.intellij.openapi.vcs.VcsException if the input format does not matches expected format\n   */\n  private List<VirtualFile> unmergedFiles(VirtualFile root) throws VcsException {\n    HashSet<VirtualFile> unmerged = new HashSet<VirtualFile>();\n    String rootPath = root.getPath();\n\n    GitRepository repository = myRepositoryManager.getRepositoryForRoot(root);\n    if (repository == null) {\n      LOG.error(\"Repository not found for root \" + root);\n      return Collections.emptyList();\n    }\n\n    GitCommandResult result = myGit.getUnmergedFiles(repository);\n    if (!result.success()) {\n      throw new VcsException(result.getErrorOutputAsJoinedString());\n    }\n\n    String output = StringUtil.join(result.getOutput(), \"\\n\");\n\n    LocalFileSystem lfs = myPlatformFacade.getLocalFileSystem();\n    for (StringScanner s = new StringScanner(output); s.hasMoreData();) {\n      if (s.isEol()) {\n        s.nextLine();\n        continue;\n      }\n      s.boundedToken('\\t');\n      final String relative = s.line();\n      String path = rootPath + \"/\" + GitUtil.unescapePath(relative);\n      VirtualFile file = lfs.refreshAndFindFileByPath(path);\n      if (file != null) {\n      // the file name is in the delete- or rename- conflict, so it is shown in the list of unmerged files,\n      // but the file itself doesn't exist. In that case we just ignore the file.\n        file.refresh(false, false);\n        unmerged.add(file);\n      }\n    }\n    if (unmerged.size() == 0) {\n      return Collections.emptyList();\n    }\n    else {\n      ArrayList<VirtualFile> rc = new ArrayList<VirtualFile>(unmerged.size());\n      rc.addAll(unmerged);\n      Collections.sort(rc, GitUtil.VIRTUAL_FILE_COMPARATOR);\n      return rc;\n    }\n  }","id":93533,"modified_method":"/**\n   * Parse changes from lines\n   *\n   *\n   * @param root    the git root\n   * @return a set of unmerged files\n   * @throws com.intellij.openapi.vcs.VcsException if the input format does not matches expected format\n   */\n  private List<VirtualFile> unmergedFiles(final VirtualFile root) throws VcsException {\n    GitRepository repository = myRepositoryManager.getRepositoryForRoot(root);\n    if (repository == null) {\n      LOG.error(\"Repository not found for root \" + root);\n      return Collections.emptyList();\n    }\n\n    GitCommandResult result = myGit.getUnmergedFiles(repository);\n    if (!result.success()) {\n      throw new VcsException(result.getErrorOutputAsJoinedString());\n    }\n\n    String output = StringUtil.join(result.getOutput(), \"\\n\");\n    HashSet<String> unmergedPaths = ContainerUtil.newHashSet();\n    for (StringScanner s = new StringScanner(output); s.hasMoreData();) {\n      if (s.isEol()) {\n        s.nextLine();\n        continue;\n      }\n      s.boundedToken('\\t');\n      String relative = s.line();\n      unmergedPaths.add(GitUtil.unescapePath(relative));\n    }\n\n    if (unmergedPaths.size() == 0) {\n      return Collections.emptyList();\n    }\n    else {\n      List<File> files = ContainerUtil.map(unmergedPaths, new Function<String, File>() {\n        @Override\n        public File fun(String path) {\n          return new File(root.getPath(), path);\n        }\n      });\n      return ContainerUtil.sorted(RefreshVFsSynchronously.refreshFiles(files), GitUtil.VIRTUAL_FILE_COMPARATOR);\n    }\n  }","commit_id":"b9d2a2b1689381da61dc595a243ea4ecb91e40e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void updateChangesImpl(final List<Change> changes, final ChangeWrapper wrapper) {\n    Collection<File> deletedOrReplaced = ContainerUtil.newHashSet();\n    Collection<File> toRefresh = ContainerUtil.newHashSet();\n    for (Change change : changes) {\n      if ((! wrapper.beforeNull(change)) && (wrapper.movedOrRenamedOrReplaced(change) || (wrapper.afterNull(change)))) {\n        deletedOrReplaced.add(wrapper.getBeforeFile(change));\n      } else if (!wrapper.beforeNull(change)) {\n        toRefresh.add(wrapper.getBeforeFile(change));\n      }\n      if ((! wrapper.afterNull(change)) &&\n          (wrapper.beforeNull(change) || (! Comparing.equal(change.getAfterRevision().getFile(), change.getBeforeRevision().getFile())))\n         ) {\n        toRefresh.add(wrapper.getAfterFile(change));\n      }\n    }\n\n    refreshFiles(toRefresh);\n    refreshDeletedOrReplaced(deletedOrReplaced);\n  }","id":93534,"modified_method":"private static void updateChangesImpl(final Collection<Change> changes, final ChangeWrapper wrapper) {\n    Collection<File> deletedOrReplaced = ContainerUtil.newHashSet();\n    Collection<File> toRefresh = ContainerUtil.newHashSet();\n    for (Change change : changes) {\n      if ((! wrapper.beforeNull(change)) && (wrapper.movedOrRenamedOrReplaced(change) || (wrapper.afterNull(change)))) {\n        deletedOrReplaced.add(wrapper.getBeforeFile(change));\n      } else if (!wrapper.beforeNull(change)) {\n        toRefresh.add(wrapper.getBeforeFile(change));\n      }\n      if ((! wrapper.afterNull(change)) &&\n          (wrapper.beforeNull(change) || (! Comparing.equal(change.getAfterRevision().getFile(), change.getBeforeRevision().getFile())))\n         ) {\n        toRefresh.add(wrapper.getAfterFile(change));\n      }\n    }\n\n    refreshFiles(toRefresh);\n    refreshDeletedOrReplaced(deletedOrReplaced);\n  }","commit_id":"b9d2a2b1689381da61dc595a243ea4ecb91e40e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void refreshFiles(@NotNull Collection<File> files) {\n    Collection<VirtualFile> filesToRefresh = ContainerUtil.newHashSet();\n    for (File file : files) {\n      VirtualFile vf = findFirstValidVirtualParent(file);\n      if (vf != null) {\n        filesToRefresh.add(vf);\n      }\n    }\n    VfsUtil.markDirtyAndRefresh(false, false, false, ArrayUtil.toObjectArray(filesToRefresh, VirtualFile.class));\n  }","id":93535,"modified_method":"@NotNull\n  public static Collection<VirtualFile> refreshFiles(@NotNull Collection<File> files) {\n    Collection<VirtualFile> filesToRefresh = ContainerUtil.newHashSet();\n    for (File file : files) {\n      VirtualFile vf = findFirstValidVirtualParent(file);\n      if (vf != null) {\n        filesToRefresh.add(vf);\n      }\n    }\n    VfsUtil.markDirtyAndRefresh(false, false, false, ArrayUtil.toObjectArray(filesToRefresh, VirtualFile.class));\n    return filesToRefresh;\n  }","commit_id":"b9d2a2b1689381da61dc595a243ea4ecb91e40e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void updateChanges(final List<Change> changes) {\n    updateChangesImpl(changes, DirectChangeWrapper.ourInstance);\n  }","id":93536,"modified_method":"public static void updateChanges(final Collection<Change> changes) {\n    updateChangesImpl(changes, DirectChangeWrapper.ourInstance);\n  }","commit_id":"b9d2a2b1689381da61dc595a243ea4ecb91e40e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Collection<File> getFiles() {\n    List<File> result = new ArrayList<File>();\n    for (Change change: getIncludedChanges()) {\n      final FilePath path = ChangesUtil.getFilePath(change);\n      final File file = path.getIOFile();\n      result.add(file);\n    }\n\n    return result;\n  }","id":93537,"modified_method":"@NotNull\n  @Override\n  public Collection<File> getFiles() {\n    return ContainerUtil.map(getIncludedChanges(), (change) -> ChangesUtil.getFilePath(change).getIOFile());\n  }","commit_id":"c4668c18653c94cea9131ad031e5e98e37b9b372","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Collection<VirtualFile> getVirtualFiles() {\n    List<VirtualFile> result = new ArrayList<VirtualFile>();\n    for (Change change: getIncludedChanges()) {\n      final FilePath path = ChangesUtil.getFilePath(change);\n      final VirtualFile vFile = path.getVirtualFile();\n      if (vFile != null) {\n        result.add(vFile);\n      }\n    }\n\n    return result;\n  }","id":93538,"modified_method":"@NotNull\n  @Override\n  public Collection<VirtualFile> getVirtualFiles() {\n    return ContainerUtil.mapNotNull(getIncludedChanges(), (change) -> ChangesUtil.getFilePath(change).getVirtualFile());\n  }","commit_id":"c4668c18653c94cea9131ad031e5e98e37b9b372","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Collection<Change> getSelectedChanges() {\n    return new ArrayList<Change>(getIncludedChanges());\n  }","id":93539,"modified_method":"@NotNull\n  @Override\n  public Collection<Change> getSelectedChanges() {\n    return ContainerUtil.newArrayList(getIncludedChanges());\n  }","commit_id":"c4668c18653c94cea9131ad031e5e98e37b9b372","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  protected JComponent createCenterPanel() {\n    mySplitter = new Splitter(true);\n    mySplitter.setHonorComponentsMinimumSize(true);\n    mySplitter.setFirstComponent(myBrowser);\n    mySplitter.setSecondComponent(myCommitMessageArea);\n    initMainSplitter();\n\n    myChangesInfoCalculator = new ChangeInfoCalculator();\n    myLegend = new CommitLegendPanel(myChangesInfoCalculator);\n\n    BorderLayoutPanel bottomPanel = JBUI.Panels.simplePanel().addToRight(myLegend.getComponent());\n    if (myShowVcsCommit && !myIsAlien && Registry.is(\"vcs.unversioned.files.in.commit\")) {\n      bottomPanel.addToLeft(createShowUnversionedFilesLabel());\n    }\n    myBrowser.getBottomPanel().add(bottomPanel, BorderLayout.SOUTH);\n\n    JPanel mainPanel;\n    if (myAdditionalOptionsPanel != null) {\n      JScrollPane optionsPane = ScrollPaneFactory.createScrollPane(myAdditionalOptionsPanel, true);\n      optionsPane.getVerticalScrollBar().setUnitIncrement(10);\n      if (!Registry.is(\"ide.scroll.new.layout\")) {\n        optionsPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n        optionsPane.getVerticalScrollBar().setUI(ButtonlessScrollBarUI.createTransparent());\n      }\n      JPanel infoPanel = JBUI.Panels.simplePanel(optionsPane).withBorder(JBUI.Borders.emptyLeft(10));\n\n      mainPanel = new JPanel(new MyOptionsLayout(mySplitter, infoPanel, 150));\n      mainPanel.add(mySplitter);\n      mainPanel.add(infoPanel);\n    } else {\n      mainPanel = mySplitter;\n    }\n\n    myWarningLabel.setBorder(JBUI.Borders.empty(5, 5, 0, 5));\n    final JPanel panel = new JPanel(new GridBagLayout());\n    panel.add(myWarningLabel, new GridBag().anchor(GridBagConstraints.NORTHWEST).weightx(1));\n\n    JPanel rootPane = JBUI.Panels.simplePanel(mainPanel).addToBottom(panel);\n\n    // TODO: there are no reason to use such heavy interface for a simple task.\n    myDetailsSplitter = new SplitterWithSecondHideable(true, \"Details\", rootPane,\n                                                       new OnOffListener<Integer>() {\n                                                         @Override\n                                                         public void on(Integer integer) {\n                                                           if (integer == 0) return;\n                                                           myDiffDetails.refresh();\n                                                           mySplitter.skipNextLayouting();\n                                                           myDetailsSplitter.getComponent().skipNextLayouting();\n                                                           final Dimension dialogSize = getSize();\n                                                           setSize(dialogSize.width, dialogSize.height + integer);\n                                                           repaint();\n                                                         }\n\n                                                         @Override\n                                                         public void off(Integer integer) {\n                                                           if (integer == 0) return;\n                                                           myDiffDetails.clear(); // TODO: we may want to keep it in memory\n                                                           mySplitter.skipNextLayouting();\n                                                           myDetailsSplitter.getComponent().skipNextLayouting();\n                                                           final Dimension dialogSize = getSize();\n                                                           setSize(dialogSize.width, dialogSize.height - integer);\n                                                           repaint();\n                                                         }\n                                                       }) {\n      @Override\n      protected RefreshablePanel createDetails() {\n        final JPanel panel = JBUI.Panels.simplePanel(myDiffDetails.getComponent());\n        return new RefreshablePanel() {\n          @Override\n          public boolean refreshDataSynch() {\n            return false;\n          }\n\n          @Override\n          public void dataChanged() {\n          }\n\n          @Override\n          public void refresh() {\n          }\n\n          @Override\n          public JPanel getPanel() {\n            return panel;\n          }\n\n          @Override\n          public void away() {\n          }\n\n          @Override\n          public boolean isStillValid(Object o) {\n            return false;\n          }\n\n          @Override\n          public void dispose() {\n          }\n        };\n      }\n\n      @Override\n      protected float getSplitterInitialProportion() {\n        float value = PropertiesComponent.getInstance().getFloat(DETAILS_SPLITTER_PROPORTION_OPTION, DETAILS_SPLITTER_PROPORTION_OPTION_DEFAULT);\n        if (value <= 0.05 || value >= 0.95) {\n          return DETAILS_SPLITTER_PROPORTION_OPTION_DEFAULT;\n        }\n        return value;\n      }\n    };\n\n    return myDetailsSplitter.getComponent();\n  }","id":93540,"modified_method":"@Override\n  @Nullable\n  protected JComponent createCenterPanel() {\n    mySplitter = new Splitter(true);\n    mySplitter.setHonorComponentsMinimumSize(true);\n    mySplitter.setFirstComponent(myBrowser);\n    mySplitter.setSecondComponent(myCommitMessageArea);\n    initMainSplitter();\n\n    myChangesInfoCalculator = new ChangeInfoCalculator();\n    myLegend = new CommitLegendPanel(myChangesInfoCalculator);\n\n    BorderLayoutPanel bottomPanel = JBUI.Panels.simplePanel().addToRight(myLegend.getComponent());\n    if (myShowVcsCommit && !myIsAlien && Registry.is(\"vcs.unversioned.files.in.commit\")) {\n      bottomPanel.addToLeft(createShowUnversionedFilesLabel());\n    }\n    myBrowser.getBottomPanel().add(bottomPanel, BorderLayout.SOUTH);\n\n    JPanel mainPanel;\n    if (myAdditionalOptionsPanel != null) {\n      JScrollPane optionsPane = ScrollPaneFactory.createScrollPane(myAdditionalOptionsPanel, true);\n      optionsPane.getVerticalScrollBar().setUnitIncrement(10);\n      if (!Registry.is(\"ide.scroll.new.layout\")) {\n        optionsPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n        optionsPane.getVerticalScrollBar().setUI(ButtonlessScrollBarUI.createTransparent());\n      }\n      JPanel infoPanel = JBUI.Panels.simplePanel(optionsPane).withBorder(JBUI.Borders.emptyLeft(10));\n\n      mainPanel = new JPanel(new MyOptionsLayout(mySplitter, infoPanel, 150));\n      mainPanel.add(mySplitter);\n      mainPanel.add(infoPanel);\n    } else {\n      mainPanel = mySplitter;\n    }\n\n    myWarningLabel.setBorder(JBUI.Borders.empty(5, 5, 0, 5));\n    final JPanel panel = new JPanel(new GridBagLayout());\n    panel.add(myWarningLabel, new GridBag().anchor(GridBagConstraints.NORTHWEST).weightx(1));\n\n    JPanel rootPane = JBUI.Panels.simplePanel(mainPanel).addToBottom(panel);\n\n    // TODO: there are no reason to use such heavy interface for a simple task.\n    myDetailsSplitter = new SplitterWithSecondHideable(true, \"Details\", rootPane,\n                                                       new OnOffListener<Integer>() {\n                                                         @Override\n                                                         public void on(Integer integer) {\n                                                           if (integer == 0) return;\n                                                           myDiffDetails.refresh();\n                                                           mySplitter.skipNextLayouting();\n                                                           myDetailsSplitter.getComponent().skipNextLayouting();\n                                                           final Dimension dialogSize = getSize();\n                                                           setSize(dialogSize.width, dialogSize.height + integer);\n                                                           repaint();\n                                                         }\n\n                                                         @Override\n                                                         public void off(Integer integer) {\n                                                           if (integer == 0) return;\n                                                           myDiffDetails.clear(); // TODO: we may want to keep it in memory\n                                                           mySplitter.skipNextLayouting();\n                                                           myDetailsSplitter.getComponent().skipNextLayouting();\n                                                           final Dimension dialogSize = getSize();\n                                                           setSize(dialogSize.width, dialogSize.height - integer);\n                                                           repaint();\n                                                         }\n                                                       }) {\n      @Override\n      protected RefreshablePanel createDetails() {\n        final JPanel panel = JBUI.Panels.simplePanel(myDiffDetails.getComponent());\n        return new RefreshablePanel() {\n          @Override\n          public boolean refreshDataSynch() {\n            return false;\n          }\n\n          @Override\n          public void dataChanged() {\n          }\n\n          @Override\n          public void refresh() {\n          }\n\n          @Override\n          public JPanel getPanel() {\n            return panel;\n          }\n\n          @Override\n          public void away() {\n          }\n\n          @Override\n          public boolean isStillValid(Object o) {\n            return false;\n          }\n\n          @Override\n          public void dispose() {\n          }\n        };\n      }\n\n      @Override\n      protected float getSplitterInitialProportion() {\n        float value = PropertiesComponent.getInstance().getFloat(DETAILS_SPLITTER_PROPORTION_OPTION, DETAILS_SPLITTER_PROPORTION_OPTION_DEFAULT);\n        return value <= 0.05 || value >= 0.95 ? DETAILS_SPLITTER_PROPORTION_OPTION_DEFAULT : value;\n      }\n    };\n\n    return myDetailsSplitter.getComponent();\n  }","commit_id":"c4668c18653c94cea9131ad031e5e98e37b9b372","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private CommitChangeListDialog(final Project project,\n                                 final List<Change> changes,\n                                 final LocalChangeList initialSelection,\n                                 final List<CommitExecutor> executors,\n                                 final boolean showVcsCommit, final LocalChangeList defaultChangeList,\n                                 final List<LocalChangeList> changeLists, @Nullable final AbstractVcs singleVcs, final boolean isAlien,\n                                 final String comment, @Nullable CommitResultHandler customResultHandler) {\n    super(project, true);\n    myCommitContext = new CommitContext();\n    myProject = project;\n    myVcsConfiguration = ObjectUtils.assertNotNull(VcsConfiguration.getInstance(myProject));\n    myExecutors = executors;\n    myShowVcsCommit = showVcsCommit;\n    myVcs = singleVcs;\n    myResultHandler = customResultHandler;\n    myListComments = new HashMap<String, String>();\n    myAdditionalData = new PseudoMap<Object, Object>();\n    myDiffDetails = new MyChangeProcessor(myProject);\n\n    if (!myShowVcsCommit && ((myExecutors == null) || myExecutors.size() == 0)) {\n      throw new IllegalArgumentException(\"nothing found to execute commit with\");\n    }\n\n    myAllOfDefaultChangeListChangesIncluded = new HashSet<Change>(changes).containsAll(new HashSet<Change>(defaultChangeList.getChanges()));\n\n    myIsAlien = isAlien;\n    if (isAlien) {\n      myBrowser = new AlienChangeListBrowser(project, changeLists, changes, initialSelection, true, true, singleVcs);\n    } else {\n      //noinspection unchecked\n      boolean showUnversioned =\n        myShowVcsCommit && myVcsConfiguration.SHOW_UNVERSIONED_FILES_WHILE_COMMIT && Registry.is(\"vcs.unversioned.files.in.commit\");\n      MultipleChangeListBrowser browser = new MultipleChangeListBrowser(project, changeLists, (List)changes, initialSelection, true, true,\n                                                                        new Runnable() {\n                                                                          @Override\n                                                                          public void run() {\n                                                                            updateWarning();\n                                                                          }\n                                                                        },\n                                                                        new Runnable() {\n                                                                          @Override\n                                                                          public void run() {\n                                                                            for (CheckinHandler handler : myHandlers) {\n                                                                              handler.includedChangesChanged();\n                                                                            }\n                                                                          }\n                                                                        }, showUnversioned) {\n        @Override\n        protected void afterDiffRefresh() {\n          myBrowser.rebuildList();\n          myBrowser.setDataIsDirty(false);\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              IdeFocusManager.findInstance().requestFocus(myBrowser.getViewer().getPreferredFocusedComponent(), true);\n            }\n          });\n        }\n      };\n      browser.addSelectedListChangeListener(new SelectedListChangeListener() {\n        @Override\n        public void selectedListChanged() {\n          updateOnListSelection();\n        }\n      });\n      myBrowser = browser;\n      myBrowser.setAlwayExpandList(false);\n    }\n    myBrowser.getViewer().addSelectionListener(new Runnable() {\n      @Override\n      public void run() {\n        SwingUtilities.invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            changeDetails();\n          }\n        });\n      }\n    });\n\n    myCommitMessageArea = new CommitMessage(project);\n\n    if (!myVcsConfiguration.CLEAR_INITIAL_COMMIT_MESSAGE) {\n      setComment(project, initialSelection, comment);\n    }\n\n    myBrowser.setDiffBottomComponent(new DiffCommitMessageEditor(this));\n\n    myActionName = VcsBundle.message(\"commit.dialog.title\");\n\n    Box optionsBox = Box.createVerticalBox();\n\n    boolean hasVcsOptions = false;\n    Box vcsCommitOptions = Box.createVerticalBox();\n    final List<AbstractVcs> vcses = new ArrayList<AbstractVcs>(getAffectedVcses());\n    Collections.sort(vcses, new Comparator<AbstractVcs>() {\n      @Override\n      public int compare(AbstractVcs o1, AbstractVcs o2) {\n        return o1.getKeyInstanceMethod().getName().compareToIgnoreCase(o2.getKeyInstanceMethod().getName());\n      }\n    });\n    myCheckinChangeListSpecificComponents = new HashMap<String, CheckinChangeListSpecificComponent>();\n    for (AbstractVcs vcs : vcses) {\n      final CheckinEnvironment checkinEnvironment = vcs.getCheckinEnvironment();\n      if (checkinEnvironment != null) {\n        final RefreshableOnComponent options = checkinEnvironment.createAdditionalOptionsPanel(this, myAdditionalData);\n        if (options != null) {\n          JPanel vcsOptions = new JPanel(new BorderLayout());\n          vcsOptions.add(options.getComponent(), BorderLayout.CENTER);\n          vcsOptions.setBorder(IdeBorderFactory.createTitledBorder(vcs.getDisplayName(), true));\n          vcsCommitOptions.add(vcsOptions);\n          myPerVcsOptionsPanels.put(vcs, vcsOptions);\n          myAdditionalComponents.add(options);\n          if (options instanceof CheckinChangeListSpecificComponent) {\n            myCheckinChangeListSpecificComponents.put(vcs.getName(), (CheckinChangeListSpecificComponent) options);\n          }\n          hasVcsOptions = true;\n        }\n      }\n    }\n\n    if (hasVcsOptions) {\n      vcsCommitOptions.add(Box.createVerticalGlue());\n      optionsBox.add(vcsCommitOptions);\n    }\n\n    boolean beforeVisible = false;\n    boolean afterVisible = false;\n    Box beforeBox = Box.createVerticalBox();\n    Box afterBox = Box.createVerticalBox();\n    for (BaseCheckinHandlerFactory factory : getCheckInFactories(project)) {\n      final CheckinHandler handler = factory.createHandler(this, myCommitContext);\n      if (CheckinHandler.DUMMY.equals(handler)) continue;\n\n      myHandlers.add(handler);\n      final RefreshableOnComponent beforePanel = handler.getBeforeCheckinConfigurationPanel();\n      if (beforePanel != null) {\n        beforeBox.add(beforePanel.getComponent());\n        beforeVisible = true;\n        myAdditionalComponents.add(beforePanel);\n      }\n\n      final RefreshableOnComponent afterPanel = handler.getAfterCheckinConfigurationPanel(getDisposable());\n      if (afterPanel != null) {\n        afterBox.add(afterPanel.getComponent());\n        afterVisible = true;\n        myAdditionalComponents.add(afterPanel);\n      }\n    }\n\n    final String actionName = getCommitActionName();\n    final String borderTitleName = actionName.replace(\"_\", \"\").replace(\"&\", \"\");\n    if (beforeVisible) {\n      beforeBox.add(Box.createVerticalGlue());\n      JPanel beforePanel = new JPanel(new BorderLayout());\n      beforePanel.add(beforeBox);\n      beforePanel.setBorder(IdeBorderFactory.createTitledBorder(\n        VcsBundle.message(\"border.standard.checkin.options.group\", borderTitleName), true));\n      optionsBox.add(beforePanel);\n    }\n\n    if (afterVisible) {\n      afterBox.add(Box.createVerticalGlue());\n      JPanel afterPanel = new JPanel(new BorderLayout());\n      afterPanel.add(afterBox);\n      afterPanel.setBorder(IdeBorderFactory.createTitledBorder(\n        VcsBundle.message(\"border.standard.after.checkin.options.group\", borderTitleName), true));\n      optionsBox.add(afterPanel);\n    }\n\n    if (hasVcsOptions || beforeVisible || afterVisible) {\n      optionsBox.add(Box.createVerticalGlue());\n      myAdditionalOptionsPanel = new JPanel(new BorderLayout());\n      myAdditionalOptionsPanel.add(optionsBox, BorderLayout.NORTH);\n    }\n    else {\n      myAdditionalOptionsPanel = null;\n    }\n\n    myOkActionText = actionName;\n\n    if (myShowVcsCommit) {\n      setTitle(myActionName);\n    }\n    else {\n      setTitle(trimEllipsis(myExecutors.get(0).getActionText()));\n    }\n\n    restoreState();\n\n    if (myExecutors != null) {\n      myExecutorActions = new CommitExecutorAction[myExecutors.size()];\n\n      for (int i = 0; i < myExecutors.size(); i++) {\n        final CommitExecutor commitExecutor = myExecutors.get(i);\n        myExecutorActions[i] = new CommitExecutorAction(commitExecutor, i == 0 && !myShowVcsCommit);\n      }\n    } else {\n      myExecutorActions = null;\n    }\n\n    myWarningLabel = new JLabel();\n    myWarningLabel.setUI(new MultiLineLabelUI());\n    myWarningLabel.setForeground(JBColor.RED);\n\n    updateWarning();\n\n    init();\n    updateButtons();\n    updateVcsOptionsVisibility();\n\n    updateOnListSelection();\n    myCommitMessageArea.requestFocusInMessage();\n\n    for (EditChangelistSupport support : Extensions.getExtensions(EditChangelistSupport.EP_NAME, project)) {\n      support.installSearch(myCommitMessageArea.getEditorField(), myCommitMessageArea.getEditorField());\n    }\n\n    showDetailsIfSaved();\n  }","id":93541,"modified_method":"private CommitChangeListDialog(@NotNull Project project,\n                                 @NotNull List<Change> changes,\n                                 final LocalChangeList initialSelection,\n                                 final List<CommitExecutor> executors,\n                                 final boolean showVcsCommit,\n                                 @NotNull LocalChangeList defaultChangeList,\n                                 final List<LocalChangeList> changeLists,\n                                 @Nullable final AbstractVcs singleVcs,\n                                 final boolean isAlien,\n                                 final String comment,\n                                 @Nullable CommitResultHandler customResultHandler) {\n    super(project, true);\n    myCommitContext = new CommitContext();\n    myProject = project;\n    myVcsConfiguration = ObjectUtils.assertNotNull(VcsConfiguration.getInstance(myProject));\n    myExecutors = executors;\n    myShowVcsCommit = showVcsCommit;\n    myVcs = singleVcs;\n    myResultHandler = customResultHandler;\n    myListComments = new HashMap<String, String>();\n    myAdditionalData = new PseudoMap<Object, Object>();\n    myDiffDetails = new MyChangeProcessor(myProject);\n\n    if (!myShowVcsCommit && ContainerUtil.isEmpty(myExecutors)) {\n      throw new IllegalArgumentException(\"nothing found to execute commit with\");\n    }\n\n    myAllOfDefaultChangeListChangesIncluded =\n      ContainerUtil.newHashSet(changes).containsAll(ContainerUtil.newHashSet(defaultChangeList.getChanges()));\n\n    myIsAlien = isAlien;\n    if (isAlien) {\n      myBrowser = new AlienChangeListBrowser(project, changeLists, changes, initialSelection, true, true, singleVcs);\n    } else {\n      //noinspection unchecked\n      boolean showUnversioned =\n        myShowVcsCommit && myVcsConfiguration.SHOW_UNVERSIONED_FILES_WHILE_COMMIT && Registry.is(\"vcs.unversioned.files.in.commit\");\n      MultipleChangeListBrowser browser = new MultipleChangeListBrowser(project, changeLists, (List)changes, initialSelection, true, true,\n                                                                        new Runnable() {\n                                                                          @Override\n                                                                          public void run() {\n                                                                            updateWarning();\n                                                                          }\n                                                                        },\n                                                                        new Runnable() {\n                                                                          @Override\n                                                                          public void run() {\n                                                                            for (CheckinHandler handler : myHandlers) {\n                                                                              handler.includedChangesChanged();\n                                                                            }\n                                                                          }\n                                                                        }, showUnversioned) {\n        @Override\n        protected void afterDiffRefresh() {\n          myBrowser.rebuildList();\n          myBrowser.setDataIsDirty(false);\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              IdeFocusManager.findInstance().requestFocus(myBrowser.getViewer().getPreferredFocusedComponent(), true);\n            }\n          });\n        }\n      };\n      browser.addSelectedListChangeListener(new SelectedListChangeListener() {\n        @Override\n        public void selectedListChanged() {\n          updateOnListSelection();\n        }\n      });\n      myBrowser = browser;\n      myBrowser.setAlwayExpandList(false);\n    }\n    myBrowser.getViewer().addSelectionListener(new Runnable() {\n      @Override\n      public void run() {\n        SwingUtilities.invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            changeDetails();\n          }\n        });\n      }\n    });\n\n    myCommitMessageArea = new CommitMessage(project);\n\n    if (!myVcsConfiguration.CLEAR_INITIAL_COMMIT_MESSAGE) {\n      setComment(initialSelection, comment);\n    }\n\n    myBrowser.setDiffBottomComponent(new DiffCommitMessageEditor(this));\n\n    myActionName = VcsBundle.message(\"commit.dialog.title\");\n\n    Box optionsBox = Box.createVerticalBox();\n\n    boolean hasVcsOptions = false;\n    Box vcsCommitOptions = Box.createVerticalBox();\n    final List<AbstractVcs> vcses = ContainerUtil.sorted(getAffectedVcses(), new Comparator<AbstractVcs>() {\n      @Override\n      public int compare(@NotNull AbstractVcs o1, @NotNull AbstractVcs o2) {\n        return o1.getKeyInstanceMethod().getName().compareToIgnoreCase(o2.getKeyInstanceMethod().getName());\n      }\n    });\n    myCheckinChangeListSpecificComponents = ContainerUtil.newHashMap();\n    for (AbstractVcs vcs : vcses) {\n      final CheckinEnvironment checkinEnvironment = vcs.getCheckinEnvironment();\n      if (checkinEnvironment != null) {\n        final RefreshableOnComponent options = checkinEnvironment.createAdditionalOptionsPanel(this, myAdditionalData);\n        if (options != null) {\n          JPanel vcsOptions = new JPanel(new BorderLayout());\n          vcsOptions.add(options.getComponent(), BorderLayout.CENTER);\n          vcsOptions.setBorder(IdeBorderFactory.createTitledBorder(vcs.getDisplayName(), true));\n          vcsCommitOptions.add(vcsOptions);\n          myPerVcsOptionsPanels.put(vcs, vcsOptions);\n          myAdditionalComponents.add(options);\n          if (options instanceof CheckinChangeListSpecificComponent) {\n            myCheckinChangeListSpecificComponents.put(vcs.getName(), (CheckinChangeListSpecificComponent) options);\n          }\n          hasVcsOptions = true;\n        }\n      }\n    }\n\n    if (hasVcsOptions) {\n      vcsCommitOptions.add(Box.createVerticalGlue());\n      optionsBox.add(vcsCommitOptions);\n    }\n\n    boolean beforeVisible = false;\n    boolean afterVisible = false;\n    Box beforeBox = Box.createVerticalBox();\n    Box afterBox = Box.createVerticalBox();\n    for (BaseCheckinHandlerFactory factory : getCheckInFactories(project)) {\n      final CheckinHandler handler = factory.createHandler(this, myCommitContext);\n      if (CheckinHandler.DUMMY.equals(handler)) continue;\n\n      myHandlers.add(handler);\n      final RefreshableOnComponent beforePanel = handler.getBeforeCheckinConfigurationPanel();\n      if (beforePanel != null) {\n        beforeBox.add(beforePanel.getComponent());\n        beforeVisible = true;\n        myAdditionalComponents.add(beforePanel);\n      }\n\n      final RefreshableOnComponent afterPanel = handler.getAfterCheckinConfigurationPanel(getDisposable());\n      if (afterPanel != null) {\n        afterBox.add(afterPanel.getComponent());\n        afterVisible = true;\n        myAdditionalComponents.add(afterPanel);\n      }\n    }\n\n    final String actionName = getCommitActionName();\n    final String borderTitleName = actionName.replace(\"_\", \"\").replace(\"&\", \"\");\n    if (beforeVisible) {\n      beforeBox.add(Box.createVerticalGlue());\n      JPanel beforePanel = new JPanel(new BorderLayout());\n      beforePanel.add(beforeBox);\n      beforePanel.setBorder(IdeBorderFactory.createTitledBorder(\n        VcsBundle.message(\"border.standard.checkin.options.group\", borderTitleName), true));\n      optionsBox.add(beforePanel);\n    }\n\n    if (afterVisible) {\n      afterBox.add(Box.createVerticalGlue());\n      JPanel afterPanel = new JPanel(new BorderLayout());\n      afterPanel.add(afterBox);\n      afterPanel.setBorder(IdeBorderFactory.createTitledBorder(\n        VcsBundle.message(\"border.standard.after.checkin.options.group\", borderTitleName), true));\n      optionsBox.add(afterPanel);\n    }\n\n    if (hasVcsOptions || beforeVisible || afterVisible) {\n      optionsBox.add(Box.createVerticalGlue());\n      myAdditionalOptionsPanel = new JPanel(new BorderLayout());\n      myAdditionalOptionsPanel.add(optionsBox, BorderLayout.NORTH);\n    }\n    else {\n      myAdditionalOptionsPanel = null;\n    }\n\n    myOkActionText = actionName;\n\n    if (myShowVcsCommit) {\n      setTitle(myActionName);\n    }\n    else {\n      setTitle(trimEllipsis(myExecutors.get(0).getActionText()));\n    }\n\n    restoreState();\n\n    if (myExecutors != null) {\n      myExecutorActions = new CommitExecutorAction[myExecutors.size()];\n\n      for (int i = 0; i < myExecutors.size(); i++) {\n        final CommitExecutor commitExecutor = myExecutors.get(i);\n        myExecutorActions[i] = new CommitExecutorAction(commitExecutor, i == 0 && !myShowVcsCommit);\n      }\n    } else {\n      myExecutorActions = null;\n    }\n\n    myWarningLabel = new JLabel();\n    myWarningLabel.setUI(new MultiLineLabelUI());\n    myWarningLabel.setForeground(JBColor.RED);\n\n    updateWarning();\n\n    init();\n    updateButtons();\n    updateVcsOptionsVisibility();\n\n    updateOnListSelection();\n    myCommitMessageArea.requestFocusInMessage();\n\n    for (EditChangelistSupport support : Extensions.getExtensions(EditChangelistSupport.EP_NAME, project)) {\n      support.installSearch(myCommitMessageArea.getEditorField(), myCommitMessageArea.getEditorField());\n    }\n\n    showDetailsIfSaved();\n  }","commit_id":"c4668c18653c94cea9131ad031e5e98e37b9b372","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean checkComment() {\n    if (myVcsConfiguration.FORCE_NON_EMPTY_COMMENT && (getCommitMessage().length() == 0)) {\n      int requestForCheckin = Messages.showYesNoDialog(VcsBundle.message(\"confirmation.text.check.in.with.empty.comment\"),\n                                                       VcsBundle.message(\"confirmation.title.check.in.with.empty.comment\"),\n                                                       Messages.getWarningIcon());\n      return requestForCheckin == Messages.YES;\n    }\n    else {\n      return true;\n    }\n  }","id":93542,"modified_method":"private boolean checkComment() {\n    if (myVcsConfiguration.FORCE_NON_EMPTY_COMMENT && getCommitMessage().isEmpty()) {\n      int requestForCheckin = Messages.showYesNoDialog(VcsBundle.message(\"confirmation.text.check.in.with.empty.comment\"),\n                                                       VcsBundle.message(\"confirmation.title.check.in.with.empty.comment\"),\n                                                       Messages.getWarningIcon());\n      return requestForCheckin == Messages.YES;\n    }\n    else {\n      return true;\n    }\n  }","commit_id":"c4668c18653c94cea9131ad031e5e98e37b9b372","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Set<AbstractVcs> getAffectedVcses() {\n    return myShowVcsCommit ? myBrowser.getAffectedVcses() : Collections.<AbstractVcs>emptySet();\n  }","id":93543,"modified_method":"@NotNull\n  public Set<AbstractVcs> getAffectedVcses() {\n    return myShowVcsCommit ? myBrowser.getAffectedVcses() : Collections.emptySet();\n  }","commit_id":"c4668c18653c94cea9131ad031e5e98e37b9b372","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setComment(Project project, LocalChangeList initialSelection, String comment) {\n    if (comment != null) {\n      setCommitMessage(comment);\n      myLastKnownComment = comment;\n      myLastSelectedListName = initialSelection == null ? myBrowser.getSelectedChangeList().getName() : initialSelection.getName();\n    } else {\n      updateComment();\n\n      if (StringUtil.isEmptyOrSpaces(myCommitMessageArea.getComment())) {\n        setCommitMessage(myVcsConfiguration.LAST_COMMIT_MESSAGE);\n        final String messageFromVcs = getInitialMessageFromVcs();\n        if (messageFromVcs != null) {\n          myCommitMessageArea.setText(messageFromVcs);\n        }\n      }\n    }\n  }","id":93544,"modified_method":"private void setComment(LocalChangeList initialSelection, String comment) {\n    if (comment != null) {\n      setCommitMessage(comment);\n      myLastKnownComment = comment;\n      myLastSelectedListName = initialSelection == null ? myBrowser.getSelectedChangeList().getName() : initialSelection.getName();\n    } else {\n      updateComment();\n\n      if (StringUtil.isEmptyOrSpaces(myCommitMessageArea.getComment())) {\n        setCommitMessage(myVcsConfiguration.LAST_COMMIT_MESSAGE);\n        final String messageFromVcs = getInitialMessageFromVcs();\n        if (messageFromVcs != null) {\n          myCommitMessageArea.setText(messageFromVcs);\n        }\n      }\n    }\n  }","commit_id":"c4668c18653c94cea9131ad031e5e98e37b9b372","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Collection<VirtualFile> getRoots() {\n    Set<VirtualFile> result = new HashSet<VirtualFile>();\n    for (Change change : myBrowser.getCurrentDisplayedChanges()) {\n      final FilePath filePath = ChangesUtil.getFilePath(change);\n      VirtualFile root = ProjectLevelVcsManager.getInstance(myProject).getVcsRootFor(filePath);\n      if (root != null) {\n        result.add(root);\n      }\n    }\n    return result;\n  }","id":93545,"modified_method":"@NotNull\n  @Override\n  public Collection<VirtualFile> getRoots() {\n    ProjectLevelVcsManager vcsManager = ProjectLevelVcsManager.getInstance(myProject);\n\n    return ContainerUtil\n      .map2SetNotNull(myBrowser.getCurrentDisplayedChanges(), (change) -> vcsManager.getVcsRootFor(ChangesUtil.getFilePath(change)));\n  }","commit_id":"c4668c18653c94cea9131ad031e5e98e37b9b372","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean vcsIsAffected(String name) {\n    // tod +- performance?\n    if (! ProjectLevelVcsManager.getInstance(myProject).checkVcsIsActive(name)) return false;\n    for (AbstractVcs vcs : myBrowser.getAffectedVcses()) {\n      if (Comparing.equal(vcs.getName(), name)) return true;\n    }\n    return false;\n  }","id":93546,"modified_method":"@Override\n  public boolean vcsIsAffected(String name) {\n    // tod +- performance?\n    if (! ProjectLevelVcsManager.getInstance(myProject).checkVcsIsActive(name)) return false;\n\n    return ContainerUtil.exists(myBrowser.getAffectedVcses(), (vcs) -> Comparing.equal(vcs.getName(), name));\n  }","commit_id":"c4668c18653c94cea9131ad031e5e98e37b9b372","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String toString() {\n    graph.setCurrentGraphInThreadLocal();\n\n    if (getLabel() == null)\n      return StringFactory.E + StringFactory.L_BRACKET + getId() + StringFactory.R_BRACKET + StringFactory.L_BRACKET\n          + getVertex(Direction.OUT).getId() + StringFactory.ARROW + getVertex(Direction.IN).getId() + StringFactory.R_BRACKET;\n\n    return StringFactory.edgeString(this);\n  }","id":93547,"modified_method":"public String toString() {\n    if (graph != null)\n      graph.setCurrentGraphInThreadLocal();\n\n    if (getLabel() == null)\n      return StringFactory.E + StringFactory.L_BRACKET + getId() + StringFactory.R_BRACKET + StringFactory.L_BRACKET\n          + getVertex(Direction.OUT).getId() + StringFactory.ARROW + getVertex(Direction.IN).getId() + StringFactory.R_BRACKET;\n\n    return StringFactory.edgeString(this);\n  }","commit_id":"7f648be82f4da35931875967f0a2dc253b89e641","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * Removes the reference to the current graph instance to let working offline.\n   * \n   * @return Current object to allow chained calls.\n   */\n  public OrientElement detach() {\n    // EARLY UNMARSHALL FIELDS\n    getRecord().fieldNames();\n    // COPY GRAPH SETTINGS TO WORK OFFLINE\n    settings = graph.settings.copy();\n    graph = null;\n    return this;\n  }","id":93548,"modified_method":"/**\n   * Removes the reference to the current graph instance to let working offline.\n   * \n   * @return Current object to allow chained calls.\n   */\n  public OrientElement detach() {\n    // EARLY UNMARSHALL FIELDS\n    getRecord().setLazyLoad(false);\n    getRecord().fieldNames();\n    // COPY GRAPH SETTINGS TO WORK OFFLINE\n    settings = graph.settings.copy();\n    graph = null;\n    return this;\n  }","commit_id":"7f648be82f4da35931875967f0a2dc253b89e641","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected OrientElement(final OrientBaseGraph rawGraph, final OIdentifiable iRawElement) {\n    graph = rawGraph;\n    rawElement = iRawElement;\n    settings = graph.settings;\n  }","id":93549,"modified_method":"protected OrientElement(final OrientBaseGraph rawGraph, final OIdentifiable iRawElement) {\n    graph = rawGraph;\n    rawElement = iRawElement;\n    if (graph != null)\n      settings = graph.settings;\n  }","commit_id":"7f648be82f4da35931875967f0a2dc253b89e641","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OrientEdge addEdge(String label, final OrientVertex inVertex, final String iClassName, final String iClusterName,\n      final Object... fields) {\n    if (inVertex == null)\n      throw new IllegalArgumentException(\"destination vertex is null\");\n\n    checkIfAttached();\n    setCurrentGraphInThreadLocal();\n    graph.autoStartTransaction();\n\n    // TEMPORARY STATIC LOCK TO AVOID MT PROBLEMS AGAINST OMVRBTreeRID\n    final ODocument outDocument = getRecord();\n    final ODocument inDocument = ((OrientVertex) inVertex).getRecord();\n\n    final OrientEdge edge;\n    OIdentifiable to;\n    OIdentifiable from;\n\n    label = OrientBaseGraph.encodeClassName(label);\n    if (label == null && iClassName != null)\n      // RETRO-COMPATIBILITY WITH THE SYNTAX CLASS:<CLASS-NAME>\n      label = OrientBaseGraph.encodeClassName(iClassName);\n\n    final String outFieldName = getConnectionFieldName(Direction.OUT, label, settings.useVertexFieldsForEdgeLabels);\n    final String inFieldName = getConnectionFieldName(Direction.IN, label, settings.useVertexFieldsForEdgeLabels);\n\n    // since the label for the edge can potentially get re-assigned\n    // before being pushed into the OrientEdge, the\n    // null check has to go here.\n    if (label == null)\n      throw ExceptionFactory.edgeLabelCanNotBeNull();\n\n    if (canCreateDynamicEdge(outDocument, inDocument, outFieldName, inFieldName, fields, label)) {\n      // CREATE A LIGHTWEIGHT DYNAMIC EDGE\n      from = rawElement;\n      to = inDocument;\n      edge = new OrientEdge(graph, from, to, label);\n    } else {\n      // CREATE THE EDGE DOCUMENT TO STORE FIELDS TOO\n      edge = new OrientEdge(graph, label, fields);\n\n      if (settings.keepInMemoryReferences)\n        edge.getRecord().fields(OrientBaseGraph.CONNECTION_OUT, rawElement.getIdentity(), OrientBaseGraph.CONNECTION_IN,\n            inDocument.getIdentity());\n      else\n        edge.getRecord().fields(OrientBaseGraph.CONNECTION_OUT, rawElement, OrientBaseGraph.CONNECTION_IN, inDocument);\n\n      from = (OIdentifiable) edge.getRecord();\n      to = (OIdentifiable) edge.getRecord();\n    }\n\n    if (settings.keepInMemoryReferences) {\n      // USES REFERENCES INSTEAD OF DOCUMENTS\n      from = from.getIdentity();\n      to = to.getIdentity();\n    }\n\n    // OUT-VERTEX ---> IN-VERTEX/EDGE\n    createLink(outDocument, to, outFieldName);\n\n    // IN-VERTEX ---> OUT-VERTEX/EDGE\n    createLink(inDocument, from, inFieldName);\n\n    edge.save(iClusterName);\n    inDocument.save();\n    outDocument.save();\n\n    return edge;\n\n  }","id":93550,"modified_method":"public OrientEdge addEdge(String label, final OrientVertex inVertex, final String iClassName, final String iClusterName,\n      final Object... fields) {\n    if (inVertex == null)\n      throw new IllegalArgumentException(\"destination vertex is null\");\n\n    if (graph != null) {\n      setCurrentGraphInThreadLocal();\n      graph.autoStartTransaction();\n    }\n\n    // TEMPORARY STATIC LOCK TO AVOID MT PROBLEMS AGAINST OMVRBTreeRID\n    final ODocument outDocument = getRecord();\n    final ODocument inDocument = ((OrientVertex) inVertex).getRecord();\n\n    final OrientEdge edge;\n    OIdentifiable to;\n    OIdentifiable from;\n\n    label = OrientBaseGraph.encodeClassName(label);\n    if (label == null && iClassName != null)\n      // RETRO-COMPATIBILITY WITH THE SYNTAX CLASS:<CLASS-NAME>\n      label = OrientBaseGraph.encodeClassName(iClassName);\n\n    final String outFieldName = getConnectionFieldName(Direction.OUT, label, settings.useVertexFieldsForEdgeLabels);\n    final String inFieldName = getConnectionFieldName(Direction.IN, label, settings.useVertexFieldsForEdgeLabels);\n\n    // since the label for the edge can potentially get re-assigned\n    // before being pushed into the OrientEdge, the\n    // null check has to go here.\n    if (label == null)\n      throw ExceptionFactory.edgeLabelCanNotBeNull();\n\n    if (canCreateDynamicEdge(outDocument, inDocument, outFieldName, inFieldName, fields, label)) {\n      // CREATE A LIGHTWEIGHT DYNAMIC EDGE\n      from = rawElement;\n      to = inDocument;\n      edge = new OrientEdge(graph, from, to, label);\n    } else {\n      // CREATE THE EDGE DOCUMENT TO STORE FIELDS TOO\n      edge = new OrientEdge(graph, label, fields);\n\n      if (settings.keepInMemoryReferences)\n        edge.getRecord().fields(OrientBaseGraph.CONNECTION_OUT, rawElement.getIdentity(), OrientBaseGraph.CONNECTION_IN,\n            inDocument.getIdentity());\n      else\n        edge.getRecord().fields(OrientBaseGraph.CONNECTION_OUT, rawElement, OrientBaseGraph.CONNECTION_IN, inDocument);\n\n      from = (OIdentifiable) edge.getRecord();\n      to = (OIdentifiable) edge.getRecord();\n    }\n\n    if (settings.keepInMemoryReferences) {\n      // USES REFERENCES INSTEAD OF DOCUMENTS\n      from = from.getIdentity();\n      to = to.getIdentity();\n    }\n\n    // OUT-VERTEX ---> IN-VERTEX/EDGE\n    createLink(outDocument, to, outFieldName);\n\n    // IN-VERTEX ---> OUT-VERTEX/EDGE\n    createLink(inDocument, from, inFieldName);\n\n    if (graph != null) {\n      edge.save(iClusterName);\n      inDocument.save();\n      outDocument.save();\n    }\n    return edge;\n\n  }","commit_id":"7f648be82f4da35931875967f0a2dc253b89e641","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public String toString() {\n    graph.setCurrentGraphInThreadLocal();\n\n    final String clsName = getRecord().getClassName();\n\n    if (clsName.equals(OrientVertexType.CLASS_NAME))\n      return StringFactory.vertexString(this);\n\n    return StringFactory.V + \"(\" + clsName + \")\" + StringFactory.L_BRACKET + getId() + StringFactory.R_BRACKET;\n  }","id":93551,"modified_method":"public String toString() {\n    if (graph != null)\n      graph.setCurrentGraphInThreadLocal();\n\n    final String clsName = getRecord().getClassName();\n\n    if (clsName.equals(OrientVertexType.CLASS_NAME))\n      return StringFactory.vertexString(this);\n\n    return StringFactory.V + \"(\" + clsName + \")\" + StringFactory.L_BRACKET + getId() + StringFactory.R_BRACKET;\n  }","commit_id":"7f648be82f4da35931875967f0a2dc253b89e641","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private static void navigate(@NotNull Project project, @NotNull PsiElement symbolType) {\n    PsiElement element = symbolType.getNavigationElement();\n    assert element != null;\n    VirtualFile file = element.getContainingFile().getVirtualFile();\n    OpenFileDescriptor descriptor=new OpenFileDescriptor(project, file, element.getTextOffset());\n    FileEditorManager.getInstance(project).openTextEditor(descriptor, true);\n  }","id":93552,"modified_method":"private static void navigate(@NotNull Project project, @NotNull PsiElement symbolType) {\n    PsiElement element = symbolType.getNavigationElement();\n    assert element != null;\n    VirtualFile file = element.getContainingFile().getVirtualFile();\n    if (file != null) {\n      OpenFileDescriptor descriptor = new OpenFileDescriptor(project, file, element.getTextOffset());\n      FileEditorManager.getInstance(project).openTextEditor(descriptor, true);\n    }\n  }","commit_id":"59264fea6dfce5623cff7d0f2babc7f80c217248","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void showAnnotation(FileAnnotation annotation, VirtualFile file, AbstractVcs vcs, int line) {\n    OpenFileDescriptor openFileDescriptor = new OpenFileDescriptor(myProject, file, line, 0);\n    Editor editor = FileEditorManager.getInstance(myProject).openTextEditor(openFileDescriptor, true);\n    if (editor == null) {\n      Messages.showMessageDialog(VcsBundle.message(\"message.text.cannot.open.editor\", file.getPresentableUrl()),\n                                 VcsBundle.message(\"message.title.cannot.open.editor\"), Messages.getInformationIcon());\n      return;\n    }\n\n    AnnotateToggleAction.doAnnotate(editor, myProject, file, annotation, vcs);\n  }","id":93553,"modified_method":"public void showAnnotation(FileAnnotation annotation, VirtualFile file, AbstractVcs vcs, int line) {\n    TextEditor textFileEditor;\n    FileEditor fileEditor = FileEditorManager.getInstance(myProject).getSelectedEditor(file);\n    if (fileEditor instanceof TextEditor) {\n      textFileEditor = ((TextEditor)fileEditor);\n    }\n    else {\n      FileEditor[] editors = FileEditorManager.getInstance(myProject).getEditors(file);\n      textFileEditor = ContainerUtil.findInstance(editors, TextEditor.class);\n    }\n\n    Editor editor;\n    if (textFileEditor != null) {\n      editor = textFileEditor.getEditor();\n    }\n    else {\n      OpenFileDescriptor openFileDescriptor = new OpenFileDescriptor(myProject, file, line, 0);\n      editor = FileEditorManager.getInstance(myProject).openTextEditor(openFileDescriptor, true);\n    }\n\n    if (editor == null) {\n      Messages.showMessageDialog(VcsBundle.message(\"message.text.cannot.open.editor\", file.getPresentableUrl()),\n                                 VcsBundle.message(\"message.title.cannot.open.editor\"), Messages.getInformationIcon());\n      return;\n    }\n\n    AnnotateToggleAction.doAnnotate(editor, myProject, file, annotation, vcs);\n  }","commit_id":"cff64461286f9fbf4903e17322a77da4dc51a269","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(@NotNull final AnActionEvent e) {\n    final VcsFileRevision fileRevision = getFileRevision(e);\n    final VirtualFile file = getFile(e);\n    final AbstractVcs vcs = getVcs(e);\n    assert vcs != null;\n    assert file != null;\n    assert fileRevision != null;\n\n    final Editor editor = getEditor(e);\n    final CharSequence oldContent = editor == null ? null : editor.getDocument().getImmutableCharSequence();\n    final int oldLine = getAnnotatedLine(e);\n\n    final AnnotationProvider annotationProvider = vcs.getCachingAnnotationProvider();\n    assert annotationProvider != null;\n\n    final Ref<FileAnnotation> fileAnnotationRef = new Ref<FileAnnotation>();\n    final Ref<Integer> newLineRef = new Ref<Integer>();\n    final Ref<VcsException> exceptionRef = new Ref<VcsException>();\n\n    VcsAnnotateUtil.getBackgroundableLock(vcs.getProject(), file).lock();\n\n    ProgressManager.getInstance().run(new Task.Backgroundable(vcs.getProject(), VcsBundle.message(\"retrieving.annotations\"), true) {\n      public void run(@NotNull ProgressIndicator indicator) {\n        try {\n          FileAnnotation fileAnnotation = annotationProvider.annotate(file, fileRevision);\n\n          int newLine = translateLine(oldContent, fileAnnotation.getAnnotatedContent(), oldLine);\n\n          fileAnnotationRef.set(fileAnnotation);\n          newLineRef.set(newLine);\n        }\n        catch (VcsException e) {\n          exceptionRef.set(e);\n        }\n      }\n\n      @Override\n      public void onFinished() {\n        VcsAnnotateUtil.getBackgroundableLock(vcs.getProject(), file).unlock();\n      }\n\n      @Override\n      public void onSuccess() {\n        if (!exceptionRef.isNull()) {\n          AbstractVcsHelper.getInstance(myProject).showError(exceptionRef.get(), VcsBundle.message(\"operation.name.annotate\"));\n        }\n        if (fileAnnotationRef.isNull()) return;\n\n        AbstractVcsHelper.getInstance(myProject).showAnnotation(fileAnnotationRef.get(), file, vcs, newLineRef.get());\n      }\n    });\n  }","id":93554,"modified_method":"@Override\n  public void actionPerformed(@NotNull final AnActionEvent e) {\n    final VcsFileRevision fileRevision = getFileRevision(e);\n    final VirtualFile file = getFile(e);\n    final AbstractVcs vcs = getVcs(e);\n    assert vcs != null;\n    assert file != null;\n    assert fileRevision != null;\n\n    final Editor editor = getEditor(e);\n    final CharSequence oldContent = editor == null ? null : editor.getDocument().getImmutableCharSequence();\n    final int oldLine = getAnnotatedLine(e);\n\n    final AnnotationProvider annotationProvider = vcs.getCachingAnnotationProvider();\n    assert annotationProvider != null;\n\n    final Ref<FileAnnotation> fileAnnotationRef = new Ref<FileAnnotation>();\n    final Ref<Integer> newLineRef = new Ref<Integer>();\n    final Ref<VcsException> exceptionRef = new Ref<VcsException>();\n\n    VcsAnnotateUtil.getBackgroundableLock(vcs.getProject(), file).lock();\n\n    Semaphore semaphore = new Semaphore(0);\n    AtomicBoolean shouldOpenEditorInSync = new AtomicBoolean(true);\n\n    ProgressManager.getInstance().run(new Task.Backgroundable(vcs.getProject(), VcsBundle.message(\"retrieving.annotations\"), true) {\n      public void run(@NotNull ProgressIndicator indicator) {\n        try {\n          FileAnnotation fileAnnotation = annotationProvider.annotate(file, fileRevision);\n\n          int newLine = translateLine(oldContent, fileAnnotation.getAnnotatedContent(), oldLine);\n\n          fileAnnotationRef.set(fileAnnotation);\n          newLineRef.set(newLine);\n\n          shouldOpenEditorInSync.set(false);\n          semaphore.release();\n        }\n        catch (VcsException e) {\n          exceptionRef.set(e);\n        }\n      }\n\n      @Override\n      public void onFinished() {\n        VcsAnnotateUtil.getBackgroundableLock(vcs.getProject(), file).unlock();\n      }\n\n      @Override\n      public void onSuccess() {\n        if (!exceptionRef.isNull()) {\n          AbstractVcsHelper.getInstance(myProject).showError(exceptionRef.get(), VcsBundle.message(\"operation.name.annotate\"));\n        }\n        if (fileAnnotationRef.isNull()) return;\n\n        AbstractVcsHelper.getInstance(myProject).showAnnotation(fileAnnotationRef.get(), file, vcs, newLineRef.get());\n      }\n    });\n\n    try {\n      semaphore.tryAcquire(ProgressWindow.DEFAULT_PROGRESS_DIALOG_POSTPONE_TIME_MILLIS, TimeUnit.MILLISECONDS);\n\n      // We want to let Backgroundable task open editor if it was fast enough.\n      // This will remove blinking on editor opening (step 1 - editor opens, step 2 - annotations are shown).\n      if (shouldOpenEditorInSync.get()) {\n        CharSequence content = LoadTextUtil.loadText(file);\n        int newLine = translateLine(oldContent, content, oldLine);\n\n        OpenFileDescriptor openFileDescriptor = new OpenFileDescriptor(vcs.getProject(), file, newLine, 0);\n        FileEditorManager.getInstance(vcs.getProject()).openTextEditor(openFileDescriptor, true);\n      }\n    }\n    catch (InterruptedException ignore) {\n    }\n  }","commit_id":"cff64461286f9fbf4903e17322a77da4dc51a269","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void navigateTo(@NotNull UsageInfo info, boolean requestFocus) {\n    int offset = info.getNavigationOffset();\n    VirtualFile file = info.getVirtualFile();\n    Project project = info.getProject();\n    FileEditorManager.getInstance(project).openTextEditor(new OpenFileDescriptor(project, file, offset), requestFocus);\n  }","id":93555,"modified_method":"public static void navigateTo(@NotNull UsageInfo info, boolean requestFocus) {\n    int offset = info.getNavigationOffset();\n    VirtualFile file = info.getVirtualFile();\n    Project project = info.getProject();\n    if (file != null) {\n      FileEditorManager.getInstance(project).openTextEditor(new OpenFileDescriptor(project, file, offset), requestFocus);\n    }\n  }","commit_id":"e8fcb93386f2a302fe3a548105dfd7f8d101d9bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int compoundWherePrint(HTable table, HBaseAdmin admin) {\n    int count = 0;\n    try {\n      if (this.version != 0) {\n        // A number of versions has been specified.\n        byte[][] result = null;\n        ParsedColumns parsedColumns = getColumns(admin, false);\n        boolean multiple = parsedColumns.isMultiple() || this.version > 1;\n        formatter.header(multiple ? HEADER_COLUMN_CELL : null);\n        for (Text column : parsedColumns.getColumns()) {\n          if (this.timestamp != 0) {\n            result = table.get(this.rowKey, column, this.timestamp, this.version);\n          } else {\n            result = table.get(this.rowKey, column, this.version);\n          }\n          for (int ii = 0; result != null && ii < result.length; ii++) {\n            if (multiple) {\n              formatter.row(new String[] { column.toString(),\n                  toString(column, result[ii]) });\n            } else {\n              formatter.row(new String[] { toString(column, result[ii]) });\n            }\n            count++;\n          }\n        }\n      } else {\n        formatter.header(isMultiple() ? HEADER_COLUMN_CELL : null);\n        for (Map.Entry<Text, byte[]> e : table.getRow(this.rowKey).entrySet()) {\n          Text key = e.getKey();\n          String keyStr = key.toString();\n          if (!this.columns.contains(STAR) && !this.columns.contains(keyStr)) {\n            continue;\n          }\n          String cellData = toString(key, e.getValue());\n          if (isMultiple()) {\n            formatter.row(new String[] { key.toString(), cellData });\n          } else {\n            formatter.row(new String[] { cellData });\n          }\n          count++;\n        }\n      }\n      formatter.footer();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return count;\n  }","id":93556,"modified_method":"private int compoundWherePrint(HTable table, HBaseAdmin admin) {\n    int count = 0;\n    try {\n      if (this.version != 0) {\n        // A number of versions has been specified.\n        byte[][] result = null;\n        ParsedColumns parsedColumns = getColumns(admin, false);\n        boolean multiple = parsedColumns.isMultiple() || this.version > 1;\n        for (Text column : parsedColumns.getColumns()) {\n          if(count == 0) {\n            formatter.header(multiple ? HEADER_COLUMN_CELL : null);\n          }\n          if (this.timestamp != 0) {\n            result = table.get(this.rowKey, column, this.timestamp, this.version);\n          } else {\n            result = table.get(this.rowKey, column, this.version);\n          }\n          for (int ii = 0; result != null && ii < result.length; ii++) {\n            if (multiple) {\n              formatter.row(new String[] { column.toString(),\n                  toString(column, result[ii]) });\n            } else {\n              formatter.row(new String[] { toString(column, result[ii]) });\n            }\n            count++;\n          }\n        }\n      } else {\n        for (Map.Entry<Text, byte[]> e : table.getRow(this.rowKey).entrySet()) {\n          if(count == 0) {\n            formatter.header(isMultiple() ? HEADER_COLUMN_CELL : null);\n          }\n          Text key = e.getKey();\n          String keyStr = key.toString();\n          if (!this.columns.contains(STAR) && !this.columns.contains(keyStr)) {\n            continue;\n          }\n          String cellData = toString(key, e.getValue());\n          if (isMultiple()) {\n            formatter.row(new String[] { key.toString(), cellData });\n          } else {\n            formatter.row(new String[] { cellData });\n          }\n          count++;\n        }\n      }\n      \n      if(count == 0 && Shell.HTML_OPTION != null) {\n        formatter.header(isMultiple() ? HEADER_COLUMN_CELL : null);\n      }\n      formatter.footer();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return count;\n  }","commit_id":"91de46cac15c5784aac2aac51bc6b6f54b125e04","url":"https://github.com/apache/hbase"},{"original_method":"private int scanPrint(HTable table, HBaseAdmin admin) {\n    int count = 0;\n    HScannerInterface scan = null;\n    try {\n      ParsedColumns parsedColumns = getColumns(admin, true);\n      Text[] cols = parsedColumns.getColumns().toArray(new Text[] {});\n      if (this.timestamp == 0) {\n        scan = table.obtainScanner(cols, this.rowKey);\n      } else {\n        scan = table.obtainScanner(cols, this.rowKey, this.timestamp);\n      }\n      HStoreKey key = new HStoreKey();\n      TreeMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n      // If only one column in query, then don't print out the column.\n      formatter.header((parsedColumns.isMultiple()) ? HEADER : HEADER_ROW_CELL);\n      while (scan.next(key, results) && checkLimit(count)) {\n        Text r = key.getRow();\n        for (Text columnKey : results.keySet()) {\n          String cellData = toString(columnKey, results.get(columnKey));\n          if (parsedColumns.isMultiple()) {\n            formatter.row(new String[] { r.toString(), columnKey.toString(),\n                cellData });\n          } else {\n            // Don't print out the column since only one specified in query.\n            formatter.row(new String[] { r.toString(), cellData });\n          }\n          count++;\n          if (this.limit > 0 && count >= this.limit) {\n            break;\n          }\n        }\n        // Clear results else subsequent results polluted w/ previous finds.\n        results.clear();\n      }\n      formatter.footer();\n      scan.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return count;\n  }","id":93557,"modified_method":"private int scanPrint(HTable table, HBaseAdmin admin) {\n    int count = 0;\n    HScannerInterface scan = null;\n    try {\n      ParsedColumns parsedColumns = getColumns(admin, true);\n      Text[] cols = parsedColumns.getColumns().toArray(new Text[] {});\n      if (this.timestamp == 0) {\n        scan = table.obtainScanner(cols, this.rowKey);\n      } else {\n        scan = table.obtainScanner(cols, this.rowKey, this.timestamp);\n      }\n      HStoreKey key = new HStoreKey();\n      TreeMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n      // If only one column in query, then don't print out the column.\n      while (scan.next(key, results) && checkLimit(count)) {\n        if(count == 0) {\n          formatter.header((parsedColumns.isMultiple()) ? HEADER : HEADER_ROW_CELL);\n        }\n        Text r = key.getRow();\n        for (Text columnKey : results.keySet()) {\n          String cellData = toString(columnKey, results.get(columnKey));\n          if (parsedColumns.isMultiple()) {\n            formatter.row(new String[] { r.toString(), columnKey.toString(),\n                cellData });\n          } else {\n            // Don't print out the column since only one specified in query.\n            formatter.row(new String[] { r.toString(), cellData });\n          }\n          count++;\n          if (this.limit > 0 && count >= this.limit) {\n            break;\n          }\n        }\n        // Clear results else subsequent results polluted w/ previous finds.\n        results.clear();\n      }\n      \n      if(count == 0 && Shell.HTML_OPTION != null) {\n        formatter.header((parsedColumns.isMultiple()) ? HEADER : HEADER_ROW_CELL);\n      }\n      \n      formatter.footer();\n      scan.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return count;\n  }","commit_id":"91de46cac15c5784aac2aac51bc6b6f54b125e04","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Main method\n   * \n   * @param args not used\n   * @throws IOException\n   */\n  public static void main(String args[]) throws IOException {\n    argumentParsing(args);\n    HBaseConfiguration conf = new HBaseConfiguration();\n    ConsoleReader reader = new ConsoleReader();\n    System.setSecurityManager(new ShellSecurityManager());\n    reader.setBellEnabled(conf.getBoolean(\"hbaseshell.jline.bell.enabled\",\n        DEFAULT_BELL_ENABLED));\n    Writer out = new OutputStreamWriter(System.out, \"UTF-8\");\n    TableFormatter tableFormater = new TableFormatterFactory(out, conf).get();\n    if (MASTER_ADDRESS != null) {\n      conf.set(\"hbase.master\", MASTER_ADDRESS.substring(9, MASTER_ADDRESS.length()));\n    }\n    if (HTML_OPTION != null) {\n      tableFormater = new HtmlTableFormatter(out);\n      System.out.println(\"--html\");\n    }\n\n    HelpCommand help = new HelpCommand(out, tableFormater);\n    if (args.length == 0 || !args[0].equals(\"7\")) {\n      help.printVersion();\n    }\n    StringBuilder queryStr = new StringBuilder();\n    String extendedLine;\n    while ((extendedLine = reader.readLine(getPrompt(queryStr))) != null) {\n      if (isEndOfCommand(extendedLine)) {\n        queryStr.append(\" \" + extendedLine);\n        long start = System.currentTimeMillis();\n        Parser parser = new Parser(queryStr.toString(), out, tableFormater);\n        ReturnMsg rs = null;\n        try {\n          Command cmd = parser.terminatedCommand();\n          if (cmd != null) {\n            rs = cmd.execute(conf);\n          }\n        } catch (ParseException pe) {\n          String[] msg = pe.getMessage().split(\"[\\n]\");\n          System.out.println(\"Syntax error : Type 'help;' for usage.\\nMessage : \"\n              + msg[0]);\n        } catch (TokenMgrError te) {\n          String[] msg = te.getMessage().split(\"[\\n]\");\n          System.out.println(\"Lexical error : Type 'help;' for usage.\\nMessage : \"\n              + msg[0]);\n        }\n\n        long end = System.currentTimeMillis();\n        if (rs != null && rs.getType() > -1)\n          System.out.println(rs.getMsg()\n              + executeTime((rs.getType() == 1), start, end));\n        queryStr = new StringBuilder();\n      } else {\n        queryStr.append(\" \" + extendedLine);\n      }\n    }\n    System.out.println();\n  }","id":93558,"modified_method":"/**\n   * Main method\n   * \n   * @param args not used\n   * @throws IOException\n   */\n  public static void main(String args[]) throws IOException {\n    argumentParsing(args);\n    if (args.length != 0) {\n      if (args[0].equals(\"--help\") || args[0].equals(\"-h\")) {\n        System.out\n            .println(\"Usage: ./bin/hbase shell [--master:master_address:port] [--html]\\n\");\n        System.exit(1);\n      }\n    }\n    \n    HBaseConfiguration conf = new HBaseConfiguration();\n    ConsoleReader reader = new ConsoleReader();\n    System.setSecurityManager(new ShellSecurityManager());\n    reader.setBellEnabled(conf.getBoolean(\"hbaseshell.jline.bell.enabled\",\n        DEFAULT_BELL_ENABLED));\n    Writer out = new OutputStreamWriter(System.out, \"UTF-8\");\n    TableFormatter tableFormater = new TableFormatterFactory(out, conf).get();\n    if (MASTER_ADDRESS != null) {\n      conf.set(\"hbase.master\", MASTER_ADDRESS.substring(9, MASTER_ADDRESS.length()));\n    }\n    if (HTML_OPTION != null) {\n      tableFormater = new HtmlTableFormatter(out);\n    }\n\n    HelpCommand help = new HelpCommand(out, tableFormater);\n    if (args.length == 0 || !args[0].equals(String.valueOf(Shell.RELAUNCH_FLAG))) {\n      help.printVersion();\n    }\n    StringBuilder queryStr = new StringBuilder();\n    String extendedLine;\n    while ((extendedLine = reader.readLine(getPrompt(queryStr))) != null) {\n      if (isEndOfCommand(extendedLine)) {\n        queryStr.append(\" \" + extendedLine);\n        long start = System.currentTimeMillis();\n        Parser parser = new Parser(queryStr.toString(), out, tableFormater);\n        ReturnMsg rs = null;\n        try {\n          Command cmd = parser.terminatedCommand();\n          if (cmd != null) {\n            rs = cmd.execute(conf);\n          }\n        } catch (ParseException pe) {\n          String[] msg = pe.getMessage().split(\"[\\n]\");\n          System.out.println(\"Syntax error : Type 'help;' for usage.\\nMessage : \"\n              + msg[0]);\n        } catch (TokenMgrError te) {\n          String[] msg = te.getMessage().split(\"[\\n]\");\n          System.out.println(\"Lexical error : Type 'help;' for usage.\\nMessage : \"\n              + msg[0]);\n        }\n\n        long end = System.currentTimeMillis();\n        if (rs != null && rs.getType() > -1)\n          System.out.println(rs.getMsg()\n              + executeTime((rs.getType() == 1), start, end));\n        queryStr = new StringBuilder();\n      } else {\n        queryStr.append(\" \" + extendedLine);\n      }\n    }\n    System.out.println();\n  }","commit_id":"91de46cac15c5784aac2aac51bc6b6f54b125e04","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Override SecurityManager#checkExit. This throws an ExitException(status)\n   * exception.\n   * \n   * @param status the exit status\n   */\n  @SuppressWarnings(\"static-access\")\n  public void checkExit(int status) {\n    if (status != 9999) {\n      // throw new ExitException(status);\n\n      // I didn't figure out How can catch the ExitException in shell main.\n      // So, I just Re-launching the shell.\n      Shell shell = new Shell();\n      String[] args = new String[] { String.valueOf(7) };\n      try {\n        shell.main(args);\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }","id":93559,"modified_method":"/**\n   * Override SecurityManager#checkExit. This throws an ExitException(status)\n   * exception.\n   * \n   * @param status the exit status\n   */\n  @SuppressWarnings(\"static-access\")\n  public void checkExit(int status) {\n    if (status != 9999) {\n      // throw new ExitException(status);\n\n      // I didn't figure out How can catch the ExitException in shell main.\n      // So, I just Re-launching the shell.\n      Shell shell = new Shell();\n\n      List<String> argList = new ArrayList<String>();\n      argList.add(String.valueOf(Shell.RELAUNCH_FLAG));\n      if(Shell.HTML_OPTION != null)\n        argList.add(Shell.HTML_OPTION);\n      if(Shell.MASTER_ADDRESS != null)\n        argList.add(Shell.MASTER_ADDRESS);\n\n      try {\n        shell.main(argList.toArray(new String[] {}));\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }","commit_id":"91de46cac15c5784aac2aac51bc6b6f54b125e04","url":"https://github.com/apache/hbase"},{"original_method":"private DeploymentInfo createServletConfig() throws StartException {\n        try {\n            mergedMetaData.resolveAnnotations();\n            final DeploymentInfo d = new DeploymentInfo();\n            d.setContextPath(contextPath);\n            if (mergedMetaData.getDescriptionGroup() != null) {\n                d.setDisplayName(mergedMetaData.getDescriptionGroup().getDisplayName());\n            }\n            d.setDeploymentName(deploymentName);\n            try {\n                //TODO: make the caching limits configurable\n                d.setResourceManager(new CachingResourceManager(100, 10 * 1024 * 1024, bufferCacheInjectedValue.getOptionalValue(), new FileResourceManager(Paths.get(deploymentRoot.getPhysicalFile().getAbsolutePath())), -1));\n            } catch (IOException e) {\n                throw new StartException(e);\n            }\n            d.setClassLoader(module.getClassLoader());\n            final String servletVersion = mergedMetaData.getServletVersion();\n            if (servletVersion != null) {\n                d.setMajorVersion(Integer.parseInt(servletVersion.charAt(0) + \"\"));\n                d.setMinorVersion(Integer.parseInt(servletVersion.charAt(2) + \"\"));\n            } else {\n                d.setMajorVersion(3);\n                d.setMinorVersion(1);\n            }\n\n            //for 2.2 apps we do not require a leading / in path mappings\n            boolean is22OrOlder;\n            if (d.getMajorVersion() == 1) {\n                is22OrOlder = true;\n            } else if (d.getMajorVersion() == 2) {\n                is22OrOlder = d.getMinorVersion() < 3;\n            } else {\n                is22OrOlder = false;\n            }\n\n            HashMap<String, TagLibraryInfo> tldInfo = createTldsInfo(tldsMetaData, sharedTlds, classReflectionIndex, componentRegistry, d);\n            HashMap<String, JspPropertyGroup> propertyGroups = createJspConfig(mergedMetaData);\n\n            JspServletBuilder.setupDeployment(d, propertyGroups, tldInfo, new UndertowJSPInstanceManager(injectionContainer));\n            d.setJspConfigDescriptor(new JspConfigDescriptorImpl(tldInfo.values(), propertyGroups.values()));\n            d.setDefaultServletConfig(new DefaultServletConfig(true, Collections.<String>emptySet()));\n\n            //default JSP servlet\n            final ServletInfo jspServlet = new ServletInfo(\"Default JSP Servlet\", JspServlet.class)\n                    .addMapping(\"*.jsp\")\n                    .addMapping(\"*.jspx\")\n                    .addInitParam(\"development\", \"false\"); //todo: make configurable\n            d.addServlet(jspServlet);\n\n            final Set<String> jspPropertyGroupMappings = propertyGroups.keySet();\n            for (final String mapping : jspPropertyGroupMappings) {\n                jspServlet.addMapping(mapping);\n            }\n\n            d.setClassIntrospecter(new ComponentClassIntrospector(componentRegistry));\n\n            final Map<String, List<ServletMappingMetaData>> servletMappings = new HashMap<>();\n\n            if (mergedMetaData.getServletMappings() != null) {\n                for (final ServletMappingMetaData mapping : mergedMetaData.getServletMappings()) {\n                    List<ServletMappingMetaData> list = servletMappings.get(mapping.getServletName());\n                    if (list == null) {\n                        servletMappings.put(mapping.getServletName(), list = new ArrayList<>());\n                    }\n                    list.add(mapping);\n                }\n            }\n            final Set<String> seenMappings = new HashSet<>(jspPropertyGroupMappings);\n            if (mergedMetaData.getServlets() != null) {\n                for (final JBossServletMetaData servlet : mergedMetaData.getServlets()) {\n                    final ServletInfo s;\n\n                    if (servlet.getJspFile() != null) {\n                        //TODO: real JSP support\n                        s = new ServletInfo(servlet.getName(), JspServlet.class);\n                        s.addHandlerChainWrapper(new JspFileWrapper(servlet.getJspFile()));\n                    } else {\n                        Class<? extends Servlet> servletClass = (Class<? extends Servlet>) classReflectionIndex.classIndex(servlet.getServletClass()).getModuleClass();\n                        ComponentRegistry.ComponentManagedReferenceFactory creator = componentRegistry.getComponentsByClass().get(servletClass);\n                        if (creator != null) {\n                            InstanceFactory<Servlet> factory = createInstanceFactory(creator);\n                            s = new ServletInfo(servlet.getName(), servletClass, factory);\n                        } else {\n                            s = new ServletInfo(servlet.getName(), servletClass);\n                        }\n                    }\n                    s.setAsyncSupported(servlet.isAsyncSupported())\n                            .setJspFile(servlet.getJspFile())\n                            .setEnabled(servlet.isEnabled());\n                    if (servlet.getRunAs() != null) {\n                        s.setRunAs(servlet.getRunAs().getRoleName());\n                    }\n                    if (servlet.getLoadOnStartupSet()) {//todo why not cleanup api and just use int everywhere\n                        s.setLoadOnStartup(servlet.getLoadOnStartupInt());\n                    }\n\n                    List<ServletMappingMetaData> mappings = servletMappings.get(servlet.getName());\n                    if (mappings != null) {\n                        for (ServletMappingMetaData mapping : mappings) {\n                            for (String pattern : mapping.getUrlPatterns()) {\n                                if (is22OrOlder && !pattern.startsWith(\"*\") && !pattern.startsWith(\"/\")) {\n                                    pattern = \"/\" + pattern;\n                                }\n                                if (!seenMappings.contains(pattern)) {\n                                    s.addMapping(pattern);\n                                    seenMappings.add(pattern);\n                                }\n                            }\n                        }\n                    }\n                    if (servlet.getInitParam() != null) {\n                        for (ParamValueMetaData initParam : servlet.getInitParam()) {\n                            if (!s.getInitParams().containsKey(initParam.getParamName())) {\n                                s.addInitParam(initParam.getParamName(), initParam.getParamValue());\n                            }\n                        }\n                    }\n                    if (servlet.getServletSecurity() != null) {\n                        ServletSecurityInfo securityInfo = new ServletSecurityInfo();\n                        s.setServletSecurityInfo(securityInfo);\n                        securityInfo.setEmptyRoleSemantic(servlet.getServletSecurity().getEmptyRoleSemantic() == EmptyRoleSemanticType.PERMIT ? PERMIT : DENY)\n                                .setTransportGuaranteeType(transportGuaranteeType(servlet.getServletSecurity().getTransportGuarantee()))\n                                .addRolesAllowed(servlet.getServletSecurity().getRolesAllowed());\n                        if (servlet.getServletSecurity().getHttpMethodConstraints() != null) {\n                            for (HttpMethodConstraintMetaData method : servlet.getServletSecurity().getHttpMethodConstraints()) {\n                                securityInfo.addHttpMethodSecurityInfo(\n                                        new HttpMethodSecurityInfo()\n                                                .setEmptyRoleSemantic(method.getEmptyRoleSemantic() == EmptyRoleSemanticType.PERMIT ? PERMIT : DENY)\n                                                .setTransportGuaranteeType(transportGuaranteeType(method.getTransportGuarantee()))\n                                                .addRolesAllowed(method.getRolesAllowed())\n                                                .setMethod(method.getMethod()));\n                            }\n                        }\n                    }\n                    if (servlet.getSecurityRoleRefs() != null) {\n                        for (final SecurityRoleRefMetaData ref : servlet.getSecurityRoleRefs()) {\n                            s.addSecurityRoleRef(ref.getRoleName(), ref.getRoleLink());\n                        }\n                    }\n\n                    d.addServlet(s);\n                }\n            }\n\n            if (mergedMetaData.getFilters() != null) {\n                for (final FilterMetaData filter : mergedMetaData.getFilters()) {\n                    Class<? extends Filter> filterClass = (Class<? extends Filter>) classReflectionIndex.classIndex(filter.getFilterClass()).getModuleClass();\n                    ComponentRegistry.ComponentManagedReferenceFactory creator = componentRegistry.getComponentsByClass().get(filterClass);\n                    FilterInfo f;\n                    if (creator != null) {\n                        InstanceFactory<Filter> instanceFactory = createInstanceFactory(creator);\n                        f = new FilterInfo(filter.getName(), filterClass, instanceFactory);\n                    } else {\n                        f = new FilterInfo(filter.getName(), filterClass);\n                    }\n                    f.setAsyncSupported(filter.isAsyncSupported());\n                    d.addFilter(f);\n\n                    if (filter.getInitParam() != null) {\n                        for (ParamValueMetaData initParam : filter.getInitParam()) {\n                            f.addInitParam(initParam.getParamName(), initParam.getParamValue());\n                        }\n                    }\n                }\n            }\n            if (mergedMetaData.getFilterMappings() != null) {\n                for (final FilterMappingMetaData mapping : mergedMetaData.getFilterMappings()) {\n                    if (mapping.getUrlPatterns() != null) {\n                        for (String url : mapping.getUrlPatterns()) {\n                            if (is22OrOlder && !url.startsWith(\"*\") && !url.startsWith(\"/\")) {\n                                url = \"/\" + url;\n                            }\n                            if (mapping.getDispatchers() != null && !mapping.getDispatchers().isEmpty()) {\n                                for (DispatcherType dispatcher : mapping.getDispatchers()) {\n\n                                    d.addFilterUrlMapping(mapping.getFilterName(), url, javax.servlet.DispatcherType.valueOf(dispatcher.name()));\n                                }\n                            } else {\n                                d.addFilterUrlMapping(mapping.getFilterName(), url, javax.servlet.DispatcherType.REQUEST);\n                            }\n                        }\n                    }\n                    if (mapping.getServletNames() != null) {\n                        for (String servletName : mapping.getServletNames()) {\n                            if (mapping.getDispatchers() != null && !mapping.getDispatchers().isEmpty()) {\n                                for (DispatcherType dispatcher : mapping.getDispatchers()) {\n                                    d.addFilterServletNameMapping(mapping.getFilterName(), servletName, javax.servlet.DispatcherType.valueOf(dispatcher.name()));\n                                }\n                            } else {\n                                d.addFilterServletNameMapping(mapping.getFilterName(), servletName, javax.servlet.DispatcherType.REQUEST);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (scisMetaData != null && scisMetaData.getHandlesTypes() != null) {\n                for (final Map.Entry<ServletContainerInitializer, Set<Class<?>>> sci : scisMetaData.getHandlesTypes().entrySet()) {\n                    final ImmediateInstanceFactory<ServletContainerInitializer> instanceFactory = new ImmediateInstanceFactory<>(sci.getKey());\n                    d.addServletContainerInitalizer(new ServletContainerInitializerInfo(sci.getKey().getClass(), instanceFactory, sci.getValue()));\n                }\n            }\n\n            if (mergedMetaData.getListeners() != null) {\n                for (ListenerMetaData listener : mergedMetaData.getListeners()) {\n                    addListener(classReflectionIndex, componentRegistry, d, listener);\n                }\n\n            }\n            if (mergedMetaData.getContextParams() != null) {\n                for (ParamValueMetaData param : mergedMetaData.getContextParams()) {\n                    d.addInitParameter(param.getParamName(), param.getParamValue());\n                }\n            }\n\n            if (mergedMetaData.getWelcomeFileList() != null &&\n                    mergedMetaData.getWelcomeFileList().getWelcomeFiles() != null) {\n                List<String> welcomeFiles = mergedMetaData.getWelcomeFileList().getWelcomeFiles();\n                for(String file : welcomeFiles) {\n                    if(file.startsWith(\"/\")) {\n                        d.addWelcomePages(file.substring(1));\n                    } else {\n                        d.addWelcomePages(file);\n                    }\n                }\n            } else {\n                d.addWelcomePages(\"index.html\", \"index.htm\", \"index.jsp\");\n            }\n\n            if (mergedMetaData.getErrorPages() != null) {\n                for (final ErrorPageMetaData page : mergedMetaData.getErrorPages()) {\n                    final ErrorPage errorPage;\n                    if (page.getExceptionType() == null || page.getExceptionType().isEmpty()) {\n                        errorPage = new ErrorPage(page.getLocation(), Integer.parseInt(page.getErrorCode()));\n                    } else {\n                        errorPage = new ErrorPage(page.getLocation(), (Class<? extends Throwable>) classReflectionIndex.classIndex(page.getExceptionType()).getModuleClass());\n                    }\n                    d.addErrorPages(errorPage);\n                }\n            }\n\n            if (mergedMetaData.getMimeMappings() != null) {\n                for (final MimeMappingMetaData mapping : mergedMetaData.getMimeMappings()) {\n                    d.addMimeMapping(new MimeMapping(mapping.getExtension(), mapping.getMimeType()));\n                }\n            }\n\n            Set<String> securityRoleNames = mergedMetaData.getSecurityRoleNames();\n            if (mergedMetaData.getSecurityConstraints() != null) {\n                for (SecurityConstraintMetaData constraint : mergedMetaData.getSecurityConstraints()) {\n                    SecurityConstraint securityConstraint = new SecurityConstraint()\n                            .setTransportGuaranteeType(transportGuaranteeType(constraint.getTransportGuarantee()));\n\n                    List<String> roleNames = constraint.getRoleNames();\n                    if (constraint.getAuthConstraint() == null) {\n                        // no auth constraint means we permit the empty roles\n                        securityConstraint.setEmptyRoleSemantic(PERMIT);\n                    } else if (roleNames.size() == 1 && roleNames.contains(\"*\") && securityRoleNames.contains(\"*\")) {\n                        // AS7-6932 - Trying to do a * to * mapping which JBossWeb passed through, for Undertow enable\n                        // authentication only mode.\n                        // TODO - AS7-6933 - Revisit workaround added to allow switching between JBoss Web and Undertow.\n                        securityConstraint.setEmptyRoleSemantic(AUTHENTICATE);\n                    } else {\n                        securityConstraint.addRolesAllowed(roleNames);\n                    }\n\n                    if (constraint.getResourceCollections() != null) {\n                        for (final WebResourceCollectionMetaData resourceCollection : constraint.getResourceCollections()) {\n                            securityConstraint.addWebResourceCollection(new WebResourceCollection()\n                                    .addHttpMethods(resourceCollection.getHttpMethods())\n                                    .addHttpMethodOmissions(resourceCollection.getHttpMethodOmissions())\n                                    .addUrlPatterns(resourceCollection.getUrlPatterns()));\n                        }\n                    }\n                    d.addSecurityConstraint(securityConstraint);\n                }\n            }\n            final LoginConfigMetaData loginConfig = mergedMetaData.getLoginConfig();\n            if (loginConfig != null) {\n                String authMethod = authMethod(loginConfig.getAuthMethod());\n                if (loginConfig.getFormLoginConfig() != null) {\n                    d.setLoginConfig(new LoginConfig(authMethod, loginConfig.getRealmName(), loginConfig.getFormLoginConfig().getLoginPage(), loginConfig.getFormLoginConfig().getErrorPage()));\n                } else {\n                    d.setLoginConfig(new LoginConfig(authMethod, loginConfig.getRealmName()));\n                }\n            }\n\n            d.addSecurityRoles(mergedMetaData.getSecurityRoleNames());\n\n\n            d.addOuterHandlerChainWrapper(SecurityContextCreationHandler.wrapper(securityDomain));\n            d.addInnerHandlerChainWrapper(SecurityContextAssociationHandler.wrapper(mergedMetaData.getPrincipalVersusRolesMap(), mergedMetaData.getRunAsIdentity(), securityContextId));\n\n            // Setup an deployer configured ServletContext attributes\n            for (ServletContextAttribute attribute : attributes) {\n                d.addServletContextAttribute(attribute.getName(), attribute.getValue());\n            }\n\n            if (mergedMetaData.getLocalEncodings() != null &&\n                    mergedMetaData.getLocalEncodings().getMappings() != null) {\n                for (LocaleEncodingMetaData locale : mergedMetaData.getLocalEncodings().getMappings()) {\n                    d.addLocaleCharsetMapping(locale.getLocale(), locale.getEncoding());\n                }\n            }\n\n            return d;\n        } catch (ClassNotFoundException e) {\n            throw new StartException(e);\n        }\n    }","id":93560,"modified_method":"private DeploymentInfo createServletConfig() throws StartException {\n        try {\n            mergedMetaData.resolveAnnotations();\n            final DeploymentInfo d = new DeploymentInfo();\n            d.setContextPath(contextPath);\n            if (mergedMetaData.getDescriptionGroup() != null) {\n                d.setDisplayName(mergedMetaData.getDescriptionGroup().getDisplayName());\n            }\n            d.setDeploymentName(deploymentName);\n            try {\n                //TODO: make the caching limits configurable\n                d.setResourceManager(new CachingResourceManager(100, 10 * 1024 * 1024, bufferCacheInjectedValue.getOptionalValue(), new FileResourceManager(Paths.get(deploymentRoot.getPhysicalFile().getAbsolutePath())), -1));\n            } catch (IOException e) {\n                throw new StartException(e);\n            }\n            d.setClassLoader(module.getClassLoader());\n            final String servletVersion = mergedMetaData.getServletVersion();\n            if (servletVersion != null) {\n                d.setMajorVersion(Integer.parseInt(servletVersion.charAt(0) + \"\"));\n                d.setMinorVersion(Integer.parseInt(servletVersion.charAt(2) + \"\"));\n            } else {\n                d.setMajorVersion(3);\n                d.setMinorVersion(1);\n            }\n\n            //for 2.2 apps we do not require a leading / in path mappings\n            boolean is22OrOlder;\n            if (d.getMajorVersion() == 1) {\n                is22OrOlder = true;\n            } else if (d.getMajorVersion() == 2) {\n                is22OrOlder = d.getMinorVersion() < 3;\n            } else {\n                is22OrOlder = false;\n            }\n\n            HashMap<String, TagLibraryInfo> tldInfo = createTldsInfo(tldsMetaData, sharedTlds, classReflectionIndex, componentRegistry, d);\n            HashMap<String, JspPropertyGroup> propertyGroups = createJspConfig(mergedMetaData);\n\n            JspServletBuilder.setupDeployment(d, propertyGroups, tldInfo, new UndertowJSPInstanceManager(injectionContainer));\n            d.setJspConfigDescriptor(new JspConfigDescriptorImpl(tldInfo.values(), propertyGroups.values()));\n            d.setDefaultServletConfig(new DefaultServletConfig(true, Collections.<String>emptySet()));\n\n            //default JSP servlet\n            final ServletInfo jspServlet = new ServletInfo(\"Default JSP Servlet\", JspServlet.class)\n                    .addMapping(\"*.jsp\")\n                    .addMapping(\"*.jspx\")\n                    .addInitParam(\"development\", \"false\"); //todo: make configurable\n            d.addServlet(jspServlet);\n\n            final Set<String> jspPropertyGroupMappings = propertyGroups.keySet();\n            for (final String mapping : jspPropertyGroupMappings) {\n                jspServlet.addMapping(mapping);\n            }\n\n            d.setClassIntrospecter(new ComponentClassIntrospector(componentRegistry));\n\n            final Map<String, List<ServletMappingMetaData>> servletMappings = new HashMap<>();\n\n            if (mergedMetaData.getServletMappings() != null) {\n                for (final ServletMappingMetaData mapping : mergedMetaData.getServletMappings()) {\n                    List<ServletMappingMetaData> list = servletMappings.get(mapping.getServletName());\n                    if (list == null) {\n                        servletMappings.put(mapping.getServletName(), list = new ArrayList<>());\n                    }\n                    list.add(mapping);\n                }\n            }\n            final Set<String> seenMappings = new HashSet<>(jspPropertyGroupMappings);\n            if (mergedMetaData.getServlets() != null) {\n                for (final JBossServletMetaData servlet : mergedMetaData.getServlets()) {\n                    final ServletInfo s;\n\n                    if (servlet.getJspFile() != null) {\n                        //TODO: real JSP support\n                        s = new ServletInfo(servlet.getName(), JspServlet.class);\n                        s.addHandlerChainWrapper(new JspFileWrapper(servlet.getJspFile()));\n                    } else {\n                        Class<? extends Servlet> servletClass = (Class<? extends Servlet>) classReflectionIndex.classIndex(servlet.getServletClass()).getModuleClass();\n                        ComponentRegistry.ComponentManagedReferenceFactory creator = componentRegistry.getComponentsByClass().get(servletClass);\n                        if (creator != null) {\n                            InstanceFactory<Servlet> factory = createInstanceFactory(creator);\n                            s = new ServletInfo(servlet.getName(), servletClass, factory);\n                        } else {\n                            s = new ServletInfo(servlet.getName(), servletClass);\n                        }\n                    }\n                    s.setAsyncSupported(servlet.isAsyncSupported())\n                            .setJspFile(servlet.getJspFile())\n                            .setEnabled(servlet.isEnabled());\n                    if (servlet.getRunAs() != null) {\n                        s.setRunAs(servlet.getRunAs().getRoleName());\n                    }\n                    if (servlet.getLoadOnStartupSet()) {//todo why not cleanup api and just use int everywhere\n                        s.setLoadOnStartup(servlet.getLoadOnStartupInt());\n                    }\n\n                    List<ServletMappingMetaData> mappings = servletMappings.get(servlet.getName());\n                    if (mappings != null) {\n                        for (ServletMappingMetaData mapping : mappings) {\n                            for (String pattern : mapping.getUrlPatterns()) {\n                                if (is22OrOlder && !pattern.startsWith(\"*\") && !pattern.startsWith(\"/\")) {\n                                    pattern = \"/\" + pattern;\n                                }\n                                if (!seenMappings.contains(pattern)) {\n                                    s.addMapping(pattern);\n                                    seenMappings.add(pattern);\n                                }\n                            }\n                        }\n                    }\n                    if (servlet.getInitParam() != null) {\n                        for (ParamValueMetaData initParam : servlet.getInitParam()) {\n                            if (!s.getInitParams().containsKey(initParam.getParamName())) {\n                                s.addInitParam(initParam.getParamName(), initParam.getParamValue());\n                            }\n                        }\n                    }\n                    if (servlet.getServletSecurity() != null) {\n                        ServletSecurityInfo securityInfo = new ServletSecurityInfo();\n                        s.setServletSecurityInfo(securityInfo);\n                        securityInfo.setEmptyRoleSemantic(servlet.getServletSecurity().getEmptyRoleSemantic() == EmptyRoleSemanticType.PERMIT ? PERMIT : DENY)\n                                .setTransportGuaranteeType(transportGuaranteeType(servlet.getServletSecurity().getTransportGuarantee()))\n                                .addRolesAllowed(servlet.getServletSecurity().getRolesAllowed());\n                        if (servlet.getServletSecurity().getHttpMethodConstraints() != null) {\n                            for (HttpMethodConstraintMetaData method : servlet.getServletSecurity().getHttpMethodConstraints()) {\n                                securityInfo.addHttpMethodSecurityInfo(\n                                        new HttpMethodSecurityInfo()\n                                                .setEmptyRoleSemantic(method.getEmptyRoleSemantic() == EmptyRoleSemanticType.PERMIT ? PERMIT : DENY)\n                                                .setTransportGuaranteeType(transportGuaranteeType(method.getTransportGuarantee()))\n                                                .addRolesAllowed(method.getRolesAllowed())\n                                                .setMethod(method.getMethod()));\n                            }\n                        }\n                    }\n                    if (servlet.getSecurityRoleRefs() != null) {\n                        for (final SecurityRoleRefMetaData ref : servlet.getSecurityRoleRefs()) {\n                            s.addSecurityRoleRef(ref.getRoleName(), ref.getRoleLink());\n                        }\n                    }\n\n                    d.addServlet(s);\n                }\n            }\n\n            if (mergedMetaData.getFilters() != null) {\n                for (final FilterMetaData filter : mergedMetaData.getFilters()) {\n                    Class<? extends Filter> filterClass = (Class<? extends Filter>) classReflectionIndex.classIndex(filter.getFilterClass()).getModuleClass();\n                    ComponentRegistry.ComponentManagedReferenceFactory creator = componentRegistry.getComponentsByClass().get(filterClass);\n                    FilterInfo f;\n                    if (creator != null) {\n                        InstanceFactory<Filter> instanceFactory = createInstanceFactory(creator);\n                        f = new FilterInfo(filter.getName(), filterClass, instanceFactory);\n                    } else {\n                        f = new FilterInfo(filter.getName(), filterClass);\n                    }\n                    f.setAsyncSupported(filter.isAsyncSupported());\n                    d.addFilter(f);\n\n                    if (filter.getInitParam() != null) {\n                        for (ParamValueMetaData initParam : filter.getInitParam()) {\n                            f.addInitParam(initParam.getParamName(), initParam.getParamValue());\n                        }\n                    }\n                }\n            }\n            if (mergedMetaData.getFilterMappings() != null) {\n                for (final FilterMappingMetaData mapping : mergedMetaData.getFilterMappings()) {\n                    if (mapping.getUrlPatterns() != null) {\n                        for (String url : mapping.getUrlPatterns()) {\n                            if (is22OrOlder && !url.startsWith(\"*\") && !url.startsWith(\"/\")) {\n                                url = \"/\" + url;\n                            }\n                            if (mapping.getDispatchers() != null && !mapping.getDispatchers().isEmpty()) {\n                                for (DispatcherType dispatcher : mapping.getDispatchers()) {\n\n                                    d.addFilterUrlMapping(mapping.getFilterName(), url, javax.servlet.DispatcherType.valueOf(dispatcher.name()));\n                                }\n                            } else {\n                                d.addFilterUrlMapping(mapping.getFilterName(), url, javax.servlet.DispatcherType.REQUEST);\n                            }\n                        }\n                    }\n                    if (mapping.getServletNames() != null) {\n                        for (String servletName : mapping.getServletNames()) {\n                            if (mapping.getDispatchers() != null && !mapping.getDispatchers().isEmpty()) {\n                                for (DispatcherType dispatcher : mapping.getDispatchers()) {\n                                    d.addFilterServletNameMapping(mapping.getFilterName(), servletName, javax.servlet.DispatcherType.valueOf(dispatcher.name()));\n                                }\n                            } else {\n                                d.addFilterServletNameMapping(mapping.getFilterName(), servletName, javax.servlet.DispatcherType.REQUEST);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (scisMetaData != null && scisMetaData.getHandlesTypes() != null) {\n                for (final Map.Entry<ServletContainerInitializer, Set<Class<?>>> sci : scisMetaData.getHandlesTypes().entrySet()) {\n                    final ImmediateInstanceFactory<ServletContainerInitializer> instanceFactory = new ImmediateInstanceFactory<>(sci.getKey());\n                    d.addServletContainerInitalizer(new ServletContainerInitializerInfo(sci.getKey().getClass(), instanceFactory, sci.getValue()));\n                }\n            }\n\n            if (mergedMetaData.getListeners() != null) {\n                for (ListenerMetaData listener : mergedMetaData.getListeners()) {\n                    addListener(classReflectionIndex, componentRegistry, d, listener);\n                }\n\n            }\n            if (mergedMetaData.getContextParams() != null) {\n                for (ParamValueMetaData param : mergedMetaData.getContextParams()) {\n                    d.addInitParameter(param.getParamName(), param.getParamValue());\n                }\n            }\n\n            if (mergedMetaData.getWelcomeFileList() != null &&\n                    mergedMetaData.getWelcomeFileList().getWelcomeFiles() != null) {\n                List<String> welcomeFiles = mergedMetaData.getWelcomeFileList().getWelcomeFiles();\n                for(String file : welcomeFiles) {\n                    if(file.startsWith(\"/\")) {\n                        d.addWelcomePages(file.substring(1));\n                    } else {\n                        d.addWelcomePages(file);\n                    }\n                }\n            } else {\n                d.addWelcomePages(\"index.html\", \"index.htm\", \"index.jsp\");\n            }\n\n            if (mergedMetaData.getErrorPages() != null) {\n                for (final ErrorPageMetaData page : mergedMetaData.getErrorPages()) {\n                    final ErrorPage errorPage;\n                    if (page.getExceptionType() != null && !page.getExceptionType().isEmpty()) {\n                        errorPage = new ErrorPage(page.getLocation(), (Class<? extends Throwable>) module.getClassLoader().loadClass(page.getExceptionType()));\n                    } else if(page.getErrorCode() != null && !page.getErrorCode().isEmpty()){\n                        errorPage = new ErrorPage(page.getLocation(), Integer.parseInt(page.getErrorCode()));\n                    } else {\n                        errorPage = new ErrorPage(page.getLocation());\n                    }\n                    d.addErrorPages(errorPage);\n                }\n            }\n\n            if (mergedMetaData.getMimeMappings() != null) {\n                for (final MimeMappingMetaData mapping : mergedMetaData.getMimeMappings()) {\n                    d.addMimeMapping(new MimeMapping(mapping.getExtension(), mapping.getMimeType()));\n                }\n            }\n\n            Set<String> securityRoleNames = mergedMetaData.getSecurityRoleNames();\n            if (mergedMetaData.getSecurityConstraints() != null) {\n                for (SecurityConstraintMetaData constraint : mergedMetaData.getSecurityConstraints()) {\n                    SecurityConstraint securityConstraint = new SecurityConstraint()\n                            .setTransportGuaranteeType(transportGuaranteeType(constraint.getTransportGuarantee()));\n\n                    List<String> roleNames = constraint.getRoleNames();\n                    if (constraint.getAuthConstraint() == null) {\n                        // no auth constraint means we permit the empty roles\n                        securityConstraint.setEmptyRoleSemantic(PERMIT);\n                    } else if (roleNames.size() == 1 && roleNames.contains(\"*\") && securityRoleNames.contains(\"*\")) {\n                        // AS7-6932 - Trying to do a * to * mapping which JBossWeb passed through, for Undertow enable\n                        // authentication only mode.\n                        // TODO - AS7-6933 - Revisit workaround added to allow switching between JBoss Web and Undertow.\n                        securityConstraint.setEmptyRoleSemantic(AUTHENTICATE);\n                    } else {\n                        securityConstraint.addRolesAllowed(roleNames);\n                    }\n\n                    if (constraint.getResourceCollections() != null) {\n                        for (final WebResourceCollectionMetaData resourceCollection : constraint.getResourceCollections()) {\n                            securityConstraint.addWebResourceCollection(new WebResourceCollection()\n                                    .addHttpMethods(resourceCollection.getHttpMethods())\n                                    .addHttpMethodOmissions(resourceCollection.getHttpMethodOmissions())\n                                    .addUrlPatterns(resourceCollection.getUrlPatterns()));\n                        }\n                    }\n                    d.addSecurityConstraint(securityConstraint);\n                }\n            }\n            final LoginConfigMetaData loginConfig = mergedMetaData.getLoginConfig();\n            if (loginConfig != null) {\n                String authMethod = authMethod(loginConfig.getAuthMethod());\n                if (loginConfig.getFormLoginConfig() != null) {\n                    d.setLoginConfig(new LoginConfig(authMethod, loginConfig.getRealmName(), loginConfig.getFormLoginConfig().getLoginPage(), loginConfig.getFormLoginConfig().getErrorPage()));\n                } else {\n                    d.setLoginConfig(new LoginConfig(authMethod, loginConfig.getRealmName()));\n                }\n            }\n\n            d.addSecurityRoles(mergedMetaData.getSecurityRoleNames());\n\n\n            d.addOuterHandlerChainWrapper(SecurityContextCreationHandler.wrapper(securityDomain));\n            d.addInnerHandlerChainWrapper(SecurityContextAssociationHandler.wrapper(mergedMetaData.getPrincipalVersusRolesMap(), mergedMetaData.getRunAsIdentity(), securityContextId));\n\n            // Setup an deployer configured ServletContext attributes\n            for (ServletContextAttribute attribute : attributes) {\n                d.addServletContextAttribute(attribute.getName(), attribute.getValue());\n            }\n\n            if (mergedMetaData.getLocalEncodings() != null &&\n                    mergedMetaData.getLocalEncodings().getMappings() != null) {\n                for (LocaleEncodingMetaData locale : mergedMetaData.getLocalEncodings().getMappings()) {\n                    d.addLocaleCharsetMapping(locale.getLocale(), locale.getEncoding());\n                }\n            }\n\n            return d;\n        } catch (ClassNotFoundException e) {\n            throw new StartException(e);\n        }\n    }","commit_id":"dbd0484e574c5ad59f17b22cea54acb0f353b9ac","url":"https://github.com/wildfly/wildfly"},{"original_method":"private DeploymentInfo createServletConfig() throws StartException {\n        try {\n            mergedMetaData.resolveAnnotations();\n            final DeploymentInfo d = new DeploymentInfo();\n            d.setContextPath(contextPath);\n            if (mergedMetaData.getDescriptionGroup() != null) {\n                d.setDisplayName(mergedMetaData.getDescriptionGroup().getDisplayName());\n            }\n            d.setDeploymentName(deploymentName);\n            try {\n                //TODO: make the caching limits configurable\n                ResourceManager resourceManager = new ServletResourceManager(deploymentRoot, overlays);\n                d.setResourceManager(new CachingResourceManager(100, 10 * 1024 * 1024, bufferCacheInjectedValue.getOptionalValue(), resourceManager, -1));\n            } catch (IOException e) {\n                throw new StartException(e);\n            }\n            d.setClassLoader(module.getClassLoader());\n            final String servletVersion = mergedMetaData.getServletVersion();\n            if (servletVersion != null) {\n                d.setMajorVersion(Integer.parseInt(servletVersion.charAt(0) + \"\"));\n                d.setMinorVersion(Integer.parseInt(servletVersion.charAt(2) + \"\"));\n            } else {\n                d.setMajorVersion(3);\n                d.setMinorVersion(1);\n            }\n\n            //for 2.2 apps we do not require a leading / in path mappings\n            boolean is22OrOlder;\n            if (d.getMajorVersion() == 1) {\n                is22OrOlder = true;\n            } else if (d.getMajorVersion() == 2) {\n                is22OrOlder = d.getMinorVersion() < 3;\n            } else {\n                is22OrOlder = false;\n            }\n\n            HashMap<String, TagLibraryInfo> tldInfo = createTldsInfo(tldsMetaData, sharedTlds, classReflectionIndex, componentRegistry, d);\n            HashMap<String, JspPropertyGroup> propertyGroups = createJspConfig(mergedMetaData);\n\n            JspServletBuilder.setupDeployment(d, propertyGroups, tldInfo, new UndertowJSPInstanceManager(injectionContainer));\n            d.setJspConfigDescriptor(new JspConfigDescriptorImpl(tldInfo.values(), propertyGroups.values()));\n            d.setDefaultServletConfig(new DefaultServletConfig(true, Collections.<String>emptySet()));\n\n            //default JSP servlet\n            final ServletInfo jspServlet = new ServletInfo(\"Default JSP Servlet\", JspServlet.class)\n                    .addMapping(\"*.jsp\")\n                    .addMapping(\"*.jspx\")\n                    .addInitParam(\"development\", \"false\"); //todo: make configurable\n            d.addServlet(jspServlet);\n\n            final Set<String> jspPropertyGroupMappings = propertyGroups.keySet();\n            for (final String mapping : jspPropertyGroupMappings) {\n                jspServlet.addMapping(mapping);\n            }\n\n            d.setClassIntrospecter(new ComponentClassIntrospector(componentRegistry));\n\n            final Map<String, List<ServletMappingMetaData>> servletMappings = new HashMap<>();\n\n            if (mergedMetaData.getServletMappings() != null) {\n                for (final ServletMappingMetaData mapping : mergedMetaData.getServletMappings()) {\n                    List<ServletMappingMetaData> list = servletMappings.get(mapping.getServletName());\n                    if (list == null) {\n                        servletMappings.put(mapping.getServletName(), list = new ArrayList<>());\n                    }\n                    list.add(mapping);\n                }\n            }\n            final Set<String> seenMappings = new HashSet<>(jspPropertyGroupMappings);\n            if (mergedMetaData.getServlets() != null) {\n                for (final JBossServletMetaData servlet : mergedMetaData.getServlets()) {\n                    final ServletInfo s;\n\n                    if (servlet.getJspFile() != null) {\n                        //TODO: real JSP support\n                        s = new ServletInfo(servlet.getName(), JspServlet.class);\n                        s.addHandlerChainWrapper(new JspFileWrapper(servlet.getJspFile()));\n                    } else {\n                        Class<? extends Servlet> servletClass = (Class<? extends Servlet>) classReflectionIndex.classIndex(servlet.getServletClass()).getModuleClass();\n                        ComponentRegistry.ComponentManagedReferenceFactory creator = componentRegistry.getComponentsByClass().get(servletClass);\n                        if (creator != null) {\n                            InstanceFactory<Servlet> factory = createInstanceFactory(creator);\n                            s = new ServletInfo(servlet.getName(), servletClass, factory);\n                        } else {\n                            s = new ServletInfo(servlet.getName(), servletClass);\n                        }\n                    }\n                    s.setAsyncSupported(servlet.isAsyncSupported())\n                            .setJspFile(servlet.getJspFile())\n                            .setEnabled(servlet.isEnabled());\n                    if (servlet.getRunAs() != null) {\n                        s.setRunAs(servlet.getRunAs().getRoleName());\n                    }\n                    if (servlet.getLoadOnStartupSet()) {//todo why not cleanup api and just use int everywhere\n                        s.setLoadOnStartup(servlet.getLoadOnStartupInt());\n                    }\n\n                    List<ServletMappingMetaData> mappings = servletMappings.get(servlet.getName());\n                    if (mappings != null) {\n                        for (ServletMappingMetaData mapping : mappings) {\n                            for (String pattern : mapping.getUrlPatterns()) {\n                                if (is22OrOlder && !pattern.startsWith(\"*\") && !pattern.startsWith(\"/\")) {\n                                    pattern = \"/\" + pattern;\n                                }\n                                if (!seenMappings.contains(pattern)) {\n                                    s.addMapping(pattern);\n                                    seenMappings.add(pattern);\n                                }\n                            }\n                        }\n                    }\n                    if (servlet.getInitParam() != null) {\n                        for (ParamValueMetaData initParam : servlet.getInitParam()) {\n                            if (!s.getInitParams().containsKey(initParam.getParamName())) {\n                                s.addInitParam(initParam.getParamName(), initParam.getParamValue());\n                            }\n                        }\n                    }\n                    if (servlet.getServletSecurity() != null) {\n                        ServletSecurityInfo securityInfo = new ServletSecurityInfo();\n                        s.setServletSecurityInfo(securityInfo);\n                        securityInfo.setEmptyRoleSemantic(servlet.getServletSecurity().getEmptyRoleSemantic() == EmptyRoleSemanticType.PERMIT ? PERMIT : DENY)\n                                .setTransportGuaranteeType(transportGuaranteeType(servlet.getServletSecurity().getTransportGuarantee()))\n                                .addRolesAllowed(servlet.getServletSecurity().getRolesAllowed());\n                        if (servlet.getServletSecurity().getHttpMethodConstraints() != null) {\n                            for (HttpMethodConstraintMetaData method : servlet.getServletSecurity().getHttpMethodConstraints()) {\n                                securityInfo.addHttpMethodSecurityInfo(\n                                        new HttpMethodSecurityInfo()\n                                                .setEmptyRoleSemantic(method.getEmptyRoleSemantic() == EmptyRoleSemanticType.PERMIT ? PERMIT : DENY)\n                                                .setTransportGuaranteeType(transportGuaranteeType(method.getTransportGuarantee()))\n                                                .addRolesAllowed(method.getRolesAllowed())\n                                                .setMethod(method.getMethod()));\n                            }\n                        }\n                    }\n                    if (servlet.getSecurityRoleRefs() != null) {\n                        for (final SecurityRoleRefMetaData ref : servlet.getSecurityRoleRefs()) {\n                            s.addSecurityRoleRef(ref.getRoleName(), ref.getRoleLink());\n                        }\n                    }\n\n                    d.addServlet(s);\n                }\n            }\n\n            if (mergedMetaData.getFilters() != null) {\n                for (final FilterMetaData filter : mergedMetaData.getFilters()) {\n                    Class<? extends Filter> filterClass = (Class<? extends Filter>) classReflectionIndex.classIndex(filter.getFilterClass()).getModuleClass();\n                    ComponentRegistry.ComponentManagedReferenceFactory creator = componentRegistry.getComponentsByClass().get(filterClass);\n                    FilterInfo f;\n                    if (creator != null) {\n                        InstanceFactory<Filter> instanceFactory = createInstanceFactory(creator);\n                        f = new FilterInfo(filter.getName(), filterClass, instanceFactory);\n                    } else {\n                        f = new FilterInfo(filter.getName(), filterClass);\n                    }\n                    f.setAsyncSupported(filter.isAsyncSupported());\n                    d.addFilter(f);\n\n                    if (filter.getInitParam() != null) {\n                        for (ParamValueMetaData initParam : filter.getInitParam()) {\n                            f.addInitParam(initParam.getParamName(), initParam.getParamValue());\n                        }\n                    }\n                }\n            }\n            if (mergedMetaData.getFilterMappings() != null) {\n                for (final FilterMappingMetaData mapping : mergedMetaData.getFilterMappings()) {\n                    if (mapping.getUrlPatterns() != null) {\n                        for (String url : mapping.getUrlPatterns()) {\n                            if (is22OrOlder && !url.startsWith(\"*\") && !url.startsWith(\"/\")) {\n                                url = \"/\" + url;\n                            }\n                            if (mapping.getDispatchers() != null && !mapping.getDispatchers().isEmpty()) {\n                                for (DispatcherType dispatcher : mapping.getDispatchers()) {\n\n                                    d.addFilterUrlMapping(mapping.getFilterName(), url, javax.servlet.DispatcherType.valueOf(dispatcher.name()));\n                                }\n                            } else {\n                                d.addFilterUrlMapping(mapping.getFilterName(), url, javax.servlet.DispatcherType.REQUEST);\n                            }\n                        }\n                    }\n                    if (mapping.getServletNames() != null) {\n                        for (String servletName : mapping.getServletNames()) {\n                            if (mapping.getDispatchers() != null && !mapping.getDispatchers().isEmpty()) {\n                                for (DispatcherType dispatcher : mapping.getDispatchers()) {\n                                    d.addFilterServletNameMapping(mapping.getFilterName(), servletName, javax.servlet.DispatcherType.valueOf(dispatcher.name()));\n                                }\n                            } else {\n                                d.addFilterServletNameMapping(mapping.getFilterName(), servletName, javax.servlet.DispatcherType.REQUEST);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (scisMetaData != null && scisMetaData.getHandlesTypes() != null) {\n                for (final Map.Entry<ServletContainerInitializer, Set<Class<?>>> sci : scisMetaData.getHandlesTypes().entrySet()) {\n                    final ImmediateInstanceFactory<ServletContainerInitializer> instanceFactory = new ImmediateInstanceFactory<>(sci.getKey());\n                    d.addServletContainerInitalizer(new ServletContainerInitializerInfo(sci.getKey().getClass(), instanceFactory, sci.getValue()));\n                }\n            }\n\n            if (mergedMetaData.getListeners() != null) {\n                for (ListenerMetaData listener : mergedMetaData.getListeners()) {\n                    addListener(classReflectionIndex, componentRegistry, d, listener);\n                }\n\n            }\n            if (mergedMetaData.getContextParams() != null) {\n                for (ParamValueMetaData param : mergedMetaData.getContextParams()) {\n                    d.addInitParameter(param.getParamName(), param.getParamValue());\n                }\n            }\n\n            if (mergedMetaData.getWelcomeFileList() != null &&\n                    mergedMetaData.getWelcomeFileList().getWelcomeFiles() != null) {\n                List<String> welcomeFiles = mergedMetaData.getWelcomeFileList().getWelcomeFiles();\n                for(String file : welcomeFiles) {\n                    if(file.startsWith(\"/\")) {\n                        d.addWelcomePages(file.substring(1));\n                    } else {\n                        d.addWelcomePages(file);\n                    }\n                }\n            } else {\n                d.addWelcomePages(\"index.html\", \"index.htm\", \"index.jsp\");\n            }\n\n            if (mergedMetaData.getErrorPages() != null) {\n                for (final ErrorPageMetaData page : mergedMetaData.getErrorPages()) {\n                    final ErrorPage errorPage;\n                    if (page.getExceptionType() != null && !page.getExceptionType().isEmpty()) {\n                        errorPage = new ErrorPage(page.getLocation(), (Class<? extends Throwable>) module.getClassLoader().loadClass(page.getExceptionType()));\n                    } else if(page.getErrorCode() != null && !page.getErrorCode().isEmpty()){\n                        errorPage = new ErrorPage(page.getLocation(), Integer.parseInt(page.getErrorCode()));\n                    } else {\n                        errorPage = new ErrorPage(page.getLocation());\n                    }\n                    d.addErrorPages(errorPage);\n                }\n            }\n\n            if (mergedMetaData.getMimeMappings() != null) {\n                for (final MimeMappingMetaData mapping : mergedMetaData.getMimeMappings()) {\n                    d.addMimeMapping(new MimeMapping(mapping.getExtension(), mapping.getMimeType()));\n                }\n            }\n\n            Set<String> securityRoleNames = mergedMetaData.getSecurityRoleNames();\n            if (mergedMetaData.getSecurityConstraints() != null) {\n                for (SecurityConstraintMetaData constraint : mergedMetaData.getSecurityConstraints()) {\n                    SecurityConstraint securityConstraint = new SecurityConstraint()\n                            .setTransportGuaranteeType(transportGuaranteeType(constraint.getTransportGuarantee()));\n\n                    List<String> roleNames = constraint.getRoleNames();\n                    if (constraint.getAuthConstraint() == null) {\n                        // no auth constraint means we permit the empty roles\n                        securityConstraint.setEmptyRoleSemantic(PERMIT);\n                    } else if (roleNames.size() == 1 && roleNames.contains(\"*\") && securityRoleNames.contains(\"*\")) {\n                        // AS7-6932 - Trying to do a * to * mapping which JBossWeb passed through, for Undertow enable\n                        // authentication only mode.\n                        // TODO - AS7-6933 - Revisit workaround added to allow switching between JBoss Web and Undertow.\n                        securityConstraint.setEmptyRoleSemantic(AUTHENTICATE);\n                    } else {\n                        securityConstraint.addRolesAllowed(roleNames);\n                    }\n\n                    if (constraint.getResourceCollections() != null) {\n                        for (final WebResourceCollectionMetaData resourceCollection : constraint.getResourceCollections()) {\n                            securityConstraint.addWebResourceCollection(new WebResourceCollection()\n                                    .addHttpMethods(resourceCollection.getHttpMethods())\n                                    .addHttpMethodOmissions(resourceCollection.getHttpMethodOmissions())\n                                    .addUrlPatterns(resourceCollection.getUrlPatterns()));\n                        }\n                    }\n                    d.addSecurityConstraint(securityConstraint);\n                }\n            }\n            final LoginConfigMetaData loginConfig = mergedMetaData.getLoginConfig();\n            if (loginConfig != null) {\n                String authMethod = authMethod(loginConfig.getAuthMethod());\n                if (loginConfig.getFormLoginConfig() != null) {\n                    d.setLoginConfig(new LoginConfig(authMethod, loginConfig.getRealmName(), loginConfig.getFormLoginConfig().getLoginPage(), loginConfig.getFormLoginConfig().getErrorPage()));\n                } else {\n                    d.setLoginConfig(new LoginConfig(authMethod, loginConfig.getRealmName()));\n                }\n            }\n\n            d.addSecurityRoles(mergedMetaData.getSecurityRoleNames());\n\n\n            d.addOuterHandlerChainWrapper(SecurityContextCreationHandler.wrapper(securityDomain));\n            d.addInnerHandlerChainWrapper(SecurityContextAssociationHandler.wrapper(mergedMetaData.getPrincipalVersusRolesMap(), mergedMetaData.getRunAsIdentity(), securityContextId));\n\n            // Setup an deployer configured ServletContext attributes\n            for (ServletContextAttribute attribute : attributes) {\n                d.addServletContextAttribute(attribute.getName(), attribute.getValue());\n            }\n\n            if (mergedMetaData.getLocalEncodings() != null &&\n                    mergedMetaData.getLocalEncodings().getMappings() != null) {\n                for (LocaleEncodingMetaData locale : mergedMetaData.getLocalEncodings().getMappings()) {\n                    d.addLocaleCharsetMapping(locale.getLocale(), locale.getEncoding());\n                }\n            }\n\n            return d;\n        } catch (ClassNotFoundException e) {\n            throw new StartException(e);\n        }\n    }","id":93561,"modified_method":"private DeploymentInfo createServletConfig() throws StartException {\n        try {\n            mergedMetaData.resolveAnnotations();\n            final DeploymentInfo d = new DeploymentInfo();\n            d.setContextPath(contextPath);\n            if (mergedMetaData.getDescriptionGroup() != null) {\n                d.setDisplayName(mergedMetaData.getDescriptionGroup().getDisplayName());\n            }\n            d.setDeploymentName(deploymentName);\n            try {\n                //TODO: make the caching limits configurable\n                ResourceManager resourceManager = new ServletResourceManager(deploymentRoot, overlays);\n                d.setResourceManager(new CachingResourceManager(100, 10 * 1024 * 1024, bufferCacheInjectedValue.getOptionalValue(), resourceManager, -1));\n            } catch (IOException e) {\n                throw new StartException(e);\n            }\n            d.setClassLoader(module.getClassLoader());\n            final String servletVersion = mergedMetaData.getServletVersion();\n            if (servletVersion != null) {\n                d.setMajorVersion(Integer.parseInt(servletVersion.charAt(0) + \"\"));\n                d.setMinorVersion(Integer.parseInt(servletVersion.charAt(2) + \"\"));\n            } else {\n                d.setMajorVersion(3);\n                d.setMinorVersion(1);\n            }\n\n            //for 2.2 apps we do not require a leading / in path mappings\n            boolean is22OrOlder;\n            if (d.getMajorVersion() == 1) {\n                is22OrOlder = true;\n            } else if (d.getMajorVersion() == 2) {\n                is22OrOlder = d.getMinorVersion() < 3;\n            } else {\n                is22OrOlder = false;\n            }\n\n            HashMap<String, TagLibraryInfo> tldInfo = createTldsInfo(tldsMetaData, sharedTlds);\n            HashMap<String, JspPropertyGroup> propertyGroups = createJspConfig(mergedMetaData);\n\n            JspServletBuilder.setupDeployment(d, propertyGroups, tldInfo, new UndertowJSPInstanceManager(injectionContainer));\n            d.setJspConfigDescriptor(new JspConfigDescriptorImpl(tldInfo.values(), propertyGroups.values()));\n            d.setDefaultServletConfig(new DefaultServletConfig(true, Collections.<String>emptySet()));\n\n            //default JSP servlet\n            final ServletInfo jspServlet = new ServletInfo(\"Default JSP Servlet\", JspServlet.class)\n                    .addMapping(\"*.jsp\")\n                    .addMapping(\"*.jspx\")\n                    .addInitParam(\"development\", \"false\"); //todo: make configurable\n            d.addServlet(jspServlet);\n\n            final Set<String> jspPropertyGroupMappings = propertyGroups.keySet();\n            for (final String mapping : jspPropertyGroupMappings) {\n                jspServlet.addMapping(mapping);\n            }\n\n            d.setClassIntrospecter(new ComponentClassIntrospector(componentRegistry));\n\n            final Map<String, List<ServletMappingMetaData>> servletMappings = new HashMap<>();\n\n            if (mergedMetaData.getServletMappings() != null) {\n                for (final ServletMappingMetaData mapping : mergedMetaData.getServletMappings()) {\n                    List<ServletMappingMetaData> list = servletMappings.get(mapping.getServletName());\n                    if (list == null) {\n                        servletMappings.put(mapping.getServletName(), list = new ArrayList<>());\n                    }\n                    list.add(mapping);\n                }\n            }\n            final Set<String> seenMappings = new HashSet<>(jspPropertyGroupMappings);\n            if (mergedMetaData.getServlets() != null) {\n                for (final JBossServletMetaData servlet : mergedMetaData.getServlets()) {\n                    final ServletInfo s;\n\n                    if (servlet.getJspFile() != null) {\n                        //TODO: real JSP support\n                        s = new ServletInfo(servlet.getName(), JspServlet.class);\n                        s.addHandlerChainWrapper(new JspFileWrapper(servlet.getJspFile()));\n                    } else {\n                        Class<? extends Servlet> servletClass = (Class<? extends Servlet>) module.getClassLoader().loadClass(servlet.getServletClass());\n                        ComponentRegistry.ComponentManagedReferenceFactory creator = componentRegistry.getComponentsByClass().get(servletClass);\n                        if (creator != null) {\n                            InstanceFactory<Servlet> factory = createInstanceFactory(creator);\n                            s = new ServletInfo(servlet.getName(), servletClass, factory);\n                        } else {\n                            s = new ServletInfo(servlet.getName(), servletClass);\n                        }\n                    }\n                    s.setAsyncSupported(servlet.isAsyncSupported())\n                            .setJspFile(servlet.getJspFile())\n                            .setEnabled(servlet.isEnabled());\n                    if (servlet.getRunAs() != null) {\n                        s.setRunAs(servlet.getRunAs().getRoleName());\n                    }\n                    if (servlet.getLoadOnStartupSet()) {//todo why not cleanup api and just use int everywhere\n                        s.setLoadOnStartup(servlet.getLoadOnStartupInt());\n                    }\n\n                    List<ServletMappingMetaData> mappings = servletMappings.get(servlet.getName());\n                    if (mappings != null) {\n                        for (ServletMappingMetaData mapping : mappings) {\n                            for (String pattern : mapping.getUrlPatterns()) {\n                                if (is22OrOlder && !pattern.startsWith(\"*\") && !pattern.startsWith(\"/\")) {\n                                    pattern = \"/\" + pattern;\n                                }\n                                if (!seenMappings.contains(pattern)) {\n                                    s.addMapping(pattern);\n                                    seenMappings.add(pattern);\n                                }\n                            }\n                        }\n                    }\n                    if (servlet.getInitParam() != null) {\n                        for (ParamValueMetaData initParam : servlet.getInitParam()) {\n                            if (!s.getInitParams().containsKey(initParam.getParamName())) {\n                                s.addInitParam(initParam.getParamName(), initParam.getParamValue());\n                            }\n                        }\n                    }\n                    if (servlet.getServletSecurity() != null) {\n                        ServletSecurityInfo securityInfo = new ServletSecurityInfo();\n                        s.setServletSecurityInfo(securityInfo);\n                        securityInfo.setEmptyRoleSemantic(servlet.getServletSecurity().getEmptyRoleSemantic() == EmptyRoleSemanticType.PERMIT ? PERMIT : DENY)\n                                .setTransportGuaranteeType(transportGuaranteeType(servlet.getServletSecurity().getTransportGuarantee()))\n                                .addRolesAllowed(servlet.getServletSecurity().getRolesAllowed());\n                        if (servlet.getServletSecurity().getHttpMethodConstraints() != null) {\n                            for (HttpMethodConstraintMetaData method : servlet.getServletSecurity().getHttpMethodConstraints()) {\n                                securityInfo.addHttpMethodSecurityInfo(\n                                        new HttpMethodSecurityInfo()\n                                                .setEmptyRoleSemantic(method.getEmptyRoleSemantic() == EmptyRoleSemanticType.PERMIT ? PERMIT : DENY)\n                                                .setTransportGuaranteeType(transportGuaranteeType(method.getTransportGuarantee()))\n                                                .addRolesAllowed(method.getRolesAllowed())\n                                                .setMethod(method.getMethod()));\n                            }\n                        }\n                    }\n                    if (servlet.getSecurityRoleRefs() != null) {\n                        for (final SecurityRoleRefMetaData ref : servlet.getSecurityRoleRefs()) {\n                            s.addSecurityRoleRef(ref.getRoleName(), ref.getRoleLink());\n                        }\n                    }\n\n                    d.addServlet(s);\n                }\n            }\n\n            if (mergedMetaData.getFilters() != null) {\n                for (final FilterMetaData filter : mergedMetaData.getFilters()) {\n                    Class<? extends Filter> filterClass = (Class<? extends Filter>) module.getClassLoader().loadClass(filter.getFilterClass());\n                    ComponentRegistry.ComponentManagedReferenceFactory creator = componentRegistry.getComponentsByClass().get(filterClass);\n                    FilterInfo f;\n                    if (creator != null) {\n                        InstanceFactory<Filter> instanceFactory = createInstanceFactory(creator);\n                        f = new FilterInfo(filter.getName(), filterClass, instanceFactory);\n                    } else {\n                        f = new FilterInfo(filter.getName(), filterClass);\n                    }\n                    f.setAsyncSupported(filter.isAsyncSupported());\n                    d.addFilter(f);\n\n                    if (filter.getInitParam() != null) {\n                        for (ParamValueMetaData initParam : filter.getInitParam()) {\n                            f.addInitParam(initParam.getParamName(), initParam.getParamValue());\n                        }\n                    }\n                }\n            }\n            if (mergedMetaData.getFilterMappings() != null) {\n                for (final FilterMappingMetaData mapping : mergedMetaData.getFilterMappings()) {\n                    if (mapping.getUrlPatterns() != null) {\n                        for (String url : mapping.getUrlPatterns()) {\n                            if (is22OrOlder && !url.startsWith(\"*\") && !url.startsWith(\"/\")) {\n                                url = \"/\" + url;\n                            }\n                            if (mapping.getDispatchers() != null && !mapping.getDispatchers().isEmpty()) {\n                                for (DispatcherType dispatcher : mapping.getDispatchers()) {\n\n                                    d.addFilterUrlMapping(mapping.getFilterName(), url, javax.servlet.DispatcherType.valueOf(dispatcher.name()));\n                                }\n                            } else {\n                                d.addFilterUrlMapping(mapping.getFilterName(), url, javax.servlet.DispatcherType.REQUEST);\n                            }\n                        }\n                    }\n                    if (mapping.getServletNames() != null) {\n                        for (String servletName : mapping.getServletNames()) {\n                            if (mapping.getDispatchers() != null && !mapping.getDispatchers().isEmpty()) {\n                                for (DispatcherType dispatcher : mapping.getDispatchers()) {\n                                    d.addFilterServletNameMapping(mapping.getFilterName(), servletName, javax.servlet.DispatcherType.valueOf(dispatcher.name()));\n                                }\n                            } else {\n                                d.addFilterServletNameMapping(mapping.getFilterName(), servletName, javax.servlet.DispatcherType.REQUEST);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (scisMetaData != null && scisMetaData.getHandlesTypes() != null) {\n                for (final Map.Entry<ServletContainerInitializer, Set<Class<?>>> sci : scisMetaData.getHandlesTypes().entrySet()) {\n                    final ImmediateInstanceFactory<ServletContainerInitializer> instanceFactory = new ImmediateInstanceFactory<>(sci.getKey());\n                    d.addServletContainerInitalizer(new ServletContainerInitializerInfo(sci.getKey().getClass(), instanceFactory, sci.getValue()));\n                }\n            }\n\n            if (mergedMetaData.getListeners() != null) {\n                for (ListenerMetaData listener : mergedMetaData.getListeners()) {\n                    addListener(module.getClassLoader(), componentRegistry, d, listener);\n                }\n\n            }\n            if (mergedMetaData.getContextParams() != null) {\n                for (ParamValueMetaData param : mergedMetaData.getContextParams()) {\n                    d.addInitParameter(param.getParamName(), param.getParamValue());\n                }\n            }\n\n            if (mergedMetaData.getWelcomeFileList() != null &&\n                    mergedMetaData.getWelcomeFileList().getWelcomeFiles() != null) {\n                List<String> welcomeFiles = mergedMetaData.getWelcomeFileList().getWelcomeFiles();\n                for (String file : welcomeFiles) {\n                    if (file.startsWith(\"/\")) {\n                        d.addWelcomePages(file.substring(1));\n                    } else {\n                        d.addWelcomePages(file);\n                    }\n                }\n            } else {\n                d.addWelcomePages(\"index.html\", \"index.htm\", \"index.jsp\");\n            }\n\n            if (mergedMetaData.getErrorPages() != null) {\n                for (final ErrorPageMetaData page : mergedMetaData.getErrorPages()) {\n                    final ErrorPage errorPage;\n                    if (page.getExceptionType() != null && !page.getExceptionType().isEmpty()) {\n                        errorPage = new ErrorPage(page.getLocation(), (Class<? extends Throwable>) module.getClassLoader().loadClass(page.getExceptionType()));\n                    } else if(page.getErrorCode() != null && !page.getErrorCode().isEmpty()){\n                        errorPage = new ErrorPage(page.getLocation(), Integer.parseInt(page.getErrorCode()));\n                    } else {\n                        errorPage = new ErrorPage(page.getLocation());\n                    }\n                    d.addErrorPages(errorPage);\n                }\n            }\n\n            if (mergedMetaData.getMimeMappings() != null) {\n                for (final MimeMappingMetaData mapping : mergedMetaData.getMimeMappings()) {\n                    d.addMimeMapping(new MimeMapping(mapping.getExtension(), mapping.getMimeType()));\n                }\n            }\n\n            Set<String> securityRoleNames = mergedMetaData.getSecurityRoleNames();\n            if (mergedMetaData.getSecurityConstraints() != null) {\n                for (SecurityConstraintMetaData constraint : mergedMetaData.getSecurityConstraints()) {\n                    SecurityConstraint securityConstraint = new SecurityConstraint()\n                            .setTransportGuaranteeType(transportGuaranteeType(constraint.getTransportGuarantee()));\n\n                    List<String> roleNames = constraint.getRoleNames();\n                    if (constraint.getAuthConstraint() == null) {\n                        // no auth constraint means we permit the empty roles\n                        securityConstraint.setEmptyRoleSemantic(PERMIT);\n                    } else if (roleNames.size() == 1 && roleNames.contains(\"*\") && securityRoleNames.contains(\"*\")) {\n                        // AS7-6932 - Trying to do a * to * mapping which JBossWeb passed through, for Undertow enable\n                        // authentication only mode.\n                        // TODO - AS7-6933 - Revisit workaround added to allow switching between JBoss Web and Undertow.\n                        securityConstraint.setEmptyRoleSemantic(AUTHENTICATE);\n                    } else {\n                        securityConstraint.addRolesAllowed(roleNames);\n                    }\n\n                    if (constraint.getResourceCollections() != null) {\n                        for (final WebResourceCollectionMetaData resourceCollection : constraint.getResourceCollections()) {\n                            securityConstraint.addWebResourceCollection(new WebResourceCollection()\n                                    .addHttpMethods(resourceCollection.getHttpMethods())\n                                    .addHttpMethodOmissions(resourceCollection.getHttpMethodOmissions())\n                                    .addUrlPatterns(resourceCollection.getUrlPatterns()));\n                        }\n                    }\n                    d.addSecurityConstraint(securityConstraint);\n                }\n            }\n            final LoginConfigMetaData loginConfig = mergedMetaData.getLoginConfig();\n            if (loginConfig != null) {\n                String authMethod = authMethod(loginConfig.getAuthMethod());\n                if (loginConfig.getFormLoginConfig() != null) {\n                    d.setLoginConfig(new LoginConfig(authMethod, loginConfig.getRealmName(), loginConfig.getFormLoginConfig().getLoginPage(), loginConfig.getFormLoginConfig().getErrorPage()));\n                } else {\n                    d.setLoginConfig(new LoginConfig(authMethod, loginConfig.getRealmName()));\n                }\n            }\n\n            d.addSecurityRoles(mergedMetaData.getSecurityRoleNames());\n\n\n            d.addOuterHandlerChainWrapper(SecurityContextCreationHandler.wrapper(securityDomain));\n            d.addInnerHandlerChainWrapper(SecurityContextAssociationHandler.wrapper(mergedMetaData.getPrincipalVersusRolesMap(), mergedMetaData.getRunAsIdentity(), securityContextId));\n\n            // Setup an deployer configured ServletContext attributes\n            for (ServletContextAttribute attribute : attributes) {\n                d.addServletContextAttribute(attribute.getName(), attribute.getValue());\n            }\n\n            if (mergedMetaData.getLocalEncodings() != null &&\n                    mergedMetaData.getLocalEncodings().getMappings() != null) {\n                for (LocaleEncodingMetaData locale : mergedMetaData.getLocalEncodings().getMappings()) {\n                    d.addLocaleCharsetMapping(locale.getLocale(), locale.getEncoding());\n                }\n            }\n\n            return d;\n        } catch (ClassNotFoundException e) {\n            throw new StartException(e);\n        }\n    }","commit_id":"d00359477d1fc2a979175ac78f6957aaa223f097","url":"https://github.com/wildfly/wildfly"},{"original_method":"private UndertowDeploymentInfoService(final JBossWebMetaData mergedMetaData, final String deploymentName, final TldsMetaData tldsMetaData, final List<TldMetaData> sharedTlds, final Module module, final DeploymentClassIndex classReflectionIndex, final WebInjectionContainer injectionContainer, final ComponentRegistry componentRegistry, final ScisMetaData scisMetaData, final VirtualFile deploymentRoot, final String securityContextId, final String securityDomain, final List<ServletContextAttribute> attributes, final String contextPath, final List<SetupAction> setupActions, final Set<VirtualFile> overlays) {\n        this.mergedMetaData = mergedMetaData;\n        this.deploymentName = deploymentName;\n        this.tldsMetaData = tldsMetaData;\n        this.sharedTlds = sharedTlds;\n        this.module = module;\n        this.classReflectionIndex = classReflectionIndex;\n        this.injectionContainer = injectionContainer;\n        this.componentRegistry = componentRegistry;\n        this.scisMetaData = scisMetaData;\n        this.deploymentRoot = deploymentRoot;\n        this.securityContextId = securityContextId;\n        this.securityDomain = securityDomain;\n        this.attributes = attributes;\n        this.contextPath = contextPath;\n        this.setupActions = setupActions;\n        this.overlays = overlays;\n    }","id":93562,"modified_method":"private UndertowDeploymentInfoService(final JBossWebMetaData mergedMetaData, final String deploymentName, final TldsMetaData tldsMetaData, final List<TldMetaData> sharedTlds, final Module module, final WebInjectionContainer injectionContainer, final ComponentRegistry componentRegistry, final ScisMetaData scisMetaData, final VirtualFile deploymentRoot, final String securityContextId, final String securityDomain, final List<ServletContextAttribute> attributes, final String contextPath, final List<SetupAction> setupActions, final Set<VirtualFile> overlays) {\n        this.mergedMetaData = mergedMetaData;\n        this.deploymentName = deploymentName;\n        this.tldsMetaData = tldsMetaData;\n        this.sharedTlds = sharedTlds;\n        this.module = module;\n        this.injectionContainer = injectionContainer;\n        this.componentRegistry = componentRegistry;\n        this.scisMetaData = scisMetaData;\n        this.deploymentRoot = deploymentRoot;\n        this.securityContextId = securityContextId;\n        this.securityDomain = securityDomain;\n        this.attributes = attributes;\n        this.contextPath = contextPath;\n        this.setupActions = setupActions;\n        this.overlays = overlays;\n    }","commit_id":"d00359477d1fc2a979175ac78f6957aaa223f097","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static TagLibraryInfo createTldInfo(final String location, final TldMetaData tldMetaData, final HashMap<String, TagLibraryInfo> ret, final DeploymentClassIndex classReflectionIndex, final ComponentRegistry components, final DeploymentInfo d) throws ClassNotFoundException {\n        String relativeLocation = location;\n        String jarPath = null;\n        if (relativeLocation != null && relativeLocation.startsWith(\"/WEB-INF/lib/\")) {\n            int pos = relativeLocation.indexOf('/', \"/WEB-INF/lib/\".length());\n            if (pos > 0) {\n                jarPath = relativeLocation.substring(pos);\n                if (jarPath.startsWith(\"/\")) {\n                    jarPath = jarPath.substring(1);\n                }\n                relativeLocation = relativeLocation.substring(0, pos);\n            }\n        }\n\n        TagLibraryInfo tagLibraryInfo = new TagLibraryInfo();\n        tagLibraryInfo.setTlibversion(tldMetaData.getTlibVersion());\n        if (tldMetaData.getJspVersion() == null) {\n            tagLibraryInfo.setJspversion(tldMetaData.getVersion());\n        } else {\n            tagLibraryInfo.setJspversion(tldMetaData.getJspVersion());\n        }\n        tagLibraryInfo.setShortname(tldMetaData.getShortName());\n        tagLibraryInfo.setUri(tldMetaData.getUri());\n        if (tldMetaData.getDescriptionGroup() != null) {\n            tagLibraryInfo.setInfo(tldMetaData.getDescriptionGroup().getDescription());\n        }\n        // Validator\n        if (tldMetaData.getValidator() != null) {\n            TagLibraryValidatorInfo tagLibraryValidatorInfo = new TagLibraryValidatorInfo();\n            tagLibraryValidatorInfo.setValidatorClass(tldMetaData.getValidator().getValidatorClass());\n            if (tldMetaData.getValidator().getInitParams() != null) {\n                for (ParamValueMetaData paramValueMetaData : tldMetaData.getValidator().getInitParams()) {\n                    tagLibraryValidatorInfo.addInitParam(paramValueMetaData.getParamName(), paramValueMetaData.getParamValue());\n                }\n            }\n            tagLibraryInfo.setValidator(tagLibraryValidatorInfo);\n        }\n        // Tag\n        if (tldMetaData.getTags() != null) {\n            for (TagMetaData tagMetaData : tldMetaData.getTags()) {\n                TagInfo tagInfo = new TagInfo();\n                tagInfo.setTagName(tagMetaData.getName());\n                tagInfo.setTagClassName(tagMetaData.getTagClass());\n                tagInfo.setTagExtraInfo(tagMetaData.getTeiClass());\n                if (tagMetaData.getBodyContent() != null) {\n                    tagInfo.setBodyContent(tagMetaData.getBodyContent().toString());\n                }\n                tagInfo.setDynamicAttributes(tagMetaData.getDynamicAttributes());\n                // Description group\n                if (tagMetaData.getDescriptionGroup() != null) {\n                    DescriptionGroupMetaData descriptionGroup = tagMetaData.getDescriptionGroup();\n                    if (descriptionGroup.getIcons() != null && descriptionGroup.getIcons().value() != null\n                            && (descriptionGroup.getIcons().value().length > 0)) {\n                        Icon icon = descriptionGroup.getIcons().value()[0];\n                        tagInfo.setLargeIcon(icon.largeIcon());\n                        tagInfo.setSmallIcon(icon.smallIcon());\n                    }\n                    tagInfo.setInfoString(descriptionGroup.getDescription());\n                    tagInfo.setDisplayName(descriptionGroup.getDisplayName());\n                }\n                // Variable\n                if (tagMetaData.getVariables() != null) {\n                    for (VariableMetaData variableMetaData : tagMetaData.getVariables()) {\n                        TagVariableInfo tagVariableInfo = new TagVariableInfo();\n                        tagVariableInfo.setNameGiven(variableMetaData.getNameGiven());\n                        tagVariableInfo.setNameFromAttribute(variableMetaData.getNameFromAttribute());\n                        tagVariableInfo.setClassName(variableMetaData.getVariableClass());\n                        tagVariableInfo.setDeclare(variableMetaData.getDeclare());\n                        if (variableMetaData.getScope() != null) {\n                            tagVariableInfo.setScope(variableMetaData.getScope().toString());\n                        }\n                        tagInfo.addTagVariableInfo(tagVariableInfo);\n                    }\n                }\n                // Attribute\n                if (tagMetaData.getAttributes() != null) {\n                    for (AttributeMetaData attributeMetaData : tagMetaData.getAttributes()) {\n                        TagAttributeInfo tagAttributeInfo = new TagAttributeInfo();\n                        tagAttributeInfo.setName(attributeMetaData.getName());\n                        tagAttributeInfo.setType(attributeMetaData.getType());\n                        tagAttributeInfo.setReqTime(attributeMetaData.getRtexprvalue());\n                        tagAttributeInfo.setRequired(attributeMetaData.getRequired());\n                        tagAttributeInfo.setFragment(attributeMetaData.getFragment());\n                        if (attributeMetaData.getDeferredValue() != null) {\n                            tagAttributeInfo.setDeferredValue(\"true\");\n                            tagAttributeInfo.setExpectedTypeName(attributeMetaData.getDeferredValue().getType());\n                        } else {\n                            tagAttributeInfo.setDeferredValue(\"false\");\n                        }\n                        if (attributeMetaData.getDeferredMethod() != null) {\n                            tagAttributeInfo.setDeferredMethod(\"true\");\n                            tagAttributeInfo.setMethodSignature(attributeMetaData.getDeferredMethod().getMethodSignature());\n                        } else {\n                            tagAttributeInfo.setDeferredMethod(\"false\");\n                        }\n                        tagInfo.addTagAttributeInfo(tagAttributeInfo);\n                    }\n                }\n                tagLibraryInfo.addTagInfo(tagInfo);\n            }\n        }\n        // Tag files\n        if (tldMetaData.getTagFiles() != null) {\n            for (TagFileMetaData tagFileMetaData : tldMetaData.getTagFiles()) {\n                TagFileInfo tagFileInfo = new TagFileInfo();\n                tagFileInfo.setName(tagFileMetaData.getName());\n                tagFileInfo.setPath(tagFileMetaData.getPath());\n                tagLibraryInfo.addTagFileInfo(tagFileInfo);\n            }\n        }\n        // Function\n        if (tldMetaData.getFunctions() != null) {\n            for (FunctionMetaData functionMetaData : tldMetaData.getFunctions()) {\n                FunctionInfo functionInfo = new FunctionInfo();\n                functionInfo.setName(functionMetaData.getName());\n                functionInfo.setFunctionClass(functionMetaData.getFunctionClass());\n                functionInfo.setFunctionSignature(functionMetaData.getFunctionSignature());\n                tagLibraryInfo.addFunctionInfo(functionInfo);\n            }\n        }\n\n        if (jarPath == null && relativeLocation == null) {\n            if (!ret.containsKey(tagLibraryInfo.getUri())) {\n                ret.put(tagLibraryInfo.getUri(), tagLibraryInfo);\n            }\n        } else if (jarPath == null) {\n            tagLibraryInfo.setLocation(\"\");\n            tagLibraryInfo.setPath(relativeLocation);\n            if (!ret.containsKey(tagLibraryInfo.getUri())) {\n                ret.put(tagLibraryInfo.getUri(), tagLibraryInfo);\n            }\n            ret.put(relativeLocation, tagLibraryInfo);\n        } else {\n            tagLibraryInfo.setLocation(relativeLocation);\n            tagLibraryInfo.setPath(jarPath);\n            if (!ret.containsKey(tagLibraryInfo.getUri())) {\n                ret.put(tagLibraryInfo.getUri(), tagLibraryInfo);\n            }\n            if (jarPath.equals(\"META-INF/taglib.tld\")) {\n                ret.put(relativeLocation, tagLibraryInfo);\n            }\n        }\n        return tagLibraryInfo;\n    }","id":93563,"modified_method":"private static TagLibraryInfo createTldInfo(final String location, final TldMetaData tldMetaData, final HashMap<String, TagLibraryInfo> ret) throws ClassNotFoundException {\n        String relativeLocation = location;\n        String jarPath = null;\n        if (relativeLocation != null && relativeLocation.startsWith(\"/WEB-INF/lib/\")) {\n            int pos = relativeLocation.indexOf('/', \"/WEB-INF/lib/\".length());\n            if (pos > 0) {\n                jarPath = relativeLocation.substring(pos);\n                if (jarPath.startsWith(\"/\")) {\n                    jarPath = jarPath.substring(1);\n                }\n                relativeLocation = relativeLocation.substring(0, pos);\n            }\n        }\n\n        TagLibraryInfo tagLibraryInfo = new TagLibraryInfo();\n        tagLibraryInfo.setTlibversion(tldMetaData.getTlibVersion());\n        if (tldMetaData.getJspVersion() == null) {\n            tagLibraryInfo.setJspversion(tldMetaData.getVersion());\n        } else {\n            tagLibraryInfo.setJspversion(tldMetaData.getJspVersion());\n        }\n        tagLibraryInfo.setShortname(tldMetaData.getShortName());\n        tagLibraryInfo.setUri(tldMetaData.getUri());\n        if (tldMetaData.getDescriptionGroup() != null) {\n            tagLibraryInfo.setInfo(tldMetaData.getDescriptionGroup().getDescription());\n        }\n        // Validator\n        if (tldMetaData.getValidator() != null) {\n            TagLibraryValidatorInfo tagLibraryValidatorInfo = new TagLibraryValidatorInfo();\n            tagLibraryValidatorInfo.setValidatorClass(tldMetaData.getValidator().getValidatorClass());\n            if (tldMetaData.getValidator().getInitParams() != null) {\n                for (ParamValueMetaData paramValueMetaData : tldMetaData.getValidator().getInitParams()) {\n                    tagLibraryValidatorInfo.addInitParam(paramValueMetaData.getParamName(), paramValueMetaData.getParamValue());\n                }\n            }\n            tagLibraryInfo.setValidator(tagLibraryValidatorInfo);\n        }\n        // Tag\n        if (tldMetaData.getTags() != null) {\n            for (TagMetaData tagMetaData : tldMetaData.getTags()) {\n                TagInfo tagInfo = new TagInfo();\n                tagInfo.setTagName(tagMetaData.getName());\n                tagInfo.setTagClassName(tagMetaData.getTagClass());\n                tagInfo.setTagExtraInfo(tagMetaData.getTeiClass());\n                if (tagMetaData.getBodyContent() != null) {\n                    tagInfo.setBodyContent(tagMetaData.getBodyContent().toString());\n                }\n                tagInfo.setDynamicAttributes(tagMetaData.getDynamicAttributes());\n                // Description group\n                if (tagMetaData.getDescriptionGroup() != null) {\n                    DescriptionGroupMetaData descriptionGroup = tagMetaData.getDescriptionGroup();\n                    if (descriptionGroup.getIcons() != null && descriptionGroup.getIcons().value() != null\n                            && (descriptionGroup.getIcons().value().length > 0)) {\n                        Icon icon = descriptionGroup.getIcons().value()[0];\n                        tagInfo.setLargeIcon(icon.largeIcon());\n                        tagInfo.setSmallIcon(icon.smallIcon());\n                    }\n                    tagInfo.setInfoString(descriptionGroup.getDescription());\n                    tagInfo.setDisplayName(descriptionGroup.getDisplayName());\n                }\n                // Variable\n                if (tagMetaData.getVariables() != null) {\n                    for (VariableMetaData variableMetaData : tagMetaData.getVariables()) {\n                        TagVariableInfo tagVariableInfo = new TagVariableInfo();\n                        tagVariableInfo.setNameGiven(variableMetaData.getNameGiven());\n                        tagVariableInfo.setNameFromAttribute(variableMetaData.getNameFromAttribute());\n                        tagVariableInfo.setClassName(variableMetaData.getVariableClass());\n                        tagVariableInfo.setDeclare(variableMetaData.getDeclare());\n                        if (variableMetaData.getScope() != null) {\n                            tagVariableInfo.setScope(variableMetaData.getScope().toString());\n                        }\n                        tagInfo.addTagVariableInfo(tagVariableInfo);\n                    }\n                }\n                // Attribute\n                if (tagMetaData.getAttributes() != null) {\n                    for (AttributeMetaData attributeMetaData : tagMetaData.getAttributes()) {\n                        TagAttributeInfo tagAttributeInfo = new TagAttributeInfo();\n                        tagAttributeInfo.setName(attributeMetaData.getName());\n                        tagAttributeInfo.setType(attributeMetaData.getType());\n                        tagAttributeInfo.setReqTime(attributeMetaData.getRtexprvalue());\n                        tagAttributeInfo.setRequired(attributeMetaData.getRequired());\n                        tagAttributeInfo.setFragment(attributeMetaData.getFragment());\n                        if (attributeMetaData.getDeferredValue() != null) {\n                            tagAttributeInfo.setDeferredValue(\"true\");\n                            tagAttributeInfo.setExpectedTypeName(attributeMetaData.getDeferredValue().getType());\n                        } else {\n                            tagAttributeInfo.setDeferredValue(\"false\");\n                        }\n                        if (attributeMetaData.getDeferredMethod() != null) {\n                            tagAttributeInfo.setDeferredMethod(\"true\");\n                            tagAttributeInfo.setMethodSignature(attributeMetaData.getDeferredMethod().getMethodSignature());\n                        } else {\n                            tagAttributeInfo.setDeferredMethod(\"false\");\n                        }\n                        tagInfo.addTagAttributeInfo(tagAttributeInfo);\n                    }\n                }\n                tagLibraryInfo.addTagInfo(tagInfo);\n            }\n        }\n        // Tag files\n        if (tldMetaData.getTagFiles() != null) {\n            for (TagFileMetaData tagFileMetaData : tldMetaData.getTagFiles()) {\n                TagFileInfo tagFileInfo = new TagFileInfo();\n                tagFileInfo.setName(tagFileMetaData.getName());\n                tagFileInfo.setPath(tagFileMetaData.getPath());\n                tagLibraryInfo.addTagFileInfo(tagFileInfo);\n            }\n        }\n        // Function\n        if (tldMetaData.getFunctions() != null) {\n            for (FunctionMetaData functionMetaData : tldMetaData.getFunctions()) {\n                FunctionInfo functionInfo = new FunctionInfo();\n                functionInfo.setName(functionMetaData.getName());\n                functionInfo.setFunctionClass(functionMetaData.getFunctionClass());\n                functionInfo.setFunctionSignature(functionMetaData.getFunctionSignature());\n                tagLibraryInfo.addFunctionInfo(functionInfo);\n            }\n        }\n\n        if (jarPath == null && relativeLocation == null) {\n            if (!ret.containsKey(tagLibraryInfo.getUri())) {\n                ret.put(tagLibraryInfo.getUri(), tagLibraryInfo);\n            }\n        } else if (jarPath == null) {\n            tagLibraryInfo.setLocation(\"\");\n            tagLibraryInfo.setPath(relativeLocation);\n            if (!ret.containsKey(tagLibraryInfo.getUri())) {\n                ret.put(tagLibraryInfo.getUri(), tagLibraryInfo);\n            }\n            ret.put(relativeLocation, tagLibraryInfo);\n        } else {\n            tagLibraryInfo.setLocation(relativeLocation);\n            tagLibraryInfo.setPath(jarPath);\n            if (!ret.containsKey(tagLibraryInfo.getUri())) {\n                ret.put(tagLibraryInfo.getUri(), tagLibraryInfo);\n            }\n            if (jarPath.equals(\"META-INF/taglib.tld\")) {\n                ret.put(relativeLocation, tagLibraryInfo);\n            }\n        }\n        return tagLibraryInfo;\n    }","commit_id":"d00359477d1fc2a979175ac78f6957aaa223f097","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public synchronized void start(final StartContext startContext) throws StartException {\n        DeploymentInfo deploymentInfo = createServletConfig();\n        handleSessionReplication(deploymentInfo);\n        handleIdentityManager(deploymentInfo);\n\n        SessionConfigMetaData sessionConfig = mergedMetaData.getSessionConfig();\n        if(sessionConfig != null) {\n            if(sessionConfig.getSessionTimeoutSet()) {\n                deploymentInfo.setDefaultSessionTimeout(sessionConfig.getSessionTimeout() * 60);\n            }\n            CookieConfigMetaData cookieConfig = sessionConfig.getCookieConfig();\n            if(cookieConfig != null) {\n                SessionCookieConfig config = new SessionCookieConfigImpl();\n                if(cookieConfig.getName() != null) {\n                    config.setName(cookieConfig.getName());\n                }\n                config.setSecure(cookieConfig.getSecure());\n                config.setPath(cookieConfig.getPath());\n                config.setMaxAge(cookieConfig.getMaxAge());\n                config.setDomain(cookieConfig.getDomain());\n                config.setComment(cookieConfig.getComment());\n                config.setHttpOnly(cookieConfig.getHttpOnly());\n                deploymentInfo.setSessionCookieConfig(config);\n            }\n            //todo: session tracking modes\n\n        }\n\n        for (final SetupAction action : setupActions) {\n            deploymentInfo.addThreadSetupAction(new ThreadSetupAction() {\n\n                private final Handle handle = new Handle() {\n                    @Override\n                    public void tearDown() {\n                        action.teardown(Collections.<String, Object>emptyMap());\n                    }\n                };\n\n                @Override\n                public Handle setup(final HttpServerExchange exchange) {\n                    action.setup(Collections.<String, Object>emptyMap());\n                    return handle;\n                }\n            });\n        }\n\n\n        this.deploymentInfo = deploymentInfo;\n\n    }","id":93564,"modified_method":"@Override\n    public synchronized void start(final StartContext startContext) throws StartException {\n        ClassLoader oldTccl = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader(module.getClassLoader());\n            DeploymentInfo deploymentInfo = createServletConfig();\n            handleSessionReplication(deploymentInfo);\n            handleIdentityManager(deploymentInfo);\n\n            SessionConfigMetaData sessionConfig = mergedMetaData.getSessionConfig();\n            if (sessionConfig != null) {\n                if (sessionConfig.getSessionTimeoutSet()) {\n                    deploymentInfo.setDefaultSessionTimeout(sessionConfig.getSessionTimeout() * 60);\n                }\n                CookieConfigMetaData cookieConfig = sessionConfig.getCookieConfig();\n                if (cookieConfig != null) {\n                    SessionCookieConfig config = new SessionCookieConfigImpl();\n                    if (cookieConfig.getName() != null) {\n                        config.setName(cookieConfig.getName());\n                    }\n                    config.setSecure(cookieConfig.getSecure());\n                    config.setPath(cookieConfig.getPath());\n                    config.setMaxAge(cookieConfig.getMaxAge());\n                    config.setDomain(cookieConfig.getDomain());\n                    config.setComment(cookieConfig.getComment());\n                    config.setHttpOnly(cookieConfig.getHttpOnly());\n                    deploymentInfo.setSessionCookieConfig(config);\n                }\n                //todo: session tracking modes\n\n            }\n\n            for (final SetupAction action : setupActions) {\n                deploymentInfo.addThreadSetupAction(new ThreadSetupAction() {\n\n                    private final Handle handle = new Handle() {\n                        @Override\n                        public void tearDown() {\n                            action.teardown(Collections.<String, Object>emptyMap());\n                        }\n                    };\n\n                    @Override\n                    public Handle setup(final HttpServerExchange exchange) {\n                        action.setup(Collections.<String, Object>emptyMap());\n                        return handle;\n                    }\n                });\n            }\n\n\n            this.deploymentInfo = deploymentInfo;\n        } finally {\n            Thread.currentThread().setContextClassLoader(oldTccl);\n        }\n\n    }","commit_id":"d00359477d1fc2a979175ac78f6957aaa223f097","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static HashMap<String, TagLibraryInfo> createTldsInfo(final TldsMetaData tldsMetaData, List<TldMetaData> sharedTlds, final DeploymentClassIndex classReflectionIndex, final ComponentRegistry components, final DeploymentInfo d) throws ClassNotFoundException {\n\n        final HashMap<String, TagLibraryInfo> ret = new HashMap<>();\n        if (tldsMetaData != null) {\n            if (tldsMetaData.getTlds() != null) {\n                for (Map.Entry<String, TldMetaData> tld : tldsMetaData.getTlds().entrySet()) {\n                    createTldInfo(tld.getKey(), tld.getValue(), ret, classReflectionIndex, components, d);\n                }\n            }\n            if (sharedTlds != null) {\n                for (TldMetaData metaData : sharedTlds) {\n\n                    createTldInfo(null, metaData, ret, classReflectionIndex, components, d);\n                }\n            }\n        }\n\n        return ret;\n    }","id":93565,"modified_method":"private static HashMap<String, TagLibraryInfo> createTldsInfo(final TldsMetaData tldsMetaData, List<TldMetaData> sharedTlds) throws ClassNotFoundException {\n\n        final HashMap<String, TagLibraryInfo> ret = new HashMap<>();\n        if (tldsMetaData != null) {\n            if (tldsMetaData.getTlds() != null) {\n                for (Map.Entry<String, TldMetaData> tld : tldsMetaData.getTlds().entrySet()) {\n                    createTldInfo(tld.getKey(), tld.getValue(), ret);\n                }\n            }\n            if (sharedTlds != null) {\n                for (TldMetaData metaData : sharedTlds) {\n\n                    createTldInfo(null, metaData, ret);\n                }\n            }\n        }\n\n        return ret;\n    }","commit_id":"d00359477d1fc2a979175ac78f6957aaa223f097","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void addListener(final DeploymentClassIndex classReflectionIndex, final ComponentRegistry components, final DeploymentInfo d, final ListenerMetaData listener) throws ClassNotFoundException {\n\n        ListenerInfo l;\n        final Class<? extends EventListener> listenerClass = (Class<? extends EventListener>) classReflectionIndex.classIndex(listener.getListenerClass()).getModuleClass();\n        ComponentRegistry.ComponentManagedReferenceFactory creator = components.getComponentsByClass().get(listenerClass);\n        if (creator != null) {\n            InstanceFactory<EventListener> factory = createInstanceFactory(creator);\n            l = new ListenerInfo(listenerClass, factory);\n        } else {\n            l = new ListenerInfo(listenerClass);\n        }\n        d.addListener(l);\n    }","id":93566,"modified_method":"private static void addListener(final ClassLoader classLoader, final ComponentRegistry components, final DeploymentInfo d, final ListenerMetaData listener) throws ClassNotFoundException {\n\n        ListenerInfo l;\n        final Class<? extends EventListener> listenerClass = (Class<? extends EventListener>) classLoader.loadClass(listener.getListenerClass());\n        ComponentRegistry.ComponentManagedReferenceFactory creator = components.getComponentsByClass().get(listenerClass);\n        if (creator != null) {\n            InstanceFactory<EventListener> factory = createInstanceFactory(creator);\n            l = new ListenerInfo(listenerClass, factory);\n        } else {\n            l = new ListenerInfo(listenerClass);\n        }\n        d.addListener(l);\n    }","commit_id":"d00359477d1fc2a979175ac78f6957aaa223f097","url":"https://github.com/wildfly/wildfly"},{"original_method":"public UndertowDeploymentInfoService createUndertowDeploymentInfoService() {\n            return new UndertowDeploymentInfoService(mergedMetaData, deploymentName, tldsMetaData, sharedTlds, module, classReflectionIndex, injectionContainer, componentRegistry, scisMetaData, deploymentRoot, securityContextId, securityDomain, attributes, contextPath, setupActions, overlays);\n        }","id":93567,"modified_method":"public UndertowDeploymentInfoService createUndertowDeploymentInfoService() {\n            return new UndertowDeploymentInfoService(mergedMetaData, deploymentName, tldsMetaData, sharedTlds, module, injectionContainer, componentRegistry, scisMetaData, deploymentRoot, securityContextId, securityDomain, attributes, contextPath, setupActions, overlays);\n        }","commit_id":"d00359477d1fc2a979175ac78f6957aaa223f097","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processDeployment(final WarMetaData warMetaData, final DeploymentUnit deploymentUnit, final ServiceTarget serviceTarget, String hostName)\n            throws DeploymentUnitProcessingException {\n        final VirtualFile deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        if (module == null) {\n            throw new DeploymentUnitProcessingException(MESSAGES.failedToResolveModule(deploymentUnit));\n        }\n        final DeploymentClassIndex deploymentClassIndex = deploymentUnit.getAttachment(Attachments.CLASS_INDEX);\n        final JBossWebMetaData metaData = warMetaData.getMergedJBossWebMetaData();\n        final List<SetupAction> setupActions = deploymentUnit.getAttachmentList(org.jboss.as.ee.component.Attachments.WEB_SETUP_ACTIONS);\n        metaData.resolveRunAs();\n\n        ScisMetaData scisMetaData = deploymentUnit.getAttachment(ScisMetaData.ATTACHMENT_KEY);\n\n        final Set<ServiceName> dependentComponents = new HashSet<>();\n        // see AS7-2077\n        // basically we want to ignore components that have failed for whatever reason\n        // if they are important they will be picked up when the web deployment actually starts\n        final List<ServiceName> components = deploymentUnit.getAttachmentList(WebComponentDescription.WEB_COMPONENTS);\n        final Set<ServiceName> failed = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.FAILED_COMPONENTS);\n        for (final ServiceName component : components) {\n            if (!failed.contains(component)) {\n                dependentComponents.add(component);\n            }\n        }\n\n        ComponentRegistry componentRegistry = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.COMPONENT_REGISTRY);\n        if (componentRegistry == null) {\n            //we do this to avoid lots of other null checks\n            //this will only happen if the EE subsystem is not installed\n            componentRegistry = new ComponentRegistry(null);\n        }\n\n        final WebInjectionContainer injectionContainer = new WebInjectionContainer(module.getClassLoader(), componentRegistry);\n\n        String securityContextId = deploymentUnit.getName();\n        if (deploymentUnit.getParent() != null) {\n            securityContextId = deploymentUnit.getParent().getName() + \"!\" + securityContextId;\n        }\n\n        final String pathName = pathNameOfDeployment(deploymentUnit, metaData);\n\n\n\n\n        String metaDataSecurityDomain = metaData.getSecurityDomain();\n        if (metaDataSecurityDomain == null) {\n            metaDataSecurityDomain = getJBossAppSecurityDomain(deploymentUnit);\n        }\n        if (metaDataSecurityDomain != null) {\n            metaDataSecurityDomain = metaDataSecurityDomain.trim();\n        }\n\n        String securityDomain = metaDataSecurityDomain == null ? SecurityConstants.DEFAULT_APPLICATION_POLICY : SecurityUtil\n                .unprefixSecurityDomain(metaDataSecurityDomain);\n\n\n        final ServiceName deploymentServiceName = UndertowService.deploymentServiceName(hostName,pathName);\n\n        TldsMetaData tldsMetaData = deploymentUnit.getAttachment(TldsMetaData.ATTACHMENT_KEY);\n        UndertowDeploymentInfoService undertowDeploymentInfoService = UndertowDeploymentInfoService.builder()\n                        .setAttributes(deploymentUnit.getAttachment(ServletContextAttribute.ATTACHMENT_KEY))\n                .setClassReflectionIndex(deploymentClassIndex)\n                .setComponentRegistry(componentRegistry)\n                .setContextPath(pathName)\n                .setDeploymentName(deploymentUnit.getName())\n                .setDeploymentRoot(deploymentRoot)\n                .setInjectionContainer(injectionContainer)\n                .setMergedMetaData(warMetaData.getMergedJBossWebMetaData())\n                .setModule(module)\n                .setScisMetaData(scisMetaData)\n                .setSecurityContextId(securityContextId)\n                .setSecurityDomain(securityDomain)\n                .setSharedTlds(tldsMetaData == null ? Collections.<TldMetaData>emptyList() : tldsMetaData.getSharedTlds(deploymentUnit))\n                .setTldsMetaData(tldsMetaData)\n                .setSetupActions(setupActions)\n                .setOverlays(warMetaData.getOverlays())\n                .createUndertowDeploymentInfoService();\n\n        final ServiceName deploymentInfoServiceName = deploymentServiceName.append(UndertowDeploymentInfoService.SERVICE_NAME);\n        ServiceBuilder<DeploymentInfo> infoBuilder = serviceTarget.addService(deploymentInfoServiceName, undertowDeploymentInfoService)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(defaultContainer), ServletContainerService.class, undertowDeploymentInfoService.getContainer())\n                .addDependency(SecurityDomainService.SERVICE_NAME.append(securityDomain), SecurityDomainContext.class, undertowDeploymentInfoService.getSecurityDomainContextValue())\n                .addDependency(UndertowService.UNDERTOW, UndertowService.class, undertowDeploymentInfoService.getUndertowService())\n                .addDependency(ServiceBuilder.DependencyType.OPTIONAL, BufferCacheService.SERVICE_NAME.append(\"default\"), DirectBufferCache.class, undertowDeploymentInfoService.getBufferCacheInjectedValue())\n                .addDependencies(deploymentUnit.getAttachmentList(Attachments.WEB_DEPENDENCIES));\n\n\n\n        if (metaData.getDistributable() != null) {\n            DistributedCacheManagerFactoryService factoryService = new DistributedCacheManagerFactoryService();\n            DistributedCacheManagerFactory factory = factoryService.getValue();\n            if (factory != null) {\n                ServiceName factoryServiceName = deploymentServiceName.append(\"session\");\n                infoBuilder.addDependency(ServiceBuilder.DependencyType.OPTIONAL, factoryServiceName, DistributedCacheManagerFactory.class, undertowDeploymentInfoService.getDistributedCacheManagerFactoryInjectedValue());\n\n                ServiceBuilder<DistributedCacheManagerFactory> factoryBuilder = serviceTarget.addService(factoryServiceName, factoryService);\n                boolean enabled = factory.addDeploymentDependencies(deploymentServiceName, deploymentUnit.getServiceRegistry(), serviceTarget, factoryBuilder, metaData);\n                factoryBuilder.setInitialMode(enabled ? Mode.ON_DEMAND : Mode.NEVER).install();\n            }\n        }\n\n        infoBuilder.install();\n\n\n        final ServiceName hostServiceName = UndertowService.virtualHostName(defaultServer, hostName);\n        final UndertowDeploymentService service = new UndertowDeploymentService(injectionContainer);\n        final ServiceBuilder<UndertowDeploymentService> builder = serviceTarget.addService(deploymentServiceName, service)\n                .addDependencies(dependentComponents)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(defaultContainer), ServletContainerService.class, service.getContainer())\n                .addDependency(hostServiceName, Host.class, service.getHost())\n                .addDependencies(deploymentUnit.getAttachmentList(Attachments.WEB_DEPENDENCIES))\n                .addDependency(deploymentInfoServiceName, DeploymentInfo.class, service.getDeploymentInfoInjectedValue());\n\n        deploymentUnit.addToAttachmentList(Attachments.DEPLOYMENT_COMPLETE_SERVICES, deploymentServiceName);\n\n\n        // OSGi web applications are activated in {@link WebContextActivationProcessor} according to bundle lifecycle changes\n        if (deploymentUnit.hasAttachment(Attachments.OSGI_MANIFEST)) {\n            builder.setInitialMode(Mode.NEVER);\n            UndertowDeploymentService.ContextActivatorImpl activator = new UndertowDeploymentService.ContextActivatorImpl(builder.install());\n            deploymentUnit.putAttachment(ContextActivator.ATTACHMENT_KEY, activator);\n        } else {\n            builder.setInitialMode(Mode.ACTIVE);\n            builder.install();\n        }\n\n\n        // Process the web related mgmt information\n        final ModelNode node = deploymentUnit.getDeploymentSubsystemModel(UndertowExtension.SUBSYSTEM_NAME);\n        node.get(DeploymentDefinition.CONTEXT_ROOT.getName()).set(\"\".equals(pathName) ? \"/\" : pathName);\n        node.get(DeploymentDefinition.VIRTUAL_HOST.getName()).set(hostName);\n        processManagement(deploymentUnit, metaData);\n    }","id":93568,"modified_method":"private void processDeployment(final WarMetaData warMetaData, final DeploymentUnit deploymentUnit, final ServiceTarget serviceTarget, String hostName)\n            throws DeploymentUnitProcessingException {\n        final VirtualFile deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        if (module == null) {\n            throw new DeploymentUnitProcessingException(MESSAGES.failedToResolveModule(deploymentUnit));\n        }\n        final JBossWebMetaData metaData = warMetaData.getMergedJBossWebMetaData();\n        final List<SetupAction> setupActions = deploymentUnit.getAttachmentList(org.jboss.as.ee.component.Attachments.WEB_SETUP_ACTIONS);\n        metaData.resolveRunAs();\n\n        ScisMetaData scisMetaData = deploymentUnit.getAttachment(ScisMetaData.ATTACHMENT_KEY);\n\n        final Set<ServiceName> dependentComponents = new HashSet<>();\n        // see AS7-2077\n        // basically we want to ignore components that have failed for whatever reason\n        // if they are important they will be picked up when the web deployment actually starts\n        final List<ServiceName> components = deploymentUnit.getAttachmentList(WebComponentDescription.WEB_COMPONENTS);\n        final Set<ServiceName> failed = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.FAILED_COMPONENTS);\n        for (final ServiceName component : components) {\n            if (!failed.contains(component)) {\n                dependentComponents.add(component);\n            }\n        }\n\n        ComponentRegistry componentRegistry = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.COMPONENT_REGISTRY);\n        if (componentRegistry == null) {\n            //we do this to avoid lots of other null checks\n            //this will only happen if the EE subsystem is not installed\n            componentRegistry = new ComponentRegistry(null);\n        }\n\n        final WebInjectionContainer injectionContainer = new WebInjectionContainer(module.getClassLoader(), componentRegistry);\n\n        String securityContextId = deploymentUnit.getName();\n        if (deploymentUnit.getParent() != null) {\n            securityContextId = deploymentUnit.getParent().getName() + \"!\" + securityContextId;\n        }\n\n        final String pathName = pathNameOfDeployment(deploymentUnit, metaData);\n\n\n        String metaDataSecurityDomain = metaData.getSecurityDomain();\n        if (metaDataSecurityDomain == null) {\n            metaDataSecurityDomain = getJBossAppSecurityDomain(deploymentUnit);\n        }\n        if (metaDataSecurityDomain != null) {\n            metaDataSecurityDomain = metaDataSecurityDomain.trim();\n        }\n\n        String securityDomain = metaDataSecurityDomain == null ? SecurityConstants.DEFAULT_APPLICATION_POLICY : SecurityUtil\n                .unprefixSecurityDomain(metaDataSecurityDomain);\n\n\n        final ServiceName deploymentServiceName = UndertowService.deploymentServiceName(hostName,pathName);\n\n        TldsMetaData tldsMetaData = deploymentUnit.getAttachment(TldsMetaData.ATTACHMENT_KEY);\n        UndertowDeploymentInfoService undertowDeploymentInfoService = UndertowDeploymentInfoService.builder()\n                        .setAttributes(deploymentUnit.getAttachment(ServletContextAttribute.ATTACHMENT_KEY))\n                .setComponentRegistry(componentRegistry)\n                .setContextPath(pathName)\n                .setDeploymentName(deploymentUnit.getName())\n                .setDeploymentRoot(deploymentRoot)\n                .setInjectionContainer(injectionContainer)\n                .setMergedMetaData(warMetaData.getMergedJBossWebMetaData())\n                .setModule(module)\n                .setScisMetaData(scisMetaData)\n                .setSecurityContextId(securityContextId)\n                .setSecurityDomain(securityDomain)\n                .setSharedTlds(tldsMetaData == null ? Collections.<TldMetaData>emptyList() : tldsMetaData.getSharedTlds(deploymentUnit))\n                .setTldsMetaData(tldsMetaData)\n                .setSetupActions(setupActions)\n                .setOverlays(warMetaData.getOverlays())\n                .createUndertowDeploymentInfoService();\n\n        final ServiceName deploymentInfoServiceName = deploymentServiceName.append(UndertowDeploymentInfoService.SERVICE_NAME);\n        ServiceBuilder<DeploymentInfo> infoBuilder = serviceTarget.addService(deploymentInfoServiceName, undertowDeploymentInfoService)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(defaultContainer), ServletContainerService.class, undertowDeploymentInfoService.getContainer())\n                .addDependency(SecurityDomainService.SERVICE_NAME.append(securityDomain), SecurityDomainContext.class, undertowDeploymentInfoService.getSecurityDomainContextValue())\n                .addDependency(UndertowService.UNDERTOW, UndertowService.class, undertowDeploymentInfoService.getUndertowService())\n                .addDependency(ServiceBuilder.DependencyType.OPTIONAL, BufferCacheService.SERVICE_NAME.append(\"default\"), DirectBufferCache.class, undertowDeploymentInfoService.getBufferCacheInjectedValue())\n                .addDependencies(deploymentUnit.getAttachmentList(Attachments.WEB_DEPENDENCIES));\n\n\n\n        if (metaData.getDistributable() != null) {\n            DistributedCacheManagerFactoryService factoryService = new DistributedCacheManagerFactoryService();\n            DistributedCacheManagerFactory factory = factoryService.getValue();\n            if (factory != null) {\n                ServiceName factoryServiceName = deploymentServiceName.append(\"session\");\n                infoBuilder.addDependency(ServiceBuilder.DependencyType.OPTIONAL, factoryServiceName, DistributedCacheManagerFactory.class, undertowDeploymentInfoService.getDistributedCacheManagerFactoryInjectedValue());\n\n                ServiceBuilder<DistributedCacheManagerFactory> factoryBuilder = serviceTarget.addService(factoryServiceName, factoryService);\n                boolean enabled = factory.addDeploymentDependencies(deploymentServiceName, deploymentUnit.getServiceRegistry(), serviceTarget, factoryBuilder, metaData);\n                factoryBuilder.setInitialMode(enabled ? Mode.ON_DEMAND : Mode.NEVER).install();\n            }\n        }\n\n        infoBuilder.install();\n\n\n        final ServiceName hostServiceName = UndertowService.virtualHostName(defaultServer, hostName);\n        final UndertowDeploymentService service = new UndertowDeploymentService(injectionContainer);\n        final ServiceBuilder<UndertowDeploymentService> builder = serviceTarget.addService(deploymentServiceName, service)\n                .addDependencies(dependentComponents)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(defaultContainer), ServletContainerService.class, service.getContainer())\n                .addDependency(hostServiceName, Host.class, service.getHost())\n                .addDependencies(deploymentUnit.getAttachmentList(Attachments.WEB_DEPENDENCIES))\n                .addDependency(deploymentInfoServiceName, DeploymentInfo.class, service.getDeploymentInfoInjectedValue());\n\n        deploymentUnit.addToAttachmentList(Attachments.DEPLOYMENT_COMPLETE_SERVICES, deploymentServiceName);\n\n\n        // OSGi web applications are activated in {@link WebContextActivationProcessor} according to bundle lifecycle changes\n        if (deploymentUnit.hasAttachment(Attachments.OSGI_MANIFEST)) {\n            builder.setInitialMode(Mode.NEVER);\n            UndertowDeploymentService.ContextActivatorImpl activator = new UndertowDeploymentService.ContextActivatorImpl(builder.install());\n            deploymentUnit.putAttachment(ContextActivator.ATTACHMENT_KEY, activator);\n        } else {\n            builder.setInitialMode(Mode.ACTIVE);\n            builder.install();\n        }\n\n\n        // Process the web related mgmt information\n        final ModelNode node = deploymentUnit.getDeploymentSubsystemModel(UndertowExtension.SUBSYSTEM_NAME);\n        node.get(DeploymentDefinition.CONTEXT_ROOT.getName()).set(\"\".equals(pathName) ? \"/\" : pathName);\n        node.get(DeploymentDefinition.VIRTUAL_HOST.getName()).set(hostName);\n        processManagement(deploymentUnit, metaData);\n    }","commit_id":"d00359477d1fc2a979175ac78f6957aaa223f097","url":"https://github.com/wildfly/wildfly"},{"original_method":"static public void cleanup(String name, String destDir)\n    {\n        URL url;\n        try {\n            url = new URL(name);\n            if (!url.getProtocol().equals(\"file\"))\n            {\n                String prefKey = getPrefKey(url, destDir);\n                Collection<String> localPath = Main.pref.getCollection(prefKey);\n                if(localPath.size() == 2) {\n                    String[] lp = (String[]) localPath.toArray();\n                    File lfile = new File(lp[1]);\n                    if(lfile.exists()) {\n                        lfile.delete();\n                    }\n                }\n                Main.pref.put(prefKey, null);\n            }\n        } catch (java.net.MalformedURLException e) {}\n    }","id":93569,"modified_method":"static public void cleanup(String name, String destDir)\n    {\n        URL url;\n        try {\n            url = new URL(name);\n            if (!url.getProtocol().equals(\"file\"))\n            {\n                String prefKey = getPrefKey(url, destDir);\n                List<String> localPath = new ArrayList<String>(Main.pref.getCollection(prefKey));\n                if (localPath.size() == 2) {\n                    File lfile = new File(localPath.get(1));\n                    if(lfile.exists()) {\n                        lfile.delete();\n                    }\n                }\n                Main.pref.put(prefKey, null);\n            }\n        } catch (java.net.MalformedURLException e) {}\n    }","commit_id":"681fc95f99060b119eb80341d036577e014c4251","url":"https://github.com/openstreetmap/josm"},{"original_method":"private CollectionImpl mkcol( XmldbURI collPath, Date created ) throws XMLDBException, URISyntaxException\n    {\n        XmldbURI[]                      segments   = collPath.getPathSegments();\n        CollectionManagementServiceImpl mgtService;\n        Collection                      c;\n        XmldbURI                        dbUri;\n\n        if( !uri.endsWith( DBBroker.ROOT_COLLECTION ) ) {\n            dbUri = XmldbURI.xmldbUriFor( uri + DBBroker.ROOT_COLLECTION );\n        } else {\n            dbUri = XmldbURI.xmldbUriFor( uri );\n        }\n        Collection current = DatabaseManager.getCollection( dbUri.toString(), username, pass );\n        XmldbURI   p       = XmldbURI.ROOT_COLLECTION_URI;\n\n        for( int i = 1; i < segments.length; i++ ) {\n            p = p.append( segments[i] );\n            XmldbURI xmldbURI = dbUri.resolveCollectionPath( p );\n            c = DatabaseManager.getCollection( xmldbURI.toString(), username, pass );\n\n            if( c == null ) {\n                mgtService = (CollectionManagementServiceImpl)current.getService( \"CollectionManagementService\", \"1.0\" );\n\n                //current = mgtService.createCollection(token);\n                current    = mgtService.createCollection( segments[i], created );\n            } else {\n                current = c;\n            }\n        }\n        ((CollectionImpl)current).setTriggersEnabled(false);\n        return( (CollectionImpl)current );\n    }","id":93570,"modified_method":"private CollectionImpl mkcol( XmldbURI collPath, Date created ) throws XMLDBException, URISyntaxException\n    {\n        XmldbURI[]                      segments   = collPath.getPathSegments();\n        CollectionManagementServiceImpl mgtService;\n        CollectionImpl                  c;\n        XmldbURI                        dbUri;\n\n        if( !uri.endsWith( DBBroker.ROOT_COLLECTION ) ) {\n            dbUri = XmldbURI.xmldbUriFor( uri + DBBroker.ROOT_COLLECTION );\n        } else {\n            dbUri = XmldbURI.xmldbUriFor( uri );\n        }\n        CollectionImpl current = (CollectionImpl)DatabaseManager.getCollection( dbUri.toString(), username, pass );\n        XmldbURI       p       = XmldbURI.ROOT_COLLECTION_URI;\n\n        for( int i = 1; i < segments.length; i++ ) {\n            p = p.append( segments[i] );\n            XmldbURI xmldbURI = dbUri.resolveCollectionPath( p );\n            c = (CollectionImpl)DatabaseManager.getCollection( xmldbURI.toString(), username, pass );\n            if( c == null ) {\n            \tcurrent.setTriggersEnabled(false);\n                mgtService = (CollectionManagementServiceImpl)current.getService( \"CollectionManagementService\", \"1.0\" );\n                c = (CollectionImpl)mgtService.createCollection( segments[i], created );\n                current.setTriggersEnabled(true);\n            }\n            current = c;\n        }\n        return current;\n    }","commit_id":"f66ed70ab3c122f2eb68121e16c287366c1eabc3","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * @see  org.xml.sax.ContentHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)\n     */\n    public void startElement( String namespaceURI, String localName, String qName, Attributes atts ) throws SAXException\n    {\n        if( namespaceURI.equals( Namespaces.EXIST_NS ) ) {\n\n            if( localName.equals( \"collection\" ) ) {\n                final String name       = atts.getValue( \"name\" );\n                final String owner      = atts.getValue( \"owner\" );\n                final String group      = atts.getValue( \"group\" );\n                final String mode       = atts.getValue( \"mode\" );\n                final String created    = atts.getValue( \"created\" );\n                String       strVersion = atts.getValue( \"version\" );\n\n                if( strVersion != null ) {\n\n                    try {\n                        this.version = Integer.parseInt( strVersion );\n                    }\n                    catch( NumberFormatException e ) {\n                        this.version = 0;\n                    }\n                }\n\n\n                if( name == null ) {\n                    throw( new SAXException( \"collection requires a name \" + \"attribute\" ) );\n                }\n\n                try {\n                    listener.createCollection( name );\n                    XmldbURI collUri;\n\n                    if( version >= strictUriVersion ) {\n                        collUri = XmldbURI.create( name );\n                    } else {\n\n                        try {\n                            collUri = URIUtils.encodeXmldbUriFor( name );\n                        }\n                        catch( URISyntaxException e ) {\n                            listener.warn( \"Could not parse document name into a URI: \" + e.getMessage() );\n                            return;\n                        }\n                    }\n\n                    Date date_created = null;\n\n                    if( created != null ) {\n\n                        try {\n                            date_created = new DateTimeValue( created ).getDate();\n                        }\n                        catch( XPathException e2 ) {\n                        }\n                    }\n\n\n                    current = mkcol( collUri, date_created );\n\n                    if( current == null ) {\n                        throw( new SAXException( \"Collection not found: \" + collUri ) );\n                    }\n                    UserManagementService service = (UserManagementService)current.getService( \"UserManagementService\", \"1.0\" );\n                    Account                  u    = new UserAider( owner, new GroupAider( group ) );\n                    service.chown( u, group );\n                    service.chmod( Integer.parseInt( mode, 8 ) );\n                }\n                catch( Exception e ) {\n                    listener.warn( \"An unrecoverable error occurred while restoring\\ncollection '\" + name + \"'. \" + \"Aborting restore!\" );\n                    e.printStackTrace();\n                    throw( new SAXException( e.getMessage(), e ) );\n                }\n\n                if( dialog != null ) {\n                    dialog.setCollection( name );\n                }\n            } else if( localName.equals( \"subcollection\" ) ) {\n\n                String name = atts.getValue( \"filename\" );\n\n                if( name == null ) {\n                    name = atts.getValue( \"name\" );\n                }\n\n                BackupDescriptor subbd = contents.getChildBackupDescriptor( name );\n\n                if( subbd != null ) {\n                    stack.push( subbd );\n                } else {\n                    listener.warn( \"collection \" + contents.getSymbolicPath(name, false) + \" does not exist or is not readable.\" );\n                }\n            } else if( localName.equals( \"resource\" ) ) {\n                String skip = atts.getValue( \"skip\" );\n\n                if( ( skip == null ) || skip.equals( \"no\" ) ) {\n                    String type = atts.getValue( \"type\" );\n\n                    if( type == null ) {\n                        type = \"XMLResource\";\n                    }\n                    final String name        = atts.getValue( \"name\" );\n                    final String owner       = atts.getValue( \"owner\" );\n                    final String group       = atts.getValue( \"group\" );\n                    final String perms       = atts.getValue( \"mode\" );\n\n                    String       filename    = atts.getValue( \"filename\" );\n                    final String mimetype    = atts.getValue( \"mimetype\" );\n                    final String created     = atts.getValue( \"created\" );\n                    final String modified    = atts.getValue( \"modified\" );\n\n                    final String publicid    = atts.getValue( \"publicid\" );\n                    final String systemid    = atts.getValue( \"systemid\" );\n                    final String namedoctype = atts.getValue( \"namedoctype\" );\n\n                    if( filename == null ) {\n                        filename = name;\n                    }\n\n                    if( name == null ) {\n                        listener.warn( \"Wrong entry in backup descriptor: resource requires a name attribute.\" );\n                    }\n                    XmldbURI docUri;\n\n                    if( version >= strictUriVersion ) {\n                        docUri = XmldbURI.create( name );\n                    } else {\n\n                        try {\n                            docUri = URIUtils.encodeXmldbUriFor( name );\n                        }\n                        catch( URISyntaxException e ) {\n                            listener.warn( \"Could not parse document name into a URI: \" + e.getMessage() );\n                            return;\n                        }\n                    }\n                    EXistInputSource is = contents.getInputSource( filename );\n\n                    if( is == null ) {\n                    \tString msg = \"Failed to restore resource '\" + name + \"'\\nfrom file '\" + contents.getSymbolicPath( name, false ) + \"'.\\nReason: Unable to obtain its EXistInputSource\";\n                    \t\n                        listener.warn( msg );\n                        throw( new RuntimeException( msg ) );\n                    }\n\n                    try {\n\n                        if( ( dialog != null ) && ( current instanceof Observable ) ) {\n                            ( (Observable)current ).addObserver( dialog.getObserver() );\n                        }\n\n                        if( dialog != null ) {\n                            dialog.setResource( name );\n                        }\n                        Resource res = current.createResource( docUri.toString(), type );\n\n                        if( mimetype != null ) {\n                            ( (EXistResource)res ).setMimeType( mimetype );\n                        }\n\n                        if( is.getByteStreamLength() > 0 ) {\n                            res.setContent( is );\n                        } else {\n                        \tif (type.equals(\"BinaryResource\"))\n                        \t\tres.setContent( \"\" );\n                        \telse\n                        \t\tres = null;\n                        }\n\n                        // Restoring name\n\n                        if (res != null) {\n\t\t\t\t\t\t\tDate date_created = null;\n\t\t\t\t\t\t\tDate date_modified = null;\n\t\t\t\t\t\t\tif (created != null) {\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tdate_created = (new DateTimeValue(created))\n\t\t\t\t\t\t\t\t\t\t\t.getDate();\n\t\t\t\t\t\t\t\t} catch (XPathException e2) {\n\t\t\t\t\t\t\t\t\tlistener.warn(\"Illegal creation date. Skipping ...\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (modified != null) {\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tdate_modified = (Date) (new DateTimeValue(\n\t\t\t\t\t\t\t\t\t\t\tmodified)).getDate();\n\t\t\t\t\t\t\t\t} catch (XPathException e2) {\n\t\t\t\t\t\t\t\t\tlistener.warn(\"Illegal modification date. Skipping ...\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrent.storeResource(res, date_created,\n\t\t\t\t\t\t\t\t\tdate_modified);\n\t\t\t\t\t\t\tif ((publicid != null) || (systemid != null)) {\n\t\t\t\t\t\t\t\tDocumentType doctype = new DocumentTypeImpl(\n\t\t\t\t\t\t\t\t\t\tnamedoctype, publicid, systemid);\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t((EXistResource) res).setDocType(doctype);\n\t\t\t\t\t\t\t\t} catch (XMLDBException e1) {\n\t\t\t\t\t\t\t\t\te1.printStackTrace();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tUserManagementService service = (UserManagementService) current\n\t\t\t\t\t\t\t\t\t.getService(\"UserManagementService\", \"1.0\");\n\t\t\t\t\t\t\tAccount u = new UserAider(owner, new GroupAider(group));\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tservice.chown(res, u, group);\n\t\t\t\t\t\t\t} catch (XMLDBException e1) {\n\t\t\t\t\t\t\t\tlistener.warn(\"Failed to change owner on document '\"\n\t\t\t\t\t\t\t\t\t\t+ name + \"'; skipping ...\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tservice.chmod(res, Integer.parseInt(perms, 8));\n\t\t\t\t\t\t} else {\n\t                    \tlistener.warn(\"Failed to restore resource '\" + name + \"'\\nfrom file '\" + contents.getSymbolicPath( name, false ) + \n\t                    \t\t\t\"'. The resource is empty.\");\n\t                    }\n\t\t\t\t\t\tlistener.restored( name );\n                    }\n                    catch( Exception e ) {\n                        listener.warn( \"Failed to restore resource '\" + name + \"'\\nfrom file '\" + contents.getSymbolicPath( name, false ) + \"'.\\nReason: \" + e.getMessage() );\n                        e.printStackTrace();\n//                        throw( new RuntimeException( e ) );\n                    }\n                    finally {\n                        is.close();\n                    }\n                }\n            } else if( localName.equals( \"deleted\" ) ) {\n                final String name = atts.getValue( \"name\" );\n                final String type = atts.getValue( \"type\" );\n\n                if( type.equals( \"collection\" ) ) {\n\n                    try {\n                        Collection child = current.getChildCollection( name );\n\n                        if( child != null ) {\n                            CollectionManagementService cmgt = (CollectionManagementService)current.getService( \"CollectionManagementService\", \"1.0\" );\n                            cmgt.removeCollection( name );\n                        }\n                    }\n                    catch( XMLDBException e ) {\n                        listener.warn( \"Failed to remove deleted collection: \" + name + \": \" + e.getMessage() );\n                    }\n                } else if( type.equals( \"resource\" ) ) {\n\n                    try {\n                        Resource resource = current.getResource( name );\n\n                        if( resource != null ) {\n                            current.removeResource( resource );\n                        }\n                    }\n                    catch( XMLDBException e ) {\n                        listener.warn( \"Failed to remove deleted resource: \" + name + \": \" + e.getMessage() );\n                    }\n                }\n            }\n        }\n    }","id":93571,"modified_method":"/**\n     * @see  org.xml.sax.ContentHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)\n     */\n    public void startElement( String namespaceURI, String localName, String qName, Attributes atts ) throws SAXException\n    {\n        if( namespaceURI.equals( Namespaces.EXIST_NS ) ) {\n\n            if( localName.equals( \"collection\" ) ) {\n            \t\n                final String name       = atts.getValue( \"name\" );\n                final String owner      = atts.getValue( \"owner\" );\n                final String group      = atts.getValue( \"group\" );\n                final String mode       = atts.getValue( \"mode\" );\n                final String created    = atts.getValue( \"created\" );\n                String       strVersion = atts.getValue( \"version\" );\n\n                if( strVersion != null ) {\n\n                    try {\n                        this.version = Integer.parseInt( strVersion );\n                    }\n                    catch( NumberFormatException e ) {\n                        this.version = 0;\n                    }\n                }\n\n\n                if( name == null ) {\n                    throw( new SAXException( \"collection requires a name \" + \"attribute\" ) );\n                }\n\n                try {\n                    listener.createCollection( name );\n                    XmldbURI collUri;\n\n                    if( version >= strictUriVersion ) {\n                        collUri = XmldbURI.create( name );\n                    } else {\n\n                        try {\n                            collUri = URIUtils.encodeXmldbUriFor( name );\n                        }\n                        catch( URISyntaxException e ) {\n                            listener.warn( \"Could not parse document name into a URI: \" + e.getMessage() );\n                            return;\n                        }\n                    }\n\n                    Date date_created = null;\n\n                    if( created != null ) {\n\n                        try {\n                            date_created = new DateTimeValue( created ).getDate();\n                        }\n                        catch( XPathException e2 ) {\n                        }\n                    }\n                    \n                    current = mkcol( collUri, date_created );\n\n                    if( current == null ) {\n                        throw( new SAXException( \"Collection not found: \" + collUri ) );\n                    }\n                    \n                    UserManagementService service = (UserManagementService)current.getService( \"UserManagementService\", \"1.0\" );\n                    Account                  u    = new UserAider( owner, new GroupAider( group ) );\n                    service.chown( u, group );\n                    service.chmod( Integer.parseInt( mode, 8 ) );\n                }\n                catch( Exception e ) {\n                    listener.warn( \"An unrecoverable error occurred while restoring\\ncollection '\" + name + \"'. \" + \"Aborting restore!\" );\n                    e.printStackTrace();\n                    throw( new SAXException( e.getMessage(), e ) );\n                }\n\n                if( dialog != null ) {\n                    dialog.setCollection( name );\n                }\n            } else if( localName.equals( \"subcollection\" ) ) {\n\n                String name = atts.getValue( \"filename\" );\n\n                if( name == null ) {\n                    name = atts.getValue( \"name\" );\n                }\n\n                BackupDescriptor subbd = contents.getChildBackupDescriptor( name );\n\n                if( subbd != null ) {\n                    stack.push( subbd );\n                } else {\n                    listener.warn( \"collection \" + contents.getSymbolicPath(name, false) + \" does not exist or is not readable.\" );\n                }\n            } else if( localName.equals( \"resource\" ) ) {\n                String skip = atts.getValue( \"skip\" );\n\n                if( ( skip == null ) || skip.equals( \"no\" ) ) {\n                    String type = atts.getValue( \"type\" );\n\n                    if( type == null ) {\n                        type = \"XMLResource\";\n                    }\n                    final String name        = atts.getValue( \"name\" );\n                    final String owner       = atts.getValue( \"owner\" );\n                    final String group       = atts.getValue( \"group\" );\n                    final String perms       = atts.getValue( \"mode\" );\n\n                    String       filename    = atts.getValue( \"filename\" );\n                    final String mimetype    = atts.getValue( \"mimetype\" );\n                    final String created     = atts.getValue( \"created\" );\n                    final String modified    = atts.getValue( \"modified\" );\n\n                    final String publicid    = atts.getValue( \"publicid\" );\n                    final String systemid    = atts.getValue( \"systemid\" );\n                    final String namedoctype = atts.getValue( \"namedoctype\" );\n\n                    if( filename == null ) {\n                        filename = name;\n                    }\n\n                    if( name == null ) {\n                        listener.warn( \"Wrong entry in backup descriptor: resource requires a name attribute.\" );\n                    }\n                    XmldbURI docUri;\n\n                    if( version >= strictUriVersion ) {\n                        docUri = XmldbURI.create( name );\n                    } else {\n\n                        try {\n                            docUri = URIUtils.encodeXmldbUriFor( name );\n                        }\n                        catch( URISyntaxException e ) {\n                            listener.warn( \"Could not parse document name into a URI: \" + e.getMessage() );\n                            return;\n                        }\n                    }\n                    EXistInputSource is = contents.getInputSource( filename );\n\n                    if( is == null ) {\n                    \tString msg = \"Failed to restore resource '\" + name + \"'\\nfrom file '\" + contents.getSymbolicPath( name, false ) + \"'.\\nReason: Unable to obtain its EXistInputSource\";\n                    \t\n                        listener.warn( msg );\n                        throw( new RuntimeException( msg ) );\n                    }\n\n                    try {\n\n                        if( ( dialog != null ) && ( current instanceof Observable ) ) {\n                            ( (Observable)current ).addObserver( dialog.getObserver() );\n                        }\n\n                        if( dialog != null ) {\n                            dialog.setResource( name );\n                        }\n                        \n                        current.setTriggersEnabled(false);\n                        \n                        Resource res = current.createResource( docUri.toString(), type );\n\n                        if( mimetype != null ) {\n                            ( (EXistResource)res ).setMimeType( mimetype );\n                        }\n\n                        if( is.getByteStreamLength() > 0 ) {\n                            res.setContent( is );\n                        } else {\n                        \tif (type.equals(\"BinaryResource\"))\n                        \t\tres.setContent( \"\" );\n                        \telse\n                        \t\tres = null;\n                        }\n\n                        // Restoring name\n\n                        if (res != null) {\n\t\t\t\t\t\t\tDate date_created = null;\n\t\t\t\t\t\t\tDate date_modified = null;\n\t\t\t\t\t\t\tif (created != null) {\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tdate_created = (new DateTimeValue(created))\n\t\t\t\t\t\t\t\t\t\t\t.getDate();\n\t\t\t\t\t\t\t\t} catch (XPathException e2) {\n\t\t\t\t\t\t\t\t\tlistener.warn(\"Illegal creation date. Skipping ...\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (modified != null) {\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tdate_modified = (Date) (new DateTimeValue(\n\t\t\t\t\t\t\t\t\t\t\tmodified)).getDate();\n\t\t\t\t\t\t\t\t} catch (XPathException e2) {\n\t\t\t\t\t\t\t\t\tlistener.warn(\"Illegal modification date. Skipping ...\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrent.storeResource(res, date_created, date_modified);\n\t\t\t\t\t\t\tif ((publicid != null) || (systemid != null)) {\n\t\t\t\t\t\t\t\tDocumentType doctype = new DocumentTypeImpl(\n\t\t\t\t\t\t\t\t\t\tnamedoctype, publicid, systemid);\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t((EXistResource) res).setDocType(doctype);\n\t\t\t\t\t\t\t\t} catch (XMLDBException e1) {\n\t\t\t\t\t\t\t\t\te1.printStackTrace();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tUserManagementService service = (UserManagementService) current.getService(\"UserManagementService\", \"1.0\");\n\t\t\t\t\t\t\tAccount u = new UserAider(owner, new GroupAider(group));\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tservice.chown(res, u, group);\n\t\t\t\t\t\t\t} catch (XMLDBException e1) {\n\t\t\t\t\t\t\t\tlistener.warn(\"Failed to change owner on document '\"\n\t\t\t\t\t\t\t\t\t\t+ name + \"'; skipping ...\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tservice.chmod(res, Integer.parseInt(perms, 8));\n\t\t\t\t\t\t\t\n\t                    \tcurrent.setTriggersEnabled(true);\n\n\t\t\t\t\t\t} else {\n\t                    \tlistener.warn(\"Failed to restore resource '\" + name + \"'\\nfrom file '\" + contents.getSymbolicPath( name, false ) + \n\t                    \t\t\t\"'. The resource is empty.\");\n\t                    }\n\t\t\t\t\t\tlistener.restored( name );\n                    }\n                    catch( Exception e ) {\n                        listener.warn( \"Failed to restore resource '\" + name + \"'\\nfrom file '\" + contents.getSymbolicPath( name, false ) + \"'.\\nReason: \" + e.getMessage() );\n                        e.printStackTrace();\n//                        throw( new RuntimeException( e ) );\n                    }\n                    finally {\n                        is.close();\n                    }\n                }\n            } else if( localName.equals( \"deleted\" ) ) {\n                final String name = atts.getValue( \"name\" );\n                final String type = atts.getValue( \"type\" );\n\n                if( type.equals( \"collection\" ) ) {\n\n                    try {\n                        Collection child = current.getChildCollection( name );\n\n                        if( child != null ) {\n                        \tcurrent.setTriggersEnabled(false);\n                            CollectionManagementService cmgt = (CollectionManagementService)current.getService( \"CollectionManagementService\", \"1.0\" );\n                            cmgt.removeCollection( name );\n                        \tcurrent.setTriggersEnabled(true);\n                        }\n                    }\n                    catch( XMLDBException e ) {\n                        listener.warn( \"Failed to remove deleted collection: \" + name + \": \" + e.getMessage() );\n                    }\n                } else if( type.equals( \"resource\" ) ) {\n\n                    try {\n                        Resource resource = current.getResource( name );\n\n                        if( resource != null ) {\n                        \tcurrent.setTriggersEnabled(false);\n                            current.removeResource( resource );\n                        \tcurrent.setTriggersEnabled(true);\n                        }\n                    }\n                    catch( XMLDBException e ) {\n                        listener.warn( \"Failed to remove deleted resource: \" + name + \": \" + e.getMessage() );\n                    }\n                }\n            }\n        }\n    }","commit_id":"f66ed70ab3c122f2eb68121e16c287366c1eabc3","url":"https://github.com/eXist-db/exist"},{"original_method":"public void updateTable() throws Exception {\n\t\t_calledUpdateTable = true;\n\n\t\tString tempFileName = generateTempFile();\n\n\t\ttry {\n\t\t\tDBUtil dbUtil = DBUtil.getInstance();\n\n\t\t\tif (Validator.isNotNull(getCreateSQL())) {\n\t\t\t\tdbUtil.runSQL(\"drop table \" + getTableName());\n\n\t\t\t\tdbUtil.runSQL(getCreateSQL());\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(tempFileName)) {\n\t\t\t\tdbUtil.runSQL(getDeleteSQL());\n\n\t\t\t\tpopulateTable(tempFileName);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (Validator.isNotNull(tempFileName)) {\n\t\t\t\tFileUtil.delete(tempFileName);\n\t\t\t}\n\t\t}\n\t}","id":93572,"modified_method":"public void updateTable() throws Exception {\n\t\t_calledUpdateTable = true;\n\n\t\tString tempFileName = generateTempFile();\n\n\t\ttry {\n\t\t\tDBUtil dbUtil = DBUtil.getInstance();\n\n\t\t\tString createSQL = getCreateSQL();\n\n\t\t\tif (Validator.isNotNull(createSQL)) {\n\t\t\t\tdbUtil.runSQL(\"drop table \" + getTableName());\n\n\t\t\t\tdbUtil.runSQL(createSQL);\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(tempFileName)) {\n\t\t\t\tString deleteSQL = getDeleteSQL();\n\n\t\t\t\tdbUtil.runSQL(deleteSQL);\n\n\t\t\t\tpopulateTable(tempFileName);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (Validator.isNotNull(tempFileName)) {\n\t\t\t\tFileUtil.delete(tempFileName);\n\t\t\t}\n\t\t}\n\t}","commit_id":"b5505b2d5d6ff5631029a9771d4f8fcdf5da3319","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doConvert() throws Exception {\n\t\ttry {\n\t\t\tBatchSessionUtil.setEnabled(true);\n\n\t\t\t_initialize();\n\n\t\t\t// Users_Permissions\n\n\t\t\t_convertPermissions(\n\t\t\t\tRoleConstants.TYPE_REGULAR,\n\t\t\t\t\"Users_Permissions\",\n\t\t\t\tnew String[] { \"userId\" },\n\t\t\t\t\"Users_Roles\",\n\t\t\t\tnew Object[][] {\n\t\t\t\t\t{ \"userId\", Types.BIGINT },\n\t\t\t\t\t{ \"roleId\", Types.BIGINT }\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// Groups_Permissions\n\n\t\t\t_convertPermissions(\n\t\t\t\t\tRoleConstants.TYPE_COMMUNITY,\n\t\t\t\t\t\"Groups_Permissions\",\n\t\t\t\t\tnew String[] { \"groupId\" },\n\t\t\t\t\t\"Groups_Roles\",\n\t\t\t\t\tnew Object[][] {\n\t\t\t\t\t\t{ \"groupId\", Types.BIGINT },\n\t\t\t\t\t\t{ \"roleId\", Types.BIGINT }\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t// OrgGroupPermission\n\n\t\t\t_convertPermissions(\n\t\t\t\t\tRoleConstants.TYPE_ORGANIZATION,\n\t\t\t\t\t\"OrgGroupPermission\",\n\t\t\t\t\tnew String[] { \"organizationId\", \"groupId\" },\n\t\t\t\t\t\"OrgGroupRole\",\n\t\t\t\t\tnew Object[][] {\n\t\t\t\t\t\t{ \"organizationId\", Types.BIGINT },\n\t\t\t\t\t\t{ \"groupId\", Types.BIGINT },\n\t\t\t\t\t\t{ \"roleId\", Types.BIGINT }\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t// Cleanup\n\n\t\t\tPermissionCacheUtil.clearCache();\n\n\t\t\t_log.info(\n\t\t\t\t\"Please set \" + PropsKeys.PERMISSIONS_USER_CHECK_ALGORITHM +\n\t\t\t\t\t\" in your portal-ext.properties to use algorithm 5\");\n\n\t\t\tPropsValues.PERMISSIONS_USER_CHECK_ALGORITHM = 5;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.fatal(e);\n\t\t}\n\t\tfinally {\n\t\t\tCacheRegistry.clear();\n\n\t\t\tBatchSessionUtil.setEnabled(false);\n\t\t}\n\t}","id":93573,"modified_method":"protected void doConvert() throws Exception {\n\t\ttry {\n\t\t\tBatchSessionUtil.setEnabled(true);\n\n\t\t\t_convert();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.fatal(e, e);\n\t\t}\n\t\tfinally {\n\t\t\tCacheRegistry.clear();\n\n\t\t\tBatchSessionUtil.setEnabled(false);\n\t\t}\n\t}","commit_id":"b5505b2d5d6ff5631029a9771d4f8fcdf5da3319","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _initialize() throws Exception {\n\n\t\t// System Roles and Users\n\n\t\tlong[] companyIds = PortalInstances.getCompanyIds();\n\n\t\t_defaultRolesMap = new HashMap<Long, Role[]>();\n\t\t_ownerRolesMap = new HashMap<Long, Role>();\n\t\t_guestRolesMap = new HashMap<Long, Role>();\n\t\t_guestUsersSet = new HashSet<Long>();\n\t\t_rolesPermissions = new HashSet<String>();\n\n\t\tfor (long companyId : companyIds) {\n\t\t\t_defaultRolesMap.put(\n\t\t\t\tcompanyId, new Role[] {\n\t\t\t\t\tRoleLocalServiceUtil.getRole(\n\t\t\t\t\t\t\tcompanyId, RoleConstants.COMMUNITY_MEMBER),\n\t\t\t\t\tRoleLocalServiceUtil.getRole(\n\t\t\t\t\t\tcompanyId, RoleConstants.ORGANIZATION_MEMBER),\n\t\t\t\t\tRoleLocalServiceUtil.getRole(\n\t\t\t\t\t\tcompanyId, RoleConstants.POWER_USER),\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\tRole ownerRole = RoleLocalServiceUtil.getRole(\n\t\t\t\tcompanyId, RoleConstants.OWNER);\n\n\t\t\t_ownerRolesMap.put(companyId, ownerRole);\n\n\t\t\tRole guestRole = RoleLocalServiceUtil.getRole(\n\t\t\t\tcompanyId, RoleConstants.GUEST);\n\n\t\t\t_guestRolesMap.put(companyId, guestRole);\n\n\t\t\t_guestUsersSet.add(\n\t\t\t\tUserLocalServiceUtil.getDefaultUserId(companyId));\n\t\t}\n\n\t\t// Roles_Permissions for GUEST\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getConnection();\n\n\t\t\tps = con.prepareStatement(\"SELECT * FROM Roles_Permissions \");\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tlong roleId = rs.getLong(\"roleId\");\n\t\t\t\tlong permissionId = rs.getLong(\"permissionId\");\n\n\t\t\t\t_rolesPermissions.add(roleId + \"_\" + permissionId);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\n\t\t// Groups\n\n\t\tList<Group> groups = GroupLocalServiceUtil.getGroups(\n\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\t_groupsMap = new HashMap<Long, Group>(groups.size());\n\n\t\tfor (Group group : groups) {\n\t\t\t_groupsMap.put(group.getGroupId(), group);\n\t\t}\n\n\t\t// Cache ResourceActions for unknown portlets\n\n\t\tList<ResourceCode> resourceCodes =\n\t\t\tResourceCodeLocalServiceUtil.getResourceCodes(\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (ResourceCode resourceCode : resourceCodes) {\n\t\t\tString name = resourceCode.getName();\n\n\t\t\tif (!name.contains(StringPool.PERIOD)) {\n\t\t\t\tResourceActionsUtil.getPortletResourceActions(name);\n\t\t\t}\n\t\t}\n\t}","id":93574,"modified_method":"private void _initialize() throws Exception {\n\n\t\t// System roles and default users\n\n\t\tlong[] companyIds = PortalInstances.getCompanyIds();\n\n\t\tfor (long companyId : companyIds) {\n\t\t\t_defaultRolesMap.put(\n\t\t\t\tcompanyId,\n\t\t\t\tnew Role[] {\n\t\t\t\t\t\tRoleLocalServiceUtil.getRole(\n\t\t\t\t\t\t\tcompanyId, RoleConstants.COMMUNITY_MEMBER),\n\t\t\t\t\t\tRoleLocalServiceUtil.getRole(\n\t\t\t\t\t\t\tcompanyId, RoleConstants.ORGANIZATION_MEMBER),\n\t\t\t\t\t\tRoleLocalServiceUtil.getRole(\n\t\t\t\t\t\t\tcompanyId, RoleConstants.POWER_USER),\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\tRole guestRole = RoleLocalServiceUtil.getRole(\n\t\t\t\tcompanyId, RoleConstants.GUEST);\n\n\t\t\t_guestRolesMap.put(companyId, guestRole);\n\n\t\t\tRole ownerRole = RoleLocalServiceUtil.getRole(\n\t\t\t\tcompanyId, RoleConstants.OWNER);\n\n\t\t\t_ownerRolesMap.put(companyId, ownerRole);\n\n\t\t\tlong defaultUserId = UserLocalServiceUtil.getDefaultUserId(\n\t\t\t\tcompanyId);\n\n\t\t\t_guestUsersSet.add(defaultUserId);\n\t\t}\n\n\t\t// Roles_Permissions\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getConnection();\n\n\t\t\tps = con.prepareStatement(\"SELECT * FROM Roles_Permissions\");\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tlong roleId = rs.getLong(\"roleId\");\n\t\t\t\tlong permissionId = rs.getLong(\"permissionId\");\n\n\t\t\t\t_rolesPermissions.add(roleId + \"_\" + permissionId);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\n\t\t// Groups\n\n\t\tList<Group> groups = GroupLocalServiceUtil.getGroups(\n\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (Group group : groups) {\n\t\t\t_groupsMap.put(group.getGroupId(), group);\n\t\t}\n\n\t\t// Resource actions for unknown portlets\n\n\t\tList<ResourceCode> resourceCodes =\n\t\t\tResourceCodeLocalServiceUtil.getResourceCodes(\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (ResourceCode resourceCode : resourceCodes) {\n\t\t\tString name = resourceCode.getName();\n\n\t\t\tif (!name.contains(StringPool.PERIOD)) {\n\t\t\t\tResourceActionsUtil.getPortletResourceActions(name);\n\t\t\t}\n\t\t}\n\t}","commit_id":"b5505b2d5d6ff5631029a9771d4f8fcdf5da3319","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String _convertGuestUsers(String legacyFile) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new FileReader(legacyFile));\n\t\tBufferedWriter bw1 =\n\t\t\tnew BufferedWriter(new FileWriter(legacyFile + _UPDATED));\n\t\tBufferedWriter bw2 =\n\t\t\tnew BufferedWriter(new FileWriter(legacyFile + _ROLE_PERM_MAP_EXT));\n\n\t\ttry {\n\t\t\tString line = null;\n\n\t\t\twhile (Validator.isNotNull(line = br.readLine())) {\n\t\t\t\tString[] values = StringUtil.split(line);\n\n\t\t\t\tlong userId = PermissionView.getPrimaryKey(values);\n\t\t\t\tlong permissionId = PermissionView.getPermissionId(values);\n\t\t\t\tlong companyId = PermissionView.getCompanyId(values);\n\t\t\t\tint scope = PermissionView.getScopeId(values);\n\n\t\t\t\tif (scope == ResourceConstants.SCOPE_INDIVIDUAL &&\n\t\t\t\t\t_guestUsersSet.contains(userId)) {\n\n\t\t\t\t\tlong roleId = _guestRolesMap.get(companyId).getRoleId();\n\n\t\t\t\t\tString key = roleId + \"_\" + permissionId;\n\n\t\t\t\t\tif (_rolesPermissions.contains(key)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t_rolesPermissions.add(key);\n\t\t\t\t\t}\n\n\t\t\t\t\tbw2.write(roleId + \",\" + permissionId + \"\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbw1.write(line + \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tbr.close();\n\t\t\tbw1.close();\n\t\t\tbw2.close();\n\t\t}\n\n\t\tTable table = new Table(\n\t\t\t\t\"Roles_Permissions\",\n\t\t\t\tnew Object[][] {\n\t\t\t\t\t{ \"roleId\", Types.BIGINT },\n\t\t\t\t\t{ \"permissionId\", Types.BIGINT }\n\t\t\t\t});\n\n\t\ttable.populateTable(legacyFile + _ROLE_PERM_MAP_EXT);\n\n\t\tFileUtil.delete(legacyFile);\n\t\tFileUtil.delete(legacyFile + _ROLE_PERM_MAP_EXT);\n\n\t\treturn legacyFile + _UPDATED;\n\t}","id":93575,"modified_method":"private String _convertGuestUsers(String legacyFile) throws Exception {\n\t\tBufferedReader legacyFileReader = new BufferedReader(\n\t\t\tnew FileReader(legacyFile));\n\n\t\tBufferedWriter legacyFileUpdatedWriter = new BufferedWriter(\n\t\t\tnew FileWriter(legacyFile + _UPDATED));\n\t\tBufferedWriter legacyFileExtRolesPermissionsWriter = new BufferedWriter(\n\t\t\tnew FileWriter(legacyFile + _EXT_ROLES_PERMIMISSIONS));\n\n\t\ttry {\n\t\t\tString line = null;\n\n\t\t\twhile (Validator.isNotNull(line = legacyFileReader.readLine())) {\n\t\t\t\tString[] values = StringUtil.split(line);\n\n\t\t\t\tlong companyId = PermissionView.getCompanyId(values);\n\t\t\t\tlong permissionId = PermissionView.getPermissionId(values);\n\t\t\t\tint scope = PermissionView.getScopeId(values);\n\t\t\t\tlong userId = PermissionView.getPrimaryKey(values);\n\n\t\t\t\tif ((scope == ResourceConstants.SCOPE_INDIVIDUAL) &&\n\t\t\t\t\t(_guestUsersSet.contains(userId))) {\n\n\t\t\t\t\tlong roleId = _guestRolesMap.get(companyId).getRoleId();\n\n\t\t\t\t\tString key = roleId + \"_\" + permissionId;\n\n\t\t\t\t\tif (_rolesPermissions.contains(key)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t_rolesPermissions.add(key);\n\t\t\t\t\t}\n\n\t\t\t\t\tlegacyFileExtRolesPermissionsWriter.write(\n\t\t\t\t\t\troleId + \",\" + permissionId + \"\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlegacyFileUpdatedWriter.write(line + \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tlegacyFileReader.close();\n\n\t\t\tlegacyFileUpdatedWriter.close();\n\t\t\tlegacyFileExtRolesPermissionsWriter.close();\n\t\t}\n\n\t\tTable table = new Table(\n\t\t\t\"Roles_Permissions\",\n\t\t\tnew Object[][] {\n\t\t\t\t{\"roleId\", Types.BIGINT}, {\"permissionId\", Types.BIGINT}\n\t\t\t});\n\n\t\ttable.populateTable(legacyFile + _EXT_ROLES_PERMIMISSIONS);\n\n\t\tFileUtil.delete(legacyFile);\n\t\tFileUtil.delete(legacyFile + _EXT_ROLES_PERMIMISSIONS);\n\n\t\treturn legacyFile + _UPDATED;\n\t}","commit_id":"b5505b2d5d6ff5631029a9771d4f8fcdf5da3319","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _convertRoles(\n\t\t\tString legacyFile, int type, String newName,\n\t\t\tObject[][] newColumns)\n\t\tthrows Exception {\n\n\t\tBufferedReader br = new BufferedReader(new FileReader(legacyFile));\n\t\tBufferedWriter rolePermMapBuff = new BufferedWriter(\n\t\t\tnew FileWriter(legacyFile + _ROLE_PERM_MAP_EXT));\n\t\tBufferedWriter roleBuff = new BufferedWriter(\n\t\t\tnew FileWriter(legacyFile + _ROLE_EXT));\n\t\tBufferedWriter otherRoleMapBuff = new BufferedWriter(\n\t\t\tnew FileWriter(legacyFile + _OTHER_ROLE_MAP_EXT));\n\n\t\ttry {\n\n\t\t\t// Group by resourceId\n\n\t\t\tMultiValueMap mvp = new MultiValueMap();\n\n\t\t\tString line;\n\n\t\t\twhile ((line = br.readLine()) != null) {\n\t\t\t\tString[] values = StringUtil.split(line);\n\n\t\t\t\tlong resourceId = PermissionView.getResourceId(values);\n\n\t\t\t\tmvp.put(resourceId, values);\n\t\t\t}\n\n\t\t\t// Assign role for each grouping\n\n\t\t\tfor (Long key : (Set<Long>)mvp.keySet()) {\n\t\t\t\tList<String[]> valuesList = new ArrayList<String[]>(\n\t\t\t\t\t(Collection<String[]>)mvp.getCollection(key));\n\n\t\t\t\tString[] values = valuesList.get(0);\n\n\t\t\t\tlong groupId = PermissionView.getPrimaryKey(values);\n\t\t\t\tlong companyId = PermissionView.getCompanyId(values);\n\t\t\t\tString name = PermissionView.getNameId(values);\n\t\t\t\tint scope = PermissionView.getScopeId(values);\n\n\t\t\t\t// Group actions and permissionIds\n\n\t\t\t\tList<String> actionsIds = new ArrayList<String>();\n\t\t\t\tList<Long> permissionIds = new ArrayList<Long>();\n\n\t\t\t\tfor (String[] values2 : valuesList) {\n\t\t\t\t\tactionsIds.add(PermissionView.getActionId(values2));\n\t\t\t\t\tpermissionIds.add(PermissionView.getPermissionId(values2));\n\t\t\t\t}\n\n\t\t\t\t// Look for owner and system roles\n\n\t\t\t\tif (type != RoleConstants.TYPE_ORGANIZATION &&\n\t\t\t\t\tscope == ResourceConstants.SCOPE_INDIVIDUAL) {\n\n\t\t\t\t\t// Find default actions\n\n\t\t\t\t\tList<String> defaultActions = null;\n\n\t\t\t\t\tif (type == RoleConstants.TYPE_REGULAR) {\n\t\t\t\t\t\tif (name.contains(StringPool.PERIOD)) {\n\t\t\t\t\t\t\tdefaultActions = ResourceActionsUtil.\n\t\t\t\t\t\t\t\tgetModelResourceActions(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdefaultActions = ResourceActionsUtil.\n\t\t\t\t\t\t\t\tgetPortletResourceActions(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (name.contains(StringPool.PERIOD)) {\n\t\t\t\t\t\t\tdefaultActions = ResourceActionsUtil.\n\t\t\t\t\t\t\t\tgetModelResourceCommunityDefaultActions(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdefaultActions = ResourceActionsUtil.\n\t\t\t\t\t\t\t\tgetPortletResourceCommunityDefaultActions(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Resolve owner and system roles\n\n\t\t\t\t\tRole defaultRole = null;\n\n\t\t\t\t\tif (type == RoleConstants.TYPE_REGULAR) {\n\t\t\t\t\t\tCollections.sort(actionsIds);\n\t\t\t\t\t\tCollections.sort(defaultActions);\n\n\t\t\t\t\t\tif (defaultActions.equals(actionsIds)) {\n\t\t\t\t\t\t\tdefaultRole = _ownerRolesMap.get(companyId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (defaultActions.containsAll(actionsIds)) {\n\t\t\t\t\t\t\tRole[] defaultRoles =\n\t\t\t\t\t\t\t\t_defaultRolesMap.get(companyId);\n\n\t\t\t\t\t\t\tGroup group = _groupsMap.get(groupId);\n\n\t\t\t\t\t\t\tif (group.isCommunity()) {\n\t\t\t\t\t\t\t\tdefaultRole = defaultRoles[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (group.isOrganization()) {\n\t\t\t\t\t\t\t\tdefaultRole = defaultRoles[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (group.isUser() || group.isUserGroup()) {\n\t\t\t\t\t\t\t\tdefaultRole = defaultRoles[2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (defaultRole != null) {\n\t\t\t\t\t\tlong roleId = defaultRole.getRoleId();\n\n\t\t\t\t\t\tfor (Long permissionId : permissionIds) {\n\t\t\t\t\t\t\tString key2 = roleId + \"_\" + permissionId;\n\n\t\t\t\t\t\t\tif (_rolesPermissions.contains(key2)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t_rolesPermissions.add(key2);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trolePermMapBuff.write(\n\t\t\t\t\t\t\t\troleId + \",\" + permissionId + \",\\n\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Role_\n\n\t\t\t\tlong roleId = CounterLocalServiceUtil.increment();\n\t\t\t\tString roleName =\n\t\t\t\t\tStringUtil.upperCaseFirstLetter(RoleConstants.getTypeLabel(type)) +\n\t\t\t\t\t\t\" \" + Long.toHexString(roleId);\n\n\t\t\t\tString[] roleColumns = new String[] {\n\t\t\t\t\tLong.toString(roleId),\n\t\t\t\t\tLong.toString(companyId),\n\t\t\t\t\tLong.toString(ClassNameLocalServiceUtil.getClassNameId(Role.class)),\n\t\t\t\t\tLong.toString(roleId),\n\t\t\t\t\troleName,\n\t\t\t\t\tStringPool.BLANK,\n\t\t\t\t\t\"Autogenerated role from portal upgrade\",\n\t\t\t\t\tInteger.toString(type),\n\t\t\t\t\tStringPool.BLANK\n\t\t\t\t};\n\n\t\t\t\tfor (int i = 0; i < roleColumns.length; i++) {\n\t\t\t\t\troleBuff.write(roleColumns[i] + StringPool.COMMA);\n\n\t\t\t\t\tif (i == (roleColumns.length - 1)) {\n\t\t\t\t\t\troleBuff.write(StringPool.NEW_LINE);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Roles_Permissions\n\n\t\t\t\tfor (Long permissionId : permissionIds) {\n\t\t\t\t\tString key2 = roleId + \"_\" + permissionId;\n\n\t\t\t\t\tif (_rolesPermissions.contains(key2)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t_rolesPermissions.add(key2);\n\t\t\t\t\t}\n\n\t\t\t\t\trolePermMapBuff.write(\n\t\t\t\t\t\troleId + \",\" + permissionId + \",\\n\");\n\t\t\t\t}\n\n\t\t\t\t// Others_Roles\n\n\t\t\t\tfor (int i = 0; i < newColumns.length - 1; i++) {\n\t\t\t\t\totherRoleMapBuff.write(values[i] + StringPool.COMMA);\n\t\t\t\t}\n\n\t\t\t\totherRoleMapBuff.write(roleId + \",\\n\");\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tbr.close();\n\t\t\troleBuff.close();\n\t\t\trolePermMapBuff.close();\n\t\t\totherRoleMapBuff.close();\n\t\t}\n\n\t\t// Role_\n\n\t\tTable roleTable =\n\t\t\tnew Table(RoleModelImpl.TABLE_NAME, RoleModelImpl.TABLE_COLUMNS);\n\n\t\troleTable.populateTable(legacyFile + _ROLE_EXT);\n\n\t\t// Roles_Permissions\n\n\t\tTable rolesPermissionsTable = new Table(\n\t\t\t\"Roles_Permissions\",\n\t\t\tnew Object[][] {\n\t\t\t\t{ \"roleId\", Types.BIGINT },\n\t\t\t\t{ \"permissionId\", Types.BIGINT }\n\t\t\t});\n\n\t\trolesPermissionsTable.populateTable(legacyFile + _ROLE_PERM_MAP_EXT);\n\n\t\t// Others_Roles\n\n\t\tTable othersRolesTable = new Table(newName, newColumns);\n\n\t\tothersRolesTable.populateTable(legacyFile + _OTHER_ROLE_MAP_EXT);\n\n\t\t// Cleanup\n\n\t\tFileUtil.delete(legacyFile + _ROLE_EXT);\n\t\tFileUtil.delete(legacyFile + _ROLE_PERM_MAP_EXT);\n\t\tFileUtil.delete(legacyFile + _OTHER_ROLE_MAP_EXT);\n\t}","id":93576,"modified_method":"private void _convertRoles(\n\t\t\tString legacyFile, int type, String newName, Object[][] newColumns)\n\t\tthrows Exception {\n\n\t\tBufferedReader legacyFileReader = new BufferedReader(\n\t\t\tnew FileReader(legacyFile));\n\n\t\tBufferedWriter legacyFileExtRoleWriter = new BufferedWriter(\n\t\t\tnew FileWriter(legacyFile + _EXT_ROLE));\n\t\tBufferedWriter legacyFileExtRolesPermissionsWriter = new BufferedWriter(\n\t\t\tnew FileWriter(legacyFile + _EXT_ROLES_PERMIMISSIONS));\n\t\tBufferedWriter legacyFileExtOtherRolesWriter = new BufferedWriter(\n\t\t\tnew FileWriter(legacyFile + _EXT_OTHER_ROLES));\n\n\t\ttry {\n\n\t\t\t// Group by resource id\n\n\t\t\tMultiValueMap mvp = new MultiValueMap();\n\n\t\t\tString line = null;\n\n\t\t\twhile ((line = legacyFileReader.readLine()) != null) {\n\t\t\t\tString[] values = StringUtil.split(line);\n\n\t\t\t\tlong resourceId = PermissionView.getResourceId(values);\n\n\t\t\t\tmvp.put(resourceId, values);\n\t\t\t}\n\n\t\t\t// Assign role for each grouping\n\n\t\t\tfor (Long key : (Set<Long>)mvp.keySet()) {\n\t\t\t\tList<String[]> valuesList = new ArrayList<String[]>(\n\t\t\t\t\tmvp.getCollection(key));\n\n\t\t\t\tString[] values = valuesList.get(0);\n\n\t\t\t\tlong companyId = PermissionView.getCompanyId(values);\n\t\t\t\tlong groupId = PermissionView.getPrimaryKey(values);\n\t\t\t\tString name = PermissionView.getNameId(values);\n\t\t\t\tint scope = PermissionView.getScopeId(values);\n\n\t\t\t\t// Group action ids and permission ids\n\n\t\t\t\tList<String> actionsIds = new ArrayList<String>();\n\t\t\t\tList<Long> permissionIds = new ArrayList<Long>();\n\n\t\t\t\tfor (String[] curValues : valuesList) {\n\t\t\t\t\tString actionId = PermissionView.getActionId(curValues);\n\t\t\t\t\tlong permissionId = PermissionView.getPermissionId(\n\t\t\t\t\t\tcurValues);\n\n\t\t\t\t\tactionsIds.add(actionId);\n\t\t\t\t\tpermissionIds.add(permissionId);\n\t\t\t\t}\n\n\t\t\t\t// Look for owner and system roles\n\n\t\t\t\tif ((type != RoleConstants.TYPE_ORGANIZATION) &&\n\t\t\t\t\t(scope == ResourceConstants.SCOPE_INDIVIDUAL)) {\n\n\t\t\t\t\t// Find default actions\n\n\t\t\t\t\tList<String> defaultActions = null;\n\n\t\t\t\t\tif (type == RoleConstants.TYPE_REGULAR) {\n\t\t\t\t\t\tif (name.contains(StringPool.PERIOD)) {\n\t\t\t\t\t\t\tdefaultActions = ResourceActionsUtil.\n\t\t\t\t\t\t\t\tgetModelResourceActions(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdefaultActions = ResourceActionsUtil.\n\t\t\t\t\t\t\t\tgetPortletResourceActions(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (name.contains(StringPool.PERIOD)) {\n\t\t\t\t\t\t\tdefaultActions = ResourceActionsUtil.\n\t\t\t\t\t\t\t\tgetModelResourceCommunityDefaultActions(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdefaultActions = ResourceActionsUtil.\n\t\t\t\t\t\t\t\tgetPortletResourceCommunityDefaultActions(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Resolve owner and system roles\n\n\t\t\t\t\tRole defaultRole = null;\n\n\t\t\t\t\tif (type == RoleConstants.TYPE_REGULAR) {\n\t\t\t\t\t\tCollections.sort(actionsIds);\n\t\t\t\t\t\tCollections.sort(defaultActions);\n\n\t\t\t\t\t\tif (defaultActions.equals(actionsIds)) {\n\t\t\t\t\t\t\tdefaultRole = _ownerRolesMap.get(companyId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (defaultActions.containsAll(actionsIds)) {\n\t\t\t\t\t\t\tRole[] defaultRoles = _defaultRolesMap.get(\n\t\t\t\t\t\t\t\tcompanyId);\n\n\t\t\t\t\t\t\tGroup group = _groupsMap.get(groupId);\n\n\t\t\t\t\t\t\tif (group.isCommunity()) {\n\t\t\t\t\t\t\t\tdefaultRole = defaultRoles[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (group.isOrganization()) {\n\t\t\t\t\t\t\t\tdefaultRole = defaultRoles[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (group.isUser() || group.isUserGroup()) {\n\t\t\t\t\t\t\t\tdefaultRole = defaultRoles[2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (defaultRole != null) {\n\t\t\t\t\t\tlong roleId = defaultRole.getRoleId();\n\n\t\t\t\t\t\tfor (Long permissionId : permissionIds) {\n\t\t\t\t\t\t\tString curKey = roleId + \"_\" + permissionId;\n\n\t\t\t\t\t\t\tif (_rolesPermissions.contains(curKey)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t_rolesPermissions.add(curKey);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlegacyFileExtRolesPermissionsWriter.write(\n\t\t\t\t\t\t\t\troleId + \",\" + permissionId + \",\\n\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Role_\n\n\t\t\t\tlong roleId = CounterLocalServiceUtil.increment();\n\n\t\t\t\tString roleName = StringUtil.upperCaseFirstLetter(\n\t\t\t\t\tRoleConstants.getTypeLabel(type));\n\n\t\t\t\troleName += \" \" + Long.toHexString(roleId);\n\n\t\t\t\tString[] roleColumns = new String[] {\n\t\t\t\t\tString.valueOf(roleId), String.valueOf(companyId),\n\t\t\t\t\tString.valueOf(\n\t\t\t\t\t\tClassNameLocalServiceUtil.getClassNameId(Role.class)),\n\t\t\t\t\tString.valueOf(roleId), roleName, StringPool.BLANK,\n\t\t\t\t\t\"Autogenerated role from portal upgrade\",\n\t\t\t\t\tString.valueOf(type), StringPool.BLANK\n\t\t\t\t};\n\n\t\t\t\tfor (int i = 0; i < roleColumns.length; i++) {\n\t\t\t\t\tlegacyFileExtRoleWriter.write(\n\t\t\t\t\t\troleColumns[i] + StringPool.COMMA);\n\n\t\t\t\t\tif (i == (roleColumns.length - 1)) {\n\t\t\t\t\t\tlegacyFileExtRoleWriter.write(StringPool.NEW_LINE);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Roles_Permissions\n\n\t\t\t\tfor (Long permissionId : permissionIds) {\n\t\t\t\t\tString curKey = roleId + \"_\" + permissionId;\n\n\t\t\t\t\tif (_rolesPermissions.contains(curKey)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t_rolesPermissions.add(curKey);\n\t\t\t\t\t}\n\n\t\t\t\t\tlegacyFileExtRolesPermissionsWriter.write(\n\t\t\t\t\t\troleId + \",\" + permissionId + \",\\n\");\n\t\t\t\t}\n\n\t\t\t\t// Others_Roles\n\n\t\t\t\tfor (int i = 0; i < newColumns.length - 1; i++) {\n\t\t\t\t\tlegacyFileExtOtherRolesWriter.write(\n\t\t\t\t\t\tvalues[i] + StringPool.COMMA);\n\t\t\t\t}\n\n\t\t\t\tlegacyFileExtOtherRolesWriter.write(roleId + \",\\n\");\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tlegacyFileReader.close();\n\n\t\t\tlegacyFileExtRoleWriter.close();\n\t\t\tlegacyFileExtRolesPermissionsWriter.close();\n\t\t\tlegacyFileExtOtherRolesWriter.close();\n\t\t}\n\n\t\t// Role_\n\n\t\tTable roleTable = new Table(\n\t\t\tRoleModelImpl.TABLE_NAME, RoleModelImpl.TABLE_COLUMNS);\n\n\t\troleTable.populateTable(legacyFile + _EXT_ROLE);\n\n\t\t// Roles_Permissions\n\n\t\tTable rolesPermissionsTable = new Table(\n\t\t\t\"Roles_Permissions\",\n\t\t\tnew Object[][] {\n\t\t\t\t{\"roleId\", Types.BIGINT}, {\"permissionId\", Types.BIGINT}\n\t\t\t});\n\n\t\trolesPermissionsTable.populateTable(\n\t\t\tlegacyFile + _EXT_ROLES_PERMIMISSIONS);\n\n\t\t// Others_Roles\n\n\t\tTable othersRolesTable = new Table(newName, newColumns);\n\n\t\tothersRolesTable.populateTable(legacyFile + _EXT_OTHER_ROLES);\n\n\t\t// Cleanup\n\n\t\tFileUtil.delete(legacyFile + _EXT_ROLE);\n\t\tFileUtil.delete(legacyFile + _EXT_ROLES_PERMIMISSIONS);\n\t\tFileUtil.delete(legacyFile + _EXT_OTHER_ROLES);\n\t}","commit_id":"b5505b2d5d6ff5631029a9771d4f8fcdf5da3319","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _convertPermissions(\n\t\t\tint type, String legacyName, String[] primKeys, String newName,\n\t\t\tObject[][] newColumns)\n\t\tthrows Exception {\n\n\t\tMaintenanceUtil.appendStatus(\"Processing \" + legacyName);\n\n\t\tTable legacyTable = new PermissionView(legacyName, primKeys);\n\n\t\tString legacyFile = legacyTable.generateTempFile();\n\n\t\tif (legacyFile != null) {\n\t\t\tif (type == RoleConstants.TYPE_REGULAR) {\n\t\t\t\tlegacyFile = _convertGuestUsers(legacyFile);\n\n\t\t\t\tMaintenanceUtil.appendStatus(\n\t\t\t\t\t\"Converted guest users to guest roles\");\n\t\t\t}\n\n\t\t\t_convertRoles(legacyFile, type, newName, newColumns);\n\n\t\t\tMaintenanceUtil.appendStatus(\"Converted roles for \" + legacyName);\n\n\t\t\t// Cleanup\n\n\t\t\tDBUtil.getInstance().runSQL(legacyTable.getDeleteSQL());\n\n\t\t\tFileUtil.delete(legacyFile);\n\t\t}\n\t}","id":93577,"modified_method":"private void _convertPermissions(\n\t\t\tint type, String legacyName, String[] primKeys, String newName,\n\t\t\tObject[][] newColumns)\n\t\tthrows Exception {\n\n\t\tMaintenanceUtil.appendStatus(\"Processing \" + legacyName);\n\n\t\tTable legacyTable = new PermissionView(legacyName, primKeys);\n\n\t\tString legacyFile = legacyTable.generateTempFile();\n\n\t\tif (legacyFile == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (type == RoleConstants.TYPE_REGULAR) {\n\t\t\tlegacyFile = _convertGuestUsers(legacyFile);\n\n\t\t\tMaintenanceUtil.appendStatus(\n\t\t\t\t\"Converted guest users to guest roles\");\n\t\t}\n\n\t\t_convertRoles(legacyFile, type, newName, newColumns);\n\n\t\tMaintenanceUtil.appendStatus(\"Converted roles for \" + legacyName);\n\n\t\tDBUtil.getInstance().runSQL(legacyTable.getDeleteSQL());\n\n\t\tFileUtil.delete(legacyFile);\n\t}","commit_id":"b5505b2d5d6ff5631029a9771d4f8fcdf5da3319","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PermissionView(String tableName, String[] primKeys) {\n\t\tsuper(tableName);\n\n\t\tArrayList<Object[]> columns = new ArrayList<Object[]>();\n\n\t\tfor (String primKey : primKeys) {\n\t\t\tcolumns.add(new Object[] { primKey, Types.BIGINT });\n\t\t}\n\n\t\tcolumns.add(new Object[] { \"permissionId\", Types.BIGINT });\n\t\tcolumns.add(new Object[] { \"companyId\", Types.BIGINT });\n\t\tcolumns.add(new Object[] { \"actionId\", Types.VARCHAR });\n\t\tcolumns.add(new Object[] { \"resourceId\", Types.BIGINT });\n\t\tcolumns.add(new Object[] { \"name\", Types.VARCHAR });\n\t\tcolumns.add(new Object[] { \"scope\", Types.INTEGER });\n\n\t\tsetColumns((Object[][])columns.toArray(new Object[][] {}));\n\t}","id":93578,"modified_method":"public PermissionView(String tableName, String[] primKeys) {\n\t\tsuper(tableName);\n\n\t\tList<Object[]> columns = new ArrayList<Object[]>();\n\n\t\tfor (String primKey : primKeys) {\n\t\t\tcolumns.add(new Object[] {primKey, Types.BIGINT});\n\t\t}\n\n\t\tcolumns.add(new Object[] {\"permissionId\", Types.BIGINT});\n\t\tcolumns.add(new Object[] {\"companyId\", Types.BIGINT});\n\t\tcolumns.add(new Object[] {\"actionId\", Types.VARCHAR});\n\t\tcolumns.add(new Object[] {\"resourceId\", Types.BIGINT});\n\t\tcolumns.add(new Object[] {\"name\", Types.VARCHAR});\n\t\tcolumns.add(new Object[] {\"scope\", Types.INTEGER});\n\n\t\tsetColumns(columns.toArray(new Object[0][]));\n\t}","commit_id":"b5505b2d5d6ff5631029a9771d4f8fcdf5da3319","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Source resolve(String href, String base)\n\t\t\tthrows TransformerException {\n\t\t\tCollection collection = doc.getCollection();\n\t\t\tString path;\n            //TODO : use dedicated function in XmldbURI\n\t\t\tif(href.startsWith(\"/\"))\n\t\t\t\tpath = href;\n\t\t\telse\n\t\t\t\tpath = collection.getURI() + \"/\" + href;\n\t\t\tDocumentImpl xslDoc;\n\t\t\ttry {\n\t\t\t\txslDoc = (DocumentImpl) context.getBroker().getXMLResource(XmldbURI.create(path));\n\t\t\t} catch (PermissionDeniedException e) {\n\t\t\t\tthrow new TransformerException(e.getMessage(), e);\n\t\t\t}\n\t\t\tif(xslDoc == null) {\n\t\t\t\tLOG.debug(\"Document \" + href + \" not found in collection \" + collection.getURI());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(!xslDoc.getPermissions().validate(context.getUser(), Permission.READ))\n\t\t\t    throw new TransformerException(\"Insufficient privileges to read resource \" + path);\n\t\t\tDOMSource source = new DOMSource(xslDoc);\n\t\t\treturn source;\n\t\t}","id":93579,"modified_method":"public Source resolve(String href, String base) throws TransformerException\n\t\t{\n\t\t\tfinal String backPath = \"../\";\n\t\t\t\n\t\t\tString collectionPath = doc.getCollection().getURI().toString();\n\t\t\tString path;\n            //TODO : use dedicated function in XmldbURI\n\t\t\tif(href.startsWith(\"/\"))\n\t\t\t{\n\t\t\t\tpath = href;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(href.startsWith(backPath))\n\t\t\t\t{\n\t\t\t\t\t//relative ../ href so adjust the collectionPath and strip the href\t\t\t\t\n\t\t\t\t\twhile(href.indexOf(backPath) > -1)\n\t\t\t\t\t{\n\t\t\t\t\t\thref = href.substring(href.indexOf(backPath) + backPath.length(), href.length());\n\t\t\t\t\t\tcollectionPath = collectionPath.substring(0, collectionPath.lastIndexOf('/'));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpath = collectionPath + \"/\" + href;\n\t\t\t}\n\t\t\t\n\t\t\tDocumentImpl xslDoc;\n\t\t\ttry {\n\t\t\t\txslDoc = (DocumentImpl) context.getBroker().getXMLResource(XmldbURI.create(path));\n\t\t\t} catch (PermissionDeniedException e) {\n\t\t\t\tthrow new TransformerException(e.getMessage(), e);\n\t\t\t}\n\t\t\tif(xslDoc == null) {\n\t\t\t\tLOG.debug(\"Document \" + href + \" not found in collection \" + collectionPath);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(!xslDoc.getPermissions().validate(context.getUser(), Permission.READ))\n\t\t\t    throw new TransformerException(\"Insufficient privileges to read resource \" + path);\n\t\t\tDOMSource source = new DOMSource(xslDoc);\n\t\t\treturn source;\n\t\t}","commit_id":"98844b841926a4ad14ca015bb64218c501134f50","url":"https://github.com/eXist-db/exist"},{"original_method":"public static String md5Hex( String message )\n    {\n        try\n        {\n            MessageDigest m = MessageDigest.getInstance( \"MD5\" );\n            m.update( message.getBytes(), 0, message.getBytes().length);\n            return new BigInteger(1, m.digest()).toString( 16 );\n        }\n        catch ( NoSuchAlgorithmException e )\n        {\n            throw new RuntimeException( \"MD5 hash algorithm is not available on this platform: \" + e.getMessage(),e );\n        }\n    }","id":93580,"modified_method":"public static String md5Hex( String message )\n    {\n        try\n        {\n            MessageDigest m = MessageDigest.getInstance( \"MD5\" );\n            m.update( message.getBytes(), 0, message.getBytes().length);\n            return hex(m.digest());\n        }\n        catch ( NoSuchAlgorithmException e )\n        {\n            throw new RuntimeException( \"MD5 hash algorithm is not available on this platform: \" + e.getMessage(),e );\n        }\n    }","commit_id":"eb8d2e4013ba8adccad96da780342aec8ac1a1c0","url":"https://github.com/neo4j/neo4j"},{"original_method":"public DefaultServiceRegistryFactory(final StartParameter startParameter) {\n        final Map<String, ModuleDescriptor> clientModuleRegistry = new HashMap<String, ModuleDescriptor>();\n\n        add(ImportsReader.class, new ImportsReader(startParameter.getDefaultImportsFile()));\n        add(ClassGenerator.class, new AsmBackedClassGenerator());\n        add(StandardOutputRedirector.class, new DefaultStandardOutputRedirector());\n        add(TaskExecuter.class, new DefaultTaskExecuter(startParameter));\n        add(PublishArtifactFactory.class, new DefaultPublishArtifactFactory());\n\n        add(new Service(RepositoryHandlerFactory.class) {\n            protected Object create() {\n                return new DefaultRepositoryHandlerFactory(new DefaultResolverFactory(), get(ClassGenerator.class));\n            }\n        });\n\n        add(new Service(CacheRepository.class){\n            protected Object create() {\n                return new DefaultCacheRepository(startParameter.getGradleUserHomeDir(),\n                        startParameter.getCacheUsage());\n            }\n        });\n\n        add(new Service(ConfigurationContainerFactory.class){\n            protected Object create() {\n                return new DefaultConfigurationContainerFactory(\n                        clientModuleRegistry,\n                        new DefaultSettingsConverter(),\n                        get(ModuleDescriptorConverter.class),\n                        new DefaultIvyFactory(),\n                        new SelfResolvingDependencyResolver(\n                                new DefaultIvyDependencyResolver(new DefaultIvyReportConverter())),\n                        new DefaultIvyDependencyPublisher(new DefaultModuleDescriptorForUploadConverter(),\n                                new DefaultPublishOptionsFactory()));\n            }\n        });\n\n        add(new Service(ModuleDescriptorConverter.class){\n            protected Object create() {\n                ExcludeRuleConverter excludeRuleConverter = new DefaultExcludeRuleConverter();\n                return new DefaultModuleDescriptorConverter(\n                        new DefaultModuleDescriptorFactory(),\n                        new DefaultConfigurationsToModuleDescriptorConverter(),\n                        new DefaultDependenciesToModuleDescriptorConverter(\n                                new DefaultDependencyDescriptorFactory(\n                                        excludeRuleConverter,\n                                        new DefaultClientModuleDescriptorFactory(),\n                                        clientModuleRegistry),\n                                excludeRuleConverter),\n                        new DefaultArtifactsToModuleDescriptorConverter());\n            }\n        });\n\n        add(new Service(DependencyFactory.class){\n            protected Object create() {\n                return new DefaultDependencyFactory(\n                        WrapUtil.<IDependencyImplementationFactory>toSet(new ModuleDependencyFactory(),\n                                new SelfResolvingDependencyFactory()),\n                        new DefaultClientModuleFactory(),\n                        new DefaultProjectDependencyFactory(startParameter.getProjectDependenciesBuildInstruction()));\n            }\n        });\n        \n        add(new Service(ProjectEvaluator.class){\n            protected Object create() {\n                return new DefaultProjectEvaluator(\n                        new BuildScriptProcessor(\n                                get(ImportsReader.class),\n                                get(ScriptCompilerFactory.class)));\n            }\n        });\n\n        add(new Service(ITaskFactory.class) {\n            protected Object create() {\n                return new ExecutionShortCircuitTaskFactory(\n                        new DependencyAutoWireTaskFactory(\n                                new AnnotationProcessingTaskFactory(\n                                        new TaskFactory(get(ClassGenerator.class)))),\n                        new DefaultTaskArtifactStateRepository(get(CacheRepository.class)));\n            }\n        });\n\n        add(new Service(ScriptCompilerFactory.class) {\n            protected Object create() {\n                return new DefaultScriptCompilerFactory(\n                        new DefaultScriptCompilationHandler(),\n                        startParameter.getCacheUsage(),\n                        new DefaultScriptRunnerFactory(new DefaultScriptMetaData()),\n                        get(CacheRepository.class));\n            }\n        });\n    }","id":93581,"modified_method":"public DefaultServiceRegistryFactory(final StartParameter startParameter) {\n        final Map<String, ModuleDescriptor> clientModuleRegistry = new HashMap<String, ModuleDescriptor>();\n\n        add(ImportsReader.class, new ImportsReader(startParameter.getDefaultImportsFile()));\n        add(ClassGenerator.class, new AsmBackedClassGenerator());\n        add(StandardOutputRedirector.class, new DefaultStandardOutputRedirector());\n        add(TaskExecuter.class, new DefaultTaskExecuter(startParameter));\n        add(PublishArtifactFactory.class, new DefaultPublishArtifactFactory());\n\n        add(new Service(RepositoryHandlerFactory.class) {\n            protected Object create() {\n                return new DefaultRepositoryHandlerFactory(new DefaultResolverFactory(), get(ClassGenerator.class));\n            }\n        });\n\n        add(new Service(CacheRepository.class){\n            protected Object create() {\n                return new DefaultCacheRepository(startParameter.getGradleUserHomeDir(),\n                        startParameter.getCacheUsage());\n            }\n        });\n\n        add(new Service(ConfigurationContainerFactory.class){\n            protected Object create() {\n                return new DefaultConfigurationContainerFactory(\n                        clientModuleRegistry,\n                        new DefaultSettingsConverter(),\n                        get(ModuleDescriptorConverter.class),\n                        new DefaultIvyFactory(),\n                        new SelfResolvingDependencyResolver(\n                                new DefaultIvyDependencyResolver(new DefaultIvyReportConverter())),\n                        new DefaultIvyDependencyPublisher(new DefaultModuleDescriptorForUploadConverter(),\n                                new DefaultPublishOptionsFactory()));\n            }\n        });\n\n        add(new Service(ModuleDescriptorConverter.class){\n            protected Object create() {\n                ExcludeRuleConverter excludeRuleConverter = new DefaultExcludeRuleConverter();\n                return new DefaultModuleDescriptorConverter(\n                        new DefaultModuleDescriptorFactory(),\n                        new DefaultConfigurationsToModuleDescriptorConverter(),\n                        new DefaultDependenciesToModuleDescriptorConverter(\n                                new DefaultDependencyDescriptorFactory(\n                                        excludeRuleConverter,\n                                        new DefaultClientModuleDescriptorFactory(),\n                                        clientModuleRegistry),\n                                excludeRuleConverter),\n                        new DefaultArtifactsToModuleDescriptorConverter());\n            }\n        });\n\n        add(new Service(DependencyFactory.class){\n            protected Object create() {\n                return new DefaultDependencyFactory(\n                        WrapUtil.<IDependencyImplementationFactory>toSet(new ModuleDependencyFactory(),\n                                new SelfResolvingDependencyFactory()),\n                        new DefaultClientModuleFactory(),\n                        new DefaultProjectDependencyFactory(startParameter.getProjectDependenciesBuildInstruction()));\n            }\n        });\n        \n        add(new Service(ProjectEvaluator.class){\n            protected Object create() {\n                return new DefaultProjectEvaluator(\n                        new BuildScriptProcessor(\n                                get(ImportsReader.class),\n                                get(ScriptCompilerFactory.class)));\n            }\n        });\n\n        add(new Service(ITaskFactory.class) {\n            protected Object create() {\n                return new ExecutionShortCircuitTaskFactory(\n                        new DependencyAutoWireTaskFactory(\n                                new AnnotationProcessingTaskFactory(\n                                        new TaskFactory(get(ClassGenerator.class)))),\n                        new DefaultTaskArtifactStateRepository(\n                                get(CacheRepository.class),\n                                new CachingHasher(\n                                        new DefaultHasher(),\n                                        get(CacheRepository.class))));\n            }\n        });\n\n        add(new Service(ScriptCompilerFactory.class) {\n            protected Object create() {\n                return new DefaultScriptCompilerFactory(\n                        new DefaultScriptCompilationHandler(),\n                        startParameter.getCacheUsage(),\n                        new DefaultScriptRunnerFactory(new DefaultScriptMetaData()),\n                        get(CacheRepository.class));\n            }\n        });\n    }","commit_id":"9f370d59afe87f58b0d2f9e501736b2f736e0854","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultTaskArtifactStateRepository(CacheRepository repository) {\n        this.repository = repository;\n    }","id":93582,"modified_method":"public DefaultTaskArtifactStateRepository(CacheRepository repository, Hasher hasher) {\n        this.repository = repository;\n        this.hasher = hasher;\n    }","commit_id":"9f370d59afe87f58b0d2f9e501736b2f736e0854","url":"https://github.com/gradle/gradle"},{"original_method":"private TaskInfo getThisExecution(TaskInternal task) {\n        return new TaskInfo(task);\n    }","id":93583,"modified_method":"private TaskInfo getThisExecution(TaskInternal task) {\n        return new TaskInfo(task, hasher);\n    }","commit_id":"9f370d59afe87f58b0d2f9e501736b2f736e0854","url":"https://github.com/gradle/gradle"},{"original_method":"public TaskArtifactState getStateFor(final TaskInternal task) {\n        if (outputs == null) {\n            loadTasks(task);\n        }\n\n        final TaskKey key = new TaskKey(task);\n        final TaskInfo thisExecution = getThisExecution(task);\n        final TaskExecution lastExecution = getLastExecution(key, thisExecution);\n\n        return new TaskArtifactState() {\n            public boolean isUpToDate() {\n                List<String> messages = thisExecution.isSameAs(lastExecution);\n                if (messages == null || messages.isEmpty()) {\n                    logger.info(\"Skipping {} as it is up-to-date.\", task);\n                    return true;\n                }\n                if (logger.isInfoEnabled()) {\n                    Formatter formatter = new Formatter();\n                    formatter.format(\"Executing %s due to:\", task);\n                    for (String message : messages) {\n                        formatter.format(\"%n%s\", message);\n                    }\n                    logger.info(formatter.toString());\n                }\n                return false;\n            }\n\n            public void invalidate() {\n                for (File file : thisExecution.outputFiles.keySet()) {\n                    OutputGenerators generators = outputs.get(file);\n                    generators.remove(key);\n                }\n            }\n\n            public void update() {\n                thisExecution.snapshotOutputFiles();\n                for (Map.Entry<File, OutputFileInfo> entry : thisExecution.outputFiles.entrySet()) {\n                    OutputGenerators generators = outputs.get(entry.getKey());\n                    if (entry.getValue().isFile) {\n                        generators.replace(key, thisExecution);\n                    } else {\n                        generators.add(key, thisExecution);\n                    }\n                }\n                save();\n            }\n        };\n    }","id":93584,"modified_method":"public TaskArtifactState getStateFor(final TaskInternal task) {\n        if (cache == null) {\n            loadTasks(task);\n        }\n\n        final TaskKey key = new TaskKey(task);\n        final TaskInfo thisExecution = getThisExecution(task);\n        final TaskExecution lastExecution = getLastExecution(key, thisExecution);\n\n        return new TaskArtifactState() {\n            public boolean isUpToDate() {\n                List<String> messages = thisExecution.isSameAs(lastExecution);\n                if (messages == null || messages.isEmpty()) {\n                    logger.info(\"Skipping {} as it is up-to-date.\", task);\n                    return true;\n                }\n                if (logger.isInfoEnabled()) {\n                    Formatter formatter = new Formatter();\n                    formatter.format(\"Executing %s due to:\", task);\n                    for (String message : messages) {\n                        formatter.format(\"%n%s\", message);\n                    }\n                    logger.info(formatter.toString());\n                }\n                return false;\n            }\n\n            public void invalidate() {\n                for (File file : thisExecution.outputFiles.keySet()) {\n                    OutputGenerators generators = cache.get(file);\n                    generators.remove(key);\n                    cache.put(file, generators);\n                }\n            }\n\n            public void update() {\n                thisExecution.snapshotOutputFiles();\n                for (Map.Entry<File, OutputFileInfo> entry : thisExecution.outputFiles.entrySet()) {\n                    OutputGenerators generators = cache.get(entry.getKey());\n                    if (entry.getValue().isFile) {\n                        generators.replace(key, thisExecution);\n                    } else {\n                        generators.add(key, thisExecution);\n                    }\n                    cache.put(entry.getKey(), generators);\n                }\n            }\n        };\n    }","commit_id":"9f370d59afe87f58b0d2f9e501736b2f736e0854","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean isUpToDate(InputFileInfo lastInputFile) {\n            if (type != lastInputFile.type) {\n                return false;\n            }\n            if (type == FILE && !hash.equals(lastInputFile.hash)) {\n                return false;\n            }\n            return true;\n        }","id":93585,"modified_method":"public boolean isUpToDate(InputFileInfo lastInputFile) {\n            if (type != lastInputFile.type) {\n                return false;\n            }\n            if (type == FILE && !Arrays.equals(hash, lastInputFile.hash)) {\n                return false;\n            }\n            return true;\n        }","commit_id":"9f370d59afe87f58b0d2f9e501736b2f736e0854","url":"https://github.com/gradle/gradle"},{"original_method":"private InputFileInfo(File file) {\n            if (file.isFile()) {\n                type = FILE;\n                hash = HashUtil.createHash(file);\n            } else if (file.isDirectory()) {\n                type = DIR;\n                hash = null;\n            } else {\n                type = MISSING;\n                hash = null;\n            }\n        }","id":93586,"modified_method":"private InputFileInfo(File file, Hasher hasher) {\n            if (file.isFile()) {\n                type = FILE;\n                hash = hasher.hash(file);\n            } else if (file.isDirectory()) {\n                type = DIR;\n                hash = null;\n            } else {\n                type = MISSING;\n                hash = null;\n            }\n        }","commit_id":"9f370d59afe87f58b0d2f9e501736b2f736e0854","url":"https://github.com/gradle/gradle"},{"original_method":"public TaskInfo(TaskInternal task) {\n            for (File file : task.getInputs().getInputFiles()) {\n                inputFiles.put(file, new InputFileInfo(file));\n            }\n            for (File file : task.getOutputs().getOutputFiles()) {\n                outputFiles.put(file, null);\n            }\n        }","id":93587,"modified_method":"public TaskInfo(TaskInternal task, Hasher hasher) {\n            for (File file : task.getInputs().getInputFiles()) {\n                inputFiles.put(file, new InputFileInfo(file, hasher));\n            }\n            for (File file : task.getOutputs().getOutputFiles()) {\n                outputFiles.put(file, null);\n            }\n        }","commit_id":"9f370d59afe87f58b0d2f9e501736b2f736e0854","url":"https://github.com/gradle/gradle"},{"original_method":"private void loadTasks(TaskInternal task) {\n        cache = repository.getCacheFor(task.getProject().getGradle(), \"taskArtifacts\", Collections.EMPTY_MAP);\n        if (cache.isValid()) {\n            load();\n        } else {\n            outputs = new HashMap<File, OutputGenerators>();\n        }\n    }","id":93588,"modified_method":"private void loadTasks(TaskInternal task) {\n        cache = repository.getIndexedCacheFor(task.getProject().getGradle(), \"taskArtifacts\", Collections.EMPTY_MAP);\n    }","commit_id":"9f370d59afe87f58b0d2f9e501736b2f736e0854","url":"https://github.com/gradle/gradle"},{"original_method":"private TaskExecution getLastExecution(TaskKey key, TaskInfo thisExecution) {\n        TaskExecution taskInfo = new EmptyTaskInfo();\n        List<String> outOfDateMessages = new ArrayList<String>();\n        for (File outputFile : thisExecution.outputFiles.keySet()) {\n            if (!outputFile.exists()) {\n                // Discard previous state for this output file\n                outputs.put(outputFile, new OutputGenerators());\n                outOfDateMessages.add(String.format(\"%s does not exist.\", outputFile));\n                continue;\n            }\n            OutputGenerators generators = outputs.get(outputFile);\n            if (generators == null) {\n                outputs.put(outputFile, new OutputGenerators());\n                outOfDateMessages.add(String.format(\"No history is available for %s.\", outputFile));\n                continue;\n            }\n            TaskInfo lastExecution = generators.get(key);\n            if (lastExecution == null) {\n                outOfDateMessages.add(String.format(\"Task did not produce %s.\", outputFile));\n                continue;\n            }\n//            if (taskInfo != null && taskInfo != lastExecution) {\n//                outOfDateMessages.add(String.format(\"Some other task produced %s.\", outputFile));\n//                continue;\n//            }\n            taskInfo = lastExecution;\n        }\n        return outOfDateMessages.isEmpty() ? taskInfo : new EmptyTaskInfo(outOfDateMessages);\n    }","id":93589,"modified_method":"private TaskExecution getLastExecution(TaskKey key, TaskInfo thisExecution) {\n        TaskExecution taskInfo = new EmptyTaskInfo();\n        List<String> outOfDateMessages = new ArrayList<String>();\n        for (File outputFile : thisExecution.outputFiles.keySet()) {\n            if (!outputFile.exists()) {\n                // Discard previous state for this output file\n                cache.put(outputFile, new OutputGenerators());\n                outOfDateMessages.add(String.format(\"%s does not exist.\", outputFile));\n                continue;\n            }\n            OutputGenerators generators = cache.get(outputFile);\n            if (generators == null) {\n                cache.put(outputFile, new OutputGenerators());\n                outOfDateMessages.add(String.format(\"No history is available for %s.\", outputFile));\n                continue;\n            }\n            TaskInfo lastExecution = generators.get(key);\n            if (lastExecution == null) {\n                outOfDateMessages.add(String.format(\"Task did not produce %s.\", outputFile));\n                continue;\n            }\n            taskInfo = lastExecution;\n        }\n        return outOfDateMessages.isEmpty() ? taskInfo : new EmptyTaskInfo(outOfDateMessages);\n    }","commit_id":"9f370d59afe87f58b0d2f9e501736b2f736e0854","url":"https://github.com/gradle/gradle"},{"original_method":"private void expectEmptyCacheLocated() {\n        context.checking(new Expectations(){{\n            one(cacheRepository).getCacheFor(gradle, \"taskArtifacts\", Collections.EMPTY_MAP);\n            will(returnValue(cache));\n            one(cache).isValid();\n            will(returnValue(false));\n            allowing(cache).getBaseDir();\n            will(returnValue(cacheDir));\n        }});\n    }","id":93590,"modified_method":"private void expectEmptyCacheLocated() {\n        context.checking(new Expectations(){{\n            one(cacheRepository).getIndexedCacheFor(gradle, \"taskArtifacts\", Collections.EMPTY_MAP);\n            will(returnValue(new DefaultPersistentIndexedCache(cache)));\n            allowing(cache).update();\n            allowing(cache).getBaseDir();\n            will(returnValue(cacheDir));\n        }});\n    }","commit_id":"9f370d59afe87f58b0d2f9e501736b2f736e0854","url":"https://github.com/gradle/gradle"},{"original_method":"private void writeTaskState(TaskInternal... tasks) {\n        expectEmptyCacheLocated();\n        context.checking(new Expectations() {{\n            atLeast(1).of(cache).update();\n        }});\n        for (TaskInternal task : tasks) {\n            repository.getStateFor(task).update();\n        }\n        cacheDir.file(\"tasks.bin\").assertIsFile();\n    }","id":93591,"modified_method":"private void writeTaskState(TaskInternal... tasks) {\n        expectEmptyCacheLocated();\n        for (TaskInternal task : tasks) {\n            repository.getStateFor(task).update();\n        }\n    }","commit_id":"9f370d59afe87f58b0d2f9e501736b2f736e0854","url":"https://github.com/gradle/gradle"},{"original_method":"public static String createHash(File file) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n        try {\n            byte[] buffer = new byte[4096];\n            InputStream instr = new FileInputStream(file);\n            try {\n                while (true) {\n                    int nread = instr.read(buffer);\n                    if (nread < 0) {\n                        break;\n                    }\n                    messageDigest.update(buffer, 0, nread);\n                }\n            } finally {\n                instr.close();\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n        return new BigInteger(1, messageDigest.digest()).toString(16);\n    }","id":93592,"modified_method":"public static byte[] createHash(File file) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n        try {\n            byte[] buffer = new byte[4096];\n            InputStream instr = new FileInputStream(file);\n            try {\n                while (true) {\n                    int nread = instr.read(buffer);\n                    if (nread < 0) {\n                        break;\n                    }\n                    messageDigest.update(buffer, 0, nread);\n                }\n            } finally {\n                instr.close();\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n        return messageDigest.digest();\n    }","commit_id":"9f370d59afe87f58b0d2f9e501736b2f736e0854","url":"https://github.com/gradle/gradle"},{"original_method":"protected void init(\n\t\tHttpServletRequest request, Portlet portlet,\n\t\tInvokerPortlet invokerPortlet, PortletContext portletContext,\n\t\tWindowState windowState, PortletMode portletMode,\n\t\tPortletPreferences preferences, long plid) {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t_portlet = portlet;\n\t\t_portletName = portlet.getPortletId();\n\t\t_publicRenderParameters = PublicRenderParametersPool.get(request, plid);\n\n\t\tString portletNamespace = PortalUtil.getPortletNamespace(_portletName);\n\n\t\tboolean portalSessionShared = false;\n\n\t\tPortletApp portletApp = portlet.getPortletApp();\n\n\t\tif (portletApp.isWARFile() && !portlet.isPrivateSessionAttributes()) {\n\t\t\tportalSessionShared = true;\n\t\t}\n\n\t\trequest = new SharedSessionServletRequest(request, portalSessionShared);\n\n\t\tDynamicServletRequest dynamicRequest = null;\n\n\t\tif (portlet.isPrivateRequestAttributes()) {\n\t\t\tdynamicRequest = new NamespaceServletRequest(\n\t\t\t\trequest, portletNamespace, portletNamespace, false);\n\t\t}\n\t\telse {\n\t\t\tdynamicRequest = new DynamicServletRequest(request, false);\n\t\t}\n\n\t\tboolean portletFocus = false;\n\n\t\tString ppid = ParamUtil.getString(request, \"p_p_id\");\n\n\t\tboolean windowStateRestoreCurrentView = ParamUtil.getBoolean(\n\t\t\trequest, \"p_p_state_rcv\");\n\n\t\tif (_portletName.equals(ppid) &&\n\t\t\t!(windowStateRestoreCurrentView &&\n\t\t\t  portlet.isRestoreCurrentView())) {\n\n\t\t\t// Request was targeted to this portlet\n\n\t\t\tif (themeDisplay.isLifecycleRender() ||\n\t\t\t\tthemeDisplay.isLifecycleResource()) {\n\n\t\t\t\t// Request was triggered by a render or resource URL\n\n\t\t\t\tportletFocus = true;\n\t\t\t}\n\t\t\telse if (themeDisplay.isLifecycleAction()) {\n\t\t\t\t_triggeredByActionURL = true;\n\n\t\t\t\tif (getLifecycle().equals(PortletRequest.ACTION_PHASE)) {\n\n\t\t\t\t\t// Request was triggered by an action URL and is being\n\t\t\t\t\t// processed by com.liferay.portlet.ActionRequestImpl\n\n\t\t\t\t\tportletFocus = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMap<String, String[]> renderParameters = RenderParametersPool.get(\n\t\t\trequest, plid, _portletName);\n\n\t\tif (portletFocus) {\n\t\t\trenderParameters = new HashMap<String, String[]>();\n\n\t\t\tif (getLifecycle().equals(PortletRequest.RENDER_PHASE) &&\n\t\t\t\t!LiferayWindowState.isExclusive(request) &&\n\t\t\t\t!LiferayWindowState.isPopUp(request)) {\n\n\t\t\t\tRenderParametersPool.put(\n\t\t\t\t\trequest, plid, _portletName, renderParameters);\n\t\t\t}\n\n\t\t\tMap<String, String[]> parameters = request.getParameterMap();\n\n\t\t\tfor (Map.Entry<String, String[]> entry : parameters.entrySet()) {\n\t\t\t\tString name = entry.getKey();\n\n\t\t\t\tif (isInvalidParameter(name)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString[] values = entry.getValue();\n\n\t\t\t\tif (themeDisplay.isLifecycleRender()) {\n\t\t\t\t\trenderParameters.put(name, values);\n\t\t\t\t}\n\n\t\t\t\tif (values == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tname = removePortletNamespace(\n\t\t\t\t\tinvokerPortlet, portletNamespace, name);\n\n\t\t\t\tdynamicRequest.setParameterValues(name, values);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (Map.Entry<String, String[]> entry :\n\t\t\t\t\trenderParameters.entrySet()) {\n\n\t\t\t\tString name = entry.getKey();\n\t\t\t\tString[] values = entry.getValue();\n\n\t\t\t\tname = removePortletNamespace(\n\t\t\t\t\tinvokerPortlet, portletNamespace, name);\n\n\t\t\t\tdynamicRequest.setParameterValues(name, values);\n\t\t\t}\n\t\t}\n\n\t\tmergePublicRenderParameters(dynamicRequest, preferences, plid);\n\n\t\t_request = dynamicRequest;\n\t\t_originalRequest = request;\n\t\t_wapTheme = BrowserSnifferUtil.isWap(_request);\n\t\t_portlet = portlet;\n\t\t_portalContext = new PortalContextImpl();\n\t\t_portletContext = portletContext;\n\t\t_windowState = windowState;\n\t\t_portletMode = portletMode;\n\t\t_preferences = preferences;\n\t\t_portalSessionId = _request.getRequestedSessionId();\n\t\t_session = new PortletSessionImpl(\n\t\t\t_request, _portletName, _portletContext, _portalSessionId, plid);\n\n\t\tString remoteUser = request.getRemoteUser();\n\n\t\tString userPrincipalStrategy = portlet.getUserPrincipalStrategy();\n\n\t\tif (userPrincipalStrategy.equals(\n\t\t\t\tPortletConstants.USER_PRINCIPAL_STRATEGY_SCREEN_NAME)) {\n\n\t\t\ttry {\n\t\t\t\tUser user = PortalUtil.getUser(request);\n\n\t\t\t\tif (user != null) {\n\t\t\t\t\t_remoteUser = user.getScreenName();\n\t\t\t\t\t_remoteUserId = user.getUserId();\n\t\t\t\t\t_userPrincipal = new ProtectedPrincipal(_remoteUser);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlong userId = PortalUtil.getUserId(request);\n\n\t\t\tif ((userId > 0) && (remoteUser == null)) {\n\t\t\t\t_remoteUser = String.valueOf(userId);\n\t\t\t\t_remoteUserId = userId;\n\t\t\t\t_userPrincipal = new ProtectedPrincipal(_remoteUser);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_remoteUser = remoteUser;\n\t\t\t\t_remoteUserId = GetterUtil.getLong(remoteUser);\n\t\t\t\t_userPrincipal = request.getUserPrincipal();\n\t\t\t}\n\t\t}\n\n\t\t_locale = themeDisplay.getLocale();\n\t\t_plid = plid;\n\t}","id":93593,"modified_method":"protected void init(\n\t\tHttpServletRequest request, Portlet portlet,\n\t\tInvokerPortlet invokerPortlet, PortletContext portletContext,\n\t\tWindowState windowState, PortletMode portletMode,\n\t\tPortletPreferences preferences, long plid) {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t_portlet = portlet;\n\t\t_portletName = portlet.getPortletId();\n\t\t_publicRenderParameters = PublicRenderParametersPool.get(request, plid);\n\n\t\tString portletNamespace = PortalUtil.getPortletNamespace(_portletName);\n\n\t\tboolean portalSessionShared = false;\n\n\t\tPortletApp portletApp = portlet.getPortletApp();\n\n\t\tif (portletApp.isWARFile() && !portlet.isPrivateSessionAttributes()) {\n\t\t\tportalSessionShared = true;\n\t\t}\n\n\t\trequest = new SharedSessionServletRequest(request, portalSessionShared);\n\n\t\tDynamicServletRequest dynamicRequest = null;\n\n\t\tif (portlet.isPrivateRequestAttributes()) {\n\t\t\tdynamicRequest = new NamespaceServletRequest(\n\t\t\t\trequest, portletNamespace, portletNamespace, false);\n\t\t}\n\t\telse {\n\t\t\tdynamicRequest = new DynamicServletRequest(request, false);\n\t\t}\n\n\t\tboolean portletFocus = false;\n\n\t\tString ppid = ParamUtil.getString(request, \"p_p_id\");\n\n\t\tboolean windowStateRestoreCurrentView = ParamUtil.getBoolean(\n\t\t\trequest, \"p_p_state_rcv\");\n\n\t\tif (_portletName.equals(ppid) &&\n\t\t\t!(windowStateRestoreCurrentView &&\n\t\t\t  portlet.isRestoreCurrentView())) {\n\n\t\t\t// Request was targeted to this portlet\n\n\t\t\tif (themeDisplay.isLifecycleRender() ||\n\t\t\t\tthemeDisplay.isLifecycleResource()) {\n\n\t\t\t\t// Request was triggered by a render or resource URL\n\n\t\t\t\tportletFocus = true;\n\t\t\t}\n\t\t\telse if (themeDisplay.isLifecycleAction()) {\n\t\t\t\t_triggeredByActionURL = true;\n\n\t\t\t\tif (getLifecycle().equals(PortletRequest.ACTION_PHASE)) {\n\n\t\t\t\t\t// Request was triggered by an action URL and is being\n\t\t\t\t\t// processed by com.liferay.portlet.ActionRequestImpl\n\n\t\t\t\t\tportletFocus = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMap<String, String[]> renderParameters = RenderParametersPool.get(\n\t\t\trequest, plid, _portletName);\n\n\t\tif (portletFocus) {\n\t\t\trenderParameters = new HashMap<String, String[]>();\n\n\t\t\tif (getLifecycle().equals(PortletRequest.RENDER_PHASE) &&\n\t\t\t\t!LiferayWindowState.isExclusive(request) &&\n\t\t\t\t!LiferayWindowState.isPopUp(request)) {\n\n\t\t\t\tRenderParametersPool.put(\n\t\t\t\t\trequest, plid, _portletName, renderParameters);\n\t\t\t}\n\n\t\t\tMap<String, String[]> parameters = request.getParameterMap();\n\n\t\t\tfor (Map.Entry<String, String[]> entry : parameters.entrySet()) {\n\t\t\t\tString name = entry.getKey();\n\n\t\t\t\tif (isInvalidParameter(name)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString[] values = entry.getValue();\n\n\t\t\t\tif (themeDisplay.isLifecycleRender()) {\n\t\t\t\t\trenderParameters.put(name, values);\n\t\t\t\t}\n\n\t\t\t\tif (values == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tname = removePortletNamespace(\n\t\t\t\t\tinvokerPortlet, portletNamespace, name);\n\n\t\t\t\tdynamicRequest.setParameterValues(name, values);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (Map.Entry<String, String[]> entry :\n\t\t\t\t\trenderParameters.entrySet()) {\n\n\t\t\t\tString name = entry.getKey();\n\t\t\t\tString[] values = entry.getValue();\n\n\t\t\t\tname = removePortletNamespace(\n\t\t\t\t\tinvokerPortlet, portletNamespace, name);\n\n\t\t\t\tdynamicRequest.setParameterValues(name, values);\n\t\t\t}\n\t\t}\n\n\t\tmergePublicRenderParameters(dynamicRequest, preferences, plid);\n\n\t\t_request = dynamicRequest;\n\t\t_originalRequest = request;\n\t\t_wapTheme = BrowserSnifferUtil.isWap(_request);\n\t\t_portlet = portlet;\n\t\t_portalContext = new PortalContextImpl();\n\t\t_portletContext = portletContext;\n\t\t_windowState = windowState;\n\t\t_portletMode = portletMode;\n\t\t_preferences = preferences;\n\t\t_session = new PortletSessionImpl(\n\t\t\t_request.getSession(), _portletContext, _portletName, plid);\n\n\t\tString remoteUser = request.getRemoteUser();\n\n\t\tString userPrincipalStrategy = portlet.getUserPrincipalStrategy();\n\n\t\tif (userPrincipalStrategy.equals(\n\t\t\t\tPortletConstants.USER_PRINCIPAL_STRATEGY_SCREEN_NAME)) {\n\n\t\t\ttry {\n\t\t\t\tUser user = PortalUtil.getUser(request);\n\n\t\t\t\tif (user != null) {\n\t\t\t\t\t_remoteUser = user.getScreenName();\n\t\t\t\t\t_remoteUserId = user.getUserId();\n\t\t\t\t\t_userPrincipal = new ProtectedPrincipal(_remoteUser);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlong userId = PortalUtil.getUserId(request);\n\n\t\t\tif ((userId > 0) && (remoteUser == null)) {\n\t\t\t\t_remoteUser = String.valueOf(userId);\n\t\t\t\t_remoteUserId = userId;\n\t\t\t\t_userPrincipal = new ProtectedPrincipal(_remoteUser);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_remoteUser = remoteUser;\n\t\t\t\t_remoteUserId = GetterUtil.getLong(remoteUser);\n\t\t\t\t_userPrincipal = request.getUserPrincipal();\n\t\t\t}\n\t\t}\n\n\t\t_locale = themeDisplay.getLocale();\n\t\t_plid = plid;\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isRequestedSessionIdValid() {\n\t\tif (_session != null) {\n\t\t\treturn _session.isValid();\n\t\t}\n\t\telse {\n\t\t\treturn _request.isRequestedSessionIdValid();\n\t\t}\n\t}","id":93594,"modified_method":"public boolean isRequestedSessionIdValid() {\n\t\treturn _request.isRequestedSessionIdValid();\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getPortletScope(String portletName, long plid) {\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(PORTLET_SCOPE_NAMESPACE);\n\t\tsb.append(portletName);\n\t\tsb.append(LAYOUT_SEPARATOR);\n\t\tsb.append(plid);\n\n\t\treturn sb.toString();\n\t}","id":93595,"modified_method":"private String _getPortletScope(String portletName, long plid) {\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(PORTLET_SCOPE_NAMESPACE);\n\t\tsb.append(portletName);\n\t\tsb.append(LAYOUT_SEPARATOR);\n\t\tsb.append(plid);\n\n\t\treturn sb.toString();\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object getAttribute(String name, int scope) {\n\t\tif (name == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tif (_invalid) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tif (scope == PortletSession.PORTLET_SCOPE) {\n\t\t\tname = _getPortletScopeName(name);\n\t\t}\n\n\t\treturn _session.getAttribute(name);\n\t}","id":93596,"modified_method":"public Object getAttribute(String name, int scope) {\n\t\tif (name == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tif (scope == PortletSession.PORTLET_SCOPE) {\n\t\t\tname = _getPortletScopeName(name);\n\t\t}\n\n\t\treturn _httpSession.getAttribute(name);\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String _getPortletScopeName(String name) {\n\t\treturn getPortletScopeName(_portletName, _plid, name);\n\t}","id":93597,"modified_method":"private String _getPortletScopeName(String name) {\n\t\treturn _portletScope.concat(StringPool.QUESTION).concat(name);\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public HttpSession getHttpSession() {\n\t\treturn _session;\n\t}","id":93598,"modified_method":"public HttpSession getHttpSession() {\n\t\treturn _httpSession;\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Map<String, Object> getAttributeMap(int scope) {\n\t\tMap<String, Object> map = new HashMap<String, Object>();\n\n\t\tEnumeration<String> enu = _getAttributeNames(scope, false);\n\n\t\tString portletScope = getPortletScope(_portletName, _plid);\n\n\t\tint portletScopeLength = portletScope.length();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = enu.nextElement();\n\n\t\t\tObject value = _session.getAttribute(name);\n\n\t\t\tif (scope == PortletSession.PORTLET_SCOPE) {\n\t\t\t\tname = name.substring(portletScopeLength + 1);\n\t\t\t}\n\n\t\t\tmap.put(name, value);\n\t\t}\n\n\t\treturn map;\n\t}","id":93599,"modified_method":"public Map<String, Object> getAttributeMap(int scope) {\n\t\tMap<String, Object> map = new HashMap<String, Object>();\n\n\t\tEnumeration<String> enu = _getAttributeNames(scope, false);\n\n\t\tint portletScopeLength = _portletScope.length();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = enu.nextElement();\n\n\t\t\tObject value = _httpSession.getAttribute(name);\n\n\t\t\tif (scope == PortletSession.PORTLET_SCOPE) {\n\t\t\t\tname = name.substring(portletScopeLength + 1);\n\t\t\t}\n\n\t\t\tmap.put(name, value);\n\t\t}\n\n\t\treturn map;\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isNew() {\n\t\tif (_invalid) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\treturn _new;\n\t}","id":93600,"modified_method":"public boolean isNew() {\n\t\treturn _httpSession.isNew();\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void removeAttribute(String name, int scope) {\n\t\tif (name == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tif (_invalid) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tif (scope == PortletSession.PORTLET_SCOPE) {\n\t\t\tname = _getPortletScopeName(name);\n\t\t}\n\n\t\t_session.removeAttribute(name);\n\t}","id":93601,"modified_method":"public void removeAttribute(String name, int scope) {\n\t\tif (name == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tif (scope == PortletSession.PORTLET_SCOPE) {\n\t\t\tname = _getPortletScopeName(name);\n\t\t}\n\n\t\t_httpSession.removeAttribute(name);\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void removeAttribute(String name) {\n\t\tif (name == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tif (_invalid) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t_session.removeAttribute(_getPortletScopeName(name));\n\t}","id":93602,"modified_method":"public void removeAttribute(String name) {\n\t\tif (name == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tString scopeName = _getPortletScopeName(name);\n\n\t\t_httpSession.removeAttribute(scopeName);\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setAttribute(String name, Object value) {\n\t\tif (name == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tif (_invalid) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t_session.setAttribute(_getPortletScopeName(name), value);\n\t}","id":93603,"modified_method":"public void setAttribute(String name, Object value) {\n\t\tif (name == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tString scopeName = _getPortletScopeName(name);\n\n\t\t_httpSession.setAttribute(scopeName, value);\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getId() {\n\t\treturn _session.getId();\n\t}","id":93604,"modified_method":"public String getId() {\n\t\treturn _httpSession.getId();\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PortletSessionImpl(\n\t\tHttpServletRequest request, String portletName,\n\t\tPortletContext portletContext, String portalSessionId, long plid) {\n\n\t\t_session = request.getSession();\n\t\t_portletName = portletName;\n\t\t_portletContext = portletContext;\n\t\t_creationTime = System.currentTimeMillis();\n\t\t_lastAccessedTime = _creationTime;\n\t\t_interval = _session.getMaxInactiveInterval();\n\t\t_new = true;\n\t\t_invalid = false;\n\t\t_portalSessionId = portalSessionId;\n\t\t_plid = plid;\n\t}","id":93605,"modified_method":"public PortletSessionImpl(\n\t\tHttpSession httpSession, PortletContext portletContext,\n\t\tString portletName, long plid) {\n\n\t\t_httpSession = httpSession;\n\t\t_portletContext = portletContext;\n\t\t_portletScope = _getPortletScope(portletName, plid);\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setAttribute(String name, Object value, int scope) {\n\t\tif (name == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tif (_invalid) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tif (scope == PortletSession.PORTLET_SCOPE) {\n\t\t\tname = _getPortletScopeName(name);\n\t\t}\n\n\t\t_session.setAttribute(name, value);\n\t}","id":93606,"modified_method":"public void setAttribute(String name, Object value, int scope) {\n\t\tif (name == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tif (scope == PortletSession.PORTLET_SCOPE) {\n\t\t\tname = _getPortletScopeName(name);\n\t\t}\n\n\t\t_httpSession.setAttribute(name, value);\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public long getCreationTime() {\n\t\tif (_invalid) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\treturn _creationTime;\n\t}","id":93607,"modified_method":"public long getCreationTime() {\n\t\treturn _httpSession.getCreationTime();\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setHttpSession(HttpSession session) {\n\t\t_session = session;\n\t}","id":93608,"modified_method":"public void setHttpSession(HttpSession session) {\n\t\t_httpSession = session;\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object getAttribute(String name) {\n\t\tif (name == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tif (_invalid) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\treturn _session.getAttribute(_getPortletScopeName(name));\n\t}","id":93609,"modified_method":"public Object getAttribute(String name) {\n\t\tif (name == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tString scopeName = _getPortletScopeName(name);\n\n\t\treturn _httpSession.getAttribute(scopeName);\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void invalidate() {\n\t\tif (_invalid) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t_session.invalidate();\n\n\t\t_invalid = true;\n\t}","id":93610,"modified_method":"public void invalidate() {\n\t\t_httpSession.invalidate();\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setMaxInactiveInterval(int interval) {\n\t\t_interval = interval;\n\t}","id":93611,"modified_method":"public void setMaxInactiveInterval(int interval) {\n\t\t_httpSession.setMaxInactiveInterval(interval);\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public long getLastAccessedTime() {\n\t\treturn _lastAccessedTime;\n\t}","id":93612,"modified_method":"public long getLastAccessedTime() {\n\t\treturn _httpSession.getLastAccessedTime();\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Enumeration<String> _getAttributeNames(\n\t\tint scope, boolean removePrefix) {\n\n\t\tif (_invalid) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tif (scope == PortletSession.PORTLET_SCOPE) {\n\t\t\tList<String> attributeNames = new ArrayList<String>();\n\n\t\t\tString portletScope = getPortletScope(_portletName, _plid);\n\n\t\t\tint portletScopeLength = portletScope.length();\n\n\t\t\tEnumeration<String> enu = _session.getAttributeNames();\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tString name = enu.nextElement();\n\n\t\t\t\tif ((name.length() > (portletScopeLength + 1)) &&\n\t\t\t\t\t(name.charAt(portletScopeLength) == CharPool.QUESTION) &&\n\t\t\t\t\tname.startsWith(portletScope)) {\n\n\t\t\t\t\tif (removePrefix) {\n\t\t\t\t\t\tname = name.substring(portletScopeLength + 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tattributeNames.add(name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Collections.enumeration(attributeNames);\n\t\t}\n\t\telse {\n\t\t\treturn _session.getAttributeNames();\n\t\t}\n\t}","id":93613,"modified_method":"private Enumeration<String> _getAttributeNames(\n\t\tint scope, boolean removePrefix) {\n\n\t\tif (scope == PortletSession.PORTLET_SCOPE) {\n\t\t\tList<String> attributeNames = new ArrayList<String>();\n\n\t\t\tint portletScopeLength = _portletScope.length();\n\n\t\t\tEnumeration<String> enu = _httpSession.getAttributeNames();\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tString name = enu.nextElement();\n\n\t\t\t\tif ((name.length() > (portletScopeLength + 1)) &&\n\t\t\t\t\t(name.charAt(portletScopeLength) == CharPool.QUESTION) &&\n\t\t\t\t\tname.startsWith(_portletScope)) {\n\n\t\t\t\t\tif (removePrefix) {\n\t\t\t\t\t\tname = name.substring(portletScopeLength + 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tattributeNames.add(name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Collections.enumeration(attributeNames);\n\t\t}\n\t\telse {\n\t\t\treturn _httpSession.getAttributeNames();\n\t\t}\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int getMaxInactiveInterval() {\n\t\treturn _interval;\n\t}","id":93614,"modified_method":"public int getMaxInactiveInterval() {\n\t\treturn _httpSession.getMaxInactiveInterval();\n\t}","commit_id":"5fb28d3277c50b6990f9b5390f49943dcb4fa1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public QueueEntry pop(QueueConsumer consumer, QueuePartitioner partitioner)\r\n  throws InterruptedException {\r\n    // Anything in the queue at all?  Wait for a push if so\r\n    if (head == null) {\r\n      waitForPush();\r\n      return pop(consumer, partitioner);\r\n    }\r\n    \r\n    // Determine the current state for this consumer group\r\n    ConsumerGroup group = null;\r\n    if (!this.consumerGroups.containsKey(consumer.getGroupId())) {\r\n      // This group has not consumed before, set group head = head\r\n      group = new ConsumerGroup(consumer.getGroupId());\r\n      group.setHead(head);\r\n      ConsumerGroup existingGroup = this.consumerGroups.putIfAbsent(\r\n          consumer.getGroupId(), group);\r\n      if (existingGroup != null) {\r\n        // Someone else added the group concurrently with us, use theirs\r\n        group = existingGroup;\r\n      }\r\n    } else {\r\n      group = this.consumerGroups.get(consumer.getConsumerId());\r\n    }\r\n    \r\n    // If group has no entries available, wait for a push\r\n    if (group.getHead() == null) {\r\n      waitForPush();\r\n      return pop(consumer, partitioner);\r\n    }\r\n    \r\n    // Iterate entries to see if we should emit one\r\n    synchronized (group) {\r\n      Entry curEntry = group.getHead();\r\n      while (curEntry != null) {\r\n        // Check if this is already assigned to someone else in the same group\r\n        // or if it's already assigned to us\r\n        GroupConsumptionInfo info =\r\n            curEntry.getConsumerInfo(consumer.getGroupId());\r\n        if (info.isAvailable() ||\r\n            (info.getConsumerId() == consumer.getConsumerId() &&\r\n            !info.isAcked())) {\r\n          QueueEntry entry = curEntry.makeQueueEntry();\r\n          if (partitioner.shouldEmit(consumer, entry)) {\r\n            entry.setConsumer(consumer);\r\n            info.setPopConsumer(consumer);\r\n            return entry;\r\n          }\r\n        }\r\n        // Entry is taken or not applicable to this consumer, iterate to next\r\n        curEntry = curEntry.getNext();\r\n      }\r\n    }\r\n      \r\n    // Didn't find anything.  Wait and try again.\r\n    waitForPush();\r\n    return pop(consumer, partitioner);\r\n  }","id":93615,"modified_method":"public QueueEntry pop(QueueConsumer consumer, QueuePartitioner partitioner)\r\n  throws InterruptedException {\r\n    // Anything in the queue at all?  Wait for a push if so\r\n    if (head == null) {\r\n      if (sync) waitForPush(); else return null;\r\n      return pop(consumer, partitioner);\r\n    }\r\n    \r\n    // Determine the current state for this consumer group\r\n    ConsumerGroup group = null;\r\n    if (!this.consumerGroups.containsKey(consumer.getGroupId())) {\r\n      // This group has not consumed before, set group head = head\r\n      group = new ConsumerGroup(consumer.getGroupId());\r\n      group.setHead(head);\r\n      ConsumerGroup existingGroup = this.consumerGroups.putIfAbsent(\r\n          consumer.getGroupId(), group);\r\n      if (existingGroup != null) {\r\n        // Someone else added the group concurrently with us, use theirs\r\n        group = existingGroup;\r\n      }\r\n    } else {\r\n      group = this.consumerGroups.get(consumer.getConsumerId());\r\n    }\r\n    \r\n    // If group has no entries available, wait for a push\r\n    if (group.getHead() == null) {\r\n      if (sync) waitForPush(); else return null;\r\n      return pop(consumer, partitioner);\r\n    }\r\n    \r\n    // Iterate entries to see if we should emit one\r\n    synchronized (group) {\r\n      Entry curEntry = group.getHead();\r\n      while (curEntry != null) {\r\n        // Check if this is already assigned to someone else in the same group\r\n        // or if it's already assigned to us\r\n        GroupConsumptionInfo info =\r\n            curEntry.getConsumerInfo(consumer.getGroupId());\r\n        if (info.isAvailable() ||\r\n            (info.getConsumerId() == consumer.getConsumerId() &&\r\n            !info.isAcked())) {\r\n          QueueEntry entry = curEntry.makeQueueEntry();\r\n          if (partitioner.shouldEmit(consumer, entry)) {\r\n            entry.setConsumer(consumer);\r\n            info.setPopConsumer(consumer);\r\n            return entry;\r\n          }\r\n        }\r\n        // Entry is taken or not applicable to this consumer, iterate to next\r\n        curEntry = curEntry.getNext();\r\n      }\r\n    }\r\n      \r\n    // Didn't find anything.  Wait and try again.\r\n    if (sync) waitForPush(); else return null;\r\n    return pop(consumer, partitioner);\r\n  }","commit_id":"d65223002c9f951623dd6b24494408a1f2026824","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\r\n  public void testSingleConsumerThreaded() throws Exception {\r\n    MemoryQueue queue = new MemoryQueue();\r\n\r\n    byte [] valueOne = Bytes.toBytes(\"value1\");\r\n    byte [] valueTwo = Bytes.toBytes(\"value2\");\r\n\r\n\r\n    // pop it with the single consumer and random partitioner\r\n    QueueConsumer consumer = new QueueConsumer(0, 0, 1);\r\n    QueuePartitioner partitioner = new QueuePartitioner.RandomPartitioner();\r\n    \r\n    // spawn a thread to pop\r\n    QueuePopper popper = new QueuePopper(queue, consumer, partitioner);\r\n    popper.start();\r\n    \r\n    // popper should be empty\r\n    assertNull(popper.nonBlockPop());\r\n    \r\n    // trigger a pop\r\n    assertTrue(popper.triggerPop());\r\n\r\n    // nothing in queue so popper should be empty\r\n    QueueEntry entry = popper.blockPop(100);\r\n    assertNull(entry);\r\n\r\n    // push\r\n    assertTrue(queue.push(valueOne));\r\n    assertNotNull(queue.pop(consumer, partitioner));\r\n    \r\n    Thread.sleep(1000);\r\n    // popper should hit now\r\n    entry = popper.blockPop(100);\r\n    assertNotNull(entry);\r\n    assertTrue(Bytes.equals(entry.getValue(), valueOne));\r\n    \r\n    // shut down\r\n    popper.shutdown();\r\n  }","id":93616,"modified_method":"@Test\r\n  public void testSingleConsumerThreaded() throws Exception {\r\n    MemoryQueue queue = new MemoryQueue();\r\n\r\n    byte [] valueOne = Bytes.toBytes(\"value1\");\r\n    byte [] valueTwo = Bytes.toBytes(\"value2\");\r\n\r\n\r\n    // pop it with the single consumer and random partitioner\r\n    QueueConsumer consumer = new QueueConsumer(0, 0, 1);\r\n    QueuePartitioner partitioner = new QueuePartitioner.RandomPartitioner();\r\n    \r\n    // spawn a thread to pop\r\n    QueuePopper popper = new QueuePopper(queue, consumer, partitioner);\r\n    popper.start();\r\n    \r\n    // popper should be empty\r\n    assertNull(popper.nonBlockPop());\r\n    \r\n    // trigger a pop\r\n    assertTrue(popper.triggerPop());\r\n\r\n    // nothing in queue so popper should be empty\r\n    QueueEntry entry = popper.blockPop(100);\r\n    assertNull(entry);\r\n\r\n    // push\r\n    assertTrue(queue.push(valueOne));\r\n    assertNotNull(queue.pop(consumer, partitioner));\r\n    \r\n    // popper should hit now\r\n    entry = popper.blockPop(100);\r\n    assertNotNull(entry);\r\n    assertTrue(Bytes.equals(entry.getValue(), valueOne));\r\n    \r\n    // shut down\r\n    popper.shutdown();\r\n  }","commit_id":"d65223002c9f951623dd6b24494408a1f2026824","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\r\n  public void testSingleConsumerSimple() throws Exception {\r\n    MemoryQueue queue = new MemoryQueue();\r\n\r\n    byte [] valueOne = Bytes.toBytes(\"value1\");\r\n    byte [] valueTwo = Bytes.toBytes(\"value2\");\r\n\r\n    // push two entries\r\n    assertTrue(queue.push(valueOne));\r\n    assertTrue(queue.push(valueTwo));\r\n\r\n    // pop it with the single consumer and random partitioner\r\n    QueueConsumer consumer = new QueueConsumer(0, 0, 1);\r\n    QueuePartitioner partitioner = new QueuePartitioner.RandomPartitioner();\r\n    QueueEntry entry = queue.pop(consumer, partitioner);\r\n\r\n    // verify it's the first value\r\n    assertTrue(Bytes.equals(entry.getValue(), valueOne));\r\n\r\n    // pop again without acking, should still get first value\r\n    entry = queue.pop(consumer, partitioner);\r\n    assertTrue(Bytes.equals(entry.getValue(), valueOne));\r\n\r\n    // ack\r\n    assertTrue(queue.ack(entry));\r\n\r\n    // pop, should get second value\r\n    entry = queue.pop(consumer, partitioner);\r\n    assertTrue(Bytes.equals(entry.getValue(), valueTwo));\r\n\r\n    // ack\r\n    assertTrue(queue.ack(entry));\r\n  }","id":93617,"modified_method":"@Test\r\n  public void testSingleConsumerSimple() throws Exception {\r\n    MemoryQueue queue = new MemoryQueue();\r\n\r\n    byte [] valueOne = Bytes.toBytes(\"value1\");\r\n    byte [] valueTwo = Bytes.toBytes(\"value2\");\r\n\r\n    // push two entries\r\n    assertTrue(queue.push(valueOne));\r\n    assertTrue(queue.push(valueTwo));\r\n\r\n    // pop it with the single consumer and random partitioner\r\n    QueueConsumer consumer = new QueueConsumer(0, 0, 1);\r\n    QueuePartitioner partitioner = new QueuePartitioner.RandomPartitioner();\r\n    QueueEntry entry = queue.pop(consumer, partitioner);\r\n\r\n    // verify it's the first value\r\n    assertTrue(Bytes.equals(entry.getValue(), valueOne));\r\n\r\n    // pop again without acking, should still get first value\r\n    entry = queue.pop(consumer, partitioner);\r\n    assertTrue(Bytes.equals(entry.getValue(), valueOne));\r\n\r\n    // ack\r\n    assertTrue(queue.ack(entry));\r\n\r\n    // pop, should get second value\r\n    entry = queue.pop(consumer, partitioner);\r\n    assertTrue(Bytes.equals(entry.getValue(), valueTwo));\r\n\r\n    // ack\r\n    assertTrue(queue.ack(entry));\r\n    \r\n    // verify queue is empty\r\n    queue.sync = false;\r\n    assertNull(queue.pop(consumer, partitioner));\r\n    queue.sync = true;\r\n  }","commit_id":"d65223002c9f951623dd6b24494408a1f2026824","url":"https://github.com/caskdata/cdap"},{"original_method":"public void storeAndShutdown() throws Exception {\n\t\tBrokerPool pool = startDB();\n\t\tDBBroker broker = null;\n\t\ttry {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            \n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection test = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            broker.saveCollection(transaction, test);\n            \n            File files[] = dir.listFiles(new FilenameFilter() {\n\t        \tpublic boolean accept(File dir, String name) {\n\t        \t\tif (name.endsWith(\".xml\"))\n\t        \t\t\treturn true;\n\t        \t\treturn false;\n\t        \t}\n\t        });\n            \n            File f;\n            IndexInfo info;\n            \n            // store some documents.\n            for (int i = 0; i < files.length; i++) {\n                f = files[i];\n                try {\n                    info = test.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                    test.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n            \n            XQuery xquery = broker.getXQueryService();\n            Sequence result = xquery.execute(\"//SPEECH[LINE &= 'love']\", Sequence.EMPTY_SEQUENCE);\n            assertEquals(result.getLength(), 160);\n            \n            transact.commit(transaction);\n            \n            transaction = transact.beginTransaction();\n            \n            broker.removeCollection(transaction, test);\n            \n            transact.commit(transaction);\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t\t\n\t\t// shut down the database\n        shutdown();\n        System.out.println(\"Database stopped.\");\n        \n        // try to remove the database files\n//        try {\n//\t        File dataDir = new File(\"webapp/WEB-INF/data\");\n//\t        File files[] = dataDir.listFiles(new FilenameFilter() {\n//\t        \tpublic boolean accept(File dir, String name) {\n//\t        \t\tif (name.endsWith(\".dbx\") || name.endsWith(\".log\"))\n//\t        \t\t\treturn true;\n//\t        \t\treturn false;\n//\t        \t}\n//\t        });\n//\t        for (int i = 0; i < files.length; i++) {\n//\t        \tSystem.out.println(\"Removing \" + files[i].getAbsolutePath());\n//\t    \t\tfiles[i].delete();\n//\t        }\n//        } catch (Exception e) {\n//        \tSystem.err.println(\"Error while deleting database files:\\n\" + e.getMessage());\n//        \te.printStackTrace();\n//        }\n\t}","id":93618,"modified_method":"public void storeAndShutdown() {\n\t\tBrokerPool pool = null;\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\tpool = startDB();\n\t\t\tassertNotNull(pool);\n\t\t\tbroker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection test = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            assertNotNull(test); \n            broker.saveCollection(transaction, test);\n            \n            File files[] = dir.listFiles(new FilenameFilter() {\n\t        \tpublic boolean accept(File dir, String name) {\n\t        \t\tif (name.endsWith(\".xml\"))\n\t        \t\t\treturn true;\n\t        \t\treturn false;\n\t        \t}\n\t        });\n            assertNotNull(files); \n            \n            File f;\n            IndexInfo info;\n            \n            // store some documents.\n            for (int i = 0; i < files.length; i++) {\n                f = files[i];\n                assertNotNull(f); \n                try {\n                    info = test.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                    assertNotNull(info); \n                    test.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n            \n            XQuery xquery = broker.getXQueryService();\n            assertNotNull(xquery); \n            Sequence result = xquery.execute(\"//SPEECH[LINE &= 'love']\", Sequence.EMPTY_SEQUENCE);\n            assertNotNull(result); \n            assertEquals(result.getLength(), 160);\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n            transaction = transact.beginTransaction();\n            System.out.println(\"Transaction started ...\");\n            \n            broker.removeCollection(transaction, test);\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n        } catch (Exception e) {            \n            fail(e.getMessage()); \n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t\t\n\t\t// shut down the database\n        shutdown();\n        System.out.println(\"Database stopped.\");\n        \n        // try to remove the database files\n//        try {\n//\t        File dataDir = new File(\"webapp/WEB-INF/data\");\n//\t        File files[] = dataDir.listFiles(new FilenameFilter() {\n//\t        \tpublic boolean accept(File dir, String name) {\n//\t        \t\tif (name.endsWith(\".dbx\") || name.endsWith(\".log\"))\n//\t        \t\t\treturn true;\n//\t        \t\treturn false;\n//\t        \t}\n//\t        });\n//\t        for (int i = 0; i < files.length; i++) {\n//\t        \tSystem.out.println(\"Removing \" + files[i].getAbsolutePath());\n//\t    \t\tfiles[i].delete();;\n//\t        }\n//        } catch (Exception e) {\n//        \tSystem.err.println(\"Error while deleting database files:\\n\" + e.getMessage());\n//        \te.printStackTrace();\n//        }\n\t}","commit_id":"f45bf0463c9c0eaa25f1da0b2fe547cd1a208a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"protected BrokerPool startDB() throws Exception {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            return BrokerPool.getInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n        return null;\n    }","id":93619,"modified_method":"protected BrokerPool startDB() {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            return BrokerPool.getInstance();\n        } catch (Exception e) {            \n            fail(e.getMessage());\n        }\n        return null;\n    }","commit_id":"f45bf0463c9c0eaa25f1da0b2fe547cd1a208a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testUpdate() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            \n            TransactionManager mgr = pool.getTransactionManager();\n            \n            IndexInfo info = init(broker, mgr);\n            DocumentSet docs = new DocumentSet();\n            docs.add(info.getDocument());\n            XUpdateProcessor proc = new XUpdateProcessor(broker, docs);\n            \n            Txn transaction = mgr.beginTransaction();\n            \n            String xupdate;\n            Modification modifications[];\n            \n            // append some new element to records\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:append select=\\\"/products\\\">\" +\n                    \"       <product>\" +\n                    \"           <xu:attribute name=\\\"id\\\"><xu:value-of select=\\\"count(/products/product) + 1\\\"/><\/xu:attribute>\" +\n                    \"           <description>Product \" + i + \"<\/description>\" +\n                    \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n                    \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n                    \"       <\/product>\" +\n                    \"   <\/xu:append>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            mgr.commit(transaction);\n            \n            // the following transaction will not be committed and thus undone during recovery\n            transaction = mgr.beginTransaction();\n            \n            // update attributes\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:update select=\\\"/products/product[\" + i + \"]/@id\\\">\" + i + \"u<\/xu:update>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            pool.getTransactionManager().getJournal().flushToLog(true);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93620,"modified_method":"public void testUpdate() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = null;        \n        DBBroker broker = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n        \tbroker = pool.get(SecurityManager.SYSTEM_USER);\n        \tassertNotNull(broker);            \n            TransactionManager mgr = pool.getTransactionManager();\n            assertNotNull(mgr); \n            \n            IndexInfo info = init(broker, mgr);\n            assertNotNull(info);\n            DocumentSet docs = new DocumentSet();\n            docs.add(info.getDocument());\n            XUpdateProcessor proc = new XUpdateProcessor(broker, docs);\n            assertNotNull(proc);\n            \n            Txn transaction = mgr.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            String xupdate;\n            Modification modifications[];\n            \n            // append some new element to records\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:append select=\\\"/products\\\">\" +\n                    \"       <product>\" +\n                    \"           <xu:attribute name=\\\"id\\\"><xu:value-of select=\\\"count(/products/product) + 1\\\"/><\/xu:attribute>\" +\n                    \"           <description>Product \" + i + \"<\/description>\" +\n                    \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n                    \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n                    \"       <\/product>\" +\n                    \"   <\/xu:append>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                assertNotNull(modifications);\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            mgr.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n            // the following transaction will not be committed and thus undone during recovery\n            transaction = mgr.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            // update attributes\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:update select=\\\"/products/product[\" + i + \"]/@id\\\">\" + i + \"u<\/xu:update>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                assertNotNull(modifications);\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n           \n            //Don't commit\n            pool.getTransactionManager().getJournal().flushToLog(true);\n            System.out.println(\"Transaction interrupted ...\");    \n        } catch (Exception e) {            \n            fail(e.getMessage());             \n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"f45bf0463c9c0eaa25f1da0b2fe547cd1a208a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testXMLDBStore() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = startDB();\n        \n        org.xmldb.api.base.Collection root = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION, \"admin\", \"\");\n        CollectionManagementServiceImpl mgr = (CollectionManagementServiceImpl) \n            root.getService(\"CollectionManagementService\", \"1.0\");\n        org.xmldb.api.base.Collection test = root.getChildCollection(\"test\");\n        if (test == null)\n            test = mgr.createCollection(DBBroker.ROOT_COLLECTION + \"/test\");\n        org.xmldb.api.base.Collection test2 = test.getChildCollection(\"test2\");\n        if (test2 == null)\n            test2 = mgr.createCollection(DBBroker.ROOT_COLLECTION + \"/test/test2\");\n        \n        Resource res = test2.createResource(\"test_xmldb.xml\", \"XMLResource\");\n        res.setContent(TEST_XML);\n        test2.storeResource(res);\n        \n        XUpdateQueryService service = (XUpdateQueryService)\n            test2.getService(\"XUpdateQueryService\", \"1.0\");\n        \n        String xupdate;\n        \n        System.out.println(\"Inserting new items  ...\");\n        // insert some nodes\n        for (int i = 1; i <= 200; i++) {\n            xupdate =\n                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                \"   <xu:insert-before select=\\\"/products/product[1]\\\">\" +\n                \"       <product>\" +\n                \"           <description>Product \" + i + \"<\/description>\" +\n                \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n                \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n                \"       <\/product>\" +\n                \"   <\/xu:insert-before>\" +\n                \"<\/xu:modifications>\";\n            service.updateResource(\"test_xmldb.xml\", xupdate);\n        }\n        \n        System.out.println(\"Adding attributes  ...\");\n        // add attribute\n        for (int i = 1; i <= 200; i++) {\n          xupdate =\n              \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n              \"   <xu:append select=\\\"/products/product[\" + i + \"]\\\">\" +\n              \"         <xu:attribute name=\\\"id\\\">\" + i + \"<\/xu:attribute>\" +\n              \" <\/xu:append>\" +\n              \"<\/xu:modifications>\";\n          service.updateResource(\"test_xmldb.xml\", xupdate);\n      }\n        \n        System.out.println(\"Replacing elements  ...\");\n        // replace some\n        for (int i = 1; i <= 100; i++) {\n          xupdate =\n              \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n              \"   <xu:replace select=\\\"/products/product[\" + i + \"]\\\">\" +\n              \"     <product id=\\\"\" + i + \"\\\">\" +\n              \"         <description>Replaced product<\/description>\" +\n              \"         <price>\" + (i * 0.75) + \"<\/price>\" +\n              \"     <\/product>\" +\n              \" <\/xu:replace>\" +\n              \"<\/xu:modifications>\";\n          service.updateResource(\"test_xmldb.xml\", xupdate);\n      }\n            \n        System.out.println(\"Removing some elements ...\");\n        // remove some\n        for (int i = 1; i <= 100; i++) {\n            xupdate =\n                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                \"   <xu:remove select=\\\"/products/product[last()]\\\"/>\" +\n                \"<\/xu:modifications>\";\n            service.updateResource(\"test_xmldb.xml\", xupdate);\n        }\n        \n        System.out.println(\"Appending some elements ...\");\n        for (int i = 1; i <= 100; i++) {\n            xupdate =\n                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                \"   <xu:append select=\\\"/products\\\">\" +\n                \"       <product>\" +\n                \"           <xu:attribute name=\\\"id\\\"><xu:value-of select=\\\"count(/products/product) + 1\\\"/><\/xu:attribute>\" +\n                \"           <description>Product \" + i + \"<\/description>\" +\n                \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n                \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n                \"       <\/product>\" +\n                \"   <\/xu:append>\" +\n                \"<\/xu:modifications>\";\n            service.updateResource(\"test_xmldb.xml\", xupdate);\n        }\n        \n        System.out.println(\"Renaming elements  ...\");\n        // rename element \"description\" to \"descript\"\n        xupdate =\n            \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n            \"   <xu:rename select=\\\"/products/product/description\\\">descript<\/xu:rename>\" +\n            \"<\/xu:modifications>\";\n        service.updateResource(\"test_xmldb.xml\", xupdate);\n        \n        System.out.println(\"Updating attribute values ...\");\n        // update attribute values\n        for (int i = 1; i <= 200; i++) {\n            xupdate =\n                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                \"   <xu:update select=\\\"/products/product[\" + i + \"]/@id\\\">\" + i + \"u<\/xu:update>\" +\n                \"<\/xu:modifications>\";\n            service.updateResource(\"test_xmldb.xml\", xupdate);\n        }\n        System.out.println(\"Append new element to each item ...\");\n        // append new element to records\n        for (int i = 1; i <= 200; i++) {\n            xupdate =\n                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                \"   <xu:append select=\\\"/products/product[\" + i + \"]\\\">\" +\n                \"       <date><xu:value-of select=\\\"current-dateTime()\\\"/><\/date>\" +\n                \"   <\/xu:append>\" +\n                \"<\/xu:modifications>\";\n            service.updateResource(\"test_xmldb.xml\", xupdate);\n        }\n        \n        System.out.println(\"Updating element content ...\");\n        // update element content\n        for (int i = 1; i <= 200; i++) {\n            xupdate =\n                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                \"   <xu:update select=\\\"/products/product[\" + i + \"]/price\\\">19.99<\/xu:update>\" +\n                \"<\/xu:modifications>\";\n            service.updateResource(\"test_xmldb.xml\", xupdate);\n        }\n    }","id":93621,"modified_method":"public void testXMLDBStore() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);        \n        \torg.xmldb.api.base.Collection root = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION, \"admin\", \"\");\n        \tassertNotNull(root);\n        \tCollectionManagementServiceImpl mgr = (CollectionManagementServiceImpl) \n            \troot.getService(\"CollectionManagementService\", \"1.0\");\n        \tassertNotNull(mgr);\n        \torg.xmldb.api.base.Collection test = root.getChildCollection(\"test\");\n        \tif (test == null)\n        \t\ttest = mgr.createCollection(DBBroker.ROOT_COLLECTION + \"/test\");\n        \tassertNotNull(test);\n        \torg.xmldb.api.base.Collection test2 = test.getChildCollection(\"test2\");\n        \tif (test2 == null)\n        \t\ttest2 = mgr.createCollection(DBBroker.ROOT_COLLECTION + \"/test/test2\");\n        \tassertNotNull(test2);        \n        \tResource res = test2.createResource(\"test_xmldb.xml\", \"XMLResource\");\n        \tassertNotNull(res);\n        \tres.setContent(TEST_XML);\n        \ttest2.storeResource(res);\n        \n        \tXUpdateQueryService service = (XUpdateQueryService)\n            \ttest2.getService(\"XUpdateQueryService\", \"1.0\");\n        \tassertNotNull(service);\n        \n        \tString xupdate;\n        \n\t        System.out.println(\"Inserting new items  ...\");\n\t        // insert some nodes\n\t        for (int i = 1; i <= 200; i++) {\n\t            xupdate =\n\t                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n\t                \"   <xu:insert-before select=\\\"/products/product[1]\\\">\" +\n\t                \"       <product>\" +\n\t                \"           <description>Product \" + i + \"<\/description>\" +\n\t                \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n\t                \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n\t                \"       <\/product>\" +\n\t                \"   <\/xu:insert-before>\" +\n\t                \"<\/xu:modifications>\";\n\t            service.updateResource(\"test_xmldb.xml\", xupdate);\n\t        }\n\t        \n\t        System.out.println(\"Adding attributes  ...\");\n\t        // add attribute\n\t        for (int i = 1; i <= 200; i++) {\n\t          xupdate =\n\t              \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n\t              \"   <xu:append select=\\\"/products/product[\" + i + \"]\\\">\" +\n\t              \"         <xu:attribute name=\\\"id\\\">\" + i + \"<\/xu:attribute>\" +\n\t              \" <\/xu:append>\" +\n\t              \"<\/xu:modifications>\";\n\t          service.updateResource(\"test_xmldb.xml\", xupdate);\n\t      }\n\t        \n\t        System.out.println(\"Replacing elements  ...\");\n\t        // replace some\n\t        for (int i = 1; i <= 100; i++) {\n\t          xupdate =\n\t              \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n\t              \"   <xu:replace select=\\\"/products/product[\" + i + \"]\\\">\" +\n\t              \"     <product id=\\\"\" + i + \"\\\">\" +\n\t              \"         <description>Replaced product<\/description>\" +\n\t              \"         <price>\" + (i * 0.75) + \"<\/price>\" +\n\t              \"     <\/product>\" +\n\t              \" <\/xu:replace>\" +\n\t              \"<\/xu:modifications>\";\n\t          service.updateResource(\"test_xmldb.xml\", xupdate);\n\t      }\n\t            \n\t        System.out.println(\"Removing some elements ...\");\n\t        // remove some\n\t        for (int i = 1; i <= 100; i++) {\n\t            xupdate =\n\t                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n\t                \"   <xu:remove select=\\\"/products/product[last()]\\\"/>\" +\n\t                \"<\/xu:modifications>\";\n\t            service.updateResource(\"test_xmldb.xml\", xupdate);\n\t        }\n\t        \n\t        System.out.println(\"Appending some elements ...\");\n\t        for (int i = 1; i <= 100; i++) {\n\t            xupdate =\n\t                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n\t                \"   <xu:append select=\\\"/products\\\">\" +\n\t                \"       <product>\" +\n\t                \"           <xu:attribute name=\\\"id\\\"><xu:value-of select=\\\"count(/products/product) + 1\\\"/><\/xu:attribute>\" +\n\t                \"           <description>Product \" + i + \"<\/description>\" +\n\t                \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n\t                \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n\t                \"       <\/product>\" +\n\t                \"   <\/xu:append>\" +\n\t                \"<\/xu:modifications>\";\n\t            service.updateResource(\"test_xmldb.xml\", xupdate);\n\t        }\n\t        \n\t        System.out.println(\"Renaming elements  ...\");\n\t        // rename element \"description\" to \"descript\"\n\t        xupdate =\n\t            \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n\t            \"   <xu:rename select=\\\"/products/product/description\\\">descript<\/xu:rename>\" +\n\t            \"<\/xu:modifications>\";\n\t        service.updateResource(\"test_xmldb.xml\", xupdate);\n\t        \n\t        System.out.println(\"Updating attribute values ...\");\n\t        // update attribute values\n\t        for (int i = 1; i <= 200; i++) {\n\t            xupdate =\n\t                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n\t                \"   <xu:update select=\\\"/products/product[\" + i + \"]/@id\\\">\" + i + \"u<\/xu:update>\" +\n\t                \"<\/xu:modifications>\";\n\t            service.updateResource(\"test_xmldb.xml\", xupdate);\n\t        }\n\t        System.out.println(\"Append new element to each item ...\");\n\t        // append new element to records\n\t        for (int i = 1; i <= 200; i++) {\n\t            xupdate =\n\t                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n\t                \"   <xu:append select=\\\"/products/product[\" + i + \"]\\\">\" +\n\t                \"       <date><xu:value-of select=\\\"current-dateTime()\\\"/><\/date>\" +\n\t                \"   <\/xu:append>\" +\n\t                \"<\/xu:modifications>\";\n\t            service.updateResource(\"test_xmldb.xml\", xupdate);\n\t        }\n\t        \n\t        System.out.println(\"Updating element content ...\");\n\t        // update element content\n\t        for (int i = 1; i <= 200; i++) {\n\t            xupdate =\n\t                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n\t                \"   <xu:update select=\\\"/products/product[\" + i + \"]/price\\\">19.99<\/xu:update>\" +\n\t                \"<\/xu:modifications>\";\n\t            service.updateResource(\"test_xmldb.xml\", xupdate);\n\t        }\n        } catch (Exception e) {            \n            fail(e.getMessage());   \n        }\t        \n    }","commit_id":"f45bf0463c9c0eaa25f1da0b2fe547cd1a208a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStore() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            \n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            broker.saveCollection(transaction, root);\n            \n            Collection test = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test/test2\");\n            broker.saveCollection(transaction, test);\n            \n            IndexInfo info;\n            info = test.validate(transaction, broker, \"test.xml\", TEST_XML);\n            test.store(transaction, broker, info, TEST_XML, false);\n            \n            transact.commit(transaction);\n            \n            transaction = transact.beginTransaction();\n            \n            DocumentSet docs = new DocumentSet();\n            docs.add(info.getDocument());\n            XUpdateProcessor proc = new XUpdateProcessor(broker, docs);\n            \n            String xupdate;\n            Modification modifications[];\n            \n            System.out.println(\"Inserting new items  ...\");\n            // insert some nodes\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:insert-before select=\\\"/products/product[1]\\\">\" +\n                    \"       <product>\" +\n                    \"           <description>Product \" + i + \"<\/description>\" +\n                    \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n                    \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n                    \"       <\/product>\" +\n                    \"   <\/xu:insert-before>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            System.out.println(\"Adding attributes  ...\");\n            // add attribute\n            for (int i = 1; i <= 200; i++) {\n              xupdate =\n                  \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                  \"   <xu:append select=\\\"/products/product[\" + i + \"]\\\">\" +\n                  \"         <xu:attribute name=\\\"id\\\">\" + i + \"<\/xu:attribute>\" +\n                  \" <\/xu:append>\" +\n                  \"<\/xu:modifications>\";\n              proc.setBroker(broker);\n              proc.setDocumentSet(docs);\n              modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n              modifications[0].process(transaction);\n              proc.reset();\n          }\n            \n            System.out.println(\"Replacing elements  ...\");\n            // replace some\n            for (int i = 1; i <= 100; i++) {\n              xupdate =\n                  \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                  \"   <xu:replace select=\\\"/products/product[\" + i + \"]\\\">\" +\n                  \"     <product id=\\\"\" + i + \"\\\">\" +\n                  \"         <description>Replaced product<\/description>\" +\n                  \"         <price>\" + (i * 0.75) + \"<\/price>\" +\n                  \"     <\/product>\" +\n                  \" <\/xu:replace>\" +\n                  \"<\/xu:modifications>\";\n              proc.setBroker(broker);\n              proc.setDocumentSet(docs);\n              modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n              long mods = modifications[0].process(transaction);\n              System.out.println(\"Modifications: \" + mods);\n              proc.reset();\n          }\n                \n            System.out.println(\"Removing some elements ...\");\n            // remove some\n            for (int i = 1; i <= 100; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:remove select=\\\"/products/product[last()]\\\"/>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            System.out.println(\"Appending some elements ...\");\n            for (int i = 1; i <= 100; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:append select=\\\"/products\\\">\" +\n                    \"       <product>\" +\n                    \"           <xu:attribute name=\\\"id\\\"><xu:value-of select=\\\"count(/products/product) + 1\\\"/><\/xu:attribute>\" +\n                    \"           <description>Product \" + i + \"<\/description>\" +\n                    \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n                    \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n                    \"       <\/product>\" +\n                    \"   <\/xu:append>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            System.out.println(\"Renaming elements  ...\");\n            // rename element \"description\" to \"descript\"\n            xupdate =\n                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                \"   <xu:rename select=\\\"/products/product/description\\\">descript<\/xu:rename>\" +\n                \"<\/xu:modifications>\";\n            proc.setBroker(broker);\n            proc.setDocumentSet(docs);\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n            modifications[0].process(transaction);\n            proc.reset();\n            \n            System.out.println(\"Updating attribute values ...\");\n            // update attribute values\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:update select=\\\"/products/product[\" + i + \"]/@id\\\">\" + i + \"u<\/xu:update>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                long mods = modifications[0].process(transaction);\n                System.out.println(mods + \" records modified.\");\n                proc.reset();\n            }\n            System.out.println(\"Append new element to each item ...\");\n            // append new element to records\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:append select=\\\"/products/product[\" + i + \"]\\\">\" +\n                    \"       <date><xu:value-of select=\\\"current-dateTime()\\\"/><\/date>\" +\n                    \"   <\/xu:append>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            System.out.println(\"Updating element content ...\");\n            // update element content\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:update select=\\\"/products/product[\" + i + \"]/price\\\">19.99<\/xu:update>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                long mods = modifications[0].process(transaction);\n                System.out.println(mods + \" records modified.\");\n                proc.reset();\n            }\n            System.out.println(\"FINISHED!!!!\");\n//            pool.getTransactionManager().getLogManager().flushToLog(true);\n            transact.commit(transaction);\n            System.out.println(\"Transaction \" + transaction.getId() + \" completed\");\n        } catch (Exception e) {\n            System.out.println(\"EXCEPTION CAUGHT!!!!!!!!\");\n            e.printStackTrace();\n            throw e;\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93622,"modified_method":"public void testStore() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = null;        \n        DBBroker broker = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n            \n            Collection test2 = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test/test2\");\n            assertNotNull(test2);\n            broker.saveCollection(transaction, test2);\n            \n            IndexInfo info = test2.validate(transaction, broker, \"test.xml\", TEST_XML);\n            assertNotNull(info);\n            test2.store(transaction, broker, info, TEST_XML, false);\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            DocumentSet docs = new DocumentSet();\n            docs.add(info.getDocument());\n            XUpdateProcessor proc = new XUpdateProcessor(broker, docs);\n            assertNotNull(proc);\n            \n            String xupdate;\n            Modification modifications[];\n            \n            System.out.println(\"Inserting new items  ...\");\n            // insert some nodes\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:insert-before select=\\\"/products/product[1]\\\">\" +\n                    \"       <product>\" +\n                    \"           <description>Product \" + i + \"<\/description>\" +\n                    \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n                    \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n                    \"       <\/product>\" +\n                    \"   <\/xu:insert-before>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                assertNotNull(modifications);\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            System.out.println(\"Adding attributes  ...\");\n            // add attribute\n            for (int i = 1; i <= 200; i++) {\n              xupdate =\n                  \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                  \"   <xu:append select=\\\"/products/product[\" + i + \"]\\\">\" +\n                  \"         <xu:attribute name=\\\"id\\\">\" + i + \"<\/xu:attribute>\" +\n                  \" <\/xu:append>\" +\n                  \"<\/xu:modifications>\";\n              proc.setBroker(broker);\n              proc.setDocumentSet(docs);\n              modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n              assertNotNull(modifications);\n              modifications[0].process(transaction);\n              proc.reset();\n          }\n            \n            System.out.println(\"Replacing elements  ...\");\n            // replace some\n            for (int i = 1; i <= 100; i++) {\n              xupdate =\n                  \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                  \"   <xu:replace select=\\\"/products/product[\" + i + \"]\\\">\" +\n                  \"     <product id=\\\"\" + i + \"\\\">\" +\n                  \"         <description>Replaced product<\/description>\" +\n                  \"         <price>\" + (i * 0.75) + \"<\/price>\" +\n                  \"     <\/product>\" +\n                  \" <\/xu:replace>\" +\n                  \"<\/xu:modifications>\";\n              proc.setBroker(broker);\n              proc.setDocumentSet(docs);\n              modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n              assertNotNull(modifications);\n              long mods = modifications[0].process(transaction);\n              System.out.println(\"Modifications: \" + mods);\n              proc.reset();\n          }\n                \n            System.out.println(\"Removing some elements ...\");\n            // remove some\n            for (int i = 1; i <= 100; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:remove select=\\\"/products/product[last()]\\\"/>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                assertNotNull(modifications);\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            System.out.println(\"Appending some elements ...\");\n            for (int i = 1; i <= 100; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:append select=\\\"/products\\\">\" +\n                    \"       <product>\" +\n                    \"           <xu:attribute name=\\\"id\\\"><xu:value-of select=\\\"count(/products/product) + 1\\\"/><\/xu:attribute>\" +\n                    \"           <description>Product \" + i + \"<\/description>\" +\n                    \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n                    \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n                    \"       <\/product>\" +\n                    \"   <\/xu:append>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                assertNotNull(modifications);\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            System.out.println(\"Renaming elements  ...\");\n            // rename element \"description\" to \"descript\"\n            xupdate =\n                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                \"   <xu:rename select=\\\"/products/product/description\\\">descript<\/xu:rename>\" +\n                \"<\/xu:modifications>\";\n            proc.setBroker(broker);\n            proc.setDocumentSet(docs);\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n            assertNotNull(modifications);\n            modifications[0].process(transaction);\n            proc.reset();\n            \n            System.out.println(\"Updating attribute values ...\");\n            // update attribute values\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:update select=\\\"/products/product[\" + i + \"]/@id\\\">\" + i + \"u<\/xu:update>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                assertNotNull(modifications);\n                long mods = modifications[0].process(transaction);\n                System.out.println(mods + \" records modified.\");\n                proc.reset();\n            }\n            System.out.println(\"Append new element to each item ...\");\n            // append new element to records\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:append select=\\\"/products/product[\" + i + \"]\\\">\" +\n                    \"       <date><xu:value-of select=\\\"current-dateTime()\\\"/><\/date>\" +\n                    \"   <\/xu:append>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                assertNotNull(modifications);\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            System.out.println(\"Updating element content ...\");\n            // update element content\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:update select=\\\"/products/product[\" + i + \"]/price\\\">19.99<\/xu:update>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                assertNotNull(modifications);\n                long mods = modifications[0].process(transaction);\n                System.out.println(mods + \" records modified.\");\n                proc.reset();\n            }           \n\n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");            \n           \n        } catch (Exception e) {\n        \tfail(e.getMessage());  \n        } finally {\n        \tif (pool!= null) pool.release(broker);\n        }\n    }","commit_id":"f45bf0463c9c0eaa25f1da0b2fe547cd1a208a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"protected BrokerPool startDB() throws Exception {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            \n            // initialize driver\n            Database database = (Database) Class.forName(\"org.exist.xmldb.DatabaseImpl\").newInstance();\n            database.setProperty(\"create-database\", \"true\");\n            DatabaseManager.registerDatabase(database);\n            \n            return BrokerPool.getInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n        return null;\n    }","id":93623,"modified_method":"protected BrokerPool startDB() {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            \n            // initialize driver\n            Database database = (Database) Class.forName(\"org.exist.xmldb.DatabaseImpl\").newInstance();\n            database.setProperty(\"create-database\", \"true\");\n            DatabaseManager.registerDatabase(database);\n            \n            return BrokerPool.getInstance();\n        } catch (Exception e) {            \n            fail(e.getMessage());\n        }\n        return null;\n    }","commit_id":"f45bf0463c9c0eaa25f1da0b2fe547cd1a208a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testXMLDBRead() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        \n        org.xmldb.api.base.Collection test = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION + \"/test/test2\", \"admin\", \"\");\n        Resource res = test.getResource(\"test_xmldb.xml\");\n        assertNotNull(\"Document should not be null\", res);\n        System.out.println(res.getContent());\n        \n        org.xmldb.api.base.Collection root = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION, \"admin\", \"\");\n        CollectionManagementServiceImpl mgr = (CollectionManagementServiceImpl) \n            root.getService(\"CollectionManagementService\", \"1.0\");\n        mgr.removeCollection(\"test\");\n    }","id":93624,"modified_method":"public void testXMLDBRead() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        try {\n\t        \n        \torg.xmldb.api.base.Collection test2 = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION + \"/test/test2\", \"admin\", \"\");\n        \tassertNotNull(test2);\n        \tResource res = test2.getResource(\"test_xmldb.xml\");\n\t        assertNotNull(\"Document should not be null\", res);\n\t        System.out.println(res.getContent());\n\t        \n\t        org.xmldb.api.base.Collection root = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION, \"admin\", \"\");\n\t        assertNotNull(root);\n\t        CollectionManagementServiceImpl mgr = (CollectionManagementServiceImpl) \n\t            root.getService(\"CollectionManagementService\", \"1.0\");\n\t        assertNotNull(mgr);\n\t        mgr.removeCollection(\"test\");\n\t        \n        } catch (Exception e) {            \n            fail(e.getMessage());   \n        }\n    }","commit_id":"f45bf0463c9c0eaa25f1da0b2fe547cd1a208a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = startDB();\n        \n        System.out.println(\"testRead() ...\\n\");\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc;\n            String data;\n            \n            doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/test2/test.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/test.xml' should not be null\", doc);\n            data = serializer.serialize(doc);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93625,"modified_method":"public void testRead() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        DBBroker broker = null;\n        try {\n\t        System.out.println(\"testRead() ...\\n\");\n\t        pool = startDB();\n\t        assertNotNull(pool);\n       \t    broker = pool.get(SecurityManager.SYSTEM_USER);\n       \t    assertNotNull(broker);\n            Serializer serializer = broker.getSerializer();\n            assertNotNull(serializer);\n            serializer.reset();\n            \n            DocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/test2/test.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/test.xml' should not be null\", doc);\n            String data = serializer.serialize(doc);\n            assertNotNull(data);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n        } catch (Exception e) {            \n        \tfail(e.getMessage());                    \n        } finally {\n        \tif (pool!= null) pool.release(broker);\n        }\n    }","commit_id":"f45bf0463c9c0eaa25f1da0b2fe547cd1a208a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"protected BrokerPool startDB() throws Exception {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            return BrokerPool.getInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n        return null;\n    }","id":93626,"modified_method":"protected BrokerPool startDB() {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            return BrokerPool.getInstance();\n        } catch (Exception e) {            \n            fail(e.getMessage());\n        }\n        return null;\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void setupCollections() throws Exception {\n        DBBroker broker = null;\n        TransactionManager transact = pool.getTransactionManager();\n        Txn transaction = transact.beginTransaction();\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, TEST_COLLECTION);\n            broker.saveCollection(transaction, root);\n            \n            test = broker.getOrCreateCollection(transaction, TEST_COLLECTION + \"/test1\");\n            broker.saveCollection(transaction, test);\n            \n            test2 = broker.getOrCreateCollection(transaction, TEST_COLLECTION + \"/test2\");\n            broker.saveCollection(transaction, test2);\n            \n            transact.commit(transaction);\n        } catch (Exception e) {\n            transact.abort(transaction);\n            e.printStackTrace();\n            fail(e.getMessage());\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93627,"modified_method":"protected void setupCollections() {\n        DBBroker broker = null;\n        TransactionManager transact = pool.getTransactionManager();\n        Txn transaction = transact.beginTransaction();\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, TEST_COLLECTION);\n            broker.saveCollection(transaction, root);\n            \n            test = broker.getOrCreateCollection(transaction, TEST_COLLECTION + \"/test1\");\n            broker.saveCollection(transaction, test);\n            \n            test2 = broker.getOrCreateCollection(transaction, TEST_COLLECTION + \"/test2\");\n            broker.saveCollection(transaction, test2);\n            \n            transact.commit(transaction);\n        } catch (Exception e) {\n            transact.abort(transaction);            \n            fail(e.getMessage());\n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public synchronized void testStore() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = true;\n        pool = startDB();\n        setupCollections();\n        \n        Thread t1 = new StoreThread1();\n        t1.start();\n        \n        wait(8000);\n        \n        Thread t2 = new StoreThread2();\n        t2.start();\n        \n        t1.join();\n        t2.join();\n    }","id":93628,"modified_method":"public synchronized void testStore() {\n    \ttry {\n\t        BrokerPool.FORCE_CORRUPTION = true;\n\t        pool = startDB();\n\t        setupCollections();\n\t        \n\t        Thread t1 = new StoreThread1();\n\t        t1.start();\n\t        \n\t        wait(8000);\n\t        \n\t        Thread t2 = new StoreThread2();\n\t        t2.start();\n\t        \n\t        t1.join();\n\t        t2.join();\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());  \n\t    }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void run() {\n            DBBroker broker = null;\n            try {\n                broker = pool.get(SecurityManager.SYSTEM_USER);\n                \n                TransactionManager transact = pool.getTransactionManager();\n                Txn transaction = transact.beginTransaction();\n                \n                System.out.println(\"Transaction started ...\");\n                XMLFilenameFilter filter = new XMLFilenameFilter();\n                File files[] = dir.listFiles(filter);\n                \n                File f;\n                IndexInfo info;\n                // store some documents into /db/test\n                for (int i = 0; i < files.length; i++) {\n                    f = files[i];\n                    try {\n                        info = test.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                        test.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                    } catch (SAXException e) {\n                        System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                    }\n//                    if (i % 5 == 0) {\n//                        transact.commit(transaction);\n//                        transaction = transact.beginTransaction();\n//                    }\n                }\n                \n                transact.commit(transaction);\n                \n                transact.getJournal().flushToLog(true);\n            } catch (Exception e) {\n                e.printStackTrace();\n                fail(e.getMessage());\n            } finally {\n                pool.release(broker);\n            }\n        }","id":93629,"modified_method":"public void run() {\n            DBBroker broker = null;\n            try {\n                broker = pool.get(SecurityManager.SYSTEM_USER);\n                \n                TransactionManager transact = pool.getTransactionManager();\n                Txn transaction = transact.beginTransaction();\n                \n                System.out.println(\"Transaction started ...\");\n                XMLFilenameFilter filter = new XMLFilenameFilter();\n                File files[] = dir.listFiles(filter);\n                \n                File f;\n                IndexInfo info;\n                // store some documents into /db/test\n                for (int i = 0; i < files.length; i++) {\n                    f = files[i];\n                    try {\n                        info = test.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                        test.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                    } catch (SAXException e) {\n                        System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                    }\n//                    if (i % 5 == 0) {\n//                        transact.commit(transaction);\n//                        transaction = transact.beginTransaction();\n//                    }\n                }\n                \n                transact.commit(transaction);\n                \n//              Don't commit...\n                transact.getJournal().flushToLog(true);\n                System.out.println(\"Transaction interrupted ...\");\n            } catch (Exception e) {\n                e.printStackTrace();\n                fail(e.getMessage());\n            } finally {\n                pool.release(broker);\n            }\n        }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        pool = startDB();\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            test = broker.getCollection(TEST_COLLECTION+ \"/test1\");\n            assertNotNull(test);\n            test2 = broker.getCollection(TEST_COLLECTION + \"/test2\");\n            assertNotNull(test2);\n            System.out.println(\"Contents of collection \" + test.getName() + \":\");\n            for (Iterator i = test.iterator(broker); i.hasNext(); ) {\n                DocumentImpl next = (DocumentImpl) i.next();\n                System.out.println(\"- \" + next.getName());\n            }\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93630,"modified_method":"public void testRead() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        pool = startDB();\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            test = broker.getCollection(TEST_COLLECTION+ \"/test1\");\n            assertNotNull(test);\n            test2 = broker.getCollection(TEST_COLLECTION + \"/test2\");\n            assertNotNull(test2);\n            System.out.println(\"Contents of collection \" + test.getName() + \":\");\n            for (Iterator i = test.iterator(broker); i.hasNext(); ) {\n                DocumentImpl next = (DocumentImpl) i.next();\n                System.out.println(\"- \" + next.getName());\n            }\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());              \n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStore() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n\n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n\n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n\n            System.out.println(\"Transaction started ...\");\n\n            Collection root = broker.getOrCreateCollection(transaction,\n            \t\tTEST_COLLECTION);\n            broker.saveCollection(transaction, root);\n\n            Collection test = broker.getOrCreateCollection(transaction,\n            \t\tTEST_COLLECTION + \"/test2\");\n            broker.saveCollection(transaction, test);\n    \n            File f = new File(\"samples/biblio.rdf\");\n            IndexInfo info = test.validate(transaction, broker, \"test.xml\",\n                    new InputSource(f.toURI().toASCIIString()));\n            test.store(transaction, broker, info, new InputSource(f.toURI()\n                    .toASCIIString()), false);\n            \n            Collection dest = broker.getOrCreateCollection(transaction,\n                DBBroker.ROOT_COLLECTION + \"/destination\");\n            broker.saveCollection(transaction, dest);\n            \n            broker.copyCollection(transaction, test, dest, \"test3\");\n\n            transact.commit(transaction);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93631,"modified_method":"public void testStore() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n        DBBroker broker = null;\n        \n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n\n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n            System.out.println(\"Transaction started ...\");\n\n            Collection root = broker.getOrCreateCollection(transaction, TEST_COLLECTION);\n            broker.saveCollection(transaction, root);\n\n            Collection test = broker.getOrCreateCollection(transaction, TEST_COLLECTION + \"/test2\");\n            broker.saveCollection(transaction, test);\n    \n            File f = new File(\"samples/biblio.rdf\");\n            IndexInfo info = test.validate(transaction, broker, \"test.xml\",\n                    new InputSource(f.toURI().toASCIIString()));\n            test.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n            \n            Collection dest = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/destination\");\n            broker.saveCollection(transaction, dest);\n            \n            broker.copyCollection(transaction, test, dest, \"test3\");\n\n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());              \n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testReadAborted() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = startDB();\n        \n        System.out.println(\"testRead() ...\\n\");\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/destination/test3/test.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document should be null\", doc);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93632,"modified_method":"public void testReadAborted() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        DBBroker broker = null;\n       \n        try {\n        \tSystem.out.println(\"testReadAborted() ...\\n\");\n        \tpool = startDB();\n        \tassertNotNull(pool);\n        \tbroker = pool.get(SecurityManager.SYSTEM_USER);\n        \tassertNotNull(broker);\n        \t\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();            \n            DocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/destination/test3/test.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document should be null\", doc);\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());              \n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = startDB();\n        \n        System.out.println(\"testRead() ...\\n\");\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc;\n            String data;\n            \n            doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/destination/test3/test.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document should not be null\", doc);\n            data = serializer.serialize(doc);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93633,"modified_method":"public void testRead() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        DBBroker broker = null;\n        \n        try {\n        \tSystem.out.println(\"testRead() ...\\n\");  \n        \tpool = startDB();\n        \tassertNotNull(pool);\n        \tbroker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            \n            Serializer serializer = broker.getSerializer();\n            serializer.reset(); \n            \n            DocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/destination/test3/test.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document should not be null\", doc);\n            String data = serializer.serialize(doc);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);                \n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());              \n        } finally {\n            if (pool != null) pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"protected BrokerPool startDB() throws Exception {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            \n            // initialize driver\n            Database database = (Database) Class.forName(\"org.exist.xmldb.DatabaseImpl\").newInstance();\n            database.setProperty(\"create-database\", \"true\");\n            DatabaseManager.registerDatabase(database);\n\n            return BrokerPool.getInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n        return null;\n    }","id":93634,"modified_method":"protected BrokerPool startDB() {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            \n            // initialize driver\n            Database database = (Database) Class.forName(\"org.exist.xmldb.DatabaseImpl\").newInstance();\n            database.setProperty(\"create-database\", \"true\");\n            DatabaseManager.registerDatabase(database);\n\n            return BrokerPool.getInstance();\n        } catch (Exception e) {            \n            fail(e.getMessage());\n        }\n        return null;\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testXMLDBRead() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = startDB();\n        \n        org.xmldb.api.base.Collection test = DatabaseManager.getCollection(\"xmldb:exist://\"+ DBBroker.ROOT_COLLECTION + \"/destination/test3\", \"admin\", \"\");\n        Resource res = test.getResource(\"test_xmldb.xml\");\n        assertNotNull(\"Document should not be null\", res);\n        System.out.println(res.getContent());\n        \n        org.xmldb.api.base.Collection root = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION, \"admin\", \"\");\n        CollectionManagementServiceImpl mgr = (CollectionManagementServiceImpl) \n            root.getService(\"CollectionManagementService\", \"1.0\");\n        mgr.removeCollection(\"destination\");\n    }","id":93635,"modified_method":"public void testXMLDBRead() {    \t\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        \n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n\t        org.xmldb.api.base.Collection test = DatabaseManager.getCollection(\"xmldb:exist://\"+ DBBroker.ROOT_COLLECTION + \"/destination/test3\", \"admin\", \"\");\n\t        assertNotNull(test);\n\t        Resource res = test.getResource(\"test_xmldb.xml\");\n\t        assertNotNull(\"Document should not be null\", res);\n\t        System.out.println(res.getContent());\n\t        \n\t        org.xmldb.api.base.Collection root = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION, \"admin\", \"\");\n\t        assertNotNull(root);\n\t        CollectionManagementServiceImpl mgr = (CollectionManagementServiceImpl) \n\t            root.getService(\"CollectionManagementService\", \"1.0\");\n\t        assertNotNull(mgr);\n\t        mgr.removeCollection(\"destination\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \n\t    }        \n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStoreAborted() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n\n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n\n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n\n            System.out.println(\"Transaction started ...\");\n\n            Collection root = broker.getOrCreateCollection(transaction,\n            \t\tTEST_COLLECTION);\n            broker.saveCollection(transaction, root);\n\n            Collection test = broker.getOrCreateCollection(transaction,\n            \t\tTEST_COLLECTION + \"/test2\");\n            broker.saveCollection(transaction, test);\n    \n            File f = new File(\"samples/biblio.rdf\");\n            IndexInfo info = test.validate(transaction, broker, \"test.xml\",\n                    new InputSource(f.toURI().toASCIIString()));\n            test.store(transaction, broker, info, new InputSource(f.toURI()\n                    .toASCIIString()), false);\n            \n            transact.commit(transaction);\n            \n            transaction = transact.beginTransaction();\n            \n            Collection dest = broker.getOrCreateCollection(transaction,\n                DBBroker.ROOT_COLLECTION + \"/destination\");\n            broker.saveCollection(transaction, dest);\n            \n            broker.copyCollection(transaction, test, dest, \"test3\");\n\n            pool.getTransactionManager().getJournal().flushToLog(true);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93636,"modified_method":"public void testStoreAborted() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = null;\n\n        DBBroker broker = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n\n            Collection root = broker.getOrCreateCollection(transaction, TEST_COLLECTION);\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n\n            Collection test2 = broker.getOrCreateCollection(transaction, TEST_COLLECTION + \"/test2\");\n            assertNotNull(test2);\n            broker.saveCollection(transaction, test2);\n    \n            File f = new File(\"samples/biblio.rdf\");\n            assertNotNull(f);\n            IndexInfo info = test2.validate(transaction, broker, \"test.xml\", new InputSource(f.toURI().toASCIIString()));\n            test2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n            transaction = transact.beginTransaction();\n            System.out.println(\"Transaction started ...\");\n            \n            Collection dest = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/destination\");\n            assertNotNull(dest);\n            broker.saveCollection(transaction, dest);            \n            broker.copyCollection(transaction, test2, dest, \"test3\");\n\n//          Don't commit...\n            transact.getJournal().flushToLog(true);\n            System.out.println(\"Transaction interrupted ...\");            \n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());              \n        } finally {\n            if (pool != null) pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testXMLDBStore() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = startDB();\n        \n        org.xmldb.api.base.Collection root = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION, \"admin\", \"\");\n        CollectionManagementServiceImpl mgr = (CollectionManagementServiceImpl) \n            root.getService(\"CollectionManagementService\", \"1.0\");\n        org.xmldb.api.base.Collection test = root.getChildCollection(\"test\");\n        if (test == null)\n            test = mgr.createCollection(TEST_COLLECTION);\n        org.xmldb.api.base.Collection test2 = test.getChildCollection(\"test2\");\n        if (test2 == null)\n            test2 = mgr.createCollection(TEST_COLLECTION + \"/test2\");\n        \n        File f = new File(\"samples/biblio.rdf\");\n        Resource res = test2.createResource(\"test_xmldb.xml\", \"XMLResource\");\n        res.setContent(f);\n        test2.storeResource(res);\n        \n        org.xmldb.api.base.Collection dest = root.getChildCollection(\"destination\");\n        if (dest == null)\n            dest = mgr.createCollection(\"destination\");\n        \n        mgr.copy(TEST_COLLECTION + \"/test2\", DBBroker.ROOT_COLLECTION + \"/destination\", \"test3\");\n    }","id":93637,"modified_method":"public void testXMLDBStore() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n\t        org.xmldb.api.base.Collection root = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION, \"admin\", \"\");\n\t        assertNotNull(root);\n\t        CollectionManagementServiceImpl mgr = (CollectionManagementServiceImpl) \n\t            root.getService(\"CollectionManagementService\", \"1.0\");\n\t        assertNotNull(mgr);\n\t        org.xmldb.api.base.Collection test = root.getChildCollection(\"test\");\n\t        if (test == null)\n\t            test = mgr.createCollection(TEST_COLLECTION);\n\t        assertNotNull(test);\n\t        org.xmldb.api.base.Collection test2 = test.getChildCollection(\"test2\");\n\t        if (test2 == null)\n\t            test2 = mgr.createCollection(TEST_COLLECTION + \"/test2\");\n\t        assertNotNull(test2);\n\t        \n\t        File f = new File(\"samples/biblio.rdf\");\n\t        assertNotNull(f);\n\t        Resource res = test2.createResource(\"test_xmldb.xml\", \"XMLResource\");\n\t        assertNotNull(res);\n\t        res.setContent(f);\n\t        test2.storeResource(res);\n\t        \n\t        org.xmldb.api.base.Collection dest = root.getChildCollection(\"destination\");\t        \n\t        if (dest == null)\n\t            dest = mgr.createCollection(\"destination\");\n\t        assertNotNull(dest);\n\t        \n\t        mgr.copy(TEST_COLLECTION + \"/test2\", DBBroker.ROOT_COLLECTION + \"/destination\", \"test3\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \n\t    }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"protected BrokerPool startDB() throws Exception {\n\t\tString home, file = \"conf.xml\";\n\t\thome = System.getProperty(\"exist.home\");\n\t\tif (home == null)\n\t\t\thome = System.getProperty(\"user.dir\");\n\t\ttry {\n\t\t\tConfiguration config = new Configuration(file, home);\n\t\t\tBrokerPool.configure(1, 5, config);\n\t\t\treturn BrokerPool.getInstance();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail(e.getMessage());\n\t\t}\n\t\treturn null;\n\t}","id":93638,"modified_method":"protected BrokerPool startDB() {\n\t\tString home, file = \"conf.xml\";\n\t\thome = System.getProperty(\"exist.home\");\n\t\tif (home == null)\n\t\t\thome = System.getProperty(\"user.dir\");\n\t\ttry {\n\t\t\tConfiguration config = new Configuration(file, home);\n\t\t\tBrokerPool.configure(1, 5, config);\n\t\t\treturn BrokerPool.getInstance();\n\t\t} catch (Exception e) {\t\t\t\n\t\t\tfail(e.getMessage());\n\t\t}\n\t\treturn null;\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead() throws Exception {\n\t\tBrokerPool.FORCE_CORRUPTION = false;\n\t\tBrokerPool pool = startDB();\n\n\t\tSystem.out.println(\"testRead() ...\\n\");\n\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\tbroker = pool.get(SecurityManager.SYSTEM_USER);\n\t\t\tSerializer serializer = broker.getSerializer();\n\t\t\tserializer.reset();\n\n\t\t\tDocumentImpl doc;\n\t\t\tString data;\n\n\t\t\tdoc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/new_test.xml\", Lock.READ_LOCK);\n\t\t\tassertNotNull(\"Document should not be null\", doc);\n\t\t\tdata = serializer.serialize(doc);\n\t\t\tSystem.out.println(data);\n\t\t\tdoc.getUpdateLock().release(Lock.READ_LOCK);\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t}","id":93639,"modified_method":"public void testRead() {\n\t\tBrokerPool.FORCE_CORRUPTION = false;\n\t\tBrokerPool pool = null;\n\t\tDBBroker broker = null;\n\t\t\n\t\ttry {\n\t\t\tSystem.out.println(\"testRead() ...\\n\");\n\t\t\tpool = startDB();\n\t\t\tassertNotNull(pool);\n\t\t\tbroker = pool.get(SecurityManager.SYSTEM_USER);\n\t\t\tassertNotNull(broker);\n\t\t\tSerializer serializer = broker.getSerializer();\n\t\t\tserializer.reset();\n\n\t\t\tDocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/new_test.xml\", Lock.READ_LOCK);\n\t\t\tassertNotNull(\"Document should not be null\", doc);\n\t\t\tString data = serializer.serialize(doc);\n\t\t\tassertNotNull(data);\n\t\t\tSystem.out.println(data);\n\t\t\tdoc.getUpdateLock().release(Lock.READ_LOCK);\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \t\t\t\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStoreAborted() throws Exception {\n\t\tBrokerPool.FORCE_CORRUPTION = true;\n\t\tBrokerPool pool = startDB();\n\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\tbroker = pool.get(SecurityManager.SYSTEM_USER);\n\n\t\t\tTransactionManager transact = pool.getTransactionManager();\n\t\t\tTxn transaction = transact.beginTransaction();\n\n\t\t\tSystem.out.println(\"Transaction started ...\");\n\n\t\t\tCollection root = broker.getOrCreateCollection(transaction,\n\t\t\t\t\tDBBroker.ROOT_COLLECTION + \"/test\");\n\t\t\tbroker.saveCollection(transaction, root);\n\n\t\t\tCollection test = broker.getOrCreateCollection(transaction,\n\t\t\t\t\tDBBroker.ROOT_COLLECTION + \"/test/test2\");\n\t\t\tbroker.saveCollection(transaction, test);\n\n\t\t\tFile f = new File(\"samples/shakespeare/r_and_j.xml\");\n\t\t\tIndexInfo info = test.validate(transaction, broker, \"test2.xml\",\n\t\t\t\t\tnew InputSource(f.toURI().toASCIIString()));\n\t\t\ttest.store(transaction, broker, info, new InputSource(f.toURI()\n\t\t\t\t\t.toASCIIString()), false);\n\n\t\t\ttransact.commit(transaction);\n\n\t\t\ttransaction = transact.beginTransaction();\n\n\t\t\tbroker.copyResource(transaction, info.getDocument(), root,\n\t\t\t\t\t\"new_test2.xml\");\n\t\t\tbroker.saveCollection(transaction, root);\n\n\t\t\tpool.getTransactionManager().getJournal().flushToLog(true);\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t}","id":93640,"modified_method":"public void testStoreAborted() {\n\t\tBrokerPool.FORCE_CORRUPTION = true;\n\t\tBrokerPool pool = null;\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\tpool = startDB();\n\t\t\tassertNotNull(pool);\n\t\t\tbroker = pool.get(SecurityManager.SYSTEM_USER);\n\t\t\tassertNotNull(broker);\n\t\t\tTransactionManager transact = pool.getTransactionManager();\n\t\t\tassertNotNull(transact);\n\t\t\tTxn transaction = transact.beginTransaction();\n\t\t\tassertNotNull(transaction);\n\t\t\tSystem.out.println(\"Transaction started ...\");\n\n\t\t\tCollection root = broker.getOrCreateCollection(transaction,\tDBBroker.ROOT_COLLECTION + \"/test\");\n\t\t\tassertNotNull(root);\n\t\t\tbroker.saveCollection(transaction, root);\n\n\t\t\tCollection test2 = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test/test2\");\n\t\t\tassertNotNull(test2);\n\t\t\tbroker.saveCollection(transaction, test2);\n\n\t\t\tFile f = new File(\"samples/shakespeare/r_and_j.xml\");\n\t\t\tassertNotNull(f);\n\t\t\tIndexInfo info = test2.validate(transaction, broker, \"test2.xml\", new InputSource(f.toURI().toASCIIString()));\n\t\t\tassertNotNull(info);\n\t\t\ttest2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n\n\t\t\ttransact.commit(transaction);\n\t\t\tSystem.out.println(\"Transaction commited ...\");\n\n\t\t\ttransaction = transact.beginTransaction();\n\t\t\tSystem.out.println(\"Transaction started ...\");\n\n\t\t\tbroker.copyResource(transaction, info.getDocument(), root, \"new_test2.xml\");\n\t\t\tbroker.saveCollection(transaction, root);\n\t\t\t\n//\t\t\tDon't commit...\n\t\t\tpool.getTransactionManager().getJournal().flushToLog(true);\n\t\t\tSystem.out.println(\"Transaction interrupted ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());\t\t\t\n\t\t} finally {\n\t\t\tif (pool != null) pool.release(broker);\n\t\t}\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStore() throws Exception {\n\t\tBrokerPool.FORCE_CORRUPTION = true;\n\t\tBrokerPool pool = startDB();\n\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\tbroker = pool.get(SecurityManager.SYSTEM_USER);\n\n\t\t\tTransactionManager transact = pool.getTransactionManager();\n\t\t\tTxn transaction = transact.beginTransaction();\n\n\t\t\tSystem.out.println(\"Transaction started ...\");\n\n\t\t\tCollection root = broker.getOrCreateCollection(transaction,\n\t\t\t\t\tDBBroker.ROOT_COLLECTION + \"/test\");\n\t\t\tbroker.saveCollection(transaction, root);\n\n\t\t\tCollection test = broker.getOrCreateCollection(transaction,\n\t\t\t\t\tDBBroker.ROOT_COLLECTION +  \"/test/test2\");\n\t\t\tbroker.saveCollection(transaction, test);\n\n\t\t\tFile f = new File(\"samples/shakespeare/r_and_j.xml\");\n\t\t\tIndexInfo info = test.validate(transaction, broker, \"test.xml\",\n\t\t\t\t\tnew InputSource(f.toURI().toASCIIString()));\n\t\t\ttest.store(transaction, broker, info, new InputSource(f.toURI()\n\t\t\t\t\t.toASCIIString()), false);\n\n\t\t\tbroker.copyResource(transaction, info.getDocument(), root,\n\t\t\t\t\t\"new_test.xml\");\n\t\t\tbroker.saveCollection(transaction, root);\n\n\t\t\ttransact.commit(transaction);\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t}","id":93641,"modified_method":"public void testStore() {\n\t\tBrokerPool.FORCE_CORRUPTION = true;\n\t\tBrokerPool pool = null;\n\t\tDBBroker broker = null;\n\t\t\n\t\ttry {\n\t\t\tpool = startDB();\n\t\t\tassertNotNull(pool);\n\t\t\tbroker = pool.get(SecurityManager.SYSTEM_USER);\n\t\t\tassertNotNull(broker);\t\t\t\n\t\t\tTransactionManager transact = pool.getTransactionManager();\n\t\t\tassertNotNull(transact);\n\t\t\tTxn transaction = transact.beginTransaction();\n\t\t\tassertNotNull(transaction);\n\t\t\tSystem.out.println(\"Transaction started ...\");\n\n\t\t\tCollection root = broker.getOrCreateCollection(transaction,\tDBBroker.ROOT_COLLECTION + \"/test\");\n\t\t\tassertNotNull(root);\n\t\t\tbroker.saveCollection(transaction, root);\n\n\t\t\tCollection test2 = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION +  \"/test/test2\");\n\t\t\tassertNotNull(test2);\n\t\t\tbroker.saveCollection(transaction, test2);\n\n\t\t\tFile f = new File(\"samples/shakespeare/r_and_j.xml\");\n\t\t\tassertNotNull(f);\n\t\t\tIndexInfo info = test2.validate(transaction, broker, \"test.xml\", new InputSource(f.toURI().toASCIIString()));\n\t\t\tassertNotNull(info);\n\t\t\ttest2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n\n\t\t\tbroker.copyResource(transaction, info.getDocument(), root, \"new_test.xml\");\n\t\t\tbroker.saveCollection(transaction, root);\n\n\t\t\ttransact.commit(transaction);\n\t\t\tSystem.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \t      \t\t\t\n\t\t} finally {\n\t\t\tif (pool != null) pool.release(broker);\n\t\t}\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testReadAborted() throws Exception {\n\t\tBrokerPool.FORCE_CORRUPTION = false;\n\t\tBrokerPool pool = startDB();\n\n\t\tSystem.out.println(\"testRead() ...\\n\");\n\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\tbroker = pool.get(SecurityManager.SYSTEM_USER);\n\t\t\tSerializer serializer = broker.getSerializer();\n\t\t\tserializer.reset();\n\n\t\t\tDocumentImpl doc;\n\t\t\tString data;\n\n\t\t\tdoc = broker.openDocument(DBBroker.ROOT_COLLECTION +  \"/test/test2/test2.xml\",\n\t\t\t\t\tLock.READ_LOCK);\n\t\t\tassertNotNull(\"Document should not be null\", doc);\n\t\t\tdata = serializer.serialize(doc);\n\t\t\tSystem.out.println(data);\n\t\t\tdoc.getUpdateLock().release(Lock.READ_LOCK);\n\n\t\t\tdoc = broker.openDocument(DBBroker.ROOT_COLLECTION +  \"/test/new_test2.xml\", Lock.READ_LOCK);\n\t\t\tassertNull(\"Document should not exist\", doc);\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t}","id":93642,"modified_method":"public void testReadAborted() {\n\t\tBrokerPool.FORCE_CORRUPTION = false;\n\t\tBrokerPool pool = null;\n\t\tDBBroker broker = null;\t\t\n\t\ttry {\n\t\t\tSystem.out.println(\"testReadAborted() ...\\n\");\n\t\t\tpool = startDB();\n\t\t\tassertNotNull(pool);\n\t\t\tbroker = pool.get(SecurityManager.SYSTEM_USER);\n\t\t\tassertNotNull(broker);\n\t\t\tSerializer serializer = broker.getSerializer();\n\t\t\tserializer.reset();\n\n\t\t\tDocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION +  \"/test/test2/test2.xml\",\tLock.READ_LOCK);\n\t\t\tassertNotNull(\"Document should not be null\", doc);\n\t\t\tString data = serializer.serialize(doc);\n\t\t\tassertNotNull(data);\n\t\t\tSystem.out.println(data);\n\t\t\tdoc.getUpdateLock().release(Lock.READ_LOCK);\n\n\t\t\tdoc = broker.openDocument(DBBroker.ROOT_COLLECTION +  \"/test/new_test2.xml\", Lock.READ_LOCK);\n\t\t\tassertNull(\"Document should not exist\", doc);\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());  \t\t\t\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testAdd() throws Exception {\n        System.out.println(\"Add some random data and force db corruption ...\\n\");\n        \n\t\tTransactionManager mgr = pool.getTransactionManager();\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\tbroker = pool.get(SecurityManager.SYSTEM_USER);\n            broker.flush();\n\t\t\tTxn txn = mgr.beginTransaction();\n\t\t\tSystem.out.println(\"Transaction started ...\");\n            \n            DOMFile domDb = ((NativeBroker) broker).getDOMFile();\n            domDb.setOwnerObject(this);\n            \n            BrokerPool.FORCE_CORRUPTION = true;\n            \n            // put 1000 values into the btree\n            long firstToRemove = -1;\n            for (int i = 1; i <= 10000; i++) {\n                byte[] data = (\"Value\" + i).getBytes();\n                long addr = domDb.put(txn, new NativeBroker.NodeRef(500, i), data);\n                if (i == 1)\n                    firstToRemove = addr;\n            }\n\n            domDb.closeDocument();\n            \n            // remove all\n            NativeBroker.NodeRef ref = new NativeBroker.NodeRef(500);\n            IndexQuery idx = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n            domDb.remove(txn, idx, null);\n            domDb.removeAll(txn, firstToRemove);\n            \n            // put some more\n            for (int i = 1; i <= 10000; i++) {\n                byte[] data = (\"Value\" + i).getBytes();\n                long addr = domDb.put(txn, new NativeBroker.NodeRef(500, i), data);\n            }\n            \n            domDb.closeDocument();\n            mgr.commit(txn);\n            \n            txn = mgr.beginTransaction();\n            \n            // put 1000 new values into the btree\n            for (int i = 1; i <= 1000; i++) {\n                byte[] data = (\"Value\" + i).getBytes();\n                long addr = domDb.put(txn, new NativeBroker.NodeRef(501, i), data);\n                if (i == 1)\n                    firstToRemove = addr;\n            }\n            domDb.closeDocument();\n            mgr.commit(txn);\n            \n            // the following transaction is not committed and will be rolled back during recovery\n            txn = mgr.beginTransaction();\n            \n            for (int i = 1; i <= 200; i++) {\n                domDb.remove(txn, new NativeBroker.NodeRef(500, i));\n            }\n\n            idx = new IndexQuery(IndexQuery.TRUNC_RIGHT, new NativeBroker.NodeRef(501));\n            domDb.remove(txn, idx, null);\n            domDb.removeAll(txn, firstToRemove);\n            \n            mgr.getJournal().flushToLog(true);\n            \n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t}","id":93643,"modified_method":"public void testAdd() {\t\t\n\t\tBrokerPool.FORCE_CORRUPTION = true;\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\tSystem.out.println(\"Add some random data and force db corruption ...\\n\");\n\t\t\tbroker = pool.get(SecurityManager.SYSTEM_USER);\n\t\t\tassertNotNull(broker);\n\t\t\t//TODO : is this necessary ?\n            broker.flush();\n\t\t\tTransactionManager mgr = pool.getTransactionManager();\n\t\t\tassertNotNull(mgr);\n\t\t\tTxn txn = mgr.beginTransaction();\n\t\t\tassertNotNull(txn);\n\t\t\tSystem.out.println(\"Transaction started ...\");\n            \n            DOMFile domDb = ((NativeBroker) broker).getDOMFile();\n            assertNotNull(domDb);\n            domDb.setOwnerObject(this);\n            \n            // put 1000 values into the btree\n            long firstToRemove = -1;\n            for (int i = 1; i <= 10000; i++) {\n                byte[] data = (\"Value\" + i).getBytes();\n                long addr = domDb.put(txn, new NativeBroker.NodeRef(500, i), data);\n//              TODO : test addr ?\n                if (i == 1)\n                    firstToRemove = addr;\n            }\n\n            domDb.closeDocument();\n            \n            // remove all\n            NativeBroker.NodeRef ref = new NativeBroker.NodeRef(500);\n            assertNotNull(ref);\n            IndexQuery idx = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n            assertNotNull(idx);\n            domDb.remove(txn, idx, null);\n            domDb.removeAll(txn, firstToRemove);\n            \n            // put some more\n            for (int i = 1; i <= 10000; i++) {\n                byte[] data = (\"Value\" + i).getBytes();\n                long addr = domDb.put(txn, new NativeBroker.NodeRef(500, i), data);\n//              TODO : test addr ?\n            }\n            \n            domDb.closeDocument();\n            mgr.commit(txn);\n            System.out.println(\"Transaction commited ...\");\n            \n            txn = mgr.beginTransaction();\n            System.out.println(\"Transaction started ...\");\n            \n            // put 1000 new values into the btree\n            for (int i = 1; i <= 1000; i++) {\n                byte[] data = (\"Value\" + i).getBytes();\n                long addr = domDb.put(txn, new NativeBroker.NodeRef(501, i), data);\n//              TODO : test addr ?                \n                if (i == 1)\n                    firstToRemove = addr;\n            }            \n            \n            domDb.closeDocument();\n            mgr.commit(txn);\n            System.out.println(\"Transaction commited ...\");\n            \n            // the following transaction is not committed and will be rolled back during recovery\n            txn = mgr.beginTransaction();\n            System.out.println(\"Transaction started ...\");\n            \n            for (int i = 1; i <= 200; i++) {\n                domDb.remove(txn, new NativeBroker.NodeRef(500, i));\n            }\n\n            idx = new IndexQuery(IndexQuery.TRUNC_RIGHT, new NativeBroker.NodeRef(501));\n            domDb.remove(txn, idx, null);\n            domDb.removeAll(txn, firstToRemove);\n            \n//          Don't commit...\n            mgr.getJournal().flushToLog(true);\n            System.out.println(\"Transaction interrupted ...\");\n            \n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());               \n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testGet() throws Exception {\n        System.out.println(\"Recover and read the data ...\\n\");\n        TransactionManager mgr = pool.getTransactionManager();\n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            \n            DOMFile domDb = ((NativeBroker) broker).getDOMFile();\n            domDb.setOwnerObject(this);\n            \n            IndexQuery query = new IndexQuery(IndexQuery.GT, new NativeBroker.NodeRef(500));\n            List keys = domDb.findKeys(query);\n            int count = 0;\n            for (Iterator i = keys.iterator(); i.hasNext(); count++) {\n                Value key = (Value) i.next();\n                Value value = domDb.get(key);\n                System.out.println(new String(value.data(), value.start(), value.getLength()));\n            }\n            System.out.println(\"Values read: \" + count);\n            \n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93644,"modified_method":"public void testGet() {\n        \n        DBBroker broker = null;\n        try {\n        \tSystem.out.println(\"Recover and read the data ...\\n\");        \t\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            TransactionManager mgr = pool.getTransactionManager();\n            assertNotNull(mgr);\n            \n            DOMFile domDb = ((NativeBroker) broker).getDOMFile();\n            assertNotNull(domDb);\n            domDb.setOwnerObject(this);\n            \n            IndexQuery query = new IndexQuery(IndexQuery.GT, new NativeBroker.NodeRef(500));\n            assertNotNull(query);\n            List keys = domDb.findKeys(query);\n            assertNotNull(keys);\n            int count = 0;\n            for (Iterator i = keys.iterator(); i.hasNext(); count++) {\n                Value key = (Value) i.next();\n                assertNotNull(key);\n                Value value = domDb.get(key);\n                assertNotNull(value);\n                System.out.println(new String(value.data(), value.start(), value.getLength()));\n            }\n            System.out.println(\"Values read: \" + count);\n            \n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());             \n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStoreAborted() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n\n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n\n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n\n            System.out.println(\"Transaction started ...\");\n\n            Collection root = broker.getOrCreateCollection(transaction,\n            \t\tDBBroker.ROOT_COLLECTION +  \"/test\");\n            broker.saveCollection(transaction, root);\n\n            Collection test = broker.getOrCreateCollection(transaction,\n            \t\tDBBroker.ROOT_COLLECTION +  \"/test/test2\");\n            broker.saveCollection(transaction, test);\n    \n            File f = new File(\"samples/biblio.rdf\");\n            IndexInfo info = test.validate(transaction, broker, \"test.xml\",\n                    new InputSource(f.toURI().toASCIIString()));\n            test.store(transaction, broker, info, new InputSource(f.toURI()\n                    .toASCIIString()), false);\n            \n            transact.commit(transaction);\n            \n            transaction = transact.beginTransaction();\n            \n            Collection dest = broker.getOrCreateCollection(transaction,\n            \t\tDBBroker.ROOT_COLLECTION +  \"/destination2\");\n            broker.saveCollection(transaction, dest);\n            \n            broker.moveCollection(transaction, test, dest, \"test3\");\n\n            pool.getTransactionManager().getJournal().flushToLog(true);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93645,"modified_method":"public void testStoreAborted() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = null;\n        DBBroker broker = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n\n            Collection root = broker.getOrCreateCollection(transaction,\tDBBroker.ROOT_COLLECTION +  \"/test\");\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n\n            Collection test2 = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION +  \"/test/test2\");\n            assertNotNull(test2);\n            broker.saveCollection(transaction, test2);\n    \n            File f = new File(\"samples/biblio.rdf\");\n            assertNotNull(f);\n            IndexInfo info = test2.validate(transaction, broker, \"test.xml\", new InputSource(f.toURI().toASCIIString()));\n            assertNotNull(info);            \n            test2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            Collection dest = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION +  \"/destination2\");\n            assertNotNull(dest);\n            broker.saveCollection(transaction, dest);            \n            broker.moveCollection(transaction, test2, dest, \"test3\");\n\n//          Don't commit...\n            pool.getTransactionManager().getJournal().flushToLog(true);\n            System.out.println(\"Transaction interrupted ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());  \n        } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"protected BrokerPool startDB() throws Exception {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            \n            // initialize driver\n            Database database = (Database) Class.forName(\"org.exist.xmldb.DatabaseImpl\").newInstance();\n            database.setProperty(\"create-database\", \"true\");\n            DatabaseManager.registerDatabase(database);\n\n            return BrokerPool.getInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n        return null;\n    }","id":93646,"modified_method":"protected BrokerPool startDB() {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            \n            // initialize driver\n            Database database = (Database) Class.forName(\"org.exist.xmldb.DatabaseImpl\").newInstance();\n            database.setProperty(\"create-database\", \"true\");\n            DatabaseManager.registerDatabase(database);\n\n            return BrokerPool.getInstance();\n        } catch (Exception e) {            \n            fail(e.getMessage());\n        }\n        return null;\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = startDB();\n        \n        System.out.println(\"testRead() ...\\n\");\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc;\n            String data;\n            \n            doc = broker.openDocument(DBBroker.ROOT_COLLECTION +  \"/destination1/test3/test.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document should not be null\", doc);\n            data = serializer.serialize(doc);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93647,"modified_method":"public void testRead() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        DBBroker broker = null;\n        try {\n        \tSystem.out.println(\"testRead() ...\\n\");\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION +  \"/destination1/test3/test.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document should not be null\", doc);\n            String data = serializer.serialize(doc);\n            assertNotNull(data);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());              \n        } finally {\n            if (pool != null) pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testXMLDBStore() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = startDB();\n        \n        org.xmldb.api.base.Collection root = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION, \"admin\", \"\");\n        CollectionManagementServiceImpl mgr = (CollectionManagementServiceImpl) \n            root.getService(\"CollectionManagementService\", \"1.0\");\n        org.xmldb.api.base.Collection test = root.getChildCollection(\"test\");\n        if (test == null)\n            test = mgr.createCollection(\"test\");\n        \n        org.xmldb.api.base.Collection test2 = test.getChildCollection(\"test2\");\n        if (test2 == null) {\n            mgr = (CollectionManagementServiceImpl) \n                test.getService(\"CollectionManagementService\", \"1.0\");\n            test2 = mgr.createCollection(\"test2\");\n        }\n        \n        File f = new File(\"samples/biblio.rdf\");\n        Resource res = test2.createResource(\"test_xmldb.xml\", \"XMLResource\");\n        res.setContent(f);\n        test2.storeResource(res);\n        \n        org.xmldb.api.base.Collection dest = root.getChildCollection(\"destination3\");\n        if (dest == null) {\n            mgr = (CollectionManagementServiceImpl) \n                root.getService(\"CollectionManagementService\", \"1.0\");\n            dest = mgr.createCollection(\"destination3\");\n        }\n        \n        mgr.move(DBBroker.ROOT_COLLECTION +  \"/test/test2\", DBBroker.ROOT_COLLECTION + \"/destination3\", \"test3\");\n    }","id":93648,"modified_method":"public void testXMLDBStore() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        try {\n\t        pool = startDB();\n\t        assertNotNull(pool);\n\t        org.xmldb.api.base.Collection root = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION, \"admin\", \"\");\n\t        assertNotNull(root);\t        \n\t        CollectionManagementServiceImpl mgr = (CollectionManagementServiceImpl) \n\t            root.getService(\"CollectionManagementService\", \"1.0\");\n\t        assertNotNull(mgr);\n\t        \n\t        org.xmldb.api.base.Collection test = root.getChildCollection(\"test\");\t        \n\t        if (test == null)\n\t            test = mgr.createCollection(\"test\");\n\t        assertNotNull(test);\n\t        \n\t        org.xmldb.api.base.Collection test2 = test.getChildCollection(\"test2\");\n\t        if (test2 == null)\n\t            test2 = mgr.createCollection(\"test2\");\n\t        assertNotNull(test2);\n\t        \n\t        File f = new File(\"samples/biblio.rdf\");\n\t        assertNotNull(f);\n\t        Resource res = test2.createResource(\"test_xmldb.xml\", \"XMLResource\");\n\t        assertNotNull(res);\n\t        res.setContent(f);\n\t        test2.storeResource(res);\n\t        \n\t        org.xmldb.api.base.Collection dest = root.getChildCollection(\"destination3\");\n\t        if (dest == null)          \n\t            dest = mgr.createCollection(\"destination3\");\n\t        assertNotNull(dest);\n\t        \n\t        mgr.move(DBBroker.ROOT_COLLECTION +  \"/test/test2\", DBBroker.ROOT_COLLECTION + \"/destination3\", \"test3\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());  \t  \n\t    }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testXMLDBRead() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = startDB();\n        \n        org.xmldb.api.base.Collection test = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION + \"/destination3/test3\", \"admin\", \"\");\n        Resource res = test.getResource(\"test_xmldb.xml\");\n        assertNotNull(\"Document should not be null\", res);\n        System.out.println(res.getContent());\n    }","id":93649,"modified_method":"public void testXMLDBRead() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n        \torg.xmldb.api.base.Collection test = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION + \"/destination3/test3\", \"admin\", \"\");\n        \tassertNotNull(test);\n        \tResource res = test.getResource(\"test_xmldb.xml\");\n        \tassertNotNull(res);\n        \tassertNotNull(\"Document should not be null\", res);        \t\n        \tSystem.out.println(res.getContent());\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());  \t  \n\t    }        \t\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testReadAborted() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = startDB();\n        \n        System.out.println(\"testRead() ...\\n\");\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION +  \"/destination2/test3/test.xml\", Lock.READ_LOCK);\n            assertNull(\"Document should be null\", doc);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93650,"modified_method":"public void testReadAborted() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        DBBroker broker = null;\n        try {\n        \tSystem.out.println(\"testRead() ...\\n\");\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();            \n            DocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION +  \"/destination2/test3/test.xml\", Lock.READ_LOCK);\n            assertNull(\"Document should be null\", doc);\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());              \n        } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStore() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n\n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n\n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n\n            System.out.println(\"Transaction started ...\");\n\n            Collection root = broker.getOrCreateCollection(transaction,\n            \t\tDBBroker.ROOT_COLLECTION +  \"/test\");\n            broker.saveCollection(transaction, root);\n\n            Collection test = broker.getOrCreateCollection(transaction,\n            \t\tDBBroker.ROOT_COLLECTION +  \"/test/test2\");\n            broker.saveCollection(transaction, test);\n    \n            File f = new File(\"samples/biblio.rdf\");\n            IndexInfo info = test.validate(transaction, broker, \"test.xml\",\n                    new InputSource(f.toURI().toASCIIString()));\n            test.store(transaction, broker, info, new InputSource(f.toURI()\n                    .toASCIIString()), false);\n            \n            Collection dest = broker.getOrCreateCollection(transaction,\n            \t\tDBBroker.ROOT_COLLECTION +  \"/destination1\");\n            broker.saveCollection(transaction, dest);\n            \n            broker.moveCollection(transaction, test, dest, \"test3\");\n\n            transact.commit(transaction);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93651,"modified_method":"public void testStore() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = null;\n        DBBroker broker = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n\n            Collection root = broker.getOrCreateCollection(transaction,\tDBBroker.ROOT_COLLECTION +  \"/test\");\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n\n            Collection test = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION +  \"/test/test2\");\n            assertNotNull(test);\n            broker.saveCollection(transaction, test);\n    \n            File f = new File(\"samples/biblio.rdf\");\n            assertNotNull(f);\n            IndexInfo info = test.validate(transaction, broker, \"test.xml\", new InputSource(f.toURI().toASCIIString()));\n            assertNotNull(info);\n            test.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n            \n            Collection dest = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION +  \"/destination1\");\n            assertNotNull(dest);\n            broker.saveCollection(transaction, dest);            \n            broker.moveCollection(transaction, test, dest, \"test3\");\n\n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());              \n        } finally {\n            if (pool != null) pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead() throws Exception {\n\t    BrokerPool.FORCE_CORRUPTION = false;\n\t    BrokerPool pool = startDB();\n\t    \n\t    System.out.println(\"testRead() ...\\n\");\n\t    \n\t    DBBroker broker = null;\n\t    try {\n\t        broker = pool.get(SecurityManager.SYSTEM_USER);\n\t        Serializer serializer = broker.getSerializer();\n\t        serializer.reset();\n\t        \n\t        DocumentImpl doc;\n\t        String data;\n\t        \n\t        doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/new_test.xml\", Lock.READ_LOCK);\n\t        assertNotNull(\"Document should not be null\", doc);\n\t        data = serializer.serialize(doc);\n//\t        System.out.println(data);\n\t        doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n            \n            Collection root = broker.openCollection(DBBroker.ROOT_COLLECTION + \"/test\", Lock.WRITE_LOCK);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);\n            \n            broker.removeCollection(transaction, root);\n            \n            transact.commit(transaction);\n\t    } finally {\n\t        pool.release(broker);\n\t    }\n\t}","id":93652,"modified_method":"public void testRead() {\n\t    BrokerPool.FORCE_CORRUPTION = false;\n\t    BrokerPool pool = null;\n\t    DBBroker broker = null;\n\t    try {\n\t    \tSystem.out.println(\"testRead() ...\\n\");\n\t    \tpool = startDB();\n\t    \tassertNotNull(pool);\n\t        broker = pool.get(SecurityManager.SYSTEM_USER);\n\t        assertNotNull(broker);\n\t        Serializer serializer = broker.getSerializer();\n\t        serializer.reset();\n\t        \n\t        DocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/new_test.xml\", Lock.READ_LOCK);\n\t        assertNotNull(\"Document should not be null\", doc);\n\t        String data = serializer.serialize(doc);\n\t        assertNotNull(data);\n//\t        System.out.println(data);\n\t        doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.openCollection(DBBroker.ROOT_COLLECTION + \"/test\", Lock.WRITE_LOCK);\n            assertNotNull(root);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);            \n            broker.removeCollection(transaction, root); \n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());  \t\n\t    } finally {\n\t        pool.release(broker);\n\t    }\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"protected BrokerPool startDB() throws Exception {\n\t\tString home, file = \"conf.xml\";\n\t\thome = System.getProperty(\"exist.home\");\n\t\tif (home == null)\n\t\t\thome = System.getProperty(\"user.dir\");\n\t\ttry {\n\t\t\tConfiguration config = new Configuration(file, home);\n\t\t\tBrokerPool.configure(1, 5, config);\n\t\t\t\n\t\t\t// initialize driver\n\t\t\tDatabase database = (Database) Class.forName(\"org.exist.xmldb.DatabaseImpl\").newInstance();\n\t\t\tdatabase.setProperty(\"create-database\", \"true\");\n\t\t\tDatabaseManager.registerDatabase(database);\n\n\t\t\treturn BrokerPool.getInstance();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail(e.getMessage());\n\t\t}\n\t\treturn null;\n\t}","id":93653,"modified_method":"protected BrokerPool startDB() {\n\t\tString home, file = \"conf.xml\";\n\t\thome = System.getProperty(\"exist.home\");\n\t\tif (home == null)\n\t\t\thome = System.getProperty(\"user.dir\");\n\t\ttry {\n\t\t\tConfiguration config = new Configuration(file, home);\n\t\t\tBrokerPool.configure(1, 5, config);\n\t\t\t\n\t\t\t// initialize driver\n\t\t\tDatabase database = (Database) Class.forName(\"org.exist.xmldb.DatabaseImpl\").newInstance();\n\t\t\tdatabase.setProperty(\"create-database\", \"true\");\n\t\t\tDatabaseManager.registerDatabase(database);\n\n\t\t\treturn BrokerPool.getInstance();\n\t\t} catch (Exception e) {\t\t\t\n\t\t\tfail(e.getMessage());\n\t\t}\n\t\treturn null;\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStore() throws Exception {\n\t\tBrokerPool.FORCE_CORRUPTION = true;\n\t\tBrokerPool pool = startDB();\n\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\tbroker = pool.get(SecurityManager.SYSTEM_USER);\n\n\t\t\tTransactionManager transact = pool.getTransactionManager();\n\t\t\tTxn transaction = transact.beginTransaction();\n\n\t\t\tSystem.out.println(\"Transaction started ...\");\n\n\t\t\tCollection root = broker.getOrCreateCollection(transaction,\n\t\t\t\t\tDBBroker.ROOT_COLLECTION + \"/test\");\n\t\t\tbroker.saveCollection(transaction, root);\n\n\t\t\tCollection test = broker.getOrCreateCollection(transaction,\n\t\t\t\t\tDBBroker.ROOT_COLLECTION + \"/test/test2\");\n\t\t\tbroker.saveCollection(transaction, test);\n\n\t\t\tFile f = new File(\"samples/shakespeare/r_and_j.xml\");\n\t\t\tIndexInfo info = test.validate(transaction, broker, \"test.xml\",\n\t\t\t\t\tnew InputSource(f.toURI().toASCIIString()));\n\t\t\ttest.store(transaction, broker, info, new InputSource(f.toURI()\n\t\t\t\t\t.toASCIIString()), false);\n\t\t\t\n            System.out.println(\"Moving document test.xml to new_test.xml ...\");\n\t\t\tbroker.moveResource(transaction, info.getDocument(), root,\n\t\t\t\t\t\"new_test.xml\");\n\t\t\tbroker.saveCollection(transaction, root);\n            \n\t\t\ttransact.commit(transaction);\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t}","id":93654,"modified_method":"public void testStore() {\n\t\tBrokerPool.FORCE_CORRUPTION = true;\n\t\tBrokerPool pool = null;\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\tpool = startDB();\n\t\t\tassertNotNull(pool);\n\t\t\tbroker = pool.get(SecurityManager.SYSTEM_USER);\n\t\t\tassertNotNull(broker);\n\t\t\tTransactionManager transact = pool.getTransactionManager();\n\t\t\tassertNotNull(transact);\n\t\t\tTxn transaction = transact.beginTransaction();\n\t\t\tassertNotNull(transaction);\n\t\t\tSystem.out.println(\"Transaction started ...\");\n\n\t\t\tCollection root = broker.getOrCreateCollection(transaction,\tDBBroker.ROOT_COLLECTION + \"/test\");\n\t\t\tassertNotNull(root);\n\t\t\tbroker.saveCollection(transaction, root);\n\n\t\t\tCollection test2 = broker.getOrCreateCollection(transaction,\tDBBroker.ROOT_COLLECTION + \"/test/test2\");\n\t\t\tassertNotNull(test2);\n\t\t\tbroker.saveCollection(transaction, test2);\n\n\t\t\tFile f = new File(\"samples/shakespeare/r_and_j.xml\");\n\t\t\tassertNotNull(f);\n\t\t\tIndexInfo info = test2.validate(transaction, broker, \"test.xml\", new InputSource(f.toURI().toASCIIString()));\n\t\t\tassertNotNull(info);\n\t\t\ttest2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n\t\t\t\n            System.out.println(\"Moving document test.xml to new_test.xml ...\");\n\t\t\tbroker.moveResource(transaction, info.getDocument(), root, \"new_test.xml\");\n\t\t\tbroker.saveCollection(transaction, root);\n            \n\t\t\ttransact.commit(transaction);\n\t\t\tSystem.out.println(\"Transaction commited ...\");\n\t\t} catch (Exception e) {            \n\t        fail(e.getMessage());  \t\t\t\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testXUpdate() throws IOException {\n\t\tHttpURLConnection connect = preparePost(XUPDATE);\n\t\tconnect.connect();\n\t\tint r = connect.getResponseCode();\n\t\tassertEquals(\"Server returned response code \" + r, 200, r);\n\t\t\n\t\tdoGet();\n\t}","id":93655,"modified_method":"public void testXUpdate() {\n\t\ttry {\n\t\t\tHttpURLConnection connect = preparePost(XUPDATE);\n\t\t\tconnect.connect();\n\t\t\tint r = connect.getResponseCode();\n\t\t\tassertEquals(\"Server returned response code \" + r, 200, r);\n\t\t\t\n\t\t\tdoGet();\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \n\t    }\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"protected HttpURLConnection getConnection(String url) throws IOException {\n\t\tURL u = new URL(url);\n\t\treturn (HttpURLConnection)u.openConnection();\n\t}","id":93656,"modified_method":"protected HttpURLConnection getConnection(String url) {\n\t\ttry {\n\t\t\tURL u = new URL(url);\n\t\t\treturn (HttpURLConnection)u.openConnection();\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \n\t    }\n\t    return null;\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRequestModule() throws IOException {\n\t\tString uri = COLLECTION_URI + \"?_query=request:request-uri()&_wrap=no\";\n\t\tHttpURLConnection connect = getConnection(uri);\n\t\tconnect.setRequestMethod(\"GET\");\n\t\tconnect.connect();\n\t\t\n\t\tint r = connect.getResponseCode();\n\t\tassertEquals(\"Server returned response code \" + r, 200, r);\n\t\n\t\tString response = readResponse(connect.getInputStream()).trim();\n\t\tassertEquals(response,\"/db/test\");\n\t\t\n\t\turi = COLLECTION_URI + \"?_query=request:request-url()&_wrap=no\";\n\t\tconnect = getConnection(uri);\n\t\tconnect.setRequestMethod(\"GET\");\n\t\tconnect.connect();\n\t\t\n\t\tr = connect.getResponseCode();\n\t\tassertEquals(\"Server returned response code \" + r, 200, r);\n\t\t\n\t\tresponse = readResponse(connect.getInputStream()).trim();\n\t\t//TODO : the server name may have been renamed by the Web server\n\t\tassertEquals(response, SERVER_URI + \"/db/test\");\t\t\n\t}","id":93657,"modified_method":"public void testRequestModule() {\n\t\ttry {\n\t\t\tString uri = COLLECTION_URI + \"?_query=request:request-uri()&_wrap=no\";\n\t\t\tHttpURLConnection connect = getConnection(uri);\n\t\t\tconnect.setRequestMethod(\"GET\");\n\t\t\tconnect.connect();\n\t\t\t\n\t\t\tint r = connect.getResponseCode();\n\t\t\tassertEquals(\"Server returned response code \" + r, 200, r);\n\t\t\n\t\t\tString response = readResponse(connect.getInputStream()).trim();\n\t\t\tassertEquals(response,\"/db/test\");\n\t\t\t\n\t\t\turi = COLLECTION_URI + \"?_query=request:request-url()&_wrap=no\";\n\t\t\tconnect = getConnection(uri);\n\t\t\tconnect.setRequestMethod(\"GET\");\n\t\t\tconnect.connect();\n\t\t\t\n\t\t\tr = connect.getResponseCode();\n\t\t\tassertEquals(\"Server returned response code \" + r, 200, r);\n\t\t\t\n\t\t\tresponse = readResponse(connect.getInputStream()).trim();\n\t\t\t//TODO : the server name may have been renamed by the Web server\n\t\t\tassertEquals(response, SERVER_URI + \"/db/test\");\t\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \n\t    }\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"protected HttpURLConnection preparePost(String content) throws IOException {\n\t\tHttpURLConnection connect = getConnection(RESOURCE_URI);\n\t\tconnect.setRequestMethod(\"POST\");\n\t\tconnect.setDoOutput(true);\n\t\tconnect.setRequestProperty(\"ContentType\", \"text/xml\");\n\t\t\n\t\tWriter writer = new OutputStreamWriter(connect.getOutputStream(), \"UTF-8\");\n\t\twriter.write(content);\n\t\twriter.close();\n\t\t\n\t\treturn connect;\n\t}","id":93658,"modified_method":"protected HttpURLConnection preparePost(String content) {\n\t\ttry {\n\t\t\tHttpURLConnection connect = getConnection(RESOURCE_URI);\n\t\t\tconnect.setRequestMethod(\"POST\");\n\t\t\tconnect.setDoOutput(true);\n\t\t\tconnect.setRequestProperty(\"ContentType\", \"text/xml\");\n\t\t\t\n\t\t\tWriter writer = new OutputStreamWriter(connect.getOutputStream(), \"UTF-8\");\n\t\t\twriter.write(content);\n\t\t\twriter.close();\n\t\t\t\n\t\t\treturn connect;\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \n\t    }\n\t    return null;\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testQueryPost() throws IOException {\n\t\tHttpURLConnection connect = preparePost(QUERY_REQUEST);\n\t\tconnect.connect();\n\t\tint r = connect.getResponseCode();\n\t\tassertEquals(\"Server returned response code \" + r, 200, r);\n\t\t\n\t\tSystem.out.println(readResponse(connect.getInputStream()));\n\t}","id":93659,"modified_method":"public void testQueryPost() {\n\t\ttry {\n\t\t\tHttpURLConnection connect = preparePost(QUERY_REQUEST);\n\t\t\tconnect.connect();\n\t\t\tint r = connect.getResponseCode();\n\t\t\tassertEquals(\"Server returned response code \" + r, 200, r);\n\t\t\t\n\t\t\tSystem.out.println(readResponse(connect.getInputStream()));\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \n\t    }\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void doGet() throws IOException {\n\t\tSystem.out.println(\"--- Retrieving document ---\");\n\t\tHttpURLConnection connect = getConnection(RESOURCE_URI);\n\t\tconnect.setRequestMethod(\"GET\");\n\t\tconnect.connect();\n\t\t\n\t\tint r = connect.getResponseCode();\n\t\tassertEquals(\"Server returned response code \" + r, 200, r);\n\t\t\n\t\tSystem.out.println(readResponse(connect.getInputStream()));\n\t}","id":93660,"modified_method":"protected void doGet() {\n\t\ttry {\n\t\t\tSystem.out.println(\"--- Retrieving document ---\");\n\t\t\tHttpURLConnection connect = getConnection(RESOURCE_URI);\n\t\t\tconnect.setRequestMethod(\"GET\");\n\t\t\tconnect.connect();\n\t\t\t\n\t\t\tint r = connect.getResponseCode();\n\t\t\tassertEquals(\"Server returned response code \" + r, 200, r);\n\t\t\t\n\t\t\tSystem.out.println(readResponse(connect.getInputStream()));\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \n\t    }\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"protected String readResponse(InputStream is) throws IOException {\n\t\tBufferedReader reader = \n\t\t\tnew BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n\t\tString line;\n\t\tStringBuffer out = new StringBuffer();\n\t\twhile((line = reader.readLine()) != null) {\n\t\t\tout.append(line);\n\t\t\tout.append(\"\\r\\n\");\n\t\t}\n\t\treturn out.toString();\n\t}","id":93661,"modified_method":"protected String readResponse(InputStream is) {\n\t\ttry {\n\t\t\tBufferedReader reader = \n\t\t\t\tnew BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n\t\t\tString line;\n\t\t\tStringBuffer out = new StringBuffer();\n\t\t\twhile((line = reader.readLine()) != null) {\n\t\t\t\tout.append(line);\n\t\t\t\tout.append(\"\\r\\n\");\n\t\t\t}\n\t\t\treturn out.toString();\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \n\t    }\n\t    return null;\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testPut() throws IOException {\n\t\tSystem.out.println(\"--- Storing document ---\");\n\t\tHttpURLConnection connect = getConnection(RESOURCE_URI);\n\t\tconnect.setRequestMethod(\"PUT\");\n\t\tconnect.setDoOutput(true);\n\t\tconnect.setRequestProperty(\"ContentType\", \"text/xml\");\n\t\t\n\t\tWriter writer = new OutputStreamWriter(connect.getOutputStream(), \"UTF-8\");\n\t\twriter.write(XML_DATA);\n\t\twriter.close();\n\t\t\n\t\tconnect.connect();\n\t\tint r = connect.getResponseCode();\n\t\tassertEquals(\"Server returned response code \" + r, 200, r);\n\t\t\n\t\tdoGet();\n\t}","id":93662,"modified_method":"public void testPut() {\n\t\ttry {\n\t\t\tSystem.out.println(\"--- Storing document ---\");\n\t\t\tHttpURLConnection connect = getConnection(RESOURCE_URI);\n\t\t\tconnect.setRequestMethod(\"PUT\");\n\t\t\tconnect.setDoOutput(true);\n\t\t\tconnect.setRequestProperty(\"ContentType\", \"text/xml\");\n\t\t\t\n\t\t\tWriter writer = new OutputStreamWriter(connect.getOutputStream(), \"UTF-8\");\n\t\t\twriter.write(XML_DATA);\n\t\t\twriter.close();\n\t\t\t\n\t\t\tconnect.connect();\n\t\t\tint r = connect.getResponseCode();\n\t\t\tassertEquals(\"Server returned response code \" + r, 200, r);\n\t\t\t\n\t\t\tdoGet();\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \n\t    }\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testQueryGet() throws IOException {\n\t\tString uri = COLLECTION_URI + \"?_query=\" + URLEncoder.encode(\"doc('/db/test/test.xml')//para[. = '\\u00E4\\u00E4\\u00FC\\u00FC\\u00F6\\u00F6\\u00C4\\u00C4\\u00D6\\u00D6\\u00DC\\u00DC']/text()\", \"UTF-8\");\n\t\tHttpURLConnection connect = getConnection(uri);\n\t\tconnect.setRequestMethod(\"GET\");\n\t\tconnect.connect();\n\t\t\n\t\tint r = connect.getResponseCode();\n\t\tassertEquals(\"Server returned response code \" + r, 200, r);\n\t\t\n\t\tSystem.out.println(readResponse(connect.getInputStream()));\n\t}","id":93663,"modified_method":"public void testQueryGet() {\n\t\ttry {\n\t\t\tString uri = COLLECTION_URI + \"?_query=\" + URLEncoder.encode(\"doc('/db/test/test.xml')//para[. = '\\u00E4\\u00E4\\u00FC\\u00FC\\u00F6\\u00F6\\u00C4\\u00C4\\u00D6\\u00D6\\u00DC\\u00DC']/text()\", \"UTF-8\");\n\t\t\tHttpURLConnection connect = getConnection(uri);\n\t\t\tconnect.setRequestMethod(\"GET\");\n\t\t\tconnect.connect();\n\t\t\t\n\t\t\tint r = connect.getResponseCode();\n\t\t\tassertEquals(\"Server returned response code \" + r, 200, r);\n\t\t\t\n\t\t\tSystem.out.println(readResponse(connect.getInputStream()));\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \n\t    }\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void setUp() throws Exception {\n\t\t//Don't worry about closing the server : the shutdown hook will do the job\n\t\tinitServer();\n\t}","id":93664,"modified_method":"protected void setUp() {\n\t\t//Don't worry about closing the server : the shutdown hook will do the job\n\t\ttry {\n\t\t\tif (server == null) {\n\t\t\t\tserver = new StandaloneServer();\n\t\t\t\tif (!server.isStarted()) {\t\t\t\n\t\t\t\t\ttry {\t\t\t\t\n\t\t\t\t\t\tSystem.out.println(\"Starting standalone server...\");\n\t\t\t\t\t\tString[] args = {};\n\t\t\t\t\t\tserver.run(args);\n\t\t\t\t\t\twhile (!server.isStarted()) {\n\t\t\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (MultiException e) {\n\t\t\t\t\t\tboolean rethrow = true;\n\t\t\t\t\t\tIterator i = e.getExceptions().iterator();\n\t\t\t\t\t\twhile (i.hasNext()) {\n\t\t\t\t\t\t\tException e0 = (Exception)i.next();\n\t\t\t\t\t\t\tif (e0 instanceof BindException) {\n\t\t\t\t\t\t\t\tSystem.out.println(\"A server is running already !\");\n\t\t\t\t\t\t\t\trethrow = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rethrow) throw e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \n\t    }\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void setUp() throws Exception {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            pool = BrokerPool.getInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }","id":93665,"modified_method":"protected void setUp() {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            pool = BrokerPool.getInstance();\n        } catch (Exception e) {            \n            fail(e.getMessage());\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStore() throws Exception {\n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            BrokerPool.FORCE_CORRUPTION = true;\n            \n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n            \n            Collection root = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            broker.saveCollection(transaction, root);\n    \n            FileInputStream is = new FileInputStream(\"LICENSE\");\n            ByteArrayOutputStream os = new ByteArrayOutputStream();\n            byte[] buf = new byte[512];\n            int count = 0;\n            while ((count = is.read(buf)) > -1) {\n                os.write(buf, 0, count);\n            }\n            BinaryDocument doc = \n\t\t\t\troot.addBinaryResource(transaction, broker, \"binary.txt\", os.toByteArray(), \n\t\t\t\t\t\t\"text/text\");\n            \n            transact.commit(transaction);\n            \n            // the following transaction will not be committed. It will thus be rolled back by recovery\n//            transaction = transact.beginTransaction();\n//            root.removeBinaryResource(transaction, broker, doc);\n            \n            transact.getJournal().flushToLog(true);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93666,"modified_method":"public void testStore() {\n    \tBrokerPool.FORCE_CORRUPTION = true;\n        DBBroker broker = null;\n        try {\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n    \n            FileInputStream is = new FileInputStream(\"LICENSE\");\n            assertNotNull(is);\n            ByteArrayOutputStream os = new ByteArrayOutputStream();\n            byte[] buf = new byte[512];\n            int count = 0;\n            while ((count = is.read(buf)) > -1) {\n                os.write(buf, 0, count);\n            }\n            BinaryDocument doc = \n\t\t\t\troot.addBinaryResource(transaction, broker, \"binary.txt\", os.toByteArray(),\t\"text/text\");\n            assertNotNull(doc);\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n            // the following transaction will not be committed. It will thus be rolled back by recovery\n//            transaction = transact.beginTransaction();\n//            root.removeBinaryResource(transaction, broker, doc);\n            \n            //TODO : remove ?\n            transact.getJournal().flushToLog(true);\n\t\t} catch (Exception e) {            \n\t        fail(e.getMessage());             \n        } finally {\n            if (pool != null) pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testLoad() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        System.out.println(\"testRead() ...\\n\");\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            BinaryDocument binDoc = (BinaryDocument) broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/binary.txt\", Lock.READ_LOCK);\n            assertNotNull(\"Binary document is null\", binDoc);\n            String data = new String(broker.getBinaryResourceData(binDoc));\n            System.out.println(data);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93667,"modified_method":"public void testLoad() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        DBBroker broker = null;\n        try {\n        \tSystem.out.println(\"testRead() ...\\n\");\n        \tassertNotNull(pool);\n        \tbroker = pool.get(SecurityManager.SYSTEM_USER);\n        \tassertNotNull(broker);\n            BinaryDocument binDoc = (BinaryDocument) broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/binary.txt\", Lock.READ_LOCK);\n            assertNotNull(\"Binary document is null\", binDoc);\n            String data = new String(broker.getBinaryResourceData(binDoc));\n            assertNotNull(data);\n            System.out.println(data);\n\t\t} catch (Exception e) {            \n\t        fail(e.getMessage());\n\t    } finally {\n            if (pool != null) pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"protected BrokerPool startDB() throws Exception {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            return BrokerPool.getInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n        return null;\n    }","id":93668,"modified_method":"protected BrokerPool startDB() {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            return BrokerPool.getInstance();\n        } catch (Exception e) {            \n            fail(e.getMessage());\n        }\n        return null;\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = startDB();\n        \n        System.out.println(\"testRead() ...\\n\");\n        \n        File files[] = dir.listFiles();\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc;\n            String data;\n            \n            doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/test2/hamlet.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/hamlet.xml' should not be null\", doc);\n            data = serializer.serialize(doc);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/test2/test_string.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/test_string.xml' should not be null\", doc);\n            data = serializer.serialize(doc);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/test2/\" + files[files.length - 1].getName(), Lock.READ_LOCK);\n            assertNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/'\" + files[files.length - 1].getName() + \" should not exist anymore\", doc);\n            \n            XQuery xquery = broker.getXQueryService();\n            Sequence seq = xquery.execute(\"//SPEECH[LINE &= 'king']\", null);\n            System.out.println(\"Found: \" + seq.getLength());\n            for (SequenceIterator i = seq.iterate(); i.hasNext(); ) {\n                Item next = i.nextItem();\n                System.out.println(serializer.serialize((NodeValue) next));\n            }\n            \n            BinaryDocument binDoc = (BinaryDocument) broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/test2/binary.txt\", Lock.READ_LOCK);\n            assertNotNull(\"Binary document is null\", binDoc);\n            data = new String(broker.getBinaryResourceData(binDoc));\n            System.out.println(data);\n            \n            DOMFile domDb = ((NativeBroker)broker).getDOMFile();\n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n            \n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n            \n            Collection root = broker.openCollection(DBBroker.ROOT_COLLECTION + \"/test\", Lock.WRITE_LOCK);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);\n            \n            broker.removeCollection(transaction, root);\n            \n            transact.commit(transaction);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93669,"modified_method":"public void testRead() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        DBBroker broker = null;           \n        \n        try {\n        \tSystem.out.println(\"testRead() ...\\n\");\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/test2/hamlet.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/hamlet.xml' should not be null\", doc);\n            String data = serializer.serialize(doc);\n            assertNotNull(data);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/test2/test_string.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/test_string.xml' should not be null\", doc);\n            data = serializer.serialize(doc);\n            assertNotNull(data);\n            System.out.println(data);            \n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            File files[] = dir.listFiles();\n            assertNotNull(files);\n            \n            doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/test2/\" + files[files.length - 1].getName(), Lock.READ_LOCK);\n            assertNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/'\" + files[files.length - 1].getName() + \" should not exist anymore\", doc);\n            \n            XQuery xquery = broker.getXQueryService();\n            assertNotNull(xquery);\n            Sequence seq = xquery.execute(\"//SPEECH[LINE &= 'king']\", null);\n            assertNotNull(seq);\n            System.out.println(\"Found: \" + seq.getLength());\n            for (SequenceIterator i = seq.iterate(); i.hasNext(); ) {\n                Item next = i.nextItem();\n                System.out.println(serializer.serialize((NodeValue) next));\n            }\n            \n            BinaryDocument binDoc = (BinaryDocument) broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/test2/binary.txt\", Lock.READ_LOCK);\n            assertNotNull(\"Binary document is null\", binDoc);\n            data = new String(broker.getBinaryResourceData(binDoc));\n            assertNotNull(data);\n            System.out.println(data);\n            \n            DOMFile domDb = ((NativeBroker)broker).getDOMFile();\n            assertNotNull(domDb);\n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n            \n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.openCollection(DBBroker.ROOT_COLLECTION + \"/test\", Lock.WRITE_LOCK);\n            assertNotNull(root);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);            \n            broker.removeCollection(transaction, root);\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());             \n        } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStore() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            \n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            broker.saveCollection(transaction, root);\n            \n            Collection test = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test/test2\");\n            broker.saveCollection(transaction, test);\n            \n            \n            File files[] = dir.listFiles();\n            \n            File f;\n            IndexInfo info;\n            \n            BinaryDocument doc = test.addBinaryResource(transaction, broker, \"binary.txt\", \"Some text data\".getBytes(), null);\n            \n            // store some documents. Will be replaced below\n            for (int i = 0; i < files.length; i++) {\n                f = files[i];\n                try {\n                    info = test.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                    test.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n            \n            // replace some documents\n            for (int i = 0; i < files.length; i++) {\n                f = files[i];\n                try {\n                    info = test.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                    test.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n    \n            info = test.validate(transaction, broker, \"test_string.xml\", TEST_XML);\n            test.store(transaction, broker, info, TEST_XML, false);\n            \n            // remove last document\n            test.removeDocument(transaction, broker, files[files.length - 1].getName());\n            \n            \n            transact.commit(transaction);\n            \n            // the following transaction will not be committed. It will thus be rolled back by recovery\n            transaction = transact.beginTransaction();\n            \n            test.removeDocument(transaction, broker, files[0].getName());\n            \n            test.removeBinaryResource(transaction, broker, doc);\n            \n            transact.getJournal().flushToLog(true);\n            \n            DOMFile domDb = ((NativeBroker)broker).getDOMFile();\n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93670,"modified_method":"public void testStore() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = null;        \n        DBBroker broker = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);            \n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n            \n            Collection test2 = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test/test2\");\n            broker.saveCollection(transaction, test2);\n            \n            \n            File files[] = dir.listFiles();\n            assertNotNull(files);\n            \n            File f;\n            IndexInfo info;\n            \n            BinaryDocument doc = test2.addBinaryResource(transaction, broker, \"binary.txt\", \"Some text data\".getBytes(), null);\n            assertNotNull(doc);\n            \n            // store some documents. Will be replaced below\n            for (int i = 0; i < files.length; i++) {\n                f = files[i];\n                try {\n                    info = test2.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                    assertNotNull(info);\n                    test2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n//                \tTODO : why pass invalid couments ?\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n            \n            // replace some documents\n            for (int i = 0; i < files.length; i++) {\n                f = files[i];\n                try {\n                    info = test2.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                    assertNotNull(info);\n                    test2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n//                \tTODO : why pass invalid couments ?\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n    \n            info = test2.validate(transaction, broker, \"test_string.xml\", TEST_XML);\n            assertNotNull(info);\n            \n            test2.store(transaction, broker, info, TEST_XML, false);            \n            // remove last document\n            test2.removeDocument(transaction, broker, files[files.length - 1].getName());            \n            \n            transact.commit(transaction);\n            \n            // the following transaction will not be committed. It will thus be rolled back by recovery\n            transaction = transact.beginTransaction();\n            System.out.println(\"Transaction commited ...\");\n            \n            test2.removeDocument(transaction, broker, files[0].getName());            \n            test2.removeBinaryResource(transaction, broker, doc);\n            \n//          Don't commit...            \n            transact.getJournal().flushToLog(true);\n            System.out.println(\"Transaction interrupted ...\");\n            \n            DOMFile domDb = ((NativeBroker)broker).getDOMFile();\n            assertNotNull(domDb);\n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \n\t        \n        } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n    }","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testFunctionDoc() {\n\t\tResourceSet result;\n\t\tString query;\n\t\tboolean exceptionThrown;\n\t\tString message;\t\t\n\t\ttry {\n\t\t\tXPathQueryService service = \n\t\t\t\tstoreXMLStringAndGetQueryService(NUMBERS_XML, numbers);\n\n\t\t\tSystem.out.println(\"testFunctionDoc 1: ========\" );\t\t\t\t\n\t\t\tquery =\"doc(\\\"/db/test/\" + NUMBERS_XML +  \"\\\")\";\t\n\t\t\tresult = service.query(query);\n\t\t\tassertEquals( \"XQuery: \" + query, 1, result.getSize() );\t\n\t\t\ttry {\t\t\t\t\n\t\t\t\tNode n = ((XMLResource)result.getResource(0)).getContentAsDOM();\t\n\t\t\t\tDetailedDiff d = new DetailedDiff(compareXML(numbers, n.toString()));\n\t\t\t\t//ignore eXist namespace's attributes\n\t\t\t\t//TODO : should be improved !\n\t\t\t\tassertEquals(1, d.getAllDifferences().size());\n\t\t\t} catch (Exception e) {\n\t\t\t\tSystem.out.println(\"testFunctionDoc : XMLDBException: \"+e);\n\t\t\t\tfail(e.getMessage());\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"testFunctionDoc 2: ========\" );\t\t\t\t\n\t\t\tquery =\"doc(\\\"http://www.w3.org/RDF/\\\")\";\t\n\t\t\tresult = service.query(query);\n\t\t\tassertEquals( \"XQuery: \" + query, 1, result.getSize() );\t\n\t\t\t\n\t\t\tSystem.out.println(\"testFunctionDoc 3: ========\" );\t\t\t\t\n\t\t\tquery = \"let $v := ()\\n\" \n\t\t\t\t+ \"return doc($v)\";\t\n\t\t\tresult = service.query(query);\n\t\t\tassertEquals( \"XQuery: \" + query, 0, result.getSize() );\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(\"testFunctionDoc 4: ========\" );\t\t\n\t\t\tquery =\"doc(\\\"/db/test/dummy\" + NUMBERS_XML +  \"\\\")\";\t\n\t\t\ttry {\n\t\t\t\texceptionThrown = false;\n\t\t\t\tresult = service.query(query);\t\t\n\t\t\t} catch (XMLDBException e) {\n\t\t\t\texceptionThrown = true;\n\t\t\t\tmessage = e.getMessage();\n\t\t\t}\n\t\t\t//TODO : to be decided !\n\t\t\t//assertTrue(exceptionThrown);\n\t\t\tassertEquals(0, result.getSize());\n\t\t\t\n\t\t\tSystem.out.println(\"testFunctionDoc 5: ========\" );\t\t\n\t\t\tquery =\"doc(\\\"http://www.w3.org/RDF/dummy\\\")\";\t\n\t\t\ttry {\n\t\t\t\texceptionThrown = false;\n\t\t\t\tresult = service.query(query);\t\t\n\t\t\t} catch (XMLDBException e) {\n\t\t\t\texceptionThrown = true;\n\t\t\t\tmessage = e.getMessage();\n\t\t\t}\n\t\t\tassertTrue(exceptionThrown);\t\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(\"testFunctionDoc 6: ========\" );\t\t\t\t\n\t\t\tquery =\"doc-available(\\\"/db/test/\" + NUMBERS_XML +  \"\\\")\";\t\n\t\t\tresult = service.query(query);\n\t\t\tassertEquals( \"XQuery: \" + query, 1, result.getSize() );\n\t\t\tassertEquals( \"XQuery: \" + query, \"true\", result.getResource(0).getContent());\n\t\t\t\n\t\t\tSystem.out.println(\"testFunctionDoc 7: ========\" );\t\t\t\t\n\t\t\tquery =\"doc-available(\\\"http://www.w3.org/RDF/\\\")\";\t\n\t\t\tresult = service.query(query);\n\t\t\tassertEquals( \"XQuery: \" + query, 1, result.getSize() );\n\t\t\tassertEquals( \"XQuery: \" + query, \"true\", result.getResource(0).getContent());\n\t\t\t\n\t\t\tSystem.out.println(\"testFunctionDoc 8: ========\" );\t\t\t\t\n\t\t\tquery = \"let $v := ()\\n\" \n\t\t\t\t+ \"return doc-available($v)\";\t\n\t\t\tresult = service.query(query); \n\t\t\tassertEquals( \"XQuery: \" + query, 1, result.getSize() );\n\t\t\tassertEquals( \"XQuery: \" + query, \"false\", result.getResource(0).getContent());\n\t\t\t\n\t\t\tSystem.out.println(\"testFunctionDoc 9: ========\" );\t\t\n\t\t\tquery =\"doc-available(\\\"/db/test/dummy\" + NUMBERS_XML +  \"\\\")\";\t\n\t\t\tassertEquals( \"XQuery: \" + query, 1, result.getSize() );\n\t\t\tassertEquals( \"XQuery: \" + query, \"false\", result.getResource(0).getContent());\t\n\t\t\t\n\t\t\tSystem.out.println(\"testFunctionDoc 10: ========\" );\t\t\n\t\t\tquery =\"doc-available(\\\"http://www.w3.org/RDF/dummy\\\")\";\t\n\t\t\tassertEquals( \"XQuery: \" + query, 1, result.getSize() );\n\t\t\tassertEquals( \"XQuery: \" + query, \"false\", result.getResource(0).getContent());\t\t\t\n\n\t\t\tSystem.out.println(\"testFunctionDoc 11: ========\" );\n\t\t\t//A redirected 404\n\t\t\tquery =\"doc-available(\\\"http://java.sun.com/404\\\")\";\t\n\t\t\tassertEquals( \"XQuery: \" + query, 1, result.getSize() );\n\t\t\tassertEquals( \"XQuery: \" + query, \"false\", result.getResource(0).getContent());\t\t\t\n\n\t\t\t\n\t\t} catch (XMLDBException e) {\n\t\t\tSystem.out.println(\"testFunctionDoc : XMLDBException: \"+e);\n\t\t\tfail(e.getMessage());\n\t\t}\n\t}","id":93671,"modified_method":"public void testFunctionDoc() {\n\t\tResourceSet result;\n\t\tString query;\n\t\tboolean exceptionThrown;\n\t\tString message;\t\t\n\t\ttry {\n\t\t\tXPathQueryService service = \n\t\t\t\tstoreXMLStringAndGetQueryService(NUMBERS_XML, numbers);\n\n\t\t\tSystem.out.println(\"testFunctionDoc 1: ========\" );\t\t\t\t\n\t\t\tquery =\"doc(\\\"/db/test/\" + NUMBERS_XML +  \"\\\")\";\t\n\t\t\tresult = service.query(query);\n\t\t\tassertEquals( \"XQuery: \" + query, 1, result.getSize() );\t\n\t\t\ttry {\t\t\t\t\n\t\t\t\tNode n = ((XMLResource)result.getResource(0)).getContentAsDOM();\t\n\t\t\t\tDetailedDiff d = new DetailedDiff(compareXML(numbers, n.toString()));\n\t\t\t\t//ignore eXist namespace's attributes\n\t\t\t\t//TODO : should be improved !\n\t\t\t\tassertEquals(1, d.getAllDifferences().size());\n\t\t\t} catch (Exception e) {\n\t\t\t\tSystem.out.println(\"testFunctionDoc : XMLDBException: \"+e);\n\t\t\t\tfail(e.getMessage());\n\t\t\t}\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(\"testFunctionDoc 2: ========\" );\t\t\t\t\n\t\t\tquery = \"let $v := ()\\n\" \n\t\t\t\t+ \"return doc($v)\";\t\n\t\t\tresult = service.query(query);\n\t\t\tassertEquals( \"XQuery: \" + query, 0, result.getSize() );\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(\"testFunctionDoc 3: ========\" );\t\t\n\t\t\tquery =\"doc(\\\"/db/test/dummy\" + NUMBERS_XML +  \"\\\")\";\t\n\t\t\ttry {\n\t\t\t\texceptionThrown = false;\n\t\t\t\tresult = service.query(query);\t\t\n\t\t\t} catch (XMLDBException e) {\n\t\t\t\texceptionThrown = true;\n\t\t\t\tmessage = e.getMessage();\n\t\t\t}\n\t\t\t//TODO : to be decided !\n\t\t\t//assertTrue(exceptionThrown);\n\t\t\tassertEquals(0, result.getSize());\t\t\t\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(\"testFunctionDoc 4: ========\" );\t\t\t\t\n\t\t\tquery =\"doc-available(\\\"/db/test/\" + NUMBERS_XML +  \"\\\")\";\t\n\t\t\tresult = service.query(query);\n\t\t\tassertEquals( \"XQuery: \" + query, 1, result.getSize() );\n\t\t\tassertEquals( \"XQuery: \" + query, \"true\", result.getResource(0).getContent());\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(\"testFunctionDoc 5: ========\" );\t\t\t\t\n\t\t\tquery = \"let $v := ()\\n\" \n\t\t\t\t+ \"return doc-available($v)\";\t\n\t\t\tresult = service.query(query); \n\t\t\tassertEquals( \"XQuery: \" + query, 1, result.getSize() );\n\t\t\tassertEquals( \"XQuery: \" + query, \"false\", result.getResource(0).getContent());\n\t\t\t\n\t\t\tSystem.out.println(\"testFunctionDoc 6: ========\" );\t\t\n\t\t\tquery =\"doc-available(\\\"/db/test/dummy\" + NUMBERS_XML +  \"\\\")\";\t\n\t\t\tassertEquals( \"XQuery: \" + query, 1, result.getSize() );\n\t\t\tassertEquals( \"XQuery: \" + query, \"false\", result.getResource(0).getContent());\t\t\t\t\n\t\t\t\n\t\t} catch (XMLDBException e) {\n\t\t\tSystem.out.println(\"testFunctionDoc : XMLDBException: \"+e);\n\t\t\tfail(e.getMessage());\n\t\t}\n\t}","commit_id":"45fc3459f5f45095d4b8192b7992e1673e31e930","url":"https://github.com/eXist-db/exist"},{"original_method":"public void run() {\n            DBBroker broker = null;\n            try {\n                broker = pool.get(SecurityManager.SYSTEM_USER);\n                \n                TransactionManager transact = pool.getTransactionManager();\n                Txn transaction = transact.beginTransaction();\n                \n                System.out.println(\"Transaction started ...\");\n                XMLFilenameFilter filter = new XMLFilenameFilter();\n                File files[] = dir.listFiles(filter);\n                \n                File f;\n                IndexInfo info;\n                // store some documents into /db/test\n                for (int i = 0; i < files.length; i++) {\n                    f = files[i];\n                    try {\n                        info = test.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                        test.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                    } catch (SAXException e) {\n                        System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                    }\n//                    if (i % 5 == 0) {\n//                        transact.commit(transaction);\n//                        transaction = transact.beginTransaction();\n//                    }\n                }\n                \n                transact.commit(transaction);\n                \n//              Don't commit...\n                transact.getJournal().flushToLog(true);\n                System.out.println(\"Transaction interrupted ...\");\n            } catch (Exception e) {\n                e.printStackTrace();\n                fail(e.getMessage());\n            } finally {\n                pool.release(broker);\n            }\n        }","id":93672,"modified_method":"public void run() {\n            DBBroker broker = null;\n            try {\n                broker = pool.get(SecurityManager.SYSTEM_USER);\n                \n                TransactionManager transact = pool.getTransactionManager();\n                Txn transaction = transact.beginTransaction();\n                \n                System.out.println(\"Transaction started ...\");\n                XMLFilenameFilter filter = new XMLFilenameFilter();\n                File files[] = dir.listFiles(filter);\n                \n                File f;\n                IndexInfo info;\n                // store some documents into /db/test\n                for (int i = 0; i < files.length; i++) {\n                    f = files[i];\n                    try {\n                        info = test.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                        test.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                    } catch (SAXException e) {\n                        System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                    }\n//                    if (i % 5 == 0) {\n//                        transact.commit(transaction);\n//                        transaction = transact.beginTransaction();\n//                    }\n                }\n                \n                transact.commit(transaction);\n                \n//              Don't commit...\n                transact.getJournal().flushToLog(true);\n                System.out.println(\"Transaction interrupted ...\");\n    \t    } catch (Exception e) {            \n    \t        fail(e.getMessage()); \n            } finally {\n                pool.release(broker);\n            }\n        }","commit_id":"6d062ec62be7c166e956bfbeb2da04c8b9fa2e77","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = startDB();\n        \n        System.out.println(\"testRead() ...\\n\");\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc;\n            String data;\n            \n            doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/test2/terms-eng.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document should not be null\", doc);\n            data = serializer.serialize(doc);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n        } finally {\n            pool.release(broker);\n        }    \n    }","id":93673,"modified_method":"public void testRead() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        DBBroker broker = null;\n        try {\n        \tSystem.out.println(\"testRead() ...\\n\");\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/test2/terms-eng.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document should not be null\", doc);\n            String data = serializer.serialize(doc);\n            assertNotNull(data);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \n\t    } finally {\n\t    \tif (pool != null) pool.release(broker);\n        }    \n    }","commit_id":"6d062ec62be7c166e956bfbeb2da04c8b9fa2e77","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStore() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            \n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            broker.saveCollection(transaction, root);\n            \n            Collection test = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test/test2\");\n            broker.saveCollection(transaction, test);\n            \n            System.out.println(\"Contents of dom.dbx:\\n\\n\");\n            DOMFile domDb = ((NativeBroker)broker).getDOMFile();\n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n            \n            File f;\n            IndexInfo info;\n            \n            // store some documents. Will be replaced below\n            File dir = new File(xmlDir);\n            File[] docs = dir.listFiles();\n            for (int i = 0; i < docs.length; i++) {\n                f = docs[i];\n                info = test.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                test.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n            }\n            \n            transact.commit(transaction);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93674,"modified_method":"public void testStore() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = null;        \n        DBBroker broker = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);            \n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            assertNotNull(root); \n            broker.saveCollection(transaction, root);\n            \n            Collection test2 = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test/test2\");\n            assertNotNull(test2); \n            broker.saveCollection(transaction, test2);\n            \n            System.out.println(\"Contents of dom.dbx:\\n\\n\");\n            DOMFile domDb = ((NativeBroker)broker).getDOMFile();\n            assertNotNull(domDb); \n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n            \n            File f;\n            IndexInfo info;\n            \n            // store some documents. Will be replaced below\n            File dir = new File(xmlDir);\n            assertNotNull(dir); \n            File[] docs = dir.listFiles();\n            assertNotNull(docs); \n            for (int i = 0; i < docs.length; i++) {\n                f = docs[i];\n                assertNotNull(f); \n                info = test2.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                assertNotNull(info); \n                test2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n            }\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());          \n        } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n    }","commit_id":"6d062ec62be7c166e956bfbeb2da04c8b9fa2e77","url":"https://github.com/eXist-db/exist"},{"original_method":"protected BrokerPool startDB() throws Exception {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            return BrokerPool.getInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n        return null;\n    }","id":93675,"modified_method":"protected BrokerPool startDB() {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            return BrokerPool.getInstance();\n        } catch (Exception e) {            \n            fail(e.getMessage());\n        }\n        return null;\n    }","commit_id":"6d062ec62be7c166e956bfbeb2da04c8b9fa2e77","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStore() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            \n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            broker.saveCollection(transaction, root);\n            \n            Collection test = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test/test2\");\n            broker.saveCollection(transaction, test);\n            \n            \n            File files[] = dir.listFiles();\n            \n            File f;\n            IndexInfo info;\n            \n            // store some documents.\n            for (int i = 0; i < files.length && i < 5000; i++) {\n                f = files[i];\n                try {\n                    info = test.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                    test.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n            \n            transact.commit(transaction);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93676,"modified_method":"public void testStore() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = null;        \n        DBBroker broker = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);            \n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n            \n            Collection test2 = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test/test2\");\n            assertNotNull(test2);\n            broker.saveCollection(transaction, test2);            \n            \n            File files[] = dir.listFiles();\n            assertNotNull(files);\n            \n            File f;\n            IndexInfo info;\n            \n            // store some documents.\n            for (int i = 0; i < files.length && i < 5000; i++) {\n                f = files[i];\n                assertNotNull(f);\n                try {\n                    info = test2.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                    assertNotNull(info);\n                    test2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n                \t//TODO : why store invalid documents ?\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());             \n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"6d062ec62be7c166e956bfbeb2da04c8b9fa2e77","url":"https://github.com/eXist-db/exist"},{"original_method":"protected BrokerPool startDB() throws Exception {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            return BrokerPool.getInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n        return null;\n    }","id":93677,"modified_method":"protected BrokerPool startDB() {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            return BrokerPool.getInstance();\n        } catch (Exception e) {            \n            fail(e.getMessage());\n        }\n        return null;\n    }","commit_id":"6d062ec62be7c166e956bfbeb2da04c8b9fa2e77","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead2() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = startDB();\n        \n        System.out.println(\"testRead() ...\\n\");\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93678,"modified_method":"public void testRead2() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        DBBroker broker = null;\n        try {\n        \tSystem.out.println(\"testRead2() ...\\n\");\n        \tpool = startDB();\n        \tassertNotNull(pool);        \n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            \n            //TODO : do something ?\n            \n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());              \n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"6d062ec62be7c166e956bfbeb2da04c8b9fa2e77","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = startDB();\n        \n        BrokerPool.FORCE_CORRUPTION = true;\n        \n        System.out.println(\"testRead() ...\\n\");\n        \n        File files[] = dir.listFiles();\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            \n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n            \n            Collection root = broker.openCollection(DBBroker.ROOT_COLLECTION + \"/test\", Lock.WRITE_LOCK);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);\n            \n            broker.removeCollection(transaction, root);\n            \n            transact.commit(transaction);\n            \n            transaction = transact.beginTransaction();\n            \n            root = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            broker.saveCollection(transaction, root);\n            \n            Collection test = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test/test2\");\n            broker.saveCollection(transaction, test);\n            \n            File f;\n            IndexInfo info;\n            \n            // store some documents.\n            for (int i = 0; i < files.length && i < 5000; i++) {\n                f = files[i];\n                try {\n                    info = test.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                    test.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n            \n            transact.commit(transaction);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93679,"modified_method":"public void testRead() {\n    \tBrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = null;\n        DBBroker broker = null;\n        try {\n        \tSystem.out.println(\"testRead() ...\\n\");\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.openCollection(DBBroker.ROOT_COLLECTION + \"/test\", Lock.WRITE_LOCK);\n            assertNotNull(root);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);            \n            broker.removeCollection(transaction, root);   \n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n            transaction = transact.beginTransaction();\n            System.out.println(\"Transaction started ...\");\n            \n            root = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n            \n            Collection test2 = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test/test2\");\n            assertNotNull(test2);\n            broker.saveCollection(transaction, test2);\n            \n            File files[] = dir.listFiles();\n            assertNotNull(files);\n            \n            File f;\n            IndexInfo info;\n            \n            // store some documents.\n            for (int i = 0; i < files.length && i < 5000; i++) {\n                f = files[i];\n                assertNotNull(f);\n                try {\n                    info = test2.validate(transaction, broker, f.getName(), new InputSource(f.toURI().toASCIIString()));\n                    assertNotNull(info);\n                    test2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());              \n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"6d062ec62be7c166e956bfbeb2da04c8b9fa2e77","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStore() throws Exception {\n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            BrokerPool.FORCE_CORRUPTION = true;\n            \n            TransactionManager transact = pool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection test = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            broker.saveCollection(transaction, test);\n            \n            Collection test2 = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test/test2\");\n            broker.saveCollection(transaction, test2);\n            \n            File f = new File(\"samples/biblio.rdf\");\n            InputSource is = new InputSource(f.toURI().toASCIIString());\n            IndexInfo info = test.validate(transaction, broker, \"biblio.rdf\", is);\n            test.store(transaction, broker, info, is, false);\n            \n            transact.commit(transaction);\n            \n            transaction = transact.beginTransaction();\n            \n            broker.removeCollection(transaction, test);\n            \n            transact.getJournal().flushToLog(true);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93680,"modified_method":"public void testStore() {\n    \tBrokerPool.FORCE_CORRUPTION = true;\n        DBBroker broker = null;\n        try {\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);                       \n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);   \n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);   \n            System.out.println(\"Transaction started ...\");\n            \n            Collection test = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test\");\n            assertNotNull(test);   \n            broker.saveCollection(transaction, test);\n            \n            Collection test2 = broker.getOrCreateCollection(transaction, DBBroker.ROOT_COLLECTION + \"/test/test2\");\n            assertNotNull(test2);   \n            broker.saveCollection(transaction, test2);\n            \n            File f = new File(\"samples/biblio.rdf\");\n            assertNotNull(f);   \n            InputSource is = new InputSource(f.toURI().toASCIIString());\n            assertNotNull(is);   \n            IndexInfo info = test.validate(transaction, broker, \"biblio.rdf\", is);\n            assertNotNull(info);   \n            test.store(transaction, broker, info, is, false);\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n            transaction = transact.beginTransaction();\n            System.out.println(\"Transaction started ...\");\n            \n            broker.removeCollection(transaction, test);\n            \n//          Don't commit...\n            transact.getJournal().flushToLog(true);\n            System.out.println(\"Transaction interrupted ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());               \n        } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n    }","commit_id":"6d062ec62be7c166e956bfbeb2da04c8b9fa2e77","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = false;\n        System.out.println(\"testRead() ...\\n\");\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            Collection test = broker.openCollection(DBBroker.ROOT_COLLECTION + \"/test\", Lock.READ_LOCK);\n            assertNotNull(\"Collection '\" + DBBroker.ROOT_COLLECTION +  \"/test' not found\", test);\n            \n            DocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/biblio.rdf\", Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION +  \"/test/biblio.rdf' should not be null\", doc);\n            String data = serializer.serialize(doc);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            test.release();\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93681,"modified_method":"public void testRead() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        DBBroker broker = null;\n        try {\n        \tSystem.out.println(\"testRead() ...\\n\");\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            Collection test = broker.openCollection(DBBroker.ROOT_COLLECTION + \"/test\", Lock.READ_LOCK);            \n            assertNotNull(\"Collection '\" + DBBroker.ROOT_COLLECTION +  \"/test' not found\", test);\n            \n            DocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION + \"/test/biblio.rdf\", Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION +  \"/test/biblio.rdf' should not be null\", doc);\n            String data = serializer.serialize(doc);\n            assertNotNull(data);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            test.release();\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());   \n\t    } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n    }","commit_id":"6d062ec62be7c166e956bfbeb2da04c8b9fa2e77","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void setUp() throws Exception {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            pool = BrokerPool.getInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }","id":93682,"modified_method":"protected void setUp() {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n            pool = BrokerPool.getInstance();\n        } catch (Exception e) {            \n            fail(e.getMessage());\n        }\n    }","commit_id":"6d062ec62be7c166e956bfbeb2da04c8b9fa2e77","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testUpdate() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            \n            TransactionManager mgr = pool.getTransactionManager();\n            \n            IndexInfo info = init(broker, mgr);\n            DocumentSet docs = new DocumentSet();\n            docs.add(info.getDocument());\n            XUpdateProcessor proc = new XUpdateProcessor(broker, docs);\n            \n            Txn transaction = mgr.beginTransaction();\n            \n            String xupdate;\n            Modification modifications[];\n            \n            // append some new element to records\n            for (int i = 1; i <= 50; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:append select=\\\"/products\\\">\" +\n                    \"       <product>\" +\n                    \"           <xu:attribute name=\\\"id\\\"><xu:value-of select=\\\"count(/products/product) + 1\\\"/><\/xu:attribute>\" +\n                    \"           <description>Product \" + i + \"<\/description>\" +\n                    \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n                    \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n                    \"       <\/product>\" +\n                    \"   <\/xu:append>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            mgr.commit(transaction);\n            \n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc;\n            String data;\n            \n            doc = broker.openDocument(DBBroker.ROOT_COLLECTION +  \"/test/test2/test.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/test.xml' should not be null\", doc);\n            data = serializer.serialize(doc);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            // the following transaction will not be committed and thus undone during recovery\n            transaction = mgr.beginTransaction();\n            \n            // remove elements\n            for (int i = 1; i <= 25; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:remove select=\\\"/products/product[last()]\\\"/>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            pool.getTransactionManager().getJournal().flushToLog(true);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93683,"modified_method":"public void testUpdate() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = null;        \n        DBBroker broker = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);            \n            TransactionManager mgr = pool.getTransactionManager();\n            assertNotNull(mgr);\n            \n            IndexInfo info = init(broker, mgr);\n            assertNotNull(info);\n            DocumentSet docs = new DocumentSet();\n            docs.add(info.getDocument());\n            XUpdateProcessor proc = new XUpdateProcessor(broker, docs);\n            assertNotNull(proc);\n            \n            Txn transaction = mgr.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            String xupdate;\n            Modification modifications[];\n            \n            // append some new element to records\n            for (int i = 1; i <= 50; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:append select=\\\"/products\\\">\" +\n                    \"       <product>\" +\n                    \"           <xu:attribute name=\\\"id\\\"><xu:value-of select=\\\"count(/products/product) + 1\\\"/><\/xu:attribute>\" +\n                    \"           <description>Product \" + i + \"<\/description>\" +\n                    \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n                    \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n                    \"       <\/product>\" +\n                    \"   <\/xu:append>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                assertNotNull(modifications);\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            mgr.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc = broker.openDocument(DBBroker.ROOT_COLLECTION +  \"/test/test2/test.xml\", Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/test.xml' should not be null\", doc);\n            String data = serializer.serialize(doc);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            // the following transaction will not be committed and thus undone during recovery\n            transaction = mgr.beginTransaction();\n            System.out.println(\"Transaction started ...\");\n            \n            // remove elements\n            for (int i = 1; i <= 25; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:remove select=\\\"/products/product[last()]\\\"/>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                assertNotNull(modifications);\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n//          Don't commit...            \n            pool.getTransactionManager().getJournal().flushToLog(true);\n            System.out.println(\"Transaction interrupted ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());  \n\t    } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"6d062ec62be7c166e956bfbeb2da04c8b9fa2e77","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testUpdate() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            \n            TransactionManager mgr = pool.getTransactionManager();\n            \n            IndexInfo info = init(broker, mgr);\n            DocumentSet docs = new DocumentSet();\n            docs.add(info.getDocument());\n            XUpdateProcessor proc = new XUpdateProcessor(broker, docs);\n            \n            Txn transaction = mgr.beginTransaction();\n            \n            String xupdate;\n            Modification modifications[];\n            \n            // append some new element to records\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:append select=\\\"/products\\\">\" +\n                    \"       <product>\" +\n                    \"           <xu:attribute name=\\\"id\\\"><xu:value-of select=\\\"count(/products/product) + 1\\\"/><\/xu:attribute>\" +\n                    \"           <description>Product \" + i + \"<\/description>\" +\n                    \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n                    \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n                    \"       <\/product>\" +\n                    \"   <\/xu:append>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            DOMFile domDb = ((NativeBroker) broker).getDOMFile();\n            System.out.println(domDb.debugPages(info.getDocument(), false));\n            \n            mgr.commit(transaction);\n            \n            // the following transaction will not be committed and thus undone during recovery\n            transaction = mgr.beginTransaction();\n            \n            // rename elements\n            xupdate =\n                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                \"   <xu:rename select=\\\"/products/product/description\\\">descript<\/xu:rename>\" +\n                \"<\/xu:modifications>\";\n            proc.setBroker(broker);\n            proc.setDocumentSet(docs);\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n            modifications[0].process(transaction);\n            proc.reset();\n            pool.getTransactionManager().getJournal().flushToLog(true);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93684,"modified_method":"public void testUpdate() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = null;        \n        DBBroker broker = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);            \n            TransactionManager mgr = pool.getTransactionManager();\n            assertNotNull(mgr);\n            \n            IndexInfo info = init(broker, mgr);\n            assertNotNull(info);\n            DocumentSet docs = new DocumentSet();\n            docs.add(info.getDocument());\n            XUpdateProcessor proc = new XUpdateProcessor(broker, docs);\n            assertNotNull(proc);\n            \n            Txn transaction = mgr.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            String xupdate;\n            Modification modifications[];\n            \n            // append some new element to records\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:append select=\\\"/products\\\">\" +\n                    \"       <product>\" +\n                    \"           <xu:attribute name=\\\"id\\\"><xu:value-of select=\\\"count(/products/product) + 1\\\"/><\/xu:attribute>\" +\n                    \"           <description>Product \" + i + \"<\/description>\" +\n                    \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n                    \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n                    \"       <\/product>\" +\n                    \"   <\/xu:append>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                assertNotNull(modifications);\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            DOMFile domDb = ((NativeBroker) broker).getDOMFile();\n            assertNotNull(domDb);\n            System.out.println(domDb.debugPages(info.getDocument(), false));\n            \n            mgr.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n            // the following transaction will not be committed and thus undone during recovery\n            transaction = mgr.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            // rename elements\n            xupdate =\n                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                \"   <xu:rename select=\\\"/products/product/description\\\">descript<\/xu:rename>\" +\n                \"<\/xu:modifications>\";\n            proc.setBroker(broker);\n            proc.setDocumentSet(docs);\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n            assertNotNull(modifications);\n            modifications[0].process(transaction);\n            proc.reset();\n            \n//          Don't commit...            \n            pool.getTransactionManager().getJournal().flushToLog(true);\n            System.out.println(\"Transaction interrupted ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());               \n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"6d062ec62be7c166e956bfbeb2da04c8b9fa2e77","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testUpdate() throws Exception {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n        \n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            \n            TransactionManager mgr = pool.getTransactionManager();\n            \n            IndexInfo info = init(broker, mgr);\n            DocumentSet docs = new DocumentSet();\n            docs.add(info.getDocument());\n            XUpdateProcessor proc = new XUpdateProcessor(broker, docs);\n            \n            Txn transaction = mgr.beginTransaction();\n            \n            String xupdate;\n            Modification modifications[];\n            \n            xupdate =\n                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                \"   <xu:append select=\\\"/products\\\">\" +\n                \"       <product id=\\\"1\\\">\" +\n                \"           <description>Product 1<\/description>\" +\n                \"           <price>24.30<\/price>\" +\n                \"           <stock>10<\/stock>\" +\n                \"       <\/product>\" +\n                \"   <\/xu:append>\" +\n                \"<\/xu:modifications>\";\n            proc.setBroker(broker);\n            proc.setDocumentSet(docs);\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n            modifications[0].process(transaction);\n            proc.reset();\n            \n            // append some new element to records\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:insert-before select=\\\"/products/product[1]\\\">\" +\n                    \"       <product>\" +\n                    \"           <xu:attribute name=\\\"id\\\"><xu:value-of select=\\\"count(/products/product) + 1\\\"/><\/xu:attribute>\" +\n                    \"           <description>Product \" + i + \"<\/description>\" +\n                    \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n                    \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n                    \"       <\/product>\" +\n                    \"   <\/xu:insert-before>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            DOMFile domDb = ((NativeBroker) broker).getDOMFile();\n            System.out.println(domDb.debugPages(info.getDocument(), false));\n            \n            mgr.commit(transaction);\n            \n            // the following transaction will not be committed and thus undone during recovery\n            transaction = mgr.beginTransaction();\n            \n            // replace elements\n            for (int i = 1; i <= 100; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:replace select=\\\"/products/product[\" + i + \"]\\\">\" +\n                    \"     <product id=\\\"\" + i + \"\\\">\" +\n                    \"         <description>Replaced product<\/description>\" +\n                    \"         <price>\" + (i * 0.75) + \"<\/price>\" +\n                    \"     <\/product>\" +\n                    \" <\/xu:replace>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n//            mgr.commit(transaction);\n            pool.getTransactionManager().getJournal().flushToLog(true);\n        } finally {\n            pool.release(broker);\n        }\n    }","id":93685,"modified_method":"public void testUpdate() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = null;        \n        DBBroker broker = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            TransactionManager mgr = pool.getTransactionManager();\n            assertNotNull(mgr);\n            \n            IndexInfo info = init(broker, mgr);\n            assertNotNull(info);\n            DocumentSet docs = new DocumentSet();\n            docs.add(info.getDocument());\n            XUpdateProcessor proc = new XUpdateProcessor(broker, docs);\n            assertNotNull(proc);\n            \n            Txn transaction = mgr.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            String xupdate;\n            Modification modifications[];\n            \n            xupdate =\n                \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                \"   <xu:append select=\\\"/products\\\">\" +\n                \"       <product id=\\\"1\\\">\" +\n                \"           <description>Product 1<\/description>\" +\n                \"           <price>24.30<\/price>\" +\n                \"           <stock>10<\/stock>\" +\n                \"       <\/product>\" +\n                \"   <\/xu:append>\" +\n                \"<\/xu:modifications>\";\n            proc.setBroker(broker);\n            proc.setDocumentSet(docs);\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n            assertNotNull(modifications);\n            modifications[0].process(transaction);\n            proc.reset();\n            \n            // append some new element to records\n            for (int i = 1; i <= 200; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:insert-before select=\\\"/products/product[1]\\\">\" +\n                    \"       <product>\" +\n                    \"           <xu:attribute name=\\\"id\\\"><xu:value-of select=\\\"count(/products/product) + 1\\\"/><\/xu:attribute>\" +\n                    \"           <description>Product \" + i + \"<\/description>\" +\n                    \"           <price>\" + (i * 2.5) + \"<\/price>\" +\n                    \"           <stock>\" + (i * 10) + \"<\/stock>\" +\n                    \"       <\/product>\" +\n                    \"   <\/xu:insert-before>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                assertNotNull(modifications);\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n            \n            DOMFile domDb = ((NativeBroker) broker).getDOMFile();\n            assertNotNull(domDb);\n            System.out.println(domDb.debugPages(info.getDocument(), false));\n            \n            mgr.commit(transaction);\n            System.out.println(\"Transaction commited ...\");            \n            \n            // the following transaction will not be committed and thus undone during recovery\n            transaction = mgr.beginTransaction();\n            System.out.println(\"Transaction started...\");   \n            \n            // replace elements\n            for (int i = 1; i <= 100; i++) {\n                xupdate =\n                    \"<xu:modifications version=\\\"1.0\\\" xmlns:xu=\\\"http://www.xmldb.org/xupdate\\\">\" +\n                    \"   <xu:replace select=\\\"/products/product[\" + i + \"]\\\">\" +\n                    \"     <product id=\\\"\" + i + \"\\\">\" +\n                    \"         <description>Replaced product<\/description>\" +\n                    \"         <price>\" + (i * 0.75) + \"<\/price>\" +\n                    \"     <\/product>\" +\n                    \" <\/xu:replace>\" +\n                    \"<\/xu:modifications>\";\n                proc.setBroker(broker);\n                proc.setDocumentSet(docs);\n                modifications = proc.parse(new InputSource(new StringReader(xupdate)));\n                modifications[0].process(transaction);\n                proc.reset();\n            }\n//            mgr.commit(transaction);\n            \n//          Don't commit...              \n            pool.getTransactionManager().getJournal().flushToLog(true);\n            System.out.println(\"Transaction interrupted ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());             \n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"6d062ec62be7c166e956bfbeb2da04c8b9fa2e77","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public List<String> completionCandidates( String partOfLine, Session session )\n    {\n        String lastWord = TextUtil.lastWordOrQuoteOf( partOfLine, false );\n        if ( lastWord.startsWith( \"-\" ) )\n        {\n            return super.completionCandidates( partOfLine, session );\n        }\n        try\n        {\n            TreeSet<String> result = new TreeSet<String>();\n            NodeOrRelationship current = getCurrent( session );\n            if ( current.isNode() )\n            {\n                // TODO Check if -r is supplied\n                Node node = current.asNode();\n                for ( Node otherNode : RelationshipToNodeIterable.wrap(\n                        node.getRelationships(), node ) )\n                {\n                    long otherNodeId = otherNode.getId();\n                    String title = findTitle( getServer(), session, otherNode );\n                    if ( title != null )\n                    {\n                        if ( !result.contains( title ) )\n                        {\n                            maybeAddCompletionCandidate( result, title + \",\" + otherNodeId,\n                                    lastWord );\n                        }\n                    }\n                    maybeAddCompletionCandidate( result, \"\" + otherNodeId, lastWord );\n                }\n            }\n            else\n            {\n                maybeAddCompletionCandidate( result, START_ALIAS, lastWord );\n                maybeAddCompletionCandidate( result, END_ALIAS, lastWord );\n                Relationship rel = current.asRelationship();\n                maybeAddCompletionCandidate( result, \"\" + rel.getStartNode().getId(), lastWord );\n                maybeAddCompletionCandidate( result, \"\" + rel.getEndNode().getId(), lastWord );\n            }\n            return new ArrayList<String>( result );\n        }\n        catch ( ShellException e )\n        {\n            e.printStackTrace();\n            return super.completionCandidates( partOfLine, session );\n        }\n    }","id":93686,"modified_method":"@Override\n    public List<String> completionCandidates( String partOfLine, Session session )\n    {\n        String lastWord = TextUtil.lastWordOrQuoteOf( partOfLine, false );\n        if ( lastWord.startsWith( \"-\" ) )\n        {\n            return super.completionCandidates( partOfLine, session );\n        }\n\n        TreeSet<String> result = new TreeSet<String>();\n        NodeOrRelationship current;\n        try\n        {\n            current = getCurrent( session );\n        }\n        catch ( ShellException e )\n        {\n            return Collections.emptyList();\n        }\n        \n        if ( current.isNode() )\n        {\n            // TODO Check if -r is supplied\n            Node node = current.asNode();\n            for ( Node otherNode : RelationshipToNodeIterable.wrap(\n                    node.getRelationships(), node ) )\n            {\n                long otherNodeId = otherNode.getId();\n                String title = findTitle( getServer(), session, otherNode );\n                if ( title != null )\n                {\n                    if ( !result.contains( title ) )\n                    {\n                        maybeAddCompletionCandidate( result, title + \",\" + otherNodeId,\n                                lastWord );\n                    }\n                }\n                maybeAddCompletionCandidate( result, \"\" + otherNodeId, lastWord );\n            }\n        }\n        else\n        {\n            maybeAddCompletionCandidate( result, START_ALIAS, lastWord );\n            maybeAddCompletionCandidate( result, END_ALIAS, lastWord );\n            Relationship rel = current.asRelationship();\n            maybeAddCompletionCandidate( result, \"\" + rel.getStartNode().getId(), lastWord );\n            maybeAddCompletionCandidate( result, \"\" + rel.getEndNode().getId(), lastWord );\n        }\n        return new ArrayList<String>( result );\n    }","commit_id":"a15b405aaeb653d09ff4c28264340e2643f7d4e4","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session,\n        Output out ) throws ShellException, RemoteException\n    {\n        List<TypedId> paths = readCurrentWorkingDir( session );\n\n        NodeOrRelationship current = getCurrent( session );\n        NodeOrRelationship newThing = null;\n        if ( parser.arguments().isEmpty() )\n        {\n            try {\n              newThing = NodeOrRelationship.wrap(\n                getServer().getDb().getReferenceNode() );\n              paths.clear();\n            } catch (NotFoundException nne) {\n                out.println( \"Can't find reference node, not moving.\");\n                return null;\n            }\n        }\n        else\n        {\n            String arg = parser.arguments().get( 0 );\n            TypedId newId = current.getTypedId();\n            if ( arg.equals( \"..\" ) )\n            {\n                if ( paths.size() > 0 )\n                {\n                    newId = paths.remove( paths.size() - 1 );\n                }\n            }\n            else if ( arg.equals( \".\" ) )\n            {\n            }\n            else if ( arg.equals( START_ALIAS ) || arg.equals( END_ALIAS ) )\n            {\n                newId = getStartOrEnd( current, arg );\n                paths.add( current.getTypedId() );\n            }\n            else\n            {\n                long suppliedId = -1;\n                try\n                {\n                    suppliedId = Long.parseLong( arg );\n                }\n                catch ( NumberFormatException e )\n                {\n                    suppliedId = findNodeWithTitle( current.asNode(), arg, session );\n                    if ( suppliedId == -1 )\n                    {\n                        throw new ShellException( \"No connected node with title '\" + arg + \"'\" );\n                    }\n                }\n\n                newId = parser.options().containsKey( \"r\" ) ?\n                    new TypedId( NodeOrRelationship.TYPE_RELATIONSHIP, suppliedId ) :\n                    new TypedId( NodeOrRelationship.TYPE_NODE, suppliedId );\n                if ( newId.equals( current.getTypedId() ) )\n                {\n                    throw new ShellException( \"Can't cd to where you stand\" );\n                }\n                boolean absolute = parser.options().containsKey( \"a\" );\n                if ( !absolute && !this.isConnected( current, newId ) )\n                {\n                    throw new ShellException(\n                        getDisplayName( getServer(), session, newId, false ) +\n                        \" isn't connected to the current primitive,\" +\n                        \" use -a to force it to go there anyway\" );\n                }\n                paths.add( current.getTypedId() );\n            }\n            newThing = this.getThingById( newId );\n        }\n\n        setCurrent( session, newThing );\n        writeCurrentWorkingDir( paths, session );\n        return null;\n    }","id":93687,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session,\n        Output out ) throws ShellException, RemoteException\n    {\n        List<TypedId> paths = readCurrentWorkingDir( session );\n\n        NodeOrRelationship newThing = null;\n        if ( parser.arguments().isEmpty() )\n        {\n            try\n            {\n                newThing = NodeOrRelationship.wrap( getServer().getDb().getReferenceNode() );\n                paths.clear();\n            }\n            catch ( NotFoundException nne )\n            {\n                clearCurrent( session );\n                writeCurrentWorkingDir( paths, session );\n                return null;\n            }\n        }\n        else\n        {\n            NodeOrRelationship current = null;\n            try\n            {\n                current = getCurrent( session );\n            }\n            catch ( ShellException e )\n            { // Ok, didn't exist\n            }\n            \n            String arg = parser.arguments().get( 0 );\n            TypedId newId = null;\n            if ( arg.equals( \"..\" ) )\n            {\n                if ( paths.size() > 0 )\n                {\n                    newId = paths.remove( paths.size() - 1 );\n                }\n            }\n            else if ( arg.equals( \".\" ) )\n            {\n            }\n            else if ( arg.equals( START_ALIAS ) || arg.equals( END_ALIAS ) )\n            {\n                if ( current == null )\n                {\n                    throw new ShellException( \"Can't do \" + START_ALIAS + \" or \" +\n                            END_ALIAS + \" on a non-existent relationship\" );\n                }\n                \n                newId = getStartOrEnd( current, arg );\n                paths.add( current.getTypedId() );\n            }\n            else\n            {\n                long suppliedId = -1;\n                try\n                {\n                    suppliedId = Long.parseLong( arg );\n                }\n                catch ( NumberFormatException e )\n                {\n                    if ( current != null )\n                    {\n                        suppliedId = findNodeWithTitle( current.asNode(), arg, session );\n                    }\n                    if ( suppliedId == -1 )\n                    {\n                        throw new ShellException( \"No connected node with title '\" + arg + \"'\" );\n                    }\n                }\n\n                newId = parser.options().containsKey( \"r\" ) ?\n                    new TypedId( NodeOrRelationship.TYPE_RELATIONSHIP, suppliedId ) :\n                    new TypedId( NodeOrRelationship.TYPE_NODE, suppliedId );\n                if ( current != null && newId.equals( current.getTypedId() ) )\n                {\n                    throw new ShellException( \"Can't cd to where you stand\" );\n                }\n                boolean absolute = parser.options().containsKey( \"a\" );\n                if ( !absolute && current != null && !isConnected( current, newId ) )\n                {\n                    throw new ShellException(\n                        getDisplayName( getServer(), session, newId, false ) +\n                        \" isn't connected to the current primitive,\" +\n                        \" use -a to force it to go there anyway\" );\n                }\n                \n                if ( current != null )\n                {\n                    paths.add( current.getTypedId() );\n                }\n            }\n            newThing = newId != null ? getThingById( newId ) : current;\n        }\n\n        if ( newThing != null )\n        {\n            setCurrent( session, newThing );\n        }\n        else\n        {\n            clearCurrent( session );\n        }\n        writeCurrentWorkingDir( paths, session );\n        return null;\n    }","commit_id":"a15b405aaeb653d09ff4c28264340e2643f7d4e4","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String getReplacement( ShellServer server, Session session )\n            throws ShellException\n        {\n            return GraphDatabaseApp.getDisplayName(\n                ( GraphDatabaseShellServer ) server, session,\n                GraphDatabaseApp.getCurrent(\n                    ( GraphDatabaseShellServer ) server, session ),\n                    false ).toString();\n        }","id":93688,"modified_method":"public String getReplacement( ShellServer server, Session session )\n            throws ShellException\n        {\n            try\n            {\n                return GraphDatabaseApp.getDisplayName(\n                    ( GraphDatabaseShellServer ) server, session,\n                    GraphDatabaseApp.getCurrent(\n                        ( GraphDatabaseShellServer ) server, session ),\n                        false ).toString();\n            }\n            catch ( ShellException e )\n            {\n                return GraphDatabaseApp.getDisplayNameForNonExistent();\n            }\n        }","commit_id":"a15b405aaeb653d09ff4c28264340e2643f7d4e4","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String stringifyPath( List<TypedId> pathIds, Session session )\n        throws ShellException\n    {\n        if ( pathIds.isEmpty() )\n        {\n            return \"\";\n        }\n        StringBuilder path = new StringBuilder();\n        for ( TypedId id : pathIds )\n        {\n            path.append( getDisplayName( getServer(), session,\n                    id, false ) ).append( \"-->\" );\n        }\n        return path.append( getDisplayName( getServer(), session,\n                getCurrent( session ), true ) ).toString();\n    }","id":93689,"modified_method":"private String stringifyPath( List<TypedId> pathIds, Session session )\n        throws ShellException\n    {\n        if ( pathIds.isEmpty() )\n        {\n            return \"\";\n        }\n        StringBuilder path = new StringBuilder();\n        for ( TypedId id : pathIds )\n        {\n            String displayName;\n            try\n            {\n                displayName = getDisplayName( getServer(), session, id, false );\n            }\n            catch ( ShellException e )\n            {\n                displayName = getDisplayNameForNonExistent();\n            }\n            path.append( displayName ).append( \"-->\" );\n        }\n        return path.toString();\n    }","commit_id":"a15b405aaeb653d09ff4c28264340e2643f7d4e4","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session,\n        Output out ) throws ShellException, RemoteException\n    {\n\n        NodeOrRelationship current = null;\n        try {\n            \n            current = this.getCurrent( session );\n        } catch (NotFoundException nnfe) {\n            out.println( \"Current not found. make sure you are standing on a valid structure.\");\n            return null;\n        }\n        out.println( \"Current is \" +\n            getDisplayName( getServer(), session, current, false ) );\n\n        String path = stringifyPath( Cd.readCurrentWorkingDir( session ), session );\n        if ( path.length() > 0 )\n        {\n            out.println( path );\n        }\n        return null;\n    }","id":93690,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session,\n        Output out ) throws ShellException, RemoteException\n    {\n        String current = null;\n        try\n        {\n            current = getDisplayName( getServer(), session, getCurrent( session ), false );\n        }\n        catch ( ShellException e )\n        {\n            current = getDisplayNameForNonExistent();\n        }\n        out.println( \"Current is \" + current );\n\n        String path = stringifyPath( Cd.readCurrentWorkingDir( session ), session ) + current;\n        if ( path.length() > 0 )\n        {\n            out.println( path );\n        }\n        return null;\n    }","commit_id":"a15b405aaeb653d09ff4c28264340e2643f7d4e4","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session,\n        Output out ) throws ShellException\n    {\n        assertCurrentIsNode( session );\n\n        if ( parser.arguments().isEmpty() )\n        {\n            throw new ShellException(\n                \"Must supply relationship id to delete as the first argument\" );\n        }\n\n        Node currentNode = this.getCurrent( session ).asNode();\n        Relationship rel = findRel( currentNode, Long.parseLong(\n            parser.arguments().get( 0 ) ) );\n        rel.delete();\n        if ( !currentNode.equals(\n            getServer().getDb().getReferenceNode() ) &&\n            !currentNode.getRelationships().iterator().hasNext() )\n        {\n            throw new ShellException( \"It would result in the current node \" +\n                currentNode + \" to be decoupled (no relationships left)\" );\n        }\n        Node otherNode = rel.getOtherNode( currentNode );\n        if ( !otherNode.getRelationships().iterator().hasNext() )\n        {\n            boolean deleteOtherNodeWhenEmpty = parser.options().containsKey(\n                \"d\" );\n            if ( !deleteOtherNodeWhenEmpty )\n            {\n                throw new ShellException( \"Since the node \" +\n                    getDisplayName( getServer(), session, otherNode, false ) +\n                    \" would be decoupled after this, you must supply the\" +\n                    \" -d (for delete-when-decoupled) so that the other node \" +\n                    \"(\" + otherNode + \") may be deleted\" );\n            }\n            otherNode.delete();\n        }\n        else\n        {\n            if ( !this.hasPathToRefNode( otherNode ) )\n            {\n                throw new ShellException( \"It would result in \" + otherNode +\n                    \" to be recursively decoupled with the reference node\" );\n            }\n            if ( !this.hasPathToRefNode( currentNode ) )\n            {\n                throw new ShellException( \"It would result in \" + currentNode +\n                    \" to be recursively decoupled with the reference node\" );\n            }\n        }\n        return null;\n    }","id":93691,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session,\n        Output out ) throws ShellException\n    {\n        assertCurrentIsNode( session );\n\n        if ( parser.arguments().isEmpty() )\n        {\n            throw new ShellException(\n                \"Must supply relationship id to delete as the first argument\" );\n        }\n\n        Node currentNode = this.getCurrent( session ).asNode();\n        Relationship rel = findRel( currentNode, Long.parseLong(\n            parser.arguments().get( 0 ) ) );\n        rel.delete();\n        \n        if ( !currentNode.equals(\n            getServer().getDb().getReferenceNode() ) &&\n            !currentNode.getRelationships().iterator().hasNext() )\n        {\n            throw new ShellException( \"It would result in the current node \" +\n                currentNode + \" to be decoupled (no relationships left)\" );\n        }\n        Node otherNode = rel.getOtherNode( currentNode );\n        if ( !otherNode.getRelationships().iterator().hasNext() )\n        {\n            boolean deleteOtherNodeWhenEmpty = parser.options().containsKey( \"d\" );\n            if ( !deleteOtherNodeWhenEmpty )\n            {\n                throw new ShellException( \"Since the node \" +\n                    getDisplayName( getServer(), session, otherNode, false ) +\n                    \" would be decoupled after this, you must supply the\" +\n                    \" -d (for delete-when-decoupled) so that the other node \" +\n                    \"(\" + otherNode + \") may be deleted\" );\n            }\n            otherNode.delete();\n        }\n        else if ( parser.options().containsKey( \"e\" ) )\n        {\n            if ( !this.hasPathToRefNode( otherNode ) )\n            {\n                throw new ShellException( \"It would result in \" + otherNode +\n                    \" to be recursively decoupled with the reference node\" );\n            }\n            if ( !this.hasPathToRefNode( currentNode ) )\n            {\n                throw new ShellException( \"It would result in \" + currentNode +\n                    \" to be recursively decoupled with the reference node\" );\n            }\n        }\n        return null;\n    }","commit_id":"a15b405aaeb653d09ff4c28264340e2643f7d4e4","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Constructs a new application which can delete relationships in Neo4j.\n     */\n    public Rmrel()\n    {\n        this.addOptionDefinition( \"d\", new OptionDefinition( OptionValueType.NONE,\n            \"Must be supplied if the affected other node gets decoupled \" +\n            \"after this operation so that it gets deleted.\" ) );\n    }","id":93692,"modified_method":"/**\n     * Constructs a new application which can delete relationships in Neo4j.\n     */\n    public Rmrel()\n    {\n        this.addOptionDefinition( \"e\", new OptionDefinition( OptionValueType.NONE,\n            \"Ensure that nodes doesn't get disconnected from the rest of the graph\" ) );\n        this.addOptionDefinition( \"d\", new OptionDefinition( OptionValueType.NONE,\n            \"Must be supplied if the affected other node gets decoupled \" +\n            \"after this operation so that it gets deleted.\" ) );\n    }","commit_id":"a15b405aaeb653d09ff4c28264340e2643f7d4e4","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\r\n\t * Get the singleton hibernate Session Factory.\r\n\t */\r\n\tpublic static SessionFactory getSessionFactory() {\r\n\t\treturn initSessionFactory(null);\r\n\t}","id":93693,"modified_method":"/**\r\n\t * Get the singleton hibernate Session Factory.\r\n\t */\r\n\tpublic static SessionFactory getSessionFactory() {\r\n\t\treturn initSessionFactory((WebApp)null);\r\n\t}","commit_id":"eb3e975ed568b8b2bf553b796a1270c20d325389","url":"https://github.com/zkoss/zk"},{"original_method":"/**\r\n\t * Used in {@link HibernateSessionFactoryListener} to init\r\n\t * Hibernate SessionFactory.\r\n\t * @param app web applicaton, given null will try to get it from current Execution.\r\n\t * @since 3.0.1\r\n\t */\r\n\t/* package */ static SessionFactory initSessionFactory(WebApp app) {\r\n\t\tif (_factory == null) {\r\n\t\t\t//read hibernate.config preference\r\n\t\t\tif (app == null) {\r\n\t\t\t\tapp = Executions.getCurrent().getDesktop().getWebApp();\r\n\t\t\t}\r\n\t\t\tfinal org.zkoss.zk.ui.util.Configuration config = app.getConfiguration();\r\n\t\t\tfinal String resource = config.getPreference(\"HibernateUtil.config\", null);\r\n\t\t\ttry {\r\n\t\t\t    // Create the SessionFactory per JavaVM version and allow JDK 1.4 compatibility\r\n\t\t\t\tif (JVMs.isJava5()) {\r\n\t\t\t\t    _factory = java5Factory(resource);\r\n\t\t\t\t} else {\r\n\t\t\t\t  \t_factory = java4Factory(resource);\r\n\t\t\t\t}\r\n\t\t\t\tlog.info(\"Hibernate configuration file loaded: \"+ (resource == null ? \"hibernate.cfg.xml\" : resource));\r\n\t\t\t} catch (Throwable ex) {\r\n\t\t\t    // Make sure you log the exception, as it might be swallowed\r\n\t\t\t    log.error(\"Initial SessionFactory creation failed.\" + ex);\r\n\t\t\t    throw new ExceptionInInitializerError(ex);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn _factory;\r\n\t}","id":93694,"modified_method":"/**\r\n\t * Used in {@link HibernateSessionFactoryListener} to init\r\n\t * Hibernate SessionFactory.\r\n\t * @param app web applicaton, given null will try to get it from current Execution.\r\n\t * @since 3.0.1\r\n\t */\r\n\t/* package */ static SessionFactory initSessionFactory(WebApp app) {\r\n\t\tif (_factory == null) {\r\n\t\t\t//read hibernate.config preference\r\n\t\t\tif (app == null) {\r\n\t\t\t\tfinal Execution exec = Executions.getCurrent();\r\n\t\t\t\tif (exec != null) {\r\n\t\t\t\t\tfinal Desktop desktop = exec.getDesktop();\r\n\t\t\t\t\tif (desktop != null) {\r\n\t\t\t\t\t\tapp = desktop.getWebApp();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tString resource = null;\r\n\t\t\tif (app != null) {\r\n\t\t\t\tfinal org.zkoss.zk.ui.util.Configuration config = app.getConfiguration();\r\n\t\t\t\tresource = config.getPreference(CONFIG, null);\r\n\t\t\t}\r\n\t\t\treturn initSessionFactory(resource);\r\n\t\t}\r\n\t\treturn _factory;\r\n\t}","commit_id":"eb3e975ed568b8b2bf553b796a1270c20d325389","url":"https://github.com/zkoss/zk"},{"original_method":"/**\r\n\t * Used in {@link HibernateSessionFactoryListener} to init\r\n\t * Hibernate SessionFactory.\r\n\t * @deprecated Use {@link #initSessionFactory(WebApp app)} instead.\r\n\t */\r\n\t/* package */ static SessionFactory initSessionFactory() {\r\n\t\treturn initSessionFactory(null);\r\n\t}","id":93695,"modified_method":"/**\r\n\t * Used in {@link HibernateSessionFactoryListener} to init\r\n\t * Hibernate SessionFactory.\r\n\t * @deprecated Use {@link #initSessionFactory(WebApp app)} instead.\r\n\t */\r\n\t/* package */ static SessionFactory initSessionFactory() {\r\n\t\treturn initSessionFactory((WebApp)null);\r\n\t}","commit_id":"eb3e975ed568b8b2bf553b796a1270c20d325389","url":"https://github.com/zkoss/zk"},{"original_method":"public DelegatingVariableResolver() {\n\t\tfinal Configuration conf = Executions.getCurrent().getDesktop()\n\t\t\t\t.getWebApp().getConfiguration();\n\t\tfinal String value = conf.getPreference(\"org.zkoss.spring.VariableResolver\",\n\t\t\t\tnull);\n\t\tif (value != null) {\n\t\t\tString[] vrClss = value.split(\",\");\n\t\t\tfor (int i = 0; i < vrClss.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tObject o = Classes.newInstanceByThread(vrClss[i]);\n\t\t\t\t\tif(!_variableResolvers.contains(o)) {\n\t\t\t\t\t\t_variableResolvers.add(o);\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// do nothing\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t_variableResolvers.add(new DefaultDelegatingVariableResolver());\n\t\t}\n\n\t}","id":93696,"modified_method":"public DelegatingVariableResolver() {\n\t\tfinal Execution exec = Executions.getCurrent();\n\t\tString classes = null;\n\t\tif (exec != null) {\n\t\t\tclasses = exec.getDesktop()\n\t\t\t\t.getWebApp().getConfiguration()\n\t\t\t\t.getPreference(\"org.zkoss.spring.VariableResolver\", null);\n\t\t}\n\n\t\tif (classes == null)\n\t\t\tclasses = Library.getProperty(\"org.zkoss.spring.VariableResolver.class\");\n\n\t\tif (classes != null) {\n\t\t\tString[] vrClss = classes.split(\",\");\n\t\t\tfor (int i = 0; i < vrClss.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tObject o = Classes.newInstanceByThread(vrClss[i]);\n\t\t\t\t\tif(!_variableResolvers.contains(o)) {\n\t\t\t\t\t\t_variableResolvers.add(o);\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// do nothing\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t_variableResolvers.add(new DefaultDelegatingVariableResolver());\n\t\t}\n\t}","commit_id":"3f51d5fb2d33ccbb5c22240a48801f464ebbe42c","url":"https://github.com/zkoss/zk"},{"original_method":"/**\r\n\t * Used in {@link HibernateSessionFactoryListener} to init\r\n\t * Hibernate SessionFactory.\r\n\t * @param app web applicaton, given null will try to get it from current Execution.\r\n\t * @since 3.0.1\r\n\t */\r\n\t/* package */ static SessionFactory initSessionFactory(WebApp app) {\r\n\t\tif (_factory == null) {\r\n\t\t\t//read hibernate.config preference\r\n\t\t\tif (app == null) {\r\n\t\t\t\tfinal Execution exec = Executions.getCurrent();\r\n\t\t\t\tif (exec != null) {\r\n\t\t\t\t\tfinal Desktop desktop = exec.getDesktop();\r\n\t\t\t\t\tif (desktop != null) {\r\n\t\t\t\t\t\tapp = desktop.getWebApp();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tString resource = null;\r\n\t\t\tif (app != null) {\r\n\t\t\t\tfinal org.zkoss.zk.ui.util.Configuration config = app.getConfiguration();\r\n\t\t\t\tresource = config.getPreference(CONFIG, null);\r\n\t\t\t}\r\n\t\t\treturn initSessionFactory(resource);\r\n\t\t}\r\n\t\treturn _factory;\r\n\t}","id":93697,"modified_method":"/**\r\n\t * Used in {@link HibernateSessionFactoryListener} to init\r\n\t * Hibernate SessionFactory.\r\n\t * @param app web applicaton, given null will try to get it from current Execution.\r\n\t * @since 3.0.1\r\n\t */\r\n\t/* package */ static SessionFactory initSessionFactory(WebApp app) {\r\n\t\tif (_factory == null) {\r\n\t\t\t//read hibernate.config preference\r\n\t\t\tif (app == null) {\r\n\t\t\t\tfinal Execution exec = Executions.getCurrent();\r\n\t\t\t\tif (exec != null) {\r\n\t\t\t\t\tfinal Desktop desktop = exec.getDesktop();\r\n\t\t\t\t\tif (desktop != null) {\r\n\t\t\t\t\t\tapp = desktop.getWebApp();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tString resource = null;\r\n\t\t\tif (app != null) {\r\n\t\t\t\tresource = app.getConfiguration().getPreference(CONFIG, null);\r\n\t\t\t}\r\n\t\t\tif (resource == null)\r\n\t\t\t\tresource = Library.getProperty(CONFIG);\r\n\t\t\treturn initSessionFactory(resource);\r\n\t\t}\r\n\t\treturn _factory;\r\n\t}","commit_id":"3f51d5fb2d33ccbb5c22240a48801f464ebbe42c","url":"https://github.com/zkoss/zk"},{"original_method":"public ThreadLocalListener() {\r\n\t\tfinal WebApp app = Executions.getCurrent().getDesktop().getWebApp();\r\n\t\t_fieldsMap = (Map) app.getAttribute(\"zkplus.util.ThreadLocalListener.fieldsMap\");\r\n\t\t_enabled = app.getConfiguration().isEventThreadEnabled();\r\n\t\tif (_fieldsMap == null) {\r\n\t\t\t_fieldsMap = new HashMap(8);\r\n\t\t\tapp.setAttribute(\"zkplus.util.ThreadLocalListener.fieldsMap\", _fieldsMap);\r\n\t\t\t//read preference\r\n\t\t\tfinal Configuration config = app.getConfiguration();\r\n\t\t\tfinal String val = config.getPreference(\"ThreadLocal\", null);\r\n\t\t\tif (val != null) {\r\n\t\t\t\tfinal Collection klassSets = CollectionsX.parse(null, val, ';');\r\n\t\t\t\tfor(Iterator its = klassSets.iterator(); its.hasNext(); ) {\r\n\t\t\t\t\tfinal String klassSetStr = (String) its.next();\r\n\t\t\t\t\tfinal Collection klassSet = CollectionsX.parse(null, klassSetStr, '=');\r\n\t\t\t\t\tfinal Iterator itz = klassSet.iterator();\r\n\t\t\t\t\tfinal String klass = (String) itz.next();\r\n\t\t\t\t\tfinal String fieldsStr = (String) itz.next();\r\n\t\t\t\t\tfinal Collection fields = CollectionsX.parse(null, fieldsStr, ',');\r\n\t\t\t\t\t_fieldsMap.put(klass, fields.toArray(new String[fields.size()]));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t_threadLocalsMap = new HashMap(_fieldsMap.size());\r\n\t}","id":93698,"modified_method":"public ThreadLocalListener() {\r\n\t\tfinal WebApp app = Executions.getCurrent().getDesktop().getWebApp();\r\n\t\t_fieldsMap = (Map) app.getAttribute(\"zkplus.util.ThreadLocalListener.fieldsMap\");\r\n\t\t_enabled = app.getConfiguration().isEventThreadEnabled();\r\n\t\tif (_fieldsMap == null) {\r\n\t\t\t_fieldsMap = new HashMap(8);\r\n\t\t\tfinal String PREF = \"zkplus.util.ThreadLocalListener.fieldsMap\";\r\n\t\t\tapp.setAttribute(PREF, _fieldsMap);\r\n\t\t\t//read preference\r\n\t\t\tString val = app.getConfiguration().getPreference(\"ThreadLocal\", null);\r\n\t\t\tif (val == null)\r\n\t\t\t\tval = Library.getProperty(PREF);\r\n\t\t\tif (val != null) {\r\n\t\t\t\tfinal Collection klassSets = CollectionsX.parse(null, val, ';');\r\n\t\t\t\tfor(Iterator its = klassSets.iterator(); its.hasNext(); ) {\r\n\t\t\t\t\tfinal String klassSetStr = (String) its.next();\r\n\t\t\t\t\tfinal Collection klassSet = CollectionsX.parse(null, klassSetStr, '=');\r\n\t\t\t\t\tfinal Iterator itz = klassSet.iterator();\r\n\t\t\t\t\tfinal String klass = (String) itz.next();\r\n\t\t\t\t\tfinal String fieldsStr = (String) itz.next();\r\n\t\t\t\t\tfinal Collection fields = CollectionsX.parse(null, fieldsStr, ',');\r\n\t\t\t\t\t_fieldsMap.put(klass, fields.toArray(new String[fields.size()]));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t_threadLocalsMap = new HashMap(_fieldsMap.size());\r\n\t}","commit_id":"3f51d5fb2d33ccbb5c22240a48801f464ebbe42c","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n   * Factory method for obtaining a resource provider based on a given type and management controller.\n   *\n   * @param type                  the resource type\n   * @param propertyIds           the property ids\n   * @param managementController  the management controller\n   *\n   * @return a new resource provider\n   */\n  public static ResourceProvider getResourceProvider(Resource.Type type,\n                                                     Set<String> propertyIds,\n                                                     Map<Resource.Type, String> keyPropertyIds,\n                                                     AmbariManagementController managementController) {\n\n    switch (type.getInternalType()) {\n      case Cluster:\n        return new ClusterResourceProvider(managementController);\n      case Service:\n        return resourceProviderFactory.getServiceResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Component:\n        return resourceProviderFactory.getComponentResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Host:\n        return resourceProviderFactory.getHostResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case HostComponent:\n        return resourceProviderFactory.getHostComponentResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Configuration:\n        return new ConfigurationResourceProvider(managementController);\n      case ServiceConfigVersion:\n        return new ServiceConfigVersionResourceProvider(managementController);\n      case Action:\n        return new ActionResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Request:\n        return new RequestResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Task:\n        return new TaskResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case User:\n        return new UserResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Group:\n        return new GroupResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Member:\n        return resourceProviderFactory.getMemberResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Upgrade:\n        return resourceProviderFactory.getUpgradeResourceProvider(managementController);\n      case Stack:\n        return new StackResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case StackVersion:\n        return new StackVersionResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case ClusterStackVersion:\n        return new ClusterStackVersionResourceProvider(managementController);\n      case HostStackVersion:\n        return new HostStackVersionResourceProvider(managementController);\n      case StackService:\n        return new StackServiceResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case StackServiceComponent:\n        return new StackServiceComponentResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case StackConfiguration:\n        return new StackConfigurationResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case StackConfigurationDependency:\n        return new StackConfigurationDependencyResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case StackLevelConfiguration:\n        return new StackLevelConfigurationResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case RootService:\n        return new RootServiceResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case RootServiceComponent:\n        return new RootServiceComponentResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case RootServiceHostComponent:\n        return new RootServiceHostComponentResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case ConfigGroup:\n        return new ConfigGroupResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case RequestSchedule:\n        return new RequestScheduleResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case HostComponentProcess:\n        return new HostComponentProcessResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Blueprint:\n        return new BlueprintResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case KerberosDescriptor:\n        return resourceProviderFactory.getKerberosDescriptorResourceProvider(managementController, propertyIds, keyPropertyIds);\n      case Recommendation:\n        return new RecommendationResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Validation:\n        return new ValidationResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case ClientConfig:\n        return new ClientConfigResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case RepositoryVersion:\n        return resourceProviderFactory.getRepositoryVersionResourceProvider();\n      case CompatibleRepositoryVersion:\n        return new CompatibleRepositoryVersionResourceProvider(managementController);\n      case StackArtifact:\n        return new StackArtifactResourceProvider(managementController);\n      case Theme:\n        return new ThemeArtifactResourceProvider(managementController);\n      case QuickLink:\n        return new QuickLinkArtifactResourceProvider(managementController);\n      case ActiveWidgetLayout:\n        return new ActiveWidgetLayoutResourceProvider(managementController);\n      case WidgetLayout:\n        return new WidgetLayoutResourceProvider(managementController);\n      case Widget:\n        return new WidgetResourceProvider(managementController);\n      case HostKerberosIdentity:\n        return resourceProviderFactory.getHostKerberosIdentityResourceProvider(managementController);\n      case Credential:\n        return resourceProviderFactory.getCredentialResourceProvider(managementController);\n      case RoleAuthorization:\n        return new RoleAuthorizationResourceProvider(managementController);\n      case UserAuthorization:\n        return new UserAuthorizationResourceProvider(managementController);\n\n      default:\n        throw new IllegalArgumentException(\"Unknown type \" + type);\n    }\n  }","id":93699,"modified_method":"/**\n   * Factory method for obtaining a resource provider based on a given type and management controller.\n   *\n   * @param type                  the resource type\n   * @param propertyIds           the property ids\n   * @param managementController  the management controller\n   *\n   * @return a new resource provider\n   */\n  public static ResourceProvider getResourceProvider(Resource.Type type,\n                                                     Set<String> propertyIds,\n                                                     Map<Resource.Type, String> keyPropertyIds,\n                                                     AmbariManagementController managementController) {\n\n    switch (type.getInternalType()) {\n      case Cluster:\n        return new ClusterResourceProvider(managementController);\n      case Service:\n        return resourceProviderFactory.getServiceResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Component:\n        return resourceProviderFactory.getComponentResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Host:\n        return resourceProviderFactory.getHostResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case HostComponent:\n        return resourceProviderFactory.getHostComponentResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Configuration:\n        return new ConfigurationResourceProvider(managementController);\n      case ServiceConfigVersion:\n        return new ServiceConfigVersionResourceProvider(managementController);\n      case Action:\n        return new ActionResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Request:\n        return new RequestResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Task:\n        return new TaskResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case User:\n        return new UserResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Group:\n        return new GroupResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Member:\n        return resourceProviderFactory.getMemberResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Upgrade:\n        return resourceProviderFactory.getUpgradeResourceProvider(managementController);\n      case Stack:\n        return new StackResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case StackVersion:\n        return new StackVersionResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case ClusterStackVersion:\n        return new ClusterStackVersionResourceProvider(managementController);\n      case HostStackVersion:\n        return new HostStackVersionResourceProvider(managementController);\n      case StackService:\n        return new StackServiceResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case StackServiceComponent:\n        return new StackServiceComponentResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case StackConfiguration:\n        return new StackConfigurationResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case StackConfigurationDependency:\n        return new StackConfigurationDependencyResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case StackLevelConfiguration:\n        return new StackLevelConfigurationResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case RootService:\n        return new RootServiceResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case RootServiceComponent:\n        return new RootServiceComponentResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case RootServiceHostComponent:\n        return new RootServiceHostComponentResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case ConfigGroup:\n        return new ConfigGroupResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case RequestSchedule:\n        return new RequestScheduleResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case HostComponentProcess:\n        return new HostComponentProcessResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Blueprint:\n        return new BlueprintResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case KerberosDescriptor:\n        return resourceProviderFactory.getKerberosDescriptorResourceProvider(managementController, propertyIds, keyPropertyIds);\n      case Recommendation:\n        return new RecommendationResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case Validation:\n        return new ValidationResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case ClientConfig:\n        return new ClientConfigResourceProvider(propertyIds, keyPropertyIds, managementController);\n      case RepositoryVersion:\n        return resourceProviderFactory.getRepositoryVersionResourceProvider();\n      case CompatibleRepositoryVersion:\n        return new CompatibleRepositoryVersionResourceProvider(managementController);\n      case StackArtifact:\n        return new StackArtifactResourceProvider(managementController);\n      case Theme:\n        return new ThemeArtifactResourceProvider(managementController);\n      case QuickLink:\n        return new QuickLinkArtifactResourceProvider(managementController);\n      case ActiveWidgetLayout:\n        return new ActiveWidgetLayoutResourceProvider(managementController);\n      case WidgetLayout:\n        return new WidgetLayoutResourceProvider(managementController);\n      case Widget:\n        return new WidgetResourceProvider(managementController);\n      case HostKerberosIdentity:\n        return resourceProviderFactory.getHostKerberosIdentityResourceProvider(managementController);\n      case Credential:\n        return resourceProviderFactory.getCredentialResourceProvider(managementController);\n      case RoleAuthorization:\n        return new RoleAuthorizationResourceProvider(managementController);\n      case UserAuthorization:\n        return new UserAuthorizationResourceProvider(managementController);\n      case VersionDefinition:\n        return new VersionDefinitionResourceProvider();\n      default:\n        throw new IllegalArgumentException(\"Unknown type \" + type);\n    }\n  }","commit_id":"986a5188334b51cf5728b4b54c2aefc48866558e","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  protected RequestStatus createResourcesAuthorized(final Request request)\n      throws SystemException,\n      UnsupportedPropertyException,\n      ResourceAlreadyExistsException,\n      NoSuchParentResourceException {\n\n    for (final Map<String, Object> properties : request.getProperties()) {\n      createResources(new Command<Void>() {\n\n        @Override\n        public Void invoke() throws AmbariException {\n          final String[] requiredProperties = {\n            REPOSITORY_VERSION_DISPLAY_NAME_PROPERTY_ID,\n            SUBRESOURCE_OPERATING_SYSTEMS_PROPERTY_ID,\n            REPOSITORY_VERSION_STACK_NAME_PROPERTY_ID,\n            REPOSITORY_VERSION_STACK_VERSION_PROPERTY_ID,\n            REPOSITORY_VERSION_REPOSITORY_VERSION_PROPERTY_ID\n          };\n\n          final RepositoryVersionEntity entity;\n          if (properties.containsKey(REPOSITORY_VERSION_DEFINITION_URL)) {\n            String definitionUrl = (String) properties.get(REPOSITORY_VERSION_DEFINITION_URL);\n\n            entity = toRepositoryVersionEntity(definitionUrl);\n          } else {\n            for (String propertyName : requiredProperties) {\n              if (properties.get(propertyName) == null) {\n                throw new AmbariException(\"Property \" + propertyName + \" should be provided\");\n              }\n            }\n            entity = toRepositoryVersionEntity(properties);\n          }\n\n          if (repositoryVersionDAO.findByDisplayName(entity.getDisplayName()) != null) {\n            throw new AmbariException(\"Repository version with name \" + entity.getDisplayName() + \" already exists\");\n          }\n          if (repositoryVersionDAO.findByStackAndVersion(entity.getStack(), entity.getVersion()) != null) {\n            throw new AmbariException(\"Repository version for stack \" + entity.getStack() + \" and version \" + entity.getVersion() + \" already exists\");\n          }\n\n          validateRepositoryVersion(entity);\n          repositoryVersionDAO.create(entity);\n          notifyCreate(Resource.Type.RepositoryVersion, request);\n          return null;\n        }\n      });\n    }\n\n    return getRequestStatus(null);\n  }","id":93700,"modified_method":"@Override\n  protected RequestStatus createResourcesAuthorized(final Request request)\n      throws SystemException,\n      UnsupportedPropertyException,\n      ResourceAlreadyExistsException,\n      NoSuchParentResourceException {\n\n    for (final Map<String, Object> properties : request.getProperties()) {\n      createResources(new Command<Void>() {\n\n        @Override\n        public Void invoke() throws AmbariException {\n          final String[] requiredProperties = {\n            REPOSITORY_VERSION_DISPLAY_NAME_PROPERTY_ID,\n            SUBRESOURCE_OPERATING_SYSTEMS_PROPERTY_ID,\n            REPOSITORY_VERSION_STACK_NAME_PROPERTY_ID,\n            REPOSITORY_VERSION_STACK_VERSION_PROPERTY_ID,\n            REPOSITORY_VERSION_REPOSITORY_VERSION_PROPERTY_ID\n          };\n\n          for (String propertyName : requiredProperties) {\n            if (properties.get(propertyName) == null) {\n              throw new AmbariException(\"Property \" + propertyName + \" should be provided\");\n            }\n          }\n\n          RepositoryVersionEntity entity = toRepositoryVersionEntity(properties);\n\n          if (repositoryVersionDAO.findByDisplayName(entity.getDisplayName()) != null) {\n            throw new AmbariException(\"Repository version with name \" + entity.getDisplayName() + \" already exists\");\n          }\n          if (repositoryVersionDAO.findByStackAndVersion(entity.getStack(), entity.getVersion()) != null) {\n            throw new AmbariException(\"Repository version for stack \" + entity.getStack() + \" and version \" + entity.getVersion() + \" already exists\");\n          }\n\n          if (!upgradePackExists(entity.getVersion())) {\n            throw new AmbariException(\"Stack \" + entity.getStackId() + \" doesn't have upgrade packages\");\n          }\n\n          validateRepositoryVersion(repositoryVersionDAO, ambariMetaInfo, entity);\n\n          repositoryVersionDAO.create(entity);\n          notifyCreate(Resource.Type.RepositoryVersion, request);\n          return null;\n        }\n      });\n    }\n\n    return getRequestStatus(null);\n  }","commit_id":"986a5188334b51cf5728b4b54c2aefc48866558e","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  @Transactional\n  protected RequestStatus updateResourcesAuthorized(Request request, Predicate predicate)\n    throws SystemException, UnsupportedPropertyException, NoSuchResourceException, NoSuchParentResourceException {\n    final Set<Map<String, Object>> propertyMaps = request.getProperties();\n\n    modifyResources(new Command<Void>() {\n      @Override\n      public Void invoke() throws AmbariException, AuthorizationException {\n        for (Map<String, Object> propertyMap : propertyMaps) {\n          final Long id;\n          try {\n            id = Long.parseLong(propertyMap.get(REPOSITORY_VERSION_ID_PROPERTY_ID).toString());\n          } catch (Exception ex) {\n            throw new AmbariException(\"Repository version should have numerical id\");\n          }\n\n          final RepositoryVersionEntity entity = repositoryVersionDAO.findByPK(id);\n          if (entity == null) {\n            throw new ObjectNotFoundException(\"There is no repository version with id \" + id);\n          }\n\n          List<OperatingSystemEntity> operatingSystemEntities = null;\n\n          if (StringUtils.isNotBlank(ObjectUtils.toString(propertyMap.get(SUBRESOURCE_OPERATING_SYSTEMS_PROPERTY_ID)))) {\n            if (!AuthorizationHelper.isAuthorized(ResourceType.AMBARI, null, RoleAuthorization.AMBARI_EDIT_STACK_REPOS)) {\n              throw new AuthorizationException(\"The authenticated user does not have authorization to modify stack repositories\");\n            }\n\n            final Object operatingSystems = propertyMap.get(SUBRESOURCE_OPERATING_SYSTEMS_PROPERTY_ID);\n            final String operatingSystemsJson = gson.toJson(operatingSystems);\n            try {\n              operatingSystemEntities = repositoryVersionHelper.parseOperatingSystems(operatingSystemsJson);\n            } catch (Exception ex) {\n              throw new AmbariException(\"Json structure for operating systems is incorrect\", ex);\n            }\n            entity.setOperatingSystems(operatingSystemsJson);\n          }\n\n          if (StringUtils.isNotBlank(ObjectUtils.toString(propertyMap.get(REPOSITORY_VERSION_DISPLAY_NAME_PROPERTY_ID)))) {\n            entity.setDisplayName(propertyMap.get(REPOSITORY_VERSION_DISPLAY_NAME_PROPERTY_ID).toString());\n          }\n\n          validateRepositoryVersion(entity);\n          repositoryVersionDAO.merge(entity);\n\n          //\n          // Update metaInfo table as well\n          //\n          if (operatingSystemEntities != null) {\n            String entityStackName = entity.getStackName();\n            String entityStackVersion = entity.getStackVersion();\n            for (OperatingSystemEntity osEntity : operatingSystemEntities) {\n              List<RepositoryEntity> repositories = osEntity.getRepositories();\n              for (RepositoryEntity repository : repositories) {\n                ambariMetaInfo.updateRepoBaseURL(entityStackName, entityStackVersion, osEntity.getOsType(), repository.getRepositoryId(), repository.getBaseUrl());\n              }\n            }\n          }\n        }\n        return null;\n      }\n    });\n\n    return getRequestStatus(null);\n  }","id":93701,"modified_method":"@Override\n  @Transactional\n  protected RequestStatus updateResourcesAuthorized(Request request, Predicate predicate)\n    throws SystemException, UnsupportedPropertyException, NoSuchResourceException, NoSuchParentResourceException {\n    final Set<Map<String, Object>> propertyMaps = request.getProperties();\n\n    modifyResources(new Command<Void>() {\n      @Override\n      public Void invoke() throws AmbariException, AuthorizationException {\n        for (Map<String, Object> propertyMap : propertyMaps) {\n          final Long id;\n          try {\n            id = Long.parseLong(propertyMap.get(REPOSITORY_VERSION_ID_PROPERTY_ID).toString());\n          } catch (Exception ex) {\n            throw new AmbariException(\"Repository version should have numerical id\");\n          }\n\n          final RepositoryVersionEntity entity = repositoryVersionDAO.findByPK(id);\n          if (entity == null) {\n            throw new ObjectNotFoundException(\"There is no repository version with id \" + id);\n          }\n\n          List<OperatingSystemEntity> operatingSystemEntities = null;\n\n          if (StringUtils.isNotBlank(ObjectUtils.toString(propertyMap.get(SUBRESOURCE_OPERATING_SYSTEMS_PROPERTY_ID)))) {\n            if (!AuthorizationHelper.isAuthorized(ResourceType.AMBARI, null, RoleAuthorization.AMBARI_EDIT_STACK_REPOS)) {\n              throw new AuthorizationException(\"The authenticated user does not have authorization to modify stack repositories\");\n            }\n\n            final Object operatingSystems = propertyMap.get(SUBRESOURCE_OPERATING_SYSTEMS_PROPERTY_ID);\n            final String operatingSystemsJson = gson.toJson(operatingSystems);\n            try {\n              operatingSystemEntities = repositoryVersionHelper.parseOperatingSystems(operatingSystemsJson);\n            } catch (Exception ex) {\n              throw new AmbariException(\"Json structure for operating systems is incorrect\", ex);\n            }\n            entity.setOperatingSystems(operatingSystemsJson);\n          }\n\n          if (StringUtils.isNotBlank(ObjectUtils.toString(propertyMap.get(REPOSITORY_VERSION_DISPLAY_NAME_PROPERTY_ID)))) {\n            entity.setDisplayName(propertyMap.get(REPOSITORY_VERSION_DISPLAY_NAME_PROPERTY_ID).toString());\n          }\n\n          if (!upgradePackExists(entity.getVersion())) {\n            throw new AmbariException(\"Stack \" + entity.getStackId() + \" doesn't have upgrade packages\");\n          }\n\n          validateRepositoryVersion(repositoryVersionDAO, ambariMetaInfo, entity);\n\n          repositoryVersionDAO.merge(entity);\n\n          //\n          // Update metaInfo table as well\n          //\n          if (operatingSystemEntities != null) {\n            String entityStackName = entity.getStackName();\n            String entityStackVersion = entity.getStackVersion();\n            for (OperatingSystemEntity osEntity : operatingSystemEntities) {\n              List<RepositoryEntity> repositories = osEntity.getRepositories();\n              for (RepositoryEntity repository : repositories) {\n                ambariMetaInfo.updateRepoBaseURL(entityStackName, entityStackVersion, osEntity.getOsType(), repository.getRepositoryId(), repository.getBaseUrl());\n              }\n            }\n          }\n        }\n        return null;\n      }\n    });\n\n    return getRequestStatus(null);\n  }","commit_id":"986a5188334b51cf5728b4b54c2aefc48866558e","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Validates newly created repository versions to contain actual information.\n   *\n   * @param repositoryVersion repository version\n   * @throws AmbariException exception with error message\n   */\n  protected void validateRepositoryVersion(RepositoryVersionEntity repositoryVersion) throws AmbariException {\n    final StackId requiredStack = new StackId(repositoryVersion.getStack());\n\n    final String requiredStackName = requiredStack.getStackName();\n    final String requiredStackVersion = requiredStack.getStackVersion();\n    final String requiredStackId = requiredStack.getStackId();\n\n    if (!upgradePackExists(repositoryVersion.getVersion())) {\n      throw new AmbariException(\"Stack \" + requiredStackId + \" doesn't have upgrade packages\");\n    }\n\n    // List of all repo urls that are already added at stack\n    Set<String> existingRepoUrls = new HashSet<String>();\n    List<RepositoryVersionEntity> existingRepoVersions = repositoryVersionDAO.findByStack(requiredStack);\n    for (RepositoryVersionEntity existingRepoVersion : existingRepoVersions) {\n      for (OperatingSystemEntity operatingSystemEntity : existingRepoVersion.getOperatingSystems()) {\n        for (RepositoryEntity repositoryEntity : operatingSystemEntity.getRepositories()) {\n          if (! repositoryEntity.getRepositoryId().startsWith(\"HDP-UTILS\") &&  // HDP-UTILS is shared between repo versions\n                  ! existingRepoVersion.getId().equals(repositoryVersion.getId())) { // Allow modifying already defined repo version\n            existingRepoUrls.add(repositoryEntity.getBaseUrl());\n          }\n        }\n      }\n    }\n\n    // check that repositories contain only supported operating systems\n    final Set<String> osSupported = new HashSet<String>();\n    for (OperatingSystemInfo osInfo: ambariMetaInfo.getOperatingSystems(requiredStackName, requiredStackVersion)) {\n      osSupported.add(osInfo.getOsType());\n    }\n    final Set<String> osRepositoryVersion = new HashSet<String>();\n    for (OperatingSystemEntity os: repositoryVersion.getOperatingSystems()) {\n      osRepositoryVersion.add(os.getOsType());\n\n      for (RepositoryEntity repositoryEntity : os.getRepositories()) {\n        String baseUrl = repositoryEntity.getBaseUrl();\n        if (existingRepoUrls.contains(baseUrl)) {\n          throw new AmbariException(\"Base url \" + baseUrl + \" is already defined for another repository version. \" +\n                  \"Setting up base urls that contain the same versions of components will cause stack upgrade to fail.\");\n        }\n      }\n    }\n    if (osRepositoryVersion.isEmpty()) {\n      throw new AmbariException(\"At least one set of repositories for OS should be provided\");\n    }\n    for (String os: osRepositoryVersion) {\n      if (!osSupported.contains(os)) {\n        throw new AmbariException(\"Operating system type \" + os + \" is not supported by stack \" + requiredStackId);\n      }\n    }\n\n    if (!RepositoryVersionEntity.isVersionInStack(repositoryVersion.getStackId(), repositoryVersion.getVersion())) {\n      throw new AmbariException(MessageFormat.format(\"Version {0} needs to belong to stack {1}\",\n          repositoryVersion.getVersion(), repositoryVersion.getStackName() + \"-\" + repositoryVersion.getStackVersion()));\n    }\n  }","id":93702,"modified_method":"/**\n   * Validates newly created repository versions to contain actual information.\n   *\n   * @param repositoryVersion repository version\n   * @throws AmbariException exception with error message\n   */\n  protected static void validateRepositoryVersion(RepositoryVersionDAO dao,\n      AmbariMetaInfo metaInfo, RepositoryVersionEntity repositoryVersion) throws AmbariException {\n    final StackId requiredStack = new StackId(repositoryVersion.getStack());\n\n    final String requiredStackName = requiredStack.getStackName();\n    final String requiredStackVersion = requiredStack.getStackVersion();\n    final String requiredStackId = requiredStack.getStackId();\n\n    // List of all repo urls that are already added at stack\n    Set<String> existingRepoUrls = new HashSet<String>();\n    List<RepositoryVersionEntity> existingRepoVersions = dao.findByStack(requiredStack);\n    for (RepositoryVersionEntity existingRepoVersion : existingRepoVersions) {\n      for (OperatingSystemEntity operatingSystemEntity : existingRepoVersion.getOperatingSystems()) {\n        for (RepositoryEntity repositoryEntity : operatingSystemEntity.getRepositories()) {\n          if (! repositoryEntity.getRepositoryId().startsWith(\"HDP-UTILS\") &&  // HDP-UTILS is shared between repo versions\n                  ! existingRepoVersion.getId().equals(repositoryVersion.getId())) { // Allow modifying already defined repo version\n            existingRepoUrls.add(repositoryEntity.getBaseUrl());\n          }\n        }\n      }\n    }\n\n    // check that repositories contain only supported operating systems\n    final Set<String> osSupported = new HashSet<String>();\n    for (OperatingSystemInfo osInfo: metaInfo.getOperatingSystems(requiredStackName, requiredStackVersion)) {\n      osSupported.add(osInfo.getOsType());\n    }\n\n    final Set<String> osRepositoryVersion = new HashSet<String>();\n    for (OperatingSystemEntity os: repositoryVersion.getOperatingSystems()) {\n      osRepositoryVersion.add(os.getOsType());\n\n      for (RepositoryEntity repositoryEntity : os.getRepositories()) {\n        String baseUrl = repositoryEntity.getBaseUrl();\n        if (existingRepoUrls.contains(baseUrl)) {\n          throw new AmbariException(\"Base url \" + baseUrl + \" is already defined for another repository version. \" +\n                  \"Setting up base urls that contain the same versions of components will cause stack upgrade to fail.\");\n        }\n      }\n    }\n    if (osRepositoryVersion.isEmpty()) {\n      throw new AmbariException(\"At least one set of repositories for OS should be provided\");\n    }\n    for (String os: osRepositoryVersion) {\n      if (!osSupported.contains(os)) {\n        throw new AmbariException(\"Operating system type \" + os + \" is not supported by stack \" + requiredStackId);\n      }\n    }\n\n    if (!RepositoryVersionEntity.isVersionInStack(repositoryVersion.getStackId(), repositoryVersion.getVersion())) {\n      throw new AmbariException(MessageFormat.format(\"Version {0} needs to belong to stack {1}\",\n          repositoryVersion.getVersion(), repositoryVersion.getStackName() + \"-\" + repositoryVersion.getStackVersion()));\n    }\n  }","commit_id":"986a5188334b51cf5728b4b54c2aefc48866558e","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testCreateResourcesWithUrl() throws Exception {\n    Authentication authentication = TestAuthenticationFactory.createAdministrator();\n    SecurityContextHolder.getContext().setAuthentication(authentication);\n\n    File file = new File(\"src/test/resources/version_definition_resource_provider.xml\");\n\n    final ResourceProvider provider = injector.getInstance(ResourceProviderFactory.class).getRepositoryVersionResourceProvider();\n\n    final Set<Map<String, Object>> propertySet = new LinkedHashSet<Map<String, Object>>();\n    final Map<String, Object> properties = new LinkedHashMap<String, Object>();\n    properties.put(RepositoryVersionResourceProvider.REPOSITORY_VERSION_DISPLAY_NAME_PROPERTY_ID, \"name\");\n    properties.put(RepositoryVersionResourceProvider.REPOSITORY_VERSION_DEFINITION_URL, file.toURI().toURL().toString());\n    propertySet.add(properties);\n\n    final Predicate predicateStackName = new PredicateBuilder().property(RepositoryVersionResourceProvider.REPOSITORY_VERSION_STACK_NAME_PROPERTY_ID).equals(\"HDP\").toPredicate();\n    final Predicate predicateStackVersion = new PredicateBuilder().property(RepositoryVersionResourceProvider.REPOSITORY_VERSION_STACK_VERSION_PROPERTY_ID).equals(\"1.1\").toPredicate();\n    Request getRequest = PropertyHelper.getReadRequest(RepositoryVersionResourceProvider.REPOSITORY_VERSION_DISPLAY_NAME_PROPERTY_ID);\n    Assert.assertEquals(0, provider.getResources(getRequest, new AndPredicate(predicateStackName, predicateStackVersion)).size());\n\n    final Request createRequest = PropertyHelper.getCreateRequest(propertySet, null);\n    provider.createResources(createRequest);\n\n    Set<Resource> results = provider.getResources(getRequest, new AndPredicate(predicateStackName, predicateStackVersion));\n    Assert.assertEquals(1, results.size());\n\n    getRequest = PropertyHelper.getReadRequest(\n        RepositoryVersionResourceProvider.REPOSITORY_VERSION_DISPLAY_NAME_PROPERTY_ID,\n        RepositoryVersionResourceProvider.REPOSITORY_VERSION_ID_PROPERTY_ID,\n        RepositoryVersionResourceProvider.REPOSITORY_VERSION_REPOSITORY_VERSION_PROPERTY_ID,\n        RepositoryVersionResourceProvider.REPOSITORY_VERSION_STACK_NAME_PROPERTY_ID,\n        RepositoryVersionResourceProvider.REPOSITORY_VERSION_STACK_VERSION_PROPERTY_ID,\n        \"RepositoryVersions/release\",\n        \"RepositoryVersions/services\",\n        RepositoryVersionResourceProvider.SUBRESOURCE_OPERATING_SYSTEMS_PROPERTY_ID,\n        RepositoryVersionResourceProvider.SUBRESOURCE_REPOSITORIES_PROPERTY_ID);\n\n    results = provider.getResources(getRequest, new AndPredicate(predicateStackName, predicateStackVersion));\n    Assert.assertEquals(1, results.size());\n\n    Resource r = results.iterator().next();\n    Map<String, Map<String, Object>> map = r.getPropertiesMap();\n    Assert.assertTrue(map.containsKey(\"RepositoryVersions\"));\n\n    Map<String, Object> vals = map.get(\"RepositoryVersions\");\n    Assert.assertEquals(\"1.1.7.1-1234\", vals.get(\"repository_version\"));\n\n    Assert.assertTrue(map.containsKey(\"RepositoryVersions/release\"));\n    vals = map.get(\"RepositoryVersions/release\");\n    Assert.assertEquals(\"1234\", vals.get(\"build\"));\n    Assert.assertEquals(\"2.3.4.[1-9]\", vals.get(\"compatible_with\"));\n    Assert.assertEquals(\"http://docs.hortonworks.com/HDPDocuments/HDP2/HDP-2.3.4/\", vals.get(\"notes\"));\n  }","id":93703,"modified_method":"@Test\n  public void testCreateResourcesWithUrl() throws Exception {\n    Authentication authentication = TestAuthenticationFactory.createAdministrator();\n    SecurityContextHolder.getContext().setAuthentication(authentication);\n\n    File file = new File(\"src/test/resources/version_definition_resource_provider.xml\");\n\n    final ResourceProvider versionProvider = new VersionDefinitionResourceProvider();\n    final ResourceProvider provider = injector.getInstance(ResourceProviderFactory.class).getRepositoryVersionResourceProvider();\n\n    final Set<Map<String, Object>> propertySet = new LinkedHashSet<Map<String, Object>>();\n    final Map<String, Object> properties = new LinkedHashMap<String, Object>();\n    properties.put(VersionDefinitionResourceProvider.VERSION_DEF_DEFINITION_URL, file.toURI().toURL().toString());\n    propertySet.add(properties);\n\n    final Predicate predicateStackName = new PredicateBuilder().property(RepositoryVersionResourceProvider.REPOSITORY_VERSION_STACK_NAME_PROPERTY_ID).equals(\"HDP\").toPredicate();\n    final Predicate predicateStackVersion = new PredicateBuilder().property(RepositoryVersionResourceProvider.REPOSITORY_VERSION_STACK_VERSION_PROPERTY_ID).equals(\"1.1\").toPredicate();\n    Request getRequest = PropertyHelper.getReadRequest(RepositoryVersionResourceProvider.REPOSITORY_VERSION_DISPLAY_NAME_PROPERTY_ID);\n    Assert.assertEquals(0, provider.getResources(getRequest, new AndPredicate(predicateStackName, predicateStackVersion)).size());\n\n    final Request createRequest = PropertyHelper.getCreateRequest(propertySet, null);\n    RequestStatus status = versionProvider.createResources(createRequest);\n    Assert.assertEquals(1, status.getAssociatedResources().size());\n\n    getRequest = PropertyHelper.getReadRequest(\"VersionDefinition\");\n    Set<Resource> results = versionProvider.getResources(getRequest, null);\n    Assert.assertEquals(1, results.size());\n\n    results = provider.getResources(getRequest, new AndPredicate(predicateStackName, predicateStackVersion));\n    Assert.assertEquals(1, results.size());\n\n    getRequest = PropertyHelper.getReadRequest(\n        RepositoryVersionResourceProvider.REPOSITORY_VERSION_DISPLAY_NAME_PROPERTY_ID,\n        RepositoryVersionResourceProvider.REPOSITORY_VERSION_ID_PROPERTY_ID,\n        RepositoryVersionResourceProvider.REPOSITORY_VERSION_REPOSITORY_VERSION_PROPERTY_ID,\n        RepositoryVersionResourceProvider.REPOSITORY_VERSION_STACK_NAME_PROPERTY_ID,\n        RepositoryVersionResourceProvider.REPOSITORY_VERSION_STACK_VERSION_PROPERTY_ID,\n        \"RepositoryVersions/release\",\n        \"RepositoryVersions/services\",\n        RepositoryVersionResourceProvider.SUBRESOURCE_OPERATING_SYSTEMS_PROPERTY_ID,\n        RepositoryVersionResourceProvider.SUBRESOURCE_REPOSITORIES_PROPERTY_ID);\n\n    results = provider.getResources(getRequest, new AndPredicate(predicateStackName, predicateStackVersion));\n    Assert.assertEquals(1, results.size());\n\n    Resource r = results.iterator().next();\n    Map<String, Map<String, Object>> map = r.getPropertiesMap();\n    Assert.assertTrue(map.containsKey(\"RepositoryVersions\"));\n\n    Map<String, Object> vals = map.get(\"RepositoryVersions\");\n    Assert.assertEquals(\"1.1.7.1-1234\", vals.get(\"repository_version\"));\n\n    Assert.assertTrue(map.containsKey(\"RepositoryVersions/release\"));\n    vals = map.get(\"RepositoryVersions/release\");\n    Assert.assertEquals(\"1234\", vals.get(\"build\"));\n    Assert.assertEquals(\"2.3.4.[1-9]\", vals.get(\"compatible_with\"));\n    Assert.assertEquals(\"http://docs.hortonworks.com/HDPDocuments/HDP2/HDP-2.3.4/\", vals.get(\"notes\"));\n  }","commit_id":"986a5188334b51cf5728b4b54c2aefc48866558e","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testValidateRepositoryVersion() throws Exception {\n    StackDAO stackDAO = injector.getInstance(StackDAO.class);\n    StackEntity stackEntity = stackDAO.find(\"HDP\", \"1.1\");\n    Assert.assertNotNull(stackEntity);\n\n    final RepositoryVersionResourceProvider provider = (RepositoryVersionResourceProvider) injector.getInstance(ResourceProviderFactory.class).getRepositoryVersionResourceProvider();\n\n    final RepositoryVersionEntity entity = new RepositoryVersionEntity();\n    entity.setDisplayName(\"name\");\n    entity.setStack(stackEntity);\n    entity.setVersion(\"1.1\");\n    entity.setOperatingSystems(\"[{\\\"OperatingSystems/os_type\\\":\\\"redhat6\\\",\\\"repositories\\\":[{\\\"Repositories/repo_id\\\":\\\"1\\\",\\\"Repositories/repo_name\\\":\\\"1\\\",\\\"Repositories/base_url\\\":\\\"http://example.com/repo1\\\"}]}]\");\n\n    // test valid usecases\n    provider.validateRepositoryVersion(entity);\n    entity.setVersion(\"1.1-17\");\n    provider.validateRepositoryVersion(entity);\n    entity.setVersion(\"1.1.1.1\");\n    provider.validateRepositoryVersion(entity);\n    entity.setVersion(\"1.1.343432.2\");\n    provider.validateRepositoryVersion(entity);\n    entity.setVersion(\"1.1.343432.2-234234324\");\n    provider.validateRepositoryVersion(entity);\n\n    // test invalid usecases\n    entity.setOperatingSystems(jsonStringRedhat7);\n    try {\n      provider.validateRepositoryVersion(entity);\n      Assert.fail(\"Should throw exception\");\n    } catch (Exception ex) {\n    }\n\n    entity.setOperatingSystems(\"\");\n    try {\n      provider.validateRepositoryVersion(entity);\n      Assert.fail(\"Should throw exception\");\n    } catch (Exception ex) {\n    }\n\n    StackEntity bigtop = new StackEntity();\n    stackEntity.setStackName(\"BIGTOP\");\n    entity.setStack(bigtop);\n    try {\n      provider.validateRepositoryVersion(entity);\n      Assert.fail(\"Should throw exception\");\n    } catch (Exception ex) {\n    }\n\n    final RepositoryVersionDAO repositoryVersionDAO = injector.getInstance(RepositoryVersionDAO.class);\n    entity.setDisplayName(\"name\");\n    entity.setStack(stackEntity);\n    entity.setVersion(\"1.1\");\n    entity.setOperatingSystems(\"[{\\\"OperatingSystems/os_type\\\":\\\"redhat6\\\",\\\"repositories\\\":[{\\\"Repositories/repo_id\\\":\\\"1\\\",\\\"Repositories/repo_name\\\":\\\"1\\\",\\\"Repositories/base_url\\\":\\\"http://example.com/repo1\\\"}]}]\");\n    repositoryVersionDAO.create(entity);\n\n    final RepositoryVersionEntity entity2 = new RepositoryVersionEntity();\n    entity2.setId(2l);\n    entity2.setDisplayName(\"name2\");\n    entity2.setStack(stackEntity);\n    entity2.setVersion(\"1.2\");\n    entity2.setOperatingSystems(\"[{\\\"OperatingSystems/os_type\\\":\\\"redhat6\\\",\\\"repositories\\\":[{\\\"Repositories/repo_id\\\":\\\"1\\\",\\\"Repositories/repo_name\\\":\\\"1\\\",\\\"Repositories/base_url\\\":\\\"http://example.com/repo1\\\"}]}]\");\n\n    try {\n      provider.validateRepositoryVersion(entity2);\n      Assert.fail(\"Should throw exception: Base url http://example.com/repo1 is already defined for another repository version\");\n    } catch (Exception ex) {\n    }\n\n  }","id":93704,"modified_method":"@Test\n  public void testValidateRepositoryVersion() throws Exception {\n    StackDAO stackDAO = injector.getInstance(StackDAO.class);\n    StackEntity stackEntity = stackDAO.find(\"HDP\", \"1.1\");\n    Assert.assertNotNull(stackEntity);\n\n    final RepositoryVersionEntity entity = new RepositoryVersionEntity();\n    entity.setDisplayName(\"name\");\n    entity.setStack(stackEntity);\n    entity.setVersion(\"1.1\");\n    entity.setOperatingSystems(\"[{\\\"OperatingSystems/os_type\\\":\\\"redhat6\\\",\\\"repositories\\\":[{\\\"Repositories/repo_id\\\":\\\"1\\\",\\\"Repositories/repo_name\\\":\\\"1\\\",\\\"Repositories/base_url\\\":\\\"http://example.com/repo1\\\"}]}]\");\n\n    final RepositoryVersionDAO repositoryVersionDAO = injector.getInstance(RepositoryVersionDAO.class);\n    AmbariMetaInfo info = injector.getInstance(AmbariMetaInfo.class);\n\n    // test valid usecases\n    RepositoryVersionResourceProvider.validateRepositoryVersion(repositoryVersionDAO, info, entity);\n    entity.setVersion(\"1.1-17\");\n    RepositoryVersionResourceProvider.validateRepositoryVersion(repositoryVersionDAO, info, entity);\n    entity.setVersion(\"1.1.1.1\");\n    RepositoryVersionResourceProvider.validateRepositoryVersion(repositoryVersionDAO, info, entity);\n    entity.setVersion(\"1.1.343432.2\");\n    RepositoryVersionResourceProvider.validateRepositoryVersion(repositoryVersionDAO, info, entity);\n    entity.setVersion(\"1.1.343432.2-234234324\");\n    RepositoryVersionResourceProvider.validateRepositoryVersion(repositoryVersionDAO, info, entity);\n\n    // test invalid usecases\n    entity.setOperatingSystems(jsonStringRedhat7);\n    try {\n      RepositoryVersionResourceProvider.validateRepositoryVersion(repositoryVersionDAO, info, entity);\n      Assert.fail(\"Should throw exception\");\n    } catch (Exception ex) {\n    }\n\n    entity.setOperatingSystems(\"\");\n    try {\n      RepositoryVersionResourceProvider.validateRepositoryVersion(repositoryVersionDAO, info, entity);\n      Assert.fail(\"Should throw exception\");\n    } catch (Exception ex) {\n    }\n\n    StackEntity bigtop = new StackEntity();\n    stackEntity.setStackName(\"BIGTOP\");\n    entity.setStack(bigtop);\n    try {\n      RepositoryVersionResourceProvider.validateRepositoryVersion(repositoryVersionDAO, info, entity);\n      Assert.fail(\"Should throw exception\");\n    } catch (Exception ex) {\n    }\n\n\n    entity.setDisplayName(\"name\");\n    entity.setStack(stackEntity);\n    entity.setVersion(\"1.1\");\n    entity.setOperatingSystems(\"[{\\\"OperatingSystems/os_type\\\":\\\"redhat6\\\",\\\"repositories\\\":[{\\\"Repositories/repo_id\\\":\\\"1\\\",\\\"Repositories/repo_name\\\":\\\"1\\\",\\\"Repositories/base_url\\\":\\\"http://example.com/repo1\\\"}]}]\");\n    repositoryVersionDAO.create(entity);\n\n    final RepositoryVersionEntity entity2 = new RepositoryVersionEntity();\n    entity2.setId(2l);\n    entity2.setDisplayName(\"name2\");\n    entity2.setStack(stackEntity);\n    entity2.setVersion(\"1.2\");\n    entity2.setOperatingSystems(\"[{\\\"OperatingSystems/os_type\\\":\\\"redhat6\\\",\\\"repositories\\\":[{\\\"Repositories/repo_id\\\":\\\"1\\\",\\\"Repositories/repo_name\\\":\\\"1\\\",\\\"Repositories/base_url\\\":\\\"http://example.com/repo1\\\"}]}]\");\n\n    try {\n      RepositoryVersionResourceProvider.validateRepositoryVersion(repositoryVersionDAO, info, entity2);\n      Assert.fail(\"Should throw exception: Base url http://example.com/repo1 is already defined for another repository version\");\n    } catch (Exception ex) {\n    }\n\n  }","commit_id":"986a5188334b51cf5728b4b54c2aefc48866558e","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Get a resource definition for the given type.\n   *\n   * @param type    the resource type\n   * @param mapIds  the map of ids\n   *\n   * @return the resource definition\n   */\n  public static ResourceDefinition getResourceDefinition(Resource.Type type, Map<Resource.Type, String> mapIds) {\n    ResourceDefinition resourceDefinition;\n\n    // Check to see if there is an external resource definition registered for the given type.\n    if (resourceDefinitions.containsKey(type)) {\n      return resourceDefinitions.get(type);\n    }\n\n    //todo: consider ResourceDependencyManager : Map<Resource.Type, ResourceDefinition>\n    switch (type.getInternalType()) {\n      case Cluster:\n        resourceDefinition = new ClusterResourceDefinition();\n        break;\n\n      case Service:\n        resourceDefinition = new ServiceResourceDefinition();\n        break;\n\n      case Host:\n        resourceDefinition = mapIds.containsKey(Resource.Type.Cluster) ?\n            new HostResourceDefinition() : new DetachedHostResourceDefinition();\n        break;\n\n      case Component:\n        resourceDefinition = new ComponentResourceDefinition();\n        break;\n\n      case HostComponent:\n        resourceDefinition = new HostComponentResourceDefinition();\n        break;\n\n      case Action:\n        resourceDefinition = new ActionResourceDefinition();\n        break;\n\n      case Configuration:\n        resourceDefinition = new ConfigurationResourceDefinition();\n        break;\n\n      case ServiceConfigVersion:\n        resourceDefinition = new ServiceConfigVersionResourceDefinition();\n        break;\n\n      case Task:\n        resourceDefinition = new TaskResourceDefinition();\n        break;\n\n      case User:\n        resourceDefinition = new UserResourceDefinition();\n        break;\n\n      case Group:\n        resourceDefinition = new GroupResourceDefinition();\n        break;\n\n      case Member:\n        resourceDefinition = new MemberResourceDefinition();\n        break;\n\n      case Request:\n        resourceDefinition = new RequestResourceDefinition();\n        break;\n\n      case Stack:\n        resourceDefinition = new StackResourceDefinition();\n        break;\n\n      case StackVersion:\n        resourceDefinition = new StackVersionResourceDefinition();\n        break;\n\n      case StackLevelConfiguration:\n        resourceDefinition = new StackLevelConfigurationResourceDefinition();\n        break;\n\n      case StackService:\n        resourceDefinition = new StackServiceResourceDefinition();\n        break;\n\n      case StackServiceComponent:\n        resourceDefinition = new StackServiceComponentResourceDefinition();\n        break;\n\n      case StackServiceComponentDependency:\n        resourceDefinition = new StackDependencyResourceDefinition();\n        break;\n\n      case StackConfiguration:\n        resourceDefinition = new StackConfigurationResourceDefinition();\n        break;\n\n      case StackConfigurationDependency:\n        resourceDefinition = new StackConfigurationDependencyResourceDefinition();\n        break;\n\n      case OperatingSystem:\n        resourceDefinition = new OperatingSystemResourceDefinition();\n        break;\n\n      case Repository:\n        resourceDefinition = new RepositoryResourceDefinition();\n        break;\n\n      case DRFeed:\n        resourceDefinition = new FeedResourceDefinition();\n        break;\n\n      case DRTargetCluster:\n        resourceDefinition = new TargetClusterResourceDefinition();\n        break;\n\n      case DRInstance:\n        resourceDefinition = new InstanceResourceDefinition();\n        break;\n\n      case Workflow:\n        resourceDefinition = new WorkflowResourceDefinition();\n        break;\n\n      case Job:\n        resourceDefinition = new JobResourceDefinition();\n        break;\n\n      case TaskAttempt:\n        resourceDefinition = new TaskAttemptResourceDefinition();\n        break;\n\n      case RootService:\n        resourceDefinition = new RootServiceResourceDefinition();\n        break;\n\n      case RootServiceComponent:\n        resourceDefinition = new RootServiceComponentResourceDefinition();\n        break;\n\n      case RootServiceHostComponent:\n        resourceDefinition = new RootServiceHostComponentResourceDefinition();\n        break;\n\n      case ConfigGroup:\n        resourceDefinition = new ConfigGroupResourceDefinition();\n        break;\n\n      case RequestSchedule:\n        resourceDefinition = new RequestScheduleResourceDefinition();\n        break;\n\n      case View:\n        resourceDefinition = new ViewResourceDefinition();\n        break;\n\n      case ViewVersion:\n        resourceDefinition = new ViewVersionResourceDefinition();\n        break;\n\n      case ViewInstance:\n        String viewName = mapIds.get(Resource.Type.View);\n        String version  = mapIds.get(Resource.Type.ViewVersion);\n\n        Set<SubResourceDefinition> subResourceDefinitions = (viewName == null || version == null)  ?\n            Collections.<SubResourceDefinition>emptySet() :\n            ViewRegistry.getInstance().getSubResourceDefinitions(viewName, version);\n\n        resourceDefinition = new ViewInstanceResourceDefinition(subResourceDefinitions);\n        break;\n\n      case Blueprint:\n        resourceDefinition = new BlueprintResourceDefinition();\n        break;\n\n      case Recommendation:\n        resourceDefinition = new RecommendationResourceDefinition();\n        break;\n\n      case Validation:\n        resourceDefinition = new ValidationResourceDefinition();\n        break;\n\n      case HostComponentProcess:\n        resourceDefinition = new HostComponentProcessResourceDefinition();\n        break;\n\n      case Permission:\n        resourceDefinition = new PermissionResourceDefinition();\n        break;\n\n      case Alert:\n        resourceDefinition = new AlertResourceDefinition();\n        break;\n\n      case AlertDefinition:\n        resourceDefinition = new AlertDefResourceDefinition();\n        break;\n\n      case AlertHistory:\n        resourceDefinition = new AlertHistoryResourceDefinition();\n        break;\n\n      case AlertGroup:\n        resourceDefinition = new AlertGroupResourceDefinition();\n        break;\n\n      case AlertTarget:\n        resourceDefinition = new AlertTargetResourceDefinition();\n        break;\n\n      case AlertNotice:\n        resourceDefinition = new AlertNoticeResourceDefinition();\n        break;\n\n      case AmbariPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.AmbariPrivilege);\n        break;\n\n      case ClusterPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.ClusterPrivilege);\n        break;\n\n      case ViewPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.ViewPrivilege);\n        break;\n\n      case UserPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.UserPrivilege);\n        break;\n\n      case ViewPermission:\n        resourceDefinition = new ViewPermissionResourceDefinition();\n        break;\n\n      case ClientConfig:\n        resourceDefinition = new ClientConfigResourceDefinition();\n        break;\n\n      case LdapSyncEvent:\n        resourceDefinition = new LdapSyncEventResourceDefinition();\n        break;\n\n      case RepositoryVersion:\n        resourceDefinition = new RepositoryVersionResourceDefinition();\n        break;\n\n      case CompatibleRepositoryVersion:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.CompatibleRepositoryVersion,\n            \"compatible_repository_version\", \"compatible_repository_versions\",\n            Resource.Type.OperatingSystem);\n        break;\n\n      case HostStackVersion:\n        resourceDefinition = new ComponentStackVersionResourceDefinition(Resource.Type.HostStackVersion);\n        break;\n\n      case ClusterStackVersion:\n        resourceDefinition = new ComponentStackVersionResourceDefinition(Resource.Type.ClusterStackVersion);\n        break;\n\n      case Upgrade:\n        resourceDefinition = new UpgradeResourceDefinition();\n        break;\n\n      case UpgradeGroup:\n        resourceDefinition = new SimpleResourceDefinition(\n            Resource.Type.UpgradeGroup, \"upgrade_group\", \"upgrade_groups\",\n            Resource.Type.UpgradeItem);\n        break;\n\n      case UpgradeItem:\n        resourceDefinition = new SimpleResourceDefinition(\n            Resource.Type.UpgradeItem, \"upgrade_item\", \"upgrade_items\", Resource.Type.Task);\n        break;\n\n      case PreUpgradeCheck:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.PreUpgradeCheck, \"rolling_upgrade_check\", \"rolling_upgrade_checks\");\n        break;\n\n      case Stage:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.Stage, \"stage\", \"stages\", Resource.Type.Task);\n        break;\n\n      case StackArtifact:\n        resourceDefinition = new BaseResourceDefinition(Resource.Type.StackArtifact) {\n          @Override\n          public String getPluralName() {\n            return \"artifacts\";\n          }\n\n          @Override\n          public String getSingularName() {\n            return \"artifact\";\n          }\n        };\n        break;\n\n      case Artifact:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.Artifact, \"artifact\", \"artifacts\");\n        break;\n\n      case Theme:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.Theme, \"theme\", \"themes\");\n        break;\n\n      case QuickLink:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.QuickLink, \"quicklink\", \"quicklinks\");\n        break;\n\n      case Widget:\n        resourceDefinition = new WidgetResourceDefinition();\n        break;\n\n      case WidgetLayout:\n        resourceDefinition = new WidgetLayoutResourceDefinition();\n        break;\n\n      case ActiveWidgetLayout:\n        resourceDefinition = new ActiveWidgetLayoutResourceDefinition();\n        break;\n\n      case HostKerberosIdentity:\n        resourceDefinition = new HostKerberosIdentityResourceDefinition();\n        break;\n\n      case KerberosDescriptor:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.KerberosDescriptor, \"kerberos_descriptor\", \"kerberos_descriptors\");\n        break;\n\n      case Credential:\n        resourceDefinition = new CredentialResourceDefinition();\n        break;\n\n      case RoleAuthorization:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.RoleAuthorization, \"authorization\", \"authorizations\");\n        break;\n\n      case UserAuthorization:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.UserAuthorization, \"authorization\", \"authorizations\");\n        break;\n\n      case AdminSetting:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.AdminSetting, \"admin-setting\", \"admin-settings\");\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Unsupported resource type: \" + type);\n    }\n    return resourceDefinition;\n  }","id":93705,"modified_method":"/**\n   * Get a resource definition for the given type.\n   *\n   * @param type    the resource type\n   * @param mapIds  the map of ids\n   *\n   * @return the resource definition\n   */\n  public static ResourceDefinition getResourceDefinition(Resource.Type type, Map<Resource.Type, String> mapIds) {\n    ResourceDefinition resourceDefinition;\n\n    // Check to see if there is an external resource definition registered for the given type.\n    if (resourceDefinitions.containsKey(type)) {\n      return resourceDefinitions.get(type);\n    }\n\n    //todo: consider ResourceDependencyManager : Map<Resource.Type, ResourceDefinition>\n    switch (type.getInternalType()) {\n      case Cluster:\n        resourceDefinition = new ClusterResourceDefinition();\n        break;\n\n      case Service:\n        resourceDefinition = new ServiceResourceDefinition();\n        break;\n\n      case Host:\n        resourceDefinition = mapIds.containsKey(Resource.Type.Cluster) ?\n            new HostResourceDefinition() : new DetachedHostResourceDefinition();\n        break;\n\n      case Component:\n        resourceDefinition = new ComponentResourceDefinition();\n        break;\n\n      case HostComponent:\n        resourceDefinition = new HostComponentResourceDefinition();\n        break;\n\n      case Action:\n        resourceDefinition = new ActionResourceDefinition();\n        break;\n\n      case Configuration:\n        resourceDefinition = new ConfigurationResourceDefinition();\n        break;\n\n      case ServiceConfigVersion:\n        resourceDefinition = new ServiceConfigVersionResourceDefinition();\n        break;\n\n      case Task:\n        resourceDefinition = new TaskResourceDefinition();\n        break;\n\n      case User:\n        resourceDefinition = new UserResourceDefinition();\n        break;\n\n      case Group:\n        resourceDefinition = new GroupResourceDefinition();\n        break;\n\n      case Member:\n        resourceDefinition = new MemberResourceDefinition();\n        break;\n\n      case Request:\n        resourceDefinition = new RequestResourceDefinition();\n        break;\n\n      case Stack:\n        resourceDefinition = new StackResourceDefinition();\n        break;\n\n      case StackVersion:\n        resourceDefinition = new StackVersionResourceDefinition();\n        break;\n\n      case StackLevelConfiguration:\n        resourceDefinition = new StackLevelConfigurationResourceDefinition();\n        break;\n\n      case StackService:\n        resourceDefinition = new StackServiceResourceDefinition();\n        break;\n\n      case StackServiceComponent:\n        resourceDefinition = new StackServiceComponentResourceDefinition();\n        break;\n\n      case StackServiceComponentDependency:\n        resourceDefinition = new StackDependencyResourceDefinition();\n        break;\n\n      case StackConfiguration:\n        resourceDefinition = new StackConfigurationResourceDefinition();\n        break;\n\n      case StackConfigurationDependency:\n        resourceDefinition = new StackConfigurationDependencyResourceDefinition();\n        break;\n\n      case OperatingSystem:\n        resourceDefinition = new OperatingSystemResourceDefinition();\n        break;\n\n      case Repository:\n        resourceDefinition = new RepositoryResourceDefinition();\n        break;\n\n      case DRFeed:\n        resourceDefinition = new FeedResourceDefinition();\n        break;\n\n      case DRTargetCluster:\n        resourceDefinition = new TargetClusterResourceDefinition();\n        break;\n\n      case DRInstance:\n        resourceDefinition = new InstanceResourceDefinition();\n        break;\n\n      case Workflow:\n        resourceDefinition = new WorkflowResourceDefinition();\n        break;\n\n      case Job:\n        resourceDefinition = new JobResourceDefinition();\n        break;\n\n      case TaskAttempt:\n        resourceDefinition = new TaskAttemptResourceDefinition();\n        break;\n\n      case RootService:\n        resourceDefinition = new RootServiceResourceDefinition();\n        break;\n\n      case RootServiceComponent:\n        resourceDefinition = new RootServiceComponentResourceDefinition();\n        break;\n\n      case RootServiceHostComponent:\n        resourceDefinition = new RootServiceHostComponentResourceDefinition();\n        break;\n\n      case ConfigGroup:\n        resourceDefinition = new ConfigGroupResourceDefinition();\n        break;\n\n      case RequestSchedule:\n        resourceDefinition = new RequestScheduleResourceDefinition();\n        break;\n\n      case View:\n        resourceDefinition = new ViewResourceDefinition();\n        break;\n\n      case ViewVersion:\n        resourceDefinition = new ViewVersionResourceDefinition();\n        break;\n\n      case ViewInstance:\n        String viewName = mapIds.get(Resource.Type.View);\n        String version  = mapIds.get(Resource.Type.ViewVersion);\n\n        Set<SubResourceDefinition> subResourceDefinitions = (viewName == null || version == null)  ?\n            Collections.<SubResourceDefinition>emptySet() :\n            ViewRegistry.getInstance().getSubResourceDefinitions(viewName, version);\n\n        resourceDefinition = new ViewInstanceResourceDefinition(subResourceDefinitions);\n        break;\n\n      case Blueprint:\n        resourceDefinition = new BlueprintResourceDefinition();\n        break;\n\n      case Recommendation:\n        resourceDefinition = new RecommendationResourceDefinition();\n        break;\n\n      case Validation:\n        resourceDefinition = new ValidationResourceDefinition();\n        break;\n\n      case HostComponentProcess:\n        resourceDefinition = new HostComponentProcessResourceDefinition();\n        break;\n\n      case Permission:\n        resourceDefinition = new PermissionResourceDefinition();\n        break;\n\n      case Alert:\n        resourceDefinition = new AlertResourceDefinition();\n        break;\n\n      case AlertDefinition:\n        resourceDefinition = new AlertDefResourceDefinition();\n        break;\n\n      case AlertHistory:\n        resourceDefinition = new AlertHistoryResourceDefinition();\n        break;\n\n      case AlertGroup:\n        resourceDefinition = new AlertGroupResourceDefinition();\n        break;\n\n      case AlertTarget:\n        resourceDefinition = new AlertTargetResourceDefinition();\n        break;\n\n      case AlertNotice:\n        resourceDefinition = new AlertNoticeResourceDefinition();\n        break;\n\n      case AmbariPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.AmbariPrivilege);\n        break;\n\n      case ClusterPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.ClusterPrivilege);\n        break;\n\n      case ViewPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.ViewPrivilege);\n        break;\n\n      case UserPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.UserPrivilege);\n        break;\n\n      case ViewPermission:\n        resourceDefinition = new ViewPermissionResourceDefinition();\n        break;\n\n      case ClientConfig:\n        resourceDefinition = new ClientConfigResourceDefinition();\n        break;\n\n      case LdapSyncEvent:\n        resourceDefinition = new LdapSyncEventResourceDefinition();\n        break;\n\n      case RepositoryVersion:\n        resourceDefinition = new RepositoryVersionResourceDefinition();\n        break;\n\n      case CompatibleRepositoryVersion:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.CompatibleRepositoryVersion,\n            \"compatible_repository_version\", \"compatible_repository_versions\",\n            Resource.Type.OperatingSystem);\n        break;\n\n      case HostStackVersion:\n        resourceDefinition = new ComponentStackVersionResourceDefinition(Resource.Type.HostStackVersion);\n        break;\n\n      case ClusterStackVersion:\n        resourceDefinition = new ComponentStackVersionResourceDefinition(Resource.Type.ClusterStackVersion);\n        break;\n\n      case Upgrade:\n        resourceDefinition = new UpgradeResourceDefinition();\n        break;\n\n      case UpgradeGroup:\n        resourceDefinition = new SimpleResourceDefinition(\n            Resource.Type.UpgradeGroup, \"upgrade_group\", \"upgrade_groups\",\n            Resource.Type.UpgradeItem);\n        break;\n\n      case UpgradeItem:\n        resourceDefinition = new SimpleResourceDefinition(\n            Resource.Type.UpgradeItem, \"upgrade_item\", \"upgrade_items\", Resource.Type.Task);\n        break;\n\n      case PreUpgradeCheck:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.PreUpgradeCheck, \"rolling_upgrade_check\", \"rolling_upgrade_checks\");\n        break;\n\n      case Stage:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.Stage, \"stage\", \"stages\", Resource.Type.Task);\n        break;\n\n      case StackArtifact:\n        resourceDefinition = new BaseResourceDefinition(Resource.Type.StackArtifact) {\n          @Override\n          public String getPluralName() {\n            return \"artifacts\";\n          }\n\n          @Override\n          public String getSingularName() {\n            return \"artifact\";\n          }\n        };\n        break;\n\n      case Artifact:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.Artifact, \"artifact\", \"artifacts\");\n        break;\n\n      case Theme:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.Theme, \"theme\", \"themes\");\n        break;\n\n      case QuickLink:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.QuickLink, \"quicklink\", \"quicklinks\");\n        break;\n\n      case Widget:\n        resourceDefinition = new WidgetResourceDefinition();\n        break;\n\n      case WidgetLayout:\n        resourceDefinition = new WidgetLayoutResourceDefinition();\n        break;\n\n      case ActiveWidgetLayout:\n        resourceDefinition = new ActiveWidgetLayoutResourceDefinition();\n        break;\n\n      case HostKerberosIdentity:\n        resourceDefinition = new HostKerberosIdentityResourceDefinition();\n        break;\n\n      case KerberosDescriptor:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.KerberosDescriptor, \"kerberos_descriptor\", \"kerberos_descriptors\");\n        break;\n\n      case Credential:\n        resourceDefinition = new CredentialResourceDefinition();\n        break;\n\n      case RoleAuthorization:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.RoleAuthorization, \"authorization\", \"authorizations\");\n        break;\n\n      case UserAuthorization:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.UserAuthorization, \"authorization\", \"authorizations\");\n        break;\n\n      case AdminSetting:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.AdminSetting, \"admin-setting\", \"admin-settings\");\n        break;\n\n      case VersionDefinition:\n        resourceDefinition = new VersionDefinitionResourceDefinition();\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Unsupported resource type: \" + type);\n    }\n    return resourceDefinition;\n  }","commit_id":"986a5188334b51cf5728b4b54c2aefc48866558e","url":"https://github.com/apache/ambari"},{"original_method":"private void percolatorRecovery(final boolean multiPercolate) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"gateway.type\", \"none\").build();\n        logger.info(\"--> starting 3 nodes\");\n        startNode(\"node1\", settings);\n        startNode(\"node2\", settings);\n        startNode(\"node3\", settings);\n\n        final Client client = client(\"node1\");\n        client.admin().indices().prepareDelete().execute().actionGet();\n        ensureGreen(client);\n\n        client.admin().indices().prepareCreate(\"test\")\n                .setSettings(settingsBuilder()\n                        .put(\"index.number_of_shards\", 2)\n                        .put(\"index.number_of_replicas\", 2)\n                )\n                .execute().actionGet();\n        ensureGreen(client);\n\n        final int numQueries = randomIntBetween(50, 100);\n        logger.info(\"--> register a queries\");\n        for (int i = 0; i < numQueries; i++) {\n            client.prepareIndex(\"test\", \"_percolator\", Integer.toString(i))\n                    .setSource(jsonBuilder().startObject().field(\"query\", matchAllQuery()).endObject())\n                    .execute().actionGet();\n        }\n\n        client.prepareIndex(\"test\", \"type\", \"1\")\n                .setSource(jsonBuilder().startObject().field(\"field\", \"a\"))\n                .execute().actionGet();\n\n        final AtomicBoolean run = new AtomicBoolean(true);\n        final CountDownLatch done = new CountDownLatch(1);\n        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();\n        Runnable r = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    XContentBuilder doc = jsonBuilder().startObject().field(\"field\", \"a\").endObject();\n                    while (run.get()) {\n                        NodesInfoResponse nodesInfoResponse = client.admin().cluster().prepareNodesInfo()\n                                .execute().actionGet();\n                        String node2Id = null;\n                        String node3Id = null;\n                        for (NodeInfo nodeInfo : nodesInfoResponse) {\n                            if (\"node2\".equals(nodeInfo.getNode().getName())) {\n                                node2Id = nodeInfo.getNode().id();\n                            } else if (\"node3\".equals(nodeInfo.getNode().getName())) {\n                                node3Id = nodeInfo.getNode().id();\n                            }\n                        }\n\n                        String preference;\n                        if (node2Id == null && node3Id == null) {\n                            preference = \"_local\";\n                        } else if (node2Id == null || node3Id == null) {\n                            if (node2Id != null) {\n                                preference = \"_prefer_node:\" + node2Id;\n                            } else {\n                                preference = \"_prefer_node:\" + node3Id;\n                            }\n                        } else {\n                            preference = \"_prefer_node:\" + (randomBoolean() ? node2Id : node3Id);\n                        }\n\n                        if (multiPercolate) {\n                            MultiPercolateRequestBuilder builder = client\n                                    .prepareMultiPercolate();\n                            int numPercolateRequest = randomIntBetween(50, 100);\n\n                            for (int i = 0; i < numPercolateRequest; i++) {\n                                if (randomBoolean()) {\n                                    builder.add(\n                                            client.preparePercolate()\n                                                    .setPreference(preference)\n                                                    .setGetRequest(Requests.getRequest(\"test\").type(\"type\").id(\"1\"))\n                                                    .setIndices(\"test\").setDocumentType(\"type\")\n                                    );\n                                } else {\n                                    builder.add(\n                                            client.preparePercolate()\n                                                    .setPreference(preference)\n                                                    .setIndices(\"test\").setDocumentType(\"type\")\n                                                    .setPercolateDoc(docBuilder().setDoc(doc)));\n                                }\n                            }\n\n                            MultiPercolateResponse response = builder.execute().actionGet();\n                            assertThat(response.items().length, equalTo(numPercolateRequest));\n                            for (MultiPercolateResponse.Item item : response) {\n                                assertThat(item.isFailure(), equalTo(false));\n                                assertNoFailures(item.getResponse());\n                                assertThat(item.getResponse().getSuccessfulShards(), equalTo(2));\n                                assertThat(item.getResponse().getCount(), equalTo((long) numQueries));\n                                assertThat(item.getResponse().getMatches().length, equalTo(numQueries));\n                            }\n                        } else {\n                            PercolateResponse response;\n                            if (randomBoolean()) {\n                                response = client.preparePercolate()\n                                        .setIndices(\"test\").setDocumentType(\"type\")\n                                        .setPercolateDoc(docBuilder().setDoc(doc))\n                                        .setPreference(preference)\n                                        .execute().actionGet();\n                            } else {\n                                response = client.preparePercolate()\n                                        .setGetRequest(Requests.getRequest(\"test\").type(\"type\").id(\"1\"))\n                                        .setIndices(\"test\").setDocumentType(\"type\")\n                                        .setPreference(preference)\n                                        .execute().actionGet();\n                            }\n                            assertNoFailures(response);\n                            assertThat(response.getSuccessfulShards(), equalTo(2));\n                            assertThat(response.getCount(), equalTo((long) numQueries));\n                            assertThat(response.getMatches().length, equalTo(numQueries));\n                        }\n                    }\n                } catch (Throwable t) {\n                    logger.info(\"Error in percolate thread...\", t);\n                    run.set(false);\n                    error.set(t);\n                } finally {\n                    done.countDown();\n                }\n            }\n        };\n        new Thread(r).start();\n\n        try {\n            for (int i = 0; i < 4; i++) {\n                closeNode(\"node3\");\n                client.admin().cluster().prepareHealth()\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setWaitForYellowStatus()\n                        .setWaitForNodes(\"2\")\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n                closeNode(\"node2\");\n                client.admin().cluster().prepareHealth()\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setWaitForYellowStatus()\n                        .setWaitForNodes(\"1\")\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n                startNode(\"node3\");\n                client.admin().cluster().prepareHealth()\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setWaitForYellowStatus()\n                        .setWaitForNodes(\"2\")\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n                startNode(\"node2\");\n                client.admin().cluster().prepareHealth()\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setWaitForYellowStatus()\n                        .setWaitForNodes(\"3\")\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n            }\n        } finally {\n            run.set(false);\n        }\n        done.await();\n        assertThat(error.get(), nullValue());\n    }","id":93706,"modified_method":"private void percolatorRecovery(final boolean multiPercolate) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"gateway.type\", \"none\").build();\n        logger.info(\"--> starting 3 nodes\");\n        startNode(\"node1\", settings);\n        startNode(\"node2\", settings);\n        startNode(\"node3\", settings);\n\n        final Client client = client(\"node1\");\n        client.admin().indices().prepareDelete().execute().actionGet();\n        ensureGreen(client);\n\n        client.admin().indices().prepareCreate(\"test\")\n                .setSettings(settingsBuilder()\n                        .put(\"index.number_of_shards\", 2)\n                        .put(\"index.number_of_replicas\", 2)\n                )\n                .execute().actionGet();\n        ensureGreen(client);\n\n        final int numQueries = randomIntBetween(50, 100);\n        logger.info(\"--> register a queries\");\n        for (int i = 0; i < numQueries; i++) {\n            client.prepareIndex(\"test\", \"_percolator\", Integer.toString(i))\n                    .setSource(jsonBuilder().startObject().field(\"query\", matchAllQuery()).endObject())\n                    .execute().actionGet();\n        }\n\n        client.prepareIndex(\"test\", \"type\", \"1\")\n                .setSource(jsonBuilder().startObject().field(\"field\", \"a\"))\n                .execute().actionGet();\n\n        final AtomicBoolean run = new AtomicBoolean(true);\n        final CountDownLatch done = new CountDownLatch(1);\n        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();\n        Runnable r = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    XContentBuilder doc = jsonBuilder().startObject().field(\"field\", \"a\").endObject();\n                    while (run.get()) {\n                        NodesInfoResponse nodesInfoResponse = client.admin().cluster().prepareNodesInfo()\n                                .execute().actionGet();\n                        String node2Id = null;\n                        String node3Id = null;\n                        for (NodeInfo nodeInfo : nodesInfoResponse) {\n                            if (\"node2\".equals(nodeInfo.getNode().getName())) {\n                                node2Id = nodeInfo.getNode().id();\n                            } else if (\"node3\".equals(nodeInfo.getNode().getName())) {\n                                node3Id = nodeInfo.getNode().id();\n                            }\n                        }\n\n                        String preference;\n                        if (node2Id == null && node3Id == null) {\n                            preference = \"_local\";\n                        } else if (node2Id == null || node3Id == null) {\n                            if (node2Id != null) {\n                                preference = \"_prefer_node:\" + node2Id;\n                            } else {\n                                preference = \"_prefer_node:\" + node3Id;\n                            }\n                        } else {\n                            preference = \"_prefer_node:\" + (randomBoolean() ? node2Id : node3Id);\n                        }\n\n                        if (multiPercolate) {\n                            MultiPercolateRequestBuilder builder = client\n                                    .prepareMultiPercolate();\n                            int numPercolateRequest = randomIntBetween(50, 100);\n\n                            for (int i = 0; i < numPercolateRequest; i++) {\n                                if (randomBoolean()) {\n                                    builder.add(\n                                            client.preparePercolate()\n                                                    .setPreference(preference)\n                                                    .setGetRequest(Requests.getRequest(\"test\").type(\"type\").id(\"1\"))\n                                                    .setIndices(\"test\").setDocumentType(\"type\")\n                                    );\n                                } else {\n                                    builder.add(\n                                            client.preparePercolate()\n                                                    .setPreference(preference)\n                                                    .setIndices(\"test\").setDocumentType(\"type\")\n                                                    .setPercolateDoc(docBuilder().setDoc(doc)));\n                                }\n                            }\n\n                            MultiPercolateResponse response = builder.execute().actionGet();\n                            assertThat(response.items().length, equalTo(numPercolateRequest));\n                            for (MultiPercolateResponse.Item item : response) {\n                                assertThat(item.isFailure(), equalTo(false));\n                                assertNoFailures(item.getResponse());\n                                assertThat(item.getResponse().getSuccessfulShards(), equalTo(item.getResponse().getTotalShards()));\n                                assertThat(item.getResponse().getCount(), equalTo((long) numQueries));\n                                assertThat(item.getResponse().getMatches().length, equalTo(numQueries));\n                            }\n                        } else {\n                            PercolateResponse response;\n                            if (randomBoolean()) {\n                                response = client.preparePercolate()\n                                        .setIndices(\"test\").setDocumentType(\"type\")\n                                        .setPercolateDoc(docBuilder().setDoc(doc))\n                                        .setPreference(preference)\n                                        .execute().actionGet();\n                            } else {\n                                response = client.preparePercolate()\n                                        .setGetRequest(Requests.getRequest(\"test\").type(\"type\").id(\"1\"))\n                                        .setIndices(\"test\").setDocumentType(\"type\")\n                                        .setPreference(preference)\n                                        .execute().actionGet();\n                            }\n                            assertNoFailures(response);\n                            assertThat(response.getSuccessfulShards(), equalTo(response.getTotalShards()));\n                            assertThat(response.getCount(), equalTo((long) numQueries));\n                            assertThat(response.getMatches().length, equalTo(numQueries));\n                        }\n                    }\n                } catch (Throwable t) {\n                    logger.info(\"Error in percolate thread...\", t);\n                    run.set(false);\n                    error.set(t);\n                } finally {\n                    done.countDown();\n                }\n            }\n        };\n        new Thread(r).start();\n\n        try {\n            // 1 index, 2 primaries, 2 replicas per primary\n            for (int i = 0; i < 4; i++) {\n                closeNode(\"node3\");\n                client.admin().cluster().prepareHealth(\"test\")\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setTimeout(TimeValue.timeValueMinutes(2))\n                        .setWaitForYellowStatus()\n                        .setWaitForActiveShards(4) // 2 nodes, so 4 shards (2 primaries, 2 replicas)\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n                closeNode(\"node2\");\n                client.admin().cluster().prepareHealth(\"test\")\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setTimeout(TimeValue.timeValueMinutes(2))\n                        .setWaitForYellowStatus()\n                        .setWaitForActiveShards(2) // 1 node, so 2 shards (2 primaries, 0 replicas)\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n                startNode(\"node3\");\n                client.admin().cluster().prepareHealth(\"test\")\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setTimeout(TimeValue.timeValueMinutes(2))\n                        .setWaitForYellowStatus()\n                        .setWaitForActiveShards(4)  // 2 nodes, so 4 shards (2 primaries, 2 replicas)\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n                startNode(\"node2\");\n                client.admin().cluster().prepareHealth(\"test\")\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setTimeout(TimeValue.timeValueMinutes(2))\n                        .setWaitForGreenStatus() // We're confirm the shard settings, so green instead of yellow\n                        .setWaitForActiveShards(6) // 3 nodes, so 6 shards (2 primaries, 4 replicas)\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n            }\n        } finally {\n            run.set(false);\n        }\n        done.await();\n        assertThat(error.get(), nullValue());\n    }","commit_id":"be00437c65c48b3aea23bbd1c0ba90ce32b21d40","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void multiPercolate(MultiPercolateRequest multiPercolateRequest, final AtomicReferenceArray<Object> percolateRequests,\n                                final ActionListener<MultiPercolateResponse> listener, ClusterState clusterState) {\n\n        final AtomicInteger[] expectedOperationsPerItem = new AtomicInteger[percolateRequests.length()];\n        final AtomicReferenceArray<AtomicReferenceArray> responsesByItemAndShard = new AtomicReferenceArray<AtomicReferenceArray>(multiPercolateRequest.requests().size());\n        final AtomicArray<Object> reducedResponses = new AtomicArray<Object>(percolateRequests.length());\n\n        // Keep track what slots belong to what shard, in case a request to a shard fails on all copies\n        final ConcurrentMap<ShardId, AtomicIntegerArray> shardToSlots = ConcurrentCollections.newConcurrentMap();\n\n        // Resolving concrete indices and routing and grouping the requests by shard\n        Map<ShardId, TransportShardMultiPercolateAction.Request> requestsByShard = new HashMap<ShardId, TransportShardMultiPercolateAction.Request>();\n        Map<ShardId, TIntArrayList> shardToSlotsBuilder = new HashMap<ShardId, TIntArrayList>();\n        int expectedResults = 0;\n        for (int i = 0;  i < percolateRequests.length(); i++) {\n            Object element = percolateRequests.get(i);\n            assert element != null;\n            if (element instanceof PercolateRequest) {\n                PercolateRequest percolateRequest = (PercolateRequest) element;\n                String[] concreteIndices = clusterState.metaData().concreteIndices(percolateRequest.indices(), percolateRequest.ignoreIndices(), true);\n                Map<String, Set<String>> routing = clusterState.metaData().resolveSearchRouting(percolateRequest.routing(), multiPercolateRequest.indices());\n                // TODO: I only need shardIds, ShardIterator(ShardRouting) is only needed in TransportShardMultiPercolateAction\n                GroupShardsIterator shards = clusterService.operationRouting().searchShards(\n                        clusterState, percolateRequest.indices(), concreteIndices, routing, percolateRequest.preference()\n                );\n\n                responsesByItemAndShard.set(i, new AtomicReferenceArray(shards.size()));\n                expectedOperationsPerItem[i] = new AtomicInteger(shards.size());\n                for (ShardIterator shard : shards) {\n                    ShardId shardId = shard.shardId();\n                    TransportShardMultiPercolateAction.Request requests = requestsByShard.get(shardId);\n                    if (requests == null) {\n                        requestsByShard.put(shardId, requests = new TransportShardMultiPercolateAction.Request(shard.shardId().getIndex(), shardId.id(), percolateRequest.preference()));\n                    }\n                    requests.add(new TransportShardMultiPercolateAction.Request.Item(i, new PercolateShardRequest(shardId, percolateRequest)));\n\n                    TIntArrayList items = shardToSlotsBuilder.get(shardId);\n                    if (items == null) {\n                        shardToSlotsBuilder.put(shardId, items = new TIntArrayList());\n                    }\n                    items.add(i);\n                }\n                expectedResults++;\n            } else if (element instanceof Throwable) {\n                reducedResponses.set(i, element);\n                responsesByItemAndShard.set(i, new AtomicReferenceArray(0));\n                expectedOperationsPerItem[i] = new AtomicInteger(0);\n            }\n        }\n\n        if (expectedResults == 0) {\n            finish(reducedResponses, listener);\n            return;\n        }\n\n        for (Map.Entry<ShardId, TIntArrayList> entry : shardToSlotsBuilder.entrySet()) {\n            shardToSlots.put(entry.getKey(), new AtomicIntegerArray(entry.getValue().toArray()));\n        }\n\n        final AtomicInteger expectedOperations = new AtomicInteger(expectedResults);\n        for (Map.Entry<ShardId, TransportShardMultiPercolateAction.Request> entry : requestsByShard.entrySet()) {\n            final ShardId shardId = entry.getKey();\n            final TransportShardMultiPercolateAction.Request shardRequest = entry.getValue();\n            shardMultiPercolateAction.execute(shardRequest, new ActionListener<TransportShardMultiPercolateAction.Response>() {\n\n                @Override\n                @SuppressWarnings(\"unchecked\")\n                public void onResponse(TransportShardMultiPercolateAction.Response response) {\n                    try {\n                        for (TransportShardMultiPercolateAction.Response.Item item : response.items()) {\n                            AtomicReferenceArray shardResults = responsesByItemAndShard.get(item.slot());\n                            if (shardResults == null) {\n                                continue;\n                            }\n\n                            if (item.failed()) {\n                                shardResults.set(shardId.id(), new BroadcastShardOperationFailedException(shardId, item.error().string()));\n                            } else {\n                                shardResults.set(shardId.id(), item.response());\n                            }\n\n                            assert expectedOperationsPerItem[item.slot()].get() >= 1 : \"slot[\" + item.slot() + \"] can't be lower than one\";\n                            if (expectedOperationsPerItem[item.slot()].decrementAndGet() == 0) {\n                                // Failure won't bubble up, since we fail the whole request now via the catch clause below,\n                                // so expectedOperationsPerItem will not be decremented twice.\n                                reduce(item.slot(), percolateRequests, expectedOperations, reducedResponses, listener, responsesByItemAndShard);\n                            }\n                        }\n                    } catch (Throwable e) {\n                        logger.error(\"{} Percolate original reduce error\", e, shardId);\n                        listener.onFailure(e);\n                    }\n                }\n\n                @Override\n                @SuppressWarnings(\"unchecked\")\n                public void onFailure(Throwable e) {\n                    logger.debug(\"Shard multi percolate failure\", e);\n                    try {\n                        AtomicIntegerArray slots = shardToSlots.get(shardId);\n                        for (int i = 0; i < slots.length(); i++) {\n                            int slot = slots.get(i);\n                            AtomicReferenceArray shardResults = responsesByItemAndShard.get(slot);\n                            if (shardResults == null) {\n                                continue;\n                            }\n\n                            shardResults.set(shardId.id(), new BroadcastShardOperationFailedException(shardId, e));\n                            assert expectedOperationsPerItem[slot].get() >= 1 : \"slot[\" + slot + \"] can't be lower than one. Caused by: \" + e.getMessage();\n                            if (expectedOperationsPerItem[slot].decrementAndGet() == 0) {\n                                reduce(slot, percolateRequests, expectedOperations, reducedResponses, listener, responsesByItemAndShard);\n                            }\n                        }\n                    } catch (Throwable t) {\n                        logger.error(\"{} Percolate original reduce error, original error {}\", t, shardId, e);\n                        listener.onFailure(t);\n                    }\n                }\n\n            });\n        }\n    }","id":93707,"modified_method":"private void multiPercolate(MultiPercolateRequest multiPercolateRequest, final AtomicReferenceArray<Object> percolateRequests,\n                                final ActionListener<MultiPercolateResponse> listener, ClusterState clusterState) {\n\n        final AtomicReferenceArray<AtomicInteger> expectedOperationsPerItem = new AtomicReferenceArray<AtomicInteger>(percolateRequests.length());\n        final AtomicReferenceArray<AtomicReferenceArray> responsesByItemAndShard = new AtomicReferenceArray<AtomicReferenceArray>(multiPercolateRequest.requests().size());\n        final AtomicArray<Object> reducedResponses = new AtomicArray<Object>(percolateRequests.length());\n\n        // Resolving concrete indices and routing and grouping the requests by shard\n        Map<ShardId, TransportShardMultiPercolateAction.Request> requestsByShard = new HashMap<ShardId, TransportShardMultiPercolateAction.Request>();\n        // Keep track what slots belong to what shard, in case a request to a shard fails on all copies\n        Map<ShardId, TIntArrayList> shardToSlotsBuilder = new HashMap<ShardId, TIntArrayList>();\n        int expectedResults = 0;\n        for (int i = 0;  i < percolateRequests.length(); i++) {\n            Object element = percolateRequests.get(i);\n            assert element != null;\n            if (element instanceof PercolateRequest) {\n                PercolateRequest percolateRequest = (PercolateRequest) element;\n                String[] concreteIndices = clusterState.metaData().concreteIndices(percolateRequest.indices(), percolateRequest.ignoreIndices(), true);\n                Map<String, Set<String>> routing = clusterState.metaData().resolveSearchRouting(percolateRequest.routing(), multiPercolateRequest.indices());\n                // TODO: I only need shardIds, ShardIterator(ShardRouting) is only needed in TransportShardMultiPercolateAction\n                GroupShardsIterator shards = clusterService.operationRouting().searchShards(\n                        clusterState, percolateRequest.indices(), concreteIndices, routing, percolateRequest.preference()\n                );\n\n                responsesByItemAndShard.set(i, new AtomicReferenceArray(shards.size()));\n                expectedOperationsPerItem.set(i, new AtomicInteger(shards.size()));\n                for (ShardIterator shard : shards) {\n                    ShardId shardId = shard.shardId();\n                    TransportShardMultiPercolateAction.Request requests = requestsByShard.get(shardId);\n                    if (requests == null) {\n                        requestsByShard.put(shardId, requests = new TransportShardMultiPercolateAction.Request(shard.shardId().getIndex(), shardId.id(), percolateRequest.preference()));\n                    }\n                    requests.add(new TransportShardMultiPercolateAction.Request.Item(i, new PercolateShardRequest(shardId, percolateRequest)));\n\n                    TIntArrayList items = shardToSlotsBuilder.get(shardId);\n                    if (items == null) {\n                        shardToSlotsBuilder.put(shardId, items = new TIntArrayList());\n                    }\n                    items.add(i);\n                }\n                expectedResults++;\n            } else if (element instanceof Throwable) {\n                reducedResponses.set(i, element);\n                responsesByItemAndShard.set(i, new AtomicReferenceArray(0));\n                expectedOperationsPerItem.set(i, new AtomicInteger(0));\n            }\n        }\n\n        if (expectedResults == 0) {\n            finish(reducedResponses, listener);\n            return;\n        }\n\n        // Move slot to shard tracking from normal map to concurrent save map\n        final ConcurrentMap<ShardId, AtomicIntegerArray> shardToSlots = ConcurrentCollections.newConcurrentMap();\n        for (Map.Entry<ShardId, TIntArrayList> entry : shardToSlotsBuilder.entrySet()) {\n            shardToSlots.put(entry.getKey(), new AtomicIntegerArray(entry.getValue().toArray()));\n        }\n\n        final AtomicInteger expectedOperations = new AtomicInteger(expectedResults);\n        for (Map.Entry<ShardId, TransportShardMultiPercolateAction.Request> entry : requestsByShard.entrySet()) {\n            final ShardId shardId = entry.getKey();\n            final TransportShardMultiPercolateAction.Request shardRequest = entry.getValue();\n            shardMultiPercolateAction.execute(shardRequest, new ActionListener<TransportShardMultiPercolateAction.Response>() {\n\n                @Override\n                @SuppressWarnings(\"unchecked\")\n                public void onResponse(TransportShardMultiPercolateAction.Response response) {\n                    try {\n                        for (TransportShardMultiPercolateAction.Response.Item item : response.items()) {\n                            AtomicReferenceArray shardResults = responsesByItemAndShard.get(item.slot());\n                            if (shardResults == null) {\n                                continue;\n                            }\n\n                            if (item.failed()) {\n                                shardResults.set(shardId.id(), new BroadcastShardOperationFailedException(shardId, item.error().string()));\n                            } else {\n                                shardResults.set(shardId.id(), item.response());\n                            }\n\n                            assert expectedOperationsPerItem.get(item.slot()).get() >= 1 : \"slot[\" + item.slot() + \"] can't be lower than one\";\n                            if (expectedOperationsPerItem.get(item.slot()).decrementAndGet() == 0) {\n                                // Failure won't bubble up, since we fail the whole request now via the catch clause below,\n                                // so expectedOperationsPerItem will not be decremented twice.\n                                reduce(item.slot(), percolateRequests, expectedOperations, reducedResponses, listener, responsesByItemAndShard);\n                            }\n                        }\n                    } catch (Throwable e) {\n                        logger.error(\"{} Percolate original reduce error\", e, shardId);\n                        listener.onFailure(e);\n                    }\n                }\n\n                @Override\n                @SuppressWarnings(\"unchecked\")\n                public void onFailure(Throwable e) {\n                    logger.debug(\"Shard multi percolate failure\", e);\n                    try {\n                        AtomicIntegerArray slots = shardToSlots.get(shardId);\n                        for (int i = 0; i < slots.length(); i++) {\n                            int slot = slots.get(i);\n                            AtomicReferenceArray shardResults = responsesByItemAndShard.get(slot);\n                            if (shardResults == null) {\n                                continue;\n                            }\n\n                            shardResults.set(shardId.id(), new BroadcastShardOperationFailedException(shardId, e));\n                            assert expectedOperationsPerItem.get(slot).get() >= 1 : \"slot[\" + slot + \"] can't be lower than one. Caused by: \" + e.getMessage();\n                            if (expectedOperationsPerItem.get(slot).decrementAndGet() == 0) {\n                                reduce(slot, percolateRequests, expectedOperations, reducedResponses, listener, responsesByItemAndShard);\n                            }\n                        }\n                    } catch (Throwable t) {\n                        logger.error(\"{} Percolate original reduce error, original error {}\", t, shardId, e);\n                        listener.onFailure(t);\n                    }\n                }\n\n            });\n        }\n    }","commit_id":"be00437c65c48b3aea23bbd1c0ba90ce32b21d40","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** \n     * Wrapper for dispatching to a file from the OpenCms VFS.<p>\n     *\n     * This method will dispatch to cache, to real file system or\n     * to the OpenCms VFS, whatever is needed.<p>\n     *\n     * This method is much more complex then it sould be because of the internal standard \n     * buffering of JSP pages.\n     * Because of that I can not just intercept and buffer the stream, since I don't have \n     * access to it (it is wrapped internally in the JSP pages, which have their own buffer).\n     * That leads to a solution where the data is first written to the bufferd stream, \n     * but without includes. Then it is parsed again later \n     * (in response.processCacheEntry()), enriched with the \n     * included elements that have been ommitted in the first case.\n     * I would love to see a simpler solution, but this works for now.<p>\n     *\n     * @param req the servlet request\n     * @param res the servlet response\n     * @throws ServletException in case something goes wrong\n     * @throws IOException in case something goes wrong\n     */ \n    public void include(\n        ServletRequest req, \n        ServletResponse res\n    ) throws ServletException, IOException {\n            \n        if (DEBUG > 0) System.err.println(\"FlexDispatcher: Include called with target=\" + m_vfsTarget + \" (ext_target=\" + m_extTarget + \")\");      \n        CmsFlexController controller = (CmsFlexController)req.getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n        CmsObject cms = controller.getCmsObject();\n                \n        if ((m_extTarget == null) && (controller != null)) {\n            // Check if the file exists in the VFS, if not set external target\n            try {\n                cms.readFileHeader(m_vfsTarget);\n            } catch (CmsException e) {\n                if (e.getType() == CmsException.C_NOT_FOUND) {\n                    // File not found in VFS, treat it as external file\n                    m_extTarget = m_vfsTarget;\n                }\n            }\n        }\n                \n        if ((m_extTarget != null) || (controller == null)) {\n            // This is an external include, probably to a JSP page, dispatch with system dispatcher\n            if (DEBUG > 0) System.err.println(\"FlexDispatcher: Dispatching to external target \" + m_extTarget);      \n            m_rd.include(req, res);   \n            return;\n        }\n        \n        CmsFlexCache cache = controller.getCmsCache();\n        \n        // this is a request through the CMS\n        CmsFlexRequest f_req = controller.getCurrentRequest();\n        CmsFlexResponse f_res = controller.getCurrentResponse();\n        \n        if (f_req.containsIncludeCall(m_vfsTarget)) {\n            // This resource was already included earlier, so we have a (probably endless) inclusion loop\n            throw new ServletException(\"FlexDispatcher: Dectected inclusion loop for target \" + m_vfsTarget);\n        } else {     \n            f_req.addInlucdeCall(m_vfsTarget);\n        }\n       \n        // Do nothing if response is already finished (probably as a result of an earlier redirect)\n        if (f_res.isSuspended()) return;\n        \n        // Indicate to response that all further output or headers are result of include calls\n        f_res.setCmsIncludeMode(true);\n                \n        // Create wrapper for request & response\n        CmsFlexRequest w_req = new CmsFlexRequest((HttpServletRequest)req, controller, m_vfsTarget);\n        CmsFlexResponse w_res = new CmsFlexResponse((HttpServletResponse)res, controller); \n        \n        // Push req/res to controller queue\n        controller.pushRequest(w_req);\n        controller.pushResponse(w_res);             \n        \n        CmsFlexCacheEntry entry = null;\n        if (f_req.isCacheable()) {\n            // Caching is on, check if requested resource is already in cache            \n            entry = cache.get(w_req.getCmsCacheKey());\n            if (entry != null) {\n                // The target is already in the cache\n                try {\n                    if (DEBUG > 0) System.err.println(\"FlexDispatcher: Loading file from cache for \" + m_vfsTarget);\n                    entry.service(w_req, w_res);\n                } catch (com.opencms.core.CmsException e) {\n                    throw new ServletException(\"FlexDispatcher: Error while loading file from cache for \" + m_vfsTarget + \"\\n\" + e, e);\n                }                       \n            } else { \n                // Cache is on and resource is not yet cached, so we need to read the cache key for the response\n                CmsFlexCacheKey res_key = cache.getKey(CmsFlexCacheKey.getKeyName(m_vfsTarget, w_req.isOnline(), w_req.isWorkplace()));            \n                if (res_key != null) {\n                    // Key already in cache, reuse it\n                    w_res.setCmsCacheKey(res_key);                                             \n                } else {                                \n                    // Cache key is unknown, read key from properties\n                    String cacheProperty = null;\n                    try {\n                        // Read caching property from requested VFS resource                                     \n                        cacheProperty = cms.readProperty(m_vfsTarget, org.opencms.loader.I_CmsResourceLoader.C_LOADER_CACHEPROPERTY);                    \n                        cache.putKey(w_res.setCmsCacheKey(cms.getRequestContext().addSiteRoot(m_vfsTarget), cacheProperty, f_req.isOnline(), f_req.isWorkplace()));                                            \n                    } catch (com.opencms.core.CmsException e) {\n                        if (e.getType() == CmsException.C_FLEX_CACHE) {\n                            // Invalid key is ignored but logged, used key is cache=never\n                            if (OpenCms.isLogging(I_CmsLogChannels.C_OPENCMS_INFO)) \n                                OpenCms.log(I_CmsLogChannels.C_OPENCMS_INFO, \"[FlexCache] Invalid cache key for external resource \\\"\" + m_vfsTarget + \"\\\": \" + cacheProperty);\n                            // There will be a vaild key in the response (\"cache=never\") even after an exception\n                            cache.putKey(w_res.getCmsCacheKey());\n                        } else {\n                            // All other errors are not handled here\n                            throw new ServletException(\"FlexDispatcher: Error while loading cache properties for \" + m_vfsTarget + \"\\n\" + e, e);\n                        }\n                    }                \n                    if (DEBUG > 1) System.err.println(\"FlexDispatcher: Cache properties for file \" + m_vfsTarget + \" are: \" + cacheProperty);\n                }\n            }\n        }\n\n        if (entry == null) {\n            // The target is not cached (or caching off), so load it with the internal resource loader\n            org.opencms.loader.I_CmsResourceLoader loader = null;\n\n            String variation = null;\n            // Check cache keys to see if the result can be cached \n            if (w_req.isCacheable()) variation = w_res.getCmsCacheKey().matchRequestKey(w_req.getCmsCacheKey());\n            // Indicate to the response if caching is not required\n            w_res.setCmsCachingRequired(variation != null);\n                        \n            com.opencms.file.CmsResource resource = null;\n            try {\n                resource = cms.readFileHeader(m_vfsTarget);\n                int type = resource.getLoaderId();\n                if (DEBUG > 0) System.err.println(\"FlexDispatcher: Loading resource type \" + type);\n                loader = OpenCms.getLoaderManager().getLoader(type);\n            } catch (java.lang.ClassCastException e) {\n                throw new ServletException(\"FlexDispatcher: CmsResourceLoader interface not implemented for cms resource \" + m_vfsTarget + \"\\n\" + e, e);\n            } catch (com.opencms.core.CmsException e) {\n                // File might not exist or no read permissions\n                throw new ServletException(\"FlexDispatcher: Error while reading header for cms resource \" + m_vfsTarget + \"\\n\" + e, e);\n            }\n                     \n            if (DEBUG > 0) System.err.println(\"FlexDispatcher: Internal call, loading file using loader.service() for \" + m_vfsTarget);\n            loader.service(cms, resource, w_req, w_res);\n\n            entry = w_res.processCacheEntry(); \n            if ((entry != null) && (variation != null) && w_req.isCacheable()) {                                      \n                cache.put(w_res.getCmsCacheKey(), entry, variation);                        \n            }                \n        }          \n        \n        if (f_res.hasIncludeList()) {\n            // Special case: This indicates that the output was not yet displayed\n            java.util.Map headers = w_res.getHeaders();\n            byte[] result = w_res.getWriterBytes();\n            if (DEBUG > 3) System.err.println(\"Non-display include call - Result of include is:\\n\" + new String(result));\n            CmsFlexResponse.processHeaders(headers, f_res);\n            f_res.addToIncludeResults(result);                    \n        }              \n\n        // Indicate to response that include is finished\n        f_res.setCmsIncludeMode(false);\n        f_req.removeIncludeCall(m_vfsTarget);      \n          \n        // Pop req/res from controller queue\n        controller.popRequest();\n        controller.popResponse();            \n    }","id":93708,"modified_method":"/** \n     * Wrapper for dispatching to a file from the OpenCms VFS.<p>\n     *\n     * This method will dispatch to cache, to real file system or\n     * to the OpenCms VFS, whatever is needed.<p>\n     *\n     * This method is much more complex then it sould be because of the internal standard \n     * buffering of JSP pages.\n     * Because of that I can not just intercept and buffer the stream, since I don't have \n     * access to it (it is wrapped internally in the JSP pages, which have their own buffer).\n     * That leads to a solution where the data is first written to the bufferd stream, \n     * but without includes. Then it is parsed again later \n     * (in response.processCacheEntry()), enriched with the \n     * included elements that have been ommitted in the first case.\n     * I would love to see a simpler solution, but this works for now.<p>\n     *\n     * @param req the servlet request\n     * @param res the servlet response\n     * @throws ServletException in case something goes wrong\n     * @throws IOException in case something goes wrong\n     */ \n    public void include(\n        ServletRequest req, \n        ServletResponse res\n    ) throws ServletException, IOException {\n            \n        if (DEBUG > 0) System.err.println(\"FlexDispatcher: Include called with target=\" + m_vfsTarget + \" (ext_target=\" + m_extTarget + \")\");      \n        CmsFlexController controller = (CmsFlexController)req.getAttribute(CmsFlexController.ATTRIBUTE_NAME);                \n        CmsObject cms = controller.getCmsObject();\n        \n        CmsResource resource = null;                \n        if ((m_extTarget == null) && (controller != null)) {\n            // Check if the file exists in the VFS, if not set external target\n            try {\n                resource = cms.readFileHeader(m_vfsTarget);\n            } catch (CmsException e) {\n                if (e.getType() == CmsException.C_NOT_FOUND) {\n                    // File not found in VFS, treat it as external file\n                    m_extTarget = m_vfsTarget;\n                }\n            }\n        }\n                \n        if ((m_extTarget != null) || (controller == null)) {\n            includeExternal(req, res);\n            return;\n        }\n        \n        CmsFlexCache cache = controller.getCmsCache();\n        \n        // this is a request through the CMS\n        CmsFlexRequest f_req = controller.getCurrentRequest();\n        CmsFlexResponse f_res = controller.getCurrentResponse();\n        \n        if (f_req.containsIncludeCall(m_vfsTarget)) {\n            // This resource was already included earlier, so we have a (probably endless) inclusion loop\n            throw new ServletException(\"FlexDispatcher: Dectected inclusion loop for target \" + m_vfsTarget);\n        } else {     \n            f_req.addInlucdeCall(m_vfsTarget);\n        }\n       \n        // Do nothing if response is already finished (probably as a result of an earlier redirect)\n        if (f_res.isSuspended()) return;\n        \n        // Indicate to response that all further output or headers are result of include calls\n        f_res.setCmsIncludeMode(true);\n                \n        // Create wrapper for request & response\n        CmsFlexRequest w_req = new CmsFlexRequest((HttpServletRequest)req, controller, m_vfsTarget);\n        CmsFlexResponse w_res = new CmsFlexResponse((HttpServletResponse)res, controller); \n        \n        // Push req/res to controller queue\n        controller.pushRequest(w_req);\n        controller.pushResponse(w_res);             \n        \n        CmsFlexCacheEntry entry = null;\n        if (f_req.isCacheable()) {\n            // Caching is on, check if requested resource is already in cache            \n            entry = cache.get(w_req.getCmsCacheKey());\n            if (entry != null) {\n                // The target is already in the cache\n                try {\n                    if (DEBUG > 0) System.err.println(\"FlexDispatcher: Loading file from cache for \" + m_vfsTarget);\n                    entry.service(w_req, w_res);\n                } catch (com.opencms.core.CmsException e) {\n                    throw new ServletException(\"FlexDispatcher: Error while loading file from cache for \" + m_vfsTarget + \"\\n\" + e, e);\n                }                       \n            } else { \n                // Cache is on and resource is not yet cached, so we need to read the cache key for the response\n                CmsFlexCacheKey res_key = cache.getKey(CmsFlexCacheKey.getKeyName(m_vfsTarget, w_req.isOnline(), w_req.isWorkplace()));            \n                if (res_key != null) {\n                    // Key already in cache, reuse it\n                    w_res.setCmsCacheKey(res_key);                                             \n                } else {                                \n                    // Cache key is unknown, read key from properties\n                    String cacheProperty = null;\n                    try {\n                        // Read caching property from requested VFS resource                                     \n                        cacheProperty = cms.readProperty(m_vfsTarget, org.opencms.loader.I_CmsResourceLoader.C_LOADER_CACHEPROPERTY);                    \n                        cache.putKey(w_res.setCmsCacheKey(cms.getRequestContext().addSiteRoot(m_vfsTarget), cacheProperty, f_req.isOnline(), f_req.isWorkplace()));                                            \n                    } catch (com.opencms.core.CmsException e) {\n                        if (e.getType() == CmsException.C_FLEX_CACHE) {\n                            // Invalid key is ignored but logged, used key is cache=never\n                            if (OpenCms.isLogging(I_CmsLogChannels.C_OPENCMS_INFO)) \n                                OpenCms.log(I_CmsLogChannels.C_OPENCMS_INFO, \"[FlexCache] Invalid cache key for external resource \\\"\" + m_vfsTarget + \"\\\": \" + cacheProperty);\n                            // There will be a vaild key in the response (\"cache=never\") even after an exception\n                            cache.putKey(w_res.getCmsCacheKey());\n                        } else {\n                            // All other errors are not handled here\n                            throw new ServletException(\"FlexDispatcher: Error while loading cache properties for \" + m_vfsTarget + \"\\n\" + e, e);\n                        }\n                    }                \n                    if (DEBUG > 1) System.err.println(\"FlexDispatcher: Cache properties for file \" + m_vfsTarget + \" are: \" + cacheProperty);\n                }\n            }\n        }\n\n        if (entry == null) {\n            // The target is not cached (or caching off), so load it with the internal resource loader\n            org.opencms.loader.I_CmsResourceLoader loader = null;\n\n            String variation = null;\n            // Check cache keys to see if the result can be cached \n            if (w_req.isCacheable()) variation = w_res.getCmsCacheKey().matchRequestKey(w_req.getCmsCacheKey());\n            // Indicate to the response if caching is not required\n            w_res.setCmsCachingRequired(variation != null);\n                        \n            try {\n                if (resource == null) resource = cms.readFileHeader(m_vfsTarget);\n                int type = resource.getLoaderId();\n                if (DEBUG > 0) System.err.println(\"FlexDispatcher: Loading resource type \" + type);\n                loader = OpenCms.getLoaderManager().getLoader(type);\n            } catch (java.lang.ClassCastException e) {\n                throw new ServletException(\"FlexDispatcher: CmsResourceLoader interface not implemented for cms resource \" + m_vfsTarget + \"\\n\" + e, e);\n            } catch (com.opencms.core.CmsException e) {\n                // File might not exist or no read permissions\n                throw new ServletException(\"FlexDispatcher: Error while reading header for cms resource \" + m_vfsTarget + \"\\n\" + e, e);\n            }\n                     \n            if (DEBUG > 0) System.err.println(\"FlexDispatcher: Internal call, loading file using loader.service() for \" + m_vfsTarget);\n            loader.service(cms, resource, w_req, w_res);\n\n            entry = w_res.processCacheEntry(); \n            if ((entry != null) && (variation != null) && w_req.isCacheable()) {                                      \n                cache.put(w_res.getCmsCacheKey(), entry, variation);                        \n            }                \n        }          \n        \n        if (f_res.hasIncludeList()) {\n            // Special case: This indicates that the output was not yet displayed\n            java.util.Map headers = w_res.getHeaders();\n            byte[] result = w_res.getWriterBytes();\n            if (DEBUG > 3) System.err.println(\"Non-display include call - Result of include is:\\n\" + new String(result));\n            CmsFlexResponse.processHeaders(headers, f_res);\n            f_res.addToIncludeResults(result);                    \n        }              \n\n        // Indicate to response that include is finished\n        f_res.setCmsIncludeMode(false);\n        f_req.removeIncludeCall(m_vfsTarget);      \n          \n        // Pop req/res from controller queue\n        controller.popRequest();\n        controller.popResponse();            \n    }","commit_id":"cba1c0602bf69cec839d06351ccb92b41d1e7f64","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private static void tryNavigateToSuperMethod(Editor editor,\n                                               DartComponent methodDeclaration,\n                                               List<DartComponent> superItems) {\n    final String methodName = methodDeclaration.getName();\n    if (methodName == null || !methodDeclaration.isPublic()) {\n      return;\n    }\n    final List<DartComponent> filteredSuperItems = ContainerUtil.filter(superItems, new Condition<DartComponent>() {\n      @Override\n      public boolean value(DartComponent component) {\n        return methodName.equals(component.getName());\n      }\n    });\n    if (!filteredSuperItems.isEmpty()) {\n      final NavigatablePsiElement[] targets =\n        DartResolveUtil.getComponentNames(filteredSuperItems).toArray(new NavigatablePsiElement[filteredSuperItems.size()]);\n      PsiElementListNavigator.openTargets(editor,\n                                          targets,\n                                          DaemonBundle.message(\"navigation.title.super.method\", methodName),\n                                          null,\n                                          new DefaultPsiElementCellRenderer());\n    }\n  }","id":93709,"modified_method":"private static void tryNavigateToSuperMethod(Editor editor,\n                                               DartComponent methodDeclaration,\n                                               List<DartComponent> superItems) {\n    final String methodName = methodDeclaration.getName();\n    if (methodName == null || !methodDeclaration.isPublic()) {\n      return;\n    }\n    final List<DartComponent> filteredSuperItems = ContainerUtil.filter(superItems, new Condition<DartComponent>() {\n      @Override\n      public boolean value(DartComponent component) {\n        return methodName.equals(component.getName());\n      }\n    });\n    if (!filteredSuperItems.isEmpty()) {\n      final NavigatablePsiElement[] targets = DartResolveUtil.getComponentNameArray(filteredSuperItems);\n      PsiElementListNavigator.openTargets(editor,\n                                          targets,\n                                          DaemonBundle.message(\"navigation.title.super.method\", methodName),\n                                          null,\n                                          new DefaultPsiElementCellRenderer());\n    }\n  }","commit_id":"ea2b8d942ba69e7816aeb34f0b0a20392dcb9cfb","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void invoke(@NotNull Project project, @NotNull Editor editor, @NotNull PsiFile file) {\n    final PsiElement at = file.findElementAt(editor.getCaretModel().getOffset());\n\n    final DartComponent component = PsiTreeUtil.getParentOfType(at, DartComponent.class);\n    final DartClass dartClass = PsiTreeUtil.getParentOfType(at, DartClass.class);\n    if (at == null || dartClass == null || component == null) return;\n\n    final List<DartClass> supers = new ArrayList<DartClass>();\n    final DartType superClass = dartClass.getSuperClass();\n    // looks like there's no sense in jumping to Object class\n    if (superClass != null && !DartResolveUtil.OBJECT.equals(superClass.getReferenceExpression().getText())) {\n      final DartClassResolveResult dartClassResolveResult = DartResolveUtil.resolveClassByType(superClass);\n      if (dartClassResolveResult.getDartClass() != null) {\n        supers.add(dartClassResolveResult.getDartClass());\n      }\n    }\n\n    List<DartClassResolveResult> implementsAndMixinsList =\n      DartResolveUtil.resolveClassesByTypes(DartResolveUtil.getImplementsAndMixinsList(dartClass));\n    for (DartClassResolveResult resolveResult : implementsAndMixinsList) {\n      final DartClass resolveResultDartClass = resolveResult.getDartClass();\n      if (resolveResultDartClass != null) {\n        supers.add(resolveResultDartClass);\n      }\n    }\n    final List<DartComponent> superItems = DartResolveUtil.findNamedSubComponents(false, supers.toArray(new DartClass[supers.size()]));\n\n    final DartComponentType type = DartComponentType.typeOf(component);\n    if (type == DartComponentType.METHOD) {\n      tryNavigateToSuperMethod(editor, component, superItems);\n    }\n    else if (!supers.isEmpty() && component instanceof DartClass) {\n      PsiElementListNavigator.openTargets(\n        editor,\n        DartResolveUtil.getComponentNames(supers).toArray(new NavigatablePsiElement[supers.size()]),\n        DaemonBundle.message(\"navigation.title.subclass\", component.getName(), supers.size()),\n        \"Subclasses of \" + component.getName(),\n        new DefaultPsiElementCellRenderer()\n      );\n    }\n  }","id":93710,"modified_method":"@Override\n  public void invoke(@NotNull Project project, @NotNull Editor editor, @NotNull PsiFile file) {\n    final PsiElement at = file.findElementAt(editor.getCaretModel().getOffset());\n\n    final DartComponent component = PsiTreeUtil.getParentOfType(at, DartComponent.class);\n    final DartClass dartClass = PsiTreeUtil.getParentOfType(at, DartClass.class);\n    if (at == null || dartClass == null || component == null) return;\n\n    final List<DartClass> supers = new ArrayList<DartClass>();\n    final DartType superClass = dartClass.getSuperClass();\n    // looks like there's no sense in jumping to Object class\n    if (superClass != null && !DartResolveUtil.OBJECT.equals(superClass.getReferenceExpression().getText())) {\n      final DartClassResolveResult dartClassResolveResult = DartResolveUtil.resolveClassByType(superClass);\n      if (dartClassResolveResult.getDartClass() != null) {\n        supers.add(dartClassResolveResult.getDartClass());\n      }\n    }\n\n    List<DartClassResolveResult> implementsAndMixinsList =\n      DartResolveUtil.resolveClassesByTypes(DartResolveUtil.getImplementsAndMixinsList(dartClass));\n    for (DartClassResolveResult resolveResult : implementsAndMixinsList) {\n      final DartClass resolveResultDartClass = resolveResult.getDartClass();\n      if (resolveResultDartClass != null) {\n        supers.add(resolveResultDartClass);\n      }\n    }\n    final List<DartComponent> superItems = DartResolveUtil.findNamedSubComponents(false, supers.toArray(new DartClass[supers.size()]));\n\n    final DartComponentType type = DartComponentType.typeOf(component);\n    if (type == DartComponentType.METHOD) {\n      tryNavigateToSuperMethod(editor, component, superItems);\n    }\n    else if (!supers.isEmpty() && component instanceof DartClass) {\n      PsiElementListNavigator.openTargets(\n        editor,\n        DartResolveUtil.getComponentNameArray(supers),\n        DaemonBundle.message(\"navigation.title.subclass\", component.getName(), supers.size()),\n        \"Subclasses of \" + component.getName(),\n        new DefaultPsiElementCellRenderer()\n      );\n    }\n  }","commit_id":"ea2b8d942ba69e7816aeb34f0b0a20392dcb9cfb","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  private static LineMarkerInfo createImplementationMarker(@NotNull final DartClass dartClass, @NotNull final List<DartClass> subClasses) {\n    final DartComponentName componentName = dartClass.getComponentName();\n    assert componentName != null : dartClass.getText(); // unnamed class can't have subclasses\n\n    return new LineMarkerInfo<PsiElement>(\n      componentName,\n      componentName.getTextRange(),\n      AllIcons.Gutter.OverridenMethod,\n      Pass.UPDATE_OVERRIDEN_MARKERS,\n      new Function<PsiElement, String>() {\n        @Override\n        public String fun(PsiElement element) {\n          return DaemonBundle.message(\"method.is.implemented.too.many\");\n        }\n      },\n      new GutterIconNavigationHandler<PsiElement>() {\n        @Override\n        public void navigate(MouseEvent e, PsiElement elt) {\n          PsiElementListNavigator.openTargets(\n            e, DartResolveUtil.getComponentNames(subClasses).toArray(new NavigatablePsiElement[subClasses.size()]),\n            DaemonBundle.message(\"navigation.title.subclass\", dartClass.getName(), subClasses.size()),\n            \"Superclasses of \" + dartClass.getName(),\n            new DefaultPsiElementCellRenderer()\n          );\n        }\n      },\n      GutterIconRenderer.Alignment.RIGHT\n    );\n  }","id":93711,"modified_method":"@NotNull\n  private static LineMarkerInfo createImplementationMarker(@NotNull final DartClass dartClass, @NotNull final List<DartClass> subClasses) {\n    final DartComponentName componentName = dartClass.getComponentName();\n    assert componentName != null : dartClass.getText(); // unnamed class can't have subclasses\n\n    return new LineMarkerInfo<PsiElement>(\n      componentName,\n      componentName.getTextRange(),\n      AllIcons.Gutter.OverridenMethod,\n      Pass.UPDATE_OVERRIDEN_MARKERS,\n      new Function<PsiElement, String>() {\n        @Override\n        public String fun(PsiElement element) {\n          return DaemonBundle.message(\"method.is.implemented.too.many\");\n        }\n      },\n      new GutterIconNavigationHandler<PsiElement>() {\n        @Override\n        public void navigate(MouseEvent e, PsiElement elt) {\n          PsiElementListNavigator.openTargets(\n            e, DartResolveUtil.getComponentNameArray(subClasses),\n            DaemonBundle.message(\"navigation.title.subclass\", dartClass.getName(), subClasses.size()),\n            \"Superclasses of \" + dartClass.getName(),\n            new DefaultPsiElementCellRenderer()\n          );\n        }\n      },\n      GutterIconRenderer.Alignment.RIGHT\n    );\n  }","commit_id":"ea2b8d942ba69e7816aeb34f0b0a20392dcb9cfb","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  private static LineMarkerInfo tryCreateOverrideMarker(final DartComponent methodDeclaration,\n                                                        List<DartComponent> superItems) {\n    final String methodName = methodDeclaration.getName();\n    if (methodName == null || !methodDeclaration.isPublic()) {\n      return null;\n    }\n    final List<DartComponent> filteredSuperItems = ContainerUtil.filter(superItems, new Condition<DartComponent>() {\n      @Override\n      public boolean value(DartComponent component) {\n        return methodName.equals(component.getName());\n      }\n    });\n    if (filteredSuperItems.isEmpty()) {\n      return null;\n    }\n    final PsiElement element = methodDeclaration.getComponentName();\n    final DartComponent dartComponent = filteredSuperItems.iterator().next();\n    final boolean overrides = !dartComponent.isAbstract();\n    final Icon icon = overrides ? AllIcons.Gutter.OverridingMethod : AllIcons.Gutter.ImplementingMethod;\n    assert element != null;\n    return new LineMarkerInfo<PsiElement>(\n      element,\n      element.getTextRange(),\n      icon,\n      Pass.UPDATE_ALL,\n      new Function<PsiElement, String>() {\n        @Override\n        public String fun(PsiElement element) {\n          final DartClass superDartClass = PsiTreeUtil.getParentOfType(methodDeclaration, DartClass.class);\n          if (superDartClass == null) return \"null\";\n          if (overrides) {\n            return DartBundle.message(\"overrides.method.in\", methodDeclaration.getName(), superDartClass.getName());\n          }\n          return DartBundle.message(\"implements.method.in\", methodDeclaration.getName(), superDartClass.getName());\n        }\n      },\n      new GutterIconNavigationHandler<PsiElement>() {\n        @Override\n        public void navigate(MouseEvent e, PsiElement elt) {\n          PsiElementListNavigator.openTargets(\n            e,\n            DartResolveUtil.getComponentNames(filteredSuperItems).toArray(new NavigatablePsiElement[filteredSuperItems.size()]),\n            DaemonBundle.message(\"navigation.title.super.method\", methodDeclaration.getName()),\n            DaemonBundle.message(\"navigation.findUsages.title.super.method\", methodDeclaration.getName()),\n            new DefaultPsiElementCellRenderer());\n        }\n      },\n      GutterIconRenderer.Alignment.LEFT\n    );\n  }","id":93712,"modified_method":"@Nullable\n  private static LineMarkerInfo tryCreateOverrideMarker(final DartComponent methodDeclaration,\n                                                        List<DartComponent> superItems) {\n    final String methodName = methodDeclaration.getName();\n    if (methodName == null || !methodDeclaration.isPublic()) {\n      return null;\n    }\n    final List<DartComponent> filteredSuperItems = ContainerUtil.filter(superItems, new Condition<DartComponent>() {\n      @Override\n      public boolean value(DartComponent component) {\n        return methodName.equals(component.getName());\n      }\n    });\n    if (filteredSuperItems.isEmpty()) {\n      return null;\n    }\n    final PsiElement element = methodDeclaration.getComponentName();\n    final DartComponent dartComponent = filteredSuperItems.iterator().next();\n    final boolean overrides = !dartComponent.isAbstract();\n    final Icon icon = overrides ? AllIcons.Gutter.OverridingMethod : AllIcons.Gutter.ImplementingMethod;\n    assert element != null;\n    return new LineMarkerInfo<PsiElement>(\n      element,\n      element.getTextRange(),\n      icon,\n      Pass.UPDATE_ALL,\n      new Function<PsiElement, String>() {\n        @Override\n        public String fun(PsiElement element) {\n          final DartClass superDartClass = PsiTreeUtil.getParentOfType(methodDeclaration, DartClass.class);\n          if (superDartClass == null) return \"null\";\n          if (overrides) {\n            return DartBundle.message(\"overrides.method.in\", methodDeclaration.getName(), superDartClass.getName());\n          }\n          return DartBundle.message(\"implements.method.in\", methodDeclaration.getName(), superDartClass.getName());\n        }\n      },\n      new GutterIconNavigationHandler<PsiElement>() {\n        @Override\n        public void navigate(MouseEvent e, PsiElement elt) {\n          PsiElementListNavigator.openTargets(\n            e,\n            DartResolveUtil.getComponentNameArray(filteredSuperItems),\n            DaemonBundle.message(\"navigation.title.super.method\", methodDeclaration.getName()),\n            DaemonBundle.message(\"navigation.findUsages.title.super.method\", methodDeclaration.getName()),\n            new DefaultPsiElementCellRenderer());\n        }\n      },\n      GutterIconRenderer.Alignment.LEFT\n    );\n  }","commit_id":"ea2b8d942ba69e7816aeb34f0b0a20392dcb9cfb","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void invoke(@NotNull Project project, @NotNull Editor editor, @NotNull PsiFile file) {\n    final PsiElement at = file.findElementAt(editor.getCaretModel().getOffset());\n    final DartComponent inComponent = PsiTreeUtil.getParentOfType(at, DartComponent.class);\n    final DartComponent inClass = PsiTreeUtil.getParentOfType(at, DartClass.class);\n    if (inClass == null || inComponent == null || inComponent.getComponentName() == null) {\n      return;\n    }\n    final boolean isInClass = inComponent instanceof DartClass;\n    // ask for the super type hierarchy\n    final String filePath = file.getVirtualFile().getPath();\n    final int offset = inComponent.getComponentName().getTextOffset();\n    final List<TypeHierarchyItem> items = DartAnalysisServerService.getInstance().search_getTypeHierarchy(filePath, offset, true);\n    // build list of DartComponent(s)\n    final List<DartComponent> supers = Lists.newArrayList();\n    if (!items.isEmpty()) {\n      TypeHierarchyItem seed = items.get(0);\n      {\n        final Integer superIndex = seed.getSuperclass();\n        if (superIndex != null) {\n          final TypeHierarchyItem superItem = items.get(superIndex);\n          addSuperComponent(project, supers, isInClass, superItem);\n        }\n      }\n      for (int superIndex : seed.getInterfaces()) {\n        final TypeHierarchyItem superItem = items.get(superIndex);\n        addSuperComponent(project, supers, isInClass, superItem);\n      }\n    }\n    // prepare the title\n    final String title;\n    if (isInClass) {\n      title = DartBundle.message(\"goto.super.class.chooser.title\");\n    }\n    else {\n      title = CodeInsightBundle.message(\"goto.super.method.chooser.title\");\n    }\n    // open DartComponent(s)\n    final NavigatablePsiElement[] targets = DartResolveUtil.getComponentNames(supers).toArray(new NavigatablePsiElement[supers.size()]);\n    PsiElementListNavigator.openTargets(editor, targets, title, null, new DefaultPsiElementCellRenderer());\n  }","id":93713,"modified_method":"@Override\n  public void invoke(@NotNull Project project, @NotNull Editor editor, @NotNull PsiFile file) {\n    final PsiElement at = file.findElementAt(editor.getCaretModel().getOffset());\n    final DartComponent inComponent = PsiTreeUtil.getParentOfType(at, DartComponent.class);\n    final DartComponent inClass = PsiTreeUtil.getParentOfType(at, DartClass.class);\n    if (inClass == null || inComponent == null || inComponent.getComponentName() == null) {\n      return;\n    }\n    final boolean isInClass = inComponent instanceof DartClass;\n    // ask for the super type hierarchy\n    final String filePath = file.getVirtualFile().getPath();\n    final int offset = inComponent.getComponentName().getTextOffset();\n    final List<TypeHierarchyItem> items = DartAnalysisServerService.getInstance().search_getTypeHierarchy(filePath, offset, true);\n    // build list of DartComponent(s)\n    final List<DartComponent> supers = Lists.newArrayList();\n    if (!items.isEmpty()) {\n      TypeHierarchyItem seed = items.get(0);\n      {\n        final Integer superIndex = seed.getSuperclass();\n        if (superIndex != null) {\n          final TypeHierarchyItem superItem = items.get(superIndex);\n          addSuperComponent(project, supers, isInClass, superItem);\n        }\n      }\n      for (int superIndex : seed.getInterfaces()) {\n        final TypeHierarchyItem superItem = items.get(superIndex);\n        addSuperComponent(project, supers, isInClass, superItem);\n      }\n    }\n    // prepare the title\n    final String title;\n    if (isInClass) {\n      title = DartBundle.message(\"goto.super.class.chooser.title\");\n    }\n    else {\n      title = CodeInsightBundle.message(\"goto.super.method.chooser.title\");\n    }\n    // open DartComponent(s)\n    final NavigatablePsiElement[] targets = DartResolveUtil.getComponentNameArray(supers);\n    PsiElementListNavigator.openTargets(editor, targets, title, null, new DefaultPsiElementCellRenderer());\n  }","commit_id":"ea2b8d942ba69e7816aeb34f0b0a20392dcb9cfb","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  private static LineMarkerInfo tryCreateOverrideMarker(final DartComponentName componentName,\n                                                        final DartComponent superclassComponent,\n                                                        final List<DartComponent> interfaceComponents) {\n    if (superclassComponent == null && interfaceComponents.isEmpty()) {\n      return null;\n    }\n    final String name = componentName.getName();\n    final boolean overrides;\n    final DartComponent superComponent;\n    if (superclassComponent != null) {\n      overrides = true;\n      superComponent = superclassComponent;\n    }\n    else {\n      overrides = false;\n      superComponent = interfaceComponents.iterator().next();\n    }\n    final Icon icon = overrides ? AllIcons.Gutter.OverridingMethod : AllIcons.Gutter.ImplementingMethod;\n    return new LineMarkerInfo<PsiElement>(componentName, componentName.getTextRange(), icon, Pass.UPDATE_ALL,\n                                          new Function<PsiElement, String>() {\n                                            @Override\n                                            public String fun(PsiElement element) {\n                                              final DartClass superClass = PsiTreeUtil.getParentOfType(superComponent, DartClass.class);\n                                              if (superClass == null) return \"null\";\n                                              if (overrides) {\n                                                return DartBundle.message(\"overrides.method.in\", name, superClass.getName());\n                                              }\n                                              return DartBundle.message(\"implements.method.in\", name, superClass.getName());\n                                            }\n                                          }, new GutterIconNavigationHandler<PsiElement>() {\n      @Override\n      public void navigate(MouseEvent e, PsiElement elt) {\n        List<DartComponent> superComponents = Lists.newArrayList();\n        if (superclassComponent != null) {\n          superComponents.add(superclassComponent);\n        }\n        superComponents.addAll(interfaceComponents);\n        PsiElementListNavigator\n          .openTargets(e, DartResolveUtil.getComponentNames(superComponents).toArray(new NavigatablePsiElement[superComponents.size()]),\n                       DaemonBundle.message(\"navigation.title.super.method\", name),\n                       DaemonBundle.message(\"navigation.findUsages.title.super.method\", name), new DefaultPsiElementCellRenderer());\n      }\n    }, GutterIconRenderer.Alignment.LEFT);\n  }","id":93714,"modified_method":"@Nullable\n  private static LineMarkerInfo tryCreateOverrideMarker(final DartComponentName componentName,\n                                                        final DartComponent superclassComponent,\n                                                        final List<DartComponent> interfaceComponents) {\n    if (superclassComponent == null && interfaceComponents.isEmpty()) {\n      return null;\n    }\n    final String name = componentName.getName();\n    final boolean overrides;\n    final DartComponent superComponent;\n    if (superclassComponent != null) {\n      overrides = true;\n      superComponent = superclassComponent;\n    }\n    else {\n      overrides = false;\n      superComponent = interfaceComponents.iterator().next();\n    }\n    final Icon icon = overrides ? AllIcons.Gutter.OverridingMethod : AllIcons.Gutter.ImplementingMethod;\n    return new LineMarkerInfo<PsiElement>(componentName, componentName.getTextRange(), icon, Pass.UPDATE_ALL,\n                                          new Function<PsiElement, String>() {\n                                            @Override\n                                            public String fun(PsiElement element) {\n                                              final DartClass superClass = PsiTreeUtil.getParentOfType(superComponent, DartClass.class);\n                                              if (superClass == null) return \"null\";\n                                              if (overrides) {\n                                                return DartBundle.message(\"overrides.method.in\", name, superClass.getName());\n                                              }\n                                              return DartBundle.message(\"implements.method.in\", name, superClass.getName());\n                                            }\n                                          }, new GutterIconNavigationHandler<PsiElement>() {\n      @Override\n      public void navigate(MouseEvent e, PsiElement elt) {\n        List<DartComponent> superComponents = Lists.newArrayList();\n        if (superclassComponent != null) {\n          superComponents.add(superclassComponent);\n        }\n        superComponents.addAll(interfaceComponents);\n        PsiElementListNavigator\n          .openTargets(e, DartResolveUtil.getComponentNameArray(superComponents),\n                       DaemonBundle.message(\"navigation.title.super.method\", name),\n                       DaemonBundle.message(\"navigation.findUsages.title.super.method\", name), new DefaultPsiElementCellRenderer());\n      }\n    }, GutterIconRenderer.Alignment.LEFT);\n  }","commit_id":"ea2b8d942ba69e7816aeb34f0b0a20392dcb9cfb","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n\t * Assuming some attributes have been changed, toXmlString() rebuilds the String on based on the\n\t * tags informations.\n\t * \n\t * @param attributeToBeIgnored\n\t * @return A xml string matching the tag\n\t */\n\tpublic CharSequence toXmlString(final String attributeToBeIgnored)\n\t{\n\t\tfinal AppendingStringBuffer buffer = new AppendingStringBuffer();\n\n\t\tbuffer.append('<');\n\n\t\tif (type == TagType.CLOSE)\n\t\t{\n\t\t\tbuffer.append('/');\n\t\t}\n\n\t\tif (namespace != null)\n\t\t{\n\t\t\tbuffer.append(namespace);\n\t\t\tbuffer.append(':');\n\t\t}\n\n\t\tbuffer.append(name);\n\n\t\tfinal IValueMap attributes = getAttributes();\n\t\tif (attributes.size() > 0)\n\t\t{\n\t\t\tfinal Iterator<String> iterator = attributes.keySet().iterator();\n\t\t\tfor (; iterator.hasNext();)\n\t\t\t{\n\t\t\t\tfinal String key = iterator.next();\n\t\t\t\tif ((key != null) &&\n\t\t\t\t\t((attributeToBeIgnored == null) || !key.equalsIgnoreCase(attributeToBeIgnored)))\n\t\t\t\t{\n\t\t\t\t\tbuffer.append(\" \");\n\t\t\t\t\tbuffer.append(key);\n\t\t\t\t\tCharSequence value = getAttribute(key);\n\n\t\t\t\t\t// Attributes without values are possible, e.g. 'disabled'\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuffer.append(\"=\\\"\");\n\t\t\t\t\t\tvalue = Strings.escapeMarkup(value);\n\t\t\t\t\t\tbuffer.append(value);\n\t\t\t\t\t\tbuffer.append(\"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (type == TagType.OPEN_CLOSE)\n\t\t{\n\t\t\tbuffer.append('/');\n\t\t}\n\n\t\tbuffer.append('>');\n\t\treturn buffer;\n\t}","id":93715,"modified_method":"/**\n\t * Assuming some attributes have been changed, toXmlString() rebuilds the String on based on the\n\t * tags informations.\n\t * \n\t * @param attributeToBeIgnored\n\t * @return A xml string matching the tag\n\t */\n\tpublic CharSequence toXmlString(final String attributeToBeIgnored)\n\t{\n\t\tfinal AppendingStringBuffer buffer = new AppendingStringBuffer();\n\n\t\tbuffer.append('<');\n\n\t\tif (type == TagType.CLOSE)\n\t\t{\n\t\t\tbuffer.append('/');\n\t\t}\n\n\t\tif (namespace != null)\n\t\t{\n\t\t\tbuffer.append(namespace);\n\t\t\tbuffer.append(':');\n\t\t}\n\n\t\tbuffer.append(name);\n\n\t\tfinal IValueMap attributes = getAttributes();\n\t\tif (attributes.size() > 0)\n\t\t{\n\t\t\tfinal Iterator<String> iterator = attributes.keySet().iterator();\n\t\t\tfor (; iterator.hasNext();)\n\t\t\t{\n\t\t\t\tfinal String key = iterator.next();\n\t\t\t\tif ((key != null) &&\n\t\t\t\t\t((attributeToBeIgnored == null) || !key.equalsIgnoreCase(attributeToBeIgnored)))\n\t\t\t\t{\n\t\t\t\t\tbuffer.append(' ');\n\t\t\t\t\tbuffer.append(key);\n\t\t\t\t\tCharSequence value = getAttribute(key);\n\n\t\t\t\t\t// Attributes without values are possible, e.g. 'disabled'\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuffer.append(\"=\\\"\");\n\t\t\t\t\t\tvalue = Strings.escapeMarkup(value);\n\t\t\t\t\t\tbuffer.append(value);\n\t\t\t\t\t\tbuffer.append('\"');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (type == TagType.OPEN_CLOSE)\n\t\t{\n\t\t\tbuffer.append('/');\n\t\t}\n\n\t\tbuffer.append('>');\n\t\treturn buffer;\n\t}","commit_id":"d2695345f52a9785e7338a1f6e823eec9dcc243d","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets the tag namespace.\n\t * \n\t * @param namespace\n\t *            New tag name\n\t */\n\tpublic void setNamespace(final String namespace)\n\t{\n\t\tif (isMutable)\n\t\t{\n\t\t\tthis.namespace = namespace.intern();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new UnsupportedOperationException(\"Attempt to set namespace of immutable tag\");\n\t\t}\n\t}","id":93716,"modified_method":"/**\n\t * Sets the tag namespace.\n\t * \n\t * @param namespace\n\t *            New tag name\n\t */\n\tpublic void setNamespace(final String namespace)\n\t{\n\t\tif (isMutable)\n\t\t{\n\t\t\tthis.namespace = namespace != null ? namespace.intern() : null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new UnsupportedOperationException(\"Attempt to set namespace of immutable tag\");\n\t\t}\n\t}","commit_id":"d2695345f52a9785e7338a1f6e823eec9dcc243d","url":"https://github.com/apache/wicket"},{"original_method":"public ClientMetadata(String mime) {\n\t\tmimeType = mime.intern();\n\t}","id":93717,"modified_method":"public ClientMetadata(String mime) {\n\t\tmimeType = (mime == null) ? null : mime.intern();\n\t}","commit_id":"1de412f27fd22a4337d13d7659c089c31ecf34be","url":"https://github.com/freenet/fred"},{"original_method":"public static synchronized void setStorageList( List<StorageInfoWeb> newStorageList ) throws EucalyptusCloudException {\n\t\tList<StorageControllerConfiguration> storageControllerConfig = Lists.newArrayList( );\n\t\tfor ( StorageInfoWeb storageControllerWeb : newStorageList ) {\n\t\t\tstorageControllerConfig.add( new StorageControllerConfiguration( storageControllerWeb.getName( ), storageControllerWeb.getHost( ), storageControllerWeb.getPort( ) ) );\n\t\t}\n\t\tupdateStorageControllerConfigurations( storageControllerConfig );\n\n\t\tfor(StorageInfoWeb storageControllerWeb : newStorageList) {\n\t\t\tUpdateStorageConfigurationType updateStorageConfiguration = new UpdateStorageConfigurationType();\n\t\t\tupdateStorageConfiguration.setName(storageControllerWeb.getName());\n\t\t\tupdateStorageConfiguration.setMaxTotalVolumeSize(storageControllerWeb.getTotalVolumesSizeInGB());\n\t\t\tupdateStorageConfiguration.setMaxVolumeSize(storageControllerWeb.getMaxVolumeSizeInGB());\n\t\t\tupdateStorageConfiguration.setStorageInterface(storageControllerWeb.getStorageInterface());\n\t\t\tupdateStorageConfiguration.setStorageRootDirectory(storageControllerWeb.getVolumesPath());\n\t\t\tupdateStorageConfiguration.setZeroFillVolumes(storageControllerWeb.getZeroFillVolumes());\n\t\t\tServiceDispatcher scDispatch = ServiceDispatcher.lookup(Component.storage, \n\t\t\t\t\tstorageControllerWeb.getHost());\n\t\t\tif(Component.eucalyptus.isLocal()) {\n\t\t\t\tupdateStorageConfiguration.setName(StorageProperties.SC_LOCAL_NAME);\n\t\t\t}\n\t\t\tscDispatch.send(updateStorageConfiguration);\n\t\t}\n\t}","id":93718,"modified_method":"public static synchronized void setStorageList( List<StorageInfoWeb> newStorageList ) throws EucalyptusCloudException {\n\t\tList<StorageControllerConfiguration> storageControllerConfig = Lists.newArrayList( );\n\t\tfor ( StorageInfoWeb storageControllerWeb : newStorageList ) {\n\t\t\tstorageControllerConfig.add( new StorageControllerConfiguration( storageControllerWeb.getName( ), storageControllerWeb.getHost( ), storageControllerWeb.getPort( ) ) );\n\t\t}\n\t\tupdateStorageControllerConfigurations( storageControllerConfig );\n\n\t\tfor(StorageInfoWeb storageControllerWeb : newStorageList) {\n\t\t\tUpdateStorageConfigurationType updateStorageConfiguration = new UpdateStorageConfigurationType();\n\t\t\tupdateStorageConfiguration.setName(storageControllerWeb.getName());\n\t\t\tupdateStorageConfiguration.setMaxTotalVolumeSize(storageControllerWeb.getTotalVolumesSizeInGB());\n\t\t\tupdateStorageConfiguration.setMaxVolumeSize(storageControllerWeb.getMaxVolumeSizeInGB());\n\t\t\tupdateStorageConfiguration.setStorageInterface(storageControllerWeb.getStorageInterface());\n\t\t\tupdateStorageConfiguration.setStorageRootDirectory(storageControllerWeb.getVolumesPath());\n\t\t\tupdateStorageConfiguration.setZeroFillVolumes(storageControllerWeb.getZeroFillVolumes());\n\t\t\tServiceDispatcher scDispatch = ServiceDispatcher.lookup(Component.storage, \n\t\t\t\t\tstorageControllerWeb.getHost());\n\t\t\tif(Component.eucalyptus.isLocal()) {\n\t\t\t\tupdateStorageConfiguration.setName(StorageProperties.SC_LOCAL_NAME);\n\t\t\t}\n\t\t\ttry {\n        scDispatch.send(updateStorageConfiguration);\n      } catch ( Exception e ) {\n        LOG.error( \"Error sending update configuration message to storage controller: \" + updateStorageConfiguration );\n        LOG.error( \"The storage controller's configuration may be out of sync!\" );\n        LOG.debug( e, e );\n      }\n\t\t}\n\t}","commit_id":"1d02aeba275d2f210b70e1290ca3be57628b6668","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static synchronized List<StorageInfoWeb> getStorageList( ) throws EucalyptusCloudException {\n\t\tList<StorageInfoWeb> storageList = new ArrayList<StorageInfoWeb>( );\n    for( ClusterConfiguration cc : Configuration.getClusterConfigurations( ) ) {\n    \ttry {\n        if( NetworkUtil.testLocal( cc.getHostName( ) ) && !Component.storage.isEnabled( ) ) {\n        \tstorageList.add( StorageInfoWeb.DEFAULT_SC );\n        \tcontinue;\n        }\n      } catch ( Exception e ) {\n        LOG.debug( \"Got an error while trying to retrieving storage controller configuration list\", e );\n      }\n    \tStorageControllerConfiguration c;\n    \ttry {\n    \t\tc = Configuration.getStorageControllerConfiguration(  cc.getName( ) );\n    \t\ttry {\n    \t\t\tGetStorageConfigurationType getStorageConfiguration = new GetStorageConfigurationType(c.getName());\n    \t\t\tif(NetworkUtil.testLocal( cc.getHostName( ) ) && Component.storage.isEnabled()) {\n    \t\t\t\tgetStorageConfiguration.setName(StorageProperties.NAME);\n    \t\t\t} \n    \t\t\tServiceDispatcher scDispatch = ServiceDispatcher.lookup(Component.storage, c.getHostName());\n    \t\t\tGetStorageConfigurationResponseType getStorageConfigResponse = \n    \t\t\t\tscDispatch.send(getStorageConfiguration, GetStorageConfigurationResponseType.class);\n    \t\t\tstorageList.add(new StorageInfoWeb(c.getName(), \n    \t\t\t\t\tc.getHostName(), \n    \t\t\t\t\tc.getPort(), \n    \t\t\t\t\tgetStorageConfigResponse.getStorageRootDirectory(), \n    \t\t\t\t\tgetStorageConfigResponse.getMaxVolumeSize(), \n    \t\t\t\t\tgetStorageConfigResponse.getMaxTotalVolumeSize(), \n    \t\t\t\t\tgetStorageConfigResponse.getStorageInterface(), \n    \t\t\t\t\tgetStorageConfigResponse.getZeroFillVolumes()));\n    \t\t} catch ( Throwable e ) {\n    \t\t\tLOG.debug( \"Got an error while trying to retrieving storage controller configuration list\", e );\n    \t\t\tstorageList.add(new StorageInfoWeb(c.getName(), \n    \t\t\t\t\tc.getHostName(), \n    \t\t\t\t\tc.getPort(), \n    \t\t\t\t\tStorageInfoWeb.DEFAULT_SC.getVolumesPath( ), \n    \t\t\t\t\tStorageInfoWeb.DEFAULT_SC.getMaxVolumeSizeInGB( ), \n    \t\t\t\t\tStorageInfoWeb.DEFAULT_SC.getTotalVolumesSizeInGB( ), \n    \t\t\t\t\tStorageInfoWeb.DEFAULT_SC.getStorageInterface( ), \n    \t\t\t\t\tStorageInfoWeb.DEFAULT_SC.getZeroFillVolumes()));            \n    \t\t}\n    \t} catch ( Exception e1 ) {\n    \t\tstorageList.add( StorageInfoWeb.DEFAULT_SC );\n    \t}\n    }\n\t\treturn storageList;\n\t}","id":93719,"modified_method":"public static synchronized List<StorageInfoWeb> getStorageList( ) throws EucalyptusCloudException {\n\t\tList<StorageInfoWeb> storageList = new ArrayList<StorageInfoWeb>( );\n    for( ClusterConfiguration cc : Configuration.getClusterConfigurations( ) ) {\n    \ttry {\n        if( NetworkUtil.testLocal( cc.getHostName( ) ) && !Component.storage.isEnabled( ) ) {\n        \tstorageList.add( StorageInfoWeb.DEFAULT_SC );\n        \tcontinue;\n        }\n      } catch ( Exception e ) {\n        LOG.debug( \"Got an error while trying to retrieving storage controller configuration list\", e );\n      }\n    \tStorageControllerConfiguration c;\n    \ttry {\n    \t\tc = Configuration.getStorageControllerConfiguration(  cc.getName( ) );\n    \t\tStorageInfoWeb scInfo = new StorageInfoWeb( c.getName( ), c.getHostName( ), c.getPort( ) );\n    \t\ttry {\n          GetStorageConfigurationResponseType getStorageConfigResponse = RemoteInfoHandler.sendForStorageInfo( cc, c );\n          if( c.getName( ).equals( getStorageConfigResponse.getName( ) ) ) {\n            scInfo.setVolumesPath( getStorageConfigResponse.getStorageRootDirectory( ) );\n            scInfo.setMaxVolumeSizeInGB( getStorageConfigResponse.getMaxVolumeSize( ) );\n            scInfo.setTotalVolumesSizeInGB( getStorageConfigResponse.getMaxTotalVolumeSize( ) );\n            scInfo.setStorageInterface( getStorageConfigResponse.getStorageInterface( ) );\n            scInfo.setZeroFillVolumes( getStorageConfigResponse.getZeroFillVolumes( ) );\n          } else {\n            LOG.debug(\"Unexpected storage controller name: \" + getStorageConfigResponse.getName( ), new Exception());\n            LOG.debug(\"Expected configuration for SC related to CC: \" + LogUtil.dumpObject( c ) );\n            LOG.debug(\"Received configuration for SC related to CC: \" + LogUtil.dumpObject( getStorageConfigResponse ) );            \n          }\n    \t\t} catch ( Throwable e ) {\n    \t\t\tLOG.debug( \"Got an error while trying to communicate with remote storage controller\", e );\n    \t\t}\n    \t\tstorageList.add( scInfo );\n    \t} catch ( Exception e1 ) {\n    \t\tstorageList.add( StorageInfoWeb.DEFAULT_SC );\n    \t}\n    }\n\t\treturn storageList;\n\t}","commit_id":"1d02aeba275d2f210b70e1290ca3be57628b6668","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void stop() {\n        super.stop();\n        running = false;\n        for (RouterStub stub : stubs) {\n            try {\n                stub.disconnect(group_addr, local_addr);\n            } catch (Exception e) {\n            }\n        }\n        stopReconnector();\n    }","id":93720,"modified_method":"public void stop() {\n        super.stop();       \n        stubManager.disconnectStubs();\n    }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void connect(String group, Address logical_addr) {\n        String logical_name=org.jgroups.util.UUID.get(logical_addr);\n        PhysicalAddress physical_addr=(PhysicalAddress)down_prot.down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr));\n        List<PhysicalAddress> physical_addrs=physical_addr != null? new ArrayList<PhysicalAddress>() : null;\n        if(physical_addr != null)\n            physical_addrs.add(physical_addr);\n\n        int num_faulty_conns=0;\n        for (RouterStub stub : stubs) {\n            try {\n                if(log.isTraceEnabled())\n                    log.trace(\"trying to connect to \" + stub.getGossipRouterAddress());\n                stub.connect(group, logical_addr, logical_name, physical_addrs);\n            }\n            catch(Exception e) {\n                if(log.isErrorEnabled())\n                log.error(\"failed connecting to \" + stub.getGossipRouterAddress(), e);\n                num_faulty_conns++;\n            }\n        }\n        if(num_faulty_conns == 0)\n            stopReconnector();\n    }","id":93721,"modified_method":"protected void connect(String group, Address logical_addr) {\n        String logical_name=org.jgroups.util.UUID.get(logical_addr);\n        PhysicalAddress physical_addr=(PhysicalAddress)down_prot.down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr));\n        List<PhysicalAddress> physical_addrs=physical_addr != null? new ArrayList<PhysicalAddress>() : null;\n        if(physical_addr != null)\n            physical_addrs.add(physical_addr);\n\n      \n        for (RouterStub stub : stubManager.getStubs()) {\n            try {\n                if(log.isTraceEnabled())\n                    log.trace(\"trying to connect to \" + stub.getGossipRouterAddress());\n                stub.connect(group, logical_addr, logical_name, physical_addrs);\n            }\n            catch(Exception e) {\n                if(log.isErrorEnabled())\n                log.error(\"failed connecting to \" + stub.getGossipRouterAddress(), e); \n                stubManager.startReconnecting(stub);\n            }\n        }     \n    }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendGetMembersRequest(String cluster_name, Promise promise, boolean return_views_only) throws Exception {\n        if (group_addr == null) {\n            if (log.isErrorEnabled())\n                log.error(\"cluster_name is null, cannot get membership\");\n            return;\n        }\n\n        if (log.isTraceEnabled())\n            log.trace(\"fetching members from GossipRouter(s)\");\n\n        final List<PingData> responses = new LinkedList<PingData>();\n        for (RouterStub stub : stubs) {\n            try {\n                List<PingData> rsps = stub.getMembers(group_addr);\n                responses.addAll(rsps);\n            }\n            catch(Throwable t) {\n                log.warn(\"failed fetching members from \" + stub.getGossipRouterAddress() + \": \" +  t);\n            }\n        }\n\n        final Set<Address> initial_mbrs = new HashSet<Address>();\n        for (PingData rsp : responses) {\n            Address logical_addr = rsp.getAddress();\n            initial_mbrs.add(logical_addr);\n\n            // 1. Set physical addresses\n            Collection<PhysicalAddress> physical_addrs = rsp.getPhysicalAddrs();\n            if (physical_addrs != null) {\n                for (PhysicalAddress physical_addr : physical_addrs)\n                    down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address, PhysicalAddress>(\n                                    logical_addr, physical_addr)));\n            }\n\n            // 2. Set logical name\n            String logical_name = rsp.getLogicalName();\n            if (logical_name != null && logical_addr instanceof org.jgroups.util.UUID)\n                org.jgroups.util.UUID.add((org.jgroups.util.UUID) logical_addr, logical_name);\n        }\n\n        if (initial_mbrs.isEmpty()) {\n            if (log.isErrorEnabled())\n                log.error(\"[FIND_INITIAL_MBRS]: found no members\");\n            return;\n        }\n        if (log.isTraceEnabled())\n            log.trace(\"consolidated mbrs from GossipRouter(s) are \" + initial_mbrs);\n\n        for (Address mbr_addr : initial_mbrs) {\n            Message msg = new Message(mbr_addr);\n            msg.setFlag(Message.OOB);\n            PingHeader hdr = new PingHeader(PingHeader.GET_MBRS_REQ, cluster_name);\n            hdr.return_view_only = return_views_only;\n            msg.putHeader(this.id, hdr);\n            if (log.isTraceEnabled())\n                log.trace(\"[FIND_INITIAL_MBRS] sending PING request to \" + mbr_addr);\n            down_prot.down(new Event(Event.MSG, msg));\n        }\n    }","id":93722,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public void sendGetMembersRequest(String cluster_name, Promise promise, boolean return_views_only) throws Exception {\n        if (group_addr == null) {\n            if (log.isErrorEnabled())\n                log.error(\"cluster_name is null, cannot get membership\");\n            return;\n        }\n\n        if (log.isTraceEnabled())\n            log.trace(\"fetching members from GossipRouter(s)\");\n\n        final List<PingData> responses = new LinkedList<PingData>();\n        for (RouterStub stub : stubManager.getStubs()) {\n            try {\n                List<PingData> rsps = stub.getMembers(group_addr);\n                responses.addAll(rsps);\n            }\n            catch(Throwable t) {\n                log.warn(\"failed fetching members from \" + stub.getGossipRouterAddress() + \": \" +  t);\n            }\n        }\n\n        final Set<Address> initial_mbrs = new HashSet<Address>();\n        for (PingData rsp : responses) {\n            Address logical_addr = rsp.getAddress();\n            initial_mbrs.add(logical_addr);\n\n            // 1. Set physical addresses\n            Collection<PhysicalAddress> physical_addrs = rsp.getPhysicalAddrs();\n            if (physical_addrs != null) {\n                for (PhysicalAddress physical_addr : physical_addrs)\n                    down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address, PhysicalAddress>(\n                                    logical_addr, physical_addr)));\n            }\n\n            // 2. Set logical name\n            String logical_name = rsp.getLogicalName();\n            if (logical_name != null && logical_addr instanceof org.jgroups.util.UUID)\n                org.jgroups.util.UUID.add((org.jgroups.util.UUID) logical_addr, logical_name);\n        }\n\n        if (initial_mbrs.isEmpty()) {\n            if (log.isErrorEnabled())\n                log.error(\"[FIND_INITIAL_MBRS]: found no members\");\n            return;\n        }\n        if (log.isTraceEnabled())\n            log.trace(\"consolidated mbrs from GossipRouter(s) are \" + initial_mbrs);\n\n        for (Address mbr_addr : initial_mbrs) {\n            Message msg = new Message(mbr_addr);\n            msg.setFlag(Message.OOB);\n            PingHeader hdr = new PingHeader(PingHeader.GET_MBRS_REQ, cluster_name);\n            hdr.return_view_only = return_views_only;\n            msg.putHeader(this.id, hdr);\n            if (log.isTraceEnabled())\n                log.trace(\"[FIND_INITIAL_MBRS] sending PING request to \" + mbr_addr);            \n            down_prot.down(new Event(Event.MSG, msg));\n        }\n    }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"public void destroy() {\n        for (RouterStub stub : stubs) {\n            stub.destroy();\n        }\n        super.destroy();\n    }","id":93723,"modified_method":"public void destroy() {\n        stubManager.destroyStubs();\n        super.destroy();\n    }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"public void handleConnect() {\n        if (group_addr == null || local_addr == null) {\n            if (log.isErrorEnabled())\n                log.error(\"group_addr or local_addr is null, cannot register with GossipRouter(s)\");\n        } else {\n            if (log.isTraceEnabled())\n                log.trace(\"registering \" + local_addr + \" under \" + group_addr\n                                + \" with GossipRouter\");\n            for (RouterStub stub : stubs)\n                // if there are any stubs, destroy them\n                stub.destroy();\n            stubs.clear();\n\n            for (InetSocketAddress host : initial_hosts) {\n                RouterStub stub = new RouterStub(host.getHostName(), host.getPort(), null,this);                \n                stubs.add(stub);\n            }\n            connect(group_addr, local_addr);\n            startConnectionChecker();\n        }\n    }","id":93724,"modified_method":"public void handleConnect() {\n        if (group_addr == null || local_addr == null) {\n            if (log.isErrorEnabled())\n                log.error(\"group_addr or local_addr is null, cannot register with GossipRouter(s)\");\n        } else {\n            if (log.isTraceEnabled())\n                log.trace(\"registering \" + local_addr + \" under \" + group_addr + \" with GossipRouter\");\n            \n            stubManager.destroyStubs();\n            stubManager = new RouterStubManager(this, group_addr, local_addr, reconnect_interval);\n            for (InetSocketAddress host : initial_hosts) {\n                stubManager.createStub(host.getHostName(), host.getPort(), null);                                \n            }\n            connect(group_addr, local_addr);            \n        }\n    }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"public void start() throws Exception {\n        super.start();\n        running=true;\n    }","id":93725,"modified_method":"public void start() throws Exception {\n        super.start();\n    }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"public void init() throws Exception {\n        super.init();\n        \n        if(timeout <= sock_conn_timeout)\n            throw new IllegalArgumentException(\"timeout (\" + timeout + \") must be greater than sock_conn_timeout (\"\n                    + sock_conn_timeout + \")\");\n\n        // we cannot use TCPGOSSIP together with TUNNEL (https://jira.jboss.org/jira/browse/JGRP-1101)\n        TP transport=getTransport();\n        if(transport instanceof TUNNEL)\n            throw new IllegalStateException(\"TCPGOSSIP cannot be used with TUNNEL; use either TUNNEL:PING or \" +\n                    \"TCP:TCPGOSSIP as valid configurations\");\n    }","id":93726,"modified_method":"public void init() throws Exception {\n        super.init();\n        stubManager = RouterStubManager.emptyGossipClientStubManager(this);\n        if(timeout <= sock_conn_timeout)\n            throw new IllegalArgumentException(\"timeout (\" + timeout + \") must be greater than sock_conn_timeout (\"\n                    + sock_conn_timeout + \")\");\n\n        // we cannot use TCPGOSSIP together with TUNNEL (https://jira.jboss.org/jira/browse/JGRP-1101)\n        TP transport=getTransport();\n        if(transport instanceof TUNNEL)\n            throw new IllegalStateException(\"TCPGOSSIP cannot be used with TUNNEL; use either TUNNEL:PING or \" +\n                    \"TCP:TCPGOSSIP as valid configurations\");\n    }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"public void handleDisconnect() {\n        for (RouterStub stub : stubs) {\n            try {\n                stub.disconnect(group_addr, local_addr);\n                stub.destroy();\n            } catch (Exception e) {\n            }\n        }\n        stopConnectionChecker();\n    }","id":93727,"modified_method":"public void handleDisconnect() {\n        stubManager.disconnectStubs();\n    }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"public void init() throws Exception {\n        super.init();\n\n        if(enable_bundling) {\n            log.warn(\"bundling is currently not supported by TUNNEL; bundling is disabled\");\n            enable_bundling=false;\n        }\n\n        if (timer == null)\n            throw new Exception(\"timer cannot be retrieved from protocol stack\");\n      \n        // Postpone TUNNEL and shared transport until 3.0 timeframe\n        // TODO [JGRP-1194] - Revisit implementation of TUNNEL and shared transport\n        if (isSingleton()) {\n            throw new Exception(\"TUNNEL and shared transport mode are not supported!\");\n        }\n\n        if ((router_host == null || router_port == 0) && gossip_router_hosts.isEmpty()) {\n            throw new Exception(\"either router_host and router_port have to be set or a list of gossip routers\");\n        }\n\n        if (router_host != null && router_port != 0 && !gossip_router_hosts.isEmpty()) {\n            throw new Exception(\"cannot specify both router host and port along with gossip_router_hosts\");\n        }\n\n        if (router_host != null && router_port != 0 && gossip_router_hosts.isEmpty()) {\n            gossip_router_hosts.add(new InetSocketAddress(router_host, router_port));\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"GossipRouters are:\" + gossip_router_hosts.toString());\n        }\n        \n        sock = Util.getSocketFactory().createDatagramSocket(Global.TUNNEL_UCAST_SOCK, 0, bind_addr);\n\n        for (InetSocketAddress gr : gossip_router_hosts) {\n           RouterStub stub = new RouterStub(gr.getHostName(), gr.getPort(), bind_addr,new StubConnectionListener());\n           stub.setTcpNoDelay(tcp_nodelay);\n           stubs.add(stub);\n        }     \n        // loopback turned on is mandatory\n        loopback = true;\n    }","id":93728,"modified_method":"public void init() throws Exception {\n        super.init();\n\n        if(enable_bundling) {\n            log.warn(\"bundling is currently not supported by TUNNEL; bundling is disabled\");\n            enable_bundling=false;\n        }\n\n        if (timer == null)\n            throw new Exception(\"timer cannot be retrieved from protocol stack\");\n      \n        // Postpone TUNNEL and shared transport until 3.0 timeframe\n        // TODO [JGRP-1194] - Revisit implementation of TUNNEL and shared transport\n        if (isSingleton()) {\n            throw new Exception(\"TUNNEL and shared transport mode are not supported!\");\n        }\n\n        if ((router_host == null || router_port == 0) && gossip_router_hosts.isEmpty()) {\n            throw new Exception(\"either router_host and router_port have to be set or a list of gossip routers\");\n        }\n\n        if (router_host != null && router_port != 0 && !gossip_router_hosts.isEmpty()) {\n            throw new Exception(\"cannot specify both router host and port along with gossip_router_hosts\");\n        }\n\n        if (router_host != null && router_port != 0 && gossip_router_hosts.isEmpty()) {\n            gossip_router_hosts.add(new InetSocketAddress(router_host, router_port));\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"GossipRouters are:\" + gossip_router_hosts.toString());\n        }\n        \n        stubManager = RouterStubManager.emptyGossipClientStubManager(this);\n        sock = Util.getSocketFactory().createDatagramSocket(Global.TUNNEL_UCAST_SOCK, 0, bind_addr);\n        \n        // loopback turned on is mandatory\n        loopback = true;\n    }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void send(Message msg, Address dest, boolean multicast) throws Exception {\n\n        // we don't currently support message bundling in TUNNEL\n        TpHeader hdr=(TpHeader)msg.getHeader(this.id);\n        if(hdr == null)\n            throw new Exception(\"message \" + msg + \" doesn't have a transport header, cannot route it\");\n        String group=hdr.channel_name;\n\n        ExposedByteArrayOutputStream out_stream=new ExposedByteArrayOutputStream((int)(msg.size() + 50));\n        ExposedDataOutputStream dos=new ExposedDataOutputStream(out_stream);\n\n        writeMessage(msg, dos, multicast);\n        Buffer buf=new Buffer(out_stream.getRawBuffer(), 0, out_stream.size());\n\n        if(stats) {\n            num_msgs_sent++;\n            num_bytes_sent+=buf.getLength();\n        }\n        if(multicast) {\n            tunnel_policy.sendToAllMembers(stubs, group, buf.getBuf(), buf.getOffset(), buf.getLength());\n        }\n        else {\n            tunnel_policy.sendToSingleMember(stubs, group, dest, buf.getBuf(), buf.getOffset(), buf.getLength());\n        }\n    }","id":93729,"modified_method":"protected void send(Message msg, Address dest, boolean multicast) throws Exception {\n\n        // we don't currently support message bundling in TUNNEL\n        TpHeader hdr=(TpHeader)msg.getHeader(this.id);\n        if(hdr == null)\n            throw new Exception(\"message \" + msg + \" doesn't have a transport header, cannot route it\");\n        String group=hdr.channel_name;\n\n        ExposedByteArrayOutputStream out_stream=new ExposedByteArrayOutputStream((int)(msg.size() + 50));\n        ExposedDataOutputStream dos=new ExposedDataOutputStream(out_stream);\n\n        writeMessage(msg, dos, multicast);\n        Buffer buf=new Buffer(out_stream.getRawBuffer(), 0, out_stream.size());\n\n        if(stats) {\n            num_msgs_sent++;\n            num_bytes_sent+=buf.getLength();\n        }\n        List<RouterStub> stubs = stubManager.getStubs();\n        if(multicast) {\n            tunnel_policy.sendToAllMembers(stubs, group, buf.getBuf(), buf.getOffset(), buf.getLength());\n        }\n        else {\n            tunnel_policy.sendToSingleMember(stubs, group, dest, buf.getBuf(), buf.getOffset(), buf.getLength());\n        }\n    }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"public void destroy() {        \n        for (RouterStub stub : stubs) {\n            stopReconnecting(stub);\n            stub.destroy();\n        }\n        super.destroy();\n    }","id":93730,"modified_method":"public void destroy() {        \n        stubManager.destroyStubs();\n        super.destroy();\n    }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object handleDownEvent(Event evt) {\n      Object retEvent = super.handleDownEvent(evt);\n      switch (evt.getType()) {\n         case Event.CONNECT:\n         case Event.CONNECT_WITH_STATE_TRANSFER:\n         case Event.CONNECT_USE_FLUSH:\n         case Event.CONNECT_WITH_STATE_TRANSFER_USE_FLUSH:\n             String group=(String)evt.getArg();\n             Address local= null;\n             if(!isSingleton()) {\n                 local = local_addr;                 \n             } else {\n                 // TODO [JGRP-1194] - Revisit implementation of TUNNEL and shared transport   \n                 ProtocolAdapter adapter = ProtocolAdapter.thread_local.get();\n                 local = adapter.local_addr;\n             }\n             PhysicalAddress physical_addr=(PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, local));\n             List<PhysicalAddress> physical_addrs=Arrays.asList(physical_addr);\n             String logical_name=org.jgroups.util.UUID.get(local);\n             tunnel_policy.connect(stubs, group, local, logical_name, physical_addrs);\n            break;\n\n         case Event.DISCONNECT:\n             if(!isSingleton()) {\n                 local = local_addr;        \n                 group = channel_name;\n             } else {\n                 // TODO [JGRP-1194] - Revisit implementation of TUNNEL and shared transport\n                 ProtocolAdapter adapter = ProtocolAdapter.thread_local.get();\n                 local = adapter.local_addr;\n                 group = adapter.cluster_name;\n             }\n             disconnectStub(group,local);\n            break;\n      }\n      return retEvent;\n   }","id":93731,"modified_method":"public Object handleDownEvent(Event evt) {\n      Object retEvent = super.handleDownEvent(evt);\n      switch (evt.getType()) {\n         case Event.CONNECT:\n         case Event.CONNECT_WITH_STATE_TRANSFER:\n         case Event.CONNECT_USE_FLUSH:\n         case Event.CONNECT_WITH_STATE_TRANSFER_USE_FLUSH:\n             String group=(String)evt.getArg();\n             Address local= null;\n             if(!isSingleton()) {\n                 local = local_addr;                 \n             } else {\n                 // TODO [JGRP-1194] - Revisit implementation of TUNNEL and shared transport   \n                 ProtocolAdapter adapter = ProtocolAdapter.thread_local.get();\n                 local = adapter.local_addr;\n             }\n             \n             stubManager = new TUNNELStubManager(this,group,local,getReconnectInterval());\n             for (InetSocketAddress gr : gossip_router_hosts) {\n                 RouterStub stub = stubManager.createStub(gr.getHostName(), gr.getPort(), bind_addr);\n                 stub.setTcpNoDelay(tcp_nodelay);           \n              }  \n             PhysicalAddress physical_addr=(PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, local));\n             List<PhysicalAddress> physical_addrs=Arrays.asList(physical_addr);\n             String logical_name=org.jgroups.util.UUID.get(local);\n             List<RouterStub> stubs = stubManager.getStubs();\n             tunnel_policy.connect(stubs, group, local, logical_name, physical_addrs);\n            break;\n\n         case Event.DISCONNECT:\n             if(!isSingleton()) {\n                 local = local_addr;        \n                 group = channel_name;\n             } else {\n                 // TODO [JGRP-1194] - Revisit implementation of TUNNEL and shared transport\n                 ProtocolAdapter adapter = ProtocolAdapter.thread_local.get();\n                 local = adapter.local_addr;\n                 group = adapter.cluster_name;\n             }\n             disconnectStub(group,local);\n            break;\n      }\n      return retEvent;\n   }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"private void disconnectStub(String group, Address addr) {\n      for (RouterStub stub : stubs) {         \n         stub.disconnect(group,addr);\n      }\n   }","id":93732,"modified_method":"private void disconnectStub(String group, Address addr) {\n      stubManager.disconnectStubs();\n   }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"public void connect(List<RouterStub> stubs, String group, Address addr, String logical_name, List<PhysicalAddress> phys_addrs) {\n           for (RouterStub stub : stubs) {\n               try {\n                   stub.connect(group, addr, logical_name, phys_addrs);\n               }\n               catch (Exception e) {\n                   if (log.isWarnEnabled())\n                       log.warn(\"Failed connecting to GossipRouter at \" + stub.getGossipRouterAddress());\n                   startReconnecting(stub);\n               }\n           }\n       }","id":93733,"modified_method":"public void connect(List<RouterStub> stubs, String group, Address addr, String logical_name, List<PhysicalAddress> phys_addrs) {\n           for (RouterStub stub : stubs) {\n               try {\n                   stub.connect(group, addr, logical_name, phys_addrs);\n               }\n               catch (Exception e) {\n                   if (log.isWarnEnabled())\n                       log.warn(\"Failed connecting to GossipRouter at \" + stub.getGossipRouterAddress(),e);\n                   stubManager.startReconnecting(stub);\n               }\n           }\n       }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"public String getInfo() {\n      if (stubs.isEmpty())\n         return stubs.toString();\n      else\n         return \"RouterStubs not yet initialized\";\n   }","id":93734,"modified_method":"public String getInfo() {\n       List<RouterStub> stubs = stubManager.getStubs();\n      if (stubs.isEmpty())\n         return stubs.toString();\n      else\n         return \"RouterStubs not yet initialized\";\n   }","commit_id":"992034cf61c530faf9bad27976de7092fdb0faad","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void connect(String group, Address logical_addr) {\n        String logical_name=org.jgroups.util.UUID.get(logical_addr);\n        PhysicalAddress physical_addr=(PhysicalAddress)down_prot.down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr));\n        List<PhysicalAddress> physical_addrs=physical_addr != null? new ArrayList<PhysicalAddress>() : null;\n        if(physical_addr != null)\n            physical_addrs.add(physical_addr);\n\n        int num_faulty_conns=0;\n        for (RouterStub stub : stubs) {\n            try {\n                if(log.isTraceEnabled())\n                    log.trace(\"trying to connect to \" + stub.getGossipRouterAddress());\n                stub.connect(group, logical_addr, logical_name, physical_addrs);\n            }\n            catch(Exception e) {\n                if(log.isErrorEnabled())\n                log.error(\"failed connecting to \" + stub.getGossipRouterAddress(), e);\n                num_faulty_conns++;\n            }\n        }\n        if(num_faulty_conns == 0)\n            stopReconnector();\n    }","id":93735,"modified_method":"protected void connect(String group, Address logical_addr) {\n        String logical_name=org.jgroups.util.UUID.get(logical_addr);\n        PhysicalAddress physical_addr=(PhysicalAddress)down_prot.down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr));\n        List<PhysicalAddress> physical_addrs=physical_addr != null? new ArrayList<PhysicalAddress>() : null;\n        if(physical_addr != null)\n            physical_addrs.add(physical_addr);\n\n      \n        for (RouterStub stub : stubManager.getStubs()) {\n            try {\n                if(log.isTraceEnabled())\n                    log.trace(\"trying to connect to \" + stub.getGossipRouterAddress());\n                stub.connect(group, logical_addr, logical_name, physical_addrs);\n            }\n            catch(Exception e) {\n                if(log.isErrorEnabled())\n                log.error(\"failed connecting to \" + stub.getGossipRouterAddress(), e); \n                stubManager.startReconnecting(stub);\n            }\n        }     \n    }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"public void init() throws Exception {\n        super.init();\n        \n        if(timeout <= sock_conn_timeout)\n            throw new IllegalArgumentException(\"timeout (\" + timeout + \") must be greater than sock_conn_timeout (\"\n                    + sock_conn_timeout + \")\");\n\n        // we cannot use TCPGOSSIP together with TUNNEL (https://jira.jboss.org/jira/browse/JGRP-1101)\n        TP transport=getTransport();\n        if(transport instanceof TUNNEL)\n            throw new IllegalStateException(\"TCPGOSSIP cannot be used with TUNNEL; use either TUNNEL:PING or \" +\n                    \"TCP:TCPGOSSIP as valid configurations\");\n    }","id":93736,"modified_method":"public void init() throws Exception {\n        super.init();\n        stubManager = RouterStubManager.emptyGossipClientStubManager(this);\n        if(timeout <= sock_conn_timeout)\n            throw new IllegalArgumentException(\"timeout (\" + timeout + \") must be greater than sock_conn_timeout (\"\n                    + sock_conn_timeout + \")\");\n\n        // we cannot use TCPGOSSIP together with TUNNEL (https://jira.jboss.org/jira/browse/JGRP-1101)\n        TP transport=getTransport();\n        if(transport instanceof TUNNEL)\n            throw new IllegalStateException(\"TCPGOSSIP cannot be used with TUNNEL; use either TUNNEL:PING or \" +\n                    \"TCP:TCPGOSSIP as valid configurations\");\n    }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"public void handleDisconnect() {\n        for (RouterStub stub : stubs) {\n            try {\n                stub.disconnect(group_addr, local_addr);\n                stub.destroy();\n            } catch (Exception e) {\n            }\n        }\n        stopConnectionChecker();\n    }","id":93737,"modified_method":"public void handleDisconnect() {\n        stubManager.disconnectStubs();\n    }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendGetMembersRequest(String cluster_name, Promise promise, boolean return_views_only) throws Exception {\n        if (group_addr == null) {\n            if (log.isErrorEnabled())\n                log.error(\"cluster_name is null, cannot get membership\");\n            return;\n        }\n\n        if (log.isTraceEnabled())\n            log.trace(\"fetching members from GossipRouter(s)\");\n\n        final List<PingData> responses = new LinkedList<PingData>();\n        for (RouterStub stub : stubs) {\n            try {\n                List<PingData> rsps = stub.getMembers(group_addr);\n                responses.addAll(rsps);\n            }\n            catch(Throwable t) {\n                log.warn(\"failed fetching members from \" + stub.getGossipRouterAddress() + \": \" +  t);\n            }\n        }\n\n        final Set<Address> initial_mbrs = new HashSet<Address>();\n        for (PingData rsp : responses) {\n            Address logical_addr = rsp.getAddress();\n            initial_mbrs.add(logical_addr);\n\n            // 1. Set physical addresses\n            Collection<PhysicalAddress> physical_addrs = rsp.getPhysicalAddrs();\n            if (physical_addrs != null) {\n                for (PhysicalAddress physical_addr : physical_addrs)\n                    down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address, PhysicalAddress>(\n                                    logical_addr, physical_addr)));\n            }\n\n            // 2. Set logical name\n            String logical_name = rsp.getLogicalName();\n            if (logical_name != null && logical_addr instanceof org.jgroups.util.UUID)\n                org.jgroups.util.UUID.add((org.jgroups.util.UUID) logical_addr, logical_name);\n        }\n\n        if (initial_mbrs.isEmpty()) {\n            if (log.isErrorEnabled())\n                log.error(\"[FIND_INITIAL_MBRS]: found no members\");\n            return;\n        }\n        if (log.isTraceEnabled())\n            log.trace(\"consolidated mbrs from GossipRouter(s) are \" + initial_mbrs);\n\n        for (Address mbr_addr : initial_mbrs) {\n            Message msg = new Message(mbr_addr);\n            msg.setFlag(Message.OOB);\n            PingHeader hdr = new PingHeader(PingHeader.GET_MBRS_REQ, cluster_name);\n            hdr.return_view_only = return_views_only;\n            msg.putHeader(this.id, hdr);\n            if (log.isTraceEnabled())\n                log.trace(\"[FIND_INITIAL_MBRS] sending PING request to \" + mbr_addr);\n            down_prot.down(new Event(Event.MSG, msg));\n        }\n    }","id":93738,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public void sendGetMembersRequest(String cluster_name, Promise promise, boolean return_views_only) throws Exception {\n        if (group_addr == null) {\n            if (log.isErrorEnabled())\n                log.error(\"cluster_name is null, cannot get membership\");\n            return;\n        }\n\n        if (log.isTraceEnabled())\n            log.trace(\"fetching members from GossipRouter(s)\");\n\n        final List<PingData> responses = new LinkedList<PingData>();\n        for (RouterStub stub : stubManager.getStubs()) {\n            try {\n                List<PingData> rsps = stub.getMembers(group_addr);\n                responses.addAll(rsps);\n            }\n            catch(Throwable t) {\n                log.warn(\"failed fetching members from \" + stub.getGossipRouterAddress() + \": \" +  t);\n            }\n        }\n\n        final Set<Address> initial_mbrs = new HashSet<Address>();\n        for (PingData rsp : responses) {\n            Address logical_addr = rsp.getAddress();\n            initial_mbrs.add(logical_addr);\n\n            // 1. Set physical addresses\n            Collection<PhysicalAddress> physical_addrs = rsp.getPhysicalAddrs();\n            if (physical_addrs != null) {\n                for (PhysicalAddress physical_addr : physical_addrs)\n                    down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address, PhysicalAddress>(\n                                    logical_addr, physical_addr)));\n            }\n\n            // 2. Set logical name\n            String logical_name = rsp.getLogicalName();\n            if (logical_name != null && logical_addr instanceof org.jgroups.util.UUID)\n                org.jgroups.util.UUID.add((org.jgroups.util.UUID) logical_addr, logical_name);\n        }\n\n        if (initial_mbrs.isEmpty()) {\n            if (log.isErrorEnabled())\n                log.error(\"[FIND_INITIAL_MBRS]: found no members\");\n            return;\n        }\n        if (log.isTraceEnabled())\n            log.trace(\"consolidated mbrs from GossipRouter(s) are \" + initial_mbrs);\n\n        for (Address mbr_addr : initial_mbrs) {\n            Message msg = new Message(mbr_addr);\n            msg.setFlag(Message.OOB);\n            PingHeader hdr = new PingHeader(PingHeader.GET_MBRS_REQ, cluster_name);\n            hdr.return_view_only = return_views_only;\n            msg.putHeader(this.id, hdr);\n            if (log.isTraceEnabled())\n                log.trace(\"[FIND_INITIAL_MBRS] sending PING request to \" + mbr_addr);            \n            down_prot.down(new Event(Event.MSG, msg));\n        }\n    }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"public void start() throws Exception {\n        super.start();\n        running=true;\n    }","id":93739,"modified_method":"public void start() throws Exception {\n        super.start();\n    }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"public void destroy() {\n        for (RouterStub stub : stubs) {\n            stub.destroy();\n        }\n        super.destroy();\n    }","id":93740,"modified_method":"public void destroy() {\n        stubManager.destroyStubs();\n        super.destroy();\n    }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        super.stop();\n        running = false;\n        for (RouterStub stub : stubs) {\n            try {\n                stub.disconnect(group_addr, local_addr);\n            } catch (Exception e) {\n            }\n        }\n        stopReconnector();\n    }","id":93741,"modified_method":"public void stop() {\n        super.stop();       \n        stubManager.disconnectStubs();\n    }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"public void handleConnect() {\n        if (group_addr == null || local_addr == null) {\n            if (log.isErrorEnabled())\n                log.error(\"group_addr or local_addr is null, cannot register with GossipRouter(s)\");\n        } else {\n            if (log.isTraceEnabled())\n                log.trace(\"registering \" + local_addr + \" under \" + group_addr\n                                + \" with GossipRouter\");\n            for (RouterStub stub : stubs)\n                // if there are any stubs, destroy them\n                stub.destroy();\n            stubs.clear();\n\n            for (InetSocketAddress host : initial_hosts) {\n                RouterStub stub = new RouterStub(host.getHostName(), host.getPort(), null,this);                \n                stubs.add(stub);\n            }\n            connect(group_addr, local_addr);\n            startConnectionChecker();\n        }\n    }","id":93742,"modified_method":"public void handleConnect() {\n        if (group_addr == null || local_addr == null) {\n            if (log.isErrorEnabled())\n                log.error(\"group_addr or local_addr is null, cannot register with GossipRouter(s)\");\n        } else {\n            if (log.isTraceEnabled())\n                log.trace(\"registering \" + local_addr + \" under \" + group_addr + \" with GossipRouter\");\n            \n            stubManager.destroyStubs();\n            stubManager = new RouterStubManager(this, group_addr, local_addr, reconnect_interval);\n            for (InetSocketAddress host : initial_hosts) {\n                stubManager.createStub(host.getHostName(), host.getPort(), null);                                \n            }\n            connect(group_addr, local_addr);            \n        }\n    }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"public void destroy() {        \n        for (RouterStub stub : stubs) {\n            stopReconnecting(stub);\n            stub.destroy();\n        }\n        super.destroy();\n    }","id":93743,"modified_method":"public void destroy() {        \n        stubManager.destroyStubs();\n        super.destroy();\n    }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"public String getInfo() {\n      if (stubs.isEmpty())\n         return stubs.toString();\n      else\n         return \"RouterStubs not yet initialized\";\n   }","id":93744,"modified_method":"public String getInfo() {\n       List<RouterStub> stubs = stubManager.getStubs();\n      if (stubs.isEmpty())\n         return stubs.toString();\n      else\n         return \"RouterStubs not yet initialized\";\n   }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object handleDownEvent(Event evt) {\n      Object retEvent = super.handleDownEvent(evt);\n      switch (evt.getType()) {\n         case Event.CONNECT:\n         case Event.CONNECT_WITH_STATE_TRANSFER:\n         case Event.CONNECT_USE_FLUSH:\n         case Event.CONNECT_WITH_STATE_TRANSFER_USE_FLUSH:\n             String group=(String)evt.getArg();\n             Address local= null;\n             if(!isSingleton()) {\n                 local = local_addr;                 \n             } else {\n                 // TODO [JGRP-1194] - Revisit implementation of TUNNEL and shared transport   \n                 ProtocolAdapter adapter = ProtocolAdapter.thread_local.get();\n                 local = adapter.local_addr;\n             }\n             PhysicalAddress physical_addr=(PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, local));\n             List<PhysicalAddress> physical_addrs=Arrays.asList(physical_addr);\n             String logical_name=org.jgroups.util.UUID.get(local);\n             tunnel_policy.connect(stubs, group, local, logical_name, physical_addrs);\n            break;\n\n         case Event.DISCONNECT:\n             if(!isSingleton()) {\n                 local = local_addr;        \n                 group = channel_name;\n             } else {\n                 // TODO [JGRP-1194] - Revisit implementation of TUNNEL and shared transport\n                 ProtocolAdapter adapter = ProtocolAdapter.thread_local.get();\n                 local = adapter.local_addr;\n                 group = adapter.cluster_name;\n             }\n             disconnectStub(group,local);\n            break;\n      }\n      return retEvent;\n   }","id":93745,"modified_method":"public Object handleDownEvent(Event evt) {\n      Object retEvent = super.handleDownEvent(evt);\n      switch (evt.getType()) {\n         case Event.CONNECT:\n         case Event.CONNECT_WITH_STATE_TRANSFER:\n         case Event.CONNECT_USE_FLUSH:\n         case Event.CONNECT_WITH_STATE_TRANSFER_USE_FLUSH:\n             String group=(String)evt.getArg();\n             Address local= null;\n             if(!isSingleton()) {\n                 local = local_addr;                 \n             } else {\n                 // TODO [JGRP-1194] - Revisit implementation of TUNNEL and shared transport   \n                 ProtocolAdapter adapter = ProtocolAdapter.thread_local.get();\n                 local = adapter.local_addr;\n             }\n             \n             stubManager = new TUNNELStubManager(this,group,local,getReconnectInterval());\n             for (InetSocketAddress gr : gossip_router_hosts) {\n                 RouterStub stub = stubManager.createStub(gr.getHostName(), gr.getPort(), bind_addr);\n                 stub.setTcpNoDelay(tcp_nodelay);           \n              }  \n             PhysicalAddress physical_addr=(PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, local));\n             List<PhysicalAddress> physical_addrs=Arrays.asList(physical_addr);\n             String logical_name=org.jgroups.util.UUID.get(local);\n             List<RouterStub> stubs = stubManager.getStubs();\n             tunnel_policy.connect(stubs, group, local, logical_name, physical_addrs);\n            break;\n\n         case Event.DISCONNECT:\n             if(!isSingleton()) {\n                 local = local_addr;        \n                 group = channel_name;\n             } else {\n                 // TODO [JGRP-1194] - Revisit implementation of TUNNEL and shared transport\n                 ProtocolAdapter adapter = ProtocolAdapter.thread_local.get();\n                 local = adapter.local_addr;\n                 group = adapter.cluster_name;\n             }\n             disconnectStub(group,local);\n            break;\n      }\n      return retEvent;\n   }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"private void disconnectStub(String group, Address addr) {\n      for (RouterStub stub : stubs) {         \n         stub.disconnect(group,addr);\n      }\n   }","id":93746,"modified_method":"private void disconnectStub(String group, Address addr) {\n      stubManager.disconnectStubs();\n   }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"public void connect(List<RouterStub> stubs, String group, Address addr, String logical_name, List<PhysicalAddress> phys_addrs) {\n           for (RouterStub stub : stubs) {\n               try {\n                   stub.connect(group, addr, logical_name, phys_addrs);\n               }\n               catch (Exception e) {\n                   if (log.isWarnEnabled())\n                       log.warn(\"Failed connecting to GossipRouter at \" + stub.getGossipRouterAddress());\n                   startReconnecting(stub);\n               }\n           }\n       }","id":93747,"modified_method":"public void connect(List<RouterStub> stubs, String group, Address addr, String logical_name, List<PhysicalAddress> phys_addrs) {\n           for (RouterStub stub : stubs) {\n               try {\n                   stub.connect(group, addr, logical_name, phys_addrs);\n               }\n               catch (Exception e) {\n                   if (log.isWarnEnabled())\n                       log.warn(\"Failed connecting to GossipRouter at \" + stub.getGossipRouterAddress(),e);\n                   stubManager.startReconnecting(stub);\n               }\n           }\n       }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"public void init() throws Exception {\n        super.init();\n\n        if(enable_bundling) {\n            log.warn(\"bundling is currently not supported by TUNNEL; bundling is disabled\");\n            enable_bundling=false;\n        }\n\n        if (timer == null)\n            throw new Exception(\"timer cannot be retrieved from protocol stack\");\n      \n        // Postpone TUNNEL and shared transport until 3.0 timeframe\n        // TODO [JGRP-1194] - Revisit implementation of TUNNEL and shared transport\n        if (isSingleton()) {\n            throw new Exception(\"TUNNEL and shared transport mode are not supported!\");\n        }\n\n        if ((router_host == null || router_port == 0) && gossip_router_hosts.isEmpty()) {\n            throw new Exception(\"either router_host and router_port have to be set or a list of gossip routers\");\n        }\n\n        if (router_host != null && router_port != 0 && !gossip_router_hosts.isEmpty()) {\n            throw new Exception(\"cannot specify both router host and port along with gossip_router_hosts\");\n        }\n\n        if (router_host != null && router_port != 0 && gossip_router_hosts.isEmpty()) {\n            gossip_router_hosts.add(new InetSocketAddress(router_host, router_port));\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"GossipRouters are:\" + gossip_router_hosts.toString());\n        }\n        \n        sock = Util.getSocketFactory().createDatagramSocket(Global.TUNNEL_UCAST_SOCK, 0, bind_addr);\n\n        for (InetSocketAddress gr : gossip_router_hosts) {\n           RouterStub stub = new RouterStub(gr.getHostName(), gr.getPort(), bind_addr,new StubConnectionListener());\n           stub.setTcpNoDelay(tcp_nodelay);\n           stubs.add(stub);\n        }     \n        // loopback turned on is mandatory\n        loopback = true;\n    }","id":93748,"modified_method":"public void init() throws Exception {\n        super.init();\n\n        if(enable_bundling) {\n            log.warn(\"bundling is currently not supported by TUNNEL; bundling is disabled\");\n            enable_bundling=false;\n        }\n\n        if (timer == null)\n            throw new Exception(\"timer cannot be retrieved from protocol stack\");\n      \n        // Postpone TUNNEL and shared transport until 3.0 timeframe\n        // TODO [JGRP-1194] - Revisit implementation of TUNNEL and shared transport\n        if (isSingleton()) {\n            throw new Exception(\"TUNNEL and shared transport mode are not supported!\");\n        }\n\n        if ((router_host == null || router_port == 0) && gossip_router_hosts.isEmpty()) {\n            throw new Exception(\"either router_host and router_port have to be set or a list of gossip routers\");\n        }\n\n        if (router_host != null && router_port != 0 && !gossip_router_hosts.isEmpty()) {\n            throw new Exception(\"cannot specify both router host and port along with gossip_router_hosts\");\n        }\n\n        if (router_host != null && router_port != 0 && gossip_router_hosts.isEmpty()) {\n            gossip_router_hosts.add(new InetSocketAddress(router_host, router_port));\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"GossipRouters are:\" + gossip_router_hosts.toString());\n        }\n        \n        stubManager = RouterStubManager.emptyGossipClientStubManager(this);\n        sock = Util.getSocketFactory().createDatagramSocket(Global.TUNNEL_UCAST_SOCK, 0, bind_addr);\n        \n        // loopback turned on is mandatory\n        loopback = true;\n    }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void send(Message msg, Address dest, boolean multicast) throws Exception {\n\n        // we don't currently support message bundling in TUNNEL\n        TpHeader hdr=(TpHeader)msg.getHeader(this.id);\n        if(hdr == null)\n            throw new Exception(\"message \" + msg + \" doesn't have a transport header, cannot route it\");\n        String group=hdr.channel_name;\n\n        ExposedByteArrayOutputStream out_stream=new ExposedByteArrayOutputStream((int)(msg.size() + 50));\n        ExposedDataOutputStream dos=new ExposedDataOutputStream(out_stream);\n\n        writeMessage(msg, dos, multicast);\n        Buffer buf=new Buffer(out_stream.getRawBuffer(), 0, out_stream.size());\n\n        if(stats) {\n            num_msgs_sent++;\n            num_bytes_sent+=buf.getLength();\n        }\n        if(multicast) {\n            tunnel_policy.sendToAllMembers(stubs, group, buf.getBuf(), buf.getOffset(), buf.getLength());\n        }\n        else {\n            tunnel_policy.sendToSingleMember(stubs, group, dest, buf.getBuf(), buf.getOffset(), buf.getLength());\n        }\n    }","id":93749,"modified_method":"protected void send(Message msg, Address dest, boolean multicast) throws Exception {\n\n        // we don't currently support message bundling in TUNNEL\n        TpHeader hdr=(TpHeader)msg.getHeader(this.id);\n        if(hdr == null)\n            throw new Exception(\"message \" + msg + \" doesn't have a transport header, cannot route it\");\n        String group=hdr.channel_name;\n\n        ExposedByteArrayOutputStream out_stream=new ExposedByteArrayOutputStream((int)(msg.size() + 50));\n        ExposedDataOutputStream dos=new ExposedDataOutputStream(out_stream);\n\n        writeMessage(msg, dos, multicast);\n        Buffer buf=new Buffer(out_stream.getRawBuffer(), 0, out_stream.size());\n\n        if(stats) {\n            num_msgs_sent++;\n            num_bytes_sent+=buf.getLength();\n        }\n        List<RouterStub> stubs = stubManager.getStubs();\n        if(multicast) {\n            tunnel_policy.sendToAllMembers(stubs, group, buf.getBuf(), buf.getOffset(), buf.getLength());\n        }\n        else {\n            tunnel_policy.sendToSingleMember(stubs, group, dest, buf.getBuf(), buf.getOffset(), buf.getLength());\n        }\n    }","commit_id":"a4372a630077c7ef69a873944bf620f74468410e","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n        public void run() {\n            // Upgraded connections need to allow multiple threads to access the\n            // connection at the same time to enable blocking IO to be used when\n            // NIO has been configured\n            if (socket != null && socket.isUpgraded() &&\n                    SocketStatus.OPEN_WRITE == status) {\n                synchronized (socket.getWriteThreadLock()) {\n                    doRun();\n                }\n            } else {\n                synchronized (socket) {\n                    doRun();\n                }\n            }\n        }","id":93750,"modified_method":"@Override\n        public void run() {\n            // Upgraded connections need to allow multiple threads to access the\n            // connection at the same time to enable blocking IO to be used when\n            // NIO has been configured\n            if (socket.isUpgraded() &&\n                    SocketStatus.OPEN_WRITE == status) {\n                synchronized (socket.getWriteThreadLock()) {\n                    doRun();\n                }\n            } else {\n                synchronized (socket) {\n                    doRun();\n                }\n            }\n        }","commit_id":"1973226082e19b6ac69f81a8f066e4538755eaeb","url":"https://github.com/apache/tomcat"},{"original_method":"private void doRun() {\n            boolean launch = false;\n            try {\n                int handshake = -1;\n\n                try {\n                    if (socket != null && socket.getSocket() != null) {\n                        // For STOP there is no point trying to handshake as the\n                        // Poller has been stopped.\n                        if (socket.getSocket().isHandshakeComplete() ||\n                                status == SocketStatus.STOP) {\n                            handshake = 0;\n                        } else {\n                            handshake = socket.getSocket().handshake();\n                            // The handshake process reads/writes from/to the\n                            // socket. status may therefore be OPEN_WRITE once\n                            // the handshake completes. However, the handshake\n                            // happens when the socket is opened so the status\n                            // must always be OPEN_READ after it completes. It\n                            // is OK to always set this as it is only used if\n                            // the handshake completes.\n                            status = SocketStatus.OPEN_READ;\n                        }\n                    }\n                } catch (IOException x) {\n                    handshake = -1;\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"endpoint.err.handshake\"), x);\n                    }\n                }\n                if (handshake == 0) {\n                    SocketState state = SocketState.OPEN;\n                    // Process the request from this socket\n                    if (status == null) {\n                        state = handler.process(socket, SocketStatus.OPEN_READ);\n                    } else {\n                        state = handler.process(socket, status);\n                    }\n                    if (state == SocketState.CLOSED) {\n                        // Close socket and pool\n                        socket.setComet(false);\n                        closeSocket(socket, SocketStatus.ERROR);\n                        if (useCaches && running && !paused) {\n                            nioChannels.push(socket.getSocket());\n                        }\n                        if (useCaches && running && !paused && socket != null) {\n                            socketWrapperCache.push((Nio2SocketWrapper) socket);\n                        }\n                    } else if (state == SocketState.UPGRADING) {\n                        socket.setKeptAlive(true);\n                        socket.access();\n                        launch = true;\n                    }\n                } else if (handshake == -1 ) {\n                    if (socket != null) {\n                        closeSocket(socket, SocketStatus.DISCONNECT);\n                    }\n                    if (useCaches && running && !paused) {\n                        nioChannels.push(socket.getSocket());\n                    }\n                    if (useCaches && running && !paused && socket != null) {\n                        socketWrapperCache.push(((Nio2SocketWrapper) socket));\n                    }\n                }\n            } catch (OutOfMemoryError oom) {\n                try {\n                    oomParachuteData = null;\n                    log.error(\"\", oom);\n                    if (socket != null) {\n                        closeSocket(socket, SocketStatus.ERROR);\n                    }\n                    releaseCaches();\n                } catch (Throwable oomt) {\n                    try {\n                        System.err.println(oomParachuteMsg);\n                        oomt.printStackTrace();\n                    } catch (Throwable letsHopeWeDontGetHere){\n                        ExceptionUtils.handleThrowable(letsHopeWeDontGetHere);\n                    }\n                }\n            } catch (VirtualMachineError vme) {\n                ExceptionUtils.handleThrowable(vme);\n            } catch (Throwable t) {\n                log.error(sm.getString(\"endpoint.processing.fail\"), t);\n                if (socket != null) {\n                    closeSocket(socket, SocketStatus.ERROR);\n                }\n            } finally {\n                if (launch) {\n                    try {\n                        getExecutor().execute(new SocketProcessor(socket, SocketStatus.OPEN_READ));\n                    } catch (NullPointerException npe) {\n                        if (running) {\n                            log.error(sm.getString(\"endpoint.launch.fail\"),\n                                    npe);\n                        }\n                    }\n                }\n                socket = null;\n                status = null;\n                //return to cache\n                if (useCaches && running && !paused) {\n                    processorCache.push(this);\n                }\n            }\n        }","id":93751,"modified_method":"private void doRun() {\n            boolean launch = false;\n            try {\n                int handshake = -1;\n\n                try {\n                    if (socket.getSocket() != null) {\n                        // For STOP there is no point trying to handshake as the\n                        // Poller has been stopped.\n                        if (socket.getSocket().isHandshakeComplete() ||\n                                status == SocketStatus.STOP) {\n                            handshake = 0;\n                        } else {\n                            handshake = socket.getSocket().handshake();\n                            // The handshake process reads/writes from/to the\n                            // socket. status may therefore be OPEN_WRITE once\n                            // the handshake completes. However, the handshake\n                            // happens when the socket is opened so the status\n                            // must always be OPEN_READ after it completes. It\n                            // is OK to always set this as it is only used if\n                            // the handshake completes.\n                            status = SocketStatus.OPEN_READ;\n                        }\n                    }\n                } catch (IOException x) {\n                    handshake = -1;\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"endpoint.err.handshake\"), x);\n                    }\n                }\n                if (handshake == 0) {\n                    SocketState state = SocketState.OPEN;\n                    // Process the request from this socket\n                    if (status == null) {\n                        state = handler.process(socket, SocketStatus.OPEN_READ);\n                    } else {\n                        state = handler.process(socket, status);\n                    }\n                    if (state == SocketState.CLOSED) {\n                        // Close socket and pool\n                        socket.setComet(false);\n                        closeSocket(socket, SocketStatus.ERROR);\n                        if (useCaches && running && !paused) {\n                            nioChannels.push(socket.getSocket());\n                        }\n                        if (useCaches && running && !paused && socket != null) {\n                            socketWrapperCache.push((Nio2SocketWrapper) socket);\n                        }\n                    } else if (state == SocketState.UPGRADING) {\n                        socket.setKeptAlive(true);\n                        socket.access();\n                        launch = true;\n                    }\n                } else if (handshake == -1 ) {\n                    closeSocket(socket, SocketStatus.DISCONNECT);\n                    if (useCaches && running && !paused) {\n                        nioChannels.push(socket.getSocket());\n                    }\n                    if (useCaches && running && !paused && socket != null) {\n                        socketWrapperCache.push(((Nio2SocketWrapper) socket));\n                    }\n                }\n            } catch (OutOfMemoryError oom) {\n                try {\n                    oomParachuteData = null;\n                    log.error(\"\", oom);\n                    closeSocket(socket, SocketStatus.ERROR);\n                    releaseCaches();\n                } catch (Throwable oomt) {\n                    try {\n                        System.err.println(oomParachuteMsg);\n                        oomt.printStackTrace();\n                    } catch (Throwable letsHopeWeDontGetHere){\n                        ExceptionUtils.handleThrowable(letsHopeWeDontGetHere);\n                    }\n                }\n            } catch (VirtualMachineError vme) {\n                ExceptionUtils.handleThrowable(vme);\n            } catch (Throwable t) {\n                log.error(sm.getString(\"endpoint.processing.fail\"), t);\n                if (socket != null) {\n                    closeSocket(socket, SocketStatus.ERROR);\n                }\n            } finally {\n                if (launch) {\n                    try {\n                        getExecutor().execute(new SocketProcessor(socket, SocketStatus.OPEN_READ));\n                    } catch (NullPointerException npe) {\n                        if (running) {\n                            log.error(sm.getString(\"endpoint.launch.fail\"),\n                                    npe);\n                        }\n                    }\n                }\n                socket = null;\n                status = null;\n                //return to cache\n                if (useCaches && running && !paused) {\n                    processorCache.push(this);\n                }\n            }\n        }","commit_id":"1973226082e19b6ac69f81a8f066e4538755eaeb","url":"https://github.com/apache/tomcat"},{"original_method":"public void closeSocket(SocketWrapper<Nio2Channel> socket, SocketStatus status) {\n        try {\n            if (socket != null && socket.isComet() && status != null) {\n                socket.setComet(false);//to avoid a loop\n                if (status == SocketStatus.TIMEOUT) {\n                    if (processSocket0(socket, status, true)) {\n                        return; // don't close on comet timeout\n                    }\n                } else {\n                    // Don't dispatch if the lines below are canceling the key\n                    processSocket0(socket, status, false);\n                }\n            }\n            if (socket!=null) handler.release(socket);\n            try {\n                if (socket!=null) {\n                    socket.getSocket().close(true);\n                }\n            } catch (Exception e){\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                            \"endpoint.debug.socketCloseFail\"), e);\n                }\n            }\n            Nio2SocketWrapper nio2Socket = (Nio2SocketWrapper) socket;\n            try {\n                if (nio2Socket != null && nio2Socket.getSendfileData() != null\n                        && nio2Socket.getSendfileData().fchannel != null\n                        && nio2Socket.getSendfileData().fchannel.isOpen()) {\n                    nio2Socket.getSendfileData().fchannel.close();\n                }\n            } catch (Exception ignore) {\n            }\n            if (nio2Socket != null) {\n                nio2Socket.reset(null, -1);\n                countDownConnection();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            if (log.isDebugEnabled()) log.error(\"\",e);\n        }\n    }","id":93752,"modified_method":"public void closeSocket(SocketWrapper<Nio2Channel> socket, SocketStatus status) {\n        if (socket == null) {\n            return;\n        }\n        try {\n            if (socket.isComet() && status != null) {\n                socket.setComet(false);//to avoid a loop\n                if (status == SocketStatus.TIMEOUT) {\n                    if (processSocket0(socket, status, true)) {\n                        return; // don't close on comet timeout\n                    }\n                } else {\n                    // Don't dispatch if the lines below are canceling the key\n                    processSocket0(socket, status, false);\n                }\n            }\n            handler.release(socket);\n            try {\n                if (socket.getSocket() != null) {\n                    socket.getSocket().close(true);\n                }\n            } catch (Exception e){\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                            \"endpoint.debug.socketCloseFail\"), e);\n                }\n            }\n            Nio2SocketWrapper nio2Socket = (Nio2SocketWrapper) socket;\n            try {\n                if (nio2Socket.getSendfileData() != null\n                        && nio2Socket.getSendfileData().fchannel != null\n                        && nio2Socket.getSendfileData().fchannel.isOpen()) {\n                    nio2Socket.getSendfileData().fchannel.close();\n                }\n            } catch (Exception ignore) {\n            }\n            nio2Socket.reset(null, -1);\n            countDownConnection();\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            if (log.isDebugEnabled()) log.error(\"\",e);\n        }\n    }","commit_id":"1973226082e19b6ac69f81a8f066e4538755eaeb","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Start the domain controller with configuration.  This will launch required service for the domain controller.\n     *\n     * @param domainControllerConfig The domain controller configuration\n     */\n    synchronized void start(final DomainControllerConfig domainControllerConfig) {\n        log.info(\"Starting Domain Controller\");\n\n        final LocalDomainControllerElement localDomainControllerElement = domainControllerConfig.getDomainControllerElement();\n        final Host hostConfig = domainControllerConfig.getHost();\n        final BatchBuilder batchBuilder = serviceContainer.batchBuilder();\n\n        final ServiceActivatorContext serviceActivatorContext = new ServiceActivatorContextImpl(batchBuilder);\n\n        // Activate Interfaces\n        final Map<String, ServerInterfaceElement> interfaces = new HashMap<String, ServerInterfaceElement>();\n        final Set<ServerInterfaceElement> hostInterfaces = hostConfig.getInterfaces();\n        if(hostInterfaces != null) {\n            for(ServerInterfaceElement interfaceElement : hostInterfaces) {\n                interfaces.put(interfaceElement.getName(), interfaceElement);\n            }\n        }\n        final Map<String, ServerInterfaceElement> dcInterfaces = localDomainControllerElement.getInterfaces();\n        if(dcInterfaces != null)\n        for(Map.Entry<String, ServerInterfaceElement> interfaceElement : dcInterfaces.entrySet()) {\n            interfaces.put(interfaceElement.getKey(), interfaceElement.getValue());\n        }\n        for(ServerInterfaceElement interfaceElement : interfaces.values()) {\n            interfaceElement.activate(serviceActivatorContext);\n        }\n\n        //  Add the server manager communication service\n        final ServerManagerCommunicationService serverManagerCommunicationService = new ServerManagerCommunicationService(this, localDomainControllerElement);\n        batchBuilder.addService(ServerManagerCommunicationService.SERVICE_NAME, serverManagerCommunicationService)\n            .addListener(new DomainControllerStartupListener())\n            .addDependency(NetworkInterfaceService.JBOSS_NETWORK_INTERFACE.append(localDomainControllerElement.getInterfaceName()), NetworkInterfaceBinding.class, serverManagerCommunicationService.getInterfaceInjector())\n            .setInitialMode(ServiceController.Mode.IMMEDIATE);\n\n        try {\n            batchBuilder.install();\n        } catch (ServiceRegistryException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":93753,"modified_method":"/**\n     * Start the domain controller with configuration.  This will launch required service for the domain controller.\n     *\n     * @param domainControllerConfig The domain controller configuration\n     */\n    synchronized void start(final DomainControllerConfig domainControllerConfig) {\n        log.info(\"Starting Domain Controller\");\n\n        log.info(\"Parsing Domain Configuration\");\n        domainConfig = parseDomain();\n\n        final LocalDomainControllerElement localDomainControllerElement = domainControllerConfig.getDomainControllerElement();\n        final Host hostConfig = domainControllerConfig.getHost();\n        final BatchBuilder batchBuilder = serviceContainer.batchBuilder();\n\n        final ServiceActivatorContext serviceActivatorContext = new ServiceActivatorContextImpl(batchBuilder);\n\n        // Activate Interfaces\n        final Map<String, ServerInterfaceElement> interfaces = new HashMap<String, ServerInterfaceElement>();\n        final Set<ServerInterfaceElement> hostInterfaces = hostConfig.getInterfaces();\n        if(hostInterfaces != null) {\n            for(ServerInterfaceElement interfaceElement : hostInterfaces) {\n                interfaces.put(interfaceElement.getName(), interfaceElement);\n            }\n        }\n        final Map<String, ServerInterfaceElement> dcInterfaces = localDomainControllerElement.getInterfaces();\n        if(dcInterfaces != null)\n        for(Map.Entry<String, ServerInterfaceElement> interfaceElement : dcInterfaces.entrySet()) {\n            interfaces.put(interfaceElement.getKey(), interfaceElement.getValue());\n        }\n        for(ServerInterfaceElement interfaceElement : interfaces.values()) {\n            interfaceElement.activate(serviceActivatorContext);\n        }\n\n        //  Add the server manager communication service\n        final ServerManagerCommunicationService serverManagerCommunicationService = new ServerManagerCommunicationService(this, localDomainControllerElement);\n        batchBuilder.addService(ServerManagerCommunicationService.SERVICE_NAME, serverManagerCommunicationService)\n            .addListener(new DomainControllerStartupListener())\n            .addDependency(NetworkInterfaceService.JBOSS_NETWORK_INTERFACE.append(localDomainControllerElement.getInterfaceName()), NetworkInterfaceBinding.class, serverManagerCommunicationService.getInterfaceInjector())\n            .setInitialMode(ServiceController.Mode.IMMEDIATE);\n\n        try {\n            batchBuilder.install();\n        } catch (ServiceRegistryException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"dea9ebca5a3d526a37add77fdfd6df7794493b5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void run() {\n            for (; ;) {\n                try {\n                    InetAddress dcAddress = domainControllerAddress.getValue();\n                    if (dcAddress.isAnyLocalAddress() || dcAddress.isSiteLocalAddress()) {\n                        dcAddress = InetAddress.getLocalHost();\n                    }\n                    socket = new Socket(dcAddress, domainControllerPort.getValue());\n                    register();\n                    log.infof(\"Connected to domain controller [%s:%d]\", dcAddress.getHostAddress(), domainControllerPort.getValue());\n                    executor.execute(new ListenerTask(socket));\n                    break;\n                } catch (IOException e) {\n                    log.info(\"Unable to connect to domain controller.  Will retry.\");\n                    log.trace(\"Unable to connect to domain controller.\", e);\n                }\n                try {\n                    Thread.sleep(POLLING_INTERVAL);\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(\"Domain controller connection polling was interrupted.\", e);\n                }\n            }\n        }","id":93754,"modified_method":"public void run() {\n            for (; ;) {\n                try {\n                    InetAddress dcAddress = domainControllerAddress.getValue();\n                    if (dcAddress.isAnyLocalAddress() || dcAddress.isSiteLocalAddress()) {\n                        dcAddress = InetAddress.getLocalHost();\n                    }\n                    DomainControllerClientService.this.socket = new Socket(dcAddress, domainControllerPort.getValue());\n                    DomainControllerClientService.this.socketIn = new BufferedInputStream(socket.getInputStream());\n                    DomainControllerClientService.this.socketOut = new BufferedOutputStream(socket.getOutputStream());\n                    register();\n                    log.infof(\"Connected to domain controller [%s:%d]\", dcAddress.getHostAddress(), domainControllerPort.getValue());\n                    executor.execute(new ListenerTask());\n                    break;\n                } catch (IOException e) {\n                    log.info(\"Unable to connect to domain controller.  Will retry.\");\n                    log.trace(\"Unable to connect to domain controller.\", e);\n                }\n                try {\n                    Thread.sleep(POLLING_INTERVAL);\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(\"Domain controller connection polling was interrupted.\", e);\n                }\n            }\n        }","commit_id":"dea9ebca5a3d526a37add77fdfd6df7794493b5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void run() {\n            Unmarshaller unmarshaller = null;\n            try {\n                final InputStream inputStream = socket.getInputStream();\n                unmarshaller = MARSHALLER_FACTORY.createUnmarshaller(CONFIG);\n                for (; ;) {\n                    if (!socket.isConnected())\n                        break;\n                    unmarshaller.start(Marshalling.createByteInput(inputStream));\n\n                    byte commandByte = unmarshaller.readByte();\n                    ProtocolCommand command = ProtocolCommand.commandFor(commandByte);\n                    if (command == null) {\n                        throw new RuntimeException(\"Invalid command byte received: \" + commandByte);\n                    }\n                    command.execute(socket, unmarshaller);\n                    // TODO:  What if execution bombs.  How do we recover?\n                }\n            } catch (Throwable t) {\n                throw new RuntimeException(t); // TODO:  Better exceptions\n            } finally {\n                if (unmarshaller != null) try {\n                    unmarshaller.close();\n                } catch (Throwable ignored) {\n                    // todo: log me\n                }\n                if (socket != null) try {\n                    socket.close();\n                } catch (Throwable ignored) {\n                    // todo: log me\n                }\n            }\n        }","id":93755,"modified_method":"@Override\n        public void run() {\n            try {\n                for (; ;) {\n                    if (!socket.isConnected()) {\n                        break;\n                    }\n                    DomainControllerClientProtocol.IncomingCommand.processNext(DomainControllerClientService.this, DomainControllerClientService.this.socketIn);\n                    // TODO:  What if execution bombs.  How do we recover?\n                }\n            } catch (Throwable t) {\n                t.printStackTrace();\n                throw new RuntimeException(t); // TODO:  Better exceptions\n            } finally {\n                closeSocket();\n            }\n        }","commit_id":"dea9ebca5a3d526a37add77fdfd6df7794493b5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Register with the domain controller.\n     */\n    public void register() {\n        final Socket socket = this.socket;\n        Marshaller marshaller = null;\n        try {\n            final OutputStream outputStream = socket.getOutputStream();\n            marshaller = MARSHALLER_FACTORY.createMarshaller(CONFIG);\n            marshaller.start(Marshalling.createByteOutput(outputStream));\n            marshaller.writeByte((byte) 1);\n            marshaller.finish();\n        } catch (Throwable t) {\n            throw new RuntimeException(\"Failed to register with domain controller\", t); // TODO: better exception\n        } finally {\n            if (marshaller != null) try {\n                marshaller.close();\n            } catch (Throwable ignored) {\n                // todo: log me\n            }\n        }\n    }","id":93756,"modified_method":"/**\n     * Register with the domain controller.\n     */\n    public void register() {\n        try {\n            DomainControllerClientProtocol.OutgoingCommand.REGISTER.execute(this, DomainControllerClientService.this.socketOut);\n        } catch (Throwable t) {\n            throw new RuntimeException(\"Failed to register with domain controller\", t); // TODO: better exception\n        }\n    }","commit_id":"dea9ebca5a3d526a37add77fdfd6df7794493b5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Stop the service.  This will shut down the executor and close the socket.\n     *\n     * @param context The stop context.\n     */\n    public synchronized void stop(final StopContext context) {\n        try {\n            if (executor != null) {\n                executor.shutdown();\n            }\n        } finally {\n            if (socket != null) try {\n                socket.close();\n            } catch (IOException e) {\n                log.warn(\"Failed to close connection to domain controller\", e);\n            }\n        }\n    }","id":93757,"modified_method":"/**\n     * Stop the service.  This will shut down the executor and close the socket.\n     *\n     * @param context The stop context.\n     */\n    public synchronized void stop(final StopContext context) {\n        try {\n            if (executor != null) {\n                executor.shutdown();\n            }\n        } finally {\n            closeSocket();\n        }\n    }","commit_id":"dea9ebca5a3d526a37add77fdfd6df7794493b5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void boot(String[] args, InputStream stdin, PrintStream stdout, PrintStream stderr) {\n        ServerManager sm = null;\n        try {\n            ServerManagerEnvironment config = determineEnvironment(args, stdin, stdout, stderr);\n            if (config == null) {\n                abort(null);\n                return;\n            } else {\n                sm = new ServerManager(config);\n                sm.start();\n            }\n        } catch (Throwable t) {\n            t.printStackTrace(stderr);\n            abort(t);\n            return;\n        }\n        \n        // We are now past the point where a failure should result in a\n        // shutdown() call; i.e. the ServerManager should be running and\n        // capable of handling external input\n        try {\n            sm.startServers();\n        }\n        catch (RuntimeException e) {\n            e.printStackTrace(stderr);\n            throw e;\n        }\n        catch (Error e) {\n            e.printStackTrace(stderr);\n            throw e;\n        }\n    }","id":93758,"modified_method":"private void boot(String[] args, InputStream stdin, PrintStream stdout, PrintStream stderr) {\n        ServerManager sm = null;\n        try {\n            ServerManagerEnvironment config = determineEnvironment(args, stdin, stdout, stderr);\n            if (config == null) {\n                abort(null);\n                return;\n            } else {\n                sm = new ServerManager(config);\n                sm.start();\n            }\n        } catch (Throwable t) {\n            t.printStackTrace(stderr);\n            abort(t);\n            return;\n        }\n    }","commit_id":"dea9ebca5a3d526a37add77fdfd6df7794493b5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ServerCommunicationHandler(String processName, InetAddress addr, Integer port, final Handler handler){\n        //TODO Duplicate code - ProcessManagerSlave\n        if (processName == null) {\n            throw new IllegalArgumentException(\"processName is null\");\n        }\n        if (addr == null) {\n            throw new IllegalArgumentException(\"addr is null\");\n        }\n        if (port == null) {\n            throw new IllegalArgumentException(\"port is null\");\n        }\n        if (handler == null) {\n            throw new IllegalArgumentException(\"handler is null\");\n        }\n\n        try {\n            this.socket = new Socket(addr, port);\n            this.input = new BufferedInputStream(socket.getInputStream());\n            this.output = new BufferedOutputStream(socket.getOutputStream());\n            this.handler = handler;\n            \n            logger.infof(\"%s connected to process manager on port %d\", processName, socket.getLocalPort());\n            \n            //Send start signal to ProcessManager so it can associate our socket with the correct ManagedProcess\n            StringBuilder sb = new StringBuilder(256);\n            sb.append(\"STARTED\");\n            sb.append('\\0');\n            sb.append(processName);\n            sb.append('\\n');\n            \n            synchronized (output) {\n                StreamUtils.writeString(output, sb.toString());\n                output.flush();\n            }\n        } catch (IOException e) {\n            if (this.socket != null) {\n                closeSocket();\n            }\n            throw new RuntimeException(e);\n        }\n        //Duplicate code - ProcessManagerSlave - END \n    }","id":93759,"modified_method":"public ServerCommunicationHandler(String processName, InetAddress addr, Integer port, final Handler handler){\n        //TODO Duplicate code - ProcessManagerSlave\n        if (processName == null) {\n            throw new IllegalArgumentException(\"processName is null\");\n        }\n        if (addr == null) {\n            throw new IllegalArgumentException(\"addr is null\");\n        }\n        if (port == null) {\n            throw new IllegalArgumentException(\"port is null\");\n        }\n        if (handler == null) {\n            throw new IllegalArgumentException(\"handler is null\");\n        }\n\n        try {\n            this.socket = new Socket(addr, port);\n            this.input = new BufferedInputStream(socket.getInputStream());\n            this.output = new BufferedOutputStream(socket.getOutputStream());\n            this.handler = handler;\n            \n            logger.infof(\"%s connected to process manager on port %d\", processName, socket.getLocalPort());\n            \n            //Send start signal to ProcessManager so it can associate our socket with the correct ManagedProcess\n            StringBuilder sb = new StringBuilder(256);\n            sb.append(\"STARTED\");\n            sb.append('\\0');\n            sb.append(processName);\n            sb.append('\\n');\n            \n            synchronized (output) {\n                StreamUtils.writeString(output, sb.toString());\n                output.flush();\n            }\n        } catch (IOException e) {\n            closeSocket();\n            throw new RuntimeException(e);\n        }\n        //Duplicate code - ProcessManagerSlave - END \n    }","commit_id":"dea9ebca5a3d526a37add77fdfd6df7794493b5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void closeSocket() {\n        try {\n            socket.shutdownOutput();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            socket.shutdownInput();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }","id":93760,"modified_method":"private void closeSocket() {\n        if(socket == null) return;\n        try {\n            socket.shutdownOutput();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            socket.shutdownInput();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }","commit_id":"dea9ebca5a3d526a37add77fdfd6df7794493b5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"private Domain parseDomain() {\n        \n        File domainXML = new File(environment.getDomainConfigurationDir(), \"domain.xml\");\n        if (!domainXML.exists()) {\n            throw new IllegalStateException(\"File \" + domainXML.getAbsolutePath() + \" does not exist. A DomainController cannot be launched without a valid domain.xml\");\n        }\n        else if (! domainXML.canWrite()) {\n            throw new IllegalStateException(\"File \" + domainXML.getAbsolutePath() + \" is not writeable. A DomainController cannot be launched without a writable domain.xml\");\n        }\n        \n        try {\n            XMLMapper mapper = XMLMapper.Factory.create();\n            extensionRegistrar.registerStandardDomainReaders(mapper);\n            ParseResult<Domain> parseResult = new ParseResult<Domain>();\n            mapper.parseDocument(parseResult, XMLInputFactory.newInstance().createXMLStreamReader(new BufferedReader(new FileReader(domainXML))));\n            return parseResult.getResult();\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Caught exception during processing of domain.xml\", e);\n        }\n    }","id":93761,"modified_method":"/**\n     * Set the domain for the server manager.  If this is the first time the domain has been set on this instance it will\n     * also invoke the server launch process.\n     *\n     * @param domain The domain configuration\n     */\n    public void setDomain(final Domain domain) {\n        this.domainConfig = domain;\n        if(serversStarted.compareAndSet(false, true)) {\n            startServers();\n        }\n    }","commit_id":"dea9ebca5a3d526a37add77fdfd6df7794493b5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void initiateDomainController() {\n        final LocalDomainControllerElement localDomainControllerElement = hostConfig.getLocalDomainControllerElement();\n        final ServerMaker serverMaker = new ServerMaker(environment, processManagerSlave, messageHandler);\n        final DomainControllerConfig config = new DomainControllerConfig(localDomainControllerElement, hostConfig);\n        try {\n            log.info(\"Starting local domain controller\");\n            localDomainControllerProcess = serverMaker.makeDomainController(getDomainControllerJvmElement(hostConfig, localDomainControllerElement.getJvm()));\n            localDomainControllerProcess.start(config);\n        } catch (IOException e) {\n            log.error(\"Failed to start domain controller server\", e);\n        }\n        this.domainConfig = parseDomain();\n    }","id":93762,"modified_method":"private void initiateDomainController() {\n        final LocalDomainControllerElement localDomainControllerElement = hostConfig.getLocalDomainControllerElement();\n        final ServerMaker serverMaker = new ServerMaker(environment, processManagerSlave, messageHandler);\n        final DomainControllerConfig config = new DomainControllerConfig(localDomainControllerElement, hostConfig);\n        try {\n            log.info(\"Starting local domain controller\");\n            localDomainControllerProcess = serverMaker.makeDomainController(getDomainControllerJvmElement(hostConfig, localDomainControllerElement.getJvm()));\n            localDomainControllerProcess.start(config);\n        } catch (IOException e) {\n            log.error(\"Failed to start domain controller server\", e);\n        }\n        //this.domainConfig = parseDomain();\n    }","commit_id":"dea9ebca5a3d526a37add77fdfd6df7794493b5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void run() {\n            boolean done = false;\n            log.infof(\"DomainController listening on %d for ServerManager requests.\", serverSocket.getLocalPort());\n            while (!done) {\n                try {\n                    final Socket socket = serverSocket.accept();\n                    final String id = String.format(\"%s:%d\", socket.getInetAddress().getHostAddress(), socket.getPort());\n                    final ServerManagerConnection connection = new ServerManagerConnection(id, domainController, socket);\n                    serverManagerConnections.putIfAbsent(id, connection);\n                    executor.execute(connection);\n                } catch (SocketException e) {\n                    log.info(\"Closed server socket\");\n                    done = true;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }","id":93763,"modified_method":"@Override\n        public void run() {\n            boolean done = false;\n            log.infof(\"DomainController listening on %d for ServerManager requests.\", serverSocket.getLocalPort());\n            while (!done) {\n                try {\n                    final Socket socket = serverSocket.accept();\n                    final String id = String.format(\"%s:%d\", socket.getInetAddress().getHostAddress(), socket.getPort());\n                    final ServerManagerConnection connection = new ServerManagerConnection(id, domainController, ServerManagerCommunicationService.this, socket);\n                    if(serverManagerConnections.putIfAbsent(id, connection) != null) {\n                        // TODO: Handle\n                    }\n                    executor.execute(connection);\n                } catch (SocketException e) {\n                    log.info(\"Closed server socket\");\n                    done = true;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }","commit_id":"dea9ebca5a3d526a37add77fdfd6df7794493b5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void run() {\n        Unmarshaller unmarshaller = null;\n        try {\n            final InputStream inputStream = socket.getInputStream();\n            unmarshaller = MARSHALLER_FACTORY.createUnmarshaller(CONFIG);\n            for (;;) {\n                if(!socket.isConnected())\n                    break;\n                unmarshaller.start(Marshalling.createByteInput(inputStream));\n\n                byte commandByte = unmarshaller.readByte();\n                ProtocolCommand command = ProtocolCommand.commandFor(commandByte);\n                if(command == null) {\n                    throw new RuntimeException(\"Invalid command byte received: \" + commandByte);\n                }\n                command.execute(id, socket, unmarshaller); // TODO: How to handle failed commands?\n            }\n        } catch (Throwable t) {\n            throw new RuntimeException(t);\n        } finally {\n            safeClose(unmarshaller);\n            if(socket != null) {\n                try {\n                    socket.close();\n                } catch (Throwable ignored) {\n                    // todo: log me\n                }\n            }\n        }\n    }","id":93764,"modified_method":"@Override\n    public void run() {\n        try {\n            for (;;) {\n                if(!socket.isConnected())\n                    break;\n                ServerManagerConnectionProtocol.IncomingCommand.processNext(this, socketIn);\n            }\n        } catch (Throwable t) {\n            log.error(t);\n            throw new RuntimeException(t);\n        } finally {\n            closeSocket();\n        }\n    }","commit_id":"dea9ebca5a3d526a37add77fdfd6df7794493b5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Create a new instance.\n     *\n     * @param id The server manager identifier\n     * @param domainController The comain controller\n     * @param socket The server managers socket\n     */\n    public ServerManagerConnection(final String id, final DomainController domainController, final Socket socket) {\n        this.id = id;\n        this.domainController = domainController;\n        this.socket = socket;\n    }","id":93765,"modified_method":"/**\n     * Create a new instance.\n     *\n     * @param id The server manager identifier\n     * @param domainController The domain controller\n     * @param communicationService The communication service\n     * @param socket The server managers socket\n     */\n    public ServerManagerConnection(final String id, final DomainController domainController, final ServerManagerCommunicationService communicationService, final Socket socket) {\n        this.id = id;\n        this.domainController = domainController;\n        this.communicationService = communicationService;\n        this.socket = socket;\n        try {\n            this.socketIn = new BufferedInputStream(socket.getInputStream());\n            this.socketOut = new BufferedOutputStream(socket.getOutputStream());\n        } catch (IOException e) {\n            closeSocket();\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"dea9ebca5a3d526a37add77fdfd6df7794493b5b","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void update(@NotNull final Icon icon, @Nullable final String toolTipText) {\n      myCurrentIcon = icon;\n      myToolTipText = toolTipText;\n      myStatusBar.updateWidget(ID());\n    }","id":93766,"modified_method":"private void update(@NotNull final Icon icon, @Nullable final String toolTipText) {\n      myCurrentIcon = icon;\n      myToolTipText = toolTipText;\n      if (myStatusBar != null) myStatusBar.updateWidget(ID());\n    }","commit_id":"06acbca56527fb764731f421a4df90d46e647195","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Consumer<MouseEvent> getClickConsumer() {\n      return new Consumer<MouseEvent>() {\n        public void consume(final MouseEvent mouseEvent) {\n          DataContext dataContext = DataManager.getInstance().getDataContext((Component) myStatusBar);\n          final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n          if (project != null) {\n            ToolWindow changesView = ToolWindowManager.getInstance(project).getToolWindow(ChangesViewContentManager.TOOLWINDOW_ID);\n            changesView.show(new Runnable() {\n              public void run() {\n                ChangesViewContentManager.getInstance(project).selectContent(\"Incoming\");\n              }\n            });\n          }\n        }\n      };\n    }","id":93767,"modified_method":"public Consumer<MouseEvent> getClickConsumer() {\n      return new Consumer<MouseEvent>() {\n        public void consume(final MouseEvent mouseEvent) {\n          if (myStatusBar != null) {\n          DataContext dataContext = DataManager.getInstance().getDataContext((Component) myStatusBar);\n          final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n          if (project != null) {\n            ToolWindow changesView = ToolWindowManager.getInstance(project).getToolWindow(ChangesViewContentManager.TOOLWINDOW_ID);\n            changesView.show(new Runnable() {\n              public void run() {\n                ChangesViewContentManager.getInstance(project).selectContent(\"Incoming\");\n              }\n            });\n          }\n          }\n        }\n      };\n    }","commit_id":"06acbca56527fb764731f421a4df90d46e647195","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void update() {\n    Project project = getProject();\n    if (project == null || project.isDisposed()) {\n      emptyTextAndTooltip();\n      return;\n    }\n\n    GitRepository repo = GitBranchUtil.getCurrentRepository(project);\n    if (repo == null) { // the file is not under version control => display nothing\n      emptyTextAndTooltip();\n      return;\n    }\n\n    int maxLength = myMaxString.length() - 1; // -1, because there are arrows indicating that it is a popup\n    myText = StringUtil.shortenTextWithEllipsis(GitBranchUtil.getDisplayableBranchText(repo), maxLength, 5);\n    myTooltip = getDisplayableBranchTooltip(repo);\n    myStatusBar.updateWidget(ID());\n    mySettings.setRecentRoot(repo.getRoot().getPath());\n  }","id":93768,"modified_method":"private void update() {\n    Project project = getProject();\n    if (project == null || project.isDisposed()) {\n      emptyTextAndTooltip();\n      return;\n    }\n\n    GitRepository repo = GitBranchUtil.getCurrentRepository(project);\n    if (repo == null) { // the file is not under version control => display nothing\n      emptyTextAndTooltip();\n      return;\n    }\n\n    int maxLength = myMaxString.length() - 1; // -1, because there are arrows indicating that it is a popup\n    myText = StringUtil.shortenTextWithEllipsis(GitBranchUtil.getDisplayableBranchText(repo), maxLength, 5);\n    myTooltip = getDisplayableBranchTooltip(repo);\n    if (myStatusBar != null) {\n      myStatusBar.updateWidget(ID());\n    }\n    mySettings.setRecentRoot(repo.getRoot().getPath());\n  }","commit_id":"3cd5386003a6efac9c39a796786084dbc8dba5ae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updatePosition(final Editor editor) {\n    if (editor == null) {\n      myText = \"\";\n    }\n    else {\n      if (!isOurEditor(editor)) return;\n      myText = getPositionText(editor);\n    }\n    myStatusBar.updateWidget(ID());\n  }","id":93769,"modified_method":"private void updatePosition(final Editor editor) {\n    if (editor == null) {\n      myText = \"\";\n    }\n    else {\n      if (!isOurEditor(editor)) return;\n      myText = getPositionText(editor);\n    }\n    if (myStatusBar != null) {\n      myStatusBar.updateWidget(ID());\n    }\n  }","commit_id":"c65a04efa3a2c8e5e51ef714939d99f2bb13e12c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eSet(int featureID, Object newValue) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\tsetParent((CompositeNode)newValue);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\tsetElement(newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}","id":93770,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eSet(int featureID, Object newValue) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\tsetParent((CompositeNode)newValue);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\tsetElement(newValue);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tsetGrammarElement((EObject)newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\tsetParent((CompositeNode)null);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\tsetElement(ELEMENT_EDEFAULT);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}","id":93771,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\tsetParent((CompositeNode)null);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\tsetElement(ELEMENT_EDEFAULT);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tsetGrammarElement((EObject)null);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\tif (resolve) return getParent();\n\t\t\t\treturn basicGetParent();\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\treturn getElement();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}","id":93772,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\tif (resolve) return getParent();\n\t\t\t\treturn basicGetParent();\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\treturn getElement();\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tif (resolve) return getGrammarElement();\n\t\t\t\treturn basicGetGrammarElement();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\treturn parent != null;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\treturn ELEMENT_EDEFAULT == null ? element != null : !ELEMENT_EDEFAULT.equals(element);\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}","id":93773,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\treturn parent != null;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\treturn ELEMENT_EDEFAULT == null ? element != null : !ELEMENT_EDEFAULT.equals(element);\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__GRAMMAR_ELEMENT:\n\t\t\t\treturn grammarElement != null;\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__GRAMMAR_ELEMENT:\n\t\t\t\treturn grammarElement != null;\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\treturn children != null && !children.isEmpty();\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}","id":93774,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\treturn children != null && !children.isEmpty();\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tsetGrammarElement((EObject)null);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\tgetChildren().clear();\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}","id":93775,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\tgetChildren().clear();\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tif (resolve) return getGrammarElement();\n\t\t\t\treturn basicGetGrammarElement();\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\treturn getChildren();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}","id":93776,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\treturn getChildren();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic void eSet(int featureID, Object newValue) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tsetGrammarElement((EObject)newValue);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\tgetChildren().clear();\n\t\t\t\tgetChildren().addAll((Collection<? extends AbstractParserNode>)newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}","id":93777,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic void eSet(int featureID, Object newValue) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\tgetChildren().clear();\n\t\t\t\tgetChildren().addAll((Collection<? extends AbstractParserNode>)newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eSet(int featureID, Object newValue) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\tsetText((String)newValue);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.LEAF_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tsetGrammarElement((EObject)newValue);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\tsetFeature((String)newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}","id":93778,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eSet(int featureID, Object newValue) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\tsetText((String)newValue);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\tsetFeature((String)newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\tsetText(TEXT_EDEFAULT);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.LEAF_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tsetGrammarElement((EObject)null);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\tsetFeature(FEATURE_EDEFAULT);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}","id":93779,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\tsetText(TEXT_EDEFAULT);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\tsetFeature(FEATURE_EDEFAULT);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\treturn getText();\n\t\t\tcase ParsetreePackage.LEAF_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tif (resolve) return getGrammarElement();\n\t\t\t\treturn basicGetGrammarElement();\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\treturn getFeature();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}","id":93780,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\treturn getText();\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\treturn getFeature();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\treturn TEXT_EDEFAULT == null ? text != null : !TEXT_EDEFAULT.equals(text);\n\t\t\tcase ParsetreePackage.LEAF_NODE__GRAMMAR_ELEMENT:\n\t\t\t\treturn grammarElement != null;\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\treturn FEATURE_EDEFAULT == null ? feature != null : !FEATURE_EDEFAULT.equals(feature);\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}","id":93781,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\treturn TEXT_EDEFAULT == null ? text != null : !TEXT_EDEFAULT.equals(text);\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\treturn FEATURE_EDEFAULT == null ? feature != null : !FEATURE_EDEFAULT.equals(feature);\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Complete the initialization of the package and its meta-model.  This\n\t * method is guarded to have no affect on any invocation but its first.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic void initializePackageContents() {\n\t\tif (isInitialized) return;\n\t\tisInitialized = true;\n\n\t\t// Initialize package\n\t\tsetName(eNAME);\n\t\tsetNsPrefix(eNS_PREFIX);\n\t\tsetNsURI(eNS_URI);\n\n\t\t// Create type parameters\n\n\t\t// Set bounds for type parameters\n\n\t\t// Add supertypes to classes\n\t\tcompositeNodeEClass.getESuperTypes().add(this.getAbstractParserNode());\n\t\tleafNodeEClass.getESuperTypes().add(this.getAbstractParserNode());\n\n\t\t// Initialize classes and features; add operations and parameters\n\t\tinitEClass(compositeNodeEClass, CompositeNode.class, \"CompositeNode\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEReference(getCompositeNode_GrammarElement(), ecorePackage.getEObject(), null, \"grammarElement\", null, 0, 1, CompositeNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getCompositeNode_Children(), this.getAbstractParserNode(), this.getAbstractParserNode_Parent(), \"children\", null, 0, -1, CompositeNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\tinitEClass(abstractParserNodeEClass, AbstractParserNode.class, \"AbstractParserNode\", IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEReference(getAbstractParserNode_Parent(), this.getCompositeNode(), this.getCompositeNode_Children(), \"parent\", null, 0, 1, AbstractParserNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEAttribute(getAbstractParserNode_Element(), ecorePackage.getEJavaObject(), \"element\", null, 0, 1, AbstractParserNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\taddEOperation(abstractParserNodeEClass, ecorePackage.getEInt(), \"length\", 0, 1, IS_UNIQUE, IS_ORDERED);\n\n\t\taddEOperation(abstractParserNodeEClass, ecorePackage.getEInt(), \"offset\", 0, 1, IS_UNIQUE, IS_ORDERED);\n\n\t\taddEOperation(abstractParserNodeEClass, ecorePackage.getEInt(), \"line\", 0, 1, IS_UNIQUE, IS_ORDERED);\n\n\t\tinitEClass(leafNodeEClass, LeafNode.class, \"LeafNode\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEAttribute(getLeafNode_Text(), ecorePackage.getEString(), \"text\", null, 0, 1, LeafNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getLeafNode_GrammarElement(), ecorePackage.getEObject(), null, \"grammarElement\", null, 0, 1, LeafNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEAttribute(getLeafNode_Feature(), ecorePackage.getEString(), \"feature\", null, 0, 1, LeafNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\t// Create resource\n\t\tcreateResource(eNS_URI);\n\t}","id":93782,"modified_method":"/**\n\t * Complete the initialization of the package and its meta-model.  This\n\t * method is guarded to have no affect on any invocation but its first.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic void initializePackageContents() {\n\t\tif (isInitialized) return;\n\t\tisInitialized = true;\n\n\t\t// Initialize package\n\t\tsetName(eNAME);\n\t\tsetNsPrefix(eNS_PREFIX);\n\t\tsetNsURI(eNS_URI);\n\n\t\t// Create type parameters\n\n\t\t// Set bounds for type parameters\n\n\t\t// Add supertypes to classes\n\t\tcompositeNodeEClass.getESuperTypes().add(this.getAbstractParserNode());\n\t\tleafNodeEClass.getESuperTypes().add(this.getAbstractParserNode());\n\n\t\t// Initialize classes and features; add operations and parameters\n\t\tinitEClass(compositeNodeEClass, CompositeNode.class, \"CompositeNode\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEReference(getCompositeNode_Children(), this.getAbstractParserNode(), this.getAbstractParserNode_Parent(), \"children\", null, 0, -1, CompositeNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\tinitEClass(abstractParserNodeEClass, AbstractParserNode.class, \"AbstractParserNode\", IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEReference(getAbstractParserNode_Parent(), this.getCompositeNode(), this.getCompositeNode_Children(), \"parent\", null, 0, 1, AbstractParserNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEAttribute(getAbstractParserNode_Element(), ecorePackage.getEJavaObject(), \"element\", null, 0, 1, AbstractParserNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getAbstractParserNode_GrammarElement(), ecorePackage.getEObject(), null, \"grammarElement\", null, 0, 1, AbstractParserNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\taddEOperation(abstractParserNodeEClass, ecorePackage.getEInt(), \"length\", 0, 1, IS_UNIQUE, IS_ORDERED);\n\n\t\taddEOperation(abstractParserNodeEClass, ecorePackage.getEInt(), \"offset\", 0, 1, IS_UNIQUE, IS_ORDERED);\n\n\t\taddEOperation(abstractParserNodeEClass, ecorePackage.getEInt(), \"line\", 0, 1, IS_UNIQUE, IS_ORDERED);\n\n\t\tinitEClass(leafNodeEClass, LeafNode.class, \"LeafNode\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEAttribute(getLeafNode_Text(), ecorePackage.getEString(), \"text\", null, 0, 1, LeafNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEAttribute(getLeafNode_Feature(), ecorePackage.getEString(), \"feature\", null, 0, 1, LeafNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\t// Create resource\n\t\tcreateResource(eNS_URI);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EReference getCompositeNode_Children() {\n\t\treturn (EReference)compositeNodeEClass.getEStructuralFeatures().get(1);\n\t}","id":93783,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EReference getCompositeNode_Children() {\n\t\treturn (EReference)compositeNodeEClass.getEStructuralFeatures().get(0);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EAttribute getLeafNode_Feature() {\n\t\treturn (EAttribute)leafNodeEClass.getEStructuralFeatures().get(2);\n\t}","id":93784,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EAttribute getLeafNode_Feature() {\n\t\treturn (EAttribute)leafNodeEClass.getEStructuralFeatures().get(1);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates the meta-model objects for the package.  This method is\n\t * guarded to have no affect on any invocation but its first.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic void createPackageContents() {\n\t\tif (isCreated) return;\n\t\tisCreated = true;\n\n\t\t// Create classes and their features\n\t\tcompositeNodeEClass = createEClass(COMPOSITE_NODE);\n\t\tcreateEReference(compositeNodeEClass, COMPOSITE_NODE__GRAMMAR_ELEMENT);\n\t\tcreateEReference(compositeNodeEClass, COMPOSITE_NODE__CHILDREN);\n\n\t\tabstractParserNodeEClass = createEClass(ABSTRACT_PARSER_NODE);\n\t\tcreateEReference(abstractParserNodeEClass, ABSTRACT_PARSER_NODE__PARENT);\n\t\tcreateEAttribute(abstractParserNodeEClass, ABSTRACT_PARSER_NODE__ELEMENT);\n\n\t\tleafNodeEClass = createEClass(LEAF_NODE);\n\t\tcreateEAttribute(leafNodeEClass, LEAF_NODE__TEXT);\n\t\tcreateEReference(leafNodeEClass, LEAF_NODE__GRAMMAR_ELEMENT);\n\t\tcreateEAttribute(leafNodeEClass, LEAF_NODE__FEATURE);\n\t}","id":93785,"modified_method":"/**\n\t * Creates the meta-model objects for the package.  This method is\n\t * guarded to have no affect on any invocation but its first.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic void createPackageContents() {\n\t\tif (isCreated) return;\n\t\tisCreated = true;\n\n\t\t// Create classes and their features\n\t\tcompositeNodeEClass = createEClass(COMPOSITE_NODE);\n\t\tcreateEReference(compositeNodeEClass, COMPOSITE_NODE__CHILDREN);\n\n\t\tabstractParserNodeEClass = createEClass(ABSTRACT_PARSER_NODE);\n\t\tcreateEReference(abstractParserNodeEClass, ABSTRACT_PARSER_NODE__PARENT);\n\t\tcreateEAttribute(abstractParserNodeEClass, ABSTRACT_PARSER_NODE__ELEMENT);\n\t\tcreateEReference(abstractParserNodeEClass, ABSTRACT_PARSER_NODE__GRAMMAR_ELEMENT);\n\n\t\tleafNodeEClass = createEClass(LEAF_NODE);\n\t\tcreateEAttribute(leafNodeEClass, LEAF_NODE__TEXT);\n\t\tcreateEAttribute(leafNodeEClass, LEAF_NODE__FEATURE);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EReference getLeafNode_GrammarElement() {\n\t\treturn (EReference)leafNodeEClass.getEStructuralFeatures().get(1);\n\t}","id":93786,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EReference getAbstractParserNode_GrammarElement() {\n\t\treturn (EReference)abstractParserNodeEClass.getEStructuralFeatures().get(2);\n\t}","commit_id":"0f67edced8459cf89670a27012ce2ba65114caaa","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID)\n\t{\n\t\tswitch (featureID)\n\t\t{\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__PARAM_TYPES:\n\t\t\t\tgetParamTypes().clear();\n\t\t\t\treturn;\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__RETURN_TYPE:\n\t\t\t\tsetReturnType((JvmTypeReference)null);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}","id":93787,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID)\n\t{\n\t\tswitch (featureID)\n\t\t{\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__PARAM_TYPES:\n\t\t\t\tgetParamTypes().clear();\n\t\t\t\treturn;\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__RETURN_TYPE:\n\t\t\t\tsetReturnType((JvmTypeReference)null);\n\t\t\t\treturn;\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__TYPE:\n\t\t\t\tsetType((JvmType)null);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType)\n\t{\n\t\tswitch (featureID)\n\t\t{\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__PARAM_TYPES:\n\t\t\t\treturn getParamTypes();\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__RETURN_TYPE:\n\t\t\t\treturn getReturnType();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}","id":93788,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType)\n\t{\n\t\tswitch (featureID)\n\t\t{\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__PARAM_TYPES:\n\t\t\t\treturn getParamTypes();\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__RETURN_TYPE:\n\t\t\t\treturn getReturnType();\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__TYPE:\n\t\t\t\tif (resolve) return getType();\n\t\t\t\treturn basicGetType();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID)\n\t{\n\t\tswitch (featureID)\n\t\t{\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__PARAM_TYPES:\n\t\t\t\treturn paramTypes != null && !paramTypes.isEmpty();\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__RETURN_TYPE:\n\t\t\t\treturn returnType != null;\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}","id":93789,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID)\n\t{\n\t\tswitch (featureID)\n\t\t{\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__PARAM_TYPES:\n\t\t\t\treturn paramTypes != null && !paramTypes.isEmpty();\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__RETURN_TYPE:\n\t\t\t\treturn returnType != null;\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__TYPE:\n\t\t\t\treturn type != null;\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic void eSet(int featureID, Object newValue)\n\t{\n\t\tswitch (featureID)\n\t\t{\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__PARAM_TYPES:\n\t\t\t\tgetParamTypes().clear();\n\t\t\t\tgetParamTypes().addAll((Collection<? extends JvmTypeReference>)newValue);\n\t\t\t\treturn;\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__RETURN_TYPE:\n\t\t\t\tsetReturnType((JvmTypeReference)newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}","id":93790,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic void eSet(int featureID, Object newValue)\n\t{\n\t\tswitch (featureID)\n\t\t{\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__PARAM_TYPES:\n\t\t\t\tgetParamTypes().clear();\n\t\t\t\tgetParamTypes().addAll((Collection<? extends JvmTypeReference>)newValue);\n\t\t\t\treturn;\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__RETURN_TYPE:\n\t\t\t\tsetReturnType((JvmTypeReference)newValue);\n\t\t\t\treturn;\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF__TYPE:\n\t\t\t\tsetType((JvmType)newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic JvmType getType() {\n\t\tif (this.type == null) {\n\t\t\t// make sure scoping has taken place and installed an IJvmTypeProvider\n\t\t\tif (returnType != null)\n\t\t\t\treturnType.getType();\n\t\t\ttype = TypesFactory.eINSTANCE.createJvmVoid();\n\t\t\t((InternalEObject)type).eSetProxyURI(computeTypeUri());\n\t\t}\n\t\treturn super.getType();\n\t}","id":93791,"modified_method":"@Override\n\tpublic JvmType getType() {\n\t\tif (this.type == null) {\n//\t\t\t// make sure scoping has taken place and installed an IJvmTypeProvider\n//\t\t\tif (returnType != null)\n//\t\t\t\treturnType.getType();\n\t\t\ttype = TypesFactory.eINSTANCE.createJvmVoid();\n\t\t\t((InternalEObject)type).eSetProxyURI(computeTypeUri());\n\t\t}\n\t\treturn super.getType();\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a new adapter for an object of class '{@link org.eclipse.xtext.xtype.XDelegateTypeReference <em>XDelegate Type Reference<\/em>}'.\n\t * <!-- begin-user-doc -->\n\t * This default implementation returns null so that we can easily ignore cases;\n\t * it's useful to ignore a case when inheritance will catch all the cases anyway.\n\t * <!-- end-user-doc -->\n\t * @return the new adapter.\n\t * @see org.eclipse.xtext.xtype.XDelegateTypeReference\n\t * @generated\n\t */\n\tpublic Adapter createXDelegateTypeReferenceAdapter()\n\t{\n\t\treturn null;\n\t}","id":93792,"modified_method":"/**\n\t * Creates a new adapter for an object of class '{@link org.eclipse.xtext.xtype.XComputedTypeReference <em>XComputed Type Reference<\/em>}'.\n\t * <!-- begin-user-doc -->\n\t * This default implementation returns null so that we can easily ignore cases;\n\t * it's useful to ignore a case when inheritance will catch all the cases anyway.\n\t * <!-- end-user-doc -->\n\t * @return the new adapter.\n\t * @see org.eclipse.xtext.xtype.XComputedTypeReference\n\t * @generated\n\t */\n\tpublic Adapter createXComputedTypeReferenceAdapter()\n\t{\n\t\treturn null;\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a new adapter for an object of class '{@link org.eclipse.xtext.common.types.JvmParameterizedTypeReference <em>Jvm Parameterized Type Reference<\/em>}'.\n\t * <!-- begin-user-doc -->\n\t * This default implementation returns null so that we can easily ignore cases;\n\t * it's useful to ignore a case when inheritance will catch all the cases anyway.\n\t * <!-- end-user-doc -->\n\t * @return the new adapter.\n\t * @see org.eclipse.xtext.common.types.JvmParameterizedTypeReference\n\t * @generated\n\t */\n\tpublic Adapter createJvmParameterizedTypeReferenceAdapter()\n\t{\n\t\treturn null;\n\t}","id":93793,"modified_method":"/**\n\t * Creates a new adapter for an object of class '{@link org.eclipse.xtext.common.types.JvmSpecializedTypeReference <em>Jvm Specialized Type Reference<\/em>}'.\n\t * <!-- begin-user-doc -->\n\t * This default implementation returns null so that we can easily ignore cases;\n\t * it's useful to ignore a case when inheritance will catch all the cases anyway.\n\t * <!-- end-user-doc -->\n\t * @return the new adapter.\n\t * @see org.eclipse.xtext.common.types.JvmSpecializedTypeReference\n\t * @generated\n\t */\n\tpublic Adapter createJvmSpecializedTypeReferenceAdapter()\n\t{\n\t\treturn null;\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic XDelegateTypeReference createXDelegateTypeReference()\n\t{\n\t\tXDelegateTypeReferenceImplCustom xDelegateTypeReference = new XDelegateTypeReferenceImplCustom();\n\t\treturn xDelegateTypeReference;\n\t}","id":93794,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic XComputedTypeReference createXComputedTypeReference()\n\t{\n\t\tXComputedTypeReferenceImpl xComputedTypeReference = new XComputedTypeReferenceImpl();\n\t\treturn xComputedTypeReference;\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic EObject create(EClass eClass)\n\t{\n\t\tswitch (eClass.getClassifierID())\n\t\t{\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF: return createXFunctionTypeRef();\n\t\t\tcase XtypePackage.XSYNONYM_TYPE_REFERENCE: return createXSynonymTypeReference();\n\t\t\tcase XtypePackage.XDELEGATE_TYPE_REFERENCE: return createXDelegateTypeReference();\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"The class '\" + eClass.getName() + \"' is not a valid classifier\");\n\t\t}\n\t}","id":93795,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic EObject create(EClass eClass)\n\t{\n\t\tswitch (eClass.getClassifierID())\n\t\t{\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF: return createXFunctionTypeRef();\n\t\t\tcase XtypePackage.XCOMPUTED_TYPE_REFERENCE: return createXComputedTypeReference();\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"The class '\" + eClass.getName() + \"' is not a valid classifier\");\n\t\t}\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EClass getXSynonymTypeReference()\n\t{\n\t\treturn xSynonymTypeReferenceEClass;\n\t}","id":93796,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EDataType getIJvmTypeReferenceProvider()\n\t{\n\t\treturn iJvmTypeReferenceProviderEDataType;\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Complete the initialization of the package and its meta-model.  This\n\t * method is guarded to have no affect on any invocation but its first.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic void initializePackageContents()\n\t{\n\t\tif (isInitialized) return;\n\t\tisInitialized = true;\n\n\t\t// Initialize package\n\t\tsetName(eNAME);\n\t\tsetNsPrefix(eNS_PREFIX);\n\t\tsetNsURI(eNS_URI);\n\n\t\t// Obtain other dependent packages\n\t\tTypesPackage theTypesPackage = (TypesPackage)EPackage.Registry.INSTANCE.getEPackage(TypesPackage.eNS_URI);\n\n\t\t// Create type parameters\n\n\t\t// Set bounds for type parameters\n\n\t\t// Add supertypes to classes\n\t\txFunctionTypeRefEClass.getESuperTypes().add(theTypesPackage.getJvmParameterizedTypeReference());\n\t\txSynonymTypeReferenceEClass.getESuperTypes().add(theTypesPackage.getJvmTypeReference());\n\t\txDelegateTypeReferenceEClass.getESuperTypes().add(theTypesPackage.getJvmTypeReference());\n\n\t\t// Initialize classes and features; add operations and parameters\n\t\tinitEClass(xFunctionTypeRefEClass, XFunctionTypeRef.class, \"XFunctionTypeRef\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEReference(getXFunctionTypeRef_ParamTypes(), theTypesPackage.getJvmTypeReference(), null, \"paramTypes\", null, 0, -1, XFunctionTypeRef.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getXFunctionTypeRef_ReturnType(), theTypesPackage.getJvmTypeReference(), null, \"returnType\", null, 0, 1, XFunctionTypeRef.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\tinitEClass(xSynonymTypeReferenceEClass, XSynonymTypeReference.class, \"XSynonymTypeReference\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEReference(getXSynonymTypeReference_Synonymes(), theTypesPackage.getJvmTypeReference(), null, \"synonymes\", null, 0, -1, XSynonymTypeReference.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getXSynonymTypeReference_Type(), theTypesPackage.getJvmType(), null, \"type\", null, 0, 1, XSynonymTypeReference.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\taddEOperation(xSynonymTypeReferenceEClass, theTypesPackage.getJvmTypeReference(), \"getPrimaryType\", 0, 1, IS_UNIQUE, IS_ORDERED);\n\n\t\tinitEClass(xDelegateTypeReferenceEClass, XDelegateTypeReference.class, \"XDelegateTypeReference\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEReference(getXDelegateTypeReference_Delegate(), theTypesPackage.getJvmTypeReference(), null, \"delegate\", null, 0, 1, XDelegateTypeReference.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\t// Create resource\n\t\tcreateResource(eNS_URI);\n\t}","id":93797,"modified_method":"/**\n\t * Complete the initialization of the package and its meta-model.  This\n\t * method is guarded to have no affect on any invocation but its first.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic void initializePackageContents()\n\t{\n\t\tif (isInitialized) return;\n\t\tisInitialized = true;\n\n\t\t// Initialize package\n\t\tsetName(eNAME);\n\t\tsetNsPrefix(eNS_PREFIX);\n\t\tsetNsURI(eNS_URI);\n\n\t\t// Obtain other dependent packages\n\t\tTypesPackage theTypesPackage = (TypesPackage)EPackage.Registry.INSTANCE.getEPackage(TypesPackage.eNS_URI);\n\n\t\t// Create type parameters\n\n\t\t// Set bounds for type parameters\n\n\t\t// Add supertypes to classes\n\t\txFunctionTypeRefEClass.getESuperTypes().add(theTypesPackage.getJvmSpecializedTypeReference());\n\t\txComputedTypeReferenceEClass.getESuperTypes().add(theTypesPackage.getJvmSpecializedTypeReference());\n\n\t\t// Initialize classes and features; add operations and parameters\n\t\tinitEClass(xFunctionTypeRefEClass, XFunctionTypeRef.class, \"XFunctionTypeRef\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEReference(getXFunctionTypeRef_ParamTypes(), theTypesPackage.getJvmTypeReference(), null, \"paramTypes\", null, 0, -1, XFunctionTypeRef.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getXFunctionTypeRef_ReturnType(), theTypesPackage.getJvmTypeReference(), null, \"returnType\", null, 0, 1, XFunctionTypeRef.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getXFunctionTypeRef_Type(), theTypesPackage.getJvmType(), null, \"type\", null, 0, 1, XFunctionTypeRef.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\tinitEClass(xComputedTypeReferenceEClass, XComputedTypeReference.class, \"XComputedTypeReference\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEAttribute(getXComputedTypeReference_TypeProvider(), this.getIJvmTypeReferenceProvider(), \"typeProvider\", null, 0, 1, XComputedTypeReference.class, IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\t// Initialize data types\n\t\tinitEDataType(iJvmTypeReferenceProviderEDataType, IJvmTypeReferenceProvider.class, \"IJvmTypeReferenceProvider\", !IS_SERIALIZABLE, !IS_GENERATED_INSTANCE_CLASS);\n\n\t\t// Create resource\n\t\tcreateResource(eNS_URI);\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates the meta-model objects for the package.  This method is\n\t * guarded to have no affect on any invocation but its first.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic void createPackageContents()\n\t{\n\t\tif (isCreated) return;\n\t\tisCreated = true;\n\n\t\t// Create classes and their features\n\t\txFunctionTypeRefEClass = createEClass(XFUNCTION_TYPE_REF);\n\t\tcreateEReference(xFunctionTypeRefEClass, XFUNCTION_TYPE_REF__PARAM_TYPES);\n\t\tcreateEReference(xFunctionTypeRefEClass, XFUNCTION_TYPE_REF__RETURN_TYPE);\n\n\t\txSynonymTypeReferenceEClass = createEClass(XSYNONYM_TYPE_REFERENCE);\n\t\tcreateEReference(xSynonymTypeReferenceEClass, XSYNONYM_TYPE_REFERENCE__SYNONYMES);\n\t\tcreateEReference(xSynonymTypeReferenceEClass, XSYNONYM_TYPE_REFERENCE__TYPE);\n\n\t\txDelegateTypeReferenceEClass = createEClass(XDELEGATE_TYPE_REFERENCE);\n\t\tcreateEReference(xDelegateTypeReferenceEClass, XDELEGATE_TYPE_REFERENCE__DELEGATE);\n\t}","id":93798,"modified_method":"/**\n\t * Creates the meta-model objects for the package.  This method is\n\t * guarded to have no affect on any invocation but its first.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic void createPackageContents()\n\t{\n\t\tif (isCreated) return;\n\t\tisCreated = true;\n\n\t\t// Create classes and their features\n\t\txFunctionTypeRefEClass = createEClass(XFUNCTION_TYPE_REF);\n\t\tcreateEReference(xFunctionTypeRefEClass, XFUNCTION_TYPE_REF__PARAM_TYPES);\n\t\tcreateEReference(xFunctionTypeRefEClass, XFUNCTION_TYPE_REF__RETURN_TYPE);\n\t\tcreateEReference(xFunctionTypeRefEClass, XFUNCTION_TYPE_REF__TYPE);\n\n\t\txComputedTypeReferenceEClass = createEClass(XCOMPUTED_TYPE_REFERENCE);\n\t\tcreateEAttribute(xComputedTypeReferenceEClass, XCOMPUTED_TYPE_REFERENCE__TYPE_PROVIDER);\n\n\t\t// Create data types\n\t\tiJvmTypeReferenceProviderEDataType = createEDataType(IJVM_TYPE_REFERENCE_PROVIDER);\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EClass getXDelegateTypeReference()\n\t{\n\t\treturn xDelegateTypeReferenceEClass;\n\t}","id":93799,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EClass getXComputedTypeReference()\n\t{\n\t\treturn xComputedTypeReferenceEClass;\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Returns the result of interpreting the object as an instance of '<em>Jvm Parameterized Type Reference<\/em>'.\n\t * <!-- begin-user-doc -->\n\t * This implementation returns null;\n\t * returning a non-null result will terminate the switch.\n\t * <!-- end-user-doc -->\n\t * @param object the target of the switch.\n\t * @return the result of interpreting the object as an instance of '<em>Jvm Parameterized Type Reference<\/em>'.\n\t * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)\n\t * @generated\n\t */\n\tpublic T caseJvmParameterizedTypeReference(JvmParameterizedTypeReference object)\n\t{\n\t\treturn null;\n\t}","id":93800,"modified_method":"/**\n\t * Returns the result of interpreting the object as an instance of '<em>Jvm Specialized Type Reference<\/em>'.\n\t * <!-- begin-user-doc -->\n\t * This implementation returns null;\n\t * returning a non-null result will terminate the switch.\n\t * <!-- end-user-doc -->\n\t * @param object the target of the switch.\n\t * @return the result of interpreting the object as an instance of '<em>Jvm Specialized Type Reference<\/em>'.\n\t * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)\n\t * @generated\n\t */\n\tpublic T caseJvmSpecializedTypeReference(JvmSpecializedTypeReference object)\n\t{\n\t\treturn null;\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Calls <code>caseXXX<\/code> for each class of the model until one returns a non null result; it yields that result.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @return the first non-null result returned by a <code>caseXXX<\/code> call.\n\t * @generated\n\t */\n\tprotected T doSwitch(int classifierID, EObject theEObject)\n\t{\n\t\tswitch (classifierID)\n\t\t{\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF:\n\t\t\t{\n\t\t\t\tXFunctionTypeRef xFunctionTypeRef = (XFunctionTypeRef)theEObject;\n\t\t\t\tT result = caseXFunctionTypeRef(xFunctionTypeRef);\n\t\t\t\tif (result == null) result = caseJvmParameterizedTypeReference(xFunctionTypeRef);\n\t\t\t\tif (result == null) result = caseJvmTypeReference(xFunctionTypeRef);\n\t\t\t\tif (result == null) result = defaultCase(theEObject);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcase XtypePackage.XSYNONYM_TYPE_REFERENCE:\n\t\t\t{\n\t\t\t\tXSynonymTypeReference xSynonymTypeReference = (XSynonymTypeReference)theEObject;\n\t\t\t\tT result = caseXSynonymTypeReference(xSynonymTypeReference);\n\t\t\t\tif (result == null) result = caseJvmTypeReference(xSynonymTypeReference);\n\t\t\t\tif (result == null) result = defaultCase(theEObject);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcase XtypePackage.XDELEGATE_TYPE_REFERENCE:\n\t\t\t{\n\t\t\t\tXDelegateTypeReference xDelegateTypeReference = (XDelegateTypeReference)theEObject;\n\t\t\t\tT result = caseXDelegateTypeReference(xDelegateTypeReference);\n\t\t\t\tif (result == null) result = caseJvmTypeReference(xDelegateTypeReference);\n\t\t\t\tif (result == null) result = defaultCase(theEObject);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tdefault: return defaultCase(theEObject);\n\t\t}\n\t}","id":93801,"modified_method":"/**\n\t * Calls <code>caseXXX<\/code> for each class of the model until one returns a non null result; it yields that result.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @return the first non-null result returned by a <code>caseXXX<\/code> call.\n\t * @generated\n\t */\n\tprotected T doSwitch(int classifierID, EObject theEObject)\n\t{\n\t\tswitch (classifierID)\n\t\t{\n\t\t\tcase XtypePackage.XFUNCTION_TYPE_REF:\n\t\t\t{\n\t\t\t\tXFunctionTypeRef xFunctionTypeRef = (XFunctionTypeRef)theEObject;\n\t\t\t\tT result = caseXFunctionTypeRef(xFunctionTypeRef);\n\t\t\t\tif (result == null) result = caseJvmSpecializedTypeReference(xFunctionTypeRef);\n\t\t\t\tif (result == null) result = caseJvmTypeReference(xFunctionTypeRef);\n\t\t\t\tif (result == null) result = defaultCase(theEObject);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcase XtypePackage.XCOMPUTED_TYPE_REFERENCE:\n\t\t\t{\n\t\t\t\tXComputedTypeReference xComputedTypeReference = (XComputedTypeReference)theEObject;\n\t\t\t\tT result = caseXComputedTypeReference(xComputedTypeReference);\n\t\t\t\tif (result == null) result = caseJvmSpecializedTypeReference(xComputedTypeReference);\n\t\t\t\tif (result == null) result = caseJvmTypeReference(xComputedTypeReference);\n\t\t\t\tif (result == null) result = defaultCase(theEObject);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tdefault: return defaultCase(theEObject);\n\t\t}\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Returns the result of interpreting the object as an instance of '<em>XDelegate Type Reference<\/em>'.\n\t * <!-- begin-user-doc -->\n\t * This implementation returns null;\n\t * returning a non-null result will terminate the switch.\n\t * <!-- end-user-doc -->\n\t * @param object the target of the switch.\n\t * @return the result of interpreting the object as an instance of '<em>XDelegate Type Reference<\/em>'.\n\t * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)\n\t * @generated\n\t */\n\tpublic T caseXDelegateTypeReference(XDelegateTypeReference object)\n\t{\n\t\treturn null;\n\t}","id":93802,"modified_method":"/**\n\t * Returns the result of interpreting the object as an instance of '<em>XComputed Type Reference<\/em>'.\n\t * <!-- begin-user-doc -->\n\t * This implementation returns null;\n\t * returning a non-null result will terminate the switch.\n\t * <!-- end-user-doc -->\n\t * @param object the target of the switch.\n\t * @return the result of interpreting the object as an instance of '<em>XComputed Type Reference<\/em>'.\n\t * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)\n\t * @generated\n\t */\n\tpublic T caseXComputedTypeReference(XComputedTypeReference object)\n\t{\n\t\treturn null;\n\t}","commit_id":"212907ce1fca501b43d15af196399e76312e973b","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\tif (resolve) return getParent();\n\t\t\t\treturn basicGetParent();\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\treturn getElement();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}","id":93803,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\tif (resolve) return getParent();\n\t\t\t\treturn basicGetParent();\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\treturn getElement();\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tif (resolve) return getGrammarElement();\n\t\t\t\treturn basicGetGrammarElement();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\treturn parent != null;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\treturn ELEMENT_EDEFAULT == null ? element != null : !ELEMENT_EDEFAULT.equals(element);\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}","id":93804,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\treturn parent != null;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\treturn ELEMENT_EDEFAULT == null ? element != null : !ELEMENT_EDEFAULT.equals(element);\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__GRAMMAR_ELEMENT:\n\t\t\t\treturn grammarElement != null;\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eSet(int featureID, Object newValue) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\tsetParent((CompositeNode)newValue);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\tsetElement(newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}","id":93805,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eSet(int featureID, Object newValue) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\tsetParent((CompositeNode)newValue);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\tsetElement(newValue);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tsetGrammarElement((EObject)newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\tsetParent((CompositeNode)null);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\tsetElement(ELEMENT_EDEFAULT);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}","id":93806,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__PARENT:\n\t\t\t\tsetParent((CompositeNode)null);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__ELEMENT:\n\t\t\t\tsetElement(ELEMENT_EDEFAULT);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.ABSTRACT_PARSER_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tsetGrammarElement((EObject)null);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic void eSet(int featureID, Object newValue) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tsetGrammarElement((EObject)newValue);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\tgetChildren().clear();\n\t\t\t\tgetChildren().addAll((Collection<? extends AbstractParserNode>)newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}","id":93807,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic void eSet(int featureID, Object newValue) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\tgetChildren().clear();\n\t\t\t\tgetChildren().addAll((Collection<? extends AbstractParserNode>)newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tsetGrammarElement((EObject)null);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\tgetChildren().clear();\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}","id":93808,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\tgetChildren().clear();\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__GRAMMAR_ELEMENT:\n\t\t\t\treturn grammarElement != null;\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\treturn children != null && !children.isEmpty();\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}","id":93809,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\treturn children != null && !children.isEmpty();\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tif (resolve) return getGrammarElement();\n\t\t\t\treturn basicGetGrammarElement();\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\treturn getChildren();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}","id":93810,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.COMPOSITE_NODE__CHILDREN:\n\t\t\t\treturn getChildren();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\tsetText(TEXT_EDEFAULT);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.LEAF_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tsetGrammarElement((EObject)null);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\tsetFeature(FEATURE_EDEFAULT);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}","id":93811,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eUnset(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\tsetText(TEXT_EDEFAULT);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\tsetFeature(FEATURE_EDEFAULT);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eUnset(featureID);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eSet(int featureID, Object newValue) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\tsetText((String)newValue);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.LEAF_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tsetGrammarElement((EObject)newValue);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\tsetFeature((String)newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}","id":93812,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic void eSet(int featureID, Object newValue) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\tsetText((String)newValue);\n\t\t\t\treturn;\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\tsetFeature((String)newValue);\n\t\t\t\treturn;\n\t\t}\n\t\tsuper.eSet(featureID, newValue);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\treturn getText();\n\t\t\tcase ParsetreePackage.LEAF_NODE__GRAMMAR_ELEMENT:\n\t\t\t\tif (resolve) return getGrammarElement();\n\t\t\t\treturn basicGetGrammarElement();\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\treturn getFeature();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}","id":93813,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic Object eGet(int featureID, boolean resolve, boolean coreType) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\treturn getText();\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\treturn getFeature();\n\t\t}\n\t\treturn super.eGet(featureID, resolve, coreType);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\treturn TEXT_EDEFAULT == null ? text != null : !TEXT_EDEFAULT.equals(text);\n\t\t\tcase ParsetreePackage.LEAF_NODE__GRAMMAR_ELEMENT:\n\t\t\t\treturn grammarElement != null;\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\treturn FEATURE_EDEFAULT == null ? feature != null : !FEATURE_EDEFAULT.equals(feature);\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}","id":93814,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\t@Override\n\tpublic boolean eIsSet(int featureID) {\n\t\tswitch (featureID) {\n\t\t\tcase ParsetreePackage.LEAF_NODE__TEXT:\n\t\t\t\treturn TEXT_EDEFAULT == null ? text != null : !TEXT_EDEFAULT.equals(text);\n\t\t\tcase ParsetreePackage.LEAF_NODE__FEATURE:\n\t\t\t\treturn FEATURE_EDEFAULT == null ? feature != null : !FEATURE_EDEFAULT.equals(feature);\n\t\t}\n\t\treturn super.eIsSet(featureID);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EReference getCompositeNode_Children() {\n\t\treturn (EReference)compositeNodeEClass.getEStructuralFeatures().get(1);\n\t}","id":93815,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EReference getCompositeNode_Children() {\n\t\treturn (EReference)compositeNodeEClass.getEStructuralFeatures().get(0);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EAttribute getLeafNode_Feature() {\n\t\treturn (EAttribute)leafNodeEClass.getEStructuralFeatures().get(2);\n\t}","id":93816,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EAttribute getLeafNode_Feature() {\n\t\treturn (EAttribute)leafNodeEClass.getEStructuralFeatures().get(1);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Complete the initialization of the package and its meta-model.  This\n\t * method is guarded to have no affect on any invocation but its first.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic void initializePackageContents() {\n\t\tif (isInitialized) return;\n\t\tisInitialized = true;\n\n\t\t// Initialize package\n\t\tsetName(eNAME);\n\t\tsetNsPrefix(eNS_PREFIX);\n\t\tsetNsURI(eNS_URI);\n\n\t\t// Create type parameters\n\n\t\t// Set bounds for type parameters\n\n\t\t// Add supertypes to classes\n\t\tcompositeNodeEClass.getESuperTypes().add(this.getAbstractParserNode());\n\t\tleafNodeEClass.getESuperTypes().add(this.getAbstractParserNode());\n\n\t\t// Initialize classes and features; add operations and parameters\n\t\tinitEClass(compositeNodeEClass, CompositeNode.class, \"CompositeNode\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEReference(getCompositeNode_GrammarElement(), ecorePackage.getEObject(), null, \"grammarElement\", null, 0, 1, CompositeNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getCompositeNode_Children(), this.getAbstractParserNode(), this.getAbstractParserNode_Parent(), \"children\", null, 0, -1, CompositeNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\tinitEClass(abstractParserNodeEClass, AbstractParserNode.class, \"AbstractParserNode\", IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEReference(getAbstractParserNode_Parent(), this.getCompositeNode(), this.getCompositeNode_Children(), \"parent\", null, 0, 1, AbstractParserNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEAttribute(getAbstractParserNode_Element(), ecorePackage.getEJavaObject(), \"element\", null, 0, 1, AbstractParserNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\taddEOperation(abstractParserNodeEClass, ecorePackage.getEInt(), \"length\", 0, 1, IS_UNIQUE, IS_ORDERED);\n\n\t\taddEOperation(abstractParserNodeEClass, ecorePackage.getEInt(), \"offset\", 0, 1, IS_UNIQUE, IS_ORDERED);\n\n\t\taddEOperation(abstractParserNodeEClass, ecorePackage.getEInt(), \"line\", 0, 1, IS_UNIQUE, IS_ORDERED);\n\n\t\tinitEClass(leafNodeEClass, LeafNode.class, \"LeafNode\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEAttribute(getLeafNode_Text(), ecorePackage.getEString(), \"text\", null, 0, 1, LeafNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getLeafNode_GrammarElement(), ecorePackage.getEObject(), null, \"grammarElement\", null, 0, 1, LeafNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEAttribute(getLeafNode_Feature(), ecorePackage.getEString(), \"feature\", null, 0, 1, LeafNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\t// Create resource\n\t\tcreateResource(eNS_URI);\n\t}","id":93817,"modified_method":"/**\n\t * Complete the initialization of the package and its meta-model.  This\n\t * method is guarded to have no affect on any invocation but its first.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic void initializePackageContents() {\n\t\tif (isInitialized) return;\n\t\tisInitialized = true;\n\n\t\t// Initialize package\n\t\tsetName(eNAME);\n\t\tsetNsPrefix(eNS_PREFIX);\n\t\tsetNsURI(eNS_URI);\n\n\t\t// Create type parameters\n\n\t\t// Set bounds for type parameters\n\n\t\t// Add supertypes to classes\n\t\tcompositeNodeEClass.getESuperTypes().add(this.getAbstractParserNode());\n\t\tleafNodeEClass.getESuperTypes().add(this.getAbstractParserNode());\n\n\t\t// Initialize classes and features; add operations and parameters\n\t\tinitEClass(compositeNodeEClass, CompositeNode.class, \"CompositeNode\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEReference(getCompositeNode_Children(), this.getAbstractParserNode(), this.getAbstractParserNode_Parent(), \"children\", null, 0, -1, CompositeNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\tinitEClass(abstractParserNodeEClass, AbstractParserNode.class, \"AbstractParserNode\", IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEReference(getAbstractParserNode_Parent(), this.getCompositeNode(), this.getCompositeNode_Children(), \"parent\", null, 0, 1, AbstractParserNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEAttribute(getAbstractParserNode_Element(), ecorePackage.getEJavaObject(), \"element\", null, 0, 1, AbstractParserNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getAbstractParserNode_GrammarElement(), ecorePackage.getEObject(), null, \"grammarElement\", null, 0, 1, AbstractParserNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_COMPOSITE, IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\taddEOperation(abstractParserNodeEClass, ecorePackage.getEInt(), \"length\", 0, 1, IS_UNIQUE, IS_ORDERED);\n\n\t\taddEOperation(abstractParserNodeEClass, ecorePackage.getEInt(), \"offset\", 0, 1, IS_UNIQUE, IS_ORDERED);\n\n\t\taddEOperation(abstractParserNodeEClass, ecorePackage.getEInt(), \"line\", 0, 1, IS_UNIQUE, IS_ORDERED);\n\n\t\tinitEClass(leafNodeEClass, LeafNode.class, \"LeafNode\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEAttribute(getLeafNode_Text(), ecorePackage.getEString(), \"text\", null, 0, 1, LeafNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEAttribute(getLeafNode_Feature(), ecorePackage.getEString(), \"feature\", null, 0, 1, LeafNode.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\t// Create resource\n\t\tcreateResource(eNS_URI);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EReference getLeafNode_GrammarElement() {\n\t\treturn (EReference)leafNodeEClass.getEStructuralFeatures().get(1);\n\t}","id":93818,"modified_method":"/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EReference getAbstractParserNode_GrammarElement() {\n\t\treturn (EReference)abstractParserNodeEClass.getEStructuralFeatures().get(2);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates the meta-model objects for the package.  This method is\n\t * guarded to have no affect on any invocation but its first.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic void createPackageContents() {\n\t\tif (isCreated) return;\n\t\tisCreated = true;\n\n\t\t// Create classes and their features\n\t\tcompositeNodeEClass = createEClass(COMPOSITE_NODE);\n\t\tcreateEReference(compositeNodeEClass, COMPOSITE_NODE__GRAMMAR_ELEMENT);\n\t\tcreateEReference(compositeNodeEClass, COMPOSITE_NODE__CHILDREN);\n\n\t\tabstractParserNodeEClass = createEClass(ABSTRACT_PARSER_NODE);\n\t\tcreateEReference(abstractParserNodeEClass, ABSTRACT_PARSER_NODE__PARENT);\n\t\tcreateEAttribute(abstractParserNodeEClass, ABSTRACT_PARSER_NODE__ELEMENT);\n\n\t\tleafNodeEClass = createEClass(LEAF_NODE);\n\t\tcreateEAttribute(leafNodeEClass, LEAF_NODE__TEXT);\n\t\tcreateEReference(leafNodeEClass, LEAF_NODE__GRAMMAR_ELEMENT);\n\t\tcreateEAttribute(leafNodeEClass, LEAF_NODE__FEATURE);\n\t}","id":93819,"modified_method":"/**\n\t * Creates the meta-model objects for the package.  This method is\n\t * guarded to have no affect on any invocation but its first.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic void createPackageContents() {\n\t\tif (isCreated) return;\n\t\tisCreated = true;\n\n\t\t// Create classes and their features\n\t\tcompositeNodeEClass = createEClass(COMPOSITE_NODE);\n\t\tcreateEReference(compositeNodeEClass, COMPOSITE_NODE__CHILDREN);\n\n\t\tabstractParserNodeEClass = createEClass(ABSTRACT_PARSER_NODE);\n\t\tcreateEReference(abstractParserNodeEClass, ABSTRACT_PARSER_NODE__PARENT);\n\t\tcreateEAttribute(abstractParserNodeEClass, ABSTRACT_PARSER_NODE__ELEMENT);\n\t\tcreateEReference(abstractParserNodeEClass, ABSTRACT_PARSER_NODE__GRAMMAR_ELEMENT);\n\n\t\tleafNodeEClass = createEClass(LEAF_NODE);\n\t\tcreateEAttribute(leafNodeEClass, LEAF_NODE__TEXT);\n\t\tcreateEAttribute(leafNodeEClass, LEAF_NODE__FEATURE);\n\t}","commit_id":"5a79c16b858a43955bcedd7d9ae8458aafa72f56","url":"https://github.com/eclipse/xtext"},{"original_method":"public void unschedulePublishToRemote(\n\t\t\tlong groupId, String jobName, String groupName)\n\t\tthrows PortalException, SystemException {\n\n\t\tGroupPermissionUtil.check(\n\t\t\tgetPermissionChecker(), groupId, ActionKeys.MANAGE_LAYOUTS);\n\n\t\tSchedulerEngineUtil.unschedule(jobName, groupName);\n\t}","id":93820,"modified_method":"public void unschedulePublishToRemote(\n\t\t\tlong groupId, String jobName, String groupName)\n\t\tthrows PortalException, SystemException {\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\tif (group.isStagingGroup()) {\n\t\t\tgroup = group.getLiveGroup();\n\t\t}\n\n\t\tif (group.isWorkflowEnabled() &&\n\t\t\t!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, groupId, ActionKeys.MANAGE_STAGING) &&\n\t\t\t!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, groupId, ActionKeys.PUBLISH_STAGING)) {\n\n\t\t\tthrow new PrincipalException();\n\t\t}\n\t\telse {\n\t\t\tGroupPermissionUtil.check(\n\t\t\t\tpermissionChecker, groupId, ActionKeys.MANAGE_LAYOUTS);\n\t\t}\n\n\t\tSchedulerEngineUtil.unschedule(jobName, groupName);\n\t}","commit_id":"498f235da69560c37deb5cdeb5101b875d5c3327","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void schedulePublishToLive(\n\t\t\tlong sourceGroupId, long targetGroupId, boolean privateLayout,\n\t\t\tMap<Long, Boolean> layoutIdMap, Map<String, String[]> parameterMap,\n\t\t\tString scope, Date startDate, Date endDate, String groupName,\n\t\t\tString cronText, Date schedulerStartDate, Date schedulerEndDate,\n\t\t\tString description)\n\t\tthrows PortalException, SystemException {\n\n\t\tGroupPermissionUtil.check(\n\t\t\tgetPermissionChecker(), sourceGroupId, ActionKeys.MANAGE_LAYOUTS);\n\n\t\tGroupPermissionUtil.check(\n\t\t\tgetPermissionChecker(), targetGroupId, ActionKeys.MANAGE_LAYOUTS);\n\n\t\tString command = StringPool.BLANK;\n\n\t\tif (scope.equals(\"all-pages\")) {\n\t\t\tcommand = LayoutsLocalPublisherRequest.COMMAND_ALL_PAGES;\n\t\t}\n\t\telse if (scope.equals(\"selected-pages\")) {\n\t\t\tcommand = LayoutsLocalPublisherRequest.COMMAND_SELECTED_PAGES;\n\t\t}\n\n\t\tLayoutsLocalPublisherRequest publisherRequest =\n\t\t\tnew LayoutsLocalPublisherRequest(\n\t\t\t\tcommand, getUserId(), sourceGroupId, targetGroupId,\n\t\t\t\tprivateLayout, layoutIdMap, parameterMap, startDate, endDate);\n\n\t\tSchedulerEngineUtil.schedule(\n\t\t\tgroupName, cronText, schedulerStartDate, schedulerEndDate,\n\t\t\tdescription, DestinationNames.LAYOUTS_LOCAL_PUBLISHER,\n\t\t\tJSONUtil.serialize(publisherRequest));\n\t}","id":93821,"modified_method":"public void schedulePublishToLive(\n\t\t\tlong sourceGroupId, long targetGroupId, boolean privateLayout,\n\t\t\tMap<Long, Boolean> layoutIdMap, Map<String, String[]> parameterMap,\n\t\t\tString scope, Date startDate, Date endDate, String groupName,\n\t\t\tString cronText, Date schedulerStartDate, Date schedulerEndDate,\n\t\t\tString description)\n\t\tthrows PortalException, SystemException {\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tif (!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, targetGroupId, ActionKeys.MANAGE_STAGING) &&\n\t\t\t!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, targetGroupId, ActionKeys.PUBLISH_STAGING)) {\n\n\t\t\tthrow new PrincipalException();\n\t\t}\n\n\t\tString command = StringPool.BLANK;\n\n\t\tif (scope.equals(\"all-pages\")) {\n\t\t\tcommand = LayoutsLocalPublisherRequest.COMMAND_ALL_PAGES;\n\t\t}\n\t\telse if (scope.equals(\"selected-pages\")) {\n\t\t\tcommand = LayoutsLocalPublisherRequest.COMMAND_SELECTED_PAGES;\n\t\t}\n\n\t\tLayoutsLocalPublisherRequest publisherRequest =\n\t\t\tnew LayoutsLocalPublisherRequest(\n\t\t\t\tcommand, getUserId(), sourceGroupId, targetGroupId,\n\t\t\t\tprivateLayout, layoutIdMap, parameterMap, startDate, endDate);\n\n\t\tSchedulerEngineUtil.schedule(\n\t\t\tgroupName, cronText, schedulerStartDate, schedulerEndDate,\n\t\t\tdescription, DestinationNames.LAYOUTS_LOCAL_PUBLISHER,\n\t\t\tJSONUtil.serialize(publisherRequest));\n\t}","commit_id":"498f235da69560c37deb5cdeb5101b875d5c3327","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void unschedulePublishToLive(\n\t\t\tlong groupId, String jobName, String groupName)\n\t\tthrows PortalException, SystemException {\n\n\t\tGroupPermissionUtil.check(\n\t\t\tgetPermissionChecker(), groupId, ActionKeys.MANAGE_LAYOUTS);\n\n\t\tSchedulerEngineUtil.unschedule(jobName, groupName);\n\t}","id":93822,"modified_method":"public void unschedulePublishToLive(\n\t\t\tlong groupId, String jobName, String groupName)\n\t\tthrows PortalException, SystemException {\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tif (!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, groupId, ActionKeys.MANAGE_STAGING) &&\n\t\t\t!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, groupId, ActionKeys.PUBLISH_STAGING)) {\n\n\t\t\tthrow new PrincipalException();\n\t\t}\n\n\t\tSchedulerEngineUtil.unschedule(jobName, groupName);\n\t}","commit_id":"498f235da69560c37deb5cdeb5101b875d5c3327","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void schedulePublishToRemote(\n\t\t\tlong sourceGroupId, boolean privateLayout,\n\t\t\tMap<Long, Boolean> layoutIdMap,\n\t\t\tMap<String, String[]> parameterMap, String remoteAddress,\n\t\t\tint remotePort, boolean secureConnection, long remoteGroupId,\n\t\t\tboolean remotePrivateLayout, Date startDate, Date endDate,\n\t\t\tString groupName, String cronText, Date schedulerStartDate,\n\t\t\tDate schedulerEndDate, String description)\n\t\tthrows PortalException, SystemException {\n\n\t\tGroupPermissionUtil.check(\n\t\t\tgetPermissionChecker(), sourceGroupId, ActionKeys.MANAGE_LAYOUTS);\n\n\t\tLayoutsRemotePublisherRequest publisherRequest =\n\t\t\tnew LayoutsRemotePublisherRequest(\n\t\t\t\tgetUserId(), sourceGroupId, privateLayout, layoutIdMap,\n\t\t\t\tparameterMap, remoteAddress, remotePort, secureConnection,\n\t\t\t\tremoteGroupId, remotePrivateLayout, startDate, endDate);\n\n\t\tSchedulerEngineUtil.schedule(\n\t\t\tgroupName, cronText, schedulerStartDate, schedulerEndDate,\n\t\t\tdescription, DestinationNames.LAYOUTS_REMOTE_PUBLISHER,\n\t\t\tJSONUtil.serialize(publisherRequest));\n\t}","id":93823,"modified_method":"public void schedulePublishToRemote(\n\t\t\tlong sourceGroupId, boolean privateLayout,\n\t\t\tMap<Long, Boolean> layoutIdMap,\n\t\t\tMap<String, String[]> parameterMap, String remoteAddress,\n\t\t\tint remotePort, boolean secureConnection, long remoteGroupId,\n\t\t\tboolean remotePrivateLayout, Date startDate, Date endDate,\n\t\t\tString groupName, String cronText, Date schedulerStartDate,\n\t\t\tDate schedulerEndDate, String description)\n\t\tthrows PortalException, SystemException {\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(sourceGroupId);\n\n\t\tif (group.isStagingGroup()) {\n\t\t\tgroup = group.getLiveGroup();\n\t\t}\n\n\t\tif (group.isWorkflowEnabled() &&\n\t\t\t!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, sourceGroupId, ActionKeys.MANAGE_STAGING) &&\n\t\t\t!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, sourceGroupId, ActionKeys.PUBLISH_STAGING)) {\n\n\t\t\tthrow new PrincipalException();\n\t\t}\n\t\telse {\n\t\t\tGroupPermissionUtil.check(\n\t\t\t\tpermissionChecker, sourceGroupId, ActionKeys.MANAGE_LAYOUTS);\n\t\t}\n\n\t\tLayoutsRemotePublisherRequest publisherRequest =\n\t\t\tnew LayoutsRemotePublisherRequest(\n\t\t\t\tgetUserId(), sourceGroupId, privateLayout, layoutIdMap,\n\t\t\t\tparameterMap, remoteAddress, remotePort, secureConnection,\n\t\t\t\tremoteGroupId, remotePrivateLayout, startDate, endDate);\n\n\t\tSchedulerEngineUtil.schedule(\n\t\t\tgroupName, cronText, schedulerStartDate, schedulerEndDate,\n\t\t\tdescription, DestinationNames.LAYOUTS_REMOTE_PUBLISHER,\n\t\t\tJSONUtil.serialize(publisherRequest));\n\t}","commit_id":"498f235da69560c37deb5cdeb5101b875d5c3327","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest,\n\t *      javax.servlet.ServletResponse, javax.servlet.FilterChain)\n\t */\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n\t\tthrows IOException, ServletException\n\t{\n\t\tHttpServletRequest httpServletRequest = ((HttpServletRequest)request);\n\t\tHttpSession httpSession = httpServletRequest.getSession(false);\n\t\tif (httpSession != null)\n\t\t{\n\t\t\tif (sessionKey == null)\n\t\t\t{\n\t\t\t\tWebApplication application = (WebApplication)Application.get(filterName);\n\t\t\t\tif (application == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Could not find wicket application mapped to filter: \" +\n\t\t\t\t\t\t\tfilterName +\n\t\t\t\t\t\t\t\". Make sure you set filterName attribute to the name of the wicket filter \" +\n\t\t\t\t\t\t\t\"for the wicket application whose session you want to access.\");\n\t\t\t\t}\n\t\t\t\tsessionKey = application.getSessionAttributePrefix(null, filterName) +\n\t\t\t\t\tSession.SESSION_ATTRIBUTE_NAME;\n\n\t\t\t\tlog.debug(\"will use {} as the session key to get the Wicket session\", sessionKey);\n\t\t\t}\n\n\t\t\tSession session = (Session)httpSession.getAttribute(sessionKey);\n\t\t\tif (session != null)\n\t\t\t{\n\t\t\t\t// set the session's threadlocal\n\t\t\t\tThreadContext.setSession(session);\n\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t{\n\t\t\t\t\tlog.debug(\"session \" + session + \" set as current for \" +\n\t\t\t\t\t\thttpServletRequest.getContextPath() + \",\" +\n\t\t\t\t\t\thttpServletRequest.getServerName());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t{\n\t\t\t\t\tlog.debug(\"could not set Wicket session: key \" + sessionKey +\n\t\t\t\t\t\t\" not found in http session for \" + httpServletRequest.getContextPath() +\n\t\t\t\t\t\t\",\" + httpServletRequest.getServerName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.debug(\"could not set Wicket session: no http session was created yet for {},{}\",\n\t\t\t\thttpServletRequest.getContextPath(), httpServletRequest.getServerName());\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\t// go on with processing\n\t\t\tchain.doFilter(request, response);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tThreadContext.detach();\n\t\t}\n\t}","id":93824,"modified_method":"/**\n\t * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest,\n\t *      javax.servlet.ServletResponse, javax.servlet.FilterChain)\n\t */\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n\t\tthrows IOException, ServletException\n\t{\n\t\tHttpServletRequest httpServletRequest = ((HttpServletRequest)request);\n\t\tHttpSession httpSession = httpServletRequest.getSession(false);\n\t\tWebApplication application = null;\n\t\tSession session = null;\n\t\tif (httpSession != null)\n\t\t{\n\t\t\tif (sessionKey == null)\n\t\t\t{\n\t\t\t\tapplication = (WebApplication)Application.get(filterName);\n\t\t\t\tif (application == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Could not find wicket application mapped to filter: \" +\n\t\t\t\t\t\t\tfilterName +\n\t\t\t\t\t\t\t\". Make sure you set filterName attribute to the name of the wicket filter \" +\n\t\t\t\t\t\t\t\"for the wicket application whose session you want to access.\");\n\t\t\t\t}\n\n\t\t\t\tsessionKey = application.getSessionAttributePrefix(null, filterName) +\n\t\t\t\t\tSession.SESSION_ATTRIBUTE_NAME;\n\n\t\t\t\tlog.debug(\"will use {} as the session key to get the Wicket session\", sessionKey);\n\t\t\t}\n\n\t\t\tsession = (Session)httpSession.getAttribute(sessionKey);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.debug(\"could not set Wicket session: no http session was created yet for {},{}\",\n\t\t\t\thttpServletRequest.getContextPath(), httpServletRequest.getServerName());\n\t\t}\n\n\t\tif (session == null)\n\t\t{\n\t\t\t// no session found\n\n\t\t\tif (log.isDebugEnabled())\n\t\t\t{\n\t\t\t\tlog.debug(\"could not set Wicket session: key \" + sessionKey +\n\t\t\t\t\t\" not found in http session for \" + httpServletRequest.getContextPath() + \",\" +\n\t\t\t\t\thttpServletRequest.getServerName());\n\t\t\t}\n\n\t\t\t// go on with processing\n\t\t\tchain.doFilter(request, response);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// session found\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tThreadContext.setApplication(application);\n\t\t\t\tThreadContext.setSession(session);\n\t\t\t\tlog.debug(\"session \" + session + \" set as current for \" +\n\t\t\t\t\thttpServletRequest.getContextPath() + \",\" + httpServletRequest.getServerName());\n\n\t\t\t\t// go on with processing\n\t\t\t\tchain.doFilter(request, response);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tThreadContext.detach();\n\t\t\t}\n\t\t}\n\t}","commit_id":"a59e2421025962c423a9bac39d6f7e17bf42acf7","url":"https://github.com/apache/wicket"},{"original_method":"public void doFilter(\n\t\t\tServletRequest req, ServletResponse res, FilterChain chain)\n\t\tthrows IOException, ServletException {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (USE_VIRTUAL_HOST_FILTER) {\n\t\t\t\t_log.debug(\"Virtual host is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Virtual host is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tHttpServletRequest httpReq = (HttpServletRequest)req;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Received \" + httpReq.getRequestURL());\n\t\t}\n\n\t\tlong companyId = PortalInstances.getCompanyId(httpReq);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Company id \" + companyId);\n\t\t}\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\n\t\tString friendlyURL = httpReq.getRequestURI().toLowerCase();\n\n\t\tif ((!contextPath.equals(StringPool.SLASH)) &&\n\t\t\t(friendlyURL.indexOf(contextPath) != -1)) {\n\n\t\t\tfriendlyURL = friendlyURL.substring(\n\t\t\t\tcontextPath.length(), friendlyURL.length());\n\t\t}\n\n\t\tfriendlyURL = StringUtil.replace(\n\t\t\tfriendlyURL, StringPool.DOUBLE_SLASH, StringPool.SLASH);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Friendly URL \" + friendlyURL);\n\t\t}\n\n\t\tString redirect = null;\n\n\t\tif (USE_VIRTUAL_HOST_FILTER && isValidFriendlyURL(friendlyURL)) {\n\t\t\tString mainPath = PortalUtil.PATH_MAIN;\n\n\t\t\tLayoutSet layoutSet = (LayoutSet)req.getAttribute(\n\t\t\t\tWebKeys.VIRTUAL_HOST_LAYOUT_SET);\n\n\t\t\tif (layoutSet != null) {\n\t\t\t\ttry {\n\t\t\t\t\tredirect = PortalUtil.getLayoutActualURL(\n\t\t\t\t\t\tlayoutSet.getGroupId(), layoutSet.isPrivateLayout(),\n\t\t\t\t\t\tmainPath, friendlyURL);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_log.error(e, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (redirect != null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Redirect to \" + redirect);\n\t\t\t}\n\n\t\t\tRequestDispatcher rd = _ctx.getRequestDispatcher(redirect);\n\n\t\t\trd.forward(req, res);\n\t\t}\n\t\telse {\n\t\t\tchain.doFilter(req, res);\n\t\t}\n\t}","id":93825,"modified_method":"public void doFilter(\n\t\t\tServletRequest req, ServletResponse res, FilterChain chain)\n\t\tthrows IOException, ServletException {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (USE_VIRTUAL_HOST_FILTER) {\n\t\t\t\t_log.debug(\"Virtual host is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Virtual host is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tHttpServletRequest httpReq = (HttpServletRequest)req;\n\n\t\t// Company id needs to always be called here so that it's properly set\n\t\t// in subsequent calls\n\n\t\tlong companyId = PortalInstances.getCompanyId(httpReq);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Company id \" + companyId);\n\t\t}\n\n\t\tif (!USE_VIRTUAL_HOST_FILTER) {\n\t\t\tchain.doFilter(req, res);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString requestURL = httpReq.getRequestURL().toString();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Received \" + requestURL);\n\t\t}\n\n\t\tif (!isValidRequestURL(requestURL)) {\n\t\t\tchain.doFilter(req, res);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\n\t\tString friendlyURL = httpReq.getRequestURI().toLowerCase();\n\n\t\tif ((!contextPath.equals(StringPool.SLASH)) &&\n\t\t\t(friendlyURL.indexOf(contextPath) != -1)) {\n\n\t\t\tfriendlyURL = friendlyURL.substring(\n\t\t\t\tcontextPath.length(), friendlyURL.length());\n\t\t}\n\n\t\tfriendlyURL = StringUtil.replace(\n\t\t\tfriendlyURL, StringPool.DOUBLE_SLASH, StringPool.SLASH);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Friendly URL \" + friendlyURL);\n\t\t}\n\n\t\tif (!isValidFriendlyURL(friendlyURL)) {\n\t\t\tchain.doFilter(req, res);\n\n\t\t\treturn;\n\t\t}\n\n\t\tLayoutSet layoutSet = (LayoutSet)req.getAttribute(\n\t\t\tWebKeys.VIRTUAL_HOST_LAYOUT_SET);\n\n\t\tif (layoutSet != null) {\n\t\t\ttry {\n\t\t\t\tString mainPath = PortalUtil.PATH_MAIN;\n\n\t\t\t\tString redirect = PortalUtil.getLayoutActualURL(\n\t\t\t\t\tlayoutSet.getGroupId(), layoutSet.isPrivateLayout(),\n\t\t\t\t\tmainPath, friendlyURL);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Redirect to \" + redirect);\n\t\t\t\t}\n\n\t\t\t\tRequestDispatcher rd = _ctx.getRequestDispatcher(redirect);\n\n\t\t\t\trd.forward(req, res);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcatch (NoSuchLayoutException nsle) {\n\t\t\t\tnsle.printStackTrace();\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(nsle.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tchain.doFilter(req, res);\n\t}","commit_id":"d506267d149275e9a27308c8a383c9be4f53d06b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isValidFriendlyURL(String friendlyURL) {\n\t\tif (PortalInstances.isIgnorePath(friendlyURL) ||\n\t\t\tfriendlyURL.startsWith(_PATH_HTML) ||\n\t\t\tfriendlyURL.startsWith(_PATH_IMAGE) ||\n\t\t\tfriendlyURL.startsWith(_PATH_WAP)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tint code = LayoutImpl.validateFriendlyURL(friendlyURL);\n\n\t\tif ((code > -1) &&\n\t\t\t(code != LayoutFriendlyURLException.ENDS_WITH_SLASH)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","id":93826,"modified_method":"protected boolean isValidFriendlyURL(String friendlyURL) {\n\t\tif (PortalInstances.isIgnorePath(friendlyURL) ||\n\t\t\tfriendlyURL.startsWith(_PATH_C) ||\n\t\t\tfriendlyURL.startsWith(_PATH_HTML) ||\n\t\t\tfriendlyURL.startsWith(_PATH_IMAGE) ||\n\t\t\tfriendlyURL.startsWith(_PATH_WAP)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tint code = LayoutImpl.validateFriendlyURL(friendlyURL);\n\n\t\tif ((code > -1) &&\n\t\t\t(code != LayoutFriendlyURLException.ENDS_WITH_SLASH)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"d506267d149275e9a27308c8a383c9be4f53d06b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void readFrom(DataInputStream in) throws IOException {\n        int len;\n\n        len=in.readShort();\n        //read the four bytes\n        byte[] a = new byte[len];\n        //in theory readFully(byte[]) should be faster\n        //than read(byte[]) since latter reads\n        // 4 bytes one at a time\n        in.readFully(a);\n        //then read the port\n        port = in.readInt();\n        //look up an instance in the cache\n        if(jdk_14)\n            this.ip_addr=InetAddress.getByAddress(a);\n        else\n            this.ip_addr = getIpAddress(a);\n        len=in.read();\n        if(len == 0)\n            return;\n        len=in.readInt();\n        if(len > 0) {\n            additional_data=new byte[len];\n            in.readFully(additional_data, 0, additional_data.length);\n        }\n    }","id":93827,"modified_method":"public void readFrom(DataInputStream in) throws IOException {\n        int len;\n\n        len=in.readShort();\n        if(len > 0) {\n            //read the four bytes\n            byte[] a = new byte[len];\n            //in theory readFully(byte[]) should be faster\n            //than read(byte[]) since latter reads\n            // 4 bytes one at a time\n            in.readFully(a);\n            //look up an instance in the cache\n            if(jdk_14)\n                this.ip_addr=InetAddress.getByAddress(a);\n            else\n                this.ip_addr = getIpAddress(a);\n        }\n        //then read the port\n        port=in.readInt();\n\n        len=in.read();\n        if(len == 0)\n            return;\n        len=in.readInt();\n        if(len > 0) {\n            additional_data=new byte[len];\n            in.readFully(additional_data, 0, additional_data.length);\n        }\n    }","commit_id":"44c356ac766d2cc3661d4911863d729763fa37b6","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeTo(DataOutputStream out) throws IOException {\n        byte[] address = ip_addr.getAddress();\n        out.writeShort(address.length); // 2 bytes\n        out.write(address, 0, address.length);\n        out.writeInt(port);\n        if(additional_data != null) {\n            out.write(1);\n            out.writeInt(additional_data.length);\n            out.write(additional_data, 0, additional_data.length);\n        }\n        else {\n            out.write(0);\n        }\n    }","id":93828,"modified_method":"public void writeTo(DataOutputStream out) throws IOException {\n        byte[] address;\n\n        if(ip_addr != null) {\n            address=ip_addr.getAddress();\n            out.writeShort(address.length); // 2 bytes\n            out.write(address, 0, address.length);\n        }\n        else {\n            out.writeShort(0);\n        }\n        out.writeInt(port);\n        if(additional_data != null) {\n            out.write(1);\n            out.writeInt(additional_data.length);\n            out.write(additional_data, 0, additional_data.length);\n        }\n        else {\n            out.write(0);\n        }\n    }","commit_id":"44c356ac766d2cc3661d4911863d729763fa37b6","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void skipPool(DataInputStream in) throws IOException {\n\t\t\n\t    int\tsize = in.readUnsignedShort();\n\n\t    for (int i = 1; i < size; i++) {\n\t    \tswitch (in.readUnsignedByte()) {\n\t    \tcase CodeConstants.CONSTANT_Utf8:\n\t    \t\tin.readUTF();\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Integer:\n\t    \tcase CodeConstants.CONSTANT_Float:\n\t    \tcase CodeConstants.CONSTANT_Fieldref:\n\t    \tcase CodeConstants.CONSTANT_Methodref:\n\t    \tcase CodeConstants.CONSTANT_InterfaceMethodref:\n\t    \tcase CodeConstants.CONSTANT_NameAndType: \n\t    \t\tin.skip(4);\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Long:\n\t    \tcase CodeConstants.CONSTANT_Double:\n\t    \t\tin.skip(8);\n\t    \t\ti++;\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Class:\n\t    \tcase CodeConstants.CONSTANT_String:\n\t    \t\tin.skip(2);\n\t    \t}\n\t    }\n\t}","id":93829,"modified_method":"public static void skipPool(DataInputStream in) throws IOException {\n\t\t\n\t    int\tsize = in.readUnsignedShort();\n\n\t    for (int i = 1; i < size; i++) {\n\t    \tswitch (in.readUnsignedByte()) {\n\t    \tcase CodeConstants.CONSTANT_Utf8:\n\t    \t\tin.readUTF();\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Integer:\n\t    \tcase CodeConstants.CONSTANT_Float:\n\t    \tcase CodeConstants.CONSTANT_Fieldref:\n\t    \tcase CodeConstants.CONSTANT_Methodref:\n\t    \tcase CodeConstants.CONSTANT_InterfaceMethodref:\n\t    \tcase CodeConstants.CONSTANT_NameAndType: \n\t    \tcase CodeConstants.CONSTANT_InvokeDynamic:\n\t    \t\tin.skip(4);\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Long:\n\t    \tcase CodeConstants.CONSTANT_Double:\n\t    \t\tin.skip(8);\n\t    \t\ti++;\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Class:\n\t    \tcase CodeConstants.CONSTANT_String:\n\t    \tcase CodeConstants.CONSTANT_MethodType:\n\t    \t\tin.skip(2);\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_MethodHandle:\n\t    \t\tin.skip(3);\n\t    \t}\n\t    }\n\t}","commit_id":"d017534f7082cc0423a5f22c32a8ca9024e9eae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConstantPool(DataInputStream in) throws IOException {\n\t\t\n\t    int\tsize = in.readUnsignedShort();\n\n\t    int[] pass = new int[size];\n\t\t\n\t    // first dummy constant\n\t    pool.add(null);\n\t    \n\t    // first pass: read the elements\n\t    for (int i = 1; i < size; i++) {\n\n\t    \tbyte tag = (byte)in.readUnsignedByte();\n\n\t    \tswitch (tag) {\n\t    \tcase CodeConstants.CONSTANT_Utf8:\n\t    \t\tpool.add(new PrimitiveConstant(CodeConstants.CONSTANT_Utf8, in.readUTF()));\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Integer:\n\t    \t\tpool.add(new PrimitiveConstant(CodeConstants.CONSTANT_Integer, new Integer(in.readInt())));\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Float:\n\t    \t\tpool.add(new PrimitiveConstant(CodeConstants.CONSTANT_Float, new Float(in.readFloat())));\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Long:\n\t    \t\tpool.add(new PrimitiveConstant(CodeConstants.CONSTANT_Long, new Long(in.readLong())));\n\t    \t\tpool.add(null);\n\t    \t\ti++;\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Double:\n\t    \t\tpool.add(new PrimitiveConstant(CodeConstants.CONSTANT_Double, new Double(in.readDouble())));\n\t    \t\tpool.add(null);\n\t    \t\ti++;\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Class:\n\t    \tcase CodeConstants.CONSTANT_String:\n\t    \tcase CodeConstants.CONSTANT_MethodType:\n\t    \t\tpool.add(new PrimitiveConstant(tag, in.readUnsignedShort()));\n\t    \t\tpass[i] = 1;\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Fieldref:\n\t    \tcase CodeConstants.CONSTANT_Methodref:\n\t    \tcase CodeConstants.CONSTANT_InterfaceMethodref:\n\t    \tcase CodeConstants.CONSTANT_NameAndType: \n\t    \t\tpool.add(new LinkConstant(tag, in.readUnsignedShort(), in.readUnsignedShort()));\n\t    \t\tif(tag == CodeConstants.CONSTANT_NameAndType) {\n\t\t    \t\tpass[i] = 1;\n\t    \t\t} else {\n\t\t    \t\tpass[i] = 2;\n\t    \t\t}\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_MethodHandle:\n\t    \t\tpool.add(new LinkConstant(tag, in.readUnsignedByte(), in.readUnsignedShort()));\n\t    \t\tpass[i] = 3;\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_InvokeDynamic:\n\t    \t\tpool.add(new LinkConstant(tag, in.readUnsignedShort(), in.readUnsignedShort()));\n\t    \t\tpass[i] = 2;\n\t    \t}\n\t    }\n\t    \n\t    \n\t    // resolving complex pool elements\n\t    for(int pass_index = 1; pass_index <= 3; pass_index++) {\n\t\t    for(int i = 1; i < size; i++) {\n\t\t    \tif(pass[i] == pass_index) {\n\t\t    \t\tpool.get(i).resolveConstant(this);\n\t\t    \t}\n\t\t    }\n\t    }\n\t    \n\t    // get global constant pool interceptor instance, if any available\n\t    interceptor = DecompilerContext.getPoolInterceptor();\n\t}","id":93830,"modified_method":"public ConstantPool(DataInputStream in) throws IOException {\n\t\t\n\t    int\tsize = in.readUnsignedShort();\n\n\t    int[] pass = new int[size];\n\t\t\n\t    // first dummy constant\n\t    pool.add(null);\n\t    \n\t    // first pass: read the elements\n\t    for (int i = 1; i < size; i++) {\n\n\t    \tbyte tag = (byte)in.readUnsignedByte();\n\n\t    \tswitch (tag) {\n\t    \tcase CodeConstants.CONSTANT_Utf8:\n\t    \t\tpool.add(new PrimitiveConstant(CodeConstants.CONSTANT_Utf8, in.readUTF()));\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Integer:\n\t    \t\tpool.add(new PrimitiveConstant(CodeConstants.CONSTANT_Integer, new Integer(in.readInt())));\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Float:\n\t    \t\tpool.add(new PrimitiveConstant(CodeConstants.CONSTANT_Float, new Float(in.readFloat())));\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Long:\n\t    \t\tpool.add(new PrimitiveConstant(CodeConstants.CONSTANT_Long, new Long(in.readLong())));\n\t    \t\tpool.add(null);\n\t    \t\ti++;\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Double:\n\t    \t\tpool.add(new PrimitiveConstant(CodeConstants.CONSTANT_Double, new Double(in.readDouble())));\n\t    \t\tpool.add(null);\n\t    \t\ti++;\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Class:\n\t    \tcase CodeConstants.CONSTANT_String:\n\t    \tcase CodeConstants.CONSTANT_MethodType:\n\t    \t\tpool.add(new PrimitiveConstant(tag, in.readUnsignedShort()));\n\t    \t\tpass[i] = 1;\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_Fieldref:\n\t    \tcase CodeConstants.CONSTANT_Methodref:\n\t    \tcase CodeConstants.CONSTANT_InterfaceMethodref:\n\t    \tcase CodeConstants.CONSTANT_NameAndType: \n\t    \tcase CodeConstants.CONSTANT_InvokeDynamic:\n\t    \t\tpool.add(new LinkConstant(tag, in.readUnsignedShort(), in.readUnsignedShort()));\n\t    \t\tif(tag == CodeConstants.CONSTANT_NameAndType) {\n\t\t    \t\tpass[i] = 1;\n\t    \t\t} else {\n\t\t    \t\tpass[i] = 2;\n\t    \t\t}\n\t    \t\tbreak;\n\t    \tcase CodeConstants.CONSTANT_MethodHandle:\n\t    \t\tpool.add(new LinkConstant(tag, in.readUnsignedByte(), in.readUnsignedShort()));\n\t    \t\tpass[i] = 3;\n\t    \t\tbreak;\n\t    \t}\n\t    }\n\t    \n\t    \n\t    // resolving complex pool elements\n\t    for(int pass_index = 1; pass_index <= 3; pass_index++) {\n\t\t    for(int i = 1; i < size; i++) {\n\t\t    \tif(pass[i] == pass_index) {\n\t\t    \t\tpool.get(i).resolveConstant(this);\n\t\t    \t}\n\t\t    }\n\t    }\n\t    \n\t    // get global constant pool interceptor instance, if any available\n\t    interceptor = DecompilerContext.getPoolInterceptor();\n\t}","commit_id":"d017534f7082cc0423a5f22c32a8ca9024e9eae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeToStream(DataOutputStream out) throws IOException {\n\t\tout.writeByte(type);\n\t\tout.writeShort(index1);\n\t\tout.writeShort(index2);\n\t}","id":93831,"modified_method":"public void writeToStream(DataOutputStream out) throws IOException {\n\t\tout.writeByte(type);\n\t\tif(type == CONSTANT_MethodHandle) {\n\t\t\tout.writeByte(index1);\n\t\t} else {\n\t\t\tout.writeShort(index1);\n\t\t}\n\t\tout.writeShort(index2);\n\t}","commit_id":"d017534f7082cc0423a5f22c32a8ca9024e9eae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void resolveConstant(ConstantPool pool) {\n\n\t\tif(type == CONSTANT_NameAndType) {\n\t\t\telementname = pool.getPrimitiveConstant(index1).getString();\n\t\t\tdescriptor = pool.getPrimitiveConstant(index2).getString();\n\t\t} else {\n\t\t\tclassname = pool.getPrimitiveConstant(index1).getString();\n\t\t\t\n\t\t\tLinkConstant nametype = pool.getLinkConstant(index2);\n\t\t\telementname = nametype.elementname;\n\t\t\tdescriptor = nametype.descriptor;\n\t\t}\n\t\t\n\t\tinitConstant();\n\t}","id":93832,"modified_method":"public void resolveConstant(ConstantPool pool) {\n\n\t\tif(type == CONSTANT_NameAndType) {\n\t\t\telementname = pool.getPrimitiveConstant(index1).getString();\n\t\t\tdescriptor = pool.getPrimitiveConstant(index2).getString();\n\t\t} else if(type == CONSTANT_MethodHandle) {\n\t\t\tLinkConstant ref_info = pool.getLinkConstant(index2);\n\t\t\t\n\t\t\tclassname = ref_info.classname;\n\t\t\telementname = ref_info.elementname;\n\t\t\tdescriptor = ref_info.descriptor;\n\t\t\t\n\t\t} else {\n\t\t\tif(type != CONSTANT_InvokeDynamic) {\n\t\t\t\tclassname = pool.getPrimitiveConstant(index1).getString();\n\t\t\t}\n\t\t\t\n\t\t\tLinkConstant nametype = pool.getLinkConstant(index2);\n\t\t\telementname = nametype.elementname;\n\t\t\tdescriptor = nametype.descriptor;\n\t\t}\n\t\t\n\t\tinitConstant();\n\t}","commit_id":"d017534f7082cc0423a5f22c32a8ca9024e9eae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initConstant() {\n\t\t\n\t\tif(type == CONSTANT_Methodref || type == CONSTANT_InterfaceMethodref) {\n\t\t\tresolveDescriptor(descriptor);\n\t\t} else if(type == CONSTANT_Fieldref) {\n\t\t\treturnCategory2 = (\"D\".equals(descriptor) || \"J\".equals(descriptor));\n\t\t}\n\t\t\n\t}","id":93833,"modified_method":"private void initConstant() {\n\t\t\n\t\tif(type == CONSTANT_Methodref || type == CONSTANT_InterfaceMethodref || type == CONSTANT_InvokeDynamic || type == CONSTANT_MethodHandle) {\n\t\t\tresolveDescriptor(descriptor);\n\t\t} else if(type == CONSTANT_Fieldref) {\n\t\t\treturnCategory2 = (\"D\".equals(descriptor) || \"J\".equals(descriptor));\n\t\t}\n\t\t\n\t}","commit_id":"d017534f7082cc0423a5f22c32a8ca9024e9eae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void resolveConstant(ConstantPool pool) {\n\n\t\tif(type == CONSTANT_Class || type == CONSTANT_String) {\n\t\t\tvalue = pool.getPrimitiveConstant(index).getString(); \n\t\t\tinitConstant();\n\t\t}\n\t}","id":93834,"modified_method":"public void resolveConstant(ConstantPool pool) {\n\n\t\tif(type == CONSTANT_Class || type == CONSTANT_String || type == CONSTANT_MethodType) {\n\t\t\tvalue = pool.getPrimitiveConstant(index).getString(); \n\t\t\tinitConstant();\n\t\t}\n\t}","commit_id":"d017534f7082cc0423a5f22c32a8ca9024e9eae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static StructGeneralAttribute getMatchingAttributeInstance(int nameindex, String attrname) {\n\t\t\n\t\tStructGeneralAttribute attr; \n\t\t\n\t\tif(ATTRIBUTE_INNER_CLASSES.equals(attrname)) {\n\t\t\tattr = new StructInnerClassesAttribute();\n\t\t} else if(ATTRIBUTE_CONSTANT_VALUE.equals(attrname)) {\n\t\t\tattr = new StructConstantValueAttribute();\n\t\t} else if(ATTRIBUTE_SIGNATURE.equals(attrname)) {\n\t\t\tattr = new StructGenericSignatureAttribute();\n\t\t} else if(ATTRIBUTE_ANNOTATION_DEFAULT.equals(attrname)) {\n\t\t\tattr = new StructAnnDefaultAttribute();\n\t\t} else if(ATTRIBUTE_EXCEPTIONS.equals(attrname)) {\n\t\t\tattr = new StructExceptionsAttribute();\n\t\t} else if(ATTRIBUTE_ENCLOSING_METHOD.equals(attrname)) {\n\t\t\tattr = new StructEnclosingMethodAttribute();\n\t\t} else if(ATTRIBUTE_RUNTIME_VISIBLE_ANNOTATIONS.equals(attrname) ||\n\t\t\t\tATTRIBUTE_RUNTIME_INVISIBLE_ANNOTATIONS.equals(attrname)) {\n\t\t\tattr = new StructAnnotationAttribute();\n\t\t} else if(ATTRIBUTE_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS.equals(attrname) ||\n\t\t\t\tATTRIBUTE_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS.equals(attrname)) {\n\t\t\tattr = new StructAnnotationParameterAttribute();\n\t\t} else if(ATTRIBUTE_LOCAL_VARIABLE_TABLE.equals(attrname)) {\n\t\t\tattr = new StructLocalVariableTableAttribute();\n\t\t} else {\n\t\t\t// unsupported attribute\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tattr.setAttribute_name_index(nameindex);\n\t\treturn attr;\n\t}","id":93835,"modified_method":"public static StructGeneralAttribute getMatchingAttributeInstance(int nameindex, String attrname) {\n\t\t\n\t\tStructGeneralAttribute attr; \n\t\t\n\t\tif(ATTRIBUTE_INNER_CLASSES.equals(attrname)) {\n\t\t\tattr = new StructInnerClassesAttribute();\n\t\t} else if(ATTRIBUTE_CONSTANT_VALUE.equals(attrname)) {\n\t\t\tattr = new StructConstantValueAttribute();\n\t\t} else if(ATTRIBUTE_SIGNATURE.equals(attrname)) {\n\t\t\tattr = new StructGenericSignatureAttribute();\n\t\t} else if(ATTRIBUTE_ANNOTATION_DEFAULT.equals(attrname)) {\n\t\t\tattr = new StructAnnDefaultAttribute();\n\t\t} else if(ATTRIBUTE_EXCEPTIONS.equals(attrname)) {\n\t\t\tattr = new StructExceptionsAttribute();\n\t\t} else if(ATTRIBUTE_ENCLOSING_METHOD.equals(attrname)) {\n\t\t\tattr = new StructEnclosingMethodAttribute();\n\t\t} else if(ATTRIBUTE_RUNTIME_VISIBLE_ANNOTATIONS.equals(attrname) ||\n\t\t\t\tATTRIBUTE_RUNTIME_INVISIBLE_ANNOTATIONS.equals(attrname)) {\n\t\t\tattr = new StructAnnotationAttribute();\n\t\t} else if(ATTRIBUTE_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS.equals(attrname) ||\n\t\t\t\tATTRIBUTE_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS.equals(attrname)) {\n\t\t\tattr = new StructAnnotationParameterAttribute();\n\t\t} else if(ATTRIBUTE_RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attrname) ||\n\t\t\t\tATTRIBUTE_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attrname)) {\n\t\t\tattr = new StructAnnotationTypeAttribute();\n\t\t} else if(ATTRIBUTE_LOCAL_VARIABLE_TABLE.equals(attrname)) {\n\t\t\tattr = new StructLocalVariableTableAttribute();\n\t\t} else if(ATTRIBUTE_BOOTSTRAP_METHODS.equals(attrname)) {\n\t\t\tattr = new StructBootstrapMethodsAttribute();\n\t\t} else {\n\t\t\t// unsupported attribute\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tattr.setAttribute_name_index(nameindex);\n\t\treturn attr;\n\t}","commit_id":"d017534f7082cc0423a5f22c32a8ca9024e9eae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeTo(DataOutputStream out) throws IOException {\n        byte[] address = ip_addr.getAddress();\n        out.writeShort(address.length); // 2 bytes\n        out.write(address, 0, address.length);\n        out.writeInt(port);\n        if(additional_data != null) {\n            out.write(1);\n            out.writeInt(additional_data.length);\n            out.write(additional_data, 0, additional_data.length);\n        }\n        else {\n            out.write(0);\n        }\n    }","id":93836,"modified_method":"public void writeTo(DataOutputStream out) throws IOException {\n        byte[] address;\n\n        if(ip_addr != null) {\n            address=ip_addr.getAddress();\n            out.writeShort(address.length); // 2 bytes\n            out.write(address, 0, address.length);\n        }\n        else {\n            out.writeShort(0);\n        }\n        out.writeInt(port);\n        if(additional_data != null) {\n            out.write(1);\n            out.writeInt(additional_data.length);\n            out.write(additional_data, 0, additional_data.length);\n        }\n        else {\n            out.write(0);\n        }\n    }","commit_id":"0c9f0c0c0d8a0556c9aa23441cd4a44c04b922f2","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readFrom(DataInputStream in) throws IOException {\n        int len;\n\n        len=in.readShort();\n        //read the four bytes\n        byte[] a = new byte[len];\n        //in theory readFully(byte[]) should be faster\n        //than read(byte[]) since latter reads\n        // 4 bytes one at a time\n        in.readFully(a);\n        //then read the port\n        port = in.readInt();\n        //look up an instance in the cache\n        if(jdk_14)\n            this.ip_addr=InetAddress.getByAddress(a);\n        else\n            this.ip_addr = getIpAddress(a);\n        len=in.read();\n        if(len == 0)\n            return;\n        len=in.readInt();\n        if(len > 0) {\n            additional_data=new byte[len];\n            in.readFully(additional_data, 0, additional_data.length);\n        }\n    }","id":93837,"modified_method":"public void readFrom(DataInputStream in) throws IOException {\n        int len;\n\n        len=in.readShort();\n        if(len > 0) {\n            //read the four bytes\n            byte[] a = new byte[len];\n            //in theory readFully(byte[]) should be faster\n            //than read(byte[]) since latter reads\n            // 4 bytes one at a time\n            in.readFully(a);\n            //look up an instance in the cache\n            if(jdk_14)\n                this.ip_addr=InetAddress.getByAddress(a);\n            else\n                this.ip_addr = getIpAddress(a);\n        }\n        //then read the port\n        port=in.readInt();\n\n        len=in.read();\n        if(len == 0)\n            return;\n        len=in.readInt();\n        if(len > 0) {\n            additional_data=new byte[len];\n            in.readFully(additional_data, 0, additional_data.length);\n        }\n    }","commit_id":"0c9f0c0c0d8a0556c9aa23441cd4a44c04b922f2","url":"https://github.com/belaban/JGroups"},{"original_method":"public Project001Stub()\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model;\n\n        try\n        {\n            model = pomReader.read(\n                ReaderFactory.newXmlReader( new File( getBasedir(), \"target/test-classes/unit/project-001/pom.xml\" ) ) );\n            setModel( model );\n\n            setGroupId( model.getGroupId() );\n            setArtifactId( model.getArtifactId() );\n            setVersion( model.getVersion() );\n            setName( model.getName() );\n            setUrl( model.getUrl() );\n            setPackaging( model.getPackaging() );\n\n            Build build = new Build();\n            build.setFinalName( getArtifactId() + \"-\" + getVersion() );\n            build.setDirectory( getBasedir() + \"/target/test/unit/project-001/target\" );\n            setBuild( build );\n\n            String basedir = getBasedir().getAbsolutePath();\n            List compileSourceRoots = new ArrayList();\n            compileSourceRoots.add( basedir + \"/target/test-classes/unit/project-001/src/main/java\" );\n            setCompileSourceRoots( compileSourceRoots );\n\n            List testCompileSourceRoots = new ArrayList();\n            testCompileSourceRoots.add( basedir + \"/target/test-classes/unit/project-001/src/test/java\" );\n            setTestCompileSourceRoots( testCompileSourceRoots );\n\n            setResources( model.getBuild().getResources() );\n            setTestResources( model.getBuild().getTestResources() );\n\n            SourcePluginArtifactStub artifact =\n                new SourcePluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging(), null );\n            artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n            artifact.setType( \"jar\" );\n            artifact.setBaseVersion( \"1.0-SNAPSHOT\" );\n            setArtifact( artifact );\n\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","id":93838,"modified_method":"public Project001Stub()\n    {\n        Model model;\n\n        try\n        {\n            model = readModelFromFile( new File( getBasedir(), \"target/test-classes/unit/project-001/pom.xml\" ) );\n            setModel( model );\n\n            setGroupId( model.getGroupId() );\n            setArtifactId( model.getArtifactId() );\n            setVersion( model.getVersion() );\n            setName( model.getName() );\n            setUrl( model.getUrl() );\n            setPackaging( model.getPackaging() );\n\n            Build build = new Build();\n            build.setFinalName( getArtifactId() + \"-\" + getVersion() );\n            build.setDirectory( getBasedir() + \"/target/test/unit/project-001/target\" );\n            setBuild( build );\n\n            String basedir = getBasedir().getAbsolutePath();\n            List compileSourceRoots = new ArrayList();\n            compileSourceRoots.add( basedir + \"/target/test-classes/unit/project-001/src/main/java\" );\n            setCompileSourceRoots( compileSourceRoots );\n\n            List testCompileSourceRoots = new ArrayList();\n            testCompileSourceRoots.add( basedir + \"/target/test-classes/unit/project-001/src/test/java\" );\n            setTestCompileSourceRoots( testCompileSourceRoots );\n\n            setResources( model.getBuild()\n                               .getResources() );\n            setTestResources( model.getBuild()\n                                   .getTestResources() );\n\n            SourcePluginArtifactStub artifact =\n                new SourcePluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging(), null );\n            artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n            artifact.setType( \"jar\" );\n            artifact.setBaseVersion( \"1.0-SNAPSHOT\" );\n            setArtifact( artifact );\n\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","commit_id":"fe98ee51af357eb14fae6d7d5fbf34424d2d4851","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Project003Stub()\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model;\n\n        try\n        {\n            model = pomReader.read(\n                ReaderFactory.newXmlReader( new File( getBasedir(), \"target/test-classes/unit/project-003/pom.xml\" ) ) );\n            setModel( model );\n\n            setGroupId( model.getGroupId() );\n            setArtifactId( model.getArtifactId() );\n            setVersion( model.getVersion() );\n            setName( model.getName() );\n            setUrl( model.getUrl() );\n            setPackaging( model.getPackaging() );\n\n            Build build = new Build();\n            build.setFinalName( getArtifactId() + \"-\" + getVersion() );\n            build.setDirectory( getBasedir() + \"/target/test/unit/project-003/target\" );\n            setBuild( build );\n\n            String basedir = getBasedir().getAbsolutePath();\n            List compileSourceRoots = new ArrayList();\n            compileSourceRoots.add( basedir + \"/target/test-classes/unit/project-003/src/main/java\" );\n            setCompileSourceRoots( compileSourceRoots );\n\n            List testCompileSourceRoots = new ArrayList();\n            testCompileSourceRoots.add( basedir + \"/target/test-classes/unit/project-003/src/test/java\" );\n            setTestCompileSourceRoots( testCompileSourceRoots );\n\n            setResources( model.getBuild().getResources() );\n            setTestResources( model.getBuild().getTestResources() );\n\n            SourcePluginArtifactStub artifact =\n                new SourcePluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging(), null );\n            artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n            artifact.setType( \"jar\" );\n            artifact.setBaseVersion( \"1.0-SNAPSHOT\" );\n            setArtifact( artifact );\n\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","id":93839,"modified_method":"public Project003Stub()\n    {\n        Model model;\n\n        try\n        {\n            model = readModelFromFile( new File( getBasedir(), \"target/test-classes/unit/project-003/pom.xml\" ) );\n            setModel( model );\n\n            setGroupId( model.getGroupId() );\n            setArtifactId( model.getArtifactId() );\n            setVersion( model.getVersion() );\n            setName( model.getName() );\n            setUrl( model.getUrl() );\n            setPackaging( model.getPackaging() );\n\n            Build build = new Build();\n            build.setFinalName( getArtifactId() + \"-\" + getVersion() );\n            build.setDirectory( getBasedir() + \"/target/test/unit/project-003/target\" );\n            setBuild( build );\n\n            String basedir = getBasedir().getAbsolutePath();\n            List compileSourceRoots = new ArrayList();\n            compileSourceRoots.add( basedir + \"/target/test-classes/unit/project-003/src/main/java\" );\n            setCompileSourceRoots( compileSourceRoots );\n\n            List testCompileSourceRoots = new ArrayList();\n            testCompileSourceRoots.add( basedir + \"/target/test-classes/unit/project-003/src/test/java\" );\n            setTestCompileSourceRoots( testCompileSourceRoots );\n\n            setResources( model.getBuild().getResources() );\n            setTestResources( model.getBuild().getTestResources() );\n\n            SourcePluginArtifactStub artifact =\n                new SourcePluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging(), null );\n            artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n            artifact.setType( \"jar\" );\n            artifact.setBaseVersion( \"1.0-SNAPSHOT\" );\n            setArtifact( artifact );\n\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","commit_id":"fe98ee51af357eb14fae6d7d5fbf34424d2d4851","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Project005Stub()\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model;\n\n        try\n        {\n            model = pomReader.read(\n                ReaderFactory.newXmlReader( new File( getBasedir(), \"target/test-classes/unit/project-005/pom.xml\" ) ) );\n            setModel( model );\n\n            setGroupId( model.getGroupId() );\n            setArtifactId( model.getArtifactId() );\n            setVersion( model.getVersion() );\n            setName( model.getName() );\n            setUrl( model.getUrl() );\n            setPackaging( model.getPackaging() );\n\n            Build build = new Build();\n            build.setFinalName( getArtifactId() + \"-\" + getVersion() );\n            build.setDirectory( getBasedir() + \"/target/test/unit/project-005/target\" );\n            setBuild( build );\n\n            SourcePluginArtifactStub artifact =\n                new SourcePluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging(), null );\n            artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n            artifact.setType( \"jar\" );\n            artifact.setBaseVersion( \"1.0-SNAPSHOT\" );\n            setArtifact( artifact );\n\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","id":93840,"modified_method":"public Project005Stub()\n    {\n        Model model;\n        try\n        {\n            model = readModelFromFile( new File( getBasedir(), \"target/test-classes/unit/project-005/pom.xml\" ) );\n            setModel( model );\n\n            setGroupId( model.getGroupId() );\n            setArtifactId( model.getArtifactId() );\n            setVersion( model.getVersion() );\n            setName( model.getName() );\n            setUrl( model.getUrl() );\n            setPackaging( model.getPackaging() );\n\n            Build build = new Build();\n            build.setFinalName( getArtifactId() + \"-\" + getVersion() );\n            build.setDirectory( getBasedir() + \"/target/test/unit/project-005/target\" );\n            setBuild( build );\n\n            SourcePluginArtifactStub artifact =\n                new SourcePluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging(), null );\n            artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n            artifact.setType( \"jar\" );\n            artifact.setBaseVersion( \"1.0-SNAPSHOT\" );\n            setArtifact( artifact );\n\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","commit_id":"fe98ee51af357eb14fae6d7d5fbf34424d2d4851","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Project007Stub()\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model;\n\n        try\n        {\n            model = pomReader.read(\n                ReaderFactory.newXmlReader( new File( getBasedir(), \"target/test-classes/unit/project-007/pom.xml\" ) ) );\n            setModel( model );\n\n            setGroupId( model.getGroupId() );\n            setArtifactId( model.getArtifactId() );\n            setVersion( model.getVersion() );\n            setName( model.getName() );\n            setUrl( model.getUrl() );\n            setPackaging( model.getPackaging() );\n\n            Build build = new Build();\n            build.setFinalName( getArtifactId() + \"-\" + getVersion() );\n            build.setDirectory( getBasedir() + \"/target/test/unit/project-007/target\" );\n            setBuild( build );\n\n            String basedir = getBasedir().getAbsolutePath();\n            List compileSourceRoots = new ArrayList();\n            compileSourceRoots.add( basedir + \"/target/test-classes/unit/project-007/src/main/java\" );\n            setCompileSourceRoots( compileSourceRoots );\n\n            List testCompileSourceRoots = new ArrayList();\n            testCompileSourceRoots.add( basedir + \"/target/test-classes/unit/project-007/src/test/java\" );\n            setTestCompileSourceRoots( testCompileSourceRoots );\n\n            setResources( model.getBuild().getResources() );\n            setTestResources( model.getBuild().getTestResources() );\n\n            SourcePluginArtifactStub artifact =\n                new SourcePluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging(), null );\n            artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n            artifact.setType( \"jar\" );\n            artifact.setBaseVersion( \"1.0-SNAPSHOT\" );\n            setArtifact( artifact );\n\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","id":93841,"modified_method":"public Project007Stub()\n    {\n        Model model;\n        try\n        {\n            model = readModelFromFile( new File( getBasedir(), \"target/test-classes/unit/project-007/pom.xml\" ) );\n            setModel( model );\n\n            setGroupId( model.getGroupId() );\n            setArtifactId( model.getArtifactId() );\n            setVersion( model.getVersion() );\n            setName( model.getName() );\n            setUrl( model.getUrl() );\n            setPackaging( model.getPackaging() );\n\n            Build build = new Build();\n            build.setFinalName( getArtifactId() + \"-\" + getVersion() );\n            build.setDirectory( getBasedir() + \"/target/test/unit/project-007/target\" );\n            setBuild( build );\n\n            String basedir = getBasedir().getAbsolutePath();\n            List compileSourceRoots = new ArrayList();\n            compileSourceRoots.add( basedir + \"/target/test-classes/unit/project-007/src/main/java\" );\n            setCompileSourceRoots( compileSourceRoots );\n\n            List testCompileSourceRoots = new ArrayList();\n            testCompileSourceRoots.add( basedir + \"/target/test-classes/unit/project-007/src/test/java\" );\n            setTestCompileSourceRoots( testCompileSourceRoots );\n\n            setResources( model.getBuild().getResources() );\n            setTestResources( model.getBuild().getTestResources() );\n\n            SourcePluginArtifactStub artifact =\n                new SourcePluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging(), null );\n            artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n            artifact.setType( \"jar\" );\n            artifact.setBaseVersion( \"1.0-SNAPSHOT\" );\n            setArtifact( artifact );\n\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","commit_id":"fe98ee51af357eb14fae6d7d5fbf34424d2d4851","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Project009Stub()\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model;\n\n        try\n        {\n            final File pomFile = new File( getBasedir(), \"target/test-classes/unit/project-009/pom.xml\" );\n            model = pomReader.read( ReaderFactory.newXmlReader( pomFile ) );\n            setModel( model );\n            setFile( pomFile );\n\n            setGroupId( model.getGroupId() );\n            setArtifactId( model.getArtifactId() );\n            setVersion( model.getVersion() );\n            setName( model.getName() );\n            setUrl( model.getUrl() );\n            setPackaging( model.getPackaging() );\n\n            Build build = new Build();\n            build.setFinalName( getArtifactId() + \"-\" + getVersion() );\n            build.setDirectory( getBasedir() + \"/target/test/unit/project-009/target\" );\n            setBuild( build );\n\n            String basedir = getBasedir().getAbsolutePath();\n            List compileSourceRoots = new ArrayList();\n            compileSourceRoots.add( basedir + \"/target/test-classes/unit/project-009/src/main/java\" );\n            setCompileSourceRoots( compileSourceRoots );\n\n            List testCompileSourceRoots = new ArrayList();\n            testCompileSourceRoots.add( basedir + \"/target/test-classes/unit/project-009/src/test/java\" );\n            setTestCompileSourceRoots( testCompileSourceRoots );\n\n            setResources( model.getBuild().getResources() );\n            setTestResources( model.getBuild().getTestResources() );\n\n            SourcePluginArtifactStub artifact =\n                new SourcePluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging(), null );\n            artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n            artifact.setType( \"jar\" );\n            artifact.setBaseVersion( \"1.0-SNAPSHOT\" );\n            setArtifact( artifact );\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","id":93842,"modified_method":"public Project009Stub()\n    {\n        Model model;\n\n        try\n        {\n            final File pomFile = new File( getBasedir(), \"target/test-classes/unit/project-009/pom.xml\" );\n            model = readModelFromFile( pomFile );\n            setModel( model );\n            setFile( pomFile );\n\n            setGroupId( model.getGroupId() );\n            setArtifactId( model.getArtifactId() );\n            setVersion( model.getVersion() );\n            setName( model.getName() );\n            setUrl( model.getUrl() );\n            setPackaging( model.getPackaging() );\n\n            Build build = new Build();\n            build.setFinalName( getArtifactId() + \"-\" + getVersion() );\n            build.setDirectory( getBasedir() + \"/target/test/unit/project-009/target\" );\n            setBuild( build );\n\n            String basedir = getBasedir().getAbsolutePath();\n            List compileSourceRoots = new ArrayList();\n            compileSourceRoots.add( basedir + \"/target/test-classes/unit/project-009/src/main/java\" );\n            setCompileSourceRoots( compileSourceRoots );\n\n            List testCompileSourceRoots = new ArrayList();\n            testCompileSourceRoots.add( basedir + \"/target/test-classes/unit/project-009/src/test/java\" );\n            setTestCompileSourceRoots( testCompileSourceRoots );\n\n            setResources( model.getBuild().getResources() );\n            setTestResources( model.getBuild().getTestResources() );\n\n            SourcePluginArtifactStub artifact =\n                new SourcePluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging(), null );\n            artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n            artifact.setType( \"jar\" );\n            artifact.setBaseVersion( \"1.0-SNAPSHOT\" );\n            setArtifact( artifact );\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","commit_id":"fe98ee51af357eb14fae6d7d5fbf34424d2d4851","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Project010Stub()\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model;\n\n        try\n        {\n            model = pomReader.read(\n                ReaderFactory.newXmlReader( new File( getBasedir(), \"target/test-classes/unit/project-010/pom.xml\" ) ) );\n            setModel( model );\n\n            setFile(new File( getBasedir(), \"target/test-classes/unit/project-010/pom.xml\" ));\n\n            setGroupId(model.getGroupId());\n            setArtifactId(model.getArtifactId());\n            setVersion(model.getVersion());\n            setName(model.getName());\n            setUrl(model.getUrl());\n            setPackaging(model.getPackaging());\n\n            Build build = new Build();\n            build.setFinalName( getArtifactId() + \"-\" + getVersion() );\n            build.setDirectory(getBasedir() + \"/target/test/unit/project-010/target\");\n\n            setBuild(build);\n\n            String basedir = getBasedir().getAbsolutePath();\n            List compileSourceRoots = new ArrayList();\n            compileSourceRoots.add( basedir + \"/target/test-classes/unit/project-010/src/main/java\" );\n            setCompileSourceRoots(compileSourceRoots);\n\n            List testCompileSourceRoots = new ArrayList();\n            testCompileSourceRoots.add(basedir + \"/target/test-classes/unit/project-010/src/test/java\");\n            setTestCompileSourceRoots(testCompileSourceRoots);\n\n            setResources(model.getBuild().getResources());\n            setTestResources(model.getBuild().getTestResources());\n\n            SourcePluginArtifactStub artifact =\n                new SourcePluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging(), null );\n            artifact.setArtifactHandler(new DefaultArtifactHandlerStub());\n            artifact.setType(\"jar\");\n            artifact.setBaseVersion(\"1.0-SNAPSHOT\");\n            setArtifact( artifact );\n\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","id":93843,"modified_method":"public Project010Stub()\n    {\n        Model model;\n\n        try\n        {\n            model = readModelFromFile( new File( getBasedir(), \"target/test-classes/unit/project-010/pom.xml\" ) );\n            setModel( model );\n\n            setFile(new File( getBasedir(), \"target/test-classes/unit/project-010/pom.xml\" ));\n\n            setGroupId(model.getGroupId());\n            setArtifactId(model.getArtifactId());\n            setVersion(model.getVersion());\n            setName(model.getName());\n            setUrl(model.getUrl());\n            setPackaging(model.getPackaging());\n\n            Build build = new Build();\n            build.setFinalName( getArtifactId() + \"-\" + getVersion() );\n            build.setDirectory(getBasedir() + \"/target/test/unit/project-010/target\");\n\n            setBuild(build);\n\n            String basedir = getBasedir().getAbsolutePath();\n            List compileSourceRoots = new ArrayList();\n            compileSourceRoots.add( basedir + \"/target/test-classes/unit/project-010/src/main/java\" );\n            setCompileSourceRoots(compileSourceRoots);\n\n            List testCompileSourceRoots = new ArrayList();\n            testCompileSourceRoots.add(basedir + \"/target/test-classes/unit/project-010/src/test/java\");\n            setTestCompileSourceRoots(testCompileSourceRoots);\n\n            setResources(model.getBuild().getResources());\n            setTestResources(model.getBuild().getTestResources());\n\n            SourcePluginArtifactStub artifact =\n                new SourcePluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging(), null );\n            artifact.setArtifactHandler(new DefaultArtifactHandlerStub());\n            artifact.setType(\"jar\");\n            artifact.setBaseVersion(\"1.0-SNAPSHOT\");\n            setArtifact( artifact );\n\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n        }\n    }","commit_id":"fe98ee51af357eb14fae6d7d5fbf34424d2d4851","url":"https://github.com/apache/maven-plugins"},{"original_method":"public SiteMavenProjectStub( String pomFilePath )\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model;\n\n        try\n        {\n            File pomFile =\n                new File( getBasedir(), pomFilePath == null ? \"/src/test/resources/unit/interpolated-site/pom.xml\"\n                                : pomFilePath );\n            model = pomReader.read( ReaderFactory.newXmlReader( pomFile ) );\n            setModel( model );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( e );\n        }\n        Site site = new Site();\n        site.setId( \"localhost\" );\n        distributionManagement.setSite( site );\n    }","id":93844,"modified_method":"public SiteMavenProjectStub( String pomFilePath )\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model;\n\n        XmlStreamReader reader = null;\n        try\n        {\n            File pomFile =\n                new File( getBasedir(), pomFilePath == null ? \"/src/test/resources/unit/interpolated-site/pom.xml\"\n                                : pomFilePath );\n            reader = ReaderFactory.newXmlReader( pomFile );\n            model = pomReader.read( reader );\n            setModel( model );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( e );\n        }\n        finally\n        {\n            IOUtil.close( reader);\n        }\n        Site site = new Site();\n        site.setId( \"localhost\" );\n        distributionManagement.setSite( site );\n    }","commit_id":"fe98ee51af357eb14fae6d7d5fbf34424d2d4851","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Will be started when a suspect is added to the suspects hashtable. Continually iterates over the\n     * entries and removes entries whose time have elapsed. For each removed entry, a SUSPECT event is passed\n     * up the stack (because elapsed time means verification of member's liveness failed). Computes the shortest\n     * time to wait (min of all timeouts) and waits(time) msecs. Will be woken up when entry is removed (in case\n     * of successful verification of that member's liveness). Terminates when no entry remains in the hashtable.\n     */\n    public void run() {\n        Address mbr;\n        long val, curr_time, diff;\n\n        while(timer != null && Thread.currentThread().equals(timer) && !suspects.isEmpty()) {\n            diff=0;\n\n            List<Address> tmp=null;\n            synchronized(suspects) {\n                for(Enumeration e=suspects.keys(); e.hasMoreElements();) {\n                    mbr=(Address)e.nextElement();\n                    val=suspects.get(mbr).longValue();\n                    curr_time=System.currentTimeMillis();\n                    diff=curr_time - val;\n                    if(diff >= timeout) {  // haven't been unsuspected, pass up SUSPECT\n                        if(log.isTraceEnabled())\n                            log.trace(\"diff=\" + diff + \", mbr \" + mbr + \" is dead (passing up SUSPECT event)\");\n                        if(tmp == null) tmp=new LinkedList<Address>();\n                        tmp.add(mbr);\n                        suspects.remove(mbr);\n                        continue;\n                    }\n                    diff=Math.max(diff, timeout - diff);\n                }\n            }\n            if(tmp != null && !tmp.isEmpty()) {\n                for(Iterator it=tmp.iterator(); it.hasNext();)\n                    up_prot.up(new Event(Event.SUSPECT, it.next()));\n            }\n\n            if(diff > 0)\n                Util.sleep(diff);\n        }\n        timer=null;\n    }","id":93845,"modified_method":"/**\n     * Will be started when a suspect is added to the suspects hashtable. Continually iterates over the\n     * entries and removes entries whose time have elapsed. For each removed entry, a SUSPECT event is passed\n     * up the stack (because elapsed time means verification of member's liveness failed). Computes the shortest\n     * time to wait (min of all timeouts) and waits(time) msecs. Will be woken up when entry is removed (in case\n     * of successful verification of that member's liveness). Terminates when no entry remains in the hashtable.\n     */\n    public void run() {       \n        long val, diff;\n\n        while(timer != null && Thread.currentThread().equals(timer) && !suspects.isEmpty()) {\n            diff=0;\n\n            List<Address> confirmed_suspects=new LinkedList<Address>();\n            synchronized(suspects) {\n                for(Enumeration<Address> e=suspects.keys(); e.hasMoreElements();) {\n                    Address mbr=e.nextElement();\n                    val=suspects.get(mbr).longValue();                    \n                    diff=System.currentTimeMillis() - val;\n                    if(diff >= timeout) {  // haven't been unsuspected, pass up SUSPECT\n                        if(log.isTraceEnabled())\n                            log.trace(\"diff=\" + diff + \", mbr \" + mbr + \" is dead (passing up SUSPECT event)\");                      \n                        \n                        confirmed_suspects.add(mbr);\n                        suspects.remove(mbr);\n                        continue;\n                    }\n                    diff=Math.max(diff, timeout - diff);\n                }\n            }\n            \n            for(Address suspect:confirmed_suspects)\n                up_prot.up(new Event(Event.SUSPECT,suspect));            \n\n            if(diff > 0)\n                Util.sleep(diff);\n        }\n        timer=null;\n    }","commit_id":"c671e9f59fa53a477c233103edc1824d6bbc3ad0","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Sends ARE_YOU_DEAD message to suspected_mbr, wait for return or timeout\n     */\n    void verifySuspect(Address mbr) {\n        Message msg;\n        if(mbr == null) return;\n\n        synchronized(suspects) {\n            if(suspects.containsKey(mbr))\n                return;\n            suspects.put(mbr, new Long(System.currentTimeMillis()));\n        }\n        // moved out of synchronized statement (bela): http://jira.jboss.com/jira/browse/JGRP-302\n        if(log.isTraceEnabled()) log.trace(\"verifying that \" + mbr + \" is dead\");\n        for(int i=0; i < num_msgs; i++) {\n            msg=new Message(mbr, null, null);\n            msg.setFlag(Message.OOB);\n            msg.putHeader(name, new VerifyHeader(VerifyHeader.ARE_YOU_DEAD, local_addr));\n            down_prot.down(new Event(Event.MSG, msg));\n        }\n        if(timer == null)\n            startTimer();\n    }","id":93846,"modified_method":"/**\n     * Sends ARE_YOU_DEAD message to suspected_mbr, wait for return or timeout\n     */\n    void verifySuspect(Address mbr) {\n        Message msg;\n        if(mbr == null) return;\n\n        synchronized(suspects) {\n            if(suspects.containsKey(mbr))\n                return;\n            suspects.put(mbr, new Long(System.currentTimeMillis()));\n        }\n        \n        //start timer before we send out are you dead messages\n        startTimer();\n        \n        // moved out of synchronized statement (bela): http://jira.jboss.com/jira/browse/JGRP-302\n        if(log.isTraceEnabled()) log.trace(\"verifying that \" + mbr + \" is dead\");\n        \n        for(int i=0; i < num_msgs; i++) {\n            msg=new Message(mbr, null, null);\n            msg.setFlag(Message.OOB);\n            msg.putHeader(name, new VerifyHeader(VerifyHeader.ARE_YOU_DEAD, local_addr));\n            down_prot.down(new Event(Event.MSG, msg));\n        }               \n    }","commit_id":"c671e9f59fa53a477c233103edc1824d6bbc3ad0","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Sends ARE_YOU_DEAD message to suspected_mbr, wait for return or timeout\n     */\n    void verifySuspect(Address mbr) {\n        Message msg;\n        if(mbr == null) return;\n\n        synchronized(suspects) {\n            if(suspects.containsKey(mbr))\n                return;\n            suspects.put(mbr, new Long(System.currentTimeMillis()));\n        }\n        // moved out of synchronized statement (bela): http://jira.jboss.com/jira/browse/JGRP-302\n        if(log.isTraceEnabled()) log.trace(\"verifying that \" + mbr + \" is dead\");\n        for(int i=0; i < num_msgs; i++) {\n            msg=new Message(mbr, null, null);\n            msg.setFlag(Message.OOB);\n            msg.putHeader(name, new VerifyHeader(VerifyHeader.ARE_YOU_DEAD, local_addr));\n            down_prot.down(new Event(Event.MSG, msg));\n        }\n        if(timer == null)\n            startTimer();\n    }","id":93847,"modified_method":"/**\n     * Sends ARE_YOU_DEAD message to suspected_mbr, wait for return or timeout\n     */\n    void verifySuspect(Address mbr) {\n        Message msg;\n        if(mbr == null) return;\n\n        synchronized(suspects) {\n            if(suspects.containsKey(mbr))\n                return;\n            suspects.put(mbr, new Long(System.currentTimeMillis()));\n        }\n        \n        //start timer before we send out are you dead messages\n        startTimer();\n        \n        // moved out of synchronized statement (bela): http://jira.jboss.com/jira/browse/JGRP-302\n        if(log.isTraceEnabled()) log.trace(\"verifying that \" + mbr + \" is dead\");\n        \n        for(int i=0; i < num_msgs; i++) {\n            msg=new Message(mbr, null, null);\n            msg.setFlag(Message.OOB);\n            msg.putHeader(name, new VerifyHeader(VerifyHeader.ARE_YOU_DEAD, local_addr));\n            down_prot.down(new Event(Event.MSG, msg));\n        }               \n    }","commit_id":"66725ab0a870d478fabc72356056fdf0f7defb83","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Will be started when a suspect is added to the suspects hashtable. Continually iterates over the\n     * entries and removes entries whose time have elapsed. For each removed entry, a SUSPECT event is passed\n     * up the stack (because elapsed time means verification of member's liveness failed). Computes the shortest\n     * time to wait (min of all timeouts) and waits(time) msecs. Will be woken up when entry is removed (in case\n     * of successful verification of that member's liveness). Terminates when no entry remains in the hashtable.\n     */\n    public void run() {\n        Address mbr;\n        long val, curr_time, diff;\n\n        while(timer != null && Thread.currentThread().equals(timer) && !suspects.isEmpty()) {\n            diff=0;\n\n            List<Address> tmp=null;\n            synchronized(suspects) {\n                for(Enumeration e=suspects.keys(); e.hasMoreElements();) {\n                    mbr=(Address)e.nextElement();\n                    val=suspects.get(mbr).longValue();\n                    curr_time=System.currentTimeMillis();\n                    diff=curr_time - val;\n                    if(diff >= timeout) {  // haven't been unsuspected, pass up SUSPECT\n                        if(log.isTraceEnabled())\n                            log.trace(\"diff=\" + diff + \", mbr \" + mbr + \" is dead (passing up SUSPECT event)\");\n                        if(tmp == null) tmp=new LinkedList<Address>();\n                        tmp.add(mbr);\n                        suspects.remove(mbr);\n                        continue;\n                    }\n                    diff=Math.max(diff, timeout - diff);\n                }\n            }\n            if(tmp != null && !tmp.isEmpty()) {\n                for(Iterator it=tmp.iterator(); it.hasNext();)\n                    up_prot.up(new Event(Event.SUSPECT, it.next()));\n            }\n\n            if(diff > 0)\n                Util.sleep(diff);\n        }\n        timer=null;\n    }","id":93848,"modified_method":"/**\n     * Will be started when a suspect is added to the suspects hashtable. Continually iterates over the\n     * entries and removes entries whose time have elapsed. For each removed entry, a SUSPECT event is passed\n     * up the stack (because elapsed time means verification of member's liveness failed). Computes the shortest\n     * time to wait (min of all timeouts) and waits(time) msecs. Will be woken up when entry is removed (in case\n     * of successful verification of that member's liveness). Terminates when no entry remains in the hashtable.\n     */\n    public void run() {       \n        long val, diff;\n\n        while(timer != null && Thread.currentThread().equals(timer) && !suspects.isEmpty()) {\n            diff=0;\n\n            List<Address> confirmed_suspects=new LinkedList<Address>();\n            synchronized(suspects) {\n                for(Enumeration<Address> e=suspects.keys(); e.hasMoreElements();) {\n                    Address mbr=e.nextElement();\n                    val=suspects.get(mbr).longValue();                    \n                    diff=System.currentTimeMillis() - val;\n                    if(diff >= timeout) {  // haven't been unsuspected, pass up SUSPECT\n                        if(log.isTraceEnabled())\n                            log.trace(\"diff=\" + diff + \", mbr \" + mbr + \" is dead (passing up SUSPECT event)\");                      \n                        \n                        confirmed_suspects.add(mbr);\n                        suspects.remove(mbr);\n                        continue;\n                    }\n                    diff=Math.max(diff, timeout - diff);\n                }\n            }\n            \n            for(Address suspect:confirmed_suspects)\n                up_prot.up(new Event(Event.SUSPECT,suspect));            \n\n            if(diff > 0)\n                Util.sleep(diff);\n        }\n        timer=null;\n    }","commit_id":"66725ab0a870d478fabc72356056fdf0f7defb83","url":"https://github.com/belaban/JGroups"},{"original_method":"public void initServlet(final Resource resource) {\n        // the resource and the request path info, will never be null\n        RequestPathInfo requestPathInfo = new SlingRequestPathInfo(resource);\n        ContentData contentData = pushContent(resource, requestPathInfo);\n\n\t    requestProgressTracker.log(\"Resource Path Info: {0}\", requestPathInfo);\n\n        // finally resolve the servlet for the resource\n        ServletResolver sr = slingRequestProcessor.getServletResolver();\n        if (sr != null) {\n            requestProgressTracker.startTimer(\"ServletResolution\");\n            Servlet servlet = sr.resolveServlet(slingRequest);\n            requestProgressTracker.logTimer(\"ServletResolution\",\n                \"URI={0} handled by Servlet={1}\",\n                getServletRequest().getRequestURI(), RequestUtil.getServletName(servlet));\n            contentData.setServlet(servlet);\n        } else {\n            log.warn(\"init(): No ServletResolver available\");\n        }\n    }","id":93849,"modified_method":"public void initServlet(final Resource resource,\n            final ServletResolver sr) {\n        // the resource and the request path info, will never be null\n        RequestPathInfo requestPathInfo = new SlingRequestPathInfo(resource);\n        ContentData contentData = pushContent(resource, requestPathInfo);\n\n\t    requestProgressTracker.log(\"Resource Path Info: {0}\", requestPathInfo);\n\n        // finally resolve the servlet for the resource\n        requestProgressTracker.startTimer(\"ServletResolution\");\n        Servlet servlet = sr.resolveServlet(slingRequest);\n        requestProgressTracker.logTimer(\"ServletResolution\",\n            \"URI={0} handled by Servlet={1}\",\n            getServletRequest().getRequestURI(), RequestUtil.getServletName(servlet));\n        contentData.setServlet(servlet);\n    }","commit_id":"a1cb0ebddc6dbace59c84b392b28f541e8b075b4","url":"https://github.com/apache/sling"},{"original_method":"public void processRequest(final HttpServletRequest servletRequest,\n            final HttpServletResponse servletResponse,\n            final ResourceResolver resourceResolver) throws IOException {\n\n        // setting the Sling request and response\n        final RequestData requestData = new RequestData(this, servletRequest,\n            servletResponse);\n        final SlingHttpServletRequest request = requestData.getSlingRequest();\n        final SlingHttpServletResponse response = requestData.getSlingResponse();\n\n        // record the request for the web console display\n        RequestHistoryConsolePlugin.recordRequest(request);\n\n        // request entry log\n        if (requestLogger != null) {\n            requestLogger.logRequestEntry(request, response);\n        }\n\n        try {\n            // check that we have all required services\n            if (resourceResolver == null) {\n                throw new UnavailableException(\"ResourceResolver\");\n            } else if (servletResolver == null) {\n                throw new UnavailableException(\"ServletResolver\");\n            }\n\n            // initialize the request data - resolve resource and servlet\n            Resource resource = requestData.initResource(resourceResolver);\n            requestData.initServlet(resource);\n\n            Filter[] filters = filterManager.getFilters(FilterChainType.REQUEST);\n            if (filters != null) {\n                FilterChain processor = new RequestSlingFilterChain(this,\n                    filters);\n\n                request.getRequestProgressTracker().log(\n                    \"Applying \" + FilterChainType.REQUEST + \"filters\");\n\n                processor.doFilter(request, response);\n\n            } else {\n\n                // no filters, directly call resource level filters and servlet\n                processComponent(request, response, FilterChainType.COMPONENT);\n\n            }\n\n        } catch (ResourceNotFoundException rnfe) {\n\n            // send this exception as a 404 status\n            log.info(\"service: Resource {} not found\", rnfe.getResource());\n\n            handleError(HttpServletResponse.SC_NOT_FOUND, rnfe.getMessage(),\n                request, response);\n\n        } catch (SlingException se) {\n\n            // if we have request data and a non-null active servlet name\n            // we assume, that this is the name of the causing servlet\n            if (requestData.getActiveServletName() != null) {\n                request.setAttribute(ERROR_SERVLET_NAME,\n                    requestData.getActiveServletName());\n            }\n\n            // send this exception as is (albeit unwrapping and wrapped\n            // exception.\n            Throwable t = (se.getCause() != null) ? se.getCause() : se;\n            log.error(\"service: Uncaught SlingException\", t);\n            handleError(t, request, response);\n\n        } catch (AccessControlException ace) {\n\n            // SLING-319 if anything goes wrong, send 403/FORBIDDEN\n            log.info(\n                \"service: Authenticated user {} does not have enough rights to executed requested action\",\n                request.getRemoteUser());\n            handleError(HttpServletResponse.SC_FORBIDDEN, null, request,\n                response);\n\n        } catch (UnavailableException ue) {\n\n            // exception is thrown before the SlingHttpServletRequest/Response\n            // is properly set up due to missing dependencies. In this case\n            // we must not use the Sling error handling infrastructure but\n            // just return a 503 status response handled by the servlet\n            // container environment\n\n            final int status = HttpServletResponse.SC_SERVICE_UNAVAILABLE;\n            final String errorMessage = ue.getMessage()\n                + \" service missing, cannot service requests\";\n            log.error(\"{} , sending status {}\", errorMessage, status);\n            servletResponse.sendError(status, errorMessage);\n\n        } catch (IOException ioe) {\n\n            // forward IOException up the call chain to properly handle it\n            throw ioe;\n\n        } catch (Throwable t) {\n\n            // if we have request data and a non-null active servlet name\n            // we assume, that this is the name of the causing servlet\n            if (requestData.getActiveServletName() != null) {\n                request.setAttribute(ERROR_SERVLET_NAME,\n                    requestData.getActiveServletName());\n            }\n\n            log.error(\"service: Uncaught Throwable\", t);\n            handleError(t, request, response);\n\n        } finally {\n\n            // request exit log\n            if (requestLogger != null) {\n                requestLogger.logRequestExit(request, response);\n            }\n\n            // dispose any request data\n            requestData.dispose();\n        }\n    }","id":93850,"modified_method":"public void processRequest(final HttpServletRequest servletRequest,\n            final HttpServletResponse servletResponse,\n            final ResourceResolver resourceResolver) throws IOException {\n\n        // setting the Sling request and response\n        final RequestData requestData = new RequestData(this, servletRequest,\n            servletResponse);\n        final SlingHttpServletRequest request = requestData.getSlingRequest();\n        final SlingHttpServletResponse response = requestData.getSlingResponse();\n\n        // record the request for the web console display\n        RequestHistoryConsolePlugin.recordRequest(request);\n\n        // request entry log\n        if (requestLogger != null) {\n            requestLogger.logRequestEntry(request, response);\n        }\n\n        try {\n            final ServletResolver sr = this.servletResolver;\n\n            // check that we have all required services\n            if (resourceResolver == null) {\n                throw new UnavailableException(\"ResourceResolver\");\n            } else if (sr == null) {\n                throw new UnavailableException(\"ServletResolver\");\n            }\n\n            // initialize the request data - resolve resource and servlet\n            Resource resource = requestData.initResource(resourceResolver);\n            requestData.initServlet(resource, sr);\n\n            Filter[] filters = filterManager.getFilters(FilterChainType.REQUEST);\n            if (filters != null) {\n                FilterChain processor = new RequestSlingFilterChain(this,\n                    filters);\n\n                request.getRequestProgressTracker().log(\n                    \"Applying \" + FilterChainType.REQUEST + \"filters\");\n\n                processor.doFilter(request, response);\n\n            } else {\n\n                // no filters, directly call resource level filters and servlet\n                processComponent(request, response, FilterChainType.COMPONENT);\n\n            }\n\n        } catch (ResourceNotFoundException rnfe) {\n\n            // send this exception as a 404 status\n            log.info(\"service: Resource {} not found\", rnfe.getResource());\n\n            handleError(HttpServletResponse.SC_NOT_FOUND, rnfe.getMessage(),\n                request, response);\n\n        } catch (SlingException se) {\n\n            // if we have request data and a non-null active servlet name\n            // we assume, that this is the name of the causing servlet\n            if (requestData.getActiveServletName() != null) {\n                request.setAttribute(ERROR_SERVLET_NAME,\n                    requestData.getActiveServletName());\n            }\n\n            // send this exception as is (albeit unwrapping and wrapped\n            // exception.\n            Throwable t = (se.getCause() != null) ? se.getCause() : se;\n            log.error(\"service: Uncaught SlingException\", t);\n            handleError(t, request, response);\n\n        } catch (AccessControlException ace) {\n\n            // SLING-319 if anything goes wrong, send 403/FORBIDDEN\n            log.info(\n                \"service: Authenticated user {} does not have enough rights to executed requested action\",\n                request.getRemoteUser());\n            handleError(HttpServletResponse.SC_FORBIDDEN, null, request,\n                response);\n\n        } catch (UnavailableException ue) {\n\n            // exception is thrown before the SlingHttpServletRequest/Response\n            // is properly set up due to missing dependencies. In this case\n            // we must not use the Sling error handling infrastructure but\n            // just return a 503 status response handled by the servlet\n            // container environment\n\n            final int status = HttpServletResponse.SC_SERVICE_UNAVAILABLE;\n            final String errorMessage = ue.getMessage()\n                + \" service missing, cannot service requests\";\n            log.error(\"{} , sending status {}\", errorMessage, status);\n            servletResponse.sendError(status, errorMessage);\n\n        } catch (IOException ioe) {\n\n            // forward IOException up the call chain to properly handle it\n            throw ioe;\n\n        } catch (Throwable t) {\n\n            // if we have request data and a non-null active servlet name\n            // we assume, that this is the name of the causing servlet\n            if (requestData.getActiveServletName() != null) {\n                request.setAttribute(ERROR_SERVLET_NAME,\n                    requestData.getActiveServletName());\n            }\n\n            log.error(\"service: Uncaught Throwable\", t);\n            handleError(t, request, response);\n\n        } finally {\n\n            // request exit log\n            if (requestLogger != null) {\n                requestLogger.logRequestExit(request, response);\n            }\n\n            // dispose any request data\n            requestData.dispose();\n        }\n    }","commit_id":"a1cb0ebddc6dbace59c84b392b28f541e8b075b4","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testIncomingAction() {\n        String[] pre_1_4_names = ActionNames.ACTION_NAMES.inverse().keySet().toArray(new String[ActionNames.ACTION_NAMES.inverse().keySet().size()]);\n        TransportService transportService = internalCluster().getInstance(TransportService.class);\n        String[] actions = transportService.serverHandlers.keySet().toArray(new String[transportService.serverHandlers.keySet().size()]);\n\n        Version version = randomVersion();\n        int iters = iterations(10, 100);\n        for (int i = 0; i < iters; i++) {\n            boolean customAction = rarely();\n            String action;\n            if (customAction) {\n                action = randomAsciiOfLength(randomInt(30));\n            } else {\n                if (version.before(Version.V_1_4_0_Beta)) {\n                    action = randomFrom(pre_1_4_names);\n                } else {\n                    action = randomFrom(actions);\n                }\n            }\n\n            String incomingAction = ActionNames.incomingAction  (action, version);\n            if (version.onOrAfter(Version.V_1_4_0_Beta) || customAction) {\n                assertThat(incomingAction, equalTo(action));\n            } else {\n                assertThat(incomingAction, not(equalTo(action)));\n                assertThat(incomingAction, equalTo(ActionNames.post_1_4_action(action)));\n            }\n        }\n    }","id":93851,"modified_method":"@Test\n    public void testIncomingAction() {\n        List<String> pre_1_4_names = Lists.newArrayList(ActionNames.ACTION_NAMES.inverse().keySet());\n        TransportService transportService = internalCluster().getInstance(TransportService.class);\n        List<String> actions = Lists.newArrayList(transportService.serverHandlers.keySet());\n\n        Version version = randomVersion();\n        int iters = iterations(10, 100);\n        for (int i = 0; i < iters; i++) {\n            //we rarely use a custom action since plugins might inject their own actions\n            boolean customAction = rarely();\n            String action;\n            if (customAction) {\n                do {\n                    action = randomAsciiOfLength(randomInt(30));\n                } while(pre_1_4_names.contains(action));\n            } else {\n                if (version.before(Version.V_1_4_0_Beta)) {\n                    action = randomFrom(pre_1_4_names);\n                } else {\n                    action = randomFrom(actions);\n                }\n            }\n\n            String incomingAction = ActionNames.incomingAction  (action, version);\n            if (version.onOrAfter(Version.V_1_4_0_Beta) || customAction) {\n                assertThat(incomingAction, equalTo(action));\n            } else {\n                assertThat(incomingAction, not(equalTo(action)));\n                assertThat(incomingAction, equalTo(ActionNames.post_1_4_action(action)));\n            }\n        }\n    }","commit_id":"38f5aa22480d1eb6726257b19783b08569a0e002","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testOutgoingAction() {\n        TransportService transportService = internalCluster().getInstance(TransportService.class);\n        String[] actions = transportService.serverHandlers.keySet().toArray(new String[transportService.serverHandlers.keySet().size()]);\n\n        int iters = iterations(10, 100);\n        for (int i = 0; i < iters; i++) {\n            boolean customAction = rarely();\n            String action;\n            if (customAction) {\n                action = randomAsciiOfLength(randomInt(30));\n            } else {\n                action = randomFrom(actions);\n            }\n\n            Version version = randomVersion();\n            String outgoingAction = ActionNames.outgoingAction(action, version);\n            if (version.onOrAfter(Version.V_1_4_0_Beta) || customAction || post_1_4_actions.contains(action)) {\n                assertThat(outgoingAction, equalTo(action));\n            } else {\n                assertThat(outgoingAction, not(equalTo(action)));\n                assertThat(outgoingAction, equalTo(ActionNames.pre_1_4_Action(action)));\n            }\n        }\n    }","id":93852,"modified_method":"@Test\n    public void testOutgoingAction() {\n        TransportService transportService = internalCluster().getInstance(TransportService.class);\n        List<String> actions = Lists.newArrayList(transportService.serverHandlers.keySet());\n\n        int iters = iterations(10, 100);\n        for (int i = 0; i < iters; i++) {\n            //we rarely use a custom action since plugins might inject their own actions\n            boolean customAction = rarely();\n            String action;\n            if (customAction) {\n                do {\n                    action = randomAsciiOfLength(randomInt(30));\n                } while(actions.contains(action));\n            } else {\n                action = randomFrom(actions);\n            }\n\n            Version version = randomVersion();\n            String outgoingAction = ActionNames.outgoingAction(action, version);\n            if (version.onOrAfter(Version.V_1_4_0_Beta) || customAction || post_1_4_actions.contains(action)) {\n                assertThat(outgoingAction, equalTo(action));\n            } else {\n                assertThat(outgoingAction, not(equalTo(action)));\n                assertThat(outgoingAction, equalTo(ActionNames.pre_1_4_Action(action)));\n            }\n        }\n    }","commit_id":"38f5aa22480d1eb6726257b19783b08569a0e002","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Send a operation response.\n     *\n     * @param context the request context\n     * @param responseType the response type\n     * @param response the operation response\n     * @throws IOException for any error\n     */\n    static void sendResponse(final ManagementRequestContext<RegistrationContext> context, final byte responseType, final ModelNode response) throws IOException {\n        final ManagementResponseHeader header = ManagementResponseHeader.create(context.getRequestHeader());\n        final FlushableDataOutput output = context.writeMessage(header);\n        try {\n            // response type\n            output.writeByte(responseType);\n            // operation result\n            response.writeExternal(output);\n            // response end\n            output.writeByte(ManagementProtocol.RESPONSE_END);\n            output.close();\n        } finally {\n            StreamUtils.safeClose(output);\n        }\n    }","id":93853,"modified_method":"/**\n     * Send a operation response.\n     *\n     * @param context the request context\n     * @param responseType the response type\n     * @param response the operation response\n     * @throws IOException for any error\n     */\n    static void sendResponse(final ManagementRequestContext<RegistrationContext> context, final byte responseType, final ModelNode response) throws IOException {\n        final ManagementResponseHeader header = ManagementResponseHeader.create(context.getRequestHeader());\n        final FlushableDataOutput output = context.writeMessage(header);\n        try {\n            // response type\n            output.writeByte(responseType);\n            if(response != null) {\n                // operation result\n                response.writeExternal(output);\n            }\n            // response end\n            output.writeByte(ManagementProtocol.RESPONSE_END);\n            output.close();\n        } finally {\n            StreamUtils.safeClose(output);\n        }\n    }","commit_id":"569bf4dc6fbe2de8fe04da30256d333cad963694","url":"https://github.com/wildfly/wildfly"},{"original_method":"void sendCompletedMessage(final ModelNode result) {\n            try {\n                sendResponse(responseChannel, DomainControllerProtocol.PARAM_OK, result);\n            } catch (IOException e) {\n                ProtocolLogger.ROOT_LOGGER.debugf(e, \"failed to process message\");\n            }\n        }","id":93854,"modified_method":"void sendCompletedMessage() {\n            try {\n                sendResponse(responseChannel, DomainControllerProtocol.PARAM_OK, null);\n            } catch (IOException e) {\n                ProtocolLogger.ROOT_LOGGER.debugf(e, \"failed to process message\");\n            }\n        }","commit_id":"569bf4dc6fbe2de8fe04da30256d333cad963694","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void handleRequest(final DataInput input, final ActiveOperation.ResultHandler<Void> resultHandler, final ManagementRequestContext<RegistrationContext> context) throws IOException {\n            expectHeader(input, DomainControllerProtocol.PARAM_HOST_ID);\n            final String hostName = input.readUTF();\n            final ModelNode hostInfo = new ModelNode();\n            hostInfo.readExternal(input);\n\n            final RegistrationContext registration = context.getAttachment();\n            registration.initialize(hostName, hostInfo, context);\n            if(domainController.isHostRegistered(hostName)) {\n                registration.failed(SlaveRegistrationException.ErrorCode.HOST_ALREADY_EXISTS, DomainControllerMessages.MESSAGES.slaveAlreadyRegistered(hostName));\n            }\n            // Read the domain model async, this will block until the registration process is complete\n            context.executeAsync(new ManagementRequestContext.AsyncTask<RegistrationContext>() {\n                @Override\n                public void execute(ManagementRequestContext<RegistrationContext> context) throws Exception {\n                    final ModelNode result;\n                    try {\n                        // The domain model is going to be sent as part of the prepared notification\n                        result = controller.execute(READ_DOMAIN_MODEL, OperationMessageHandler.logging, registration, OperationAttachments.EMPTY);\n                    } catch (Exception e) {\n                        registration.failed(SlaveRegistrationException.ErrorCode.UNKNOWN, e.getClass().getName() + \":\" + e.getMessage());\n                        return;\n                    }\n                    // Send a registered notification back\n                    registration.sendCompletedMessage(result);\n                }\n            });\n        }","id":93855,"modified_method":"@Override\n        public void handleRequest(final DataInput input, final ActiveOperation.ResultHandler<Void> resultHandler, final ManagementRequestContext<RegistrationContext> context) throws IOException {\n            expectHeader(input, DomainControllerProtocol.PARAM_HOST_ID);\n            final String hostName = input.readUTF();\n            final ModelNode hostInfo = new ModelNode();\n            hostInfo.readExternal(input);\n\n            final RegistrationContext registration = context.getAttachment();\n            registration.initialize(hostName, hostInfo, context);\n            if(domainController.isHostRegistered(hostName)) {\n                registration.failed(SlaveRegistrationException.ErrorCode.HOST_ALREADY_EXISTS, DomainControllerMessages.MESSAGES.slaveAlreadyRegistered(hostName));\n            }\n            // Read the domain model async, this will block until the registration process is complete\n            context.executeAsync(new ManagementRequestContext.AsyncTask<RegistrationContext>() {\n                @Override\n                public void execute(ManagementRequestContext<RegistrationContext> context) throws Exception {\n                    final ModelNode result;\n                    try {\n                        // The domain model is going to be sent as part of the prepared notification\n                        result = controller.execute(READ_DOMAIN_MODEL, OperationMessageHandler.logging, registration, OperationAttachments.EMPTY);\n                    } catch (Exception e) {\n                        registration.failed(SlaveRegistrationException.ErrorCode.UNKNOWN, e.getClass().getName() + \":\" + e.getMessage());\n                        return;\n                    }\n                    // Send a registered notification back\n                    registration.sendCompletedMessage();\n                }\n            });\n        }","commit_id":"569bf4dc6fbe2de8fe04da30256d333cad963694","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void handleRequest(DataInput input, ActiveOperation.ResultHandler<RegistrationResult> resultHandler, ManagementRequestContext<Void> voidManagementRequestContext) throws IOException {\n            final byte param = input.readByte();\n            // If it failed\n            if(param != DomainControllerProtocol.PARAM_OK) {\n                final byte errorCode = input.readByte();\n                final String message =  input.readUTF();\n                resultHandler.done(new RegistrationResult(errorCode, message));\n                return;\n            }\n            final ModelNode result = new ModelNode();\n            result.readExternal(input);\n            registered(result);\n            resultHandler.done(new RegistrationResult());\n        }","id":93856,"modified_method":"@Override\n        public void handleRequest(DataInput input, ActiveOperation.ResultHandler<RegistrationResult> resultHandler, ManagementRequestContext<Void> voidManagementRequestContext) throws IOException {\n            final byte param = input.readByte();\n            // If it failed\n            if(param != DomainControllerProtocol.PARAM_OK) {\n                final byte errorCode = input.readByte();\n                final String message =  input.readUTF();\n                resultHandler.done(new RegistrationResult(errorCode, message));\n                return;\n            }\n            resultHandler.done(new RegistrationResult());\n        }","commit_id":"569bf4dc6fbe2de8fe04da30256d333cad963694","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * Event that the registration was completed.\n         *\n         * @param result the result\n         * @param handler the handler\n         */\n        void registrationComplete(ModelNode result, ManagementChannelHandler handler);","id":93857,"modified_method":"/**\n         * Event that the registration was completed.\n         *\n         * @param handler the handler\n         */\n        void registrationComplete(ManagementChannelHandler handler);","commit_id":"569bf4dc6fbe2de8fe04da30256d333cad963694","url":"https://github.com/wildfly/wildfly"},{"original_method":"void registered(final ModelNode result) {\n        callback.registrationComplete(result, channelHandler);\n    }","id":93858,"modified_method":"void registered() {\n        callback.registrationComplete(channelHandler);\n    }","commit_id":"569bf4dc6fbe2de8fe04da30256d333cad963694","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public synchronized void start(StartContext context) throws StartException {\n        final RemoteDomainConnection connection;\n        final ManagementChannelHandler handler;\n        try {\n\n            // Include additional local host information when registering at the DC\n            final ModelNode hostInfo = createLocalHostHostInfo(localHostInfo, productConfig);\n\n            // Gather the required information to connect to the remote DC\n            final ProtocolChannelClient.Configuration configuration = new ProtocolChannelClient.Configuration();\n            configuration.setUri(new URI(\"remote://\" + ProtocolUtils.formatPossibleIpv6Address(localHostInfo.getRemoteDomainControllerHost()) + \":\" + localHostInfo.getRemoteDomainControllertPort()));\n            configuration.setEndpoint(endpointInjector.getValue());\n\n            final SecurityRealm realm = securityRealmInjector.getOptionalValue();\n            // Create the remote domain channel strategy\n            connection = new RemoteDomainConnection(localHostInfo.getLocalHostName(), hostInfo, configuration, realm,\n                                                    executor, new RemoteDomainConnection.HostRegistrationCallback() {\n                @Override\n                public boolean applyDomainModel(final List<ModelNode> bootOperations) {\n                    // Apply the model..\n                    return applyRemoteDomainModel(bootOperations);\n                }\n\n                @Override\n                public void registrationComplete(ModelNode result, ManagementChannelHandler handler) {\n                    //\n                }\n            });\n            // Setup the management channel handler\n            handler = connection.getHandler();\n        } catch (Exception e) {\n            throw new StartException(e);\n        } finally {\n            futureClient.setClient(this);\n        }\n        this.connection = connection;\n        this.handler = handler;\n    }","id":93859,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public synchronized void start(StartContext context) throws StartException {\n        final RemoteDomainConnection connection;\n        final ManagementChannelHandler handler;\n        try {\n\n            // Include additional local host information when registering at the DC\n            final ModelNode hostInfo = createLocalHostHostInfo(localHostInfo, productConfig);\n\n            // Gather the required information to connect to the remote DC\n            final ProtocolChannelClient.Configuration configuration = new ProtocolChannelClient.Configuration();\n            configuration.setUri(new URI(\"remote://\" + ProtocolUtils.formatPossibleIpv6Address(localHostInfo.getRemoteDomainControllerHost()) + \":\" + localHostInfo.getRemoteDomainControllertPort()));\n            configuration.setEndpoint(endpointInjector.getValue());\n\n            final SecurityRealm realm = securityRealmInjector.getOptionalValue();\n            // Create the remote domain channel strategy\n            connection = new RemoteDomainConnection(localHostInfo.getLocalHostName(), hostInfo, configuration, realm,\n                                                    executor, new RemoteDomainConnection.HostRegistrationCallback() {\n                @Override\n                public boolean applyDomainModel(final List<ModelNode> bootOperations) {\n                    // Apply the model..\n                    return applyRemoteDomainModel(bootOperations);\n                }\n\n                @Override\n                public void registrationComplete(ManagementChannelHandler handler) {\n                    //\n                }\n            });\n            // Setup the management channel handler\n            handler = connection.getHandler();\n        } catch (Exception e) {\n            throw new StartException(e);\n        } finally {\n            futureClient.setClient(this);\n        }\n        this.connection = connection;\n        this.handler = handler;\n    }","commit_id":"569bf4dc6fbe2de8fe04da30256d333cad963694","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Nullable\n  @Override\n  public Element getState() {\n    Element parentNode = new Element(\"state\");\n    writeContext(parentNode);//writes temporary configurations here\n    for (final RunnerAndConfigurationSettings runnerAndConfigurationSettings : myTemplateConfigurationsMap.values()) {\n      if (runnerAndConfigurationSettings.getConfiguration() instanceof UnknownRunConfiguration) {\n        if (((UnknownRunConfiguration)runnerAndConfigurationSettings.getConfiguration()).isDoNotStore()) {\n          continue;\n        }\n      }\n\n      addConfigurationElement(parentNode, runnerAndConfigurationSettings);\n    }\n\n    for (RunnerAndConfigurationSettings configuration : getStableConfigurations(false)) {\n      addConfigurationElement(parentNode, configuration);\n    }\n\n    final JDOMExternalizableStringList order = new JDOMExternalizableStringList();\n    //temp && stable configurations, !unknown\n    for (RunnerAndConfigurationSettings each : myConfigurations.values()) {\n      if (each.getType() instanceof UnknownConfigurationType) continue;\n      order.add(each.getUniqueID());\n    }\n\n    order.writeExternal(parentNode);\n\n    final JDOMExternalizableStringList recentList = new JDOMExternalizableStringList();\n    for (RunConfiguration each : myRecentlyUsedTemporaries) {\n      if (each.getType() instanceof UnknownConfigurationType) continue;\n      RunnerAndConfigurationSettings settings = getSettings(each);\n      if (settings == null) {\n        continue;\n      }\n      recentList.add(settings.getUniqueID());\n    }\n    if (!recentList.isEmpty()) {\n      final Element recent = new Element(RECENT);\n      parentNode.addContent(recent);\n      recentList.writeExternal(recent);\n    }\n\n    if (myUnknownElements != null) {\n      for (Element unloadedElement : myUnknownElements) {\n        parentNode.addContent(unloadedElement.clone());\n      }\n    }\n    return parentNode;\n  }","id":93860,"modified_method":"@Nullable\n  @Override\n  public Element getState() {\n    Element parentNode = new Element(\"state\");\n    // writes temporary configurations here\n    writeContext(parentNode);\n\n    for (RunnerAndConfigurationSettings configuration : myTemplateConfigurationsMap.values()) {\n      if (configuration.getConfiguration() instanceof UnknownRunConfiguration &&\n          ((UnknownRunConfiguration)configuration.getConfiguration()).isDoNotStore()) {\n        continue;\n      }\n\n      addConfigurationElement(parentNode, configuration);\n    }\n\n    for (RunnerAndConfigurationSettings configuration : getStableConfigurations(false)) {\n      addConfigurationElement(parentNode, configuration);\n    }\n\n    // temp && stable configurations, !unknown\n    JDOMExternalizableStringList order = null;\n    for (RunnerAndConfigurationSettings each : myConfigurations.values()) {\n      if (each.getType() instanceof UnknownConfigurationType) {\n        continue;\n      }\n\n      if (order == null) {\n        order = new JDOMExternalizableStringList();\n      }\n      order.add(each.getUniqueID());\n    }\n    if (order != null) {\n      order.writeExternal(parentNode);\n    }\n\n    final JDOMExternalizableStringList recentList = new JDOMExternalizableStringList();\n    for (RunConfiguration each : myRecentlyUsedTemporaries) {\n      if (each.getType() instanceof UnknownConfigurationType) {\n        continue;\n      }\n      RunnerAndConfigurationSettings settings = getSettings(each);\n      if (settings == null) {\n        continue;\n      }\n      recentList.add(settings.getUniqueID());\n    }\n    if (!recentList.isEmpty()) {\n      Element recent = new Element(RECENT);\n      parentNode.addContent(recent);\n      recentList.writeExternal(recent);\n    }\n\n    if (myUnknownElements != null) {\n      for (Element unloadedElement : myUnknownElements) {\n        parentNode.addContent(unloadedElement.clone());\n      }\n    }\n    return parentNode;\n  }","commit_id":"70fab7f2f604f828ab133384b5e45ea8170e143f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doCheckPermission(Permission permission, Object context) {\n\t\tif (!PortalSecurityManagerThreadLocal.isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (permission instanceof AllPermission) {\n\t\t}\n\t\telse if (permission instanceof AuthPermission) {\n\t\t\tcheckAuthPermission((AuthPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof AWTPermission) {\n\t\t}\n\t\telse if (permission instanceof DelegationPermission) {\n\t\t}\n\t\telse if (permission instanceof FilePermission) {\n\t\t\tcheckFilePermission((FilePermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof LoggingPermission) {\n\t\t\tcheckLoggingPermission((LoggingPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof ManagementPermission) {\n\t\t\tcheckManagementPermission(\n\t\t\t\t(ManagementPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof MBeanPermission) {\n\t\t\tcheckMBeanPermission((MBeanPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof MBeanServerPermission) {\n\t\t\tcheckMBeanServerPermission(\n\t\t\t\t(MBeanServerPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof MBeanTrustPermission) {\n\t\t\tcheckMBeanTrustPermission(\n\t\t\t\t(MBeanTrustPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof NetPermission) {\n\t\t\tcheckNetPermission((NetPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof PrivateCredentialPermission) {\n\t\t}\n\t\telse if (permission instanceof PropertyPermission) {\n\t\t\tcheckPropertyPermission((PropertyPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof ReflectPermission) {\n\t\t\tcheckReflectPermission((ReflectPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof RuntimePermission) {\n\t\t\tcheckRuntimePermission((RuntimePermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof SecurityPermission) {\n\t\t\tcheckSecurityPermission((SecurityPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof SerializablePermission) {\n\t\t}\n\t\telse if (permission instanceof ServicePermission) {\n\t\t}\n\t\telse if (permission instanceof SocketPermission) {\n\t\t\tcheckSocketPermission((SocketPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof SQLPermission) {\n\t\t}\n\t\telse if (permission instanceof SSLPermission) {\n\t\t}\n\t\telse if (permission instanceof SubjectDelegationPermission) {\n\t\t}\n\t\telse if (permission instanceof UnresolvedPermission) {\n\t\t\tcheckUnresolvedPermission(\n\t\t\t\t(UnresolvedPermission)permission, context);\n\t\t}\n\n\t\tif (_parentSecurityManager != null) {\n\t\t\t_parentSecurityManager.checkPermission(permission, context);\n\t\t}\n\t}","id":93861,"modified_method":"protected void doCheckPermission(Permission permission, Object context) {\n\t\tboolean enabled = PortalSecurityManagerThreadLocal.isEnabled();\n\n\t\tif (!enabled) {\n\t\t\tif (_parentSecurityManager != null) {\n\t\t\t\t_parentSecurityManager.checkPermission(permission, context);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tPACLPolicy paclPolicy = null;\n\n\t\ttry {\n\t\t\tPortalSecurityManagerThreadLocal.setEnabled(false);\n\n\t\t\tpaclPolicy = getPACLPolicy(_log.isDebugEnabled());\n\t\t}\n\t\tfinally {\n\t\t\tPortalSecurityManagerThreadLocal.setEnabled(enabled);\n\t\t}\n\n\t\tif ((paclPolicy != null) && paclPolicy.isActive()) {\n\t\t\tif (_parentSecurityManager != null) {\n\t\t\t\t_parentSecurityManager.checkPermission(permission, context);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (permission instanceof AllPermission) {\n\t\t}\n\t\telse if (permission instanceof AuthPermission) {\n\t\t\tcheckAuthPermission((AuthPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof AWTPermission) {\n\t\t}\n\t\telse if (permission instanceof DelegationPermission) {\n\t\t}\n\t\telse if (permission instanceof FilePermission) {\n\t\t\tcheckFilePermission((FilePermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof LoggingPermission) {\n\t\t\tcheckLoggingPermission((LoggingPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof ManagementPermission) {\n\t\t\tcheckManagementPermission(\n\t\t\t\t(ManagementPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof MBeanPermission) {\n\t\t\tcheckMBeanPermission((MBeanPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof MBeanServerPermission) {\n\t\t\tcheckMBeanServerPermission(\n\t\t\t\t(MBeanServerPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof MBeanTrustPermission) {\n\t\t\tcheckMBeanTrustPermission(\n\t\t\t\t(MBeanTrustPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof NetPermission) {\n\t\t\tcheckNetPermission((NetPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof PrivateCredentialPermission) {\n\t\t}\n\t\telse if (permission instanceof PropertyPermission) {\n\t\t\tcheckPropertyPermission((PropertyPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof ReflectPermission) {\n\t\t\tcheckReflectPermission((ReflectPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof RuntimePermission) {\n\t\t\tcheckRuntimePermission((RuntimePermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof SecurityPermission) {\n\t\t\tcheckSecurityPermission((SecurityPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof SerializablePermission) {\n\t\t}\n\t\telse if (permission instanceof ServicePermission) {\n\t\t}\n\t\telse if (permission instanceof SocketPermission) {\n\t\t\tcheckSocketPermission((SocketPermission)permission, context);\n\t\t}\n\t\telse if (permission instanceof SQLPermission) {\n\t\t}\n\t\telse if (permission instanceof SSLPermission) {\n\t\t}\n\t\telse if (permission instanceof SubjectDelegationPermission) {\n\t\t}\n\t\telse if (permission instanceof UnresolvedPermission) {\n\t\t\tcheckUnresolvedPermission(\n\t\t\t\t(UnresolvedPermission)permission, context);\n\t\t}\n\n\t\tif (_parentSecurityManager != null) {\n\t\t\t_parentSecurityManager.checkPermission(permission, context);\n\t\t}\n\t}","commit_id":"710abe867ab770dda10ad36c1c8a453949baaae1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void checkPermission(Permission permission) {\n\t\tdoCheckPermission(permission, null);\n\t}","id":93862,"modified_method":"@Override\n\tpublic void checkPermission(Permission permission) {\n\t\tdoCheckPermission(permission, AccessController.getContext());\n\t}","commit_id":"710abe867ab770dda10ad36c1c8a453949baaae1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  @NotNull\n  public DebuggerActionHandler getRunToCursorHandler() {\n    return myRunToCursorActionHandler;\n  }","id":93863,"modified_method":"@Override\n  @NotNull\n  public DebuggerActionHandler getRunToCursorHandler() {\n    return DISABLED;\n  }","commit_id":"dce4e0f9098d74f3e4f8cc56e4b77542af0e78c0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public DebuggerActionHandler getForceRunToCursorHandler() {\n    return myForceRunToCursorActionHandler;\n  }","id":93864,"modified_method":"@Override\n  @NotNull\n  public DebuggerActionHandler getForceRunToCursorHandler() {\n    return DISABLED;\n  }","commit_id":"dce4e0f9098d74f3e4f8cc56e4b77542af0e78c0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean isEnabled(final @NotNull XDebugSession session, final DataContext dataContext) {\n    return super.isEnabled(session, dataContext) && XDebuggerUtilImpl.getCaretPosition(session.getProject(), dataContext) != null;\n  }","id":93865,"modified_method":"protected boolean isEnabled(final @NotNull XDebugSession session, final DataContext dataContext) {\n    if (!super.isEnabled(session, dataContext)) return false;\n    XSourcePosition position = XDebuggerUtilImpl.getCaretPosition(session.getProject(), dataContext);\n    return position != null && XDebuggerUtil.getInstance().canPutBreakpointAt(session.getProject(), position.getFile(), position.getLine());\n  }","commit_id":"dce4e0f9098d74f3e4f8cc56e4b77542af0e78c0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void update(final AnActionEvent e)\n  {\n    final Presentation presentation = e.getPresentation();\n\n    super.update(e);\n\n    if (presentation.isEnabled() && !isUnderSourceRoots(e))\n    {\n      presentation.setEnabled(false);\n      presentation.setVisible(false);\n    }\n  }","id":93866,"modified_method":"public final void update(final AnActionEvent e)\n  {\n    final Presentation presentation = e.getPresentation();\n\n    super.update(e);\n\n    if (!presentation.isEnabled() || !isUnderSourceRoots(e))\n      return;\n\n    if (GroovyGroup.isGroovyFacetPresented(e)) return;\n\n    presentation.setEnabled(false);\n    presentation.setVisible(false);\n  }","commit_id":"58cb744f7ab3d8b148b2492f10bd8a3537504921","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean isEnabled(UIContext context) {\n        if (requiresCamelSetup()) {\n            // requires camel is already setup\n            Project project = getSelectedProjectOrNull(context);\n            return project != null && super.isEnabled(context) && findCamelCoreDependency(project) != null;\n        } else {\n            return super.isEnabled(context);\n        }\n    }","id":93867,"modified_method":"@Override\n    public boolean isEnabled(UIContext context) {\n        boolean enabled = super.isEnabled(context);\n        if (!enabled) {\n            return false;\n        }\n        if (requiresCamelSetup()) {\n            // requires camel is already setup\n            Project project = getSelectedProjectOrNull(context);\n            if (project != null) {\n                return findCamelCoreDependency(project) != null;\n            }\n        }\n        return false;\n    }","commit_id":"f74a622cbc4aceb1e9d0943a766969271d8bd882","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public UICommandMetadata getMetadata(UIContext context) {\n        return Metadata.forCommand(CamelEditEndpointXmlCommand.class).name(\n                \"Camel: Edit Endpoint XML\").category(Categories.create(CATEGORY))\n                .description(\"Edit Camel endpoint to an existing XML file\");\n    }","id":93868,"modified_method":"@Override\n    public UICommandMetadata getMetadata(UIContext context) {\n        return Metadata.forCommand(CamelEditEndpointXmlCommand.class).name(\n                \"Camel: Edit Endpoint XML\").category(Categories.create(CATEGORY))\n                .description(\"Edit Camel endpoint from an existing XML file\");\n    }","commit_id":"f74a622cbc4aceb1e9d0943a766969271d8bd882","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public int lineLengthBefore(final int offset) {\n    int _xblockexpression = (int) 0;\n    {\n      int currentIndentation = 0;\n      NewLineData lastWrap = null;\n      int lastIndentation = 0;\n      TreeMap<Integer,FormattingData> _formattings = this.getFormattings();\n      Collection<FormattingData> _values = _formattings.values();\n      for (final FormattingData f : _values) {\n        int _offset = f.getOffset();\n        boolean _lessThan = (_offset < offset);\n        if (_lessThan) {\n          int _indentationChange = f.getIndentationChange();\n          int _plus = (currentIndentation + _indentationChange);\n          currentIndentation = _plus;\n          if ((f instanceof NewLineData)) {\n            lastWrap = ((NewLineData) f);\n            lastIndentation = currentIndentation;\n          }\n        }\n      }\n      int _offset_1 = lastWrap.getOffset();\n      int _length = lastWrap.getLength();\n      int lastOffset = (_offset_1 + _length);\n      int lineStart = lastOffset;\n      TreeMap<Integer,FormattingData> _formattings_1 = this.getFormattings();\n      int _offset_2 = lastWrap.getOffset();\n      int _plus_1 = (_offset_2 + 1);\n      SortedMap<Integer,FormattingData> _subMap = _formattings_1.subMap(Integer.valueOf(_plus_1), Integer.valueOf(offset));\n      Collection<FormattingData> _values_1 = _subMap.values();\n      for (final FormattingData f_1 : _values_1) {\n        {\n          String _document = this.getDocument();\n          int _offset_3 = f_1.getOffset();\n          final String text = _document.substring(lastOffset, _offset_3);\n          final int index = text.lastIndexOf(\"\\n\");\n          boolean _greaterEqualsThan = (index >= 0);\n          if (_greaterEqualsThan) {\n            int _plus_2 = (index + lastOffset);\n            lineStart = _plus_2;\n            currentIndentation = 0;\n          }\n          int _offset_4 = f_1.getOffset();\n          int _length_1 = f_1.getLength();\n          int _plus_3 = (_offset_4 + _length_1);\n          lastOffset = _plus_3;\n        }\n      }\n      int lengthDiff = 0;\n      TreeMap<Integer,FormattingData> _formattings_2 = this.getFormattings();\n      int _offset_3 = lastWrap.getOffset();\n      int _plus_2 = (_offset_3 + 1);\n      SortedMap<Integer,FormattingData> _subMap_1 = _formattings_2.subMap(Integer.valueOf(_plus_2), Integer.valueOf(offset));\n      Collection<FormattingData> _values_2 = _subMap_1.values();\n      for (final FormattingData f_2 : _values_2) {\n        if ((f_2 instanceof WhitespaceData)) {\n          String _space = ((WhitespaceData) f_2).getSpace();\n          int _length_1 = _space==null?0:_space.length();\n          Integer _elvis = ObjectExtensions.<Integer>operator_elvis(Integer.valueOf(_length_1), Integer.valueOf(0));\n          int _length_2 = f_2.getLength();\n          int _minus = ((_elvis).intValue() - _length_2);\n          int _plus_3 = (lengthDiff + _minus);\n          lengthDiff = _plus_3;\n        }\n      }\n      int _minus_1 = (offset - lineStart);\n      int _indentationLenght = this.getIndentationLenght(currentIndentation);\n      int _plus_4 = (_minus_1 + _indentationLenght);\n      int _plus_5 = (_plus_4 + lengthDiff);\n      _xblockexpression = (_plus_5);\n    }\n    return _xblockexpression;\n  }","id":93869,"modified_method":"public int lineLengthBefore(final int offset) {\n    int _xblockexpression = (int) 0;\n    {\n      int currentIndentation = 0;\n      NewLineData lastWrap = null;\n      int lastIndentation = 0;\n      TreeMap<Integer,FormattingData> _formattings = this.getFormattings();\n      Collection<FormattingData> _values = _formattings.values();\n      for (final FormattingData f : _values) {\n        int _offset = f.getOffset();\n        boolean _lessThan = (_offset < offset);\n        if (_lessThan) {\n          int _indentationChange = f.getIndentationChange();\n          int _plus = (currentIndentation + _indentationChange);\n          currentIndentation = _plus;\n          if ((f instanceof NewLineData)) {\n            lastWrap = ((NewLineData) f);\n            lastIndentation = currentIndentation;\n          }\n        }\n      }\n      int _offset_1 = lastWrap.getOffset();\n      int _length = lastWrap.getLength();\n      int lastOffset = (_offset_1 + _length);\n      int lineStart = lastOffset;\n      TreeMap<Integer,FormattingData> _formattings_1 = this.getFormattings();\n      int _offset_2 = lastWrap.getOffset();\n      int _plus_1 = (_offset_2 + 1);\n      SortedMap<Integer,FormattingData> _subMap = _formattings_1.subMap(Integer.valueOf(_plus_1), Integer.valueOf(offset));\n      Collection<FormattingData> _values_1 = _subMap.values();\n      for (final FormattingData f_1 : _values_1) {\n        {\n          String _document = this.getDocument();\n          int _offset_3 = f_1.getOffset();\n          final String text = _document.substring(lastOffset, _offset_3);\n          final int index = text.lastIndexOf(\"\\n\");\n          boolean _greaterEqualsThan = (index >= 0);\n          if (_greaterEqualsThan) {\n            int _plus_2 = (index + lastOffset);\n            lineStart = _plus_2;\n            currentIndentation = 0;\n          }\n          int _offset_4 = f_1.getOffset();\n          int _length_1 = f_1.getLength();\n          int _plus_3 = (_offset_4 + _length_1);\n          lastOffset = _plus_3;\n        }\n      }\n      int lengthDiff = 0;\n      TreeMap<Integer,FormattingData> _formattings_2 = this.getFormattings();\n      int _offset_3 = lastWrap.getOffset();\n      int _plus_2 = (_offset_3 + 1);\n      SortedMap<Integer,FormattingData> _subMap_1 = _formattings_2.subMap(Integer.valueOf(_plus_2), Integer.valueOf(offset));\n      Collection<FormattingData> _values_2 = _subMap_1.values();\n      for (final FormattingData f_2 : _values_2) {\n        if ((f_2 instanceof WhitespaceData)) {\n          final String space = ((WhitespaceData) f_2).getSpace();\n          int _xifexpression = (int) 0;\n          boolean _equals = ObjectExtensions.operator_equals(space, null);\n          if (_equals) {\n            _xifexpression = 0;\n          } else {\n            int _length_1 = space.length();\n            _xifexpression = _length_1;\n          }\n          final int length = _xifexpression;\n          int _plus_3 = (lengthDiff + length);\n          int _length_2 = f_2.getLength();\n          int _minus = (_plus_3 - _length_2);\n          lengthDiff = _minus;\n        }\n      }\n      int _minus_1 = (offset - lineStart);\n      int _indentationLenght = this.getIndentationLenght(currentIndentation);\n      int _plus_4 = (_minus_1 + _indentationLenght);\n      int _plus_5 = (_plus_4 + lengthDiff);\n      _xblockexpression = (_plus_5);\n    }\n    return _xblockexpression;\n  }","commit_id":"ea9d241feef6ac1d2c78860170cbc5048acb1781","url":"https://github.com/eclipse/xtext"},{"original_method":"protected ArrayList<TextReplacement> createMissingEditReplacements(final XtextResource res, final Collection<TextReplacement> edits, final int offset, final int length) {\n    ArrayList<TextReplacement> _xblockexpression = null;\n    {\n      final Function1<TextReplacement,Integer> _function = new Function1<TextReplacement,Integer>() {\n          public Integer apply(final TextReplacement it) {\n            int _offset = it.getOffset();\n            return Integer.valueOf(_offset);\n          }\n        };\n      Iterable<Integer> _map = IterableExtensions.<TextReplacement, Integer>map(edits, _function);\n      final Set<Integer> offsets = IterableExtensions.<Integer>toSet(_map);\n      final ArrayList<TextReplacement> result = CollectionLiterals.<TextReplacement>newArrayList();\n      int lastOffset = 0;\n      IParseResult _parseResult = res.getParseResult();\n      ICompositeNode _rootNode = _parseResult==null?(ICompositeNode)null:_parseResult.getRootNode();\n      Iterable<ILeafNode> _leafNodes = _rootNode==null?(Iterable<ILeafNode>)null:_rootNode.getLeafNodes();\n      List<ILeafNode> _emptyList = CollectionLiterals.<ILeafNode>emptyList();\n      Iterable<? extends ILeafNode> _elvis = ObjectExtensions.<Iterable<? extends ILeafNode>>operator_elvis(_leafNodes, _emptyList);\n      for (final ILeafNode leaf : _elvis) {\n        boolean _or = false;\n        boolean _isHidden = leaf.isHidden();\n        boolean _not = (!_isHidden);\n        if (_not) {\n          _or = true;\n        } else {\n          String _text = leaf.getText();\n          String _trim = _text.trim();\n          boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(_trim);\n          boolean _not_1 = (!_isNullOrEmpty);\n          _or = (_not || _not_1);\n        }\n        if (_or) {\n          boolean _and = false;\n          boolean _and_1 = false;\n          boolean _greaterEqualsThan = (lastOffset >= offset);\n          if (!_greaterEqualsThan) {\n            _and_1 = false;\n          } else {\n            int _offset = leaf.getOffset();\n            int _plus = (offset + length);\n            boolean _lessEqualsThan = (_offset <= _plus);\n            _and_1 = (_greaterEqualsThan && _lessEqualsThan);\n          }\n          if (!_and_1) {\n            _and = false;\n          } else {\n            boolean _contains = offsets.contains(Integer.valueOf(lastOffset));\n            boolean _not_2 = (!_contains);\n            _and = (_and_1 && _not_2);\n          }\n          if (_and) {\n            int _offset_1 = leaf.getOffset();\n            int _minus = (_offset_1 - lastOffset);\n            TextReplacement _textReplacement = new TextReplacement(lastOffset, _minus, \"!!\");\n            result.add(_textReplacement);\n          }\n          int _offset_2 = leaf.getOffset();\n          int _length = leaf.getLength();\n          int _plus_1 = (_offset_2 + _length);\n          lastOffset = _plus_1;\n        }\n      }\n      _xblockexpression = (result);\n    }\n    return _xblockexpression;\n  }","id":93870,"modified_method":"protected ArrayList<TextReplacement> createMissingEditReplacements(final XtextResource res, final Collection<TextReplacement> edits, final int offset, final int length) {\n    ArrayList<TextReplacement> _xblockexpression = null;\n    {\n      final Function1<TextReplacement,Integer> _function = new Function1<TextReplacement,Integer>() {\n          public Integer apply(final TextReplacement it) {\n            int _offset = it.getOffset();\n            return Integer.valueOf(_offset);\n          }\n        };\n      Iterable<Integer> _map = IterableExtensions.<TextReplacement, Integer>map(edits, _function);\n      final Set<Integer> offsets = IterableExtensions.<Integer>toSet(_map);\n      final ArrayList<TextReplacement> result = CollectionLiterals.<TextReplacement>newArrayList();\n      int lastOffset = 0;\n      Iterable<? extends ILeafNode> _elvis = null;\n      IParseResult _parseResult = res.getParseResult();\n      ICompositeNode _rootNode = _parseResult==null?(ICompositeNode)null:_parseResult.getRootNode();\n      Iterable<ILeafNode> _leafNodes = _rootNode==null?(Iterable<ILeafNode>)null:_rootNode.getLeafNodes();\n      if (_leafNodes != null) {\n        _elvis = _leafNodes;\n      } else {\n        List<ILeafNode> _emptyList = CollectionLiterals.<ILeafNode>emptyList();\n        _elvis = ObjectExtensions.<Iterable<? extends ILeafNode>>operator_elvis(_leafNodes, _emptyList);\n      }\n      for (final ILeafNode leaf : _elvis) {\n        boolean _or = false;\n        boolean _isHidden = leaf.isHidden();\n        boolean _not = (!_isHidden);\n        if (_not) {\n          _or = true;\n        } else {\n          String _text = leaf.getText();\n          String _trim = _text.trim();\n          boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(_trim);\n          boolean _not_1 = (!_isNullOrEmpty);\n          _or = (_not || _not_1);\n        }\n        if (_or) {\n          boolean _and = false;\n          boolean _and_1 = false;\n          boolean _greaterEqualsThan = (lastOffset >= offset);\n          if (!_greaterEqualsThan) {\n            _and_1 = false;\n          } else {\n            int _offset = leaf.getOffset();\n            int _plus = (offset + length);\n            boolean _lessEqualsThan = (_offset <= _plus);\n            _and_1 = (_greaterEqualsThan && _lessEqualsThan);\n          }\n          if (!_and_1) {\n            _and = false;\n          } else {\n            boolean _contains = offsets.contains(Integer.valueOf(lastOffset));\n            boolean _not_2 = (!_contains);\n            _and = (_and_1 && _not_2);\n          }\n          if (_and) {\n            int _offset_1 = leaf.getOffset();\n            int _minus = (_offset_1 - lastOffset);\n            TextReplacement _textReplacement = new TextReplacement(lastOffset, _minus, \"!!\");\n            result.add(_textReplacement);\n          }\n          int _offset_2 = leaf.getOffset();\n          int _length = leaf.getLength();\n          int _plus_1 = (_offset_2 + _length);\n          lastOffset = _plus_1;\n        }\n      }\n      _xblockexpression = (result);\n    }\n    return _xblockexpression;\n  }","commit_id":"ea9d241feef6ac1d2c78860170cbc5048acb1781","url":"https://github.com/eclipse/xtext"},{"original_method":"public Function1<? super FormattableDocument,? extends Iterable<FormattingData>> surround(final INode node, final Procedure1<? super FormattingDataInit> before, final Procedure1<? super FormattingDataInit> after) {\n    final Function1<FormattableDocument,ArrayList<FormattingData>> _function = new Function1<FormattableDocument,ArrayList<FormattingData>>() {\n        public ArrayList<FormattingData> apply(final FormattableDocument doc) {\n          ArrayList<FormattingData> _xblockexpression = null;\n          {\n            final ArrayList<FormattingData> result = CollectionLiterals.<FormattingData>newArrayList();\n            boolean _notEquals = ObjectExtensions.operator_notEquals(node, null);\n            if (_notEquals) {\n              HiddenLeafs _hiddenLeafsBefore = FormattingDataFactory.this._hiddenLeafAccess.getHiddenLeafsBefore(node);\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _newFormattingData = FormattingDataFactory.this.newFormattingData(_hiddenLeafsBefore, before);\n              Iterable<FormattingData> _apply = _newFormattingData==null?(Iterable<FormattingData>)null:_newFormattingData.apply(doc);\n              List<FormattingData> _emptyList = CollectionLiterals.<FormattingData>emptyList();\n              Iterable<FormattingData> _elvis = ObjectExtensions.<Iterable<FormattingData>>operator_elvis(_apply, _emptyList);\n              Iterables.<FormattingData>addAll(result, _elvis);\n              HiddenLeafs _hiddenLeafsAfter = FormattingDataFactory.this._hiddenLeafAccess.getHiddenLeafsAfter(node);\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _newFormattingData_1 = FormattingDataFactory.this.newFormattingData(_hiddenLeafsAfter, after);\n              Iterable<FormattingData> _apply_1 = _newFormattingData_1==null?(Iterable<FormattingData>)null:_newFormattingData_1.apply(doc);\n              List<FormattingData> _emptyList_1 = CollectionLiterals.<FormattingData>emptyList();\n              Iterable<FormattingData> _elvis_1 = ObjectExtensions.<Iterable<FormattingData>>operator_elvis(_apply_1, _emptyList_1);\n              Iterables.<FormattingData>addAll(result, _elvis_1);\n            }\n            _xblockexpression = (result);\n          }\n          return _xblockexpression;\n        }\n      };\n    return _function;\n  }","id":93871,"modified_method":"public Function1<? super FormattableDocument,? extends Iterable<FormattingData>> surround(final INode node, final Procedure1<? super FormattingDataInit> before, final Procedure1<? super FormattingDataInit> after) {\n    final Function1<FormattableDocument,ArrayList<FormattingData>> _function = new Function1<FormattableDocument,ArrayList<FormattingData>>() {\n        public ArrayList<FormattingData> apply(final FormattableDocument doc) {\n          ArrayList<FormattingData> _xblockexpression = null;\n          {\n            final ArrayList<FormattingData> result = CollectionLiterals.<FormattingData>newArrayList();\n            boolean _notEquals = ObjectExtensions.operator_notEquals(node, null);\n            if (_notEquals) {\n              Iterable<FormattingData> _elvis = null;\n              HiddenLeafs _hiddenLeafsBefore = FormattingDataFactory.this._hiddenLeafAccess.getHiddenLeafsBefore(node);\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _newFormattingData = FormattingDataFactory.this.newFormattingData(_hiddenLeafsBefore, before);\n              Iterable<FormattingData> _apply = _newFormattingData==null?(Iterable<FormattingData>)null:_newFormattingData.apply(doc);\n              if (_apply != null) {\n                _elvis = _apply;\n              } else {\n                List<FormattingData> _emptyList = CollectionLiterals.<FormattingData>emptyList();\n                _elvis = ObjectExtensions.<Iterable<FormattingData>>operator_elvis(_apply, _emptyList);\n              }\n              Iterables.<FormattingData>addAll(result, _elvis);\n              Iterable<FormattingData> _elvis_1 = null;\n              HiddenLeafs _hiddenLeafsAfter = FormattingDataFactory.this._hiddenLeafAccess.getHiddenLeafsAfter(node);\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _newFormattingData_1 = FormattingDataFactory.this.newFormattingData(_hiddenLeafsAfter, after);\n              Iterable<FormattingData> _apply_1 = _newFormattingData_1==null?(Iterable<FormattingData>)null:_newFormattingData_1.apply(doc);\n              if (_apply_1 != null) {\n                _elvis_1 = _apply_1;\n              } else {\n                List<FormattingData> _emptyList_1 = CollectionLiterals.<FormattingData>emptyList();\n                _elvis_1 = ObjectExtensions.<Iterable<FormattingData>>operator_elvis(_apply_1, _emptyList_1);\n              }\n              Iterables.<FormattingData>addAll(result, _elvis_1);\n            }\n            _xblockexpression = (result);\n          }\n          return _xblockexpression;\n        }\n      };\n    return _function;\n  }","commit_id":"ea9d241feef6ac1d2c78860170cbc5048acb1781","url":"https://github.com/eclipse/xtext"},{"original_method":"public Function1<? super FormattableDocument,? extends Iterable<FormattingData>> surround(final INode node, final Procedure1<? super FormattingDataInit> init) {\n    final Function1<FormattableDocument,ArrayList<FormattingData>> _function = new Function1<FormattableDocument,ArrayList<FormattingData>>() {\n        public ArrayList<FormattingData> apply(final FormattableDocument doc) {\n          ArrayList<FormattingData> _xblockexpression = null;\n          {\n            final ArrayList<FormattingData> result = CollectionLiterals.<FormattingData>newArrayList();\n            boolean _notEquals = ObjectExtensions.operator_notEquals(node, null);\n            if (_notEquals) {\n              HiddenLeafs _hiddenLeafsBefore = FormattingDataFactory.this._hiddenLeafAccess.getHiddenLeafsBefore(node);\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _newFormattingData = FormattingDataFactory.this.newFormattingData(_hiddenLeafsBefore, init);\n              Iterable<FormattingData> _apply = _newFormattingData==null?(Iterable<FormattingData>)null:_newFormattingData.apply(doc);\n              List<FormattingData> _emptyList = CollectionLiterals.<FormattingData>emptyList();\n              Iterable<FormattingData> _elvis = ObjectExtensions.<Iterable<FormattingData>>operator_elvis(_apply, _emptyList);\n              Iterables.<FormattingData>addAll(result, _elvis);\n              HiddenLeafs _hiddenLeafsAfter = FormattingDataFactory.this._hiddenLeafAccess.getHiddenLeafsAfter(node);\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _newFormattingData_1 = FormattingDataFactory.this.newFormattingData(_hiddenLeafsAfter, init);\n              Iterable<FormattingData> _apply_1 = _newFormattingData_1==null?(Iterable<FormattingData>)null:_newFormattingData_1.apply(doc);\n              List<FormattingData> _emptyList_1 = CollectionLiterals.<FormattingData>emptyList();\n              Iterable<FormattingData> _elvis_1 = ObjectExtensions.<Iterable<FormattingData>>operator_elvis(_apply_1, _emptyList_1);\n              Iterables.<FormattingData>addAll(result, _elvis_1);\n            }\n            _xblockexpression = (result);\n          }\n          return _xblockexpression;\n        }\n      };\n    return _function;\n  }","id":93872,"modified_method":"public Function1<? super FormattableDocument,? extends Iterable<FormattingData>> surround(final INode node, final Procedure1<? super FormattingDataInit> init) {\n    final Function1<FormattableDocument,ArrayList<FormattingData>> _function = new Function1<FormattableDocument,ArrayList<FormattingData>>() {\n        public ArrayList<FormattingData> apply(final FormattableDocument doc) {\n          ArrayList<FormattingData> _xblockexpression = null;\n          {\n            final ArrayList<FormattingData> result = CollectionLiterals.<FormattingData>newArrayList();\n            boolean _notEquals = ObjectExtensions.operator_notEquals(node, null);\n            if (_notEquals) {\n              Iterable<FormattingData> _elvis = null;\n              HiddenLeafs _hiddenLeafsBefore = FormattingDataFactory.this._hiddenLeafAccess.getHiddenLeafsBefore(node);\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _newFormattingData = FormattingDataFactory.this.newFormattingData(_hiddenLeafsBefore, init);\n              Iterable<FormattingData> _apply = _newFormattingData==null?(Iterable<FormattingData>)null:_newFormattingData.apply(doc);\n              if (_apply != null) {\n                _elvis = _apply;\n              } else {\n                List<FormattingData> _emptyList = CollectionLiterals.<FormattingData>emptyList();\n                _elvis = ObjectExtensions.<Iterable<FormattingData>>operator_elvis(_apply, _emptyList);\n              }\n              Iterables.<FormattingData>addAll(result, _elvis);\n              Iterable<FormattingData> _elvis_1 = null;\n              HiddenLeafs _hiddenLeafsAfter = FormattingDataFactory.this._hiddenLeafAccess.getHiddenLeafsAfter(node);\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _newFormattingData_1 = FormattingDataFactory.this.newFormattingData(_hiddenLeafsAfter, init);\n              Iterable<FormattingData> _apply_1 = _newFormattingData_1==null?(Iterable<FormattingData>)null:_newFormattingData_1.apply(doc);\n              if (_apply_1 != null) {\n                _elvis_1 = _apply_1;\n              } else {\n                List<FormattingData> _emptyList_1 = CollectionLiterals.<FormattingData>emptyList();\n                _elvis_1 = ObjectExtensions.<Iterable<FormattingData>>operator_elvis(_apply_1, _emptyList_1);\n              }\n              Iterables.<FormattingData>addAll(result, _elvis_1);\n            }\n            _xblockexpression = (result);\n          }\n          return _xblockexpression;\n        }\n      };\n    return _function;\n  }","commit_id":"ea9d241feef6ac1d2c78860170cbc5048acb1781","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void formatClosureMultiLine(final XClosure expr, final INode open, final Collection<XExpression> children, final INode close, final FormattableDocument format) {\n    this.formatClosureParameters(expr, format);\n    final INode explicit = this._nodeModelAccess.nodeForFeature(expr, org.eclipse.xtext.xbase.XbasePackage.Literals.XCLOSURE__EXPLICIT_SYNTAX);\n    boolean _notEquals = ObjectExtensions.operator_notEquals(explicit, null);\n    if (_notEquals) {\n      final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.oneSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formattingDataFactory.append(open, _function);\n      format.operator_add(_append);\n      final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.oneSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formattingDataFactory.prepend(explicit, _function_1);\n      format.operator_add(_prepend);\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formattingDataFactory.append(explicit, _function_2);\n      format.operator_add(_append_1);\n    } else {\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formattingDataFactory.append(open, _function_3);\n      format.operator_add(_append_2);\n    }\n    for (final XExpression c : children) {\n      {\n        this.format(c, format);\n        final INode node = this._nodeModelAccess.nodeForEObject(c);\n        final ILeafNode semicolon = this._nodeModelAccess.immediatelyFollowingKeyword(node, \";\");\n        final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.noSpace();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formattingDataFactory.prepend(semicolon, _function_4);\n        format.operator_add(_prepend_1);\n        XExpression _last = IterableExtensions.<XExpression>last(children);\n        boolean _notEquals_1 = ObjectExtensions.operator_notEquals(c, _last);\n        if (_notEquals_1) {\n          INode _elvis = ObjectExtensions.<INode>operator_elvis(semicolon, node);\n          final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.newLine();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formattingDataFactory.append(_elvis, _function_5);\n          format.operator_add(_append_3);\n        }\n      }\n    }\n    final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.newLine();\n          it.decreaseIndentation();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formattingDataFactory.prepend(close, _function_4);\n    format.operator_add(_prepend_1);\n  }","id":93873,"modified_method":"protected void formatClosureMultiLine(final XClosure expr, final INode open, final Collection<XExpression> children, final INode close, final FormattableDocument format) {\n    this.formatClosureParameters(expr, format);\n    final INode explicit = this._nodeModelAccess.nodeForFeature(expr, org.eclipse.xtext.xbase.XbasePackage.Literals.XCLOSURE__EXPLICIT_SYNTAX);\n    boolean _notEquals = ObjectExtensions.operator_notEquals(explicit, null);\n    if (_notEquals) {\n      final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.oneSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formattingDataFactory.append(open, _function);\n      format.operator_add(_append);\n      final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.oneSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formattingDataFactory.prepend(explicit, _function_1);\n      format.operator_add(_prepend);\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formattingDataFactory.append(explicit, _function_2);\n      format.operator_add(_append_1);\n    } else {\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formattingDataFactory.append(open, _function_3);\n      format.operator_add(_append_2);\n    }\n    for (final XExpression c : children) {\n      {\n        this.format(c, format);\n        final INode node = this._nodeModelAccess.nodeForEObject(c);\n        final ILeafNode semicolon = this._nodeModelAccess.immediatelyFollowingKeyword(node, \";\");\n        final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.noSpace();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formattingDataFactory.prepend(semicolon, _function_4);\n        format.operator_add(_prepend_1);\n        XExpression _last = IterableExtensions.<XExpression>last(children);\n        boolean _notEquals_1 = ObjectExtensions.operator_notEquals(c, _last);\n        if (_notEquals_1) {\n          INode _elvis = null;\n          if (semicolon != null) {\n            _elvis = semicolon;\n          } else {\n            _elvis = ObjectExtensions.<INode>operator_elvis(semicolon, node);\n          }\n          final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.newLine();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formattingDataFactory.append(_elvis, _function_5);\n          format.operator_add(_append_3);\n        }\n      }\n    }\n    final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.newLine();\n          it.decreaseIndentation();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formattingDataFactory.prepend(close, _function_4);\n    format.operator_add(_prepend_1);\n  }","commit_id":"ea9d241feef6ac1d2c78860170cbc5048acb1781","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XCollectionLiteral literal, final FormattableDocument document) {\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(literal, \"#\");\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formattingDataFactory.append(_nodeForKeyword, _function);\n    document.operator_add(_append);\n    ILeafNode _nodeForKeyword_1 = this._nodeModelAccess.nodeForKeyword(literal, \"[\");\n    ILeafNode _nodeForKeyword_2 = this._nodeModelAccess.nodeForKeyword(literal, \"{\");\n    ILeafNode node = ObjectExtensions.<ILeafNode>operator_elvis(_nodeForKeyword_1, _nodeForKeyword_2);\n    EList<XExpression> _elements = literal.getElements();\n    for (final XExpression value : _elements) {\n      {\n        final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              EList<XExpression> _elements = literal.getElements();\n              XExpression _head = IterableExtensions.<XExpression>head(_elements);\n              boolean _equals = ObjectExtensions.operator_equals(value, _head);\n              if (_equals) {\n                it.noSpace();\n              } else {\n                it.oneSpace();\n              }\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formattingDataFactory.append(node, _function_1);\n        document.operator_add(_append_1);\n        this.format(value, document);\n        INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(value);\n        ILeafNode _immediatelyFollowingKeyword = this._nodeModelAccess.immediatelyFollowingKeyword(_nodeForEObject, \",\");\n        node = _immediatelyFollowingKeyword;\n        final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.noSpace();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formattingDataFactory.prepend(node, _function_2);\n        document.operator_add(_prepend);\n      }\n    }\n    ILeafNode _nodeForKeyword_3 = this._nodeModelAccess.nodeForKeyword(literal, \"]\");\n    ILeafNode _nodeForKeyword_4 = this._nodeModelAccess.nodeForKeyword(literal, \"}\");\n    ILeafNode _elvis = ObjectExtensions.<ILeafNode>operator_elvis(_nodeForKeyword_3, _nodeForKeyword_4);\n    node = _elvis;\n    final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formattingDataFactory.prepend(node, _function_1);\n    document.operator_add(_prepend);\n  }","id":93874,"modified_method":"protected void _format(final XCollectionLiteral literal, final FormattableDocument document) {\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(literal, \"#\");\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formattingDataFactory.append(_nodeForKeyword, _function);\n    document.operator_add(_append);\n    ILeafNode _elvis = null;\n    ILeafNode _nodeForKeyword_1 = this._nodeModelAccess.nodeForKeyword(literal, \"[\");\n    if (_nodeForKeyword_1 != null) {\n      _elvis = _nodeForKeyword_1;\n    } else {\n      ILeafNode _nodeForKeyword_2 = this._nodeModelAccess.nodeForKeyword(literal, \"{\");\n      _elvis = ObjectExtensions.<ILeafNode>operator_elvis(_nodeForKeyword_1, _nodeForKeyword_2);\n    }\n    ILeafNode node = _elvis;\n    EList<XExpression> _elements = literal.getElements();\n    for (final XExpression value : _elements) {\n      {\n        final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              EList<XExpression> _elements = literal.getElements();\n              XExpression _head = IterableExtensions.<XExpression>head(_elements);\n              boolean _equals = ObjectExtensions.operator_equals(value, _head);\n              if (_equals) {\n                it.noSpace();\n              } else {\n                it.oneSpace();\n              }\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formattingDataFactory.append(node, _function_1);\n        document.operator_add(_append_1);\n        this.format(value, document);\n        INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(value);\n        ILeafNode _immediatelyFollowingKeyword = this._nodeModelAccess.immediatelyFollowingKeyword(_nodeForEObject, \",\");\n        node = _immediatelyFollowingKeyword;\n        final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.noSpace();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formattingDataFactory.prepend(node, _function_2);\n        document.operator_add(_prepend);\n      }\n    }\n    ILeafNode _elvis_1 = null;\n    ILeafNode _nodeForKeyword_3 = this._nodeModelAccess.nodeForKeyword(literal, \"]\");\n    if (_nodeForKeyword_3 != null) {\n      _elvis_1 = _nodeForKeyword_3;\n    } else {\n      ILeafNode _nodeForKeyword_4 = this._nodeModelAccess.nodeForKeyword(literal, \"}\");\n      _elvis_1 = ObjectExtensions.<ILeafNode>operator_elvis(_nodeForKeyword_3, _nodeForKeyword_4);\n    }\n    node = _elvis_1;\n    final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formattingDataFactory.prepend(node, _function_1);\n    document.operator_add(_prepend);\n  }","commit_id":"ea9d241feef6ac1d2c78860170cbc5048acb1781","url":"https://github.com/eclipse/xtext"},{"original_method":"public void registerValueMapping(String propertyName, String mappings)\n    {\n        propertyToolkit.registerValueMapping(propertyName, mappings);\n    }","id":93875,"modified_method":"public void registerValueMapping(String propertyName, String mappings)\n    {\n        valueMappings.put(propertyName, new ValueMap(propertyName, mappings));\n    }","commit_id":"85aa31ee81df5f7b9955ba9d15f9b551a9474fe0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void registerValueMapping(String propertyName, Map mappings)\n    {\n        propertyToolkit.registerValueMapping(propertyName, mappings);\n    }","id":93876,"modified_method":"public void registerValueMapping(String propertyName, Map mappings)\n    {\n        valueMappings.put(propertyName, new ValueMap(propertyName, mappings));\n    }","commit_id":"85aa31ee81df5f7b9955ba9d15f9b551a9474fe0","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Creates a {@link BeanDefinitionBuilder} instance for the\n     * {@link #getBeanClass bean Class} and passes it to the\n     * {@link #doParse} strategy method.\n     *\n     * @param element       the element that is to be parsed into a single BeanDefinition\n     * @param parserContext the object encapsulating the current state of the parsing process\n     * @return the BeanDefinition resulting from the parsing of the supplied {@link Element}\n     * @throws IllegalStateException if the bean {@link Class} returned from\n     *                               {@link #getBeanClass(org.w3c.dom.Element)} is <code>null<\/code>\n     * @see #doParse\n     */\n    protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext)\n    {\n        this.parserContext = parserContext;\n        preProcess();\n        Class beanClass = getBeanClass(element);\n        Assert.state(beanClass != null, \"Class returned from getBeanClass(Element) must not be null, element is: \" + element.getNodeName());\n        BeanDefinitionBuilder builder = createBeanDefinitionBuilder(element, beanClass);\n        builder.setSource(parserContext.extractSource(element));\n        builder.setSingleton(isSingleton());\n        builder.addDependsOn(\"_muleRegistry\");\n\n        List interfaces = ClassUtils.getAllInterfaces(beanClass);\n        if(interfaces!=null)\n        {\n            if(interfaces.contains(Initialisable.class))\n            {\n                builder.setInitMethodName(Initialisable.PHASE_NAME);\n            }\n\n            if(interfaces.contains(Disposable.class))\n            {\n                builder.setDestroyMethodName(Disposable.PHASE_NAME);\n            }\n        }\n\n        if (parserContext.isNested())\n        {\n            // Inner bean definition must receive same singleton status as containing bean.\n            builder.setSingleton(parserContext.getContainingBeanDefinition().isSingleton());\n        }\n        doParse(element, parserContext, builder);\n        return builder.getBeanDefinition();\n    }","id":93877,"modified_method":"/**\n     * Creates a {@link BeanDefinitionBuilder} instance for the\n     * {@link #getBeanClass bean Class} and passes it to the\n     * {@link #doParse} strategy method.\n     *\n     * @param element       the element that is to be parsed into a single BeanDefinition\n     * @param parserContext the object encapsulating the current state of the parsing process\n     * @return the BeanDefinition resulting from the parsing of the supplied {@link Element}\n     * @throws IllegalStateException if the bean {@link Class} returned from\n     *                               {@link #getBeanClass(org.w3c.dom.Element)} is <code>null<\/code>\n     * @see #doParse\n     */\n    protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext)\n    {\n        this.parserContext = parserContext;\n        preProcess();\n        Class beanClass = null;\n        if (allowClassAttribute)\n        {\n            beanClass = getBeanClassFromAttribute(element);\n        }\n        if (beanClass == null)\n        {\n            beanClass = getBeanClass(element);\n        }\n        Assert.state(beanClass != null, \"Class returned from getBeanClass(Element) must not be null, element is: \" + element.getNodeName());\n        BeanDefinitionBuilder builder = createBeanDefinitionBuilder(element, beanClass);\n        builder.setSource(parserContext.extractSource(element));\n        builder.setSingleton(isSingleton());\n        builder.addDependsOn(\"_muleRegistry\");\n\n        List interfaces = ClassUtils.getAllInterfaces(beanClass);\n        if(interfaces!=null)\n        {\n            if(interfaces.contains(Initialisable.class))\n            {\n                builder.setInitMethodName(Initialisable.PHASE_NAME);\n            }\n\n            if(interfaces.contains(Disposable.class))\n            {\n                builder.setDestroyMethodName(Disposable.PHASE_NAME);\n            }\n        }\n\n        if (parserContext.isNested())\n        {\n            // Inner bean definition must receive same singleton status as containing bean.\n            builder.setSingleton(parserContext.getContainingBeanDefinition().isSingleton());\n        }\n        doParse(element, parserContext, builder);\n        return builder.getBeanDefinition();\n    }","commit_id":"85aa31ee81df5f7b9955ba9d15f9b551a9474fe0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void registerValueMapping(PropertyToolkit.ValueMap mapping)\n    {\n        propertyToolkit.registerValueMapping(mapping);\n    }","id":93878,"modified_method":"public void registerValueMapping(ValueMap mapping)\n    {\n        valueMappings.put(mapping.getPropertyName(), mapping);\n    }","commit_id":"85aa31ee81df5f7b9955ba9d15f9b551a9474fe0","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void processProperty(Attr attribute, BeanDefinitionBuilder builder)\n    {\n        boolean isBeanReference = propertyToolkit.isBeanReference(attribute.getNodeName());\n        String propertyName = propertyToolkit.extractPropertyName(attribute.getNodeName());\n        String propertyValue = propertyToolkit.extractPropertyValue(propertyName, attribute.getValue());\n        Assert.state(StringUtils.hasText(propertyName),\n                \"Illegal property name returned from 'extractPropertyName(String)': cannot be null or empty.\");\n\n        // The property may be a reference to another bean.\n        if (isBeanReference)\n        {\n            builder.addPropertyReference(propertyName, propertyValue);\n        }\n        else\n        {\n            builder.addPropertyValue(propertyName, propertyValue);\n        }\n    }","id":93879,"modified_method":"protected void processProperty(Attr attribute, BeanDefinitionBuilder builder)\n    {\n        boolean isBeanReference = isBeanReference(attribute.getNodeName());\n        String propertyName = extractPropertyName(attribute.getNodeName());\n        String propertyValue = extractPropertyValue(propertyName, attribute.getValue());\n        Assert.state(StringUtils.hasText(propertyName),\n                \"Illegal property name returned from 'extractPropertyName(String)': cannot be null or empty.\");\n\n        // The property may be a reference to another bean.\n        if (isBeanReference)\n        {\n            builder.addPropertyReference(propertyName, propertyValue);\n        }\n        else\n        {\n            builder.addPropertyValue(propertyName, propertyValue);\n        }\n    }","commit_id":"85aa31ee81df5f7b9955ba9d15f9b551a9474fe0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void registerAttributeMapping(String alias, String propertyName)\n    {\n        propertyToolkit.registerAttributeMapping(alias, propertyName);\n    }","id":93880,"modified_method":"protected void registerAttributeMapping(String alias, String propertyName)\n    {\n        attributeMappings.put(alias, propertyName);\n    }","commit_id":"85aa31ee81df5f7b9955ba9d15f9b551a9474fe0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void registerBeanReference(String propertyName)\n    {\n        propertyToolkit.registerBeanReference(propertyName);\n    }","id":93881,"modified_method":"public void registerBeanReference(String propertyName)\n    {\n        beanReferences.add(propertyName);\n    }","commit_id":"85aa31ee81df5f7b9955ba9d15f9b551a9474fe0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"environment-properties\", new MapBeanDefinitionParser(HashMap.class, MuleProperties.OBJECT_MULE_APPLICATION_PROPERTIES));\n        registerBeanDefinitionParser(\"default-threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"default-dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"default-receiver-connection-strategy\", new ConnectionStrategyDefinitionParser());\n\n        //registerBeanDefinitionParser(\"mule-configuration\", new ManagementContextDefinitionParser());\n        registerBeanDefinitionParser(\"threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new SimpleChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-component-exception-strategy\", new SimpleChildDefinitionParser(\"exceptionListener\", DefaultComponentExceptionStrategy.class));\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new SimpleChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new SimpleChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"dispatcher-connection-straqtegy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"receiver-connection-straqtegy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new SingleElementDefinitionParser(true));\n\n        //Transformer elements\n        registerBeanDefinitionParser(\"custom-transformer\", new SingleElementDefinitionParser(false));\n        registerBeanDefinitionParser(\"transformer-no-action\", new SingleElementDefinitionParser(NoActionTransformer.class, false));\n\n        registerBeanDefinitionParser(\"transformer-base64-encoder\", new SingleElementDefinitionParser(Base64Encoder.class, false));\n        registerBeanDefinitionParser(\"transformer-base64-decoder\", new SingleElementDefinitionParser(Base64Decoder.class, false));\n\n        registerBeanDefinitionParser(\"transformer-xml-entity-encoder\", new SingleElementDefinitionParser(XmlEntityEncoder.class, false));\n        registerBeanDefinitionParser(\"transformer-xml-entity-decoder\", new SingleElementDefinitionParser(XmlEntityDecoder.class, false));\n        registerBeanDefinitionParser(\"transformer-gzip-compress\", new SingleElementDefinitionParser(GZipCompressTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-gzip-uncompress\", new SingleElementDefinitionParser(GZipUncompressTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-encrypt\", new SingleElementDefinitionParser(EncryptionTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-decrypt\", new SingleElementDefinitionParser(DecryptionTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-hex-string\", new SingleElementDefinitionParser(ByteArrayToHexString.class, false));\n        registerBeanDefinitionParser(\"transformer-hex-sting-to-byte-array\", new SingleElementDefinitionParser(HexStringToByteArray.class, false));\n\n        registerBeanDefinitionParser(\"transformer-byte-array-to-object\", new SingleElementDefinitionParser(ByteArrayToObject.class, false));\n        registerBeanDefinitionParser(\"transformer-object-to-byte-array\", new SingleElementDefinitionParser(ObjectToByteArray.class, false));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-serializable\", new SingleElementDefinitionParser(ByteArrayToSerializable.class, false));\n        registerBeanDefinitionParser(\"transformer-serializable-to-byte-array\", new SingleElementDefinitionParser(SerializableToByteArray.class, false));\n\n        //Transaction Managers\n        //TODO RM*: Need to review these, since Spring have some facilities for configuring the transactionMaanger\n        registerBeanDefinitionParser(\"jndi-transaction-manager\", new SingleElementDefinitionParser(GenericTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"weblogic-transaction-manager\", new SingleElementDefinitionParser(WeblogicTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"jboss-transaction-manager\", new SingleElementDefinitionParser(JBossTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"jrun-transaction-manager\", new SingleElementDefinitionParser(JRunTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"resin3-transaction-manager\", new SingleElementDefinitionParser(Resin3TransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"websphere-transaction-manager\", new SingleElementDefinitionParser(WebsphereTransactionManagerLookupFactory.class, true));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new EndpointDefinitionParser());\n        registerBeanDefinitionParser(\"endpoint-ref\", new EndpointRefDefinitionParser());\n        registerBeanDefinitionParser(\"transaction\", new TransactionConfigDefinitionParser());\n\n        //Container contexts\n        registerBeanDefinitionParser(\"custom-container\", new SingleElementDefinitionParser(true));\n        registerBeanDefinitionParser(\"rmi-container\", new SingleElementDefinitionParser(RmiContainerContext.class, true));\n        registerBeanDefinitionParser(\"jndi-container\", new SingleElementDefinitionParser(JndiContainerContext.class, true));\n        registerBeanDefinitionParser(\"properties-container\", new SingleElementDefinitionParser(PropertiesContainerContext.class, true));\n\n        //Model Elements\n        registerBeanDefinitionParser(\"model-seda\", new SingleElementDefinitionParser(SedaModel.class, true));\n        registerBeanDefinitionParser(\"model-inherited\", new InheritedModelDefinitionParser());\n        registerBeanDefinitionParser(\"model-seda-optimised\", new SingleElementDefinitionParser(OptimisedSedaModel.class, true));\n        registerBeanDefinitionParser(\"model-simple\", new SingleElementDefinitionParser(DirectModel.class, true));\n        registerBeanDefinitionParser(\"model-pipeline\", new SingleElementDefinitionParser(PipelineModel.class, true));\n        registerBeanDefinitionParser(\"model-streaming\", new SingleElementDefinitionParser(StreamingModel.class, true));\n        registerBeanDefinitionParser(\"model-custom\", new SingleElementDefinitionParser(true));\n\n        registerBeanDefinitionParser(\"component-lifecycle-adapter-factory\", new SimpleChildDefinitionParser(\"lifecycleAdapterFactory\", null));\n        registerBeanDefinitionParser(\"callable-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        registerBeanDefinitionParser(\"custom-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entryPointResolver\", null));\n        //registerBeanDefinitionParser(\"method-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"reflection-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"non-void-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entrypointResolver\", NonVoidEntryPointResolver.class));\n\n        //Service Elements\n        registerBeanDefinitionParser(\"service\", new ServiceDescriptorDefinitionParser());\n        registerBeanDefinitionParser(\"component\", new ObjectFactoryDefinitionParser(\"serviceFactory\"));\n        registerBeanDefinitionParser(\"inbound-router\", new SimpleChildDefinitionParser(\"inboundRouter\", InboundRouterCollection.class));\n        registerBeanDefinitionParser(\"outbound-router\", new SimpleChildDefinitionParser(\"outboundRouter\", OutboundRouterCollection.class));\n        registerBeanDefinitionParser(\"nested-router\", new SimpleChildDefinitionParser(\"nestedRouter\", NestedRouterCollection.class));\n        registerBeanDefinitionParser(\"response-router\", new SimpleChildDefinitionParser(\"responseRouter\", ResponseRouterCollection.class));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"pass-through-router\", new RouterDefinitionParser(\"router\", InboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentReceiver.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentSecureHashReceiver.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new RouterDefinitionParser(\"router\", SelectiveConsumer.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new RouterDefinitionParser(\"router\", WireTap.class));\n        registerBeanDefinitionParser(\"correlation-aggregator-router\", new RouterDefinitionParser(\"router\", CorrelationAggregator.class));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new RouterDefinitionParser(\"router\", MessageChunkingAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new RouterDefinitionParser(\"router\", CorrelationEventResequencer.class));\n        registerBeanDefinitionParser(\"custom-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Nested binding\n        registerBeanDefinitionParser(\"binding\", new RouterDefinitionParser(\"router\", NestedRouter.class));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"pass-through-router\", new RouterDefinitionParser(\"router\", OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(\"router\", FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(\"router\", ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(\"router\", EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(\"router\", ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(\"router\", FilteringListMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(\"router\", MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(\"router\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(\"router\", StaticRecipientList.class));\n        registerBeanDefinitionParser(\"template-endpoint-router\", new RouterDefinitionParser(\"router\", TemplateEndpointRouter.class));\n        registerBeanDefinitionParser(\"custom-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new SimpleChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new SimpleChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Retry strategies\n        registerBeanDefinitionParser(\"retry-connection-strategy\", new SimpleChildDefinitionParser(\"connectionStrategy\", SimpleRetryConnectionStrategy.class));\n\n        // Utils / Standard Types\n        registerBeanDefinitionParser(\"properties\", new PropertiesBeanDefinitionParser(\"properties\"));\n        registerBeanDefinitionParser(\"jndi-provider-properties\", new PropertiesBeanDefinitionParser(\"jndiProviderProperties\"));\n\n        // Security\n        registerBeanDefinitionParser(\"security-manager\", new SecurityManagerParser());\n        registerBeanDefinitionParser(\"custom-security-provider\", new CustomSecurityProviderDefinitionParser());\n    }","id":93882,"modified_method":"public void init()\n    {\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"environment-properties\", new MapBeanDefinitionParser(HashMap.class, MuleProperties.OBJECT_MULE_APPLICATION_PROPERTIES));\n        registerBeanDefinitionParser(\"default-threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"default-dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"default-receiver-connection-strategy\", new ConnectionStrategyDefinitionParser());\n\n        //registerBeanDefinitionParser(\"mule-configuration\", new ManagementContextDefinitionParser());\n        registerBeanDefinitionParser(\"threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new SimpleChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-component-exception-strategy\", new SimpleChildDefinitionParser(\"exceptionListener\", DefaultComponentExceptionStrategy.class));\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new SimpleChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new SimpleChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"dispatcher-connection-straqtegy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"receiver-connection-straqtegy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new SingleElementDefinitionParser(true));\n\n        //Transformer elements\n        registerBeanDefinitionParser(\"custom-transformer\", new SingleElementDefinitionParser(false));\n        registerBeanDefinitionParser(\"transformer-no-action\", new SingleElementDefinitionParser(NoActionTransformer.class, false));\n\n        registerBeanDefinitionParser(\"transformer-base64-encoder\", new SingleElementDefinitionParser(Base64Encoder.class, false));\n        registerBeanDefinitionParser(\"transformer-base64-decoder\", new SingleElementDefinitionParser(Base64Decoder.class, false));\n\n        registerBeanDefinitionParser(\"transformer-xml-entity-encoder\", new SingleElementDefinitionParser(XmlEntityEncoder.class, false));\n        registerBeanDefinitionParser(\"transformer-xml-entity-decoder\", new SingleElementDefinitionParser(XmlEntityDecoder.class, false));\n        registerBeanDefinitionParser(\"transformer-gzip-compress\", new SingleElementDefinitionParser(GZipCompressTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-gzip-uncompress\", new SingleElementDefinitionParser(GZipUncompressTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-encrypt\", new SingleElementDefinitionParser(EncryptionTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-decrypt\", new SingleElementDefinitionParser(DecryptionTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-hex-string\", new SingleElementDefinitionParser(ByteArrayToHexString.class, false));\n        registerBeanDefinitionParser(\"transformer-hex-sting-to-byte-array\", new SingleElementDefinitionParser(HexStringToByteArray.class, false));\n\n        registerBeanDefinitionParser(\"transformer-byte-array-to-object\", new SingleElementDefinitionParser(ByteArrayToObject.class, false));\n        registerBeanDefinitionParser(\"transformer-object-to-byte-array\", new SingleElementDefinitionParser(ObjectToByteArray.class, false));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-serializable\", new SingleElementDefinitionParser(ByteArrayToSerializable.class, false));\n        registerBeanDefinitionParser(\"transformer-serializable-to-byte-array\", new SingleElementDefinitionParser(SerializableToByteArray.class, false));\n\n        //Transaction Managers\n        //TODO RM*: Need to review these, since Spring have some facilities for configuring the transactionMaanger\n        registerBeanDefinitionParser(\"jndi-transaction-manager\", new SingleElementDefinitionParser(GenericTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"weblogic-transaction-manager\", new SingleElementDefinitionParser(WeblogicTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"jboss-transaction-manager\", new SingleElementDefinitionParser(JBossTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"jrun-transaction-manager\", new SingleElementDefinitionParser(JRunTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"resin3-transaction-manager\", new SingleElementDefinitionParser(Resin3TransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"websphere-transaction-manager\", new SingleElementDefinitionParser(WebsphereTransactionManagerLookupFactory.class, true));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new EndpointDefinitionParser());\n        registerBeanDefinitionParser(\"endpoint-ref\", new EndpointRefDefinitionParser());\n        registerBeanDefinitionParser(\"transaction\", new TransactionConfigDefinitionParser());\n\n        //Container contexts\n        registerBeanDefinitionParser(\"custom-container\", new SingleElementDefinitionParser(true));\n        registerBeanDefinitionParser(\"rmi-container\", new SingleElementDefinitionParser(RmiContainerContext.class, true));\n        registerBeanDefinitionParser(\"jndi-container\", new SingleElementDefinitionParser(JndiContainerContext.class, true));\n        registerBeanDefinitionParser(\"properties-container\", new SingleElementDefinitionParser(PropertiesContainerContext.class, true));\n\n        //Model Elements\n        registerBeanDefinitionParser(\"model-seda\", new SingleElementDefinitionParser(SedaModel.class, true));\n        registerBeanDefinitionParser(\"model-inherited\", new InheritedModelDefinitionParser());\n        registerBeanDefinitionParser(\"model-seda-optimised\", new SingleElementDefinitionParser(OptimisedSedaModel.class, true));\n        registerBeanDefinitionParser(\"model-simple\", new SingleElementDefinitionParser(DirectModel.class, true));\n        registerBeanDefinitionParser(\"model-pipeline\", new SingleElementDefinitionParser(PipelineModel.class, true));\n        registerBeanDefinitionParser(\"model-streaming\", new SingleElementDefinitionParser(StreamingModel.class, true));\n        registerBeanDefinitionParser(\"model-custom\", new SingleElementDefinitionParser(true));\n\n        registerBeanDefinitionParser(\"component-lifecycle-adapter-factory\", new SimpleChildDefinitionParser(\"lifecycleAdapterFactory\", null));\n        registerBeanDefinitionParser(\"callable-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        registerBeanDefinitionParser(\"custom-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entryPointResolver\", null));\n        //registerBeanDefinitionParser(\"method-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"reflection-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"non-void-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entrypointResolver\", NonVoidEntryPointResolver.class));\n\n        //Service Elements\n        registerBeanDefinitionParser(\"service\", new ServiceDescriptorDefinitionParser());\n        registerBeanDefinitionParser(\"component\", new ObjectFactoryDefinitionParser(\"serviceFactory\"));\n        registerBeanDefinitionParser(\"inbound-router\", new SimpleChildDefinitionParser(\"inboundRouter\", InboundRouterCollection.class));\n        registerBeanDefinitionParser(\"outbound-router\", new SimpleChildDefinitionParser(\"outboundRouter\", OutboundRouterCollection.class));\n        registerBeanDefinitionParser(\"nested-router\", new SimpleChildDefinitionParser(\"nestedRouter\", NestedRouterCollection.class));\n        registerBeanDefinitionParser(\"response-router\", new SimpleChildDefinitionParser(\"responseRouter\", ResponseRouterCollection.class));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"pass-through-router\", new RouterDefinitionParser(\"router\", InboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentReceiver.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentSecureHashReceiver.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new RouterDefinitionParser(\"router\", SelectiveConsumer.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new RouterDefinitionParser(\"router\", WireTap.class));\n        registerBeanDefinitionParser(\"correlation-aggregator-router\", new RouterDefinitionParser(\"router\", CorrelationAggregator.class));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new RouterDefinitionParser(\"router\", MessageChunkingAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new RouterDefinitionParser(\"router\", CorrelationEventResequencer.class));\n        registerBeanDefinitionParser(\"custom-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Nested binding\n        registerBeanDefinitionParser(\"binding\", new RouterDefinitionParser(\"router\", NestedRouter.class));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"pass-through-router\", new RouterDefinitionParser(\"router\", OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(\"router\", FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(\"router\", ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(\"router\", EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(\"router\", ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(\"router\", FilteringListMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(\"router\", MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(\"router\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(\"router\", StaticRecipientList.class));\n        registerBeanDefinitionParser(\"template-endpoint-router\", new RouterDefinitionParser(\"router\", TemplateEndpointRouter.class));\n        registerBeanDefinitionParser(\"custom-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new SimpleChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new SimpleChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Retry strategies\n        registerBeanDefinitionParser(\"retry-connection-strategy\", new SimpleChildDefinitionParser(\"connectionStrategy\", SimpleRetryConnectionStrategy.class));\n\n        // Utils / Standard Types\n        registerBeanDefinitionParser(\"properties\", new PropertiesBeanDefinitionParser(\"properties\"));\n        registerBeanDefinitionParser(\"jndi-provider-properties\", new PropertiesBeanDefinitionParser(\"jndiProviderProperties\"));\n    }","commit_id":"85aa31ee81df5f7b9955ba9d15f9b551a9474fe0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void setProviders(Collection providers)\n    {\n        for (Iterator iterator = providers.iterator(); iterator.hasNext();)\n        {\n            UMOSecurityProvider provider = (UMOSecurityProvider) iterator.next();\n            addProvider(provider);\n        }\n    }","id":93883,"modified_method":"public void setProviders(List providers)\n    {\n        for (Iterator iterator = providers.iterator(); iterator.hasNext();)\n        {\n            UMOSecurityProvider provider = (UMOSecurityProvider) iterator.next();\n            addProvider(provider);\n        }\n    }","commit_id":"85aa31ee81df5f7b9955ba9d15f9b551a9474fe0","url":"https://github.com/mulesoft/mule"},{"original_method":"public Collection getProviders()\n    {\n        return Collections.unmodifiableCollection(new ArrayList(providers.values()));\n    }","id":93884,"modified_method":"public List getProviders()\n    {\n        return Collections.unmodifiableList(new ArrayList(providers.values()));\n    }","commit_id":"85aa31ee81df5f7b9955ba9d15f9b551a9474fe0","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n\t * Instantiate the bean using a named factory method. The method may be static, if the\n\t * bean definition parameter specifies a class, rather than a \"factory-bean\", or\n\t * an instance variable on a factory object itself configured using Dependency Injection.\n\t * <p>Implementation requires iterating over the static or instance methods with the\n\t * name specified in the RootBeanDefinition (the method may be overloaded) and trying\n\t * to match with the parameters. We don't have the types attached to constructor args,\n\t * so trial and error is the only way to go here. The explicitArgs array may contain\n\t * argument values passed in programmatically via the corresponding getBean method.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param explicitArgs argument values passed in programmatically via the getBean\n\t * method, or <code>null<\/code> if none (-> use constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t */\n\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tClass factoryClass = null;\n\t\tObject factoryBean = null;\n\t\tboolean isStatic = true;\n\n\t\tString factoryBeanName = mbd.getFactoryBeanName();\n\t\tif (factoryBeanName != null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean == null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n\t\t\t}\n\t\t\tfactoryClass = factoryBean.getClass();\n\t\t\tisStatic = false;\n\t\t}\n\t\telse {\n\t\t\t// It's a static factory method on the bean class.\n\t\t\tfactoryClass = mbd.getBeanClass();\n\t\t}\n\n\t\tMethod factoryMethodToUse = null;\n\t\tObject[] argsToUse = null;\n\n\t\tif (explicitArgs != null) {\n\t\t\targsToUse = explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse != null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse == null) {\n\t\t\t\t\tClass[] paramTypes = factoryMethodToUse.getParameterTypes();\n\t\t\t\t\tObject[] argsToResolve = mbd.preparedConstructorArguments;\n\t\t\t\t\tTypeConverter converter = (this.typeConverter != null ? this.typeConverter : bw);\n\t\t\t\t\tBeanDefinitionValueResolver valueResolver =\n\t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\t\t\t\t\targsToUse = new Object[argsToResolve.length];\n\t\t\t\t\tfor (int i = 0; i < argsToResolve.length; i++) {\n\t\t\t\t\t\tObject argValue = argsToResolve[i];\n\t\t\t\t\t\tMethodParameter methodParam = new MethodParameter(factoryMethodToUse, i);\n\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n\t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n\t\t\t\t\t\t\targValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n\t\t\t\t\t\t\targValue = valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsToUse[i] = converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse == null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tMethod[] candidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n\t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n\t\t\tConstructorArgumentValues resolvedValues = null;\n\n\t\t\tint minNrOfArgs = 0;\n\t\t\tif (explicitArgs != null) {\n\t\t\t\tminNrOfArgs = explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList<Exception> causes = null;\n\n\t\t\tfor (int i = 0; i < candidates.length; i++) {\n\t\t\t\tMethod candidate = candidates[i];\n\t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n\t\t\t\t\t\tparamTypes.length >= minNrOfArgs) {\n\n\t\t\t\t\tArgumentsHolder args = null;\n\n\t\t\t\t\tif (resolvedValues != null) {\n\t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\targs = createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n\t\t\t\t\t\t\t\tif (causes != null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes == null) {\n\t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n\t\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse = candidate;\n\t\t\t\t\t\targsToUse = args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse == null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n\t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n\t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n\t\t\t}\n\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"': needs to have a non-void return type!\");\n\t\t\t}\n\n\t\t\tif (explicitArgs == null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance = this.instantiationStrategy.instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\tif (beanInstance == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}","id":93885,"modified_method":"/**\n\t * Instantiate the bean using a named factory method. The method may be static, if the\n\t * bean definition parameter specifies a class, rather than a \"factory-bean\", or\n\t * an instance variable on a factory object itself configured using Dependency Injection.\n\t * <p>Implementation requires iterating over the static or instance methods with the\n\t * name specified in the RootBeanDefinition (the method may be overloaded) and trying\n\t * to match with the parameters. We don't have the types attached to constructor args,\n\t * so trial and error is the only way to go here. The explicitArgs array may contain\n\t * argument values passed in programmatically via the corresponding getBean method.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param explicitArgs argument values passed in programmatically via the getBean\n\t * method, or <code>null<\/code> if none (-> use constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t */\n\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName = mbd.getFactoryBeanName();\n\t\tif (factoryBeanName != null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean == null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n\t\t\t}\n\t\t\tfactoryClass = factoryBean.getClass();\n\t\t\tisStatic = false;\n\t\t}\n\t\telse {\n\t\t\t// It's a static factory method on the bean class.\n\t\t\tfactoryBean = null;\n\t\t\tfactoryClass = mbd.getBeanClass();\n\t\t\tisStatic = true;\n\t\t}\n\n\t\tMethod factoryMethodToUse = null;\n\t\tObject[] argsToUse = null;\n\n\t\tif (explicitArgs != null) {\n\t\t\targsToUse = explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse != null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse == null) {\n\t\t\t\t\tClass[] paramTypes = factoryMethodToUse.getParameterTypes();\n\t\t\t\t\tObject[] argsToResolve = mbd.preparedConstructorArguments;\n\t\t\t\t\tTypeConverter converter = (this.typeConverter != null ? this.typeConverter : bw);\n\t\t\t\t\tBeanDefinitionValueResolver valueResolver =\n\t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\t\t\t\t\targsToUse = new Object[argsToResolve.length];\n\t\t\t\t\tfor (int i = 0; i < argsToResolve.length; i++) {\n\t\t\t\t\t\tObject argValue = argsToResolve[i];\n\t\t\t\t\t\tMethodParameter methodParam = new MethodParameter(factoryMethodToUse, i);\n\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n\t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n\t\t\t\t\t\t\targValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n\t\t\t\t\t\t\targValue = valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsToUse[i] = converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse == null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tMethod[] candidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n\t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n\t\t\tConstructorArgumentValues resolvedValues = null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs != null) {\n\t\t\t\tminNrOfArgs = explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList<Exception> causes = null;\n\n\t\t\tfor (int i = 0; i < candidates.length; i++) {\n\t\t\t\tMethod candidate = candidates[i];\n\t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n\t\t\t\t\t\tparamTypes.length >= minNrOfArgs) {\n\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues != null) {\n\t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\targs = createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n\t\t\t\t\t\t\t\tif (causes != null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes == null) {\n\t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n\t\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse = candidate;\n\t\t\t\t\t\targsToUse = args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse == null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n\t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n\t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n\t\t\t}\n\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"': needs to have a non-void return type!\");\n\t\t\t}\n\n\t\t\tif (explicitArgs == null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance = this.instantiationStrategy.instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\tif (beanInstance == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}","commit_id":"092de0107cd876d7f8207da7a9fc9ba163cfadfe","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * \"autowire constructor\" (with constructor arguments by type) behavior.\n\t * Also applied if explicit constructor argument values are specified,\n\t * matching all remaining arguments with beans from the bean factory.\n\t * <p>This corresponds to constructor injection: In this mode, a Spring\n\t * bean factory is able to host components that expect constructor-based\n\t * dependency resolution.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param chosenCtors chosen candidate constructors (or <code>null<\/code> if none)\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or <code>null<\/code> if none (-> use constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t */\n\tprotected BeanWrapper autowireConstructor(\n\t\t\tString beanName, RootBeanDefinition mbd, Constructor[] chosenCtors, Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tConstructor constructorToUse = null;\n\t\tObject[] argsToUse = null;\n\n\t\tif (explicitArgs != null) {\n\t\t\targsToUse = explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tconstructorToUse = (Constructor) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (constructorToUse != null) {\n\t\t\t\t// Found a cached constructor...\n\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse == null) {\n\t\t\t\t\tClass[] paramTypes = constructorToUse.getParameterTypes();\n\t\t\t\t\tObject[] argsToResolve = mbd.preparedConstructorArguments;\n\t\t\t\t\tTypeConverter converter = (this.typeConverter != null ? this.typeConverter : bw);\n\t\t\t\t\tBeanDefinitionValueResolver valueResolver =\n\t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\t\t\t\t\targsToUse = new Object[argsToResolve.length];\n\t\t\t\t\tfor (int i = 0; i < argsToResolve.length; i++) {\n\t\t\t\t\t\tObject argValue = argsToResolve[i];\n\t\t\t\t\t\tMethodParameter methodParam = new MethodParameter(constructorToUse, i);\n\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, constructorToUse.getDeclaringClass());\n\t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n\t\t\t\t\t\t\targValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n\t\t\t\t\t\t\targValue = valueResolver.resolveValueIfNecessary(\"constructor argument\", argValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsToUse[i] = converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (constructorToUse == null) {\n\t\t\t// Need to resolve the constructor.\n\t\t\tboolean autowiring = (chosenCtors != null ||\n\t\t\t\t\tmbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tConstructorArgumentValues resolvedValues = null;\n\n\t\t\tint minNrOfArgs = 0;\n\t\t\tif (explicitArgs != null) {\n\t\t\t\tminNrOfArgs = explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\t// Take specified constructors, if any.\n\t\t\tConstructor[] candidates =\n\t\t\t\t\t(chosenCtors != null ? chosenCtors : mbd.getBeanClass().getDeclaredConstructors());\n\t\t\tAutowireUtils.sortConstructors(candidates);\n\t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n\n\t\t\tfor (int i = 0; i < candidates.length; i++) {\n\t\t\t\tConstructor candidate = candidates[i];\n\t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n\n\t\t\t\tif (constructorToUse != null && argsToUse.length > paramTypes.length) {\n\t\t\t\t\t// Already found greedy constructor that can be satisfied ->\n\t\t\t\t\t// do not look any further, there are only less greedy constructors left.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (paramTypes.length < minNrOfArgs) {\n\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\tminNrOfArgs + \" constructor arguments specified but no matching constructor found in bean '\" +\n\t\t\t\t\t\t\tbeanName + \"' \" +\n\t\t\t\t\t\t\t\"(hint: specify index and/or type arguments for simple parameters to avoid type ambiguities)\");\n\t\t\t\t}\n\n\t\t\t\tArgumentsHolder args = null;\n\t\t\t\tList<Exception> causes = null;\n\n\t\t\t\tif (resolvedValues != null) {\n\t\t\t\t\t// Try to resolve arguments for current constructor.\n\t\t\t\t\ttry {\n\t\t\t\t\t\targs = createArgumentArray(\n\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\n\t\t\t\t\t\t\t\t\t\"Ignoring constructor [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i == candidates.length - 1 && constructorToUse == null) {\n\t\t\t\t\t\t\tif (causes != null) {\n\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// Swallow and try next constructor.\n\t\t\t\t\t\t\tif (causes == null) {\n\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n\t\t\t\t}\n\n\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n\t\t\t\t\tconstructorToUse = candidate;\n\t\t\t\t\targsToUse = args.arguments;\n\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (constructorToUse == null) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Could not resolve matching constructor\");\n\t\t\t}\n\n\t\t\tif (explicitArgs == null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod = constructorToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance = this.instantiationStrategy.instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, constructorToUse, argsToUse);\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}","id":93886,"modified_method":"/**\n\t * \"autowire constructor\" (with constructor arguments by type) behavior.\n\t * Also applied if explicit constructor argument values are specified,\n\t * matching all remaining arguments with beans from the bean factory.\n\t * <p>This corresponds to constructor injection: In this mode, a Spring\n\t * bean factory is able to host components that expect constructor-based\n\t * dependency resolution.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param chosenCtors chosen candidate constructors (or <code>null<\/code> if none)\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or <code>null<\/code> if none (-> use constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t */\n\tpublic BeanWrapper autowireConstructor(\n\t\t\tString beanName, RootBeanDefinition mbd, Constructor[] chosenCtors, Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tConstructor constructorToUse = null;\n\t\tObject[] argsToUse = null;\n\n\t\tif (explicitArgs != null) {\n\t\t\targsToUse = explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tconstructorToUse = (Constructor) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (constructorToUse != null) {\n\t\t\t\t// Found a cached constructor...\n\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse == null) {\n\t\t\t\t\tClass[] paramTypes = constructorToUse.getParameterTypes();\n\t\t\t\t\tObject[] argsToResolve = mbd.preparedConstructorArguments;\n\t\t\t\t\tTypeConverter converter = (this.typeConverter != null ? this.typeConverter : bw);\n\t\t\t\t\tBeanDefinitionValueResolver valueResolver =\n\t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\t\t\t\t\targsToUse = new Object[argsToResolve.length];\n\t\t\t\t\tfor (int i = 0; i < argsToResolve.length; i++) {\n\t\t\t\t\t\tObject argValue = argsToResolve[i];\n\t\t\t\t\t\tMethodParameter methodParam = new MethodParameter(constructorToUse, i);\n\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, constructorToUse.getDeclaringClass());\n\t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n\t\t\t\t\t\t\targValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n\t\t\t\t\t\t\targValue = valueResolver.resolveValueIfNecessary(\"constructor argument\", argValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsToUse[i] = converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (constructorToUse == null) {\n\t\t\t// Need to resolve the constructor.\n\t\t\tboolean autowiring = (chosenCtors != null ||\n\t\t\t\t\tmbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tConstructorArgumentValues resolvedValues = null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs != null) {\n\t\t\t\tminNrOfArgs = explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\t// Take specified constructors, if any.\n\t\t\tConstructor[] candidates = chosenCtors;\n\t\t\tif (candidates == null) {\n\t\t\t\tClass beanClass = mbd.getBeanClass();\n\t\t\t\ttry {\n\t\t\t\t\tcandidates = beanClass.getDeclaredConstructors();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\"Resolution of declared constructors on bean Class [\" + beanClass.getName() +\n\t\t\t\t\t\t\t\t\t\"] from ClassLoader [\" + beanClass.getClassLoader() + \"] failed\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tAutowireUtils.sortConstructors(candidates);\n\t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n\n\t\t\tfor (int i = 0; i < candidates.length; i++) {\n\t\t\t\tConstructor candidate = candidates[i];\n\t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n\n\t\t\t\tif (constructorToUse != null && argsToUse.length > paramTypes.length) {\n\t\t\t\t\t// Already found greedy constructor that can be satisfied ->\n\t\t\t\t\t// do not look any further, there are only less greedy constructors left.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (paramTypes.length < minNrOfArgs) {\n\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\tminNrOfArgs + \" constructor arguments specified but no matching constructor found in bean '\" +\n\t\t\t\t\t\t\tbeanName + \"' \" +\n\t\t\t\t\t\t\t\"(hint: specify index and/or type arguments for simple parameters to avoid type ambiguities)\");\n\t\t\t\t}\n\n\t\t\t\tArgumentsHolder args;\n\t\t\t\tList<Exception> causes = null;\n\n\t\t\t\tif (resolvedValues != null) {\n\t\t\t\t\t// Try to resolve arguments for current constructor.\n\t\t\t\t\ttry {\n\t\t\t\t\t\targs = createArgumentArray(\n\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\n\t\t\t\t\t\t\t\t\t\"Ignoring constructor [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i == candidates.length - 1 && constructorToUse == null) {\n\t\t\t\t\t\t\tif (causes != null) {\n\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// Swallow and try next constructor.\n\t\t\t\t\t\t\tif (causes == null) {\n\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n\t\t\t\t}\n\n\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n\t\t\t\t\tconstructorToUse = candidate;\n\t\t\t\t\targsToUse = args.arguments;\n\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (constructorToUse == null) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Could not resolve matching constructor\");\n\t\t\t}\n\n\t\t\tif (explicitArgs == null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod = constructorToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance = this.instantiationStrategy.instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, constructorToUse, argsToUse);\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}","commit_id":"092de0107cd876d7f8207da7a9fc9ba163cfadfe","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n     * Creates a {@link BeanDefinitionBuilder} instance for the\n     * {@link #getBeanClass bean Class} and passes it to the\n     * {@link #doParse} strategy method.\n     *\n     * @param element       the element that is to be parsed into a single BeanDefinition\n     * @param parserContext the object encapsulating the current state of the parsing process\n     * @return the BeanDefinition resulting from the parsing of the supplied {@link Element}\n     * @throws IllegalStateException if the bean {@link Class} returned from\n     *                               {@link #getBeanClass(org.w3c.dom.Element)} is <code>null<\/code>\n     * @see #doParse\n     */\n    protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext)\n    {\n        this.parserContext = parserContext;\n        preProcess();\n        Class beanClass = getBeanClass(element);\n        Assert.state(beanClass != null, \"Class returned from getBeanClass(Element) must not be null, element is: \" + element.getNodeName());\n        BeanDefinitionBuilder builder = createBeanDefinitionBuilder(element, beanClass);\n        builder.setSource(parserContext.extractSource(element));\n        builder.setSingleton(isSingleton());\n        builder.addDependsOn(\"_muleRegistry\");\n\n        List interfaces = ClassUtils.getAllInterfaces(beanClass);\n        if(interfaces!=null)\n        {\n            if(interfaces.contains(Initialisable.class))\n            {\n                builder.setInitMethodName(Initialisable.PHASE_NAME);\n            }\n\n            if(interfaces.contains(Disposable.class))\n            {\n                builder.setDestroyMethodName(Disposable.PHASE_NAME);\n            }\n        }\n\n        if (parserContext.isNested())\n        {\n            // Inner bean definition must receive same singleton status as containing bean.\n            builder.setSingleton(parserContext.getContainingBeanDefinition().isSingleton());\n        }\n        doParse(element, parserContext, builder);\n        return builder.getBeanDefinition();\n    }","id":93887,"modified_method":"/**\n     * Creates a {@link BeanDefinitionBuilder} instance for the\n     * {@link #getBeanClass bean Class} and passes it to the\n     * {@link #doParse} strategy method.\n     *\n     * @param element       the element that is to be parsed into a single BeanDefinition\n     * @param parserContext the object encapsulating the current state of the parsing process\n     * @return the BeanDefinition resulting from the parsing of the supplied {@link Element}\n     * @throws IllegalStateException if the bean {@link Class} returned from\n     *                               {@link #getBeanClass(org.w3c.dom.Element)} is <code>null<\/code>\n     * @see #doParse\n     */\n    protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext)\n    {\n        this.parserContext = parserContext;\n        preProcess();\n        Class beanClass = null;\n        if (allowClassAttribute)\n        {\n            beanClass = getBeanClassFromAttribute(element);\n        }\n        if (beanClass == null)\n        {\n            beanClass = getBeanClass(element);\n        }\n        Assert.state(beanClass != null, \"Class returned from getBeanClass(Element) must not be null, element is: \" + element.getNodeName());\n        BeanDefinitionBuilder builder = createBeanDefinitionBuilder(element, beanClass);\n        builder.setSource(parserContext.extractSource(element));\n        builder.setSingleton(isSingleton());\n        builder.addDependsOn(\"_muleRegistry\");\n\n        List interfaces = ClassUtils.getAllInterfaces(beanClass);\n        if(interfaces!=null)\n        {\n            if(interfaces.contains(Initialisable.class))\n            {\n                builder.setInitMethodName(Initialisable.PHASE_NAME);\n            }\n\n            if(interfaces.contains(Disposable.class))\n            {\n                builder.setDestroyMethodName(Disposable.PHASE_NAME);\n            }\n        }\n\n        if (parserContext.isNested())\n        {\n            // Inner bean definition must receive same singleton status as containing bean.\n            builder.setSingleton(parserContext.getContainingBeanDefinition().isSingleton());\n        }\n        doParse(element, parserContext, builder);\n        return builder.getBeanDefinition();\n    }","commit_id":"9fcde0c6e4d58336adc3f797eb76a14eb3346264","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"environment-properties\", new MapBeanDefinitionParser(HashMap.class, MuleProperties.OBJECT_MULE_APPLICATION_PROPERTIES));\n        registerBeanDefinitionParser(\"default-threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"default-dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"default-receiver-connection-strategy\", new ConnectionStrategyDefinitionParser());\n\n        //registerBeanDefinitionParser(\"mule-configuration\", new ManagementContextDefinitionParser());\n        registerBeanDefinitionParser(\"threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new SimpleChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-component-exception-strategy\", new SimpleChildDefinitionParser(\"exceptionListener\", DefaultComponentExceptionStrategy.class));\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new SimpleChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new SimpleChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"dispatcher-connection-straqtegy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"receiver-connection-straqtegy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new CustomElementDefinitionParser(true));\n\n        //Transformer elements\n        registerBeanDefinitionParser(\"custom-transformer\", new CustomElementDefinitionParser(false));\n        registerBeanDefinitionParser(\"transformer-no-action\", new SingleElementDefinitionParser(NoActionTransformer.class, false));\n\n        registerBeanDefinitionParser(\"transformer-base64-encoder\", new SingleElementDefinitionParser(Base64Encoder.class, false));\n        registerBeanDefinitionParser(\"transformer-base64-decoder\", new SingleElementDefinitionParser(Base64Decoder.class, false));\n\n        registerBeanDefinitionParser(\"transformer-xml-entity-encoder\", new SingleElementDefinitionParser(XmlEntityEncoder.class, false));\n        registerBeanDefinitionParser(\"transformer-xml-entity-decoder\", new SingleElementDefinitionParser(XmlEntityDecoder.class, false));\n        registerBeanDefinitionParser(\"transformer-gzip-compress\", new SingleElementDefinitionParser(GZipCompressTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-gzip-uncompress\", new SingleElementDefinitionParser(GZipUncompressTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-encrypt\", new SingleElementDefinitionParser(EncryptionTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-decrypt\", new SingleElementDefinitionParser(DecryptionTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-hex-string\", new SingleElementDefinitionParser(ByteArrayToHexString.class, false));\n        registerBeanDefinitionParser(\"transformer-hex-sting-to-byte-array\", new SingleElementDefinitionParser(HexStringToByteArray.class, false));\n\n        registerBeanDefinitionParser(\"transformer-byte-array-to-object\", new SingleElementDefinitionParser(ByteArrayToObject.class, false));\n        registerBeanDefinitionParser(\"transformer-object-to-byte-array\", new SingleElementDefinitionParser(ObjectToByteArray.class, false));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-serializable\", new SingleElementDefinitionParser(ByteArrayToSerializable.class, false));\n        registerBeanDefinitionParser(\"transformer-serializable-to-byte-array\", new SingleElementDefinitionParser(SerializableToByteArray.class, false));\n\n        //Transaction Managers\n        //TODO RM*: Need to review these, since Spring have some facilities for configuring the transactionMaanger\n        registerBeanDefinitionParser(\"jndi-transaction-manager\", new SingleElementDefinitionParser(GenericTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"weblogic-transaction-manager\", new SingleElementDefinitionParser(WeblogicTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"jboss-transaction-manager\", new SingleElementDefinitionParser(JBossTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"jrun-transaction-manager\", new SingleElementDefinitionParser(JRunTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"resin3-transaction-manager\", new SingleElementDefinitionParser(Resin3TransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"websphere-transaction-manager\", new SingleElementDefinitionParser(WebsphereTransactionManagerLookupFactory.class, true));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new EndpointDefinitionParser());\n        registerBeanDefinitionParser(\"endpoint-ref\", new EndpointRefDefinitionParser());\n        registerBeanDefinitionParser(\"transaction\", new TransactionConfigDefinitionParser());\n\n        //Container contexts\n        registerBeanDefinitionParser(\"custom-container\", new CustomElementDefinitionParser(true));\n        registerBeanDefinitionParser(\"rmi-container\", new SingleElementDefinitionParser(RmiContainerContext.class, true));\n        registerBeanDefinitionParser(\"jndi-container\", new SingleElementDefinitionParser(JndiContainerContext.class, true));\n        registerBeanDefinitionParser(\"properties-container\", new SingleElementDefinitionParser(PropertiesContainerContext.class, true));\n\n        //Model Elements\n        registerBeanDefinitionParser(\"model-seda\", new SingleElementDefinitionParser(SedaModel.class, true));\n        registerBeanDefinitionParser(\"model-inherited\", new InheritedModelDefinitionParser());\n        registerBeanDefinitionParser(\"model-seda-optimised\", new SingleElementDefinitionParser(OptimisedSedaModel.class, true));\n        registerBeanDefinitionParser(\"model-simple\", new SingleElementDefinitionParser(DirectModel.class, true));\n        registerBeanDefinitionParser(\"model-pipeline\", new SingleElementDefinitionParser(PipelineModel.class, true));\n        registerBeanDefinitionParser(\"model-streaming\", new SingleElementDefinitionParser(StreamingModel.class, true));\n        registerBeanDefinitionParser(\"model-custom\", new CustomElementDefinitionParser(true));\n\n        registerBeanDefinitionParser(\"component-lifecycle-adapter-factory\", new SimpleChildDefinitionParser(\"lifecycleAdapterFactory\", null));\n        registerBeanDefinitionParser(\"callable-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        registerBeanDefinitionParser(\"custom-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entryPointResolver\", null));\n        //registerBeanDefinitionParser(\"method-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"reflection-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"non-void-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entrypointResolver\", NonVoidEntryPointResolver.class));\n\n        //Service Elements\n        registerBeanDefinitionParser(\"service\", new ServiceDescriptorDefinitionParser());\n        registerBeanDefinitionParser(\"inbound-router\", new SimpleChildDefinitionParser(\"inboundRouter\", InboundRouterCollection.class));\n        registerBeanDefinitionParser(\"outbound-router\", new SimpleChildDefinitionParser(\"outboundRouter\", OutboundRouterCollection.class));\n        registerBeanDefinitionParser(\"nested-router\", new SimpleChildDefinitionParser(\"nestedRouter\", NestedRouterCollection.class));\n        registerBeanDefinitionParser(\"response-router\", new SimpleChildDefinitionParser(\"responseRouter\", ResponseRouterCollection.class));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"pass-through-router\", new RouterDefinitionParser(\"router\", InboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentReceiver.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentSecureHashReceiver.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new RouterDefinitionParser(\"router\", SelectiveConsumer.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new RouterDefinitionParser(\"router\", WireTap.class));\n        registerBeanDefinitionParser(\"correlation-aggregator-router\", new RouterDefinitionParser(\"router\", CorrelationAggregator.class));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new RouterDefinitionParser(\"router\", MessageChunkingAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new RouterDefinitionParser(\"router\", CorrelationEventResequencer.class));\n        registerBeanDefinitionParser(\"custom-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Nested binding\n        registerBeanDefinitionParser(\"binding\", new RouterDefinitionParser(\"router\", NestedRouter.class));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"pass-through-router\", new RouterDefinitionParser(\"router\", OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(\"router\", FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(\"router\", ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(\"router\", EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(\"router\", ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(\"router\", FilteringListMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(\"router\", MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(\"router\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(\"router\", StaticRecipientList.class));\n        registerBeanDefinitionParser(\"template-endpoint-router\", new RouterDefinitionParser(\"router\", TemplateEndpointRouter.class));\n        registerBeanDefinitionParser(\"custom-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new SimpleChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new SimpleChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Retry strategies\n        registerBeanDefinitionParser(\"retry-connection-strategy\", new SimpleChildDefinitionParser(\"connectionStrategy\", SimpleRetryConnectionStrategy.class));\n\n        // Utils / Standard Types\n        registerBeanDefinitionParser(\"properties\", new PropertiesBeanDefinitionParser(\"properties\"));\n        registerBeanDefinitionParser(\"jndi-provider-properties\", new PropertiesBeanDefinitionParser(\"jndiProviderProperties\"));\n    }","id":93888,"modified_method":"public void init()\n    {\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"environment-properties\", new MapBeanDefinitionParser(HashMap.class, MuleProperties.OBJECT_MULE_APPLICATION_PROPERTIES));\n        registerBeanDefinitionParser(\"default-threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"default-dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"default-receiver-connection-strategy\", new ConnectionStrategyDefinitionParser());\n\n        //registerBeanDefinitionParser(\"mule-configuration\", new ManagementContextDefinitionParser());\n        registerBeanDefinitionParser(\"threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new SimpleChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-component-exception-strategy\", new SimpleChildDefinitionParser(\"exceptionListener\", DefaultComponentExceptionStrategy.class));\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new SimpleChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new SimpleChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"dispatcher-connection-straqtegy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"receiver-connection-straqtegy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new SingleElementDefinitionParser(true));\n\n        //Transformer elements\n        registerBeanDefinitionParser(\"custom-transformer\", new SingleElementDefinitionParser(false));\n        registerBeanDefinitionParser(\"transformer-no-action\", new SingleElementDefinitionParser(NoActionTransformer.class, false));\n\n        registerBeanDefinitionParser(\"transformer-base64-encoder\", new SingleElementDefinitionParser(Base64Encoder.class, false));\n        registerBeanDefinitionParser(\"transformer-base64-decoder\", new SingleElementDefinitionParser(Base64Decoder.class, false));\n\n        registerBeanDefinitionParser(\"transformer-xml-entity-encoder\", new SingleElementDefinitionParser(XmlEntityEncoder.class, false));\n        registerBeanDefinitionParser(\"transformer-xml-entity-decoder\", new SingleElementDefinitionParser(XmlEntityDecoder.class, false));\n        registerBeanDefinitionParser(\"transformer-gzip-compress\", new SingleElementDefinitionParser(GZipCompressTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-gzip-uncompress\", new SingleElementDefinitionParser(GZipUncompressTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-encrypt\", new SingleElementDefinitionParser(EncryptionTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-decrypt\", new SingleElementDefinitionParser(DecryptionTransformer.class, false));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-hex-string\", new SingleElementDefinitionParser(ByteArrayToHexString.class, false));\n        registerBeanDefinitionParser(\"transformer-hex-sting-to-byte-array\", new SingleElementDefinitionParser(HexStringToByteArray.class, false));\n\n        registerBeanDefinitionParser(\"transformer-byte-array-to-object\", new SingleElementDefinitionParser(ByteArrayToObject.class, false));\n        registerBeanDefinitionParser(\"transformer-object-to-byte-array\", new SingleElementDefinitionParser(ObjectToByteArray.class, false));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-serializable\", new SingleElementDefinitionParser(ByteArrayToSerializable.class, false));\n        registerBeanDefinitionParser(\"transformer-serializable-to-byte-array\", new SingleElementDefinitionParser(SerializableToByteArray.class, false));\n\n        //Transaction Managers\n        //TODO RM*: Need to review these, since Spring have some facilities for configuring the transactionMaanger\n        registerBeanDefinitionParser(\"jndi-transaction-manager\", new SingleElementDefinitionParser(GenericTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"weblogic-transaction-manager\", new SingleElementDefinitionParser(WeblogicTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"jboss-transaction-manager\", new SingleElementDefinitionParser(JBossTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"jrun-transaction-manager\", new SingleElementDefinitionParser(JRunTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"resin3-transaction-manager\", new SingleElementDefinitionParser(Resin3TransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"websphere-transaction-manager\", new SingleElementDefinitionParser(WebsphereTransactionManagerLookupFactory.class, true));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new EndpointDefinitionParser());\n        registerBeanDefinitionParser(\"endpoint-ref\", new EndpointRefDefinitionParser());\n        registerBeanDefinitionParser(\"transaction\", new TransactionConfigDefinitionParser());\n\n        //Container contexts\n        registerBeanDefinitionParser(\"custom-container\", new SingleElementDefinitionParser(true));\n        registerBeanDefinitionParser(\"rmi-container\", new SingleElementDefinitionParser(RmiContainerContext.class, true));\n        registerBeanDefinitionParser(\"jndi-container\", new SingleElementDefinitionParser(JndiContainerContext.class, true));\n        registerBeanDefinitionParser(\"properties-container\", new SingleElementDefinitionParser(PropertiesContainerContext.class, true));\n\n        //Model Elements\n        registerBeanDefinitionParser(\"model-seda\", new SingleElementDefinitionParser(SedaModel.class, true));\n        registerBeanDefinitionParser(\"model-inherited\", new InheritedModelDefinitionParser());\n        registerBeanDefinitionParser(\"model-seda-optimised\", new SingleElementDefinitionParser(OptimisedSedaModel.class, true));\n        registerBeanDefinitionParser(\"model-simple\", new SingleElementDefinitionParser(DirectModel.class, true));\n        registerBeanDefinitionParser(\"model-pipeline\", new SingleElementDefinitionParser(PipelineModel.class, true));\n        registerBeanDefinitionParser(\"model-streaming\", new SingleElementDefinitionParser(StreamingModel.class, true));\n        registerBeanDefinitionParser(\"model-custom\", new SingleElementDefinitionParser(true));\n\n        registerBeanDefinitionParser(\"component-lifecycle-adapter-factory\", new SimpleChildDefinitionParser(\"lifecycleAdapterFactory\", null));\n        registerBeanDefinitionParser(\"callable-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        registerBeanDefinitionParser(\"custom-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entryPointResolver\", null));\n        //registerBeanDefinitionParser(\"method-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"reflection-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"non-void-entrypoint-resolver\", new SimpleChildDefinitionParser(\"entrypointResolver\", NonVoidEntryPointResolver.class));\n\n        //Service Elements\n        registerBeanDefinitionParser(\"service\", new ServiceDescriptorDefinitionParser());\n        registerBeanDefinitionParser(\"component\", new ObjectFactoryDefinitionParser(\"serviceFactory\"));\n        registerBeanDefinitionParser(\"inbound-router\", new SimpleChildDefinitionParser(\"inboundRouter\", InboundRouterCollection.class));\n        registerBeanDefinitionParser(\"outbound-router\", new SimpleChildDefinitionParser(\"outboundRouter\", OutboundRouterCollection.class));\n        registerBeanDefinitionParser(\"nested-router\", new SimpleChildDefinitionParser(\"nestedRouter\", NestedRouterCollection.class));\n        registerBeanDefinitionParser(\"response-router\", new SimpleChildDefinitionParser(\"responseRouter\", ResponseRouterCollection.class));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"pass-through-router\", new RouterDefinitionParser(\"router\", InboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentReceiver.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentSecureHashReceiver.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new RouterDefinitionParser(\"router\", SelectiveConsumer.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new RouterDefinitionParser(\"router\", WireTap.class));\n        registerBeanDefinitionParser(\"correlation-aggregator-router\", new RouterDefinitionParser(\"router\", CorrelationAggregator.class));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new RouterDefinitionParser(\"router\", MessageChunkingAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new RouterDefinitionParser(\"router\", CorrelationEventResequencer.class));\n        registerBeanDefinitionParser(\"custom-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Nested binding\n        registerBeanDefinitionParser(\"binding\", new RouterDefinitionParser(\"router\", NestedRouter.class));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"pass-through-router\", new RouterDefinitionParser(\"router\", OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(\"router\", FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(\"router\", ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(\"router\", EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(\"router\", ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(\"router\", FilteringListMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(\"router\", MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(\"router\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(\"router\", StaticRecipientList.class));\n        registerBeanDefinitionParser(\"template-endpoint-router\", new RouterDefinitionParser(\"router\", TemplateEndpointRouter.class));\n        registerBeanDefinitionParser(\"custom-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new SimpleChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new SimpleChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser());\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Retry strategies\n        registerBeanDefinitionParser(\"retry-connection-strategy\", new SimpleChildDefinitionParser(\"connectionStrategy\", SimpleRetryConnectionStrategy.class));\n\n        // Utils / Standard Types\n        registerBeanDefinitionParser(\"properties\", new PropertiesBeanDefinitionParser(\"properties\"));\n        registerBeanDefinitionParser(\"jndi-provider-properties\", new PropertiesBeanDefinitionParser(\"jndiProviderProperties\"));\n    }","commit_id":"9fcde0c6e4d58336adc3f797eb76a14eb3346264","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Class getBeanClass(Element element)\n    {\n        if (clazz == null)\n        {\n            String cls = element.getAttribute(ATTRIBUTE_CLASS);\n            try\n            {\n                //TODO TC: probably need to use OSGi Loader here\n                clazz = ClassUtils.loadClass(cls, getClass());\n            }\n            catch (ClassNotFoundException e)\n            {\n                logger.error(\"could not load class: \" + cls, e);\n            }\n        }\n        element.removeAttribute(ATTRIBUTE_CLASS);\n        if (null != clazz && null != constraint && !constraint.isAssignableFrom(clazz))\n        {\n            logger.error(clazz + \" not a subclass of \" + constraint);\n            clazz = null;\n        }\n        return clazz;\n    }","id":93889,"modified_method":"protected Class getBeanClass(Element element)\n    {\n        // This is now handled by AbstractMuleSingleBeanDefinitionParser.getBeanClassFromAttribute()\n//        if (clazz == null)\n//        {\n//            String cls = element.getAttribute(ATTRIBUTE_CLASS);\n//            try\n//            {\n//                //TODO TC: probably need to use OSGi Loader here\n//                clazz = ClassUtils.loadClass(cls, getClass());\n//            }\n//            catch (ClassNotFoundException e)\n//            {\n//                logger.error(\"could not load class: \" + cls, e);\n//            }\n//        }\n//        element.removeAttribute(ATTRIBUTE_CLASS);\n        if (null != clazz && null != constraint && !constraint.isAssignableFrom(clazz))\n        {\n            logger.error(clazz + \" not a subclass of \" + constraint);\n            clazz = null;\n        }\n        return clazz;\n    }","commit_id":"9fcde0c6e4d58336adc3f797eb76a14eb3346264","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Class getBeanClass(Element element)\n    {\n        if(beanClass==null)\n        {\n            String cls = element.getAttribute(\"class\");\n            try\n            {\n                //TODO TC: probably need to use OSGi Loader here\n                beanClass = ClassUtils.loadClass(cls, getClass());\n            }\n            catch (ClassNotFoundException e)\n            {\n                logger.error(\"could not load class: \" + cls, e);\n            }\n        }\n        element.removeAttribute(\"class\");\n        return beanClass;\n    }","id":93890,"modified_method":"protected Class getBeanClass(Element element)\n    {\n        return beanClass;\n    }","commit_id":"9fcde0c6e4d58336adc3f797eb76a14eb3346264","url":"https://github.com/mulesoft/mule"},{"original_method":"public int getChildCollectionCount() throws XMLDBException {\n\t\tif (childCollections == null)\n\t\t\treadCollection();\n\t\treturn childCollections.size();\n\t}","id":93891,"modified_method":"public int getChildCollectionCount() throws XMLDBException {\n\t\t//  AF Always refresh cache for latest set - if (childCollections == null)\n\t\treadCollection();\n\t\treturn childCollections.size();\n\t}","commit_id":"8a294f523e638ce4757490856acfa4d0467fdcb8","url":"https://github.com/eXist-db/exist"},{"original_method":"public Collection getChildCollection(XmldbURI name) throws XMLDBException {\n\t\tif (childCollections == null)\n\t\treadCollection();\n\t\tif (name.numSegments()>1)\n\t\t\treturn (Collection) childCollections.get(name);\n\t\telse\n\t\t\treturn (Collection) childCollections.get(getPathURI().append(name));\n\t}","id":93892,"modified_method":"public Collection getChildCollection(XmldbURI name) throws XMLDBException {\n\t\t// AF get the child collection refreshing cache from server if not found\n\t\treturn getChildCollection(name,true);\n\t}","commit_id":"8a294f523e638ce4757490856acfa4d0467fdcb8","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t *  Returns a list of collection names naming all child collections of the\n\t *  current collection. Only the name of the collection is returned - not\n\t *  the entire path to the collection.\n\t *\n\t *@return                     Description of the Return Value\n\t *@exception  XMLDBException  Description of the Exception\n\t */\n\tpublic String[] listChildCollections() throws XMLDBException {\n\t\tif (childCollections == null)\n\t\t\treadCollection();\n\t\tString coll[] = new String[childCollections.size()];\n\t\tint j = 0;\n\t\tXmldbURI uri;\n\t\tfor (Iterator i = childCollections.keySet().iterator(); i.hasNext(); j++) {\n\t\t\turi = (XmldbURI) i.next();\n\t\t\tcoll[j] = uri.lastSegment().toString();\n\t\t}\n\t\treturn coll;\n\t}","id":93893,"modified_method":"/**\n\t *  Returns a list of collection names naming all child collections of the\n\t *  current collection. Only the name of the collection is returned - not\n\t *  the entire path to the collection.\n\t *\n\t *@return                     Description of the Return Value\n\t *@exception  XMLDBException  Description of the Exception\n\t */\n\tpublic String[] listChildCollections() throws XMLDBException {\n\t\t// Always refresh cache for latest set - if (childCollections == null)\n\t\treadCollection();\n\t\tString coll[] = new String[childCollections.size()];\n\t\tint j = 0;\n\t\tXmldbURI uri;\n\t\tfor (Iterator i = childCollections.keySet().iterator(); i.hasNext(); j++) {\n\t\t\turi = (XmldbURI) i.next();\n\t\t\tcoll[j] = uri.lastSegment().toString();\n\t\t}\n\t\treturn coll;\n\t}","commit_id":"8a294f523e638ce4757490856acfa4d0467fdcb8","url":"https://github.com/eXist-db/exist"},{"original_method":"protected boolean hasChildCollection(String name) throws XMLDBException {\n\t\tif (childCollections == null)\n\t\t\treadCollection();\n\t\ttry {\n\t\t\treturn childCollections.containsKey(XmldbURI.xmldbUriFor(name));\n\t\t} catch(URISyntaxException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.INVALID_URI,e);\n\t\t}\n\t}","id":93894,"modified_method":"protected boolean hasChildCollection(String name) throws XMLDBException {\n\t\t//  AF Always refresh cache for latest set - if (childCollections == null)\n\t\treadCollection();\n\t\ttry {\n\t\t\treturn childCollections.containsKey(XmldbURI.xmldbUriFor(name));\n\t\t} catch(URISyntaxException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.INVALID_URI,e);\n\t\t}\n\t}","commit_id":"8a294f523e638ce4757490856acfa4d0467fdcb8","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public void sawOpcode(int seen) {\n        boolean isDefaultOffset = switchHdlr.getDefaultOffset() == getPC();\n        boolean isCaseOffset = switchHdlr.isOnSwitchOffset(this);\n\n        if (DEBUG)\n            System.out\n                    .println(getPC() + \": \" + OPCODE_NAMES[seen] + \" \" + reachable + \" \" + isCaseOffset + \" \" + isDefaultOffset);\n\n        if (reachable && (isDefaultOffset || isCaseOffset)) {\n            if (DEBUG) {\n                System.out.println(\"Fallthrough at : \" + getPC() + \": \" + OPCODE_NAMES[seen]);\n            }\n            fallthroughDistance = 0;\n            potentiallyDeadStoresFromBeforeFallthrough = (BitSet) potentiallyDeadStores.clone();\n            potentiallyDeadFieldsFromBeforeFallthrough = new HashSet<XField>(potentiallyDeadFields);\n            if (!hasFallThruComment(lastPC + 1, getPC() - 1)) {\n                if (isDefaultOffset) {\n                    SourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation.fromVisitedInstructionRange(\n                            getClassContext(), this, getPC(), getPC());\n                    foundDefault.add(sourceLineAnnotation);\n                } else {\n                    SourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation.fromVisitedInstructionRange(\n                            getClassContext(), this, lastPC, getPC());\n                    found.add(sourceLineAnnotation);\n\n                }\n            }\n\n        }\n\n        if (isBranch(seen) || isSwitch(seen) || seen == GOTO || seen == ARETURN || seen == IRETURN || seen == RETURN\n                || seen == LRETURN || seen == DRETURN || seen == FRETURN) {\n            clearAll();\n        }\n\n        if (seen == GETFIELD && stack.getStackDepth() > 0) {\n            OpcodeStack.Item top = stack.getStackItem(0);\n            if (top.getRegisterNumber() == 0)\n                potentiallyDeadFields.remove(getXFieldOperand());\n        }\n\n        else if (seen == PUTFIELD && stack.getStackDepth() >= 2) {\n            OpcodeStack.Item obj = stack.getStackItem(1);\n            if (obj.getRegisterNumber() == 0) {\n                XField f = getXFieldOperand();\n                if (potentiallyDeadFields.contains(f) && potentiallyDeadFieldsFromBeforeFallthrough.contains(f)) {\n                    // killed store\n                    priority = HIGH_PRIORITY;\n                    bugAccumulator.accumulateBug(new BugInstance(this, \"SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH\", priority)\n                            .addClassAndMethod(this).addField(f), this);\n\n                }\n                potentiallyDeadFields.add(f);\n            }\n        }\n\n        if (seen == ATHROW) {\n            int sz = edu.umd.cs.findbugs.visitclass.Util.getSizeOfSurroundingTryBlock(getMethod(), null, getPC());\n            if (sz == Integer.MAX_VALUE) {\n\n                BitSet dead = new BitSet();\n                dead.or(potentiallyDeadStores);\n                dead.and(potentiallyDeadStoresFromBeforeFallthrough);\n                if (dead.cardinality() > 0) {\n                    int register = dead.nextSetBit(0);\n                    priority = HIGH_PRIORITY;\n                    deadStore = LocalVariableAnnotation.getLocalVariableAnnotation(getMethod(), register, getPC() - 1, getPC());\n                    bugAccumulator.accumulateBug(new BugInstance(this, \"SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW\",\n                            priority).addClassAndMethod(this).add(deadStore), this);\n                }\n            }\n            clearAll();\n        }\n\n        if (isRegisterLoad())\n            potentiallyDeadStores.clear(getRegisterOperand());\n\n        else if (isRegisterStore() && !atCatchBlock()) {\n            int register = getRegisterOperand();\n            if (potentiallyDeadStores.get(register) && (potentiallyDeadStoresFromBeforeFallthrough.get(register))) {\n                // killed store\n                priority = HIGH_PRIORITY;\n                deadStore = LocalVariableAnnotation.getLocalVariableAnnotation(getMethod(), register, getPC() - 1, getPC());\n                bugAccumulator.accumulateBug(new BugInstance(this, \"SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH\", priority)\n                        .addClassAndMethod(this).add(deadStore), this);\n\n            }\n            potentiallyDeadStores.set(register);\n        }\n\n        if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals(\"ordinal\") && getSigConstantOperand().equals(\"()I\")) {\n            XClass c = getXClassOperand();\n            if (c.getSuperclassDescriptor().getClassName().equals(\"java/lang/Enum\"))\n                enumType = c;\n            if (DEBUG) \n                System.out.println(\"Saw \" + enumType+\".ordinal()\");\n        } else if (seen != TABLESWITCH && seen != LOOKUPSWITCH && seen != IALOAD)\n            enumType = null;\n\n        switch (seen) {\n        case TABLESWITCH:\n        case LOOKUPSWITCH:\n            reachable = false;\n            switchHdlr.enterSwitch(this, enumType);\n            break;\n\n        case ATHROW:\n        case RETURN:\n        case ARETURN:\n        case IRETURN:\n        case LRETURN:\n        case DRETURN:\n        case FRETURN:\n        case GOTO_W:\n        case GOTO:\n            reachable = false;\n            break;\n\n        case INVOKESTATIC:\n            reachable = !(\"exit\".equals(getNameConstantOperand()) && \"java/lang/System\".equals(getClassConstantOperand()));\n            break;\n\n        default:\n            reachable = true;\n        }\n\n        lastPC = getPC();\n        fallthroughDistance++;\n    }","id":93895,"modified_method":"@Override\n    public void sawOpcode(int seen) {\n        boolean isDefaultOffset = switchHdlr.getDefaultOffset() == getPC();\n        boolean isCaseOffset = switchHdlr.isOnSwitchOffset(this);\n\n        if (DEBUG)\n            System.out\n                    .println(getPC() + \": \" + OPCODE_NAMES[seen] + \" \" + reachable + \" \" + isCaseOffset + \" \" + isDefaultOffset);\n\n        if (reachable && (isDefaultOffset || isCaseOffset)) {\n            if (DEBUG) {\n                System.out.println(\"Fallthrough at : \" + getPC() + \": \" + OPCODE_NAMES[seen]);\n            }\n            fallthroughDistance = 0;\n            potentiallyDeadStoresFromBeforeFallthrough = (BitSet) potentiallyDeadStores.clone();\n            potentiallyDeadFieldsFromBeforeFallthrough = new HashSet<XField>(potentiallyDeadFields);\n            if (!hasFallThruComment(lastPC + 1, getPC() - 1)) {\n                if (isDefaultOffset) {\n                    SourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation.fromVisitedInstructionRange(\n                            getClassContext(), this, getPC(), getPC());\n                    foundDefault.add(sourceLineAnnotation);\n                } else {\n                    SourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation.fromVisitedInstructionRange(\n                            getClassContext(), this, lastPC, getPC());\n                    found.add(sourceLineAnnotation);\n\n                }\n            }\n\n        }\n\n        if (isBranch(seen) || isSwitch(seen) || seen == GOTO || seen == ARETURN || seen == IRETURN || seen == RETURN\n                || seen == LRETURN || seen == DRETURN || seen == FRETURN) {\n            clearAll();\n        }\n\n        if (seen == GETFIELD && stack.getStackDepth() > 0) {\n            OpcodeStack.Item top = stack.getStackItem(0);\n            if (top.getRegisterNumber() == 0)\n                potentiallyDeadFields.remove(getXFieldOperand());\n        }\n\n        else if (seen == PUTFIELD && stack.getStackDepth() >= 2) {\n            OpcodeStack.Item obj = stack.getStackItem(1);\n            if (obj.getRegisterNumber() == 0) {\n                XField f = getXFieldOperand();\n                if (potentiallyDeadFields.contains(f) && potentiallyDeadFieldsFromBeforeFallthrough.contains(f)) {\n                    // killed store\n                    priority = HIGH_PRIORITY;\n                    bugAccumulator.accumulateBug(new BugInstance(this, \"SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH\", priority)\n                            .addClassAndMethod(this).addField(f), this);\n\n                }\n                potentiallyDeadFields.add(f);\n            }\n        }\n\n        if (seen == ATHROW) {\n            int sz = edu.umd.cs.findbugs.visitclass.Util.getSizeOfSurroundingTryBlock(getMethod(), null, getPC());\n            if (sz == Integer.MAX_VALUE) {\n\n                BitSet dead = new BitSet();\n                dead.or(potentiallyDeadStores);\n                dead.and(potentiallyDeadStoresFromBeforeFallthrough);\n                if (dead.cardinality() > 0) {\n                    int register = dead.nextSetBit(0);\n                    priority = HIGH_PRIORITY;\n                    deadStore = LocalVariableAnnotation.getLocalVariableAnnotation(getMethod(), register, getPC() - 1, getPC());\n                    bugAccumulator.accumulateBug(new BugInstance(this, \"SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW\",\n                            priority).addClassAndMethod(this).add(deadStore), this);\n                }\n            }\n            clearAll();\n        }\n\n        if (isRegisterLoad())\n            potentiallyDeadStores.clear(getRegisterOperand());\n\n        else if (isRegisterStore() && !atCatchBlock()) {\n            int register = getRegisterOperand();\n            if (potentiallyDeadStores.get(register) && (potentiallyDeadStoresFromBeforeFallthrough.get(register))) {\n                // killed store\n                priority = HIGH_PRIORITY;\n                deadStore = LocalVariableAnnotation.getLocalVariableAnnotation(getMethod(), register, getPC() - 1, getPC());\n                bugAccumulator.accumulateBug(new BugInstance(this, \"SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH\", priority)\n                        .addClassAndMethod(this).add(deadStore), this);\n\n            }\n            potentiallyDeadStores.set(register);\n        }\n\n        if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals(\"ordinal\") && getSigConstantOperand().equals(\"()I\")) {\n            XClass c = getXClassOperand();\n            if (c != null) {\n                ClassDescriptor superclassDescriptor = c.getSuperclassDescriptor();\n                if (superclassDescriptor != null && superclassDescriptor.getClassName().equals(\"java/lang/Enum\"))\n                    enumType = c;\n                if (DEBUG) \n                    System.out.println(\"Saw \" + enumType+\".ordinal()\");\n            }\n        } else if (seen != TABLESWITCH && seen != LOOKUPSWITCH && seen != IALOAD)\n            enumType = null;\n\n        switch (seen) {\n        case TABLESWITCH:\n        case LOOKUPSWITCH:\n            reachable = false;\n            switchHdlr.enterSwitch(this, enumType);\n            break;\n\n        case ATHROW:\n        case RETURN:\n        case ARETURN:\n        case IRETURN:\n        case LRETURN:\n        case DRETURN:\n        case FRETURN:\n        case GOTO_W:\n        case GOTO:\n            reachable = false;\n            break;\n\n        case INVOKESTATIC:\n            reachable = !(\"exit\".equals(getNameConstantOperand()) && \"java/lang/System\".equals(getClassConstantOperand()));\n            break;\n\n        default:\n            reachable = true;\n        }\n\n        lastPC = getPC();\n        fallthroughDistance++;\n    }","commit_id":"b9954220d929dfd61db06765660e1554dcb28804","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static int getPriorityForBeingMutable(Type type) {\n    \tif (type instanceof ArrayType) {\n    \t\treturn HIGH_PRIORITY;\n    \t} else if (type instanceof ObjectType) {\n    \t\tUnreadFields unreadFields = AnalysisContext.currentAnalysisContext().getUnreadFields();\n    \t\t\n    \t\tClassDescriptor cd = DescriptorFactory.getClassDescriptor((ObjectType)type);\n    \t\t@SlashedClassName String className = cd.getClassName();\n    \t\tif (immutableClassNames.contains(className))\n    \t\t\treturn Priorities.LOW_PRIORITY;\n    \t\t\n    \t\tXClass xClass =  AnalysisContext.currentXFactory().getXClass(cd);\n    \t\t@SlashedClassName String superClassName = xClass.getSuperclassDescriptor().getClassName();\n    \t\tif (superClassName.equals(\"java/lang/Enum\"))\n    \t\t\treturn Priorities.LOW_PRIORITY; \n    \t\tboolean hasMutableField = false;\n\t\t\tboolean hasUpdates = false;\n\t\t\tfor (XField f : xClass.getXFields())\n\t\t\t\tif (!f.isStatic()) {\n\t\t\t\t\tif (!f.isFinal() && !f.isSynthetic()) {\n\t\t\t\t\t\thasMutableField = true;\n\t\t\t\t\t\tif (unreadFields.isWrittenOutsideOfInitialization(f))\n\t\t\t\t\t\t\thasUpdates = true;\n\t\t\t\t\t}\n\t\t\t\t\tString signature = f.getSignature();\n\t\t\t\t\tif (signature.startsWith(\"Ljava/util/concurrent\") || signature.startsWith(\"Ljava/lang/StringB\")\n\t\t\t\t\t        || signature.charAt(0) == '[' || signature.indexOf(\"Map\") >= 0 || signature.indexOf(\"List\") >= 0\n\t\t\t\t\t        || signature.indexOf(\"Set\") >= 0)\n\t\t\t\t\t\thasMutableField = hasUpdates = true;\n\n\t\t\t\t}\n        \t\t\n    \t\tif (!hasMutableField && !xClass.isInterface()  && !xClass.isAbstract())\n    \t\t\treturn Priorities.LOW_PRIORITY;\n    \t\tif (hasUpdates || className.startsWith(\"java/util\")\n    \t\t\t\t  || className.indexOf(\"Map\") >= 0 || className.indexOf(\"List\") >= 0)\n    \t\t\treturn Priorities.HIGH_PRIORITY;\n    \t\treturn Priorities.NORMAL_PRIORITY;\n    \t\t\n    \t\t\n    \t} else\n    \t\treturn Priorities.IGNORE_PRIORITY;\n    }","id":93896,"modified_method":"private static int getPriorityForBeingMutable(Type type) {\n    \tif (type instanceof ArrayType) {\n    \t\treturn HIGH_PRIORITY;\n    \t} else if (type instanceof ObjectType) {\n    \t\tUnreadFields unreadFields = AnalysisContext.currentAnalysisContext().getUnreadFields();\n    \t\t\n    \t\tClassDescriptor cd = DescriptorFactory.getClassDescriptor((ObjectType)type);\n    \t\t@SlashedClassName String className = cd.getClassName();\n    \t\tif (immutableClassNames.contains(className))\n    \t\t\treturn Priorities.LOW_PRIORITY;\n    \t\t\n    \t\tXClass xClass =  AnalysisContext.currentXFactory().getXClass(cd);\n    \t\tif (xClass == null)\n    \t\t\treturn Priorities.IGNORE_PRIORITY;\n    \t\tClassDescriptor superclassDescriptor = xClass.getSuperclassDescriptor();\n    \t\tif (superclassDescriptor != null) {\n    \t\t\t@SlashedClassName String superClassName = superclassDescriptor.getClassName();\n    \t\t\tif (superClassName.equals(\"java/lang/Enum\"))\n    \t\t\t\treturn Priorities.LOW_PRIORITY; \n    \t\t}\n    \t\tboolean hasMutableField = false;\n\t\t\tboolean hasUpdates = false;\n\t\t\tfor (XField f : xClass.getXFields())\n\t\t\t\tif (!f.isStatic()) {\n\t\t\t\t\tif (!f.isFinal() && !f.isSynthetic()) {\n\t\t\t\t\t\thasMutableField = true;\n\t\t\t\t\t\tif (unreadFields.isWrittenOutsideOfInitialization(f))\n\t\t\t\t\t\t\thasUpdates = true;\n\t\t\t\t\t}\n\t\t\t\t\tString signature = f.getSignature();\n\t\t\t\t\tif (signature.startsWith(\"Ljava/util/concurrent\") || signature.startsWith(\"Ljava/lang/StringB\")\n\t\t\t\t\t        || signature.charAt(0) == '[' || signature.indexOf(\"Map\") >= 0 || signature.indexOf(\"List\") >= 0\n\t\t\t\t\t        || signature.indexOf(\"Set\") >= 0)\n\t\t\t\t\t\thasMutableField = hasUpdates = true;\n\n\t\t\t\t}\n        \t\t\n    \t\tif (!hasMutableField && !xClass.isInterface()  && !xClass.isAbstract())\n    \t\t\treturn Priorities.LOW_PRIORITY;\n    \t\tif (hasUpdates || className.startsWith(\"java/util\")\n    \t\t\t\t  || className.indexOf(\"Map\") >= 0 || className.indexOf(\"List\") >= 0)\n    \t\t\treturn Priorities.HIGH_PRIORITY;\n    \t\treturn Priorities.NORMAL_PRIORITY;\n    \t\t\n    \t\t\n    \t} else\n    \t\treturn Priorities.IGNORE_PRIORITY;\n    }","commit_id":"8da9cb3d3c4298639ac3a2185c7d47c5275d06aa","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"static @NonNull XMethod getInvokedMethod(XClass xClass, String name, String sig, boolean isStatic) throws CheckedAnalysisException {\n\t\tIAnalysisCache cache = Global.getAnalysisCache();\n\t\twhile (true) {\n\t\t XMethod result = xClass.findMethod(name, sig, isStatic);\n\t\t if (result != null) return result;\n\t\t if (isStatic) throw  new CheckedAnalysisException();\n\t\t xClass = cache.getClassAnalysis(XClass.class, xClass.getSuperclassDescriptor());\n\t\t}\n\t\t \n\t}","id":93897,"modified_method":"static @NonNull XMethod getInvokedMethod(XClass xClass, String name, String sig, boolean isStatic) throws CheckedAnalysisException {\n\t\tIAnalysisCache cache = Global.getAnalysisCache();\n\t\twhile (true) {\n\t\t XMethod result = xClass.findMethod(name, sig, isStatic);\n\t\t if (result != null) return result;\n\t\t if (isStatic) throw  new CheckedAnalysisException();\n\t\t ClassDescriptor superclassDescriptor = xClass.getSuperclassDescriptor();\n\t\t if (superclassDescriptor == null) throw new CheckedAnalysisException();\n\t\txClass = cache.getClassAnalysis(XClass.class, superclassDescriptor);\n\t\t}\n\t\t \n\t}","commit_id":"00f7df2c27045818153093fba657adf1bce6ecc8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private boolean isStaticOnlyClass(@SlashedClassName\n\tString clsName) throws ClassNotFoundException {\n\n\t\ttry {\n\t\t\tXClass xClass = Global.getAnalysisCache().getClassAnalysis(XClass.class,\n\t\t\t        ClassDescriptor.createClassDescriptor(clsName));\n\n\t\t\tif (xClass.getInterfaceDescriptorList().length > 0)\n\t\t\t\treturn false;\n\t\t\tString superClassName = xClass.getSuperclassDescriptor().getClassName();\n\t\t\tif (!superClassName.equals(\"java/lang/Object\"))\n\t\t\t\treturn false;\n\t\t\tint staticCount = 0;\n\n\t\t\tList<? extends XMethod> methods = xClass.getXMethods();\n\t\t\tfor (XMethod m : methods) {\n\t\t\t\tif (m.isStatic()) {\n\t\t\t\t\tstaticCount++;\n\t\t\t\t} else if (!m.getName().equals(\"<init>\") || !m.getSignature().equals(\"()V\"))\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tList<? extends XField> fields = xClass.getXFields();\n\t\t\tfor (XField f : fields) {\n\t\t\t\tif (f.isStatic()) {\n\t\t\t\t\tstaticCount++;\n\t\t\t\t} else if (!f.isPrivate())\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (staticCount == 0)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\n\t\t} catch (CheckedAnalysisException e) {\n\t\t\treturn false;\n\t\t}\n\t}","id":93898,"modified_method":"private boolean isStaticOnlyClass(@SlashedClassName\n\tString clsName) throws ClassNotFoundException {\n\n\t\ttry {\n\t\t\tXClass xClass = Global.getAnalysisCache().getClassAnalysis(XClass.class,\n\t\t\t        ClassDescriptor.createClassDescriptor(clsName));\n\n\t\t\tif (xClass.getInterfaceDescriptorList().length > 0)\n\t\t\t\treturn false;\n\t\t\tClassDescriptor superclassDescriptor = xClass.getSuperclassDescriptor();\n\t\t\tif (superclassDescriptor == null) return false;\n\t\t\tString superClassName = superclassDescriptor.getClassName();\n\t\t\tif (!superClassName.equals(\"java/lang/Object\"))\n\t\t\t\treturn false;\n\t\t\tint staticCount = 0;\n\n\t\t\tList<? extends XMethod> methods = xClass.getXMethods();\n\t\t\tfor (XMethod m : methods) {\n\t\t\t\tif (m.isStatic()) {\n\t\t\t\t\tstaticCount++;\n\t\t\t\t} else if (!m.getName().equals(\"<init>\") || !m.getSignature().equals(\"()V\"))\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tList<? extends XField> fields = xClass.getXFields();\n\t\t\tfor (XField f : fields) {\n\t\t\t\tif (f.isStatic()) {\n\t\t\t\t\tstaticCount++;\n\t\t\t\t} else if (!f.isPrivate())\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (staticCount == 0)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\n\t\t} catch (CheckedAnalysisException e) {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"00f7df2c27045818153093fba657adf1bce6ecc8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static XClass findSuperImplementor(XClass clazz, String name, String signature, boolean isStatic)\n\t        throws CheckedAnalysisException {\n\n\t\treturn findImplementor(getXClass(clazz.getSuperclassDescriptor()), name, signature, isStatic);\n\t}","id":93899,"modified_method":"public static XClass findSuperImplementor(XClass clazz, String name, String signature, boolean isStatic)\n\t        throws CheckedAnalysisException {\n\n\t\tClassDescriptor superclassDescriptor = clazz.getSuperclassDescriptor();\n\t\tif (superclassDescriptor == null) return clazz;\n\t\treturn findImplementor(getXClass(superclassDescriptor), name, signature, isStatic);\n\t}","commit_id":"00f7df2c27045818153093fba657adf1bce6ecc8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public synchronized void stop() throws Exception {\n        checkProcess();\n        if (this.process == null) {\n            throw new IllegalStateException(\"Instance not started\");\n        }\n        this.process.destroy();\n    }","id":93900,"modified_method":"public synchronized void stop() throws Exception {\n        checkProcess();\n        if (this.process == null) {\n            throw new IllegalStateException(\"Instance not started\");\n        }\n        // Try a clean shutdown\n        cleanShutdown();\n        if (this.process != null) {\n            this.process.destroy();\n        }\n    }","commit_id":"6d0e01cfec6f336a3d52ff6dfc00f4f7c57fdf49","url":"https://github.com/apache/felix"},{"original_method":"protected void setupShutdown(Properties props) {\n        try {\n            String pidFile = props.getProperty(KARAF_SHUTDOWN_PID_FILE);\n            if (pidFile != null) {\n                RuntimeMXBean rtb = ManagementFactory.getRuntimeMXBean();\n                String processName = rtb.getName();\n                Pattern pattern = Pattern.compile(\"^([0-9]+)@.+$\", Pattern.CASE_INSENSITIVE);\n                Matcher matcher = pattern.matcher(processName);\n                if (matcher.matches()) {\n                    int pid = Integer.parseInt(matcher.group(1));\n                    Writer w = new OutputStreamWriter(new FileOutputStream(pidFile));\n                    w.write(Integer.toString(pid));\n                    w.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            int port = Integer.parseInt(props.getProperty(KARAF_SHUTDOWN_PORT, \"0\"));\n            String host = props.getProperty(KARAF_SHUTDOWN_HOST, \"localhost\");\n            String portFile = props.getProperty(KARAF_SHUTDOWN_PORT_FILE);\n            final String shutdown = props.getProperty(KARAF_SHUTDOWN_COMMAND, DEFAULT_SHUTDOWN_COMMAND);\n            if (port >= 0) {\n                shutdownSocket = new ServerSocket(port, 1, InetAddress.getByName(host));\n                if (port == 0) {\n                    port = shutdownSocket.getLocalPort();\n                }\n                if (portFile != null) {\n                    Writer w = new OutputStreamWriter(new FileOutputStream(portFile));\n                    w.write(Integer.toString(port));\n                    w.close();\n                }\n                Thread thread = new Thread() {\n                    public void run() {\n                        try {\n                            while (true) {\n                                // Wait for the next connection\n                                Socket socket = null;\n                                InputStream stream = null;\n                                try {\n                                    socket = shutdownSocket.accept();\n                                    socket.setSoTimeout(10 * 1000);  // Ten seconds\n                                    stream = socket.getInputStream();\n                                } catch (AccessControlException ace) {\n                                    LOG.log(Level.WARNING, \"Karaf shutdown socket: security exception: \"\n                                                       + ace.getMessage(), ace);\n                                    continue;\n                                } catch (IOException e) {\n                                    LOG.log(Level.SEVERE, \"Karaf shutdown socket: accept: \", e);\n                                    System.exit(1);\n                                }\n\n                                // Read a set of characters from the socket\n                                StringBuilder command = new StringBuilder();\n                                int expected = 1024; // Cut off to avoid DoS attack\n                                while (expected < shutdown.length()) {\n                                    if (random == null) {\n                                        random = new Random();\n                                    }\n                                    expected += (random.nextInt() % 1024);\n                                }\n                                while (expected > 0) {\n                                    int ch = -1;\n                                    try {\n                                        ch = stream.read();\n                                    } catch (IOException e) {\n                                        LOG.log(Level.WARNING, \"Karaf shutdown socket:  read: \", e);\n                                        ch = -1;\n                                    }\n                                    if (ch < 32) {  // Control character or EOF terminates loop\n                                        break;\n                                    }\n                                    command.append((char) ch);\n                                    expected--;\n                                }\n\n                                // Close the socket now that we are done with it\n                                try {\n                                    socket.close();\n                                } catch (IOException e) {\n                                    // Ignore\n                                }\n\n                                // Match against our command string\n                                boolean match = command.toString().equals(shutdown);\n                                if (match) {\n                                    framework.stop();\n                                    break;\n                                } else {\n                                    LOG.log(Level.WARNING, \"Karaf shutdown socket:  Invalid command '\" +\n                                                       command.toString() + \"' received\");\n                                }\n                            }\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        } finally {\n                            try {\n                                shutdownSocket.close();\n                            } catch (IOException e) {\n                            }\n                        }\n                    }\n                };\n                thread.setDaemon(true);\n                thread.start();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","id":93901,"modified_method":"protected void setupShutdown(Properties props) {\n        try {\n            String pidFile = props.getProperty(KARAF_SHUTDOWN_PID_FILE);\n            if (pidFile != null) {\n                RuntimeMXBean rtb = ManagementFactory.getRuntimeMXBean();\n                String processName = rtb.getName();\n                Pattern pattern = Pattern.compile(\"^([0-9]+)@.+$\", Pattern.CASE_INSENSITIVE);\n                Matcher matcher = pattern.matcher(processName);\n                if (matcher.matches()) {\n                    int pid = Integer.parseInt(matcher.group(1));\n                    Writer w = new OutputStreamWriter(new FileOutputStream(pidFile));\n                    w.write(Integer.toString(pid));\n                    w.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            int port = Integer.parseInt(props.getProperty(KARAF_SHUTDOWN_PORT, \"0\"));\n            String host = props.getProperty(KARAF_SHUTDOWN_HOST, \"localhost\");\n            String portFile = props.getProperty(KARAF_SHUTDOWN_PORT_FILE);\n            final String shutdown = props.getProperty(KARAF_SHUTDOWN_COMMAND, DEFAULT_SHUTDOWN_COMMAND);\n            if (port >= 0) {\n                shutdownSocket = new ServerSocket(port, 1, InetAddress.getByName(host));\n                if (port == 0) {\n                    port = shutdownSocket.getLocalPort();\n                }\n                if (portFile != null) {\n                    Writer w = new OutputStreamWriter(new FileOutputStream(portFile));\n                    w.write(Integer.toString(port));\n                    w.close();\n                }\n                Thread thread = new Thread() {\n                    public void run() {\n                        try {\n                            while (true) {\n                                // Wait for the next connection\n                                Socket socket = null;\n                                InputStream stream = null;\n                                try {\n                                    socket = shutdownSocket.accept();\n                                    socket.setSoTimeout(10 * 1000);  // Ten seconds\n                                    stream = socket.getInputStream();\n                                } catch (AccessControlException ace) {\n                                    LOG.log(Level.WARNING, \"Karaf shutdown socket: security exception: \"\n                                                       + ace.getMessage(), ace);\n                                    continue;\n                                } catch (IOException e) {\n                                    LOG.log(Level.SEVERE, \"Karaf shutdown socket: accept: \", e);\n                                    System.exit(1);\n                                }\n\n                                // Read a set of characters from the socket\n                                StringBuilder command = new StringBuilder();\n                                int expected = 1024; // Cut off to avoid DoS attack\n                                while (expected < shutdown.length()) {\n                                    if (random == null) {\n                                        random = new Random();\n                                    }\n                                    expected += (random.nextInt() % 1024);\n                                }\n                                while (expected > 0) {\n                                    int ch = -1;\n                                    try {\n                                        ch = stream.read();\n                                    } catch (IOException e) {\n                                        LOG.log(Level.WARNING, \"Karaf shutdown socket:  read: \", e);\n                                        ch = -1;\n                                    }\n                                    if (ch < 32) {  // Control character or EOF terminates loop\n                                        break;\n                                    }\n                                    command.append((char) ch);\n                                    expected--;\n                                }\n\n                                // Close the socket now that we are done with it\n                                try {\n                                    socket.close();\n                                } catch (IOException e) {\n                                    // Ignore\n                                }\n\n                                // Match against our command string\n                                boolean match = command.toString().equals(shutdown);\n                                if (match) {\n                                    LOG.log(Level.INFO, \"Karaf shutdown socket: received shutdown command. Stopping framework...\");\n                                    framework.stop();\n                                    break;\n                                } else {\n                                    LOG.log(Level.WARNING, \"Karaf shutdown socket:  Invalid command '\" +\n                                                       command.toString() + \"' received\");\n                                }\n                            }\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        } finally {\n                            try {\n                                shutdownSocket.close();\n                            } catch (IOException e) {\n                            }\n                        }\n                    }\n                };\n                thread.setDaemon(true);\n                thread.start();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","commit_id":"6d0e01cfec6f336a3d52ff6dfc00f4f7c57fdf49","url":"https://github.com/apache/felix"},{"original_method":"public void init() {\n\t\t registerBeanDefinitionParser(\"routeBuilder\", new CamelBeanDefinitionParser());    \n\t}","id":93902,"modified_method":"public void init() {\n        registerBeanDefinitionParser(\"routes\", camelBeanDefinitionParser);\n        registerBeanDefinitionParser(\"routeBuilder\", camelBeanDefinitionParser);\n        \n        registerBeanDefinitionParser(\"camelContext\", new AbstractSimpleBeanDefinitionParser() {\n            protected Class getBeanClass(Element element) {\n                return CamelContextFactoryBean.class;\n            }\n\n            @Override\n            protected boolean isEligibleAttribute(String attributeName) {\n                return super.isEligibleAttribute(attributeName) && !attributeName.equals(\"xmlns\");\n            }\n\n            @Override\n            protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {\n                super.doParse(element, parserContext, builder);\n\n                NodeList list = element.getElementsByTagName(\"routes\");\n                for (int size = list.getLength(), i = 0; i < size; i++) {\n                    Element node = (Element) list.item(i);\n                    BeanDefinition definition = camelBeanDefinitionParser.parseInternal(node, parserContext);\n                    builder.addPropertyValue(\"routeBuilder\", definition);\n                }\n            }\n        });\n    }","commit_id":"e362b4e0c22a78b01b3b0c86b794d826c20de3da","url":"https://github.com/apache/camel"},{"original_method":"public void testXMLRouteLoading() throws Exception {\n        applicationContext = new ClassPathXmlApplicationContext(\"org/apache/camel/spring/routingUsingCamelContextFactoryTest.xml\");\n\n        CamelContext context = (CamelContext) applicationContext.getBean(\"camel\");\n        assertNotNull(\"No context found!\", context);\n\n        MockEndpoint resultEndpoint = (MockEndpoint) resolveMandatoryEndpoint(context, \"mock:result\");\n        resultEndpoint.expectedBodiesReceived(body);\n\n        // now lets send a message\n        CamelClient<Exchange> client = new CamelClient<Exchange>(context);\n        client.send(\"queue:start\", new Processor<Exchange>() {\n            public void process(Exchange exchange) {\n                Message in = exchange.getIn();\n                in.setHeader(\"name\", \"James\");\n                in.setBody(body);\n            }\n        });\n        \n\n        resultEndpoint.assertIsSatisfied();\n    }","id":93903,"modified_method":"public void testXMLRouteLoading() throws Exception {\n        applicationContext = createApplicationContext();\n\n        SpringCamelContext context = (SpringCamelContext) applicationContext.getBean(\"camel\");\n        assertValidContext(context);\n\n        MockEndpoint resultEndpoint = (MockEndpoint) resolveMandatoryEndpoint(context, \"mock:result\");\n        resultEndpoint.expectedBodiesReceived(body);\n\n        // now lets send a message\n        CamelClient<Exchange> client = new CamelClient<Exchange>(context);\n        client.send(\"queue:start\", new Processor<Exchange>() {\n            public void process(Exchange exchange) {\n                Message in = exchange.getIn();\n                in.setHeader(\"name\", \"James\");\n                in.setBody(body);\n            }\n        });\n\n        resultEndpoint.assertIsSatisfied();\n    }","commit_id":"e362b4e0c22a78b01b3b0c86b794d826c20de3da","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void tearDown() throws Exception {\n        super.tearDown();\n        applicationContext.destroy();\n    }","id":93904,"modified_method":"@Override\n    protected void tearDown() throws Exception {\n        super.tearDown();\n        if (applicationContext != null) {\n            applicationContext.destroy();\n        }\n    }","commit_id":"e362b4e0c22a78b01b3b0c86b794d826c20de3da","url":"https://github.com/apache/camel"},{"original_method":"@Override\n  public void perform(Project project, MavenEmbeddersManager embeddersManager, MavenConsole console, final MavenProgressIndicator indicator)\n    throws MavenProcessCanceledException {\n    final long start = System.currentTimeMillis();\n    this.indicator = indicator;\n\n    indicator.setText(FlexBundle.message(\"generating.flex.configs\"));\n\n    try {\n      runGeneratorServer(MavenProjectsManager.getInstance(project), project);\n      writeProjects();\n    }\n    catch (IOException e) {\n      showWarning(project);\n      LOG.error(e);\n    }\n    catch (ExecutionException e) {\n      showWarning(e.getMessage(), project);\n    }\n\n    if (process == null) {\n      return;\n    }\n\n    //noinspection WhileLoopSpinsOnField\n    while (process != null) {\n      try {\n        //noinspection BusyWait\n        Thread.sleep(500);\n      }\n      catch (InterruptedException e) {\n        break;\n      }\n      if (indicator.isCanceled()) {\n        LOG.warn(\"Generating flex configs canceled\");\n        process.destroy();\n        break;\n      }\n    }\n\n    if (postTask != null) {\n      MavenUtil.invokeAndWait(project, postTask);\n\n      MavenUtil.invokeAndWaitWriteAction(project, new Runnable() {\n        public void run() {\n          for (Map.Entry<Module, String> entry : myModuleToConfigFilePath.entrySet()) {\n            if (entry.getKey().isDisposed()) continue;\n\n            final VirtualFile configFile = LocalFileSystem.getInstance().refreshAndFindFileByPath(entry.getValue());\n            if (configFile != null && !configFile.isDirectory()) {\n              Flexmojos3GenerateConfigTask.updateMainClass(entry.getKey(), configFile);\n            }\n          }\n        }\n      });\n    }\n\n    final long duration = System.currentTimeMillis() - start;\n    LOG.info(\"Generating flex configs took \" + duration + \" ms: \" + duration / 60000 + \" min \" + (duration % 60000) / 1000 + \"sec\");\n  }","id":93905,"modified_method":"@Override\n  public void perform(Project project, MavenEmbeddersManager embeddersManager, MavenConsole console, final MavenProgressIndicator indicator)\n    throws MavenProcessCanceledException {\n    final long start = System.currentTimeMillis();\n    this.indicator = indicator;\n\n    indicator.setText(FlexBundle.message(\"generating.flex.configs\"));\n\n    try {\n      runGeneratorServer(MavenProjectsManager.getInstance(project), project);\n      writeProjects();\n    }\n    catch (IOException e) {\n      showWarning(project);\n      LOG.error(e);\n    }\n    catch (ExecutionException e) {\n      showWarning(e.getMessage(), project);\n    }\n\n    if (process == null) {\n      return;\n    }\n\n    //noinspection WhileLoopSpinsOnField\n    while (process != null) {\n      try {\n        //noinspection BusyWait\n        Thread.sleep(500);\n      }\n      catch (InterruptedException e) {\n        break;\n      }\n      if (indicator.isCanceled()) {\n        LOG.warn(\"Generating flex configs canceled\");\n        if (process != null) {\n          process.destroy();\n        }\n        break;\n      }\n    }\n\n    if (postTask != null) {\n      MavenUtil.invokeAndWait(project, postTask);\n\n      MavenUtil.invokeAndWaitWriteAction(project, new Runnable() {\n        public void run() {\n          for (Map.Entry<Module, String> entry : myModuleToConfigFilePath.entrySet()) {\n            if (entry.getKey().isDisposed()) continue;\n\n            final VirtualFile configFile = LocalFileSystem.getInstance().refreshAndFindFileByPath(entry.getValue());\n            if (configFile != null && !configFile.isDirectory()) {\n              Flexmojos3GenerateConfigTask.updateMainClass(entry.getKey(), configFile);\n            }\n          }\n        }\n      });\n    }\n\n    final long duration = System.currentTimeMillis() - start;\n    LOG.info(\"Generating flex configs took \" + duration + \" ms: \" + duration / 60000 + \" min \" + (duration % 60000) / 1000 + \"sec\");\n  }","commit_id":"fd9351027d9eba349db3d567bd8e7e7b0c6a0482","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected void doPortalDestroy() {\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\ttry {\n\t\t\tcurrentThread.setContextClassLoader(\n\t\t\t\tPortalClassLoaderUtil.getClassLoader());\n\n\t\t\t_servlet.destroy();\n\t\t}\n\t\tfinally {\n\t\t\tcurrentThread.setContextClassLoader(contextClassLoader);\n\t\t}\n\t}","id":93906,"modified_method":"protected void doPortalDestroy() {\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\ttry {\n\t\t\tcurrentThread.setContextClassLoader(\n\t\t\t\tPortalClassLoaderUtil.getClassLoader());\n\n\t\t\tif (_servlet != null) {\n\t\t\t\t_servlet.destroy();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tcurrentThread.setContextClassLoader(contextClassLoader);\n\t\t}\n\t}","commit_id":"3953787d42fb5db28fce6a035da5b5d5e1b68dfd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    protected void doStop() throws Exception {\n        listenerContainer.stop();\n        listenerContainer.destroy();\n\n        // null container and listener so they are fully re created if this consumer is restarted\n        // then we will use updated configuration from jms endpoint that may have been managed using JMX\n        listenerContainer = null;\n        messageListener = null;\n        super.doStop();\n    }","id":93907,"modified_method":"@Override\n    protected void doStop() throws Exception {\n        if (listenerContainer != null) {\n            listenerContainer.stop();\n            listenerContainer.destroy();\n        }\n\n        // null container and listener so they are fully re created if this consumer is restarted\n        // then we will use updated configuration from jms endpoint that may have been managed using JMX\n        listenerContainer = null;\n        messageListener = null;\n        super.doStop();\n    }","commit_id":"b3c52aae94e14a6ab1ef33392d05d8675d560fae","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Destroys this OpenCms instance.<p> \n     */    \n    protected synchronized void destroy() {        \n        if (getLog(CmsLog.CHANNEL_INIT).isInfoEnabled()) {\n            getLog(CmsLog.CHANNEL_INIT).info(\"[OpenCms] Performing shutdown ...\");\n        }\n        try {\n            m_scheduler.shutDown();\n            m_driverManager.destroy();\n        } catch (Throwable e) {\n            if (getLog(this).isErrorEnabled()) {\n                getLog(this).error(\"[OpenCms]\" + e.toString());\n            }\n        }\n        try {\n            Utils.getModulShutdownMethods(getRegistry());\n        } catch (Throwable e) {\n            // log exception since we are about to shutdown anyway\n            if (getLog(this).isErrorEnabled()) {\n                getLog(this).error(\"[OpenCms] Module shutdown exception: \" + e);\n            }\n        }\n        if (getLog(this).isInfoEnabled()) {\n            getLog(CmsLog.CHANNEL_INIT).info(\"[OpenCms] ... shutdown completed.\");\n        }        \n        m_instance = null;\n    }","id":93908,"modified_method":"/**\n     * Destroys this OpenCms instance.<p> \n     */    \n    protected synchronized void destroy() {        \n        if (getLog(CmsLog.CHANNEL_INIT).isInfoEnabled()) {\n            getLog(CmsLog.CHANNEL_INIT).info(\"[OpenCms] Performing shutdown ...\");\n        }\n        try {\n            if (m_scheduler != null) {\n                m_scheduler.shutDown();\n            }\n            if (m_driverManager != null) {\n                m_driverManager.destroy();\n            }\n        } catch (Throwable e) {\n            if (getLog(this).isErrorEnabled()) {\n                getLog(this).error(\"[OpenCms]\" + e.toString());\n            }\n        }\n        try {\n            Utils.getModulShutdownMethods(getRegistry());\n        } catch (Throwable e) {\n            // log exception since we are about to shutdown anyway\n            if (getLog(this).isErrorEnabled()) {\n                getLog(this).error(\"[OpenCms] Module shutdown exception: \" + e);\n            }\n        }\n        if (getLog(this).isInfoEnabled()) {\n            getLog(CmsLog.CHANNEL_INIT).info(\"[OpenCms] ... shutdown completed.\");\n        }        \n        m_instance = null;\n    }","commit_id":"0fbb7a6f605b76eee500fc12b520efb84572a42f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Deactivate\n\tprotected void deactivate() {\n\t\t_serviceRegistration.unregister();\n\n\t\t_serviceRegistration = null;\n\n\t\t_httpServiceServlet.destroy();\n\n\t\t_httpServiceServlet = null;\n\t}","id":93909,"modified_method":"@Deactivate\n\tprotected void deactivate() {\n\t\tif (_serviceRegistration != null) {\n\t\t\t_serviceRegistration.unregister();\n\t\t}\n\n\t\t_serviceRegistration = null;\n\n\t\tif (_httpServiceServlet != null) {\n\t\t\t_httpServiceServlet.destroy();\n\t\t}\n\n\t\t_httpServiceServlet = null;\n\t}","commit_id":"33024c82dbae1775bc4783f32f230c53180563c2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n            final DeploymentUnit deploymentUnit = context.getDeploymentUnit();\n            final DeploymentReflectionIndex index = deploymentUnit.getAttachment(REFLECTION_INDEX);\n            final Object instanceKey = BasicComponentInstance.INSTANCE_KEY;\n            final Module module = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.MODULE);\n\n            // Module stuff\n            final EEModuleClassConfiguration componentClassConfiguration = configuration.getModuleClassConfiguration();\n            final EEModuleConfiguration moduleConfiguration = componentClassConfiguration.getModuleConfiguration();\n\n            final Deque<InterceptorFactory> instantiators = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> injectors = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> uninjectors = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> destructors = new ArrayDeque<InterceptorFactory>();\n\n            final ClassReflectionIndex<?> componentClassIndex = index.getClassIndex(componentClassConfiguration.getModuleClass());\n            final List<InterceptorFactory> componentUserAroundInvoke = new ArrayList<InterceptorFactory>();\n            final Map<String, List<InterceptorFactory>> userAroundInvokesByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n\n            final Map<String, List<InterceptorFactory>> userPostConstructByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n            final Map<String, List<InterceptorFactory>> userPreDestroyByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n\n            // Primary instance\n            final ManagedReferenceFactory instanceFactory = configuration.getInstanceFactory();\n            if (instanceFactory != null) {\n                instantiators.addFirst(new ManagedReferenceInterceptorFactory(instanceFactory, instanceKey));\n            } else {\n                //use the default constructor if no instanceFactory has been set\n                ValueManagedReferenceFactory factory = new ValueManagedReferenceFactory(new ConstructedValue<Object>((Constructor<Object>) componentClassIndex.getConstructor(EMPTY_CLASS_ARRAY), Collections.<Value<?>>emptyList()));\n                instantiators.addFirst(new ManagedReferenceInterceptorFactory(factory, instanceKey));\n            }\n            destructors.addLast(new ManagedReferenceReleaseInterceptorFactory(instanceKey));\n\n            new ClassDescriptionTraversal(componentClassConfiguration, moduleConfiguration) {\n\n                @Override\n                public void handle(EEModuleClassConfiguration classConfiguration, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                    for (final ResourceInjectionConfiguration injectionConfiguration : classConfiguration.getInjectionConfigurations()) {\n                        final Object valueContextKey = new Object();\n                        final InjectedValue<ManagedReferenceFactory> managedReferenceFactoryValue = new InjectedValue<ManagedReferenceFactory>();\n                        configuration.getStartDependencies().add(new InjectedConfigurator(injectionConfiguration, configuration, context, managedReferenceFactoryValue));\n                        injectors.addFirst(injectionConfiguration.getTarget().createInjectionInterceptorFactory(instanceKey, valueContextKey, managedReferenceFactoryValue, deploymentUnit));\n                        uninjectors.addLast(new ManagedReferenceReleaseInterceptorFactory(valueContextKey));\n                    }\n                }\n            }.run();\n\n            // Interceptor instances\n            final List<InterceptorDescription> interceptors = new ArrayList<InterceptorDescription>();\n            //TODO: add default interceptor\n            //interceptors.addAll(description.getClassInterceptors());\n            interceptors.addAll(description.getAllInterceptors().values());\n            for (InterceptorDescription interceptorDescription : interceptors) {\n                final String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                final EEModuleClassConfiguration interceptorConfiguration = moduleConfiguration.getClassConfiguration(interceptorClassName);\n\n                //we store the interceptor instance under the class key\n                final Object contextKey = interceptorConfiguration.getModuleClass();\n                instantiators.addFirst(new ManagedReferenceInterceptorFactory(interceptorConfiguration.getInstantiator(), contextKey));\n                destructors.addLast(new ManagedReferenceReleaseInterceptorFactory(contextKey));\n\n                final boolean isClassLevelInterceptor = description.getClassInterceptors().contains(interceptorDescription);\n                new ClassDescriptionTraversal(interceptorConfiguration, moduleConfiguration) {\n                    @Override\n                    public void handle(EEModuleClassConfiguration interceptorClassConfiguration, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                        final ClassReflectionIndex<?> interceptorClassIndex = index.getClassIndex(interceptorClassConfiguration.getModuleClass());\n\n                        for (final ResourceInjectionConfiguration injectionConfiguration : interceptorClassConfiguration.getInjectionConfigurations()) {\n                            final Object valueContextKey = new Object();\n                            final InjectedValue<ManagedReferenceFactory> managedReferenceFactoryValue = new InjectedValue<ManagedReferenceFactory>();\n                            configuration.getStartDependencies().add(new InjectedConfigurator(injectionConfiguration, configuration, context, managedReferenceFactoryValue));\n                            injectors.addFirst(injectionConfiguration.getTarget().createInjectionInterceptorFactory(contextKey, valueContextKey, managedReferenceFactoryValue, deploymentUnit));\n                            uninjectors.addLast(new ManagedReferenceReleaseInterceptorFactory(valueContextKey));\n                        }\n                        // Only class level interceptors are processed for postconstruct/predestroy methods.\n                        // Method level interceptors aren't supposed to be processed for postconstruct/predestroy lifecycle\n                        // methods, as per interceptors spec\n                        if (isClassLevelInterceptor) {\n                            final MethodIdentifier postConstructMethod = classDescription.getPostConstructMethod();\n                            if (postConstructMethod != null) {\n                                Method method = interceptorClassIndex.getMethod(postConstructMethod);\n                                InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(contextKey, method, true);\n                                List<InterceptorFactory> userPostConstruct = userPostConstructByInterceptorClass.get(interceptorClassName);\n                                if(userPostConstruct == null) {\n                                    userPostConstructByInterceptorClass.put(interceptorClassName, userPostConstruct = new ArrayList<InterceptorFactory>());\n                                }\n                                userPostConstruct.add(interceptorFactory);\n                            }\n                            final MethodIdentifier preDestroyMethod = classDescription.getPreDestroyMethod();\n                            if (preDestroyMethod != null) {\n                                Method method = interceptorClassIndex.getMethod(preDestroyMethod);\n                                InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(contextKey, method, true);\n                                List<InterceptorFactory> userPreDestroy = userPreDestroyByInterceptorClass.get(interceptorClassName);\n                                if(userPreDestroy == null) {\n                                    userPreDestroyByInterceptorClass.put(interceptorClassName, userPreDestroy = new ArrayList<InterceptorFactory>());\n                                }\n                                userPreDestroy.add(interceptorFactory);\n                            }\n                        }\n                        final MethodIdentifier aroundInvokeMethod = classDescription.getAroundInvokeMethod();\n                        if (aroundInvokeMethod != null) {\n                            Method method = interceptorClassIndex.getMethod(aroundInvokeMethod);\n                            List<InterceptorFactory> interceptors;\n                            if ((interceptors = userAroundInvokesByInterceptorClass.get(interceptorClassName)) == null) {\n                                userAroundInvokesByInterceptorClass.put(interceptorClassName, interceptors = new ArrayList<InterceptorFactory>());\n                            }\n                            interceptors.add(new ManagedReferenceLifecycleMethodInterceptorFactory(contextKey, method, false));\n                        }\n                    }\n                }.run();\n            }\n\n            final Deque<InterceptorFactory> userPostConstruct = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> userPreDestroy = new ArrayDeque<InterceptorFactory>();\n\n            //now add the lifecycle interceptors in the correct order\n            //TODO: default interceptors\n            for(final InterceptorDescription interceptorClass : description.getClassInterceptors()) {\n                if(userPostConstructByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                    userPostConstruct.addAll(userPostConstructByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n                }\n                if(userPreDestroyByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                    userPreDestroy.addAll(userPreDestroyByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n                }\n            }\n\n\n\n\n            new ClassDescriptionTraversal(componentClassConfiguration, moduleConfiguration) {\n                @Override\n                public void handle(EEModuleClassConfiguration configuration, EEModuleClassDescription classDescription) {\n                    final MethodIdentifier componentPostConstructMethod = classDescription.getPostConstructMethod();\n                    if (componentPostConstructMethod != null) {\n                        Method method = componentClassIndex.getMethod(componentPostConstructMethod);\n                        InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(instanceKey, method, true);\n                        userPostConstruct.addLast(interceptorFactory);\n                    }\n                    final MethodIdentifier componentPreDestroyMethod = classDescription.getPreDestroyMethod();\n                    if (componentPreDestroyMethod != null) {\n                        Method method = componentClassIndex.getMethod(componentPreDestroyMethod);\n                        InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(instanceKey, method, true);\n                        userPreDestroy.addLast(interceptorFactory);\n                    }\n                    final MethodIdentifier componentAroundInvokeMethod = classDescription.getAroundInvokeMethod();\n                    if (componentAroundInvokeMethod != null) {\n                        Method method = componentClassIndex.getMethod(componentAroundInvokeMethod);\n                        componentUserAroundInvoke.add(new ManagedReferenceLifecycleMethodInterceptorFactory(instanceKey, method, false));\n                    }\n                }\n            }.run();\n\n            final InterceptorFactory tcclInterceptor = new ImmediateInterceptorFactory(new TCCLInterceptor(module.getClassLoader()));\n\n            // apply instantiation interceptors\n            final Deque<InterceptorFactory> instantiationInterceptors = configuration.getInstantiationInterceptors();\n            instantiationInterceptors.addAll(instantiators);\n            instantiationInterceptors.add(Interceptors.getTerminalInterceptorFactory());\n            instantiationInterceptors.addFirst(tcclInterceptor);\n\n            // Apply post-construct\n            final Deque<InterceptorFactory> postConstructInterceptors = configuration.getPostConstructInterceptors();\n            final Iterator<InterceptorFactory> injectorIterator = injectors.descendingIterator();\n            while (injectorIterator.hasNext()) {\n                postConstructInterceptors.addFirst(injectorIterator.next());\n            }\n            postConstructInterceptors.addAll(userPostConstruct);\n            postConstructInterceptors.add(Interceptors.getTerminalInterceptorFactory());\n            postConstructInterceptors.addFirst(tcclInterceptor);\n\n            // Apply pre-destroy\n            final Deque<InterceptorFactory> preDestroyInterceptors = configuration.getPreDestroyInterceptors();\n            final Iterator<InterceptorFactory> uninjectorsIterator = uninjectors.descendingIterator();\n            while (uninjectorsIterator.hasNext()) {\n                preDestroyInterceptors.addFirst(uninjectorsIterator.next());\n            }\n            final Iterator<InterceptorFactory> destructorIterator = destructors.descendingIterator();\n            while (destructorIterator.hasNext()) {\n                preDestroyInterceptors.addFirst(destructorIterator.next());\n            }\n            preDestroyInterceptors.addAll(userPreDestroy);\n            preDestroyInterceptors.add(Interceptors.getTerminalInterceptorFactory());\n            preDestroyInterceptors.addFirst(tcclInterceptor);\n\n            // @AroundInvoke interceptors\n            final List<InterceptorDescription> classInterceptors = description.getClassInterceptors();\n\n            Class clazz = componentClassConfiguration.getModuleClass();\n            while (clazz != null) {\n                final ClassReflectionIndex classIndex = index.getClassIndex(clazz);\n                for (final Method method : (Collection<Method>) classIndex.getMethods()) {\n                    MethodIdentifier identifier = MethodIdentifier.getIdentifier(method.getReturnType(), method.getName(), method.getParameterTypes());\n                    Deque<InterceptorFactory> interceptorDeque = configuration.getComponentInterceptorDeque(method);\n                    if (!description.isExcludeClassInterceptors(identifier)) {\n                        for (InterceptorDescription interceptorDescription : classInterceptors) {\n                            String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                            List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                            if (aroundInvokes != null) {\n                                interceptorDeque.addAll(aroundInvokes);\n                            }\n                        }\n                        if (componentUserAroundInvoke != null) {\n                            interceptorDeque.addAll(componentUserAroundInvoke);\n                        }\n                    }\n                    if (!description.isExcludeDefaultInterceptors() && !description.isExcludeDefaultInterceptors(identifier)) {\n                        // todo: default interceptors here\n                    }\n                }\n                clazz = clazz.getSuperclass();\n            }\n\n            //now handle method level interceptors\n            final Map<MethodIdentifier, List<InterceptorDescription>> methodInterceptors = description.getMethodInterceptors();\n            for (MethodIdentifier identifier : methodInterceptors.keySet()) {\n                final List<InterceptorDescription> descriptions = methodInterceptors.get(identifier);\n                final Method componentMethod = componentClassIndex.getMethod(identifier);\n                final Deque<InterceptorFactory> interceptorDeque = configuration.getComponentInterceptorDeque(componentMethod);\n                // TODO - ordering...?\n                for (InterceptorDescription interceptorDescription : descriptions) {\n                    String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                    List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                    if (aroundInvokes != null) {\n                        interceptorDeque.addAll(aroundInvokes);\n                    }\n                }\n            }\n\n            //now add the interceptor that initializes and the interceptor that actually invokes to the end of the interceptor chain\n            // and also add the tccl interceptor\n            for (Method method : configuration.getDefinedComponentMethods()) {\n                configuration.getComponentInterceptorDeque(method).addFirst(Interceptors.getInitialInterceptorFactory());\n                configuration.getComponentInterceptorDeque(method).addLast(new ManagedReferenceMethodInterceptorFactory(instanceKey, method));\n                // add to the beginning\n                configuration.getComponentInterceptorDeque(method).addFirst(tcclInterceptor);\n            }\n\n            //views\n            for (ViewDescription view : description.getViews()) {\n                Class<?> viewClass;\n                try {\n                    viewClass = module.getClassLoader().loadClass(view.getViewClassName());\n                } catch (ClassNotFoundException e) {\n                    throw new DeploymentUnitProcessingException(\"Could not load view class \" + view.getViewClassName() + \" for component \" + configuration, e);\n                }\n                final ViewConfiguration viewConfiguration;\n                if (viewClass.isInterface()) {\n                    viewConfiguration = new ViewConfiguration(viewClass, configuration, view.getServiceName(), new ProxyFactory(viewClass.getName() + \"$$$view\" + PROXY_ID.incrementAndGet(), Object.class, viewClass.getClassLoader(), viewClass));\n                } else {\n                    viewConfiguration = new ViewConfiguration(viewClass, configuration, view.getServiceName(), new ProxyFactory(viewClass.getName() + \"$$$view\" + PROXY_ID.incrementAndGet(), viewClass, viewClass.getClassLoader()));\n                }\n                for (final ViewConfigurator configurator : view.getConfigurators()) {\n                    configurator.configure(context, configuration, view, viewConfiguration);\n                }\n                configuration.getViews().add(viewConfiguration);\n            }\n        }","id":93910,"modified_method":"public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n            final DeploymentUnit deploymentUnit = context.getDeploymentUnit();\n            final DeploymentReflectionIndex index = deploymentUnit.getAttachment(REFLECTION_INDEX);\n            final Object instanceKey = BasicComponentInstance.INSTANCE_KEY;\n            final Module module = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.MODULE);\n\n            // Module stuff\n            final EEModuleClassConfiguration componentClassConfiguration = configuration.getModuleClassConfiguration();\n            final EEModuleConfiguration moduleConfiguration = componentClassConfiguration.getModuleConfiguration();\n\n            final Deque<InterceptorFactory> instantiators = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> injectors = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> uninjectors = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> destructors = new ArrayDeque<InterceptorFactory>();\n\n            final ClassReflectionIndex<?> componentClassIndex = index.getClassIndex(componentClassConfiguration.getModuleClass());\n            final List<InterceptorFactory> componentUserAroundInvoke = new ArrayList<InterceptorFactory>();\n            final Map<String, List<InterceptorFactory>> userAroundInvokesByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n\n            final Map<String, List<InterceptorFactory>> userPostConstructByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n            final Map<String, List<InterceptorFactory>> userPreDestroyByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n\n            // Primary instance\n            final ManagedReferenceFactory instanceFactory = configuration.getInstanceFactory();\n            if (instanceFactory != null) {\n                instantiators.addFirst(new ManagedReferenceInterceptorFactory(instanceFactory, instanceKey));\n            } else {\n                //use the default constructor if no instanceFactory has been set\n                ValueManagedReferenceFactory factory = new ValueManagedReferenceFactory(new ConstructedValue<Object>((Constructor<Object>) componentClassIndex.getConstructor(EMPTY_CLASS_ARRAY), Collections.<Value<?>>emptyList()));\n                instantiators.addFirst(new ManagedReferenceInterceptorFactory(factory, instanceKey));\n            }\n            destructors.addLast(new ManagedReferenceReleaseInterceptorFactory(instanceKey));\n\n            new ClassDescriptionTraversal(componentClassConfiguration, moduleConfiguration) {\n\n                @Override\n                public void handle(EEModuleClassConfiguration classConfiguration, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                    for (final ResourceInjectionConfiguration injectionConfiguration : classConfiguration.getInjectionConfigurations()) {\n                        final Object valueContextKey = new Object();\n                        final InjectedValue<ManagedReferenceFactory> managedReferenceFactoryValue = new InjectedValue<ManagedReferenceFactory>();\n                        configuration.getStartDependencies().add(new InjectedConfigurator(injectionConfiguration, configuration, context, managedReferenceFactoryValue));\n                        injectors.addFirst(injectionConfiguration.getTarget().createInjectionInterceptorFactory(instanceKey, valueContextKey, managedReferenceFactoryValue, deploymentUnit));\n                        uninjectors.addLast(new ManagedReferenceReleaseInterceptorFactory(valueContextKey));\n                    }\n                }\n            }.run();\n\n            // Interceptor instances\n            final List<InterceptorDescription> interceptors = new ArrayList<InterceptorDescription>();\n            //TODO: add default interceptor\n            //interceptors.addAll(description.getClassInterceptors());\n            interceptors.addAll(description.getAllInterceptors().values());\n            for (InterceptorDescription interceptorDescription : interceptors) {\n                final String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                final EEModuleClassConfiguration interceptorConfiguration = moduleConfiguration.getClassConfiguration(interceptorClassName);\n\n                //we store the interceptor instance under the class key\n                final Object contextKey = interceptorConfiguration.getModuleClass();\n                if(interceptorConfiguration.getInstantiator() == null) {\n                    throw new DeploymentUnitProcessingException(\"No default constructor for interceptor class \" + interceptorClassName + \" on component \" + componentClassConfiguration.getModuleClass());\n                }\n                instantiators.addFirst(new ManagedReferenceInterceptorFactory(interceptorConfiguration.getInstantiator(), contextKey));\n                destructors.addLast(new ManagedReferenceReleaseInterceptorFactory(contextKey));\n\n                final boolean isClassLevelInterceptor = description.getClassInterceptors().contains(interceptorDescription);\n                new ClassDescriptionTraversal(interceptorConfiguration, moduleConfiguration) {\n                    @Override\n                    public void handle(EEModuleClassConfiguration interceptorClassConfiguration, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                        final ClassReflectionIndex<?> interceptorClassIndex = index.getClassIndex(interceptorClassConfiguration.getModuleClass());\n\n                        for (final ResourceInjectionConfiguration injectionConfiguration : interceptorClassConfiguration.getInjectionConfigurations()) {\n                            final Object valueContextKey = new Object();\n                            final InjectedValue<ManagedReferenceFactory> managedReferenceFactoryValue = new InjectedValue<ManagedReferenceFactory>();\n                            configuration.getStartDependencies().add(new InjectedConfigurator(injectionConfiguration, configuration, context, managedReferenceFactoryValue));\n                            injectors.addFirst(injectionConfiguration.getTarget().createInjectionInterceptorFactory(contextKey, valueContextKey, managedReferenceFactoryValue, deploymentUnit));\n                            uninjectors.addLast(new ManagedReferenceReleaseInterceptorFactory(valueContextKey));\n                        }\n                        // Only class level interceptors are processed for postconstruct/predestroy methods.\n                        // Method level interceptors aren't supposed to be processed for postconstruct/predestroy lifecycle\n                        // methods, as per interceptors spec\n                        if (isClassLevelInterceptor) {\n                            final MethodIdentifier postConstructMethod = classDescription.getPostConstructMethod();\n                            if (postConstructMethod != null) {\n                                Method method = interceptorClassIndex.getMethod(postConstructMethod);\n                                InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(contextKey, method, true);\n                                List<InterceptorFactory> userPostConstruct = userPostConstructByInterceptorClass.get(interceptorClassName);\n                                if(userPostConstruct == null) {\n                                    userPostConstructByInterceptorClass.put(interceptorClassName, userPostConstruct = new ArrayList<InterceptorFactory>());\n                                }\n                                userPostConstruct.add(interceptorFactory);\n                            }\n                            final MethodIdentifier preDestroyMethod = classDescription.getPreDestroyMethod();\n                            if (preDestroyMethod != null) {\n                                Method method = interceptorClassIndex.getMethod(preDestroyMethod);\n                                InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(contextKey, method, true);\n                                List<InterceptorFactory> userPreDestroy = userPreDestroyByInterceptorClass.get(interceptorClassName);\n                                if(userPreDestroy == null) {\n                                    userPreDestroyByInterceptorClass.put(interceptorClassName, userPreDestroy = new ArrayList<InterceptorFactory>());\n                                }\n                                userPreDestroy.add(interceptorFactory);\n                            }\n                        }\n                        final MethodIdentifier aroundInvokeMethod = classDescription.getAroundInvokeMethod();\n                        if (aroundInvokeMethod != null) {\n                            Method method = interceptorClassIndex.getMethod(aroundInvokeMethod);\n                            List<InterceptorFactory> interceptors;\n                            if ((interceptors = userAroundInvokesByInterceptorClass.get(interceptorClassName)) == null) {\n                                userAroundInvokesByInterceptorClass.put(interceptorClassName, interceptors = new ArrayList<InterceptorFactory>());\n                            }\n                            interceptors.add(new ManagedReferenceLifecycleMethodInterceptorFactory(contextKey, method, false));\n                        }\n                    }\n                }.run();\n            }\n\n            final Deque<InterceptorFactory> userPostConstruct = new ArrayDeque<InterceptorFactory>();\n            final Deque<InterceptorFactory> userPreDestroy = new ArrayDeque<InterceptorFactory>();\n\n            //now add the lifecycle interceptors in the correct order\n            //TODO: default interceptors\n            for(final InterceptorDescription interceptorClass : description.getClassInterceptors()) {\n                if(userPostConstructByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                    userPostConstruct.addAll(userPostConstructByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n                }\n                if(userPreDestroyByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                    userPreDestroy.addAll(userPreDestroyByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n                }\n            }\n\n\n\n\n            new ClassDescriptionTraversal(componentClassConfiguration, moduleConfiguration) {\n                @Override\n                public void handle(EEModuleClassConfiguration configuration, EEModuleClassDescription classDescription) {\n                    final MethodIdentifier componentPostConstructMethod = classDescription.getPostConstructMethod();\n                    if (componentPostConstructMethod != null) {\n                        Method method = componentClassIndex.getMethod(componentPostConstructMethod);\n                        InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(instanceKey, method, true);\n                        userPostConstruct.addLast(interceptorFactory);\n                    }\n                    final MethodIdentifier componentPreDestroyMethod = classDescription.getPreDestroyMethod();\n                    if (componentPreDestroyMethod != null) {\n                        Method method = componentClassIndex.getMethod(componentPreDestroyMethod);\n                        InterceptorFactory interceptorFactory = new ManagedReferenceLifecycleMethodInterceptorFactory(instanceKey, method, true);\n                        userPreDestroy.addLast(interceptorFactory);\n                    }\n                    final MethodIdentifier componentAroundInvokeMethod = classDescription.getAroundInvokeMethod();\n                    if (componentAroundInvokeMethod != null) {\n                        Method method = componentClassIndex.getMethod(componentAroundInvokeMethod);\n                        componentUserAroundInvoke.add(new ManagedReferenceLifecycleMethodInterceptorFactory(instanceKey, method, false));\n                    }\n                }\n            }.run();\n\n            final InterceptorFactory tcclInterceptor = new ImmediateInterceptorFactory(new TCCLInterceptor(module.getClassLoader()));\n\n            // apply instantiation interceptors\n            final Deque<InterceptorFactory> instantiationInterceptors = configuration.getInstantiationInterceptors();\n            instantiationInterceptors.addAll(instantiators);\n            instantiationInterceptors.add(Interceptors.getTerminalInterceptorFactory());\n            instantiationInterceptors.addFirst(tcclInterceptor);\n\n            // Apply post-construct\n            final Deque<InterceptorFactory> postConstructInterceptors = configuration.getPostConstructInterceptors();\n            final Iterator<InterceptorFactory> injectorIterator = injectors.descendingIterator();\n            while (injectorIterator.hasNext()) {\n                postConstructInterceptors.addFirst(injectorIterator.next());\n            }\n            postConstructInterceptors.addAll(userPostConstruct);\n            postConstructInterceptors.add(Interceptors.getTerminalInterceptorFactory());\n            postConstructInterceptors.addFirst(tcclInterceptor);\n\n            // Apply pre-destroy\n            final Deque<InterceptorFactory> preDestroyInterceptors = configuration.getPreDestroyInterceptors();\n            final Iterator<InterceptorFactory> uninjectorsIterator = uninjectors.descendingIterator();\n            while (uninjectorsIterator.hasNext()) {\n                preDestroyInterceptors.addFirst(uninjectorsIterator.next());\n            }\n            final Iterator<InterceptorFactory> destructorIterator = destructors.descendingIterator();\n            while (destructorIterator.hasNext()) {\n                preDestroyInterceptors.addFirst(destructorIterator.next());\n            }\n            preDestroyInterceptors.addAll(userPreDestroy);\n            preDestroyInterceptors.add(Interceptors.getTerminalInterceptorFactory());\n            preDestroyInterceptors.addFirst(tcclInterceptor);\n\n            // @AroundInvoke interceptors\n            final List<InterceptorDescription> classInterceptors = description.getClassInterceptors();\n\n            Class clazz = componentClassConfiguration.getModuleClass();\n            while (clazz != null) {\n                final ClassReflectionIndex classIndex = index.getClassIndex(clazz);\n                for (final Method method : (Collection<Method>) classIndex.getMethods()) {\n                    MethodIdentifier identifier = MethodIdentifier.getIdentifier(method.getReturnType(), method.getName(), method.getParameterTypes());\n                    Deque<InterceptorFactory> interceptorDeque = configuration.getComponentInterceptorDeque(method);\n                    if (!description.isExcludeClassInterceptors(identifier)) {\n                        for (InterceptorDescription interceptorDescription : classInterceptors) {\n                            String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                            List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                            if (aroundInvokes != null) {\n                                interceptorDeque.addAll(aroundInvokes);\n                            }\n                        }\n                        if (componentUserAroundInvoke != null) {\n                            interceptorDeque.addAll(componentUserAroundInvoke);\n                        }\n                    }\n                    if (!description.isExcludeDefaultInterceptors() && !description.isExcludeDefaultInterceptors(identifier)) {\n                        // todo: default interceptors here\n                    }\n                }\n                clazz = clazz.getSuperclass();\n            }\n\n            //now handle method level interceptors\n            final Map<MethodIdentifier, List<InterceptorDescription>> methodInterceptors = description.getMethodInterceptors();\n            for (MethodIdentifier identifier : methodInterceptors.keySet()) {\n                final List<InterceptorDescription> descriptions = methodInterceptors.get(identifier);\n                final Method componentMethod = componentClassIndex.getMethod(identifier);\n                final Deque<InterceptorFactory> interceptorDeque = configuration.getComponentInterceptorDeque(componentMethod);\n                // TODO - ordering...?\n                for (InterceptorDescription interceptorDescription : descriptions) {\n                    String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                    List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                    if (aroundInvokes != null) {\n                        interceptorDeque.addAll(aroundInvokes);\n                    }\n                }\n            }\n\n            //now add the interceptor that initializes and the interceptor that actually invokes to the end of the interceptor chain\n            // and also add the tccl interceptor\n            for (Method method : configuration.getDefinedComponentMethods()) {\n                configuration.getComponentInterceptorDeque(method).addFirst(Interceptors.getInitialInterceptorFactory());\n                configuration.getComponentInterceptorDeque(method).addLast(new ManagedReferenceMethodInterceptorFactory(instanceKey, method));\n                // add to the beginning\n                configuration.getComponentInterceptorDeque(method).addFirst(tcclInterceptor);\n            }\n\n            //views\n            for (ViewDescription view : description.getViews()) {\n                Class<?> viewClass;\n                try {\n                    viewClass = module.getClassLoader().loadClass(view.getViewClassName());\n                } catch (ClassNotFoundException e) {\n                    throw new DeploymentUnitProcessingException(\"Could not load view class \" + view.getViewClassName() + \" for component \" + configuration, e);\n                }\n                final ViewConfiguration viewConfiguration;\n                if (viewClass.isInterface()) {\n                    viewConfiguration = new ViewConfiguration(viewClass, configuration, view.getServiceName(), new ProxyFactory(viewClass.getName() + \"$$$view\" + PROXY_ID.incrementAndGet(), Object.class, viewClass.getClassLoader(), viewClass));\n                } else {\n                    viewConfiguration = new ViewConfiguration(viewClass, configuration, view.getServiceName(), new ProxyFactory(viewClass.getName() + \"$$$view\" + PROXY_ID.incrementAndGet(), viewClass, viewClass.getClassLoader()));\n                }\n                for (final ViewConfigurator configurator : view.getConfigurators()) {\n                    configurator.configure(context, configuration, view, viewConfiguration);\n                }\n                configuration.getViews().add(viewConfiguration);\n            }\n        }","commit_id":"58ccd019fea2d5f686ab9db09cf2df9226a83306","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void configure(final DeploymentPhaseContext context, final EEModuleClassDescription description, final EEModuleClassConfiguration configuration) throws DeploymentUnitProcessingException {\n            DeploymentReflectionIndex index = context.getDeploymentUnit().getAttachment(REFLECTION_INDEX);\n            Class<?> moduleClass = configuration.getModuleClass();\n            ClassReflectionIndex<?> classIndex = index.getClassIndex(moduleClass);\n            // Use the basic instantiator if none was set up\n            if (configuration.getInstantiator() == null) {\n                Constructor<?> constructor = classIndex.getConstructor(NO_CLASSES);\n                if (constructor == null) {\n                    throw new DeploymentUnitProcessingException(\"No acceptable constructor found for \" + moduleClass);\n                }\n                configuration.setInstantiator(new ValueManagedReferenceFactory(createConstructedValue(constructor)));\n            }\n        }","id":93911,"modified_method":"public void configure(final DeploymentPhaseContext context, final EEModuleClassDescription description, final EEModuleClassConfiguration configuration) throws DeploymentUnitProcessingException {\n            DeploymentReflectionIndex index = context.getDeploymentUnit().getAttachment(REFLECTION_INDEX);\n            Class<?> moduleClass = configuration.getModuleClass();\n            ClassReflectionIndex<?> classIndex = index.getClassIndex(moduleClass);\n            // Use the basic instantiator if none was set up\n            if (configuration.getInstantiator() == null) {\n                Constructor<?> constructor = classIndex.getConstructor(NO_CLASSES);\n                if (constructor != null) {\n                    configuration.setInstantiator(new ValueManagedReferenceFactory(createConstructedValue(constructor)));\n                }\n            }\n        }","commit_id":"58ccd019fea2d5f686ab9db09cf2df9226a83306","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void remove() {\n        instance.destroy();\n        removed = true;\n    }","id":93912,"modified_method":"@Override\n    public void remove() {\n        if(instance != null) {\n            instance.destroy();\n        }\n        removed = true;\n    }","commit_id":"58ccd019fea2d5f686ab9db09cf2df9226a83306","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * As the weld based instantiator needs access to the bean manager it is installed as a service.\n     */\n    private void addWeldInstantiator(final ComponentConfiguration configuration, final Class<?> componentClass, final String beanName, final ServiceName serviceName, final InjectedValue<BeanManagerImpl> beanManager, final Set<Class<?>> interceptorClasses) {\n        final WeldManagedReferenceFactory factory = new WeldManagedReferenceFactory(componentClass, beanName, beanManager, interceptorClasses);\n        configuration.setInstanceFactory(factory);\n        configuration.getStartDependencies().add(new DependencyConfigurator() {\n            @Override\n            public void configureDependency(final ServiceBuilder<?> serviceBuilder) throws DeploymentUnitProcessingException {\n                serviceBuilder.addDependency(serviceName);\n            }\n        });\n    }","id":93913,"modified_method":"/**\n     * As the weld based instantiator needs access to the bean manager it is installed as a service.\n     */\n    private void addWeldInstantiator(final ServiceTarget target, final ComponentConfiguration configuration, final Class<?> componentClass, final String beanName, final ServiceName deploymentServiceName, final ServiceName beanManagerServiceName, final InjectedValue<BeanManagerImpl> beanManager, final Set<Class<?>> interceptorClasses) {\n\n        final ServiceName serviceName = configuration.getComponentDescription().getServiceName().append(\"WeldInstantiator\");\n\n        final WeldManagedReferenceFactory factory = new WeldManagedReferenceFactory(componentClass, beanName, beanManager, interceptorClasses);\n\n        target.addService(serviceName, factory)\n                .addDependency(beanManagerServiceName, BeanManagerImpl.class, factory.getBeanManager())\n                .install();\n\n        configuration.setInstanceFactory(factory);\n        configuration.getStartDependencies().add(new DependencyConfigurator() {\n            @Override\n            public void configureDependency(final ServiceBuilder<?> serviceBuilder) throws DeploymentUnitProcessingException {\n                serviceBuilder.addDependency(serviceName);\n            }\n        });\n    }","commit_id":"58ccd019fea2d5f686ab9db09cf2df9226a83306","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n            return;\n        }\n\n\n        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);\n        final ServiceName beanManagerServiceName = BeanManagerService.serviceName(deploymentUnit);\n\n        final ServiceName serviceName = deploymentUnit.getServiceName().append(\"WeldComponentInstantiatorService\");\n        final InjectedValue<BeanManagerImpl> beanManager = new InjectedValue<BeanManagerImpl>();\n        phaseContext.getServiceTarget().addService(serviceName, Service.NULL)\n                .addDependency(beanManagerServiceName, BeanManagerImpl.class, beanManager)\n                .install();\n\n        for (ComponentDescription component : eeModuleDescription.getComponentDescriptions()) {\n            final String beanName;\n            if (component instanceof SessionBeanComponentDescription) {\n                beanName = component.getComponentName();\n            } else {\n                beanName = null;\n            }\n            component.getConfigurators().addFirst(new ComponentConfigurator() {\n                @Override\n                public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n                    final Class<?> componentClass = configuration.getModuleClassConfiguration().getModuleClass();\n                    final EEModuleConfiguration module = configuration.getModuleClassConfiguration().getModuleConfiguration();\n\n\n                    //get the interceptors so they can be injected as well\n                    final Set<Class<?>> interceptorClasses = new HashSet<Class<?>>();\n                    for (InterceptorDescription interceptorDescription : description.getAllInterceptors().values()) {\n                        EEModuleClassConfiguration clazz = module.getClassConfiguration(interceptorDescription.getInterceptorClassName());\n                        if(clazz != null) {\n                            interceptorClasses.add(clazz.getModuleClass());\n                        }\n                    }\n\n\n                    addWeldInstantiator(configuration, componentClass, beanName, serviceName, beanManager, interceptorClasses);\n\n                    configuration.getPostConstructInterceptors().addLast(new WeldInjectionInterceptor.Factory(configuration, interceptorClasses));\n                }\n            });\n\n        }\n\n    }","id":93914,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (!WeldDeploymentMarker.isWeldDeployment(deploymentUnit)) {\n            return;\n        }\n\n\n        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);\n        final ServiceName beanManagerServiceName = BeanManagerService.serviceName(deploymentUnit);\n\n        final InjectedValue<BeanManagerImpl> beanManager = new InjectedValue<BeanManagerImpl>();\n\n        for (ComponentDescription component : eeModuleDescription.getComponentDescriptions()) {\n            final String beanName;\n            if (component instanceof SessionBeanComponentDescription) {\n                beanName = component.getComponentName();\n            } else {\n                beanName = null;\n            }\n            component.getConfigurators().addFirst(new ComponentConfigurator() {\n                @Override\n                public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n                    final Class<?> componentClass = configuration.getModuleClassConfiguration().getModuleClass();\n                    final EEModuleConfiguration module = configuration.getModuleClassConfiguration().getModuleConfiguration();\n\n\n                    //get the interceptors so they can be injected as well\n                    final Set<Class<?>> interceptorClasses = new HashSet<Class<?>>();\n                    for (InterceptorDescription interceptorDescription : description.getAllInterceptors().values()) {\n                        EEModuleClassConfiguration clazz = module.getClassConfiguration(interceptorDescription.getInterceptorClassName());\n                        if (clazz != null) {\n                            interceptorClasses.add(clazz.getModuleClass());\n                        }\n                    }\n\n\n                    addWeldInstantiator(context.getServiceTarget(), configuration, componentClass, beanName, deploymentUnit.getServiceName(), beanManagerServiceName, beanManager, interceptorClasses);\n\n                    configuration.getPostConstructInterceptors().addLast(new WeldInjectionInterceptor.Factory(configuration, interceptorClasses));\n                }\n            });\n\n        }\n\n    }","commit_id":"58ccd019fea2d5f686ab9db09cf2df9226a83306","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ManagedReference getReference() {\n        final BeanManagerImpl beanManager = this.beanManager.getValue();\n        if (injectionTarget == null) {\n            synchronized (this) {\n                if (injectionTarget == null) {\n\n                    for(final Class<?> interceptor : interceptorClasses) {\n                        interceptorInjections.put(interceptor, WeldEEInjection.createWeldEEInjection(interceptor, null, beanManager));\n                    }\n\n                    if (ejbName != null) {\n                        EjbDescriptor<Object> descriptor = beanManager.getEjbDescriptor(ejbName);\n                        bean = beanManager.getBean(descriptor);\n                    }\n                    injectionTarget = WeldEEInjection.createWeldEEInjection(componentClass, bean, beanManager);\n                }\n            }\n        }\n        final CreationalContext<?> ctx;\n        if (bean == null) {\n            ctx = beanManager.createCreationalContext(null);\n        } else {\n            ctx = beanManager.createCreationalContext(bean);\n        }\n        final Object instance = injectionTarget.produce(ctx);\n        return new WeldManagedReference(ctx, instance, injectionTarget, interceptorInjections);\n    }","id":93915,"modified_method":"@Override\n    public ManagedReference getReference() {\n        final BeanManagerImpl beanManager = this.beanManager.getValue();\n        final CreationalContext<?> ctx;\n        if (bean == null) {\n            ctx = beanManager.createCreationalContext(null);\n        } else {\n            ctx = beanManager.createCreationalContext(bean);\n        }\n        final Object instance = injectionTarget.produce(ctx);\n        return new WeldManagedReference(ctx, instance, injectionTarget, interceptorInjections);\n    }","commit_id":"58ccd019fea2d5f686ab9db09cf2df9226a83306","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n\tpublic void destroy() {\n\t\tdisconnect();\n\n\t\t_messageBusEventListeners.clear();\n\n\t\t_messageBusEventListenerServiceRegistrar.destroy();\n\n\t\t_destinationConfigurations.clear();\n\n\t\t_destinationConfigServiceRegistrar.destroy();\n\n\t\t_destinations.clear();\n\n\t\t_destinationServiceRegistrar.destroy(\n\n\t\t\tnew ServiceFinalizer<Destination>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void finalize(\n\t\t\t\t\tServiceReference<Destination> serviceReference,\n\t\t\t\t\tDestination destination) {\n\n\t\t\t\t\tdestination.close();\n\n\t\t\t\t\tdestination.removeDestinationEventListeners();\n\n\t\t\t\t\tdestination.unregisterMessageListeners();\n\t\t\t}\n\n\t\t});\n\n\t\t_messageListeners.clear();\n\n\t\t_messageListenerServiceRegistrar.destroy();\n\n\t\t_destinationEventListeners.clear();\n\n\t\t_destinationEventListenerServiceRegistrar.destroy();\n\n\t\tClassLoader operatingClassLoader = getOperatingClassloader();\n\n\t\tString servletContextName = ClassLoaderPool.getContextName(\n\t\t\toperatingClassLoader);\n\n\t\tMessagingConfiguratorRegistry.unregisterMessagingConfigurator(\n\t\t\tservletContextName, this);\n\t}","id":93916,"modified_method":"@Override\n\tpublic void destroy() {\n\t\tdisconnect();\n\n\t\t_messageBusEventListeners.clear();\n\n\t\tif (_messageBusEventListenerServiceRegistrar != null) {\n\t\t\t_messageBusEventListenerServiceRegistrar.destroy();\n\t\t}\n\n\t\t_destinationConfigurations.clear();\n\n\t\tif (_destinationConfigServiceRegistrar != null) {\n\t\t\t_destinationConfigServiceRegistrar.destroy();\n\t\t}\n\n\t\t_destinations.clear();\n\n\t\tif (_destinationServiceRegistrar != null) {\n\t\t\t_destinationServiceRegistrar.destroy(\n\n\t\t\t\tnew ServiceFinalizer<Destination>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void finalize(\n\t\t\t\t\t\tServiceReference<Destination> serviceReference,\n\t\t\t\t\t\tDestination destination) {\n\n\t\t\t\t\t\tdestination.close();\n\n\t\t\t\t\t\tdestination.removeDestinationEventListeners();\n\n\t\t\t\t\t\tdestination.unregisterMessageListeners();\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t}\n\n\t\t_messageListeners.clear();\n\n\t\tif (_messageListenerServiceRegistrar != null) {\n\t\t\t_messageListenerServiceRegistrar.destroy();\n\t\t}\n\n\t\t_destinationEventListeners.clear();\n\n\t\tif (_destinationEventListenerServiceRegistrar != null) {\n\t\t\t_destinationEventListenerServiceRegistrar.destroy();\n\t\t}\n\n\t\tClassLoader operatingClassLoader = getOperatingClassloader();\n\n\t\tString servletContextName = ClassLoaderPool.getContextName(\n\t\t\toperatingClassLoader);\n\n\t\tMessagingConfiguratorRegistry.unregisterMessagingConfigurator(\n\t\t\tservletContextName, this);\n\t}","commit_id":"40c101f572b03b172d3dc5d17195e1beeea2b0a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void registerDestinations() {\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\tif (_destinationServiceRegistrar == null) {\n\t\t\t_destinationServiceRegistrar = registry.getServiceRegistrar(\n\t\t\t\tDestination.class);\n\t\t}\n\n\t\tfor (Destination destination : _destinations) {\n\t\t\tString destinationName = destination.getName();\n\n\t\t\ttry {\n\t\t\t\tPortalMessageBusPermission.checkListen(destinationName);\n\t\t\t}\n\t\t\tcatch (SecurityException se) {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Rejecting destination \" + destinationName);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tMap<String, Object> properties = new HashMap<>();\n\n\t\t\tproperties.put(\"destination.name\", destinationName);\n\n\t\t\t_destinationServiceRegistrar.registerService(\n\t\t\t\tDestination.class, destination, properties);\n\t\t}\n\t}","id":93917,"modified_method":"protected void registerDestinations() {\n\t\tif (_destinations.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t_destinationServiceRegistrar = registry.getServiceRegistrar(\n\t\t\tDestination.class);\n\n\t\tfor (Destination destination : _destinations) {\n\t\t\tString destinationName = destination.getName();\n\n\t\t\ttry {\n\t\t\t\tPortalMessageBusPermission.checkListen(destinationName);\n\t\t\t}\n\t\t\tcatch (SecurityException se) {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Rejecting destination \" + destinationName);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tMap<String, Object> properties = new HashMap<>();\n\n\t\t\tproperties.put(\"destination.name\", destinationName);\n\n\t\t\t_destinationServiceRegistrar.registerService(\n\t\t\t\tDestination.class, destination, properties);\n\t\t}\n\t}","commit_id":"40c101f572b03b172d3dc5d17195e1beeea2b0a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public synchronized void stop(final StopContext context) {\n        thread.interrupt();\n        thread = null;\n        instance.destroy();\n    }","id":93918,"modified_method":"@Override\n    public synchronized void stop(final StopContext context) {\n        if(instance != null) {\n            instance.destroy();\n        }\n        thread.interrupt();\n        thread = null;\n    }","commit_id":"4e77385411ab4e77e3dd9ff92ddea162535af9c8","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void init(FilterConfig filterConfig) throws ServletException {\n        Binding binding = new Binding();\n        binding.setVariable(\"authenticationManagerProxy\", AUTHENTICATION_MANAGER);\n        binding.setVariable(\"UserDetailsServiceProxy\", USER_DETAILS_SERVICE_PROXY);\n        binding.setVariable(\"app\", Hudson.getInstance());\n        BeanBuilder builder = new BeanBuilder();\n        builder.parse(filterConfig.getServletContext().getResourceAsStream(\"/WEB-INF/security/SecurityFilters.groovy\"),binding);\n\n        WebApplicationContext context = builder.createApplicationContext();\n        \n        acegi = (Filter) context.getBean(\"filter\");\n        acegi.init(filterConfig);\n\n        legacy = (Filter) context.getBean(\"legacy\");\n        legacy.init(filterConfig);\n    }","id":93919,"modified_method":"public void init(FilterConfig filterConfig) throws ServletException {\n        Binding binding = new Binding();\n        binding.setVariable(\"authenticationManagerProxy\", AUTHENTICATION_MANAGER);\n        binding.setVariable(\"userDetailsServiceProxy\", USER_DETAILS_SERVICE_PROXY);\n        binding.setVariable(\"app\", Hudson.getInstance());\n        BeanBuilder builder = new BeanBuilder();\n        builder.parse(filterConfig.getServletContext().getResourceAsStream(\"/WEB-INF/security/SecurityFilters.groovy\"),binding);\n\n        WebApplicationContext context = builder.createApplicationContext();\n        \n        acegi = (Filter) context.getBean(\"filter\");\n        acegi.init(filterConfig);\n\n        legacy = (Filter) context.getBean(\"legacy\");\n        legacy.init(filterConfig);\n    }","commit_id":"4da8aec86ec27fb5a705553fdcc34d227f7b2db9","url":"https://github.com/kohsuke/hudson"},{"original_method":"public void destroy() {\n        legacy.destroy();\n        acegi.destroy();\n    }","id":93920,"modified_method":"public void destroy() {\n        // these fields can be null if HudsonFilter.init() fails in the middle\n        if(legacy!=null)\n            legacy.destroy();\n        if(acegi!=null)\n            acegi.destroy();\n    }","commit_id":"4da8aec86ec27fb5a705553fdcc34d227f7b2db9","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n\tpublic void destroy() {\n\t\t_serviceRegistrar.destroy();\n\n\t\tportalCaches.clear();\n\n\t\tdoDestroy();\n\t}","id":93921,"modified_method":"@Override\n\tpublic void destroy() {\n\t\tif (_serviceRegistrar != null) {\n\t\t\t_serviceRegistrar.destroy();\n\t\t}\n\n\t\tif (_serviceTracker != null) {\n\t\t\t_serviceTracker.close();\n\t\t}\n\n\t\tportalCaches.clear();\n\n\t\tdoDestroy();\n\t}","commit_id":"429e1f3b2621313d0c3cc569c8fd19685e7bc8f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initialize() {\n\t\tif ((_portalCacheManagerConfiguration != null) ||\n\t\t\t(_mpiOnly && SPIUtil.isSPI())) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (Validator.isNull(_name)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Portal cache manager name is not specified\");\n\t\t}\n\n\t\tinitPortalCacheManager();\n\n\t\t_portalCacheManagerConfiguration = getPortalCacheManagerConfiguration();\n\n\t\tfor (CallbackConfiguration callbackConfiguration :\n\t\t\t\t_portalCacheManagerConfiguration.\n\t\t\t\t\tgetCacheManagerListenerConfigurations()) {\n\n\t\t\tCallbackFactory callbackFactory =\n\t\t\t\tcallbackConfiguration.getCallbackFactory();\n\n\t\t\tCacheManagerListener cacheManagerListener =\n\t\t\t\tcallbackFactory.createCacheManagerListener(\n\t\t\t\t\tcallbackConfiguration.getProperties());\n\n\t\t\tif (cacheManagerListener != null) {\n\t\t\t\tregisterCacheManagerListener(cacheManagerListener);\n\t\t\t}\n\t\t}\n\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t_serviceRegistrar = registry.getServiceRegistrar(\n\t\t\t(Class<PortalCacheManager<K, V>>)(Class<?>)\n\t\t\t\tPortalCacheManager.class);\n\n\t\tMap<String, Object> properties = new HashMap<>();\n\n\t\tproperties.put(\"portal.cache.manager.name\", _name);\n\t\tproperties.put(\"portal.cache.manager.type\", getType());\n\n\t\t_serviceRegistrar.registerService(\n\t\t\t(Class<PortalCacheManager<K, V>>)(Class<?>)PortalCacheManager.class,\n\t\t\tthis, properties);\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"(&(objectClass=\");\n\t\tsb.append(PortalCacheConfiguratorSettings.class.getName());\n\t\tsb.append(\")(portal.cache.manager.name=\");\n\t\tsb.append(_name);\n\t\tsb.append(\"))\");\n\n\t\tFilter filter = registry.getFilter(sb.toString());\n\n\t\tServiceTracker<PortalCacheConfiguratorSettings,\n\t\t\tPortalCacheConfiguratorSettings> serviceTracker =\n\t\t\t\tregistry.trackServices(\n\t\t\t\t\tfilter,\n\t\t\t\t\tnew PortalCacheConfiguratorSettingsServiceTrackerCustomizer());\n\n\t\tserviceTracker.open();\n\t}","id":93922,"modified_method":"protected void initialize() {\n\t\tif ((_portalCacheManagerConfiguration != null) ||\n\t\t\t(_mpiOnly && SPIUtil.isSPI())) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (Validator.isNull(_name)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Portal cache manager name is not specified\");\n\t\t}\n\n\t\tinitPortalCacheManager();\n\n\t\t_portalCacheManagerConfiguration = getPortalCacheManagerConfiguration();\n\n\t\tfor (CallbackConfiguration callbackConfiguration :\n\t\t\t\t_portalCacheManagerConfiguration.\n\t\t\t\t\tgetCacheManagerListenerConfigurations()) {\n\n\t\t\tCallbackFactory callbackFactory =\n\t\t\t\tcallbackConfiguration.getCallbackFactory();\n\n\t\t\tCacheManagerListener cacheManagerListener =\n\t\t\t\tcallbackFactory.createCacheManagerListener(\n\t\t\t\t\tcallbackConfiguration.getProperties());\n\n\t\t\tif (cacheManagerListener != null) {\n\t\t\t\tregisterCacheManagerListener(cacheManagerListener);\n\t\t\t}\n\t\t}\n\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t_serviceRegistrar = registry.getServiceRegistrar(\n\t\t\t(Class<PortalCacheManager<K, V>>)(Class<?>)\n\t\t\t\tPortalCacheManager.class);\n\n\t\tMap<String, Object> properties = new HashMap<>();\n\n\t\tproperties.put(\"portal.cache.manager.name\", _name);\n\t\tproperties.put(\"portal.cache.manager.type\", getType());\n\n\t\t_serviceRegistrar.registerService(\n\t\t\t(Class<PortalCacheManager<K, V>>)(Class<?>)PortalCacheManager.class,\n\t\t\tthis, properties);\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"(&(objectClass=\");\n\t\tsb.append(PortalCacheConfiguratorSettings.class.getName());\n\t\tsb.append(\")(portal.cache.manager.name=\");\n\t\tsb.append(_name);\n\t\tsb.append(\"))\");\n\n\t\tFilter filter = registry.getFilter(sb.toString());\n\n\t\t_serviceTracker = registry.trackServices(\n\t\t\tfilter,\n\t\t\tnew PortalCacheConfiguratorSettingsServiceTrackerCustomizer());\n\n\t\t_serviceTracker.open();\n\t}","commit_id":"429e1f3b2621313d0c3cc569c8fd19685e7bc8f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        int randomNumber = (int)(Math.random() * 3);\r\n        Permanent target = game.getPermanent(source.getTargets().get(randomNumber).getFirstTarget());\r\n        if (target != null) {\r\n            game.informPlayers(\"Wild Swing: The randomly chosen target to destroy is \" + target.getName());\r\n            return target.destroy(source.getSourceId(), game, false);\r\n        }\r\n        return false;\r\n    }","id":93923,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        MageObject sourceObject = source.getSourceObject(game);\r\n        if (!source.getTargets().isEmpty() && sourceObject != null) {\r\n            Target target = source.getTargets().get(0);\r\n            if (target != null && !target.getTargets().isEmpty()) {\r\n                Random rnd = new Random();\r\n                Permanent targetPermanent = game.getPermanent(target.getTargets().get(rnd.nextInt(target.getTargets().size())));\r\n                if (targetPermanent != null) {\r\n                    game.informPlayers(sourceObject.getLogName() + \": The randomly chosen target to destroy is \" + targetPermanent.getLogName());\r\n                    targetPermanent.destroy(source.getSourceId(), game, false);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"04ab3adec51cb401c0735eba78b11c3154be1b10","url":"https://github.com/magefree/mage"},{"original_method":"public String getReferencePresentation(SNode targetNode, boolean visible, boolean smartRef, boolean inEditor, String defaultPresentation) {\n    // todo: remove default presentation\n    if (myScopeProvider == null || !myScopeProvider.hasPresentation()) {\n      return defaultPresentation;\n    }\n\n    return myScopeProvider.getPresentation(getOperationContext(getModule(myReference)),\n      new PresentationReferentConstraintContext(myReferentConstraintContext.getModel(), myReferentConstraintContext.getEnclosingNode(),\n        myReferentConstraintContext.getReferenceNode(), myReferentConstraintContext.getLinkTarget(), targetNode, myReferentConstraintContext.getContainingLink(), visible, smartRef, inEditor));\n  }","id":93924,"modified_method":"public String getReferencePresentation(SNode targetNode, boolean visible, boolean smartRef, boolean inEditor, String defaultPresentation) {\n    // todo: remove default presentation, use node.getPresentation() instead?\n    if (scopeProvider == null || !scopeProvider.hasPresentation()) {\n      return defaultPresentation;\n    }\n\n    return scopeProvider.getPresentation(\n      getOperationContext(module),\n      new PresentationReferentConstraintContext(model, enclosingNode, referenceNode, linkTarget, targetNode, containingLinkDeclaration, visible, smartRef, inEditor)\n    );\n  }","commit_id":"2c227c484fb3df96415e12118b2dad7c86725360","url":"https://github.com/JetBrains/MPS"},{"original_method":"ReferenceDescriptor(@NotNull SReference reference) {\n    myReference = reference;\n    SNode node = reference.getSourceNode();\n    myRefRole = reference.getRole();\n    myRefConcept = node.getConceptDeclarationNode();\n    SNode linkDeclaration = SModelSearchUtil.findLinkDeclaration(myRefConcept, myRefRole);\n    myReferentConstraintContext = createReferentConstraintContext(true, node.getParent(), node, myRefRole, 0, SModelUtil.getLinkDeclarationTarget(linkDeclaration), node.getRoleLink());\n    myScopeProvider = getScopeProvider(myRefConcept, myRefRole);\n  }","id":93925,"modified_method":"ReferenceDescriptor(@NotNull SReference reference) {\n    SNode node = reference.getSourceNode();\n\n    // not synthetic\n    this.reference = reference;\n    sourceNodeConcept = node.getConceptDeclarationNode();\n    refRole = reference.getRole();\n    role = refRole;\n    enclosingNode = node.getParent();\n    referenceNode = node;\n    linkTarget = SModelUtil.getLinkDeclarationTarget(SModelSearchUtil.findLinkDeclaration(sourceNodeConcept, refRole));\n    containingLinkDeclaration = node.getRoleLink();\n    index = 0;\n\n    // my stuff\n    scopeProvider = getScopeProvider(sourceNodeConcept, refRole);\n    contextNode = referenceNode != null ? referenceNode : enclosingNode;\n    model = contextNode != null ? contextNode.getModel() : null;\n    module = getModule(model);\n    exists = reference != null;\n  }","commit_id":"2c227c484fb3df96415e12118b2dad7c86725360","url":"https://github.com/JetBrains/MPS"},{"original_method":"ReferenceDescriptor(@NotNull SNode enclosingNode, @Nullable String role, int index, @NotNull SNode smartConcept) {\n    myReference = null;\n    myRefConcept = smartConcept;\n    final SNode smartReference = ReferenceConceptUtil.getCharacteristicReference(smartConcept);\n    if (smartReference == null) {\n      throw new IllegalArgumentException(\"smartConcept has no characteristic reference: \" + smartConcept.getName());\n    }\n    myRefRole = SModelUtil.getGenuineLinkRole(smartReference);\n    SNode linkDeclaration = role != null ? enclosingNode.getLinkDeclaration(role) : null;\n    if (linkDeclaration != null && SNodeUtil.getLinkDeclaration_IsReference(linkDeclaration)) {\n      throw new IllegalArgumentException(\"for reference role smartConcept should be null\");\n    }\n    myReferentConstraintContext = createReferentConstraintContext(false, enclosingNode, null, role, index, SModelUtil.getLinkDeclarationTarget(smartReference), linkDeclaration);\n    myScopeProvider = getScopeProvider(smartConcept, myRefRole);\n  }","id":93926,"modified_method":"ReferenceDescriptor(@NotNull SNode enclosingNode, @Nullable String role, int index, @NotNull SNode smartConcept) {\n    final SNode smartReference = ReferenceConceptUtil.getCharacteristicReference(smartConcept);\n    if (smartReference == null) {\n      throw new IllegalArgumentException(\"smartConcept has no characteristic reference: \" + smartConcept.getName());\n    }\n    SNode linkDeclaration = role != null ? enclosingNode.getLinkDeclaration(role) : null;\n    if (linkDeclaration != null && SNodeUtil.getLinkDeclaration_IsReference(linkDeclaration)) {\n      throw new IllegalArgumentException(\"for reference role smartConcept should be null\");\n    }\n\n    // not synthetic\n    reference = null;\n    sourceNodeConcept = smartConcept;\n    refRole = SModelUtil.getGenuineLinkRole(smartReference);\n    this.role = role;\n    this.enclosingNode = enclosingNode;\n    referenceNode = null;\n    linkTarget = SModelUtil.getLinkDeclarationTarget(smartReference);\n    containingLinkDeclaration = linkDeclaration;\n    this.index = index;\n\n    // my stuff\n    scopeProvider = getScopeProvider(sourceNodeConcept, refRole);\n    contextNode = referenceNode != null ? referenceNode : enclosingNode;\n    model = contextNode != null ? contextNode.getModel() : null;\n    module = getModule(model);\n    exists = reference != null;\n  }","commit_id":"2c227c484fb3df96415e12118b2dad7c86725360","url":"https://github.com/JetBrains/MPS"},{"original_method":"ReferenceDescriptor(@NotNull SNode referenceNode, @NotNull String role, int index) {\n    myReference = null;\n    SNode scopeReference = referenceNode.getLinkDeclaration(role);\n    if (scopeReference == null) {\n      throw new IllegalArgumentException(\"can't find link for role '\" + role + \"' in '\" + referenceNode.getConcept().getId() + \"'\");\n    }\n    myReferentConstraintContext = createReferentConstraintContext(false, referenceNode.getParent(), referenceNode, role, 0, SModelUtil.getLinkDeclarationTarget(scopeReference), referenceNode.getRoleLink());\n    myRefConcept = referenceNode.getConceptDeclarationNode();\n    myRefRole = SModelUtil.getGenuineLinkRole(scopeReference);\n    myScopeProvider = getScopeProvider(myRefConcept, myRefRole);\n  }","id":93927,"modified_method":"ReferenceDescriptor(@NotNull SNode referenceNode, @NotNull String role, int index) {\n    SNode scopeReference = referenceNode.getLinkDeclaration(role);\n    if (scopeReference == null) {\n      throw new IllegalArgumentException(\"can't find link for role '\" + role + \"' in '\" + referenceNode.getConcept().getId() + \"'\");\n    }\n\n    // not synthetic\n    reference = null;\n    sourceNodeConcept = referenceNode.getConceptDeclarationNode();\n    refRole =  SModelUtil.getGenuineLinkRole(scopeReference);\n    this.role = role;\n    enclosingNode = referenceNode.getParent();\n    this.referenceNode = referenceNode;\n    linkTarget = SModelUtil.getLinkDeclarationTarget(scopeReference);\n    containingLinkDeclaration = referenceNode.getRoleLink();\n    this.index = 0;\n\n    // my stuff\n    scopeProvider = getScopeProvider(sourceNodeConcept, refRole);\n    contextNode = referenceNode != null ? referenceNode : enclosingNode;\n    model = contextNode != null ? contextNode.getModel() : null;\n    module = getModule(model);\n    exists = reference != null;\n  }","commit_id":"2c227c484fb3df96415e12118b2dad7c86725360","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public ReferenceScopeProvider getScopeProvider() {\n    return myScopeProvider;\n  }","id":93928,"modified_method":"@Nullable\n  public ReferenceScopeProvider getScopeProvider() {\n    return scopeProvider;\n  }","commit_id":"2c227c484fb3df96415e12118b2dad7c86725360","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Scope getScope() {\n    return TypeContextManager.getInstance().runResolveAction(new Computable<Scope>() {\n      @Override\n      public Scope compute() {\n        try {\n          if (myScopeProvider != null) {\n            Scope searchScope = myScopeProvider.createScope(getOperationContext(getModule(myReference)), myReferentConstraintContext);\n            if (searchScope != null) {\n              if (myReference != null && searchScope instanceof Adapter) {\n                return new RefAdapter(((Adapter) searchScope).getSearchScope(), myReference);\n              }\n              return searchScope;\n            }\n          }\n          // global search scope\n          return new jetbrains.mps.scope.DefaultScope(myReferentConstraintContext.getModel(), getModuleScope(getModule(myReference)), NameUtil.nodeFQName(myReferentConstraintContext.getLinkTarget()));\n        } catch (Exception t) {\n          LOG.error(t, myReferentConstraintContext.getReferenceNode() != null ? myReferentConstraintContext.getReferenceNode() : myReferentConstraintContext.getEnclosingNode());\n          return new ErrorScope(\"can't create search scope for role `\" + myRefRole + \"' in '\" + myRefConcept.getName() + \"'\");\n        }\n      }\n    });\n  }","id":93929,"modified_method":"public Scope getScope() {\n    final ReferentConstraintContext context = new ReferentConstraintContext(model, exists, contextNode, role, index, enclosingNode, referenceNode, linkTarget, containingLinkDeclaration);;\n\n    return TypeContextManager.getInstance().runResolveAction(new Computable<Scope>() {\n      @Override\n      public Scope compute() {\n        try {\n          if (scopeProvider != null) {\n            Scope searchScope = scopeProvider.createScope(getOperationContext(module), context);\n            if (searchScope != null) {\n              if (reference != null && searchScope instanceof Adapter) {\n                return new RefAdapter(((Adapter) searchScope).getSearchScope(), reference);\n              }\n              return searchScope;\n            }\n          }\n          // global search scope\n          return new jetbrains.mps.scope.DefaultScope(model, getModuleScope(module), NameUtil.nodeFQName(linkTarget));\n        } catch (Exception t) {\n          LOG.error(t, contextNode);\n          return new ErrorScope(\"can't create search scope for role `\" + refRole + \"' in '\" + sourceNodeConcept.getName() + \"'\");\n        }\n      }\n    });\n  }","commit_id":"2c227c484fb3df96415e12118b2dad7c86725360","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * @param linkRole - use *genuine* link role here!!!\n   */\n  public static SearchScopeStatus getSearchScope(SNode enclosingNode, SNode referenceNode, SNode referenceNodeConcept, String linkRole, SNode containingLinkDeclaration, IOperationContext context) {\n    return getSearchScope(enclosingNode, referenceNode, referenceNodeConcept, linkRole, null, containingLinkDeclaration, context);\n  }","id":93930,"modified_method":"/**\n   * @param linkRole - use *genuine* link role here!!!\n   */\n  public static SearchScopeStatus getSearchScope(SNode enclosingNode, SNode referenceNode, SNode referenceNodeConcept, String linkRole, SNode containingLinkDeclaration, IOperationContext context) {\n    return getSearchScope(createReferentConstraintContext(enclosingNode, referenceNode, null, containingLinkDeclaration), referenceNodeConcept, linkRole, context);\n  }","commit_id":"38a7b6f48a54619edbd5432208648731e7c3ab0e","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public static Scope getScope(@NotNull SReference reference, IOperationContext context) {\n    ModelAccess.assertLegalRead();\n\n    SNode node = reference.getSourceNode();\n    String role = reference.getRole();\n    SNode concept = node.getConceptDeclarationNode();\n    SearchScopeStatus status = getSearchScope(node.getParent(), node, concept, role, null, node.getRoleLink(), context);\n    if (status.isOk()) {\n      if (status.isDefault()) {\n        SNode linkDeclaration = SModelSearchUtil.findLinkDeclaration(concept, reference.getRole());\n        SNode linkTarget = SModelUtil.getLinkDeclarationTarget(linkDeclaration);\n        return createDefaultScope(reference.getSourceNode().getModel(), context, NameUtil.nodeFQName(linkTarget));\n      }\n      return new RefAdapter(status.getSearchScope(), reference);\n    }\n    return new ErrorScope(status.getMessage());\n  }","id":93931,"modified_method":"@NotNull\n  public static Scope getScope(@NotNull SReference reference, IOperationContext context) {\n    ModelAccess.assertLegalRead();\n\n    SNode node = reference.getSourceNode();\n    String role = reference.getRole();\n    SNode concept = node.getConceptDeclarationNode();\n    SearchScopeStatus status = getSearchScope(createReferentConstraintContext(node.getParent(), node, null, node.getRoleLink()), concept, role, context);\n    if (status.isOk()) {\n      if (status.isDefault()) {\n        SNode linkDeclaration = SModelSearchUtil.findLinkDeclaration(concept, reference.getRole());\n        SNode linkTarget = SModelUtil.getLinkDeclarationTarget(linkDeclaration);\n        return createDefaultScope(reference.getSourceNode().getModel(), context, NameUtil.nodeFQName(linkTarget));\n      }\n      return new RefAdapter(status.getSearchScope(), reference);\n    }\n    return new ErrorScope(status.getMessage());\n  }","commit_id":"38a7b6f48a54619edbd5432208648731e7c3ab0e","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public static Scope getScope(@NotNull SNode enclosingNode, @Nullable String role, int index, @Nullable SNode smartConcept, IOperationContext context) {\n    ModelAccess.assertLegalRead();\n\n    SearchScopeStatus status;\n    SNode scopeReference;\n    if (smartConcept == null) {\n      if (role == null) throw new NullPointerException(\"role and smartConcept cannot be null at the same time\");\n      scopeReference = enclosingNode.getLinkDeclaration(role);\n      if (scopeReference == null) {\n        return new ErrorScope(\"can't find link for role '\" + role + \"' in '\" + enclosingNode.getConceptFqName() + \"'\");\n      }\n      status = getSearchScope(enclosingNode.getParent(), enclosingNode, enclosingNode.getConceptDeclarationNode(), SModelUtil.getGenuineLinkRole(scopeReference), SModelUtil.getLinkDeclarationTarget(scopeReference), enclosingNode.getRoleLink(), context);\n    } else {\n      scopeReference = ReferenceConceptUtil.getCharacteristicReference(smartConcept);\n      SNode linkDeclaration = role != null ? enclosingNode.getLinkDeclaration(role) : null;\n      if (linkDeclaration != null && SNodeUtil.getLinkDeclaration_IsReference(linkDeclaration)) {\n        throw new IllegalArgumentException(\"for reference role smartConcept should be null\");\n      }\n      status = getSearchScope(enclosingNode, null, smartConcept, SModelUtil.getGenuineLinkRole(scopeReference), SModelUtil.getLinkDeclarationTarget(scopeReference), linkDeclaration, context);\n    }\n    if (status.isOk()) {\n      if (status.isDefault()) {\n        SNode smartTarget = SModelUtil.getLinkDeclarationTarget(scopeReference);\n        return createDefaultScope(enclosingNode.getModel(), context, NameUtil.nodeFQName(smartTarget));\n      }\n      return new Adapter(status.getSearchScope());\n    }\n    return new ErrorScope(status.getMessage());\n  }","id":93932,"modified_method":"@NotNull\n  public static Scope getScope(@NotNull SNode enclosingNode, @Nullable String role, int index, @Nullable SNode smartConcept, IOperationContext context) {\n    ModelAccess.assertLegalRead();\n\n    SearchScopeStatus status;\n    SNode scopeReference;\n    if (smartConcept == null) {\n      if (role == null) throw new NullPointerException(\"role and smartConcept cannot be null at the same time\");\n      scopeReference = enclosingNode.getLinkDeclaration(role);\n      if (scopeReference == null) {\n        return new ErrorScope(\"can't find link for role '\" + role + \"' in '\" + enclosingNode.getConceptFqName() + \"'\");\n      }\n      status = getSearchScope(createReferentConstraintContext(enclosingNode.getParent(), enclosingNode, SModelUtil.getLinkDeclarationTarget(scopeReference), enclosingNode.getRoleLink()), enclosingNode.getConceptDeclarationNode(), SModelUtil.getGenuineLinkRole(scopeReference), context);\n    } else {\n      scopeReference = ReferenceConceptUtil.getCharacteristicReference(smartConcept);\n      SNode linkDeclaration = role != null ? enclosingNode.getLinkDeclaration(role) : null;\n      if (linkDeclaration != null && SNodeUtil.getLinkDeclaration_IsReference(linkDeclaration)) {\n        throw new IllegalArgumentException(\"for reference role smartConcept should be null\");\n      }\n      status = getSearchScope(createReferentConstraintContext(enclosingNode, null, SModelUtil.getLinkDeclarationTarget(scopeReference), linkDeclaration), smartConcept, SModelUtil.getGenuineLinkRole(scopeReference), context);\n    }\n    if (status.isOk()) {\n      if (status.isDefault()) {\n        SNode smartTarget = SModelUtil.getLinkDeclarationTarget(scopeReference);\n        return createDefaultScope(enclosingNode.getModel(), context, NameUtil.nodeFQName(smartTarget));\n      }\n      return new Adapter(status.getSearchScope());\n    }\n    return new ErrorScope(status.getMessage());\n  }","commit_id":"38a7b6f48a54619edbd5432208648731e7c3ab0e","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SearchScopeStatus getSearchScope(SNode enclosingNode, final SNode referenceNode, final SNode referenceNodeConcept, final String linkRole, SNode linkTarget, SNode containingLinkDeclaration, final IOperationContext context) {\n    ModelAccess.assertLegalRead();\n\n    final SModel model;\n    if (enclosingNode != null) {\n      model = enclosingNode.getModel();\n    } else if (referenceNode != null) {\n      model = referenceNode.getModel();\n      enclosingNode = referenceNode.getParent();\n    } else {\n      model = null;\n    }\n\n    final ReferenceScopeProvider scopeProvider = ModelConstraintsManager.getNodeReferentSearchScopeProvider(referenceNodeConcept, linkRole);\n    final ReferentConstraintContext referentConstraintContext = new ReferentConstraintContext(model, enclosingNode, referenceNode, linkTarget, containingLinkDeclaration);\n\n    return TypeContextManager.getInstance().runResolveAction(new Computable<SearchScopeStatus>() {\n      @Override\n      public SearchScopeStatus compute() {\n        try {\n          return getSearchScope_intern(scopeProvider, referentConstraintContext, context);\n        } catch (Exception t) {\n          LOG.error(t, referenceNode != null ? referenceNode : referentConstraintContext.getEnclosingNode());\n          return new SearchScopeStatus.ERROR(\"can't create search scope for role '\" + linkRole + \"' in '\" + referenceNodeConcept.getName() + \"'\");\n        }\n      }\n    });\n  }","id":93933,"modified_method":"private static SearchScopeStatus getSearchScope(final ReferentConstraintContext referentConstraintContext, final SNode referenceNodeConcept, final String linkRole, final IOperationContext context) {\n    ModelAccess.assertLegalRead();\n    final ReferenceScopeProvider scopeProvider = ModelConstraintsManager.getNodeReferentSearchScopeProvider(referenceNodeConcept, linkRole);\n\n    return TypeContextManager.getInstance().runResolveAction(new Computable<SearchScopeStatus>() {\n      @Override\n      public SearchScopeStatus compute() {\n        try {\n          return getSearchScope_intern(scopeProvider, referentConstraintContext, context);\n        } catch (Exception t) {\n          LOG.error(t, referentConstraintContext.getReferenceNode() != null ? referentConstraintContext.getReferenceNode() : referentConstraintContext.getEnclosingNode());\n          return new SearchScopeStatus.ERROR(\"can't create search scope for role '\" + linkRole + \"' in '\" + referenceNodeConcept.getName() + \"'\");\n        }\n      }\n    });\n  }","commit_id":"38a7b6f48a54619edbd5432208648731e7c3ab0e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SearchScopeStatus getSearchScope(SNode enclosingNode, SNode referenceNode, SNode referenceNodeConcept, SNode referenceLinkDeclaration, SNode containingLinkDeclaration, IOperationContext context) {\n    String linkRole = SModelUtil.getGenuineLinkRole(referenceLinkDeclaration);\n    SNode linkTarget = SModelUtil.getLinkDeclarationTarget(referenceLinkDeclaration);\n    return getSearchScope(enclosingNode, referenceNode, referenceNodeConcept, linkRole, linkTarget, containingLinkDeclaration, context);\n  }","id":93934,"modified_method":"public static SearchScopeStatus getSearchScope(SNode enclosingNode, SNode referenceNode, SNode referenceNodeConcept, SNode referenceLinkDeclaration, SNode containingLinkDeclaration, IOperationContext context) {\n    String linkRole = SModelUtil.getGenuineLinkRole(referenceLinkDeclaration);\n    SNode linkTarget = SModelUtil.getLinkDeclarationTarget(referenceLinkDeclaration);\n    return getSearchScope(createReferentConstraintContext(enclosingNode, referenceNode, linkTarget, containingLinkDeclaration), referenceNodeConcept, linkRole, context);\n  }","commit_id":"38a7b6f48a54619edbd5432208648731e7c3ab0e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addBuffer(byte buf[], int offset, int length)\n    {\n        if (this.length + length > maxSize)\n        {\n            throw new MessageTooLargeException(\"Frame is too large\");\n        }\n        buffers.add(new Buf(buf,offset,length));\n        this.length += length;\n    }","id":93935,"modified_method":"public void addChunk(byte buf[], int offset, int length)\n    {\n        if (this.length + length > maxSize)\n        {\n            throw new MessageTooLargeException(\"Frame is too large\");\n        }\n        chunks.add(new Chunk(buf, offset, length));\n        this.length += length;\n    }","commit_id":"81b8990dece9979d0633e9235590c386c2390284","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public ByteAccumulator(int maxOverallBufferSize)\n    {\n        this.maxSize = maxOverallBufferSize;\n        this.buffers = new ArrayList<>();\n    }","id":93936,"modified_method":"public ByteAccumulator(int maxOverallBufferSize)\n    {\n        this.maxSize = maxOverallBufferSize;\n    }","commit_id":"81b8990dece9979d0633e9235590c386c2390284","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public String toString()\n    {\n        return this.getClass().getSimpleName() + \"[]\";\n    }","id":93937,"modified_method":"@Override\n    public String toString()\n    {\n        return getClass().getSimpleName();\n    }","commit_id":"81b8990dece9979d0633e9235590c386c2390284","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void incomingFrame(Frame frame)\n    {\n        if (OpCode.isControlFrame(frame.getOpCode()) || !frame.isRsv1())\n        {\n            // Cannot modify incoming control frames or ones with RSV1 set.\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        if (!frame.hasPayload())\n        {\n            // no payload? nothing to do.\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        // Prime the decompressor\n        ByteBuffer payload = frame.getPayload();\n        int inlen = payload.remaining();\n        byte compressed[] = new byte[inlen + TAIL.length];\n        payload.get(compressed,0,inlen);\n        System.arraycopy(TAIL,0,compressed,inlen,TAIL.length);\n\n        // Since we don't track text vs binary vs continuation state, just grab whatever is the greater value.\n        int maxSize = Math.max(getPolicy().getMaxTextMessageSize(),getPolicy().getMaxBinaryMessageBufferSize());\n        ByteAccumulator accumulator = new ByteAccumulator(maxSize);\n\n        DataFrame out = new DataFrame(frame);\n        out.setRsv1(false); // Unset RSV1\n\n        synchronized (decompressor)\n        {\n            decompressor.setInput(compressed,0,compressed.length);\n\n            // Perform decompression\n            while (decompressor.getRemaining() > 0 && !decompressor.finished())\n            {\n                byte outbuf[] = new byte[Math.min(inlen * 2,bufferSize)];\n                try\n                {\n                    int len = decompressor.inflate(outbuf);\n                    if (len == 0)\n                    {\n                        if (decompressor.needsInput())\n                        {\n                            throw new BadPayloadException(\"Unable to inflate frame, not enough input on frame\");\n                        }\n                        if (decompressor.needsDictionary())\n                        {\n                            throw new BadPayloadException(\"Unable to inflate frame, frame erroneously says it needs a dictionary\");\n                        }\n                    }\n                    if (len > 0)\n                    {\n                        accumulator.addBuffer(outbuf,0,len);\n                    }\n                }\n                catch (DataFormatException e)\n                {\n                    LOG.warn(e);\n                    throw new BadPayloadException(e);\n                }\n            }\n        }\n\n        // Forward on the frame\n        out.setPayload(accumulator.getByteBuffer(getBufferPool()));\n        nextIncomingFrame(out);\n    }","id":93938,"modified_method":"@Override\n    public void incomingFrame(Frame frame)\n    {\n        // Incoming frames are always non concurrent because\n        // they are read and parsed with a single thread, and\n        // therefore there is no need for synchronization.\n\n        if (OpCode.isControlFrame(frame.getOpCode()) || !frame.isRsv1())\n        {\n            // Cannot modify incoming control frames or ones without RSV1 set.\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        if (!frame.hasPayload())\n        {\n            // No payload ? Nothing to do.\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        ByteBuffer payload = frame.getPayload();\n        int remaining = payload.remaining();\n        byte[] input = new byte[remaining + TAIL_BYTES.length];\n        payload.get(input, 0, remaining);\n        System.arraycopy(TAIL_BYTES, 0, input, remaining, TAIL_BYTES.length);\n\n        // Since we don't track text vs binary vs continuation state, just grab whatever is the greater value.\n        int maxSize = Math.max(getPolicy().getMaxTextMessageSize(), getPolicy().getMaxBinaryMessageBufferSize());\n        ByteAccumulator accumulator = new ByteAccumulator(maxSize);\n\n        DataFrame out = new DataFrame(frame);\n        // Unset RSV1 since it's not compressed anymore.\n        out.setRsv1(false);\n\n        decompressor.setInput(input, 0, input.length);\n\n        try\n        {\n            while (decompressor.getRemaining() > 0)\n            {\n                byte[] output = new byte[Math.min(remaining * 2, 64 * 1024)];\n                int len = decompressor.inflate(output);\n                if (len == 0)\n                {\n                    if (decompressor.needsInput())\n                    {\n                        throw new BadPayloadException(\"Unable to inflate frame, not enough input on frame\");\n                    }\n                    if (decompressor.needsDictionary())\n                    {\n                        throw new BadPayloadException(\"Unable to inflate frame, frame erroneously says it needs a dictionary\");\n                    }\n                }\n                else\n                {\n                    accumulator.addChunk(output, 0, len);\n                }\n            }\n        }\n        catch (DataFormatException x)\n        {\n            throw new BadPayloadException(x);\n        }\n\n        ByteBuffer buffer = getBufferPool().acquire(accumulator.getLength(), false);\n        try\n        {\n            BufferUtil.flipToFill(buffer);\n            accumulator.transferTo(buffer);\n            out.setPayload(buffer);\n            nextIncomingFrame(out);\n        }\n        finally\n        {\n            getBufferPool().release(buffer);\n        }\n    }","commit_id":"81b8990dece9979d0633e9235590c386c2390284","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void outgoingFrame(Frame frame, WriteCallback callback)\n    {\n        if (OpCode.isControlFrame(frame.getOpCode()))\n        {\n            // skip, cannot compress control frames.\n            nextOutgoingFrame(frame,callback);\n            return;\n        }\n\n        if (!frame.hasPayload())\n        {\n            // pass through, nothing to do\n            nextOutgoingFrame(frame,callback);\n            return;\n        }\n\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"outgoingFrame({}, {}) - {}\",OpCode.name(frame.getOpCode()),callback != null?callback.getClass().getSimpleName():\"<null>\",\n                    BufferUtil.toDetailString(frame.getPayload()));\n        }\n\n        // Prime the compressor\n        byte uncompressed[] = BufferUtil.toArray(frame.getPayload());\n        List<DataFrame> dframes = new ArrayList<>();\n\n        synchronized (compressor)\n        {\n            // Perform the compression\n            if (!compressor.finished())\n            {\n                compressor.setInput(uncompressed,0,uncompressed.length);\n                byte compressed[] = new byte[uncompressed.length + OVERHEAD];\n\n                while (!compressor.needsInput())\n                {\n                    int len = compressor.deflate(compressed,0,compressed.length,Deflater.SYNC_FLUSH);\n                    ByteBuffer outbuf = getBufferPool().acquire(len,true);\n                    BufferUtil.clearToFill(outbuf);\n\n                    if (len > 0)\n                    {\n                        outbuf.put(compressed,0,len - 4);\n                    }\n\n                    BufferUtil.flipToFlush(outbuf,0);\n\n                    if (len > 0 && BFINAL_HACK)\n                    {\n                        /*\n                         * Per the spec, it says that BFINAL 1 or 0 are allowed.\n                         * \n                         * However, Java always uses BFINAL 1, whereas the browsers Chromium and Safari fail to decompress when it encounters BFINAL 1.\n                         * \n                         * This hack will always set BFINAL 0\n                         */\n                        byte b0 = outbuf.get(0);\n                        if ((b0 & 1) != 0) // if BFINAL 1\n                        {\n                            outbuf.put(0,(b0 ^= 1)); // flip bit to BFINAL 0\n                        }\n                    }\n\n                    DataFrame out = new DataFrame(frame);\n                    out.setRsv1(true);\n                    out.setBufferPool(getBufferPool());\n                    out.setPayload(outbuf);\n\n                    if (!compressor.needsInput())\n                    {\n                        // this is fragmented\n                        out.setFin(false);\n                    }\n                    dframes.add(out);\n                }\n            }\n        }\n        \n        // notify outside of synchronize\n        for (DataFrame df : dframes)\n        {\n            if (df.isFin())\n            {\n                nextOutgoingFrame(df,callback);\n            }\n            else\n            {\n                // non final frames have no callback\n                nextOutgoingFrame(df,null);\n            }\n        }\n    }","id":93939,"modified_method":"@Override\n    public void outgoingFrame(Frame frame, WriteCallback callback)\n    {\n        if (flusher.isFailed())\n        {\n            if (callback != null)\n                callback.writeFailed(new ZipException());\n            return;\n        }\n\n        FrameEntry entry = new FrameEntry(frame, callback);\n        LOG.debug(\"Queuing {}\", entry);\n        entries.offer(entry);\n        flusher.iterate();\n    }","commit_id":"81b8990dece9979d0633e9235590c386c2390284","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public synchronized void incomingFrame(Frame frame)\n    {\n        switch (frame.getOpCode())\n        {\n            case OpCode.BINARY: // fall-thru\n            case OpCode.TEXT:\n                incomingCompressed = frame.isRsv1();\n                break;\n            case OpCode.CONTINUATION:\n                if (!incomingCompressed)\n                {\n                    nextIncomingFrame(frame);\n                }\n                break;\n            default:\n                // All others are assumed to be control frames\n                nextIncomingFrame(frame);\n                return;\n        }\n\n        if (!incomingCompressed || !frame.hasPayload())\n        {\n            // nothing to do with this frame\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        // Prime the decompressor\n        ByteBuffer payload = frame.getPayload();\n        int inlen = payload.remaining();\n        byte compressed[] = null;\n\n        if (frame.isFin())\n        {\n            compressed = new byte[inlen + TAIL.length];\n            payload.get(compressed,0,inlen);\n            System.arraycopy(TAIL,0,compressed,inlen,TAIL.length);\n            incomingCompressed = false;\n        }\n        else\n        {\n            compressed = new byte[inlen];\n            payload.get(compressed,0,inlen);\n        }\n\n        decompressor.setInput(compressed,0,compressed.length);\n\n        // Since we don't track text vs binary vs continuation state, just grab whatever is the greater value.\n        int maxSize = Math.max(getPolicy().getMaxTextMessageSize(),getPolicy().getMaxBinaryMessageBufferSize());\n        ByteAccumulator accumulator = new ByteAccumulator(maxSize);\n\n        DataFrame out = new DataFrame(frame);\n        out.setRsv1(false); // Unset RSV1\n\n        // Perform decompression\n        while (decompressor.getRemaining() > 0 && !decompressor.finished())\n        {\n            byte outbuf[] = new byte[inlen];\n            try\n            {\n                int len = decompressor.inflate(outbuf);\n                if (len == 0)\n                {\n                    if (decompressor.needsInput())\n                    {\n                        throw new BadPayloadException(\"Unable to inflate frame, not enough input on frame\");\n                    }\n                    if (decompressor.needsDictionary())\n                    {\n                        throw new BadPayloadException(\"Unable to inflate frame, frame erroneously says it needs a dictionary\");\n                    }\n                }\n                if (len > 0)\n                {\n                    accumulator.addBuffer(outbuf,0,len);\n                }\n            }\n            catch (DataFormatException e)\n            {\n                LOG.warn(e);\n                throw new BadPayloadException(e);\n            }\n        }\n\n        // Forward on the frame\n        out.setPayload(accumulator.getByteBuffer(getBufferPool()));\n        nextIncomingFrame(out);\n    }","id":93940,"modified_method":"@Override\n    public synchronized void incomingFrame(Frame frame)\n    {\n        switch (frame.getOpCode())\n        {\n            case OpCode.BINARY: // fall-thru\n            case OpCode.TEXT:\n                incomingCompressed = frame.isRsv1();\n                break;\n            case OpCode.CONTINUATION:\n                if (!incomingCompressed)\n                {\n                    nextIncomingFrame(frame);\n                }\n                break;\n            default:\n                // All others are assumed to be control frames\n                nextIncomingFrame(frame);\n                return;\n        }\n\n        if (!incomingCompressed || !frame.hasPayload())\n        {\n            // nothing to do with this frame\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        // Prime the decompressor\n        ByteBuffer payload = frame.getPayload();\n        int inlen = payload.remaining();\n        byte compressed[] = null;\n\n        if (frame.isFin())\n        {\n            compressed = new byte[inlen + TAIL.length];\n            payload.get(compressed,0,inlen);\n            System.arraycopy(TAIL,0,compressed,inlen,TAIL.length);\n            incomingCompressed = false;\n        }\n        else\n        {\n            compressed = new byte[inlen];\n            payload.get(compressed,0,inlen);\n        }\n\n        decompressor.setInput(compressed,0,compressed.length);\n\n        // Since we don't track text vs binary vs continuation state, just grab whatever is the greater value.\n        int maxSize = Math.max(getPolicy().getMaxTextMessageSize(),getPolicy().getMaxBinaryMessageBufferSize());\n        ByteAccumulator accumulator = new ByteAccumulator(maxSize);\n\n        DataFrame out = new DataFrame(frame);\n        out.setRsv1(false); // Unset RSV1\n\n        // Perform decompression\n        while (decompressor.getRemaining() > 0 && !decompressor.finished())\n        {\n            byte outbuf[] = new byte[inlen];\n            try\n            {\n                int len = decompressor.inflate(outbuf);\n                if (len == 0)\n                {\n                    if (decompressor.needsInput())\n                    {\n                        throw new BadPayloadException(\"Unable to inflate frame, not enough input on frame\");\n                    }\n                    if (decompressor.needsDictionary())\n                    {\n                        throw new BadPayloadException(\"Unable to inflate frame, frame erroneously says it needs a dictionary\");\n                    }\n                }\n                if (len > 0)\n                {\n                    accumulator.addChunk(outbuf, 0, len);\n                }\n            }\n            catch (DataFormatException e)\n            {\n                LOG.warn(e);\n                throw new BadPayloadException(e);\n            }\n        }\n\n        ByteBuffer buffer = getBufferPool().acquire(accumulator.getLength(), false);\n        try\n        {\n            BufferUtil.flipToFill(buffer);\n            accumulator.transferTo(buffer);\n            out.setPayload(buffer);\n            nextIncomingFrame(out);\n        }\n        finally\n        {\n            getBufferPool().release(buffer);\n        }\n    }","commit_id":"81b8990dece9979d0633e9235590c386c2390284","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public synchronized void incomingFrame(Frame frame)\n    {\n        if (OpCode.isControlFrame(frame.getOpCode()) || !frame.isRsv1())\n        {\n            // Cannot modify incoming control frames or ones with RSV1 set.\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        if (!frame.hasPayload())\n        {\n            // no payload? nothing to do.\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        // Prime the decompressor\n        ByteBuffer payload = frame.getPayload();\n        int inlen = payload.remaining();\n        byte compressed[] = new byte[inlen + TAIL.length];\n        payload.get(compressed,0,inlen);\n        System.arraycopy(TAIL,0,compressed,inlen,TAIL.length);\n        decompressor.setInput(compressed,0,compressed.length);\n\n        // Perform decompression\n        while (decompressor.getRemaining() > 0 && !decompressor.finished())\n        {\n            DataFrame out = new DataFrame(frame);\n            out.setRsv1(false); // Unset RSV1\n            byte outbuf[] = new byte[Math.min(inlen * 2,bufferSize)];\n            try\n            {\n                int len = decompressor.inflate(outbuf);\n                if (len == 0)\n                {\n                    if (decompressor.needsInput())\n                    {\n                        throw new BadPayloadException(\"Unable to inflate frame, not enough input on frame\");\n                    }\n                    if (decompressor.needsDictionary())\n                    {\n                        throw new BadPayloadException(\"Unable to inflate frame, frame erroneously says it needs a dictionary\");\n                    }\n                }\n                if (len > 0)\n                {\n                    out.setPayload(ByteBuffer.wrap(outbuf,0,len));\n                }\n                nextIncomingFrame(out);\n            }\n            catch (DataFormatException e)\n            {\n                LOG.warn(e);\n                throw new BadPayloadException(e);\n            }\n        }\n    }","id":93941,"modified_method":"@Override\n    public synchronized void incomingFrame(Frame frame)\n    {\n        if (OpCode.isControlFrame(frame.getOpCode()) || !frame.isRsv1())\n        {\n            // Cannot modify incoming control frames or ones with RSV1 set.\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        if (!frame.hasPayload())\n        {\n            // no payload? nothing to do.\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        // Prime the decompressor\n        ByteBuffer payload = frame.getPayload();\n        int inlen = payload.remaining();\n        byte compressed[] = new byte[inlen + TAIL.length];\n        payload.get(compressed,0,inlen);\n        System.arraycopy(TAIL,0,compressed,inlen,TAIL.length);\n        decompressor.setInput(compressed,0,compressed.length);\n\n        // Since we don't track text vs binary vs continuation state, just grab whatever is the greater value.\n        int maxSize = Math.max(getPolicy().getMaxTextMessageSize(),getPolicy().getMaxBinaryMessageBufferSize());\n        ByteAccumulator accumulator = new ByteAccumulator(maxSize);\n\n        DataFrame out = new DataFrame(frame);\n        out.setRsv1(false); // Unset RSV1\n\n        // Perform decompression\n        while (decompressor.getRemaining() > 0 && !decompressor.finished())\n        {\n            byte outbuf[] = new byte[Math.min(inlen * 2,bufferSize)];\n            try\n            {\n                int len = decompressor.inflate(outbuf);\n                if (len == 0)\n                {\n                    if (decompressor.needsInput())\n                    {\n                        throw new BadPayloadException(\"Unable to inflate frame, not enough input on frame\");\n                    }\n                    if (decompressor.needsDictionary())\n                    {\n                        throw new BadPayloadException(\"Unable to inflate frame, frame erroneously says it needs a dictionary\");\n                    }\n                }\n                if (len > 0)\n                {\n                    accumulator.addBuffer(outbuf,0,len);\n                }\n            }\n            catch (DataFormatException e)\n            {\n                LOG.warn(e);\n                throw new BadPayloadException(e);\n            }\n        }\n\n        // Forward on the frame\n        out.setPayload(accumulator.getByteBuffer(getBufferPool()));\n        nextIncomingFrame(out);\n    }","commit_id":"5445c42ffea4bb054a436504b3c3f645fa363f66","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public synchronized void incomingFrame(Frame frame)\n    {\n        if (OpCode.isControlFrame(frame.getOpCode()) || !frame.isRsv1())\n        {\n            // Cannot modify incoming control frames or ones with RSV1 set.\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        if (!frame.hasPayload())\n        {\n            // no payload? nothing to do.\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        // Prime the decompressor\n        ByteBuffer payload = frame.getPayload();\n        int inlen = payload.remaining();\n        byte compressed[] = new byte[inlen + TAIL.length];\n        payload.get(compressed,0,inlen);\n        System.arraycopy(TAIL,0,compressed,inlen,TAIL.length);\n        decompressor.setInput(compressed,0,compressed.length);\n\n        // Perform decompression\n        while (decompressor.getRemaining() > 0 && !decompressor.finished())\n        {\n            DataFrame out = new DataFrame(frame);\n            out.setRsv1(false); // Unset RSV1\n            byte outbuf[] = new byte[Math.min(inlen * 2,bufferSize)];\n            try\n            {\n                int len = decompressor.inflate(outbuf);\n                if (len == 0)\n                {\n                    if (decompressor.needsInput())\n                    {\n                        throw new BadPayloadException(\"Unable to inflate frame, not enough input on frame\");\n                    }\n                    if (decompressor.needsDictionary())\n                    {\n                        throw new BadPayloadException(\"Unable to inflate frame, frame erroneously says it needs a dictionary\");\n                    }\n                }\n                if (len > 0)\n                {\n                    out.setPayload(ByteBuffer.wrap(outbuf,0,len));\n                }\n                nextIncomingFrame(out);\n            }\n            catch (DataFormatException e)\n            {\n                LOG.warn(e);\n                throw new BadPayloadException(e);\n            }\n        }\n    }","id":93942,"modified_method":"@Override\n    public synchronized void incomingFrame(Frame frame)\n    {\n        if (OpCode.isControlFrame(frame.getOpCode()) || !frame.isRsv1())\n        {\n            // Cannot modify incoming control frames or ones with RSV1 set.\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        if (!frame.hasPayload())\n        {\n            // no payload? nothing to do.\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        // Prime the decompressor\n        ByteBuffer payload = frame.getPayload();\n        int inlen = payload.remaining();\n        byte compressed[] = new byte[inlen + TAIL.length];\n        payload.get(compressed,0,inlen);\n        System.arraycopy(TAIL,0,compressed,inlen,TAIL.length);\n        decompressor.setInput(compressed,0,compressed.length);\n\n        // Since we don't track text vs binary vs continuation state, just grab whatever is the greater value.\n        int maxSize = Math.max(getPolicy().getMaxTextMessageSize(),getPolicy().getMaxBinaryMessageBufferSize());\n        ByteAccumulator accumulator = new ByteAccumulator(maxSize);\n\n        DataFrame out = new DataFrame(frame);\n        out.setRsv1(false); // Unset RSV1\n\n        // Perform decompression\n        while (decompressor.getRemaining() > 0 && !decompressor.finished())\n        {\n            byte outbuf[] = new byte[Math.min(inlen * 2,bufferSize)];\n            try\n            {\n                int len = decompressor.inflate(outbuf);\n                if (len == 0)\n                {\n                    if (decompressor.needsInput())\n                    {\n                        throw new BadPayloadException(\"Unable to inflate frame, not enough input on frame\");\n                    }\n                    if (decompressor.needsDictionary())\n                    {\n                        throw new BadPayloadException(\"Unable to inflate frame, frame erroneously says it needs a dictionary\");\n                    }\n                }\n                if (len > 0)\n                {\n                    accumulator.addBuffer(outbuf,0,len);\n                }\n            }\n            catch (DataFormatException e)\n            {\n                LOG.warn(e);\n                throw new BadPayloadException(e);\n            }\n        }\n\n        // Forward on the frame\n        out.setPayload(accumulator.getByteBuffer(getBufferPool()));\n        nextIncomingFrame(out);\n    }","commit_id":"5445c42ffea4bb054a436504b3c3f645fa363f66","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void invoke(Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PsiDocCommentOwner container = getContainer();\n    ReadonlyStatusHandler.getInstance(project).ensureFilesWritable(new VirtualFile[] {container.getContainingFile().getVirtualFile()});\n    PsiDocComment docComment = container.getDocComment();\n    if (docComment != null){\n      PsiDocTag noInspectionTag = docComment.findTagByName(InspectionManagerEx.SUPPRESS_INSPECTIONS_TAG_NAME);\n      if (noInspectionTag != null) {\n        String tagText = \"@\" + InspectionManagerEx.SUPPRESS_INSPECTIONS_TAG_NAME + \" ALL\";\n        noInspectionTag.replace(myContext.getManager().getElementFactory().createDocTagFromText(tagText, null));\n        return;\n      }\n    }\n    super.invoke(project, editor, file);\n  }","id":93943,"modified_method":"public void invoke(Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PsiDocCommentOwner container = getContainer();\n    final ReadonlyStatusHandler.OperationStatus status = ReadonlyStatusHandler.getInstance(project)\n      .ensureFilesWritable(new VirtualFile[]{container.getContainingFile().getVirtualFile()});\n    if (status.hasReadonlyFiles()) return;\n    PsiDocComment docComment = container.getDocComment();\n    if (docComment != null){\n      PsiDocTag noInspectionTag = docComment.findTagByName(InspectionManagerEx.SUPPRESS_INSPECTIONS_TAG_NAME);\n      if (noInspectionTag != null) {\n        String tagText = \"@\" + InspectionManagerEx.SUPPRESS_INSPECTIONS_TAG_NAME + \" ALL\";\n        noInspectionTag.replace(myContext.getManager().getElementFactory().createDocTagFromText(tagText, null));\n        return;\n      }\n    }\n    super.invoke(project, editor, file);\n  }","commit_id":"bea6fea11908a73b835149b5426662fc0e67bb98","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PsiStatement container = getContainer();\n    ReadonlyStatusHandler.getInstance(project).ensureFilesWritable(new VirtualFile[] {container.getContainingFile().getVirtualFile()});\n    PsiElement prev = PsiTreeUtil.skipSiblingsBackward(container, new Class[]{PsiWhiteSpace.class});\n    PsiElementFactory factory = myContext.getManager().getElementFactory();\n    if (prev instanceof PsiComment) {\n      String text = prev.getText();\n      if (text.startsWith(COMMENT_START_TEXT)) {\n        prev.replace(factory.createCommentFromText(text + \",\" + myID, null));\n        return;\n      }\n    }\n    boolean caretWasBeforeStatement = editor.getCaretModel().getOffset() == container.getTextRange().getStartOffset();\n    container.getParent().addBefore(factory.createCommentFromText(COMMENT_START_TEXT +  myID, null), container);\n    if (caretWasBeforeStatement) {\n      editor.getCaretModel().moveToOffset(container.getTextRange().getStartOffset());\n    }\n    QuickFixAction.markDocumentForUndo(file);\n  }","id":93944,"modified_method":"public void invoke(Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PsiStatement container = getContainer();\n    final ReadonlyStatusHandler.OperationStatus status = ReadonlyStatusHandler.getInstance(project)\n      .ensureFilesWritable(new VirtualFile[]{container.getContainingFile().getVirtualFile()});\n    if (status.hasReadonlyFiles()) return;\n    PsiElement prev = PsiTreeUtil.skipSiblingsBackward(container, new Class[]{PsiWhiteSpace.class});\n    PsiElementFactory factory = myContext.getManager().getElementFactory();\n    if (prev instanceof PsiComment) {\n      String text = prev.getText();\n      if (text.startsWith(COMMENT_START_TEXT)) {\n        prev.replace(factory.createCommentFromText(text + \",\" + myID, null));\n        return;\n      }\n    }\n    boolean caretWasBeforeStatement = editor.getCaretModel().getOffset() == container.getTextRange().getStartOffset();\n    container.getParent().addBefore(factory.createCommentFromText(COMMENT_START_TEXT +  myID, null), container);\n    if (caretWasBeforeStatement) {\n      editor.getCaretModel().moveToOffset(container.getTextRange().getStartOffset());\n    }\n    QuickFixAction.markDocumentForUndo(file);\n  }","commit_id":"bea6fea11908a73b835149b5426662fc0e67bb98","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PsiDocCommentOwner container = getContainer();\n    ReadonlyStatusHandler.getInstance(project).ensureFilesWritable(new VirtualFile[] {container.getContainingFile().getVirtualFile()});\n    PsiDocComment docComment = container.getDocComment();\n    PsiManager manager = myContext.getManager();\n    if (docComment == null) {\n      String commentText = \"/** @\" + InspectionManagerEx.SUPPRESS_INSPECTIONS_TAG_NAME + \" \"+ myID + \"*/\";\n      docComment = manager.getElementFactory().createDocCommentFromText(commentText, null);\n      manager.getCodeStyleManager().reformat(docComment);\n      PsiElement firstChild = container.getFirstChild();\n      container.addBefore(docComment, firstChild);\n      manager.getCodeStyleManager().reformatRange(container,\n                                                  container.getTextRange().getStartOffset(),\n                                                  firstChild.getTextRange().getStartOffset());\n      return;\n    }\n\n    PsiDocTag noInspectionTag = docComment.findTagByName(InspectionManagerEx.SUPPRESS_INSPECTIONS_TAG_NAME);\n    if (noInspectionTag != null) {\n      String tagText = \"@\" + InspectionManagerEx.SUPPRESS_INSPECTIONS_TAG_NAME + \" \"\n                           + noInspectionTag.getValueElement().getText() + \",\"+ myID;\n      noInspectionTag.replace(manager.getElementFactory().createDocTagFromText(tagText, null));\n    } else {\n      String tagText = \"@\" + InspectionManagerEx.SUPPRESS_INSPECTIONS_TAG_NAME + \" \" + myID;\n      docComment.add(manager.getElementFactory().createDocTagFromText(tagText, null));\n    }\n  }","id":93945,"modified_method":"public void invoke(Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PsiDocCommentOwner container = getContainer();\n    final ReadonlyStatusHandler.OperationStatus status = ReadonlyStatusHandler.getInstance(project)\n      .ensureFilesWritable(new VirtualFile[]{container.getContainingFile().getVirtualFile()});\n    if (status.hasReadonlyFiles()) return;\n    PsiDocComment docComment = container.getDocComment();\n    PsiManager manager = myContext.getManager();\n    if (docComment == null) {\n      String commentText = \"/** @\" + InspectionManagerEx.SUPPRESS_INSPECTIONS_TAG_NAME + \" \"+ myID + \"*/\";\n      docComment = manager.getElementFactory().createDocCommentFromText(commentText, null);\n      manager.getCodeStyleManager().reformat(docComment);\n      PsiElement firstChild = container.getFirstChild();\n      container.addBefore(docComment, firstChild);\n      manager.getCodeStyleManager().reformatRange(container,\n                                                  container.getTextRange().getStartOffset(),\n                                                  firstChild.getTextRange().getStartOffset());\n      return;\n    }\n\n    PsiDocTag noInspectionTag = docComment.findTagByName(InspectionManagerEx.SUPPRESS_INSPECTIONS_TAG_NAME);\n    if (noInspectionTag != null) {\n      String tagText = \"@\" + InspectionManagerEx.SUPPRESS_INSPECTIONS_TAG_NAME + \" \"\n                           + noInspectionTag.getValueElement().getText() + \",\"+ myID;\n      noInspectionTag.replace(manager.getElementFactory().createDocTagFromText(tagText, null));\n    } else {\n      String tagText = \"@\" + InspectionManagerEx.SUPPRESS_INSPECTIONS_TAG_NAME + \" \" + myID;\n      docComment.add(manager.getElementFactory().createDocTagFromText(tagText, null));\n    }\n  }","commit_id":"bea6fea11908a73b835149b5426662fc0e67bb98","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doUpdateGadget(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong gadgetId = ParamUtil.getLong(actionRequest, \"gadgetId\");\n\n\t\tString name = ParamUtil.getString(actionRequest, \"name\");\n\t\tString url = ParamUtil.getString(actionRequest, \"url\");\n\n\t\tif (gadgetId <= 0) {\n\t\t\tGadgetLocalServiceUtil.addGadget(\n\t\t\t\tthemeDisplay.getCompanyId(), name, url);\n\t\t}\n\t\telse {\n\t\t\tGadgetLocalServiceUtil.updateGadget(gadgetId, name);\n\t\t}\n\t}","id":93946,"modified_method":"protected void doUpdateGadget(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong gadgetId = ParamUtil.getLong(actionRequest, \"gadgetId\");\n\n\t\tString name = ParamUtil.getString(actionRequest, \"name\");\n\t\tString url = ParamUtil.getString(actionRequest, \"url\");\n\n\t\tif (gadgetId <= 0) {\n\t\t\tGadgetLocalServiceUtil.addGadget(\n\t\t\t\tthemeDisplay.getCompanyId(), name, url);\n\t\t}\n\t\telse {\n\t\t\tGadgetLocalServiceUtil.updateGadget(\n\t\t\t\tthemeDisplay.getCompanyId(), gadgetId, name);\n\t\t}\n\t}","commit_id":"882f4be1f58c303205984704ca5707c0f205a52e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public com.liferay.opensocial.model.Gadget updateGadget(long gadgetId,\n\t\tjava.lang.String name)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\tObject paramObj0 = new LongWrapper(gadgetId);\n\n\t\tObject paramObj1 = ClpSerializer.translateInput(name);\n\n\t\tif (name == null) {\n\t\t\tparamObj1 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject returnObj = null;\n\n\t\ttry {\n\t\t\treturnObj = _classLoaderProxy.invoke(\"updateGadget\",\n\t\t\t\t\tnew Object[] { paramObj0, paramObj1 });\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tif (t instanceof com.liferay.portal.kernel.exception.PortalException) {\n\t\t\t\tthrow (com.liferay.portal.kernel.exception.PortalException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof com.liferay.portal.kernel.exception.SystemException) {\n\t\t\t\tthrow (com.liferay.portal.kernel.exception.SystemException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof RuntimeException) {\n\t\t\t\tthrow (RuntimeException)t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new RuntimeException(t.getClass().getName() +\n\t\t\t\t\t\" is not a valid exception\");\n\t\t\t}\n\t\t}\n\n\t\treturn (com.liferay.opensocial.model.Gadget)ClpSerializer.translateOutput(returnObj);\n\t}","id":93947,"modified_method":"public com.liferay.opensocial.model.Gadget updateGadget(long companyId,\n\t\tlong gadgetId, java.lang.String name)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\tObject paramObj0 = new LongWrapper(companyId);\n\n\t\tObject paramObj1 = new LongWrapper(gadgetId);\n\n\t\tObject paramObj2 = ClpSerializer.translateInput(name);\n\n\t\tif (name == null) {\n\t\t\tparamObj2 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject returnObj = null;\n\n\t\ttry {\n\t\t\treturnObj = _classLoaderProxy.invoke(\"updateGadget\",\n\t\t\t\t\tnew Object[] { paramObj0, paramObj1, paramObj2 });\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tif (t instanceof com.liferay.portal.kernel.exception.PortalException) {\n\t\t\t\tthrow (com.liferay.portal.kernel.exception.PortalException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof com.liferay.portal.kernel.exception.SystemException) {\n\t\t\t\tthrow (com.liferay.portal.kernel.exception.SystemException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof RuntimeException) {\n\t\t\t\tthrow (RuntimeException)t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new RuntimeException(t.getClass().getName() +\n\t\t\t\t\t\" is not a valid exception\");\n\t\t\t}\n\t\t}\n\n\t\treturn (com.liferay.opensocial.model.Gadget)ClpSerializer.translateOutput(returnObj);\n\t}","commit_id":"882f4be1f58c303205984704ca5707c0f205a52e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void deleteGadget(Gadget gadget)\n\t\tthrows PortalException, SystemException {\n\n\t\tgadgetLocalService.destroyGadget(gadget);\n\n\t\tgadgetPersistence.remove(gadget);\n\t}","id":93948,"modified_method":"public void deleteGadget(Gadget gadget)\n\t\tthrows PortalException, SystemException {\n\n\t\tgadgetLocalService.destroyGadget(\n\t\t\tgadget.getCompanyId(), gadget.getGadgetId(),\n\t\t\tgadget.getName());\n\n\t\tgadgetPersistence.remove(gadget);\n\t}","commit_id":"882f4be1f58c303205984704ca5707c0f205a52e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void destroyGadgets() throws PortalException, SystemException {\n\t\tList<Gadget> gadgets = gadgetPersistence.findAll();\n\n\t\tfor (Gadget gadget : gadgets) {\n\t\t\tdestroyGadget(gadget);\n\t\t}\n\t}","id":93949,"modified_method":"public void destroyGadgets() throws PortalException, SystemException {\n\t\tList<Gadget> gadgets = gadgetPersistence.findAll();\n\n\t\tfor (Gadget gadget : gadgets) {\n\t\t\tdestroyGadget(\n\t\t\t\tgadget.getCompanyId(), gadget.getGadgetId(), gadget.getName());\n\t\t}\n\t}","commit_id":"882f4be1f58c303205984704ca5707c0f205a52e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Clusterable\n\tpublic void initGadget(Gadget gadget)\n\t\tthrows PortalException, SystemException {\n\n\t\ttry {\n\t\t\tPortlet portlet = getPortlet(gadget);\n\n\t\t\tPortletLocalServiceUtil.deployRemotePortlet(\n\t\t\t\tportlet, _OPENSOCIAL_CATEGORY);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow pe;\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow se;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t}","id":93950,"modified_method":"@Clusterable\n\tpublic void initGadget(\n\t\t\tlong companyId, long gadgetId, String name)\n\t\tthrows PortalException, SystemException {\n\n\t\ttry {\n\t\t\tPortlet portlet = getPortlet(companyId, gadgetId, name);\n\n\t\t\tPortletLocalServiceUtil.deployRemotePortlet(\n\t\t\t\tportlet, _OPENSOCIAL_CATEGORY);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow pe;\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow se;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t}","commit_id":"882f4be1f58c303205984704ca5707c0f205a52e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void initGadgets()\n\t\tthrows PortalException, SystemException {\n\n\t\tList<Gadget> gadgets = gadgetPersistence.findAll();\n\n\t\tfor (Gadget gadget : gadgets) {\n\t\t\tinitGadget(gadget);\n\t\t}\n\t}","id":93951,"modified_method":"public void initGadgets()\n\t\tthrows PortalException, SystemException {\n\n\t\tList<Gadget> gadgets = gadgetPersistence.findAll();\n\n\t\tfor (Gadget gadget : gadgets) {\n\t\t\tinitGadget(\n\t\t\t\tgadget.getCompanyId(), gadget.getGadgetId(), gadget.getName());\n\t\t}\n\t}","commit_id":"882f4be1f58c303205984704ca5707c0f205a52e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public Gadget updateGadget(long gadgetId, String name)\n\t\tthrows PortalException, SystemException {\n\n\t\tDate now = new Date();\n\n\t\tvalidate(name);\n\n\t\tGadget gadget = gadgetPersistence.findByPrimaryKey(gadgetId);\n\n\t\tgadget.setModifiedDate(now);\n\t\tgadget.setName(name);\n\n\t\tgadgetPersistence.update(gadget, false);\n\n\t\ttry {\n\t\t\tPortlet portlet = getPortlet(gadget);\n\n\t\t\tportlet.setPortletInfo(new PortletInfo(name, name, name, name));\n\n\t\t\tPortletConfigFactoryUtil.update(portlet);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow pe;\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow se;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\n\t\treturn gadget;\n\t}","id":93952,"modified_method":"public Gadget updateGadget(long companyId, long gadgetId, String name)\n\t\tthrows PortalException, SystemException {\n\n\t\tDate now = new Date();\n\n\t\tvalidate(name);\n\n\t\tGadget gadget = gadgetPersistence.findByPrimaryKey(gadgetId);\n\n\t\tgadget.setModifiedDate(now);\n\t\tgadget.setName(name);\n\n\t\tgadgetPersistence.update(gadget, false);\n\n\t\ttry {\n\t\t\tPortlet portlet = getPortlet(companyId, gadgetId, name);\n\n\t\t\tportlet.setPortletInfo(new PortletInfo(name, name, name, name));\n\n\t\t\tPortletConfigFactoryUtil.update(portlet);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow pe;\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow se;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\n\t\treturn gadget;\n\t}","commit_id":"882f4be1f58c303205984704ca5707c0f205a52e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public Gadget addGadget(long companyId, String name, String url)\n\t\tthrows PortalException, SystemException {\n\n\t\tDate now = new Date();\n\n\t\tvalidate(name);\n\n\t\tlong gadgetId = counterLocalService.increment();\n\n\t\tGadget gadget = gadgetPersistence.create(gadgetId);\n\n\t\tgadget.setCompanyId(companyId);\n\t\tgadget.setCreateDate(now);\n\t\tgadget.setModifiedDate(now);\n\t\tgadget.setName(name);\n\t\tgadget.setUrl(url);\n\n\t\tgadgetPersistence.update(gadget, false);\n\n\t\tgadgetLocalService.initGadget(gadget);\n\n\t\treturn gadget;\n\t}","id":93953,"modified_method":"public Gadget addGadget(long companyId, String name, String url)\n\t\tthrows PortalException, SystemException {\n\n\t\tDate now = new Date();\n\n\t\tvalidate(name);\n\n\t\tlong gadgetId = counterLocalService.increment();\n\n\t\tGadget gadget = gadgetPersistence.create(gadgetId);\n\n\t\tgadget.setCompanyId(companyId);\n\t\tgadget.setCreateDate(now);\n\t\tgadget.setModifiedDate(now);\n\t\tgadget.setName(name);\n\t\tgadget.setUrl(url);\n\n\t\tgadgetPersistence.update(gadget, false);\n\n\t\tgadgetLocalService.initGadget(companyId, gadgetId, name);\n\n\t\treturn gadget;\n\t}","commit_id":"882f4be1f58c303205984704ca5707c0f205a52e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Clusterable\n\tpublic void destroyGadget(Gadget gadget)\n\t\tthrows PortalException, SystemException {\n\n\t\ttry {\n\t\t\tPortlet portlet = getPortlet(gadget);\n\n\t\t\tPortletLocalServiceUtil.destroyRemotePortlet(portlet);\n\n\t\t\tPortletInstanceFactoryUtil.destroy(portlet);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow pe;\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow se;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t}","id":93954,"modified_method":"@Clusterable\n\tpublic void destroyGadget(long companyId, long gadgetId, String name)\n\t\tthrows PortalException, SystemException {\n\n\t\ttry {\n\t\t\tPortlet portlet = getPortlet(companyId, gadgetId, name);\n\n\t\t\tPortletLocalServiceUtil.destroyRemotePortlet(portlet);\n\n\t\t\tPortletInstanceFactoryUtil.destroy(portlet);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow pe;\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow se;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t}","commit_id":"882f4be1f58c303205984704ca5707c0f205a52e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static com.liferay.opensocial.model.Gadget updateGadget(\n\t\tlong gadgetId, java.lang.String name)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn getService().updateGadget(gadgetId, name);\n\t}","id":93955,"modified_method":"public static com.liferay.opensocial.model.Gadget updateGadget(\n\t\tlong companyId, long gadgetId, java.lang.String name)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn getService().updateGadget(companyId, gadgetId, name);\n\t}","commit_id":"882f4be1f58c303205984704ca5707c0f205a52e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public com.liferay.opensocial.model.Gadget updateGadget(long gadgetId,\n\t\tjava.lang.String name)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn _gadgetLocalService.updateGadget(gadgetId, name);\n\t}","id":93956,"modified_method":"public com.liferay.opensocial.model.Gadget updateGadget(long companyId,\n\t\tlong gadgetId, java.lang.String name)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn _gadgetLocalService.updateGadget(companyId, gadgetId, name);\n\t}","commit_id":"882f4be1f58c303205984704ca5707c0f205a52e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static void setupDocker(Project project, String fromImage, String main) {\n        MavenPluginBuilder plugin = MavenPluginBuilder.create()\n                .setCoordinate(createCoordinate(\"org.jolokia\", \"docker-maven-plugin\", VersionHelper.dockerVersion()));\n\n        ConfigurationElement cfgName = ConfigurationElementBuilder.create().setName(\"name\").setText(\"${docker.image}\");\n        ConfigurationElement cfgFrom = ConfigurationElementBuilder.create().setName(\"from\").setText(\"${docker.from}\");\n        ConfigurationElement cfgDescriptorRef = ConfigurationElementBuilder.create().setName(\"descriptorRef\").setText(\"${docker.assemblyDescriptorRef}\");\n\n        ConfigurationElement cfgAssembly = ConfigurationElementBuilder.create().setName(\"assembly\");\n        cfgAssembly.getChildren().add(cfgDescriptorRef);\n\n        ConfigurationElement cfgBuild = ConfigurationElementBuilder.create().setName(\"build\");\n        cfgBuild.getChildren().add(cfgFrom);\n        cfgBuild.getChildren().add(cfgAssembly);\n\n        Map<String, String> envs = new LinkedHashMap<>();\n\n        boolean springBoot = hasSpringBootMavenPlugin(project);\n        String packaging = getProjectPackaging(project);\n        boolean war = packaging != null && packaging.equals(\"war\");\n        boolean bundle = packaging != null && packaging.equals(\"bundle\");\n        boolean jar = packaging != null && packaging.equals(\"jar\");\n\n        if (springBoot) {\n            envs.put(\"JAR\", \"${project.artifactId}-${project.version}.war\");\n            envs.put(\"JAVA_OPTIONS\", \"-Djava.security.egd=/dev/./urandom\");\n        } else if (war) {\n            envs.put(\"CATALINA_OPTS\", \"-javaagent:/opt/tomcat/jolokia-agent.jar=host=0.0.0.0,port=8778\");\n        } else if (jar && main != null) {\n            // only include main for JAR deployment as WAR/bundle is container based\n            envs.put(\"MAIN\", main);\n        }\n\n        if (!envs.isEmpty()) {\n            ConfigurationElement cfgEnv = ConfigurationElementBuilder.create().setName(\"env\");\n            cfgBuild.getChildren().add(cfgEnv);\n            for (Map.Entry<String, String> env : envs.entrySet()) {\n                ConfigurationElement cfg = ConfigurationElementBuilder.create().setName(env.getKey()).setText(env.getValue());\n                cfgEnv.getChildren().add(cfg);\n            }\n        }\n\n        if (bundle) {\n            // need to add command config when using bundle/karaf\n            ConfigurationElement cfgCommand = ConfigurationElementBuilder.create().setName(\"command\").setText(\"/usr/bin/deploy-and-start\");\n            cfgBuild.getChildren().add(cfgCommand);\n        }\n\n        ConfigurationElement cfgImage = ConfigurationElementBuilder.create().setName(\"image\");\n        cfgImage.getChildren().add(cfgName);\n        cfgImage.getChildren().add(cfgBuild);\n\n        ConfigurationElement cfgImages = ConfigurationElementBuilder.create().setName(\"images\");\n        cfgImages.getChildren().add(cfgImage);\n\n        setupDockerProperties(project, fromImage);\n\n        // add docker-maven-plugin using latest version\n        MavenPluginFacet pluginFacet = project.getFacet(MavenPluginFacet.class);\n        plugin.createConfiguration().addConfigurationElement(cfgImages);\n        pluginFacet.addPlugin(plugin);\n    }","id":93957,"modified_method":"public static void setupDocker(Project project, String fromImage, String main) {\n        MavenFacet maven = project.getFacet(MavenFacet.class);\n        Model pom = maven.getModel();\n        if (!MavenHelpers.hasMavenPlugin(pom, \"org.jolokia\", \"docker-maven-plugin\")) {\n            MavenPluginBuilder plugin = MavenPluginBuilder.create()\n                    .setCoordinate(createCoordinate(\"org.jolokia\", \"docker-maven-plugin\", VersionHelper.dockerVersion()));\n\n            ConfigurationElement cfgName = ConfigurationElementBuilder.create().setName(\"name\").setText(\"${docker.image}\");\n            ConfigurationElement cfgFrom = ConfigurationElementBuilder.create().setName(\"from\").setText(\"${docker.from}\");\n            ConfigurationElement cfgDescriptorRef = ConfigurationElementBuilder.create().setName(\"descriptorRef\").setText(\"${docker.assemblyDescriptorRef}\");\n\n            ConfigurationElement cfgAssembly = ConfigurationElementBuilder.create().setName(\"assembly\");\n            cfgAssembly.getChildren().add(cfgDescriptorRef);\n\n            ConfigurationElement cfgBuild = ConfigurationElementBuilder.create().setName(\"build\");\n            cfgBuild.getChildren().add(cfgFrom);\n            cfgBuild.getChildren().add(cfgAssembly);\n\n            Map<String, String> envs = new LinkedHashMap<>();\n\n            boolean springBoot = hasSpringBootMavenPlugin(project);\n            String packaging = getProjectPackaging(project);\n            boolean war = packaging != null && packaging.equals(\"war\");\n            boolean bundle = packaging != null && packaging.equals(\"bundle\");\n            boolean jar = packaging != null && packaging.equals(\"jar\");\n\n            if (springBoot) {\n                envs.put(\"JAR\", \"${project.artifactId}-${project.version}.war\");\n                envs.put(\"JAVA_OPTIONS\", \"-Djava.security.egd=/dev/./urandom\");\n            } else if (war) {\n                envs.put(\"CATALINA_OPTS\", \"-javaagent:/opt/tomcat/jolokia-agent.jar=host=0.0.0.0,port=8778\");\n            } else if (jar && main != null) {\n                // only include main for JAR deployment as WAR/bundle is container based\n                envs.put(\"MAIN\", main);\n            }\n\n            if (!envs.isEmpty()) {\n                ConfigurationElement cfgEnv = ConfigurationElementBuilder.create().setName(\"env\");\n                cfgBuild.getChildren().add(cfgEnv);\n                for (Map.Entry<String, String> env : envs.entrySet()) {\n                    ConfigurationElement cfg = ConfigurationElementBuilder.create().setName(env.getKey()).setText(env.getValue());\n                    cfgEnv.getChildren().add(cfg);\n                }\n            }\n\n            if (bundle) {\n                // need to add command config when using bundle/karaf\n                ConfigurationElement cfgCommand = ConfigurationElementBuilder.create().setName(\"command\").setText(\"/usr/bin/deploy-and-start\");\n                cfgBuild.getChildren().add(cfgCommand);\n            }\n\n            ConfigurationElement cfgImage = ConfigurationElementBuilder.create().setName(\"image\");\n            cfgImage.getChildren().add(cfgName);\n            cfgImage.getChildren().add(cfgBuild);\n\n            ConfigurationElement cfgImages = ConfigurationElementBuilder.create().setName(\"images\");\n            cfgImages.getChildren().add(cfgImage);\n\n            setupDockerProperties(project, fromImage);\n\n            // add docker-maven-plugin using latest version\n            MavenPluginFacet pluginFacet = project.getFacet(MavenPluginFacet.class);\n            plugin.createConfiguration().addConfigurationElement(cfgImages);\n            pluginFacet.addPlugin(plugin);\n        }\n    }","commit_id":"aa73caeeb4f351d62b4782175942159ac67de919","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static void setupDockerProperties(Project project, String fromImage) {\n        String packaging = getProjectPackaging(project);\n\n        boolean springBoot = hasSpringBootMavenPlugin(project);\n        boolean war = packaging != null && packaging.equals(\"war\");\n        boolean bundle = packaging != null && packaging.equals(\"bundle\");\n        boolean jar = packaging != null && packaging.equals(\"jar\");\n\n        // update properties section in pom.xml\n        MavenFacet maven = project.getFacet(MavenFacet.class);\n        Model pom = maven.getModel();\n        Properties properties = pom.getProperties();\n        properties.put(\"docker.registryPrefix\", \"${env.DOCKER_REGISTRY}/\");\n        properties.put(\"docker.from\", dockerFromImagePrefix + fromImage);\n        properties.put(\"docker.image\", \"${docker.registryPrefix}fabric8/${project.artifactId}:${project.version}\");\n        // jolokia is exposed on our docker images on port 8778\n        properties.put(\"docker.port.container.jolokia\", \"8778\");\n\n        if (springBoot) {\n            // spring-boot is packaged as war but runs as fat WARs\n            properties.put(\"docker.assemblyDescriptorRef\", \"artifact\");\n            properties.put(\"docker.port.container.http\", \"8080\");\n        } else if (war) {\n            // tomcat/jetty on port 8080\n            properties.put(\"docker.assemblyDescriptorRef\", \"rootWar\");\n            properties.put(\"docker.port.container.http\", \"8080\");\n        } else if (bundle) {\n            // karaf\n            properties.put(\"docker.assemblyDescriptorRef\", \"artifact-with-dependencies\");\n            properties.put(\"docker.port.container.http\", \"8181\");\n        } else {\n            properties.put(\"docker.assemblyDescriptorRef\", \"artifact-with-dependencies\");\n        }\n\n        // to save then set the model\n        maven.setModel(pom);\n    }","id":93958,"modified_method":"public static void setupDockerProperties(Project project, String fromImage) {\n        String packaging = getProjectPackaging(project);\n\n        boolean springBoot = hasSpringBootMavenPlugin(project);\n        boolean war = packaging != null && packaging.equals(\"war\");\n        boolean bundle = packaging != null && packaging.equals(\"bundle\");\n        boolean jar = packaging != null && packaging.equals(\"jar\");\n\n        // update properties section in pom.xml\n        MavenFacet maven = project.getFacet(MavenFacet.class);\n        Model pom = maven.getModel();\n        Properties properties = pom.getProperties();\n        boolean updated = false;\n        updated = MavenHelpers.updatePomProperty(properties, \"docker.registryPrefix\", \"${env.DOCKER_REGISTRY}/\", updated);\n        if (Strings.isNotBlank(fromImage)) {\n            updated = MavenHelpers.updatePomProperty(properties, \"docker.from\", dockerFromImagePrefix + fromImage, updated);\n        }\n        updated = MavenHelpers.updatePomProperty(properties, \"docker.image\", \"${docker.registryPrefix}fabric8/${project.artifactId}:${project.version}\", updated);\n        // jolokia is exposed on our docker images on port 8778\n        updated = MavenHelpers.updatePomProperty(properties, \"docker.port.container.jolokia\", \"8778\", updated);\n\n        if (springBoot) {\n            // spring-boot is packaged as war but runs as fat WARs\n            updated = MavenHelpers.updatePomProperty(properties, \"docker.assemblyDescriptorRef\", \"artifact\", updated);\n            updated = MavenHelpers.updatePomProperty(properties, \"docker.port.container.http\", \"8080\", updated);\n        } else if (war) {\n            // tomcat/jetty on port 8080\n            updated = MavenHelpers.updatePomProperty(properties, \"docker.assemblyDescriptorRef\", \"rootWar\", updated);\n            updated = MavenHelpers.updatePomProperty(properties, \"docker.port.container.http\", \"8080\", updated);\n        } else if (bundle) {\n            // karaf\n            updated = MavenHelpers.updatePomProperty(properties, \"docker.assemblyDescriptorRef\", \"artifact-with-dependencies\", updated);\n            updated = MavenHelpers.updatePomProperty(properties, \"docker.port.container.http\", \"8181\", updated);\n        } else {\n            updated = MavenHelpers.updatePomProperty(properties, \"docker.assemblyDescriptorRef\", \"artifact-with-dependencies\", updated);\n        }\n\n        // to save then set the model\n        if (updated) {\n            maven.setModel(pom);\n        }\n    }","commit_id":"aa73caeeb4f351d62b4782175942159ac67de919","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Result execute(UIExecutionContext context) throws Exception {\n        Project project = getCurrentProject(context.getUIContext());\n\n\n        System.out.println(\"====== execute() and we have a project: \" + project);\n\n        DockerSetupHelper.setupDocker(project, from.getValue(), main.getValue());\n\n        // make sure we have resources as we need it later\n        facetFactory.install(project, ResourcesFacet.class);\n\n        // install fabric8 bom\n\n        // include test dependencies?\n        if (test.getValue() != null && test.getValue()) {\n            // I guess we only need to add this import if we add a test case?\n            // unless the app is using fabric8-cdi or something?\n            Dependency bom = DependencyBuilder.create()\n                    .setCoordinate(MavenHelpers.createCoordinate(\"io.fabric8\", \"fabric8-project\", VersionHelper.fabric8Version(), \"pom\"))\n                    .setScopeType(\"import\");\n            dependencyInstaller.installManaged(project, bom);\n\n\n            Dependency dependency = DependencyBuilder.create()\n                    .setCoordinate(MavenHelpers.createCoordinate(\"io.fabric8\", \"arquillian-fabric8\", null))\n                    .setScopeType(\"test\");\n            dependencyInstaller.installManaged(project, dependency);\n\n            dependency = DependencyBuilder.create()\n                    .setCoordinate(MavenHelpers.createCoordinate(\"org.jboss.arquillian.junit\", \"arquillian-junit-container\", null))\n                    .setScopeType(\"test\");\n            dependencyInstaller.installManaged(project, dependency);\n        }\n\n        // add fabric8 plugin\n        MavenPluginFacet pluginFacet = project.getFacet(MavenPluginFacet.class);\n        MavenPlugin plugin = MavenPluginBuilder.create()\n                .setCoordinate(MavenHelpers.createCoordinate(\"io.fabric8\", \"fabric8-maven-plugin\", VersionHelper.fabric8Version()))\n                .addExecution(ExecutionBuilder.create().setId(\"json\").addGoal(\"json\"))\n                .addExecution(ExecutionBuilder.create().setId(\"zip\").addGoal(\"zip\"));\n        pluginFacet.addPlugin(plugin);\n\n        // update properties section in pom.xml\n        MavenFacet maven = project.getFacet(MavenFacet.class);\n        Model pom = maven.getModel();\n        Properties properties = pom.getProperties();\n        boolean updated = false;\n        if (container.getValue() != null) {\n            properties.put(\"fabric8.label.container\", container.getValue());\n            updated = true;\n        }\n        if (icon.getValue() != null) {\n            properties.put(\"fabric8.iconRef\", \"icons/\" + icon.getValue());\n            updated = true;\n        }\n        if (group.getValue() != null) {\n            properties.put(\"fabric8.label.group\", group.getValue());\n            updated = true;\n        }\n\n        // to save then set the model\n        if (updated) {\n            maven.setModel(pom);\n        }\n        return Results.success(\"Adding Fabric8 maven support with base Docker image: \" + from.getValue());\n    }","id":93959,"modified_method":"@Override\n    public Result execute(UIExecutionContext context) throws Exception {\n        Project project = getCurrentProject(context.getUIContext());\n        MavenFacet maven = project.getFacet(MavenFacet.class);\n        Model pom = maven.getModel();\n\n        DockerSetupHelper.setupDocker(project, from.getValue(), main.getValue());\n\n        // make sure we have resources as we need it later\n        facetFactory.install(project, ResourcesFacet.class);\n\n        // install fabric8 bom\n\n        // include test dependencies?\n        if (test.getValue() != null && test.getValue()) {\n            boolean hasFabric8Arquillian = !MavenHelpers.hasDependency(pom, \"io.fabric8\", \"fabric8-arquillian\");\n            boolean hasArquillianJunitContainer = !MavenHelpers.hasDependency(pom, \"org.jboss.arquillian.junit\", \"arquillian-junit-container\");\n\n\n            // I guess we only need to add this import if we add a test case?\n            // unless the app is using fabric8-cdi or something?\n            if (!hasFabric8Arquillian || !hasArquillianJunitContainer) {\n                if (!MavenHelpers.hasManagedDependency(pom, \"io.fabric8\", \"fabric8-project\")) {\n                    Dependency bom = DependencyBuilder.create()\n                            .setCoordinate(MavenHelpers.createCoordinate(\"io.fabric8\", \"fabric8-project\", VersionHelper.fabric8Version(), \"pom\"))\n                            .setScopeType(\"import\");\n                    dependencyInstaller.installManaged(project, bom);\n                }\n            }\n            ensureMavenDependencyAdded(project, dependencyInstaller, \"io.fabric8\", \"fabric8-arquillian\", \"test\");\n            ensureMavenDependencyAdded(project, dependencyInstaller, \"org.jboss.arquillian.junit\", \"arquillian-junit-container\", \"test\");\n        }\n\n        if (!MavenHelpers.hasMavenPlugin(pom, \"io.fabric8\", \"fabric8-maven-plugin\")) {\n            // add fabric8 plugin\n            MavenPluginFacet pluginFacet = project.getFacet(MavenPluginFacet.class);\n            MavenPlugin plugin = MavenPluginBuilder.create()\n                    .setCoordinate(MavenHelpers.createCoordinate(\"io.fabric8\", \"fabric8-maven-plugin\", VersionHelper.fabric8Version()))\n                    .addExecution(ExecutionBuilder.create().setId(\"json\").addGoal(\"json\"))\n                    .addExecution(ExecutionBuilder.create().setId(\"zip\").addGoal(\"zip\"));\n            pluginFacet.addPlugin(plugin);\n        }\n\n        // update properties section in pom.xml\n        Properties properties = pom.getProperties();\n        boolean updated = false;\n        updated = MavenHelpers.updatePomProperty(properties, \"fabric8.label.container\", container.getValue(), updated);\n        String iconValue = icon.getValue();\n        if (Strings.isNotBlank(iconValue)) {\n            updated = MavenHelpers.updatePomProperty(properties, \"fabric8.iconRef\", \"icons/\" + iconValue, updated);\n        }\n        updated = MavenHelpers.updatePomProperty(properties, \"fabric8.label.group\", group.getValue(), updated);\n\n        // to save then set the model\n        if (updated) {\n            maven.setModel(pom);\n        }\n        return Results.success(\"Adding Fabric8 maven support with base Docker image: \" + from.getValue());\n    }","commit_id":"aa73caeeb4f351d62b4782175942159ac67de919","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public void initializeUI(final UIBuilder builder) throws Exception {\n        Project project = getCurrentProject(builder.getUIContext());\n\n        String packaging = getProjectPackaging(project);\n\n        boolean springBoot = hasSpringBootMavenPlugin(project);\n\n        // limit the choices depending on the project packaging\n        List<String> choices = new ArrayList<String>();\n        if (packaging == null || springBoot || \"jar\".equals(packaging)) {\n            choices.add(jarImages[0]);\n        }\n        if (packaging == null || \"bundle\".equals(packaging)) {\n            choices.add(bundleImages[0]);\n        }\n        if (!springBoot && (packaging == null || \"war\".equals(packaging))) {\n            choices.add(warImages[0]);\n            choices.add(warImages[1]);\n        }\n        from.setValueChoices(choices);\n\n        // is it possible to pre select a choice?\n        if (choices.size() > 0) {\n            String defaultChoice = choices.get(0);\n            if (defaultChoice != null) {\n                from.setDefaultValue(defaultChoice);\n            }\n        }\n\n        from.addValueChangeListener(new ValueChangeListener() {\n            @Override\n            public void valueChanged(ValueChangeEvent event) {\n                // use a listener so the jube step knows what we selected as it want to reuse\n                builder.getUIContext().getAttributeMap().put(\"docker.from\", event.getNewValue());\n            }\n        });\n        builder.add(from);\n\n        if (packaging == null || (!packaging.equals(\"war\") && !packaging.equals(\"ear\"))) {\n            main.setRequired(new Callable<Boolean>() {\n                @Override\n                public Boolean call() throws Exception {\n                    return DockerSetupHelper.isJarImage(from.getValue());\n                }\n            });\n            // only enable main if its required\n            main.setEnabled(main.isRequired());\n            if (project != null) {\n                main.setDefaultValue(DockerSetupHelper.defaultMainClass(project));\n            }\n            main.addValidator(new ClassNameValidator(true));\n            main.addValueChangeListener(new ValueChangeListener() {\n                @Override\n                public void valueChanged(ValueChangeEvent event) {\n                    // use a listener so the jube step knows what we selected as it want to reuse\n                    builder.getUIContext().getAttributeMap().put(\"docker.main\", event.getNewValue());\n                }\n            });\n            builder.add(main);\n        }\n\n\n        container.setDefaultValue(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                String from = (String) builder.getUIContext().getAttributeMap().get(\"docker.from\");\n                if (from != null) {\n                    return asContainer(from);\n                }\n                return null;\n            }\n        });\n\n        // the from image values\n        icon.setValueChoices(new Iterable<String>() {\n            @Override\n            public Iterator<String> iterator() {\n                Set<String> choices = new LinkedHashSet<String>();\n                choices.add(\"activemq\");\n                choices.add(\"camel\");\n                choices.add(\"java\");\n                choices.add(\"jetty\");\n                choices.add(\"karaf\");\n                choices.add(\"mule\");\n                choices.add(\"tomcat\");\n                choices.add(\"tomee\");\n                choices.add(\"weld\");\n                choices.add(\"wildfly\");\n                return choices.iterator();\n            }\n        });\n        icon.setDefaultValue(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                if (container.getValue() != null) {\n                    for (String choice : icon.getValueChoices()) {\n                        if (choice.equals(container.getValue())) {\n                            return choice;\n                        }\n                    }\n                }\n                return null;\n            }\n        });\n\n        group.setDefaultValue(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                // use the project name as default value\n                return null;\n            }\n        });\n\n        builder.add(container).add(group).add(icon).add(test);\n    }","id":93960,"modified_method":"@Override\n    public void initializeUI(final UIBuilder builder) throws Exception {\n        Project project = getCurrentProject(builder.getUIContext());\n\n        String packaging = getProjectPackaging(project);\n\n        boolean springBoot = hasSpringBootMavenPlugin(project);\n\n        // limit the choices depending on the project packaging\n        List<String> choices = new ArrayList<String>();\n        if (packaging == null || springBoot || \"jar\".equals(packaging)) {\n            choices.add(jarImages[0]);\n        }\n        if (packaging == null || \"bundle\".equals(packaging)) {\n            choices.add(bundleImages[0]);\n        }\n        if (!springBoot && (packaging == null || \"war\".equals(packaging))) {\n            choices.add(warImages[0]);\n            choices.add(warImages[1]);\n        }\n        from.setValueChoices(choices);\n\n        // is it possible to pre select a choice?\n        if (choices.size() > 0) {\n            String defaultChoice = choices.get(0);\n            if (defaultChoice != null) {\n                from.setDefaultValue(defaultChoice);\n            }\n        }\n\n        from.addValueChangeListener(new ValueChangeListener() {\n            @Override\n            public void valueChanged(ValueChangeEvent event) {\n                // use a listener so the jube step knows what we selected as it want to reuse\n                builder.getUIContext().getAttributeMap().put(\"docker.from\", event.getNewValue());\n            }\n        });\n        builder.add(from);\n\n        if (packaging == null || (!packaging.equals(\"war\") && !packaging.equals(\"ear\"))) {\n            main.setRequired(new Callable<Boolean>() {\n                @Override\n                public Boolean call() throws Exception {\n                    return DockerSetupHelper.isJarImage(from.getValue());\n                }\n            });\n            // only enable main if its required\n            main.setEnabled(main.isRequired());\n            if (project != null) {\n                main.setDefaultValue(DockerSetupHelper.defaultMainClass(project));\n            }\n            main.addValidator(new ClassNameValidator(true));\n            main.addValueChangeListener(new ValueChangeListener() {\n                @Override\n                public void valueChanged(ValueChangeEvent event) {\n                    // use a listener so the jube step knows what we selected as it want to reuse\n                    builder.getUIContext().getAttributeMap().put(\"docker.main\", event.getNewValue());\n                }\n            });\n            builder.add(main);\n        }\n\n\n        container.setDefaultValue(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                String from = (String) builder.getUIContext().getAttributeMap().get(\"docker.from\");\n                if (from != null) {\n                    return asContainer(from);\n                }\n                return null;\n            }\n        });\n\n        // the from image values\n        icon.setValueChoices(new Iterable<String>() {\n            @Override\n            public Iterator<String> iterator() {\n                Set<String> choices = new LinkedHashSet<String>();\n                choices.add(\"activemq\");\n                choices.add(\"camel\");\n                choices.add(\"java\");\n                choices.add(\"jetty\");\n                choices.add(\"karaf\");\n                choices.add(\"mule\");\n                choices.add(\"tomcat\");\n                choices.add(\"tomee\");\n                choices.add(\"weld\");\n                choices.add(\"wildfly\");\n                return choices.iterator();\n            }\n        });\n        icon.setDefaultValue(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                if (container.getValue() != null) {\n                    for (String choice : icon.getValueChoices()) {\n                        if (choice.equals(container.getValue())) {\n                            return choice;\n                        }\n                    }\n                }\n                return null;\n            }\n        });\n\n        group.setDefaultValue(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                // use the project name as default value\n                return null;\n            }\n        });\n\n        builder.add(test).add(icon).add(group).add(container);\n    }","commit_id":"aa73caeeb4f351d62b4782175942159ac67de919","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected void analyzeAndCheck(File testDataFile, List<TestFile> testFiles) {\n        List<JetFile> jetFiles = getJetFiles(testFiles);\n\n        BindingTrace trace = CliLightClassGenerationSupport.getInstanceForCli(getProject()).getTrace();\n\n        BindingContext bindingContext = AnalyzerFacadeForJVM.analyzeFilesWithJavaIntegration(\n                getProject(), jetFiles, trace,\n                Collections.<AnalyzerScriptParameter>emptyList(), Predicates.<PsiFile>alwaysTrue(), false).getBindingContext();\n\n        boolean ok = true;\n\n        StringBuilder actualText = new StringBuilder();\n        for (TestFile testFile : testFiles) {\n            ok &= testFile.getActualText(bindingContext, actualText);\n        }\n\n        JetTestUtils.assertEqualsToFile(testDataFile, actualText.toString());\n\n        assertTrue(\"Diagnostics mismatch. See the output above\", ok);\n\n        checkAllResolvedCallsAreCompleted(jetFiles, bindingContext);\n    }","id":93961,"modified_method":"@Override\n    protected void analyzeAndCheck(File testDataFile, List<TestFile> testFiles) {\n        List<JetFile> jetFiles = getJetFiles(testFiles);\n\n        CliLightClassGenerationSupport support = CliLightClassGenerationSupport.getInstanceForCli(getProject());\n\n        BindingContext bindingContext = AnalyzerFacadeForJVM.analyzeFilesWithJavaIntegration(\n                getProject(), jetFiles, support.getTrace(),\n                Collections.<AnalyzerScriptParameter>emptyList(), Predicates.<PsiFile>alwaysTrue(), false, support.getModule()).getBindingContext();\n\n        boolean ok = true;\n\n        StringBuilder actualText = new StringBuilder();\n        for (TestFile testFile : testFiles) {\n            ok &= testFile.getActualText(bindingContext, actualText);\n        }\n\n        JetTestUtils.assertEqualsToFile(testDataFile, actualText.toString());\n\n        assertTrue(\"Diagnostics mismatch. See the output above\", ok);\n\n        checkAllResolvedCallsAreCompleted(jetFiles, bindingContext);\n    }","commit_id":"9d2b79c631e6b3ea3f612c87f51b1ad7af1ae6ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected void doTestJavaAgainstKotlin(String expectedFileName) throws Exception {\n        File expectedFile = new File(expectedFileName);\n        File sourcesDir = new File(expectedFileName.replaceFirst(\"\\\\.txt$\", \"\"));\n\n        FileUtil.copyDir(sourcesDir, new File(tmpdir, \"test\"), new FileFilter() {\n            @Override\n            public boolean accept(@NotNull File pathname) {\n                return pathname.getName().endsWith(\".java\");\n            }\n        });\n\n        CompilerConfiguration configuration = JetTestUtils.compilerConfigurationForTests(\n                ConfigurationKind.JDK_ONLY, TestJdkKind.MOCK_JDK, tmpdir);\n        configuration.put(CommonConfigurationKeys.SOURCE_ROOTS_KEY, Arrays.asList(sourcesDir.getAbsolutePath()));\n        configuration.add(JVMConfigurationKeys.CLASSPATH_KEY, new File(\"compiler/tests\")); // for @ExpectLoadError annotation\n        JetCoreEnvironment environment = JetCoreEnvironment.createForTests(getTestRootDisposable(), configuration);\n\n        // we need the same binding trace for resolve from Java and Kotlin\n        BindingTrace trace = CliLightClassGenerationSupport.getInstanceForCli(environment.getProject()).getTrace();\n\n        ModuleDescriptorImpl moduleDescriptor = AnalyzerFacadeForJVM.createJavaModule(\"<test module>\");\n\n        InjectorForTopDownAnalyzerForJvm injectorForAnalyzer = new InjectorForTopDownAnalyzerForJvm(\n                environment.getProject(),\n                new TopDownAnalysisParameters(\n                        Predicates.<PsiFile>alwaysFalse(), false, false, Collections.<AnalyzerScriptParameter>emptyList()),\n                trace,\n                moduleDescriptor);\n\n        injectorForAnalyzer.getTopDownAnalyzer().analyzeFiles(environment.getSourceFiles(), Collections.<AnalyzerScriptParameter>emptyList());\n\n        PackageViewDescriptor packageView = moduleDescriptor.getPackage(TEST_PACKAGE_FQNAME);\n        assert packageView != null : \"Test namespace not found\";\n\n        checkJavaPackage(expectedFile, packageView, trace.getBindingContext(), DONT_INCLUDE_METHODS_OF_OBJECT);\n    }","id":93962,"modified_method":"protected void doTestJavaAgainstKotlin(String expectedFileName) throws Exception {\n        File expectedFile = new File(expectedFileName);\n        File sourcesDir = new File(expectedFileName.replaceFirst(\"\\\\.txt$\", \"\"));\n\n        FileUtil.copyDir(sourcesDir, new File(tmpdir, \"test\"), new FileFilter() {\n            @Override\n            public boolean accept(@NotNull File pathname) {\n                return pathname.getName().endsWith(\".java\");\n            }\n        });\n\n        CompilerConfiguration configuration = JetTestUtils.compilerConfigurationForTests(\n                ConfigurationKind.JDK_ONLY, TestJdkKind.MOCK_JDK, tmpdir);\n        configuration.put(CommonConfigurationKeys.SOURCE_ROOTS_KEY, Arrays.asList(sourcesDir.getAbsolutePath()));\n        configuration.add(JVMConfigurationKeys.CLASSPATH_KEY, new File(\"compiler/tests\")); // for @ExpectLoadError annotation\n        JetCoreEnvironment environment = JetCoreEnvironment.createForTests(getTestRootDisposable(), configuration);\n\n        // we need the same binding trace for resolve from Java and Kotlin\n        CliLightClassGenerationSupport support = CliLightClassGenerationSupport.getInstanceForCli(environment.getProject());\n        BindingTrace trace = support.getTrace();\n\n        InjectorForTopDownAnalyzerForJvm injectorForAnalyzer = new InjectorForTopDownAnalyzerForJvm(\n                environment.getProject(),\n                new TopDownAnalysisParameters(\n                        Predicates.<PsiFile>alwaysFalse(), false, false, Collections.<AnalyzerScriptParameter>emptyList()),\n                trace,\n                support.getModule());\n\n        injectorForAnalyzer.getTopDownAnalyzer().analyzeFiles(environment.getSourceFiles(), Collections.<AnalyzerScriptParameter>emptyList());\n\n        PackageViewDescriptor packageView = support.getModule().getPackage(TEST_PACKAGE_FQNAME);\n        assert packageView != null : \"Test namespace not found\";\n\n        checkJavaPackage(expectedFile, packageView, trace.getBindingContext(), DONT_INCLUDE_METHODS_OF_OBJECT);\n    }","commit_id":"9d2b79c631e6b3ea3f612c87f51b1ad7af1ae6ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<FqName> getSubPackages(@NotNull FqName fqn, @NotNull GlobalSearchScope scope) {\n        NamespaceDescriptor namespaceDescriptor = getTrace().get(BindingContext.FQNAME_TO_NAMESPACE_DESCRIPTOR, fqn);\n        if (namespaceDescriptor == null) return Collections.emptyList();\n\n        Collection<DeclarationDescriptor> allDescriptors = namespaceDescriptor.getMemberScope().getAllDescriptors();\n        return ContainerUtil.mapNotNull(allDescriptors, new Function<DeclarationDescriptor, FqName>() {\n            @Override\n            public FqName fun(DeclarationDescriptor input) {\n                if (input instanceof NamespaceDescriptor) {\n                    return DescriptorUtils.getFQName(input).toSafe();\n                }\n                return null;\n            }\n        });\n    }","id":93963,"modified_method":"@NotNull\n    @Override\n    public Collection<FqName> getSubPackages(@NotNull FqName fqn, @NotNull GlobalSearchScope scope) {\n        PackageViewDescriptor packageView = getModule().getPackage(fqn);\n        if (packageView == null) return Collections.emptyList();\n\n        Collection<DeclarationDescriptor> members = packageView.getMemberScope().getAllDescriptors();\n        return ContainerUtil.mapNotNull(members, new Function<DeclarationDescriptor, FqName>() {\n            @Override\n            public FqName fun(DeclarationDescriptor member) {\n                if (member instanceof PackageViewDescriptor) {\n                    return ((PackageViewDescriptor) member).getFqName();\n                }\n                return null;\n            }\n        });\n    }","commit_id":"9d2b79c631e6b3ea3f612c87f51b1ad7af1ae6ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void newBindingTrace() {\n        assert ApplicationManager.getApplication().isUnitTestMode() : \"Mutating project service's state shouldn't happen other than in tests\";\n        trace = null;\n    }","id":93964,"modified_method":"@TestOnly\n    public void newBindingTrace() {\n        trace = null;\n        module = null;\n    }","commit_id":"9d2b79c631e6b3ea3f612c87f51b1ad7af1ae6ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public boolean packageExists(\n            @NotNull FqName fqName, @NotNull GlobalSearchScope scope\n    ) {\n        return getTrace().get(BindingContext.FQNAME_TO_NAMESPACE_DESCRIPTOR, fqName) != null;\n    }","id":93965,"modified_method":"@Override\n    public boolean packageExists(@NotNull FqName fqName, @NotNull GlobalSearchScope scope) {\n        return getModule().getPackage(fqName) != null;\n    }","commit_id":"9d2b79c631e6b3ea3f612c87f51b1ad7af1ae6ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    @NotNull\n    public Collection<JavaPackage> getSubPackages() {\n        return packages(getPsi().getSubPackages());\n    }","id":93966,"modified_method":"@Override\n    @NotNull\n    public Collection<JavaPackage> getSubPackages() {\n        PsiPackage psiPackage = getPsi();\n        return packages(new JavaPsiFacadeKotlinHacks(psiPackage.getProject()).getSubPackages(psiPackage));\n    }","commit_id":"9d2b79c631e6b3ea3f612c87f51b1ad7af1ae6ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private static AnalyzeExhaust analyze(@NotNull final JetCoreEnvironment environment) {\n        AnalyzerWithCompilerReport analyzerWithCompilerReport = new AnalyzerWithCompilerReport(\n                environment.getConfiguration().get(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY));\n        analyzerWithCompilerReport.analyzeAndReport(\n                new Function0<AnalyzeExhaust>() {\n                    @NotNull\n                    @Override\n                    public AnalyzeExhaust invoke() {\n                        BindingTrace sharedTrace = CliLightClassGenerationSupport.getInstanceForCli(environment.getProject()).getTrace();\n                        return AnalyzerFacadeForJVM.analyzeFilesWithJavaIntegration(\n                                environment.getProject(),\n                                environment.getSourceFiles(),\n                                sharedTrace,\n                                environment.getConfiguration().getList(JVMConfigurationKeys.SCRIPT_PARAMETERS),\n                                Predicates.<PsiFile>alwaysTrue(),\n                                false\n                        );\n                    }\n                }, environment.getSourceFiles()\n        );\n\n        return analyzerWithCompilerReport.hasErrors() ? null : analyzerWithCompilerReport.getAnalyzeExhaust();\n    }","id":93967,"modified_method":"@Nullable\n    private static AnalyzeExhaust analyze(@NotNull final JetCoreEnvironment environment) {\n        AnalyzerWithCompilerReport analyzerWithCompilerReport = new AnalyzerWithCompilerReport(\n                environment.getConfiguration().get(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY));\n        analyzerWithCompilerReport.analyzeAndReport(\n                new Function0<AnalyzeExhaust>() {\n                    @NotNull\n                    @Override\n                    public AnalyzeExhaust invoke() {\n                        CliLightClassGenerationSupport support = CliLightClassGenerationSupport.getInstanceForCli(environment.getProject());\n                        BindingTrace sharedTrace = support.getTrace();\n                        ModuleDescriptorImpl sharedModule = support.getModule();\n                        return AnalyzerFacadeForJVM.analyzeFilesWithJavaIntegration(\n                                environment.getProject(),\n                                environment.getSourceFiles(),\n                                sharedTrace,\n                                environment.getConfiguration().getList(JVMConfigurationKeys.SCRIPT_PARAMETERS),\n                                Predicates.<PsiFile>alwaysTrue(),\n                                false,\n                                sharedModule\n                        );\n                    }\n                }, environment.getSourceFiles()\n        );\n\n        return analyzerWithCompilerReport.hasErrors() ? null : analyzerWithCompilerReport.getAnalyzeExhaust();\n    }","commit_id":"9d2b79c631e6b3ea3f612c87f51b1ad7af1ae6ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static KotlinCodeAnalyzer resolveLazilyWithSession(List<JetFile> files, JetCoreEnvironment environment, boolean addBuiltIns) {\n        JetTestUtils.newTrace(environment);\n\n        Project project = environment.getProject();\n        BindingTrace sharedTrace = CliLightClassGenerationSupport.getInstanceForCli(project).getTrace();\n        InjectorForJavaDescriptorResolver injector = new InjectorForJavaDescriptorResolver(project, sharedTrace);\n\n        return AnalyzerFacadeForJVM.createLazyResolveSession(project, files, sharedTrace, injector, addBuiltIns);\n    }","id":93968,"modified_method":"public static KotlinCodeAnalyzer resolveLazilyWithSession(List<JetFile> files, JetCoreEnvironment environment, boolean addBuiltIns) {\n        JetTestUtils.newTrace(environment);\n\n        Project project = environment.getProject();\n        CliLightClassGenerationSupport support = CliLightClassGenerationSupport.getInstanceForCli(project);\n        BindingTrace sharedTrace = support.getTrace();\n        InjectorForJavaDescriptorResolver injector = new InjectorForJavaDescriptorResolver(project, sharedTrace);\n        support.setModule(injector.getModule());\n\n        return AnalyzerFacadeForJVM.createLazyResolveSession(project, files, sharedTrace, injector, addBuiltIns);\n    }","commit_id":"9d2b79c631e6b3ea3f612c87f51b1ad7af1ae6ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static ModuleDescriptor resolveEagerly(List<JetFile> files, JetCoreEnvironment environment) {\n        ModuleDescriptorImpl module = AnalyzerFacadeForJVM.createJavaModule(\"<test module>\");\n        InjectorForTopDownAnalyzer injector = createInjectorForTDA(module, environment);\n        injector.getTopDownAnalyzer().analyzeFiles(files, Collections.<AnalyzerScriptParameter>emptyList());\n        return module;\n    }","id":93969,"modified_method":"public static ModuleDescriptor resolveEagerly(List<JetFile> files, JetCoreEnvironment environment) {\n        InjectorForTopDownAnalyzer injector = createInjectorForTDA(environment);\n        injector.getTopDownAnalyzer().analyzeFiles(files, Collections.<AnalyzerScriptParameter>emptyList());\n        return injector.getModuleDescriptor();\n    }","commit_id":"9d2b79c631e6b3ea3f612c87f51b1ad7af1ae6ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static InjectorForTopDownAnalyzer getEagerInjectorForTopDownAnalyzer(JetCoreEnvironment environment) {\n        ModuleDescriptorImpl eagerModuleForLazy = AnalyzerFacadeForJVM.createJavaModule(\"<eager module for lazy>\");\n\n        InjectorForTopDownAnalyzer tdaInjectorForLazy = createInjectorForTDA(eagerModuleForLazy, environment);\n        // This line is required fro the 'jet' namespace to be filled in with functions\n        tdaInjectorForLazy.getTopDownAnalyzer().analyzeFiles(\n                Collections.singletonList(JetPsiFactory.createFile(environment.getProject(), \"\")), Collections.<AnalyzerScriptParameter>emptyList());\n        return tdaInjectorForLazy;\n    }","id":93970,"modified_method":"public static InjectorForTopDownAnalyzer getEagerInjectorForTopDownAnalyzer(JetCoreEnvironment environment) {\n        InjectorForTopDownAnalyzer tdaInjectorForLazy = createInjectorForTDA(environment);\n        // This line is required fro the 'jet' namespace to be filled in with functions\n        tdaInjectorForLazy.getTopDownAnalyzer().analyzeFiles(\n                Collections.singletonList(JetPsiFactory.createFile(environment.getProject(), \"\")), Collections.<AnalyzerScriptParameter>emptyList());\n        return tdaInjectorForLazy;\n    }","commit_id":"9d2b79c631e6b3ea3f612c87f51b1ad7af1ae6ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static InjectorForTopDownAnalyzer createInjectorForTDA(ModuleDescriptorImpl module, JetCoreEnvironment environment) {\n        JetTestUtils.newTrace(environment);\n\n        TopDownAnalysisParameters params = new TopDownAnalysisParameters(\n                Predicates.<PsiFile>alwaysTrue(), false, false, Collections.<AnalyzerScriptParameter>emptyList());\n        BindingTrace sharedTrace = CliLightClassGenerationSupport.getInstanceForCli(environment.getProject()).getTrace();\n        return new InjectorForTopDownAnalyzerForJvm(environment.getProject(), params, sharedTrace, module);\n    }","id":93971,"modified_method":"public static InjectorForTopDownAnalyzer createInjectorForTDA(JetCoreEnvironment environment) {\n        JetTestUtils.newTrace(environment);\n\n        TopDownAnalysisParameters params = new TopDownAnalysisParameters(\n                Predicates.<PsiFile>alwaysTrue(), false, false, Collections.<AnalyzerScriptParameter>emptyList());\n        CliLightClassGenerationSupport support = CliLightClassGenerationSupport.getInstanceForCli(environment.getProject());\n        BindingTrace sharedTrace = support.getTrace();\n        ModuleDescriptorImpl sharedModule = support.getModule();\n        return new InjectorForTopDownAnalyzerForJvm(environment.getProject(), params, sharedTrace, sharedModule);\n    }","commit_id":"9d2b79c631e6b3ea3f612c87f51b1ad7af1ae6ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * <p>\n     * This method actually tests the remote host to determine if it is\n     * running a functional DHCP server.\n     * <\/p>\n     * <p>\n     * Formats a DHCP query and encodes it in a client request message which\n     * is sent to the DHCP daemon over the established TCP socket connection.\n     * If a matching DHCP response packet is not received from the DHCP daemon\n     * within the specified timeout the client request message will be re-sent\n     * up to the specified number of retries.\n     * <\/p>\n     * <p>\n     * If a response is received from the DHCP daemon it is validated to\n     * ensure that:\n     * <\/p>\n     * <ul>\n     * <li>The DHCP response packet was sent from the remote host to which the\n     * original request packet was directed.<\/li>\n     * <li>The XID of the DHCP response packet matches the XID of the original\n     * DHCP request packet.<\/li>\n     * <\/ul>\n     * <p>\n     * If the response validates 'true' is returned. Otherwise the request is\n     * resent until max retry count is exceeded.\n     * <\/p>\n     * <p>\n     * Before returning, a client disconnect message (remote host field set to\n     * zero) is sent to the DHCP daemon.\n     * <\/p>\n     * \n     * @return response time in milliseconds if the specified host responded\n     *         with a valid DHCP offer datagram within the context of the\n     *         specified timeout and retry values or negative one (-1)\n     *         otherwise.\n     */\n    static long isServer(InetAddress host, long timeout, int retries) throws IOException {\n        Category log = ThreadCategory.getInstance(Poller.class);\n\n        boolean isDhcpServer = false;\n        // List of DHCP queries to try. The default when extended\n        // mode = false must be listed first. (DISCOVER)\n        byte[] typeList = { (byte) DHCPMessage.DISCOVER, (byte) DHCPMessage.INFORM, (byte) DHCPMessage.REQUEST };\n        String[] typeName = { \"DISCOVER\", \"INFORM\", \"REQUEST\" };\n        DhcpdConfigFactory dcf = DhcpdConfigFactory.getInstance();\n        if (!paramsChecked) {\n            if (extendedMode == null) {\n                String s_extendedMode = dcf.getExtendedMode();\n                if (s_extendedMode == null) {\n                    extendedMode = false;\n                } else {\n                    extendedMode = Boolean.parseBoolean(s_extendedMode);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: DHCP extended mode is \" + extendedMode);\n                }\n            }\n            if (s_hwAddress == null) {\n                String hwAddressStr = dcf.getMacAddress();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: DHCP query hardware/MAC address is \" + hwAddressStr);\n                }\n                setHwAddress(hwAddressStr);\n            }\n            if (s_myIpAddress == null) {\n                String myIpStr = dcf.getMyIpAddress();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: DHCP relay agent address is \" + myIpStr);\n                }\n                if (myIpStr == null || myIpStr.equals(\"\") || myIpStr.equalsIgnoreCase(\"broadcast\")) {\n                    // do nothing\n                } else if (IpValidator.isIpValid(myIpStr)) {\n                    s_myIpAddress = setIpAddress(myIpStr);\n                    relayMode = true;\n                }\n            }\n            if (s_requestIpAddress == null && extendedMode == true) {\n                String requestStr = dcf.getRequestIpAddress();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: REQUEST query target is \" + requestStr);\n                }\n                if (requestStr == null || requestStr.equals(\"\") || requestStr.equalsIgnoreCase(\"targetSubnet\")) {\n                    // do nothing\n                } else if (requestStr.equalsIgnoreCase(\"targetHost\")) {\n                    targetOffset = false;\n                } else if (IpValidator.isIpValid(requestStr)) {\n                    s_requestIpAddress = setIpAddress(requestStr);\n                    reqTargetIp = false;\n                    targetOffset = false;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"REQUEST query options are: reqTargetIp = \" + reqTargetIp + \", targetOffset = \" + targetOffset);\n                }\n            }\n            paramsChecked = true;\n        }\n\n        int j = 1;\n        if (extendedMode == true) {\n            j = typeList.length;\n        }\n\n        if (timeout < 500) {\n            timeout = 500;\n        }\n\n        Poller p = new Poller(timeout);\n        long responseTime = -1;\n        try {\n            pollit: for (int i = 0; i < j; i++) {\n\n                Message ping = getPollingRequest(host, (byte) typeList[i]);\n\n                int rt = retries;\n                while (rt >= 0 && !isDhcpServer) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"isServer: sending DHCP \" + typeName[i] + \" query to host \" + host.getHostAddress() + \" with Xid: \" + ping.getMessage().getXid());\n                    }\n                    \n                    long start = System.currentTimeMillis();\n                    p.m_outs.writeObject(ping);\n                    long end;\n\n                    do {\n                        Message resp = null;\n                        try {\n                            resp = (Message) p.m_ins.readObject();\n                        } catch (InterruptedIOException ex) {\n                            resp = null;\n                        }\n\n                        if (resp != null) {\n                            responseTime = System.currentTimeMillis() - start;\n\n                            // DEBUG only\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"isServer: got a DHCP response from host \" + resp.getAddress().getHostAddress() + \" with Xid: \" + resp.getMessage().getXid());\n                            }\n\n                            if (host.equals(resp.getAddress()) && ping.getMessage().getXid() == resp.getMessage().getXid()) {\n                                // Inspect response message to see if it is a valid DHCP response\n                                byte[] type = resp.getMessage().getOption(MESSAGE_TYPE);\n                                if (log.isDebugEnabled()) {\n                                    if (type[0] == DHCPMessage.OFFER) {\n                                        log.debug(\"isServer: got a DHCP OFFER response, validating...\");\n                                    } else if (type[0] == DHCPMessage.ACK) {\n                                        log.debug(\"isServer: got a DHCP ACK response, validating...\");\n                                    } else if (type[0] == DHCPMessage.NAK) {\n                                        log.debug(\"isServer: got a DHCP NAK response, validating...\");\n                                    }\n                                }\n\n                                // accept offer or ACK or NAK\n                                if (type[0] == DHCPMessage.OFFER || (extendedMode == true && (type[0] == DHCPMessage.ACK || type[0] == DHCPMessage.NAK))) {\n                                    if (log.isDebugEnabled()) {\n                                        log.debug(\"isServer: got a valid DHCP response. responseTime= \" + responseTime + \"ms\");\n                                    }\n                                    \n                                    isDhcpServer = true;\n                                    break pollit;\n                                }\n                            }\n                        }\n\n                        end = System.currentTimeMillis();\n\n                    } while ((end - start) < timeout);\n\n                    if (log.isDebugEnabled()) {\n                        if (!isDhcpServer) {\n                            log.debug(\"Timed out waiting for DHCP response, remaining retries: \" + rt);\n                        }\n                    }\n\n                    --rt;\n                }\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Sending disconnect request\");\n            }\n            p.m_outs.writeObject(getDisconnectRequest());\n            if (log.isDebugEnabled()) {\n                log.debug(\"wait half a sec before closing connection\");\n            }\n            Thread.sleep(500);\n            p.close();\n        } catch (IOException ex) {\n            log.error(\"IO Exception caught.\", ex);\n            p.close();\n            throw ex;\n        } catch (Throwable t) {\n            log.error(\"Unexpected Exception caught.\", t);\n            p.close();\n            throw new UndeclaredThrowableException(t);\n        }\n\n        // Return response time if the remote box IS a DHCP\n        // server or -1 if the remote box is NOT a DHCP server.\n        if (isDhcpServer) {\n            return responseTime;\n        } else {\n            return -1;\n        }\n    }","id":93972,"modified_method":"/**\n     * <p>\n     * This method actually tests the remote host to determine if it is\n     * running a functional DHCP server.\n     * <\/p>\n     * <p>\n     * Formats a DHCP query and encodes it in a client request message which\n     * is sent to the DHCP daemon over the established TCP socket connection.\n     * If a matching DHCP response packet is not received from the DHCP daemon\n     * within the specified timeout the client request message will be re-sent\n     * up to the specified number of retries.\n     * <\/p>\n     * <p>\n     * If a response is received from the DHCP daemon it is validated to\n     * ensure that:\n     * <\/p>\n     * <ul>\n     * <li>The DHCP response packet was sent from the remote host to which the\n     * original request packet was directed.<\/li>\n     * <li>The XID of the DHCP response packet matches the XID of the original\n     * DHCP request packet.<\/li>\n     * <\/ul>\n     * <p>\n     * If the response validates 'true' is returned. Otherwise the request is\n     * resent until max retry count is exceeded.\n     * <\/p>\n     * <p>\n     * Before returning, a client disconnect message (remote host field set to\n     * zero) is sent to the DHCP daemon.\n     * <\/p>\n     * \n     * @return response time in milliseconds if the specified host responded\n     *         with a valid DHCP offer datagram within the context of the\n     *         specified timeout and retry values or negative one (-1)\n     *         otherwise.\n     */\n    static long isServer(InetAddress host, long timeout, int retries) throws IOException {\n        Category log = ThreadCategory.getInstance(Poller.class);\n\n        boolean isDhcpServer = false;\n        // List of DHCP queries to try. The default when extended\n        // mode = false must be listed first. (DISCOVER)\n        byte[] typeList = { (byte) DHCPMessage.DISCOVER, (byte) DHCPMessage.INFORM, (byte) DHCPMessage.REQUEST };\n        String[] typeName = { \"DISCOVER\", \"INFORM\", \"REQUEST\" };\n        DhcpdConfigFactory dcf = DhcpdConfigFactory.getInstance();\n        if (!paramsChecked) {\n            String s_extendedMode = dcf.getExtendedMode();\n            if (s_extendedMode == null) {\n                extendedMode = false;\n            } else {\n                extendedMode = Boolean.parseBoolean(s_extendedMode);\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"isServer: DHCP extended mode is \" + extendedMode);\n            }\n            \n            String hwAddressStr = dcf.getMacAddress();\n            if (log.isDebugEnabled()) {\n                log.debug(\"isServer: DHCP query hardware/MAC address is \" + hwAddressStr);\n            }\n            setHwAddress(hwAddressStr);\n            \n            String myIpStr = dcf.getMyIpAddress();\n            if (log.isDebugEnabled()) {\n                log.debug(\"isServer: DHCP relay agent address is \" + myIpStr);\n            }\n            if (myIpStr == null || myIpStr.equals(\"\") || myIpStr.equalsIgnoreCase(\"broadcast\")) {\n                // do nothing\n            } else if (IpValidator.isIpValid(myIpStr)) {\n                s_myIpAddress = setIpAddress(myIpStr);\n                relayMode = true;\n            }\n            \n            if (extendedMode == true) {\n                String requestStr = dcf.getRequestIpAddress();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: REQUEST query target is \" + requestStr);\n                }\n                if (requestStr == null || requestStr.equals(\"\") || requestStr.equalsIgnoreCase(\"targetSubnet\")) {\n                    // do nothing\n                } else if (requestStr.equalsIgnoreCase(\"targetHost\")) {\n                    targetOffset = false;\n                } else if (IpValidator.isIpValid(requestStr)) {\n                    s_requestIpAddress = setIpAddress(requestStr);\n                    reqTargetIp = false;\n                    targetOffset = false;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"REQUEST query options are: reqTargetIp = \" + reqTargetIp + \", targetOffset = \" + targetOffset);\n                }\n            }\n            paramsChecked = true;\n        }\n\n        int j = 1;\n        if (extendedMode == true) {\n            j = typeList.length;\n        }\n\n        if (timeout < 500) {\n            timeout = 500;\n        }\n\n        Poller p = new Poller(timeout);\n        long responseTime = -1;\n        try {\n            pollit: for (int i = 0; i < j; i++) {\n\n                Message ping = getPollingRequest(host, (byte) typeList[i]);\n\n                int rt = retries;\n                while (rt >= 0 && !isDhcpServer) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"isServer: sending DHCP \" + typeName[i] + \" query to host \" + host.getHostAddress() + \" with Xid: \" + ping.getMessage().getXid());\n                    }\n                    \n                    long start = System.currentTimeMillis();\n                    p.m_outs.writeObject(ping);\n                    long end;\n\n                    do {\n                        Message resp = null;\n                        try {\n                            resp = (Message) p.m_ins.readObject();\n                        } catch (InterruptedIOException ex) {\n                            resp = null;\n                        }\n\n                        if (resp != null) {\n                            responseTime = System.currentTimeMillis() - start;\n\n                            // DEBUG only\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"isServer: got a DHCP response from host \" + resp.getAddress().getHostAddress() + \" with Xid: \" + resp.getMessage().getXid());\n                            }\n\n                            if (host.equals(resp.getAddress()) && ping.getMessage().getXid() == resp.getMessage().getXid()) {\n                                // Inspect response message to see if it is a valid DHCP response\n                                byte[] type = resp.getMessage().getOption(MESSAGE_TYPE);\n                                if (log.isDebugEnabled()) {\n                                    if (type[0] == DHCPMessage.OFFER) {\n                                        log.debug(\"isServer: got a DHCP OFFER response, validating...\");\n                                    } else if (type[0] == DHCPMessage.ACK) {\n                                        log.debug(\"isServer: got a DHCP ACK response, validating...\");\n                                    } else if (type[0] == DHCPMessage.NAK) {\n                                        log.debug(\"isServer: got a DHCP NAK response, validating...\");\n                                    }\n                                }\n\n                                // accept offer or ACK or NAK\n                                if (type[0] == DHCPMessage.OFFER || (extendedMode == true && (type[0] == DHCPMessage.ACK || type[0] == DHCPMessage.NAK))) {\n                                    if (log.isDebugEnabled()) {\n                                        log.debug(\"isServer: got a valid DHCP response. responseTime= \" + responseTime + \"ms\");\n                                    }\n                                    \n                                    isDhcpServer = true;\n                                    break pollit;\n                                }\n                            }\n                        }\n\n                        end = System.currentTimeMillis();\n\n                    } while ((end - start) < timeout);\n\n                    if (log.isDebugEnabled()) {\n                        if (!isDhcpServer) {\n                            log.debug(\"Timed out waiting for DHCP response, remaining retries: \" + rt);\n                        }\n                    }\n\n                    --rt;\n                }\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Sending disconnect request\");\n            }\n            p.m_outs.writeObject(getDisconnectRequest());\n            if (log.isDebugEnabled()) {\n                log.debug(\"wait half a sec before closing connection\");\n            }\n            Thread.sleep(500);\n            p.close();\n        } catch (IOException ex) {\n            log.error(\"IO Exception caught.\", ex);\n            p.close();\n            throw ex;\n        } catch (Throwable t) {\n            log.error(\"Unexpected Exception caught.\", t);\n            p.close();\n            throw new UndeclaredThrowableException(t);\n        }\n\n        // Return response time if the remote box IS a DHCP\n        // server or -1 if the remote box is NOT a DHCP server.\n        if (isDhcpServer) {\n            return responseTime;\n        } else {\n            return -1;\n        }\n    }","commit_id":"76980e063686e6bee83a3bf7009fb8e689a78eae","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>\n     * This method actually tests the remote host to determine if it is\n     * running a functional DHCP server.\n     * <\/p>\n     * <p>\n     * Formats a DHCP query and encodes it in a client request message which\n     * is sent to the DHCP daemon over the established TCP socket connection.\n     * If a matching DHCP response packet is not received from the DHCP daemon\n     * within the specified timeout the client request message will be re-sent\n     * up to the specified number of retries.\n     * <\/p>\n     * <p>\n     * If a response is received from the DHCP daemon it is validated to\n     * ensure that:\n     * <\/p>\n     * <ul>\n     * <li>The DHCP response packet was sent from the remote host to which the\n     * original request packet was directed.<\/li>\n     * <li>The XID of the DHCP response packet matches the XID of the original\n     * DHCP request packet.<\/li>\n     * <\/ul>\n     * <p>\n     * If the response validates 'true' is returned. Otherwise the request is\n     * resent until max retry count is exceeded.\n     * <\/p>\n     * <p>\n     * Before returning, a client disconnect message (remote host field set to\n     * zero) is sent to the DHCP daemon.\n     * <\/p>\n     * \n     * @return response time in milliseconds if the specified host responded\n     *         with a valid DHCP offer datagram within the context of the\n     *         specified timeout and retry values or negative one (-1)\n     *         otherwise.\n     */\n    static long isServer(InetAddress host, long timeout, int retries) throws IOException {\n        Category log = ThreadCategory.getInstance(Poller.class);\n\n        boolean isDhcpServer = false;\n        // List of DHCP queries to try. The default when extended\n        // mode = false must be listed first. (DISCOVER)\n        byte[] typeList = { (byte) DHCPMessage.DISCOVER, (byte) DHCPMessage.INFORM, (byte) DHCPMessage.REQUEST };\n        String[] typeName = { \"DISCOVER\", \"INFORM\", \"REQUEST\" };\n        DhcpdConfigFactory dcf = DhcpdConfigFactory.getInstance();\n        if (!paramsChecked) {\n            if (extendedMode == null) {\n                String s_extendedMode = dcf.getExtendedMode();\n                if (s_extendedMode == null) {\n                    extendedMode = false;\n                } else {\n                    extendedMode = Boolean.parseBoolean(s_extendedMode);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: DHCP extended mode is \" + extendedMode);\n                }\n            }\n            if (s_hwAddress == null) {\n                String hwAddressStr = dcf.getMacAddress();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: DHCP query hardware/MAC address is \" + hwAddressStr);\n                }\n                setHwAddress(hwAddressStr);\n            }\n            if (s_myIpAddress == null) {\n                String myIpStr = dcf.getMyIpAddress();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: DHCP relay agent address is \" + myIpStr);\n                }\n                if (myIpStr == null || myIpStr.equals(\"\") || myIpStr.equalsIgnoreCase(\"broadcast\")) {\n                    // do nothing\n                } else if (IpValidator.isIpValid(myIpStr)) {\n                    s_myIpAddress = setIpAddress(myIpStr);\n                    relayMode = true;\n                }\n            }\n            if (s_requestIpAddress == null && extendedMode == true) {\n                String requestStr = dcf.getRequestIpAddress();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: REQUEST query target is \" + requestStr);\n                }\n                if (requestStr == null || requestStr.equals(\"\") || requestStr.equalsIgnoreCase(\"targetSubnet\")) {\n                    // do nothing\n                } else if (requestStr.equalsIgnoreCase(\"targetHost\")) {\n                    targetOffset = false;\n                } else if (IpValidator.isIpValid(requestStr)) {\n                    s_requestIpAddress = setIpAddress(requestStr);\n                    reqTargetIp = false;\n                    targetOffset = false;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"REQUEST query options are: reqTargetIp = \" + reqTargetIp + \", targetOffset = \" + targetOffset);\n                }\n            }\n            paramsChecked = true;\n        }\n\n        int j = 1;\n        if (extendedMode == true) {\n            j = typeList.length;\n        }\n\n        if (timeout < 500) {\n            timeout = 500;\n        }\n\n        Poller p = new Poller(timeout);\n        long responseTime = -1;\n        try {\n            pollit: for (int i = 0; i < j; i++) {\n\n                Message ping = getPollingRequest(host, (byte) typeList[i]);\n\n                int rt = retries;\n                while (rt >= 0 && !isDhcpServer) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"isServer: sending DHCP \" + typeName[i] + \" query to host \" + host.getHostAddress() + \" with Xid: \" + ping.getMessage().getXid());\n                    }\n                    \n                    long start = System.currentTimeMillis();\n                    p.m_outs.writeObject(ping);\n                    long end;\n\n                    do {\n                        Message resp = null;\n                        try {\n                            resp = (Message) p.m_ins.readObject();\n                        } catch (InterruptedIOException ex) {\n                            resp = null;\n                        }\n\n                        if (resp != null) {\n                            responseTime = System.currentTimeMillis() - start;\n\n                            // DEBUG only\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"isServer: got a DHCP response from host \" + resp.getAddress().getHostAddress() + \" with Xid: \" + resp.getMessage().getXid());\n                            }\n\n                            if (host.equals(resp.getAddress()) && ping.getMessage().getXid() == resp.getMessage().getXid()) {\n                                // Inspect response message to see if it is a valid DHCP response\n                                byte[] type = resp.getMessage().getOption(MESSAGE_TYPE);\n                                if (log.isDebugEnabled()) {\n                                    if (type[0] == DHCPMessage.OFFER) {\n                                        log.debug(\"isServer: got a DHCP OFFER response, validating...\");\n                                    } else if (type[0] == DHCPMessage.ACK) {\n                                        log.debug(\"isServer: got a DHCP ACK response, validating...\");\n                                    } else if (type[0] == DHCPMessage.NAK) {\n                                        log.debug(\"isServer: got a DHCP NAK response, validating...\");\n                                    }\n                                }\n\n                                // accept offer or ACK or NAK\n                                if (type[0] == DHCPMessage.OFFER || (extendedMode == true && (type[0] == DHCPMessage.ACK || type[0] == DHCPMessage.NAK))) {\n                                    if (log.isDebugEnabled()) {\n                                        log.debug(\"isServer: got a valid DHCP response. responseTime= \" + responseTime + \"ms\");\n                                    }\n                                    \n                                    isDhcpServer = true;\n                                    break pollit;\n                                }\n                            }\n                        }\n\n                        end = System.currentTimeMillis();\n\n                    } while ((end - start) < timeout);\n\n                    if (log.isDebugEnabled()) {\n                        if (!isDhcpServer) {\n                            log.debug(\"Timed out waiting for DHCP response, remaining retries: \" + rt);\n                        }\n                    }\n\n                    --rt;\n                }\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Sending disconnect request\");\n            }\n            p.m_outs.writeObject(getDisconnectRequest());\n            if (log.isDebugEnabled()) {\n                log.debug(\"wait half a sec before closing connection\");\n            }\n            Thread.sleep(500);\n            p.close();\n        } catch (IOException ex) {\n            log.error(\"IO Exception caught.\", ex);\n            p.close();\n            throw ex;\n        } catch (Throwable t) {\n            log.error(\"Unexpected Exception caught.\", t);\n            p.close();\n            throw new UndeclaredThrowableException(t);\n        }\n\n        // Return response time if the remote box IS a DHCP\n        // server or -1 if the remote box is NOT a DHCP server.\n        if (isDhcpServer) {\n            return responseTime;\n        } else {\n            return -1;\n        }\n    }","id":93973,"modified_method":"/**\n     * <p>\n     * This method actually tests the remote host to determine if it is\n     * running a functional DHCP server.\n     * <\/p>\n     * <p>\n     * Formats a DHCP query and encodes it in a client request message which\n     * is sent to the DHCP daemon over the established TCP socket connection.\n     * If a matching DHCP response packet is not received from the DHCP daemon\n     * within the specified timeout the client request message will be re-sent\n     * up to the specified number of retries.\n     * <\/p>\n     * <p>\n     * If a response is received from the DHCP daemon it is validated to\n     * ensure that:\n     * <\/p>\n     * <ul>\n     * <li>The DHCP response packet was sent from the remote host to which the\n     * original request packet was directed.<\/li>\n     * <li>The XID of the DHCP response packet matches the XID of the original\n     * DHCP request packet.<\/li>\n     * <\/ul>\n     * <p>\n     * If the response validates 'true' is returned. Otherwise the request is\n     * resent until max retry count is exceeded.\n     * <\/p>\n     * <p>\n     * Before returning, a client disconnect message (remote host field set to\n     * zero) is sent to the DHCP daemon.\n     * <\/p>\n     * \n     * @return response time in milliseconds if the specified host responded\n     *         with a valid DHCP offer datagram within the context of the\n     *         specified timeout and retry values or negative one (-1)\n     *         otherwise.\n     */\n    static long isServer(InetAddress host, long timeout, int retries) throws IOException {\n        Category log = ThreadCategory.getInstance(Poller.class);\n\n        boolean isDhcpServer = false;\n        // List of DHCP queries to try. The default when extended\n        // mode = false must be listed first. (DISCOVER)\n        byte[] typeList = { (byte) DHCPMessage.DISCOVER, (byte) DHCPMessage.INFORM, (byte) DHCPMessage.REQUEST };\n        String[] typeName = { \"DISCOVER\", \"INFORM\", \"REQUEST\" };\n        DhcpdConfigFactory dcf = DhcpdConfigFactory.getInstance();\n        if (!paramsChecked) {\n            String s_extendedMode = dcf.getExtendedMode();\n            if (s_extendedMode == null) {\n                extendedMode = false;\n            } else {\n                extendedMode = Boolean.parseBoolean(s_extendedMode);\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"isServer: DHCP extended mode is \" + extendedMode);\n            }\n            \n            String hwAddressStr = dcf.getMacAddress();\n            if (log.isDebugEnabled()) {\n                log.debug(\"isServer: DHCP query hardware/MAC address is \" + hwAddressStr);\n            }\n            setHwAddress(hwAddressStr);\n            \n            String myIpStr = dcf.getMyIpAddress();\n            if (log.isDebugEnabled()) {\n                log.debug(\"isServer: DHCP relay agent address is \" + myIpStr);\n            }\n            if (myIpStr == null || myIpStr.equals(\"\") || myIpStr.equalsIgnoreCase(\"broadcast\")) {\n                // do nothing\n            } else if (IpValidator.isIpValid(myIpStr)) {\n                s_myIpAddress = setIpAddress(myIpStr);\n                relayMode = true;\n            }\n            \n            if (extendedMode == true) {\n                String requestStr = dcf.getRequestIpAddress();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: REQUEST query target is \" + requestStr);\n                }\n                if (requestStr == null || requestStr.equals(\"\") || requestStr.equalsIgnoreCase(\"targetSubnet\")) {\n                    // do nothing\n                } else if (requestStr.equalsIgnoreCase(\"targetHost\")) {\n                    targetOffset = false;\n                } else if (IpValidator.isIpValid(requestStr)) {\n                    s_requestIpAddress = setIpAddress(requestStr);\n                    reqTargetIp = false;\n                    targetOffset = false;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"REQUEST query options are: reqTargetIp = \" + reqTargetIp + \", targetOffset = \" + targetOffset);\n                }\n            }\n            paramsChecked = true;\n        }\n\n        int j = 1;\n        if (extendedMode == true) {\n            j = typeList.length;\n        }\n\n        if (timeout < 500) {\n            timeout = 500;\n        }\n\n        Poller p = new Poller(timeout);\n        long responseTime = -1;\n        try {\n            pollit: for (int i = 0; i < j; i++) {\n\n                Message ping = getPollingRequest(host, (byte) typeList[i]);\n\n                int rt = retries;\n                while (rt >= 0 && !isDhcpServer) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"isServer: sending DHCP \" + typeName[i] + \" query to host \" + host.getHostAddress() + \" with Xid: \" + ping.getMessage().getXid());\n                    }\n                    \n                    long start = System.currentTimeMillis();\n                    p.m_outs.writeObject(ping);\n                    long end;\n\n                    do {\n                        Message resp = null;\n                        try {\n                            resp = (Message) p.m_ins.readObject();\n                        } catch (InterruptedIOException ex) {\n                            resp = null;\n                        }\n\n                        if (resp != null) {\n                            responseTime = System.currentTimeMillis() - start;\n\n                            // DEBUG only\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"isServer: got a DHCP response from host \" + resp.getAddress().getHostAddress() + \" with Xid: \" + resp.getMessage().getXid());\n                            }\n\n                            if (host.equals(resp.getAddress()) && ping.getMessage().getXid() == resp.getMessage().getXid()) {\n                                // Inspect response message to see if it is a valid DHCP response\n                                byte[] type = resp.getMessage().getOption(MESSAGE_TYPE);\n                                if (log.isDebugEnabled()) {\n                                    if (type[0] == DHCPMessage.OFFER) {\n                                        log.debug(\"isServer: got a DHCP OFFER response, validating...\");\n                                    } else if (type[0] == DHCPMessage.ACK) {\n                                        log.debug(\"isServer: got a DHCP ACK response, validating...\");\n                                    } else if (type[0] == DHCPMessage.NAK) {\n                                        log.debug(\"isServer: got a DHCP NAK response, validating...\");\n                                    }\n                                }\n\n                                // accept offer or ACK or NAK\n                                if (type[0] == DHCPMessage.OFFER || (extendedMode == true && (type[0] == DHCPMessage.ACK || type[0] == DHCPMessage.NAK))) {\n                                    if (log.isDebugEnabled()) {\n                                        log.debug(\"isServer: got a valid DHCP response. responseTime= \" + responseTime + \"ms\");\n                                    }\n                                    \n                                    isDhcpServer = true;\n                                    break pollit;\n                                }\n                            }\n                        }\n\n                        end = System.currentTimeMillis();\n\n                    } while ((end - start) < timeout);\n\n                    if (log.isDebugEnabled()) {\n                        if (!isDhcpServer) {\n                            log.debug(\"Timed out waiting for DHCP response, remaining retries: \" + rt);\n                        }\n                    }\n\n                    --rt;\n                }\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Sending disconnect request\");\n            }\n            p.m_outs.writeObject(getDisconnectRequest());\n            if (log.isDebugEnabled()) {\n                log.debug(\"wait half a sec before closing connection\");\n            }\n            Thread.sleep(500);\n            p.close();\n        } catch (IOException ex) {\n            log.error(\"IO Exception caught.\", ex);\n            p.close();\n            throw ex;\n        } catch (Throwable t) {\n            log.error(\"Unexpected Exception caught.\", t);\n            p.close();\n            throw new UndeclaredThrowableException(t);\n        }\n\n        // Return response time if the remote box IS a DHCP\n        // server or -1 if the remote box is NOT a DHCP server.\n        if (isDhcpServer) {\n            return responseTime;\n        } else {\n            return -1;\n        }\n    }","commit_id":"174ea4b243260a9ef624e0c7b5be89544e2f004f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>\n     * This method actually tests the remote host to determine if it is\n     * running a functional DHCP server.\n     * <\/p>\n     * <p>\n     * Formats a DHCP query and encodes it in a client request message which\n     * is sent to the DHCP daemon over the established TCP socket connection.\n     * If a matching DHCP response packet is not received from the DHCP daemon\n     * within the specified timeout the client request message will be re-sent\n     * up to the specified number of retries.\n     * <\/p>\n     * <p>\n     * If a response is received from the DHCP daemon it is validated to\n     * ensure that:\n     * <\/p>\n     * <ul>\n     * <li>The DHCP response packet was sent from the remote host to which the\n     * original request packet was directed.<\/li>\n     * <li>The XID of the DHCP response packet matches the XID of the original\n     * DHCP request packet.<\/li>\n     * <\/ul>\n     * <p>\n     * If the response validates 'true' is returned. Otherwise the request is\n     * resent until max retry count is exceeded.\n     * <\/p>\n     * <p>\n     * Before returning, a client disconnect message (remote host field set to\n     * zero) is sent to the DHCP daemon.\n     * <\/p>\n     * \n     * @return response time in milliseconds if the specified host responded\n     *         with a valid DHCP offer datagram within the context of the\n     *         specified timeout and retry values or negative one (-1)\n     *         otherwise.\n     */\n    static long isServer(InetAddress host, long timeout, int retries) throws IOException {\n        Category log = ThreadCategory.getInstance(Poller.class);\n\n        boolean isDhcpServer = false;\n        // List of DHCP queries to try. The default when extended\n        // mode = false must be listed first. (DISCOVER)\n        byte[] typeList = { (byte) DHCPMessage.DISCOVER, (byte) DHCPMessage.INFORM, (byte) DHCPMessage.REQUEST };\n        String[] typeName = { \"DISCOVER\", \"INFORM\", \"REQUEST\" };\n        DhcpdConfigFactory dcf = DhcpdConfigFactory.getInstance();\n        if (!paramsChecked) {\n            if (extendedMode == null) {\n                String s_extendedMode = dcf.getExtendedMode();\n                if (s_extendedMode == null) {\n                    extendedMode = false;\n                } else {\n                    extendedMode = Boolean.parseBoolean(s_extendedMode);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: DHCP extended mode is \" + extendedMode);\n                }\n            }\n            if (s_hwAddress == null) {\n                String hwAddressStr = dcf.getMacAddress();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: DHCP query hardware/MAC address is \" + hwAddressStr);\n                }\n                setHwAddress(hwAddressStr);\n            }\n            if (s_myIpAddress == null) {\n                String myIpStr = dcf.getMyIpAddress();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: DHCP relay agent address is \" + myIpStr);\n                }\n                if (myIpStr == null || myIpStr.equals(\"\") || myIpStr.equalsIgnoreCase(\"broadcast\")) {\n                    // do nothing\n                } else if (IpValidator.isIpValid(myIpStr)) {\n                    s_myIpAddress = setIpAddress(myIpStr);\n                    relayMode = true;\n                }\n            }\n            if (s_requestIpAddress == null && extendedMode == true) {\n                String requestStr = dcf.getRequestIpAddress();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: REQUEST query target is \" + requestStr);\n                }\n                if (requestStr == null || requestStr.equals(\"\") || requestStr.equalsIgnoreCase(\"targetSubnet\")) {\n                    // do nothing\n                } else if (requestStr.equalsIgnoreCase(\"targetHost\")) {\n                    targetOffset = false;\n                } else if (IpValidator.isIpValid(requestStr)) {\n                    s_requestIpAddress = setIpAddress(requestStr);\n                    reqTargetIp = false;\n                    targetOffset = false;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"REQUEST query options are: reqTargetIp = \" + reqTargetIp + \", targetOffset = \" + targetOffset);\n                }\n            }\n            paramsChecked = true;\n        }\n\n        int j = 1;\n        if (extendedMode == true) {\n            j = typeList.length;\n        }\n\n        if (timeout < 500) {\n            timeout = 500;\n        }\n\n        Poller p = new Poller(timeout);\n        long responseTime = -1;\n        try {\n            pollit: for (int i = 0; i < j; i++) {\n\n                Message ping = getPollingRequest(host, (byte) typeList[i]);\n\n                int rt = retries;\n                while (rt >= 0 && !isDhcpServer) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"isServer: sending DHCP \" + typeName[i] + \" query to host \" + host.getHostAddress() + \" with Xid: \" + ping.getMessage().getXid());\n                    }\n                    \n                    long start = System.currentTimeMillis();\n                    p.m_outs.writeObject(ping);\n                    long end;\n\n                    do {\n                        Message resp = null;\n                        try {\n                            resp = (Message) p.m_ins.readObject();\n                        } catch (InterruptedIOException ex) {\n                            resp = null;\n                        }\n\n                        if (resp != null) {\n                            responseTime = System.currentTimeMillis() - start;\n\n                            // DEBUG only\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"isServer: got a DHCP response from host \" + resp.getAddress().getHostAddress() + \" with Xid: \" + resp.getMessage().getXid());\n                            }\n\n                            if (host.equals(resp.getAddress()) && ping.getMessage().getXid() == resp.getMessage().getXid()) {\n                                // Inspect response message to see if it is a valid DHCP response\n                                byte[] type = resp.getMessage().getOption(MESSAGE_TYPE);\n                                if (log.isDebugEnabled()) {\n                                    if (type[0] == DHCPMessage.OFFER) {\n                                        log.debug(\"isServer: got a DHCP OFFER response, validating...\");\n                                    } else if (type[0] == DHCPMessage.ACK) {\n                                        log.debug(\"isServer: got a DHCP ACK response, validating...\");\n                                    } else if (type[0] == DHCPMessage.NAK) {\n                                        log.debug(\"isServer: got a DHCP NAK response, validating...\");\n                                    }\n                                }\n\n                                // accept offer or ACK or NAK\n                                if (type[0] == DHCPMessage.OFFER || (extendedMode == true && (type[0] == DHCPMessage.ACK || type[0] == DHCPMessage.NAK))) {\n                                    if (log.isDebugEnabled()) {\n                                        log.debug(\"isServer: got a valid DHCP response. responseTime= \" + responseTime + \"ms\");\n                                    }\n                                    \n                                    isDhcpServer = true;\n                                    break pollit;\n                                }\n                            }\n                        }\n\n                        end = System.currentTimeMillis();\n\n                    } while ((end - start) < timeout);\n\n                    if (log.isDebugEnabled()) {\n                        if (!isDhcpServer) {\n                            log.debug(\"Timed out waiting for DHCP response, remaining retries: \" + rt);\n                        }\n                    }\n\n                    --rt;\n                }\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Sending disconnect request\");\n            }\n            p.m_outs.writeObject(getDisconnectRequest());\n            if (log.isDebugEnabled()) {\n                log.debug(\"wait half a sec before closing connection\");\n            }\n            Thread.sleep(500);\n            p.close();\n        } catch (IOException ex) {\n            log.error(\"IO Exception caught.\", ex);\n            p.close();\n            throw ex;\n        } catch (Throwable t) {\n            log.error(\"Unexpected Exception caught.\", t);\n            p.close();\n            throw new UndeclaredThrowableException(t);\n        }\n\n        // Return response time if the remote box IS a DHCP\n        // server or -1 if the remote box is NOT a DHCP server.\n        if (isDhcpServer) {\n            return responseTime;\n        } else {\n            return -1;\n        }\n    }","id":93974,"modified_method":"/**\n     * <p>\n     * This method actually tests the remote host to determine if it is\n     * running a functional DHCP server.\n     * <\/p>\n     * <p>\n     * Formats a DHCP query and encodes it in a client request message which\n     * is sent to the DHCP daemon over the established TCP socket connection.\n     * If a matching DHCP response packet is not received from the DHCP daemon\n     * within the specified timeout the client request message will be re-sent\n     * up to the specified number of retries.\n     * <\/p>\n     * <p>\n     * If a response is received from the DHCP daemon it is validated to\n     * ensure that:\n     * <\/p>\n     * <ul>\n     * <li>The DHCP response packet was sent from the remote host to which the\n     * original request packet was directed.<\/li>\n     * <li>The XID of the DHCP response packet matches the XID of the original\n     * DHCP request packet.<\/li>\n     * <\/ul>\n     * <p>\n     * If the response validates 'true' is returned. Otherwise the request is\n     * resent until max retry count is exceeded.\n     * <\/p>\n     * <p>\n     * Before returning, a client disconnect message (remote host field set to\n     * zero) is sent to the DHCP daemon.\n     * <\/p>\n     * \n     * @return response time in milliseconds if the specified host responded\n     *         with a valid DHCP offer datagram within the context of the\n     *         specified timeout and retry values or negative one (-1)\n     *         otherwise.\n     */\n    static long isServer(InetAddress host, long timeout, int retries) throws IOException {\n        Category log = ThreadCategory.getInstance(Poller.class);\n\n        boolean isDhcpServer = false;\n        // List of DHCP queries to try. The default when extended\n        // mode = false must be listed first. (DISCOVER)\n        byte[] typeList = { (byte) DHCPMessage.DISCOVER, (byte) DHCPMessage.INFORM, (byte) DHCPMessage.REQUEST };\n        String[] typeName = { \"DISCOVER\", \"INFORM\", \"REQUEST\" };\n        DhcpdConfigFactory dcf = DhcpdConfigFactory.getInstance();\n        if (!paramsChecked) {\n            String s_extendedMode = dcf.getExtendedMode();\n            if (s_extendedMode == null) {\n                extendedMode = false;\n            } else {\n                extendedMode = Boolean.parseBoolean(s_extendedMode);\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"isServer: DHCP extended mode is \" + extendedMode);\n            }\n            \n            String hwAddressStr = dcf.getMacAddress();\n            if (log.isDebugEnabled()) {\n                log.debug(\"isServer: DHCP query hardware/MAC address is \" + hwAddressStr);\n            }\n            setHwAddress(hwAddressStr);\n            \n            String myIpStr = dcf.getMyIpAddress();\n            if (log.isDebugEnabled()) {\n                log.debug(\"isServer: DHCP relay agent address is \" + myIpStr);\n            }\n            if (myIpStr == null || myIpStr.equals(\"\") || myIpStr.equalsIgnoreCase(\"broadcast\")) {\n                // do nothing\n            } else if (IpValidator.isIpValid(myIpStr)) {\n                s_myIpAddress = setIpAddress(myIpStr);\n                relayMode = true;\n            }\n            \n            if (extendedMode == true) {\n                String requestStr = dcf.getRequestIpAddress();\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isServer: REQUEST query target is \" + requestStr);\n                }\n                if (requestStr == null || requestStr.equals(\"\") || requestStr.equalsIgnoreCase(\"targetSubnet\")) {\n                    // do nothing\n                } else if (requestStr.equalsIgnoreCase(\"targetHost\")) {\n                    targetOffset = false;\n                } else if (IpValidator.isIpValid(requestStr)) {\n                    s_requestIpAddress = setIpAddress(requestStr);\n                    reqTargetIp = false;\n                    targetOffset = false;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"REQUEST query options are: reqTargetIp = \" + reqTargetIp + \", targetOffset = \" + targetOffset);\n                }\n            }\n            paramsChecked = true;\n        }\n\n        int j = 1;\n        if (extendedMode == true) {\n            j = typeList.length;\n        }\n\n        if (timeout < 500) {\n            timeout = 500;\n        }\n\n        Poller p = new Poller(timeout);\n        long responseTime = -1;\n        try {\n            pollit: for (int i = 0; i < j; i++) {\n\n                Message ping = getPollingRequest(host, (byte) typeList[i]);\n\n                int rt = retries;\n                while (rt >= 0 && !isDhcpServer) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"isServer: sending DHCP \" + typeName[i] + \" query to host \" + host.getHostAddress() + \" with Xid: \" + ping.getMessage().getXid());\n                    }\n                    \n                    long start = System.currentTimeMillis();\n                    p.m_outs.writeObject(ping);\n                    long end;\n\n                    do {\n                        Message resp = null;\n                        try {\n                            resp = (Message) p.m_ins.readObject();\n                        } catch (InterruptedIOException ex) {\n                            resp = null;\n                        }\n\n                        if (resp != null) {\n                            responseTime = System.currentTimeMillis() - start;\n\n                            // DEBUG only\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"isServer: got a DHCP response from host \" + resp.getAddress().getHostAddress() + \" with Xid: \" + resp.getMessage().getXid());\n                            }\n\n                            if (host.equals(resp.getAddress()) && ping.getMessage().getXid() == resp.getMessage().getXid()) {\n                                // Inspect response message to see if it is a valid DHCP response\n                                byte[] type = resp.getMessage().getOption(MESSAGE_TYPE);\n                                if (log.isDebugEnabled()) {\n                                    if (type[0] == DHCPMessage.OFFER) {\n                                        log.debug(\"isServer: got a DHCP OFFER response, validating...\");\n                                    } else if (type[0] == DHCPMessage.ACK) {\n                                        log.debug(\"isServer: got a DHCP ACK response, validating...\");\n                                    } else if (type[0] == DHCPMessage.NAK) {\n                                        log.debug(\"isServer: got a DHCP NAK response, validating...\");\n                                    }\n                                }\n\n                                // accept offer or ACK or NAK\n                                if (type[0] == DHCPMessage.OFFER || (extendedMode == true && (type[0] == DHCPMessage.ACK || type[0] == DHCPMessage.NAK))) {\n                                    if (log.isDebugEnabled()) {\n                                        log.debug(\"isServer: got a valid DHCP response. responseTime= \" + responseTime + \"ms\");\n                                    }\n                                    \n                                    isDhcpServer = true;\n                                    break pollit;\n                                }\n                            }\n                        }\n\n                        end = System.currentTimeMillis();\n\n                    } while ((end - start) < timeout);\n\n                    if (log.isDebugEnabled()) {\n                        if (!isDhcpServer) {\n                            log.debug(\"Timed out waiting for DHCP response, remaining retries: \" + rt);\n                        }\n                    }\n\n                    --rt;\n                }\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Sending disconnect request\");\n            }\n            p.m_outs.writeObject(getDisconnectRequest());\n            if (log.isDebugEnabled()) {\n                log.debug(\"wait half a sec before closing connection\");\n            }\n            Thread.sleep(500);\n            p.close();\n        } catch (IOException ex) {\n            log.error(\"IO Exception caught.\", ex);\n            p.close();\n            throw ex;\n        } catch (Throwable t) {\n            log.error(\"Unexpected Exception caught.\", t);\n            p.close();\n            throw new UndeclaredThrowableException(t);\n        }\n\n        // Return response time if the remote box IS a DHCP\n        // server or -1 if the remote box is NOT a DHCP server.\n        if (isDhcpServer) {\n            return responseTime;\n        } else {\n            return -1;\n        }\n    }","commit_id":"cc512834816bfe127dd7a2e5cd8e7871d64fa820","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void describeMojoGuts( MojoDescriptor md, StringBuffer buffer )\n    {\n        buffer.append( \"\\nDescription:\\n\\n\" ).append( md.getDescription() ).append( \"\\n\" );\n        \n        String deprecation = md.getDeprecated();\n        \n        if ( deprecation != null )\n        {\n            buffer.append( \"\\n\\nNOTE: This mojo is deprecated.\\n\" ).append( deprecation ).append( \"\\n\" );\n        }\n        \n        buffer.append( \"\\nImplementation: \" ).append( md.getImplementation() );\n        buffer.append( \"\\nLanguage: \" ).append( md.getLanguage() );\n        \n        String phase = md.getPhase();\n        if ( phase != null )\n        {\n            buffer.append( \"\\nBound to Phase: \" ).append( phase );\n        }\n        \n        String eGoal = md.getExecuteGoal();\n        String eLife = md.getExecuteLifecycle();\n        String ePhase = md.getExecutePhase();\n        \n        if ( eGoal != null || ePhase != null )\n        {\n            buffer.append( \"\\n\\nBefore this mojo executes, it will call:\\n\" );\n            \n            if ( eGoal != null )\n            {\n                buffer.append( \"\\nSingle mojo: \\'\" ).append( eGoal ).append( \"\\'\" );\n            }\n            \n            if ( ePhase != null )\n            {\n                buffer.append( \"\\nPhase: \\'\" ).append( ePhase ).append( \"\\'\" );\n                \n                if ( eLife != null )\n                {\n                    buffer.append( \" in Lifecycle Overlay: \\'\" ).append( eLife ).append( \"\\'\" );\n                }\n            }\n        }\n        \n        List parameters = md.getParameters();\n        \n        List requirements = md.getRequirements();\n    }","id":93975,"modified_method":"private void describeMojoGuts( MojoDescriptor md, StringBuffer buffer, boolean fullDescription )\n    {\n        buffer.append( \"\\nDescription:\\n\\n\" );\n        prettyAppend( formatDescription( md.getDescription() ), buffer );\n        buffer.append( \"\\n\" );\n        \n        String deprecation = md.getDeprecated();\n        \n        if ( deprecation != null )\n        {\n            buffer.append( \"\\n\\nNOTE: This mojo is deprecated.\\n\" ).append( deprecation ).append( \"\\n\" );\n        }\n        \n        if ( fullDescription )\n        {\n            buffer.append( \"\\nImplementation: \" ).append( md.getImplementation() );\n            buffer.append( \"\\nLanguage: \" ).append( md.getLanguage() );\n\n            String phase = md.getPhase();\n            if ( phase != null )\n            {\n                buffer.append( \"\\nBound to Phase: \" ).append( phase );\n            }\n\n            String eGoal = md.getExecuteGoal();\n            String eLife = md.getExecuteLifecycle();\n            String ePhase = md.getExecutePhase();\n\n            if ( eGoal != null || ePhase != null )\n            {\n                buffer.append( \"\\n\\nBefore this mojo executes, it will call:\\n\" );\n\n                if ( eGoal != null )\n                {\n                    buffer.append( \"\\nSingle mojo: \\'\" ).append( eGoal ).append( \"\\'\" );\n                }\n\n                if ( ePhase != null )\n                {\n                    buffer.append( \"\\nPhase: \\'\" ).append( ePhase ).append( \"\\'\" );\n\n                    if ( eLife != null )\n                    {\n                        buffer.append( \" in Lifecycle Overlay: \\'\" ).append( eLife ).append( \"\\'\" );\n                    }\n                }\n            }\n\n            describeMojoParameters( md, buffer );\n\n            describeMojoRequirements( md, buffer );\n        }\n    }","commit_id":"1adf576da83849452e3d32ac9c27f2bbda316d07","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void describeMojo( MojoDescriptor md, StringBuffer buffer )\n    {\n        buffer.append( \"Mojo: \\'\" ).append( md.getFullGoalName() ).append( '\\'' );\n        buffer.append( \"\\n-----------------------------------------------\" );\n        buffer.append( \"\\nGoal: \\'\" ).append( md.getGoal() ).append( \"\\'\" );\n\n        describeMojoGuts( md, buffer );\n        \n        buffer.append( \"\\n\\n\" );\n    }","id":93976,"modified_method":"private void describeMojo( MojoDescriptor md, StringBuffer buffer )\n    {\n        String line = \"\\n===============================================\";\n        \n        buffer.append( \"Mojo: \\'\" ).append( md.getFullGoalName() ).append( '\\'' );\n        buffer.append( line );\n        buffer.append( \"\\nGoal: \\'\" ).append( md.getGoal() ).append( \"\\'\" );\n\n        describeMojoGuts( md, buffer, full );\n        \n        buffer.append( line );\n        buffer.append( \"\\n\\n\" );\n    }","commit_id":"1adf576da83849452e3d32ac9c27f2bbda316d07","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        PluginInfo pi = new PluginInfo();\n        \n        parsePluginLookupInfo( pi );\n        \n        PluginDescriptor descriptor = lookupPluginDescriptor( pi );\n\n        StringBuffer descriptionBuffer = new StringBuffer();\n\n        if ( mojo != null && mojo.length() > 0 )\n        {\n            describeMojo( descriptor.getMojo( mojo ), descriptionBuffer );\n        }\n        else\n        {\n            describePlugin( descriptor, descriptionBuffer );\n        }\n\n        writeDescription( descriptionBuffer );\n    }","id":93977,"modified_method":"public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( project == null )\n        {\n            try\n            {\n                project = projectBuilder.buildStandaloneSuperProject( localRepository );\n            }\n            catch ( ProjectBuildingException e )\n            {\n                throw new MojoExecutionException( \"Error while retrieving the super-project.\", e );\n            }\n        }\n        \n        PluginInfo pi = new PluginInfo();\n        \n        parsePluginLookupInfo( pi );\n        \n        PluginDescriptor descriptor = lookupPluginDescriptor( pi );\n\n        StringBuffer descriptionBuffer = new StringBuffer();\n\n        if ( mojo != null && mojo.length() > 0 )\n        {\n            describeMojo( descriptor.getMojo( mojo ), descriptionBuffer );\n        }\n        else\n        {\n            describePlugin( descriptor, descriptionBuffer );\n        }\n\n        writeDescription( descriptionBuffer );\n    }","commit_id":"1adf576da83849452e3d32ac9c27f2bbda316d07","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void writeDescription( StringBuffer descriptionBuffer ) throws MojoExecutionException\n    {\n        if ( output != null )\n        {\n            Writer out = null;\n            try\n            {\n                output.getParentFile().mkdirs();\n                \n                out = new FileWriter( output );\n\n                out.write( descriptionBuffer.toString() );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write plugin/mojo description.\", e );\n            }\n            finally\n            {\n                if ( out != null )\n                {\n                    try\n                    {\n                        out.close();\n                    }\n                    catch ( IOException e )\n                    {\n                        getLog().debug( \"Error closing file output.\", e );\n                    }\n                }\n            }\n        }\n        else\n        {\n            getLog().info( descriptionBuffer.toString() );\n        }\n    }","id":93978,"modified_method":"private void writeDescription( StringBuffer descriptionBuffer ) throws MojoExecutionException\n    {\n        if ( output != null )\n        {\n            Writer out = null;\n            try\n            {\n                output.getParentFile().mkdirs();\n                \n                out = new FileWriter( output );\n\n                out.write( descriptionBuffer.toString() );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write plugin/mojo description.\", e );\n            }\n            finally\n            {\n                if ( out != null )\n                {\n                    try\n                    {\n                        out.close();\n                    }\n                    catch ( IOException e )\n                    {\n                        getLog().debug( \"Error closing file output.\", e );\n                    }\n                }\n            }\n            \n            getLog().info( \"Wrote descriptions to: \" + output );\n        }\n        else\n        {\n            getLog().info( descriptionBuffer.toString() );\n        }\n    }","commit_id":"1adf576da83849452e3d32ac9c27f2bbda316d07","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void describePlugin( PluginDescriptor pd, StringBuffer buffer )\n    {\n        buffer.append( \"Plugin: \\'\" ).append( pd.getName() ).append( '\\'' );\n        buffer.append( \"\\n-----------------------------------------------\" );\n        buffer.append( \"\\nGroup Id:  \" ).append( pd.getGroupId() );\n        buffer.append( \"\\nArtifact Id: \" ).append( pd.getArtifactId() );\n        buffer.append( \"\\nVersion:     \" ).append( pd.getVersion() );\n        buffer.append( \"\\nGoal Prefix: \" ).append( pd.getGoalPrefix() );\n        buffer.append( \"\\nDescription:\\n\\n\" ).append( pd.getDescription() ).append( \"\\n\" );\n        buffer.append( \"\\nMojos:\\n\" );\n\n        for ( Iterator it = pd.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor md = (MojoDescriptor) it.next();\n\n            buffer.append( \"\\nGoal: \\'\" ).append( md.getGoal() ).append( '\\'' );\n            buffer.append( \"\\n========================================\" );\n            \n            describeMojoGuts( md, buffer );\n            \n            buffer.append( \"\\n\\n\" );\n        }\n    }","id":93979,"modified_method":"private void describePlugin( PluginDescriptor pd, StringBuffer buffer )\n    {\n        String name = pd.getName();\n        if ( name == null )\n        {\n            name = pd.getId();\n        }\n        \n        buffer.append( \"Plugin: \\'\" ).append( name ).append( '\\'' );\n        buffer.append( \"\\n-----------------------------------------------\" );\n        buffer.append( \"\\nGroup Id:  \" ).append( pd.getGroupId() );\n        buffer.append( \"\\nArtifact Id: \" ).append( pd.getArtifactId() );\n        buffer.append( \"\\nVersion:     \" ).append( pd.getVersion() );\n        buffer.append( \"\\nGoal Prefix: \" ).append( pd.getGoalPrefix() );\n        \n        buffer.append( \"\\nDescription:\\n\\n\" );\n        prettyAppend( formatDescription( pd.getDescription() ), buffer );\n        buffer.append( \"\\n\" );\n        \n        if ( full )\n        {\n            buffer.append( \"\\nMojos:\\n\" );\n\n            String line = \"\\n===============================================\";\n            \n            for ( Iterator it = pd.getMojos().iterator(); it.hasNext(); )\n            {\n                MojoDescriptor md = (MojoDescriptor) it.next();\n\n                buffer.append( line );\n                buffer.append( \"\\nGoal: \\'\" ).append( md.getGoal() ).append( '\\'' );\n                buffer.append( line );\n                \n                describeMojoGuts( md, buffer, true );\n                \n                buffer.append( line );\n                buffer.append( \"\\n\\n\" );\n            }\n        }\n    }","commit_id":"1adf576da83849452e3d32ac9c27f2bbda316d07","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        PluginInfo pi = new PluginInfo();\n        \n        parsePluginLookupInfo( pi );\n        \n        PluginDescriptor descriptor = lookupPluginDescriptor( pi );\n\n        StringBuffer descriptionBuffer = new StringBuffer();\n\n        if ( mojo != null && mojo.length() > 0 )\n        {\n            describeMojo( descriptor.getMojo( mojo ), descriptionBuffer );\n        }\n        else\n        {\n            describePlugin( descriptor, descriptionBuffer );\n        }\n\n        writeDescription( descriptionBuffer );\n    }","id":93980,"modified_method":"public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( project == null )\n        {\n            try\n            {\n                project = projectBuilder.buildStandaloneSuperProject( localRepository );\n            }\n            catch ( ProjectBuildingException e )\n            {\n                throw new MojoExecutionException( \"Error while retrieving the super-project.\", e );\n            }\n        }\n        \n        PluginInfo pi = new PluginInfo();\n        \n        parsePluginLookupInfo( pi );\n        \n        PluginDescriptor descriptor = lookupPluginDescriptor( pi );\n\n        StringBuffer descriptionBuffer = new StringBuffer();\n\n        if ( mojo != null && mojo.length() > 0 )\n        {\n            describeMojo( descriptor.getMojo( mojo ), descriptionBuffer );\n        }\n        else\n        {\n            describePlugin( descriptor, descriptionBuffer );\n        }\n\n        writeDescription( descriptionBuffer );\n    }","commit_id":"dda4d9944fbb8f4f9b8d8b20542d048a86d6ed6b","url":"https://github.com/apache/maven"},{"original_method":"private void describePlugin( PluginDescriptor pd, StringBuffer buffer )\n    {\n        buffer.append( \"Plugin: \\'\" ).append( pd.getName() ).append( '\\'' );\n        buffer.append( \"\\n-----------------------------------------------\" );\n        buffer.append( \"\\nGroup Id:  \" ).append( pd.getGroupId() );\n        buffer.append( \"\\nArtifact Id: \" ).append( pd.getArtifactId() );\n        buffer.append( \"\\nVersion:     \" ).append( pd.getVersion() );\n        buffer.append( \"\\nGoal Prefix: \" ).append( pd.getGoalPrefix() );\n        buffer.append( \"\\nDescription:\\n\\n\" ).append( pd.getDescription() ).append( \"\\n\" );\n        buffer.append( \"\\nMojos:\\n\" );\n\n        for ( Iterator it = pd.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor md = (MojoDescriptor) it.next();\n\n            buffer.append( \"\\nGoal: \\'\" ).append( md.getGoal() ).append( '\\'' );\n            buffer.append( \"\\n========================================\" );\n            \n            describeMojoGuts( md, buffer );\n            \n            buffer.append( \"\\n\\n\" );\n        }\n    }","id":93981,"modified_method":"private void describePlugin( PluginDescriptor pd, StringBuffer buffer )\n    {\n        String name = pd.getName();\n        if ( name == null )\n        {\n            name = pd.getId();\n        }\n        \n        buffer.append( \"Plugin: \\'\" ).append( name ).append( '\\'' );\n        buffer.append( \"\\n-----------------------------------------------\" );\n        buffer.append( \"\\nGroup Id:  \" ).append( pd.getGroupId() );\n        buffer.append( \"\\nArtifact Id: \" ).append( pd.getArtifactId() );\n        buffer.append( \"\\nVersion:     \" ).append( pd.getVersion() );\n        buffer.append( \"\\nGoal Prefix: \" ).append( pd.getGoalPrefix() );\n        \n        buffer.append( \"\\nDescription:\\n\\n\" );\n        prettyAppend( formatDescription( pd.getDescription() ), buffer );\n        buffer.append( \"\\n\" );\n        \n        if ( full )\n        {\n            buffer.append( \"\\nMojos:\\n\" );\n\n            String line = \"\\n===============================================\";\n            \n            for ( Iterator it = pd.getMojos().iterator(); it.hasNext(); )\n            {\n                MojoDescriptor md = (MojoDescriptor) it.next();\n\n                buffer.append( line );\n                buffer.append( \"\\nGoal: \\'\" ).append( md.getGoal() ).append( '\\'' );\n                buffer.append( line );\n                \n                describeMojoGuts( md, buffer, true );\n                \n                buffer.append( line );\n                buffer.append( \"\\n\\n\" );\n            }\n        }\n    }","commit_id":"dda4d9944fbb8f4f9b8d8b20542d048a86d6ed6b","url":"https://github.com/apache/maven"},{"original_method":"private void writeDescription( StringBuffer descriptionBuffer ) throws MojoExecutionException\n    {\n        if ( output != null )\n        {\n            Writer out = null;\n            try\n            {\n                output.getParentFile().mkdirs();\n                \n                out = new FileWriter( output );\n\n                out.write( descriptionBuffer.toString() );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write plugin/mojo description.\", e );\n            }\n            finally\n            {\n                if ( out != null )\n                {\n                    try\n                    {\n                        out.close();\n                    }\n                    catch ( IOException e )\n                    {\n                        getLog().debug( \"Error closing file output.\", e );\n                    }\n                }\n            }\n        }\n        else\n        {\n            getLog().info( descriptionBuffer.toString() );\n        }\n    }","id":93982,"modified_method":"private void writeDescription( StringBuffer descriptionBuffer ) throws MojoExecutionException\n    {\n        if ( output != null )\n        {\n            Writer out = null;\n            try\n            {\n                output.getParentFile().mkdirs();\n                \n                out = new FileWriter( output );\n\n                out.write( descriptionBuffer.toString() );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write plugin/mojo description.\", e );\n            }\n            finally\n            {\n                if ( out != null )\n                {\n                    try\n                    {\n                        out.close();\n                    }\n                    catch ( IOException e )\n                    {\n                        getLog().debug( \"Error closing file output.\", e );\n                    }\n                }\n            }\n            \n            getLog().info( \"Wrote descriptions to: \" + output );\n        }\n        else\n        {\n            getLog().info( descriptionBuffer.toString() );\n        }\n    }","commit_id":"dda4d9944fbb8f4f9b8d8b20542d048a86d6ed6b","url":"https://github.com/apache/maven"},{"original_method":"private void describeMojo( MojoDescriptor md, StringBuffer buffer )\n    {\n        buffer.append( \"Mojo: \\'\" ).append( md.getFullGoalName() ).append( '\\'' );\n        buffer.append( \"\\n-----------------------------------------------\" );\n        buffer.append( \"\\nGoal: \\'\" ).append( md.getGoal() ).append( \"\\'\" );\n\n        describeMojoGuts( md, buffer );\n        \n        buffer.append( \"\\n\\n\" );\n    }","id":93983,"modified_method":"private void describeMojo( MojoDescriptor md, StringBuffer buffer )\n    {\n        String line = \"\\n===============================================\";\n        \n        buffer.append( \"Mojo: \\'\" ).append( md.getFullGoalName() ).append( '\\'' );\n        buffer.append( line );\n        buffer.append( \"\\nGoal: \\'\" ).append( md.getGoal() ).append( \"\\'\" );\n\n        describeMojoGuts( md, buffer, full );\n        \n        buffer.append( line );\n        buffer.append( \"\\n\\n\" );\n    }","commit_id":"dda4d9944fbb8f4f9b8d8b20542d048a86d6ed6b","url":"https://github.com/apache/maven"},{"original_method":"private void describeMojoGuts( MojoDescriptor md, StringBuffer buffer )\n    {\n        buffer.append( \"\\nDescription:\\n\\n\" ).append( md.getDescription() ).append( \"\\n\" );\n        \n        String deprecation = md.getDeprecated();\n        \n        if ( deprecation != null )\n        {\n            buffer.append( \"\\n\\nNOTE: This mojo is deprecated.\\n\" ).append( deprecation ).append( \"\\n\" );\n        }\n        \n        buffer.append( \"\\nImplementation: \" ).append( md.getImplementation() );\n        buffer.append( \"\\nLanguage: \" ).append( md.getLanguage() );\n        \n        String phase = md.getPhase();\n        if ( phase != null )\n        {\n            buffer.append( \"\\nBound to Phase: \" ).append( phase );\n        }\n        \n        String eGoal = md.getExecuteGoal();\n        String eLife = md.getExecuteLifecycle();\n        String ePhase = md.getExecutePhase();\n        \n        if ( eGoal != null || ePhase != null )\n        {\n            buffer.append( \"\\n\\nBefore this mojo executes, it will call:\\n\" );\n            \n            if ( eGoal != null )\n            {\n                buffer.append( \"\\nSingle mojo: \\'\" ).append( eGoal ).append( \"\\'\" );\n            }\n            \n            if ( ePhase != null )\n            {\n                buffer.append( \"\\nPhase: \\'\" ).append( ePhase ).append( \"\\'\" );\n                \n                if ( eLife != null )\n                {\n                    buffer.append( \" in Lifecycle Overlay: \\'\" ).append( eLife ).append( \"\\'\" );\n                }\n            }\n        }\n        \n        List parameters = md.getParameters();\n        \n        List requirements = md.getRequirements();\n    }","id":93984,"modified_method":"private void describeMojoGuts( MojoDescriptor md, StringBuffer buffer, boolean fullDescription )\n    {\n        buffer.append( \"\\nDescription:\\n\\n\" );\n        prettyAppend( formatDescription( md.getDescription() ), buffer );\n        buffer.append( \"\\n\" );\n        \n        String deprecation = md.getDeprecated();\n        \n        if ( deprecation != null )\n        {\n            buffer.append( \"\\n\\nNOTE: This mojo is deprecated.\\n\" ).append( deprecation ).append( \"\\n\" );\n        }\n        \n        if ( fullDescription )\n        {\n            buffer.append( \"\\nImplementation: \" ).append( md.getImplementation() );\n            buffer.append( \"\\nLanguage: \" ).append( md.getLanguage() );\n\n            String phase = md.getPhase();\n            if ( phase != null )\n            {\n                buffer.append( \"\\nBound to Phase: \" ).append( phase );\n            }\n\n            String eGoal = md.getExecuteGoal();\n            String eLife = md.getExecuteLifecycle();\n            String ePhase = md.getExecutePhase();\n\n            if ( eGoal != null || ePhase != null )\n            {\n                buffer.append( \"\\n\\nBefore this mojo executes, it will call:\\n\" );\n\n                if ( eGoal != null )\n                {\n                    buffer.append( \"\\nSingle mojo: \\'\" ).append( eGoal ).append( \"\\'\" );\n                }\n\n                if ( ePhase != null )\n                {\n                    buffer.append( \"\\nPhase: \\'\" ).append( ePhase ).append( \"\\'\" );\n\n                    if ( eLife != null )\n                    {\n                        buffer.append( \" in Lifecycle Overlay: \\'\" ).append( eLife ).append( \"\\'\" );\n                    }\n                }\n            }\n\n            describeMojoParameters( md, buffer );\n\n            describeMojoRequirements( md, buffer );\n        }\n    }","commit_id":"dda4d9944fbb8f4f9b8d8b20542d048a86d6ed6b","url":"https://github.com/apache/maven"},{"original_method":"public static void main(String[] args) throws Exception {\n\t\ttry {\n\t\t\tOptions options = _getOptions();\n\n\t\t\tCommandLineParser commandLineParser = new DefaultParser();\n\n\t\t\tCommandLine commandLine = commandLineParser.parse(options, args);\n\n\t\t\tif (commandLine.hasOption(\"help\")) {\n\t\t\t\t_printOptions();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString deploymentFileNames = null;\n\n\t\t\tif (commandLine.hasOption(\"fileNames\")) {\n\t\t\t\tdeploymentFileNames = commandLine.getOptionValue(\"fileNames\");\n\t\t\t}\n\n\t\t\tString deploymentPath = null;\n\n\t\t\tif (commandLine.hasOption(\"path\")) {\n\t\t\t\tdeploymentPath = commandLine.getOptionValue(\"path\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeploymentPath = \"\";\n\t\t\t}\n\n\t\t\tString outputFileName = null;\n\n\t\t\tif (commandLine.hasOption(\"outputFile\")) {\n\t\t\t\toutputFileName = commandLine.getOptionValue(\"outputFile\");\n\t\t\t}\n\n\t\t\tnew DeploymentHelper(\n\t\t\t\tdeploymentFileNames, deploymentPath, outputFileName);\n\t\t}\n\t\tcatch (ParseException pe) {\n\t\t\tSystem.err.println(pe.getMessage());\n\n\t\t\t_printOptions();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(\"Error running deployment helper\");\n\n\t\t\te.printStackTrace();\n\t\t}\n\t}","id":93985,"modified_method":"public static void main(String[] args) throws Exception {\n\t\ttry {\n\t\t\tOptions options = _getOptions();\n\n\t\t\tCommandLineParser commandLineParser = new DefaultParser();\n\n\t\t\tCommandLine commandLine = commandLineParser.parse(options, args);\n\n\t\t\tif (commandLine.hasOption(\"help\")) {\n\t\t\t\t_printOptions();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString deploymentFileNames = commandLine.getOptionValue(\n\t\t\t\t\"fileNames\");\n\t\t\tString deploymentPath = commandLine.getOptionValue(\"path\", \"\");\n\t\t\tString outputFileName = commandLine.getOptionValue(\"outputFile\");\n\n\t\t\tnew DeploymentHelper(\n\t\t\t\tdeploymentFileNames, deploymentPath, outputFileName);\n\t\t}\n\t\tcatch (ParseException pe) {\n\t\t\tSystem.err.println(pe.getMessage());\n\n\t\t\t_printOptions();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(\"Error running deployment helper\");\n\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"b292fcf6a588aa70c91937228fddeb49376ce35e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void reportAnnotation(@NotNull PsiElement element, @NotNull DeclarationDescriptor descriptor) {\n        reportAnnotation(element, descriptor, false);\n    }","id":93986,"modified_method":"private boolean reportAnnotationIfNeeded(@NotNull PsiElement element, @NotNull DeclarationDescriptor descriptor) {\n        return reportAnnotationIfNeeded(element, descriptor, false);\n    }","commit_id":"5d2edc53b4ac80cba58ba91ec9de35834e37e276","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkPropertyDescriptor(\n            @NotNull JetExpression expression,\n            @NotNull PropertyDescriptor propertyDescriptor\n    ) {\n        // Deprecated for Property\n        if (KotlinBuiltIns.getInstance().isDeprecated(propertyDescriptor)) {\n            reportAnnotation(expression, propertyDescriptor, propertyDescriptor.isVar());\n            return;\n        }\n\n        // Deprecated for Getter (val, var), Setter (var)\n        if (!propertyDescriptor.isVar()) {\n            checkPropertyGetter(propertyDescriptor, expression);\n        }\n        else {\n            IElementType operation = null;\n            JetBinaryExpression binaryExpression = PsiTreeUtil.getParentOfType(expression, JetBinaryExpression.class);\n            if (binaryExpression != null) {\n                JetExpression left = binaryExpression.getLeft();\n                if (left == expression) {\n                    operation = binaryExpression.getOperationToken();\n                }\n                else {\n                    JetReferenceExpression[] jetReferenceExpressions = PsiTreeUtil.getChildrenOfType(left, JetReferenceExpression.class);\n                    if (jetReferenceExpressions != null) {\n                        for (JetReferenceExpression expr : jetReferenceExpressions) {\n                            if (expr == expression) {\n                                operation = binaryExpression.getOperationToken();\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                JetUnaryExpression unaryExpression = PsiTreeUtil.getParentOfType(expression, JetUnaryExpression.class);\n                if (unaryExpression != null) {\n                    operation = unaryExpression.getOperationReference().getReferencedNameElementType();\n                }\n            }\n\n            if (operation != null && PROPERTY_SET_OPERATIONS.contains(operation)) {\n                checkPropertySetter(propertyDescriptor, expression);\n            }\n            else {\n                checkPropertyGetter(propertyDescriptor, expression);\n            }\n        }\n    }","id":93987,"modified_method":"private void checkPropertyDescriptor(\n            @NotNull JetExpression expression,\n            @NotNull PropertyDescriptor propertyDescriptor\n    ) {\n        // Deprecated for Property\n        if (reportAnnotationIfNeeded(expression, propertyDescriptor, propertyDescriptor.isVar())) {\n            return;\n        }\n\n        // Deprecated for Getter (val, var), Setter (var)\n        if (!propertyDescriptor.isVar()) {\n            checkPropertyGetter(propertyDescriptor, expression);\n        }\n        else {\n            IElementType operation = null;\n            JetBinaryExpression binaryExpression = PsiTreeUtil.getParentOfType(expression, JetBinaryExpression.class);\n            if (binaryExpression != null) {\n                JetExpression left = binaryExpression.getLeft();\n                if (left == expression) {\n                    operation = binaryExpression.getOperationToken();\n                }\n                else {\n                    JetReferenceExpression[] jetReferenceExpressions = PsiTreeUtil.getChildrenOfType(left, JetReferenceExpression.class);\n                    if (jetReferenceExpressions != null) {\n                        for (JetReferenceExpression expr : jetReferenceExpressions) {\n                            if (expr == expression) {\n                                operation = binaryExpression.getOperationToken();\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                JetUnaryExpression unaryExpression = PsiTreeUtil.getParentOfType(expression, JetUnaryExpression.class);\n                if (unaryExpression != null) {\n                    operation = unaryExpression.getOperationReference().getReferencedNameElementType();\n                }\n            }\n\n            if (operation != null && PROPERTY_SET_OPERATIONS.contains(operation)) {\n                checkPropertySetter(propertyDescriptor, expression);\n            }\n            else {\n                checkPropertyGetter(propertyDescriptor, expression);\n            }\n        }\n    }","commit_id":"5d2edc53b4ac80cba58ba91ec9de35834e37e276","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkPropertyAccessor(\n            @NotNull PropertyAccessorDescriptor accessor,\n            @NotNull JetExpression expression, boolean isVar\n    ) {\n        if (KotlinBuiltIns.getInstance().isDeprecated(accessor)) {\n            reportAnnotation(expression, accessor, isVar);\n        }\n    }","id":93988,"modified_method":"private void checkPropertyAccessor(\n            @NotNull PropertyAccessorDescriptor accessor,\n            @NotNull JetExpression expression, boolean isVar\n    ) {\n        reportAnnotationIfNeeded(expression, accessor, isVar);\n    }","commit_id":"5d2edc53b4ac80cba58ba91ec9de35834e37e276","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void visitReferenceExpression(JetReferenceExpression expression) {\n        super.visitReferenceExpression(expression);\n        ResolvedCall resolvedCall = bindingContext.get(BindingContext.RESOLVED_CALL, expression);\n        if (resolvedCall != null && resolvedCall instanceof VariableAsFunctionResolvedCall) {\n            // Deprecated for invoke()\n            JetCallExpression parent = PsiTreeUtil.getParentOfType(expression, JetCallExpression.class);\n            if (parent != null && KotlinBuiltIns.getInstance().isDeprecated(resolvedCall.getResultingDescriptor())) {\n                reportAnnotation(parent, resolvedCall.getResultingDescriptor(), true);\n            }\n        }\n        if (expression.getNode().getElementType() == JetNodeTypes.OPERATION_REFERENCE) {\n            // Deprecated for operations (mark as warning)\n            checkDeprecatedForOperations(expression);\n        }\n        else {\n            checkDeprecatedForReferenceExpression(expression);\n        }\n    }","id":93989,"modified_method":"@Override\n    public void visitReferenceExpression(JetReferenceExpression expression) {\n        super.visitReferenceExpression(expression);\n        ResolvedCall resolvedCall = bindingContext.get(BindingContext.RESOLVED_CALL, expression);\n        if (resolvedCall != null && resolvedCall instanceof VariableAsFunctionResolvedCall) {\n            // Deprecated for invoke()\n            JetCallExpression parent = PsiTreeUtil.getParentOfType(expression, JetCallExpression.class);\n            if (parent != null) {\n                reportAnnotationIfNeeded(parent, resolvedCall.getResultingDescriptor(), true);\n            }\n        }\n        if (expression.getNode().getElementType() == JetNodeTypes.OPERATION_REFERENCE) {\n            // Deprecated for operations (mark as warning)\n            checkDeprecatedForOperations(expression);\n        }\n        else {\n            checkDeprecatedForReferenceExpression(expression);\n        }\n    }","commit_id":"5d2edc53b4ac80cba58ba91ec9de35834e37e276","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void reportAnnotation(@NotNull PsiElement element, @NotNull DeclarationDescriptor descriptor, boolean isWarning) {\n        if (isWarning) {\n            holder.createInfoAnnotation(element, \"'\" + renderName(descriptor) + \"' is deprecated\")\n                    .setTextAttributes(CodeInsightColors.WARNINGS_ATTRIBUTES);\n        }\n        else {\n            holder.createInfoAnnotation(element, \"'\" + renderName(descriptor) + \"' is deprecated\")\n                    .setTextAttributes(CodeInsightColors.DEPRECATED_ATTRIBUTES);\n        }\n    }","id":93990,"modified_method":"private boolean reportAnnotationIfNeeded(@NotNull PsiElement element, @NotNull DeclarationDescriptor descriptor, boolean isWarning) {\n        AnnotationDescriptor deprecated = getDeprecated(descriptor);\n        if (deprecated != null) {\n            if (isWarning) {\n            holder.createInfoAnnotation(element, \"'\" + renderName(descriptor) + \"' is deprecated\")\n                        .setTextAttributes(CodeInsightColors.WARNINGS_ATTRIBUTES);\n            }\n            else {\n            holder.createInfoAnnotation(element, \"'\" + renderName(descriptor) + \"' is deprecated\")\n                        .setTextAttributes(CodeInsightColors.DEPRECATED_ATTRIBUTES);\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"5d2edc53b4ac80cba58ba91ec9de35834e37e276","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkDeprecatedForOperations(@NotNull JetReferenceExpression expression) {\n        DeclarationDescriptor target = bindingContext.get(BindingContext.REFERENCE_TARGET, expression);\n        if (target != null) {\n            if (KotlinBuiltIns.getInstance().isDeprecated(target)) {\n                reportAnnotation(expression, target, true);\n            }\n        }\n    }","id":93991,"modified_method":"private void checkDeprecatedForOperations(@NotNull JetReferenceExpression expression) {\n        DeclarationDescriptor target = bindingContext.get(BindingContext.REFERENCE_TARGET, expression);\n        if (target != null) {\n            reportAnnotationIfNeeded(expression, target, true);\n        }\n    }","commit_id":"5d2edc53b4ac80cba58ba91ec9de35834e37e276","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkConstructorDescriptor(@NotNull JetExpression expression, @NotNull DeclarationDescriptor target) {\n        // Deprecated for Class and for Constructor\n        DeclarationDescriptor containingDeclaration = target.getContainingDeclaration();\n        if (containingDeclaration != null) {\n            if (KotlinBuiltIns.getInstance().isDeprecated(containingDeclaration) || KotlinBuiltIns.getInstance().isDeprecated(target)) {\n                reportAnnotation(expression, containingDeclaration);\n            }\n        }\n    }","id":93992,"modified_method":"private void checkConstructorDescriptor(@NotNull JetExpression expression, @NotNull DeclarationDescriptor target) {\n        // Deprecated for Class and for Constructor\n        DeclarationDescriptor containingDeclaration = target.getContainingDeclaration();\n        if (containingDeclaration != null) {\n            if (!reportAnnotationIfNeeded(expression, containingDeclaration)) {\n                reportAnnotationIfNeeded(expression, target);\n            }\n        }\n    }","commit_id":"5d2edc53b4ac80cba58ba91ec9de35834e37e276","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkFunctionDescriptor(JetExpression expression, DeclarationDescriptor target) {\n        // Deprecated for Function\n        if (KotlinBuiltIns.getInstance().isDeprecated(target)) {\n            reportAnnotation(expression, target, expression instanceof JetArrayAccessExpression);\n        }\n    }","id":93993,"modified_method":"private void checkFunctionDescriptor(JetExpression expression, DeclarationDescriptor target) {\n        // Deprecated for Function\n        reportAnnotationIfNeeded(expression, target, expression instanceof JetArrayAccessExpression);\n    }","commit_id":"5d2edc53b4ac80cba58ba91ec9de35834e37e276","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkClassDescriptor(@NotNull JetExpression expression, @NotNull ClassDescriptor target) {\n        // Deprecated for Class, for ClassObject (if reference isn't in UserType or in ModifierList (trait))\n        if (KotlinBuiltIns.getInstance().isDeprecated(target)) {\n            reportAnnotation(expression, target);\n        }\n        else if (PsiTreeUtil.getParentOfType(expression, JetUserType.class) == null &&\n                 PsiTreeUtil.getParentOfType(expression, JetModifierList.class) == null) {\n            ClassDescriptor classObjectDescriptor = target.getClassObjectDescriptor();\n            if (classObjectDescriptor != null && KotlinBuiltIns.getInstance().isDeprecated(classObjectDescriptor)) {\n                reportAnnotation(expression, classObjectDescriptor);\n            }\n        }\n    }","id":93994,"modified_method":"private void checkClassDescriptor(@NotNull JetExpression expression, @NotNull ClassDescriptor target) {\n        // Deprecated for Class, for ClassObject (if reference isn't in UserType or in ModifierList (trait))\n        if (!reportAnnotationIfNeeded(expression, target)) {\n            if (PsiTreeUtil.getParentOfType(expression, JetUserType.class) == null &&\n                PsiTreeUtil.getParentOfType(expression, JetModifierList.class) == null) {\n                ClassDescriptor classObjectDescriptor = target.getClassObjectDescriptor();\n                if (classObjectDescriptor != null) {\n                    reportAnnotationIfNeeded(expression, classObjectDescriptor);\n                }\n            }\n        }\n    }","commit_id":"5d2edc53b4ac80cba58ba91ec9de35834e37e276","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private boolean pollCanDelete(Poll poll) {\n        if (securityService.isSuperUser() || this.isSiteOwner())\n            return true;\n        if (securityService.unlock(PERMISSION_DELETE_ANY, \"/site/\"\n                + toolManager.getCurrentPlacement().getContext()))\n            return true;\n\n        if (securityService.unlock(PERMISSION_DELETE_OWN, \"/site/\"\n                + toolManager.getCurrentPlacement().getContext())\n                && poll.getOwner().equals(UserDirectoryService.getCurrentUser().getId()))\n            return true;\n\n        return false;\n    }","id":93995,"modified_method":"private boolean pollCanDelete(Poll poll) {\n        if (externalLogic.isUserAdmin() || this.isSiteOwner())\n            return true;\n        if (externalLogic.isAllowedInLocation(PERMISSION_DELETE_ANY, externalLogic.getCurrentLocationReference()))\n            return true;\n\n        if (externalLogic.isAllowedInLocation(PERMISSION_DELETE_OWN, externalLogic.getCurrentLocationReference())\n        \t\t&& poll.getOwner().equals(externalLogic.getCurrentUserId()))\n            return true;\n\n        return false;\n    }","commit_id":"9a502b93319ae0b6be2f81bc963bd3bda7e3a4f7","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void init() {\n        try {\n            entityManager.registerEntityProducer(this, REFERENCE_ROOT);\n        } catch (Throwable t) {\n            log.warn(\"init(): \", t);\n        }\n\n        functionManager.registerFunction(PERMISSION_VOTE);\n        functionManager.registerFunction(PERMISSION_ADD);\n        functionManager.registerFunction(PERMISSION_DELETE_OWN);\n        functionManager.registerFunction(PERMISSION_DELETE_ANY);\n        functionManager.registerFunction(PERMISSION_EDIT_ANY);\n        functionManager.registerFunction(PERMISSION_EDIT_OWN);\n        log.info(this + \" init()\");\n\n    }","id":93996,"modified_method":"public void init() {\n        try {\n            entityManager.registerEntityProducer(this, REFERENCE_ROOT);\n        } catch (Throwable t) {\n            log.warn(\"init(): \", t);\n        }\n\n        externalLogic.registerFunction(PERMISSION_VOTE);\n        externalLogic.registerFunction(PERMISSION_ADD);\n        externalLogic.registerFunction(PERMISSION_DELETE_OWN);\n        externalLogic.registerFunction(PERMISSION_DELETE_ANY);\n        externalLogic.registerFunction(PERMISSION_EDIT_ANY);\n        externalLogic.registerFunction(PERMISSION_EDIT_OWN);\n        log.info(this + \" init()\");\n\n    }","commit_id":"9a502b93319ae0b6be2f81bc963bd3bda7e3a4f7","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean deletePoll(Poll t) throws PermissionException {\n        if (!pollCanDelete(t))\n            throw new PermissionException(UserDirectoryService.getCurrentUser().getId(),\n                    \"poll.delete\", \"poll.\" + t.getId());\n\n        try {\n            dao.delete(t);\n        } catch (DataAccessException e) {\n            log.error(\"Hibernate could not delete: \" + e.toString());\n            e.printStackTrace();\n            return false;\n        }\n        log.info(\"Poll id \" + t.getId() + \" deleted\");\n        eventTrackingService.post(eventTrackingService.newEvent(\"poll.delete\", \"poll/site/\"\n                + t.getSiteId() + \"/poll/\" + t.getId(), true));\n        return true;\n    }","id":93997,"modified_method":"public boolean deletePoll(Poll t) throws PermissionException {\n    \tif (t == null)\n    \t\tthrow new NullPointerException(\"Poll can't be null\");\n    \t\n        if (!pollCanDelete(t))\n            throw new PermissionException(externalLogic.getCurrentUserId(),\n                    \"poll.delete\", \"poll.\" + t.getId());\n\n       \n            dao.delete(t);\n        \n        log.info(\"Poll id \" + t.getId() + \" deleted\");\n        externalLogic.postEvent(\"poll.delete\", \"poll/site/\"\n                + t.getSiteId() + \"/poll/\" + t.getId(), true);\n        return true;\n    }","commit_id":"9a502b93319ae0b6be2f81bc963bd3bda7e3a4f7","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean savePoll(Poll t) {\n        boolean newPoll = false;\n        if (t.getId() == null) {\n            newPoll = true;\n            t.setId(idManager.createUuid());\n        }\n\n        // we may need to truncate the description field\n        if (t.getDetails().length() > 254)\n            t.setDetails(t.getDetails().substring(0, 254));\n\n        try {\n            dao.save(t);\n\n        } catch (DataAccessException e) {\n            log.error(\"Hibernate could not save: \" + e.toString());\n            e.printStackTrace();\n            return false;\n        }\n        log.debug(\" Poll  \" + t.toString() + \"successfuly saved\");\n        if (newPoll)\n\n            eventTrackingService.post(eventTrackingService.newEvent(\"poll.add\", \"poll/site/\"\n                    + t.getSiteId() + \"/poll/\" + t.getId(), true));\n        else\n            eventTrackingService.post(eventTrackingService.newEvent(\"poll.update\", \"poll/site/\"\n                    + t.getSiteId() + \" /poll/\" + t.getId(), true));\n\n        return true;\n    }","id":93998,"modified_method":"public boolean savePoll(Poll t) {\n        boolean newPoll = false;\n        if (t.getId() == null) {\n            newPoll = true;\n            t.setId(idManager.createUuid());\n        }\n\n        // we may need to truncate the description field\n        if (t.getDetails().length() > 254)\n            t.setDetails(t.getDetails().substring(0, 254));\n\n        try {\n            dao.save(t);\n\n        } catch (DataAccessException e) {\n            log.error(\"Hibernate could not save: \" + e.toString());\n            e.printStackTrace();\n            return false;\n        }\n        log.debug(\" Poll  \" + t.toString() + \"successfuly saved\");\n        if (newPoll)\n        \texternalLogic.postEvent(\"poll.add\", \"poll/site/\"\n                    + t.getSiteId() + \"/poll/\" + t.getId(), true);\n        else\n        \texternalLogic.postEvent(\"poll.update\", \"poll/site/\"\n                    + t.getSiteId() + \" /poll/\" + t.getId(), true);\n\n        return true;\n    }","commit_id":"9a502b93319ae0b6be2f81bc963bd3bda7e3a4f7","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public List<Poll> findAllPollsForUserAndSitesAndPermission(String userId, String[] siteIds,\n            String permissionConstant) {\n        if (userId == null || permissionConstant == null) {\n            throw new IllegalArgumentException(\"userId and permissionConstant must be set\");\n        }\n        List<Poll> polls = null;\n        // get all allowed sites for this user\n        List<String> allowedSites = getSitesForUser(userId, permissionConstant);\n        if (! allowedSites.isEmpty()) {\n            if (siteIds != null) {\n                if (siteIds.length > 0) {\n                    // filter down to just the requested ones\n                    for (int j = 0; j < allowedSites.size(); j++) {\n                        String siteId = allowedSites.get(j);\n                        boolean found = false;\n                        for (int i = 0; i < siteIds.length; i++) {\n                            if (siteId.equals(siteIds[i])) {\n                                found = true;\n                            }\n                        }\n                        if (!found) {\n                            allowedSites.remove(j);\n                        }\n                    }\n                } else {\n                    // no sites to search so EXIT here\n                    return new ArrayList<Poll>();\n                }\n            }\n            String[] siteIdsToSearch = allowedSites.toArray(new String[allowedSites.size()]);\n            Search search = new Search();\n            if (siteIdsToSearch.length > 0) {\n                search.addRestriction(new Restriction(\"siteId\", siteIdsToSearch));\n            }\n            if (PollListManager.PERMISSION_VOTE.equals(permissionConstant)) {\n                // limit to polls which are open\n                Date now = new Date();\n                search.addRestriction(new Restriction(\"voteOpen\", now));\n                search.addRestriction(new Restriction(\"voteClose\", now));\n            } else {\n                // show all polls\n            }\n            search.addOrder(new Order(\"creationDate\"));\n            polls = dao.findBySearch(Poll.class, search);\n        }\n        if (polls == null) {\n            polls = new ArrayList<Poll>();\n        }\n        return polls;\n    }","id":93999,"modified_method":"public List<Poll> findAllPollsForUserAndSitesAndPermission(String userId, String[] siteIds,\n            String permissionConstant) {\n        if (userId == null || permissionConstant == null) {\n            throw new IllegalArgumentException(\"userId and permissionConstant must be set\");\n        }\n        List<Poll> polls = null;\n        // get all allowed sites for this user\n        List<String> allowedSites = externalLogic.getSitesForUser(userId, permissionConstant);\n        if (! allowedSites.isEmpty()) {\n            if (siteIds != null) {\n                if (siteIds.length > 0) {\n                    // filter down to just the requested ones\n                    for (int j = 0; j < allowedSites.size(); j++) {\n                        String siteId = allowedSites.get(j);\n                        boolean found = false;\n                        for (int i = 0; i < siteIds.length; i++) {\n                            if (siteId.equals(siteIds[i])) {\n                                found = true;\n                            }\n                        }\n                        if (!found) {\n                            allowedSites.remove(j);\n                        }\n                    }\n                } else {\n                    // no sites to search so EXIT here\n                    return new ArrayList<Poll>();\n                }\n            }\n            String[] siteIdsToSearch = allowedSites.toArray(new String[allowedSites.size()]);\n            Search search = new Search();\n            if (siteIdsToSearch.length > 0) {\n                search.addRestriction(new Restriction(\"siteId\", siteIdsToSearch));\n            }\n            if (PollListManager.PERMISSION_VOTE.equals(permissionConstant)) {\n                // limit to polls which are open\n                Date now = new Date();\n                search.addRestriction(new Restriction(\"voteOpen\", now));\n                search.addRestriction(new Restriction(\"voteClose\", now));\n            } else {\n                // show all polls\n            }\n            search.addOrder(new Order(\"creationDate\"));\n            polls = dao.findBySearch(Poll.class, search);\n        }\n        if (polls == null) {\n            polls = new ArrayList<Poll>();\n        }\n        return polls;\n    }","commit_id":"9a502b93319ae0b6be2f81bc963bd3bda7e3a4f7","url":"https://github.com/sakaiproject/sakai"}]