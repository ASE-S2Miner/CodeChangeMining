[{"original_method":"@Test\n    public void shouldReturnAvailableAndAliveSlaves() throws Throwable\n    {\n        // given\n        Cluster cluster = mock( Cluster.class);\n        ClusterMembers clusterMembers = mock( ClusterMembers.class);\n        when( clusterMembers.getMembers() ).thenReturn( iterable(new ClusterMember(clusterUri1).availableAs( HighAvailabilityModeSwitcher.SLAVE,haUri1 )) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n        when( slaveFactory.newSlave( (ClusterMember)any() ) ).thenReturn( mock(Slave.class));\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory);\n        slaves.init();\n\n        // when\n        Iterable<Slave> memberSlaves = slaves.getSlaves();\n\n        // then\n        Assert.assertThat( count( memberSlaves ), CoreMatchers.equalTo( 1L ));\n    }","id":25000,"modified_method":"@Test\n    public void shouldReturnAvailableAndAliveSlaves() throws Throwable\n    {\n        // given\n        Cluster cluster = mock( Cluster.class);\n        ClusterMembers clusterMembers = mock( ClusterMembers.class);\n        when( clusterMembers.getMembers() ).thenReturn( Iterables.<ClusterMember,ClusterMember>iterable(new ClusterMember(clusterUri1).availableAs(HighAvailabilityModeSwitcher.SLAVE, haUri1)) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n        when( slaveFactory.newSlave( (ClusterMember)any() ) ).thenReturn( mock(Slave.class));\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory);\n        slaves.init();\n\n        // when\n        Iterable<Slave> memberSlaves = slaves.getSlaves();\n\n        // then\n        Assert.assertThat( count( memberSlaves ), CoreMatchers.equalTo( 1L ));\n    }","commit_id":"f29a3e9f642d75976a70c73f67b52823dda3e651","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotReturnUnavailableSlaves() throws Throwable\n    {\n        // given\n        Cluster cluster = mock( Cluster.class);\n        ClusterMembers clusterMembers = mock( ClusterMembers.class);\n        when( clusterMembers.getMembers() ).thenReturn( iterable(new ClusterMember(clusterUri1)) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory);\n        slaves.init();\n\n        // when\n        Iterable<Slave> memberSlaves = slaves.getSlaves();\n\n        // then\n        Assert.assertThat( count( memberSlaves ), CoreMatchers.equalTo( 0L ));\n    }","id":25001,"modified_method":"@Test\n    public void shouldNotReturnUnavailableSlaves() throws Throwable\n    {\n        // given\n        Cluster cluster = mock( Cluster.class);\n        ClusterMembers clusterMembers = mock( ClusterMembers.class);\n        when( clusterMembers.getMembers() ).thenReturn( Iterables.<ClusterMember,ClusterMember>iterable(new ClusterMember(clusterUri1)) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory);\n        slaves.init();\n\n        // when\n        Iterable<Slave> memberSlaves = slaves.getSlaves();\n\n        // then\n        Assert.assertThat( count( memberSlaves ), CoreMatchers.equalTo( 0L ));\n    }","commit_id":"f29a3e9f642d75976a70c73f67b52823dda3e651","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldClearSlavesWhenNewMasterElected() throws Throwable\n    {\n        // given\n        Cluster cluster = mock( Cluster.class );\n        ClusterMembers clusterMembers = mock( ClusterMembers.class);\n        when( clusterMembers.getMembers() ).thenReturn( iterable(new ClusterMember(clusterUri1).availableAs( HighAvailabilityModeSwitcher.SLAVE, haUri1 )) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n        when( slaveFactory.newSlave( (ClusterMember)any() ) ).thenReturn( mock(Slave.class), mock(Slave.class) );\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory);\n        slaves.init();\n\n        ArgumentCaptor<ClusterListener> listener = ArgumentCaptor.forClass( ClusterListener.class );\n        verify( cluster ).addClusterListener( listener.capture() );\n\n        // when\n        Slave slave1 = slaves.getSlaves().iterator().next();\n\n        listener.getValue().elected( ClusterConfiguration.COORDINATOR, clusterUri2 );\n\n        Slave slave2 = slaves.getSlaves().iterator().next();\n\n        // then\n        Assert.assertThat( slave2, not( sameInstance( slave1 ) ));\n    }","id":25002,"modified_method":"@Test\n    public void shouldClearSlavesWhenNewMasterElected() throws Throwable\n    {\n        // given\n        Cluster cluster = mock( Cluster.class );\n        ClusterMembers clusterMembers = mock( ClusterMembers.class);\n        when( clusterMembers.getMembers() ).thenReturn( Iterables.<ClusterMember,ClusterMember>iterable(new ClusterMember(clusterUri1).availableAs(HighAvailabilityModeSwitcher.SLAVE, haUri1)) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n        when( slaveFactory.newSlave( (ClusterMember)any() ) ).thenReturn( mock(Slave.class), mock(Slave.class) );\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory);\n        slaves.init();\n\n        ArgumentCaptor<ClusterListener> listener = ArgumentCaptor.forClass( ClusterListener.class );\n        verify( cluster ).addClusterListener( listener.capture() );\n\n        // when\n        Slave slave1 = slaves.getSlaves().iterator().next();\n\n        listener.getValue().elected( ClusterConfiguration.COORDINATOR, clusterUri2 );\n\n        Slave slave2 = slaves.getSlaves().iterator().next();\n\n        // then\n        Assert.assertThat( slave2, not( sameInstance( slave1 ) ));\n    }","commit_id":"f29a3e9f642d75976a70c73f67b52823dda3e651","url":"https://github.com/neo4j/neo4j"},{"original_method":"public HighlyAvailableGraphDatabase( String storeDir, Map<String, String> params,\n                                         List<IndexProvider> indexProviders, List<KernelExtensionFactory<?>>\n            kernelExtensions,\n                                         List<CacheProvider> cacheProviders, List<TransactionInterceptorProvider>\n            txInterceptorProviders )\n    {\n        super( storeDir, params, iterable( GraphDatabaseSettings.class, HaSettings.class,\n                NetworkInstance.Configuration.class, ClusterSettings.class ), indexProviders, kernelExtensions,\n                cacheProviders,\n                txInterceptorProviders );\n        run();\n    }","id":25003,"modified_method":"public HighlyAvailableGraphDatabase( String storeDir, Map<String, String> params,\n                                         List<IndexProvider> indexProviders, List<KernelExtensionFactory<?>>\n            kernelExtensions,\n                                         List<CacheProvider> cacheProviders, List<TransactionInterceptorProvider>\n            txInterceptorProviders )\n    {\n        super( storeDir, params, Iterables.<Class<?>,Class<?>>iterable( GraphDatabaseSettings.class, HaSettings.class,\n                NetworkInstance.Configuration.class, ClusterSettings.class ), indexProviders, kernelExtensions,\n                cacheProviders,\n                txInterceptorProviders );\n        run();\n    }","commit_id":"f29a3e9f642d75976a70c73f67b52823dda3e651","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldHaveSensibleDefaultJettyThreadPoolSize() throws Exception\n    {\n    \tJetty6WebServer server = new Jetty6WebServer();\n        server.setPort( 7480 );\n    \ttry {\n\t        server.start();\n\t        QueuedThreadPool threadPool = (QueuedThreadPool) server.getJetty()\n\t                .getThreadPool();\n\t        threadPool.start();\n\t        loadThreadPool( threadPool );\n\t        assertEquals( 10 * Runtime.getRuntime()\n\t                .availableProcessors(), threadPool.getThreads() );\n\t    } finally \n\t    {\n\t    \tserver.stop();\n\t    }\n    }","id":25004,"modified_method":"@Test\n    public void shouldHaveSensibleDefaultJettyThreadPoolSize() throws Exception\n    {\n    \tJetty6WebServer server = new Jetty6WebServer();\n        server.setPort( 7480 );\n    \ttry {\n\t        server.start();\n\t        QueuedThreadPool threadPool = (QueuedThreadPool) server.getJetty()\n\t                .getThreadPool();\n\t        threadPool.start();\n            int configuredMaxThreads = 10 * Runtime.getRuntime().availableProcessors();\n            loadThreadPool( threadPool, configuredMaxThreads + 1 );\n            assertEquals(configuredMaxThreads, threadPool.getThreads() );\n\t    } finally \n\t    {\n\t    \tserver.stop();\n\t    }\n    }","commit_id":"f29a3e9f642d75976a70c73f67b52823dda3e651","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldHaveConfigurableJettyThreadPoolSize() throws Exception\n    {\n    \tJetty6WebServer server = new Jetty6WebServer();\n        final int maxThreads = 7;\n        server.setMaxThreads( maxThreads );\n        server.setPort( 7480 );\n        try {\n\t        server.start();\n\t        QueuedThreadPool threadPool = (QueuedThreadPool) server.getJetty()\n\t                .getThreadPool();\n\t        threadPool.start();\n\t        loadThreadPool( threadPool );\n\t        int threads = threadPool.getThreads();\n\t        assertTrue( threads <= maxThreads );\n        } finally \n        {\n        \tserver.stop();\n        }\n    }","id":25005,"modified_method":"@Test\n    public void shouldHaveConfigurableJettyThreadPoolSize() throws Exception\n    {\n    \tJetty6WebServer server = new Jetty6WebServer();\n        final int maxThreads = 7;\n        server.setMaxThreads( maxThreads );\n        server.setPort( 7480 );\n        try {\n\t        server.start();\n\t        QueuedThreadPool threadPool = (QueuedThreadPool) server.getJetty()\n\t                .getThreadPool();\n\t        threadPool.start();\n            int configuredMaxThreads = maxThreads * Runtime.getRuntime().availableProcessors();\n            loadThreadPool( threadPool, configuredMaxThreads + 1);\n\t        int threads = threadPool.getThreads();\n\t        assertTrue( threads <= maxThreads );\n        } finally \n        {\n        \tserver.stop();\n        }\n    }","commit_id":"f29a3e9f642d75976a70c73f67b52823dda3e651","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void loadThreadPool( QueuedThreadPool threadPool )\n    {\n        final CyclicBarrier cb = new CyclicBarrier( 100 );\n        for ( int i = 0; i < 100; i++ )\n        {\n            threadPool.dispatch( new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        cb.await();\n                    }\n                    catch ( InterruptedException e )\n                    {\n                    }\n                    catch ( BrokenBarrierException e )\n                    {\n                    }\n                }\n            } );\n        }\n    }","id":25006,"modified_method":"private void loadThreadPool(QueuedThreadPool threadPool, int tasksToSubmit)\n    {\n        final CyclicBarrier cb = new CyclicBarrier(tasksToSubmit);\n        for ( int i = 0; i < tasksToSubmit; i++ )\n        {\n            threadPool.dispatch( new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        cb.await();\n                    }\n                    catch ( InterruptedException e )\n                    {\n                    }\n                    catch ( BrokenBarrierException e )\n                    {\n                    }\n                }\n            } );\n        }\n    }","commit_id":"f29a3e9f642d75976a70c73f67b52823dda3e651","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public ProtocolServer newProtocolServer( TimeoutStrategy timeoutStrategy, MessageSource input,\n                                             MessageProcessor output,\n                                             AcceptorInstanceStore acceptorInstanceStore,\n                                             ElectionCredentialsProvider electionCredentialsProvider )\n    {\n        LatencyCalculator latencyCalculator = new LatencyCalculator( timeoutStrategy, input );\n\n        DelayedDirectExecutor executor = new DelayedDirectExecutor();\n\n        // Create state machines\n        ConnectedStateMachines connectedStateMachines = new ConnectedStateMachines( input, output, latencyCalculator,\n                executor );\n        Timeouts timeouts = connectedStateMachines.getTimeouts();\n        connectedStateMachines.addMessageProcessor( latencyCalculator );\n\n        AcceptorContext acceptorContext = new AcceptorContext( logging, acceptorInstanceStore );\n        LearnerContext learnerContext = new LearnerContext();\n        ProposerContext proposerContext = new ProposerContext();\n        final ClusterContext clusterContext = new ClusterContext( proposerContext, learnerContext,\n                new ClusterConfiguration( initialConfig.getName(), initialConfig.getMembers() ), timeouts, executor,\n                logging );\n        final HeartbeatContext heartbeatContext = new HeartbeatContext( clusterContext, learnerContext, executor );\n        final MultiPaxosContext context = new MultiPaxosContext( clusterContext, proposerContext, learnerContext,\n                heartbeatContext, timeouts );\n        ElectionContext electionContext = new ElectionContext( Iterables.iterable( new ElectionRole(\n                ClusterConfiguration.COORDINATOR ) ),\n                clusterContext, heartbeatContext );\n        SnapshotContext snapshotContext = new SnapshotContext( clusterContext, learnerContext );\n        AtomicBroadcastContext atomicBroadcastContext = new AtomicBroadcastContext( clusterContext, executor );\n\n        connectedStateMachines.addStateMachine( new StateMachine( atomicBroadcastContext,\n                AtomicBroadcastMessage.class, AtomicBroadcastState.start ) );\n        connectedStateMachines.addStateMachine( new StateMachine( acceptorContext, AcceptorMessage.class,\n                AcceptorState.start ) );\n        connectedStateMachines.addStateMachine( new StateMachine( context, ProposerMessage.class,\n                ProposerState.start ) );\n        connectedStateMachines.addStateMachine( new StateMachine( context, LearnerMessage.class, LearnerState.start ) );\n        connectedStateMachines.addStateMachine( new StateMachine( heartbeatContext, HeartbeatMessage.class,\n                HeartbeatState.start ) );\n        connectedStateMachines.addStateMachine( new StateMachine( electionContext, ElectionMessage.class,\n                ElectionState.start ) );\n        connectedStateMachines.addStateMachine( new StateMachine( snapshotContext, SnapshotMessage.class,\n                SnapshotState.start ) );\n        connectedStateMachines.addStateMachine( new StateMachine( clusterContext, ClusterMessage.class,\n                ClusterState.start ) );\n\n        final ProtocolServer server = new ProtocolServer( connectedStateMachines, logging.getLogger( ProtocolServer\n        .class ) );\n\n        server.addBindingListener( new BindingListener()\n        {\n            @Override\n            public void listeningAt( URI me )\n            {\n                clusterContext.setMe( me );\n            }\n        } );\n\n        connectedStateMachines.addMessageProcessor( new HeartbeatRefreshProcessor( connectedStateMachines.getOutgoing\n                () ) );\n        input.addMessageProcessor( new HeartbeatIAmAliveProcessor( connectedStateMachines.getOutgoing() ) );\n\n        server.newClient( Cluster.class ).addClusterListener( new HeartbeatJoinListener( connectedStateMachines\n                .getOutgoing() ) );\n\n        heartbeatContext.addHeartbeatListener( new HeartbeatFailedReelectionListener( server.newClient( Election\n                .class ) ) );\n        clusterContext.addClusterListener( new ClusterLeaveReelectionListener( server.newClient( Election.class ) ) );\n        electionContext.setElectionCredentialsProvider( electionCredentialsProvider );\n\n        StateMachineRules rules = new StateMachineRules( connectedStateMachines.getOutgoing() )\n                .rule( ClusterState.start, ClusterMessage.create, ClusterState.entered,\n                        internal( AtomicBroadcastMessage.entered ),\n                        internal( ProposerMessage.join ),\n                        internal( AcceptorMessage.join ),\n                        internal( LearnerMessage.join ),\n                        internal( HeartbeatMessage.join ),\n                        internal( ElectionMessage.created ),\n                        internal( SnapshotMessage.join ) )\n\n                .rule( ClusterState.acquiringConfiguration, ClusterMessage.configurationResponse, ClusterState.joining,\n                        internal( AcceptorMessage.join ),\n                        internal( LearnerMessage.join ),\n                        internal( AtomicBroadcastMessage.join ) )\n\n                .rule( ClusterState.acquiringConfiguration, ClusterMessage.configurationResponse, ClusterState.entered,\n                        internal( AtomicBroadcastMessage.entered ),\n                        internal( ProposerMessage.join ),\n                        internal( AcceptorMessage.join ),\n                        internal( LearnerMessage.join ),\n                        internal( HeartbeatMessage.join ),\n                        internal( ElectionMessage.join ),\n                        internal( SnapshotMessage.join ) )\n\n                .rule( ClusterState.joining, ClusterMessage.configurationChanged, ClusterState.entered,\n                        internal( AtomicBroadcastMessage.entered ),\n                        internal( ProposerMessage.join ),\n                        internal( AcceptorMessage.join ),\n                        internal( LearnerMessage.join ),\n                        internal( HeartbeatMessage.join ),\n                        internal( ElectionMessage.join ),\n                        internal( SnapshotMessage.join ) )\n\n                .rule( ClusterState.joining, ClusterMessage.joinFailure, ClusterState.start,\n                        internal( AtomicBroadcastMessage.leave ),\n                        internal( AcceptorMessage.leave ),\n                        internal( LearnerMessage.leave ),\n                        internal( ProposerMessage.leave ) )\n\n                .rule( ClusterState.entered, ClusterMessage.leave, ClusterState.start,\n                        internal( AtomicBroadcastMessage.leave ),\n                        internal( AcceptorMessage.leave ),\n                        internal( LearnerMessage.leave ),\n                        internal( HeartbeatMessage.leave ),\n                        internal( SnapshotMessage.leave ),\n                        internal( ElectionMessage.leave ),\n                        internal( ProposerMessage.leave ) )\n\n                .rule( ClusterState.entered, ClusterMessage.leave, ClusterState.start,\n                        internal( AtomicBroadcastMessage.leave ),\n                        internal( AcceptorMessage.leave ),\n                        internal( LearnerMessage.leave ),\n                        internal( HeartbeatMessage.leave ),\n                        internal( ElectionMessage.leave ),\n                        internal( SnapshotMessage.leave ),\n                        internal( ProposerMessage.leave ) )\n\n                .rule( ClusterState.leaving, ClusterMessage.configurationChanged, ClusterState.start,\n                        internal( AtomicBroadcastMessage.leave ),\n                        internal( AcceptorMessage.leave ),\n                        internal( LearnerMessage.leave ),\n                        internal( HeartbeatMessage.leave ),\n                        internal( ElectionMessage.leave ),\n                        internal( SnapshotMessage.leave ),\n                        internal( ProposerMessage.leave ) )\n\n                .rule( ClusterState.leaving, ClusterMessage.leaveTimedout, ClusterState.start,\n                        internal( AtomicBroadcastMessage.leave ),\n                        internal( AcceptorMessage.leave ),\n                        internal( LearnerMessage.leave ),\n                        internal( HeartbeatMessage.leave ),\n                        internal( ElectionMessage.leave ),\n                        internal( SnapshotMessage.leave ),\n                        internal( ProposerMessage.leave ) );\n\n\n        connectedStateMachines.addStateTransitionListener( rules );\n\n        return server;\n    }","id":25007,"modified_method":"@Override\n    public ProtocolServer newProtocolServer( TimeoutStrategy timeoutStrategy, MessageSource input,\n                                             MessageProcessor output,\n                                             AcceptorInstanceStore acceptorInstanceStore,\n                                             ElectionCredentialsProvider electionCredentialsProvider )\n    {\n        LatencyCalculator latencyCalculator = new LatencyCalculator( timeoutStrategy, input );\n\n        DelayedDirectExecutor executor = new DelayedDirectExecutor();\n\n        // Create state machines\n        ConnectedStateMachines connectedStateMachines = new ConnectedStateMachines( input, output, latencyCalculator,\n                executor );\n        Timeouts timeouts = connectedStateMachines.getTimeouts();\n        connectedStateMachines.addMessageProcessor( latencyCalculator );\n\n        AcceptorContext acceptorContext = new AcceptorContext( logging, acceptorInstanceStore );\n        LearnerContext learnerContext = new LearnerContext();\n        ProposerContext proposerContext = new ProposerContext();\n        final ClusterContext clusterContext = new ClusterContext( proposerContext, learnerContext,\n                new ClusterConfiguration( initialConfig.getName(), initialConfig.getMembers() ), timeouts, executor,\n                logging );\n        final HeartbeatContext heartbeatContext = new HeartbeatContext( clusterContext, learnerContext, executor );\n        final MultiPaxosContext context = new MultiPaxosContext( clusterContext, proposerContext, learnerContext,\n                heartbeatContext, timeouts );\n        ElectionContext electionContext = new ElectionContext( Iterables.<ElectionRole,ElectionRole>iterable( new ElectionRole(\n                ClusterConfiguration.COORDINATOR ) ),\n                clusterContext, heartbeatContext );\n        SnapshotContext snapshotContext = new SnapshotContext( clusterContext, learnerContext );\n        AtomicBroadcastContext atomicBroadcastContext = new AtomicBroadcastContext( clusterContext, executor );\n\n        connectedStateMachines.addStateMachine( new StateMachine( atomicBroadcastContext,\n                AtomicBroadcastMessage.class, AtomicBroadcastState.start ) );\n        connectedStateMachines.addStateMachine( new StateMachine( acceptorContext, AcceptorMessage.class,\n                AcceptorState.start ) );\n        connectedStateMachines.addStateMachine( new StateMachine( context, ProposerMessage.class,\n                ProposerState.start ) );\n        connectedStateMachines.addStateMachine( new StateMachine( context, LearnerMessage.class, LearnerState.start ) );\n        connectedStateMachines.addStateMachine( new StateMachine( heartbeatContext, HeartbeatMessage.class,\n                HeartbeatState.start ) );\n        connectedStateMachines.addStateMachine( new StateMachine( electionContext, ElectionMessage.class,\n                ElectionState.start ) );\n        connectedStateMachines.addStateMachine( new StateMachine( snapshotContext, SnapshotMessage.class,\n                SnapshotState.start ) );\n        connectedStateMachines.addStateMachine( new StateMachine( clusterContext, ClusterMessage.class,\n                ClusterState.start ) );\n\n        final ProtocolServer server = new ProtocolServer( connectedStateMachines, logging.getLogger( ProtocolServer\n        .class ) );\n\n        server.addBindingListener( new BindingListener()\n        {\n            @Override\n            public void listeningAt( URI me )\n            {\n                clusterContext.setMe( me );\n            }\n        } );\n\n        connectedStateMachines.addMessageProcessor( new HeartbeatRefreshProcessor( connectedStateMachines.getOutgoing\n                () ) );\n        input.addMessageProcessor( new HeartbeatIAmAliveProcessor( connectedStateMachines.getOutgoing() ) );\n\n        server.newClient( Cluster.class ).addClusterListener( new HeartbeatJoinListener( connectedStateMachines\n                .getOutgoing() ) );\n\n        heartbeatContext.addHeartbeatListener( new HeartbeatFailedReelectionListener( server.newClient( Election\n                .class ) ) );\n        clusterContext.addClusterListener( new ClusterLeaveReelectionListener( server.newClient( Election.class ) ) );\n        electionContext.setElectionCredentialsProvider( electionCredentialsProvider );\n\n        StateMachineRules rules = new StateMachineRules( connectedStateMachines.getOutgoing() )\n                .rule( ClusterState.start, ClusterMessage.create, ClusterState.entered,\n                        internal( AtomicBroadcastMessage.entered ),\n                        internal( ProposerMessage.join ),\n                        internal( AcceptorMessage.join ),\n                        internal( LearnerMessage.join ),\n                        internal( HeartbeatMessage.join ),\n                        internal( ElectionMessage.created ),\n                        internal( SnapshotMessage.join ) )\n\n                .rule( ClusterState.acquiringConfiguration, ClusterMessage.configurationResponse, ClusterState.joining,\n                        internal( AcceptorMessage.join ),\n                        internal( LearnerMessage.join ),\n                        internal( AtomicBroadcastMessage.join ) )\n\n                .rule( ClusterState.acquiringConfiguration, ClusterMessage.configurationResponse, ClusterState.entered,\n                        internal( AtomicBroadcastMessage.entered ),\n                        internal( ProposerMessage.join ),\n                        internal( AcceptorMessage.join ),\n                        internal( LearnerMessage.join ),\n                        internal( HeartbeatMessage.join ),\n                        internal( ElectionMessage.join ),\n                        internal( SnapshotMessage.join ) )\n\n                .rule( ClusterState.joining, ClusterMessage.configurationChanged, ClusterState.entered,\n                        internal( AtomicBroadcastMessage.entered ),\n                        internal( ProposerMessage.join ),\n                        internal( AcceptorMessage.join ),\n                        internal( LearnerMessage.join ),\n                        internal( HeartbeatMessage.join ),\n                        internal( ElectionMessage.join ),\n                        internal( SnapshotMessage.join ) )\n\n                .rule( ClusterState.joining, ClusterMessage.joinFailure, ClusterState.start,\n                        internal( AtomicBroadcastMessage.leave ),\n                        internal( AcceptorMessage.leave ),\n                        internal( LearnerMessage.leave ),\n                        internal( ProposerMessage.leave ) )\n\n                .rule( ClusterState.entered, ClusterMessage.leave, ClusterState.start,\n                        internal( AtomicBroadcastMessage.leave ),\n                        internal( AcceptorMessage.leave ),\n                        internal( LearnerMessage.leave ),\n                        internal( HeartbeatMessage.leave ),\n                        internal( SnapshotMessage.leave ),\n                        internal( ElectionMessage.leave ),\n                        internal( ProposerMessage.leave ) )\n\n                .rule( ClusterState.entered, ClusterMessage.leave, ClusterState.start,\n                        internal( AtomicBroadcastMessage.leave ),\n                        internal( AcceptorMessage.leave ),\n                        internal( LearnerMessage.leave ),\n                        internal( HeartbeatMessage.leave ),\n                        internal( ElectionMessage.leave ),\n                        internal( SnapshotMessage.leave ),\n                        internal( ProposerMessage.leave ) )\n\n                .rule( ClusterState.leaving, ClusterMessage.configurationChanged, ClusterState.start,\n                        internal( AtomicBroadcastMessage.leave ),\n                        internal( AcceptorMessage.leave ),\n                        internal( LearnerMessage.leave ),\n                        internal( HeartbeatMessage.leave ),\n                        internal( ElectionMessage.leave ),\n                        internal( SnapshotMessage.leave ),\n                        internal( ProposerMessage.leave ) )\n\n                .rule( ClusterState.leaving, ClusterMessage.leaveTimedout, ClusterState.start,\n                        internal( AtomicBroadcastMessage.leave ),\n                        internal( AcceptorMessage.leave ),\n                        internal( LearnerMessage.leave ),\n                        internal( HeartbeatMessage.leave ),\n                        internal( ElectionMessage.leave ),\n                        internal( SnapshotMessage.leave ),\n                        internal( ProposerMessage.leave ) );\n\n\n        connectedStateMachines.addStateTransitionListener( rules );\n\n        return server;\n    }","commit_id":"f29a3e9f642d75976a70c73f67b52823dda3e651","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldInvokeAllCallbacksEvenWhenOneThrowsException() throws Exception\n    {\n        // given\n        ProgressMonitorFactory.MultiPartBuilder builder = ProgressMonitorFactory.NONE.multipleParts( testName.getMethodName() );\n        ProgressListener progressListener = builder.progressForPart( \"only part\", 1 );\n        Completion completion = builder.build();\n        Runnable callback = mock( Runnable.class );\n        doThrow( RuntimeException.class ).doNothing().when( callback ).run();\n        completion.notify( callback );\n        completion.notify( callback );\n\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        PrintStream sysErr = System.out;\n        try\n        {\n            System.setErr( new PrintStream( out ) );\n\n            // when\n            progressListener.done();\n        }\n        finally\n        {\n            System.setOut( sysErr );\n        }\n\n        // then\n        verify( callback, times( 2 ) ).run();\n        String printedOutput = out.toString( Charset.defaultCharset().name() );\n        assertTrue( printedOutput, printedOutput.startsWith( RuntimeException.class.getName() ) );\n        assertTrue( printedOutput, printedOutput\n                .contains( \"\\n\\tat \" + getClass().getName() + \".\" + testName.getMethodName() ) );\n    }","id":25008,"modified_method":"@Test\n    public void shouldInvokeAllCallbacksEvenWhenOneThrowsException() throws Exception\n    {\n        // given\n        ProgressMonitorFactory.MultiPartBuilder builder = ProgressMonitorFactory.NONE.multipleParts( testName.getMethodName() );\n        ProgressListener progressListener = builder.progressForPart( \"only part\", 1 );\n        Completion completion = builder.build();\n        Runnable callback = mock( Runnable.class );\n        doThrow( new RuntimeException()).doNothing().when( callback ).run();\n        completion.notify( callback );\n        completion.notify( callback );\n\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        PrintStream sysErr = System.out;\n        try\n        {\n            System.setErr(new PrintStream(out));\n\n            // when\n            progressListener.done();\n        }\n        finally\n        {\n            System.setOut( sysErr );\n        }\n\n        // then\n        verify( callback, times( 2 ) ).run();\n        String printedOutput = out.toString( Charset.defaultCharset().name() );\n        assertTrue( printedOutput, printedOutput.startsWith( RuntimeException.class.getName() ) );\n        assertTrue( printedOutput, printedOutput\n                .contains( \"\\n\\tat \" + getClass().getName() + \".\" + testName.getMethodName() ) );\n    }","commit_id":"f29a3e9f642d75976a70c73f67b52823dda3e651","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static <T> Function<String, T> options( T... optionValues )\n    {\n        return options( Iterables.iterable( optionValues ) );\n    }","id":25009,"modified_method":"public static <T> Function<String, T> options( T... optionValues )\n    {\n        return Settings.<T>options( Iterables.<T,T>iterable( optionValues ) );\n    }","commit_id":"f29a3e9f642d75976a70c73f67b52823dda3e651","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Function<ClusterMember, Slave> slaveForMember()\n    {\n        return new Function<ClusterMember, Slave>()\n        {\n            @Override\n            public Slave apply( ClusterMember from )\n            {\n                Slave slave = life.add( slaveFactory.newSlave( from ));\n                slaves.put( from, slave );\n                return slave;\n            }\n        };\n    }","id":25010,"modified_method":"private Function<ClusterMember, Slave> slaveForMember()\n    {\n        return new Function<ClusterMember, Slave>()\n        {\n            @Override\n            public Slave apply( ClusterMember from )\n            {\n                synchronized ( HighAvailabilitySlaves.this )\n                {\n                    Slave presentSlave = slaves.get( from );\n                    if ( presentSlave == null )\n                    {\n                        presentSlave = life.add( slaveFactory.newSlave( from ) );\n                        slaves.put( from, presentSlave );\n                    }\n                    return presentSlave;\n                }\n            }\n        };\n    }","commit_id":"a95323a1ea7b5415608b508b1eb902a5cd9b148c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldClearSlavesWhenNewMasterElected() throws Throwable\n    {\n        // given\n        Cluster cluster = mock( Cluster.class );\n        ClusterMembers clusterMembers = mock( ClusterMembers.class);\n        when( clusterMembers.getMembers() ).thenReturn( Iterables.<ClusterMember,ClusterMember>iterable(\n                new ClusterMember( instanceId1 ).availableAs( HighAvailabilityModeSwitcher.SLAVE, haUri1 ) ) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n        when( slaveFactory.newSlave( (ClusterMember)any() ) ).thenReturn( mock(Slave.class), mock(Slave.class) );\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory);\n        slaves.init();\n\n        ArgumentCaptor<ClusterListener> listener = ArgumentCaptor.forClass( ClusterListener.class );\n        verify( cluster ).addClusterListener( listener.capture() );\n\n        // when\n        Slave slave1 = slaves.getSlaves().iterator().next();\n\n        listener.getValue().elected( ClusterConfiguration.COORDINATOR, instanceId1, clusterUri2 );\n\n        Slave slave2 = slaves.getSlaves().iterator().next();\n\n        // then\n        Assert.assertThat( slave2, not( sameInstance( slave1 ) ));\n    }","id":25011,"modified_method":"@Test\n    public void shouldClearSlavesWhenNewMasterElected()\n    {\n        // given\n        Cluster cluster = mock( Cluster.class );\n        ClusterMembers clusterMembers = mock( ClusterMembers.class );\n        when( clusterMembers.getMembers() ).thenReturn( Iterables.option(\n                new ClusterMember( INSTANCE_ID ).availableAs( HighAvailabilityModeSwitcher.SLAVE, HA_URI ) ) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n        when( slaveFactory.newSlave( (ClusterMember) any() ) ).thenReturn( mock( Slave.class ), mock( Slave.class ) );\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory );\n        slaves.init();\n\n        ArgumentCaptor<ClusterListener> listener = ArgumentCaptor.forClass( ClusterListener.class );\n        verify( cluster ).addClusterListener( listener.capture() );\n\n        // when\n        Slave slave1 = slaves.getSlaves().iterator().next();\n\n        listener.getValue().elected( ClusterConfiguration.COORDINATOR, INSTANCE_ID, CLUSTER_URI );\n\n        Slave slave2 = slaves.getSlaves().iterator().next();\n\n        // then\n        assertThat( slave2, not( sameInstance( slave1 ) ) );\n    }","commit_id":"a95323a1ea7b5415608b508b1eb902a5cd9b148c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotReturnUnavailableSlaves() throws Throwable\n    {\n        // given\n        Cluster cluster = mock( Cluster.class);\n        ClusterMembers clusterMembers = mock( ClusterMembers.class);\n        when( clusterMembers.getMembers() ).thenReturn( Iterables.<ClusterMember,ClusterMember>iterable(\n                new ClusterMember( instanceId1 ) ) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory);\n        slaves.init();\n\n        // when\n        Iterable<Slave> memberSlaves = slaves.getSlaves();\n\n        // then\n        Assert.assertThat( count( memberSlaves ), CoreMatchers.equalTo( 0L ));\n    }","id":25012,"modified_method":"@Test\n    public void shouldNotReturnUnavailableSlaves()\n    {\n        // given\n        Cluster cluster = mock( Cluster.class );\n        ClusterMembers clusterMembers = mock( ClusterMembers.class );\n        when( clusterMembers.getMembers() ).thenReturn( Iterables.option( new ClusterMember( INSTANCE_ID ) ) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory );\n        slaves.init();\n\n        // when\n        Iterable<Slave> memberSlaves = slaves.getSlaves();\n\n        // then\n        assertThat( count( memberSlaves ), equalTo( 0L ) );\n    }","commit_id":"a95323a1ea7b5415608b508b1eb902a5cd9b148c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldRegisterItselfOnMonitors() throws Throwable\n    {\n        // given\n        ClusterMembers clusterMembers = mock( ClusterMembers.class );\n        Cluster cluster = mock( Cluster.class );\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n        \n        // when\n        new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory).init();\n\n        // then\n        verify( cluster ).addClusterListener( Mockito.<ClusterListener>any() );\n    }","id":25013,"modified_method":"@Test\n    public void shouldRegisterItselfOnMonitors()\n    {\n        // given\n        ClusterMembers clusterMembers = mock( ClusterMembers.class );\n        Cluster cluster = mock( Cluster.class );\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n\n        // when\n        new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory ).init();\n\n        // then\n        verify( cluster ).addClusterListener( any( ClusterListener.class ) );\n    }","commit_id":"a95323a1ea7b5415608b508b1eb902a5cd9b148c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotReturnAvailableButFailedSlaves() throws Throwable\n    {\n        // given\n        Cluster cluster = mock( Cluster.class);\n        ClusterMembers clusterMembers = mock( ClusterMembers.class);\n        when( clusterMembers.getMembers() ).thenReturn( Iterables.<ClusterMember,ClusterMember>iterable(\n                new ClusterMember( instanceId1 ).availableAs( \"SLAVE\", haUri1 ).failed() ) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory);\n        slaves.init();\n\n        // when\n        Iterable<Slave> memberSlaves = slaves.getSlaves();\n\n        // then\n        Assert.assertThat( count( memberSlaves ), CoreMatchers.equalTo( 0L ));\n    }","id":25014,"modified_method":"@Test\n    public void shouldNotReturnAvailableButFailedSlaves()\n    {\n        // given\n        Cluster cluster = mock( Cluster.class );\n        ClusterMembers clusterMembers = mock( ClusterMembers.class );\n        when( clusterMembers.getMembers() ).thenReturn( Iterables.option(\n                new ClusterMember( INSTANCE_ID ).availableAs( HighAvailabilityModeSwitcher.SLAVE, HA_URI ).failed() ) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory );\n        slaves.init();\n\n        // when\n        Iterable<Slave> memberSlaves = slaves.getSlaves();\n\n        // then\n        assertThat( count( memberSlaves ), equalTo( 0L ) );\n    }","commit_id":"a95323a1ea7b5415608b508b1eb902a5cd9b148c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldReturnAvailableAndAliveSlaves() throws Throwable\n    {\n        // given\n        Cluster cluster = mock( Cluster.class);\n        ClusterMembers clusterMembers = mock( ClusterMembers.class);\n        when( clusterMembers.getMembers() ).thenReturn( Iterables.<ClusterMember,ClusterMember>iterable(\n                new ClusterMember( instanceId1 ).availableAs( HighAvailabilityModeSwitcher.SLAVE, haUri1) ) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n        when( slaveFactory.newSlave( (ClusterMember)any() ) ).thenReturn( mock(Slave.class));\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory);\n        slaves.init();\n\n        // when\n        Iterable<Slave> memberSlaves = slaves.getSlaves();\n\n        // then\n        Assert.assertThat( count( memberSlaves ), CoreMatchers.equalTo( 1L ));\n    }","id":25015,"modified_method":"@Test\n    public void shouldReturnAvailableAndAliveSlaves()\n    {\n        // given\n        Cluster cluster = mock( Cluster.class );\n        ClusterMembers clusterMembers = mock( ClusterMembers.class );\n        when( clusterMembers.getMembers() ).thenReturn( Iterables.option(\n                new ClusterMember( INSTANCE_ID ).availableAs( HighAvailabilityModeSwitcher.SLAVE, HA_URI ) ) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n        when( slaveFactory.newSlave( (ClusterMember) any() ) ).thenReturn( mock( Slave.class ) );\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory );\n        slaves.init();\n\n        // when\n        Iterable<Slave> memberSlaves = slaves.getSlaves();\n\n        // then\n        assertThat( count( memberSlaves ), equalTo( 1L ) );\n    }","commit_id":"a95323a1ea7b5415608b508b1eb902a5cd9b148c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private AutocompletionContext getAutocompletionContext()\n   {\n      AutocompletionContext context = new AutocompletionContext();\n      \n      String firstLine = input_.getText();\n      int row = input_.getCursorPosition().getRow();\n      \n      // trim to cursor position\n      firstLine = firstLine.substring(0, input_.getCursorPosition().getColumn());\n      \n      // Get the token at the cursor position\n      String token = firstLine.replaceAll(\".*[^a-zA-Z0-9._:$@-]\", \"\");\n      \n      // If we're in Markdown mode and have an appropriate string, try to get\n      // file completions\n      if (DocumentMode.isCursorInMarkdownMode(docDisplay_) &&\n            firstLine.matches(\".*\\\\[.*\\\\]\\\\(.*\"))\n         return getAutocompletionContextForFileMarkdownLink(firstLine);\n      \n      // If we're completing an object within a string, assume it's a\n      // file-system completion\n      String firstLineStripped = StringUtil.stripBalancedQuotes(\n            StringUtil.stripRComment(firstLine));\n      \n      if (firstLineStripped.indexOf('\\'') != -1 || \n          firstLineStripped.indexOf('\"') != -1)\n         return getAutocompletionContextForFile(firstLine);\n      \n      // If this line starts with '```{', then we're completing chunk options\n      // pass the whole line as a token\n      if (firstLine.startsWith(\"```{\") || firstLine.startsWith(\"<<\"))\n         return new AutocompletionContext(firstLine, AutocompletionContext.TYPE_CHUNK);\n      \n      // If this line starts with a '?', assume it's a help query\n      if (firstLine.matches(\"^\\\\s*[?].*\"))\n         return new AutocompletionContext(token, AutocompletionContext.TYPE_HELP);\n      \n      // escape early for roxygen\n      if (firstLine.matches(\"\\\\s*#+'.*\"))\n         return new AutocompletionContext(\n               token, AutocompletionContext.TYPE_ROXYGEN);\n      \n      // If the token has '$' or '@', escape early as we'll be completing\n      // either from names or an overloaded `$` method\n      if (token.contains(\"$\") || token.contains(\"@\"))\n         addAutocompletionContextForDollar(context);\n      \n      // If the token has '::' or ':::', escape early as we'll be completing\n      // something from a namespace\n      if (token.contains(\"::\"))\n         addAutocompletionContextForNamespace(token, context);\n      \n      // Now strip the '$' and '@' post-hoc since they're not really part\n      // of the identifier\n      token = token.replaceAll(\".*[$@:]\", \"\");\n      context.setToken(token);\n      \n      // access to the R Code model\n      AceEditor editor = (AceEditor) docDisplay_;\n      if (editor == null)\n         return context;\n      \n      CodeModel codeModel = editor.getSession().getMode().getCodeModel();\n      \n      // We might need to grab content from further up in the document than\n      // the current cursor position -- so tokenize ahead.\n      codeModel.tokenizeUpToRow(row + 100);\n      \n      // Make a token cursor and place it at the first token previous\n      // to the cursor.\n      TokenCursor tokenCursor = codeModel.getTokenCursor();\n      if (!tokenCursor.moveToPosition(input_.getCursorPosition()))\n         return context;\n      \n      TokenCursor startCursor = tokenCursor.cloneCursor();\n      boolean startedOnEquals = tokenCursor.currentValue() == \"=\";\n      if (startCursor.currentType() == \"identifier\")\n         if (startCursor.moveToPreviousToken())\n            if (startCursor.currentValue() == \"=\")\n            {\n               startedOnEquals = true;\n               startCursor.moveToNextToken();\n            }\n      \n      // Find an opening '(' or '[' -- this provides the function or object\n      // for completion.\n      int initialNumCommas = 0;\n      if (tokenCursor.currentValue() != \"(\" && tokenCursor.currentValue() != \"[\")\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(new String[]{ \"[\", \"(\" }, true);\n         if (commaCount == -1)\n         {\n            commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n            if (commaCount == -1)\n               return context;\n            else\n               initialNumCommas = commaCount;\n         }\n         else\n         {\n            initialNumCommas = commaCount;\n         }\n      }\n      \n      // Figure out whether we're looking at '(', '[', or '[[',\n      // and place the token cursor on the first token preceding.\n      TokenCursor endOfDecl = tokenCursor.cloneCursor();\n      int initialDataType = AutocompletionContext.TYPE_UNKNOWN;\n      if (tokenCursor.currentValue() == \"(\")\n      {\n         // Don't produce function argument completions\n         // if the cursor is on, or after, an '='\n         if (!startedOnEquals)\n            initialDataType = AutocompletionContext.TYPE_FUNCTION;\n         else\n            initialDataType = AutocompletionContext.TYPE_UNKNOWN;\n         \n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n      }\n      else if (tokenCursor.currentValue() == \"[\")\n      {\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!endOfDecl.moveToPreviousToken())\n               return context;\n            \n            initialDataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            initialDataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n      }\n      \n      // Get the string marking the function or data\n      if (!tokenCursor.findStartOfEvaluationContext())\n         return context;\n      \n      // Try to get the function call string -- either there's\n      // an associated closing paren we can use, or we should just go up\n      // to the current cursor position\n      \n      // default case: use start cursor\n      Position endPos = startCursor.currentPosition();\n      endPos.setColumn(endPos.getColumn() + startCursor.currentValue().length());\n      \n      // try to look forward for closing paren\n      if (endOfDecl.currentValue() == \"(\")\n      {\n         TokenCursor closingParenCursor = endOfDecl.cloneCursor();\n         if (closingParenCursor.fwdToMatchingToken())\n         {\n            endPos = closingParenCursor.currentPosition();\n            endPos.setColumn(endPos.getColumn() + 1);\n         }\n      }\n      \n      // We can now set the function call string\n      context.setFunctionCallString(\n            editor.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(), endPos)).trim());\n      \n      String initialData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  endOfDecl.currentPosition())).trim();\n      \n      // And the first context\n      context.add(initialData, initialDataType, initialNumCommas);\n\n      // Get the rest of the single-bracket contexts for completions as well\n      String assocData;\n      int dataType;\n      int numCommas;\n      while (true)\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n         if (commaCount == -1)\n            break;\n         \n         numCommas = commaCount;\n         \n         TokenCursor declEnd = tokenCursor.cloneCursor();\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!declEnd.moveToPreviousToken())\n               return context;\n            \n            dataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            dataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n         \n         tokenCursor.findStartOfEvaluationContext();\n         \n         assocData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  declEnd.currentPosition())).trim();\n         \n         context.add(assocData, dataType, numCommas);\n      }\n      \n      return context;\n      \n   }","id":25016,"modified_method":"private AutocompletionContext getAutocompletionContext()\n   {\n      AutocompletionContext context = new AutocompletionContext();\n      \n      String firstLine = input_.getText();\n      int row = input_.getCursorPosition().getRow();\n      \n      // trim to cursor position\n      firstLine = firstLine.substring(0, input_.getCursorPosition().getColumn());\n      \n      // Get the token at the cursor position\n      String token = firstLine.replaceAll(\".*[^a-zA-Z0-9._:$@-]\", \"\");\n      \n      // If we're in Markdown mode and have an appropriate string, try to get\n      // file completions\n      if (DocumentMode.isCursorInMarkdownMode(docDisplay_) &&\n            firstLine.matches(\".*\\\\[.*\\\\]\\\\(.*\"))\n         return getAutocompletionContextForFileMarkdownLink(firstLine);\n      \n      // If we're completing an object within a string, assume it's a\n      // file-system completion\n      String firstLineStripped = StringUtil.stripBalancedQuotes(\n            StringUtil.stripRComment(firstLine));\n      \n      if (firstLineStripped.indexOf('\\'') != -1 || \n          firstLineStripped.indexOf('\"') != -1)\n         return getAutocompletionContextForFile(firstLine);\n      \n      // If this line starts with '```{', then we're completing chunk options\n      // pass the whole line as a token\n      if (firstLine.startsWith(\"```{\") || firstLine.startsWith(\"<<\"))\n         return new AutocompletionContext(firstLine, AutocompletionContext.TYPE_CHUNK);\n      \n      // If this line starts with a '?', assume it's a help query\n      if (firstLine.matches(\"^\\\\s*[?].*\"))\n         return new AutocompletionContext(token, AutocompletionContext.TYPE_HELP);\n      \n      // escape early for roxygen\n      if (firstLine.matches(\"\\\\s*#+'.*\"))\n         return new AutocompletionContext(\n               token, AutocompletionContext.TYPE_ROXYGEN);\n      \n      // If the token has '$' or '@', escape early as we'll be completing\n      // either from names or an overloaded `$` method\n      if (token.contains(\"$\") || token.contains(\"@\"))\n         addAutocompletionContextForDollar(context);\n      \n      // If the token has '::' or ':::', escape early as we'll be completing\n      // something from a namespace\n      if (token.contains(\"::\"))\n         addAutocompletionContextForNamespace(token, context);\n      \n      // Now strip the '$' and '@' post-hoc since they're not really part\n      // of the identifier\n      token = token.replaceAll(\".*[$@:]\", \"\");\n      context.setToken(token);\n      \n      // access to the R Code model\n      AceEditor editor = (AceEditor) docDisplay_;\n      if (editor == null)\n         return context;\n      \n      CodeModel codeModel = editor.getSession().getMode().getCodeModel();\n      \n      // We might need to grab content from further up in the document than\n      // the current cursor position -- so tokenize ahead.\n      codeModel.tokenizeUpToRow(row + 100);\n      \n      // Make a token cursor and place it at the first token previous\n      // to the cursor.\n      TokenCursor tokenCursor = codeModel.getTokenCursor();\n      if (!tokenCursor.moveToPosition(input_.getCursorPosition()))\n         return context;\n      \n      TokenCursor startCursor = tokenCursor.cloneCursor();\n      \n      // If this is an argument, return auto-completions tuned to that argument\n      TokenCursor argsCursor = startCursor.cloneCursor();\n      if (argsCursor.currentType() == \"identifier\")\n         argsCursor.moveToPreviousToken();\n      \n      if (argsCursor.currentValue() == \"=\")\n      {\n         if (argsCursor.moveToPreviousToken())\n         {\n            return new AutocompletionContext(\n                  token,\n                  argsCursor.currentValue(),\n                  AutocompletionContext.TYPE_ARGUMENT);\n         }\n      }\n      \n      // Find an opening '(' or '[' -- this provides the function or object\n      // for completion.\n      int initialNumCommas = 0;\n      if (tokenCursor.currentValue() != \"(\" && tokenCursor.currentValue() != \"[\")\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(\n               new String[]{ \"[\", \"(\" }, true);\n         \n         if (commaCount == -1)\n         {\n            commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n            if (commaCount == -1)\n               return context;\n            else\n               initialNumCommas = commaCount;\n         }\n         else\n         {\n            initialNumCommas = commaCount;\n         }\n      }\n      \n      // Figure out whether we're looking at '(', '[', or '[[',\n      // and place the token cursor on the first token preceding.\n      TokenCursor endOfDecl = tokenCursor.cloneCursor();\n      int initialDataType = AutocompletionContext.TYPE_UNKNOWN;\n      if (tokenCursor.currentValue() == \"(\")\n      {\n         initialDataType = AutocompletionContext.TYPE_FUNCTION;\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n      }\n      else if (tokenCursor.currentValue() == \"[\")\n      {\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!endOfDecl.moveToPreviousToken())\n               return context;\n            \n            initialDataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            initialDataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n      }\n      \n      // Get the string marking the function or data\n      if (!tokenCursor.findStartOfEvaluationContext())\n         return context;\n      \n      // Try to get the function call string -- either there's\n      // an associated closing paren we can use, or we should just go up\n      // to the current cursor position\n      \n      // default case: use start cursor\n      Position endPos = startCursor.currentPosition();\n      endPos.setColumn(endPos.getColumn() + startCursor.currentValue().length());\n      \n      // try to look forward for closing paren\n      if (endOfDecl.currentValue() == \"(\")\n      {\n         TokenCursor closingParenCursor = endOfDecl.cloneCursor();\n         if (closingParenCursor.fwdToMatchingToken())\n         {\n            endPos = closingParenCursor.currentPosition();\n            endPos.setColumn(endPos.getColumn() + 1);\n         }\n      }\n      \n      // We can now set the function call string\n      // We strip the current token so that the matched.call work later on\n      // can properly resolve the current argument\n      Position startPosition = startCursor.currentPosition();\n      if (startCursor.currentValue() == \"(\")\n         startPosition.setColumn(startPosition.getColumn() + 1);\n      \n      String beforeText = editor.getTextForRange(Range.fromPoints(\n            tokenCursor.currentPosition(),\n            startPosition));\n      \n      Position afterTokenPos = startCursor.currentPosition();\n      if (startCursor.currentType() == \"identifier\")\n         afterTokenPos.setColumn(afterTokenPos.getColumn() +\n               startCursor.currentValue().length());\n      \n      String afterText = editor.getTextForRange(Range.fromPoints(\n            afterTokenPos, endPos));\n            \n      context.setFunctionCallString(\n            (beforeText + afterText).trim());\n      \n      String initialData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  endOfDecl.currentPosition())).trim();\n      \n      // And the first context\n      context.add(initialData, initialDataType, initialNumCommas);\n\n      // Get the rest of the single-bracket contexts for completions as well\n      String assocData;\n      int dataType;\n      int numCommas;\n      while (true)\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n         if (commaCount == -1)\n            break;\n         \n         numCommas = commaCount;\n         \n         TokenCursor declEnd = tokenCursor.cloneCursor();\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!declEnd.moveToPreviousToken())\n               return context;\n            \n            dataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            dataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n         \n         tokenCursor.findStartOfEvaluationContext();\n         \n         assocData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  declEnd.currentPosition())).trim();\n         \n         context.add(assocData, dataType, numCommas);\n      }\n      \n      return context;\n      \n   }","commit_id":"7780ef42f05024671eb4b2f987f528561af52227","url":"https://github.com/rstudio/rstudio"},{"original_method":"public boolean previewKeyPress(char c)\n   {\n      if (popup_.isShowing())\n      {\n         if (isValidForRIdentifier(c) || c == ':')\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(false, true, false);\n               }\n            });\n         }\n      }\n      else\n      {\n         \n         // Perform an auto-popup if a set number of R identifier characters\n         // have been inserted (but only if the user has allowed it in prefs)\n         boolean autoPopupEnabled = uiPrefs_.codeComplete().getValue().equals(\n               UIPrefsAccessor.COMPLETION_ALWAYS);\n\n         if (!autoPopupEnabled)\n            return false;\n         \n         final boolean canAutoPopup = checkCanAutoPopup(c, 4);\n         char prevChar = docDisplay_.getCurrentLine().charAt(\n               input_.getCursorPosition().getColumn() - 1); \n         \n         if (\n               (canAutoPopup) ||\n               (c == ':' && prevChar == ':') ||\n               (c == '$') ||\n               (c == '@') ||\n               isSweaveCompletion(c))\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(true, true, false);\n               }\n            });\n         }\n         else if (CompletionUtils.handleEncloseSelection(input_, c))\n         {\n            return true;\n         }\n      }\n      return false ;\n   }","id":25017,"modified_method":"public boolean previewKeyPress(char c)\n   {\n      if (popup_.isShowing())\n      {\n         if (isValidForRIdentifier(c) || c == ':')\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(false, true, false);\n               }\n            });\n         }\n      }\n      else\n      {\n         // Perform an auto-popup if a set number of R identifier characters\n         // have been inserted (but only if the user has allowed it in prefs)\n         boolean autoPopupEnabled = uiPrefs_.codeComplete().getValue().equals(\n               UIPrefsAccessor.COMPLETION_ALWAYS);\n\n         if (!autoPopupEnabled)\n            return false;\n         \n         \n         // Check for a valid number of R identifier characters for autopopup\n         boolean canAutoPopup = checkCanAutoPopup(c, 4);\n         char prevChar = docDisplay_.getCurrentLine().charAt(\n               input_.getCursorPosition().getColumn() - 1); \n         \n         // Automatically popup completions after certain function calls\n         if (c == '(')\n         {\n            String token = StringUtil.getToken(\n                  docDisplay_.getCurrentLine(),\n                  input_.getCursorPosition().getColumn(),\n                  \"[a-z]\",\n                  false,\n                  true);\n            \n            if (token.matches(\"^(library|require|requireNamespace|data)\\\\s*$\"))\n               canAutoPopup = true;\n         }\n         \n         if (\n               (canAutoPopup) ||\n               (c == ':' && prevChar == ':') ||\n               (c == '$') ||\n               (c == '@') ||\n               isSweaveCompletion(c))\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(true, true, false);\n               }\n            });\n         }\n         else if (CompletionUtils.handleEncloseSelection(input_, c))\n         {\n            return true;\n         }\n      }\n      return false ;\n   }","commit_id":"62e2906d15ebf585086ffb197b0ed3c81e4804d1","url":"https://github.com/rstudio/rstudio"},{"original_method":"private boolean checkCanAutoPopup(char c, int lookbackLimit)\n   {\n      String currentLine = docDisplay_.getCurrentLine();\n      Position cursorPos = input_.getCursorPosition();\n      int cursorColumn = cursorPos.getColumn();\n      \n      // Grab the current token on the line\n      String currentToken = StringUtil.getToken(\n            currentLine, cursorColumn, \"^[a-zA-Z0-9._'\\\"`]$\", false);\n      \n      // Don't auto-popup for common keywords\n      String[] keywords = {\n            \"for\", \"if\", \"in\", \"function\", \"while\", \"repeat\",\n            \"break\", \"switch\", \"return\", \"library\", \"require\"};\n      for (String keyword : keywords)\n         if (keyword.substring(0, currentToken.length()).equals(currentToken))\n            return false;\n      \n      boolean canAutocomplete = canAutoPopup_ && \n            (currentLine.length() > lookbackLimit - 1 && isValidForRIdentifier(c));\n\n      if (canAutocomplete)\n      {\n         for (int i = 0; i < lookbackLimit; i++)\n         {\n            if (!isValidForRIdentifier(currentLine.charAt(cursorColumn - i - 1)))\n            {\n               canAutocomplete = false;\n               break;\n            }\n         }\n      }\n\n      return canAutocomplete;\n      \n   }","id":25018,"modified_method":"private boolean checkCanAutoPopup(char c, int lookbackLimit)\n   {\n      String currentLine = docDisplay_.getCurrentLine();\n      Position cursorPos = input_.getCursorPosition();\n      int cursorColumn = cursorPos.getColumn();\n      \n      // Grab the current token on the line\n      String currentToken = StringUtil.getToken(\n            currentLine, cursorColumn, \"^[a-zA-Z0-9._'\\\"`]$\", false, false);\n      \n      // Don't auto-popup for common keywords\n      String[] keywords = {\n            \"for\", \"if\", \"in\", \"function\", \"while\", \"repeat\",\n            \"break\", \"switch\", \"return\", \"library\", \"require\"};\n      for (String keyword : keywords)\n         if (keyword.substring(0, currentToken.length()).equals(currentToken))\n            return false;\n      \n      boolean canAutocomplete = canAutoPopup_ && \n            (currentLine.length() > lookbackLimit - 1 && isValidForRIdentifier(c));\n\n      if (canAutocomplete)\n      {\n         for (int i = 0; i < lookbackLimit; i++)\n         {\n            if (!isValidForRIdentifier(currentLine.charAt(cursorColumn - i - 1)))\n            {\n               canAutocomplete = false;\n               break;\n            }\n         }\n      }\n\n      return canAutocomplete;\n      \n   }","commit_id":"62e2906d15ebf585086ffb197b0ed3c81e4804d1","url":"https://github.com/rstudio/rstudio"},{"original_method":"private AutocompletionContext getAutocompletionContext()\n   {\n      AutocompletionContext context = new AutocompletionContext();\n      \n      String firstLine = input_.getText();\n      int row = input_.getCursorPosition().getRow();\n      \n      // trim to cursor position\n      firstLine = firstLine.substring(0, input_.getCursorPosition().getColumn());\n      \n      // Get the token at the cursor position\n      String token = firstLine.replaceAll(\".*[^a-zA-Z0-9._:$@-]\", \"\");\n      \n      // If we're completing an object within a string, assume it's a\n      // file-system completion\n      String firstLineStripped = StringUtil.stripBalancedQuotes(\n            StringUtil.stripRComment(firstLine));\n      \n      if (firstLineStripped.indexOf('\\'') != -1 || \n          firstLineStripped.indexOf('\"') != -1)\n         return getAutocompletionContextForFile(firstLine);\n      \n      // If this line starts with '```{', then we're completing chunk options\n      // pass the whole line as a token\n      if (firstLine.startsWith(\"```{\") || firstLine.startsWith(\"<<\"))\n         return new AutocompletionContext(firstLine, AutocompletionContext.TYPE_CHUNK);\n      \n      // If this line starts with a '?', assume it's a help query\n      if (firstLine.matches(\"^\\\\s*[?].*\"))\n         return new AutocompletionContext(token, AutocompletionContext.TYPE_HELP);\n      \n      // escape early for roxygen\n      if (firstLine.matches(\"\\\\s*#+'.*\"))\n         return new AutocompletionContext(\n               token, AutocompletionContext.TYPE_ROXYGEN);\n      \n      // If the token has '$' or '@', escape early as we'll be completing\n      // either from names or an overloaded `$` method\n      if (token.contains(\"$\") || token.contains(\"@\"))\n         addAutocompletionContextForDollar(context);\n      \n      // If the token has '::' or ':::', escape early as we'll be completing\n      // something from a namespace\n      if (token.contains(\"::\"))\n         addAutocompletionContextForNamespace(token, context);\n      \n      // Now strip the '$' and '@' post-hoc since they're not really part\n      // of the identifier\n      token = token.replaceAll(\".*[$@:]\", \"\");\n      context.setToken(token);\n      \n      // access to the R Code model\n      AceEditor editor = (AceEditor) docDisplay_;\n      if (editor == null)\n         return context;\n      \n      CodeModel codeModel = editor.getSession().getMode().getCodeModel();\n      \n      // We might need to grab content from further up in the document than\n      // the current cursor position -- so tokenize ahead.\n      codeModel.tokenizeUpToRow(row + 100);\n      \n      // Make a token cursor and place it at the first token previous\n      // to the cursor.\n      TokenCursor tokenCursor = codeModel.getTokenCursor();\n      if (!tokenCursor.moveToPosition(input_.getCursorPosition()))\n         return context;\n      \n      TokenCursor startCursor = tokenCursor.cloneCursor();\n      boolean startedOnEquals = tokenCursor.currentValue() == \"=\";\n      if (startCursor.currentType() == \"identifier\")\n         if (startCursor.moveToPreviousToken())\n            if (startCursor.currentValue() == \"=\")\n            {\n               startedOnEquals = true;\n               startCursor.moveToNextToken();\n            }\n      \n      // Find an opening '(' or '[' -- this provides the function or object\n      // for completion.\n      int initialNumCommas = 0;\n      if (tokenCursor.currentValue() != \"(\" && tokenCursor.currentValue() != \"[\")\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(new String[]{ \"[\", \"(\" }, true);\n         if (commaCount == -1)\n         {\n            commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n            if (commaCount == -1)\n               return context;\n            else\n               initialNumCommas = commaCount;\n         }\n         else\n         {\n            initialNumCommas = commaCount;\n         }\n      }\n      \n      // Figure out whether we're looking at '(', '[', or '[[',\n      // and place the token cursor on the first token preceding.\n      TokenCursor endOfDecl = tokenCursor.cloneCursor();\n      int initialDataType = AutocompletionContext.TYPE_UNKNOWN;\n      if (tokenCursor.currentValue() == \"(\")\n      {\n         // Don't produce function argument completions\n         // if the cursor is on, or after, an '='\n         if (!startedOnEquals)\n            initialDataType = AutocompletionContext.TYPE_FUNCTION;\n         else\n            initialDataType = AutocompletionContext.TYPE_UNKNOWN;\n         \n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n      }\n      else if (tokenCursor.currentValue() == \"[\")\n      {\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!endOfDecl.moveToPreviousToken())\n               return context;\n            \n            initialDataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            initialDataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n      }\n      \n      // Get the string marking the function or data\n      if (!tokenCursor.findStartOfEvaluationContext())\n         return context;\n      \n      // Try to get the function call string -- either there's\n      // an associated closing paren we can use, or we should just go up\n      // to the current cursor position\n      \n      // default case: use start cursor\n      Position endPos = startCursor.currentPosition();\n      endPos.setColumn(endPos.getColumn() + startCursor.currentValue().length());\n      \n      // try to look forward for closing paren\n      if (endOfDecl.currentValue() == \"(\")\n      {\n         TokenCursor closingParenCursor = endOfDecl.cloneCursor();\n         if (closingParenCursor.fwdToMatchingToken())\n         {\n            endPos = closingParenCursor.currentPosition();\n            endPos.setColumn(endPos.getColumn() + 1);\n         }\n      }\n      \n      // We can now set the function call string\n      context.setFunctionCallString(\n            editor.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(), endPos)));\n      \n      String initialData = \n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  endOfDecl.currentPosition()));\n      \n      // And the first context\n      context.add(initialData, initialDataType, initialNumCommas);\n\n      // Get the rest of the single-bracket contexts for completions as well\n      String assocData;\n      int dataType;\n      int numCommas;\n      while (true)\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n         if (commaCount == -1)\n            break;\n         \n         numCommas = commaCount;\n         \n         TokenCursor declEnd = tokenCursor.cloneCursor();\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!declEnd.moveToPreviousToken())\n               return context;\n            \n            dataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            dataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n         \n         tokenCursor.findStartOfEvaluationContext();\n         \n         assocData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  declEnd.currentPosition()));\n         \n         context.add(assocData, dataType, numCommas);\n      }\n      \n      return context;\n      \n   }","id":25019,"modified_method":"private AutocompletionContext getAutocompletionContext()\n   {\n      AutocompletionContext context = new AutocompletionContext();\n      \n      String firstLine = input_.getText();\n      int row = input_.getCursorPosition().getRow();\n      \n      // trim to cursor position\n      firstLine = firstLine.substring(0, input_.getCursorPosition().getColumn());\n      \n      // Get the token at the cursor position\n      String token = firstLine.replaceAll(\".*[^a-zA-Z0-9._:$@-]\", \"\");\n      \n      // If we're completing an object within a string, assume it's a\n      // file-system completion\n      String firstLineStripped = StringUtil.stripBalancedQuotes(\n            StringUtil.stripRComment(firstLine));\n      \n      if (firstLineStripped.indexOf('\\'') != -1 || \n          firstLineStripped.indexOf('\"') != -1)\n         return getAutocompletionContextForFile(firstLine);\n      \n      // If this line starts with '```{', then we're completing chunk options\n      // pass the whole line as a token\n      if (firstLine.startsWith(\"```{\") || firstLine.startsWith(\"<<\"))\n         return new AutocompletionContext(firstLine, AutocompletionContext.TYPE_CHUNK);\n      \n      // If this line starts with a '?', assume it's a help query\n      if (firstLine.matches(\"^\\\\s*[?].*\"))\n         return new AutocompletionContext(token, AutocompletionContext.TYPE_HELP);\n      \n      // escape early for roxygen\n      if (firstLine.matches(\"\\\\s*#+'.*\"))\n         return new AutocompletionContext(\n               token, AutocompletionContext.TYPE_ROXYGEN);\n      \n      // If the token has '$' or '@', escape early as we'll be completing\n      // either from names or an overloaded `$` method\n      if (token.contains(\"$\") || token.contains(\"@\"))\n         addAutocompletionContextForDollar(context);\n      \n      // If the token has '::' or ':::', escape early as we'll be completing\n      // something from a namespace\n      if (token.contains(\"::\"))\n         addAutocompletionContextForNamespace(token, context);\n      \n      // Now strip the '$' and '@' post-hoc since they're not really part\n      // of the identifier\n      token = token.replaceAll(\".*[$@:]\", \"\");\n      context.setToken(token);\n      \n      // access to the R Code model\n      AceEditor editor = (AceEditor) docDisplay_;\n      if (editor == null)\n         return context;\n      \n      CodeModel codeModel = editor.getSession().getMode().getCodeModel();\n      \n      // We might need to grab content from further up in the document than\n      // the current cursor position -- so tokenize ahead.\n      codeModel.tokenizeUpToRow(row + 100);\n      \n      // Make a token cursor and place it at the first token previous\n      // to the cursor.\n      TokenCursor tokenCursor = codeModel.getTokenCursor();\n      if (!tokenCursor.moveToPosition(input_.getCursorPosition()))\n         return context;\n      \n      TokenCursor startCursor = tokenCursor.cloneCursor();\n      boolean startedOnEquals = tokenCursor.currentValue() == \"=\";\n      if (startCursor.currentType() == \"identifier\")\n         if (startCursor.moveToPreviousToken())\n            if (startCursor.currentValue() == \"=\")\n            {\n               startedOnEquals = true;\n               startCursor.moveToNextToken();\n            }\n      \n      // Find an opening '(' or '[' -- this provides the function or object\n      // for completion.\n      int initialNumCommas = 0;\n      if (tokenCursor.currentValue() != \"(\" && tokenCursor.currentValue() != \"[\")\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(new String[]{ \"[\", \"(\" }, true);\n         if (commaCount == -1)\n         {\n            commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n            if (commaCount == -1)\n               return context;\n            else\n               initialNumCommas = commaCount;\n         }\n         else\n         {\n            initialNumCommas = commaCount;\n         }\n      }\n      \n      // Figure out whether we're looking at '(', '[', or '[[',\n      // and place the token cursor on the first token preceding.\n      TokenCursor endOfDecl = tokenCursor.cloneCursor();\n      int initialDataType = AutocompletionContext.TYPE_UNKNOWN;\n      if (tokenCursor.currentValue() == \"(\")\n      {\n         // Don't produce function argument completions\n         // if the cursor is on, or after, an '='\n         if (!startedOnEquals)\n            initialDataType = AutocompletionContext.TYPE_FUNCTION;\n         else\n            initialDataType = AutocompletionContext.TYPE_UNKNOWN;\n         \n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n      }\n      else if (tokenCursor.currentValue() == \"[\")\n      {\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!endOfDecl.moveToPreviousToken())\n               return context;\n            \n            initialDataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            initialDataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n      }\n      \n      // Get the string marking the function or data\n      if (!tokenCursor.findStartOfEvaluationContext())\n         return context;\n      \n      // Try to get the function call string -- either there's\n      // an associated closing paren we can use, or we should just go up\n      // to the current cursor position\n      \n      // default case: use start cursor\n      Position endPos = startCursor.currentPosition();\n      endPos.setColumn(endPos.getColumn() + startCursor.currentValue().length());\n      \n      // try to look forward for closing paren\n      if (endOfDecl.currentValue() == \"(\")\n      {\n         TokenCursor closingParenCursor = endOfDecl.cloneCursor();\n         if (closingParenCursor.fwdToMatchingToken())\n         {\n            endPos = closingParenCursor.currentPosition();\n            endPos.setColumn(endPos.getColumn() + 1);\n         }\n      }\n      \n      // We can now set the function call string\n      context.setFunctionCallString(\n            editor.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(), endPos)).trim());\n      \n      String initialData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  endOfDecl.currentPosition())).trim();\n      \n      // And the first context\n      context.add(initialData, initialDataType, initialNumCommas);\n\n      // Get the rest of the single-bracket contexts for completions as well\n      String assocData;\n      int dataType;\n      int numCommas;\n      while (true)\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n         if (commaCount == -1)\n            break;\n         \n         numCommas = commaCount;\n         \n         TokenCursor declEnd = tokenCursor.cloneCursor();\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!declEnd.moveToPreviousToken())\n               return context;\n            \n            dataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            dataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n         \n         tokenCursor.findStartOfEvaluationContext();\n         \n         assocData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  declEnd.currentPosition())).trim();\n         \n         context.add(assocData, dataType, numCommas);\n      }\n      \n      return context;\n      \n   }","commit_id":"62e2906d15ebf585086ffb197b0ed3c81e4804d1","url":"https://github.com/rstudio/rstudio"},{"original_method":"public static String getToken(String string,\n                                 int pos,\n                                 String tokenRegex,\n                                 boolean expandForward)\n   {\n      int startPos = Math.max(0, pos - 1);\n      int endPos = Math.min(pos, string.length());\n      \n      while (startPos >= 0 &&\n            string.substring(startPos, startPos + 1).matches(tokenRegex))\n         --startPos;\n      \n      if (expandForward)\n         while (endPos < string.length() &&\n               string.substring(endPos, endPos + 1).matches(tokenRegex))\n            ++endPos;\n      \n      return string.substring(startPos + 1, endPos);\n   }","id":25020,"modified_method":"public static String getToken(String string,\n                                 int pos,\n                                 String tokenRegex,\n                                 boolean expandForward,\n                                 boolean backOverWhitespace)\n   {\n      if (backOverWhitespace)\n         while (string.substring(pos - 1, pos).matches(\"\\\\s\"))\n            --pos;\n      \n      int startPos = Math.max(0, pos - 1);\n      int endPos = Math.min(pos, string.length());\n      \n      while (startPos >= 0 &&\n            string.substring(startPos, startPos + 1).matches(tokenRegex))\n         --startPos;\n      \n      if (expandForward)\n         while (endPos < string.length() &&\n               string.substring(endPos, endPos + 1).matches(tokenRegex))\n            ++endPos;\n      \n      return string.substring(startPos + 1, endPos);\n   }","commit_id":"62e2906d15ebf585086ffb197b0ed3c81e4804d1","url":"https://github.com/rstudio/rstudio"},{"original_method":"public List<Role> filterGroupRoles(\n\t\t\tPermissionChecker permissionChecker, long groupId, List<Role> roles)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean isCompanyAdmin = permissionChecker.isCompanyAdmin();\n\t\tboolean isGroupOwner = permissionChecker.isGroupOwner(groupId);\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\tif (!isCompanyAdmin && !isGroupOwner &&\n\t\t\t!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, groupId, ActionKeys.ASSIGN_USER_ROLES) &&\n\t\t\t!OrganizationPermissionUtil.contains(\n\t\t\t\tpermissionChecker, group.getOrganizationId(),\n\t\t\t\tActionKeys.ASSIGN_USER_ROLES)) {\n\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tList<Role> filteredGroupRoles = ListUtil.copy(roles);\n\n\t\tIterator<Role> itr = filteredGroupRoles.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tRole groupRole = itr.next();\n\n\t\t\tString name = groupRole.getName();\n\n\t\t\tif (name.equals(RoleConstants.ORGANIZATION_USER) ||\n\t\t\t\tname.equals(RoleConstants.SITE_MEMBER)) {\n\n\t\t\t\titr.remove();\n\t\t\t}\n\t\t}\n\n\t\tif (isCompanyAdmin || isGroupOwner) {\n\t\t\treturn filteredGroupRoles;\n\t\t}\n\n\t\titr = filteredGroupRoles.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tRole groupRole = itr.next();\n\n\t\t\tString groupRoleName = groupRole.getName();\n\n\t\t\tif (groupRoleName.equals(\n\t\t\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR) ||\n\t\t\t\tgroupRoleName.equals(RoleConstants.ORGANIZATION_OWNER) ||\n\t\t\t\tgroupRoleName.equals(RoleConstants.SITE_ADMINISTRATOR) ||\n\t\t\t\tgroupRoleName.equals(RoleConstants.SITE_OWNER)) {\n\n\t\t\t\titr.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn filteredGroupRoles;\n\t}","id":25021,"modified_method":"public List<Role> filterGroupRoles(\n\t\t\tPermissionChecker permissionChecker, long groupId, List<Role> roles)\n\t\tthrows PortalException, SystemException {\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\tif (!permissionChecker.isCompanyAdmin() &&\n\t\t\t!permissionChecker.isGroupOwner(groupId) &&\n\t\t\t!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, groupId, ActionKeys.ASSIGN_USER_ROLES) &&\n\t\t\t!OrganizationPermissionUtil.contains(\n\t\t\t\tpermissionChecker, group.getOrganizationId(),\n\t\t\t\tActionKeys.ASSIGN_USER_ROLES)) {\n\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tList<Role> filteredGroupRoles = ListUtil.copy(roles);\n\n\t\tIterator<Role> itr = filteredGroupRoles.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tRole groupRole = itr.next();\n\n\t\t\tString name = groupRole.getName();\n\n\t\t\tif (name.equals(RoleConstants.ORGANIZATION_USER) ||\n\t\t\t\tname.equals(RoleConstants.SITE_MEMBER)) {\n\n\t\t\t\titr.remove();\n\t\t\t}\n\t\t}\n\n\t\tif (permissionChecker.isCompanyAdmin() ||\n\t\t\tpermissionChecker.isGroupOwner(groupId)) {\n\n\t\t\treturn filteredGroupRoles;\n\t\t}\n\n\t\titr = filteredGroupRoles.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tRole groupRole = itr.next();\n\n\t\t\tString groupRoleName = groupRole.getName();\n\n\t\t\tif (groupRoleName.equals(\n\t\t\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR) ||\n\t\t\t\tgroupRoleName.equals(RoleConstants.ORGANIZATION_OWNER) ||\n\t\t\t\tgroupRoleName.equals(RoleConstants.SITE_ADMINISTRATOR) ||\n\t\t\t\tgroupRoleName.equals(RoleConstants.SITE_OWNER)) {\n\n\t\t\t\titr.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn filteredGroupRoles;\n\t}","commit_id":"6987da2cc5cfd1f1b463e3b9e7bf261793eb50e5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<Group> getManageableGroups(long userId, String actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tList<Group> manageableGroups = groupLocalService.getManageableGroups(\n\t\t\tuserId);\n\n\t\tif (Validator.isNull(actionId) || permissionChecker.isCompanyAdmin()) {\n\t\t\treturn manageableGroups;\n\t\t}\n\n\t\tfor (Group group : manageableGroups) {\n\t\t\tif (!GroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, group.getGroupId(),actionId)) {\n\n\t\t\t\tmanageableGroups.remove(group);\n\t\t\t}\n\t\t}\n\n\t\treturn manageableGroups;\n\t}","id":25022,"modified_method":"public List<Group> getManageableGroups(long userId, String actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tif (permissionChecker.isCompanyAdmin()) {\n\t\t\treturn groupLocalService.search(\n\t\t\t\tpermissionChecker.getCompanyId(), null, null, null,\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\t\t}\n\n\t\tList<Group> manageableGroups = groupLocalService.getManageableGroups(\n\t\t\tuserId);\n\n\t\tif (Validator.isNull(actionId) || permissionChecker.isCompanyAdmin()) {\n\t\t\treturn manageableGroups;\n\t\t}\n\n\t\tfor (Group group : manageableGroups) {\n\t\t\tif (!GroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, group.getGroupId(),actionId)) {\n\n\t\t\t\tmanageableGroups.remove(group);\n\t\t\t}\n\t\t}\n\n\t\treturn manageableGroups;\n\t}","commit_id":"0dd649e978a63467b4e9cccdc0120bcb1eeda2aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<Organization> getManageableOrganizations(\n\t\t\tlong userId, String actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tif (Validator.isNull(actionId) || permissionChecker.isCompanyAdmin()) {\n\t\t\treturn organizationLocalService.getManageableOrganizations(userId);\n\t\t}\n\n\t\tList<Organization> manageableOrganizations =\n\t\t\tnew UniqueList<Organization>();\n\n\t\tList<Organization> userOrganizations = userPersistence.getOrganizations(\n\t\t\tuserId);\n\n\t\tfor (Organization userOrganization : userOrganizations) {\n\t\t\tif (OrganizationPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, userOrganization.getOrganizationId(),\n\t\t\t\t\tactionId)) {\n\n\t\t\t\tmanageableOrganizations.add(userOrganization);\n\t\t\t}\n\n\t\t\tif (OrganizationPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, userOrganization.getOrganizationId(),\n\t\t\t\t\tActionKeys.MANAGE_SUBORGANIZATIONS)) {\n\n\t\t\t\tmanageableOrganizations.addAll(\n\t\t\t\t\tuserOrganization.getSuborganizations());\n\t\t\t}\n\t\t}\n\n\t\treturn manageableOrganizations;\n\t}","id":25023,"modified_method":"public List<Organization> getManageableOrganizations(\n\t\t\tlong userId, String actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tif (permissionChecker.isCompanyAdmin()) {\n\t\t\treturn organizationLocalService.search(\n\t\t\t\tpermissionChecker.getCompanyId(), 0, null, null, null, null,\n\t\t\t\tnull, QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\t\t}\n\n\t\tif (Validator.isNull(actionId)) {\n\t\t\treturn organizationLocalService.getManageableOrganizations(userId);\n\t\t}\n\n\t\tList<Organization> manageableOrganizations =\n\t\t\tnew UniqueList<Organization>();\n\n\t\tList<Organization> userOrganizations = userPersistence.getOrganizations(\n\t\t\tuserId);\n\n\t\tfor (Organization userOrganization : userOrganizations) {\n\t\t\tif (OrganizationPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, userOrganization.getOrganizationId(),\n\t\t\t\t\tactionId)) {\n\n\t\t\t\tmanageableOrganizations.add(userOrganization);\n\t\t\t}\n\n\t\t\tif (OrganizationPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, userOrganization.getOrganizationId(),\n\t\t\t\t\tActionKeys.MANAGE_SUBORGANIZATIONS)) {\n\n\t\t\t\tmanageableOrganizations.addAll(\n\t\t\t\t\tuserOrganization.getSuborganizations());\n\t\t\t}\n\t\t}\n\n\t\treturn manageableOrganizations;\n\t}","commit_id":"0dd649e978a63467b4e9cccdc0120bcb1eeda2aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<Role> filterGroupRoles(\n\t\t\tPermissionChecker permissionChecker, long groupId, List<Role> roles)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<Role> filteredGroupRoles = ListUtil.copy(roles);\n\n\t\tIterator<Role> itr = filteredGroupRoles.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tRole groupRole = itr.next();\n\n\t\t\tString name = groupRole.getName();\n\n\t\t\tif (name.equals(RoleConstants.ORGANIZATION_USER) ||\n\t\t\t\tname.equals(RoleConstants.SITE_MEMBER)) {\n\n\t\t\t\titr.remove();\n\t\t\t}\n\t\t}\n\n\t\tif (permissionChecker.isCompanyAdmin() ||\n\t\t\tpermissionChecker.isGroupOwner(groupId)) {\n\n\t\t\treturn filteredGroupRoles;\n\t\t}\n\n\t\titr = filteredGroupRoles.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tRole groupRole = itr.next();\n\n\t\t\tString groupRoleName = groupRole.getName();\n\n\t\t\tif (groupRoleName.equals(\n\t\t\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR) ||\n\t\t\t\tgroupRoleName.equals(RoleConstants.ORGANIZATION_OWNER) ||\n\t\t\t\tgroupRoleName.equals(RoleConstants.SITE_ADMINISTRATOR) ||\n\t\t\t\tgroupRoleName.equals(RoleConstants.SITE_OWNER) ||\n\t\t\t\t!GroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, groupId, ActionKeys.ASSIGN_USER_ROLES)) {\n\n\t\t\t\titr.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn filteredGroupRoles;\n\t}","id":25024,"modified_method":"public List<Role> filterGroupRoles(\n\t\t\tPermissionChecker permissionChecker, long groupId, List<Role> roles)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean companyAdmin = permissionChecker.isCompanyAdmin();\n\t\tboolean groupOwner = permissionChecker.isGroupOwner(groupId);\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\tif (!companyAdmin && !groupOwner &&\n\t\t\t!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, groupId, ActionKeys.ASSIGN_USER_ROLES) &&\n\t\t\t!OrganizationPermissionUtil.contains(\n\t\t\t\tpermissionChecker, group.getOrganizationId(),\n\t\t\t\tActionKeys.ASSIGN_USER_ROLES)) {\n\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tList<Role> filteredGroupRoles = ListUtil.copy(roles);\n\n\t\tIterator<Role> itr = filteredGroupRoles.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tRole groupRole = itr.next();\n\n\t\t\tString name = groupRole.getName();\n\n\t\t\tif (name.equals(RoleConstants.ORGANIZATION_USER) ||\n\t\t\t\tname.equals(RoleConstants.SITE_MEMBER)) {\n\n\t\t\t\titr.remove();\n\t\t\t}\n\t\t}\n\n\t\tif (companyAdmin || groupOwner) {\n\t\t\treturn filteredGroupRoles;\n\t\t}\n\n\t\titr = filteredGroupRoles.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tRole groupRole = itr.next();\n\n\t\t\tString groupRoleName = groupRole.getName();\n\n\t\t\tif (groupRoleName.equals(\n\t\t\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR) ||\n\t\t\t\tgroupRoleName.equals(RoleConstants.ORGANIZATION_OWNER) ||\n\t\t\t\tgroupRoleName.equals(RoleConstants.SITE_ADMINISTRATOR) ||\n\t\t\t\tgroupRoleName.equals(RoleConstants.SITE_OWNER)) {\n\n\t\t\t\titr.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn filteredGroupRoles;\n\t}","commit_id":"4c5a8b3a5d0a4ae702e528ebbd25e5b66aa79f03","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void layoutStatusIcons() {\n      int adHeight = myAdvertiser.getAdComponent().getPreferredSize().height;\n      Dimension buttonSize = adHeight > 0 || !mySortingLabel.isVisible() ? new Dimension(0, 0) : new Dimension(\n        AllIcons.Ide.LookupRelevance.getIconWidth(), AllIcons.Ide.LookupRelevance.getIconHeight());\n      myScrollBarIncreaseButton.setPreferredSize(buttonSize);\n      myScrollBarIncreaseButton.setMinimumSize(buttonSize);\n      myScrollBarIncreaseButton.setMaximumSize(buttonSize);\n      JScrollBar vScrollBar = myScrollPane.getVerticalScrollBar();\n      vScrollBar.revalidate();\n      vScrollBar.repaint();\n      \n      final Dimension iconSize = myProcessIcon.getPreferredSize();\n      myIconPanel.setBounds(getWidth() - iconSize.width - (vScrollBar.isVisible() ? vScrollBar.getWidth() : 0), 0, iconSize.width,\n                            iconSize.height);\n\n      final Dimension sortSize = mySortingLabel.getPreferredSize();\n      final int sortWidth = vScrollBar.isVisible() ? vScrollBar.getWidth() : sortSize.width;\n      final int sortHeight = Math.max(sortSize.height, adHeight);\n      mySortingLabel.setBounds(getWidth() - sortWidth, getHeight() - sortHeight, sortSize.width, sortHeight);\n    }","id":25025,"modified_method":"private void layoutStatusIcons() {\n      int adHeight = myAdvertiser.getAdComponent().getPreferredSize().height;\n      int bottomOffset = adHeight > 0 || !mySortingLabel.isVisible() ? 0 : AllIcons.Ide.LookupRelevance.getIconHeight();\n      JScrollBar vScrollBar = myScrollPane.getVerticalScrollBar();\n      ScrollBottomBorder.update(vScrollBar, bottomOffset);\n\n      final Dimension iconSize = myProcessIcon.getPreferredSize();\n      myIconPanel.setBounds(getWidth() - iconSize.width - (vScrollBar.isVisible() ? vScrollBar.getWidth() : 0), 0, iconSize.width,\n                            iconSize.height);\n\n      final Dimension sortSize = mySortingLabel.getPreferredSize();\n      final int sortWidth = vScrollBar.isVisible() ? vScrollBar.getWidth() : sortSize.width;\n      final int sortHeight = Math.max(sortSize.height, adHeight);\n      mySortingLabel.setBounds(getWidth() - sortWidth, getHeight() - sortHeight, sortSize.width, sortHeight);\n    }","commit_id":"3868da720e91b02ebe3c9bf623d59d9dcac7f27d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"LookupUi(@NotNull LookupImpl lookup, Advertiser advertiser, JBList list, Project project) {\n    myLookup = lookup;\n    myAdvertiser = advertiser;\n    myList = list;\n    myProject = project;\n\n    myIconPanel.setVisible(false);\n    myIconPanel.setBackground(Color.LIGHT_GRAY);\n    myIconPanel.add(myProcessIcon);\n\n    JComponent adComponent = advertiser.getAdComponent();\n    adComponent.setBorder(new EmptyBorder(0, 1, 1, 2 + AllIcons.Ide.LookupRelevance.getIconWidth()));\n    myLayeredPane.mainPanel.add(adComponent, BorderLayout.SOUTH);\n\n    myScrollBarIncreaseButton = new JButton();\n    myScrollBarIncreaseButton.setFocusable(false);\n    myScrollBarIncreaseButton.setRequestFocusEnabled(false);\n\n    myScrollPane = new JBScrollPane(lookup.getList());\n    myScrollPane.setViewportBorder(JBUI.Borders.empty());\n    myScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    myScrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(13, -1));\n    myScrollPane.getVerticalScrollBar().setUI(new ButtonlessScrollBarUI() {\n      @Override\n      protected JButton createIncreaseButton(int orientation) {\n        return myScrollBarIncreaseButton;\n      }\n    });\n    lookup.getComponent().add(myLayeredPane, BorderLayout.CENTER);\n\n    //IDEA-82111\n    fixMouseCheaters();\n\n    myLayeredPane.mainPanel.add(myScrollPane, BorderLayout.CENTER);\n    myScrollPane.setBorder(null);\n\n    mySortingLabel.setBorder(new LineBorder(new JBColor(Color.LIGHT_GRAY, JBColor.background())));\n    mySortingLabel.setOpaque(true);\n    new ChangeLookupSorting().installOn(mySortingLabel);\n    updateSorting();\n    myModalityState = ModalityState.stateForComponent(lookup.getTopLevelEditor().getComponent());\n\n    addListeners();\n\n    updateScrollbarVisibility();\n\n    Disposer.register(lookup, myProcessIcon);\n    Disposer.register(lookup, myHintAlarm);\n  }","id":25026,"modified_method":"LookupUi(@NotNull LookupImpl lookup, Advertiser advertiser, JBList list, Project project) {\n    myLookup = lookup;\n    myAdvertiser = advertiser;\n    myList = list;\n    myProject = project;\n\n    myIconPanel.setVisible(false);\n    myIconPanel.setBackground(Color.LIGHT_GRAY);\n    myIconPanel.add(myProcessIcon);\n\n    JComponent adComponent = advertiser.getAdComponent();\n    adComponent.setBorder(new EmptyBorder(0, 1, 1, 2 + AllIcons.Ide.LookupRelevance.getIconWidth()));\n    myLayeredPane.mainPanel.add(adComponent, BorderLayout.SOUTH);\n\n    myScrollPane = ScrollPaneFactory.createScrollPane(lookup.getList(), true);\n    myScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    lookup.getComponent().add(myLayeredPane, BorderLayout.CENTER);\n\n    //IDEA-82111\n    fixMouseCheaters();\n\n    myLayeredPane.mainPanel.add(myScrollPane, BorderLayout.CENTER);\n\n    mySortingLabel.setBorder(new LineBorder(new JBColor(Color.LIGHT_GRAY, JBColor.background())));\n    mySortingLabel.setOpaque(true);\n    new ChangeLookupSorting().installOn(mySortingLabel);\n    updateSorting();\n    myModalityState = ModalityState.stateForComponent(lookup.getTopLevelEditor().getComponent());\n\n    addListeners();\n\n    updateScrollbarVisibility();\n\n    Disposer.register(lookup, myProcessIcon);\n    Disposer.register(lookup, myHintAlarm);\n  }","commit_id":"3868da720e91b02ebe3c9bf623d59d9dcac7f27d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void apply() throws ConfigurationException {\n    GeneralSettings settings = GeneralSettings.getInstance();\n\n    settings.setBrowserPath(alternativeBrowserPathField.getText());\n    settings.setUseDefaultBrowser(useSystemDefaultBrowser.isSelected());\n    settings.setConfirmExtractFiles(confirmExtractFiles.isSelected());\n\n    if (!modifiedBrowsers.isEmpty()) {\n      modifiedBrowsers.forEachEntry(new TObjectObjectProcedure<ConfigurableWebBrowser, ConfigurableWebBrowser>() {\n        @Override\n        public boolean execute(ConfigurableWebBrowser info, ConfigurableWebBrowser newInfo) {\n          info.setName(newInfo.getName());\n          info.setFamily(newInfo.getFamily());\n          info.setPath(newInfo.getPath());\n          info.setActive(newInfo.isActive());\n          info.setSpecificSettings(newInfo.getSpecificSettings());\n          return true;\n        }\n      });\n    }\n  }","id":25027,"modified_method":"public void apply() throws ConfigurationException {\n    GeneralSettings settings = GeneralSettings.getInstance();\n\n    settings.setBrowserPath(alternativeBrowserPathField.getText());\n    settings.setUseDefaultBrowser(useSystemDefaultBrowser.isSelected());\n    settings.setConfirmExtractFiles(confirmExtractFiles.isSelected());\n\n    WebBrowserManager.getInstance().setList(browsersEditor.apply());\n  }","commit_id":"871d53d432d41ae8852bc6f0aa3161fbf45a26ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isModified() {\n    GeneralSettings settings = GeneralSettings.getInstance();\n    boolean isModified = !Comparing.strEqual(settings.getBrowserPath(), alternativeBrowserPathField.getText());\n    isModified |= settings.isUseDefaultBrowser() != useSystemDefaultBrowser.isSelected();\n    isModified |= settings.isConfirmExtractFiles() != confirmExtractFiles.isSelected();\n\n    if (isModified) {\n      return true;\n    }\n\n    if (!modifiedBrowsers.isEmpty()) {\n      for (Map.Entry<ConfigurableWebBrowser, ConfigurableWebBrowser> entry : modifiedBrowsers.entrySet()) {\n        if (entry.getValue().isChanged(entry.getKey())) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }","id":25028,"modified_method":"public boolean isModified() {\n    GeneralSettings settings = GeneralSettings.getInstance();\n    if (!Comparing.strEqual(settings.getBrowserPath(), alternativeBrowserPathField.getText()) ||\n        settings.isUseDefaultBrowser() != useSystemDefaultBrowser.isSelected() ||\n        settings.isConfirmExtractFiles() != confirmExtractFiles.isSelected()) {\n      return true;\n    }\n\n    return browsersEditor.isModified(WebBrowserManager.getInstance().getList());\n  }","commit_id":"871d53d432d41ae8852bc6f0aa3161fbf45a26ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createUIComponents() {\n    ColumnInfo[] columns = {new ColumnInfo<ConfigurableWebBrowser, Boolean>(\"\") {\n      @Override\n      public Class getColumnClass() {\n        return Boolean.class;\n      }\n\n      @Override\n      public Boolean valueOf(ConfigurableWebBrowser info) {\n        return getEffective(info).isActive();\n      }\n\n      @Override\n      public boolean isCellEditable(ConfigurableWebBrowser info) {\n        return true;\n      }\n\n      @Override\n      public void setValue(ConfigurableWebBrowser info, Boolean value) {\n        if (value != info.isActive()) {\n          getMutable(info).setActive(value);\n        }\n      }\n    }, new ColumnInfo<ConfigurableWebBrowser, String>(\"Name\") {\n      @Override\n      public String valueOf(ConfigurableWebBrowser info) {\n        return getEffective(info).getName();\n      }\n\n      @Override\n      public boolean isCellEditable(ConfigurableWebBrowser info) {\n        return true;\n      }\n\n      @Override\n      public void setValue(ConfigurableWebBrowser info, String value) {\n        if (!value.equals(info.getName())) {\n          getMutable(info).setName(value);\n        }\n      }\n    }, new ColumnInfo<ConfigurableWebBrowser, BrowserFamily>(\"Family\") {\n      @Override\n      public Class getColumnClass() {\n        return BrowserFamily.class;\n      }\n\n      @Override\n      public BrowserFamily valueOf(ConfigurableWebBrowser info) {\n        return getEffective(info).getFamily();\n      }\n\n      @Override\n      public boolean isCellEditable(ConfigurableWebBrowser info) {\n        return true;\n      }\n\n      @Override\n      public void setValue(ConfigurableWebBrowser info, BrowserFamily value) {\n        if (value != info.getFamily()) {\n          getMutable(info).setFamily(value);\n        }\n      }\n\n      @Nullable\n      @Override\n      public TableCellRenderer getRenderer(ConfigurableWebBrowser info) {\n        return IconTableCellRenderer.ICONABLE;\n      }\n\n      @Nullable\n      @Override\n      public TableCellEditor getEditor(ConfigurableWebBrowser o) {\n        return ComboBoxTableCellEditor.INSTANCE;\n      }\n    }, new ColumnInfo<ConfigurableWebBrowser, String>(\"Path\") {\n      @Override\n      public String valueOf(ConfigurableWebBrowser info) {\n        return getEffective(info).getPath();\n      }\n\n      @Override\n      public boolean isCellEditable(ConfigurableWebBrowser info) {\n        return true;\n      }\n\n      @Override\n      public void setValue(ConfigurableWebBrowser info, String value) {\n        if (!value.equals(info.getPath())) {\n          getMutable(info).setPath(StringUtil.nullize(value, true));\n        }\n      }\n\n      @Nullable\n      @Override\n      public TableCellEditor getEditor(ConfigurableWebBrowser info) {\n        return new LocalPathCellEditor(null).fileChooserDescriptor(appFileChooserDescriptor);\n      }\n    }};\n    ListTableModel<ConfigurableWebBrowser> tableModel = new ListTableModel<ConfigurableWebBrowser>(columns, new ArrayList<ConfigurableWebBrowser>(WebBrowserManager.getInstance().getList()));\n    TableView<ConfigurableWebBrowser> table = new TableView<ConfigurableWebBrowser>(tableModel);\n    table.setStriped(true);\n    new TableSpeedSearch(table);\n    TableUtil.setupCheckboxColumn(table.getColumnModel().getColumn(0));\n\n    browsersTable = ToolbarDecorator.createDecorator(table).createPanel();\n  }","id":25029,"modified_method":"private void createUIComponents() {\n    browsersEditor = new TableModelEditor<ConfigurableWebBrowser>(WebBrowserManager.getInstance().getList(), new ColumnInfo[]{new EditableColumnInfo<ConfigurableWebBrowser, Boolean>() {\n      @Override\n      public Class getColumnClass() {\n        return Boolean.class;\n      }\n\n      @Override\n      public Boolean valueOf(ConfigurableWebBrowser item) {\n        return browsersEditor.getEffective(item).isActive();\n      }\n\n      @Override\n      public void setValue(ConfigurableWebBrowser item, Boolean value) {\n        if (value != item.isActive()) {\n          browsersEditor.getMutable(item).setActive(value);\n        }\n      }\n    }, new EditableColumnInfo<ConfigurableWebBrowser, String>(\"Name\") {\n      @Override\n      public String valueOf(ConfigurableWebBrowser item) {\n        return browsersEditor.getEffective(item).getName();\n      }\n\n      @Override\n      public void setValue(ConfigurableWebBrowser item, String value) {\n        if (!value.equals(item.getName())) {\n          browsersEditor.getMutable(item).setName(value);\n        }\n      }\n    }, new EditableColumnInfo<ConfigurableWebBrowser, BrowserFamily>(\"Family\") {\n      @Override\n      public Class getColumnClass() {\n        return BrowserFamily.class;\n      }\n\n      @Override\n      public BrowserFamily valueOf(ConfigurableWebBrowser item) {\n        return browsersEditor.getEffective(item).getFamily();\n      }\n\n      @Override\n      public void setValue(ConfigurableWebBrowser item, BrowserFamily value) {\n        if (value != item.getFamily()) {\n          browsersEditor.getMutable(item).setFamily(value);\n        }\n      }\n\n      @Nullable\n      @Override\n      public TableCellRenderer getRenderer(ConfigurableWebBrowser item) {\n        return IconTableCellRenderer.ICONABLE;\n      }\n\n      @Nullable\n      @Override\n      public TableCellEditor getEditor(ConfigurableWebBrowser item) {\n        return ComboBoxTableCellEditor.INSTANCE;\n      }\n    }, new EditableColumnInfo<ConfigurableWebBrowser, String>(\"Path\") {\n      @Override\n      public String valueOf(ConfigurableWebBrowser info) {\n        return browsersEditor.getEffective(info).getPath();\n      }\n\n      @Override\n      public void setValue(ConfigurableWebBrowser item, String value) {\n        String normalizedValue = StringUtil.nullize(value, true);\n        if (!Comparing.equal(normalizedValue, item.getPath())) {\n          browsersEditor.getMutable(item).setPath(normalizedValue);\n        }\n      }\n\n      @Nullable\n      @Override\n      public TableCellEditor getEditor(ConfigurableWebBrowser item) {\n        return new LocalPathCellEditor().fileChooserDescriptor(appFileChooserDescriptor);\n      }\n    }}, new Function<ConfigurableWebBrowser, ConfigurableWebBrowser>() {\n      @Override\n      public ConfigurableWebBrowser fun(ConfigurableWebBrowser browser) {\n        return new ConfigurableWebBrowser(browser.getId(), browser.getFamily(), browser.getName(), browser.getPath(), browser.isActive(), browser.getSpecificSettings());\n      }\n    }, ConfigurableWebBrowser.class);\n    browsersTable = browsersEditor.createComponent();\n  }","commit_id":"871d53d432d41ae8852bc6f0aa3161fbf45a26ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reset() {\n    GeneralSettings settings = GeneralSettings.getInstance();\n    alternativeBrowserPathField.setText(settings.getBrowserPath());\n\n    if (settings.isUseDefaultBrowser()) {\n      useSystemDefaultBrowser.setSelected(true);\n    }\n    else {\n      useAlternativeBrowser.setSelected(true);\n    }\n    confirmExtractFiles.setSelected(settings.isConfirmExtractFiles());\n\n    updateBrowserField();\n\n    modifiedBrowsers.clear();\n  }","id":25030,"modified_method":"public void reset() {\n    GeneralSettings settings = GeneralSettings.getInstance();\n    alternativeBrowserPathField.setText(settings.getBrowserPath());\n\n    if (settings.isUseDefaultBrowser()) {\n      useSystemDefaultBrowser.setSelected(true);\n    }\n    else {\n      useAlternativeBrowser.setSelected(true);\n    }\n    confirmExtractFiles.setSelected(settings.isConfirmExtractFiles());\n\n    updateBrowserField();\n\n    browsersEditor.clear();\n  }","commit_id":"871d53d432d41ae8852bc6f0aa3161fbf45a26ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected AnAction[] computeChildren(@NotNull ActionManager manager) {\n    CheckoutProvider[] providers = Extensions.getExtensions(CheckoutProvider.EXTENSION_POINT_NAME);\n    if (providers.length == 0) {\n      return EMPTY_ARRAY;\n    }\n\n    Arrays.sort(providers, new CheckoutProvider.CheckoutProviderComparator());\n    AnAction[] children = new AnAction[providers.length];\n    for (int i = 0; i < providers.length; i++) {\n      children[i] = new CheckoutAction(providers[i]);\n    }\n    return children;\n  }","id":25031,"modified_method":"@NotNull\n  @Override\n  protected AnAction[] computeChildren(@NotNull ActionManager manager) {\n    CheckoutProvider[] providers = CheckoutProvider.EXTENSION_POINT_NAME.getExtensions();\n    if (providers.length == 0) {\n      return EMPTY_ARRAY;\n    }\n\n    Arrays.sort(providers, new CheckoutProvider.CheckoutProviderComparator());\n    AnAction[] children = new AnAction[providers.length];\n    for (int i = 0; i < providers.length; i++) {\n      children[i] = new CheckoutAction(providers[i]);\n    }\n    return children;\n  }","commit_id":"871d53d432d41ae8852bc6f0aa3161fbf45a26ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  /**\n   * @see com.intellij.util.ui.table.ComboBoxTableCellEditor\n   */\n  public TableCellEditor getEditor(Item o) {\n    return null;\n  }","id":25032,"modified_method":"@Nullable\n  /**\n   * @see com.intellij.util.ui.table.ComboBoxTableCellEditor\n   */\n  public TableCellEditor getEditor(Item item) {\n    return null;\n  }","commit_id":"871d53d432d41ae8852bc6f0aa3161fbf45a26ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setFamily(@NotNull BrowsersConfiguration.BrowserFamily value) {\n    family = value;\n  }","id":25033,"modified_method":"public void setFamily(@NotNull BrowserFamily value) {\n    family = value;\n  }","commit_id":"871d53d432d41ae8852bc6f0aa3161fbf45a26ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConfigurableWebBrowser(@NotNull UUID id,\n                                @NotNull BrowsersConfiguration.BrowserFamily family,\n                                @NotNull String name,\n                                @Nullable String path,\n                                boolean active,\n                                @Nullable BrowserSpecificSettings specificSettings) {\n    super(family, name);\n\n    this.id = id;\n    this.path = path;\n    this.active = active;\n    this.specificSettings = specificSettings;\n  }","id":25034,"modified_method":"public ConfigurableWebBrowser(@NotNull UUID id,\n                                @NotNull BrowserFamily family,\n                                @NotNull String name,\n                                @Nullable String path,\n                                boolean active,\n                                @Nullable BrowserSpecificSettings specificSettings) {\n    super(family, name);\n\n    this.id = id;\n    this.path = path;\n    this.active = active;\n    this.specificSettings = specificSettings;\n  }","commit_id":"871d53d432d41ae8852bc6f0aa3161fbf45a26ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConfigurableWebBrowser(@NotNull UUID id, @NotNull BrowsersConfiguration.BrowserFamily family) {\n    this(id, family, family.getName(), family.getExecutionPath(), true, family.createBrowserSpecificSettings());\n  }","id":25035,"modified_method":"public ConfigurableWebBrowser(@NotNull UUID id, @NotNull BrowserFamily family) {\n    this(id, family, family.getName(), family.getExecutionPath(), true, family.createBrowserSpecificSettings());\n  }","commit_id":"871d53d432d41ae8852bc6f0aa3161fbf45a26ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected AnAction[] computeChildren(@NotNull ActionManager manager) {\n    List<AnAction> actionsByEP = new SmartList<AnAction>();\n    for (OpenInBrowserActionProducer actionProducer : OpenInBrowserActionProducer.EP_NAME.getExtensions()) {\n      actionsByEP.addAll(actionProducer.getActions());\n    }\n\n    List<WebBrowser> browsers = WebBrowserManager.getInstance().getBrowsers();\n    boolean addDefaultBrowser = isPopup();\n    int offset = addDefaultBrowser ? 1 : 0;\n    AnAction[] actions = new AnAction[browsers.size() + offset + actionsByEP.size()];\n\n    if (addDefaultBrowser) {\n      if (myDefaultBrowserAction == null) {\n        myDefaultBrowserAction = new OpenFileInDefaultBrowserAction();\n        myDefaultBrowserAction.getTemplatePresentation().setText(\"Default\");\n        myDefaultBrowserAction.getTemplatePresentation().setIcon(AllIcons.Nodes.PpWeb);\n      }\n      actions[0] = myDefaultBrowserAction;\n    }\n\n    for (int i = 0, size = browsers.size(); i < size; i++) {\n      actions[i + offset] = new BaseWebBrowserAction(browsers.get(i));\n    }\n\n    ArrayUtil.copy(actionsByEP, actions, offset + browsers.size());\n\n    return actions;\n  }","id":25036,"modified_method":"@NotNull\n  @Override\n  protected final CachedValueProvider<AnAction[]> createChildrenProvider(@NotNull final ActionManager actionManager) {\n    return new CachedValueProvider<AnAction[]>() {\n      @Nullable\n      @Override\n      public Result<AnAction[]> compute() {\n        List<AnAction> actionsByEP = new SmartList<AnAction>();\n        for (OpenInBrowserActionProducer actionProducer : OpenInBrowserActionProducer.EP_NAME.getExtensions()) {\n          actionsByEP.addAll(actionProducer.getActions());\n        }\n\n        List<WebBrowser> browsers = WebBrowserManager.getInstance().getBrowsers();\n        boolean addDefaultBrowser = isPopup();\n        int offset = addDefaultBrowser ? 1 : 0;\n        AnAction[] actions = new AnAction[browsers.size() + offset + actionsByEP.size()];\n\n        if (addDefaultBrowser) {\n          if (myDefaultBrowserAction == null) {\n            myDefaultBrowserAction = new OpenFileInDefaultBrowserAction();\n            myDefaultBrowserAction.getTemplatePresentation().setText(\"Default\");\n            myDefaultBrowserAction.getTemplatePresentation().setIcon(AllIcons.Nodes.PpWeb);\n          }\n          actions[0] = myDefaultBrowserAction;\n        }\n\n        for (int i = 0, size = browsers.size(); i < size; i++) {\n          actions[i + offset] = new BaseWebBrowserAction(browsers.get(i));\n        }\n\n        ArrayUtil.copy(actionsByEP, actions, offset + browsers.size());\n\n        return Result.create(actions, WebBrowserManager.getInstance());\n      }\n    };\n  }","commit_id":"871d53d432d41ae8852bc6f0aa3161fbf45a26ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void loadState(Element element) {\n    List<ConfigurableWebBrowser> list = new ArrayList<ConfigurableWebBrowser>();\n    for (Element child : element.getChildren(\"browser\")) {\n      BrowserFamily family = readFamily(child.getAttributeValue(\"family\"));\n      if (family == null) {\n        continue;\n      }\n\n      UUID id = readId(child.getAttributeValue(\"id\"), family, list);\n      if (id == null) {\n        continue;\n      }\n\n      Element settingsElement = child.getChild(\"settings\");\n      BrowserSpecificSettings specificSettings = settingsElement == null ? null : family.createBrowserSpecificSettings();\n      if (specificSettings != null) {\n        try {\n          XmlSerializer.deserializeInto(specificSettings, settingsElement);\n        }\n        catch (Exception e) {\n          LOG.warn(e);\n        }\n      }\n\n      String activeValue = child.getAttributeValue(\"active\");\n      list.add(new ConfigurableWebBrowser(id,\n                                          family,\n                                          StringUtil.notNullize(child.getAttributeValue(\"name\"), family.getName()),\n                                          StringUtil.nullize(child.getAttributeValue(\"path\"), true),\n                                          activeValue == null || Boolean.parseBoolean(activeValue),\n                                          specificSettings));\n    }\n\n    browsers.clear();\n    browsers.addAll(list);\n  }","id":25037,"modified_method":"@Override\n  public void loadState(Element element) {\n    List<ConfigurableWebBrowser> list = new ArrayList<ConfigurableWebBrowser>();\n    for (Element child : element.getChildren(\"browser\")) {\n      BrowserFamily family = readFamily(child.getAttributeValue(\"family\"));\n      if (family == null) {\n        continue;\n      }\n\n      UUID id = readId(child.getAttributeValue(\"id\"), family, list);\n      if (id == null) {\n        continue;\n      }\n\n      Element settingsElement = child.getChild(\"settings\");\n      BrowserSpecificSettings specificSettings = settingsElement == null ? null : family.createBrowserSpecificSettings();\n      if (specificSettings != null) {\n        try {\n          XmlSerializer.deserializeInto(specificSettings, settingsElement);\n        }\n        catch (Exception e) {\n          LOG.warn(e);\n        }\n      }\n\n      String activeValue = child.getAttributeValue(\"active\");\n      list.add(new ConfigurableWebBrowser(id,\n                                          family,\n                                          StringUtil.notNullize(child.getAttributeValue(\"name\"), family.getName()),\n                                          StringUtil.nullize(child.getAttributeValue(\"path\"), true),\n                                          activeValue == null || Boolean.parseBoolean(activeValue),\n                                          specificSettings));\n    }\n\n    setList(list);\n  }","commit_id":"871d53d432d41ae8852bc6f0aa3161fbf45a26ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"List<AutoCompletionListItem> getList() {\n        return Collections.unmodifiableList(list);\n    }","id":25038,"modified_method":"ArrayList<AutoCompletionListItem> getList() {\n        return list;\n    }","commit_id":"b0dcf05f44ee50852b69f2b6b28debb003f25961","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Populates the an {@see AutoCompletionList} with the currently cached\n     * tag keys\n     *\n     * @param list the list to populate\n     * @param append true to add the keys to the list; false, to replace the keys\n     * in the list by the keys in the cache\n     */\n    public void populateWithKeys(AutoCompletionList list) {\n        list.add(getPresetKeys(), AutoCompletionItemPritority.IS_IN_STANDARD);\n        list.add(getDataKeys(), AutoCompletionItemPritority.IS_IN_DATASET);\n    }","id":25039,"modified_method":"/**\n     * Populates the an {@see AutoCompletionList} with the currently cached\n     * tag keys\n     *\n     * @param list the list to populate\n     */\n    public void populateWithKeys(AutoCompletionList list) {\n        list.add(getPresetKeys(), AutoCompletionItemPritority.IS_IN_STANDARD);\n        list.add(getDataKeys(), AutoCompletionItemPritority.IS_IN_DATASET);\n    }","commit_id":"b0dcf05f44ee50852b69f2b6b28debb003f25961","url":"https://github.com/openstreetmap/josm"},{"original_method":"public List<AutoCompletionListItem> getValues(String key) {\n        AutoCompletionList list = new AutoCompletionList();\n        populateWithTagValues(list, key);\n        return new ArrayList<AutoCompletionListItem>(list.getList());\n    }","id":25040,"modified_method":"/**\n     * Returns the currently cached tag values for a given tag key.\n     * @param key the tag key\n     * @return a list of tag values\n     */\n    public List<AutoCompletionListItem> getValues(String key) {\n        return getValues(Arrays.asList(key));\n    }","commit_id":"b0dcf05f44ee50852b69f2b6b28debb003f25961","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Populates the an {@see AutoCompletionList} with the currently cached\n     * values for a tag\n     *\n     * @param list the list to populate\n     * @param key the tag key\n     * @param append true to add the values to the list; false, to replace the values\n     * in the list by the tag values\n     */\n    public void populateWithTagValues(AutoCompletionList list, String key) {\n        list.add(getPresetValues(key), AutoCompletionItemPritority.IS_IN_STANDARD);\n        list.add(getDataValues(key), AutoCompletionItemPritority.IS_IN_DATASET);\n    }","id":25041,"modified_method":"/**\n     * Populates the an {@see AutoCompletionList} with the currently cached\n     * values for a tag\n     *\n     * @param list the list to populate\n     * @param key the tag key\n     */\n    public void populateWithTagValues(AutoCompletionList list, String key) {\n        populateWithTagValues(list, Arrays.asList(key));\n    }","commit_id":"b0dcf05f44ee50852b69f2b6b28debb003f25961","url":"https://github.com/openstreetmap/josm"},{"original_method":"public List<AutoCompletionListItem> getKeys() {\n        AutoCompletionList list = new AutoCompletionList();\n        populateWithKeys(list);\n        return new ArrayList<AutoCompletionListItem>(list.getList());\n    }","id":25042,"modified_method":"/**\n     * Returns the currently cached tag keys.\n     * @return a list of tag keys\n     */\n    public List<AutoCompletionListItem> getKeys() {\n        AutoCompletionList list = new AutoCompletionList();\n        populateWithKeys(list);\n        return list.getList();\n    }","commit_id":"b0dcf05f44ee50852b69f2b6b28debb003f25961","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * @param allData\n     * @param keys\n     * @param values\n     */\n    private FocusAdapter addFocusAdapter(final int row, final AutoCompletingComboBox keys, final AutoCompletingComboBox values, final AutoCompletionManager autocomplete) {\n        // get the combo box' editor component\n        JTextComponent editor = (JTextComponent)values.getEditor()\n        .getEditorComponent();\n        // Refresh the values model when focus is gained\n        FocusAdapter focus = new FocusAdapter() {\n            @Override public void focusGained(FocusEvent e) {\n                String key = keys.getEditor().getItem().toString();\n\n                List<AutoCompletionListItem> valueList = autocomplete.getValues(key);\n                Collections.sort(valueList, defaultACItemComparator);\n\n                values.setPossibleACItems(valueList);\n                objKey=key;\n            }\n        };\n        editor.addFocusListener(focus);\n        return focus;\n    }","id":25043,"modified_method":"/**\n     * @param allData\n     * @param keys\n     * @param values\n     */\n    private FocusAdapter addFocusAdapter(final int row, final AutoCompletingComboBox keys, final AutoCompletingComboBox values, final AutoCompletionManager autocomplete) {\n        // get the combo box' editor component\n        JTextComponent editor = (JTextComponent)values.getEditor()\n        .getEditorComponent();\n        // Refresh the values model when focus is gained\n        FocusAdapter focus = new FocusAdapter() {\n            @Override public void focusGained(FocusEvent e) {\n                String key = keys.getEditor().getItem().toString();\n\n                List<AutoCompletionListItem> valueList = autocomplete.getValues(getAutocompletionKeys(key));\n                Collections.sort(valueList, defaultACItemComparator);\n\n                values.setPossibleACItems(valueList);\n                objKey=key;\n            }\n        };\n        editor.addFocusListener(focus);\n        return focus;\n    }","commit_id":"b0dcf05f44ee50852b69f2b6b28debb003f25961","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Edit the value in the properties table row\n     * @param row The row of the table from which the value is edited.\n     */\n    @SuppressWarnings(\"unchecked\")\n    void propertyEdit(int row) {\n        Collection<OsmPrimitive> sel = Main.main.getCurrentDataSet().getSelected();\n        if (sel.isEmpty()) return;\n\n        String key = propertyData.getValueAt(row, 0).toString();\n        objKey=key;\n\n        String msg = \"<html>\"+trn(\"This will change {0} object.\",\n                \"This will change up to {0} objects.\", sel.size(), sel.size())\n                +\"<br><br>(\"+tr(\"An empty value deletes the tag.\", key)+\")<\/html>\";\n\n        JPanel panel = new JPanel(new BorderLayout());\n        panel.add(new JLabel(msg), BorderLayout.NORTH);\n\n        JPanel p = new JPanel(new GridBagLayout());\n        panel.add(p, BorderLayout.CENTER);\n\n        AutoCompletionManager autocomplete = Main.main.getEditLayer().data.getAutoCompletionManager();\n        List<AutoCompletionListItem> keyList = autocomplete.getKeys();\n        Collections.sort(keyList, defaultACItemComparator);\n\n        final AutoCompletingComboBox keys = new AutoCompletingComboBox();\n        keys.setPossibleACItems(keyList);\n        keys.setEditable(true);\n        keys.setSelectedItem(key);\n\n        p.add(new JLabel(tr(\"Key\")), GBC.std());\n        p.add(Box.createHorizontalStrut(10), GBC.std());\n        p.add(keys, GBC.eol().fill(GBC.HORIZONTAL));\n\n        final AutoCompletingComboBox values = new AutoCompletingComboBox();\n        values.setRenderer(new DefaultListCellRenderer() {\n            @Override public Component getListCellRendererComponent(JList list,\n                    Object value, int index, boolean isSelected,  boolean cellHasFocus){\n                Component c = super.getListCellRendererComponent(list, value,\n                        index, isSelected, cellHasFocus);\n                if (c instanceof JLabel) {\n                    String str = null;\n                    str=((AutoCompletionListItem) value).getValue();\n                    if (valueCount.containsKey(objKey)){\n                        Map<String, Integer> m=valueCount.get(objKey);\n                        if (m.containsKey(str)) {\n                            str+=\"(\"+m.get(str)+\")\";\n                            c.setFont(c.getFont().deriveFont(Font.ITALIC+Font.BOLD));\n                        }\n                    }\n                    ((JLabel)c).setText(str);\n                }\n                return c;\n            }\n        });\n        values.setEditable(true);\n\n        List<AutoCompletionListItem> valueList = autocomplete.getValues(key);\n        Collections.sort(valueList, defaultACItemComparator);\n\n        values.setPossibleACItems(valueList);\n        Map<String, Integer> m=(Map<String, Integer>)propertyData.getValueAt(row, 1);\n        final String selection= m.size()!=1?tr(\"<different>\"):m.entrySet().iterator().next().getKey();\n        values.setSelectedItem(selection);\n        values.getEditor().setItem(selection);\n        p.add(new JLabel(tr(\"Value\")), GBC.std());\n        p.add(Box.createHorizontalStrut(10), GBC.std());\n        p.add(values, GBC.eol().fill(GBC.HORIZONTAL));\n        addFocusAdapter(row, keys, values, autocomplete);\n\n        final JOptionPane optionPane = new JOptionPane(panel, JOptionPane.QUESTION_MESSAGE, JOptionPane.OK_CANCEL_OPTION) {\n            @Override public void selectInitialValue() {\n                values.requestFocusInWindow();\n                values.getEditor().selectAll();\n            }\n        };\n        final JDialog dlg = optionPane.createDialog(Main.parent, tr(\"Change values?\"));\n        dlg.setModalityType(ModalityType.DOCUMENT_MODAL);\n        Dimension dlgSize = dlg.getSize();\n        if(dlgSize.width > Main.parent.getSize().width) {\n            dlgSize.width = Math.max(250, Main.parent.getSize().width);\n            dlg.setSize(dlgSize);\n        }\n        dlg.setLocationRelativeTo(Main.parent);\n        values.getEditor().addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                dlg.setVisible(false);\n                optionPane.setValue(JOptionPane.OK_OPTION);\n            }\n        });\n\n        String oldValue = values.getEditor().getItem().toString();\n        dlg.setVisible(true);\n\n        Object answer = optionPane.getValue();\n        if (answer == null || answer == JOptionPane.UNINITIALIZED_VALUE ||\n                (answer instanceof Integer && (Integer)answer != JOptionPane.OK_OPTION)) {\n            values.getEditor().setItem(oldValue);\n            return;\n        }\n\n        String value = values.getEditor().getItem().toString().trim();\n        // is not Java 1.5\n        //value = java.text.Normalizer.normalize(value, java.text.Normalizer.Form.NFC);\n        if (value.equals(\"\")) {\n            value = null; // delete the key\n        }\n        String newkey = keys.getEditor().getItem().toString().trim();\n        //newkey = java.text.Normalizer.normalize(newkey, java.text.Normalizer.Form.NFC);\n        if (newkey.equals(\"\")) {\n            newkey = key;\n            value = null; // delete the key instead\n        }\n        if (key.equals(newkey) && tr(\"<different>\").equals(value))\n            return;\n        if (key.equals(newkey) || value == null) {\n            Main.main.undoRedo.add(new ChangePropertyCommand(sel, newkey, value));\n        } else {\n            for (OsmPrimitive osm: sel) {\n                if(osm.get(newkey) != null) {\n                    ExtendedDialog ed = new ExtendedDialog(\n                            Main.parent,\n                            tr(\"Overwrite key\"),\n                            new String[]{tr(\"Replace\"), tr(\"Cancel\")});\n                    ed.setButtonIcons(new String[]{\"purge\", \"cancel\"});\n                    ed.setContent(tr(\"You changed the key from ''{0}'' to ''{1}''.\\n\"\n                    + \"The new key is already used, overwrite values?\", key, newkey));\n                    ed.setCancelButton(2);\n                    ed.toggleEnable(\"overwriteEditKey\");\n                    ed.showDialog();\n\n                    if (ed.getValue() != 1) {\n                        return;\n                    }\n                    break;\n                }\n            }\n            Collection<Command> commands=new Vector<Command>();\n            commands.add(new ChangePropertyCommand(sel, key, null));\n            if (value.equals(tr(\"<different>\"))) {\n                HashMap<String, Vector<OsmPrimitive>> map=new HashMap<String, Vector<OsmPrimitive>>();\n                for (OsmPrimitive osm: sel) {\n                    String val=osm.get(key);\n                    if(val != null)\n                    {\n                        if (map.containsKey(val)) {\n                            map.get(val).add(osm);\n                        } else {\n                            Vector<OsmPrimitive> v = new Vector<OsmPrimitive>();\n                            v.add(osm);\n                            map.put(val, v);\n                        }\n                    }\n                }\n                for (Entry<String, Vector<OsmPrimitive>> e: map.entrySet()) {\n                    commands.add(new ChangePropertyCommand(e.getValue(), newkey, e.getKey()));\n                }\n            } else {\n                commands.add(new ChangePropertyCommand(sel, newkey, value));\n            }\n            Main.main.undoRedo.add(new SequenceCommand(\n                    trn(\"Change properties of up to {0} object\",\n                            \"Change properties of up to {0} objects\", sel.size(), sel.size()),\n                            commands));\n        }\n\n        if(!key.equals(newkey)) {\n            for(int i=0; i < propertyTable.getRowCount(); i++)\n                if(propertyData.getValueAt(i, 0).toString().equals(newkey)) {\n                    row=i;\n                    break;\n                }\n        }\n        propertyTable.changeSelection(row, 0, false, false);\n    }","id":25044,"modified_method":"/**\n     * Edit the value in the properties table row\n     * @param row The row of the table from which the value is edited.\n     */\n    @SuppressWarnings(\"unchecked\")\n    void propertyEdit(int row) {\n        Collection<OsmPrimitive> sel = Main.main.getCurrentDataSet().getSelected();\n        if (sel.isEmpty()) return;\n\n        String key = propertyData.getValueAt(row, 0).toString();\n        objKey=key;\n\n        String msg = \"<html>\"+trn(\"This will change {0} object.\",\n                \"This will change up to {0} objects.\", sel.size(), sel.size())\n                +\"<br><br>(\"+tr(\"An empty value deletes the tag.\", key)+\")<\/html>\";\n\n        JPanel panel = new JPanel(new BorderLayout());\n        panel.add(new JLabel(msg), BorderLayout.NORTH);\n\n        JPanel p = new JPanel(new GridBagLayout());\n        panel.add(p, BorderLayout.CENTER);\n\n        AutoCompletionManager autocomplete = Main.main.getEditLayer().data.getAutoCompletionManager();\n        List<AutoCompletionListItem> keyList = autocomplete.getKeys();\n        Collections.sort(keyList, defaultACItemComparator);\n\n        final AutoCompletingComboBox keys = new AutoCompletingComboBox();\n        keys.setPossibleACItems(keyList);\n        keys.setEditable(true);\n        keys.setSelectedItem(key);\n\n        p.add(new JLabel(tr(\"Key\")), GBC.std());\n        p.add(Box.createHorizontalStrut(10), GBC.std());\n        p.add(keys, GBC.eol().fill(GBC.HORIZONTAL));\n\n        final AutoCompletingComboBox values = new AutoCompletingComboBox();\n        values.setRenderer(new DefaultListCellRenderer() {\n            @Override public Component getListCellRendererComponent(JList list,\n                    Object value, int index, boolean isSelected,  boolean cellHasFocus){\n                Component c = super.getListCellRendererComponent(list, value,\n                        index, isSelected, cellHasFocus);\n                if (c instanceof JLabel) {\n                    String str = null;\n                    str=((AutoCompletionListItem) value).getValue();\n                    if (valueCount.containsKey(objKey)){\n                        Map<String, Integer> m=valueCount.get(objKey);\n                        if (m.containsKey(str)) {\n                            str+=\"(\"+m.get(str)+\")\";\n                            c.setFont(c.getFont().deriveFont(Font.ITALIC+Font.BOLD));\n                        }\n                    }\n                    ((JLabel)c).setText(str);\n                }\n                return c;\n            }\n        });\n        values.setEditable(true);\n\n        List<AutoCompletionListItem> valueList = autocomplete.getValues(getAutocompletionKeys(key));\n        Collections.sort(valueList, defaultACItemComparator);\n\n        values.setPossibleACItems(valueList);\n        Map<String, Integer> m=(Map<String, Integer>)propertyData.getValueAt(row, 1);\n        final String selection= m.size()!=1?tr(\"<different>\"):m.entrySet().iterator().next().getKey();\n        values.setSelectedItem(selection);\n        values.getEditor().setItem(selection);\n        p.add(new JLabel(tr(\"Value\")), GBC.std());\n        p.add(Box.createHorizontalStrut(10), GBC.std());\n        p.add(values, GBC.eol().fill(GBC.HORIZONTAL));\n        addFocusAdapter(row, keys, values, autocomplete);\n\n        final JOptionPane optionPane = new JOptionPane(panel, JOptionPane.QUESTION_MESSAGE, JOptionPane.OK_CANCEL_OPTION) {\n            @Override public void selectInitialValue() {\n                values.requestFocusInWindow();\n                values.getEditor().selectAll();\n            }\n        };\n        final JDialog dlg = optionPane.createDialog(Main.parent, tr(\"Change values?\"));\n        dlg.setModalityType(ModalityType.DOCUMENT_MODAL);\n        Dimension dlgSize = dlg.getSize();\n        if(dlgSize.width > Main.parent.getSize().width) {\n            dlgSize.width = Math.max(250, Main.parent.getSize().width);\n            dlg.setSize(dlgSize);\n        }\n        dlg.setLocationRelativeTo(Main.parent);\n        values.getEditor().addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                dlg.setVisible(false);\n                optionPane.setValue(JOptionPane.OK_OPTION);\n            }\n        });\n\n        String oldValue = values.getEditor().getItem().toString();\n        dlg.setVisible(true);\n\n        Object answer = optionPane.getValue();\n        if (answer == null || answer == JOptionPane.UNINITIALIZED_VALUE ||\n                (answer instanceof Integer && (Integer)answer != JOptionPane.OK_OPTION)) {\n            values.getEditor().setItem(oldValue);\n            return;\n        }\n\n        String value = values.getEditor().getItem().toString().trim();\n        // is not Java 1.5\n        //value = java.text.Normalizer.normalize(value, java.text.Normalizer.Form.NFC);\n        if (value.equals(\"\")) {\n            value = null; // delete the key\n        }\n        String newkey = keys.getEditor().getItem().toString().trim();\n        //newkey = java.text.Normalizer.normalize(newkey, java.text.Normalizer.Form.NFC);\n        if (newkey.equals(\"\")) {\n            newkey = key;\n            value = null; // delete the key instead\n        }\n        if (key.equals(newkey) && tr(\"<different>\").equals(value))\n            return;\n        if (key.equals(newkey) || value == null) {\n            Main.main.undoRedo.add(new ChangePropertyCommand(sel, newkey, value));\n        } else {\n            for (OsmPrimitive osm: sel) {\n                if(osm.get(newkey) != null) {\n                    ExtendedDialog ed = new ExtendedDialog(\n                            Main.parent,\n                            tr(\"Overwrite key\"),\n                            new String[]{tr(\"Replace\"), tr(\"Cancel\")});\n                    ed.setButtonIcons(new String[]{\"purge\", \"cancel\"});\n                    ed.setContent(tr(\"You changed the key from ''{0}'' to ''{1}''.\\n\"\n                    + \"The new key is already used, overwrite values?\", key, newkey));\n                    ed.setCancelButton(2);\n                    ed.toggleEnable(\"overwriteEditKey\");\n                    ed.showDialog();\n\n                    if (ed.getValue() != 1) {\n                        return;\n                    }\n                    break;\n                }\n            }\n            Collection<Command> commands=new Vector<Command>();\n            commands.add(new ChangePropertyCommand(sel, key, null));\n            if (value.equals(tr(\"<different>\"))) {\n                HashMap<String, Vector<OsmPrimitive>> map=new HashMap<String, Vector<OsmPrimitive>>();\n                for (OsmPrimitive osm: sel) {\n                    String val=osm.get(key);\n                    if(val != null)\n                    {\n                        if (map.containsKey(val)) {\n                            map.get(val).add(osm);\n                        } else {\n                            Vector<OsmPrimitive> v = new Vector<OsmPrimitive>();\n                            v.add(osm);\n                            map.put(val, v);\n                        }\n                    }\n                }\n                for (Entry<String, Vector<OsmPrimitive>> e: map.entrySet()) {\n                    commands.add(new ChangePropertyCommand(e.getValue(), newkey, e.getKey()));\n                }\n            } else {\n                commands.add(new ChangePropertyCommand(sel, newkey, value));\n            }\n            Main.main.undoRedo.add(new SequenceCommand(\n                    trn(\"Change properties of up to {0} object\",\n                            \"Change properties of up to {0} objects\", sel.size(), sel.size()),\n                            commands));\n        }\n\n        if(!key.equals(newkey)) {\n            for(int i=0; i < propertyTable.getRowCount(); i++)\n                if(propertyData.getValueAt(i, 0).toString().equals(newkey)) {\n                    row=i;\n                    break;\n                }\n        }\n        propertyTable.changeSelection(row, 0, false, false);\n    }","commit_id":"b0dcf05f44ee50852b69f2b6b28debb003f25961","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Test\n    public void streamFilesRecursiveMustNotThrowWhenTargetFileOfRenameAlreadyExistsAndUsingReplaceExisting() throws Exception\n    {\n        PageSwapperFactory factory = swapperFactory();\n        File base = baseDirectory();\n        File a = new File( base, \"a\" );\n        File b = new File( base, \"b\" );\n        createSwapperAndFile( factory, a );\n        createSwapperAndFile( factory, b );\n        FileHandle handle = factory.streamFilesRecursive( a ).findAny().get();\n        handle.rename( b, REPLACE_EXISTING );\n    }","id":25045,"modified_method":"@Test\n    public void streamFilesRecursiveMustNotThrowWhenTargetFileOfRenameAlreadyExistsAndUsingReplaceExisting() throws Exception\n    {\n        PageSwapperFactory factory = swapperFactory();\n        File base = baseDirectory();\n        File a = new File( base, \"a\" );\n        File b = new File( base, \"b\" );\n        createSwapperAndFile( factory, a ).close();\n        createSwapperAndFile( factory, b ).close();\n        FileHandle handle = factory.streamFilesRecursive( a ).findAny().get();\n        handle.rename( b, REPLACE_EXISTING );\n    }","commit_id":"d1c11be5a673c3420dbdf68f6e60c528d083dbe7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void streamFilesRecursiveMustThrowWhenTargetFileOfRenameAlreadyExists() throws Exception\n    {\n        PageSwapperFactory factory = swapperFactory();\n        File base = baseDirectory();\n        File a = new File( base, \"a\" );\n        File b = new File( base, \"b\" );\n        createSwapperAndFile( factory, a );\n        createSwapperAndFile( factory, b );\n        FileHandle handle = factory.streamFilesRecursive( a ).findAny().get();\n        expectedException.expect( FileAlreadyExistsException.class );\n        handle.rename( b );\n    }","id":25046,"modified_method":"@Test\n    public void streamFilesRecursiveMustThrowWhenTargetFileOfRenameAlreadyExists() throws Exception\n    {\n        PageSwapperFactory factory = swapperFactory();\n        File base = baseDirectory();\n        File a = new File( base, \"a\" );\n        File b = new File( base, \"b\" );\n        createSwapperAndFile( factory, a ).close();\n        createSwapperAndFile( factory, b ).close();\n        FileHandle handle = factory.streamFilesRecursive( a ).findAny().get();\n        expectedException.expect( FileAlreadyExistsException.class );\n        handle.rename( b );\n    }","commit_id":"d1c11be5a673c3420dbdf68f6e60c528d083dbe7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n\tpublic void handleReturnValue(Object returnValue, MethodParameter returnType, Message<?> message)\n\t\t\tthrows Exception {\n\n\t\tAssert.notNull(this.clientChannel, \"No clientChannel to send messages to\");\n\n\t\tif (message == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tPubSubHeaderAccesssor headers = PubSubHeaderAccesssor.wrap(message);\n\t\tAssert.notNull(headers.getSubscriptionId(), \"No subscription id: \" + message);\n\n\t\tPubSubHeaderAccesssor returnHeaders = PubSubHeaderAccesssor.wrap(message);\n\t\treturnHeaders.setSessionId(headers.getSessionId());\n\t\treturnHeaders.setSubscriptionId(headers.getSubscriptionId());\n\n\t\tif (returnHeaders.getDestination() == null) {\n\t\t\treturnHeaders.setDestination(headers.getDestination());\n\t\t}\n\n\t\tMessage<?> returnMessage = MessageBuilder.withPayload(\n\t\t\t\tmessage.getPayload()).copyHeaders(headers.toHeaders()).build();\n\n\t\tthis.clientChannel.send(returnMessage);\n \t}","id":25047,"modified_method":"@Override\n\tpublic void handleReturnValue(Object returnValue, MethodParameter returnType, Message<?> message)\n\t\t\tthrows Exception {\n\n\t\tAssert.notNull(this.clientChannel, \"No clientChannel to send messages to\");\n\n\t\tMessage<?> returnMessage = (Message<?>) returnValue;\n\t\tif (message == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tPubSubHeaderAccesssor headers = PubSubHeaderAccesssor.wrap(message);\n\t\tAssert.notNull(headers.getSubscriptionId(), \"No subscription id: \" + message);\n\n\t\tPubSubHeaderAccesssor returnHeaders = PubSubHeaderAccesssor.wrap(returnMessage);\n\t\treturnHeaders.setSessionId(headers.getSessionId());\n\t\treturnHeaders.setSubscriptionId(headers.getSubscriptionId());\n\n\t\tif (returnHeaders.getDestination() == null) {\n\t\t\treturnHeaders.setDestination(headers.getDestination());\n\t\t}\n\n\t\treturnMessage = MessageBuilder.withPayload(\n\t\t\t\treturnMessage.getPayload()).copyHeaders(returnHeaders.toHeaders()).build();\n\n\t\tthis.clientChannel.send(returnMessage);\n \t}","commit_id":"ac23832e4df5d5291c87ded4f56d198b3fa00c04","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void connectFrame() throws Exception {\n\n\t\tString accept = \"accept-version:1.1\\n\";\n\t\tString host = \"host:github.org\\n\";\n\t\tString frame = \"\\n\\n\\nCONNECT\\n\" + accept + host + \"\\n\";\n\t\tMessage<byte[]> message = this.converter.toMessage(frame.getBytes(\"UTF-8\"), \"session-123\");\n\n\t\tassertEquals(0, message.getPayload().length);\n\n\t\tMessageHeaders headers = message.getHeaders();\n\t\tStompHeaderAccessor stompHeaders = StompHeaderAccessor.wrap(message);\n\t\tassertEquals(7, stompHeaders.toHeaders().size());\n\n\t\tassertEquals(Collections.singleton(\"1.1\"), stompHeaders.getAcceptVersion());\n\t\tassertEquals(\"github.org\", stompHeaders.getHost());\n\n\t\tassertEquals(MessageType.CONNECT, stompHeaders.getMessageType());\n\t\tassertEquals(StompCommand.CONNECT, stompHeaders.getStompCommand());\n\t\tassertEquals(\"session-123\", stompHeaders.getSessionId());\n\t\tassertNotNull(headers.get(MessageHeaders.ID));\n\t\tassertNotNull(headers.get(MessageHeaders.TIMESTAMP));\n\n\t\tString convertedBack = new String(this.converter.fromMessage(message), \"UTF-8\");\n\n\t\tassertEquals(\"CONNECT\\n\", convertedBack.substring(0,8));\n\t\tassertTrue(convertedBack.contains(accept));\n\t\tassertTrue(convertedBack.contains(host));\n\t}","id":25048,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t@Test\n\tpublic void connectFrame() throws Exception {\n\n\t\tString accept = \"accept-version:1.1\\n\";\n\t\tString host = \"host:github.org\\n\";\n\t\tString frame = \"\\n\\n\\nCONNECT\\n\" + accept + host + \"\\n\";\n\t\tMessage<byte[]> message = (Message<byte[]>) this.converter.toMessage(frame.getBytes(\"UTF-8\"), \"session-123\");\n\n\t\tassertEquals(0, message.getPayload().length);\n\n\t\tMessageHeaders headers = message.getHeaders();\n\t\tStompHeaderAccessor stompHeaders = StompHeaderAccessor.wrap(message);\n\t\tassertEquals(7, stompHeaders.toHeaders().size());\n\n\t\tassertEquals(Collections.singleton(\"1.1\"), stompHeaders.getAcceptVersion());\n\t\tassertEquals(\"github.org\", stompHeaders.getHost());\n\n\t\tassertEquals(MessageType.CONNECT, stompHeaders.getMessageType());\n\t\tassertEquals(StompCommand.CONNECT, stompHeaders.getStompCommand());\n\t\tassertEquals(\"session-123\", stompHeaders.getSessionId());\n\t\tassertNotNull(headers.get(MessageHeaders.ID));\n\t\tassertNotNull(headers.get(MessageHeaders.TIMESTAMP));\n\n\t\tString convertedBack = new String(this.converter.fromMessage(message), \"UTF-8\");\n\n\t\tassertEquals(\"CONNECT\\n\", convertedBack.substring(0,8));\n\t\tassertTrue(convertedBack.contains(accept));\n\t\tassertTrue(convertedBack.contains(host));\n\t}","commit_id":"ac23832e4df5d5291c87ded4f56d198b3fa00c04","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void connectWithEscapesAndCR12() throws Exception {\n\n\t\tString accept = \"accept-version:1.1\\n\";\n\t\tString host = \"ho\\\\c\\\\ns\\\\rt:st\\\\nomp.gi\\\\cthu\\\\b.org\\n\";\n\t\tString test = \"\\n\\n\\nCONNECT\\r\\n\" + accept.replaceAll(\"\\n\", \"\\r\\n\") + host.replaceAll(\"\\n\", \"\\r\\n\") + \"\\r\\n\";\n\t\tMessage<byte[]> message = this.converter.toMessage(test.getBytes(\"UTF-8\"), \"session-123\");\n\n\t\tassertEquals(0, message.getPayload().length);\n\n\t\tStompHeaderAccessor stompHeaders = StompHeaderAccessor.wrap(message);\n\t\tassertEquals(Collections.singleton(\"1.1\"), stompHeaders.getAcceptVersion());\n\t\tassertEquals(\"st\\nomp.gi:thu\\\\b.org\", stompHeaders.getExternalSourceHeaders().get(\"ho:\\ns\\rt\").get(0));\n\n\t\tString convertedBack = new String(this.converter.fromMessage(message), \"UTF-8\");\n\n\t\tassertEquals(\"CONNECT\\n\", convertedBack.substring(0,8));\n\t\tassertTrue(convertedBack.contains(accept));\n\t\tassertTrue(convertedBack.contains(host));\n\t}","id":25049,"modified_method":"@Test\n\tpublic void connectWithEscapesAndCR12() throws Exception {\n\n\t\tString accept = \"accept-version:1.1\\n\";\n\t\tString host = \"ho\\\\c\\\\ns\\\\rt:st\\\\nomp.gi\\\\cthu\\\\b.org\\n\";\n\t\tString test = \"\\n\\n\\nCONNECT\\r\\n\" + accept.replaceAll(\"\\n\", \"\\r\\n\") + host.replaceAll(\"\\n\", \"\\r\\n\") + \"\\r\\n\";\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tMessage<byte[]> message = (Message<byte[]>) this.converter.toMessage(test.getBytes(\"UTF-8\"), \"session-123\");\n\n\t\tassertEquals(0, message.getPayload().length);\n\n\t\tStompHeaderAccessor stompHeaders = StompHeaderAccessor.wrap(message);\n\t\tassertEquals(Collections.singleton(\"1.1\"), stompHeaders.getAcceptVersion());\n\t\tassertEquals(\"st\\nomp.gi:thu\\\\b.org\", stompHeaders.getExternalSourceHeaders().get(\"ho:\\ns\\rt\").get(0));\n\n\t\tString convertedBack = new String(this.converter.fromMessage(message), \"UTF-8\");\n\n\t\tassertEquals(\"CONNECT\\n\", convertedBack.substring(0,8));\n\t\tassertTrue(convertedBack.contains(accept));\n\t\tassertTrue(convertedBack.contains(host));\n\t}","commit_id":"ac23832e4df5d5291c87ded4f56d198b3fa00c04","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setup() {\n\t\tthis.converter = new StompMessageConverter<Message<byte[]>>();\n\t}","id":25050,"modified_method":"@Before\n\tpublic void setup() {\n\t\tthis.converter = new StompMessageConverter();\n\t}","commit_id":"ac23832e4df5d5291c87ded4f56d198b3fa00c04","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void connectWithEscapes() throws Exception {\n\n\t\tString accept = \"accept-version:1.1\\n\";\n\t\tString host = \"ho\\\\c\\\\ns\\\\rt:st\\\\nomp.gi\\\\cthu\\\\b.org\\n\";\n\t\tString frame = \"CONNECT\\n\" + accept + host + \"\\n\";\n\t\tMessage<byte[]> message = this.converter.toMessage(frame.getBytes(\"UTF-8\"), \"session-123\");\n\n\t\tassertEquals(0, message.getPayload().length);\n\n\t\tStompHeaderAccessor stompHeaders = StompHeaderAccessor.wrap(message);\n\t\tassertEquals(Collections.singleton(\"1.1\"), stompHeaders.getAcceptVersion());\n\t\tassertEquals(\"st\\nomp.gi:thu\\\\b.org\", stompHeaders.getExternalSourceHeaders().get(\"ho:\\ns\\rt\").get(0));\n\n\t\tString convertedBack = new String(this.converter.fromMessage(message), \"UTF-8\");\n\n\t\tassertEquals(\"CONNECT\\n\", convertedBack.substring(0,8));\n\t\tassertTrue(convertedBack.contains(accept));\n\t\tassertTrue(convertedBack.contains(host));\n\t}","id":25051,"modified_method":"@Test\n\tpublic void connectWithEscapes() throws Exception {\n\n\t\tString accept = \"accept-version:1.1\\n\";\n\t\tString host = \"ho\\\\c\\\\ns\\\\rt:st\\\\nomp.gi\\\\cthu\\\\b.org\\n\";\n\t\tString frame = \"CONNECT\\n\" + accept + host + \"\\n\";\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tMessage<byte[]> message = (Message<byte[]>) this.converter.toMessage(frame.getBytes(\"UTF-8\"), \"session-123\");\n\n\t\tassertEquals(0, message.getPayload().length);\n\n\t\tStompHeaderAccessor stompHeaders = StompHeaderAccessor.wrap(message);\n\t\tassertEquals(Collections.singleton(\"1.1\"), stompHeaders.getAcceptVersion());\n\t\tassertEquals(\"st\\nomp.gi:thu\\\\b.org\", stompHeaders.getExternalSourceHeaders().get(\"ho:\\ns\\rt\").get(0));\n\n\t\tString convertedBack = new String(this.converter.fromMessage(message), \"UTF-8\");\n\n\t\tassertEquals(\"CONNECT\\n\", convertedBack.substring(0,8));\n\t\tassertTrue(convertedBack.contains(accept));\n\t\tassertTrue(convertedBack.contains(host));\n\t}","commit_id":"ac23832e4df5d5291c87ded4f56d198b3fa00c04","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void connectCR12() throws Exception {\n\n\t\tString accept = \"accept-version:1.2\\n\";\n\t\tString host = \"host:github.org\\n\";\n\t\tString test = \"CONNECT\\r\\n\" + accept.replaceAll(\"\\n\", \"\\r\\n\") + host.replaceAll(\"\\n\", \"\\r\\n\") + \"\\r\\n\";\n\t\tMessage<byte[]> message = this.converter.toMessage(test.getBytes(\"UTF-8\"), \"session-123\");\n\n\t\tassertEquals(0, message.getPayload().length);\n\n\t\tStompHeaderAccessor stompHeaders = StompHeaderAccessor.wrap(message);\n\t\tassertEquals(Collections.singleton(\"1.2\"), stompHeaders.getAcceptVersion());\n\t\tassertEquals(\"github.org\", stompHeaders.getHost());\n\n\t\tString convertedBack = new String(this.converter.fromMessage(message), \"UTF-8\");\n\n\t\tassertEquals(\"CONNECT\\n\", convertedBack.substring(0,8));\n\t\tassertTrue(convertedBack.contains(accept));\n\t\tassertTrue(convertedBack.contains(host));\n\t}","id":25052,"modified_method":"@Test\n\tpublic void connectCR12() throws Exception {\n\n\t\tString accept = \"accept-version:1.2\\n\";\n\t\tString host = \"host:github.org\\n\";\n\t\tString test = \"CONNECT\\r\\n\" + accept.replaceAll(\"\\n\", \"\\r\\n\") + host.replaceAll(\"\\n\", \"\\r\\n\") + \"\\r\\n\";\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tMessage<byte[]> message = (Message<byte[]>) this.converter.toMessage(test.getBytes(\"UTF-8\"), \"session-123\");\n\n\t\tassertEquals(0, message.getPayload().length);\n\n\t\tStompHeaderAccessor stompHeaders = StompHeaderAccessor.wrap(message);\n\t\tassertEquals(Collections.singleton(\"1.2\"), stompHeaders.getAcceptVersion());\n\t\tassertEquals(\"github.org\", stompHeaders.getHost());\n\n\t\tString convertedBack = new String(this.converter.fromMessage(message), \"UTF-8\");\n\n\t\tassertEquals(\"CONNECT\\n\", convertedBack.substring(0,8));\n\t\tassertTrue(convertedBack.contains(accept));\n\t\tassertTrue(convertedBack.contains(host));\n\t}","commit_id":"ac23832e4df5d5291c87ded4f56d198b3fa00c04","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public String toString() {\n        return key.toString();\n    }","id":25053,"modified_method":"public String toString() {\n        return sKey.toString();\n    }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"public Key(String key,Type type) {\n        this.type = type;\n        this.key = key;\n        if(type.getDisplayName().equals(Type.INTEGER_TYPE))\n            defaultValue = new Integer(0);\n        else if(type.getDisplayName().equals(Type.BOOLEAN_TYPE))\n            defaultValue = new Boolean(true);\n        else \n            defaultValue = new String(\"\");\n    }","id":25054,"modified_method":"public Key(String key,Type type) {\n        this.type = type;\n        this.sKey = key;\n        if(type.getDisplayName().equals(Type.INTEGER_TYPE))\n            defaultValue = new Integer(0);\n        else if(type.getDisplayName().equals(Type.BOOLEAN_TYPE))\n            defaultValue = new Boolean(true);\n        else \n            defaultValue = new String(\"\");\n    }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"public void setKey(Object key) {\n        this.key = key;\n    }","id":25055,"modified_method":"public void setKey(Object key) {\n        this.sKey = key;\n    }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"public Object getKey() {\n        return this.key;\n    }","id":25056,"modified_method":"public Object getKey() {\n        return this.sKey;\n    }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"public synchronized void add(Key key) {\n        super.add(key);\n    }","id":25057,"modified_method":"public synchronized void add(Key key) {\n        keyVector.add(key);\n    }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"/** Creates a new instance of MapMetadataModel */\n    \n    public MapFilterModel() {\n    }","id":25058,"modified_method":"public MapFilterModel() {\n        keyVector = new Vector();\n    }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"private void setMapFilterModelPanel() {\n        JTable mapFilterTable = new JTable(mapFilterTableModel);\n        mapFilterTable.setPreferredScrollableViewportSize(new Dimension(200,100));\n        JScrollPane mapFilterScrollPane=new JScrollPane(mapFilterTable);\n        mapFilterScrollPane.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));\n        JPanel  mapFilterPanel=new JPanel();\n        mapFilterPanel.setLayout(new BorderLayout());\n        mapFilterPanel.add( mapFilterScrollPane, BorderLayout.CENTER);\n        mapFilterPanel.setBorder(BorderFactory.createEmptyBorder(3,6,3,6));\n        \n        // GRID: addConditionButton\n        JButton addButton=new tufts.vue.VueButton(\"add\");\n        addButton.addActionListener(new AddButtonListener(mapFilterTableModel));\n        \n        \n        // GRID: deleteConditionButton\n        JButton deleteButton=new tufts.vue.VueButton(\"delete\");\n        deleteButton.setEnabled(false);\n\n        //setting the listeners\n         \n        JPanel innerPanel=new JPanel();\n        innerPanel.setLayout(new BoxLayout(innerPanel, BoxLayout.Y_AXIS));\n        innerPanel.setBorder(BorderFactory.createEmptyBorder(2,6,6,6));\n        JPanel bottomPanel=new JPanel(new FlowLayout(FlowLayout.RIGHT,2,0));\n        bottomPanel.setBorder(BorderFactory.createEmptyBorder(3,6,3,6));\n        bottomPanel.add(addButton);\n        bottomPanel.add(deleteButton);\n        \n        \n        \n        //innerPanel.add(labelPanel);\n        innerPanel.add(mapFilterPanel);\n        innerPanel.add(bottomPanel);\n        \n        add(innerPanel);\n        //setSize(300, 300);\n        \n        validate();\n        \n    }","id":25059,"modified_method":"private void setMapFilterModelPanel() {\n        mapFilterTable = new JTable(mapFilterModel);\n        mapFilterTable.setPreferredScrollableViewportSize(new Dimension(200,100));\n        JScrollPane mapFilterScrollPane=new JScrollPane(mapFilterTable);\n        mapFilterScrollPane.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));\n        JPanel  mapFilterPanel=new JPanel();\n        mapFilterPanel.setLayout(new BorderLayout());\n        mapFilterPanel.add( mapFilterScrollPane, BorderLayout.CENTER);\n        mapFilterPanel.setBorder(BorderFactory.createEmptyBorder(3,6,3,6));\n        // addConditionButton\n        addButtonListener = new AddButtonListener(mapFilterModel);\n        addButton.addActionListener(addButtonListener);\n        // deleteConditionButton\n       \n        deleteButton.setEnabled(false);\n        \n        \n        JPanel innerPanel=new JPanel();\n        innerPanel.setLayout(new BoxLayout(innerPanel, BoxLayout.Y_AXIS));\n        innerPanel.setBorder(BorderFactory.createEmptyBorder(2,6,6,6));\n        JPanel bottomPanel=new JPanel(new FlowLayout(FlowLayout.RIGHT,2,0));\n        bottomPanel.setBorder(BorderFactory.createEmptyBorder(3,6,3,6));\n        bottomPanel.add(addButton);\n        bottomPanel.add(deleteButton);\n        \n        //innerPanel.add(labelPanel);\n        innerPanel.add(mapFilterPanel);\n        innerPanel.add(bottomPanel);\n        add(innerPanel);\n        //setSize(300, 300);\n        validate();\n        \n    }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"public AddButtonListener(MapFilterTableModel model) {\n            this.model=model;\n        }","id":25060,"modified_method":"public AddButtonListener(MapFilterModel model) {\n            this.model=model;\n        }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"public AddDialog(MapFilterTableModel model) {\n            super(tufts.vue.VUE.getInstance(),\"Add Key\",true);\n            this.model = model;\n            allTypes = (Vector)TypeFactory.getAllTypes();\n            keyLabel = new JLabel(\"Field\");\n            typeLabel = new JLabel(\"Type\");\n            keyEditor = new JTextField();\n            typeEditor = new JComboBox(allTypes);\n            keyEditor.setPreferredSize(new Dimension(80,20));\n            JPanel keyPanel=new JPanel();\n            keyPanel.setLayout(new FlowLayout(FlowLayout.CENTER));\n            keyPanel.setBorder(BorderFactory.createEmptyBorder(6,6,6,6));\n            keyPanel.add(keyLabel);\n            keyPanel.add(keyEditor);\n            \n            JPanel typePanel=new JPanel();\n            typePanel.setLayout(new FlowLayout(FlowLayout.CENTER));\n            typePanel.setBorder(BorderFactory.createEmptyBorder(6,6,6,6));\n            typePanel.add(typeLabel);\n            typePanel.add(typeEditor);\n            \n            // SOUTH: southPanel(cancelButton, okButton)\n            \n            JButton okButton=new JButton(\"Ok\");\n            okButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    updateModelAndNotify();\n                    setVisible(false);\n                }\n            });\n            \n            JButton cancelButton=new JButton(\"Cancel\");\n            cancelButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    setVisible(false);\n                }\n            });\n            \n            JPanel southPanel=new JPanel();\n            southPanel.setLayout(new FlowLayout(FlowLayout.CENTER));\n            southPanel.add(okButton);\n            southPanel.add(cancelButton);\n            BoxLayout layout = new BoxLayout(getContentPane(), BoxLayout.Y_AXIS);\n            \n          \n           \n            getContentPane().setLayout(layout);\n            getContentPane().add(keyPanel);\n            getContentPane().add(typePanel);\n            getContentPane().add(southPanel);\n            pack();\n            setLocation(500,300);\n            show();\n            \n        }","id":25061,"modified_method":"public AddDialog(MapFilterModel model) {\n            super(tufts.vue.VUE.getInstance(),\"Add Key\",true);\n            this.model = model;\n            allTypes = (Vector)TypeFactory.getAllTypes();\n            keyLabel = new JLabel(\"Field\");\n            typeLabel = new JLabel(\"Type\");\n            keyEditor = new JTextField();\n            typeEditor = new JComboBox(allTypes);\n            keyEditor.setPreferredSize(new Dimension(80,20));\n            JPanel keyPanel=new JPanel();\n            keyPanel.setLayout(new FlowLayout(FlowLayout.CENTER));\n            keyPanel.setBorder(BorderFactory.createEmptyBorder(6,6,6,6));\n            keyPanel.add(keyLabel);\n            keyPanel.add(keyEditor);\n            \n            JPanel typePanel=new JPanel();\n            typePanel.setLayout(new FlowLayout(FlowLayout.CENTER));\n            typePanel.setBorder(BorderFactory.createEmptyBorder(6,6,6,6));\n            typePanel.add(typeLabel);\n            typePanel.add(typeEditor);\n            \n            // SOUTH: southPanel(cancelButton, okButton)\n            \n            JButton okButton=new JButton(\"Ok\");\n            okButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    updateModelAndNotify();\n                    setVisible(false);\n                }\n            });\n            \n            JButton cancelButton=new JButton(\"Cancel\");\n            cancelButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    setVisible(false);\n                }\n            });\n            \n            JPanel southPanel=new JPanel();\n            southPanel.setLayout(new FlowLayout(FlowLayout.CENTER));\n            southPanel.add(okButton);\n            southPanel.add(cancelButton);\n            BoxLayout layout = new BoxLayout(getContentPane(), BoxLayout.Y_AXIS);\n            \n            \n            \n            getContentPane().setLayout(layout);\n            getContentPane().add(keyPanel);\n            getContentPane().add(typePanel);\n            getContentPane().add(southPanel);\n            pack();\n            setLocation(500,300);\n            show();\n            \n        }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"private void updateModelAndNotify(){\n            Key key = new Key(keyEditor.getText(),(Type)typeEditor.getSelectedItem());\n            model.addKey(key);\n            model.fireTableDataChanged();\n        }","id":25062,"modified_method":"private void updateModelAndNotify(){\n            Key key = new Key(keyEditor.getText(),(Type)typeEditor.getSelectedItem());\n            model.addKey(key);\n            System.out.println(\"ADDED KEY of Type = \"+((Type)typeEditor.getSelectedItem()).getDisplayName());\n            model.fireTableDataChanged();\n        }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"/** Creates a new instance of MapFilterModelEditor */\n    public MapFilterModelEditor(MapFilterModel mapFilterModel) {\n        mapFilterTableModel = new MapFilterTableModel(mapFilterModel,editable);\n        setMapFilterModelPanel();\n    }","id":25063,"modified_method":"/** Creates a new instance of MapFilterModelEditor */\n    public MapFilterModelEditor(MapFilterModel mapFilterModel) {\n        this.mapFilterModel = mapFilterModel;\n        setMapFilterModelPanel();\n    }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"/** Creates a new instance of NodeFilter */\n    public NodeFilter() {\n    }","id":25064,"modified_method":"public NodeFilter() {\n        this(false);\n    }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"public boolean compare(Statement statement) {\n        Iterator i = iterator();\n        while(i.hasNext()) {\n            Statement nodeStatement = (Statement) i.next();\n            if(nodeStatement.compare(statement))\n                return true;\n        }\n        return false;\n    }","id":25065,"modified_method":"public boolean compare(Statement statement) {\n        Iterator i = statementVector.iterator();\n        while(i.hasNext()) {\n            Statement nodeStatement = (Statement) i.next();\n            if(nodeStatement.compare(statement))\n                return true;\n        }\n        return false;\n    }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"public synchronized void add(Statement statement) {\n        super.add(statement);\n    }","id":25066,"modified_method":"public synchronized void add(Statement statement) {\n        statementVector.add(statement);\n    }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"public AddDialog(NodeFilterTableModel model) {\n            super(tufts.vue.VUE.getInstance(),\"Add Key\",true);\n            this.model = model;\n            allTypes = (Vector)TypeFactory.getAllTypes();\n            keyLabel = new JLabel(\"Key\");\n            typeLabel = new JLabel(\"Type\");\n            operatorLabel = new JLabel(\"Operator\");\n            valueLabel = new JLabel(\"Value\");\n            keyEditor = new JComboBox(tufts.vue.VUE.getActiveMap().getMapFilterModel());\n            \n            \n            operatorEditor = new JComboBox();\n            valueEditor = new JTextField();\n            typeEditor = new JTextField();\n            typeEditor.setEditable(false);\n            \n            keyEditor.setPreferredSize(new Dimension(80,20));\n            keyEditor.addItemListener(new ItemListener() {\n                public void itemStateChanged(ItemEvent e) {\n                    if( e.getStateChange() == e.SELECTED) {\n                        Key key = (Key) e.getItem();\n                        operatorEditor.addItem(\"Hello\");\n                        typeEditor.setText(key.getType().getDisplayName());\n                        \n                    }\n                }\n            });\n            GridBagLayout gridbag = new GridBagLayout();\n            GridBagConstraints c  = new GridBagConstraints();\n            c.insets = new Insets(2,2, 2, 2);\n            JPanel panel = new JPanel();\n            panel.setLayout(gridbag);\n            \n            \n            c.anchor = GridBagConstraints.EAST;\n            c.gridwidth = GridBagConstraints.RELATIVE;\n            gridbag.setConstraints(keyLabel, c);\n            panel.add(keyLabel);\n            \n            c.anchor = GridBagConstraints.WEST;\n            c.gridwidth = GridBagConstraints.REMAINDER;\n            gridbag.setConstraints(keyEditor, c);\n            panel.add(keyEditor);\n            \n            \n            c.anchor = GridBagConstraints.EAST;\n            c.gridwidth = GridBagConstraints.RELATIVE;\n            gridbag.setConstraints(operatorLabel, c);\n            panel.add(operatorLabel);\n            \n            c.anchor = GridBagConstraints.WEST;\n            c.gridwidth = GridBagConstraints.REMAINDER;\n            gridbag.setConstraints(operatorEditor, c);\n            panel.add(operatorEditor);\n            \n            c.anchor = GridBagConstraints.EAST;\n            c.gridwidth = GridBagConstraints.RELATIVE;\n            gridbag.setConstraints(valueLabel, c);\n            panel.add(valueLabel);\n            \n            c.anchor = GridBagConstraints.WEST;\n            c.gridwidth = GridBagConstraints.REMAINDER;\n            c.fill = GridBagConstraints.HORIZONTAL;\n            gridbag.setConstraints(valueEditor, c);\n            panel.add(valueEditor);\n            \n            c.anchor = GridBagConstraints.EAST;\n            c.fill = GridBagConstraints.NONE;\n            c.gridwidth = GridBagConstraints.RELATIVE;\n            gridbag.setConstraints(typeLabel, c);\n            panel.add(typeLabel);\n            \n            c.anchor = GridBagConstraints.WEST;\n            c.gridwidth = GridBagConstraints.REMAINDER;\n            c.fill = GridBagConstraints.HORIZONTAL;\n            gridbag.setConstraints(typeEditor, c);\n            panel.add(typeEditor);\n            \n            // SOUTH: southPanel(cancelButton, okButton)\n            \n            JButton okButton=new JButton(\"Ok\");\n            okButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    updateModelAndNotify();\n                    setVisible(false);\n                }\n            });\n            \n            JButton cancelButton=new JButton(\"Cancel\");\n            cancelButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    setVisible(false);\n                }\n            });\n            \n            JPanel southPanel=new JPanel();\n            southPanel.setLayout(new FlowLayout(FlowLayout.CENTER));\n            southPanel.add(okButton);\n            southPanel.add(cancelButton);\n            \n            \n            c.gridwidth = GridBagConstraints.REMAINDER;\n            gridbag.setConstraints(southPanel, c);\n            panel.add(southPanel);\n            \n            getContentPane().setLayout(new BorderLayout());\n            getContentPane().add(panel,BorderLayout.CENTER);\n            \n            pack();\n            setLocation(500,300);\n            show();\n            \n        }","id":25067,"modified_method":"public AddDialog(NodeFilter model) {\n            super(tufts.vue.VUE.getInstance(),\"Add Key\",true);\n            this.model = model;\n            allTypes = (Vector)TypeFactory.getAllTypes();\n            keyLabel = new JLabel(\"Key\");\n            typeLabel = new JLabel(\"Type\");\n            operatorLabel = new JLabel(\"Operator\");\n            valueLabel = new JLabel(\"Value\");\n            keyEditor = new JComboBox(tufts.vue.VUE.getActiveMap().getMapFilterModel().getKeyVector());\n            \n            \n            operatorEditor = new JComboBox();\n            valueEditor = new JTextField();\n            typeEditor = new JTextField();\n            typeEditor.setEditable(false);\n            \n            keyEditor.setPreferredSize(new Dimension(80,20));\n            keyEditor.addItemListener(new ItemListener() {\n                public void itemStateChanged(ItemEvent e) {\n                    if( e.getStateChange() == e.SELECTED) {\n                        Key key = (Key) e.getItem();\n                        operatorEditor.addItem(\"Hello\");\n                        typeEditor.setText(key.getType().getDisplayName());\n                        \n                    }\n                }\n            });\n            GridBagLayout gridbag = new GridBagLayout();\n            GridBagConstraints c  = new GridBagConstraints();\n            c.insets = new Insets(2,2, 2, 2);\n            JPanel panel = new JPanel();\n            panel.setLayout(gridbag);\n            \n            \n            c.anchor = GridBagConstraints.EAST;\n            c.gridwidth = GridBagConstraints.RELATIVE;\n            gridbag.setConstraints(keyLabel, c);\n            panel.add(keyLabel);\n            \n            c.anchor = GridBagConstraints.WEST;\n            c.gridwidth = GridBagConstraints.REMAINDER;\n            gridbag.setConstraints(keyEditor, c);\n            panel.add(keyEditor);\n            \n            \n            c.anchor = GridBagConstraints.EAST;\n            c.gridwidth = GridBagConstraints.RELATIVE;\n            gridbag.setConstraints(operatorLabel, c);\n            panel.add(operatorLabel);\n            \n            c.anchor = GridBagConstraints.WEST;\n            c.gridwidth = GridBagConstraints.REMAINDER;\n            gridbag.setConstraints(operatorEditor, c);\n            panel.add(operatorEditor);\n            \n            c.anchor = GridBagConstraints.EAST;\n            c.gridwidth = GridBagConstraints.RELATIVE;\n            gridbag.setConstraints(valueLabel, c);\n            panel.add(valueLabel);\n            \n            c.anchor = GridBagConstraints.WEST;\n            c.gridwidth = GridBagConstraints.REMAINDER;\n            c.fill = GridBagConstraints.HORIZONTAL;\n            gridbag.setConstraints(valueEditor, c);\n            panel.add(valueEditor);\n            \n            c.anchor = GridBagConstraints.EAST;\n            c.fill = GridBagConstraints.NONE;\n            c.gridwidth = GridBagConstraints.RELATIVE;\n            gridbag.setConstraints(typeLabel, c);\n            panel.add(typeLabel);\n            \n            c.anchor = GridBagConstraints.WEST;\n            c.gridwidth = GridBagConstraints.REMAINDER;\n            c.fill = GridBagConstraints.HORIZONTAL;\n            gridbag.setConstraints(typeEditor, c);\n            panel.add(typeEditor);\n            \n            // SOUTH: southPanel(cancelButton, okButton)\n            \n            JButton okButton=new JButton(\"Ok\");\n            okButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    updateModelAndNotify();\n                    setVisible(false);\n                }\n            });\n            \n            JButton cancelButton=new JButton(\"Cancel\");\n            cancelButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    setVisible(false);\n                }\n            });\n            \n            JPanel southPanel=new JPanel();\n            southPanel.setLayout(new FlowLayout(FlowLayout.CENTER));\n            southPanel.add(okButton);\n            southPanel.add(cancelButton);\n            \n            \n            c.gridwidth = GridBagConstraints.REMAINDER;\n            gridbag.setConstraints(southPanel, c);\n            panel.add(southPanel);\n            \n            getContentPane().setLayout(new BorderLayout());\n            getContentPane().add(panel,BorderLayout.CENTER);\n            \n            pack();\n            setLocation(500,300);\n            show();\n            \n        }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {\n            TableModel tableModel = table.getModel();\n            if (tableModel instanceof NodeFilterTableModel) {\n                editor = new JComboBox((Vector)tufts.vue.VUE.getActiveMap().getMapFilterModel());\n                return editor;\n            }\n            return (new JTextField(\"\"));// if no editor present\n        }","id":25068,"modified_method":"public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {\n            TableModel tableModel = table.getModel();\n            if (tableModel instanceof NodeFilter) {\n                editor = new JComboBox((Vector)tufts.vue.VUE.getActiveMap().getMapFilterModel().getKeyVector());\n                return editor;\n            }\n            return (new JTextField(\"\"));// if no editor present\n        }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {\n            \n            TableModel tableModel = table.getModel();\n            if (tableModel instanceof NodeFilterTableModel) {\n                NodeFilterTableModel nodeFilterTableModel  = (NodeFilterTableModel) tableModel;\n                editor =  new JComboBox((Vector)((Statement)(nodeFilterTableModel.getNodeFilter().get(row))).getKey().getType().getSettableOperators());\n                return editor;\n            }\n            return (new JTextField(\"\"));\n        }","id":25069,"modified_method":"public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {\n            \n            TableModel tableModel = table.getModel();\n            if (tableModel instanceof NodeFilter) {\n                NodeFilter nodeFilter  = (NodeFilter) tableModel;\n                editor =  new JComboBox((Vector)((Statement)(nodeFilter.get(row))).getKey().getType().getSettableOperators());\n                return editor;\n            }\n            return (new JTextField(\"\"));\n        }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"/** Creates a new instance of NodeFilterEditor */\n    public NodeFilterEditor( NodeFilter nodeFilter,boolean editable) {\n        nodeFilterTableModel = new NodeFilterTableModel(nodeFilter,editable);\n        setNodeFilterPanel();\n    }","id":25070,"modified_method":"/** Creates a new instance of NodeFilterEditor */\n    public NodeFilterEditor( NodeFilter nodeFilter,boolean editable) {\n        System.out.println(\"Created new instance of node filter editor\");\n        this.nodeFilter = nodeFilter;\n        setNodeFilterPanel();\n    }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(ActionEvent e) {\n            // will only be invoked if an existing row is selected\n            int r=m_sListener.getSelectedRow();\n            ((NodeFilterTableModel) table.getModel()).getNodeFilter().remove(r);\n            ((NodeFilterTableModel) table.getModel()).fireTableRowsDeleted(r,r);\n            if(r> 0)\n                table.setRowSelectionInterval(r-1, r-1);\n            else if(table.getRowCount() > 0)\n                table.setRowSelectionInterval(0,0);\n        }","id":25071,"modified_method":"public void actionPerformed(ActionEvent e) {\n            // will only be invoked if an existing row is selected\n            int r=m_sListener.getSelectedRow();\n            ((NodeFilter) table.getModel()).remove(r);\n            ((NodeFilter) table.getModel()).fireTableRowsDeleted(r,r);\n            if(r> 0)\n                table.setRowSelectionInterval(r-1, r-1);\n            else if(table.getRowCount() > 0)\n                table.setRowSelectionInterval(0,0);\n        }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"public AddButtonListener(NodeFilterTableModel model) {\n            this.model=model;\n        }","id":25072,"modified_method":"public AddButtonListener(NodeFilter model) {\n            this.model=model;\n        }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"private void setNodeFilterPanel() {\n        nodeFilterTable = new JTable(nodeFilterTableModel);\n        nodeFilterTable.setPreferredScrollableViewportSize(new Dimension(200,100));\n        JScrollPane nodeFilterScrollPane=new JScrollPane(nodeFilterTable);\n        nodeFilterScrollPane.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));\n        JPanel  nodeFilterPanel=new JPanel();\n        nodeFilterPanel.setLayout(new BorderLayout());\n        nodeFilterPanel.add( nodeFilterScrollPane, BorderLayout.CENTER);\n        nodeFilterPanel.setBorder(BorderFactory.createEmptyBorder(3,6,3,6));\n        \n        // GRID: addConditionButton\n        JButton addButton=new tufts.vue.VueButton(\"add\");\n        addButton.addActionListener(new AddButtonListener(nodeFilterTableModel));\n        \n        \n        // GRID: deleteConditionButton\n        JButton deleteButton=new tufts.vue.VueButton(\"delete\");\n        deleteButton.setEnabled(false);\n        // adding the delete functionality */\n        NodeFilterSelectionListener sListener= new NodeFilterSelectionListener(deleteButton, -1);\n        nodeFilterTable.getSelectionModel().addListSelectionListener(sListener);\n        deleteButton.addActionListener(new DeleteButtonListener(nodeFilterTable, sListener));\n        \n        /** setting editors ***/\n        keyEditor = new JComboBox(tufts.vue.VUE.getActiveMap().getMapFilterModel());\n        nodeFilterTable.getColumnModel().getColumn(0).setCellEditor(new DefaultCellEditor(keyEditor));\n        //operatorEditor = new JComboBox((Vector)((Key)keyEditor.getItemAt(0)).getType().getOperators());\n        nodeFilterTable.getColumnModel().getColumn(NodeFilterTableModel.OPERATOR_COL).setCellEditor(new OperatorCellEditor());\n        \n        \n        JPanel innerPanel=new JPanel();\n        innerPanel.setLayout(new BoxLayout(innerPanel, BoxLayout.Y_AXIS));\n        innerPanel.setBorder(BorderFactory.createEmptyBorder(2,6,6,6));\n        JPanel bottomPanel=new JPanel(new FlowLayout(FlowLayout.RIGHT,2,0));\n        bottomPanel.setBorder(BorderFactory.createEmptyBorder(3,6,3,6));\n        bottomPanel.add(addButton);\n        bottomPanel.add(deleteButton);\n        \n        \n        \n        //innerPanel.add(labelPanel);\n        innerPanel.add(nodeFilterPanel);\n        innerPanel.add(bottomPanel);\n        \n        add(innerPanel);\n        //setSize(300, 300);\n        \n        validate();\n    }","id":25073,"modified_method":"private void setNodeFilterPanel() {\n        nodeFilterTable = new JTable(nodeFilter);\n        nodeFilterTable.setPreferredScrollableViewportSize(new Dimension(200,100));\n        JScrollPane nodeFilterScrollPane=new JScrollPane(nodeFilterTable);\n        nodeFilterScrollPane.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));\n        JPanel  nodeFilterPanel=new JPanel();\n        nodeFilterPanel.setLayout(new BorderLayout());\n        nodeFilterPanel.add( nodeFilterScrollPane, BorderLayout.CENTER);\n        nodeFilterPanel.setBorder(BorderFactory.createEmptyBorder(3,6,3,6));\n        \n        // GRID: addConditionButton\n        addButtonListener = new AddButtonListener(nodeFilter);\n        addButton.addActionListener(addButtonListener);\n        \n        \n        // GRID: deleteConditionButton\n        \n        deleteButton.setEnabled(false);\n        // adding the delete functionality */\n        sListener= new NodeFilterSelectionListener(deleteButton, -1);\n        nodeFilterTable.getSelectionModel().addListSelectionListener(sListener);\n        deleteButtonListener = new DeleteButtonListener(nodeFilterTable, sListener);\n        deleteButton.addActionListener(deleteButtonListener);\n        \n        /** setting editors ***/\n        keyEditor = new JComboBox(tufts.vue.VUE.getActiveMap().getMapFilterModel().getKeyVector());\n        nodeFilterTable.getColumnModel().getColumn(0).setCellEditor(new DefaultCellEditor(keyEditor));\n        //operatorEditor = new JComboBox((Vector)((Key)keyEditor.getItemAt(0)).getType().getOperators());\n        nodeFilterTable.getColumnModel().getColumn(NodeFilter.OPERATOR_COL).setCellEditor(new OperatorCellEditor());\n        \n        \n        JPanel innerPanel=new JPanel();\n        innerPanel.setLayout(new BoxLayout(innerPanel, BoxLayout.Y_AXIS));\n        innerPanel.setBorder(BorderFactory.createEmptyBorder(2,6,6,6));\n        JPanel bottomPanel=new JPanel(new FlowLayout(FlowLayout.RIGHT,2,0));\n        bottomPanel.setBorder(BorderFactory.createEmptyBorder(3,6,3,6));\n        bottomPanel.add(addButton);\n        bottomPanel.add(deleteButton);\n        \n        \n        \n        //innerPanel.add(labelPanel);\n        innerPanel.add(nodeFilterPanel);\n        innerPanel.add(bottomPanel);\n        \n        add(innerPanel);\n        //setSize(300, 300);\n        \n        validate();\n    }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"/** Creates a new instance of TypeFactory */\n    public static Type getIntegerType() {\n        return new IntergerType();\n        /**\n        Operator eqOperator = new DefaultOperator(\"equal\",\"=\",true) {\n            public boolean compare(Statement s1,Statement s2) {\n                Object value1  = s1.getValue();\n                Object value2 = s2.getValue();\n                System.out.println(\"COMPARING \"+ value1+ \" AND \" + value2+ \"CLASSES =\"+value1.getClass()); \n                if(!(value1 instanceof Integer) || !(value2 instanceof Integer))\n                    return false;\n                else {\n                    int v1 = ((Integer)value1).intValue();\n                    int v2 = ((Integer)value2).intValue();\n                    System.out.println(\"COMPARING \"+ v1+ \" AND \" + v2);\n                \n                    if(v1 == v2) \n                        return true;\n                    else \n                        return false;\n                }\n            }\n        };\n        Operator gtOperator = new DefaultOperator(\"smaller\",\"<\",true) {\n            public boolean compare(Statement s1,Statement s2) {\n                Object value1  = s1.getValue();\n                Object value2 = s2.getValue();\n                if(!(value1 instanceof Integer) || !(value2 instanceof Integer))\n                    return false;\n                else {\n                    int v1 = ((Integer)value1).intValue();\n                    int v2 = ((Integer)value2).intValue();\n                    if(v1 > v2) \n                        return true;\n                    else \n                        return false;\n                }\n            }\n        };\n        Operator ltOperator = new DefaultOperator(\"greater\",\">\",true) {\n            public boolean compare(Statement s1,Statement s2) {\n                Object value1  = s1.getValue();\n                Object value2 = s2.getValue();\n                if(!(value1 instanceof Integer) || !(value2 instanceof Integer))\n                    return false;\n                else {\n                    int v1 = ((Integer)value1).intValue();\n                    int v2 = ((Integer)value2).intValue();\n                    if(v1 < v2) \n                        return true;\n                    else \n                        return false;\n                }\n            }\n        };\n                      \n        Type type = new DefaultType(Type.INTEGER_TYPE);\n        type.getOperators().add(eqOperator);   \n        type.getOperators().add(gtOperator);\n        type.getOperators().add(ltOperator);\n        return type;\n         */\n    }","id":25074,"modified_method":"/** Creates a new instance of TypeFactory */\n    public static Type getIntegerType() {\n        return new IntegerType();\n        /**\n        Operator eqOperator = new DefaultOperator(\"equal\",\"=\",true) {\n            public boolean compare(Statement s1,Statement s2) {\n                Object value1  = s1.getValue();\n                Object value2 = s2.getValue();\n                System.out.println(\"COMPARING \"+ value1+ \" AND \" + value2+ \"CLASSES =\"+value1.getClass()); \n                if(!(value1 instanceof Integer) || !(value2 instanceof Integer))\n                    return false;\n                else {\n                    int v1 = ((Integer)value1).intValue();\n                    int v2 = ((Integer)value2).intValue();\n                    System.out.println(\"COMPARING \"+ v1+ \" AND \" + v2);\n                \n                    if(v1 == v2) \n                        return true;\n                    else \n                        return false;\n                }\n            }\n        };\n        Operator gtOperator = new DefaultOperator(\"smaller\",\"<\",true) {\n            public boolean compare(Statement s1,Statement s2) {\n                Object value1  = s1.getValue();\n                Object value2 = s2.getValue();\n                if(!(value1 instanceof Integer) || !(value2 instanceof Integer))\n                    return false;\n                else {\n                    int v1 = ((Integer)value1).intValue();\n                    int v2 = ((Integer)value2).intValue();\n                    if(v1 > v2) \n                        return true;\n                    else \n                        return false;\n                }\n            }\n        };\n        Operator ltOperator = new DefaultOperator(\"greater\",\">\",true) {\n            public boolean compare(Statement s1,Statement s2) {\n                Object value1  = s1.getValue();\n                Object value2 = s2.getValue();\n                if(!(value1 instanceof Integer) || !(value2 instanceof Integer))\n                    return false;\n                else {\n                    int v1 = ((Integer)value1).intValue();\n                    int v2 = ((Integer)value2).intValue();\n                    if(v1 < v2) \n                        return true;\n                    else \n                        return false;\n                }\n            }\n        };\n                      \n        Type type = new DefaultType(Type.INTEGER_TYPE);\n        type.getOperators().add(eqOperator);   \n        type.getOperators().add(gtOperator);\n        type.getOperators().add(ltOperator);\n        return type;\n         */\n    }","commit_id":"a0d3122e5d376eab3d9713a879366f62e1cad096","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n\tpublic void enableLocalStaging(\n\t\t\tlong userId, Group liveGroup, boolean branchingPublic,\n\t\t\tboolean branchingPrivate, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tif (liveGroup.isStagedRemotely()) {\n\t\t\tdisableStaging(liveGroup, serviceContext);\n\t\t}\n\n\t\tif (!liveGroup.hasStagingGroup()) {\n\t\t\tserviceContext.setAttribute(\"staging\", String.valueOf(true));\n\n\t\t\tGroup stagingGroup = addStagingGroup(\n\t\t\t\tuserId, liveGroup, serviceContext);\n\n\t\t\tMap<String, String[]> parameterMap =\n\t\t\t\tStagingUtil.getStagingParameters();\n\n\t\t\tif (liveGroup.hasPrivateLayouts()) {\n\t\t\t\tStagingUtil.publishLayouts(\n\t\t\t\t\tuserId, liveGroup.getGroupId(), stagingGroup.getGroupId(),\n\t\t\t\t\ttrue, parameterMap, null, null);\n\t\t\t}\n\n\t\t\tif (liveGroup.hasPublicLayouts() ||\n\t\t\t\t!liveGroup.hasPrivateLayouts()) {\n\n\t\t\t\tStagingUtil.publishLayouts(\n\t\t\t\t\tuserId, liveGroup.getGroupId(), stagingGroup.getGroupId(),\n\t\t\t\t\tfalse, parameterMap, null, null);\n\t\t\t}\n\t\t}\n\n\t\tcheckDefaultLayoutSetBranches(\n\t\t\tuserId, liveGroup, branchingPublic, branchingPrivate, false,\n\t\t\tserviceContext);\n\n\t\tUnicodeProperties typeSettingsProperties =\n\t\t\tliveGroup.getTypeSettingsProperties();\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"branchingPrivate\", String.valueOf(branchingPrivate));\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"branchingPublic\", String.valueOf(branchingPublic));\n\t\ttypeSettingsProperties.setProperty(\"staged\", Boolean.TRUE.toString());\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"stagedRemotely\", String.valueOf(false));\n\n\t\tsetCommonStagingOptions(\n\t\t\tliveGroup, typeSettingsProperties, serviceContext);\n\n\t\tgroupLocalService.updateGroup(\n\t\t\tliveGroup.getGroupId(), typeSettingsProperties.toString());\n\t}","id":25075,"modified_method":"@Override\n\tpublic void enableLocalStaging(\n\t\t\tlong userId, Group liveGroup, boolean branchingPublic,\n\t\t\tboolean branchingPrivate, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tif (liveGroup.isStagedRemotely()) {\n\t\t\tdisableStaging(liveGroup, serviceContext);\n\t\t}\n\n\t\tboolean hasStagingGroup = liveGroup.hasStagingGroup();\n\n\t\tif (!hasStagingGroup) {\n\t\t\tserviceContext.setAttribute(\"staging\", String.valueOf(true));\n\n\t\t\taddStagingGroup(userId, liveGroup, serviceContext);\n\t\t}\n\n\t\tcheckDefaultLayoutSetBranches(\n\t\t\tuserId, liveGroup, branchingPublic, branchingPrivate, false,\n\t\t\tserviceContext);\n\n\t\tUnicodeProperties typeSettingsProperties =\n\t\t\tliveGroup.getTypeSettingsProperties();\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"branchingPrivate\", String.valueOf(branchingPrivate));\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"branchingPublic\", String.valueOf(branchingPublic));\n\t\ttypeSettingsProperties.setProperty(\"staged\", Boolean.TRUE.toString());\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"stagedRemotely\", String.valueOf(false));\n\n\t\tsetCommonStagingOptions(\n\t\t\tliveGroup, typeSettingsProperties, serviceContext);\n\n\t\tgroupLocalService.updateGroup(\n\t\t\tliveGroup.getGroupId(), typeSettingsProperties.toString());\n\n\t\tif (!hasStagingGroup) {\n\t\t\tGroup stagingGroup = liveGroup.getStagingGroup();\n\n\t\t\tMap<String, String[]> parameterMap =\n\t\t\t\tStagingUtil.getStagingParameters();\n\n\t\t\tif (liveGroup.hasPrivateLayouts()) {\n\t\t\t\tStagingUtil.publishLayouts(\n\t\t\t\t\tuserId, liveGroup.getGroupId(), stagingGroup.getGroupId(),\n\t\t\t\t\ttrue, parameterMap, null, null);\n\t\t\t}\n\n\t\t\tif (liveGroup.hasPublicLayouts() ||\n\t\t\t\t!liveGroup.hasPrivateLayouts()) {\n\n\t\t\t\tStagingUtil.publishLayouts(\n\t\t\t\t\tuserId, liveGroup.getGroupId(), stagingGroup.getGroupId(),\n\t\t\t\t\tfalse, parameterMap, null, null);\n\t\t\t}\n\t\t}\n\t}","commit_id":"b2131c112627031166ddd917c3528ebaaf893aa1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int doStartTag() {\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\n\t\tGroup group = (Group)request.getAttribute(WebKeys.GROUP);\n\n\t\ttry {\n\t\t\tif (groupId > 0) {\n\t\t\t\tgroup = GroupLocalServiceUtil.getGroup(groupId);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tif (group == null) {\n\t\t\tgroup = themeDisplay.getScopeGroup();\n\t\t}\n\n\t\tif (group == null) {\n\t\t\treturn SKIP_BODY;\n\t\t}\n\n\t\tlong liveGroupId = group.getGroupId();\n\t\tlong stagingGroupId = group.getGroupId();\n\n\t\tGroup liveGroup = group;\n\t\tGroup stagingGroup = group;\n\n\t\tif (group.isStagingGroup() && !group.isStagedRemotely()) {\n\t\t\tliveGroup = group.getLiveGroup();\n\n\t\t\tliveGroupId = liveGroup.getGroupId();\n\t\t}\n\n\t\tif (group.hasStagingGroup() && !group.isStagedRemotely()) {\n\t\t\tstagingGroup = group.getStagingGroup();\n\n\t\t\tstagingGroupId = stagingGroup.getGroupId();\n\t\t}\n\n\t\tpageContext.setAttribute(\"group\", group);\n\t\tpageContext.setAttribute(\"groupId\", groupId);\n\t\tpageContext.setAttribute(\"liveGroup\", liveGroup);\n\t\tpageContext.setAttribute(\"liveGroupId\", liveGroupId);\n\t\tpageContext.setAttribute(\"stagingGroup\", stagingGroup);\n\t\tpageContext.setAttribute(\"stagingGroupId\", stagingGroupId);\n\t\tpageContext.setAttribute(\n\t\t\t\"privateLayout\", ParamUtil.getBoolean(request, \"privateLayout\"));\n\n\t\treturn SKIP_BODY;\n\t}","id":25076,"modified_method":"@Override\n\tpublic int doStartTag() {\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\n\t\tGroup group = GroupLocalServiceUtil.fetchGroup(groupId);\n\n\t\tif (group == null) {\n\t\t\tgroup = (Group)request.getAttribute(WebKeys.GROUP);\n\t\t}\n\n\t\tif (group == null) {\n\t\t\tgroup = themeDisplay.getScopeGroup();\n\t\t}\n\n\t\tif (group == null) {\n\t\t\treturn SKIP_BODY;\n\t\t}\n\n\t\tlong liveGroupId = group.getGroupId();\n\t\tlong stagingGroupId = group.getGroupId();\n\n\t\tGroup liveGroup = group;\n\t\tGroup stagingGroup = group;\n\n\t\tif (!group.isStagedRemotely()) {\n\t\t\tif (group.isStagingGroup()) {\n\t\t\t\tliveGroup = group.getLiveGroup();\n\n\t\t\t\tliveGroupId = liveGroup.getGroupId();\n\t\t\t}\n\n\t\t\tif (group.hasStagingGroup()) {\n\t\t\t\tstagingGroup = group.getStagingGroup();\n\n\t\t\t\tstagingGroupId = stagingGroup.getGroupId();\n\t\t\t}\n\t\t}\n\n\t\tpageContext.setAttribute(\"group\", group);\n\t\tpageContext.setAttribute(\"groupId\", groupId);\n\t\tpageContext.setAttribute(\"liveGroup\", liveGroup);\n\t\tpageContext.setAttribute(\"liveGroupId\", liveGroupId);\n\t\tpageContext.setAttribute(\"stagingGroup\", stagingGroup);\n\t\tpageContext.setAttribute(\"stagingGroupId\", stagingGroupId);\n\t\tpageContext.setAttribute(\n\t\t\t\"privateLayout\", ParamUtil.getBoolean(request, \"privateLayout\"));\n\n\t\treturn SKIP_BODY;\n\t}","commit_id":"20c7706f8f241c5409d7ad03747d7a489f77507a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateStaging(PortletRequest portletRequest, Group liveGroup)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tlong userId = permissionChecker.getUserId();\n\n\t\tGroup scopeGroup = themeDisplay.getScopeGroup();\n\n\t\tif (!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, liveGroup.getGroupId(),\n\t\t\t\tActionKeys.MANAGE_STAGING)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tint stagingType = ParamUtil.getInteger(portletRequest, \"stagingType\");\n\n\t\tboolean branchingPublic = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"branchingPublic\");\n\t\tboolean branchingPrivate = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"branchingPrivate\");\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextThreadLocal.getServiceContext();\n\n\t\tif (stagingType == StagingConstants.TYPE_NOT_STAGED) {\n\t\t\tif (liveGroup.hasStagingGroup()) {\n\t\t\t\tdisableStaging(\n\t\t\t\t\tportletRequest, scopeGroup, liveGroup, serviceContext);\n\t\t\t}\n\t\t}\n\t\telse if (stagingType == StagingConstants.TYPE_LOCAL_STAGING) {\n\t\t\tenableLocalStaging(\n\t\t\t\tuserId, scopeGroup, liveGroup, branchingPublic,\n\t\t\t\tbranchingPrivate, serviceContext);\n\t\t}\n\t\telse if (stagingType == StagingConstants.TYPE_REMOTE_STAGING) {\n\t\t\tString remoteAddress = ParamUtil.getString(\n\t\t\t\tportletRequest, \"remoteAddress\");\n\t\t\tlong remoteGroupId = ParamUtil.getLong(\n\t\t\t\tportletRequest, \"remoteGroupId\");\n\t\t\tint remotePort = ParamUtil.getInteger(portletRequest, \"remotePort\");\n\t\t\tboolean secureConnection = ParamUtil.getBoolean(\n\t\t\t\tportletRequest, \"secureConnection\");\n\n\t\t\tenableRemoteStaging(\n\t\t\t\tuserId, scopeGroup, liveGroup, branchingPublic,\n\t\t\t\tbranchingPrivate, remoteAddress, remoteGroupId, remotePort,\n\t\t\t\tsecureConnection, serviceContext);\n\t\t}\n\t}","id":25077,"modified_method":"public void updateStaging(PortletRequest portletRequest, Group liveGroup)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tlong userId = permissionChecker.getUserId();\n\n\t\tGroup scopeGroup = themeDisplay.getScopeGroup();\n\n\t\tif (!GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, liveGroup.getGroupId(),\n\t\t\t\tActionKeys.MANAGE_STAGING)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tint stagingType = ParamUtil.getInteger(portletRequest, \"stagingType\");\n\n\t\tboolean branchingPublic = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"branchingPublic\");\n\t\tboolean branchingPrivate = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"branchingPrivate\");\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextThreadLocal.getServiceContext();\n\n\t\tif (stagingType == StagingConstants.TYPE_NOT_STAGED) {\n\t\t\tif (liveGroup.hasStagingGroup() || liveGroup.isStagedRemotely()) {\n\t\t\t\tdisableStaging(\n\t\t\t\t\tportletRequest, scopeGroup, liveGroup, serviceContext);\n\t\t\t}\n\t\t}\n\t\telse if (stagingType == StagingConstants.TYPE_LOCAL_STAGING) {\n\t\t\tenableLocalStaging(\n\t\t\t\tuserId, scopeGroup, liveGroup, branchingPublic,\n\t\t\t\tbranchingPrivate, serviceContext);\n\t\t}\n\t\telse if (stagingType == StagingConstants.TYPE_REMOTE_STAGING) {\n\t\t\tString remoteAddress = ParamUtil.getString(\n\t\t\t\tportletRequest, \"remoteAddress\");\n\t\t\tlong remoteGroupId = ParamUtil.getLong(\n\t\t\t\tportletRequest, \"remoteGroupId\");\n\t\t\tint remotePort = ParamUtil.getInteger(portletRequest, \"remotePort\");\n\t\t\tboolean secureConnection = ParamUtil.getBoolean(\n\t\t\t\tportletRequest, \"secureConnection\");\n\n\t\t\tenableRemoteStaging(\n\t\t\t\tuserId, scopeGroup, liveGroup, branchingPublic,\n\t\t\t\tbranchingPrivate, remoteAddress, remoteGroupId, remotePort,\n\t\t\t\tsecureConnection, serviceContext);\n\t\t}\n\t}","commit_id":"ed82cdb3dc100fbfce9c8e2bd86cf6c8545afa77","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Test asserting OAK-3348: Cross gc sessions might introduce references to pre-compacted segments\n     */\n    @Test\n    @Ignore(\"OAK-3348\")  // FIXME OAK-3348\n    public void preCompactionReferences() throws IOException, CommitFailedException, InterruptedException {\n        for (String ref : new String[] {\"merge-before-compact\", \"merge-after-compact\"}) {\n            File repoDir = new File(directory, ref);\n            FileStore fileStore = newFileStore(repoDir).withMaxFileSize(2).create();\n            final SegmentNodeStore nodeStore = newSegmentNodeStore(fileStore).create();\n            fileStore.setCompactionStrategy(new CompactionStrategy(true, false, CLEAN_NONE, 0, (byte) 5) {\n                @Override\n                public boolean compacted(Callable<Boolean> setHead) throws Exception {\n                    return nodeStore.locked(setHead);\n                }\n            });\n\n            try {\n                // add some content\n                NodeBuilder root = nodeStore.getRoot().builder();\n                root.setChildNode(\"test\").setProperty(\"blob\", createBlob(nodeStore, 1024 * 1024));\n                nodeStore.merge(root, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n                // remove it again so we have something to gc\n                root = nodeStore.getRoot().builder();\n                root.getChildNode(\"test\").remove();\n                nodeStore.merge(root, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n                // with a new builder simulate exceeding the update limit.\n                // This will cause changes to be pre-written to segments\n                root = nodeStore.getRoot().builder();\n                for (int k = 0; k < getInteger(\"update.limit\", 10000); k += 2) {\n                    root.setChildNode(\"test\").remove();\n                }\n                root.setChildNode(\"test\");\n\n                // case 1: merge above changes before compact\n                if (\"merge-before-compact\".equals(ref)) {\n                    nodeStore.merge(root, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n                }\n\n                fileStore.compact();\n\n                // case 2: merge above changes after compact\n                if (\"merge-after-compact\".equals(ref)) {\n                    nodeStore.merge(root, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n                }\n            } finally {\n                fileStore.close();\n            }\n\n            // Re-initialise the file store to simulate off-line gc\n            fileStore = newFileStore(repoDir).withMaxFileSize(2).create();\n            try {\n                // The 1M blob should get gc-ed. This works for case 1.\n                // However it doesn't for case 2 as merging after compaction\n                // apparently creates references from the current segment\n                // to the pre-compacted segment to which above changes have\n                // been pre-written.\n                fileStore.cleanup();\n                assertTrue(ref + \" repository size \" + fileStore.size() + \" < \" + 1024 * 1024,\n                        fileStore.size() < 1024 * 1024);\n            } finally {\n                fileStore.close();\n            }\n        }\n    }","id":25078,"modified_method":"/**\n     * Test asserting OAK-3348: Cross gc sessions might introduce references to pre-compacted segments\n     */\n    @Test\n    @Ignore(\"OAK-3348\")  // FIXME OAK-3348\n    public void preCompactionReferences() throws IOException, CommitFailedException, InterruptedException {\n        for (String ref : new String[] {\"merge-before-compact\", \"merge-after-compact\"}) {\n            File repoDir = new File(directory, ref);\n            FileStore fileStore = newFileStore(repoDir).withMaxFileSize(2).create();\n            final SegmentNodeStore nodeStore = newSegmentNodeStore(fileStore).create();\n            fileStore.setCompactionStrategy(new CompactionStrategy(true, false, CLEAN_NONE, 0, (byte) 5) {\n                @Override\n                public boolean compacted(Callable<Boolean> setHead) throws Exception {\n                    return nodeStore.locked(setHead);\n                }\n            });\n\n            try {\n                // add some content\n                NodeBuilder preGCBuilder = nodeStore.getRoot().builder();\n                preGCBuilder.setChildNode(\"test\").setProperty(\"blob\", createBlob(nodeStore, 1024 * 1024));\n                nodeStore.merge(preGCBuilder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n                // remove it again so we have something to gc\n                preGCBuilder = nodeStore.getRoot().builder();\n                preGCBuilder.getChildNode(\"test\").remove();\n                nodeStore.merge(preGCBuilder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n                // with a new builder simulate exceeding the update limit.\n                // This will cause changes to be pre-written to segments\n                preGCBuilder = nodeStore.getRoot().builder();\n                preGCBuilder.setChildNode(\"test\").setChildNode(\"a\").setChildNode(\"b\").setProperty(\"foo\", \"bar\");\n                for (int k = 0; k < getInteger(\"update.limit\", 10000); k += 2) {\n                    preGCBuilder.setChildNode(\"dummy\").remove();\n                }\n\n                // case 1: merge above changes before compact\n                if (\"merge-before-compact\".equals(ref)) {\n                    NodeBuilder builder = nodeStore.getRoot().builder();\n                    builder.setChildNode(\"n\");\n                    nodeStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n                    nodeStore.merge(preGCBuilder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n                }\n\n                fileStore.compact();\n\n                // case 2: merge above changes after compact\n                if (\"merge-after-compact\".equals(ref)) {\n                    NodeBuilder builder = nodeStore.getRoot().builder();\n                    builder.setChildNode(\"n\");\n                    nodeStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n                    nodeStore.merge(preGCBuilder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n                }\n            } finally {\n                fileStore.close();\n            }\n\n            // Re-initialise the file store to simulate off-line gc\n            fileStore = newFileStore(repoDir).withMaxFileSize(2).create();\n            try {\n                // The 1M blob should get gc-ed. This works for case 1.\n                // However it doesn't for case 2 as merging after compaction\n                // apparently creates references from the current segment\n                // to the pre-compacted segment to which above changes have\n                // been pre-written.\n                fileStore.cleanup();\n                assertTrue(ref + \" repository size \" + fileStore.size() + \" < \" + 1024 * 1024,\n                        fileStore.size() < 1024 * 1024);\n            } finally {\n                fileStore.close();\n            }\n        }\n    }","commit_id":"0eb400b80c16efa6c32f2a9a13b822e2154af23b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Return all residual node definitions.\n     *\n     * @return All residual node definitions.\n     */\n    @Nonnull\n    public Iterable<NodeDefinition> getResidualNodeDefinitions() {\n        return Iterables.concat(Iterables.transform(\n                nodeTypes.values(),\n                new Function<NodeTypeImpl, Iterable<NodeDefinition>>() {\n                    @Override\n                    public Iterable<NodeDefinition> apply(NodeTypeImpl input) {\n                        return input.getDeclaredResidualNodeDefinitions();\n                    }\n                }));\n    }","id":25079,"modified_method":"/**\n     * Return all residual node definitions.\n     *\n     * @return All residual node definitions.\n     */\n    @Nonnull\n    public Iterable<NodeDefinition> getResidualNodeDefinitions() {\n        List<NodeDefinition> definitions = newArrayList();\n        for (NodeTypeImpl type : nodeTypes.values()) {\n            definitions.addAll(type.getDeclaredResidualNodeDefinitions());\n        }\n        return definitions;\n    }","commit_id":"4e6e8d6a9178f690715e69cb626eaa167bca03da","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Return all residual property definitions.\n     *\n     * @return All residual property definitions.\n     */\n    @Nonnull\n    public Iterable<PropertyDefinition> getResidualPropertyDefinitions() {\n        return Iterables.concat(Iterables.transform(\n                nodeTypes.values(),\n                new Function<NodeTypeImpl, Iterable<PropertyDefinition>>() {\n                    @Override\n                    public Iterable<PropertyDefinition> apply(NodeTypeImpl input) {\n                        return input.getDeclaredResidualPropertyDefinitions();\n                    }\n                }));\n    }","id":25080,"modified_method":"/**\n     * Return all residual property definitions.\n     *\n     * @return All residual property definitions.\n     */\n    @Nonnull\n    public Iterable<PropertyDefinition> getResidualPropertyDefinitions() {\n        List<PropertyDefinition> definitions = newArrayList();\n        for (NodeTypeImpl type : nodeTypes.values()) {\n            definitions.addAll(type.getDeclaredResidualPropertyDefinitions());\n        }\n        return definitions;\n    }","commit_id":"4e6e8d6a9178f690715e69cb626eaa167bca03da","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Return all property definitions that match the specified oak name.\n     *\n     * @param oakName An internal oak name.\n     * @return All property definitions that match the given internal oak name.\n     */\n    @Nonnull\n    public Iterable<PropertyDefinition> getNamedPropertyDefinitions(\n            final String oakName) {\n        return Iterables.concat(Iterables.transform(\n                nodeTypes.values(),\n                new Function<NodeTypeImpl, Iterable<PropertyDefinition>>() {\n                    @Override\n                    public Iterable<PropertyDefinition> apply(NodeTypeImpl input) {\n                        return input.getDeclaredNamedPropertyDefinitions(oakName);\n                    }\n                }));\n    }","id":25081,"modified_method":"/**\n     * Return all property definitions that match the specified oak name.\n     *\n     * @param oakName An internal oak name.\n     * @return All property definitions that match the given internal oak name.\n     */\n    @Nonnull\n    public Iterable<PropertyDefinition> getNamedPropertyDefinitions(\n            String oakName) {\n        List<PropertyDefinition> definitions = newArrayList();\n        for (NodeTypeImpl type : nodeTypes.values()) {\n            definitions.addAll(type.getDeclaredNamedPropertyDefinitions(oakName));\n        }\n        return definitions;\n    }","commit_id":"4e6e8d6a9178f690715e69cb626eaa167bca03da","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"Iterable<NodeDefinition> getDeclaredResidualNodeDefinitions() {\n        Tree definitions = definition.getChild(\"oak:residualChildNodeDefinitions\");\n        return Iterables.transform(\n                definitions.getChildren(),\n                new Function<Tree, NodeDefinition>() {\n                    @Override\n                    public NodeDefinition apply(Tree input) {\n                        return new NodeDefinitionImpl(\n                                input, NodeTypeImpl.this, mapper);\n                    }\n                });\n    }","id":25082,"modified_method":"List<NodeDefinition> getDeclaredResidualNodeDefinitions() {\n        return getDeclaredNodeDefs(definition\n                .getChild(OAK_RESIDUAL_CHILD_NODE_DEFINITIONS));\n    }","commit_id":"4e6e8d6a9178f690715e69cb626eaa167bca03da","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"Iterable<PropertyDefinition> getDeclaredResidualPropertyDefinitions() {\n        Tree definitions = definition.getChild(\"oak:residualPropertyDefinitions\");\n        return Iterables.transform(\n                definitions.getChildren(),\n                new Function<Tree, PropertyDefinition>() {\n                    @Override\n                    public PropertyDefinition apply(Tree input) {\n                        return new PropertyDefinitionImpl(\n                                input, NodeTypeImpl.this, mapper);\n                    }\n                });\n    }","id":25083,"modified_method":"List<PropertyDefinition> getDeclaredResidualPropertyDefinitions() {\n        return getDeclaredPropertyDefs(definition\n                .getChild(OAK_RESIDUAL_PROPERTY_DEFINITIONS));\n    }","commit_id":"4e6e8d6a9178f690715e69cb626eaa167bca03da","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"Iterable<PropertyDefinition> getDeclaredNamedPropertyDefinitions(String oakName) {\n        Tree named = definition.getChild(\"oak:namedPropertyDefinitions\");\n        if (named.exists()) {\n            String escapedName;\n            if (JCR_PRIMARYTYPE.equals(oakName)) {\n                escapedName = \"oak:primaryType\";\n            } else if (JCR_MIXINTYPES.equals(oakName)) {\n                escapedName = \"oak:mixinTypes\";\n            } else if (JCR_UUID.equals(oakName)) {\n                escapedName = \"oak:uuid\";\n            } else {\n                escapedName = oakName;\n            }\n            Tree definitions = named.getChild(escapedName);\n            return Iterables.transform(\n                    definitions.getChildren(),\n                    new Function<Tree, PropertyDefinition>() {\n                        @Override\n                        public PropertyDefinition apply(Tree input) {\n                            return new PropertyDefinitionImpl(\n                                    input, NodeTypeImpl.this, mapper);\n                        }\n                    });\n        }\n        return Collections.emptyList();\n    }","id":25084,"modified_method":"List<PropertyDefinition> getDeclaredNamedPropertyDefinitions(String oakName) {\n        String escapedName = oakName;\n        if (JCR_PRIMARYTYPE.equals(oakName)) {\n            escapedName = OAK_PRIMARY_TYPE;\n        } else if (JCR_MIXINTYPES.equals(oakName)) {\n            escapedName = OAK_MIXIN_TYPES;\n        } else if (JCR_UUID.equals(oakName)) {\n            escapedName = OAK_UUID;\n        }\n        return getDeclaredPropertyDefs(definition\n                .getChild(OAK_NAMED_PROPERTY_DEFINITIONS)\n                .getChild(escapedName));\n    }","commit_id":"4e6e8d6a9178f690715e69cb626eaa167bca03da","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"Iterable<NodeDefinition> getDeclaredNamedNodeDefinitions(String oakName) {\n        Tree definitions = definition.getChild(\"oak:namedChildNodeDefinitions\").getChild(oakName);\n        return Iterables.transform(\n                definitions.getChildren(),\n                new Function<Tree, NodeDefinition>() {\n                    @Override\n                    public NodeDefinition apply(Tree input) {\n                        return new NodeDefinitionImpl(\n                                input, NodeTypeImpl.this, mapper);\n                    }\n                });\n    }","id":25085,"modified_method":"List<NodeDefinition> getDeclaredNamedNodeDefinitions(String oakName) {\n        return getDeclaredNodeDefs(definition\n                .getChild(OAK_NAMED_CHILD_NODE_DEFINITIONS)\n                .getChild(oakName));\n    }","commit_id":"4e6e8d6a9178f690715e69cb626eaa167bca03da","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Validates and pre-compiles the named node type.\n     *\n     * @param types builder for the /jcr:system/jcr:nodeTypes node\n     * @param name name of the node type to validate and compile\n     * @throws CommitFailedException if type validation fails\n     */\n    private void validateAndCompileType(NodeBuilder types, String name)\n            throws CommitFailedException {\n        NodeBuilder type = types.child(name);\n\n        // - jcr:nodeTypeName (NAME) protected mandatory\n        PropertyState nodeTypeName = type.getProperty(JCR_NODETYPENAME);\n        if (nodeTypeName == null\n                || !name.equals(nodeTypeName.getValue(NAME))) {\n            throw new CommitFailedException(\n                    CONSTRAINT, 34,\n                    \"Unexpected \" + JCR_NODETYPENAME + \" in type \" + name);\n        }\n\n        // Prepare the type node pre-compilation of the oak:nodeType info\n        Iterable<String> empty = emptyList();\n        type.setProperty(JCR_PRIMARYTYPE, \"oak:nodeType\", NAME);\n        type.removeProperty(OAK_SUPERTYPES);\n        type.setProperty(OAK_PRIMARY_SUBTYPES, empty, NAMES);\n        type.setProperty(OAK_MANDATORY_PROPERTIES, empty, NAMES);\n        type.setProperty(OAK_MANDATORY_CHILD_NODES, empty, NAMES);\n        type.setProperty(OAK_PROTECTED_PROPERTIES, empty, NAMES);\n        type.setProperty(OAK_PROTECTED_CHILD_NODES, empty, NAMES);\n        type.setProperty(OAK_HAS_PROTECTED_RESIDUAL_PROPERTIES, false, BOOLEAN);\n        type.setProperty(OAK_HAS_PROTECTED_RESIDUAL_CHILD_NODES, false, BOOLEAN);\n        type.setProperty(OAK_NAMED_SINGLE_VALUED_PROPERTIES, empty, NAMES);\n        type.getChildNode(OAK_NAMED_PROPERTY_DEFINITIONS).remove();\n        type.getChildNode(OAK_RESIDUAL_PROPERTY_DEFINITIONS).remove();\n        type.getChildNode(OAK_NAMED_CHILD_NODE_DEFINITIONS).remove();\n        type.getChildNode(OAK_RESIDUAL_CHILD_NODE_DEFINITIONS).remove();\n\n        // + jcr:propertyDefinition (nt:propertyDefinition)\n        //   = nt:propertyDefinition protected sns\n        // + jcr:childNodeDefinition (nt:childNodeDefinition)\n        //   = nt:childNodeDefinition protected sns\n        for (String childNodeName : type.getChildNodeNames()) {\n            NodeState definition = type.child(childNodeName).getNodeState();\n            if (childNodeName.startsWith(JCR_PROPERTYDEFINITION)) {\n                validateAndCompilePropertyDefinition(type, definition);\n            } else if (childNodeName.startsWith(JCR_CHILDNODEDEFINITION)) {\n                validateAndCompileChildNodeDefinition(types, type, definition);\n            }\n        }\n    }","id":25086,"modified_method":"/**\n     * Validates and pre-compiles the named node type.\n     *\n     * @param types builder for the /jcr:system/jcr:nodeTypes node\n     * @param name name of the node type to validate and compile\n     * @throws CommitFailedException if type validation fails\n     */\n    private void validateAndCompileType(NodeBuilder types, String name)\n            throws CommitFailedException {\n        NodeBuilder type = types.child(name);\n\n        // - jcr:nodeTypeName (NAME) protected mandatory\n        PropertyState nodeTypeName = type.getProperty(JCR_NODETYPENAME);\n        if (nodeTypeName == null\n                || !name.equals(nodeTypeName.getValue(NAME))) {\n            throw new CommitFailedException(\n                    CONSTRAINT, 34,\n                    \"Unexpected \" + JCR_NODETYPENAME + \" in type \" + name);\n        }\n\n        // Prepare the type node pre-compilation of the oak:nodeType info\n        Iterable<String> empty = emptyList();\n        type.setProperty(JCR_PRIMARYTYPE, \"oak:nodeType\", NAME);\n        type.removeProperty(OAK_SUPERTYPES);\n        type.setProperty(OAK_PRIMARY_SUBTYPES, empty, NAMES);\n        type.setProperty(OAK_MANDATORY_PROPERTIES, empty, NAMES);\n        type.setProperty(OAK_MANDATORY_CHILD_NODES, empty, NAMES);\n        type.setProperty(OAK_PROTECTED_PROPERTIES, empty, NAMES);\n        type.setProperty(OAK_PROTECTED_CHILD_NODES, empty, NAMES);\n        type.setProperty(OAK_HAS_PROTECTED_RESIDUAL_PROPERTIES, false, BOOLEAN);\n        type.setProperty(OAK_HAS_PROTECTED_RESIDUAL_CHILD_NODES, false, BOOLEAN);\n        type.setProperty(OAK_NAMED_SINGLE_VALUED_PROPERTIES, empty, NAMES);\n        type.getChildNode(OAK_NAMED_PROPERTY_DEFINITIONS).remove();\n        type.getChildNode(OAK_RESIDUAL_PROPERTY_DEFINITIONS).remove();\n        type.getChildNode(OAK_NAMED_CHILD_NODE_DEFINITIONS).remove();\n        type.getChildNode(OAK_RESIDUAL_CHILD_NODE_DEFINITIONS).remove();\n\n        // + jcr:propertyDefinition (nt:propertyDefinition)\n        //   = nt:propertyDefinition protected sns\n        // + jcr:childNodeDefinition (nt:childNodeDefinition)\n        //   = nt:childNodeDefinition protected sns\n        for (String childNodeName : type.getChildNodeNames()) {\n            NodeState definition = type.child(childNodeName).getNodeState();\n            if (childNodeName.startsWith(JCR_PROPERTYDEFINITION)) {\n                validateAndCompilePropertyDefinition(type, name, definition);\n            } else if (childNodeName.startsWith(JCR_CHILDNODEDEFINITION)) {\n                validateAndCompileChildNodeDefinition(types, type, name, definition);\n            }\n        }\n    }","commit_id":"4e6e8d6a9178f690715e69cb626eaa167bca03da","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void validateAndCompileChildNodeDefinition(\n            NodeBuilder types, NodeBuilder type, NodeState definition)\n            throws CommitFailedException {\n        // - jcr:name (NAME) protected \n        PropertyState name = definition.getProperty(JCR_NAME);\n        NodeBuilder definitions;\n        if (name != null) {\n            String childNodeName = name.getValue(NAME);\n            definitions = type.child(OAK_NAMED_CHILD_NODE_DEFINITIONS);\n            definitions.setProperty(\n                    JCR_PRIMARYTYPE, OAK_NAMED_CHILD_NODE_DEFINITIONS, NAME);\n            definitions = definitions.child(childNodeName);\n\n            // - jcr:mandatory (BOOLEAN) protected mandatory\n            if (definition.getBoolean(JCR_MANDATORY)) {\n                addNameToList(type, OAK_MANDATORY_CHILD_NODES, childNodeName);\n            }\n            // - jcr:protected (BOOLEAN) protected mandatory\n            if (definition.getBoolean(JCR_PROTECTED)) {\n                addNameToList(type, OAK_PROTECTED_CHILD_NODES, childNodeName);\n            }\n        } else {\n            definitions = type.child(OAK_RESIDUAL_CHILD_NODE_DEFINITIONS);\n\n            // - jcr:protected (BOOLEAN) protected mandatory\n            if (definition.getBoolean(JCR_PROTECTED)) {\n                type.setProperty(OAK_HAS_PROTECTED_RESIDUAL_CHILD_NODES, true);\n            }\n        }\n        definitions.setProperty(\n                JCR_PRIMARYTYPE, OAK_CHILD_NODE_DEFINITIONS, NAME);\n\n        // - jcr:requiredPrimaryTypes (NAME)\n        //   = 'nt:base' protected mandatory multiple\n        PropertyState requiredTypes =\n                definition.getProperty(JCR_REQUIREDPRIMARYTYPES);\n        if (requiredTypes != null) {\n            for (String key : requiredTypes.getValue(NAMES)) {\n                if (!types.hasChildNode(key)) {\n                    throw new CommitFailedException(\n                            \"Constraint\", 33,\n                            \"Unknown required primary type \" + key);\n                } else if (!definitions.hasChildNode(key)) {\n                    definitions.setChildNode(key, definition);\n                }\n            }\n        }\n    }","id":25087,"modified_method":"private void validateAndCompileChildNodeDefinition(\n            NodeBuilder types, NodeBuilder type, String typeName,\n            NodeState definition) throws CommitFailedException {\n        // - jcr:name (NAME) protected \n        PropertyState name = definition.getProperty(JCR_NAME);\n        NodeBuilder definitions;\n        if (name != null) {\n            String childNodeName = name.getValue(NAME);\n            definitions = type.child(OAK_NAMED_CHILD_NODE_DEFINITIONS);\n            definitions.setProperty(\n                    JCR_PRIMARYTYPE, OAK_NAMED_CHILD_NODE_DEFINITIONS, NAME);\n            definitions = definitions.child(childNodeName);\n\n            // - jcr:mandatory (BOOLEAN) protected mandatory\n            if (definition.getBoolean(JCR_MANDATORY)) {\n                addNameToList(type, OAK_MANDATORY_CHILD_NODES, childNodeName);\n            }\n            // - jcr:protected (BOOLEAN) protected mandatory\n            if (definition.getBoolean(JCR_PROTECTED)) {\n                addNameToList(type, OAK_PROTECTED_CHILD_NODES, childNodeName);\n            }\n        } else {\n            definitions = type.child(OAK_RESIDUAL_CHILD_NODE_DEFINITIONS);\n\n            // - jcr:protected (BOOLEAN) protected mandatory\n            if (definition.getBoolean(JCR_PROTECTED)) {\n                type.setProperty(OAK_HAS_PROTECTED_RESIDUAL_CHILD_NODES, true);\n            }\n        }\n        definitions.setProperty(\n                JCR_PRIMARYTYPE, OAK_CHILD_NODE_DEFINITIONS, NAME);\n\n        // - jcr:requiredPrimaryTypes (NAME)\n        //   = 'nt:base' protected mandatory multiple\n        PropertyState requiredTypes =\n                definition.getProperty(JCR_REQUIREDPRIMARYTYPES);\n        if (requiredTypes != null) {\n            for (String key : requiredTypes.getValue(NAMES)) {\n                if (!types.hasChildNode(key)) {\n                    throw new CommitFailedException(\n                            \"Constraint\", 33,\n                            \"Unknown required primary type \" + key);\n                } else if (!definitions.hasChildNode(key)) {\n                    definitions.setChildNode(key, definition)\n                        .setProperty(JCR_PRIMARYTYPE, OAK_CHILD_NODE_DEFINITION, NAME)\n                        .setProperty(OAK_DECLARING_NODE_TYPE, typeName, NAME);\n                }\n            }\n        }\n    }","commit_id":"4e6e8d6a9178f690715e69cb626eaa167bca03da","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void validateAndCompilePropertyDefinition(\n            NodeBuilder type, NodeState definition)\n            throws CommitFailedException {\n        // - jcr:name (NAME) protected \n        PropertyState name = definition.getProperty(JCR_NAME);\n        NodeBuilder definitions;\n        String propertyName = null;\n        if (name != null) {\n            propertyName = name.getValue(NAME);\n            String escapedName = propertyName;\n            if (JCR_PRIMARYTYPE.equals(escapedName)) {\n                escapedName = \"oak:primaryType\";\n            } else if (JCR_MIXINTYPES.equals(escapedName)) {\n                escapedName = \"oak:mixinTypes\";\n            } else if (JCR_UUID.equals(escapedName)) {\n                escapedName = \"oak:uuid\";\n            }\n            definitions = type.child(OAK_NAMED_PROPERTY_DEFINITIONS);\n            definitions.setProperty(\n                    JCR_PRIMARYTYPE, OAK_NAMED_PROPERTY_DEFINITIONS, NAME);\n            definitions = definitions.child(escapedName);\n\n            // - jcr:mandatory (BOOLEAN) protected mandatory\n            if (definition.getBoolean(JCR_MANDATORY)) {\n                addNameToList(type, OAK_MANDATORY_PROPERTIES, propertyName);\n            }\n            // - jcr:protected (BOOLEAN) protected mandatory\n            if (definition.getBoolean(JCR_PROTECTED)) {\n                addNameToList(type, OAK_PROTECTED_PROPERTIES, propertyName);\n            }\n        } else {\n            definitions = type.child(OAK_RESIDUAL_PROPERTY_DEFINITIONS);\n\n            // - jcr:protected (BOOLEAN) protected mandatory\n            if (definition.getBoolean(JCR_PROTECTED)) {\n                type.setProperty(OAK_HAS_PROTECTED_RESIDUAL_PROPERTIES, true);\n            }\n        }\n        definitions.setProperty(\n                JCR_PRIMARYTYPE, OAK_PROPERTY_DEFINITIONS, NAME);\n\n        // - jcr:requiredType (STRING) protected mandatory\n        // < 'STRING', 'URI', 'BINARY', 'LONG', 'DOUBLE',\n        //   'DECIMAL', 'BOOLEAN', 'DATE', 'NAME', 'PATH',\n        //   'REFERENCE', 'WEAKREFERENCE', 'UNDEFINED'\n        String key = \"UNDEFINED\";\n        PropertyState requiredType = definition.getProperty(JCR_REQUIREDTYPE);\n        if (requiredType != null) {\n            key = requiredType.getValue(STRING);\n        }\n\n        // - jcr:multiple (BOOLEAN) protected mandatory\n        if (definition.getBoolean(JCR_MULTIPLE)) {\n            if (\"BINARY\".equals(key)) {\n                key = \"BINARIES\";\n            } else {\n                key = key + \"S\";\n            }\n        } else if (propertyName != null) {\n            addNameToList(type, OAK_NAMED_SINGLE_VALUED_PROPERTIES, propertyName);\n        }\n\n        definitions.setChildNode(key, definition);\n    }","id":25088,"modified_method":"private void validateAndCompilePropertyDefinition(\n            NodeBuilder type, String typeName, NodeState definition)\n            throws CommitFailedException {\n        // - jcr:name (NAME) protected \n        PropertyState name = definition.getProperty(JCR_NAME);\n        NodeBuilder definitions;\n        String propertyName = null;\n        if (name != null) {\n            propertyName = name.getValue(NAME);\n            String escapedName = propertyName;\n            if (JCR_PRIMARYTYPE.equals(escapedName)) {\n                escapedName = OAK_PRIMARY_TYPE;\n            } else if (JCR_MIXINTYPES.equals(escapedName)) {\n                escapedName = OAK_MIXIN_TYPES;\n            } else if (JCR_UUID.equals(escapedName)) {\n                escapedName = OAK_UUID;\n            }\n            definitions = type.child(OAK_NAMED_PROPERTY_DEFINITIONS);\n            definitions.setProperty(\n                    JCR_PRIMARYTYPE, OAK_NAMED_PROPERTY_DEFINITIONS, NAME);\n            definitions = definitions.child(escapedName);\n\n            // - jcr:mandatory (BOOLEAN) protected mandatory\n            if (definition.getBoolean(JCR_MANDATORY)) {\n                addNameToList(type, OAK_MANDATORY_PROPERTIES, propertyName);\n            }\n            // - jcr:protected (BOOLEAN) protected mandatory\n            if (definition.getBoolean(JCR_PROTECTED)) {\n                addNameToList(type, OAK_PROTECTED_PROPERTIES, propertyName);\n            }\n        } else {\n            definitions = type.child(OAK_RESIDUAL_PROPERTY_DEFINITIONS);\n\n            // - jcr:protected (BOOLEAN) protected mandatory\n            if (definition.getBoolean(JCR_PROTECTED)) {\n                type.setProperty(OAK_HAS_PROTECTED_RESIDUAL_PROPERTIES, true);\n            }\n        }\n        definitions.setProperty(\n                JCR_PRIMARYTYPE, OAK_PROPERTY_DEFINITIONS, NAME);\n\n        // - jcr:requiredType (STRING) protected mandatory\n        // < 'STRING', 'URI', 'BINARY', 'LONG', 'DOUBLE',\n        //   'DECIMAL', 'BOOLEAN', 'DATE', 'NAME', 'PATH',\n        //   'REFERENCE', 'WEAKREFERENCE', 'UNDEFINED'\n        String key = \"UNDEFINED\";\n        PropertyState requiredType = definition.getProperty(JCR_REQUIREDTYPE);\n        if (requiredType != null) {\n            key = requiredType.getValue(STRING);\n        }\n\n        // - jcr:multiple (BOOLEAN) protected mandatory\n        if (definition.getBoolean(JCR_MULTIPLE)) {\n            if (\"BINARY\".equals(key)) {\n                key = \"BINARIES\";\n            } else {\n                key = key + \"S\";\n            }\n        } else if (propertyName != null) {\n            addNameToList(type, OAK_NAMED_SINGLE_VALUED_PROPERTIES, propertyName);\n        }\n\n        definitions.setChildNode(key, definition)\n            .setProperty(JCR_PRIMARYTYPE, OAK_PROPERTY_DEFINITION, NAME)\n            .setProperty(OAK_DECLARING_NODE_TYPE, typeName, NAME);\n    }","commit_id":"4e6e8d6a9178f690715e69cb626eaa167bca03da","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n\t * Returns the results of the rest fetch spec as an response in the format returned from the format() method. \n\t * This uses the editing context returned by editingContext().\n\t * \n\t * @param fetchSpec\n\t *            the rest fetch specification to execute\n\t * @param filter\n\t *            the filter to apply to the objects\n\t * @return a WOResponse of the format returned from the format() method\n\t */\n\tpublic WOActionResults response(ERXRestFetchSpecification<?> fetchSpec, ERXKeyFilter filter) {\n\t\treturn response(format(), editingContext(), fetchSpec.entityName(), fetchSpec.objects(editingContext(), options()), filter);\n\t}","id":25089,"modified_method":"/**\n\t * Returns the results of the rest fetch spec as an response in the format returned from the format() method. \n\t * This uses the editing context returned by editingContext().\n\t * \n\t * @param fetchSpec\n\t *            the rest fetch specification to execute\n\t * @param filter\n\t *            the filter to apply to the objects\n\t * @return a WOResponse of the format returned from the format() method\n\t */\n\tpublic WOActionResults response(ERXRestFetchSpecification<?> fetchSpec, ERXKeyFilter filter) {\n\t\tWOActionResults response;\n\t\tif (fetchSpec == null) {\n\t\t\t// MS: you probably meant to call response(Object, filter) in this case -- just proxy through\n\t\t\tresponse = response(format(), null, filter);\n\t\t}\n\t\telse {\n\t\t\tresponse = response(format(), editingContext(), fetchSpec.entityName(), fetchSpec.objects(editingContext(), options()), filter);\n\t\t}\n\t\treturn response;\n\t}","commit_id":"5444db62a154b254c7be22318b04cd9314951221","url":"https://github.com/wocommunity/wonder"},{"original_method":"private static final\n\tvoid outResponsePostfix(HttpServletResponse response, Writer out)\n\tthrows IOException {\n\t\tout.write(\"\\n<\/rs>\");\n\n\t\tfinal byte[] bs = ((StringWriter)out).toString().getBytes(\"UTF-8\");\n\t\tresponse.setContentType(\"text/xml;charset=UTF-8\");\n\t\tresponse.setContentLength(bs.length); //Strange but required for Jetty 6: Bug 1528592\n\t\tresponse.getOutputStream().write(bs);\n\t\tresponse.flushBuffer();\n\t}","id":25090,"modified_method":"private static final\n\tvoid outResponsePostfix(HttpServletResponse response, Writer out)\n\tthrows IOException {\n\t\tout.write(\"\\n<\/rs>\");\n\t\tflush(response, (StringWriter)out);\n\t}","commit_id":"06c6a4e6959270e779e74c804f15a09ba0a36b1b","url":"https://github.com/zkoss/zk"},{"original_method":"/** Generates a response for an error message.\n\t */\n\tprivate static\n\tvoid responseError(UiEngine uieng, HttpServletResponse response,\n\tString errmsg) throws IOException {\n\t\tlog.debug(errmsg);\n\t\t//Don't use sendError because Browser cannot handle UTF-8\n\t\tresponse.setContentType(\"text/xml;charset=UTF-8\");\n\t\tuieng.response(new AuAlert(errmsg), response.getWriter());\n\t}","id":25091,"modified_method":"/** Generates a response for an error message.\n\t */\n\tprivate static\n\tvoid responseError(UiEngine uieng, HttpServletResponse response,\n\tString errmsg) throws IOException {\n\t\tlog.debug(errmsg);\n\t\t//Don't use sendError because Browser cannot handle UTF-8\n\n\t\tfinal StringWriter out = new StringWriter();\n\t\tout.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\t\tuieng.response(new AuAlert(errmsg), out);\n\t\tflush(response, out);\n\t}","commit_id":"06c6a4e6959270e779e74c804f15a09ba0a36b1b","url":"https://github.com/zkoss/zk"},{"original_method":"private static void encodeByCData(StringBuffer outsb, String data) {\n\t\tfor (int j = data.length(); --j >= 0;) {\n\t\t\tfinal char cc = data.charAt(j);\n\t\t\tif (cc == '<' || cc == '>' || cc == '&') {\n\t\t\t\toutsb.append(\"<![CDATA[\").append(data).append(\"]]>\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\toutsb.append(data);\n\t}","id":25092,"modified_method":"private static void encodeByCData(String data, Writer out)\n\tthrows IOException {\n\t\tfor (int j = data.length(); --j >= 0;) {\n\t\t\tfinal char cc = data.charAt(j);\n\t\t\tif (cc == '<' || cc == '>' || cc == '&') {\n\t\t\t\tout.write(\"<![CDATA[\");\n\t\t\t\tout.write(data);\n\t\t\t\tout.write(\"]]>\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.write(data);\n\t}","commit_id":"5411573c970695838206b99e41872d805d6a6d5a","url":"https://github.com/zkoss/zk"},{"original_method":"public void execUpdate(Execution exec, List requests, Writer out)\n\tthrows IOException {\n\t\tif (requests == null)\n\t\t\tthrow new IllegalArgumentException(\"null requests\");\n\t\tassert D.OFF || ExecutionsCtrl.getCurrentCtrl() == null:\n\t\t\t\"Impossible to re-activate for update: old=\"+ExecutionsCtrl.getCurrentCtrl()+\", new=\"+exec+\", reqs=\"+requests;\n\n\t\tfinal Execution oldexec = Executions.getCurrent();\n\t\tfinal UiVisualizer uv = doActivate(exec, requests);\n\t\tif (uv == null)\n\t\t\treturn; //done (request is added to the exec currently activated)\n\n\t\tfinal Desktop desktop = exec.getDesktop();\n\t\tfinal Configuration config = desktop.getWebApp().getConfiguration();\n\t\tfinal Monitor monitor = config.getMonitor();\n\t\tif (monitor != null) {\n\t\t\ttry {\n\t\t\t\tmonitor.beforeUpdate(desktop, requests);\n\t\t\t} catch (Throwable ex) {\n\t\t\t\tlog.error(ex);\n\t\t\t}\n\t\t}\n\n\t\tboolean cleaned = false;\n\t\ttry {\n\t\t\tconfig.invokeExecutionInits(exec, oldexec);\n\t\t\tfinal RequestQueue rque = ((DesktopCtrl)exec.getDesktop()).getRequestQueue();\n\t\t\tfinal List errs = new LinkedList();\n\t\t\tfinal long tmexpired = System.currentTimeMillis() + 3000;\n\t\t\t\t//Tom Yeh: 20060120\n\t\t\t\t//Don't process all requests if this thread has processed\n\t\t\t\t//a while. Thus, user could see the response sooner.\n\t\t\tfor (AuRequest request; System.currentTimeMillis() < tmexpired\n\t\t\t&& (request = rque.nextRequest()) != null;) {\n\t\t\t\t//Cycle 1: Process one request\n\t\t\t\t//Don't process more such that requests will be queued\n\t\t\t\t//adn we have the chance to optimize them\n\t\t\t\ttry {\n\t\t\t\t\tprocess(exec, request, !errs.isEmpty());\n\t\t\t\t} catch (ComponentNotFoundException ex) {\n\t\t\t\t\t//possible because the previous might remove some comp\n\t\t\t\t\t//so ignore it\n\t\t\t\t\tif (log.debugable()) log.debug(\"Component not found: \"+request);\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\thandleError(ex, uv, errs);\n\t\t\t\t\t//we don't skip request to avoid mis-match between c/s\n\t\t\t\t}\n\n\t\t\t\t//Cycle 2: Process any pending events posted by components\n\t\t\t\tEvent event = nextEvent(uv);\n\t\t\t\tdo {\n\t\t\t\t\tfor (; event != null; event = nextEvent(uv)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tprocess(desktop, event);\n\t\t\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\t\t\thandleError(ex, uv, errs);\n\t\t\t\t\t\t\tbreak; //skip the rest of events! \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//Cycle 2a: processing resumed event processing\n\t\t\t\t\tresumeAll(desktop, uv, errs);\n\t\t\t\t} while ((event = nextEvent(uv)) != null);\n\t\t\t}\n\n\t\t\t//Cycle 3: Generate output\n\t\t\tif (!uv.isAborting()) {\n\t\t\t\tList responses;\n\t\t\t\ttry {\n\t\t\t\t\t//Note: we have to call visualizeErrors before uv.getResponses,\n\t\t\t\t\t//since it might create/update components\n\t\t\t\t\tif (!errs.isEmpty())\n\t\t\t\t\t\tvisualizeErrors(exec, uv, errs);\n\n\t\t\t\t\tresponses = uv.getResponses();\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\tresponses = new LinkedList();\n\t\t\t\t\tresponses.add(new AuAlert(Exceptions.getMessage(ex)));\n\n\t\t\t\t\tlog.error(ex);\n\t\t\t\t\terrs.add(ex); //so invokeExecutionCleanups knows it\n\t\t\t\t}\n\n\t\t\t\tcleaned = true;\n\t\t\t\tfinal List cleanerrs = new LinkedList();\n\t\t\t\tconfig.invokeExecutionCleanups(\n\t\t\t\t\texec, oldexec, errs.isEmpty() ? null: (Throwable)errs.get(0),\n\t\t\t\t\tcleanerrs);\n\t\t\t\tif (!cleanerrs.isEmpty()) {\n\t\t\t\t\tfinal StringBuffer errmsg = new StringBuffer(100);\n\t\t\t\t\tfor (Iterator it = cleanerrs.iterator(); it.hasNext();) {\n\t\t\t\t\t\tfinal Throwable t = (Throwable)it.next();\n\t\t\t\t\t\tif (errmsg.length() > 0) errmsg.append('\\n');\n\t\t\t\t\t\terrmsg.append(Exceptions.getMessage(t));\n\t\t\t\t\t}\n\t\t\t\t\tresponses.add(new AuAlert(errmsg.toString()));\n\t\t\t\t}\n\n\t\t\t\tif (rque.hasRequest())\n\t\t\t\t\tresponses.add(new AuEcho());\n\n\t\t\t\tresponse(responses, out);\n\n\t\t\t\tif (log.debugable())\n\t\t\t\t\tif (responses.size() < 5 || log.finerable()) log.debug(\"Responses: \"+responses);\n\t\t\t\t\telse log.debug(\"Responses: \"+responses.subList(0, 5)+\"...\");\n\t\t\t}\n\n\t\t\tfinal AbortingReason aborting = uv.getAbortingReason();\n\t\t\tif (aborting != null) {\n\t\t\t\tfinal AuResponse abtresp = aborting.getResponse();\n\t\t\t\tif (abtresp != null)\n\t\t\t\t\tresponse(abtresp, out);\n\t\t\t}\n\n\t\t\tout.flush();\n\t\t\t\t//flush before deactivating to make sure it has been sent\n\t\t} catch (Throwable ex) {\n\t\t\tif (!cleaned) {\n\t\t\t\tcleaned = true;\n\t\t\t\tconfig.invokeExecutionCleanups(exec, oldexec, ex, null);\n\t\t\t}\n\n\t\t\tif (ex instanceof IOException) throw (IOException)ex;\n\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t} finally {\n\t\t\tif (!cleaned) config.invokeExecutionCleanups(exec, oldexec, null, null);\n\n\t\t\tdoDeactivate(exec);\n\n\t\t\tif (monitor != null) {\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.afterUpdate(desktop);\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\tlog.error(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":25093,"modified_method":"public void execUpdate(Execution exec, List requests, Writer out)\n\tthrows IOException {\n\t\tif (requests == null)\n\t\t\tthrow new IllegalArgumentException(\"null requests\");\n\t\tassert D.OFF || ExecutionsCtrl.getCurrentCtrl() == null:\n\t\t\t\"Impossible to re-activate for update: old=\"+ExecutionsCtrl.getCurrentCtrl()+\", new=\"+exec+\", reqs=\"+requests;\n\n\t\tfinal Execution oldexec = Executions.getCurrent();\n\t\tfinal UiVisualizer uv = doActivate(exec, requests);\n\t\tif (uv == null)\n\t\t\treturn; //done (request is added to the exec currently activated)\n\n\t\tfinal Desktop desktop = exec.getDesktop();\n\t\tfinal Configuration config = desktop.getWebApp().getConfiguration();\n\t\tfinal Monitor monitor = config.getMonitor();\n\t\tif (monitor != null) {\n\t\t\ttry {\n\t\t\t\tmonitor.beforeUpdate(desktop, requests);\n\t\t\t} catch (Throwable ex) {\n\t\t\t\tlog.error(ex);\n\t\t\t}\n\t\t}\n\n\t\tboolean cleaned = false;\n\t\ttry {\n\t\t\tconfig.invokeExecutionInits(exec, oldexec);\n\t\t\tfinal RequestQueue rque = ((DesktopCtrl)desktop).getRequestQueue();\n\t\t\tfinal List errs = new LinkedList();\n\t\t\tfinal long tmexpired = System.currentTimeMillis() + 3000;\n\t\t\t\t//Tom Yeh: 20060120\n\t\t\t\t//Don't process all requests if this thread has processed\n\t\t\t\t//a while. Thus, user could see the response sooner.\n\t\t\tfor (AuRequest request; System.currentTimeMillis() < tmexpired\n\t\t\t&& (request = rque.nextRequest()) != null;) {\n\t\t\t\t//Cycle 1: Process one request\n\t\t\t\t//Don't process more such that requests will be queued\n\t\t\t\t//adn we have the chance to optimize them\n\t\t\t\ttry {\n\t\t\t\t\tprocess(exec, request, !errs.isEmpty());\n\t\t\t\t} catch (ComponentNotFoundException ex) {\n\t\t\t\t\t//possible because the previous might remove some comp\n\t\t\t\t\t//so ignore it\n\t\t\t\t\tif (log.debugable()) log.debug(\"Component not found: \"+request);\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\thandleError(ex, uv, errs);\n\t\t\t\t\t//we don't skip request to avoid mis-match between c/s\n\t\t\t\t}\n\n\t\t\t\t//Cycle 2: Process any pending events posted by components\n\t\t\t\tEvent event = nextEvent(uv);\n\t\t\t\tdo {\n\t\t\t\t\tfor (; event != null; event = nextEvent(uv)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tprocess(desktop, event);\n\t\t\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\t\t\thandleError(ex, uv, errs);\n\t\t\t\t\t\t\tbreak; //skip the rest of events! \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//Cycle 2a: processing resumed event processing\n\t\t\t\t\tresumeAll(desktop, uv, errs);\n\t\t\t\t} while ((event = nextEvent(uv)) != null);\n\t\t\t}\n\n\t\t\t//Cycle 3: Generate output\n\t\t\tif (!uv.isAborting()) {\n\t\t\t\tList responses;\n\t\t\t\ttry {\n\t\t\t\t\t//Note: we have to call visualizeErrors before uv.getResponses,\n\t\t\t\t\t//since it might create/update components\n\t\t\t\t\tif (!errs.isEmpty())\n\t\t\t\t\t\tvisualizeErrors(exec, uv, errs);\n\n\t\t\t\t\tresponses = uv.getResponses();\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\tresponses = new LinkedList();\n\t\t\t\t\tresponses.add(new AuAlert(Exceptions.getMessage(ex)));\n\n\t\t\t\t\tlog.error(ex);\n\t\t\t\t\terrs.add(ex); //so invokeExecutionCleanups knows it\n\t\t\t\t}\n\n\t\t\t\tcleaned = true;\n\t\t\t\tfinal List cleanerrs = new LinkedList();\n\t\t\t\tconfig.invokeExecutionCleanups(\n\t\t\t\t\texec, oldexec, errs.isEmpty() ? null: (Throwable)errs.get(0),\n\t\t\t\t\tcleanerrs);\n\t\t\t\tif (!cleanerrs.isEmpty()) {\n\t\t\t\t\tfinal StringBuffer errmsg = new StringBuffer(100);\n\t\t\t\t\tfor (Iterator it = cleanerrs.iterator(); it.hasNext();) {\n\t\t\t\t\t\tfinal Throwable t = (Throwable)it.next();\n\t\t\t\t\t\tif (errmsg.length() > 0) errmsg.append('\\n');\n\t\t\t\t\t\terrmsg.append(Exceptions.getMessage(t));\n\t\t\t\t\t}\n\t\t\t\t\tresponses.add(new AuAlert(errmsg.toString()));\n\t\t\t\t}\n\n\t\t\t\tif (rque.hasRequest())\n\t\t\t\t\tresponses.add(new AuEcho());\n\n\t\t\t\tresponseSequenceId(desktop, out);\n\t\t\t\tresponse(responses, out);\n\n\t\t\t\tif (log.debugable())\n\t\t\t\t\tif (responses.size() < 5 || log.finerable()) log.debug(\"Responses: \"+responses);\n\t\t\t\t\telse log.debug(\"Responses: \"+responses.subList(0, 5)+\"...\");\n\t\t\t}\n\n\t\t\tfinal AbortingReason aborting = uv.getAbortingReason();\n\t\t\tif (aborting != null) {\n\t\t\t\tfinal AuResponse abtresp = aborting.getResponse();\n\t\t\t\tif (abtresp != null) {\n\t\t\t\t\tresponseSequenceId(desktop, out);\n\t\t\t\t\tresponse(abtresp, out);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.flush();\n\t\t\t\t//flush before deactivating to make sure it has been sent\n\t\t} catch (Throwable ex) {\n\t\t\tif (!cleaned) {\n\t\t\t\tcleaned = true;\n\t\t\t\tconfig.invokeExecutionCleanups(exec, oldexec, ex, null);\n\t\t\t}\n\n\t\t\tif (ex instanceof IOException) throw (IOException)ex;\n\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t} finally {\n\t\t\tif (!cleaned) config.invokeExecutionCleanups(exec, oldexec, null, null);\n\n\t\t\tdoDeactivate(exec);\n\n\t\t\tif (monitor != null) {\n\t\t\t\ttry {\n\t\t\t\t\tmonitor.afterUpdate(desktop);\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\tlog.error(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"5411573c970695838206b99e41872d805d6a6d5a","url":"https://github.com/zkoss/zk"},{"original_method":"public void response(List responses, Writer out)\n\tthrows IOException {\n\t\tfinal StringBuffer outsb = new StringBuffer(1024*8);\n\t\tfor (Iterator it = responses.iterator(); it.hasNext();) {\n\t\t\tfinal AuResponse response = (AuResponse)it.next();\n\t\t\toutput(response, outsb);\n\t\t}\n\t\tif (D.ON && log.finerable()) log.finer(outsb);\n\t\tout.write(outsb.toString());\n\t}","id":25094,"modified_method":"public void response(List responses, Writer out)\n\tthrows IOException {\n\t\tfor (Iterator it = responses.iterator(); it.hasNext();)\n\t\t\tresponse((AuResponse)it.next(), out);\n\t}","commit_id":"5411573c970695838206b99e41872d805d6a6d5a","url":"https://github.com/zkoss/zk"},{"original_method":"public void response(AuResponse response, Writer out)\n\tthrows IOException {\n\t\tfinal StringBuffer outsb = new StringBuffer(1024*4);\n\t\toutput(response, outsb);\n\t\tout.write(outsb.toString());\n\t}","id":25095,"modified_method":"public void response(AuResponse response, Writer out)\n\tthrows IOException {\n\t\tout.write(\"\\n<r><c>\");\n\t\tout.write(response.getCommand());\n\t\tout.write(\"<\/c>\");\n\t\tfinal String[] data = response.getData();\n\t\tif (data != null) {\n\t\t\tfor (int j = 0; j < data.length; ++j) {\n\t\t\t\tout.write(\"\\n<d>\");\n\t\t\t\tencodeXML(data[j], out);\n\t\t\t\tout.write(\"<\/d>\");\n\t\t\t}\n\t\t}\n\t\tout.write(\"\\n<\/r>\");\n\t}","commit_id":"5411573c970695838206b99e41872d805d6a6d5a","url":"https://github.com/zkoss/zk"},{"original_method":"private static void encodeXML(StringBuffer outsb, String data) {\n\t\tif (data == null || data.length() == 0)\n\t\t\treturn;\n\n\t\t//20051208: Tom Yeh\n\t\t//The following codes are tricky.\n\t\t//Reason:\n\t\t//1. nested CDATA is not allowed\n\t\t//2. Firefox (1.0.7)'s XML parser cannot handle over 4096 chars\n\t\t//\tif CDATA is not used\n\t\tint j = 0;\n\t\tfor (int k; (k = data.indexOf(\"]]>\", j)) >= 0;) {\n\t\t\tencodeByCData(outsb, data.substring(j, k));\n\t\t\toutsb.append(\"]]&gt;\");\n\t\t\tj = k + 3;\n\t\t}\n\t\tencodeByCData(outsb, data.substring(j));\n\t}","id":25096,"modified_method":"private static void encodeXML(String data, Writer out)\n\tthrows IOException {\n\t\tif (data == null || data.length() == 0)\n\t\t\treturn;\n\n\t\t//20051208: Tom Yeh\n\t\t//The following codes are tricky.\n\t\t//Reason:\n\t\t//1. nested CDATA is not allowed\n\t\t//2. Firefox (1.0.7)'s XML parser cannot handle over 4096 chars\n\t\t//\tif CDATA is not used\n\t\tint j = 0;\n\t\tfor (int k; (k = data.indexOf(\"]]>\", j)) >= 0;) {\n\t\t\tencodeByCData(data.substring(j, k), out);\n\t\t\tout.write(\"]]&gt;\");\n\t\t\tj = k + 3;\n\t\t}\n\t\tencodeByCData(data.substring(j), out);\n\t}","commit_id":"5411573c970695838206b99e41872d805d6a6d5a","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n     * Create CallbackInfo without sent message\n     *\n     * @param target target to send message\n     * @param callback\n     * @param serializer serializer to deserialize response message\n     */\n    public CallbackInfo(InetAddress target, IAsyncCallback callback, IVersionedSerializer<?> serializer)\n    {\n        this.target = target;\n        this.callback = callback;\n        this.serializer = serializer;\n    }","id":25097,"modified_method":"public CallbackInfo(InetAddress target, IAsyncCallback callback, IVersionedSerializer<?> serializer)\n    {\n        this(target, callback, serializer, false);\n    }","commit_id":"7e1adb4976470b48a361ec6dcca7cbbcdb86d85f","url":"https://github.com/apache/cassandra"},{"original_method":"public String toString()\n    {\n        return \"CallbackInfo(\" +\n               \"target=\" + target +\n               \", callback=\" + callback +\n               \", serializer=\" + serializer +\n               ')';\n    }","id":25098,"modified_method":"public String toString()\n    {\n        return \"CallbackInfo(\" +\n               \"target=\" + target +\n               \", callback=\" + callback +\n               \", serializer=\" + serializer +\n               \", failureCallback=\" + failureCallback +\n               ')';\n    }","commit_id":"7e1adb4976470b48a361ec6dcca7cbbcdb86d85f","url":"https://github.com/apache/cassandra"},{"original_method":"public void run()\n    {\n        MessagingService.Verb verb = message.verb;\n        if (MessagingService.DROPPABLE_VERBS.contains(verb)\n            && System.currentTimeMillis() > constructionTime + message.getTimeout())\n        {\n            MessagingService.instance().incrementDroppedMessages(verb);\n            return;\n        }\n\n        IVerbHandler verbHandler = MessagingService.instance().getVerbHandler(verb);\n        if (verbHandler == null)\n        {\n            logger.debug(\"Unknown verb {}\", verb);\n            return;\n        }\n\n        verbHandler.doVerb(message, id);\n        if (GOSSIP_VERBS.contains(message.verb))\n            Gossiper.instance.setLastProcessedMessageAt(constructionTime);\n    }","id":25099,"modified_method":"public void run()\n    {\n        MessagingService.Verb verb = message.verb;\n        if (MessagingService.DROPPABLE_VERBS.contains(verb)\n            && System.currentTimeMillis() > constructionTime + message.getTimeout())\n        {\n            MessagingService.instance().incrementDroppedMessages(verb);\n            return;\n        }\n\n        IVerbHandler verbHandler = MessagingService.instance().getVerbHandler(verb);\n        if (verbHandler == null)\n        {\n            logger.debug(\"Unknown verb {}\", verb);\n            return;\n        }\n\n        try\n        {\n            verbHandler.doVerb(message, id);\n        }\n        catch (Throwable t)\n        {\n            if (message.doCallbackOnFailure())\n            {\n                MessageOut response = new MessageOut(MessagingService.Verb.INTERNAL_RESPONSE)\n                                                    .withParameter(MessagingService.FAILURE_RESPONSE_PARAM, MessagingService.ONE_BYTE);\n                MessagingService.instance().sendReply(response, id, message.from);\n            }\n\n            throw t;\n        }\n        if (GOSSIP_VERBS.contains(message.verb))\n            Gossiper.instance.setLastProcessedMessageAt(constructionTime);\n    }","commit_id":"7e1adb4976470b48a361ec6dcca7cbbcdb86d85f","url":"https://github.com/apache/cassandra"},{"original_method":"public int sendRR(MessageOut message, InetAddress to, IAsyncCallback cb)\n    {\n        return sendRR(message, to, cb, message.getTimeout());\n    }","id":25100,"modified_method":"public int sendRR(MessageOut message, InetAddress to, IAsyncCallback cb)\n    {\n        return sendRR(message, to, cb, message.getTimeout(), false);\n    }","commit_id":"7e1adb4976470b48a361ec6dcca7cbbcdb86d85f","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Send a non-mutation message to a given endpoint. This method specifies a callback\n     * which is invoked with the actual response.\n     *\n     * @param message message to be sent.\n     * @param to      endpoint to which the message needs to be sent\n     * @param cb      callback interface which is used to pass the responses or\n     *                suggest that a timeout occurred to the invoker of the send().\n     * @param timeout the timeout used for expiration\n     * @return an reference to message id used to match with the result\n     */\n    public int sendRR(MessageOut message, InetAddress to, IAsyncCallback cb, long timeout)\n    {\n        int id = addCallback(cb, message, to, timeout);\n        sendOneWay(message, id, to);\n        return id;\n    }","id":25101,"modified_method":"/**\n     * Send a non-mutation message to a given endpoint. This method specifies a callback\n     * which is invoked with the actual response.\n     *\n     * @param message message to be sent.\n     * @param to      endpoint to which the message needs to be sent\n     * @param cb      callback interface which is used to pass the responses or\n     *                suggest that a timeout occurred to the invoker of the send().\n     * @param timeout the timeout used for expiration\n     * @param failureCallback true if given cb has failure callback\n     * @return an reference to message id used to match with the result\n     */\n    public int sendRR(MessageOut message, InetAddress to, IAsyncCallback cb, long timeout, boolean failureCallback)\n    {\n        int id = addCallback(cb, message, to, timeout, failureCallback);\n        sendOneWay(failureCallback ? message.withParameter(FAILURE_CALLBACK_PARAM, ONE_BYTE) : message, id, to);\n        return id;\n    }","commit_id":"7e1adb4976470b48a361ec6dcca7cbbcdb86d85f","url":"https://github.com/apache/cassandra"},{"original_method":"public int addCallback(IAsyncCallback cb, MessageOut message, InetAddress to, long timeout)\n    {\n        assert message.verb != Verb.MUTATION; // mutations need to call the overload with a ConsistencyLevel\n        int messageId = nextId();\n        CallbackInfo previous = callbacks.put(messageId, new CallbackInfo(to, cb, callbackDeserializers.get(message.verb)), timeout);\n        assert previous == null : String.format(\"Callback already exists for id %d! (%s)\", messageId, previous);\n        return messageId;\n    }","id":25102,"modified_method":"public int addCallback(IAsyncCallback cb, MessageOut message, InetAddress to, long timeout, boolean failureCallback)\n    {\n        assert message.verb != Verb.MUTATION; // mutations need to call the overload with a ConsistencyLevel\n        int messageId = nextId();\n        CallbackInfo previous = callbacks.put(messageId, new CallbackInfo(to, cb, callbackDeserializers.get(message.verb), failureCallback), timeout);\n        assert previous == null : String.format(\"Callback already exists for id %d! (%s)\", messageId, previous);\n        return messageId;\n    }","commit_id":"7e1adb4976470b48a361ec6dcca7cbbcdb86d85f","url":"https://github.com/apache/cassandra"},{"original_method":"private MessagingService()\n    {\n        for (Verb verb : DROPPABLE_VERBS)\n        {\n            droppedMessages.put(verb, new DroppedMessageMetrics(verb));\n            lastDroppedInternal.put(verb, 0);\n        }\n\n        listenGate = new SimpleCondition();\n        verbHandlers = new EnumMap<Verb, IVerbHandler>(Verb.class);\n        Runnable logDropped = new Runnable()\n        {\n            public void run()\n            {\n                logDroppedMessages();\n            }\n        };\n        StorageService.scheduledTasks.scheduleWithFixedDelay(logDropped, LOG_DROPPED_INTERVAL_IN_MS, LOG_DROPPED_INTERVAL_IN_MS, TimeUnit.MILLISECONDS);\n\n        Function<Pair<Integer, ExpiringMap.CacheableObject<CallbackInfo>>, ?> timeoutReporter = new Function<Pair<Integer, ExpiringMap.CacheableObject<CallbackInfo>>, Object>()\n        {\n            public Object apply(Pair<Integer, ExpiringMap.CacheableObject<CallbackInfo>> pair)\n            {\n                CallbackInfo expiredCallbackInfo = pair.right.value;\n                maybeAddLatency(expiredCallbackInfo.callback, expiredCallbackInfo.target, pair.right.timeout);\n                ConnectionMetrics.totalTimeouts.mark();\n                getConnectionPool(expiredCallbackInfo.target).incrementTimeout();\n\n                if (expiredCallbackInfo.shouldHint())\n                {\n                    RowMutation rm = (RowMutation) ((WriteCallbackInfo) expiredCallbackInfo).sentMessage.payload;\n                    return StorageProxy.submitHint(rm, expiredCallbackInfo.target, null);\n                }\n\n                return null;\n            }\n        };\n\n        callbacks = new ExpiringMap<Integer, CallbackInfo>(DatabaseDescriptor.getMinRpcTimeout(), timeoutReporter);\n\n        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n        try\n        {\n            mbs.registerMBean(this, new ObjectName(MBEAN_NAME));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }","id":25103,"modified_method":"private MessagingService()\n    {\n        for (Verb verb : DROPPABLE_VERBS)\n        {\n            droppedMessages.put(verb, new DroppedMessageMetrics(verb));\n            lastDroppedInternal.put(verb, 0);\n        }\n\n        listenGate = new SimpleCondition();\n        verbHandlers = new EnumMap<Verb, IVerbHandler>(Verb.class);\n        Runnable logDropped = new Runnable()\n        {\n            public void run()\n            {\n                logDroppedMessages();\n            }\n        };\n        StorageService.scheduledTasks.scheduleWithFixedDelay(logDropped, LOG_DROPPED_INTERVAL_IN_MS, LOG_DROPPED_INTERVAL_IN_MS, TimeUnit.MILLISECONDS);\n\n        Function<Pair<Integer, ExpiringMap.CacheableObject<CallbackInfo>>, ?> timeoutReporter = new Function<Pair<Integer, ExpiringMap.CacheableObject<CallbackInfo>>, Object>()\n        {\n            public Object apply(Pair<Integer, ExpiringMap.CacheableObject<CallbackInfo>> pair)\n            {\n                final CallbackInfo expiredCallbackInfo = pair.right.value;\n                maybeAddLatency(expiredCallbackInfo.callback, expiredCallbackInfo.target, pair.right.timeout);\n                ConnectionMetrics.totalTimeouts.mark();\n                getConnectionPool(expiredCallbackInfo.target).incrementTimeout();\n                if (expiredCallbackInfo.isFailureCallback())\n                {\n                    StageManager.getStage(Stage.INTERNAL_RESPONSE).submit(new Runnable() {\n                        @Override\n                        public void run() {\n                            ((IAsyncCallbackWithFailure)expiredCallbackInfo.callback).onFailure(expiredCallbackInfo.target);\n                        }\n                    });\n                }\n\n                if (expiredCallbackInfo.shouldHint())\n                {\n                    RowMutation rm = (RowMutation) ((WriteCallbackInfo) expiredCallbackInfo).sentMessage.payload;\n                    return StorageProxy.submitHint(rm, expiredCallbackInfo.target, null);\n                }\n\n                return null;\n            }\n        };\n\n        callbacks = new ExpiringMap<Integer, CallbackInfo>(DatabaseDescriptor.getMinRpcTimeout(), timeoutReporter);\n\n        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n        try\n        {\n            mbs.registerMBean(this, new ObjectName(MBEAN_NAME));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"7e1adb4976470b48a361ec6dcca7cbbcdb86d85f","url":"https://github.com/apache/cassandra"},{"original_method":"public void doVerb(MessageIn message, int id)\n    {\n        long latency = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - MessagingService.instance().getRegisteredCallbackAge(id));\n        CallbackInfo callbackInfo = MessagingService.instance().removeRegisteredCallback(id);\n        if (callbackInfo == null)\n        {\n            String msg = \"Callback already removed for {} (from {})\";\n            logger.debug(msg, id, message.from);\n            Tracing.trace(msg, id, message.from);\n            return;\n        }\n\n        Tracing.trace(\"Processing response from {}\", message.from);\n        IAsyncCallback cb = callbackInfo.callback;\n        MessagingService.instance().maybeAddLatency(cb, message.from, latency);\n        cb.response(message);\n    }","id":25104,"modified_method":"public void doVerb(MessageIn message, int id)\n    {\n        long latency = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - MessagingService.instance().getRegisteredCallbackAge(id));\n        CallbackInfo callbackInfo = MessagingService.instance().removeRegisteredCallback(id);\n        if (callbackInfo == null)\n        {\n            String msg = \"Callback already removed for {} (from {})\";\n            logger.debug(msg, id, message.from);\n            Tracing.trace(msg, id, message.from);\n            return;\n        }\n\n        Tracing.trace(\"Processing response from {}\", message.from);\n        IAsyncCallback cb = callbackInfo.callback;\n        if (message.isFailureResponse())\n        {\n            ((IAsyncCallbackWithFailure) cb).onFailure(message.from);\n        }\n        else\n        {\n            //TODO: Should we add latency only in success cases?\n            MessagingService.instance().maybeAddLatency(cb, message.from, latency);\n            cb.response(message);\n        }\n    }","commit_id":"7e1adb4976470b48a361ec6dcca7cbbcdb86d85f","url":"https://github.com/apache/cassandra"},{"original_method":"public void run()\n    {\n        MessagingService.instance().sendRR(new SnapshotCommand(desc.keyspace,\n                                                               desc.columnFamily,\n                                                               desc.sessionId.toString(),\n                                                               false).createMessage(),\n                                           endpoint,\n                                           new SnapshotCallback(this));\n    }","id":25105,"modified_method":"public void run()\n    {\n        MessagingService.instance().sendRRWithFailure(new SnapshotCommand(desc.keyspace,\n                                                                          desc.columnFamily,\n                                                                          desc.sessionId.toString(),\n                                                                          false).createMessage(),\n                                                      endpoint,\n                                                      new SnapshotCallback(this));\n    }","commit_id":"7e1adb4976470b48a361ec6dcca7cbbcdb86d85f","url":"https://github.com/apache/cassandra"},{"original_method":"public Object addingBundle(Bundle bundle, BundleEvent event) {\n        List<BundleScriptEngineResolver> r = new ArrayList<BundleScriptEngineResolver>();\n        registerScriptEngines(bundle, r);\n        for (BundleScriptEngineResolver service : r) {\n            service.register();\n        }\n        resolvers.put(bundle.getBundleId(), r);\n        updateAvailableScriptLanguages();\n        return bundle;\n    }","id":25106,"modified_method":"public Object addingBundle(Bundle bundle, BundleEvent event) {\n        List<BundleScriptEngineResolver> r = new ArrayList<BundleScriptEngineResolver>();\n        registerScriptEngines(bundle, r);\n        for (BundleScriptEngineResolver service : r) {\n            service.register();\n        }\n        resolvers.put(bundle.getBundleId(), r);\n        // Only update the script language engine when the resolver is changed\n        if (r.size() > 0) {\n            updateAvailableScriptLanguages();\n        }\n        return bundle;\n    }","commit_id":"2134101785a5638fa58aaeea485c8b47b007a2db","url":"https://github.com/apache/camel"},{"original_method":"private List<String> getScriptNames(ScriptEngineFactory factory) {\n            List<String> names = factory.getNames();\n            return names;\n        }","id":25107,"modified_method":"private List<String> getScriptNames(ScriptEngineFactory factory) {\n            List<String> names = null;\n            if (factory != null) {\n                names = factory.getNames();\n            } else {\n                // return an empty script name list\n                names = new ArrayList<String>(0);\n            }\n            return names;\n        }","commit_id":"2134101785a5638fa58aaeea485c8b47b007a2db","url":"https://github.com/apache/camel"},{"original_method":"private ScriptEngineFactory getFactory() {\n            try {\n                BufferedReader in = IOHelper.buffered(new InputStreamReader(configFile.openStream()));\n                String className = in.readLine();\n                in.close();\n                Class<?> cls = bundle.loadClass(className);\n                if (!ScriptEngineFactory.class.isAssignableFrom(cls)) {\n                    throw new IllegalStateException(\"Invalid ScriptEngineFactory: \" + cls.getName());\n                }\n                return (ScriptEngineFactory) cls.newInstance();\n            } catch (Exception e) {\n                //do something\n                return null;\n            }\n        }","id":25108,"modified_method":"private ScriptEngineFactory getFactory() {\n            try {\n                BufferedReader in = IOHelper.buffered(new InputStreamReader(configFile.openStream()));\n                String className = in.readLine();\n                in.close();\n                Class<?> cls = bundle.loadClass(className);\n                if (!ScriptEngineFactory.class.isAssignableFrom(cls)) {\n                    throw new IllegalStateException(\"Invalid ScriptEngineFactory: \" + cls.getName());\n                }\n                return (ScriptEngineFactory) cls.newInstance();\n            } catch (Exception e) {\n                LOG.warn(\"Cannot create the ScriptEngineFactory: \" + e.getClass().getName(), e);\n                return null;\n            }\n        }","commit_id":"2134101785a5638fa58aaeea485c8b47b007a2db","url":"https://github.com/apache/camel"},{"original_method":"protected List<String> assertQuery(String sql, String language,\n            List<String> expected) {\n        List<String> paths = executeQuery(sql, language, true);\n        assertEquals(\"Result set size is different\", expected.size(),\n                paths.size());\n        for (String p : expected) {\n            assertTrue(paths.contains(p));\n        }\n        return paths;\n    }","id":25109,"modified_method":"protected List<String> assertQuery(String sql, String language,\n            List<String> expected) {\n        List<String> paths = executeQuery(sql, language, true);\n        for (String p : expected) {\n            assertTrue(\"Expected path \" + p + \" not found\", paths.contains(p));\n        }\n        assertEquals(\"Result set size is different\", expected.size(),\n                paths.size());\n        return paths;\n    }","commit_id":"0b2e03e6d2e37d8fa90e58e91c0350edf17a849a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    PropertyValue currentValue() {\n        return query.getBindVariableValue(bindVariableName);\n    }","id":25110,"modified_method":"@Override\n    public PropertyValue currentValue() {\n        return query.getBindVariableValue(bindVariableName);\n    }","commit_id":"0b2e03e6d2e37d8fa90e58e91c0350edf17a849a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    PropertyValue currentValue() {\n        // TODO namespace remapping?\n        return value;\n    }","id":25111,"modified_method":"@Override\n    public PropertyValue currentValue() {\n        // TODO namespace remapping?\n        return value;\n    }","commit_id":"0b2e03e6d2e37d8fa90e58e91c0350edf17a849a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Push down the \"property in(1, 2, 3)\" conditions to the selector, if there\n     * are any that can be derived.\n     * \n     * @param s the selector\n     */\n    private void restrictPushDownInList(SelectorImpl s) {\n        DynamicOperandImpl operand = null;\n        LinkedHashSet<StaticOperandImpl> values = newLinkedHashSet();\n \n        List<AndImpl> ands = newArrayList();\n        for (ConstraintImpl constraint : constraints) {\n            Set<SelectorImpl> selectors = constraint.getSelectors();\n            if (selectors.size() != 1 || !selectors.contains(s)) {\n                return;\n            } else if (constraint instanceof AndImpl) {\n                ands.add((AndImpl) constraint);\n            } else if (constraint instanceof InImpl) {\n                InImpl in = (InImpl) constraint;\n                DynamicOperandImpl o = in.getOperand1();\n                if (operand == null || operand.equals(o)) {\n                    operand = o;\n                    values.addAll(in.getOperand2());\n                } else {\n                    return;\n                }\n            } else if (constraint instanceof ComparisonImpl\n                    && ((ComparisonImpl) constraint).getOperator() == EQUAL) {\n                ComparisonImpl comparison = (ComparisonImpl) constraint;\n                DynamicOperandImpl o = comparison.getOperand1();\n                if (operand == null || operand.equals(o)) {\n                    operand = o;\n                    values.add(comparison.getOperand2());\n                } else {\n                    return;\n                }\n            } else {\n                return;\n            }\n        }\n\n        if (operand == null) {\n            return;\n        }\n\n        for (AndImpl and : ands) {\n            boolean found = false;\n            for (ConstraintImpl constraint : and.getConstraints()) {\n                if (constraint instanceof InImpl) {\n                    InImpl in = (InImpl) constraint;\n                    if (operand.equals(in.getOperand1())) {\n                        values.addAll(in.getOperand2());\n                        found = true;\n                        break;\n                    }\n                } else if (constraint instanceof ComparisonImpl\n                        && ((ComparisonImpl) constraint).getOperator() == EQUAL) {\n                    ComparisonImpl comparison = (ComparisonImpl) constraint;\n                    if (operand.equals(comparison.getOperand1())) {\n                        values.add(comparison.getOperand2());\n                        found = true;\n                        break;\n                    }\n                }\n            }\n            if (!found) {\n                return;\n            }\n        }\n\n        InImpl in = new InImpl(operand, newArrayList(values));\n        in.setQuery(query);\n        in.restrictPushDown(s);\n    }","id":25112,"modified_method":"/**\n     * Push down the \"property in(1, 2, 3)\" conditions to the selector, if there\n     * are any that can be derived.\n     * \n     * @param s the selector\n     */\n    private void restrictPushDownInList(SelectorImpl s) {\n        DynamicOperandImpl operand = null;\n        LinkedHashSet<StaticOperandImpl> values = newLinkedHashSet();\n \n        boolean multiPropertyOr = false;\n        List<AndImpl> ands = newArrayList();\n        for (ConstraintImpl constraint : constraints) {\n            Set<SelectorImpl> selectors = constraint.getSelectors();\n            if (selectors.size() != 1 || !selectors.contains(s)) {\n                return;\n            } else if (constraint instanceof AndImpl) {\n                ands.add((AndImpl) constraint);\n            } else if (constraint instanceof InImpl) {\n                InImpl in = (InImpl) constraint;\n                DynamicOperandImpl o = in.getOperand1();\n                if (operand == null || operand.equals(o)) {\n                    operand = o;\n                    values.addAll(in.getOperand2());\n                } else {\n                    multiPropertyOr = true;\n                }\n            } else if (constraint instanceof ComparisonImpl\n                    && ((ComparisonImpl) constraint).getOperator() == EQUAL) {\n                ComparisonImpl comparison = (ComparisonImpl) constraint;\n                DynamicOperandImpl o = comparison.getOperand1();\n                if (operand == null || operand.equals(o)) {\n                    operand = o;\n                    values.add(comparison.getOperand2());\n                } else {\n                    multiPropertyOr = true;\n                }\n            } else {\n                return;\n            }\n        }\n\n        if (multiPropertyOr && ands.isEmpty()) {\n            s.restrictSelector(this);\n            return;\n        } else if (operand == null) {\n            return;\n        }\n\n        for (AndImpl and : ands) {\n            boolean found = false;\n            for (ConstraintImpl constraint : and.getConstraints()) {\n                if (constraint instanceof InImpl) {\n                    InImpl in = (InImpl) constraint;\n                    if (operand.equals(in.getOperand1())) {\n                        values.addAll(in.getOperand2());\n                        found = true;\n                        break;\n                    }\n                } else if (constraint instanceof ComparisonImpl\n                        && ((ComparisonImpl) constraint).getOperator() == EQUAL) {\n                    ComparisonImpl comparison = (ComparisonImpl) constraint;\n                    if (operand.equals(comparison.getOperand1())) {\n                        values.add(comparison.getOperand2());\n                        found = true;\n                        break;\n                    }\n                }\n            }\n            if (!found) {\n                return;\n            }\n        }\n\n        InImpl in = new InImpl(operand, newArrayList(values));\n        in.setQuery(query);\n        in.restrictPushDown(s);\n    }","commit_id":"0b2e03e6d2e37d8fa90e58e91c0350edf17a849a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"PropertyIndexPlan(String name, NodeState definition, Filter filter) {\n        this.name = name;\n        this.definition = definition;\n\n        if (definition.getBoolean(UNIQUE_PROPERTY_NAME)) {\n            this.strategy = UNIQUE;\n        } else {\n            this.strategy = MIRROR;\n        }\n\n        this.filter = filter;\n\n        Iterable<String> types = definition.getNames(DECLARING_NODE_TYPES);\n        this.matchesAllTypes = isEmpty(types);\n        this.matchesNodeTypes =\n                matchesAllTypes || any(types, in(filter.getSupertypes()));\n\n        double bestCost = Double.POSITIVE_INFINITY;\n        Set<String> bestValues = emptySet();\n        int bestDepth = 1;\n\n        if (matchesNodeTypes) {\n            for (String property : definition.getNames(PROPERTY_NAMES)) {\n                int depth = 1;\n\n                PropertyRestriction restriction =\n                        filter.getPropertyRestriction(property);\n                if (restriction == null) {\n                    // no direct restriction, try one with a relative path\n                    String suffix = \"/\" + property;\n                    for (PropertyRestriction relative\n                            : filter.getPropertyRestrictions()) {\n                        if (relative.propertyName.endsWith(suffix)) {\n                            restriction = relative;\n                            depth = PathUtils.getDepth(relative.propertyName);\n                        }\n                    }\n                }\n                if (restriction == null) {\n                    continue; // no matching restrictions\n                }\n\n                Set<String> values = getValues(restriction);\n                double cost = strategy.count(definition, values, MAX_COST);\n                if (cost < bestCost) {\n                    bestDepth = depth;\n                    bestValues = values;\n                    bestCost = cost;\n                }\n            }\n        }\n\n        this.depth = bestDepth;\n        this.values = bestValues;\n        this.cost = COST_OVERHEAD + bestCost;\n    }","id":25113,"modified_method":"PropertyIndexPlan(String name, NodeState definition, Filter filter) {\n        this.name = name;\n        this.definition = definition;\n        this.properties = newHashSet(definition.getNames(PROPERTY_NAMES));\n\n        if (definition.getBoolean(UNIQUE_PROPERTY_NAME)) {\n            this.strategy = UNIQUE;\n        } else {\n            this.strategy = MIRROR;\n        }\n\n        this.filter = filter;\n\n        Iterable<String> types = definition.getNames(DECLARING_NODE_TYPES);\n        this.matchesAllTypes = isEmpty(types);\n        this.matchesNodeTypes =\n                matchesAllTypes || any(types, in(filter.getSupertypes()));\n\n        double bestCost = Double.POSITIVE_INFINITY;\n        Set<String> bestValues = emptySet();\n        int bestDepth = 1;\n\n        if (matchesNodeTypes) {\n            for (String property : properties) {\n                PropertyRestriction restriction =\n                        filter.getPropertyRestriction(property);\n                int depth = 1;\n\n                if (restriction == null) {\n                    // no direct restriction, try one with a relative path\n                    // TODO: avoid repeated scans through the restrictions\n                    String suffix = \"/\" + property;\n                    for (PropertyRestriction relative\n                            : filter.getPropertyRestrictions()) {\n                        if (relative.propertyName.endsWith(suffix)) {\n                            restriction = relative;\n                            depth = PathUtils.getDepth(relative.propertyName);\n                        }\n                    }\n                }\n\n                if (restriction != null) {\n                    Set<String> values = getValues(restriction);\n                    double cost = strategy.count(definition, values, MAX_COST);\n                    if (cost < bestCost) {\n                        bestDepth = depth;\n                        bestValues = values;\n                        bestCost = cost;\n                    }\n                }\n            }\n\n            // OAK-1965: let's see if we can find a (x='...' OR y='...')\n            // constraint where both x and y are covered by this index\n            // TODO: avoid repeated scans through the constraints\n            for (ConstraintImpl constraint\n                    : filter.getSelector().getSelectorConstraints()) {\n                if (constraint instanceof OrImpl) {\n                    Set<String> values = findMultiProperty((OrImpl) constraint);\n                    if (values != null) {\n                        double cost = strategy.count(definition, values, MAX_COST);\n                        if (cost < bestCost) {\n                            bestDepth = 1;\n                            bestValues = values;\n                            bestCost = cost;\n                        }\n                    }\n                }\n            }\n        }\n\n        this.depth = bestDepth;\n        this.values = bestValues;\n        this.cost = COST_OVERHEAD + bestCost;\n    }","commit_id":"0b2e03e6d2e37d8fa90e58e91c0350edf17a849a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"abstract PropertyValue currentValue();","id":25114,"modified_method":"public abstract PropertyValue currentValue();","commit_id":"0b2e03e6d2e37d8fa90e58e91c0350edf17a849a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected String getMetadataValue(\n\t\tMetadata metadata, java.lang.reflect.Field beanField) {\n\n\t\tObject fieldValue = getFieldValue(metadata, beanField);\n\n\t\tString metadataKey = null;\n\n\t\tif (fieldValue instanceof String) {\n\t\t\tmetadataKey = (String) fieldValue;\n\t\t}\n\t\telse {\n\t\t\tmetadataKey = ((Property)fieldValue).getName();\n\t\t}\n\n\t\treturn metadata.get(metadataKey);\n\t}","id":25115,"modified_method":"protected String getMetadataValue(Metadata metadata, Field field) {\n\t\tObject fieldValue = getFieldValue(metadata, field);\n\n\t\tif (fieldValue instanceof String) {\n\t\t\treturn metadata.get((String)fieldValue);\n\t\t}\n\t\telse {\n\t\t\tProperty property = (Property)fieldValue;\n\n\t\t\treturn metadata.get(property.getName());\n\t\t}\n\t}","commit_id":"c40c00a30c0d1224c96d1f07d4f05744626edd52","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Fields createDDMFields(\n\t\t\tMetadata metadata, java.lang.reflect.Field[] beanFields)\n\t\tthrows StorageException {\n\n\t\tFields ddmFields = new Fields();\n\n\t\tfor (java.lang.reflect.Field beanField : beanFields) {\n\t\t\tString value = getMetadataValue(metadata, beanField);\n\n\t\t\tif (value != null) {\n\t\t\t\tddmFields.put(\n\t\t\t\t\tnew com.liferay.portlet.dynamicdatamapping.storage.Field(\n\t\t\t\t\t\tbeanField.getName(), value));\n\t\t\t}\n\t\t}\n\n\t\treturn ddmFields;\n\t}","id":25116,"modified_method":"protected Fields createDDMFields(Metadata metadata, Field[] fields) {\n\t\tFields ddmFields = new Fields();\n\n\t\tfor (Field field : fields) {\n\t\t\tString value = getMetadataValue(metadata, field);\n\n\t\t\tif (value == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcom.liferay.portlet.dynamicdatamapping.storage.Field ddmField =\n\t\t\t\tnew com.liferay.portlet.dynamicdatamapping.storage.Field(\n\t\t\t\t\tfield.getName(), value);\n\n\t\t\tddmFields.put(ddmField);\n\t\t}\n\n\t\treturn ddmFields;\n\t}","commit_id":"c40c00a30c0d1224c96d1f07d4f05744626edd52","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Object getFieldValue(\n\t\tMetadata metadata, java.lang.reflect.Field beanField) {\n\n\t\tObject fieldValue = null;\n\n\t\ttry {\n\t\t\tfieldValue = beanField.get(metadata);\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"The property \" + beanField.getName() +\n\t\t\t\t\t\" will not be added to the metatada set\");\n\t\t\t}\n\t\t}\n\n\t\treturn fieldValue;\n\t}","id":25117,"modified_method":"protected Object getFieldValue(Metadata metadata, Field field) {\n\t\tObject fieldValue = null;\n\n\t\ttry {\n\t\t\tfieldValue = field.get(metadata);\n\t\t}\n\t\tcatch (IllegalAccessException iae) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"The property \" + field.getName() +\n\t\t\t\t\t\t\" will not be added to the metatada set\");\n\t\t\t}\n\t\t}\n\n\t\treturn fieldValue;\n\t}","commit_id":"c40c00a30c0d1224c96d1f07d4f05744626edd52","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Map<String, Fields> createDDMFieldsMap(\n\t\t\tMetadata metadata, Map<String, java.lang.reflect.Field[]> fieldsMap)\n\t\tthrows SystemException, StorageException {\n\n\t\tMap<String, Fields> ddmFieldsMap = new HashMap<String, Fields>();\n\n\t\tfor (String key : fieldsMap.keySet()) {\n\t\t\tFields ddmFields = createDDMFields(metadata, fieldsMap.get(key));\n\n\t\t\tif (ddmFields.getNames().size() > 0) {\n\t\t\t\tddmFieldsMap.put(key, ddmFields);\n\t\t\t}\n\t\t}\n\n\t\treturn ddmFieldsMap;\n\t}","id":25118,"modified_method":"protected Map<String, Fields> createDDMFieldsMap(\n\t\tMetadata metadata, Map<String, Field[]> fieldsMap) {\n\n\t\tMap<String, Fields> ddmFieldsMap = new HashMap<String, Fields>();\n\n\t\tfor (String key : fieldsMap.keySet()) {\n\t\t\tField[] fields = fieldsMap.get(key);\n\n\t\t\tFields ddmFields = createDDMFields(metadata, fields);\n\n\t\t\tSet<String> names = ddmFields.getNames();\n\n\t\t\tif (!names.isEmpty()) {\n\t\t\t\tddmFieldsMap.put(key, ddmFields);\n\t\t\t}\n\t\t}\n\n\t\treturn ddmFieldsMap;\n\t}","commit_id":"c40c00a30c0d1224c96d1f07d4f05744626edd52","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Map<String, Fields> getRawMetadataMap(InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tMetadata metadata = extractMetadata(is);\n\n\t\treturn createDDMFieldsMap(metadata, RAW_METADATA_SETS);\n\t}","id":25119,"modified_method":"public Map<String, Fields> getRawMetadataMap(InputStream inputStream) {\n\t\tMetadata metadata = extractMetadata(inputStream);\n\n\t\treturn createDDMFieldsMap(metadata, _fields);\n\t}","commit_id":"c40c00a30c0d1224c96d1f07d4f05744626edd52","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static List<LaunchableGradleTask> tasks(DefaultGradleProject owner, TaskContainerInternal tasks) {\n        List<LaunchableGradleTask> out = new LinkedList<LaunchableGradleTask>();\n        for (String taskName : tasks.getNames()) {\n            Task t = tasks.findByName(taskName);\n            if (t != null) {\n                out.add(new LaunchableGradleProjectTask()\n                                .setProject(owner)\n                                .setPath(t.getPath())\n                                .setName(t.getName())\n                                .setDisplayName(t.toString())\n                                .setDescription(t.getDescription())\n                                .setPublic(PublicTaskSpecification.INSTANCE.isSatisfiedBy(t))\n                );\n            }\n        }\n\n        return out;\n    }","id":25120,"modified_method":"private static List<LaunchableGradleTask> tasks(DefaultGradleProject owner, TaskContainerInternal tasks) {\n        tasks.discoverTasks();\n        SortedSet<String> taskNames = tasks.getNames();\n        List<LaunchableGradleTask> out = new ArrayList<LaunchableGradleTask>(taskNames.size());\n        for (String taskName : taskNames) {\n            Task t = tasks.findByName(taskName);\n            if (t != null) {\n                out.add(new LaunchableGradleProjectTask()\n                                .setProject(owner)\n                                .setPath(t.getPath())\n                                .setName(t.getName())\n                                .setDisplayName(t.toString())\n                                .setDescription(t.getDescription())\n                                .setPublic(PublicTaskSpecification.INSTANCE.isSatisfiedBy(t))\n                );\n            }\n        }\n\n        return out;\n    }","commit_id":"abcd794cc24e2ee3c59d793553abc65601bd3392","url":"https://github.com/gradle/gradle"},{"original_method":"public void execute(ProjectInternal project) {\n        ToolingModelBuilderRegistry modelBuilderRegistry = project.getServices().get(ToolingModelBuilderRegistry.class);\n        ProjectPublicationRegistry projectPublicationRegistry = project.getServices().get(ProjectPublicationRegistry.class);\n        ProjectTaskLister taskLister = project.getServices().get(ProjectTaskLister.class);\n\n        GradleProjectBuilder gradleProjectBuilder  = new GradleProjectBuilder(taskLister);\n        IdeaModelBuilder ideaModelBuilder = new IdeaModelBuilder(gradleProjectBuilder);\n        modelBuilderRegistry.register(new EclipseModelBuilder(gradleProjectBuilder));\n        modelBuilderRegistry.register(ideaModelBuilder);\n        modelBuilderRegistry.register(gradleProjectBuilder);\n        modelBuilderRegistry.register(new GradleBuildBuilder());\n        modelBuilderRegistry.register(new BasicIdeaModelBuilder(ideaModelBuilder));\n        modelBuilderRegistry.register(new BuildInvocationsBuilder(taskLister));\n        modelBuilderRegistry.register(new PublicationsBuilder(projectPublicationRegistry));\n    }","id":25121,"modified_method":"public void execute(ProjectInternal project) {\n        ToolingModelBuilderRegistry modelBuilderRegistry = project.getServices().get(ToolingModelBuilderRegistry.class);\n        ProjectPublicationRegistry projectPublicationRegistry = project.getServices().get(ProjectPublicationRegistry.class);\n        ProjectTaskLister taskLister = project.getServices().get(ProjectTaskLister.class);\n\n        GradleProjectBuilder gradleProjectBuilder  = new GradleProjectBuilder();\n        IdeaModelBuilder ideaModelBuilder = new IdeaModelBuilder(gradleProjectBuilder);\n        modelBuilderRegistry.register(new EclipseModelBuilder(gradleProjectBuilder));\n        modelBuilderRegistry.register(ideaModelBuilder);\n        modelBuilderRegistry.register(gradleProjectBuilder);\n        modelBuilderRegistry.register(new GradleBuildBuilder());\n        modelBuilderRegistry.register(new BasicIdeaModelBuilder(ideaModelBuilder));\n        modelBuilderRegistry.register(new BuildInvocationsBuilder(taskLister));\n        modelBuilderRegistry.register(new PublicationsBuilder(projectPublicationRegistry));\n    }","commit_id":"abcd794cc24e2ee3c59d793553abc65601bd3392","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean isSearchInAnyPlace() {\n    return mySearchInAnyPlace;\n  }","id":25122,"modified_method":"public boolean isSearchInAnyPlace() {\n    return PlatformUtils.isCidr() || mySearchInAnyPlace;\n  }","commit_id":"43c3b39adc76b9cac98ab7af37d26d4be498ba7f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void filterElements(ChooseByNameBase base,\n                             String pattern,\n                             boolean everywhere,\n                             Computable<Boolean> cancelled,\n                             Processor<Object> consumer) {\n    String namePattern = getNamePattern(base, pattern);\n    String qualifierPattern = getQualifierPattern(base, pattern);\n\n    if (base.isSearchInAnyPlace() && !namePattern.trim().isEmpty()) {\n      namePattern = \"*\" + namePattern + \"*\";\n    }\n\n    boolean empty = namePattern.isEmpty() || namePattern.equals(\"@\");    // TODO[yole]: remove implicit dependency\n    if (empty && !base.canShowListForEmptyPattern()) return;\n\n    List<String> namesList = new ArrayList<String>();\n    getNamesByPattern(base, base.getNames(everywhere), cancelled, namesList, namePattern);\n    if (cancelled.compute()) {\n      throw new ProcessCanceledException();\n    }\n    sortNamesList(namePattern, namesList);\n\n\n    List<Object> sameNameElements = new SmartList<Object>();\n\n    for (String name : namesList) {\n      if (cancelled.compute()) {\n        throw new ProcessCanceledException();\n      }\n      final Object[] elements = base.getModel().getElementsByName(name, everywhere, namePattern);\n      if (elements.length > 1) {\n        sameNameElements.clear();\n        for (final Object element : elements) {\n          if (matchesQualifier(element, qualifierPattern, base)) {\n            sameNameElements.add(element);\n          }\n        }\n        sortByProximity(base, sameNameElements);\n        for (Object element : sameNameElements) {\n          if (!consumer.process(element)) return;\n        }\n      }\n      else if (elements.length == 1 && matchesQualifier(elements[0], qualifierPattern, base)) {\n        if (!consumer.process(elements[0])) return;\n      }\n    }\n  }","id":25123,"modified_method":"@Override\n  public void filterElements(ChooseByNameBase base,\n                             String pattern,\n                             boolean everywhere,\n                             Computable<Boolean> cancelled,\n                             Processor<Object> consumer) {\n    String namePattern = getNamePattern(base, pattern);\n    String qualifierPattern = getQualifierPattern(base, pattern);\n    String modifiedNamePattern = null;\n\n    if (base.isSearchInAnyPlace() && !namePattern.trim().isEmpty()) {\n      modifiedNamePattern = \"*\" + namePattern + \"*\";\n    }\n\n    boolean empty = namePattern.isEmpty() || namePattern.equals(\"@\");    // TODO[yole]: remove implicit dependency\n    if (empty && !base.canShowListForEmptyPattern()) return;\n\n    List<String> namesList = new ArrayList<String>();\n    String[] names = base.getNames(everywhere);\n    getNamesByPattern(base, names, cancelled, namesList, namePattern);\n    if (cancelled.compute()) {\n      throw new ProcessCanceledException();\n    }\n    sortNamesList(namePattern, namesList);\n\n    if (modifiedNamePattern != null) {\n      final Set<String> matched = new HashSet<String>(namesList);\n      List<String> additionalNamesList = new ArrayList<String>();\n      namePattern = modifiedNamePattern;\n      getNamesByPattern(base, names, cancelled, additionalNamesList, namePattern);\n      additionalNamesList = ContainerUtil.filter(additionalNamesList, new Condition<String>() {\n        @Override\n        public boolean value(String name) {\n          return !matched.contains(name);\n        }\n      });\n      sortNamesList(namePattern, additionalNamesList);\n      namesList.addAll(additionalNamesList);\n    }\n\n    if (cancelled.compute()) {\n      throw new ProcessCanceledException();\n    }\n\n    List<Object> sameNameElements = new SmartList<Object>();\n\n    for (String name : namesList) {\n      if (cancelled.compute()) {\n        throw new ProcessCanceledException();\n      }\n      final Object[] elements = base.getModel().getElementsByName(name, everywhere, namePattern);\n      if (elements.length > 1) {\n        sameNameElements.clear();\n        for (final Object element : elements) {\n          if (matchesQualifier(element, qualifierPattern, base)) {\n            sameNameElements.add(element);\n          }\n        }\n        sortByProximity(base, sameNameElements);\n        for (Object element : sameNameElements) {\n          if (!consumer.process(element)) return;\n        }\n      }\n      else if (elements.length == 1 && matchesQualifier(elements[0], qualifierPattern, base)) {\n        if (!consumer.process(elements[0])) return;\n      }\n    }\n  }","commit_id":"43c3b39adc76b9cac98ab7af37d26d4be498ba7f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Adds the given document dependency to this document.<p>\n     * \n     * @param cms the current CmsObject\n     * @param resDeps the dependency\n     */\n    public void addDocumentDependency(CmsObject cms, CmsDocumentDependency resDeps) {\n\n        m_doc.addField(I_CmsSearchField.FIELD_DEPENDENCY_TYPE, resDeps.getType());\n        for (CmsDocumentDependency dep : resDeps.getDependencies()) {\n            m_doc.addField(\"dep_\" + dep.getType().toString(), dep.toJSON(cms, true).toString());\n        }\n    }","id":25124,"modified_method":"/**\n     * Adds the given document dependency to this document.<p>\n     * \n     * @param cms the current CmsObject\n     * @param resDeps the dependency\n     */\n    public void addDocumentDependency(CmsObject cms, CmsDocumentDependency resDeps) {\n\n        if (resDeps != null) {\n            m_doc.addField(I_CmsSearchField.FIELD_DEPENDENCY_TYPE, resDeps.getType());\n            if ((resDeps.getMainDocument() != null) && (resDeps.getType() != null)) {\n                m_doc.addField(\n                    I_CmsSearchField.FIELD_PREFIX_DEPENDENCY + resDeps.getType().toString(),\n                    resDeps.getMainDocument().toDependencyString(cms));\n            }\n            for (CmsDocumentDependency dep : resDeps.getVariants()) {\n                m_doc.addField(\n                    I_CmsSearchField.FIELD_PREFIX_DEPENDENCY + dep.getType().toString(),\n                    dep.toDependencyString(cms));\n            }\n            for (CmsDocumentDependency dep : resDeps.getAttachments()) {\n                m_doc.addField(\n                    I_CmsSearchField.FIELD_PREFIX_DEPENDENCY + dep.getType().toString(),\n                    dep.toDependencyString(cms));\n            }\n        }\n    }","commit_id":"f0948e31814da7020a319c8a4c6e911f5ce14ff3","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.search.I_CmsSearchDocument#getFieldValueAsString(java.lang.String)\n     */\n    public String getFieldValueAsString(String fieldName) {\n\n        Object o = m_doc.getFieldValue(fieldName);\n        if (o != null) {\n            return o.toString();\n        }\n        return null;\n    }","id":25125,"modified_method":"/**\n     * @see org.opencms.search.I_CmsSearchDocument#getFieldValueAsString(java.lang.String)\n     */\n    public String getFieldValueAsString(String fieldName) {\n\n        List<String> values = getMultivaluedFieldAsStringList(fieldName);\n        if ((values != null) && !values.isEmpty()) {\n            return CmsStringUtil.listAsString(values, \"\\n\");\n        } else {\n            Object o = m_doc.getFieldValue(fieldName);\n            if (o != null) {\n                return o.toString();\n            }\n        }\n        return null;\n    }","commit_id":"f0948e31814da7020a319c8a4c6e911f5ce14ff3","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.search.I_CmsSearchDocument#addSearchField(org.opencms.search.fields.I_CmsSearchField, java.lang.String)\n     */\n    public void addSearchField(I_CmsSearchField sfield, String value) {\n\n        CmsSolrField field = (CmsSolrField)sfield;\n        List<String> fieldsToAdd = new ArrayList<String>(Collections.singletonList(field.getName()));\n        if ((field.getCopyFields() != null) && !field.getCopyFields().isEmpty()) {\n            fieldsToAdd.addAll(field.getCopyFields());\n        }\n        for (String fieldName : fieldsToAdd) {\n\n            IndexSchema schema = OpenCms.getSearchManager().getSolrServerConfiguration().getSolrSchema();\n            try {\n                try {\n                    FieldType type = schema.getFieldType(fieldName);\n                    if (type instanceof DateField) {\n                        value = DateField.formatExternal(new Date(new Long(value).longValue()));\n                    }\n                } catch (SolrException e) {\n                    LOG.debug(e.getMessage(), e);\n                    throw new RuntimeException(e);\n                }\n\n                SolrInputField exfield = m_doc.getField(fieldName);\n                if (exfield == null) {\n                    if (schema.hasExplicitField(fieldName)) {\n                        m_doc.addField(fieldName, value);\n                    } else {\n                        m_doc.addField(fieldName, value, field.getBoost());\n                    }\n                } else {\n                    if (schema.hasExplicitField(fieldName)) {\n                        m_doc.setField(fieldName, value);\n                    } else {\n                        m_doc.setField(fieldName, value, field.getBoost());\n                    }\n                }\n            } catch (SolrException e) {\n                LOG.error(e.getMessage(), e);\n            } catch (RuntimeException e) {\n                // noop\n            }\n        }\n    }","id":25126,"modified_method":"/**\n     * @see org.opencms.search.I_CmsSearchDocument#addSearchField(org.opencms.search.fields.I_CmsSearchField, java.lang.String)\n     */\n    public void addSearchField(I_CmsSearchField sfield, String value) {\n\n        CmsSolrField field = (CmsSolrField)sfield;\n        List<String> fieldsToAdd = new ArrayList<String>(Collections.singletonList(field.getName()));\n        if ((field.getCopyFields() != null) && !field.getCopyFields().isEmpty()) {\n            fieldsToAdd.addAll(field.getCopyFields());\n        }\n        IndexSchema schema = OpenCms.getSearchManager().getSolrServerConfiguration().getSolrSchema();\n        for (String fieldName : fieldsToAdd) {\n            try {\n                List<String> splitedValues = new ArrayList<String>();\n                boolean multi = false;\n                SchemaField f = schema.getField(fieldName);\n                if (f != null) {\n                    multi = f.multiValued();\n                }\n                FieldType type = schema.getFieldType(fieldName);\n                if (multi) {\n                    splitedValues = CmsStringUtil.splitAsList(value.toString(), \"\\n\");\n                } else {\n                    splitedValues.add(value);\n                }\n                for (String val : splitedValues) {\n                    try {\n                        if (type instanceof DateField) {\n                            val = DateField.formatExternal(new Date(new Long(val).longValue()));\n                        }\n                    } catch (SolrException e) {\n                        LOG.debug(e.getMessage(), e);\n                        throw new RuntimeException(e);\n                    }\n                    if (schema.hasExplicitField(fieldName)) {\n                        m_doc.addField(fieldName, val);\n                    } else {\n                        m_doc.addField(fieldName, val, field.getBoost());\n                    }\n                }\n            } catch (SolrException e) {\n                LOG.error(e.getMessage(), e);\n            } catch (RuntimeException e) {\n                // noop\n            }\n        }\n    }","commit_id":"f0948e31814da7020a319c8a4c6e911f5ce14ff3","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.search.documents.CmsDocumentXmlContent#extractContent(org.opencms.file.CmsObject, org.opencms.file.CmsResource, org.opencms.search.A_CmsSearchIndex)\n     */\n    @Override\n    public I_CmsExtractionResult extractContent(CmsObject cms, CmsResource resource, A_CmsSearchIndex index)\n    throws CmsException {\n\n        logContentExtraction(resource, index);\n        try {\n\n            // unmarshall the content\n            A_CmsXmlDocument xmlContent = CmsXmlContentFactory.unmarshal(cms, readFile(cms, resource));\n            Map<String, String> items = new HashMap<String, String>();\n            StringBuffer locales = new StringBuffer();\n            Locale resLocale = index.getLocaleForResource(cms, resource, xmlContent.getLocales());\n            String defaultContent = null;\n\n            // loop over the locales\n            for (Locale locale : xmlContent.getLocales()) {\n\n                // store the extracted locales\n                locales.append(locale.toString());\n                locales.append(' ');\n                StringBuffer content = new StringBuffer();\n\n                // loop over the available element paths\n                for (String xpath : xmlContent.getNames(locale)) {\n\n                    // get the value for the element path\n                    I_CmsXmlContentValue value = xmlContent.getValue(xpath, locale);\n\n                    // first try to receive the text value \n                    String extracted = value.getPlainText(cms);\n                    if (value.isSimpleType()) {\n\n                        // put the extraction to the content and to the items\n                        if (value.getContentDefinition().getContentHandler().isSearchable(value)\n                            && CmsStringUtil.isNotEmptyOrWhitespaceOnly(extracted)) {\n                            // create the content value for the locale by adding all String values in the XML nodes\n                            content.append(extracted);\n                            content.append('\\n');\n                            items.put(xpath, extracted);\n                        }\n\n                        // if the extraction was empty try to take the String value as fall-back\n                        if (CmsStringUtil.isEmptyOrWhitespaceOnly(extracted)\n                            && CmsStringUtil.isNotEmptyOrWhitespaceOnly(value.getStringValue(cms))) {\n                            try {\n                                extracted = value.getStringValue(cms);\n                                items.put(xpath, extracted);\n                            } catch (CmsRuntimeException re) {\n                                // ignore: is only thrown for those XML content values \n                                // that don't have a String representation for those we \n                                // will store a 'null'\n                            }\n                        }\n\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(extracted)) {\n                            // The key must be the local extended parameter value of the Solr field mapping defined in:\n                            // CmsDefaultXmlContentHandler.initSearchSettings(Element, CmsXmlContentDefinition)\n                            // later during index process the values are retrieved in:\n                            // I_CmsSearchFieldMapping#getStringValue(CmsObject, CmsResource, I_CmsExtractionResult, List, List)\n                            items.put(A_CmsSearchFieldConfiguration.getLocaleExtendedName(\n                                CmsXmlUtils.removeXpath(xpath),\n                                locale), extracted);\n                        }\n                    }\n                }\n                if (content.length() > 0) {\n                    // add the extracted content with a localized key into the extraction result\n                    String contentKey = A_CmsSearchFieldConfiguration.getLocaleExtendedName(\n                        I_CmsSearchField.FIELD_CONTENT,\n                        locale);\n                    items.put(contentKey, content.toString());\n                    if (resLocale.equals(locale)) {\n                        defaultContent = content.toString();\n                    }\n                }\n                // add the locales that have been indexed for this document as item\n                items.put(I_CmsSearchField.FIELD_RESOURCE_LOCALES, locales.toString());\n            }\n            // get all search fields configured in the XSD of this XML content\n            Set<I_CmsSearchField> fields = new HashSet<I_CmsSearchField>(xmlContent.getHandler().getSearchFields());\n            return new CmsExtractionResult(defaultContent, items, fields);\n        } catch (Exception e) {\n            throw new CmsIndexException(\n                Messages.get().container(Messages.ERR_TEXT_EXTRACTION_1, resource.getRootPath()),\n                e);\n        }\n    }","id":25127,"modified_method":"/**\n     * @see org.opencms.search.documents.CmsDocumentXmlContent#extractContent(org.opencms.file.CmsObject, org.opencms.file.CmsResource, org.opencms.search.A_CmsSearchIndex)\n     */\n    @Override\n    public I_CmsExtractionResult extractContent(CmsObject cms, CmsResource resource, A_CmsSearchIndex index)\n    throws CmsException {\n\n        logContentExtraction(resource, index);\n        try {\n\n            // unmarshall the content\n            A_CmsXmlDocument xmlContent = CmsXmlContentFactory.unmarshal(cms, readFile(cms, resource));\n            Map<String, String> items = new HashMap<String, String>();\n            StringBuffer locales = new StringBuffer();\n            Locale resLocale = index.getLocaleForResource(cms, resource, xmlContent.getLocales());\n            String defaultContent = null;\n\n            // loop over the locales\n            for (Locale locale : xmlContent.getLocales()) {\n\n                // store the extracted locales\n                locales.append(locale.toString());\n                locales.append(' ');\n                StringBuffer content = new StringBuffer();\n\n                // loop over the available element paths\n                List<String> paths = xmlContent.getNames(locale);\n                for (String xpath : paths) {\n\n                    String extracted = extractValue(cms, xmlContent, xpath, locale);\n                    I_CmsXmlContentValue value = xmlContent.getValue(xpath, locale);\n\n                    // put the extraction to the content and to the items\n                    if (value.getContentDefinition().getContentHandler().isSearchable(value)\n                        && CmsStringUtil.isNotEmptyOrWhitespaceOnly(extracted)) {\n                        // create the content value for the locale by adding all String values in the XML nodes\n                        content.append(extracted);\n                        content.append('\\n');\n                        items.put(xpath, extracted);\n                    }\n\n                    if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(extracted)) {\n                        // The key must be the local extended parameter value of the Solr field mapping defined in:\n                        // CmsDefaultXmlContentHandler.initSearchSettings(Element, CmsXmlContentDefinition)\n                        // later during index process the values are retrieved in:\n                        // I_CmsSearchFieldMapping#getStringValue(CmsObject, CmsResource, I_CmsExtractionResult, List, List)\n                        items.put(\n                            A_CmsSearchFieldConfiguration.getLocaleExtendedName(CmsXmlUtils.removeXpath(xpath), locale),\n                            extracted);\n                    }\n                }\n                if (content.length() > 0) {\n                    // add the extracted content with a localized key into the extraction result\n                    String contentKey = A_CmsSearchFieldConfiguration.getLocaleExtendedName(\n                        I_CmsSearchField.FIELD_CONTENT,\n                        locale);\n                    items.put(contentKey, content.toString());\n                    if (resLocale.equals(locale)) {\n                        defaultContent = content.toString();\n                    }\n                }\n                // add the locales that have been indexed for this document as item\n                items.put(I_CmsSearchField.FIELD_RESOURCE_LOCALES, locales.toString());\n            }\n            // get all search fields configured in the XSD of this XML content\n            Set<I_CmsSearchField> fields = new HashSet<I_CmsSearchField>(xmlContent.getHandler().getSearchFields());\n            return new CmsExtractionResult(defaultContent, items, fields);\n        } catch (Exception e) {\n            throw new CmsIndexException(\n                Messages.get().container(Messages.ERR_TEXT_EXTRACTION_1, resource.getRootPath()),\n                e);\n        }\n    }","commit_id":"f0948e31814da7020a319c8a4c6e911f5ce14ff3","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * @see org.apache.avalon.framework.parameters.Parameterizable#parameterize(org.apache.avalon.framework.parameters.Parameters)\n\t */\n\tpublic void parameterize(Parameters params) throws ParameterException {\n\t\tthis.optionalParameters = new HashMap();\n\t\tString paramNames[] = params.getNames();\n\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\tString param = paramNames[i];\n\t\t\toptionalParameters.put(param, params.getParameter(param));\n\t\t}\n\t}","id":25128,"modified_method":"/**\n\t * @see org.apache.avalon.framework.parameters.Parameterizable#parameterize(org.apache.avalon.framework.parameters.Parameters)\n\t */\n\tpublic void parameterize(Parameters params) throws ParameterException {\n\t\tthis.componentParams = params;\n\t}","commit_id":"8835f3910fdb3d018c2052341c40231bca9e961c","url":"https://github.com/eXist-db/exist"},{"original_method":"public void setup(SourceResolver resolver, Map objectModel, String source,\n\t\t\t\t\t\tParameters parameters) throws ProcessingException,\n\t\t\tSAXException, IOException {\n\t\tsuper.setup(resolver, objectModel, source, parameters);\n\t\tthis.objectModel = objectModel;\n\t\tthis.inputSource = resolver.resolveURI(source);\n\t\tthis.collectionURI = parameters.getParameter(COLLECTION_URI,\n\t\t\t\tthis.defaultCollectionURI);\n\t\tthis.user = parameters.getParameter(USER, this.defaultUser);\n\t\tthis.password = parameters.getParameter(PASSWORD, this.defaultPassword);\n\t\tthis.createSession = parameters.getParameterAsBoolean(CREATE_SESSION,\n\t\t\t\tthis.defaultCreateSession);\n\t\tthis.expandXIncludes = parameters.getParameterAsBoolean(\n\t\t\t\tEXPAND_XINCLUDES, this.defaultExpandXIncludes);\n\t\tString paramNames[] = parameters.getNames();\n\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\tString param = paramNames[i];\n\t\t\tif (!(param.equals(COLLECTION_URI) || param.equals(USER)\n\t\t\t\t\t|| param.equals(PASSWORD)\n\t\t\t\t\t|| param.equals(CREATE_SESSION) || param\n\t\t\t\t\t.equals(EXPAND_XINCLUDES))) {\n\t\t\t\tthis.optionalParameters.put(param, parameters\n\t\t\t\t\t\t.getParameter(param, \"\"));\n\t\t\t}\n\t\t}\n        Context context = ObjectModelHelper.getContext(objectModel);\n        String dbHome = context.getRealPath(\"WEB-INF\");\n\t\ttry {\n\t\t\tClass driver = Class.forName(DRIVER);\n\t\t\tDatabase database = (Database)driver.newInstance();\n            database.setProperty(\"create-database\", \"true\");\n            database.setProperty(\"configuration\", dbHome + File.separatorChar + \"conf.xml\");\n\t\t\tDatabaseManager.registerDatabase(database);\n\t\t} catch(Exception e) {\n\t\t\tthrow new ProcessingException(\"Failed to initialize database driver: \" + e.getMessage(), e);\n\t\t}\n\t}","id":25129,"modified_method":"public void setup(SourceResolver resolver, Map objectModel, String source,\n\t\t\t\t\t\tParameters parameters) throws ProcessingException,\n\t\t\tSAXException, IOException {\n\t\tsuper.setup(resolver, objectModel, source, parameters);\n\n\t\t/*\n\t\t * We don't do this directly in parameterize() because setup() can be\n\t\t * called multiple times and optionalParameters needs resetting to forget\n\t\t * sitemap parameters that may have been removed inbetween\n\t\t */\n\t\tthis.optionalParameters = new HashMap();\n\t\tString paramNames[] = componentParams.getNames();\n\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\tString param = paramNames[i];\n\t\t\ttry {\n\t\t\t\toptionalParameters.put(param, componentParams.getParameter(param));\n\t\t\t} catch (ParameterException e1) {\n\t\t\t\t// Cannot happen as we iterate through existing parameters\n\t\t\t}\n\t\t}\n\n\t\tthis.objectModel = objectModel;\n\t\tthis.inputSource = resolver.resolveURI(source);\n\t\tthis.collectionURI = parameters.getParameter(COLLECTION_URI,\n\t\t\t\tthis.defaultCollectionURI);\n\t\tthis.user = parameters.getParameter(USER, this.defaultUser);\n\t\tthis.password = parameters.getParameter(PASSWORD, this.defaultPassword);\n\t\tthis.createSession = parameters.getParameterAsBoolean(CREATE_SESSION,\n\t\t\t\tthis.defaultCreateSession);\n\t\tthis.expandXIncludes = parameters.getParameterAsBoolean(\n\t\t\t\tEXPAND_XINCLUDES, this.defaultExpandXIncludes);\n\t\tthis.cacheValidity = parameters.getParameterAsLong(CACHE_VALIDITY, defaultCacheValidity);\n\t\tparamNames = parameters.getNames();\n\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\tString param = paramNames[i];\n\t\t\tif (!(param.equals(COLLECTION_URI) || param.equals(USER)\n\t\t\t\t\t|| param.equals(PASSWORD)\n\t\t\t\t\t|| param.equals(CREATE_SESSION) || param\n\t\t\t\t\t.equals(EXPAND_XINCLUDES) || param.equals(CACHE_VALIDITY))) {\n\t\t\t\tthis.optionalParameters.put(param, parameters\n\t\t\t\t\t\t.getParameter(param, \"\"));\n\t\t\t}\n\t\t}\n        Context context = ObjectModelHelper.getContext(objectModel);\n        String dbHome = context.getRealPath(\"WEB-INF\");\n\t\ttry {\n\t\t\tClass driver = Class.forName(DRIVER);\n\t\t\tDatabase database = (Database)driver.newInstance();\n            database.setProperty(\"create-database\", \"true\");\n            database.setProperty(\"configuration\", dbHome + File.separatorChar + \"conf.xml\");\n\t\t\tDatabaseManager.registerDatabase(database);\n\t\t} catch(Exception e) {\n\t\t\tthrow new ProcessingException(\"Failed to initialize database driver: \" + e.getMessage(), e);\n\t\t}\n\t}","commit_id":"8835f3910fdb3d018c2052341c40231bca9e961c","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * @see org.apache.avalon.framework.configuration.Configurable#configure(org.apache.avalon.framework.configuration.Configuration)\n\t */\n\tpublic void configure(Configuration config) throws ConfigurationException {\n\t\tthis.defaultCollectionURI = config.getAttribute(COLLECTION_URI, this.defaultCollectionURI);\n\t\tthis.defaultCreateSession = config.getAttributeAsBoolean(CREATE_SESSION, this.defaultCreateSession);\n\t\tthis.defaultExpandXIncludes = config.getAttributeAsBoolean(EXPAND_XINCLUDES, this.defaultExpandXIncludes);\n\t\tthis.defaultPassword = config.getAttribute(PASSWORD, this.defaultPassword);\n\t\tthis.defaultUser = config.getAttribute(USER, this.defaultUser);\n\t}","id":25130,"modified_method":"/**\n\t * @see org.apache.avalon.framework.configuration.Configurable#configure(org.apache.avalon.framework.configuration.Configuration)\n\t */\n\tpublic void configure(Configuration config) throws ConfigurationException {\n\t\tthis.defaultCollectionURI = config.getAttribute(COLLECTION_URI, this.defaultCollectionURI);\n\t\tthis.defaultCreateSession = config.getAttributeAsBoolean(CREATE_SESSION, this.defaultCreateSession);\n\t\tthis.defaultExpandXIncludes = config.getAttributeAsBoolean(EXPAND_XINCLUDES, this.defaultExpandXIncludes);\n\t\tthis.defaultPassword = config.getAttribute(PASSWORD, this.defaultPassword);\n\t\tthis.defaultUser = config.getAttribute(USER, this.defaultUser);\n\t\tthis.defaultCacheValidity = config.getAttributeAsLong(CACHE_VALIDITY, this.defaultCacheValidity);\n\t}","commit_id":"8835f3910fdb3d018c2052341c40231bca9e961c","url":"https://github.com/eXist-db/exist"},{"original_method":"private void addConfiguration(MutableLocalComponentMetaData metaData, Configuration configuration) {\n        String[] superConfigs = Configurations.getNames(configuration.getExtendsFrom()).toArray(new String[configuration.getExtendsFrom().size()]);\n        Arrays.sort(superConfigs);\n        metaData.addConfiguration(configuration.getName(), configuration.isVisible(), configuration.getDescription(), superConfigs, configuration.isTransitive());\n    }","id":25131,"modified_method":"private void addConfiguration(MutableLocalComponentMetaData metaData, Configuration configuration) {\n        Set<String> hierarchy = Configurations.getNames(configuration.getHierarchy());\n        Set<String> extendsFrom = Configurations.getNames(configuration.getExtendsFrom());\n        metaData.addConfiguration(configuration.getName(), configuration.getDescription(), extendsFrom, hierarchy, configuration.isVisible(), configuration.isTransitive());\n    }","commit_id":"691d359217d8ba072165237e9db07aa02f91f7ae","url":"https://github.com/gradle/gradle"},{"original_method":"private Configuration createNamesAndExtendedConfigurationStub(final String name, final Configuration... extendsFromConfigurations) {\n        final Configuration configurationStub = IvyConverterTestUtil.createNamedConfigurationStub(name, context);\n        context.checking(new Expectations() {{\n            allowing(configurationStub).isTransitive();\n            will(returnValue(true));\n\n            allowing(configurationStub).getDescription();\n            will(returnValue(TestUtil.createUniqueId()));\n\n            allowing(configurationStub).isVisible();\n            will(returnValue(true));\n\n            allowing(configurationStub).getExtendsFrom();\n            will(returnValue(WrapUtil.toSet(extendsFromConfigurations)));\n        }});\n        return configurationStub;\n    }","id":25132,"modified_method":"private Configuration createNamesAndExtendedConfigurationStub(final String name, final Configuration... extendsFromConfigurations) {\n        final Configuration configurationStub = IvyConverterTestUtil.createNamedConfigurationStub(name, context);\n        context.checking(new Expectations() {{\n            allowing(configurationStub).isTransitive();\n            will(returnValue(true));\n\n            allowing(configurationStub).getDescription();\n            will(returnValue(TestUtil.createUniqueId()));\n\n            allowing(configurationStub).isVisible();\n            will(returnValue(true));\n\n            allowing(configurationStub).getExtendsFrom();\n            will(returnValue(WrapUtil.toSet(extendsFromConfigurations)));\n\n            allowing(configurationStub).getHierarchy();\n            will(returnValue(WrapUtil.toSet(extendsFromConfigurations)));\n        }});\n        return configurationStub;\n    }","commit_id":"691d359217d8ba072165237e9db07aa02f91f7ae","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void addConfiguration(Configuration configuration) {\n        moduleDescriptor.addConfiguration(configuration);\n    }","id":25133,"modified_method":"@Override\n    public void addConfiguration(LocalConfigurationMetaData configuration) {\n        Set<String> extendsFrom = configuration.getExtendsFrom();\n        String[] superConfigs = extendsFrom.toArray(new String[extendsFrom.size()]);\n        Arrays.sort(superConfigs);\n        Configuration.Visibility visibility = configuration.isVisible() ? Configuration.Visibility.PUBLIC : Configuration.Visibility.PRIVATE;\n        Configuration conf = new Configuration(configuration.getName(), visibility, configuration.getDescription(), superConfigs, configuration.isTransitive(), null);\n        moduleDescriptor.addConfiguration(conf);\n    }","commit_id":"691d359217d8ba072165237e9db07aa02f91f7ae","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultConfigurationMetaData getConfiguration(final String name) {\n            DefaultConfigurationMetaData configuration = configurations.get(name);\n            if (configuration == null) {\n                configuration = populateConfigurationFromDescriptor(name);\n            }\n            return configuration;\n        }","id":25134,"modified_method":"public DefaultLocalConfigurationMetaData getConfiguration(final String name) {\n            return allConfigurations.get(name);\n        }","commit_id":"691d359217d8ba072165237e9db07aa02f91f7ae","url":"https://github.com/gradle/gradle"},{"original_method":"public void addConfiguration(String name, boolean visible, String description, String[] superConfigs, boolean transitive) {\n        Configuration conf = new Configuration(name, visible ? Configuration.Visibility.PUBLIC : Configuration.Visibility.PRIVATE, description, superConfigs, transitive, null);\n        allConfigurations.put(name, conf);\n    }","id":25135,"modified_method":"public void addConfiguration(String name, String description, Set<String> extendsFrom, Set<String> hierarchy, boolean visible, boolean transitive) {\n        DefaultLocalConfigurationMetaData conf = new DefaultLocalConfigurationMetaData(name, description, visible, transitive, extendsFrom, hierarchy);\n        allConfigurations.put(name, conf);\n    }","commit_id":"691d359217d8ba072165237e9db07aa02f91f7ae","url":"https://github.com/gradle/gradle"},{"original_method":"public BuildableIvyModulePublishMetaData toPublishMetaData() {\n        DefaultIvyModulePublishMetaData publishMetaData = new DefaultIvyModulePublishMetaData(id, status);\n        for (Configuration configuration : allConfigurations.values()) {\n            publishMetaData.addConfiguration(configuration);\n        }\n        for (ExcludeRule excludeRule : allExcludeRules) {\n            publishMetaData.addExcludeRule(excludeRule);\n        }\n        for (DependencyMetaData dependency : allDependencies) {\n            publishMetaData.addDependency(dependency);\n        }\n        for (String configuration : allArtifacts.keySet()) {\n            PublishArtifactSet publishArtifacts = allArtifacts.get(configuration);\n            for (PublishArtifact publishArtifact : publishArtifacts) {\n                publishMetaData.addArtifact(configuration, publishArtifact);\n            }\n        }\n        return publishMetaData;\n    }","id":25136,"modified_method":"public BuildableIvyModulePublishMetaData toPublishMetaData() {\n        DefaultIvyModulePublishMetaData publishMetaData = new DefaultIvyModulePublishMetaData(id, status);\n        for (DefaultLocalConfigurationMetaData configuration : allConfigurations.values()) {\n            publishMetaData.addConfiguration(configuration);\n        }\n        for (ExcludeRule excludeRule : allExcludeRules) {\n            publishMetaData.addExcludeRule(excludeRule);\n        }\n        for (DependencyMetaData dependency : allDependencies) {\n            publishMetaData.addDependency(dependency);\n        }\n        for (String configuration : allArtifacts.keySet()) {\n            PublishArtifactSet publishArtifacts = allArtifacts.get(configuration);\n            for (PublishArtifact publishArtifact : publishArtifacts) {\n                publishMetaData.addArtifact(configuration, publishArtifact);\n            }\n        }\n        return publishMetaData;\n    }","commit_id":"691d359217d8ba072165237e9db07aa02f91f7ae","url":"https://github.com/gradle/gradle"},{"original_method":"public List<String> getNames(String defName) {\n\t\tList<String> l = new ArrayList<String>();\n\t\tif (!Algorithms.isEmpty(getName())) {\n\t\t\tl.add(defName);\n\t\t}\n\t\tfor (String nm : getAdditionalInfo().keySet()) {\n\t\t\tif (nm.startsWith(\"name:\")) {\n\t\t\t\tl.add(nm.substring(\"name:\".length()));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn l;\n\t}","id":25137,"modified_method":"public List<String> getNames(String tag) {\n\t\tList<String> l = new ArrayList<String>();\n\t\tfor (String nm : getAdditionalInfo().keySet()) {\n\t\t\tif (nm.startsWith(tag+\":\")) {\n\t\t\t\tl.add(nm.substring(tag.length() +1));\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}","commit_id":"63417876f3577f1b0d7e1f1816d33aac9e42be58","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public String getAdditionalInfo(String key){\n\t\tif(additionalInfo == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString str = additionalInfo.get(key);\n\t\tif (str != null) {\n\t\t\tif (str.startsWith(\" gz \")) {\n\t\t\t\ttry {\n\t\t\t\t\tint ind = 4;\n\t\t\t\t\tbyte[] bytes = new byte[str.length() - ind];\n\t\t\t\t\tfor (int i = ind; i < str.length(); i++) {\n\t\t\t\t\t\tchar ch = str.charAt(i);\n\t\t\t\t\t\tbytes[i - ind] = (byte) ((int) ch - 128 - 32);\n\n\t\t\t\t\t}\n\t\t\t\t\tGZIPInputStream gzn = new GZIPInputStream(new ByteArrayInputStream(bytes));\n\t\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(gzn, \"UTF-8\"));\n\t\t\t\t\tStringBuilder bld = new StringBuilder();\n\t\t\t\t\tString s;\n\t\t\t\t\twhile ((s = br.readLine()) != null) {\n\t\t\t\t\t\tbld.append(s);\n\t\t\t\t\t}\n\t\t\t\t\tstr = bld.toString();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn str;\n\t}","id":25138,"modified_method":"public String getAdditionalInfo(String key){\n\t\tif(additionalInfo == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString str = additionalInfo.get(key);\n\t\tstr = unzipContent(str);\n\t\treturn str;\n\t}","commit_id":"63417876f3577f1b0d7e1f1816d33aac9e42be58","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public String getNameSelected(String lang) {\n\t\tif (lang != null) {\n\t\t\tString translateName;\n\t\t\tif (lang.equals(\"en\")) {\n\t\t\t\ttranslateName = getEnName();\n\t\t\t} else {\n\t\t\t\ttranslateName = getAdditionalInfo(\"name:\" + lang);\n\t\t\t}\n\t\t\tif (!Algorithms.isEmpty(translateName)) {\n\t\t\t\treturn lang;\n\t\t\t}\n\t\t}\n\t\tif (!Algorithms.isEmpty(getName())) {\n\t\t\treturn \"\";\n\t\t}\n\t\tfor (String nm : getAdditionalInfo().keySet()) {\n\t\t\tif (nm.startsWith(\"name:\")) {\n\t\t\t\treturn nm.substring(\"name:\".length());\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}","id":25139,"modified_method":"public String getNameSelected(String lang) {\n\t\tif (lang != null) {\n\t\t\tString translateName;\n\t\t\tif (lang.equals(\"en\")) {\n\t\t\t\ttranslateName = getEnName();\n\t\t\t} else {\n\t\t\t\ttranslateName = getAdditionalInfo(\"name:\" + lang);\n\t\t\t}\n\t\t\tif (!Algorithms.isEmpty(translateName)) {\n\t\t\t\treturn lang;\n\t\t\t}\n\t\t}\n\t\tfor (String nm : getAdditionalInfo().keySet()) {\n\t\t\tif (nm.startsWith(\"name:\")) {\n\t\t\t\treturn nm.substring(\"name:\".length());\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}","commit_id":"63417876f3577f1b0d7e1f1816d33aac9e42be58","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static String getAmenityDescriptionContent(Context ctx, Amenity amenity, boolean shortDescription) {\n\t\tStringBuilder d = new StringBuilder();\n\t\tfor(Entry<String, String>  e : amenity.getAdditionalInfo().entrySet()) {\n\t\t\tString key = e.getKey();\n\t\t\tString vl = e.getValue();\n\t\t\tif(key.startsWith(\"name:\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if(vl.length() >= 150) {\n\t\t\t\tif(shortDescription) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if(Amenity.OPENING_HOURS.equals(key)) {\n\t\t\t\td.append(ctx.getString(R.string.opening_hours) + \": \");\n\t\t\t} else if(Amenity.PHONE.equals(key)) {\n\t\t\t\td.append(ctx.getString(R.string.phone) + \": \");\n\t\t\t} else if(Amenity.WEBSITE.equals(key)) {\n\t\t\t\tif(amenity.getType().isWiki()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\td.append(ctx.getString(R.string.website) + \": \");\n\t\t\t} else {\n\t\t\t\tPoiCategory pc = amenity.getType();\n\t\t\t\tPoiType pt = pc.getPoiTypeByKeyName(e.getKey());\n\t\t\t\tif (pt != null) {\n\t\t\t\t\tvl = pt.getTranslation();\n\t\t\t\t} else {\n\t\t\t\t\tvl = Algorithms.capitalizeFirstLetterAndLowercase(e.getKey());\n\t\t\t\t}\n\t\t\t\tvl += \": \" + e.getValue();\n\t\t\t}\n\t\t\td.append(vl).append('\\n');\n\t\t}\n\t\treturn d.toString().trim();\n\t}","id":25140,"modified_method":"public static String getAmenityDescriptionContent(Context ctx, Amenity amenity, boolean shortDescription) {\n\t\tStringBuilder d = new StringBuilder();\n\t\tif(amenity.getType().isWiki()) {\n\t\t\treturn \"\";\n\t\t}\n\t\tfor(Entry<String, String>  e : amenity.getAdditionalInfo().entrySet()) {\n\t\t\tString key = e.getKey();\n\t\t\tString vl = e.getValue();\n\t\t\tif(key.startsWith(\"name:\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if(vl.length() >= 150) {\n\t\t\t\tif(shortDescription) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if(Amenity.OPENING_HOURS.equals(key)) {\n\t\t\t\td.append(ctx.getString(R.string.opening_hours) + \": \");\n\t\t\t} else if(Amenity.PHONE.equals(key)) {\n\t\t\t\td.append(ctx.getString(R.string.phone) + \": \");\n\t\t\t} else if(Amenity.WEBSITE.equals(key)) {\n\t\t\t\t\n\t\t\t\td.append(ctx.getString(R.string.website) + \": \");\n\t\t\t} else {\n\t\t\t\tPoiCategory pc = amenity.getType();\n\t\t\t\tPoiType pt = pc.getPoiTypeByKeyName(e.getKey());\n\t\t\t\tif (pt != null) {\n\t\t\t\t\tvl = pt.getTranslation();\n\t\t\t\t} else {\n\t\t\t\t\tvl = Algorithms.capitalizeFirstLetterAndLowercase(e.getKey());\n\t\t\t\t}\n\t\t\t\tvl += \": \" + amenity.unzipContent(e.getValue());\n\t\t\t}\n\t\t\td.append(vl).append('\\n');\n\t\t}\n\t\treturn d.toString().trim();\n\t}","commit_id":"63417876f3577f1b0d7e1f1816d33aac9e42be58","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected static void showPopupLangMenu(final Context ctx, Toolbar tb, \n\t\t\tfinal OsmandApplication app, final Amenity a, final Dialog dialog) {\n\t\tfinal PopupMenu optionsMenu = new PopupMenu(ctx, tb, Gravity.RIGHT);\n\t\tList<String> names = a.getNames(\"\");\n\t\tfor (final String n : names) {\n\t\t\tString vn = FileNameTranslationHelper.getVoiceName(ctx, n);\n\t\t\tMenuItem item = optionsMenu.getMenu().add(vn);\n\t\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tdialog.dismiss();\n\t\t\t\t\tshowWiki(ctx, app, a, n);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\toptionsMenu.show();\n\t\t\n\t}","id":25141,"modified_method":"protected static void showPopupLangMenu(final Context ctx, Toolbar tb, \n\t\t\tfinal OsmandApplication app, final Amenity a, final Dialog dialog) {\n\t\tfinal PopupMenu optionsMenu = new PopupMenu(ctx, tb, Gravity.RIGHT);\n\t\tSet<String> names = new TreeSet<String>(); \n\t\tnames.addAll(a.getNames(\"content\"));\n\t\tnames.addAll(a.getNames(\"description\"));\n\t\t\n\t\tfor (final String n : names) {\n\t\t\tString vn = FileNameTranslationHelper.getVoiceName(ctx, n);\n\t\t\tMenuItem item = optionsMenu.getMenu().add(vn);\n\t\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tdialog.dismiss();\n\t\t\t\t\tshowWiki(ctx, app, a, n);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\toptionsMenu.show();\n\t\t\n\t}","commit_id":"63417876f3577f1b0d7e1f1816d33aac9e42be58","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void populateObjectContextMenu(Object o, ContextMenuAdapter adapter) {\n\t\tif (o instanceof Amenity) {\n\t\t\tfinal Amenity a = (Amenity) o;\n\t\t\tOnContextMenuClick listener = new ContextMenuAdapter.OnContextMenuClick() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {\n\t\t\t\t\tif (itemId == R.string.poi_context_menu_call) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW);\n\t\t\t\t\t\t\tintent.setData(Uri.parse(\"tel:\" + a.getPhone())); //$NON-NLS-1$\n\t\t\t\t\t\t\tview.getContext().startActivity(intent);\n\t\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\t\tlog.error(\"Failed to invoke call\", e); //$NON-NLS-1$\n\t\t\t\t\t\t\tAccessibleToast.makeText(view.getContext(), e.getMessage(), Toast.LENGTH_SHORT).show();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (itemId == R.string.poi_context_menu_website) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW);\n\t\t\t\t\t\t\tintent.setData(Uri.parse(a.getSite()));\n\t\t\t\t\t\t\tview.getContext().startActivity(intent);\n\t\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\t\tlog.error(\"Failed to invoke call\", e); //$NON-NLS-1$\n\t\t\t\t\t\t\tAccessibleToast.makeText(view.getContext(), e.getMessage(), Toast.LENGTH_SHORT).show();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (itemId == R.string.poi_context_menu_showdescription) {\n\t\t\t\t\t\tshowDescriptionDialog(view.getContext(), app, a);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (OsmAndFormatter.getAmenityDescriptionContent(view.getApplication(), a, false).length() > 0) {\n\t\t\t\tadapter.item(R.string.poi_context_menu_showdescription)\n\t\t\t\t\t\t.iconColor(R.drawable.ic_action_note_dark).listen(listener).reg();\n\t\t\t}\n\t\t\tif (a.getPhone() != null) {\n\t\t\t\tadapter.item(R.string.poi_context_menu_call)\n\t\t\t\t\t\t.iconColor(R.drawable.ic_action_call_dark).listen(listener).reg();\n\t\t\t}\n\t\t\tif (a.getSite() != null) {\n\t\t\t\tadapter.item(R.string.poi_context_menu_website)\n\t\t\t\t\t\t.iconColor(R.drawable.ic_world_globe_dark).listen(listener)\n\t\t\t\t\t\t.reg();\n\t\t\t}\n\t\t}\n\t}","id":25142,"modified_method":"@Override\n\tpublic void populateObjectContextMenu(Object o, ContextMenuAdapter adapter) {\n\t\tif (o instanceof Amenity) {\n\t\t\tfinal Amenity a = (Amenity) o;\n\t\t\tOnContextMenuClick listener = new ContextMenuAdapter.OnContextMenuClick() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {\n\t\t\t\t\tif (itemId == R.string.poi_context_menu_call) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW);\n\t\t\t\t\t\t\tintent.setData(Uri.parse(\"tel:\" + a.getPhone())); //$NON-NLS-1$\n\t\t\t\t\t\t\tview.getContext().startActivity(intent);\n\t\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\t\tlog.error(\"Failed to invoke call\", e); //$NON-NLS-1$\n\t\t\t\t\t\t\tAccessibleToast.makeText(view.getContext(), e.getMessage(), Toast.LENGTH_SHORT).show();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (itemId == R.string.poi_context_menu_website) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW);\n\t\t\t\t\t\t\tintent.setData(Uri.parse(a.getSite()));\n\t\t\t\t\t\t\tview.getContext().startActivity(intent);\n\t\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\t\tlog.error(\"Failed to invoke call\", e); //$NON-NLS-1$\n\t\t\t\t\t\t\tAccessibleToast.makeText(view.getContext(), e.getMessage(), Toast.LENGTH_SHORT).show();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (itemId == R.string.poi_context_menu_showdescription) {\n\t\t\t\t\t\tshowDescriptionDialog(view.getContext(), app, a);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (OsmAndFormatter.getAmenityDescriptionContent(view.getApplication(), a, false).length() > 0 || \n\t\t\t\t\ta.getType().isWiki()) {\n\t\t\t\tadapter.item(R.string.poi_context_menu_showdescription)\n\t\t\t\t\t\t.iconColor(R.drawable.ic_action_note_dark).listen(listener).reg();\n\t\t\t}\n\t\t\tif (a.getPhone() != null) {\n\t\t\t\tadapter.item(R.string.poi_context_menu_call)\n\t\t\t\t\t\t.iconColor(R.drawable.ic_action_call_dark).listen(listener).reg();\n\t\t\t}\n\t\t\tif (a.getSite() != null) {\n\t\t\t\tadapter.item(R.string.poi_context_menu_website)\n\t\t\t\t\t\t.iconColor(R.drawable.ic_world_globe_dark).listen(listener)\n\t\t\t\t\t\t.reg();\n\t\t\t}\n\t\t}\n\t}","commit_id":"63417876f3577f1b0d7e1f1816d33aac9e42be58","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private static void showWiki(final Context ctx,final OsmandApplication app, final Amenity a, final String lang ) {\n\t\tfinal Dialog dialog = new Dialog(ctx, \n\t\t\t\tapp.getSettings().isLightContent() ?\n\t\t\t\t\t\tR.style.OsmandLightTheme:\n\t\t\t\t\t\t\tR.style.OsmandDarkTheme);\n\t\tfinal String title = a.getName(lang);\n\t\tLinearLayout ll = new LinearLayout(ctx);\n\t\tll.setOrientation(LinearLayout.VERTICAL);\n\t\t\n\t\tfinal Toolbar topBar = new Toolbar(ctx);\n\t\ttopBar.setClickable(true);\n\t\tDrawable back = app.getIconsCache().getIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha);\n\t\ttopBar.setNavigationIcon(back);\n\t\ttopBar.setTitle(title);\n\t\ttopBar.setBackgroundColor(ctx.getResources().getColor(getResIdFromAttribute(ctx, R.attr.pstsTabBackground)));\n\t\ttopBar.setTitleTextColor(ctx.getResources().getColor(getResIdFromAttribute(ctx, R.attr.pstsTextColor)));\n\n\t\tString lng = a.getNameSelected(lang);\n\t\tif(Algorithms.isEmpty(lng)) {\n\t\t\t// Second choice to display wiki article in if it does not exist in the OsmAnd locale is EN\n\t\t\tlng = a.getNameSelected(\"en\");\n\t\t\t// If POI has no \"en\" name, \"\" is returned. Unfortunatley no easy way then to determine what the corresponding article language is.\n\t\t\t// \"\" is also returned if no name can be found at all\n\t\t}\n\n\t\tfinal String langSelected = lng;\n\t\tString content = a.getDescription(langSelected);\n\t\tfinal Button bottomBar = new Button(ctx);\n\t\tbottomBar.setText(R.string.read_full_article);\n\t\tbottomBar.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tString article = \"http://\"+langSelected.toLowerCase()+\".wikipedia.org/wiki/\" + title.replace(' ', '_');\n\t\t\t\t// If Default language, use EN for the URL, unless we find a better way to determine what the articles default language is\n\t\t\t\tif(langSelected.equals(\"\")) {\n\t\t\t\t\tarticle = \"http://en.wikipedia.org/wiki/\" + title.replace(' ', '_');\n\t\t\t\t}\n\t\t\t\tIntent i = new Intent(Intent.ACTION_VIEW);\n\t\t\t\ti.setData(Uri.parse(article));\n\t\t\t\tctx.startActivity(i);\n\t\t\t}\n\t\t});\n\t\tMenuItem mi = topBar.getMenu().add(langSelected.toUpperCase()).setOnMenuItemClickListener(new OnMenuItemClickListener()  {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(final MenuItem item) {\n\t\t\t\tshowPopupLangMenu(ctx, topBar, app, a, dialog);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tMenuItemCompat.setShowAsAction(mi, MenuItem.SHOW_AS_ACTION_ALWAYS);\n\t\ttopBar.setNavigationOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(final View v) {\n\t\t\t\tdialog.dismiss();\n\t\t\t}\n\t\t});\n\t\tfinal WebView wv = new WebView(ctx);\n\t\tWebSettings settings = wv.getSettings();\n\t\tsettings.setDefaultTextEncodingName(\"utf-8\");\n\t\twv.loadDataWithBaseURL(null, content, \"text/html\", \"UTF-8\", null);\n//\t\twv.loadUrl(OsMoService.SIGN_IN_URL + app.getSettings().OSMO_DEVICE_KEY.get());\n\t\tScrollView scrollView = new ScrollView(ctx);\n\t\tll.addView(topBar);\n\t\tLayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, 0);\n\t\tlp.weight = 1;\n\t\tll.addView(scrollView, lp);\n\t\tll.addView(bottomBar, new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT));\n\t\tscrollView.addView(wv);\n\t\tdialog.setContentView(ll);\n\t\twv.setFocusable(true);\n        wv.setFocusableInTouchMode(true);\n\t\twv.requestFocus(View.FOCUS_DOWN);\n\t\twv.setOnTouchListener(new View.OnTouchListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\tif (!v.hasFocus()) {\n\t\t\t\t\t\tv.requestFocus();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\t\n\t\tdialog.setCancelable(true);\n\t\tdialog.show();\t\t\n//\t\twv.setWebViewClient();\t\t\n\t}","id":25143,"modified_method":"private static void showWiki(final Context ctx,final OsmandApplication app, final Amenity a, final String lang ) {\n\t\tfinal Dialog dialog = new Dialog(ctx, \n\t\t\t\tapp.getSettings().isLightContent() ?\n\t\t\t\t\t\tR.style.OsmandLightTheme:\n\t\t\t\t\t\t\tR.style.OsmandDarkTheme);\n\t\tfinal String title = a.getName(lang);\n\t\tLinearLayout ll = new LinearLayout(ctx);\n\t\tll.setOrientation(LinearLayout.VERTICAL);\n\t\t\n\t\tfinal Toolbar topBar = new Toolbar(ctx);\n\t\ttopBar.setClickable(true);\n\t\tDrawable back = app.getIconsCache().getIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha);\n\t\ttopBar.setNavigationIcon(back);\n\t\ttopBar.setTitle(title);\n\t\ttopBar.setBackgroundColor(ctx.getResources().getColor(getResIdFromAttribute(ctx, R.attr.pstsTabBackground)));\n\t\ttopBar.setTitleTextColor(ctx.getResources().getColor(getResIdFromAttribute(ctx, R.attr.pstsTextColor)));\n\n\t\tString lng = a.getNameSelected(lang);\n\t\tif(Algorithms.isEmpty(lng)) {\n\t\t\tlng = \"en\";\n\t\t}\n\n\t\tfinal String langSelected = lng;\n\t\tString content = a.getDescription(langSelected);\n\t\tfinal Button bottomBar = new Button(ctx);\n\t\tbottomBar.setText(R.string.read_full_article);\n\t\tbottomBar.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tString article = \"http://\"+langSelected.toLowerCase()+\".wikipedia.org/wiki/\" + title.replace(' ', '_');\n\t\t\t\t// If Default language, use EN for the URL, unless we find a better way to determine what the articles default language is\n\t\t\t\tif(langSelected.equals(\"\")) {\n\t\t\t\t\tarticle = \"http://en.wikipedia.org/wiki/\" + title.replace(' ', '_');\n\t\t\t\t}\n\t\t\t\tIntent i = new Intent(Intent.ACTION_VIEW);\n\t\t\t\ti.setData(Uri.parse(article));\n\t\t\t\tctx.startActivity(i);\n\t\t\t}\n\t\t});\n\t\tMenuItem mi = topBar.getMenu().add(langSelected.toUpperCase()).setOnMenuItemClickListener(new OnMenuItemClickListener()  {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(final MenuItem item) {\n\t\t\t\tshowPopupLangMenu(ctx, topBar, app, a, dialog);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tMenuItemCompat.setShowAsAction(mi, MenuItem.SHOW_AS_ACTION_ALWAYS);\n\t\ttopBar.setNavigationOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(final View v) {\n\t\t\t\tdialog.dismiss();\n\t\t\t}\n\t\t});\n\t\tfinal WebView wv = new WebView(ctx);\n\t\tWebSettings settings = wv.getSettings();\n\t\tsettings.setDefaultTextEncodingName(\"utf-8\");\n\t\twv.loadDataWithBaseURL(null, content, \"text/html\", \"UTF-8\", null);\n//\t\twv.loadUrl(OsMoService.SIGN_IN_URL + app.getSettings().OSMO_DEVICE_KEY.get());\n\t\tScrollView scrollView = new ScrollView(ctx);\n\t\tll.addView(topBar);\n\t\tLayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, 0);\n\t\tlp.weight = 1;\n\t\tll.addView(scrollView, lp);\n\t\tll.addView(bottomBar, new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT));\n\t\tscrollView.addView(wv);\n\t\tdialog.setContentView(ll);\n\t\twv.setFocusable(true);\n        wv.setFocusableInTouchMode(true);\n\t\twv.requestFocus(View.FOCUS_DOWN);\n\t\twv.setOnTouchListener(new View.OnTouchListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\tif (!v.hasFocus()) {\n\t\t\t\t\t\tv.requestFocus();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\t\n\t\tdialog.setCancelable(true);\n\t\tdialog.show();\t\t\n//\t\twv.setWebViewClient();\t\t\n\t}","commit_id":"63417876f3577f1b0d7e1f1816d33aac9e42be58","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void onItemClick(AdapterView<?> parent, final View view, int position, long id) {\n\t\tfinal Amenity amenity = ((AmenityAdapter) getListAdapter()).getItem(position);\n\t\tfinal OsmandSettings settings = app.getSettings();\n\t\tString poiSimpleFormat = OsmAndFormatter.getPoiStringWithoutType(amenity,\n\t\t\t\tapp.getSettings().MAP_PREFERRED_LOCALE.get());\n\t\tPointDescription name = new PointDescription(PointDescription.POINT_TYPE_POI, poiSimpleFormat);\n\t\tint z = Math.max(16, settings.getLastKnownMapZoom());\n\t\tfinal PopupMenu optionsMenu = new PopupMenu(this, view);\n\t\tDirectionsDialogs.createDirectionsActionsPopUpMenu(optionsMenu, amenity.getLocation(), amenity, name, z, this,\n\t\t\t\ttrue);\n\t\tfinal String d = OsmAndFormatter.getAmenityDescriptionContent(getMyApplication(), amenity, false);\n\t\tif (d.toString().trim().length() > 0) {\n\t\t\tMenuItem item = optionsMenu\n\t\t\t\t\t.getMenu()\n\t\t\t\t\t.add(R.string.poi_context_menu_showdescription)\n\t\t\t\t\t.setIcon(\n\t\t\t\t\t\t\tgetMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_note_dark));\n\t\t\titem.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// Build text(amenity)\n\t\t\t\t\tPOIMapLayer.showDescriptionDialog(SearchPOIActivity.this, app, amenity);\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (((OsmandApplication) getApplication()).accessibilityEnabled()) {\n\t\t\tMenuItem item = optionsMenu.getMenu().add(R.string.shared_string_show_details);\n\t\t\titem.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tshowPOIDetails(amenity, app.getSettings().MAP_PREFERRED_LOCALE.get());\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\toptionsMenu.show();\n\t}","id":25144,"modified_method":"@Override\n\tpublic void onItemClick(AdapterView<?> parent, final View view, int position, long id) {\n\t\tfinal Amenity amenity = ((AmenityAdapter) getListAdapter()).getItem(position);\n\t\tfinal OsmandSettings settings = app.getSettings();\n\t\tString poiSimpleFormat = OsmAndFormatter.getPoiStringWithoutType(amenity,\n\t\t\t\tapp.getSettings().MAP_PREFERRED_LOCALE.get());\n\t\tPointDescription name = new PointDescription(PointDescription.POINT_TYPE_POI, poiSimpleFormat);\n\t\tint z = Math.max(16, settings.getLastKnownMapZoom());\n\t\tfinal PopupMenu optionsMenu = new PopupMenu(this, view);\n\t\tDirectionsDialogs.createDirectionsActionsPopUpMenu(optionsMenu, amenity.getLocation(), amenity, name, z, this,\n\t\t\t\ttrue);\n\t\tfinal String d = OsmAndFormatter.getAmenityDescriptionContent(getMyApplication(), amenity, false);\n\t\tif (d.toString().trim().length() > 0 || amenity.getType().isWiki()) {\n\t\t\tMenuItem item = optionsMenu\n\t\t\t\t\t.getMenu()\n\t\t\t\t\t.add(R.string.poi_context_menu_showdescription)\n\t\t\t\t\t.setIcon(\n\t\t\t\t\t\t\tgetMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_note_dark));\n\t\t\titem.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// Build text(amenity)\n\t\t\t\t\tPOIMapLayer.showDescriptionDialog(SearchPOIActivity.this, app, amenity);\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (((OsmandApplication) getApplication()).accessibilityEnabled()) {\n\t\t\tMenuItem item = optionsMenu.getMenu().add(R.string.shared_string_show_details);\n\t\t\titem.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tshowPOIDetails(amenity, app.getSettings().MAP_PREFERRED_LOCALE.get());\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\toptionsMenu.show();\n\t}","commit_id":"63417876f3577f1b0d7e1f1816d33aac9e42be58","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void actionPerformed(ActionEvent e)\n    {\n        /*\n        JFileChooser chooser = new JFileChooser();\n        chooser.setDialogTitle(\"Open Map\");\n        chooser.setFileFilter(new VueFileFilter());\n        if (VueUtil.isCurrentDirectoryPathSet()) \n            chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n        int option = chooser.showDialog(tufts.vue.VUE.frame, \"Open\");\n        String fileName = \"test.xml\";\n        if (option == JFileChooser.APPROVE_OPTION) {\n            fileName = chooser.getSelectedFile().getAbsolutePath();\n            VueUtil.setCurrentDirectoryPath(chooser.getSelectedFile().getP //if it isn't a file name with the right extention \n                if (!fileName.endsWith(\".\" + extension))\n                fileName += \".\" + extension;arent());\n         */\n           \n        File file = ActionUtil.openFile(\"Open Map\", \"xml\");\n        \n        if (file != null && file.getName().endsWith(\".xml\"))\n        {\n         \n            VUE.activateWaitCursor();\n            try \n            {\n                //LWMap loadedMap = loadMap(fileName);\n                LWMap loadedMap = loadMap(file.getAbsolutePath());\n                VUE.displayMap(loadedMap);\n            } \n            finally \n            {\n                VUE.clearWaitCursor();\n            }\n        }\n        \n        System.out.println(\"Action[\"+e.getActionCommand()+\"] completed.\");\n    }","id":25145,"modified_method":"public void actionPerformed(ActionEvent e)\n    {\n        /*\n        JFileChooser chooser = new JFileChooser();\n        chooser.setDialogTitle(\"Open Map\");\n        chooser.setFileFilter(new VueFileFilter());\n        if (VueUtil.isCurrentDirectoryPathSet()) \n            chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n        int option = chooser.showDialog(tufts.vue.VUE.frame, \"Open\");\n        String fileName = \"test.xml\";\n        if (option == JFileChooser.APPROVE_OPTION) {\n            fileName = chooser.getSelectedFile().getAbsolutePath();\n            VueUtil.setCurrentDirectoryPath(chooser.getSelectedFile().getP //if it isn't a file name with the right extention \n                if (!fileName.endsWith(\".\" + extension))\n                fileName += \".\" + extension;arent());\n         */\n           \n        File file = ActionUtil.openFile(\"Open Map\", \"xml\");\n        displayMap(file);\n        \n        \n        \n        System.out.println(\"Action[\"+e.getActionCommand()+\"] completed.\");\n    }","commit_id":"59dc61050bb88a535651f271df954fcdabdab3d6","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(java.awt.event.ActionEvent e) {\n        try {\n            Publisher publisher = new Publisher();\n       /**\n            createIMSCP();\n           \n            transferMap();\n           createMETSFile();\n          **/\n        } catch(Exception ex) {\n            VueUtil.alert(null, ex.getMessage(), \"Publish Error\");\n           ex.printStackTrace();\n        }\n    }","id":25146,"modified_method":"public void actionPerformed(java.awt.event.ActionEvent e) {\n        try {\n           // Publisher publisher = new Publisher();\n       /**\n            createIMSCP();\n           \n            transferMap();\n           createMETSFile();\n          **/\n        } catch(Exception ex) {\n            VueUtil.alert(null, ex.getMessage(), \"Publish Error\");\n           ex.printStackTrace();\n        }\n    }","commit_id":"59dc61050bb88a535651f271df954fcdabdab3d6","url":"https://github.com/VUE/VUE"},{"original_method":"public  void publishAll() {\n        try {\n            \n        Iterator i = resourceVector.iterator();\n        while(i.hasNext()) {\n            Vector vector = (Vector)i.next();\n            Resource r = (Resource)(vector.elementAt(1));\n            Boolean b = (Boolean)(vector.elementAt(0));\n            File file = new File(r.toURLString().substring(8));\n            if(file.isFile() && b.booleanValue()) {\n                 String transferredFileName = transferFile(file,file.getName());\n                 File METSFile = createMETSFile( transferredFileName,\"obj-binary.xml\");\n                 String pid = ingestToFedora(METSFile);\n                 System.out.println(\"Resource = \" + r+\"size = \"+r.getSize()+ \" FileName = \"+file.getName()+\" pid =\"+pid);\n              \n            }    \n           publishMap();\n        }\n            System.out.println(\"Publish All\");\n        } catch (Exception ex) {\n            VueUtil.alert(null, ex.getMessage(), \"Publish Error\");\n             ex.printStackTrace();\n        }\n    }","id":25147,"modified_method":"public  void publishAll() {\n        try {\n            \n        Iterator i = resourceVector.iterator();\n        while(i.hasNext()) {\n            Vector vector = (Vector)i.next();\n            Resource r = (Resource)(vector.elementAt(1));\n            Boolean b = (Boolean)(vector.elementAt(0));\n\n            File file = new File(r.getSpec());\n\n            if(file.isFile() && b.booleanValue()) {\n                 resourceTable.getModel().setValueAt(\"Processing\",resourceVector.indexOf(vector),STATUS_COL);\n                 String transferredFileName = transferFile(file,file.getName());\n                 File METSFile = createMETSFile( transferredFileName,\"obj-binary.xml\");\n                 String pid = ingestToFedora(METSFile);\n                 resourceTable.getModel().setValueAt(\"Done\",resourceVector.indexOf(vector),STATUS_COL);\n                 System.out.println(\"Resource = \" + r+\"size = \"+r.getSize()+ \" FileName = \"+file.getName()+\" pid =\"+pid+\" vector =\"+resourceVector.indexOf(vector)+\" table value= \"+resourceTable.getValueAt(resourceVector.indexOf(vector),STATUS_COL));\n              \n            }    \n           publishMap();\n        }\n            System.out.println(\"Publish All\");\n        } catch (Exception ex) {\n            VueUtil.alert(null, ex.getMessage(), \"Publish Error\");\n             ex.printStackTrace();\n        }\n    }","commit_id":"59dc61050bb88a535651f271df954fcdabdab3d6","url":"https://github.com/VUE/VUE"},{"original_method":"private File createIMSCP() throws IOException,URISyntaxException {\n        \n        LWMap map = tufts.vue.VUE.getActiveMap();\n        IMSCP imscp = new IMSCP();\n        saveActiveMap();\n        System.out.println(\"Writing Active Map : \"+activeMapFile.getName());\n        imscp.putEntry(IMSCP.MAP_FILE,activeMapFile);\n        \n        Iterator i = resourceVector.iterator();\n        \n        while(i.hasNext()) {\n            Vector vector = (Vector)i.next();\n            Resource r = (Resource)(vector.elementAt(1));\n            Boolean b = (Boolean)(vector.elementAt(0));\n            File file = new File(r.toURLString().substring(8));\n            if(file.isFile() && b.booleanValue()) {\n                 System.out.println(\"Resource = \" + r+\"size = \"+r.getSize()+ \" FileName = \"+file.getName()+\" index =\"+vector.indexOf(r));\n                 resourceTable.setValueAt(\"Processing\",resourceVector.indexOf(vector),3);\n                 imscp.putEntry(IMSCP.RESOURCE_FILES+\"/\"+file.getName(),file);\n                 resourceTable.setValueAt(\"Done\",resourceVector.indexOf(vector),3);\n                 \n            }    \n           \n        }\n       \n        imscp.closeZOS();\n        return imscp.getFile();\n        \n    }","id":25148,"modified_method":"private File createIMSCP() throws IOException,URISyntaxException {\n        \n        LWMap map = tufts.vue.VUE.getActiveMap();\n        IMSCP imscp = new IMSCP();\n        saveActiveMap();\n        System.out.println(\"Writing Active Map : \"+activeMapFile.getName());\n        imscp.putEntry(IMSCP.MAP_FILE,activeMapFile);\n        \n        Iterator i = resourceVector.iterator();\n        \n        while(i.hasNext()) {\n            Vector vector = (Vector)i.next();\n            Resource r = (Resource)(vector.elementAt(1));\n            Boolean b = (Boolean)(vector.elementAt(0));\n\n            File file = new File(r.getSpec());\n\n       \n            if(file.isFile() && b.booleanValue()) {\n                 System.out.println(\"Resource = \" + r+\"size = \"+r.getSize()+ \" FileName = \"+file.getName()+\" index =\"+resourceVector.indexOf(vector));\n                 resourceTable.setValueAt(\"Processing\",resourceVector.indexOf(vector),STATUS_COL);\n                 imscp.putEntry(IMSCP.RESOURCE_FILES+\"/\"+file.getName(),file);\n                 resourceTable.setValueAt(\"Done\",resourceVector.indexOf(vector),STATUS_COL);\n                 \n            }    \n           \n        }\n       \n        imscp.closeZOS();\n        return imscp.getFile();\n        \n    }","commit_id":"59dc61050bb88a535651f271df954fcdabdab3d6","url":"https://github.com/VUE/VUE"},{"original_method":"private void setLocalResourceVector(Vector vector,LWContainer map) {\n\n       \n       Iterator i = map.getChildIterator();\n\n       while(i.hasNext()) {\n           LWComponent component = (LWComponent) i.next();\n           if(component.hasResource()){\n               Resource resource = component.getResource();\n               if(resource.isLocalFile()) {\n                   File file = new File(resource.toURLString().substring(8));\n                    if(file.isFile()) {\n                        Vector row = new Vector();\n                        row.add(new Boolean(true));\n                        row.add(resource);\n                        row.add(new Long(file.length()));\n                        row.add(\"Ready\");\n                        vector.add(row);\n                    }\n               }\n           }\n           if(component instanceof LWContainer) {\n                setLocalResourceVector(vector,(LWContainer)component);\n           }\n       }\n    }","id":25149,"modified_method":"private void setLocalResourceVector(Vector vector,LWContainer map) {\n\n       \n       Iterator i = map.getChildIterator();\n\n       while(i.hasNext()) {\n           LWComponent component = (LWComponent) i.next();\n           if(component.hasResource()){\n               Resource resource = component.getResource();\n               if(resource.isLocalFile()) {\n                    File file = new File(resource.getSpec());\n                    if(file.isFile()) {\n                        Vector row = new Vector();\n                        row.add(new Boolean(true));\n                        row.add(resource);\n                        row.add(new Long(file.length()));\n                        row.add(\"Ready\");\n                        vector.add(row);\n                    }\n               }\n           }\n           if(component instanceof LWContainer) {\n                setLocalResourceVector(vector,(LWContainer)component);\n           }\n       }\n    }","commit_id":"59dc61050bb88a535651f271df954fcdabdab3d6","url":"https://github.com/VUE/VUE"},{"original_method":"public static void main(String[] args)\n    {\n        String laf = null;\n        //laf = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\n        //laf = javax.swing.UIManager.getCrossPlatformLookAndFeelClassName();\n        try {\n            if (laf != null)\n                javax.swing.UIManager.setLookAndFeel(laf);\n        } catch (Exception e) {\n            System.err.println(e);\n        }\n        \n        // loading preferences\n        prefs = java.util.prefs.Preferences.userRoot().node(\"/\");\n        try {\n            FileInputStream fis = new FileInputStream(getResource(VUE_CONF).getPath());\n            prefs.importPreferences(fis);\n        } catch (Exception e) { System.out.println(e);}\n\n        //-------------------------------------------------------\n        // Create the tabbed pane for the viewers\n        //-------------------------------------------------------\n\n        mMapTabsLeft = new MapTabbedPane();\n        mMapTabsLeft.setTabPlacement(SwingConstants.BOTTOM);\n        mMapTabsLeft.setPreferredSize(new Dimension(300,400));\n        \n        mMapTabsRight = new MapTabbedPane();\n        mMapTabsRight.setTabPlacement(SwingConstants.BOTTOM);\n        mMapTabsRight.setPreferredSize(new Dimension(300,400));\n\n        if (true||args.length < 1) { // pathway code currently blowing us out unless we have these maps loaded\n            //-------------------------------------------------------\n            // Temporary: create example map(s)\n            //-------------------------------------------------------\n            //LWMap map1 = new LWMap(\"Test Nodes\");\n            //LWMap map2 = new LWMap(\"Example Map\");\n            //LWMap map1 = new LWMap(\"Map 1\");\n            LWMap map2 = new LWMap(\"Map 2\");\n\n            //installExampleNodes(map1);\n            installExampleMap(map2);\n\n            //map1.setFillColor(new Color(255, 255, 192));\n            \n            //displayMap(map1);\n            displayMap(map2);\n            \n        }\n        \n        \n        //-------------------------------------------------------\n        // create a an application frame and layout components\n        //-------------------------------------------------------\n        \n        toolPanel = new JPanel();\n        //JPanel toolPanel = new JPanel();\n        toolPanel.setLayout(new BorderLayout());\n        //DRBrowser drBrowser = new DRBrowser();\n        DRBrowser drBrowser = null;\n        if (args.length < 1 || !args[0].equals(\"-nodr\"))  {\n            drBrowser = new DRBrowser();\n            toolPanel.add(new DRBrowser(), BorderLayout.CENTER);\n        }\n\t\t\t        \n        // DEMO FIX:\n        // no lwinspector in left\n        //toolPanel.add(new LWCInspector(), BorderLayout.SOUTH);\n\n        JSplitPane splitPane = new JSplitPane();\n        splitPane.setResizeWeight(0.25); // 25% space to the left component\n        splitPane.setContinuousLayout(false);\n        splitPane.setOneTouchExpandable(true);\n        splitPane.setLeftComponent(toolPanel);\n        //splitPane.setLeftComponent(leftScroller);\n\n        viewerSplit = new JSplitPane();\n        viewerSplit.setOneTouchExpandable(true);\n        viewerSplit.setRightComponent(mMapTabsRight);\n        // NOTE: set left component AFTER set right component -- the\n        // LAST set left/right call determines the default focus component!\n        // It needs to be the LEFT component as the right one isn't\n        // even visible at startup!\n        viewerSplit.setLeftComponent(mMapTabsLeft);\n        viewerSplit.setResizeWeight(0.5);\n        viewerSplit.setDividerLocation(9999);\n\n        //splitPane.setRightComponent(mMapTabsLeft);\n        splitPane.setRightComponent(viewerSplit);\n\n        frame = new VueFrame();\n        JPanel vuePanel = new VuePanel();\n        vuePanel.setLayout(new BorderLayout());\n        vuePanel.add(splitPane, BorderLayout.CENTER);\n        \n        // Create the tool windows\n        ToolWindow pannerTool = new ToolWindow(\"Panner\", frame);\n        pannerTool.setSize(120,120);\n        pannerTool.addTool(new MapPanner());\n\n        ToolWindow inspectorTool = new ToolWindow(\"Inspector\", frame);\n        inspectorTool.addTool(new LWCInspector());\n        \n        ToolWindow drBrowserTool  = new ToolWindow(\"DR Browser\", frame);\n        if (drBrowser != null)\n            drBrowserTool.addTool(drBrowser);\n        \n        // The real tool palette window withtools and contextual tools\n        ToolWindow toolbarWindow = new ToolWindow( VueResources.getString(\"tbWindowName\"), frame);\n        VueToolbarController tbc = VueToolbarController.getController();\n        tbc.setToolWindow( toolbarWindow);\n        toolbarWindow.getContentPane().add( tbc.getToolbar() );\n        toolbarWindow.pack();\n\n        boolean scottHack =\n            System.getProperty(\"user.name\").equals(\"sfraize\") &&\n            System.getProperty(\"scottHack\") != null;\n        // Need to factor some stuff out for the moment as has some bugs -- SMF 2003-12-29 21:32.39 Monday\n\n        if (!scottHack) ModelSelection.addListener(tbc);\n        \n        frame.getContentPane().add( tbc.getToolbar(), BorderLayout.NORTH);\n\t\t\n\t\t// Map Inspector\n\t\t\n\t\t// get the proper scree/main frame size\n\t\tToolWindow mapInspector = new ToolWindow(  VueResources.getString(\"mapInspectorTitle\"), frame);\n\t\tMapInspectorPanel mip = new MapInspectorPanel();\n\t\tif (!scottHack) ModelSelection.addListener( mip);\n\t\tmapInspector.addTool( mip );\n\t\t\n\t\t//ToolWindow objectInspector = new ToolWindow( VueResources.getString(\"objectInspectorTitle\"), frame);\n\t\tobjectInspector = new ToolWindow( VueResources.getString(\"objectInspectorTitle\"), frame);\n\t\tobjectInspectorPanel = new ObjectInspectorPanel();\n\t\tif (!scottHack) ModelSelection.addListener(objectInspectorPanel);\n\t\tsResourceSelection.addListener( objectInspectorPanel);\n\t\tobjectInspector.addTool(objectInspectorPanel);\n\t\t\n\t\t\n\t\tif( false) {\n\t\t\tJFrame testFrame = new JFrame(\"Debug\");\n\t\t\ttestFrame.setSize( 300,300);\n\t\t\t//testFrame.getContentPane().add( new NodeInspectorPanel() );\n\t\t\ttestFrame.getContentPane().add(objectInspectorPanel);\n\t\t\ttestFrame.show();\n\t\t}\n\t\t\n\t\t\n        //addtion by the power team\n        pathwayInspector = new LWPathwayInspector(frame);\n        //control = new PathwayControl(frame);\n        \n        hierarchyTree = new LWHierarchyTree(frame);\n        outlineView = new LWOutlineView(frame);\n        //end of addition\n       \n        Window[] toolWindows = {\n            toolbarWindow,\n            pannerTool,\n            inspectorTool,\n            drBrowserTool,\n            pathwayInspector,\n            hierarchyTree,\n            mapInspector,\n            objectInspector,\n            outlineView,\n        };\n        \n        // adding the menus and toolbars\n        setMenuToolbars(frame, toolWindows);\n        System.out.println(\"after setting menu toolbars...\");\n        frame.getContentPane().add(vuePanel,BorderLayout.CENTER);\n        //frame.setContentPane(vuePanel);\n        //frame.setContentPane(splitPane);\n        frame.setBackground(Color.white);\n        frame.pack();\n\n        Dimension d = frame.getToolkit().getScreenSize();\n        int x = d.width/2 - frame.getWidth()/2;\n        int y = d.height/2 - frame.getHeight()/2;\n        frame.setLocation(x, y);\n        \n        // position inspectors pased on frame location\n        int inspectorx = x + frame.getWidth() - mapInspector.getWidth();\n        mapInspector.setLocation( inspectorx, y);\n        objectInspector.setLocation( inspectorx, y + mapInspector.getHeight() );\n        \n        \n        \n        frame.show();\n        System.out.println(\"after showing frame...\");\n        if (args.length > 0) {\n            try {\n                OpenAction oa = null;\n                for (int i = 0; i < args.length; i++) {\n                    if (args[i].charAt(0) == '-')\n                        continue;\n                    if (oa == null)\n                        oa = new OpenAction();\n                    VUE.activateWaitCursor();\n                    LWMap map = oa.loadMap(args[i]);\n                    if (map != null)\n                        displayMap(map);\n                }\n            } finally {\n                VUE.clearWaitCursor();\n            }\n        }\n        //setViewerScrollbarsDisplayed(true);\n        System.out.println(\"VUE.main completed.\");\n    }","id":25150,"modified_method":"public static void main(String[] args)\n    {\n        String laf = null;\n        //laf = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\n        //laf = javax.swing.UIManager.getCrossPlatformLookAndFeelClassName();\n        try {\n            if (laf != null)\n                javax.swing.UIManager.setLookAndFeel(laf);\n        } catch (Exception e) {\n            System.err.println(e);\n        }\n        \n        // loading preferences\n        prefs = java.util.prefs.Preferences.userRoot().node(\"/\");\n        try {\n            FileInputStream fis = new FileInputStream(getResource(VUE_CONF).getPath());\n            prefs.importPreferences(fis);\n        } catch (Exception e) { System.out.println(e);}\n\n        //-------------------------------------------------------\n        // Create the tabbed pane for the viewers\n        //-------------------------------------------------------\n\n        mMapTabsLeft = new MapTabbedPane();\n        mMapTabsLeft.setTabPlacement(SwingConstants.BOTTOM);\n        mMapTabsLeft.setPreferredSize(new Dimension(300,400));\n        \n        mMapTabsRight = new MapTabbedPane();\n        mMapTabsRight.setTabPlacement(SwingConstants.BOTTOM);\n        mMapTabsRight.setPreferredSize(new Dimension(300,400));\n\n        if (true||args.length < 1) { // pathway code currently blowing us out unless we have these maps loaded\n            //-------------------------------------------------------\n            // Temporary: create example map(s)\n            //-------------------------------------------------------\n            //LWMap map1 = new LWMap(\"Test Nodes\");\n            //LWMap map2 = new LWMap(\"Example Map\");\n            //LWMap map1 = new LWMap(\"Map 1\");\n            LWMap map2 = new LWMap(\"Map 2\");\n\n            //installExampleNodes(map1);\n            installExampleMap(map2);\n\n            //map1.setFillColor(new Color(255, 255, 192));\n            \n            //displayMap(map1);\n            displayMap(map2);\n            \n        }\n        \n        \n        //-------------------------------------------------------\n        // create a an application frame and layout components\n        //-------------------------------------------------------\n        \n        toolPanel = new JPanel();\n        //JPanel toolPanel = new JPanel();\n        toolPanel.setLayout(new BorderLayout());\n        //DRBrowser drBrowser = new DRBrowser();\n        DRBrowser drBrowser = null;\n        if (args.length < 1 || !args[0].equals(\"-nodr\"))  {\n            drBrowser = new DRBrowser();\n            toolPanel.add(new DRBrowser(), BorderLayout.CENTER);\n        }\n\t\t\t        \n        // DEMO FIX:\n        // no lwinspector in left\n        //toolPanel.add(new LWCInspector(), BorderLayout.SOUTH);\n\n        JSplitPane splitPane = new JSplitPane();\n        splitPane.setResizeWeight(0.25); // 25% space to the left component\n        splitPane.setContinuousLayout(false);\n        splitPane.setOneTouchExpandable(true);\n        splitPane.setLeftComponent(toolPanel);\n        //splitPane.setLeftComponent(leftScroller);\n\n        viewerSplit = new JSplitPane();\n        viewerSplit.setOneTouchExpandable(true);\n        viewerSplit.setRightComponent(mMapTabsRight);\n        // NOTE: set left component AFTER set right component -- the\n        // LAST set left/right call determines the default focus component!\n        // It needs to be the LEFT component as the right one isn't\n        // even visible at startup!\n        viewerSplit.setLeftComponent(mMapTabsLeft);\n        viewerSplit.setResizeWeight(0.5);\n        viewerSplit.setDividerLocation(9999);\n\n        //splitPane.setRightComponent(mMapTabsLeft);\n        splitPane.setRightComponent(viewerSplit);\n\n        frame = new VueFrame();\n        JPanel vuePanel = new VuePanel();\n        vuePanel.setLayout(new BorderLayout());\n        vuePanel.add(splitPane, BorderLayout.CENTER);\n        \n        // Create the tool windows\n        ToolWindow pannerTool = new ToolWindow(\"Panner\", frame);\n        pannerTool.setSize(120,120);\n        pannerTool.addTool(new MapPanner());\n\n        ToolWindow inspectorTool = new ToolWindow(\"Inspector\", frame);\n        inspectorTool.addTool(new LWCInspector());\n        \n        ToolWindow drBrowserTool  = new ToolWindow(\"DR Browser\", frame);\n        if (drBrowser != null)\n            drBrowserTool.addTool(drBrowser);\n        \n        // The real tool palette window withtools and contextual tools\n        ToolWindow toolbarWindow = new ToolWindow( VueResources.getString(\"tbWindowName\"), frame);\n        VueToolbarController tbc = VueToolbarController.getController();\n        tbc.setToolWindow( toolbarWindow);\n        toolbarWindow.getContentPane().add( tbc.getToolbar() );\n        toolbarWindow.pack();\n\n        boolean scottHack =\n            System.getProperty(\"user.name\").equals(\"sfraize\") &&\n            System.getProperty(\"scottHack\") != null;\n        // Need to factor some stuff out for the moment as has some bugs -- SMF 2003-12-29 21:32.39 Monday\n\n        if (!scottHack) ModelSelection.addListener(tbc);\n        \n        frame.getContentPane().add( tbc.getToolbar(), BorderLayout.NORTH);\n\t\t\n\t\t// Map Inspector\n\t\t\n\t\t// get the proper scree/main frame size\n\t\tToolWindow mapInspector = new ToolWindow(  VueResources.getString(\"mapInspectorTitle\"), frame);\n\t\tMapInspectorPanel mip = new MapInspectorPanel();\n\t\tif (!scottHack) ModelSelection.addListener( mip);\n\t\tmapInspector.addTool( mip );\n\t\t\n\t\t//ToolWindow objectInspector = new ToolWindow( VueResources.getString(\"objectInspectorTitle\"), frame);\n\t\tobjectInspector = new ToolWindow( VueResources.getString(\"objectInspectorTitle\"), frame);\n\t\tobjectInspectorPanel = new ObjectInspectorPanel();\n\t\tif (!scottHack) ModelSelection.addListener(objectInspectorPanel);\n\t\tsResourceSelection.addListener( objectInspectorPanel);\n\t\tobjectInspector.addTool(objectInspectorPanel);\n\t\t\n\t\t\n\t\tif( false) {\n\t\t\tJFrame testFrame = new JFrame(\"Debug\");\n\t\t\ttestFrame.setSize( 300,300);\n\t\t\t//testFrame.getContentPane().add( new NodeInspectorPanel() );\n\t\t\ttestFrame.getContentPane().add(objectInspectorPanel);\n\t\t\ttestFrame.show();\n\t\t}\n\t\t\n\t\t\n        //addtion by the power team\n        pathwayInspector = new LWPathwayInspector(frame);\n        //control = new PathwayControl(frame);\n        \n        hierarchyTree = new LWHierarchyTree(frame);\n        outlineView = new LWOutlineView(frame);\n        //end of addition\n       \n        Window[] toolWindows = {\n            toolbarWindow,\n            pannerTool,\n            inspectorTool,\n            drBrowserTool,\n            pathwayInspector,\n            hierarchyTree,\n            mapInspector,\n            objectInspector,\n            outlineView,\n        };\n        \n        // adding the menus and toolbars\n        setMenuToolbars(frame, toolWindows);\n        System.out.println(\"after setting menu toolbars...\");\n        frame.getContentPane().add(vuePanel,BorderLayout.CENTER);\n        //frame.setContentPane(vuePanel);\n        //frame.setContentPane(splitPane);\n        frame.setBackground(Color.white);\n        frame.pack();\n\n        Dimension d = frame.getToolkit().getScreenSize();\n        int x = d.width/2 - frame.getWidth()/2;\n        int y = d.height/2 - frame.getHeight()/2;\n        frame.setLocation(x, y);\n        \n        // position inspectors pased on frame location\n        int inspectorx = x + frame.getWidth() - mapInspector.getWidth();\n        mapInspector.setLocation( inspectorx, y);\n        objectInspector.setLocation( inspectorx, y + mapInspector.getHeight() );\n        \n        \n        \n        frame.show();\n        System.out.println(\"after showing frame...\");\n        if (args.length > 0) {\n            try {\n                OpenAction oa = null;\n                for (int i = 0; i < args.length; i++) {\n                    if (args[i].charAt(0) == '-')\n                        continue;\n                    if (oa == null)\n                        oa = new OpenAction();\n                    VUE.activateWaitCursor();\n                    LWMap map = oa.loadMap(args[i]);\n                    if (map != null)\n                        displayMap(map);\n                }\n            } finally {\n                VUE.clearWaitCursor();\n            }\n        }\n        \n        try {\n            OpenAction.displayMap(new File(System.getProperty(\"user.dir\")+\"/tufts/vue/resources/startup.xml\"));// this will be loaded using vue resourece\n        } catch(Exception ex) {\n            VueUtil.alert(null, \"Cannot load the Start up map\", \"Start Up Map Error\");\n            ex.printStackTrace();\n        }\n        //setViewerScrollbarsDisplayed(true);\n        System.out.println(\"VUE.main completed.\");\n    }","commit_id":"59dc61050bb88a535651f271df954fcdabdab3d6","url":"https://github.com/VUE/VUE"},{"original_method":"private static void  setMenuToolbars(JFrame frame, Window[] toolWindows)\n    {\n        final int metaMask = VueUtil.isMacPlatform() ? Event.META_MASK : Event.CTRL_MASK;\n        \n        JMenuBar menuBar = new JMenuBar();\n        menuBar.setBackground( menuColor);\n        \n        JMenu fileMenu = new JMenu(\"File\");\n        fileMenu.setBackground( menuColor);\n        \n        JMenu editMenu = new JMenu(\"Edit\");\n        editMenu.setBackground( menuColor);\n        \n        JMenu viewMenu = new JMenu(\"View\");\n        viewMenu.setBackground( menuColor);\n        \n        JMenu formatMenu = new JMenu(\"Format\");\n        formatMenu.setBackground( menuColor);\n        \n        JMenu arrangeMenu = new JMenu(\"Arrange\");\n        arrangeMenu.setBackground( menuColor);\n        \n        JMenu alignMenu = new JMenu(\"Align\");\n        alignMenu.setBackground(menuColor);\n\n        JMenu windowMenu = new JMenu(\"Window\");\n        windowMenu.setBackground( menuColor);\n        \n        JMenu optionsMenu = new JMenu(\"Options\");\n        optionsMenu.setBackground( menuColor);\n        \n        JMenu helpMenu = new JMenu(\"Help\");\n        helpMenu.setBackground( menuColor);\n        \n        menuBar.add(fileMenu);\n        menuBar.add(editMenu);\n        menuBar.add(viewMenu);\n        menuBar.add(formatMenu);\n        menuBar.add(arrangeMenu);\n        menuBar.add(optionsMenu);\n        menuBar.add(windowMenu);\n        menuBar.add(helpMenu);\n        //adding actions\n        SaveAction saveAction = new SaveAction(\"Save\", false);\n        SaveAction saveAsAction = new SaveAction(\"Save As...\");\n        OpenAction openAction = new OpenAction(\"Open\");\n        ExitAction exitAction = new ExitAction(\"Quit\");\n        \n        /**Actions added by the power team*/\n        JMenu exportMenu = new JMenu(\"Export\");\n        \n        PDFTransform pdfAction = new PDFTransform(\"PDF\");\n        HTMLConversion htmlAction = new HTMLConversion(\"HTML\");\n        ImageConversion imageAction = new ImageConversion(\"JPEG\");\n        ImageMap imageMap = new ImageMap(\"IMAP\");\n        SVGConversion svgAction = new SVGConversion(\"SVG\");\n        PrintAction printAction = new PrintAction(\"Print\");\n        XMLView xmlAction = new XMLView(\"XML View\");\n        \n        exportMenu.add(htmlAction);\n        exportMenu.add(pdfAction);\n        exportMenu.add(imageAction);\n        exportMenu.add(svgAction);\n        exportMenu.add(xmlAction);\n        exportMenu.add(imageMap);\n        /**End of addition*/\n        \n        fileMenu.add(Actions.NewMap);\n        fileMenu.add(openAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, metaMask));\n        fileMenu.add(saveAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S, metaMask));\n        fileMenu.add(saveAsAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S, metaMask+Event.SHIFT_MASK));\n        fileMenu.add(Actions.CloseMap);\n        fileMenu.add(printAction);\n        fileMenu.add(exportMenu);\n        fileMenu.addSeparator();\n        fileMenu.add(exitAction);\n        \n        editMenu.add(Actions.Undo);\n        editMenu.add(Actions.Redo);\n        editMenu.addSeparator();\n        editMenu.add(Actions.NewNode);\n        editMenu.add(Actions.NewText);\n        editMenu.add(Actions.Rename);\n        editMenu.add(Actions.Duplicate);\n        editMenu.addSeparator();\n        editMenu.add(Actions.Cut);\n        editMenu.add(Actions.Copy);\n        editMenu.add(Actions.Paste);\n        editMenu.addSeparator();\n        editMenu.add(Actions.SelectAll);\n        editMenu.add(Actions.DeselectAll);\n        \n        viewMenu.add(Actions.ZoomIn);\n        viewMenu.add(Actions.ZoomOut);\n        viewMenu.add(Actions.ZoomFit);\n        viewMenu.add(Actions.ZoomActual);\n        viewMenu.addSeparator();\n        viewMenu.add(new JMenuItem(\"Resources\"));\n        viewMenu.add(new JMenuItem(\"Collection\"));\n        viewMenu.add(new JMenuItem(\"Inspector\"));\n        viewMenu.add(new JMenuItem(\"Pathway\"));\n        viewMenu.add(new JMenuItem(\"Toolbar\"));\n        viewMenu.add(new JMenuItem(\"Overview\"));\n        \n        JMenu fontMenu = new JMenu(\"Font\");\n\n        /*\n        // this list bigger than screen & menu isn't scrolling for us!\n        String[] fonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n        System.out.println(java.util.Arrays.asList(fonts));\n        for (int i = 0; i < fonts.length; i++) {\n            JMenuItem fm = new JMenuItem(fonts[i]);\n            fontMenu.add(fm);\n        }\n        */\n                           \n        //formatMenu.add(fontMenu);\n        formatMenu.add(Actions.FontSmaller);\n        formatMenu.add(Actions.FontBigger);\n        formatMenu.add(Actions.FontBold);\n        formatMenu.add(Actions.FontItalic);\n        //formatMenu.add(new JMenuItem(\"Size\"));\n        //formatMenu.add(new JMenuItem(\"Style\"));\n        //formatMenu.add(\"Text Justify\").setEnabled(false);\n        // TODO: ultimately better to break these out in to Node & Link submenus\n        formatMenu.addSeparator();\n        for (int i = 0; i < Actions.NODE_MENU_ACTIONS.length; i++) {\n            Action a = Actions.NODE_MENU_ACTIONS[i];\n            if (a == null)\n                formatMenu.addSeparator();\n            else\n                formatMenu.add(a);\n        }\n        formatMenu.addSeparator();\n        for (int i = 0; i < Actions.LINK_MENU_ACTIONS.length; i++) {\n            Action a = Actions.LINK_MENU_ACTIONS[i];\n            if (a == null)\n                formatMenu.addSeparator();\n            else\n                formatMenu.add(a);\n        }\n\n        for (int i = 0; i < Actions.ALIGN_MENU_ACTIONS.length; i++) {\n            Action a = Actions.ALIGN_MENU_ACTIONS[i];\n            if (a == null)\n                alignMenu.addSeparator();\n            else\n                alignMenu.add(a);\n        }\n        \n        arrangeMenu.add(Actions.BringToFront);\n        arrangeMenu.add(Actions.BringForward);\n        arrangeMenu.add(Actions.SendToBack);\n        arrangeMenu.add(Actions.SendBackward);\n        arrangeMenu.addSeparator();\n        arrangeMenu.add(Actions.Group);\n        arrangeMenu.add(Actions.Ungroup);\n        arrangeMenu.addSeparator();\n        arrangeMenu.add(alignMenu);\n        \n        for (int i = 0; i < toolWindows.length; i++) {\n            //System.out.println(\"adding \" + toolWindows[i]);\n            Window window = toolWindows[i];\n            WindowDisplayAction windowAction = new WindowDisplayAction(window);\n            JCheckBoxMenuItem checkBox = new JCheckBoxMenuItem(windowAction);\n            windowAction.setLinkedButton(checkBox);\n            windowMenu.add(checkBox);\n        }\n\n        optionsMenu.add(new JMenuItem(\"Node Types...\"));\n        optionsMenu.add(new JMenuItem(\"Map Preference...\"));\n        optionsMenu.add(new JMenuItem(\"Preferences...\"));\n        \n        helpMenu.add(new JMenuItem(\"Help\"));\n        \n        JToolBar toolBar = new JToolBar();\n        toolBar.add(Actions.NewMap);\n        toolBar.add(openAction);\n        toolBar.add(Actions.CloseMap);\n        toolBar.add(saveAction);\n        toolBar.add(saveAsAction);\n        toolBar.add(printAction);\n        toolBar.add(imageAction);\n        toolBar.add(htmlAction);\n        toolBar.add(xmlAction);\n        toolBar.add(pdfAction);\n        toolBar.add(imageMap);\n        toolBar.add(svgAction);\n       // toolBar.add(new JButton(new ImageIcon(\"tufts/vue/images/ZoomOut16.gif\")));\n        toolBar.add(new JButton(new PolygonIcon(Color.RED)));\n        frame.setJMenuBar(menuBar);\n        //frame.getContentPane().add(toolBar,BorderLayout.NORTH);\n        frame.addWindowListener(new WindowAdapter() {\n            public void windowClosing(WindowEvent e) {ExitAction.exitVue();}});\n\n    }","id":25151,"modified_method":"private static void  setMenuToolbars(JFrame frame, Window[] toolWindows)\n    {\n        final int metaMask = VueUtil.isMacPlatform() ? Event.META_MASK : Event.CTRL_MASK;\n        \n        JMenuBar menuBar = new JMenuBar();\n        menuBar.setBackground( menuColor);\n        \n        JMenu fileMenu = new JMenu(\"File\");\n        fileMenu.setBackground( menuColor);\n        \n        JMenu editMenu = new JMenu(\"Edit\");\n        editMenu.setBackground( menuColor);\n        \n        JMenu viewMenu = new JMenu(\"View\");\n        viewMenu.setBackground( menuColor);\n        \n        JMenu formatMenu = new JMenu(\"Format\");\n        formatMenu.setBackground( menuColor);\n        \n        JMenu arrangeMenu = new JMenu(\"Arrange\");\n        arrangeMenu.setBackground( menuColor);\n        \n        JMenu alignMenu = new JMenu(\"Align\");\n        alignMenu.setBackground(menuColor);\n\n        JMenu windowMenu = new JMenu(\"Window\");\n        windowMenu.setBackground( menuColor);\n        \n        JMenu optionsMenu = new JMenu(\"Options\");\n        optionsMenu.setBackground( menuColor);\n        \n        JMenu helpMenu = new JMenu(\"Help\");\n        helpMenu.setBackground( menuColor);\n        \n        menuBar.add(fileMenu);\n        menuBar.add(editMenu);\n        menuBar.add(viewMenu);\n        menuBar.add(formatMenu);\n        menuBar.add(arrangeMenu);\n        menuBar.add(optionsMenu);\n        menuBar.add(windowMenu);\n        menuBar.add(helpMenu);\n        //adding actions\n        SaveAction saveAction = new SaveAction(\"Save\", false);\n        SaveAction saveAsAction = new SaveAction(\"Save As...\");\n        OpenAction openAction = new OpenAction(\"Open\");\n        ExitAction exitAction = new ExitAction(\"Quit\");\n        Publish publishAction = new Publish(\"Publish\");\n        \n        /**Actions added by the power team*/\n        JMenu exportMenu = new JMenu(\"Export\");\n        \n        PDFTransform pdfAction = new PDFTransform(\"PDF\");\n        HTMLConversion htmlAction = new HTMLConversion(\"HTML\");\n        ImageConversion imageAction = new ImageConversion(\"JPEG\");\n        ImageMap imageMap = new ImageMap(\"IMAP\");\n        SVGConversion svgAction = new SVGConversion(\"SVG\");\n        PrintAction printAction = new PrintAction(\"Print\");\n        XMLView xmlAction = new XMLView(\"XML View\");\n        \n        exportMenu.add(htmlAction);\n        exportMenu.add(pdfAction);\n        exportMenu.add(imageAction);\n        exportMenu.add(svgAction);\n        exportMenu.add(xmlAction);\n        exportMenu.add(imageMap);\n        /**End of addition*/\n        \n        fileMenu.add(Actions.NewMap);\n        fileMenu.add(openAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, metaMask));\n        fileMenu.add(saveAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S, metaMask));\n        fileMenu.add(saveAsAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S, metaMask+Event.SHIFT_MASK));\n        fileMenu.add(Actions.CloseMap);\n        fileMenu.add(printAction);\n        fileMenu.add(publishAction);\n        fileMenu.add(exportMenu);\n        fileMenu.addSeparator();\n        fileMenu.add(exitAction);\n        \n        editMenu.add(Actions.Undo);\n        editMenu.add(Actions.Redo);\n        editMenu.addSeparator();\n        editMenu.add(Actions.NewNode);\n        editMenu.add(Actions.NewText);\n        editMenu.add(Actions.Rename);\n        editMenu.add(Actions.Duplicate);\n        editMenu.addSeparator();\n        editMenu.add(Actions.Cut);\n        editMenu.add(Actions.Copy);\n        editMenu.add(Actions.Paste);\n        editMenu.addSeparator();\n        editMenu.add(Actions.SelectAll);\n        editMenu.add(Actions.DeselectAll);\n        \n        viewMenu.add(Actions.ZoomIn);\n        viewMenu.add(Actions.ZoomOut);\n        viewMenu.add(Actions.ZoomFit);\n        viewMenu.add(Actions.ZoomActual);\n        viewMenu.addSeparator();\n        viewMenu.add(new JMenuItem(\"Resources\"));\n        viewMenu.add(new JMenuItem(\"Collection\"));\n        viewMenu.add(new JMenuItem(\"Inspector\"));\n        viewMenu.add(new JMenuItem(\"Pathway\"));\n        viewMenu.add(new JMenuItem(\"Toolbar\"));\n        viewMenu.add(new JMenuItem(\"Overview\"));\n        \n        JMenu fontMenu = new JMenu(\"Font\");\n\n        /*\n        // this list bigger than screen & menu isn't scrolling for us!\n        String[] fonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n        System.out.println(java.util.Arrays.asList(fonts));\n        for (int i = 0; i < fonts.length; i++) {\n            JMenuItem fm = new JMenuItem(fonts[i]);\n            fontMenu.add(fm);\n        }\n        */\n                           \n        //formatMenu.add(fontMenu);\n        formatMenu.add(Actions.FontSmaller);\n        formatMenu.add(Actions.FontBigger);\n        formatMenu.add(Actions.FontBold);\n        formatMenu.add(Actions.FontItalic);\n        //formatMenu.add(new JMenuItem(\"Size\"));\n        //formatMenu.add(new JMenuItem(\"Style\"));\n        //formatMenu.add(\"Text Justify\").setEnabled(false);\n        // TODO: ultimately better to break these out in to Node & Link submenus\n        formatMenu.addSeparator();\n        for (int i = 0; i < Actions.NODE_MENU_ACTIONS.length; i++) {\n            Action a = Actions.NODE_MENU_ACTIONS[i];\n            if (a == null)\n                formatMenu.addSeparator();\n            else\n                formatMenu.add(a);\n        }\n        formatMenu.addSeparator();\n        for (int i = 0; i < Actions.LINK_MENU_ACTIONS.length; i++) {\n            Action a = Actions.LINK_MENU_ACTIONS[i];\n            if (a == null)\n                formatMenu.addSeparator();\n            else\n                formatMenu.add(a);\n        }\n\n        for (int i = 0; i < Actions.ALIGN_MENU_ACTIONS.length; i++) {\n            Action a = Actions.ALIGN_MENU_ACTIONS[i];\n            if (a == null)\n                alignMenu.addSeparator();\n            else\n                alignMenu.add(a);\n        }\n        \n        arrangeMenu.add(Actions.BringToFront);\n        arrangeMenu.add(Actions.BringForward);\n        arrangeMenu.add(Actions.SendToBack);\n        arrangeMenu.add(Actions.SendBackward);\n        arrangeMenu.addSeparator();\n        arrangeMenu.add(Actions.Group);\n        arrangeMenu.add(Actions.Ungroup);\n        arrangeMenu.addSeparator();\n        arrangeMenu.add(alignMenu);\n        \n        for (int i = 0; i < toolWindows.length; i++) {\n            //System.out.println(\"adding \" + toolWindows[i]);\n            Window window = toolWindows[i];\n            WindowDisplayAction windowAction = new WindowDisplayAction(window);\n            JCheckBoxMenuItem checkBox = new JCheckBoxMenuItem(windowAction);\n            windowAction.setLinkedButton(checkBox);\n            windowMenu.add(checkBox);\n        }\n\n        optionsMenu.add(new JMenuItem(\"Node Types...\"));\n        optionsMenu.add(new JMenuItem(\"Map Preference...\"));\n        optionsMenu.add(new JMenuItem(\"Preferences...\"));\n        \n        helpMenu.add(new JMenuItem(\"Help\"));\n        \n        JToolBar toolBar = new JToolBar();\n        toolBar.add(Actions.NewMap);\n        toolBar.add(openAction);\n        toolBar.add(Actions.CloseMap);\n        toolBar.add(saveAction);\n        toolBar.add(saveAsAction);\n        toolBar.add(printAction);\n        toolBar.add(imageAction);\n        toolBar.add(htmlAction);\n        toolBar.add(xmlAction);\n        toolBar.add(pdfAction);\n        toolBar.add(imageMap);\n        toolBar.add(svgAction);\n       // toolBar.add(new JButton(new ImageIcon(\"tufts/vue/images/ZoomOut16.gif\")));\n        toolBar.add(new JButton(new PolygonIcon(Color.RED)));\n        frame.setJMenuBar(menuBar);\n        //frame.getContentPane().add(toolBar,BorderLayout.NORTH);\n        frame.addWindowListener(new WindowAdapter() {\n            public void windowClosing(WindowEvent e) {ExitAction.exitVue();}});\n\n    }","commit_id":"59dc61050bb88a535651f271df954fcdabdab3d6","url":"https://github.com/VUE/VUE"},{"original_method":"protected byte[] readContent(AlluxioURI uri, int length) throws IOException, AlluxioException {\n    FileInStream tfis =\n        mFileSystem.openFile(uri, OpenFileOptions.defaults().setReadType(ReadType.NO_CACHE));\n    byte[] read = new byte[length];\n    tfis.read(read);\n    return read;\n  }","id":25152,"modified_method":"protected byte[] readContent(AlluxioURI uri, int length) throws IOException, AlluxioException {\n    try (FileInStream tfis = mFileSystem\n        .openFile(uri, OpenFileOptions.defaults().setReadType(ReadType.NO_CACHE))) {\n      byte[] read = new byte[length];\n      tfis.read(read);\n      return read;\n    }\n  }","commit_id":"671d3a93e3b809b5d3de06314b9414363bb2f153","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Checks whether the given file is actually persisted by freeing it, then\n   * reading it and comparing it against the expected byte array.\n   *\n   * @param uri The uri to persist\n   * @param size The size of the file\n   */\n  protected void checkFilePersisted(AlluxioURI uri, int size) throws Exception {\n    Assert.assertTrue(mFileSystem.getStatus(uri).isPersisted());\n    mFileSystem.free(uri);\n    FileInStream tfis = mFileSystem.openFile(uri);\n    byte[] actual = new byte[size];\n    tfis.read(actual);\n    Assert.assertArrayEquals(BufferUtils.getIncreasingByteArray(size), actual);\n  }","id":25153,"modified_method":"/**\n   * Checks whether the given file is actually persisted by freeing it, then\n   * reading it and comparing it against the expected byte array.\n   *\n   * @param uri The uri to persist\n   * @param size The size of the file\n   */\n  protected void checkFilePersisted(AlluxioURI uri, int size) throws Exception {\n    Assert.assertTrue(mFileSystem.getStatus(uri).isPersisted());\n    mFileSystem.free(uri);\n    try (FileInStream tfis = mFileSystem.openFile(uri)) {\n      byte[] actual = new byte[size];\n      tfis.read(actual);\n      Assert.assertArrayEquals(BufferUtils.getIncreasingByteArray(size), actual);\n    }\n  }","commit_id":"671d3a93e3b809b5d3de06314b9414363bb2f153","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void copyFromLocalDirToExistingFile() throws IOException, AlluxioException {\n    // Copy a directory from local to a file which exists in Alluxio filesystem. This case should\n    // fail.\n    File localDir = new File(mLocalAlluxioCluster.getAlluxioHome() + \"/localDir\");\n    File innerDir = new File(mLocalAlluxioCluster.getAlluxioHome() + \"/localDir/innerDir\");\n    localDir.mkdir();\n    innerDir.mkdir();\n    generateFileContent(\"/localDir/srcFile\", BufferUtils.getIncreasingByteArray(10));\n    mFileSystem.createFile(new AlluxioURI(\"/dstFile\"));\n    int ret = mFsShell.run(\"copyFromLocal\", localDir.getPath(), \"/dstFile\");\n    Assert.assertEquals(-1, ret);\n    Assert.assertFalse(mFileSystem.getStatus(new AlluxioURI(\"/dstFile\")).isFolder());\n    Assert.assertFalse(mFileSystem.exists(new AlluxioURI(\"/dstFile/innerDir\")));\n  }","id":25154,"modified_method":"@Test\n  public void copyFromLocalDirToExistingFile() throws IOException, AlluxioException {\n    // Copy a directory from local to a file which exists in Alluxio filesystem. This case should\n    // fail.\n    File localDir = new File(mLocalAlluxioCluster.getAlluxioHome() + \"/localDir\");\n    File innerDir = new File(mLocalAlluxioCluster.getAlluxioHome() + \"/localDir/innerDir\");\n    localDir.mkdir();\n    innerDir.mkdir();\n    generateFileContent(\"/localDir/srcFile\", BufferUtils.getIncreasingByteArray(10));\n    mFileSystem.createFile(new AlluxioURI(\"/dstFile\")).close();\n    int ret = mFsShell.run(\"copyFromLocal\", localDir.getPath(), \"/dstFile\");\n    Assert.assertEquals(-1, ret);\n    Assert.assertFalse(mFileSystem.getStatus(new AlluxioURI(\"/dstFile\")).isFolder());\n    Assert.assertFalse(mFileSystem.exists(new AlluxioURI(\"/dstFile/innerDir\")));\n  }","commit_id":"671d3a93e3b809b5d3de06314b9414363bb2f153","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void copyFromLocalLarge() throws IOException, AlluxioException {\n    File testFile = new File(mLocalAlluxioCluster.getAlluxioHome() + \"/testFile\");\n    testFile.createNewFile();\n    FileOutputStream fos = new FileOutputStream(testFile);\n    byte[] toWrite = BufferUtils.getIncreasingByteArray(SIZE_BYTES);\n    fos.write(toWrite);\n    fos.close();\n    mFsShell.run(\"copyFromLocal\", testFile.getAbsolutePath(), \"/testFile\");\n    Assert.assertEquals(\n        getCommandOutput(new String[] {\"copyFromLocal\", testFile.getAbsolutePath(), \"/testFile\"}),\n        mOutput.toString());\n    AlluxioURI uri = new AlluxioURI(\"/testFile\");\n    URIStatus status = mFileSystem.getStatus(uri);\n    Assert.assertNotNull(status);\n    Assert.assertEquals(SIZE_BYTES, status.getLength());\n\n    FileInStream tfis =\n        mFileSystem.openFile(uri, OpenFileOptions.defaults().setReadType(ReadType.NO_CACHE));\n    byte[] read = new byte[SIZE_BYTES];\n    tfis.read(read);\n    Assert.assertTrue(BufferUtils.equalIncreasingByteArray(SIZE_BYTES, read));\n  }","id":25155,"modified_method":"@Test\n  public void copyFromLocalLarge() throws IOException, AlluxioException {\n    File testFile = new File(mLocalAlluxioCluster.getAlluxioHome() + \"/testFile\");\n    testFile.createNewFile();\n    FileOutputStream fos = new FileOutputStream(testFile);\n    byte[] toWrite = BufferUtils.getIncreasingByteArray(SIZE_BYTES);\n    fos.write(toWrite);\n    fos.close();\n    mFsShell.run(\"copyFromLocal\", testFile.getAbsolutePath(), \"/testFile\");\n    Assert.assertEquals(\n        getCommandOutput(new String[] {\"copyFromLocal\", testFile.getAbsolutePath(), \"/testFile\"}),\n        mOutput.toString());\n    AlluxioURI uri = new AlluxioURI(\"/testFile\");\n    URIStatus status = mFileSystem.getStatus(uri);\n    Assert.assertNotNull(status);\n    Assert.assertEquals(SIZE_BYTES, status.getLength());\n\n    try (FileInStream tfis =\n        mFileSystem.openFile(uri, OpenFileOptions.defaults().setReadType(ReadType.NO_CACHE))) {\n      byte[] read = new byte[SIZE_BYTES];\n      tfis.read(read);\n      Assert.assertTrue(BufferUtils.equalIncreasingByteArray(SIZE_BYTES, read));\n    }\n  }","commit_id":"671d3a93e3b809b5d3de06314b9414363bb2f153","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n    public void run() {\n      try {\n        FileInStream stream = sFileSystem.openFile(mUri);\n        stream.read();\n        stream.close();\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }","id":25156,"modified_method":"@Override\n    public void run() {\n      try (FileInStream stream = sFileSystem.openFile(mUri)) {\n        stream.read();\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }","commit_id":"671d3a93e3b809b5d3de06314b9414363bb2f153","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void openFile() throws IOException, AlluxioException {\n    AlluxioURI fileUri = new AlluxioURI(FILE_PATH);\n    mFileSystem.loadMetadata(fileUri);\n    Assert.assertNotNull(mFileSystem.openFile(fileUri));\n\n    fileUri = new AlluxioURI(SUB_FILE_PATH);\n    mFileSystem.loadMetadata(fileUri, LoadMetadataOptions.defaults().setRecursive(true));\n    Assert.assertNotNull(mFileSystem.openFile(fileUri));\n  }","id":25157,"modified_method":"@Test\n  public void openFile() throws IOException, AlluxioException {\n    AlluxioURI fileUri = new AlluxioURI(FILE_PATH);\n    mFileSystem.loadMetadata(fileUri);\n    FileInStream inStream = mFileSystem.openFile(fileUri);\n    Assert.assertNotNull(inStream);\n    inStream.close();\n\n    fileUri = new AlluxioURI(SUB_FILE_PATH);\n    mFileSystem.loadMetadata(fileUri, LoadMetadataOptions.defaults().setRecursive(true));\n    inStream = mFileSystem.openFile(fileUri);\n    Assert.assertNotNull(inStream);\n    inStream.close();\n  }","commit_id":"671d3a93e3b809b5d3de06314b9414363bb2f153","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void cacheBlock() throws Exception {\n    mFileSystem.createFile(new AlluxioURI(\"/testFile\"));\n    URIStatus file = mFileSystem.getStatus(new AlluxioURI(\"/testFile\"));\n\n    final int blockSize = (int) WORKER_CAPACITY_BYTES / 10;\n    // Construct the block ids for the file.\n    final long blockId0 = BlockId.createBlockId(BlockId.getContainerId(file.getFileId()), 0);\n    final long blockId1 = BlockId.createBlockId(BlockId.getContainerId(file.getFileId()), 1);\n\n    String filename =\n        mBlockWorkerServiceHandler.requestBlockLocation(SESSION_ID, blockId0, blockSize);\n    createBlockFile(filename, blockSize);\n    mBlockWorkerServiceHandler.cacheBlock(SESSION_ID, blockId0);\n\n    // The master should be immediately updated with the persisted block\n    Assert.assertEquals(blockSize, mBlockMasterClient.getUsedBytes());\n\n    // Attempting to cache a non existent block should throw an exception\n    Exception exception = null;\n    try {\n      mBlockWorkerServiceHandler.cacheBlock(SESSION_ID, blockId1);\n    } catch (TException e) {\n      exception = e;\n    }\n    Assert.assertNotNull(exception);\n  }","id":25158,"modified_method":"@Test\n  public void cacheBlock() throws Exception {\n    mFileSystem.createFile(new AlluxioURI(\"/testFile\")).close();\n    URIStatus file = mFileSystem.getStatus(new AlluxioURI(\"/testFile\"));\n\n    final int blockSize = (int) WORKER_CAPACITY_BYTES / 10;\n    // Construct the block ids for the file.\n    final long blockId0 = BlockId.createBlockId(BlockId.getContainerId(file.getFileId()), 0);\n    final long blockId1 = BlockId.createBlockId(BlockId.getContainerId(file.getFileId()), 1);\n\n    String filename =\n        mBlockWorkerServiceHandler.requestBlockLocation(SESSION_ID, blockId0, blockSize);\n    createBlockFile(filename, blockSize);\n    mBlockWorkerServiceHandler.cacheBlock(SESSION_ID, blockId0);\n\n    // The master should be immediately updated with the persisted block\n    Assert.assertEquals(blockSize, mBlockMasterClient.getUsedBytes());\n\n    // Attempting to cache a non existent block should throw an exception\n    Exception exception = null;\n    try {\n      mBlockWorkerServiceHandler.cacheBlock(SESSION_ID, blockId1);\n    } catch (TException e) {\n      exception = e;\n    }\n    Assert.assertNotNull(exception);\n  }","commit_id":"6d3276da8e4449149c7a03aa4983496bf09c0b82","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void cancelBlock() throws Exception {\n    mFileSystem.createFile(new AlluxioURI(\"/testFile\"));\n    URIStatus file = mFileSystem.getStatus(new AlluxioURI(\"/testFile\"));\n\n    final int blockSize = (int) WORKER_CAPACITY_BYTES / 2;\n    final long blockId = BlockId.createBlockId(BlockId.getContainerId(file.getFileId()), 0);\n\n    String filename =\n        mBlockWorkerServiceHandler.requestBlockLocation(SESSION_ID, blockId, blockSize);\n    createBlockFile(filename, blockSize);\n    mBlockWorkerServiceHandler.cancelBlock(SESSION_ID, blockId);\n\n    // The block should not exist after being cancelled\n    Assert.assertFalse(new File(filename).exists());\n\n    // The master should not have recorded any used space after the block is cancelled\n    HeartbeatScheduler.execute(HeartbeatContext.WORKER_BLOCK_SYNC);\n    Assert.assertEquals(0, mBlockMasterClient.getUsedBytes());\n  }","id":25159,"modified_method":"@Test\n  public void cancelBlock() throws Exception {\n    mFileSystem.createFile(new AlluxioURI(\"/testFile\")).close();\n    URIStatus file = mFileSystem.getStatus(new AlluxioURI(\"/testFile\"));\n\n    final int blockSize = (int) WORKER_CAPACITY_BYTES / 2;\n    final long blockId = BlockId.createBlockId(BlockId.getContainerId(file.getFileId()), 0);\n\n    String filename =\n        mBlockWorkerServiceHandler.requestBlockLocation(SESSION_ID, blockId, blockSize);\n    createBlockFile(filename, blockSize);\n    mBlockWorkerServiceHandler.cancelBlock(SESSION_ID, blockId);\n\n    // The block should not exist after being cancelled\n    Assert.assertFalse(new File(filename).exists());\n\n    // The master should not have recorded any used space after the block is cancelled\n    HeartbeatScheduler.execute(HeartbeatContext.WORKER_BLOCK_SYNC);\n    Assert.assertEquals(0, mBlockMasterClient.getUsedBytes());\n  }","commit_id":"6d3276da8e4449149c7a03aa4983496bf09c0b82","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void lockBlockFailure() throws Exception {\n    mFileSystem.createFile(new AlluxioURI(\"/testFile\"));\n    URIStatus file = mFileSystem.getStatus(new AlluxioURI(\"/testFile\"));\n    final long blockId = BlockId.createBlockId(BlockId.getContainerId(file.getFileId()), 0);\n\n    Exception exception = null;\n    try {\n      mBlockWorkerServiceHandler.lockBlock(blockId, SESSION_ID);\n    } catch (AlluxioTException e) {\n      exception = e;\n    }\n\n    // A file does not exist exception should have been thrown\n    Assert.assertNotNull(exception);\n  }","id":25160,"modified_method":"@Test\n  public void lockBlockFailure() throws Exception {\n    mFileSystem.createFile(new AlluxioURI(\"/testFile\")).close();\n    URIStatus file = mFileSystem.getStatus(new AlluxioURI(\"/testFile\"));\n    final long blockId = BlockId.createBlockId(BlockId.getContainerId(file.getFileId()), 0);\n\n    Exception exception = null;\n    try {\n      mBlockWorkerServiceHandler.lockBlock(blockId, SESSION_ID);\n    } catch (AlluxioTException e) {\n      exception = e;\n    }\n\n    // A file does not exist exception should have been thrown\n    Assert.assertNotNull(exception);\n  }","commit_id":"6d3276da8e4449149c7a03aa4983496bf09c0b82","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a simple file with {@code len} bytes.\n   *\n   * @param fs a {@link FileSystem} handler\n   * @param fileURI URI of the file\n   * @param options client options to create the file with\n   * @param len file size\n   * @throws IOException if {@code path} is invalid (e.g., illegal URI)\n   */\n  public static void createByteFile(FileSystem fs, AlluxioURI fileURI,\n      CreateFileOptions options, int len) throws IOException {\n    try {\n      FileOutStream os = fs.createFile(fileURI, options);\n\n      byte[] arr = new byte[len];\n      for (int k = 0; k < len; k++) {\n        arr[k] = (byte) k;\n      }\n      os.write(arr);\n      os.close();\n    } catch (AlluxioException e) {\n      throw new IOException(e.getMessage());\n    }\n  }","id":25161,"modified_method":"/**\n   * Creates a simple file with {@code len} bytes.\n   *\n   * @param fs a {@link FileSystem} handler\n   * @param fileURI URI of the file\n   * @param options client options to create the file with\n   * @param len file size\n   * @throws IOException if {@code path} is invalid (e.g., illegal URI)\n   */\n  public static void createByteFile(FileSystem fs, AlluxioURI fileURI,\n      CreateFileOptions options, int len) throws IOException {\n    try (FileOutStream os = fs.createFile(fileURI, options)) {\n      byte[] arr = new byte[len];\n      for (int k = 0; k < len; k++) {\n        arr[k] = (byte) k;\n      }\n      os.write(arr);\n    } catch (AlluxioException e) {\n      throw new IOException(e.getMessage());\n    }\n  }","commit_id":"6d3276da8e4449149c7a03aa4983496bf09c0b82","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a {@link RetryHandlingBlockWorkerClient}. Set sessionId to null if no session Id is\n   * required when using this client. For example, if you only call RPCs like promote, a session\n   * Id is not required.\n   *\n   * @param workerNetAddress to worker's location\n   * @param sessionId the id of the session\n   * @throws IOException if it fails to register the session with the worker specified\n   */\n  public RetryHandlingBlockWorkerClient(WorkerNetAddress workerNetAddress, final Long sessionId)\n      throws IOException {\n    mRpcAddress = NetworkAddressUtils.getRpcPortSocketAddress(workerNetAddress);\n\n    mWorkerNetAddress = Preconditions.checkNotNull(workerNetAddress);\n    mWorkerDataServerAddress = NetworkAddressUtils.getDataPortSocketAddress(workerNetAddress);\n    mSessionId = sessionId;\n    if (sessionId != null) {\n      NUM_ACTIVE_SESSIONS.incrementAndGet();\n      // The heartbeat is scheduled to run in a fixed rate. The heartbeat won't consume a thread\n      // from the pool while it is not running.\n      mHeartbeat = HEARTBEAT_POOL.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                sessionHeartbeat();\n              } catch (InterruptedException e) {\n                // Do nothing.\n              } catch (Exception e) {\n                LOG.error(\"Failed to heartbeat for session \" + sessionId, e);\n              }\n            }\n          }, Configuration.getInt(PropertyKey.USER_HEARTBEAT_INTERVAL_MS),\n          Configuration.getInt(PropertyKey.USER_HEARTBEAT_INTERVAL_MS), TimeUnit.MILLISECONDS);\n\n      try {\n        sessionHeartbeat();\n      } catch (InterruptedException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }","id":25162,"modified_method":"/**\n   * Creates a {@link RetryHandlingBlockWorkerClient}. Set sessionId to null if no session Id is\n   * required when using this client. For example, if you only call RPCs like promote, a session\n   * Id is not required.\n   *\n   * @param workerNetAddress to worker's location\n   * @param sessionId the id of the session\n   * @throws IOException if it fails to register the session with the worker specified\n   */\n  public RetryHandlingBlockWorkerClient(WorkerNetAddress workerNetAddress, final Long sessionId)\n      throws IOException {\n    mRpcAddress = NetworkAddressUtils.getRpcPortSocketAddress(workerNetAddress);\n\n    mWorkerNetAddress = Preconditions.checkNotNull(workerNetAddress);\n    mWorkerDataServerAddress = NetworkAddressUtils.getDataPortSocketAddress(workerNetAddress);\n    mSessionId = sessionId;\n    if (sessionId != null) {\n      // The heartbeat is scheduled to run in a fixed rate. The heartbeat won't consume a thread\n      // from the pool while it is not running.\n      mHeartbeat = HEARTBEAT_POOL.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                sessionHeartbeat();\n              } catch (InterruptedException e) {\n                // Do nothing.\n              } catch (Exception e) {\n                LOG.error(\"Failed to heartbeat for session \" + sessionId, e);\n              }\n            }\n          }, Configuration.getInt(PropertyKey.USER_HEARTBEAT_INTERVAL_MS),\n          Configuration.getInt(PropertyKey.USER_HEARTBEAT_INTERVAL_MS), TimeUnit.MILLISECONDS);\n\n      NUM_ACTIVE_SESSIONS.incrementAndGet();\n      try {\n        sessionHeartbeat();\n      } catch (InterruptedException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }","commit_id":"6d3276da8e4449149c7a03aa4983496bf09c0b82","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * When a user starts a cluster with journal logs, which are generated by previous running\n   * cluster owned by a different user, it should fail and throw an exception.\n   */\n  @Test\n  @LocalAlluxioClusterResource.Config(\n      confParams = {PropertyKey.Name.SECURITY_LOGIN_USERNAME, SUPER_USER})\n  public void recoverClusterFail() throws Exception {\n    mThrown.expect(RuntimeException.class);\n    mThrown.expectMessage(ExceptionMessage.PERMISSION_DENIED\n        .getMessage(\"Unauthorized user on root\"));\n\n    FileSystem fs = mLocalAlluxioClusterResource.get().getClient();\n    fs.createFile(new AlluxioURI(\"/testFile\"));\n    mLocalAlluxioClusterResource.get().stopFS();\n\n    LoginUserTestUtils.resetLoginUser(USER);\n\n    // user jack cannot recover master from journal, in which the root is owned by alluxio.\n    MasterTestUtils.createLeaderFileSystemMasterFromJournal();\n  }","id":25163,"modified_method":"/**\n   * When a user starts a cluster with journal logs, which are generated by previous running\n   * cluster owned by a different user, it should fail and throw an exception.\n   */\n  @Test\n  @LocalAlluxioClusterResource.Config(\n      confParams = {PropertyKey.Name.SECURITY_LOGIN_USERNAME, SUPER_USER})\n  public void recoverClusterFail() throws Exception {\n    mThrown.expect(RuntimeException.class);\n    mThrown.expectMessage(ExceptionMessage.PERMISSION_DENIED\n        .getMessage(\"Unauthorized user on root\"));\n\n    FileSystem fs = mLocalAlluxioClusterResource.get().getClient();\n    fs.createFile(new AlluxioURI(\"/testFile\")).close();\n    mLocalAlluxioClusterResource.get().stopFS();\n\n    LoginUserTestUtils.resetLoginUser(USER);\n\n    // user jack cannot recover master from journal, in which the root is owned by alluxio.\n    MasterTestUtils.createLeaderFileSystemMasterFromJournal();\n  }","commit_id":"5ebb7a1cee57c9dca756a86dccef3d7c3299d765","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * When a user starts a cluster with journal logs, which are generated by previous running\n   * cluster owned by the same user, it should succeed.\n   */\n  @Test\n  @LocalAlluxioClusterResource.Config(\n      confParams = {PropertyKey.Name.SECURITY_LOGIN_USERNAME, SUPER_USER})\n  public void recoverClusterSuccess() throws Exception {\n    FileSystem fs = mLocalAlluxioClusterResource.get().getClient();\n    fs.createFile(new AlluxioURI(\"/testFile\"));\n    mLocalAlluxioClusterResource.get().stopFS();\n\n    LoginUserTestUtils.resetLoginUser(SUPER_USER);\n\n    // user alluxio can recover master from journal\n    FileSystemMaster fileSystemMaster = MasterTestUtils.createLeaderFileSystemMasterFromJournal();\n\n    AuthenticatedClientUser.set(SUPER_USER);\n    Assert.assertEquals(SUPER_USER,\n        fileSystemMaster.getFileInfo(new AlluxioURI(\"/testFile\")).getOwner());\n  }","id":25164,"modified_method":"/**\n   * When a user starts a cluster with journal logs, which are generated by previous running\n   * cluster owned by the same user, it should succeed.\n   */\n  @Test\n  @LocalAlluxioClusterResource.Config(\n      confParams = {PropertyKey.Name.SECURITY_LOGIN_USERNAME, SUPER_USER})\n  public void recoverClusterSuccess() throws Exception {\n    FileSystem fs = mLocalAlluxioClusterResource.get().getClient();\n    fs.createFile(new AlluxioURI(\"/testFile\")).close();\n    mLocalAlluxioClusterResource.get().stopFS();\n\n    LoginUserTestUtils.resetLoginUser(SUPER_USER);\n\n    // user alluxio can recover master from journal\n    FileSystemMaster fileSystemMaster = MasterTestUtils.createLeaderFileSystemMasterFromJournal();\n\n    AuthenticatedClientUser.set(SUPER_USER);\n    Assert.assertEquals(SUPER_USER,\n        fileSystemMaster.getFileInfo(new AlluxioURI(\"/testFile\")).getOwner());\n  }","commit_id":"5ebb7a1cee57c9dca756a86dccef3d7c3299d765","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void createFileWithFileAlreadyExistsException() throws Exception {\n    AlluxioURI uri = new AlluxioURI(PathUtils.uniqPath());\n    mFileSystem.createFile(uri, mWriteBoth).close();\n    Assert.assertNotNull(mFileSystem.getStatus(uri));\n    try {\n      mFileSystem.createFile(uri, mWriteBoth);\n    } catch (AlluxioException e) {\n      Assert.assertTrue(e instanceof FileAlreadyExistsException);\n    }\n  }","id":25165,"modified_method":"@Test\n  public void createFileWithFileAlreadyExistsException() throws Exception {\n    AlluxioURI uri = new AlluxioURI(PathUtils.uniqPath());\n    mFileSystem.createFile(uri, mWriteBoth).close();\n    Assert.assertNotNull(mFileSystem.getStatus(uri));\n    try {\n      mFileSystem.createFile(uri, mWriteBoth).close();\n    } catch (AlluxioException e) {\n      Assert.assertTrue(e instanceof FileAlreadyExistsException);\n    }\n  }","commit_id":"5ebb7a1cee57c9dca756a86dccef3d7c3299d765","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void createFileWithInvalidPathException() throws Exception {\n    mThrown.expect(InvalidPathException.class);\n    mThrown.expectMessage(ExceptionMessage.PATH_INVALID.getMessage(\"root/testFile1\"));\n    mFileSystem.createFile(new AlluxioURI(\"root/testFile1\"), mWriteBoth);\n  }","id":25166,"modified_method":"@Test\n  public void createFileWithInvalidPathException() throws Exception {\n    mThrown.expect(InvalidPathException.class);\n    mThrown.expectMessage(ExceptionMessage.PATH_INVALID.getMessage(\"root/testFile1\"));\n    mFileSystem.createFile(new AlluxioURI(\"root/testFile1\"), mWriteBoth).close();\n  }","commit_id":"5ebb7a1cee57c9dca756a86dccef3d7c3299d765","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Tests reading multiple edit logs.\n   */\n  @Test\n  public void multiEditLog() throws Exception {\n    for (int i = 0; i < 124; i++) {\n      CreateFileOptions op = CreateFileOptions.defaults().setBlockSizeBytes((i + 10) / 10 * 64);\n      mFileSystem.createFile(new AlluxioURI(\"/a\" + i), op);\n    }\n    mLocalAlluxioCluster.stopFS();\n    multiEditLogTestUtil();\n    deleteFsMasterJournalLogs();\n    multiEditLogTestUtil();\n  }","id":25167,"modified_method":"/**\n   * Tests reading multiple edit logs.\n   */\n  @Test\n  public void multiEditLog() throws Exception {\n    for (int i = 0; i < 124; i++) {\n      CreateFileOptions op = CreateFileOptions.defaults().setBlockSizeBytes((i + 10) / 10 * 64);\n      mFileSystem.createFile(new AlluxioURI(\"/a\" + i), op).close();\n    }\n    mLocalAlluxioCluster.stopFS();\n    multiEditLogTestUtil();\n    deleteFsMasterJournalLogs();\n    multiEditLogTestUtil();\n  }","commit_id":"5ebb7a1cee57c9dca756a86dccef3d7c3299d765","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Tests load metadata on list.\n   */\n  @Test\n  public void loadMetadata() throws Exception {\n    String dirName = \"loadMetaDataRoot\";\n\n    String rootDir = PathUtils.concatPath(mUnderfsAddress, dirName);\n    mUfs.mkdirs(rootDir, true);\n\n    String rootFile1 = PathUtils.concatPath(rootDir, \"file1\");\n    createEmptyFile(rootFile1);\n\n    String rootFile2 = PathUtils.concatPath(rootDir, \"file2\");\n    createEmptyFile(rootFile2);\n\n    AlluxioURI rootAlluxioURI = new AlluxioURI(\"/\" + dirName);\n    FileSystem client = mLocalAlluxioClusterResource.get().getClient();\n    client.listStatus(rootAlluxioURI,\n        ListStatusOptions.defaults().setLoadMetadataType(LoadMetadataType.Always));\n\n    try {\n      client.createDirectory(rootAlluxioURI, CreateDirectoryOptions.defaults());\n      Assert.fail(\"create is expected to fail with FileAlreadyExistsException\");\n    } catch (FileAlreadyExistsException e) {\n      Assert.assertEquals(\n          ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(rootAlluxioURI), e.getMessage());\n    }\n\n    AlluxioURI file1URI = rootAlluxioURI.join(\"file1\");\n    try {\n      client.createFile(file1URI, CreateFileOptions.defaults());\n      Assert.fail(\"create is expected to fail with FileAlreadyExistsException\");\n    } catch (FileAlreadyExistsException e) {\n      Assert.assertEquals(\n          ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(file1URI), e.getMessage());\n    }\n\n    AlluxioURI file2URI = rootAlluxioURI.join(\"file2\");\n    try {\n      client.createFile(file2URI, CreateFileOptions.defaults());\n      Assert.fail(\"create is expected to fail with FileAlreadyExistsException\");\n    } catch (FileAlreadyExistsException e) {\n      Assert.assertEquals(\n          ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(file2URI), e.getMessage());\n    }\n  }","id":25168,"modified_method":"/**\n   * Tests load metadata on list.\n   */\n  @Test\n  public void loadMetadata() throws Exception {\n    String dirName = \"loadMetaDataRoot\";\n\n    String rootDir = PathUtils.concatPath(mUnderfsAddress, dirName);\n    mUfs.mkdirs(rootDir, true);\n\n    String rootFile1 = PathUtils.concatPath(rootDir, \"file1\");\n    createEmptyFile(rootFile1);\n\n    String rootFile2 = PathUtils.concatPath(rootDir, \"file2\");\n    createEmptyFile(rootFile2);\n\n    AlluxioURI rootAlluxioURI = new AlluxioURI(\"/\" + dirName);\n    FileSystem client = mLocalAlluxioClusterResource.get().getClient();\n    client.listStatus(rootAlluxioURI,\n        ListStatusOptions.defaults().setLoadMetadataType(LoadMetadataType.Always));\n\n    try {\n      client.createDirectory(rootAlluxioURI, CreateDirectoryOptions.defaults());\n      Assert.fail(\"create is expected to fail with FileAlreadyExistsException\");\n    } catch (FileAlreadyExistsException e) {\n      Assert.assertEquals(\n          ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(rootAlluxioURI), e.getMessage());\n    }\n\n    AlluxioURI file1URI = rootAlluxioURI.join(\"file1\");\n    try {\n      client.createFile(file1URI, CreateFileOptions.defaults()).close();\n      Assert.fail(\"create is expected to fail with FileAlreadyExistsException\");\n    } catch (FileAlreadyExistsException e) {\n      Assert.assertEquals(\n          ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(file1URI), e.getMessage());\n    }\n\n    AlluxioURI file2URI = rootAlluxioURI.join(\"file2\");\n    try {\n      client.createFile(file2URI, CreateFileOptions.defaults()).close();\n      Assert.fail(\"create is expected to fail with FileAlreadyExistsException\");\n    } catch (FileAlreadyExistsException e) {\n      Assert.assertEquals(\n          ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(file2URI), e.getMessage());\n    }\n  }","commit_id":"5ebb7a1cee57c9dca756a86dccef3d7c3299d765","url":"https://github.com/amplab/tachyon"},{"original_method":"protected void doGet( HttpServletRequest request, HttpServletResponse response ) throws ServletException,\n        IOException\n    {\n        final RequestInfo reqInfo = new RequestInfo(request);\n        if ( reqInfo.bundle == null && reqInfo.bundleRequested ) {\n            response.sendError(404);\n            return;\n        }\n        if ( reqInfo.extension.equals(\"json\")  )\n        {\n            this.renderJSON(response, reqInfo.bundle);\n\n            // nothing more to do\n            return;\n        }\n\n        super.doGet( request, response );\n    }","id":25169,"modified_method":"protected void doGet( HttpServletRequest request, HttpServletResponse response ) throws ServletException,\n        IOException\n    {\n        final RequestInfo reqInfo = new RequestInfo(request);\n        if ( \"upload\".equals(reqInfo.pathInfo) )\n        {\n            super.doGet(request, response);\n            return;\n        }\n        if ( reqInfo.bundle == null && reqInfo.bundleRequested )\n        {\n            response.sendError(404);\n            return;\n        }\n        if ( reqInfo.extension.equals(\"json\")  )\n        {\n            this.renderJSON(response, reqInfo.bundle);\n\n            // nothing more to do\n            return;\n        }\n\n        super.doGet( request, response );\n    }","commit_id":"19f2de5b8efc49d3ce766eec0d13c9a793129d6d","url":"https://github.com/apache/felix"},{"original_method":"protected RequestInfo( final HttpServletRequest request )\n        {\n            String info = request.getPathInfo();\n            // remove label and starting slash\n            info = info.substring(getLabel().length() + 1);\n\n            // get extension\n            if ( info.endsWith(\".json\") )\n            {\n                extension = \"json\";\n                info = info.substring(0, info.length() - 5);\n            }\n            else\n            {\n                extension = \"html\";\n            }\n\n            // we only accept direct requests to a bundle if they have a slash after the label\n            String bundleInfo = null;\n            if (info.startsWith(\"/\") )\n            {\n                bundleInfo = info.substring(1);\n            }\n            if ( bundleInfo == null )\n            {\n                bundle = null;\n                bundleRequested = false;\n            }\n            else\n            {\n                bundle = getBundle(bundleInfo);\n                bundleRequested = true;\n            }\n            request.setAttribute(BundlesServlet.class.getName(), this);\n        }","id":25170,"modified_method":"protected RequestInfo( final HttpServletRequest request )\n        {\n            String info = request.getPathInfo();\n            // remove label and starting slash\n            info = info.substring(getLabel().length() + 1);\n\n            // get extension\n            if ( info.endsWith(\".json\") )\n            {\n                extension = \"json\";\n                info = info.substring(0, info.length() - 5);\n            }\n            else\n            {\n                extension = \"html\";\n            }\n\n            // we only accept direct requests to a bundle if they have a slash after the label\n            String bundleInfo = null;\n            if (info.startsWith(\"/\") )\n            {\n                bundleInfo = info.substring(1);\n            }\n            if ( bundleInfo == null )\n            {\n                bundle = null;\n                bundleRequested = false;\n                pathInfo = null;\n            }\n            else\n            {\n                bundle = getBundle(bundleInfo);\n                bundleRequested = true;\n                pathInfo = bundleInfo;\n            }\n            request.setAttribute(BundlesServlet.class.getName(), this);\n        }","commit_id":"19f2de5b8efc49d3ce766eec0d13c9a793129d6d","url":"https://github.com/apache/felix"},{"original_method":"protected void renderContent( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n        // get request info from request attribute\n        final RequestInfo reqInfo = getRequestInfo(request);\n        final PrintWriter pw = response.getWriter();\n\n        final String appRoot = ( String ) request.getAttribute( OsgiManager.ATTR_APP_ROOT );\n        Util.script(pw, appRoot, \"bundles.js\");\n\n        Util.startScript( pw );\n        pw.println( \"var imgRoot = '\" + appRoot + \"/res/imgs';\");\n        pw.println( \"var startLevel = \" + getStartLevel().getInitialBundleStartLevel() + \";\");\n        pw.println( \"var drawDetails = \" + reqInfo.bundleRequested + \";\");\n        Util.endScript( pw );\n\n        Util.script(pw, appRoot, \"bundles.js\");\n\n        pw.println( \"<div id='plugin_content'/>\");\n        Util.startScript( pw );\n        pw.print( \"renderBundles(\");\n        writeJSON(pw, reqInfo.bundle);\n        pw.println(\");\" );\n        Util.endScript( pw );\n    }","id":25171,"modified_method":"protected void renderContent( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n        // get request info from request attribute\n        final RequestInfo reqInfo = getRequestInfo(request);\n        final PrintWriter pw = response.getWriter();\n\n        final String appRoot = ( String ) request.getAttribute( OsgiManager.ATTR_APP_ROOT );\n        Util.script(pw, appRoot, \"bundles.js\");\n\n        Util.startScript( pw );\n        pw.println( \"var imgRoot = '\" + appRoot + \"/res/imgs';\");\n        pw.println( \"var startLevel = \" + getStartLevel().getInitialBundleStartLevel() + \";\");\n        pw.println( \"var drawDetails = \" + reqInfo.bundleRequested + \";\");\n        Util.endScript( pw );\n\n        Util.script(pw, appRoot, \"bundles.js\");\n\n        if ( \"upload\".equals(reqInfo.pathInfo) )\n        {\n            renderUploadForm(pw);\n        }\n        else\n        {\n            pw.println( \"<div id='plugin_content'/>\");\n            Util.startScript( pw );\n            pw.print( \"renderBundles(\");\n            writeJSON(pw, reqInfo.bundle);\n            pw.println(\");\" );\n            Util.endScript( pw );\n        }\n    }","commit_id":"19f2de5b8efc49d3ce766eec0d13c9a793129d6d","url":"https://github.com/apache/felix"},{"original_method":"private String getStatusLine(final Bundle[] bundles)\n    {\n        int active = 0, installed = 0, resolved = 0, fragments = 0;\n        for ( int i = 0; i < bundles.length; i++ )\n        {\n            switch ( bundles[i].getState() )\n            {\n                case Bundle.ACTIVE:\n                    active++;\n                    break;\n                case Bundle.INSTALLED:\n                    installed++;\n                    break;\n                case Bundle.RESOLVED:\n                    if ( isFragmentBundle( bundles[i] ) )\n                    {\n                        fragments++;\n                    }\n                    else\n                    {\n                        resolved++;\n                    }\n                    break;\n            }\n        }\n        final StringBuffer buffer = new StringBuffer();\n        buffer.append(\"Bundle information: \");\n        appendBundleInfoCount(buffer, \"in total\", bundles.length);\n        if ( active == bundles.length || active + fragments == bundles.length )\n        {\n            buffer.append(\" - all \");\n            appendBundleInfoCount(buffer, \"active.\", bundles.length);\n        }\n        else\n        {\n            if ( active != 0 )\n            {\n                buffer.append(\", \");\n                appendBundleInfoCount(buffer, \"active\", active);\n            }\n            if ( fragments != 0 )\n            {\n                buffer.append(\", \");\n                appendBundleInfoCount(buffer, \"active fragments\", fragments);\n            }\n            if ( resolved != 0 )\n            {\n                buffer.append(\", \");\n                appendBundleInfoCount(buffer, \"resolved\", resolved);\n            }\n            if ( installed != 0 )\n            {\n                buffer.append(\", \");\n                appendBundleInfoCount(buffer, \"installed\", installed);\n            }\n            buffer.append('.');\n        }\n        return buffer.toString();\n    }","id":25172,"modified_method":"private Object[] getStatusLine(final Bundle[] bundles)\n    {\n        Object[] ret = new Object[6];\n        int active = 0, installed = 0, resolved = 0, fragments = 0;\n        for ( int i = 0; i < bundles.length; i++ )\n        {\n            switch ( bundles[i].getState() )\n            {\n                case Bundle.ACTIVE:\n                    active++;\n                    break;\n                case Bundle.INSTALLED:\n                    installed++;\n                    break;\n                case Bundle.RESOLVED:\n                    if ( isFragmentBundle( bundles[i] ) )\n                    {\n                        fragments++;\n                    }\n                    else\n                    {\n                        resolved++;\n                    }\n                    break;\n            }\n        }\n        final StringBuffer buffer = new StringBuffer();\n        buffer.append(\"Bundle information: \");\n        appendBundleInfoCount(buffer, \"in total\", bundles.length);\n        if ( active == bundles.length || active + fragments == bundles.length )\n        {\n            buffer.append(\" - all \");\n            appendBundleInfoCount(buffer, \"active.\", bundles.length);\n        }\n        else\n        {\n            if ( active != 0 )\n            {\n                buffer.append(\", \");\n                appendBundleInfoCount(buffer, \"active\", active);\n            }\n            if ( fragments != 0 )\n            {\n                buffer.append(\", \");\n                appendBundleInfoCount(buffer, \"active fragments\", fragments);\n            }\n            if ( resolved != 0 )\n            {\n                buffer.append(\", \");\n                appendBundleInfoCount(buffer, \"resolved\", resolved);\n            }\n            if ( installed != 0 )\n            {\n                buffer.append(\", \");\n                appendBundleInfoCount(buffer, \"installed\", installed);\n            }\n            buffer.append('.');\n        }\n        ret[0] = new Integer(bundles.length);\n        ret[1] = new Integer(active);\n        ret[2] = new Integer(fragments);\n        ret[3] = new Integer(resolved);\n        ret[4] = new Integer(installed);\n        ret[5] = buffer.toString();\n        return ret;\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"private boolean hasStart( Bundle bundle )\n    {\n        if ( isFragmentBundle(bundle) )\n        {\n            return false;\n        }\n        return bundle.getState() == Bundle.INSTALLED || bundle.getState() == Bundle.RESOLVED;\n    }","id":25173,"modified_method":"private final boolean hasStart( Bundle bundle )\n    {\n        if ( isFragmentBundle(bundle) )\n        {\n            return false;\n        }\n        return bundle.getState() == Bundle.INSTALLED || bundle.getState() == Bundle.RESOLVED;\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"protected void doGet( HttpServletRequest request, HttpServletResponse response ) throws ServletException,\n        IOException\n    {\n        final RequestInfo reqInfo = new RequestInfo(request);\n        if ( \"upload\".equals(reqInfo.pathInfo) )\n        {\n            super.doGet(request, response);\n            return;\n        }\n        if ( reqInfo.bundle == null && reqInfo.bundleRequested )\n        {\n            response.sendError(404);\n            return;\n        }\n        if ( reqInfo.extension.equals(\"json\")  )\n        {\n            final String pluginRoot = ( String ) request.getAttribute( WebConsoleConstants.ATTR_PLUGIN_ROOT );\n            final String servicesRoot = getServicesRoot( request );\n            this.renderJSON(response, reqInfo.bundle, pluginRoot, servicesRoot);\n\n            // nothing more to do\n            return;\n        }\n\n        super.doGet( request, response );\n    }","id":25174,"modified_method":"/**\n     * @see org.apache.felix.webconsole.AbstractWebConsolePlugin#doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    protected void doGet( HttpServletRequest request, HttpServletResponse response ) throws ServletException,\n        IOException\n    {\n        final RequestInfo reqInfo = new RequestInfo(request);\n        if ( \"upload\".equals(reqInfo.pathInfo) )\n        {\n            super.doGet(request, response);\n            return;\n        }\n        if ( reqInfo.bundle == null && reqInfo.bundleRequested )\n        {\n            response.sendError(404);\n            return;\n        }\n        if ( reqInfo.extension.equals(\"json\")  )\n        {\n            final String pluginRoot = ( String ) request.getAttribute( WebConsoleConstants.ATTR_PLUGIN_ROOT );\n            final String servicesRoot = getServicesRoot( request );\n            this.renderJSON(response, reqInfo.bundle, pluginRoot, servicesRoot);\n\n            // nothing more to do\n            return;\n        }\n\n        super.doGet( request, response );\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"private boolean hasUninstall( Bundle bundle )\n    {\n        return bundle.getState() == Bundle.INSTALLED || bundle.getState() == Bundle.RESOLVED\n            || bundle.getState() == Bundle.ACTIVE;\n\n    }","id":25175,"modified_method":"private static final boolean hasUninstall( Bundle bundle )\n    {\n        return bundle.getState() == Bundle.INSTALLED || bundle.getState() == Bundle.RESOLVED\n            || bundle.getState() == Bundle.ACTIVE;\n\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"public void deactivate()\n    {\n        if ( configurationPrinter != null )\n        {\n            configurationPrinter.unregister();\n            configurationPrinter = null;\n        }\n\n        super.deactivate();\n    }","id":25176,"modified_method":"/**\n     * @see org.apache.felix.webconsole.SimpleWebConsolePlugin#deactivate()\n     */\n    public void deactivate()\n    {\n        if ( configurationPrinter != null )\n        {\n            configurationPrinter.unregister();\n            configurationPrinter = null;\n        }\n\n        super.deactivate();\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"private void bundleDetails( JSONWriter jw, Bundle bundle, final String pluginRoot, final String servicesRoot)\n        throws JSONException\n    {\n        Dictionary headers = bundle.getHeaders();\n\n        jw.key( \"props\" );\n        jw.array();\n        WebConsoleUtil.keyVal( jw, \"Symbolic Name\", bundle.getSymbolicName() );\n        WebConsoleUtil.keyVal( jw, \"Version\", headers.get( Constants.BUNDLE_VERSION ) );\n        WebConsoleUtil.keyVal( jw, \"Bundle Location\", bundle.getLocation() );\n        WebConsoleUtil.keyVal( jw, \"Last Modification\", new Date( bundle.getLastModified() ) );\n\n        String docUrl = ( String ) headers.get( Constants.BUNDLE_DOCURL );\n        if ( docUrl != null )\n        {\n            WebConsoleUtil.keyVal( jw, \"Bundle Documentation\", docUrl );\n        }\n\n        WebConsoleUtil.keyVal( jw, \"Vendor\", headers.get( Constants.BUNDLE_VENDOR ) );\n        WebConsoleUtil.keyVal( jw, \"Copyright\", headers.get( Constants.BUNDLE_COPYRIGHT ) );\n        WebConsoleUtil.keyVal( jw, \"Description\", headers.get( Constants.BUNDLE_DESCRIPTION ) );\n\n        WebConsoleUtil.keyVal( jw, \"Start Level\", getStartLevel( bundle ) );\n\n        WebConsoleUtil.keyVal( jw, \"Bundle Classpath\", headers.get( Constants.BUNDLE_CLASSPATH ) );\n\n        listFragmentInfo( jw, bundle, pluginRoot );\n\n        if ( bundle.getState() == Bundle.INSTALLED )\n        {\n            listImportExportsUnresolved( jw, bundle, pluginRoot );\n        }\n        else\n        {\n            listImportExport( jw, bundle, pluginRoot );\n        }\n\n        listServices( jw, bundle, servicesRoot );\n\n        listHeaders( jw, bundle );\n\n        jw.endArray();\n    }","id":25177,"modified_method":"private final void bundleDetails( JSONWriter jw, Bundle bundle, final String pluginRoot, final String servicesRoot)\n        throws JSONException\n    {\n        Dictionary headers = bundle.getHeaders();\n\n        jw.key( \"props\" );\n        jw.array();\n        WebConsoleUtil.keyVal( jw, \"Symbolic Name\", bundle.getSymbolicName() );\n        WebConsoleUtil.keyVal( jw, \"Version\", headers.get( Constants.BUNDLE_VERSION ) );\n        WebConsoleUtil.keyVal( jw, \"Bundle Location\", bundle.getLocation() );\n        WebConsoleUtil.keyVal( jw, \"Last Modification\", new Date( bundle.getLastModified() ) );\n\n        String docUrl = ( String ) headers.get( Constants.BUNDLE_DOCURL );\n        if ( docUrl != null )\n        {\n            WebConsoleUtil.keyVal( jw, \"Bundle Documentation\", docUrl );\n        }\n\n        WebConsoleUtil.keyVal( jw, \"Vendor\", headers.get( Constants.BUNDLE_VENDOR ) );\n        WebConsoleUtil.keyVal( jw, \"Copyright\", headers.get( Constants.BUNDLE_COPYRIGHT ) );\n        WebConsoleUtil.keyVal( jw, \"Description\", headers.get( Constants.BUNDLE_DESCRIPTION ) );\n\n        WebConsoleUtil.keyVal( jw, \"Start Level\", getStartLevel( bundle ) );\n\n        WebConsoleUtil.keyVal( jw, \"Bundle Classpath\", headers.get( Constants.BUNDLE_CLASSPATH ) );\n\n        listFragmentInfo( jw, bundle, pluginRoot );\n\n        if ( bundle.getState() == Bundle.INSTALLED )\n        {\n            listImportExportsUnresolved( jw, bundle, pluginRoot );\n        }\n        else\n        {\n            listImportExport( jw, bundle, pluginRoot );\n        }\n\n        listServices( jw, bundle, servicesRoot );\n\n        listHeaders( jw, bundle );\n\n        jw.endArray();\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"public static RequestInfo getRequestInfo(final HttpServletRequest request)\n    {\n        return (RequestInfo)request.getAttribute(BundlesServlet.class.getName());\n    }","id":25178,"modified_method":"static final RequestInfo getRequestInfo(final HttpServletRequest request)\n    {\n        return (RequestInfo)request.getAttribute( BundlesServlet.class.getName() );\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"private boolean hasStop( Bundle bundle )\n    {\n        if ( isFragmentBundle(bundle) )\n        {\n            return false;\n        }\n        return bundle.getState() == Bundle.ACTIVE;\n    }","id":25179,"modified_method":"private final boolean hasStop( Bundle bundle )\n    {\n        if ( isFragmentBundle(bundle) )\n        {\n            return false;\n        }\n        return bundle.getState() == Bundle.ACTIVE;\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"private Bundle getBundle( String pathInfo )\n    {\n        // only use last part of the pathInfo\n        pathInfo = pathInfo.substring( pathInfo.lastIndexOf( '/' ) + 1 );\n\n        // assume bundle Id\n        try\n        {\n            final long bundleId = Long.parseLong( pathInfo );\n            if ( bundleId >= 0 )\n            {\n                return getBundleContext().getBundle( bundleId );\n            }\n        }\n        catch ( NumberFormatException nfe )\n        {\n            // check if this follows the pattern {symbolic-name}[:{version}]\n            final int pos = pathInfo.indexOf(':');\n            final String symbolicName;\n            final String version;\n            if ( pos == -1 ) {\n                symbolicName = pathInfo;\n                version = null;\n            } else {\n                symbolicName = pathInfo.substring(0, pos);\n                version = pathInfo.substring(pos+1);\n            }\n\n            // search\n            final Bundle[] bundles = getBundleContext().getBundles();\n            for(int i=0; i<bundles.length; i++)\n            {\n                final Bundle bundle = bundles[i];\n                // check symbolic name first\n                if ( symbolicName.equals(bundle.getSymbolicName()) )\n                {\n                    if ( version == null || version.equals(bundle.getHeaders().get(Constants.BUNDLE_VERSION)) )\n                    {\n                        return bundle;\n                    }\n                }\n            }\n        }\n\n\n        return null;\n    }","id":25180,"modified_method":"Bundle getBundle( String pathInfo )\n    {\n        // only use last part of the pathInfo\n        pathInfo = pathInfo.substring( pathInfo.lastIndexOf( '/' ) + 1 );\n\n        // assume bundle Id\n        try\n        {\n            final long bundleId = Long.parseLong( pathInfo );\n            if ( bundleId >= 0 )\n            {\n                return getBundleContext().getBundle( bundleId );\n            }\n        }\n        catch ( NumberFormatException nfe )\n        {\n            // check if this follows the pattern {symbolic-name}[:{version}]\n            final int pos = pathInfo.indexOf(':');\n            final String symbolicName;\n            final String version;\n            if ( pos == -1 ) {\n                symbolicName = pathInfo;\n                version = null;\n            } else {\n                symbolicName = pathInfo.substring(0, pos);\n                version = pathInfo.substring(pos+1);\n            }\n\n            // search\n            final Bundle[] bundles = getBundleContext().getBundles();\n            for(int i=0; i<bundles.length; i++)\n            {\n                final Bundle bundle = bundles[i];\n                // check symbolic name first\n                if ( symbolicName.equals(bundle.getSymbolicName()) )\n                {\n                    if ( version == null || version.equals(bundle.getHeaders().get(Constants.BUNDLE_VERSION)) )\n                    {\n                        return bundle;\n                    }\n                }\n            }\n        }\n\n\n        return null;\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"private void writeJSON( final Writer pw, final Bundle bundle, final String pluginRoot,\n        final String servicesRoot, final boolean fullDetails ) throws IOException\n    {\n        final Bundle[] allBundles = this.getBundles();\n        final String statusLine = this.getStatusLine(allBundles);\n        final Bundle[] bundles = ( bundle != null ) ? new Bundle[]\n            { bundle } : allBundles;\n        Util.sort( bundles );\n\n        final JSONWriter jw = new JSONWriter( pw );\n\n        try\n        {\n            jw.object();\n\n            jw.key( \"status\" );\n            jw.value( statusLine );\n\n            jw.key( \"data\" );\n\n            jw.array();\n\n            for ( int i = 0; i < bundles.length; i++ )\n            {\n                bundleInfo( jw, bundles[i], fullDetails || bundle != null, pluginRoot, servicesRoot );\n            }\n\n            jw.endArray();\n\n            jw.endObject();\n\n        }\n        catch ( JSONException je )\n        {\n            throw new IOException( je.toString() );\n        }\n\n    }","id":25181,"modified_method":"private void writeJSON( final Writer pw, final Bundle bundle, final String pluginRoot,\n        final String servicesRoot, final boolean fullDetails ) throws IOException\n    {\n        final Bundle[] allBundles = this.getBundles();\n        final Object[] status = getStatusLine(allBundles);\n        final String statusLine = (String) status[5];\n        final Bundle[] bundles = ( bundle != null ) ? new Bundle[]\n            { bundle } : allBundles;\n        Util.sort( bundles );\n\n        final JSONWriter jw = new JSONWriter( pw );\n\n        try\n        {\n            jw.object();\n\n            jw.key( \"status\" );\n            jw.value( statusLine );\n            \n            // add raw status\n            jw.key( \"s\" );\n            jw.array();\n            for ( int i = 0; i < 5; i++ ) jw.value(status[i]); \n            jw.endArray();\n\n            jw.key( \"data\" );\n\n            jw.array();\n\n            for ( int i = 0; i < bundles.length; i++ )\n            {\n                bundleInfo( jw, bundles[i], fullDetails || bundle != null, pluginRoot, servicesRoot );\n            }\n\n            jw.endArray();\n\n            jw.endObject();\n\n        }\n        catch ( JSONException je )\n        {\n            throw new IOException( je.toString() );\n        }\n\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"private boolean isFragmentBundle( Bundle bundle)\n    {\n        return getPackageAdmin().getBundleType( bundle ) == PackageAdmin.BUNDLE_TYPE_FRAGMENT;\n    }","id":25182,"modified_method":"private final boolean isFragmentBundle( Bundle bundle)\n    {\n        return getPackageAdmin().getBundleType( bundle ) == PackageAdmin.BUNDLE_TYPE_FRAGMENT;\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"public void activate( BundleContext bundleContext )\n    {\n        super.activate( bundleContext );\n\n        // bootdelegation property parsing from Apache Felix R4SearchPolicyCore\n        String bootDelegation = bundleContext.getProperty( Constants.FRAMEWORK_BOOTDELEGATION );\n        bootDelegation = ( bootDelegation == null ) ? \"java.*\" : bootDelegation + \",java.*\";\n        StringTokenizer st = new StringTokenizer( bootDelegation, \" ,\" );\n        bootPkgs = new String[st.countTokens()];\n        bootPkgWildcards = new boolean[bootPkgs.length];\n        for ( int i = 0; i < bootPkgs.length; i++ )\n        {\n            bootDelegation = st.nextToken();\n            if ( bootDelegation.endsWith( \"*\" ) )\n            {\n                bootPkgWildcards[i] = true;\n                bootDelegation = bootDelegation.substring( 0, bootDelegation.length() - 1 );\n            }\n            bootPkgs[i] = bootDelegation;\n        }\n\n        configurationPrinter = bundleContext.registerService( ConfigurationPrinter.SERVICE, this, null );\n    }","id":25183,"modified_method":"/**\n     * @see org.apache.felix.webconsole.AbstractWebConsolePlugin#activate(org.osgi.framework.BundleContext)\n     */\n    public void activate( BundleContext bundleContext )\n    {\n        super.activate( bundleContext );\n\n        // bootdelegation property parsing from Apache Felix R4SearchPolicyCore\n        String bootDelegation = bundleContext.getProperty( Constants.FRAMEWORK_BOOTDELEGATION );\n        bootDelegation = ( bootDelegation == null ) ? \"java.*\" : bootDelegation + \",java.*\";\n        StringTokenizer st = new StringTokenizer( bootDelegation, \" ,\" );\n        bootPkgs = new String[st.countTokens()];\n        bootPkgWildcards = new boolean[bootPkgs.length];\n        for ( int i = 0; i < bootPkgs.length; i++ )\n        {\n            bootDelegation = st.nextToken();\n            if ( bootDelegation.endsWith( \"*\" ) )\n            {\n                bootPkgWildcards[i] = true;\n                bootDelegation = bootDelegation.substring( 0, bootDelegation.length() - 1 );\n            }\n            bootPkgs[i] = bootDelegation;\n        }\n\n        configurationPrinter = bundleContext.registerService( ConfigurationPrinter.SERVICE, this, null );\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"protected void renderContent( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n        // get request info from request attribute\n        final RequestInfo reqInfo = getRequestInfo(request);\n        final PrintWriter pw = response.getWriter();\n\n        final String appRoot = ( String ) request.getAttribute( WebConsoleConstants.ATTR_APP_ROOT );\n\n        Util.startScript( pw );\n        pw.println( \"var imgRoot = '\" + appRoot + \"/res/imgs';\");\n        pw.println( \"var startLevel = \" + getStartLevel().getInitialBundleStartLevel() + \";\");\n        pw.println( \"var drawDetails = \" + reqInfo.bundleRequested + \";\");\n        pw.println( \"var currentBundle = \" + (reqInfo.bundleRequested && reqInfo.bundle != null ? String.valueOf(reqInfo.bundle.getBundleId()) : \"null\") + \";\");\n        Util.endScript( pw );\n\n        Util.script(pw, appRoot, \"bundles.js\");\n\n        if ( \"upload\".equals(reqInfo.pathInfo) )\n        {\n            renderUploadForm(pw, appRoot);\n        }\n        else\n        {\n            pw.println( \"<div id='plugin_content'/>\");\n            Util.startScript( pw );\n            pw.print( \"renderBundles(\");\n            final String pluginRoot = ( String ) request.getAttribute( WebConsoleConstants.ATTR_PLUGIN_ROOT );\n            final String servicesRoot = getServicesRoot ( request );\n            writeJSON(pw, reqInfo.bundle, pluginRoot, servicesRoot );\n            pw.println(\");\" );\n            Util.endScript( pw );\n        }\n    }","id":25184,"modified_method":"/**\n     * @see org.apache.felix.webconsole.AbstractWebConsolePlugin#renderContent(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    protected void renderContent( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n        // get request info from request attribute\n        final RequestInfo reqInfo = getRequestInfo(request);\n\n        final int startLevel = getStartLevel().getInitialBundleStartLevel();\n\n        // prepare variables\n        DefaultVariableResolver vars = ( ( DefaultVariableResolver ) WebConsoleUtil.getVariableResolver( request ) );\n        vars.put( \"startLevel\", String.valueOf(startLevel));\n        vars.put( \"drawDetails\", reqInfo.bundleRequested ? Boolean.TRUE : Boolean.FALSE );\n        vars.put( \"currentBundle\", (reqInfo.bundleRequested && reqInfo.bundle != null ? String.valueOf(reqInfo.bundle.getBundleId()) : \"null\"));\n\n        if ( \"upload\".equals(reqInfo.pathInfo) )\n        {\n            response.getWriter().print(TEMPLATE_UPLOAD);\n        }\n        else\n        {\n            final String pluginRoot = ( String ) request.getAttribute( WebConsoleConstants.ATTR_PLUGIN_ROOT );\n            final String servicesRoot = getServicesRoot ( request );\n            StringWriter w = new StringWriter();\n            PrintWriter w2 = new PrintWriter(w);\n            writeJSON(w2, reqInfo.bundle, pluginRoot, servicesRoot );\n            vars.put( \"__bundles__\", w.toString());\n            \n            response.getWriter().print(TEMPLATE_MAIN);\n        }\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"private Integer getStartLevel( Bundle bundle )\n    {\n        StartLevel sl = getStartLevel();\n        return ( sl != null ) ? new Integer( sl.getBundleStartLevel( bundle ) ) : null;\n    }","id":25185,"modified_method":"private final Integer getStartLevel( Bundle bundle )\n    {\n        StartLevel sl = getStartLevel();\n        return ( sl != null ) ? new Integer( sl.getBundleStartLevel( bundle ) ) : null;\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"protected Bundle[] getBundles()\n    {\n        return getBundleContext().getBundles();\n    }","id":25186,"modified_method":"private final Bundle[] getBundles()\n    {\n        return getBundleContext().getBundles();\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"protected void doPost( HttpServletRequest req, HttpServletResponse resp ) throws ServletException, IOException\n    {\n        final RequestInfo reqInfo = new RequestInfo(req);\n        if ( reqInfo.bundle == null && reqInfo.bundleRequested ) {\n            resp.sendError(404);\n            return;\n        }\n\n        boolean success = false;\n\n        final String action = req.getParameter( \"action\" );\n\n        Bundle bundle = getBundle( req.getPathInfo() );\n\n        if ( bundle != null )\n        {\n            if ( action == null )\n            {\n                success = true;\n            }\n            else if ( \"start\".equals( action ) )\n            {\n                // start bundle\n                success = true;\n                try\n                {\n                    bundle.start();\n                }\n                catch ( BundleException be )\n                {\n                    getLog().log( LogService.LOG_ERROR, \"Cannot start\", be );\n                }\n            }\n            else if ( \"stop\".equals( action ) )\n            {\n                // stop bundle\n                success = true;\n                try\n                {\n                    bundle.stop();\n                }\n                catch ( BundleException be )\n                {\n                    getLog().log( LogService.LOG_ERROR, \"Cannot stop\", be );\n                }\n            }\n            else if ( \"refresh\".equals( action ) )\n            {\n                // refresh bundle wiring\n                refresh( bundle );\n                success = true;\n            }\n            else if ( \"update\".equals( action ) )\n            {\n                // update the bundle\n                update( bundle );\n                success = true;\n            }\n            else if ( \"uninstall\".equals( action ) )\n            {\n                // uninstall bundle\n                success = true;\n                try\n                {\n                    bundle.uninstall();\n                    bundle = null; // bundle has gone !\n                }\n                catch ( BundleException be )\n                {\n                    getLog().log( LogService.LOG_ERROR, \"Cannot uninstall\", be );\n                }\n            }\n        }\n\n        if ( \"refreshPackages\".equals( action ) )\n        {\n            getPackageAdmin().refreshPackages( null );\n            success = true;\n        }\n\n        if ( success )\n        {\n            // let's wait a little bit to give the framework time\n            // to process our request\n            try {\n                Thread.sleep(800);\n            } catch (InterruptedException e) {\n                // we ignore this\n            }\n            final String pluginRoot = ( String ) req.getAttribute( WebConsoleConstants.ATTR_PLUGIN_ROOT );\n            final String servicesRoot = getServicesRoot( req );\n            this.renderJSON(resp, null, pluginRoot, servicesRoot);\n        }\n        else\n        {\n            super.doPost( req, resp );\n        }\n    }","id":25187,"modified_method":"/**\n     * @see javax.servlet.http.HttpServlet#doPost(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    protected void doPost( HttpServletRequest req, HttpServletResponse resp ) throws ServletException, IOException\n    {\n        final RequestInfo reqInfo = new RequestInfo(req);\n        if ( reqInfo.bundle == null && reqInfo.bundleRequested ) {\n            resp.sendError(404);\n            return;\n        }\n\n        boolean success = false;\n\n        final String action = req.getParameter( \"action\" );\n\n        Bundle bundle = getBundle( req.getPathInfo() );\n\n        if ( bundle != null )\n        {\n            if ( action == null )\n            {\n                success = true;\n            }\n            else if ( \"start\".equals( action ) )\n            {\n                // start bundle\n                success = true;\n                try\n                {\n                    bundle.start();\n                }\n                catch ( BundleException be )\n                {\n                    log( \"Cannot start\", be );\n                }\n            }\n            else if ( \"stop\".equals( action ) )\n            {\n                // stop bundle\n                success = true;\n                try\n                {\n                    bundle.stop();\n                }\n                catch ( BundleException be )\n                {\n                    log( \"Cannot stop\", be );\n                }\n            }\n            else if ( \"refresh\".equals( action ) )\n            {\n                // refresh bundle wiring\n                refresh( bundle );\n                success = true;\n            }\n            else if ( \"update\".equals( action ) )\n            {\n                // update the bundle\n                update( bundle );\n                success = true;\n            }\n            else if ( \"uninstall\".equals( action ) )\n            {\n                // uninstall bundle\n                success = true;\n                try\n                {\n                    bundle.uninstall();\n                    bundle = null; // bundle has gone !\n                }\n                catch ( BundleException be )\n                {\n                    log( \"Cannot uninstall\", be );\n                }\n            }\n        }\n\n        if ( \"refreshPackages\".equals( action ) )\n        {\n            getPackageAdmin().refreshPackages( null );\n            success = true;\n        }\n\n        if ( success )\n        {\n            // let's wait a little bit to give the framework time\n            // to process our request\n            try {\n                Thread.sleep(800);\n            } catch (InterruptedException e) {\n                // we ignore this\n            }\n            final String pluginRoot = ( String ) req.getAttribute( WebConsoleConstants.ATTR_PLUGIN_ROOT );\n            final String servicesRoot = getServicesRoot( req );\n            this.renderJSON(resp, null, pluginRoot, servicesRoot);\n        }\n        else\n        {\n            super.doPost( req, resp );\n        }\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"private void listImportExport( JSONWriter jw, Bundle bundle, final String pluginRoot ) throws JSONException\n    {\n        PackageAdmin packageAdmin = getPackageAdmin();\n        if ( packageAdmin == null )\n        {\n            return;\n        }\n\n        Map usingBundles = new TreeMap();\n\n        ExportedPackage[] exports = packageAdmin.getExportedPackages( bundle );\n        if ( exports != null && exports.length > 0 )\n        {\n            // do alphabetical sort\n            Arrays.sort( exports, new Comparator()\n            {\n                public int compare( ExportedPackage p1, ExportedPackage p2 )\n                {\n                    return p1.getName().compareTo( p2.getName() );\n                }\n\n\n                public int compare( Object o1, Object o2 )\n                {\n                    return compare( ( ExportedPackage ) o1, ( ExportedPackage ) o2 );\n                }\n            } );\n\n            JSONArray val = new JSONArray();\n            for ( int j = 0; j < exports.length; j++ )\n            {\n                ExportedPackage export = exports[j];\n                collectExport( val, export.getName(), export.getVersion() );\n                Bundle[] ubList = export.getImportingBundles();\n                if ( ubList != null )\n                {\n                    for ( int i = 0; i < ubList.length; i++ )\n                    {\n                        Bundle ub = ubList[i];\n                        usingBundles.put( ub.getSymbolicName(), ub );\n                    }\n                }\n            }\n            WebConsoleUtil.keyVal( jw, \"Exported Packages\", val );\n        }\n        else\n        {\n            WebConsoleUtil.keyVal( jw, \"Exported Packages\", \"None\" );\n        }\n\n        exports = packageAdmin.getExportedPackages( ( Bundle ) null );\n        if ( exports != null && exports.length > 0 )\n        {\n            // collect import packages first\n            final List imports = new ArrayList();\n            for ( int i = 0; i < exports.length; i++ )\n            {\n                final ExportedPackage ep = exports[i];\n                final Bundle[] importers = ep.getImportingBundles();\n                for ( int j = 0; importers != null && j < importers.length; j++ )\n                {\n                    if ( importers[j].getBundleId() == bundle.getBundleId() )\n                    {\n                        imports.add( ep );\n\n                        break;\n                    }\n                }\n            }\n            // now sort\n            JSONArray val = new JSONArray();\n            if ( imports.size() > 0 )\n            {\n                final ExportedPackage[] packages = ( ExportedPackage[] ) imports.toArray( new ExportedPackage[imports\n                    .size()] );\n                Arrays.sort( packages, new Comparator()\n                {\n                    public int compare( ExportedPackage p1, ExportedPackage p2 )\n                    {\n                        return p1.getName().compareTo( p2.getName() );\n                    }\n\n\n                    public int compare( Object o1, Object o2 )\n                    {\n                        return compare( ( ExportedPackage ) o1, ( ExportedPackage ) o2 );\n                    }\n                } );\n                // and finally print out\n                for ( int i = 0; i < packages.length; i++ )\n                {\n                    ExportedPackage ep = packages[i];\n                    collectImport( val, ep.getName(), ep.getVersion(), false, ep, pluginRoot );\n                }\n            }\n            else\n            {\n                // add description if there are no imports\n                val.put( \"None\" );\n            }\n\n            WebConsoleUtil.keyVal( jw, \"Imported Packages\", val );\n        }\n\n        if ( !usingBundles.isEmpty() )\n        {\n            JSONArray val = new JSONArray();\n            for ( Iterator ui = usingBundles.values().iterator(); ui.hasNext(); )\n            {\n                Bundle usingBundle = ( Bundle ) ui.next();\n                val.put( getBundleDescriptor( usingBundle, pluginRoot ) );\n            }\n            WebConsoleUtil.keyVal( jw, \"Importing Bundles\", val );\n        }\n    }","id":25188,"modified_method":"private void listImportExport( JSONWriter jw, Bundle bundle, final String pluginRoot ) throws JSONException\n    {\n        PackageAdmin packageAdmin = getPackageAdmin();\n        if ( packageAdmin == null )\n        {\n            return;\n        }\n\n        Map usingBundles = new TreeMap();\n\n        ExportedPackage[] exports = packageAdmin.getExportedPackages( bundle );\n        if ( exports != null && exports.length > 0 )\n        {\n            // do alphabetical sort\n            Arrays.sort( exports, new Comparator()\n            {\n                public int compare( ExportedPackage p1, ExportedPackage p2 )\n                {\n                    return p1.getName().compareTo( p2.getName() );\n                }\n\n\n                public int compare( Object o1, Object o2 )\n                {\n                    return compare( ( ExportedPackage ) o1, ( ExportedPackage ) o2 );\n                }\n            } );\n\n            JSONArray val = new JSONArray();\n            for ( int j = 0; j < exports.length; j++ )\n            {\n                ExportedPackage export = exports[j];\n                collectExport( val, export.getName(), export.getVersion() );\n                Bundle[] ubList = export.getImportingBundles();\n                if ( ubList != null )\n                {\n                    for ( int i = 0; i < ubList.length; i++ )\n                    {\n                        Bundle ub = ubList[i];\n                        usingBundles.put( ub.getSymbolicName(), ub );\n                    }\n                }\n            }\n            WebConsoleUtil.keyVal( jw, \"Exported Packages\", val );\n        }\n        else\n        {\n            WebConsoleUtil.keyVal( jw, \"Exported Packages\", \"---\" );\n        }\n\n        exports = packageAdmin.getExportedPackages( ( Bundle ) null );\n        if ( exports != null && exports.length > 0 )\n        {\n            // collect import packages first\n            final List imports = new ArrayList();\n            for ( int i = 0; i < exports.length; i++ )\n            {\n                final ExportedPackage ep = exports[i];\n                final Bundle[] importers = ep.getImportingBundles();\n                for ( int j = 0; importers != null && j < importers.length; j++ )\n                {\n                    if ( importers[j].getBundleId() == bundle.getBundleId() )\n                    {\n                        imports.add( ep );\n\n                        break;\n                    }\n                }\n            }\n            // now sort\n            JSONArray val = new JSONArray();\n            if ( imports.size() > 0 )\n            {\n                final ExportedPackage[] packages = ( ExportedPackage[] ) imports.toArray( new ExportedPackage[imports\n                    .size()] );\n                Arrays.sort( packages, new Comparator()\n                {\n                    public int compare( ExportedPackage p1, ExportedPackage p2 )\n                    {\n                        return p1.getName().compareTo( p2.getName() );\n                    }\n\n\n                    public int compare( Object o1, Object o2 )\n                    {\n                        return compare( ( ExportedPackage ) o1, ( ExportedPackage ) o2 );\n                    }\n                } );\n                // and finally print out\n                for ( int i = 0; i < packages.length; i++ )\n                {\n                    ExportedPackage ep = packages[i];\n                    collectImport( val, ep.getName(), ep.getVersion(), false, ep, pluginRoot );\n                }\n            }\n            else\n            {\n                // add description if there are no imports\n                val.put( \"None\" );\n            }\n\n            WebConsoleUtil.keyVal( jw, \"Imported Packages\", val );\n        }\n\n        if ( !usingBundles.isEmpty() )\n        {\n            JSONArray val = new JSONArray();\n            for ( Iterator ui = usingBundles.values().iterator(); ui.hasNext(); )\n            {\n                Bundle usingBundle = ( Bundle ) ui.next();\n                val.put( getBundleDescriptor( usingBundle, pluginRoot ) );\n            }\n            WebConsoleUtil.keyVal( jw, \"Importing Bundles\", val );\n        }\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"private void listImportExportsUnresolved( JSONWriter jw, Bundle bundle, final String pluginRoot ) throws JSONException\n    {\n        Dictionary dict = bundle.getHeaders();\n\n        String target = ( String ) dict.get( Constants.EXPORT_PACKAGE );\n        if ( target != null )\n        {\n            R4Package[] pkgs = R4Package.parseImportOrExportHeader( target );\n            if ( pkgs != null && pkgs.length > 0 )\n            {\n                // do alphabetical sort\n                Arrays.sort( pkgs, new Comparator()\n                {\n                    public int compare( R4Package p1, R4Package p2 )\n                    {\n                        return p1.getName().compareTo( p2.getName() );\n                    }\n\n\n                    public int compare( Object o1, Object o2 )\n                    {\n                        return compare( ( R4Package ) o1, ( R4Package ) o2 );\n                    }\n                } );\n\n                JSONArray val = new JSONArray();\n                for ( int i = 0; i < pkgs.length; i++ )\n                {\n                    R4Export export = new R4Export( pkgs[i] );\n                    collectExport( val, export.getName(), export.getVersion() );\n                }\n                WebConsoleUtil.keyVal( jw, \"Exported Packages\", val );\n            }\n            else\n            {\n                WebConsoleUtil.keyVal( jw, \"Exported Packages\", \"None\" );\n            }\n        }\n\n        target = ( String ) dict.get( Constants.IMPORT_PACKAGE );\n        if ( target != null )\n        {\n            R4Package[] pkgs = R4Package.parseImportOrExportHeader( target );\n            if ( pkgs != null && pkgs.length > 0 )\n            {\n                Map imports = new TreeMap();\n                for ( int i = 0; i < pkgs.length; i++ )\n                {\n                    R4Package pkg = pkgs[i];\n                    imports.put( pkg.getName(), new R4Import( pkg ) );\n                }\n\n                // collect import packages first\n                final Map candidates = new HashMap();\n                PackageAdmin packageAdmin = getPackageAdmin();\n                if ( packageAdmin != null )\n                {\n                    ExportedPackage[] exports = packageAdmin.getExportedPackages( ( Bundle ) null );\n                    if ( exports != null && exports.length > 0 )\n                    {\n\n                        for ( int i = 0; i < exports.length; i++ )\n                        {\n                            final ExportedPackage ep = exports[i];\n\n                            R4Import imp = ( R4Import ) imports.get( ep.getName() );\n                            if ( imp != null && imp.isSatisfied( toR4Export( ep ) ) )\n                            {\n                                candidates.put( ep.getName(), ep );\n                            }\n                        }\n                    }\n                }\n\n                // now sort\n                JSONArray val = new JSONArray();\n                if ( imports.size() > 0 )\n                {\n                    for ( Iterator ii = imports.values().iterator(); ii.hasNext(); )\n                    {\n                        R4Import r4Import = ( R4Import ) ii.next();\n                        ExportedPackage ep = ( ExportedPackage ) candidates.get( r4Import.getName() );\n\n                        // if there is no matching export, check whether this\n                        // bundle has the package, ignore the entry in this case\n                        if ( ep == null )\n                        {\n                            String path = r4Import.getName().replace( '.', '/' );\n                            if ( bundle.getEntry( path ) != null )\n                            {\n                                continue;\n                            }\n                        }\n\n                        collectImport( val, r4Import.getName(), r4Import.getVersion(), r4Import.isOptional(), ep, pluginRoot );\n                    }\n                }\n                else\n                {\n                    // add description if there are no imports\n                    val.put( \"None\" );\n                }\n\n                WebConsoleUtil.keyVal( jw, \"Imported Packages\", val );\n            }\n        }\n    }","id":25189,"modified_method":"private void listImportExportsUnresolved( JSONWriter jw, Bundle bundle, final String pluginRoot ) throws JSONException\n    {\n        Dictionary dict = bundle.getHeaders();\n\n        String target = ( String ) dict.get( Constants.EXPORT_PACKAGE );\n        if ( target != null )\n        {\n            R4Package[] pkgs = R4Package.parseImportOrExportHeader( target );\n            if ( pkgs != null && pkgs.length > 0 )\n            {\n                // do alphabetical sort\n                Arrays.sort( pkgs, new Comparator()\n                {\n                    public int compare( R4Package p1, R4Package p2 )\n                    {\n                        return p1.getName().compareTo( p2.getName() );\n                    }\n\n\n                    public int compare( Object o1, Object o2 )\n                    {\n                        return compare( ( R4Package ) o1, ( R4Package ) o2 );\n                    }\n                } );\n\n                JSONArray val = new JSONArray();\n                for ( int i = 0; i < pkgs.length; i++ )\n                {\n                    R4Export export = new R4Export( pkgs[i] );\n                    collectExport( val, export.getName(), export.getVersion() );\n                }\n                WebConsoleUtil.keyVal( jw, \"Exported Packages\", val );\n            }\n            else\n            {\n                WebConsoleUtil.keyVal( jw, \"Exported Packages\", \"---\" );\n            }\n        }\n\n        target = ( String ) dict.get( Constants.IMPORT_PACKAGE );\n        if ( target != null )\n        {\n            R4Package[] pkgs = R4Package.parseImportOrExportHeader( target );\n            if ( pkgs != null && pkgs.length > 0 )\n            {\n                Map imports = new TreeMap();\n                for ( int i = 0; i < pkgs.length; i++ )\n                {\n                    R4Package pkg = pkgs[i];\n                    imports.put( pkg.getName(), new R4Import( pkg ) );\n                }\n\n                // collect import packages first\n                final Map candidates = new HashMap();\n                PackageAdmin packageAdmin = getPackageAdmin();\n                if ( packageAdmin != null )\n                {\n                    ExportedPackage[] exports = packageAdmin.getExportedPackages( ( Bundle ) null );\n                    if ( exports != null && exports.length > 0 )\n                    {\n\n                        for ( int i = 0; i < exports.length; i++ )\n                        {\n                            final ExportedPackage ep = exports[i];\n\n                            R4Import imp = ( R4Import ) imports.get( ep.getName() );\n                            if ( imp != null && imp.isSatisfied( toR4Export( ep ) ) )\n                            {\n                                candidates.put( ep.getName(), ep );\n                            }\n                        }\n                    }\n                }\n\n                // now sort\n                JSONArray val = new JSONArray();\n                if ( imports.size() > 0 )\n                {\n                    for ( Iterator ii = imports.values().iterator(); ii.hasNext(); )\n                    {\n                        R4Import r4Import = ( R4Import ) ii.next();\n                        ExportedPackage ep = ( ExportedPackage ) candidates.get( r4Import.getName() );\n\n                        // if there is no matching export, check whether this\n                        // bundle has the package, ignore the entry in this case\n                        if ( ep == null )\n                        {\n                            String path = r4Import.getName().replace( '.', '/' );\n                            if ( bundle.getEntry( path ) != null )\n                            {\n                                continue;\n                            }\n                        }\n\n                        collectImport( val, r4Import.getName(), r4Import.getVersion(), r4Import.isOptional(), ep, pluginRoot );\n                    }\n                }\n                else\n                {\n                    // add description if there are no imports\n                    val.put( \"---\" );\n                }\n\n                WebConsoleUtil.keyVal( jw, \"Imported Packages\", val );\n            }\n        }\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"public void printConfiguration( PrintWriter pw )\n    {\n        try\n        {\n            StringWriter w = new StringWriter();\n            writeJSON( w, null, null, null, true );\n            String jsonString = w.toString();\n            JSONObject json = new JSONObject( jsonString );\n\n            pw.println( \"Status: \" + json.get( \"status\" ) );\n            pw.println();\n\n            JSONArray data = json.getJSONArray( \"data\" );\n            for ( int i = 0; i < data.length(); i++ )\n            {\n                if ( !data.isNull( i ) )\n                {\n                    JSONObject bundle = data.getJSONObject( i );\n\n                    pw.println( MessageFormat.format( \"Bundle {0} - {1} {2} (state: {3})\", new Object[]\n                        { bundle.get( \"id\" ), bundle.get( \"name\" ), bundle.get( \"version\" ), bundle.get( \"state\" ) } ) );\n\n                    JSONArray props = bundle.getJSONArray( \"props\" );\n                    for ( int pi = 0; pi < props.length(); pi++ )\n                    {\n                        if ( !props.isNull( pi ) )\n                        {\n                            JSONObject entry = props.getJSONObject( pi );\n\n                            pw.print( \"    \" + entry.get( \"key\" ) + \": \" );\n\n                            Object entryValue = entry.get( \"value\" );\n                            if ( entryValue instanceof JSONArray )\n                            {\n                                pw.println();\n                                JSONArray entryArray = ( JSONArray ) entryValue;\n                                for ( int ei = 0; ei < entryArray.length(); ei++ )\n                                {\n                                    if ( !entryArray.isNull( ei ) )\n                                    {\n                                        pw.println( \"        \" + entryArray.get( ei ) );\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                pw.println( entryValue );\n                            }\n                        }\n                    }\n\n                    pw.println();\n                }\n            }\n        }\n        catch ( Exception e )\n        {\n            getLog().log( LogService.LOG_ERROR, \"Problem rendering Bundle details for configuration status\", e );\n        }\n    }","id":25190,"modified_method":"/**\n     * @see org.apache.felix.webconsole.ConfigurationPrinter#printConfiguration(java.io.PrintWriter)\n     */\n    public void printConfiguration( PrintWriter pw )\n    {\n        try\n        {\n            StringWriter w = new StringWriter();\n            writeJSON( w, null, null, null, true );\n            String jsonString = w.toString();\n            JSONObject json = new JSONObject( jsonString );\n\n            pw.println( \"Status: \" + json.get( \"status\" ) );\n            pw.println();\n\n            JSONArray data = json.getJSONArray( \"data\" );\n            for ( int i = 0; i < data.length(); i++ )\n            {\n                if ( !data.isNull( i ) )\n                {\n                    JSONObject bundle = data.getJSONObject( i );\n\n                    pw.println( MessageFormat.format( \"Bundle {0} - {1} {2} (state: {3})\", new Object[]\n                        { bundle.get( \"id\" ), bundle.get( \"name\" ), bundle.get( \"version\" ), bundle.get( \"state\" ) } ) );\n\n                    JSONArray props = bundle.getJSONArray( \"props\" );\n                    for ( int pi = 0; pi < props.length(); pi++ )\n                    {\n                        if ( !props.isNull( pi ) )\n                        {\n                            JSONObject entry = props.getJSONObject( pi );\n\n                            pw.print( \"    \" + entry.get( \"key\" ) + \": \" );\n\n                            Object entryValue = entry.get( \"value\" );\n                            if ( entryValue instanceof JSONArray )\n                            {\n                                pw.println();\n                                JSONArray entryArray = ( JSONArray ) entryValue;\n                                for ( int ei = 0; ei < entryArray.length(); ei++ )\n                                {\n                                    if ( !entryArray.isNull( ei ) )\n                                    {\n                                        pw.println( \"        \" + entryArray.get( ei ) );\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                pw.println( entryValue );\n                            }\n                        }\n                    }\n\n                    pw.println();\n                }\n            }\n        }\n        catch ( Exception e )\n        {\n            log( \"Problem rendering Bundle details for configuration status\", e );\n        }\n    }","commit_id":"63d692ad750252f578ce7220909345a450bb0778","url":"https://github.com/apache/felix"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\t\tUploadException uploadException =\n\t\t\t\t(UploadException)actionRequest.getAttribute(\n\t\t\t\t\tWebKeys.UPLOAD_EXCEPTION);\n\n\t\t\tif (uploadException != null) {\n\t\t\t\tif (uploadException.isExceededSizeLimit()) {\n\t\t\t\t\tthrow new FileSizeException(uploadException.getCause());\n\t\t\t\t}\n\n\t\t\t\tthrow new PortalException(uploadException.getCause());\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\taddTempImageFile(actionRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileEntry fileEntry = null;\n\n\t\t\t\tboolean imageUploaded = ParamUtil.getBoolean(\n\t\t\t\t\tactionRequest, \"imageUploaded\");\n\n\t\t\t\tif (imageUploaded) {\n\t\t\t\t\tfileEntry = saveTempImageFile(actionRequest);\n\t\t\t\t}\n\n\t\t\t\tlong maxFileSize = ParamUtil.getLong(\n\t\t\t\t\tactionRequest, \"maxFileSize\");\n\n\t\t\t\tif (fileEntry.getSize() > maxFileSize) {\n\t\t\t\t\tthrow new FileSizeException();\n\t\t\t\t}\n\n\t\t\t\tSessionMessages.add(actionRequest, \"imageUploaded\", fileEntry);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof PrincipalException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portal.error\");\n\t\t\t}\n\t\t\telse if (e instanceof ImageTypeException) {\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.putException(e);\n\n\t\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t\t\t}\n\t\t\telse if (e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof NoSuchFileException ||\n\t\t\t\t\t e instanceof UploadException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":25191,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping actionMapping, ActionForm actionForm,\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tlong maxFileSize = ParamUtil.getLong(actionRequest, \"maxFileSize\");\n\n\t\ttry {\n\t\t\tUploadException uploadException =\n\t\t\t\t(UploadException)actionRequest.getAttribute(\n\t\t\t\t\tWebKeys.UPLOAD_EXCEPTION);\n\n\t\t\tif (uploadException != null) {\n\t\t\t\tif (uploadException.isExceededSizeLimit()) {\n\t\t\t\t\tthrow new FileSizeException(uploadException.getCause());\n\t\t\t\t}\n\n\t\t\t\tthrow new PortalException(uploadException.getCause());\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\taddTempImageFile(actionRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileEntry fileEntry = null;\n\n\t\t\t\tboolean imageUploaded = ParamUtil.getBoolean(\n\t\t\t\t\tactionRequest, \"imageUploaded\");\n\n\t\t\t\tif (imageUploaded) {\n\t\t\t\t\tfileEntry = saveTempImageFile(actionRequest);\n\t\t\t\t}\n\n\t\t\t\tif (fileEntry.getSize() > maxFileSize) {\n\t\t\t\t\tthrow new FileSizeException();\n\t\t\t\t}\n\n\t\t\t\tSessionMessages.add(actionRequest, \"imageUploaded\", fileEntry);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof PrincipalException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portal.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileExtensionException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof ImageTypeException ||\n\t\t\t\t\t e instanceof NoSuchFileException ||\n\t\t\t\t\t e instanceof UploadException) {\n\n\t\t\t\tif (cmd.equals(Constants.ADD_TEMP)) {\n\t\t\t\t\thideDefaultErrorMessage(actionRequest);\n\n\t\t\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t\t\t(ThemeDisplay)actionRequest.getAttribute(\n\t\t\t\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\t\t\tString errorMessage = StringPool.BLANK;\n\n\t\t\t\t\tif (e instanceof FileExtensionException) {\n\t\t\t\t\t\terrorMessage = themeDisplay.translate(\n\t\t\t\t\t\t\t\"please-enter-a-file-with-a-valid-extension-x\",\n\t\t\t\t\t\t\tStringUtil.merge(\n\t\t\t\t\t\t\t\tPropsValues.DL_FILE_EXTENSIONS,\n\t\t\t\t\t\t\t\tStringPool.COMMA));\n\t\t\t\t\t}\n\t\t\t\t\telse if (e instanceof FileSizeException) {\n\t\t\t\t\t\tif (maxFileSize == 0) {\n\t\t\t\t\t\t\tmaxFileSize = PrefsPropsUtil.getLong(\n\t\t\t\t\t\t\t\tPropsKeys.UPLOAD_SERVLET_REQUEST_IMPL_MAX_SIZE);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terrorMessage = themeDisplay.translate(\n\t\t\t\t\t\t\t\"please-enter-a-file-with-a-valid-file-size-no\" +\n\t\t\t\t\t\t\t\t\"-larger-than-x\",\n\t\t\t\t\t\t\tTextFormatter.formatStorageSize(\n\t\t\t\t\t\t\t\tmaxFileSize, themeDisplay.getLocale()));\n\t\t\t\t\t}\n\t\t\t\t\telse if (e instanceof ImageTypeException) {\n\t\t\t\t\t\terrorMessage = themeDisplay.translate(\n\t\t\t\t\t\t\t\"please-enter-a-file-with-a-valid-file-type\");\n\t\t\t\t\t}\n\t\t\t\t\telse if (e instanceof NoSuchFileException ||\n\t\t\t\t\t\t\t e instanceof UploadException) {\n\n\t\t\t\t\t\terrorMessage = themeDisplay.translate(\n\t\t\t\t\t\t\t\"an-unexpected-error-occurred-while-uploading\" +\n\t\t\t\t\t\t\t\t\"-your-file\");\n\t\t\t\t\t}\n\n\t\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\t\tjsonObject.put(\"errorMessage\", errorMessage);\n\n\t\t\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"da38765d96ebd7f5b1f68d3d249e89bfe663a0e4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Reads the <code>templateFile<\/code> as a resource through the class\n     * loader of this class converting the binary data into a string using\n     * UTF-8 encoding.\n     * <p>\n     * If the template file cannot read into a string and an exception is\n     * caused, the exception is logged and an empty string returned.\n     *\n     * @param templateFile The absolute path to the template file to read.\n     * @return The contents of the template file as a string or and empty\n     * string if the template file fails to be read.\n     */\n    private final String readTemplateFile( final String templateFile )\n    {\n        try\n        {\n            return IOUtils.toString( getClass().getResourceAsStream( templateFile ), \"UTF-8\" );\n        }\n        catch ( IOException e )\n        {\n            log( \"readTemplateFile: Error loading \" + templateFile, e );\n        }\n\n        // fall back to empty contents to prevent NPE\n        return \"\";\n    }","id":25192,"modified_method":"/**\n     * Reads the <code>templateFile<\/code> as a resource through the class\n     * loader of this class converting the binary data into a string using\n     * UTF-8 encoding.\n     * <p>\n     * If the template file cannot read into a string and an exception is\n     * caused, the exception is logged and an empty string returned.\n     *\n     * @param templateFile The absolute path to the template file to read.\n     * @return The contents of the template file as a string or and empty\n     *      string if the template file fails to be read.\n     *\n     * @throws NullPointerException if <code>templateFile<\/code> is\n     *      <code>null<\/code>\n     * @throws RuntimeException if an <code>IOException<\/code> is thrown reading\n     *      the template file into a string. The exception provides the\n     *      exception thrown as its cause.\n     */\n    protected final String readTemplateFile( final String templateFile )\n    {\n        InputStream templateStream = getClass().getResourceAsStream( templateFile );\n        if ( templateStream != null )\n        {\n            try\n            {\n                return IOUtils.toString( templateStream, \"UTF-8\" );\n            }\n            catch ( IOException e )\n            {\n                throw new RuntimeException( \"readTemplateFile: Error loading \" + templateFile, e );\n            }\n            finally\n            {\n                try\n                {\n                    templateStream.close();\n                }\n                catch ( IOException ignore )\n                {\n                    // ignored\n                }\n            }\n        }\n\n        // template file does not exist, return an empty string\n        log( \"readTemplateFile: File '\" + templateFile + \"' not found through class \" + getClass() );\n        return \"\";\n    }","commit_id":"2fc6a6efb9aad7d0efc32b427f72ce6d15714a10","url":"https://github.com/apache/felix"},{"original_method":"public void deactivate()\n    {\n        if ( configurationPrinter != null )\n        {\n            configurationPrinter.unregister();\n            configurationPrinter = null;\n        }\n\n        super.deactivate();\n    }","id":25193,"modified_method":"/**\n     * @see org.apache.felix.webconsole.SimpleWebConsolePlugin#deactivate()\n     */\n    public void deactivate()\n    {\n        if ( configurationPrinter != null )\n        {\n            configurationPrinter.unregister();\n            configurationPrinter = null;\n        }\n\n        super.deactivate();\n    }","commit_id":"2fc6a6efb9aad7d0efc32b427f72ce6d15714a10","url":"https://github.com/apache/felix"},{"original_method":"private void writeJSON( final Writer pw, final ServiceReference service, final boolean fullDetails )\n        throws IOException\n    {\n        final ServiceReference[] allServices = this.getServices();\n        final String statusLine = this.getStatusLine( allServices );\n        final ServiceReference[] services = ( service != null ) ? new ServiceReference[]\n            { service } : allServices;\n\n        final JSONWriter jw = new JSONWriter( pw );\n\n        try\n        {\n            jw.object();\n\n            jw.key( \"status\" );\n            jw.value( statusLine );\n\n            jw.key( \"data\" );\n\n            jw.array();\n\n            for ( int i = 0; i < services.length; i++ )\n            {\n                serviceInfo( jw, services[i], fullDetails || service != null );\n            }\n\n            jw.endArray();\n\n            jw.endObject();\n\n        }\n        catch ( JSONException je )\n        {\n            throw new IOException( je.toString() );\n        }\n\n    }","id":25194,"modified_method":"private void writeJSON( final Writer pw, final ServiceReference service, final boolean fullDetails )\n        throws IOException\n    {\n        final ServiceReference[] allServices = this.getServices();\n        final String statusLine = getStatusLine( allServices );\n\n        final ServiceReference[] services = ( service != null ) ? new ServiceReference[]\n            { service } : allServices;\n\n        final JSONWriter jw = new JSONWriter( pw );\n\n        try\n        {\n            jw.object();\n\n            jw.key( \"status\" );\n            jw.value( statusLine );\n\n            jw.key( \"serviceCount\" );\n            jw.value( allServices.length );\n\n            jw.key( \"data\" );\n\n            jw.array();\n\n            for ( int i = 0; i < services.length; i++ )\n            {\n                serviceInfo( jw, services[i], fullDetails || service != null );\n            }\n\n            jw.endArray();\n\n            jw.endObject();\n\n        }\n        catch ( JSONException je )\n        {\n            throw new IOException( je.toString() );\n        }\n\n    }","commit_id":"2fc6a6efb9aad7d0efc32b427f72ce6d15714a10","url":"https://github.com/apache/felix"},{"original_method":"protected RequestInfo( final HttpServletRequest request )\n        {\n            String info = request.getPathInfo();\n            // remove label and starting slash\n            info = info.substring( getLabel().length() + 1 );\n\n            // get extension\n            if ( info.endsWith( \".json\" ) )\n            {\n                extension = \"json\";\n                info = info.substring( 0, info.length() - 5 );\n            }\n            else\n            {\n                extension = \"html\";\n            }\n\n            // we only accept direct requests to a service if they have a slash\n            // after the label\n            String serviceInfo = null;\n            if ( info.startsWith( \"/\" ) )\n            {\n                serviceInfo = info.substring( 1 );\n            }\n            if ( serviceInfo == null || serviceInfo.length() == 0 )\n            {\n                service = null;\n                serviceRequested = false;\n                pathInfo = null;\n            }\n            else\n            {\n                service = getServiceById( serviceInfo );\n                serviceRequested = true;\n                pathInfo = serviceInfo;\n            }\n            request.setAttribute( ServicesServlet.class.getName(), this );\n        }","id":25195,"modified_method":"protected RequestInfo( final HttpServletRequest request )\n        {\n            String info = request.getPathInfo();\n            // remove label and starting slash\n            info = info.substring( getLabel().length() + 1 );\n\n            // get extension\n            if ( info.endsWith( \".json\" ) )\n            {\n                extension = \"json\";\n                info = info.substring( 0, info.length() - 5 );\n            }\n            else\n            {\n                extension = \"html\";\n            }\n\n            // we only accept direct requests to a service if they have a slash\n            // after the label\n            String serviceInfo = null;\n            if ( info.startsWith( \"/\" ) )\n            {\n                serviceInfo = info.substring( 1 );\n            }\n            if ( serviceInfo == null || serviceInfo.length() == 0 )\n            {\n                service = null;\n                serviceRequested = false;\n            }\n            else\n            {\n                service = getServiceById( serviceInfo );\n                serviceRequested = true;\n            }\n            request.setAttribute( ServicesServlet.class.getName(), this );\n        }","commit_id":"2fc6a6efb9aad7d0efc32b427f72ce6d15714a10","url":"https://github.com/apache/felix"},{"original_method":"protected void doGet( HttpServletRequest request, HttpServletResponse response ) throws ServletException,\n        IOException\n    {\n        final RequestInfo reqInfo = new RequestInfo( request );\n        if ( reqInfo.service == null && reqInfo.serviceRequested )\n        {\n            response.sendError( 404 );\n            return;\n        }\n        if ( reqInfo.extension.equals( \"json\" ) )\n        {\n            this.renderJSON( response, reqInfo.service );\n\n            // nothing more to do\n            return;\n        }\n\n        super.doGet( request, response );\n    }","id":25196,"modified_method":"/**\n     * @see org.apache.felix.webconsole.AbstractWebConsolePlugin#doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    protected void doGet( HttpServletRequest request, HttpServletResponse response ) throws ServletException,\n        IOException\n    {\n        if (request.getPathInfo().indexOf(\"/res/\") == -1)\n        { // not resource\n            final RequestInfo reqInfo = new RequestInfo( request );\n            if ( reqInfo.service == null && reqInfo.serviceRequested )\n            {\n                response.sendError( 404 );\n                return;\n            }\n            if ( reqInfo.extension.equals( \"json\" ) )\n            {\n                this.renderJSON( response, reqInfo.service );\n\n                // nothing more to do\n                return;\n            }\n        }\n\n        super.doGet( request, response );\n    }","commit_id":"2fc6a6efb9aad7d0efc32b427f72ce6d15714a10","url":"https://github.com/apache/felix"},{"original_method":"private String getStatusLine( final ServiceReference[] services )\n    {\n        final StringBuffer buffer = new StringBuffer();\n        buffer.append( \"Services information: \" );\n        appendServiceInfoCount( buffer, \"in total\", services.length );\n        return buffer.toString();\n    }","id":25197,"modified_method":"private static final String getStatusLine( final ServiceReference[] services )\n    {\n        final StringBuffer buffer = new StringBuffer();\n        buffer.append( \"Services information: \" );\n        appendServiceInfoCount( buffer, \"in total\", services.length );\n        return buffer.toString();\n    }","commit_id":"2fc6a6efb9aad7d0efc32b427f72ce6d15714a10","url":"https://github.com/apache/felix"},{"original_method":"private ServiceReference getServiceById( String pathInfo )\n    {\n        // only use last part of the pathInfo\n        pathInfo = pathInfo.substring( pathInfo.lastIndexOf( '/' ) + 1 );\n\n        StringBuffer filter = new StringBuffer();\n        filter.append( \"(\" ).append( Constants.SERVICE_ID ).append( \"=\" );\n        filter.append( pathInfo ).append( \")\" );\n        String filterStr = filter.toString();\n        try\n        {\n            ServiceReference[] refs = getBundleContext().getServiceReferences( null, filterStr );\n            if ( refs == null || refs.length != 1 )\n            {\n                return null;\n            }\n            return refs[0];\n        }\n        catch ( InvalidSyntaxException e )\n        {\n            getLog().log( LogService.LOG_WARNING, \"Unable to search for services using filter \" + filterStr, e );\n            // this shouldn't happen\n            return null;\n        }\n    }","id":25198,"modified_method":"final ServiceReference getServiceById( String pathInfo )\n    {\n        // only use last part of the pathInfo\n        pathInfo = pathInfo.substring( pathInfo.lastIndexOf( '/' ) + 1 );\n\n        StringBuffer filter = new StringBuffer();\n        filter.append( \"(\" ).append( Constants.SERVICE_ID ).append( \"=\" );\n        filter.append( pathInfo ).append( \")\" );\n        String filterStr = filter.toString();\n        try\n        {\n            ServiceReference[] refs = getBundleContext().getServiceReferences( null, filterStr );\n            if ( refs == null || refs.length != 1 )\n            {\n                return null;\n            }\n            return refs[0];\n        }\n        catch ( InvalidSyntaxException e )\n        {\n            log( \"Unable to search for services using filter \" + filterStr, e );\n            // this shouldn't happen\n            return null;\n        }\n    }","commit_id":"2fc6a6efb9aad7d0efc32b427f72ce6d15714a10","url":"https://github.com/apache/felix"},{"original_method":"public void printConfiguration( PrintWriter pw )\n    {\n        try\n        {\n            StringWriter w = new StringWriter();\n            writeJSON( w, null, true );\n            String jsonString = w.toString();\n            JSONObject json = new JSONObject( jsonString );\n\n            pw.println( \"Status: \" + json.get( \"status\" ) );\n            pw.println();\n\n            JSONArray data = json.getJSONArray( \"data\" );\n            for ( int i = 0; i < data.length(); i++ )\n            {\n                if ( !data.isNull( i ) )\n                {\n                    JSONObject service = data.getJSONObject( i );\n\n                    pw.println( MessageFormat.format( \"Service {0} - {1} (pid: {2})\", new Object[]\n                        { service.get( \"id\" ), service.get( \"types\" ), service.get( \"pid\" ) } ) );\n                    pw.println( MessageFormat.format( \"  from Bundle {0} - {1} ({2}), version {3}\", new Object[]\n                        { service.get( \"bundleId\" ), service.get( \"bundleName\" ), service.get( \"bundleSymbolicName\" ),\n                            service.get( \"bundleVersion\" ) } ) );\n\n                    JSONArray props = service.getJSONArray( \"props\" );\n                    for ( int pi = 0; pi < props.length(); pi++ )\n                    {\n                        if ( !props.isNull( pi ) )\n                        {\n                            JSONObject entry = props.getJSONObject( pi );\n\n                            pw.print( \"    \" + entry.get( \"key\" ) + \": \" );\n\n                            Object entryValue = entry.get( \"value\" );\n                            if ( entryValue instanceof JSONArray )\n                            {\n                                pw.println();\n                                JSONArray entryArray = ( JSONArray ) entryValue;\n                                for ( int ei = 0; ei < entryArray.length(); ei++ )\n                                {\n                                    if ( !entryArray.isNull( ei ) )\n                                    {\n                                        pw.println( \"        \" + entryArray.get( ei ) );\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                pw.println( entryValue );\n                            }\n                        }\n                    }\n\n                    JSONArray usingBundles = service.getJSONArray( \"usingBundles\" );\n                    for ( int ui = 0; ui < usingBundles.length(); ui++ )\n                    {\n                        if ( !usingBundles.isNull( ui ) )\n                        {\n                            JSONObject bundle = usingBundles.getJSONObject( ui );\n                            pw.println( MessageFormat.format( \"  Using Bundle {0} - {1} ({2}), version {3}\", new Object[]\n                                { bundle.get( \"bundleId\" ), bundle.get( \"bundleName\" ),\n                                    bundle.get( \"bundleSymbolicName\" ), bundle.get( \"bundleVersion\" ) } ) );\n                        }\n                    }\n\n                    pw.println();\n                }\n            }\n        }\n        catch ( Exception e )\n        {\n            getLog().log( LogService.LOG_ERROR, \"Problem rendering Bundle details for configuration status\", e );\n        }\n    }","id":25199,"modified_method":"/**\n     * @see org.apache.felix.webconsole.ConfigurationPrinter#printConfiguration(java.io.PrintWriter)\n     */\n    public void printConfiguration( PrintWriter pw )\n    {\n        try\n        {\n            StringWriter w = new StringWriter();\n            writeJSON( w, null, true );\n            String jsonString = w.toString();\n            JSONObject json = new JSONObject( jsonString );\n\n            pw.println( \"Status: \" + json.get( \"status\" ) );\n            pw.println();\n\n            JSONArray data = json.getJSONArray( \"data\" );\n            for ( int i = 0; i < data.length(); i++ )\n            {\n                if ( !data.isNull( i ) )\n                {\n                    JSONObject service = data.getJSONObject( i );\n\n                    pw.println( MessageFormat.format( \"Service {0} - {1} (pid: {2})\", new Object[]\n                        { service.get( \"id\" ), service.get( \"types\" ), service.get( \"pid\" ) } ) );\n                    pw.println( MessageFormat.format( \"  from Bundle {0} - {1} ({2}), version {3}\", new Object[]\n                        { service.get( \"bundleId\" ), service.get( \"bundleName\" ), service.get( \"bundleSymbolicName\" ),\n                            service.get( \"bundleVersion\" ) } ) );\n\n                    JSONArray props = service.getJSONArray( \"props\" );\n                    for ( int pi = 0; pi < props.length(); pi++ )\n                    {\n                        if ( !props.isNull( pi ) )\n                        {\n                            JSONObject entry = props.getJSONObject( pi );\n\n                            pw.print( \"    \" + entry.get( \"key\" ) + \": \" );\n\n                            Object entryValue = entry.get( \"value\" );\n                            if ( entryValue instanceof JSONArray )\n                            {\n                                pw.println();\n                                JSONArray entryArray = ( JSONArray ) entryValue;\n                                for ( int ei = 0; ei < entryArray.length(); ei++ )\n                                {\n                                    if ( !entryArray.isNull( ei ) )\n                                    {\n                                        pw.println( \"        \" + entryArray.get( ei ) );\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                pw.println( entryValue );\n                            }\n                        }\n                    }\n\n                    JSONArray usingBundles = service.getJSONArray( \"usingBundles\" );\n                    for ( int ui = 0; ui < usingBundles.length(); ui++ )\n                    {\n                        if ( !usingBundles.isNull( ui ) )\n                        {\n                            JSONObject bundle = usingBundles.getJSONObject( ui );\n                            pw.println( MessageFormat.format( \"  Using Bundle {0} - {1} ({2}), version {3}\", new Object[]\n                                { bundle.get( \"bundleId\" ), bundle.get( \"bundleName\" ),\n                                    bundle.get( \"bundleSymbolicName\" ), bundle.get( \"bundleVersion\" ) } ) );\n                        }\n                    }\n\n                    pw.println();\n                }\n            }\n        }\n        catch ( Exception e )\n        {\n            log( \"Problem rendering Bundle details for configuration status\", e );\n        }\n    }","commit_id":"2fc6a6efb9aad7d0efc32b427f72ce6d15714a10","url":"https://github.com/apache/felix"},{"original_method":"private void appendServiceInfoCount( final StringBuffer buf, String msg, int count )\n    {\n        buf.append( count );\n        buf.append( \" service\" );\n        if ( count != 1 )\n            buf.append( 's' );\n        buf.append( ' ' );\n        buf.append( msg );\n    }","id":25200,"modified_method":"private static final void appendServiceInfoCount( final StringBuffer buf, String msg, int count )\n    {\n        buf.append( count );\n        buf.append( \" service\" );\n        if ( count != 1 )\n            buf.append( 's' );\n        buf.append( ' ' );\n        buf.append( msg );\n    }","commit_id":"2fc6a6efb9aad7d0efc32b427f72ce6d15714a10","url":"https://github.com/apache/felix"},{"original_method":"protected void renderContent( HttpServletRequest request, HttpServletResponse response ) throws ServletException,\n        IOException\n    {\n        // get request info from request attribute\n        final RequestInfo reqInfo = getRequestInfo( request );\n        final PrintWriter pw = response.getWriter();\n\n        final String appRoot = ( String ) request.getAttribute( WebConsoleConstants.ATTR_APP_ROOT );\n\n        Util.startScript( pw );\n        pw.println( \"var imgRoot = '\" + appRoot + \"/res/imgs';\" );\n        pw.println( \"var bundlePath = '\" + appRoot + \"/\" + BundlesServlet.NAME + \"/\" + \"';\" );\n        pw.println( \"var drawDetails = \" + reqInfo.serviceRequested + \";\" );\n        Util.endScript( pw );\n\n        Util.script( pw, appRoot, \"services.js\" );\n\n        pw.println( \"<div id='plugin_content'/>\" );\n        Util.startScript( pw );\n        pw.print( \"renderServices(\" );\n        writeJSON( pw, reqInfo.service );\n        pw.println( \");\" );\n        Util.endScript( pw );\n\n    }","id":25201,"modified_method":"/**\n     * @see org.apache.felix.webconsole.AbstractWebConsolePlugin#renderContent(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    protected void renderContent( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n        // get request info from request attribute\n        final RequestInfo reqInfo = getRequestInfo( request );\n\n        final String appRoot = ( String ) request.getAttribute( WebConsoleConstants.ATTR_APP_ROOT );\n        StringWriter w = new StringWriter();\n        PrintWriter w2 = new PrintWriter(w);\n        writeJSON(w2, reqInfo.service);\n\n        // prepare variables\n        DefaultVariableResolver vars = ( ( DefaultVariableResolver ) WebConsoleUtil.getVariableResolver( request ) );\n        vars.put( \"bundlePath\", appRoot +  \"/\" + BundlesServlet.NAME + \"/\" );\n        vars.put( \"drawDetails\", reqInfo.serviceRequested ? Boolean.TRUE : Boolean.FALSE );\n        vars.put( \"__data__\", w.toString() );\n\n        response.getWriter().print( TEMPLATE );\n    }","commit_id":"2fc6a6efb9aad7d0efc32b427f72ce6d15714a10","url":"https://github.com/apache/felix"},{"original_method":"public static RequestInfo getRequestInfo( final HttpServletRequest request )\n    {\n        return ( RequestInfo ) request.getAttribute( ServicesServlet.class.getName() );\n    }","id":25202,"modified_method":"static RequestInfo getRequestInfo( final HttpServletRequest request )\n    {\n        return ( RequestInfo ) request.getAttribute( ServicesServlet.class.getName() );\n    }","commit_id":"2fc6a6efb9aad7d0efc32b427f72ce6d15714a10","url":"https://github.com/apache/felix"},{"original_method":"public void activate( BundleContext bundleContext )\n    {\n        super.activate( bundleContext );\n        configurationPrinter = bundleContext.registerService( ConfigurationPrinter.SERVICE, this, null );\n    }","id":25203,"modified_method":"/**\n     * @see org.apache.felix.webconsole.AbstractWebConsolePlugin#activate(org.osgi.framework.BundleContext)\n     */\n    public void activate( BundleContext bundleContext )\n    {\n        super.activate( bundleContext );\n        configurationPrinter = bundleContext.registerService( ConfigurationPrinter.SERVICE, this, null );\n    }","commit_id":"2fc6a6efb9aad7d0efc32b427f72ce6d15714a10","url":"https://github.com/apache/felix"},{"original_method":"private ServiceReference[] getServices()\n    {\n        try\n        {\n            return getBundleContext().getServiceReferences( null, null );\n        }\n        catch ( InvalidSyntaxException e )\n        {\n            getLog().log( LogService.LOG_WARNING, \"Unable to access service reference list.\", e );\n            return new ServiceReference[0];\n        }\n    }","id":25204,"modified_method":"private final ServiceReference[] getServices()\n    {\n        try\n        {\n            return getBundleContext().getServiceReferences( null, null );\n        }\n        catch ( InvalidSyntaxException e )\n        {\n            log( \"Unable to access service reference list.\", e );\n            return NO_REFS;\n        }\n    }","commit_id":"2fc6a6efb9aad7d0efc32b427f72ce6d15714a10","url":"https://github.com/apache/felix"},{"original_method":"public static void process(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse,\n\t\t\tMap<String, BaseAlloyControllerImpl> alloyControllers)\n\t\tthrows Exception {\n\n\t\tString jsonString = null;\n\n\t\tString controller = ParamUtil.getString(actionRequest, \"controller\");\n\n\t\tBaseAlloyControllerImpl baseAlloyControllerImpl = alloyControllers.get(\n\t\t\tcontroller);\n\n\t\tif (baseAlloyControllerImpl == null) {\n\t\t\tthrow new Exception(\"Unable to find controller \" + controller);\n\t\t}\n\n\t\tString action = ParamUtil.getString(actionRequest, \"action\");\n\n\t\ttry {\n\t\t\tif (action.equals(\"custom\")) {\n\t\t\t\tClass<?> clazz = BaseAlloyControllerImpl.class;\n\n\t\t\t\tMethod method = clazz.getDeclaredMethod(\n\t\t\t\t\t\"processDataRequest\", new Class<?>[] {ActionRequest.class});\n\n\t\t\t\tjsonString =\n\t\t\t\t\t(String)ServiceBeanMethodInvocationFactoryUtil.proceed(\n\t\t\t\t\t\tbaseAlloyControllerImpl, clazz, method,\n\t\t\t\t\t\tnew Object[] {actionRequest},\n\t\t\t\t\t\tnew String[] {\"transactionAdvice\"});\n\t\t\t}\n\t\t\telse if (action.equals(\"dynamicQuery\")) {\n\t\t\t\tjsonString = executeDynamicQuery(\n\t\t\t\t\tbaseAlloyControllerImpl, actionRequest);\n\t\t\t}\n\t\t\telse if (action.equals(\"search\")) {\n\t\t\t\tjsonString = executeSearch(\n\t\t\t\t\tbaseAlloyControllerImpl, actionRequest);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tString message = e.getMessage();\n\n\t\t\tif (Validator.isNull(message)) {\n\t\t\t\tmessage = baseAlloyControllerImpl.translate(\n\t\t\t\t\t\"an-unexpected-error-occurred\");\n\t\t\t}\n\n\t\t\tjsonObject.put(\"message\", message);\n\n\t\t\tjsonObject.put(\"stacktrace\", StackTraceUtil.getStackTrace(e));\n\t\t\tjsonObject.put(\"success\", false);\n\n\t\t\tjsonString = jsonObject.toString();\n\t\t}\n\n\t\tif (jsonString != null) {\n\t\t\twriteJSON(actionRequest, actionResponse, jsonString);\n\t\t}\n\t}","id":25205,"modified_method":"public static void process(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse,\n\t\t\tMap<String, BaseAlloyControllerImpl> alloyControllers)\n\t\tthrows Exception {\n\n\t\tString jsonString = null;\n\n\t\tString controller = ParamUtil.getString(actionRequest, \"controller\");\n\n\t\tBaseAlloyControllerImpl baseAlloyControllerImpl = alloyControllers.get(\n\t\t\tcontroller);\n\n\t\tif (baseAlloyControllerImpl == null) {\n\t\t\tthrow new Exception(\"Unable to find controller \" + controller);\n\t\t}\n\n\t\tString action = ParamUtil.getString(actionRequest, \"action\");\n\n\t\ttry {\n\t\t\tif (action.equals(\"custom\")) {\n\t\t\t\tClass<?> clazz = BaseAlloyControllerImpl.class;\n\n\t\t\t\tMethod method = clazz.getDeclaredMethod(\n\t\t\t\t\t\"processDataRequest\", new Class<?>[] {ActionRequest.class});\n\n\t\t\t\tjsonString =\n\t\t\t\t\t(String)ServiceBeanMethodInvocationFactoryUtil.proceed(\n\t\t\t\t\t\tbaseAlloyControllerImpl, clazz, method,\n\t\t\t\t\t\tnew Object[] {actionRequest},\n\t\t\t\t\t\tnew String[] {\"transactionAdvice\"});\n\t\t\t}\n\t\t\telse if (action.equals(\"dynamicQuery\")) {\n\t\t\t\tjsonString = executeDynamicQuery(\n\t\t\t\t\tbaseAlloyControllerImpl, actionRequest);\n\t\t\t}\n\t\t\telse if (action.equals(\"search\")) {\n\t\t\t\tjsonString = executeSearch(\n\t\t\t\t\tbaseAlloyControllerImpl, actionRequest);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tString message = e.getMessage();\n\n\t\t\tif (Validator.isNull(message)) {\n\t\t\t\tmessage = baseAlloyControllerImpl.translate(\n\t\t\t\t\t\"an-unexpected-error-occurred\");\n\t\t\t}\n\n\t\t\tjsonObject.put(\"message\", message);\n\n\t\t\tjsonObject.put(\"stacktrace\", StackTraceUtil.getStackTrace(e));\n\t\t\tjsonObject.put(\"success\", false);\n\n\t\t\tjsonString = jsonObject.toString();\n\t\t}\n\n\t\tif (jsonString != null) {\n\t\t\twriteJSON(actionRequest, actionResponse, jsonString);\n\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\t\tjsonString);\n\n\t\t\tif (jsonObject.getBoolean(\"success\")) {\n\t\t\t\tAlloyNotificationEventHelper alloyNotificationEventHelper =\n\t\t\t\t\tbaseAlloyControllerImpl.alloyNotificationEventHelper;\n\n\t\t\t\talloyNotificationEventHelper.addUserNotificationEvents(\n\t\t\t\t\tPortalUtil.getHttpServletRequest(actionRequest), controller,\n\t\t\t\t\taction,\n\t\t\t\t\tjsonObject.getJSONObject(\n\t\t\t\t\t\t\"alloyNotificationEventHelperPayload\"));\n\t\t\t}\n\t\t}\n\t}","commit_id":"c0cf1dcddd2e88b99c3c6557fd25ed41f1b55e5d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public abstract void addUserNotificationEvents(\n\t\t\tHttpServletRequest request, String controllerPath,\n\t\t\tString actionPath, Object payload)\n\t\tthrows Exception;","id":25206,"modified_method":"public abstract void addUserNotificationEvents(\n\t\t\tHttpServletRequest request, String controllerPath,\n\t\t\tString actionPath, JSONObject payload)\n\t\tthrows Exception;","commit_id":"c0cf1dcddd2e88b99c3c6557fd25ed41f1b55e5d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic void execute() throws Exception {\n\t\tMethod method = getMethod(actionPath);\n\n\t\tif (method == null) {\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"No method found for action \" + actionPath);\n\t\t\t}\n\t\t}\n\n\t\tif (!hasPermission()) {\n\t\t\trenderError(\n\t\t\t\t\"you-do-not-have-permission-to-access-the-requested-resource\");\n\n\t\t\tmethod = null;\n\t\t}\n\n\t\tif (lifecycle.equals(PortletRequest.ACTION_PHASE)) {\n\t\t\tClass<?> superClass = clazz.getSuperclass();\n\n\t\t\tMethod executeActionMethod = superClass.getDeclaredMethod(\n\t\t\t\t\"executeAction\", new Class<?>[] {Method.class});\n\n\t\t\ttry {\n\t\t\t\tServiceBeanMethodInvocationFactoryUtil.proceed(\n\t\t\t\t\tthis, BaseAlloyControllerImpl.class, executeActionMethod,\n\t\t\t\t\tnew Object[] {method}, new String[] {\"transactionAdvice\"});\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error(e, e);\n\n\t\t\t\tactionRequest.setAttribute(\n\t\t\t\t\tCALLED_PROCESS_ACTION, Boolean.TRUE.toString());\n\n\t\t\t\tString message = \"an-unexpected-system-error-occurred\";\n\n\t\t\t\tThrowable rootCause = getRootCause(e);\n\n\t\t\t\tif (rootCause instanceof AlloyException) {\n\t\t\t\t\tmessage = rootCause.getMessage();\n\t\t\t\t}\n\n\t\t\t\trenderError(message);\n\n\t\t\t\tactionRequest.setAttribute(VIEW_PATH, viewPath);\n\n\t\t\t\tPortalUtil.copyRequestParameters(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\telse if (lifecycle.equals(PortletRequest.RENDER_PHASE)) {\n\t\t\texecuteRender(method);\n\t\t}\n\t\telse if (lifecycle.equals(PortletRequest.RESOURCE_PHASE)) {\n\t\t\texecuteResource(method);\n\t\t}\n\n\t\tif (alloyNotificationEventHelper != null) {\n\t\t\talloyNotificationEventHelper.addUserNotificationEvents(\n\t\t\t\trequest, controllerPath, actionPath,\n\t\t\t\talloyNotificationEventHelperPayload);\n\t\t}\n\t}","id":25207,"modified_method":"@Override\n\tpublic void execute() throws Exception {\n\t\tMethod method = getMethod(actionPath);\n\n\t\tif (method == null) {\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"No method found for action \" + actionPath);\n\t\t\t}\n\t\t}\n\n\t\tif (!hasPermission()) {\n\t\t\trenderError(\n\t\t\t\t\"you-do-not-have-permission-to-access-the-requested-resource\");\n\n\t\t\tmethod = null;\n\t\t}\n\n\t\tif (lifecycle.equals(PortletRequest.ACTION_PHASE)) {\n\t\t\tClass<?> superClass = clazz.getSuperclass();\n\n\t\t\tMethod executeActionMethod = superClass.getDeclaredMethod(\n\t\t\t\t\"executeAction\", new Class<?>[] {Method.class});\n\n\t\t\ttry {\n\t\t\t\tServiceBeanMethodInvocationFactoryUtil.proceed(\n\t\t\t\t\tthis, BaseAlloyControllerImpl.class, executeActionMethod,\n\t\t\t\t\tnew Object[] {method}, new String[] {\"transactionAdvice\"});\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error(e, e);\n\n\t\t\t\tactionRequest.setAttribute(\n\t\t\t\t\tCALLED_PROCESS_ACTION, Boolean.TRUE.toString());\n\n\t\t\t\tString message = \"an-unexpected-system-error-occurred\";\n\n\t\t\t\tThrowable rootCause = getRootCause(e);\n\n\t\t\t\tif (rootCause instanceof AlloyException) {\n\t\t\t\t\tmessage = rootCause.getMessage();\n\t\t\t\t}\n\n\t\t\t\trenderError(message);\n\n\t\t\t\tactionRequest.setAttribute(VIEW_PATH, viewPath);\n\n\t\t\t\tPortalUtil.copyRequestParameters(actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t\telse if (lifecycle.equals(PortletRequest.RENDER_PHASE)) {\n\t\t\texecuteRender(method);\n\t\t}\n\t\telse if (lifecycle.equals(PortletRequest.RESOURCE_PHASE)) {\n\t\t\texecuteResource(method);\n\t\t}\n\n\t\tif ((alloyNotificationEventHelper != null) &&\n\t\t\t!viewPath.equals(_VIEW_PATH_ERROR)) {\n\n\t\t\talloyNotificationEventHelper.addUserNotificationEvents(\n\t\t\t\trequest, controllerPath, actionPath,\n\t\t\t\talloyNotificationEventHelperPayload);\n\t\t}\n\t}","commit_id":"c0cf1dcddd2e88b99c3c6557fd25ed41f1b55e5d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private static List<FunctionDescriptor> generateFunctionsToAdd(JetNamedFunction functionElement) {\n        BindingContext context = KotlinCacheManagerUtil.getDeclarationsFromProject(functionElement).getBindingContext();\n\n        FunctionDescriptor functionDescriptor = context.get(BindingContext.FUNCTION, functionElement);\n        if (functionDescriptor == null) return Collections.emptyList();\n\n        DeclarationDescriptor containingDeclaration = functionDescriptor.getContainingDeclaration();\n        if (!(containingDeclaration instanceof ClassDescriptor)) return Collections.emptyList();\n\n        List<FunctionDescriptor> functions = Lists.newArrayList();\n        ClassDescriptor classDescriptor = (ClassDescriptor) containingDeclaration;\n        // TODO: filter out impossible supertypes (for example when argument's type isn't visible in a superclass).\n        for (ClassDescriptor supertypeDescriptor : getSupertypes(classDescriptor)) {\n            if (KotlinBuiltIns.getInstance().isAnyOrNullableAny(supertypeDescriptor.getDefaultType())) continue;\n            functions.add(generateFunctionSignatureForType(functionDescriptor, supertypeDescriptor));\n        }\n        return functions;\n    }","id":25208,"modified_method":"private static List<FunctionDescriptor> generateFunctionsToAdd(JetNamedFunction functionElement) {\n        BindingContext context = KotlinCacheManagerUtil.getDeclarationsBindingContext(functionElement);\n\n        FunctionDescriptor functionDescriptor = context.get(BindingContext.FUNCTION, functionElement);\n        if (functionDescriptor == null) return Collections.emptyList();\n\n        DeclarationDescriptor containingDeclaration = functionDescriptor.getContainingDeclaration();\n        if (!(containingDeclaration instanceof ClassDescriptor)) return Collections.emptyList();\n\n        List<FunctionDescriptor> functions = Lists.newArrayList();\n        ClassDescriptor classDescriptor = (ClassDescriptor) containingDeclaration;\n        // TODO: filter out impossible supertypes (for example when argument's type isn't visible in a superclass).\n        for (ClassDescriptor supertypeDescriptor : getSupertypes(classDescriptor)) {\n            if (KotlinBuiltIns.getInstance().isAnyOrNullableAny(supertypeDescriptor.getDefaultType())) continue;\n            functions.add(generateFunctionSignatureForType(functionDescriptor, supertypeDescriptor));\n        }\n        return functions;\n    }","commit_id":"99b5fa1f4765ce00642e0e4ba0a7c8a6761aa472","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private JetAddFunctionToClassifierAction createAction(Project project, Editor editor) {\n        BindingContext bindingContext = KotlinCacheManagerUtil.getDeclarationsFromProject(element).getBindingContext();\n        return new JetAddFunctionToClassifierAction(project, editor, bindingContext, functionsToAdd);\n    }","id":25209,"modified_method":"@NotNull\n    private JetAddFunctionToClassifierAction createAction(Project project, Editor editor) {\n        BindingContext bindingContext = KotlinCacheManagerUtil.getDeclarationsBindingContext(element);\n        return new JetAddFunctionToClassifierAction(project, editor, bindingContext, functionsToAdd);\n    }","commit_id":"99b5fa1f4765ce00642e0e4ba0a7c8a6761aa472","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Computes all the signatures a 'functionElement' could be changed to in order to remove NOTHING_TO_OVERRIDE error.\n     */\n    @NotNull\n    private static List<FunctionDescriptor> computePossibleSignatures(JetNamedFunction functionElement) {\n        BindingContext context = KotlinCacheManagerUtil.getDeclarationsFromProject(functionElement).getBindingContext();\n        FunctionDescriptor functionDescriptor = context.get(BindingContext.FUNCTION, functionElement);\n        if (functionDescriptor == null) return Lists.newArrayList();\n        List<FunctionDescriptor> superFunctions = getPossibleSuperFunctionsDescriptors(functionDescriptor);\n        Map<String, FunctionDescriptor> possibleSignatures = Maps.newHashMap();\n        for (FunctionDescriptor superFunction : superFunctions) {\n            if (!superFunction.getKind().isReal()) continue;\n            FunctionDescriptor signature = changeSignatureToMatch(functionDescriptor, superFunction);\n            possibleSignatures.put(getFunctionSignatureString(signature, /* shortTypeNames = */ false), signature);\n        }\n        return Lists.newArrayList(possibleSignatures.values());\n    }","id":25210,"modified_method":"/**\n     * Computes all the signatures a 'functionElement' could be changed to in order to remove NOTHING_TO_OVERRIDE error.\n     */\n    @NotNull\n    private static List<FunctionDescriptor> computePossibleSignatures(JetNamedFunction functionElement) {\n        BindingContext context = KotlinCacheManagerUtil.getDeclarationsBindingContext(functionElement);\n        FunctionDescriptor functionDescriptor = context.get(BindingContext.FUNCTION, functionElement);\n        if (functionDescriptor == null) return Lists.newArrayList();\n        List<FunctionDescriptor> superFunctions = getPossibleSuperFunctionsDescriptors(functionDescriptor);\n        Map<String, FunctionDescriptor> possibleSignatures = Maps.newHashMap();\n        for (FunctionDescriptor superFunction : superFunctions) {\n            if (!superFunction.getKind().isReal()) continue;\n            FunctionDescriptor signature = changeSignatureToMatch(functionDescriptor, superFunction);\n            possibleSignatures.put(getFunctionSignatureString(signature, /* shortTypeNames = */ false), signature);\n        }\n        return Lists.newArrayList(possibleSignatures.values());\n    }","commit_id":"99b5fa1f4765ce00642e0e4ba0a7c8a6761aa472","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n\t * Create an RRD database file for storing latency/response time\n\t * data.\n\t * \n\t * @param rrdJniInterface \tinterface used to issue RRD commands.\n\t * @param repository\t\tpath to the RRD file repository\n\t * @param addr\t\t\tinterface address\n\t * @param dsName\t\tdata source/RRD file name\n\t * \n\t * @return true if RRD file successfully created, false otherwise\n\t */\n\tpublic boolean createRRD(Interface rrdJniInterface, String repository, InetAddress addr, String dsName)\n\t{\n\t\tCategory log = ThreadCategory.getInstance(this.getClass());\n\t\t\n\t\t// add interface address to RRD repository path\n\t\tString path = repository + File.separator + addr.getHostAddress();\n\t\t\n\t\t// If a directory does not yet exist for this interface create it.\n\t\t//\n\t\tFile f = new File(path);\n\t\tif (!f.isDirectory())\n\t\t\tif (!f.mkdirs())\n\t\t\t\tthrow new RuntimeException(\"Unable to create RRD file repository, path: \" + path);\n\t\t\n\t\t// add RRD file name to path\n\t\tString fullPath = path + File.separator + dsName + \".rrd\";\n\t\t\n\t\tf = new File(fullPath);\n\t\tif (f.exists())\n\t\t{\n\t\t\t// Already exists, no need to create\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Build RRD create command\n\t\t\t// \n\t\t\t// Step size: \t5 minutes\n\t\t\t// RRAs:    \t1 week of 5 minute average data\n\t\t\t//              6 months worth of hourly min, max, average data\n\t\t\tString cmd = \"create \" + fullPath + \" --step 300 \" +\n\t\t\t\t\"DS:\" + dsName + \":GAUGE:600:U:U \" + \n\t\t\t\t\"RRA:AVERAGE:0.5:1:2016 \" +\n\t\t\t\t\"RRA:AVERAGE:0.5:12:4464 \" + \n\t\t\t\t\"RRA:MIN:0.5:12:4464 \" +\n\t\t\t\t\"RRA:MAX:0.5:12:4464\";\n\t\t\t\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"createRRD: issuing RRD create command: \" + cmd);\n\t\t\t\n\t\t\t// Issue the RRD 'create' command\n\t\t\tString[] results = rrdJniInterface.launch(cmd);\n\t\t    \n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"createRRD: RRD create command completed for \" + addr.getHostAddress());\n\t\t\t\t\n\t\t\t// Sanity check results array\n\t\t\tif (results == null)\n\t\t\t{\n\t\t\t\tif(log.isEnabledFor(Priority.ERROR))\n\t\t\t\t{\n\t\t\t\t\tlog.error(\"createRRD: Unexpected failure calling native method launch() with command string: \" + cmd);\n\t\t\t\t\tlog.error(\"createRRD: No error text available.\");\n\t\t\t\t}\n\t\t\t\tthrow new RuntimeException(\"RRD database 'create' failed for interface \" + addr.getHostAddress());\n\t\t\t}\n\t\t    \n\t\t\t// Check error string at index 0, will be null if create was successful\n\t\t\tif (results[0] != null)\n\t\t\t{\n\t\t\t\tif(log.isEnabledFor(Priority.ERROR))\n\t\t\t\t\tlog.error(\"RRD database 'create' failed for \" + addr.getHostAddress() + \", reason: \" + results[0]);\n\t\t\t\t\tthrow new RuntimeException(\"RRD database 'create' failed for interface \" + addr.getHostAddress() + \", reason: \" + results[0]);\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t}","id":25211,"modified_method":"/**\n\t * Create an RRD database file for storing latency/response time\n\t * data.\n\t * \n\t * @param rrdJniInterface \tinterface used to issue RRD commands.\n\t * @param repository\t\tpath to the RRD file repository\n\t * @param addr\t\t\tinterface address\n\t * @param dsName\t\tdata source/RRD file name\n\t * \n\t * @return true if RRD file successfully created, false otherwise\n\t */\n\tpublic boolean createRRD(Interface rrdJniInterface, String repository, InetAddress addr, String dsName, org.opennms.netmgt.config.poller.Package pkg)\n\t{\n\t\tCategory log = ThreadCategory.getInstance(this.getClass());\n\t\t\n\t\t// add interface address to RRD repository path\n\t\tString path = repository + File.separator + addr.getHostAddress();\n\t\t\n\t\t// If a directory does not yet exist for this interface create it.\n\t\t//\n\t\tFile f = new File(path);\n\t\tif (!f.isDirectory())\n\t\t\tif (!f.mkdirs())\n\t\t\t\tthrow new RuntimeException(\"Unable to create RRD file repository, path: \" + path);\n\t\t\n\t\t// add RRD file name to path\n\t\tString fullPath = path + File.separator + dsName + \".rrd\";\n\t\t\n\t\tf = new File(fullPath);\n\t\tif (f.exists())\n\t\t{\n\t\t\t// Already exists, no need to create\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n                        // Build RRA portion of RRD create command\n                        //\n                        String cmdRRA = new String();\n                        List rraList = PollerConfigFactory.getInstance().getRRAList(pkg);\n                        Iterator j = rraList.iterator();\n                        while (j.hasNext())\n                        {\n                                String rra = (String)j.next();\n                                cmdRRA = cmdRRA.concat(\" \" + rra);\n                        }\n\n\t\t\t// Build RRD create command\n\t\t\t// \n\t\t\t// Step size: \t5 minutes\n\t\t\t// RRAs:    \t1 week of 5 minute average data\n\t\t\t//              6 months worth of hourly min, max, average data\n\t\t\tString cmd = \"create \" + fullPath + \" --step \" +\n\t\t\t\tPollerConfigFactory.getInstance().getStep(pkg) +\n\t\t\t\t\" DS:\" + dsName + \":GAUGE:600:U:U \" + \n\t\t\t\tcmdRRA;\n\t\t\t\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"createRRD: issuing RRD create command: \" + cmd);\n\t\t\t\n\t\t\t// Issue the RRD 'create' command\n\t\t\tString[] results = rrdJniInterface.launch(cmd);\n\t\t    \n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"createRRD: RRD create command completed for \" + addr.getHostAddress());\n\t\t\t\t\n\t\t\t// Sanity check results array\n\t\t\tif (results == null)\n\t\t\t{\n\t\t\t\tif(log.isEnabledFor(Priority.ERROR))\n\t\t\t\t{\n\t\t\t\t\tlog.error(\"createRRD: Unexpected failure calling native method launch() with command string: \" + cmd);\n\t\t\t\t\tlog.error(\"createRRD: No error text available.\");\n\t\t\t\t}\n\t\t\t\tthrow new RuntimeException(\"RRD database 'create' failed for interface \" + addr.getHostAddress());\n\t\t\t}\n\t\t    \n\t\t\t// Check error string at index 0, will be null if create was successful\n\t\t\tif (results[0] != null)\n\t\t\t{\n\t\t\t\tif(log.isEnabledFor(Priority.ERROR))\n\t\t\t\t\tlog.error(\"RRD database 'create' failed for \" + addr.getHostAddress() + \", reason: \" + results[0]);\n\t\t\t\t\tthrow new RuntimeException(\"RRD database 'create' failed for interface \" + addr.getHostAddress() + \", reason: \" + results[0]);\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t}","commit_id":"a6a144ab11a9b78e02e9d8fa45264e3cadd0ca2a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Update an RRD database file with latency/response time data.\n\t * \n\t * @param rrdJniInterface \tinterface used to issue RRD commands.\n\t * @param repository\t\tpath to the RRD file repository\n\t * @param addr\t\t\tinterface address\n\t * @param value\t\t\tvalue to update the RRD file with\n\t * \n\t * @return true if RRD file successfully created, false otherwise\n\t */\n\tpublic void updateRRD(Interface rrdJniInterface, String repository, InetAddress addr, String dsName, long value)\n\t{\n\t\tCategory log = ThreadCategory.getInstance(this.getClass());\n\t\t\n\t\t// Create RRD if it doesn't already exist\n\t\tcreateRRD(rrdJniInterface, repository, addr, dsName);\n\t\t\n\t\t// Build complete path\n\t\tString fullPath = repository + File.separator + addr.getHostAddress() + File.separator + dsName + \".rrd\";\n\t\t\n\t\t// update RRD database\n\t\tString cmd = \"update \" + fullPath + \" N:\" + String.valueOf(value);\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"updateRRD: issuing RRD update command: \" + cmd);\n\n\t\t// Issue the RRD 'create' command\n\t\tString[] results = rrdJniInterface.launch(cmd);\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"updateRRD: RRD update command completed for \" + addr.getHostAddress());\n\t\t\t\n\t\t// Sanity check results array\n\t\tif (results == null)\n\t\t{\n\t\t\tif(log.isEnabledFor(Priority.ERROR))\n\t\t\t{\n\t\t\t\tlog.error(\"updateRRD: Unexpected failure calling native method launch() with command string: \" + cmd);\n\t\t\t\tlog.error(\"updateRRD: No error text available.\");\n\t\t\t}\n\t\t\tthrow new RuntimeException(\"RRD database 'update' failed for interface \" + addr.getHostAddress());\n\t\t}\n\t    \n\t\t// Check error string at index 0, will be null if create was successful\n\t\tif (results[0] != null)\n\t\t{\n\t\t\tif(log.isEnabledFor(Priority.ERROR))\n\t\t\t\tlog.error(\"RRD database 'update' failed for \" + addr.getHostAddress() + \", reason: \" + results[0]);\n\t\t\t\tthrow new RuntimeException(\"RRD database 'update' failed for interface \" + addr.getHostAddress() + \", reason: \" + results[0]);\n\t\t}\n\t}","id":25212,"modified_method":"/**\n\t * Update an RRD database file with latency/response time data.\n\t * \n\t * @param rrdJniInterface \tinterface used to issue RRD commands.\n\t * @param repository\t\tpath to the RRD file repository\n\t * @param addr\t\t\tinterface address\n\t * @param value\t\t\tvalue to update the RRD file with\n\t * \n\t * @return true if RRD file successfully created, false otherwise\n\t */\n\tpublic void updateRRD(Interface rrdJniInterface, String repository, InetAddress addr, String dsName, long value, org.opennms.netmgt.config.poller.Package pkg)\n\t{\n\t\tCategory log = ThreadCategory.getInstance(this.getClass());\n\t\t\n\t\t// Create RRD if it doesn't already exist\n\t\tcreateRRD(rrdJniInterface, repository, addr, dsName, pkg);\n\t\t\n\t\t// Build complete path\n\t\tString fullPath = repository + File.separator + addr.getHostAddress() + File.separator + dsName + \".rrd\";\n\t\t\n\t\t// update RRD database\n\t\tString cmd = \"update \" + fullPath + \" N:\" + String.valueOf(value);\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"updateRRD: issuing RRD update command: \" + cmd);\n\n\t\t// Issue the RRD 'create' command\n\t\tString[] results = rrdJniInterface.launch(cmd);\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"updateRRD: RRD update command completed for \" + addr.getHostAddress());\n\t\t\t\n\t\t// Sanity check results array\n\t\tif (results == null)\n\t\t{\n\t\t\tif(log.isEnabledFor(Priority.ERROR))\n\t\t\t{\n\t\t\t\tlog.error(\"updateRRD: Unexpected failure calling native method launch() with command string: \" + cmd);\n\t\t\t\tlog.error(\"updateRRD: No error text available.\");\n\t\t\t}\n\t\t\tthrow new RuntimeException(\"RRD database 'update' failed for interface \" + addr.getHostAddress());\n\t\t}\n\t    \n\t\t// Check error string at index 0, will be null if create was successful\n\t\tif (results[0] != null)\n\t\t{\n\t\t\tif(log.isEnabledFor(Priority.ERROR))\n\t\t\t\tlog.error(\"RRD database 'update' failed for \" + addr.getHostAddress() + \", reason: \" + results[0]);\n\t\t\t\tthrow new RuntimeException(\"RRD database 'update' failed for interface \" + addr.getHostAddress() + \", reason: \" + results[0]);\n\t\t}\n\t}","commit_id":"a6a144ab11a9b78e02e9d8fa45264e3cadd0ca2a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <P>Invokes a poll of the service via the ServiceMonitor.<\/P>\n\t */\n\tpublic int poll()\n\t{\n\t\tCategory log = ThreadCategory.getInstance(getClass());\n\t\t\n\t\tm_lastPoll = System.currentTimeMillis();\n\t\tm_statusChangedFlag = false;\n\t\tInetAddress addr = (InetAddress)m_pInterface.getAddress();\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"poll: starting new poll for \" + addr.getHostAddress() + \n\t\t\t\t\t\"/\" + m_service.getName() + \"/\" + m_package.getName());\n\t\t\n\t\t// Poll the interface/service pair via the service monitor\n\t\t//\n\t\tint status = ServiceMonitor.SERVICE_UNAVAILABLE;\n\t\tMap propertiesMap = (Map)SVC_PROP_MAP.get(m_svcPropKey);\n\t\ttry\n\t\t{\n\t\t\tstatus = m_monitor.poll(this, propertiesMap);\n\t\t}\n\t\tcatch(NetworkInterfaceNotSupportedException ex)\n\t\t{\n\t\t\tlog.error(\"poll: Interface \" + addr.getHostAddress() + \" Not Supported!\", ex);\n\t\t\treturn status;\n\t\t}\n\t\tcatch(Throwable t)\n\t\t{\n\t\t\tlog.error(\"poll: An undeclared throwable was caught polling interface \" + addr.getHostAddress(), t);\n\t\t}\n\t\t\n\t\t// serviceUnresponsive behavior disabled?\n                //\n                if (!PollerConfigFactory.getInstance().serviceUnresponsiveEnabled())\n                {\n                        // serviceUnresponsive behavior is disabled, a status\n                        // of SERVICE_UNRESPONSIVE is treated as SERVICE_UNAVAILABLE\n                        if (status == ServiceMonitor.SERVICE_UNRESPONSIVE)\n                                status = ServiceMonitor.SERVICE_UNAVAILABLE;\n                }\n                else\n                {\n\t\t\t// Update unresponsive flag based on latest status\n\t\t\t// returned by the monitor and generate serviceUnresponsive\n\t\t\t// or serviceResponsive event if necessary.\n\t\t\t//\n\t\t\tswitch (status)\n\t\t\t{\n\t\t\t\tcase ServiceMonitor.SERVICE_UNRESPONSIVE: \n\t\t\t\t\t// Check unresponsive flag to determine if we need\n\t\t\t\t\t// to generate a 'serviceUnresponsive' event.\n\t\t\t\t\t//\n\t\t\t\t\tif (m_unresponsiveFlag == false )\n\t\t\t\t\t{\n\t\t\t\t\t\tm_unresponsiveFlag = true;\n\t\t\t\t\t\tsendEvent(EventConstants.SERVICE_UNRESPONSIVE_EVENT_UEI, propertiesMap);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set status back to available, don't want unresponsive \n\t\t\t\t\t\t// service to generate outage\n\t\t\t\t\t\tstatus = ServiceMonitor.SERVICE_AVAILABLE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t\tcase ServiceMonitor.SERVICE_AVAILABLE: \n\t\t\t\t\t// Check unresponsive flag to determine if we\n\t\t\t\t\t// need to generate a 'serviceResponsive' event\n\t\t\t\t\tif (m_unresponsiveFlag == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_unresponsiveFlag = false;\n\t\t\t\t\t\tsendEvent(EventConstants.SERVICE_RESPONSIVE_EVENT_UEI, propertiesMap);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\n\t\t\t\tcase ServiceMonitor.SERVICE_UNAVAILABLE: \n\t\t\t\t\t// Clear unresponsive flag\n\t\t\t\t\tm_unresponsiveFlag = false;\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t// Any change in status?\n\t\t//\n\t\tif(status != m_status)\n\t\t{\n\t\t\t// get the time of the status change\n\t\t\t//\n\t\t\tm_statusChangedFlag = true;\n\t\t\tm_statusChangeTime = System.currentTimeMillis();\n\t\t\t\t\n\t\t\t// Is node outage processing disabled? \n\t\t\tif (!PollerConfigFactory.getInstance().nodeOutageProcessingEnabled())\n\t\t\t{\n\t\t\t\t// node outage processing disabled, go ahead and generate\n\t\t\t\t// transition events.\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"poll: node outage disabled, status change will trigger event.\");\n\t\n\t\t\t\t// get the \"qualifier\" property from the properties map if it exists.\n\t\t\t\t// This is mainly used by HTTP at the moment.\n\t\t\t\t//\n\t\t\t\tString qualifier = (String)propertiesMap.get(\"qualifier\");\n\t\n\t\t\t\t// Send the appropriate event\n\t\t\t\t//\n\t\t\t\tswitch(status)\n\t\t\t\t{\n\t\t\t\tcase ServiceMonitor.SERVICE_AVAILABLE: // service up!\n\t\t\t\t\tsendEvent(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI, propertiesMap);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase ServiceMonitor.SERVICE_UNAVAILABLE: // service down!\n\t\t\t\t\tsendEvent(EventConstants.NODE_LOST_SERVICE_EVENT_UEI, propertiesMap);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set the new status\n\t\tm_status = status;\n\t\t\n\t\t// Reset poll immediate flag\n\t\tm_pollImmediate = false;\n\t\t\n\t\t// Reschedule the interface\n\t\t// \n\t\t// NOTE: rescheduling now handled by PollableService.run()\n\t\t//reschedule(false);\n\t\t\t\n\t\treturn m_status;\n\t}","id":25213,"modified_method":"/**\n\t * <P>Invokes a poll of the service via the ServiceMonitor.<\/P>\n\t */\n\tpublic int poll()\n\t{\n\t\tCategory log = ThreadCategory.getInstance(getClass());\n\t\t\n\t\tm_lastPoll = System.currentTimeMillis();\n\t\tm_statusChangedFlag = false;\n\t\tInetAddress addr = (InetAddress)m_pInterface.getAddress();\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"poll: starting new poll for \" + addr.getHostAddress() + \n\t\t\t\t\t\"/\" + m_service.getName() + \"/\" + m_package.getName());\n\t\t\n\t\t// Poll the interface/service pair via the service monitor\n\t\t//\n\t\tint status = ServiceMonitor.SERVICE_UNAVAILABLE;\n\t\tMap propertiesMap = (Map)SVC_PROP_MAP.get(m_svcPropKey);\n\t\ttry\n\t\t{\n\t\t\tstatus = m_monitor.poll(this, propertiesMap, m_package);\n\t\t}\n\t\tcatch(NetworkInterfaceNotSupportedException ex)\n\t\t{\n\t\t\tlog.error(\"poll: Interface \" + addr.getHostAddress() + \" Not Supported!\", ex);\n\t\t\treturn status;\n\t\t}\n\t\tcatch(Throwable t)\n\t\t{\n\t\t\tlog.error(\"poll: An undeclared throwable was caught polling interface \" + addr.getHostAddress(), t);\n\t\t}\n\t\t\n\t\t// serviceUnresponsive behavior disabled?\n                //\n                if (!PollerConfigFactory.getInstance().serviceUnresponsiveEnabled())\n                {\n                        // serviceUnresponsive behavior is disabled, a status\n                        // of SERVICE_UNRESPONSIVE is treated as SERVICE_UNAVAILABLE\n                        if (status == ServiceMonitor.SERVICE_UNRESPONSIVE)\n                                status = ServiceMonitor.SERVICE_UNAVAILABLE;\n                }\n                else\n                {\n\t\t\t// Update unresponsive flag based on latest status\n\t\t\t// returned by the monitor and generate serviceUnresponsive\n\t\t\t// or serviceResponsive event if necessary.\n\t\t\t//\n\t\t\tswitch (status)\n\t\t\t{\n\t\t\t\tcase ServiceMonitor.SERVICE_UNRESPONSIVE: \n\t\t\t\t\t// Check unresponsive flag to determine if we need\n\t\t\t\t\t// to generate a 'serviceUnresponsive' event.\n\t\t\t\t\t//\n\t\t\t\t\tif (m_unresponsiveFlag == false )\n\t\t\t\t\t{\n\t\t\t\t\t\tm_unresponsiveFlag = true;\n\t\t\t\t\t\tsendEvent(EventConstants.SERVICE_UNRESPONSIVE_EVENT_UEI, propertiesMap);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set status back to available, don't want unresponsive \n\t\t\t\t\t\t// service to generate outage\n\t\t\t\t\t\tstatus = ServiceMonitor.SERVICE_AVAILABLE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t\tcase ServiceMonitor.SERVICE_AVAILABLE: \n\t\t\t\t\t// Check unresponsive flag to determine if we\n\t\t\t\t\t// need to generate a 'serviceResponsive' event\n\t\t\t\t\tif (m_unresponsiveFlag == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_unresponsiveFlag = false;\n\t\t\t\t\t\tsendEvent(EventConstants.SERVICE_RESPONSIVE_EVENT_UEI, propertiesMap);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\n\t\t\t\tcase ServiceMonitor.SERVICE_UNAVAILABLE: \n\t\t\t\t\t// Clear unresponsive flag\n\t\t\t\t\tm_unresponsiveFlag = false;\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t// Any change in status?\n\t\t//\n\t\tif(status != m_status)\n\t\t{\n\t\t\t// get the time of the status change\n\t\t\t//\n\t\t\tm_statusChangedFlag = true;\n\t\t\tm_statusChangeTime = System.currentTimeMillis();\n\t\t\t\t\n\t\t\t// Is node outage processing disabled? \n\t\t\tif (!PollerConfigFactory.getInstance().nodeOutageProcessingEnabled())\n\t\t\t{\n\t\t\t\t// node outage processing disabled, go ahead and generate\n\t\t\t\t// transition events.\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"poll: node outage disabled, status change will trigger event.\");\n\t\n\t\t\t\t// get the \"qualifier\" property from the properties map if it exists.\n\t\t\t\t// This is mainly used by HTTP at the moment.\n\t\t\t\t//\n\t\t\t\tString qualifier = (String)propertiesMap.get(\"qualifier\");\n\t\n\t\t\t\t// Send the appropriate event\n\t\t\t\t//\n\t\t\t\tswitch(status)\n\t\t\t\t{\n\t\t\t\tcase ServiceMonitor.SERVICE_AVAILABLE: // service up!\n\t\t\t\t\tsendEvent(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI, propertiesMap);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase ServiceMonitor.SERVICE_UNAVAILABLE: // service down!\n\t\t\t\t\tsendEvent(EventConstants.NODE_LOST_SERVICE_EVENT_UEI, propertiesMap);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set the new status\n\t\tm_status = status;\n\t\t\n\t\t// Reset poll immediate flag\n\t\tm_pollImmediate = false;\n\t\t\n\t\t// Reschedule the interface\n\t\t// \n\t\t// NOTE: rescheduling now handled by PollableService.run()\n\t\t//reschedule(false);\n\t\t\t\n\t\treturn m_status;\n\t}","commit_id":"a6a144ab11a9b78e02e9d8fa45264e3cadd0ca2a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private List<MethodContract> visitLogicalOperation(PsiExpression[] operands, boolean conjunction, List<ValueConstraint[]> states) {\n    ValueConstraint breakValue = conjunction ? FALSE_VALUE : TRUE_VALUE;\n    List<MethodContract> finalStates = ContainerUtil.newArrayList();\n    for (PsiExpression operand : operands) {\n      List<MethodContract> opResults = visitExpression(states, operand);\n      finalStates.addAll(filterReturning(opResults, breakValue));\n      states = antecedentsOf(filterReturning(opResults, negateConstraint(breakValue)));\n    }\n    finalStates.addAll(toContracts(states, negateConstraint(breakValue)));\n    return finalStates;\n  }","id":25214,"modified_method":"private List<MethodContract> visitLogicalOperation(PsiExpression[] operands, boolean conjunction, List<ValueConstraint[]> states) {\n    ValueConstraint breakValue = conjunction ? FALSE_VALUE : TRUE_VALUE;\n    List<MethodContract> finalStates = ContainerUtil.newArrayList();\n    for (PsiExpression operand : operands) {\n      List<MethodContract> opResults = visitExpression(states, operand);\n      finalStates.addAll(ContainerUtil.filter(opResults, contract -> contract.returnValue == breakValue));\n      states = antecedentsReturning(opResults, negateConstraint(breakValue));\n    }\n    finalStates.addAll(toContracts(states, negateConstraint(breakValue)));\n    return finalStates;\n  }","commit_id":"ed8ede7b8a4a3dcb5ffe9d3b1e44f9809106a778","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private List<MethodContract> visitStatements(List<ValueConstraint[]> states, PsiStatement... statements) {\n    List<MethodContract> result = ContainerUtil.newArrayList();\n    for (PsiStatement statement : statements) {\n      if (statement instanceof PsiBlockStatement) {\n        result.addAll(visitStatements(states, ((PsiBlockStatement)statement).getCodeBlock().getStatements()));\n      }\n      else if (statement instanceof PsiIfStatement) {\n        List<MethodContract> conditionResults = visitExpression(states, ((PsiIfStatement)statement).getCondition());\n\n        PsiStatement thenBranch = ((PsiIfStatement)statement).getThenBranch();\n        if (thenBranch != null) {\n          result.addAll(visitStatements(antecedentsOf(filterReturning(conditionResults, TRUE_VALUE)), thenBranch));\n        }\n\n        List<ValueConstraint[]> falseStates = antecedentsOf(filterReturning(conditionResults, FALSE_VALUE));\n        PsiStatement elseBranch = ((PsiIfStatement)statement).getElseBranch();\n        if (elseBranch != null) {\n          result.addAll(visitStatements(falseStates, elseBranch));\n        } else {\n          states = falseStates;\n          continue;\n        }\n      }\n      else if (statement instanceof PsiThrowStatement) {\n        result.addAll(toContracts(states, THROW_EXCEPTION));\n      }\n      else if (statement instanceof PsiReturnStatement) {\n        result.addAll(visitExpression(states, ((PsiReturnStatement)statement).getReturnValue()));\n      }\n      else if (statement instanceof PsiAssertStatement) {\n        List<MethodContract> conditionResults = visitExpression(states, ((PsiAssertStatement)statement).getAssertCondition());\n        result.addAll(toContracts(antecedentsOf(filterReturning(conditionResults, FALSE_VALUE)), THROW_EXCEPTION));\n      }\n      else if (statement instanceof PsiDeclarationStatement && !mayHaveSideEffects((PsiDeclarationStatement)statement)) {\n        continue;\n      }\n      else if (statement instanceof PsiDoWhileStatement) {\n        result.addAll(visitStatements(states, ((PsiDoWhileStatement)statement).getBody()));\n      }\n\n      break; // visit only the first statement unless it's 'if' whose 'then' always returns and the next statement is effectively 'else'\n    }\n    return result;\n  }","id":25215,"modified_method":"@NotNull\n  private List<MethodContract> visitStatements(List<ValueConstraint[]> states, PsiStatement... statements) {\n    List<MethodContract> result = ContainerUtil.newArrayList();\n    for (PsiStatement statement : statements) {\n      if (statement instanceof PsiBlockStatement) {\n        result.addAll(visitStatements(states, ((PsiBlockStatement)statement).getCodeBlock().getStatements()));\n      }\n      else if (statement instanceof PsiIfStatement) {\n        List<MethodContract> conditionResults = visitExpression(states, ((PsiIfStatement)statement).getCondition());\n\n        PsiStatement thenBranch = ((PsiIfStatement)statement).getThenBranch();\n        if (thenBranch != null) {\n          result.addAll(visitStatements(antecedentsReturning(conditionResults, TRUE_VALUE), thenBranch));\n        }\n\n        List<ValueConstraint[]> falseStates = antecedentsReturning(conditionResults, FALSE_VALUE);\n        PsiStatement elseBranch = ((PsiIfStatement)statement).getElseBranch();\n        if (elseBranch != null) {\n          result.addAll(visitStatements(falseStates, elseBranch));\n        } else {\n          states = falseStates;\n          continue;\n        }\n      }\n      else if (statement instanceof PsiThrowStatement) {\n        result.addAll(toContracts(states, THROW_EXCEPTION));\n      }\n      else if (statement instanceof PsiReturnStatement) {\n        result.addAll(visitExpression(states, ((PsiReturnStatement)statement).getReturnValue()));\n      }\n      else if (statement instanceof PsiAssertStatement) {\n        List<MethodContract> conditionResults = visitExpression(states, ((PsiAssertStatement)statement).getAssertCondition());\n        result.addAll(toContracts(antecedentsReturning(conditionResults, FALSE_VALUE), THROW_EXCEPTION));\n      }\n      else if (statement instanceof PsiDeclarationStatement && !mayHaveSideEffects((PsiDeclarationStatement)statement)) {\n        continue;\n      }\n      else if (statement instanceof PsiDoWhileStatement) {\n        result.addAll(visitStatements(states, ((PsiDoWhileStatement)statement).getBody()));\n      }\n\n      break; // visit only the first statement unless it's 'if' whose 'then' always returns and the next statement is effectively 'else'\n    }\n    return result;\n  }","commit_id":"ed8ede7b8a4a3dcb5ffe9d3b1e44f9809106a778","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private List<MethodContract> visitExpression(final List<ValueConstraint[]> states, @Nullable PsiExpression expr) {\n    if (states.isEmpty()) return Collections.emptyList();\n    if (states.size() > 300) return Collections.emptyList(); // too complex\n\n    if (expr instanceof PsiPolyadicExpression) {\n      PsiExpression[] operands = ((PsiPolyadicExpression)expr).getOperands();\n      IElementType op = ((PsiPolyadicExpression)expr).getOperationTokenType();\n      if (operands.length == 2 && (op == JavaTokenType.EQEQ || op == JavaTokenType.NE)) {\n        return visitEqualityComparison(states, operands[0], operands[1], op == JavaTokenType.EQEQ);\n      }\n      if (op == JavaTokenType.ANDAND || op == JavaTokenType.OROR) {\n        return visitLogicalOperation(operands, op == JavaTokenType.ANDAND, states);\n      }\n    }\n\n    if (expr instanceof PsiConditionalExpression) {\n      List<MethodContract> conditionResults = visitExpression(states, ((PsiConditionalExpression)expr).getCondition());\n      return ContainerUtil.concat(\n        visitExpression(antecedentsOf(filterReturning(conditionResults, TRUE_VALUE)), ((PsiConditionalExpression)expr).getThenExpression()),\n        visitExpression(antecedentsOf(filterReturning(conditionResults, FALSE_VALUE)), ((PsiConditionalExpression)expr).getElseExpression()));\n    }\n\n\n    if (expr instanceof PsiParenthesizedExpression) {\n      return visitExpression(states, ((PsiParenthesizedExpression)expr).getExpression());\n    }\n    if (expr instanceof PsiTypeCastExpression) {\n      return visitExpression(states, ((PsiTypeCastExpression)expr).getOperand());\n    }\n\n    if (expr instanceof PsiPrefixExpression && ((PsiPrefixExpression)expr).getOperationTokenType() == JavaTokenType.EXCL) {\n      List<MethodContract> result = ContainerUtil.newArrayList();\n      for (MethodContract contract : visitExpression(states, ((PsiPrefixExpression)expr).getOperand())) {\n        if (contract.returnValue == TRUE_VALUE || contract.returnValue == FALSE_VALUE) {\n          result.add(new MethodContract(contract.arguments, negateConstraint(contract.returnValue)));\n        }\n      }\n      return result;\n    }\n\n    if (expr instanceof PsiInstanceOfExpression) {\n      final int parameter = resolveParameter(((PsiInstanceOfExpression)expr).getOperand());\n      if (parameter >= 0) {\n        return ContainerUtil.mapNotNull(states, state -> contractWithConstraint(state, parameter, NULL_VALUE, FALSE_VALUE));\n      }\n    }\n\n    if (expr instanceof PsiNewExpression) {\n      return toContracts(states, NOT_NULL_VALUE);\n    }\n    if (expr instanceof PsiMethodCallExpression) {\n      PsiMethod method = ((PsiMethodCallExpression)expr).resolveMethod();\n      if (method != null && NullableNotNullManager.isNotNull(method)) {\n        return toContracts(states, NOT_NULL_VALUE);\n      }\n    }\n\n    final ValueConstraint constraint = getLiteralConstraint(expr);\n    if (constraint != null) {\n      return toContracts(states, constraint);\n    }\n\n    int paramIndex = resolveParameter(expr);\n    if (paramIndex >= 0) {\n      List<MethodContract> result = ContainerUtil.newArrayList();\n      for (ValueConstraint[] state : states) {\n        if (state[paramIndex] != ANY_VALUE) {\n          // the second 'o' reference in cases like: if (o != null) return o;\n          result.add(new MethodContract(state, state[paramIndex]));\n        } else if (textMatches(getParameter(paramIndex).getTypeElement(), PsiKeyword.BOOLEAN)) {\n          // if (boolValue) ...\n          ContainerUtil.addIfNotNull(result, contractWithConstraint(state, paramIndex, TRUE_VALUE, TRUE_VALUE));\n          ContainerUtil.addIfNotNull(result, contractWithConstraint(state, paramIndex, FALSE_VALUE, FALSE_VALUE));\n        }\n      }\n      return result;\n    }\n\n    return Collections.emptyList();\n  }","id":25216,"modified_method":"@NotNull\n  private List<MethodContract> visitExpression(final List<ValueConstraint[]> states, @Nullable PsiExpression expr) {\n    if (states.isEmpty()) return Collections.emptyList();\n    if (states.size() > 300) return Collections.emptyList(); // too complex\n\n    if (expr instanceof PsiPolyadicExpression) {\n      PsiExpression[] operands = ((PsiPolyadicExpression)expr).getOperands();\n      IElementType op = ((PsiPolyadicExpression)expr).getOperationTokenType();\n      if (operands.length == 2 && (op == JavaTokenType.EQEQ || op == JavaTokenType.NE)) {\n        return visitEqualityComparison(states, operands[0], operands[1], op == JavaTokenType.EQEQ);\n      }\n      if (op == JavaTokenType.ANDAND || op == JavaTokenType.OROR) {\n        return visitLogicalOperation(operands, op == JavaTokenType.ANDAND, states);\n      }\n    }\n\n    if (expr instanceof PsiConditionalExpression) {\n      List<MethodContract> conditionResults = visitExpression(states, ((PsiConditionalExpression)expr).getCondition());\n      return ContainerUtil.concat(\n        visitExpression(antecedentsReturning(conditionResults, TRUE_VALUE), ((PsiConditionalExpression)expr).getThenExpression()),\n        visitExpression(antecedentsReturning(conditionResults, FALSE_VALUE), ((PsiConditionalExpression)expr).getElseExpression()));\n    }\n\n\n    if (expr instanceof PsiParenthesizedExpression) {\n      return visitExpression(states, ((PsiParenthesizedExpression)expr).getExpression());\n    }\n    if (expr instanceof PsiTypeCastExpression) {\n      return visitExpression(states, ((PsiTypeCastExpression)expr).getOperand());\n    }\n\n    if (expr instanceof PsiPrefixExpression && ((PsiPrefixExpression)expr).getOperationTokenType() == JavaTokenType.EXCL) {\n      List<MethodContract> result = ContainerUtil.newArrayList();\n      for (MethodContract contract : visitExpression(states, ((PsiPrefixExpression)expr).getOperand())) {\n        if (contract.returnValue == TRUE_VALUE || contract.returnValue == FALSE_VALUE) {\n          result.add(new MethodContract(contract.arguments, negateConstraint(contract.returnValue)));\n        }\n      }\n      return result;\n    }\n\n    if (expr instanceof PsiInstanceOfExpression) {\n      final int parameter = resolveParameter(((PsiInstanceOfExpression)expr).getOperand());\n      if (parameter >= 0) {\n        return ContainerUtil.mapNotNull(states, state -> contractWithConstraint(state, parameter, NULL_VALUE, FALSE_VALUE));\n      }\n    }\n\n    if (expr instanceof PsiNewExpression) {\n      return toContracts(states, NOT_NULL_VALUE);\n    }\n    if (expr instanceof PsiMethodCallExpression) {\n      PsiMethod method = ((PsiMethodCallExpression)expr).resolveMethod();\n      if (method != null && NullableNotNullManager.isNotNull(method)) {\n        return toContracts(states, NOT_NULL_VALUE);\n      }\n    }\n\n    final ValueConstraint constraint = getLiteralConstraint(expr);\n    if (constraint != null) {\n      return toContracts(states, constraint);\n    }\n\n    int paramIndex = resolveParameter(expr);\n    if (paramIndex >= 0) {\n      List<MethodContract> result = ContainerUtil.newArrayList();\n      for (ValueConstraint[] state : states) {\n        if (state[paramIndex] != ANY_VALUE) {\n          // the second 'o' reference in cases like: if (o != null) return o;\n          result.add(new MethodContract(state, state[paramIndex]));\n        } else if (textMatches(getParameter(paramIndex).getTypeElement(), PsiKeyword.BOOLEAN)) {\n          // if (boolValue) ...\n          ContainerUtil.addIfNotNull(result, contractWithConstraint(state, paramIndex, TRUE_VALUE, TRUE_VALUE));\n          ContainerUtil.addIfNotNull(result, contractWithConstraint(state, paramIndex, FALSE_VALUE, FALSE_VALUE));\n        }\n      }\n      return result;\n    }\n\n    return Collections.emptyList();\n  }","commit_id":"ed8ede7b8a4a3dcb5ffe9d3b1e44f9809106a778","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<MethodContract> filterReturning(List<MethodContract> values, ValueConstraint result) {\n    return ContainerUtil.filter(values, contract -> contract.returnValue == result);\n  }","id":25217,"modified_method":"private static List<ValueConstraint[]> antecedentsReturning(List<MethodContract> values, ValueConstraint result) {\n    return ContainerUtil.mapNotNull(values, contract -> contract.returnValue == result ? contract.arguments : null);\n  }","commit_id":"ed8ede7b8a4a3dcb5ffe9d3b1e44f9809106a778","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Returns a lazy iterable instance against vertices.\n   *\n   * @param iDirection\n   *          The direction between OUT, IN or BOTH\n   * @param iLabels\n   *          Optional varargs of Strings representing edge label to consider\n   */\n  @Override\n  public Iterable<Vertex> getVertices(final Direction iDirection, final String... iLabels) {\n    setCurrentGraphInThreadLocal();\n\n    OrientBaseGraph.getEdgeClassNames(getGraph(), iLabels);\n    OrientBaseGraph.encodeClassNames(iLabels);\n\n    final ODocument doc = getRecord();\n\n    final OMultiCollectionIterator<Vertex> iterable = new OMultiCollectionIterator<Vertex>();\n    for (String fieldName : doc.fieldNames()) {\n      final OPair<Direction, String> connection = getConnection(iDirection, fieldName, iLabels);\n      if (connection == null)\n        // SKIP THIS FIELD\n        continue;\n\n      final Object fieldValue = doc.field(fieldName);\n      if (fieldValue != null)\n        if (fieldValue instanceof OIdentifiable) {\n          addSingleVertex(doc, iterable, fieldName, connection, fieldValue, iLabels);\n\n        } else if (fieldValue instanceof Collection<?>) {\n          Collection<?> coll = (Collection<?>) fieldValue;\n\n          if (coll.size() == 1) {\n            // SINGLE ITEM: AVOID CALLING ITERATOR\n            if (coll instanceof ORecordLazyMultiValue)\n              addSingleVertex(doc, iterable, fieldName, connection, ((ORecordLazyMultiValue) coll).rawIterator().next(), iLabels);\n            else if (coll instanceof List<?>)\n              addSingleVertex(doc, iterable, fieldName, connection, ((List<?>) coll).get(0), iLabels);\n            else\n              addSingleVertex(doc, iterable, fieldName, connection, coll.iterator().next(), iLabels);\n          } else {\n            // CREATE LAZY Iterable AGAINST COLLECTION FIELD\n            if (coll instanceof ORecordLazyMultiValue)\n              iterable.add(new OrientVertexIterator(this, coll, ((ORecordLazyMultiValue) coll).rawIterator(), connection, iLabels,\n                  coll.size()));\n            else\n              iterable.add(new OrientVertexIterator(this, coll, coll.iterator(), connection, iLabels, -1));\n          }\n        } else if (fieldValue instanceof ORidBag) {\n          iterable.add(new OrientVertexIterator(this, fieldValue, ((ORidBag) fieldValue).rawIterator(), connection, iLabels, -1));\n        }\n    }\n\n    return iterable;\n  }","id":25218,"modified_method":"/**\n   * Returns a lazy iterable instance against vertices.\n   *\n   * @param iDirection\n   *          The direction between OUT, IN or BOTH\n   * @param iLabels\n   *          Optional varargs of Strings representing edge label to consider\n   */\n  @Override\n  public Iterable<Vertex> getVertices(final Direction iDirection, final String... iLabels) {\n    setCurrentGraphInThreadLocal();\n\n    OrientBaseGraph.getEdgeClassNames(getGraph(), iLabels);\n    OrientBaseGraph.encodeClassNames(iLabels);\n\n    final ODocument doc = getRecord();\n\n    final OMultiCollectionIterator<Vertex> iterable = new OMultiCollectionIterator<Vertex>();\n\n    String[] fieldNames = null;\n    if (iLabels != null && iLabels.length > 0) {\n      // EDGE LABELS: CREATE FIELD NAME TABLE (FASTER THAN EXTRACT FIELD NAMES FROM THE DOCUMENT)\n      fieldNames = getFieldNames(iDirection, iLabels);\n\n      if (fieldNames != null)\n        // EARLY FETCH ALL THE FIELDS THAT MATTERS\n        doc.deserializeFields(fieldNames);\n    }\n\n    if (fieldNames == null)\n      fieldNames = doc.fieldNames();\n\n    for (String fieldName : fieldNames) {\n      final OPair<Direction, String> connection = getConnection(iDirection, fieldName, iLabels);\n      if (connection == null)\n        // SKIP THIS FIELD\n        continue;\n\n      final Object fieldValue = doc.rawField(fieldName);\n      if (fieldValue != null)\n        if (fieldValue instanceof OIdentifiable) {\n          addSingleVertex(doc, iterable, fieldName, connection, fieldValue, iLabels);\n\n        } else if (fieldValue instanceof Collection<?>) {\n          Collection<?> coll = (Collection<?>) fieldValue;\n\n          if (coll.size() == 1) {\n            // SINGLE ITEM: AVOID CALLING ITERATOR\n            if (coll instanceof ORecordLazyMultiValue)\n              addSingleVertex(doc, iterable, fieldName, connection, ((ORecordLazyMultiValue) coll).rawIterator().next(), iLabels);\n            else if (coll instanceof List<?>)\n              addSingleVertex(doc, iterable, fieldName, connection, ((List<?>) coll).get(0), iLabels);\n            else\n              addSingleVertex(doc, iterable, fieldName, connection, coll.iterator().next(), iLabels);\n          } else {\n            // CREATE LAZY Iterable AGAINST COLLECTION FIELD\n            if (coll instanceof ORecordLazyMultiValue)\n              iterable.add(new OrientVertexIterator(this, coll, ((ORecordLazyMultiValue) coll).rawIterator(), connection, iLabels,\n                  coll.size()));\n            else\n              iterable.add(new OrientVertexIterator(this, coll, coll.iterator(), connection, iLabels, -1));\n          }\n        } else if (fieldValue instanceof ORidBag) {\n          iterable.add(new OrientVertexIterator(this, fieldValue, ((ORidBag) fieldValue).rawIterator(), connection, iLabels, -1));\n        }\n    }\n\n    return iterable;\n  }","commit_id":"9bfea13c783dbe25a590ac4452f0bf021afab17e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * (Blueprints Extension) Returns all the edges from the current Vertex to another one.\n   *\n   * @param iDestination\n   *          The target vertex\n   * @param iDirection\n   *          The direction between OUT, IN or BOTH\n   * @param iLabels\n   *          Optional labels as Strings to consider\n   * @return\n   */\n  public Iterable<Edge> getEdges(final OrientVertex iDestination, final Direction iDirection, final String... iLabels) {\n\n    setCurrentGraphInThreadLocal();\n\n    final ODocument doc = getRecord();\n\n    OrientBaseGraph.getEdgeClassNames(getGraph(), iLabels);\n    OrientBaseGraph.encodeClassNames(iLabels);\n\n    final OMultiCollectionIterator<Edge> iterable = new OMultiCollectionIterator<Edge>().setEmbedded(true);\n    for (String fieldName : doc.fieldNames()) {\n      final OPair<Direction, String> connection = getConnection(iDirection, fieldName, iLabels);\n      if (connection == null)\n        // SKIP THIS FIELD\n        continue;\n\n      final Object fieldValue = doc.field(fieldName);\n      if (fieldValue != null) {\n        final OIdentifiable destinationVId = iDestination != null ? (OIdentifiable) iDestination.getId() : null;\n\n        if (fieldValue instanceof OIdentifiable) {\n          addSingleEdge(doc, iterable, fieldName, connection, fieldValue, destinationVId, iLabels);\n\n        } else if (fieldValue instanceof Collection<?>) {\n          Collection<?> coll = (Collection<?>) fieldValue;\n\n          if (coll.size() == 1) {\n            // SINGLE ITEM: AVOID CALLING ITERATOR\n            if (coll instanceof ORecordLazyMultiValue)\n              addSingleEdge(doc, iterable, fieldName, connection, ((ORecordLazyMultiValue) coll).rawIterator().next(),\n                  destinationVId, iLabels);\n            else if (coll instanceof List<?>)\n              addSingleEdge(doc, iterable, fieldName, connection, ((List<?>) coll).get(0), destinationVId, iLabels);\n            else\n              addSingleEdge(doc, iterable, fieldName, connection, coll.iterator().next(), destinationVId, iLabels);\n          } else {\n            // CREATE LAZY Iterable AGAINST COLLECTION FIELD\n            if (coll instanceof ORecordLazyMultiValue) {\n              iterable.add(new OrientEdgeIterator(this, iDestination, coll, ((ORecordLazyMultiValue) coll).rawIterator(),\n                  connection, iLabels, coll.size()));\n            } else\n              iterable.add(new OrientEdgeIterator(this, iDestination, coll, coll.iterator(), connection, iLabels, -1));\n          }\n        } else if (fieldValue instanceof ORidBag) {\n          iterable.add(new OrientEdgeIterator(this, iDestination, fieldValue, ((ORidBag) fieldValue).rawIterator(), connection,\n              iLabels, ((ORidBag) fieldValue).size()));\n        }\n      }\n    }\n\n    return iterable;\n  }","id":25219,"modified_method":"/**\n   * (Blueprints Extension) Returns all the edges from the current Vertex to another one.\n   *\n   * @param iDestination\n   *          The target vertex\n   * @param iDirection\n   *          The direction between OUT, IN or BOTH\n   * @param iLabels\n   *          Optional labels as Strings to consider\n   * @return\n   */\n  public Iterable<Edge> getEdges(final OrientVertex iDestination, final Direction iDirection, final String... iLabels) {\n\n    setCurrentGraphInThreadLocal();\n\n    final ODocument doc = getRecord();\n\n    OrientBaseGraph.getEdgeClassNames(getGraph(), iLabels);\n    OrientBaseGraph.encodeClassNames(iLabels);\n\n    final OMultiCollectionIterator<Edge> iterable = new OMultiCollectionIterator<Edge>().setEmbedded(true);\n\n    String[] fieldNames = null;\n    if (iLabels != null && iLabels.length > 0) {\n      // EDGE LABELS: CREATE FIELD NAME TABLE (FASTER THAN EXTRACT FIELD NAMES FROM THE DOCUMENT)\n      fieldNames = getFieldNames(iDirection, iLabels);\n\n      if (fieldNames != null)\n        // EARLY FETCH ALL THE FIELDS THAT MATTERS\n        doc.deserializeFields(fieldNames);\n    }\n\n    if (fieldNames == null)\n      fieldNames = doc.fieldNames();\n\n    for (String fieldName : fieldNames) {\n      final OPair<Direction, String> connection = getConnection(iDirection, fieldName, iLabels);\n      if (connection == null)\n        // SKIP THIS FIELD\n        continue;\n\n      final Object fieldValue = doc.rawField(fieldName);\n      if (fieldValue != null) {\n        final OIdentifiable destinationVId = iDestination != null ? (OIdentifiable) iDestination.getId() : null;\n\n        if (fieldValue instanceof OIdentifiable) {\n          addSingleEdge(doc, iterable, fieldName, connection, fieldValue, destinationVId, iLabels);\n\n        } else if (fieldValue instanceof Collection<?>) {\n          Collection<?> coll = (Collection<?>) fieldValue;\n\n          if (coll.size() == 1) {\n            // SINGLE ITEM: AVOID CALLING ITERATOR\n            if (coll instanceof ORecordLazyMultiValue)\n              addSingleEdge(doc, iterable, fieldName, connection, ((ORecordLazyMultiValue) coll).rawIterator().next(),\n                  destinationVId, iLabels);\n            else if (coll instanceof List<?>)\n              addSingleEdge(doc, iterable, fieldName, connection, ((List<?>) coll).get(0), destinationVId, iLabels);\n            else\n              addSingleEdge(doc, iterable, fieldName, connection, coll.iterator().next(), destinationVId, iLabels);\n          } else {\n            // CREATE LAZY Iterable AGAINST COLLECTION FIELD\n            if (coll instanceof ORecordLazyMultiValue) {\n              iterable.add(new OrientEdgeIterator(this, iDestination, coll, ((ORecordLazyMultiValue) coll).rawIterator(),\n                  connection, iLabels, coll.size()));\n            } else\n              iterable.add(new OrientEdgeIterator(this, iDestination, coll, coll.iterator(), connection, iLabels, -1));\n          }\n        } else if (fieldValue instanceof ORidBag) {\n          iterable.add(new OrientEdgeIterator(this, iDestination, fieldValue, ((ORidBag) fieldValue).rawIterator(), connection,\n              iLabels, ((ORidBag) fieldValue).size()));\n        }\n      }\n    }\n\n    return iterable;\n  }","commit_id":"9bfea13c783dbe25a590ac4452f0bf021afab17e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private FieldSelector buildFieldSelectors(SearchContext context) {\n        if (context.fieldNames() == null || context.fieldNames().length == 0) {\n            return new UidAndSourceFieldSelector();\n        }\n\n        FieldMappersFieldSelector fieldSelector = new FieldMappersFieldSelector();\n        for (String fieldName : context.fieldNames()) {\n            FieldMappers x = context.mapperService().smartNameFieldMappers(fieldName);\n            if (x == null) {\n                throw new FetchPhaseExecutionException(context, \"No mapping for field [\" + fieldName + \"]\");\n            }\n            fieldSelector.add(x);\n        }\n        fieldSelector.add(context.mapperService().uidFieldMappers());\n        return fieldSelector;\n    }","id":25220,"modified_method":"private FieldSelector buildFieldSelectors(SearchContext context) {\n        if (context.fieldNames() == null) {\n            return new UidAndSourceFieldSelector();\n        }\n\n        FieldMappersFieldSelector fieldSelector = new FieldMappersFieldSelector();\n        for (String fieldName : context.fieldNames()) {\n            FieldMappers x = context.mapperService().smartNameFieldMappers(fieldName);\n            if (x == null) {\n                throw new FetchPhaseExecutionException(context, \"No mapping for field [\" + fieldName + \"]\");\n            }\n            fieldSelector.add(x);\n        }\n        fieldSelector.add(context.mapperService().uidFieldMappers());\n        return fieldSelector;\n    }","commit_id":"4b04db903075a84df34c1b847951a58bff058b6d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void parse(JsonParser jp, SearchContext context) throws Exception {\n        JsonToken token = jp.getCurrentToken();\n        if (token == JsonToken.START_ARRAY) {\n            jp.nextToken();\n            ArrayList<String> fieldNames = new ArrayList<String>();\n            do {\n                fieldNames.add(jp.getText());\n            } while ((token = jp.nextToken()) != JsonToken.END_ARRAY);\n            context.fieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n        } else if (token == JsonToken.VALUE_STRING) {\n            context.fieldNames(new String[]{jp.getText()});\n        }\n    }","id":25221,"modified_method":"@Override public void parse(JsonParser jp, SearchContext context) throws Exception {\n        JsonToken token = jp.getCurrentToken();\n        if (token == JsonToken.START_ARRAY) {\n            ArrayList<String> fieldNames = new ArrayList<String>();\n            while ((token = jp.nextToken()) != JsonToken.END_ARRAY) {\n                fieldNames.add(jp.getText());\n            }\n            if (fieldNames.isEmpty()) {\n                context.fieldNames(Strings.EMPTY_ARRAY);\n            } else {\n                context.fieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n            }\n        } else if (token == JsonToken.VALUE_STRING) {\n            context.fieldNames(new String[]{jp.getText()});\n        }\n    }","commit_id":"4b04db903075a84df34c1b847951a58bff058b6d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public PyRequirement(@NotNull String name, @Nullable String version, @NotNull String url, boolean editable) {\n    myName = name;\n    if (version != null) {\n      myVersionSpecs = Collections.singletonList(new PyRequirementVersionSpec(PyRequirementRelation.EQ, version));\n    }\n    else {\n      myVersionSpecs = Collections.emptyList();\n    }\n    myOptions = url;\n  }","id":25222,"modified_method":"public PyRequirement(@NotNull String name, @NotNull String version, @NotNull String options) {\n    this(name, Collections.singletonList(calculateVersionSpec(version, PyRequirementRelation.EQ)), options);\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyRequirement(@NotNull String name, @NotNull String version) {\n    this(name, Collections.singletonList(new PyRequirementVersionSpec(PyRequirementRelation.EQ, version)));\n  }","id":25223,"modified_method":"public PyRequirement(@NotNull String name, @NotNull String version) {\n    this(name, Collections.singletonList(calculateVersionSpec(version, PyRequirementRelation.EQ)));\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyRequirement(@NotNull String name) {\n    this(name, Collections.<PyRequirementVersionSpec>emptyList());\n  }","id":25224,"modified_method":"public PyRequirement(@NotNull String name) {\n    this(name, Collections.emptyList());\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PyRequirement parseRequirement(@NotNull String line) {\n    final Matcher matcher = REQUIREMENT.matcher(line);\n    if (matcher.matches()) {\n      return new PyRequirement(matcher.group(NAME_GROUP), line, parseVersionSpecs(matcher.group(VERSIONS_SPECS_GROUP)));\n    }\n\n    return null;\n  }","id":25225,"modified_method":"@Nullable\n  private static PyRequirement parseRequirement(@NotNull String line) {\n    final Matcher matcher = REQUIREMENT.matcher(line);\n    if (matcher.matches()) {\n      return new PyRequirement(matcher.group(NAME_GROUP), parseVersionSpecs(matcher.group(VERSIONS_SPECS_GROUP)), line);\n    }\n\n    return null;\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static PyRequirement createVcsOrArchiveRequirement(@NotNull String line, @NotNull Pair<String, String> nameAndVersion) {\n    final String name = nameAndVersion.getFirst();\n    final String version = nameAndVersion.getSecond();\n\n    if (version == null) {\n      return new PyRequirement(name, line, Collections.emptyList());\n    }\n\n    final String normalizedVersion = PyRequirementVersionNormalizer.normalize(version);\n    final PyRequirementVersionSpec versionSpec = normalizedVersion == null ?\n                                                 new PyRequirementVersionSpec(PyRequirementRelation.STR_EQ, version) :\n                                                 new PyRequirementVersionSpec(PyRequirementRelation.EQ, normalizedVersion);\n\n    return new PyRequirement(name, line, Collections.singletonList(versionSpec));\n  }","id":25226,"modified_method":"@NotNull\n  private static PyRequirement createVcsOrArchiveRequirement(@NotNull String line, @NotNull Pair<String, String> nameAndVersion) {\n    final String name = nameAndVersion.getFirst();\n    final String version = nameAndVersion.getSecond();\n\n    if (version == null) {\n      return new PyRequirement(name, Collections.emptyList(), line);\n    }\n\n    return new PyRequirement(name, Collections.singletonList(calculateVersionSpec(version, PyRequirementRelation.EQ)), line);\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PyRequirement parseGithubArchiveUrl(@NotNull String line) {\n    final Matcher matcher = GITHUB_ARCHIVE_URL.matcher(line);\n\n    if (matcher.matches()) {\n      return new PyRequirement(matcher.group(NAME_GROUP), line, Collections.emptyList());\n    }\n\n    return null;\n  }","id":25227,"modified_method":"@Nullable\n  private static PyRequirement parseGithubArchiveUrl(@NotNull String line) {\n    final Matcher matcher = GITHUB_ARCHIVE_URL.matcher(line);\n\n    if (matcher.matches()) {\n      return new PyRequirement(matcher.group(NAME_GROUP), Collections.emptyList(), line);\n    }\n\n    return null;\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyRequirement(@NotNull String name, @NotNull String options, @NotNull List<PyRequirementVersionSpec> versionSpecs) {\n    myName = name;\n    myOptions = options;\n    myVersionSpecs = versionSpecs;\n  }","id":25228,"modified_method":"public PyRequirement(@NotNull String name, @NotNull List<PyRequirementVersionSpec> versionSpecs, @NotNull String options) {\n    myName = name;\n    myVersionSpecs = versionSpecs;\n    myOptions = options;\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PyRequirementVersionSpec parseVersionSpec(@NotNull String versionSpec) {\n    PyRequirementRelation relation = null;\n\n    if (versionSpec.startsWith(\"===\")) {\n      relation = PyRequirementRelation.STR_EQ;\n    }\n    else if (versionSpec.startsWith(\"==\")) {\n      relation = PyRequirementRelation.EQ;\n    }\n    else if (versionSpec.startsWith(\"<=\")) {\n      relation = PyRequirementRelation.LTE;\n    }\n    else if (versionSpec.startsWith(\">=\")) {\n      relation = PyRequirementRelation.GTE;\n    }\n    else if (versionSpec.startsWith(\"<\")) {\n      relation = PyRequirementRelation.LT;\n    }\n    else if (versionSpec.startsWith(\">\")) {\n      relation = PyRequirementRelation.GT;\n    }\n    else if (versionSpec.startsWith(\"~=\")) {\n      relation = PyRequirementRelation.COMPATIBLE;\n    }\n    else if (versionSpec.startsWith(\"!=\")) {\n      relation = PyRequirementRelation.NE;\n    }\n\n    if (relation != null) {\n      final int versionIndex = findFirstNotWhiteSpace(versionSpec, relation.toString().length());\n      final String version = versionSpec.substring(versionIndex);\n\n      if (relation == PyRequirementRelation.STR_EQ) {\n        return new PyRequirementVersionSpec(relation, version);\n      }\n\n      final String normalizedVersion = PyRequirementVersionNormalizer.normalize(version);\n\n      if (normalizedVersion == null) {\n        return new PyRequirementVersionSpec(PyRequirementRelation.STR_EQ, version);\n      } else {\n        return new PyRequirementVersionSpec(relation, normalizedVersion);\n      }\n    }\n\n    return null;\n  }","id":25229,"modified_method":"@Nullable\n  private static PyRequirementVersionSpec parseVersionSpec(@NotNull String versionSpec) {\n    PyRequirementRelation relation = null;\n\n    if (versionSpec.startsWith(\"===\")) {\n      relation = PyRequirementRelation.STR_EQ;\n    }\n    else if (versionSpec.startsWith(\"==\")) {\n      relation = PyRequirementRelation.EQ;\n    }\n    else if (versionSpec.startsWith(\"<=\")) {\n      relation = PyRequirementRelation.LTE;\n    }\n    else if (versionSpec.startsWith(\">=\")) {\n      relation = PyRequirementRelation.GTE;\n    }\n    else if (versionSpec.startsWith(\"<\")) {\n      relation = PyRequirementRelation.LT;\n    }\n    else if (versionSpec.startsWith(\">\")) {\n      relation = PyRequirementRelation.GT;\n    }\n    else if (versionSpec.startsWith(\"~=\")) {\n      relation = PyRequirementRelation.COMPATIBLE;\n    }\n    else if (versionSpec.startsWith(\"!=\")) {\n      relation = PyRequirementRelation.NE;\n    }\n\n    if (relation != null) {\n      final int versionIndex = findFirstNotWhiteSpace(versionSpec, relation.toString().length());\n      final String version = versionSpec.substring(versionIndex);\n\n      if (relation == PyRequirementRelation.STR_EQ) {\n        return new PyRequirementVersionSpec(relation, version);\n      }\n\n      return calculateVersionSpec(version, relation);\n    }\n\n    return null;\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testArchiveUrlWithSha512() {\n    final String url = \"https://pypi.python.org/packages/source/g/geoip2/geoip2-2.2.0.tar.gz#sha512=26259d212447bc840400c25a48275fbc\";\n\n    assertEquals(new PyRequirement(\"geoip2\", \"2.2.0\", url, false), PyRequirement.fromString(url));\n  }","id":25230,"modified_method":"public void testArchiveUrlWithSha512() {\n    final String url = \"https://pypi.python.org/packages/source/g/geoip2/geoip2-2.2.0.tar.gz#sha512=26259d212447bc840400c25a48275fbc\";\n\n    assertEquals(new PyRequirement(\"geoip2\", \"2.2.0\", url), PyRequirement.fromString(url));\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testArchiveUrl() {\n    final String url = \"https://pypi.python.org/packages/source/g/geoip2/geoip2-2.2.0.tar.gz\";\n\n    assertEquals(new PyRequirement(\"geoip2\", \"2.2.0\", url, false), PyRequirement.fromString(url));\n  }","id":25231,"modified_method":"public void testArchiveUrl() {\n    final String url = \"https://pypi.python.org/packages/source/g/geoip2/geoip2-2.2.0.tar.gz\";\n\n    assertEquals(new PyRequirement(\"geoip2\", \"2.2.0\", url), PyRequirement.fromString(url));\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doTest(@NotNull String options) {\n    doTest(options, false);\n  }","id":25232,"modified_method":"private static void doTest(@NotNull String options) {\n    assertEquals(new PyRequirement(\"MyProject1\", Collections.emptyList(), options), PyRequirement.fromString(options));\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testEditableBazaar() {\n    doTest(\"-e bzr+http://bzr.myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+http://bzr.myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"-e bzr+http://bzr.myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+http://bzr.myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"-e bzr+https://bzr.myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+https://bzr.myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"-e bzr+https://bzr.myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+https://bzr.myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"-e bzr+sftp://myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+sftp://myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"-e bzr+sftp://myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+sftp://myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"-e bzr+sftp://user@myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+sftp://user@myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"-e bzr+sftp://user@myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+sftp://user@myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"-e bzr+ssh://myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+ssh://myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"-e bzr+ssh://myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+ssh://myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"-e bzr+ssh://user@myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+ssh://user@myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"-e bzr+ssh://user@myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+ssh://user@myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"-e bzr+ftp://myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+ftp://myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"-e bzr+ftp://myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+ftp://myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"-e bzr+ftp://user@myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+ftp://user@myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"-e bzr+ftp://user@myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e bzr+ftp://user@myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"-e bzr+lp:MyProject#egg=MyProject1\", true);\n\n    doTest(\"--editable bzr+http://bzr.myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+http://bzr.myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"--editable bzr+http://bzr.myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+http://bzr.myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"--editable bzr+https://bzr.myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+https://bzr.myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"--editable bzr+https://bzr.myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+https://bzr.myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"--editable bzr+sftp://myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+sftp://myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"--editable bzr+sftp://myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+sftp://myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"--editable bzr+sftp://user@myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+sftp://user@myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"--editable bzr+sftp://user@myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+sftp://user@myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"--editable bzr+ssh://myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+ssh://myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"--editable bzr+ssh://myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+ssh://myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"--editable bzr+ssh://user@myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+ssh://user@myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"--editable bzr+ssh://user@myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+ssh://user@myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"--editable bzr+ftp://myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+ftp://myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"--editable bzr+ftp://myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+ftp://myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"--editable bzr+ftp://user@myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+ftp://user@myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"--editable bzr+ftp://user@myproject.org/path/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable bzr+ftp://user@myproject.org/path/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"--editable bzr+lp:MyProject#egg=MyProject1\", true);\n  }","id":25233,"modified_method":"public void testEditableBazaar() {\n    doTest(\"-e bzr+http://bzr.myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+http://bzr.myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"-e bzr+http://bzr.myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+http://bzr.myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"-e bzr+https://bzr.myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+https://bzr.myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"-e bzr+https://bzr.myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+https://bzr.myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"-e bzr+sftp://myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+sftp://myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"-e bzr+sftp://myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+sftp://myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"-e bzr+sftp://user@myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+sftp://user@myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"-e bzr+sftp://user@myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+sftp://user@myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"-e bzr+ssh://myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+ssh://myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"-e bzr+ssh://myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+ssh://myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"-e bzr+ssh://user@myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+ssh://user@myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"-e bzr+ssh://user@myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+ssh://user@myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"-e bzr+ftp://myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+ftp://myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"-e bzr+ftp://myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+ftp://myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"-e bzr+ftp://user@myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+ftp://user@myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"-e bzr+ftp://user@myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e bzr+ftp://user@myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"-e bzr+lp:MyProject#egg=MyProject1\");\n\n    doTest(\"--editable bzr+http://bzr.myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+http://bzr.myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"--editable bzr+http://bzr.myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+http://bzr.myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"--editable bzr+https://bzr.myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+https://bzr.myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"--editable bzr+https://bzr.myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+https://bzr.myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"--editable bzr+sftp://myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+sftp://myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"--editable bzr+sftp://myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+sftp://myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"--editable bzr+sftp://user@myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+sftp://user@myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"--editable bzr+sftp://user@myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+sftp://user@myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"--editable bzr+ssh://myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+ssh://myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"--editable bzr+ssh://myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+ssh://myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"--editable bzr+ssh://user@myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+ssh://user@myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"--editable bzr+ssh://user@myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+ssh://user@myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"--editable bzr+ftp://myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+ftp://myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"--editable bzr+ftp://myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+ftp://myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"--editable bzr+ftp://user@myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+ftp://user@myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"--editable bzr+ftp://user@myproject.org/path/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable bzr+ftp://user@myproject.org/path/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"--editable bzr+lp:MyProject#egg=MyProject1\");\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doRequirementRelationTest(@NotNull String name,\n                                                @Nullable String extras,\n                                                @NotNull List<PyRequirementRelation> relations,\n                                                @NotNull List<String> versions) {\n    assertEquals(versions.size(), relations.size());\n\n    final StringBuilder sb = new StringBuilder(name);\n    final List<PyRequirementVersionSpec> expectedVersionSpecs = new ArrayList<>();\n\n    if (extras != null) sb.append(extras);\n    final int initialLength = sb.length();\n\n    for (Pair<PyRequirementRelation, String> pair : ContainerUtil.zip(relations, versions)) {\n      final PyRequirementRelation relation = pair.getFirst();\n      final String version = pair.getSecond();\n\n      sb.append(relation).append(version).append(\",\");\n      expectedVersionSpecs.add(new PyRequirementVersionSpec(relation, version));\n    }\n\n    if (sb.length() != initialLength) {\n      sb.setLength(sb.length() - 1);\n    }\n\n    final String options = sb.toString();\n\n    assertEquals(new PyRequirement(name, options, expectedVersionSpecs), PyRequirement.fromString(options));\n  }","id":25234,"modified_method":"private static void doRequirementRelationTest(@NotNull String name,\n                                                @Nullable String extras,\n                                                @NotNull List<PyRequirementRelation> relations,\n                                                @NotNull List<String> versions) {\n    assertEquals(versions.size(), relations.size());\n\n    final StringBuilder sb = new StringBuilder(name);\n    final List<PyRequirementVersionSpec> expectedVersionSpecs = new ArrayList<>();\n\n    if (extras != null) sb.append(extras);\n    final int initialLength = sb.length();\n\n    for (Pair<PyRequirementRelation, String> pair : ContainerUtil.zip(relations, versions)) {\n      final PyRequirementRelation relation = pair.getFirst();\n      final String version = pair.getSecond();\n\n      sb.append(relation).append(version).append(\",\");\n      expectedVersionSpecs.add(new PyRequirementVersionSpec(relation, version));\n    }\n\n    if (sb.length() != initialLength) {\n      sb.setLength(sb.length() - 1);\n    }\n\n    final String options = sb.toString();\n\n    assertEquals(new PyRequirement(name, expectedVersionSpecs, options), PyRequirement.fromString(options));\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testArchiveUrlWithSha224() {\n    final String url = \"https://pypi.python.org/packages/source/g/geoip2/geoip2-2.2.0.tar.gz#sha224=26259d212447bc840400c25a48275fbc\";\n\n    assertEquals(new PyRequirement(\"geoip2\", \"2.2.0\", url, false), PyRequirement.fromString(url));\n  }","id":25235,"modified_method":"public void testArchiveUrlWithSha224() {\n    final String url = \"https://pypi.python.org/packages/source/g/geoip2/geoip2-2.2.0.tar.gz#sha224=26259d212447bc840400c25a48275fbc\";\n\n    assertEquals(new PyRequirement(\"geoip2\", \"2.2.0\", url), PyRequirement.fromString(url));\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testEditableSubversion() {\n    doTest(\"-e svn+http://svn.myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e svn+http://svn.myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"-e svn+http://svn.myproject.org/svn/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e svn+http://svn.myproject.org/svn/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"-e svn+https://svn.myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e svn+https://svn.myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"-e svn+https://svn.myproject.org/svn/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"-e svn+https://svn.myproject.org/svn/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"-e svn+ssh://svn.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"-e svn+ssh://svn.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e svn+ssh://svn.myproject.org/svn/MyProject#egg=MyProject1\", true);\n    doTest(\"-e svn+ssh://svn.myproject.org/svn/MyProject/#egg=MyProject1\", true);\n\n    doTest(\"-e svn+ssh://user@svn.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"-e svn+ssh://user@svn.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e svn+ssh://user@svn.myproject.org/svn/MyProject#egg=MyProject1\", true);\n    doTest(\"-e svn+ssh://user@svn.myproject.org/svn/MyProject/#egg=MyProject1\", true);\n\n    doTest(\"-e svn+svn://svn.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"-e svn+svn://svn.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e svn+svn://svn.myproject.org/svn/MyProject#egg=MyProject1\", true);\n    doTest(\"-e svn+svn://svn.myproject.org/svn/MyProject/#egg=MyProject1\", true);\n\n    doTest(\"-e svn+svn://user@svn.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"-e svn+svn://user@svn.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e svn+svn://user@svn.myproject.org/svn/MyProject#egg=MyProject1\", true);\n    doTest(\"-e svn+svn://user@svn.myproject.org/svn/MyProject/#egg=MyProject1\", true);\n\n    doTest(\"--editable svn+http://svn.myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable svn+http://svn.myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"--editable svn+http://svn.myproject.org/svn/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable svn+http://svn.myproject.org/svn/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"--editable svn+https://svn.myproject.org/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable svn+https://svn.myproject.org/MyProject/trunk/#egg=MyProject1\", true);\n    doTest(\"--editable svn+https://svn.myproject.org/svn/MyProject/trunk#egg=MyProject1\", true);\n    doTest(\"--editable svn+https://svn.myproject.org/svn/MyProject/trunk/#egg=MyProject1\", true);\n\n    doTest(\"--editable svn+ssh://svn.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable svn+ssh://svn.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable svn+ssh://svn.myproject.org/svn/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable svn+ssh://svn.myproject.org/svn/MyProject/#egg=MyProject1\", true);\n\n    doTest(\"--editable svn+ssh://user@svn.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable svn+ssh://user@svn.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable svn+ssh://user@svn.myproject.org/svn/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable svn+ssh://user@svn.myproject.org/svn/MyProject/#egg=MyProject1\", true);\n\n    doTest(\"--editable svn+svn://svn.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable svn+svn://svn.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable svn+svn://svn.myproject.org/svn/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable svn+svn://svn.myproject.org/svn/MyProject/#egg=MyProject1\", true);\n\n    doTest(\"--editable svn+svn://user@svn.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable svn+svn://user@svn.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable svn+svn://user@svn.myproject.org/svn/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable svn+svn://user@svn.myproject.org/svn/MyProject/#egg=MyProject1\", true);\n  }","id":25236,"modified_method":"public void testEditableSubversion() {\n    doTest(\"-e svn+http://svn.myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e svn+http://svn.myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"-e svn+http://svn.myproject.org/svn/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e svn+http://svn.myproject.org/svn/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"-e svn+https://svn.myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e svn+https://svn.myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"-e svn+https://svn.myproject.org/svn/MyProject/trunk#egg=MyProject1\");\n    doTest(\"-e svn+https://svn.myproject.org/svn/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"-e svn+ssh://svn.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"-e svn+ssh://svn.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"-e svn+ssh://svn.myproject.org/svn/MyProject#egg=MyProject1\");\n    doTest(\"-e svn+ssh://svn.myproject.org/svn/MyProject/#egg=MyProject1\");\n\n    doTest(\"-e svn+ssh://user@svn.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"-e svn+ssh://user@svn.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"-e svn+ssh://user@svn.myproject.org/svn/MyProject#egg=MyProject1\");\n    doTest(\"-e svn+ssh://user@svn.myproject.org/svn/MyProject/#egg=MyProject1\");\n\n    doTest(\"-e svn+svn://svn.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"-e svn+svn://svn.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"-e svn+svn://svn.myproject.org/svn/MyProject#egg=MyProject1\");\n    doTest(\"-e svn+svn://svn.myproject.org/svn/MyProject/#egg=MyProject1\");\n\n    doTest(\"-e svn+svn://user@svn.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"-e svn+svn://user@svn.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"-e svn+svn://user@svn.myproject.org/svn/MyProject#egg=MyProject1\");\n    doTest(\"-e svn+svn://user@svn.myproject.org/svn/MyProject/#egg=MyProject1\");\n\n    doTest(\"--editable svn+http://svn.myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable svn+http://svn.myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"--editable svn+http://svn.myproject.org/svn/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable svn+http://svn.myproject.org/svn/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"--editable svn+https://svn.myproject.org/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable svn+https://svn.myproject.org/MyProject/trunk/#egg=MyProject1\");\n    doTest(\"--editable svn+https://svn.myproject.org/svn/MyProject/trunk#egg=MyProject1\");\n    doTest(\"--editable svn+https://svn.myproject.org/svn/MyProject/trunk/#egg=MyProject1\");\n\n    doTest(\"--editable svn+ssh://svn.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"--editable svn+ssh://svn.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"--editable svn+ssh://svn.myproject.org/svn/MyProject#egg=MyProject1\");\n    doTest(\"--editable svn+ssh://svn.myproject.org/svn/MyProject/#egg=MyProject1\");\n\n    doTest(\"--editable svn+ssh://user@svn.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"--editable svn+ssh://user@svn.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"--editable svn+ssh://user@svn.myproject.org/svn/MyProject#egg=MyProject1\");\n    doTest(\"--editable svn+ssh://user@svn.myproject.org/svn/MyProject/#egg=MyProject1\");\n\n    doTest(\"--editable svn+svn://svn.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"--editable svn+svn://svn.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"--editable svn+svn://svn.myproject.org/svn/MyProject#egg=MyProject1\");\n    doTest(\"--editable svn+svn://svn.myproject.org/svn/MyProject/#egg=MyProject1\");\n\n    doTest(\"--editable svn+svn://user@svn.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"--editable svn+svn://user@svn.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"--editable svn+svn://user@svn.myproject.org/svn/MyProject#egg=MyProject1\");\n    doTest(\"--editable svn+svn://user@svn.myproject.org/svn/MyProject/#egg=MyProject1\");\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testArchiveUrlWithMd5() {\n    final String url = \"https://pypi.python.org/packages/source/g/geoip2/geoip2-2.2.0.tar.gz#md5=26259d212447bc840400c25a48275fbc\";\n\n    assertEquals(new PyRequirement(\"geoip2\", \"2.2.0\", url, false), PyRequirement.fromString(url));\n  }","id":25237,"modified_method":"public void testArchiveUrlWithMd5() {\n    final String url = \"https://pypi.python.org/packages/source/g/geoip2/geoip2-2.2.0.tar.gz#md5=26259d212447bc840400c25a48275fbc\";\n\n    assertEquals(new PyRequirement(\"geoip2\", \"2.2.0\", url), PyRequirement.fromString(url));\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testDevInRequirementEggName() {\n    final String options1 = \"git://github.com/toastdriven/django-haystack.git#egg=django_haystack-dev\";\n    assertEquals(new PyRequirement(\"django-haystack\", \"dev\", options1, true), PyRequirement.fromString(options1));\n\n    final String options2 = \"git://github.com/toastdriven/django-haystack.git#egg=django-haystack-dev\";\n    assertEquals(new PyRequirement(\"django-haystack\", \"dev\", options2, true), PyRequirement.fromString(options2));\n  }","id":25238,"modified_method":"public void testDevInRequirementEggName() {\n    final String options1 = \"git://github.com/toastdriven/django-haystack.git#egg=django_haystack-dev\";\n    assertEquals(new PyRequirement(\"django-haystack\", \"dev\", options1), PyRequirement.fromString(options1));\n\n    final String options2 = \"git://github.com/toastdriven/django-haystack.git#egg=django-haystack-dev\";\n    assertEquals(new PyRequirement(\"django-haystack\", \"dev\", options2), PyRequirement.fromString(options2));\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testArchiveUrlWithSha384() {\n    final String url = \"https://pypi.python.org/packages/source/g/geoip2/geoip2-2.2.0.tar.gz#sha384=26259d212447bc840400c25a48275fbc\";\n\n    assertEquals(new PyRequirement(\"geoip2\", \"2.2.0\", url, false), PyRequirement.fromString(url));\n  }","id":25239,"modified_method":"public void testArchiveUrlWithSha384() {\n    final String url = \"https://pypi.python.org/packages/source/g/geoip2/geoip2-2.2.0.tar.gz#sha384=26259d212447bc840400c25a48275fbc\";\n\n    assertEquals(new PyRequirement(\"geoip2\", \"2.2.0\", url), PyRequirement.fromString(url));\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testArchiveUrlWithSha256() {\n    final String url = \"https://pypi.python.org/packages/source/g/geoip2/geoip2-2.2.0.tar.gz#sha256=26259d212447bc840400c25a48275fbc\";\n\n    assertEquals(new PyRequirement(\"geoip2\", \"2.2.0\", url, false), PyRequirement.fromString(url));\n  }","id":25240,"modified_method":"public void testArchiveUrlWithSha256() {\n    final String url = \"https://pypi.python.org/packages/source/g/geoip2/geoip2-2.2.0.tar.gz#sha256=26259d212447bc840400c25a48275fbc\";\n\n    assertEquals(new PyRequirement(\"geoip2\", \"2.2.0\", url), PyRequirement.fromString(url));\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testMinusInRequirementEggName() {\n    final String options = \"git://github.com/toastdriven/django-haystack.git#egg=django-haystack\";\n\n    assertEquals(new PyRequirement(\"django-haystack\", null, options, false), PyRequirement.fromString(options));\n  }","id":25241,"modified_method":"public void testMinusInRequirementEggName() {\n    final String options = \"git://github.com/toastdriven/django-haystack.git#egg=django-haystack\";\n\n    assertEquals(new PyRequirement(\"django-haystack\", Collections.emptyList(), options), PyRequirement.fromString(options));\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testGitWithoutEgg() {\n    doTest(\"-e git://git.myproject.org/MyProject1\", true);\n    doTest(\"-e git://git.myproject.org/MyProject1/\", true);\n    doTest(\"-e git://git.myproject.org/MyProject1.git\", true);\n    doTest(\"-e git://git.myproject.org/MyProject1.git/\", true);\n    doTest(\"-e git://git.myproject.org/path/MyProject1\", true);\n    doTest(\"-e git://git.myproject.org/path/MyProject1/\", true);\n    doTest(\"-e git://git.myproject.org/path/MyProject1.git\", true);\n    doTest(\"-e git://git.myproject.org/path/MyProject1.git/\", true);\n\n    doTest(\"-e git+git://git.myproject.org/MyProject1\", true);\n    doTest(\"-e git+git://git.myproject.org/MyProject1/\", true);\n    doTest(\"-e git+git://git.myproject.org/MyProject1.git\", true);\n    doTest(\"-e git+git://git.myproject.org/MyProject1.git/\", true);\n    doTest(\"-e git+git://git.myproject.org/path/MyProject1\", true);\n    doTest(\"-e git+git://git.myproject.org/path/MyProject1/\", true);\n    doTest(\"-e git+git://git.myproject.org/path/MyProject1.git\", true);\n    doTest(\"-e git+git://git.myproject.org/path/MyProject1.git/\", true);\n\n    doTest(\"-e git+https://git.myproject.org/MyProject1\", true);\n    doTest(\"-e git+https://git.myproject.org/MyProject1/\", true);\n    doTest(\"-e git+https://git.myproject.org/MyProject1.git\", true);\n    doTest(\"-e git+https://git.myproject.org/MyProject1.git/\", true);\n    doTest(\"-e git+https://git.myproject.org/path/MyProject1\", true);\n    doTest(\"-e git+https://git.myproject.org/path/MyProject1/\", true);\n    doTest(\"-e git+https://git.myproject.org/path/MyProject1.git\", true);\n    doTest(\"-e git+https://git.myproject.org/path/MyProject1.git/\", true);\n\n    doTest(\"-e git+ssh://git.myproject.org/MyProject1\", true);\n    doTest(\"-e git+ssh://git.myproject.org/MyProject1/\", true);\n    doTest(\"-e git+ssh://git.myproject.org/MyProject1.git\", true);\n    doTest(\"-e git+ssh://git.myproject.org/MyProject1.git/\", true);\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject1\", true);\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject1/\", true);\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject1.git\", true);\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject1.git/\", true);\n\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject1\", true);\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject1/\", true);\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject1.git\", true);\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject1.git/\", true);\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject1\", true);\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject1/\", true);\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject1.git\", true);\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject1.git/\", true);\n\n    doTest(\"-e git+user@git.myproject.org:MyProject1\", true);\n    doTest(\"-e git+user@git.myproject.org:MyProject1/\", true);\n    doTest(\"-e git+user@git.myproject.org:MyProject1.git\", true);\n    doTest(\"-e git+user@git.myproject.org:MyProject1.git/\", true);\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject1\", true);\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject1/\", true);\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject1.git\", true);\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject1.git/\", true);\n  }","id":25242,"modified_method":"public void testGitWithoutEgg() {\n    doTest(\"-e git://git.myproject.org/MyProject1\");\n    doTest(\"-e git://git.myproject.org/MyProject1/\");\n    doTest(\"-e git://git.myproject.org/MyProject1.git\");\n    doTest(\"-e git://git.myproject.org/MyProject1.git/\");\n    doTest(\"-e git://git.myproject.org/path/MyProject1\");\n    doTest(\"-e git://git.myproject.org/path/MyProject1/\");\n    doTest(\"-e git://git.myproject.org/path/MyProject1.git\");\n    doTest(\"-e git://git.myproject.org/path/MyProject1.git/\");\n\n    doTest(\"-e git+git://git.myproject.org/MyProject1\");\n    doTest(\"-e git+git://git.myproject.org/MyProject1/\");\n    doTest(\"-e git+git://git.myproject.org/MyProject1.git\");\n    doTest(\"-e git+git://git.myproject.org/MyProject1.git/\");\n    doTest(\"-e git+git://git.myproject.org/path/MyProject1\");\n    doTest(\"-e git+git://git.myproject.org/path/MyProject1/\");\n    doTest(\"-e git+git://git.myproject.org/path/MyProject1.git\");\n    doTest(\"-e git+git://git.myproject.org/path/MyProject1.git/\");\n\n    doTest(\"-e git+https://git.myproject.org/MyProject1\");\n    doTest(\"-e git+https://git.myproject.org/MyProject1/\");\n    doTest(\"-e git+https://git.myproject.org/MyProject1.git\");\n    doTest(\"-e git+https://git.myproject.org/MyProject1.git/\");\n    doTest(\"-e git+https://git.myproject.org/path/MyProject1\");\n    doTest(\"-e git+https://git.myproject.org/path/MyProject1/\");\n    doTest(\"-e git+https://git.myproject.org/path/MyProject1.git\");\n    doTest(\"-e git+https://git.myproject.org/path/MyProject1.git/\");\n\n    doTest(\"-e git+ssh://git.myproject.org/MyProject1\");\n    doTest(\"-e git+ssh://git.myproject.org/MyProject1/\");\n    doTest(\"-e git+ssh://git.myproject.org/MyProject1.git\");\n    doTest(\"-e git+ssh://git.myproject.org/MyProject1.git/\");\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject1\");\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject1/\");\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject1.git\");\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject1.git/\");\n\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject1\");\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject1/\");\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject1.git\");\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject1.git/\");\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject1\");\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject1/\");\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject1.git\");\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject1.git/\");\n\n    doTest(\"-e git+user@git.myproject.org:MyProject1\");\n    doTest(\"-e git+user@git.myproject.org:MyProject1/\");\n    doTest(\"-e git+user@git.myproject.org:MyProject1.git\");\n    doTest(\"-e git+user@git.myproject.org:MyProject1.git/\");\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject1\");\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject1/\");\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject1.git\");\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject1.git/\");\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testEditableGit() {\n    doTest(\"-e git://git.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"-e git://git.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e git://git.myproject.org/MyProject.git#egg=MyProject1\", true);\n    doTest(\"-e git://git.myproject.org/MyProject.git/#egg=MyProject1\", true);\n    doTest(\"-e git://git.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"-e git://git.myproject.org/path/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e git://git.myproject.org/path/MyProject.git#egg=MyProject1\", true);\n    doTest(\"-e git://git.myproject.org/path/MyProject.git/#egg=MyProject1\", true);\n\n    doTest(\"-e git+git://git.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"-e git+git://git.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e git+git://git.myproject.org/MyProject.git#egg=MyProject1\", true);\n    doTest(\"-e git+git://git.myproject.org/MyProject.git/#egg=MyProject1\", true);\n    doTest(\"-e git+git://git.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"-e git+git://git.myproject.org/path/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e git+git://git.myproject.org/path/MyProject.git#egg=MyProject1\", true);\n    doTest(\"-e git+git://git.myproject.org/path/MyProject.git/#egg=MyProject1\", true);\n\n    doTest(\"-e git+https://git.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"-e git+https://git.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e git+https://git.myproject.org/MyProject.git#egg=MyProject1\", true);\n    doTest(\"-e git+https://git.myproject.org/MyProject.git/#egg=MyProject1\", true);\n    doTest(\"-e git+https://git.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"-e git+https://git.myproject.org/path/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e git+https://git.myproject.org/path/MyProject.git#egg=MyProject1\", true);\n    doTest(\"-e git+https://git.myproject.org/path/MyProject.git/#egg=MyProject1\", true);\n\n    doTest(\"-e git+ssh://git.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"-e git+ssh://git.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e git+ssh://git.myproject.org/MyProject.git#egg=MyProject1\", true);\n    doTest(\"-e git+ssh://git.myproject.org/MyProject.git/#egg=MyProject1\", true);\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject.git#egg=MyProject1\", true);\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject.git/#egg=MyProject1\", true);\n\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject.git#egg=MyProject1\", true);\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject.git/#egg=MyProject1\", true);\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject.git#egg=MyProject1\", true);\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject.git/#egg=MyProject1\", true);\n\n    doTest(\"-e git+user@git.myproject.org:MyProject#egg=MyProject1\", true);\n    doTest(\"-e git+user@git.myproject.org:MyProject/#egg=MyProject1\", true);\n    doTest(\"-e git+user@git.myproject.org:MyProject.git#egg=MyProject1\", true);\n    doTest(\"-e git+user@git.myproject.org:MyProject.git/#egg=MyProject1\", true);\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject#egg=MyProject1\", true);\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject.git#egg=MyProject1\", true);\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject.git/#egg=MyProject1\", true);\n\n    doTest(\"--editable git://git.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable git://git.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable git://git.myproject.org/MyProject.git#egg=MyProject1\", true);\n    doTest(\"--editable git://git.myproject.org/MyProject.git/#egg=MyProject1\", true);\n    doTest(\"--editable git://git.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable git://git.myproject.org/path/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable git://git.myproject.org/path/MyProject.git#egg=MyProject1\", true);\n    doTest(\"--editable git://git.myproject.org/path/MyProject.git/#egg=MyProject1\", true);\n\n    doTest(\"--editable git+git://git.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable git+git://git.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable git+git://git.myproject.org/MyProject.git#egg=MyProject1\", true);\n    doTest(\"--editable git+git://git.myproject.org/MyProject.git/#egg=MyProject1\", true);\n    doTest(\"--editable git+git://git.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable git+git://git.myproject.org/path/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable git+git://git.myproject.org/path/MyProject.git#egg=MyProject1\", true);\n    doTest(\"--editable git+git://git.myproject.org/path/MyProject.git/#egg=MyProject1\", true);\n\n    doTest(\"--editable git+https://git.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable git+https://git.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable git+https://git.myproject.org/MyProject.git#egg=MyProject1\", true);\n    doTest(\"--editable git+https://git.myproject.org/MyProject.git/#egg=MyProject1\", true);\n    doTest(\"--editable git+https://git.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable git+https://git.myproject.org/path/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable git+https://git.myproject.org/path/MyProject.git#egg=MyProject1\", true);\n    doTest(\"--editable git+https://git.myproject.org/path/MyProject.git/#egg=MyProject1\", true);\n\n    doTest(\"--editable git+ssh://git.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable git+ssh://git.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable git+ssh://git.myproject.org/MyProject.git#egg=MyProject1\", true);\n    doTest(\"--editable git+ssh://git.myproject.org/MyProject.git/#egg=MyProject1\", true);\n    doTest(\"--editable git+ssh://git.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable git+ssh://git.myproject.org/path/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable git+ssh://git.myproject.org/path/MyProject.git#egg=MyProject1\", true);\n    doTest(\"--editable git+ssh://git.myproject.org/path/MyProject.git/#egg=MyProject1\", true);\n\n    doTest(\"--editable git+ssh://user@git.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable git+ssh://user@git.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable git+ssh://user@git.myproject.org/MyProject.git#egg=MyProject1\", true);\n    doTest(\"--editable git+ssh://user@git.myproject.org/MyProject.git/#egg=MyProject1\", true);\n    doTest(\"--editable git+ssh://user@git.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable git+ssh://user@git.myproject.org/path/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable git+ssh://user@git.myproject.org/path/MyProject.git#egg=MyProject1\", true);\n    doTest(\"--editable git+ssh://user@git.myproject.org/path/MyProject.git/#egg=MyProject1\", true);\n\n    doTest(\"--editable git+user@git.myproject.org:MyProject#egg=MyProject1\", true);\n    doTest(\"--editable git+user@git.myproject.org:MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable git+user@git.myproject.org:MyProject.git#egg=MyProject1\", true);\n    doTest(\"--editable git+user@git.myproject.org:MyProject.git/#egg=MyProject1\", true);\n    doTest(\"--editable git+user@git.myproject.org:/path/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable git+user@git.myproject.org:/path/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable git+user@git.myproject.org:/path/MyProject.git#egg=MyProject1\", true);\n    doTest(\"--editable git+user@git.myproject.org:/path/MyProject.git/#egg=MyProject1\", true);\n  }","id":25243,"modified_method":"public void testEditableGit() {\n    doTest(\"-e git://git.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"-e git://git.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"-e git://git.myproject.org/MyProject.git#egg=MyProject1\");\n    doTest(\"-e git://git.myproject.org/MyProject.git/#egg=MyProject1\");\n    doTest(\"-e git://git.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"-e git://git.myproject.org/path/MyProject/#egg=MyProject1\");\n    doTest(\"-e git://git.myproject.org/path/MyProject.git#egg=MyProject1\");\n    doTest(\"-e git://git.myproject.org/path/MyProject.git/#egg=MyProject1\");\n\n    doTest(\"-e git+git://git.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"-e git+git://git.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"-e git+git://git.myproject.org/MyProject.git#egg=MyProject1\");\n    doTest(\"-e git+git://git.myproject.org/MyProject.git/#egg=MyProject1\");\n    doTest(\"-e git+git://git.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"-e git+git://git.myproject.org/path/MyProject/#egg=MyProject1\");\n    doTest(\"-e git+git://git.myproject.org/path/MyProject.git#egg=MyProject1\");\n    doTest(\"-e git+git://git.myproject.org/path/MyProject.git/#egg=MyProject1\");\n\n    doTest(\"-e git+https://git.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"-e git+https://git.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"-e git+https://git.myproject.org/MyProject.git#egg=MyProject1\");\n    doTest(\"-e git+https://git.myproject.org/MyProject.git/#egg=MyProject1\");\n    doTest(\"-e git+https://git.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"-e git+https://git.myproject.org/path/MyProject/#egg=MyProject1\");\n    doTest(\"-e git+https://git.myproject.org/path/MyProject.git#egg=MyProject1\");\n    doTest(\"-e git+https://git.myproject.org/path/MyProject.git/#egg=MyProject1\");\n\n    doTest(\"-e git+ssh://git.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"-e git+ssh://git.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"-e git+ssh://git.myproject.org/MyProject.git#egg=MyProject1\");\n    doTest(\"-e git+ssh://git.myproject.org/MyProject.git/#egg=MyProject1\");\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject/#egg=MyProject1\");\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject.git#egg=MyProject1\");\n    doTest(\"-e git+ssh://git.myproject.org/path/MyProject.git/#egg=MyProject1\");\n\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject.git#egg=MyProject1\");\n    doTest(\"-e git+ssh://user@git.myproject.org/MyProject.git/#egg=MyProject1\");\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject/#egg=MyProject1\");\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject.git#egg=MyProject1\");\n    doTest(\"-e git+ssh://user@git.myproject.org/path/MyProject.git/#egg=MyProject1\");\n\n    doTest(\"-e git+user@git.myproject.org:MyProject#egg=MyProject1\");\n    doTest(\"-e git+user@git.myproject.org:MyProject/#egg=MyProject1\");\n    doTest(\"-e git+user@git.myproject.org:MyProject.git#egg=MyProject1\");\n    doTest(\"-e git+user@git.myproject.org:MyProject.git/#egg=MyProject1\");\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject#egg=MyProject1\");\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject/#egg=MyProject1\");\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject.git#egg=MyProject1\");\n    doTest(\"-e git+user@git.myproject.org:/path/MyProject.git/#egg=MyProject1\");\n\n    doTest(\"--editable git://git.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"--editable git://git.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"--editable git://git.myproject.org/MyProject.git#egg=MyProject1\");\n    doTest(\"--editable git://git.myproject.org/MyProject.git/#egg=MyProject1\");\n    doTest(\"--editable git://git.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"--editable git://git.myproject.org/path/MyProject/#egg=MyProject1\");\n    doTest(\"--editable git://git.myproject.org/path/MyProject.git#egg=MyProject1\");\n    doTest(\"--editable git://git.myproject.org/path/MyProject.git/#egg=MyProject1\");\n\n    doTest(\"--editable git+git://git.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"--editable git+git://git.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"--editable git+git://git.myproject.org/MyProject.git#egg=MyProject1\");\n    doTest(\"--editable git+git://git.myproject.org/MyProject.git/#egg=MyProject1\");\n    doTest(\"--editable git+git://git.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"--editable git+git://git.myproject.org/path/MyProject/#egg=MyProject1\");\n    doTest(\"--editable git+git://git.myproject.org/path/MyProject.git#egg=MyProject1\");\n    doTest(\"--editable git+git://git.myproject.org/path/MyProject.git/#egg=MyProject1\");\n\n    doTest(\"--editable git+https://git.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"--editable git+https://git.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"--editable git+https://git.myproject.org/MyProject.git#egg=MyProject1\");\n    doTest(\"--editable git+https://git.myproject.org/MyProject.git/#egg=MyProject1\");\n    doTest(\"--editable git+https://git.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"--editable git+https://git.myproject.org/path/MyProject/#egg=MyProject1\");\n    doTest(\"--editable git+https://git.myproject.org/path/MyProject.git#egg=MyProject1\");\n    doTest(\"--editable git+https://git.myproject.org/path/MyProject.git/#egg=MyProject1\");\n\n    doTest(\"--editable git+ssh://git.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"--editable git+ssh://git.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"--editable git+ssh://git.myproject.org/MyProject.git#egg=MyProject1\");\n    doTest(\"--editable git+ssh://git.myproject.org/MyProject.git/#egg=MyProject1\");\n    doTest(\"--editable git+ssh://git.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"--editable git+ssh://git.myproject.org/path/MyProject/#egg=MyProject1\");\n    doTest(\"--editable git+ssh://git.myproject.org/path/MyProject.git#egg=MyProject1\");\n    doTest(\"--editable git+ssh://git.myproject.org/path/MyProject.git/#egg=MyProject1\");\n\n    doTest(\"--editable git+ssh://user@git.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"--editable git+ssh://user@git.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"--editable git+ssh://user@git.myproject.org/MyProject.git#egg=MyProject1\");\n    doTest(\"--editable git+ssh://user@git.myproject.org/MyProject.git/#egg=MyProject1\");\n    doTest(\"--editable git+ssh://user@git.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"--editable git+ssh://user@git.myproject.org/path/MyProject/#egg=MyProject1\");\n    doTest(\"--editable git+ssh://user@git.myproject.org/path/MyProject.git#egg=MyProject1\");\n    doTest(\"--editable git+ssh://user@git.myproject.org/path/MyProject.git/#egg=MyProject1\");\n\n    doTest(\"--editable git+user@git.myproject.org:MyProject#egg=MyProject1\");\n    doTest(\"--editable git+user@git.myproject.org:MyProject/#egg=MyProject1\");\n    doTest(\"--editable git+user@git.myproject.org:MyProject.git#egg=MyProject1\");\n    doTest(\"--editable git+user@git.myproject.org:MyProject.git/#egg=MyProject1\");\n    doTest(\"--editable git+user@git.myproject.org:/path/MyProject#egg=MyProject1\");\n    doTest(\"--editable git+user@git.myproject.org:/path/MyProject/#egg=MyProject1\");\n    doTest(\"--editable git+user@git.myproject.org:/path/MyProject.git#egg=MyProject1\");\n    doTest(\"--editable git+user@git.myproject.org:/path/MyProject.git/#egg=MyProject1\");\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testArchiveUrlWithSha1() {\n    final String url = \"https://pypi.python.org/packages/source/g/geoip2/geoip2-2.2.0.tar.gz#sha1=26259d212447bc840400c25a48275fbc\";\n\n    assertEquals(new PyRequirement(\"geoip2\", \"2.2.0\", url, false), PyRequirement.fromString(url));\n  }","id":25244,"modified_method":"public void testArchiveUrlWithSha1() {\n    final String url = \"https://pypi.python.org/packages/source/g/geoip2/geoip2-2.2.0.tar.gz#sha1=26259d212447bc840400c25a48275fbc\";\n\n    assertEquals(new PyRequirement(\"geoip2\", \"2.2.0\", url), PyRequirement.fromString(url));\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testEditableMercurial() {\n    doTest(\"-e hg+http://hg.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"-e hg+http://hg.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e hg+http://hg.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"-e hg+http://hg.myproject.org/path/MyProject/#egg=MyProject1\", true);\n\n    doTest(\"-e hg+https://hg.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"-e hg+https://hg.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e hg+https://hg.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"-e hg+https://hg.myproject.org/path/MyProject/#egg=MyProject1\", true);\n\n    doTest(\"-e hg+ssh://hg.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"-e hg+ssh://hg.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e hg+ssh://hg.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"-e hg+ssh://hg.myproject.org/path/MyProject/#egg=MyProject1\", true);\n\n    doTest(\"-e hg+ssh://user@hg.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"-e hg+ssh://user@hg.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"-e hg+ssh://user@hg.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"-e hg+ssh://user@hg.myproject.org/path/MyProject/#egg=MyProject1\", true);\n\n    doTest(\"--editable hg+http://hg.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable hg+http://hg.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable hg+http://hg.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable hg+http://hg.myproject.org/path/MyProject/#egg=MyProject1\", true);\n\n    doTest(\"--editable hg+https://hg.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable hg+https://hg.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable hg+https://hg.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable hg+https://hg.myproject.org/path/MyProject/#egg=MyProject1\", true);\n\n    doTest(\"--editable hg+ssh://hg.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable hg+ssh://hg.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable hg+ssh://hg.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable hg+ssh://hg.myproject.org/path/MyProject/#egg=MyProject1\", true);\n\n    doTest(\"--editable hg+ssh://user@hg.myproject.org/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable hg+ssh://user@hg.myproject.org/MyProject/#egg=MyProject1\", true);\n    doTest(\"--editable hg+ssh://user@hg.myproject.org/path/MyProject#egg=MyProject1\", true);\n    doTest(\"--editable hg+ssh://user@hg.myproject.org/path/MyProject/#egg=MyProject1\", true);\n  }","id":25245,"modified_method":"public void testEditableMercurial() {\n    doTest(\"-e hg+http://hg.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"-e hg+http://hg.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"-e hg+http://hg.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"-e hg+http://hg.myproject.org/path/MyProject/#egg=MyProject1\");\n\n    doTest(\"-e hg+https://hg.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"-e hg+https://hg.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"-e hg+https://hg.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"-e hg+https://hg.myproject.org/path/MyProject/#egg=MyProject1\");\n\n    doTest(\"-e hg+ssh://hg.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"-e hg+ssh://hg.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"-e hg+ssh://hg.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"-e hg+ssh://hg.myproject.org/path/MyProject/#egg=MyProject1\");\n\n    doTest(\"-e hg+ssh://user@hg.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"-e hg+ssh://user@hg.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"-e hg+ssh://user@hg.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"-e hg+ssh://user@hg.myproject.org/path/MyProject/#egg=MyProject1\");\n\n    doTest(\"--editable hg+http://hg.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"--editable hg+http://hg.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"--editable hg+http://hg.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"--editable hg+http://hg.myproject.org/path/MyProject/#egg=MyProject1\");\n\n    doTest(\"--editable hg+https://hg.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"--editable hg+https://hg.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"--editable hg+https://hg.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"--editable hg+https://hg.myproject.org/path/MyProject/#egg=MyProject1\");\n\n    doTest(\"--editable hg+ssh://hg.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"--editable hg+ssh://hg.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"--editable hg+ssh://hg.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"--editable hg+ssh://hg.myproject.org/path/MyProject/#egg=MyProject1\");\n\n    doTest(\"--editable hg+ssh://user@hg.myproject.org/MyProject#egg=MyProject1\");\n    doTest(\"--editable hg+ssh://user@hg.myproject.org/MyProject/#egg=MyProject1\");\n    doTest(\"--editable hg+ssh://user@hg.myproject.org/path/MyProject#egg=MyProject1\");\n    doTest(\"--editable hg+ssh://user@hg.myproject.org/path/MyProject/#egg=MyProject1\");\n  }","commit_id":"1ef3192231fdb95ce35739b930a600664f2f01bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n    public void testHsql() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<jdbc:connector name=\\\"jdbcConnector\\\" pollingFrequency=\\\"1000\\\" dataSource-ref=\\\"hsqlDatasource\\\" queryTimeout=\\\"3000\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\";\n        Document document = XMLUnit.buildControlDocument(config);\n\n        //String refDef =\n        //        \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.h2.jdbcx.JdbcConnectionPool\\\" destroy-method=\\\"dispose\\\" id=\\\"hsqlDatasource\\\">\"\n        //        + \"<springjdbc:embedded-database xmlns:springjdbc=\\\"http://www.springframework.org/schema/jdbc\\\" id=\\\"embeddedDatasource\\\" type=\\\"HSQL\\\"/>\"\n        //        + \"<\/spring:bean>\"\n        //        ;\n        //XmlConfigurationCallback callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"hsqlDatasource\", refDef));\n        //doTest(document, callback);\n        //doTest(document, callback);\n        //doTest(document, callback);\n\n        String refDef =\n                \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.apache.commons.dbcp.BasicDataSource\\\" destroy-method=\\\"close\\\" id=\\\"hsqlDatasource\\\">\"\n                + \"<spring:property name=\\\"driverClassName\\\" value=\\\"org.hsqldb.jdbcDriver\\\"/>\"\n                + \"<spring:property name=\\\"url\\\" value=\\\"jdbc:hsqldb:mem:spring-playground\\\"/>\"\n                + \"<spring:property name=\\\"username\\\" value=\\\"sa\\\"/>\"\n                + \"<spring:property name=\\\"password\\\" value=\\\"\\\"/>\"\n                + \"<\/spring:bean>\"\n        ;\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"hsqlDatasource\", refDef));\n        doTest(document, callback, true);\n        doTest(document, callback, true);\n        doTest(document, callback, true);\n    }","id":25246,"modified_method":"@Test\n    public void testHsql() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<jdbc:connector name=\\\"jdbcConnector\\\" pollingFrequency=\\\"1000\\\" dataSource-ref=\\\"hsqlDatasource\\\" queryTimeout=\\\"3000\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\";\n        Document document = XMLUnit.buildControlDocument(config);\n        String refDef =\n                \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.apache.commons.dbcp.BasicDataSource\\\" destroy-method=\\\"close\\\" id=\\\"hsqlDatasource\\\">\"\n                + \"<spring:property name=\\\"driverClassName\\\" value=\\\"org.hsqldb.jdbcDriver\\\"/>\"\n                + \"<spring:property name=\\\"url\\\" value=\\\"jdbc:hsqldb:mem:spring-playground\\\"/>\"\n                + \"<spring:property name=\\\"username\\\" value=\\\"sa\\\"/>\"\n                + \"<spring:property name=\\\"password\\\" value=\\\"\\\"/>\"\n                + \"<\/spring:bean>\";\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"hsqlDatasource\", refDef));\n        doTest(document, callback);\n        doTest(document, callback);\n        doTest(document, callback);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = MuleArtifactFactoryException.class)\n    public void testMissingAttribute() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        Document document = XMLUnit.buildControlDocument(\"<jdbc:connector name=\\\"jdbcConnector\\\" pollingFrequency=\\\"1000\\\" queryTimeout=\\\"3000\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\");\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback();\n\n        System.out.println((lookupArtifact().getArtifact(document.getDocumentElement(), callback)));\n    }","id":25247,"modified_method":"@Test(expected = MuleArtifactFactoryException.class)\n    public void detectsMissingAttribute() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        Document document = XMLUnit.buildControlDocument(\"<jdbc:connector name=\\\"jdbcConnector\\\" pollingFrequency=\\\"1000\\\" queryTimeout=\\\"3000\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\");\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback();\n\n        lookupArtifact().getArtifact(document.getDocumentElement(), callback);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    @Ignore\n    public void testMySql() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<jdbc:connector name=\\\"jdbcConnector\\\" pollingFrequency=\\\"1000\\\" dataSource-ref=\\\"mysqlDatasource\\\" queryTimeout=\\\"3000\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\";\n        Document document = XMLUnit.buildControlDocument(config);\n        String refDef =\n                //    \t\"<jdbc:mysql-data-source name=\\\"mysqlDatasource\\\" user=\\\"myUser\\\" password=\\\"secret\\\" host=\\\"localhost\\\" database=\\\"test\\\"  port=\\\"3306\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\"\n\n                \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.apache.commons.dbcp.BasicDataSource\\\" destroy-method=\\\"close\\\" id=\\\"mysqlDatasource\\\" name=\\\"Bean\\\">\"\n                + \"<spring:property name=\\\"driverClassName\\\" value=\\\"com.mysql.jdbc.Driver\\\"/>\"\n                + \"<spring:property name=\\\"url\\\" value=\\\"jdbc:mysql://localhost/test\\\"/>\"\n                + \"<spring:property name=\\\"username\\\" value=\\\"myUser\\\"/>\"\n                + \"<spring:property name=\\\"password\\\" value=\\\"secret\\\"/>\"\n                + \"<\/spring:bean>\"\n\n                //        \t\"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.enhydra.jdbc.standard.StandardXADataSource\\\" destroy-method=\\\"shutdown\\\" id=\\\"mysqlDatasource\\\" name=\\\"Bean\\\">\"\n                //\t\t\t+ \"<spring:property name=\\\"driverName\\\" value=\\\"com.mysql.jdbc.Driver\\\"/>\"\n                //\t\t\t+ \"<spring:property name=\\\"url\\\" value=\\\"jdbc:mysql://localhost/test\\\"/>\"\n                //\t\t\t+ \"<spring:property name=\\\"user\\\" value=\\\"myUser\\\"/>\"\n                //\t\t\t+ \"<spring:property name=\\\"password\\\" value=\\\"secret\\\"/>\"\n                //\t\t\t+ \"<\/spring:bean>\"\n                ;\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"mysqlDatasource\", refDef));\n\n        doTest(document, callback, false);\n        doTest(document, callback, false);\n        doTest(document, callback, false);\n    }","id":25248,"modified_method":"@Test\n    @Ignore\n    public void testMySql() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<jdbc:connector name=\\\"jdbcConnector\\\" pollingFrequency=\\\"1000\\\" dataSource-ref=\\\"mysqlDatasource\\\" queryTimeout=\\\"3000\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\";\n        Document document = XMLUnit.buildControlDocument(config);\n        String refDef =\n                \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.apache.commons.dbcp.BasicDataSource\\\" destroy-method=\\\"close\\\" id=\\\"mysqlDatasource\\\" name=\\\"Bean\\\">\"\n                + \"<spring:property name=\\\"driverClassName\\\" value=\\\"com.mysql.jdbc.Driver\\\"/>\"\n                + \"<spring:property name=\\\"url\\\" value=\\\"jdbc:mysql://localhost/test\\\"/>\"\n                + \"<spring:property name=\\\"username\\\" value=\\\"myUser\\\"/>\"\n                + \"<spring:property name=\\\"password\\\" value=\\\"secret\\\"/>\"\n                + \"<\/spring:bean>\";\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"mysqlDatasource\", refDef));\n\n        doTest(document, callback);\n        doTest(document, callback);\n        doTest(document, callback);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = MuleArtifactFactoryException.class)\n    public void testMissingDependentElement() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        Document document = XMLUnit.buildControlDocument(\"<jdbc:connector name=\\\"jdbcConnector\\\" pollingFrequency=\\\"1000\\\" dataSource-ref=\\\"unknownJdbcDataSource\\\" queryTimeout=\\\"3000\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\");\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback();\n\n        System.out.println((lookupArtifact().getArtifact(document.getDocumentElement(), callback)));\n    }","id":25249,"modified_method":"@Test(expected = MuleArtifactFactoryException.class)\n    public void detectsMissingDependentElement() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        Document document = XMLUnit.buildControlDocument(\"<jdbc:connector name=\\\"jdbcConnector\\\" pollingFrequency=\\\"1000\\\" dataSource-ref=\\\"unknownJdbcDataSource\\\" queryTimeout=\\\"3000\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\");\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback();\n\n        lookupArtifact().getArtifact(document.getDocumentElement(), callback);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testDerby() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<jdbc:connector name=\\\"jdbcConnector\\\" pollingFrequency=\\\"1000\\\" dataSource-ref=\\\"jdbcDataSource\\\" queryTimeout=\\\"3000\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\";\n        Document document = XMLUnit.buildControlDocument(config);\n        String refDef =\n                //              \"<jdbc:derby-data-source name=\\\"jdbcDataSource\\\" url=\\\"jdbc:derby:muleEmbeddedDB;create=true\\\"  xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\"\n\n                //          \t\"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.apache.derby.jdbc.EmbeddedXADataSource\\\" id=\\\"jdbcDataSource\\\" name=\\\"Bean\\\">\"\n                //          \t+ \"<spring:property name=\\\"databaseName\\\" value=\\\"muleEmbeddedDB\\\"/>\"\n                //\t\t\t\t+ \"<\/spring:bean>\"\n\n                //          \t\"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.enhydra.jdbc.standard.StandardXADataSource\\\" destroy-method=\\\"shutdown\\\" id=\\\"jdbcDataSource\\\" name=\\\"Bean\\\">\"\n                //\t\t\t\t+ \"<spring:property name=\\\"driverName\\\" value=\\\"org.apache.derby.jdbc.EmbeddedDriver\\\"/>\"\n                //\t\t\t\t+ \"<spring:property name=\\\"url\\\" value=\\\"jdbc:derby:muleEmbeddedDB;create=true\\\"/>\"\n                //\t\t\t\t+ \"<\/spring:bean>\"\n\n                \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.apache.commons.dbcp.BasicDataSource\\\" destroy-method=\\\"close\\\" id=\\\"jdbcDataSource\\\" name=\\\"Bean\\\">\"\n                + \"<spring:property name=\\\"driverClassName\\\" value=\\\"org.apache.derby.jdbc.EmbeddedDriver\\\"/>\"\n                + \"<spring:property name=\\\"url\\\" value=\\\"jdbc:derby:muleEmbeddedDB;create=true\\\"/>\"\n                + \"<\/spring:bean>\"\n\n                //              \t\"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"com.mchange.v2.c3p0.ComboPooledDataSource\\\" destroy-method=\\\"close\\\" id=\\\"jdbcDataSource\\\" name=\\\"Bean\\\">\"\n                //\t\t\t\t\t+ \"<spring:property name=\\\"driverClass\\\" value=\\\"org.apache.derby.jdbc.EmbeddedDriver\\\"/>\"\n                //\t\t\t\t\t+ \"<spring:property name=\\\"jdbcUrl\\\" value=\\\"jdbc:derby:muleEmbeddedDB;create=true\\\"/>\"\n                //\t\t\t\t\t+ \"<\/spring:bean>\"\n                ;\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"jdbcDataSource\", refDef));\n\n        doTest(document, callback, true);\n        doTest(document, callback, true);\n        doTest(document, callback, true);\n    }","id":25250,"modified_method":"@Test\n    public void testDerby() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<jdbc:connector name=\\\"jdbcConnector\\\" pollingFrequency=\\\"1000\\\" dataSource-ref=\\\"jdbcDataSource\\\" queryTimeout=\\\"3000\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\";\n        Document document = XMLUnit.buildControlDocument(config);\n        String refDef =\n                \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.apache.commons.dbcp.BasicDataSource\\\" destroy-method=\\\"close\\\" id=\\\"jdbcDataSource\\\" name=\\\"Bean\\\">\"\n                + \"<spring:property name=\\\"driverClassName\\\" value=\\\"org.apache.derby.jdbc.EmbeddedDriver\\\"/>\"\n                + \"<spring:property name=\\\"url\\\" value=\\\"jdbc:derby:muleEmbeddedDB;create=true\\\"/>\"\n                + \"<\/spring:bean>\";\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"jdbcDataSource\", refDef));\n\n        doTest(document, callback);\n        doTest(document, callback);\n        doTest(document, callback);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testH2() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<jdbc:connector name=\\\"jdbcConnector\\\" pollingFrequency=\\\"1000\\\" dataSource-ref=\\\"h2Datasource\\\" queryTimeout=\\\"3000\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\";\n        Document document = XMLUnit.buildControlDocument(config);\n\n        String refDef =\n                \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.h2.jdbcx.JdbcConnectionPool\\\" destroy-method=\\\"dispose\\\" id=\\\"h2Datasource\\\">\"\n                + \"  <spring:constructor-arg>\"\n                + \"    <spring:bean class=\\\"org.h2.jdbcx.JdbcDataSource\\\">\"\n                + \"      <spring:property name=\\\"URL\\\" value=\\\"jdbc:h2:dbname\\\"/>\"\n                + \"      <spring:property name=\\\"user\\\" value=\\\"user\\\"/>\"\n                + \"      <spring:property name=\\\"password\\\" value=\\\"password\\\"/>\"\n                + \"    <\/spring:bean>\"\n                + \"  <\/spring:constructor-arg>\"\n                + \"<\/spring:bean>\"\n                ;\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"h2Datasource\", refDef));\n        doTest(document, callback, true);\n        doTest(document, callback, true);\n        doTest(document, callback, true);\n\n        refDef =\n                \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.enhydra.jdbc.standard.StandardXADataSource\\\" destroy-method=\\\"shutdown\\\" id=\\\"h2Datasource\\\">\"\n                + \"<spring:property name=\\\"driverName\\\" value=\\\"org.h2.Driver\\\"/>\"\n                + \"<spring:property name=\\\"url\\\" value=\\\"jdbc:h2:dbname\\\"/>\"\n                + \"<spring:property name=\\\"user\\\" value=\\\"user\\\"/>\"\n                + \"<spring:property name=\\\"password\\\" value=\\\"password\\\"/>\"\n                + \"<\/spring:bean>\"\n        ;\n        callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"h2Datasource\", refDef));\n        doTest(document, callback, true);\n        doTest(document, callback, true);\n        doTest(document, callback, true);\n\n        refDef =\n                \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.apache.commons.dbcp.BasicDataSource\\\" destroy-method=\\\"close\\\" id=\\\"h2Datasource\\\">\"\n                + \"<spring:property name=\\\"driverClassName\\\" value=\\\"org.h2.Driver\\\"/>\"\n                + \"<spring:property name=\\\"url\\\" value=\\\"jdbc:h2:dbname\\\"/>\"\n                + \"<spring:property name=\\\"username\\\" value=\\\"user\\\"/>\"\n                + \"<spring:property name=\\\"password\\\" value=\\\"password\\\"/>\"\n                + \"<\/spring:bean>\"\n        ;\n        callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"h2Datasource\", refDef));\n        doTest(document, callback, true);\n        doTest(document, callback, true);\n        doTest(document, callback, true);\n    }","id":25251,"modified_method":"@Test\n    public void testH2() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<jdbc:connector name=\\\"jdbcConnector\\\" pollingFrequency=\\\"1000\\\" dataSource-ref=\\\"h2Datasource\\\" queryTimeout=\\\"3000\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\";\n        Document document = XMLUnit.buildControlDocument(config);\n\n        String refDef =\n                \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.h2.jdbcx.JdbcConnectionPool\\\" destroy-method=\\\"dispose\\\" id=\\\"h2Datasource\\\">\"\n                + \"  <spring:constructor-arg>\"\n                + \"    <spring:bean class=\\\"org.h2.jdbcx.JdbcDataSource\\\">\"\n                + \"      <spring:property name=\\\"URL\\\" value=\\\"jdbc:h2:dbname\\\"/>\"\n                + \"      <spring:property name=\\\"user\\\" value=\\\"user\\\"/>\"\n                + \"      <spring:property name=\\\"password\\\" value=\\\"password\\\"/>\"\n                + \"    <\/spring:bean>\"\n                + \"  <\/spring:constructor-arg>\"\n                + \"<\/spring:bean>\"\n                ;\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"h2Datasource\", refDef));\n        doTest(document, callback);\n        doTest(document, callback);\n        doTest(document, callback);\n\n        refDef =\n                \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.enhydra.jdbc.standard.StandardXADataSource\\\" destroy-method=\\\"shutdown\\\" id=\\\"h2Datasource\\\">\"\n                + \"<spring:property name=\\\"driverName\\\" value=\\\"org.h2.Driver\\\"/>\"\n                + \"<spring:property name=\\\"url\\\" value=\\\"jdbc:h2:dbname\\\"/>\"\n                + \"<spring:property name=\\\"user\\\" value=\\\"user\\\"/>\"\n                + \"<spring:property name=\\\"password\\\" value=\\\"password\\\"/>\"\n                + \"<\/spring:bean>\"\n        ;\n        callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"h2Datasource\", refDef));\n        doTest(document, callback);\n        doTest(document, callback);\n        doTest(document, callback);\n\n        refDef =\n                \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.apache.commons.dbcp.BasicDataSource\\\" destroy-method=\\\"close\\\" id=\\\"h2Datasource\\\">\"\n                + \"<spring:property name=\\\"driverClassName\\\" value=\\\"org.h2.Driver\\\"/>\"\n                + \"<spring:property name=\\\"url\\\" value=\\\"jdbc:h2:dbname\\\"/>\"\n                + \"<spring:property name=\\\"username\\\" value=\\\"user\\\"/>\"\n                + \"<spring:property name=\\\"password\\\" value=\\\"password\\\"/>\"\n                + \"<\/spring:bean>\";\n        callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"h2Datasource\", refDef));\n        doTest(document, callback);\n        doTest(document, callback);\n        doTest(document, callback);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = MuleArtifactFactoryException.class)\n    public void testMissingAttribute() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        Document document = XMLUnit.buildControlDocument(\"<db:select xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template\\\"/><\/db:select>\");\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback();\n\n        System.out.println((lookupArtifact().getArtifactForMessageProcessor(document.getDocumentElement(), callback)));\n    }","id":25252,"modified_method":"@Test(expected = MuleArtifactFactoryException.class)\n    public void detectsMissingAttribute() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        Document document = XMLUnit.buildControlDocument(\"<db:select xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template\\\"/><\/db:select>\");\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback();\n\n        lookupArtifact().getArtifactForMessageProcessor(document.getDocumentElement(), callback);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testNewDatabaseGenericMySqlTemplateWithMissingQueryRef() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<db:select config-ref=\\\"mysql-config\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template1\\\"/><\/db:select>\";\n        Document document = XMLUnit.buildControlDocument(config);\n\n        String configRef = \"<db:generic-config name=\\\"mysql-config\\\" url=\\\"jdbc:mysql://localhost/test?user=myUser&amp;password=secret\\\" driverClassName=\\\"com.mysql.jdbc.Driver\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\" />\";\n        String templateRef1 = \"<db:template-query name=\\\"template1\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template2\\\"/><\/db:template-query>\";\n        String templateRef2 = \"<db:template-query name=\\\"template2\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:parameterized-query><![CDATA[SELECT username, password FROM Users]]><\/db:parameterized-query><db:in-param name=\\\"myParameter1\\\" defaultValue=\\\"jeje\\\"/><db:in-param name=\\\"myParameter2\\\" defaultValue=\\\"#[payload.parameter]\\\"/><\/db:template-query>\";\n\n        Map<String, String> callbackData = new HashMap<String, String>();\n        callbackData.put(\"mysql-config\", configRef);\n        callbackData.put(\"template1\", templateRef1);\n        callbackData.put(\"template2\", templateRef2);\n\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(callbackData);\n        doTestMessageProcessor(document, callback, false);\n        doTestMessageProcessor(document, callback, false);\n        doTestMessageProcessor(document, callback, false);\n    }","id":25253,"modified_method":"@Test\n    public void testNewDatabaseGenericMySqlTemplateWithMissingQueryRef() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<db:select config-ref=\\\"mysql-config\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template1\\\"/><\/db:select>\";\n        Document document = XMLUnit.buildControlDocument(config);\n\n        String configRef = \"<db:generic-config name=\\\"mysql-config\\\" url=\\\"jdbc:mysql://localhost/test?user=myUser&amp;password=secret\\\" driverClassName=\\\"com.mysql.jdbc.Driver\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\" />\";\n        String templateRef1 = \"<db:template-query name=\\\"template1\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template2\\\"/><\/db:template-query>\";\n        String templateRef2 = \"<db:template-query name=\\\"template2\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:parameterized-query><![CDATA[SELECT username, password FROM Users]]><\/db:parameterized-query><db:in-param name=\\\"myParameter1\\\" defaultValue=\\\"jeje\\\"/><db:in-param name=\\\"myParameter2\\\" defaultValue=\\\"#[payload.parameter]\\\"/><\/db:template-query>\";\n\n        Map<String, String> callbackData = new HashMap<String, String>();\n        callbackData.put(\"mysql-config\", configRef);\n        callbackData.put(\"template1\", templateRef1);\n        callbackData.put(\"template2\", templateRef2);\n\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(callbackData);\n        doTestMessageProcessorCapabilities(document, callback);\n        doTestMessageProcessorCapabilities(document, callback);\n        doTestMessageProcessorCapabilities(document, callback);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testNewDatabaseDerbyTemplateQueryRef() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<db:select config-ref=\\\"derby-config\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template\\\"/><\/db:select>\";\n        Document document = XMLUnit.buildControlDocument(config);\n\n        String configRef = \"<db:derby-config name=\\\"derby-config\\\" url=\\\"jdbc:derby:muleEmbeddedDB;create=true\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\" driverClassName=\\\"org.apache.derby.jdbc.EmbeddedDriver\\\"/>\";\n        String templateRef = \"<db:template-query name=\\\"template\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:parameterized-query><![CDATA[SELECT CURRENT_TIMESTAMP FROM SYSIBM.SYSDUMMY1]]><\/db:parameterized-query><db:in-param name=\\\"myParameter1\\\" defaultValue=\\\"lala\\\"/><db:in-param name=\\\"myParameter2\\\" defaultValue=\\\"#[payload.parameter2]\\\"/><\/db:template-query>\";\n\n        Map<String, String> callbackData = new HashMap<String, String>();\n        callbackData.put(\"derby-config\", configRef);\n        callbackData.put(\"template\", templateRef);\n\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(callbackData);\n        doTestMessageProcessor(document, callback, true);\n        doTestMessageProcessor(document, callback, true);\n        doTestMessageProcessor(document, callback, true);\n    }","id":25254,"modified_method":"@Test\n    public void testNewDatabaseDerbyTemplateQueryRef() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<db:select config-ref=\\\"derby-config\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template\\\"/><\/db:select>\";\n        Document document = XMLUnit.buildControlDocument(config);\n\n        String configRef = \"<db:derby-config name=\\\"derby-config\\\" url=\\\"jdbc:derby:muleEmbeddedDB;create=true\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\" driverClassName=\\\"org.apache.derby.jdbc.EmbeddedDriver\\\"/>\";\n        String templateRef = \"<db:template-query name=\\\"template\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:parameterized-query><![CDATA[SELECT CURRENT_TIMESTAMP FROM SYSIBM.SYSDUMMY1]]><\/db:parameterized-query><db:in-param name=\\\"myParameter1\\\" defaultValue=\\\"lala\\\"/><db:in-param name=\\\"myParameter2\\\" defaultValue=\\\"#[payload.parameter2]\\\"/><\/db:template-query>\";\n\n        Map<String, String> callbackData = new HashMap<String, String>();\n        callbackData.put(\"derby-config\", configRef);\n        callbackData.put(\"template\", templateRef);\n\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(callbackData);\n        doTestMessageProcessor(document, callback);\n        doTestMessageProcessor(document, callback);\n        doTestMessageProcessor(document, callback);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testNewDatabaseGenericMySqlTemplateQueryRef() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<db:select config-ref=\\\"mysql-config\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template\\\"/><\/db:select>\";\n        Document document = XMLUnit.buildControlDocument(config);\n\n        String configRef = \"<db:generic-config name=\\\"mysql-config\\\" url=\\\"jdbc:mysql://localhost/test?user=myUser&amp;password=secret\\\" driverClassName=\\\"com.mysql.jdbc.Driver\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\" />\";\n        String templateRef = \"<db:template-query name=\\\"template\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:parameterized-query><![CDATA[SELECT * FROM Users]]><\/db:parameterized-query><db:in-param name=\\\"myParameter1\\\" defaultValue=\\\"lala\\\"/><db:in-param name=\\\"myParameter2\\\" defaultValue=\\\"#[payload.parameter2]\\\"/><\/db:template-query>\";\n\n        Map<String, String> callbackData = new HashMap<String, String>();\n        callbackData.put(\"mysql-config\", configRef);\n        callbackData.put(\"template\", templateRef);\n\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(callbackData);\n        doTestMessageProcessor(document, callback, false);\n        doTestMessageProcessor(document, callback, false);\n        doTestMessageProcessor(document, callback, false);\n    }","id":25255,"modified_method":"@Test\n    public void testNewDatabaseGenericMySqlTemplateQueryRef() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<db:select config-ref=\\\"mysql-config\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template\\\"/><\/db:select>\";\n        Document document = XMLUnit.buildControlDocument(config);\n\n        String configRef = \"<db:generic-config name=\\\"mysql-config\\\" url=\\\"jdbc:mysql://localhost/test?user=myUser&amp;password=secret\\\" driverClassName=\\\"com.mysql.jdbc.Driver\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\" />\";\n        String templateRef = \"<db:template-query name=\\\"template\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:parameterized-query><![CDATA[SELECT * FROM Users]]><\/db:parameterized-query><db:in-param name=\\\"myParameter1\\\" defaultValue=\\\"lala\\\"/><db:in-param name=\\\"myParameter2\\\" defaultValue=\\\"#[payload.parameter2]\\\"/><\/db:template-query>\";\n\n        Map<String, String> callbackData = new HashMap<String, String>();\n        callbackData.put(\"mysql-config\", configRef);\n        callbackData.put(\"template\", templateRef);\n\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(callbackData);\n        doTestMessageProcessorCapabilities(document, callback);\n        doTestMessageProcessorCapabilities(document, callback);\n        doTestMessageProcessorCapabilities(document, callback);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = MuleArtifactFactoryException.class)\n    public void testNewDatabaseGenericMySqlTemplateWithTemplateQueryRef() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<db:select config-ref=\\\"mysql-config\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template1\\\"/><\/db:select>\";\n        Document document = XMLUnit.buildControlDocument(config);\n\n        String configRef = \"<db:generic-config name=\\\"mysql-config\\\" url=\\\"jdbc:mysql://localhost/test?user=myUser&amp;password=secret\\\" driverClassName=\\\"com.mysql.jdbc.Driver\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\" />\";\n        String templateRef1 = \"<db:template-query name=\\\"template1\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template2\\\"/><\/db:template-query>\";\n\n        Map<String, String> callbackData = new HashMap<String, String>();\n        callbackData.put(\"mysql-config\", configRef);\n        callbackData.put(\"template1\", templateRef1);\n\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(callbackData);\n        doTestMessageProcessor(document, callback, false);\n        doTestMessageProcessor(document, callback, false);\n        doTestMessageProcessor(document, callback, false);\n    }","id":25256,"modified_method":"@Test(expected = MuleArtifactFactoryException.class)\n    public void testNewDatabaseGenericMySqlTemplateWithTemplateQueryRef() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<db:select config-ref=\\\"mysql-config\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template1\\\"/><\/db:select>\";\n        Document document = XMLUnit.buildControlDocument(config);\n\n        String configRef = \"<db:generic-config name=\\\"mysql-config\\\" url=\\\"jdbc:mysql://localhost/test?user=myUser&amp;password=secret\\\" driverClassName=\\\"com.mysql.jdbc.Driver\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\" />\";\n        String templateRef1 = \"<db:template-query name=\\\"template1\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template2\\\"/><\/db:template-query>\";\n\n        Map<String, String> callbackData = new HashMap<String, String>();\n        callbackData.put(\"mysql-config\", configRef);\n        callbackData.put(\"template1\", templateRef1);\n\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(callbackData);\n        doTestMessageProcessorCapabilities(document, callback);\n        doTestMessageProcessorCapabilities(document, callback);\n        doTestMessageProcessorCapabilities(document, callback);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test(expected = MuleArtifactFactoryException.class)\n    public void testMissingDependentElement() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        Document document = XMLUnit.buildControlDocument(\"<db:select config-ref=\\\"mysql-config\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template\\\"/><\/db:select>\");\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback();\n\n        System.out.println((lookupArtifact().getArtifactForMessageProcessor(document.getDocumentElement(), callback)));\n    }","id":25257,"modified_method":"@Test(expected = MuleArtifactFactoryException.class)\n    public void detectsMissingDependentElement() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        Document document = XMLUnit.buildControlDocument(\"<db:select config-ref=\\\"mysql-config\\\" xmlns:db=\\\"http://www.mulesoft.org/schema/mule/db\\\"><db:template-query-ref name=\\\"template\\\"/><\/db:select>\");\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback();\n\n        lookupArtifact().getArtifactForMessageProcessor(document.getDocumentElement(), callback);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"protected String getArtifactMuleConfig(String flowName, org.w3c.dom.Element element, final XmlConfigurationCallback callback, boolean embedInFlow) throws MuleArtifactFactoryException\n    {\n        Document document = DocumentHelper.createDocument();\n\n        // the rootElement is the root of the document\n        Element rootElement = document.addElement(\"mule\", \"http://www.mulesoft.org/schema/mule/core\");\n\n        org.w3c.dom.Element[] placeholders = callback.getPropertyPlaceholders();\n        int noIgnoreUnresolvableCount = 0;\n        for (org.w3c.dom.Element placeholder : placeholders)\n        {\n            try\n            {\n                Element newPlaceHolder = convert(placeholder);\n                String ignoreUnresolvable = newPlaceHolder.attributeValue(IGNORE_UNRESOLVABLE_ATTR);\n                if (!\"true\".equalsIgnoreCase(ignoreUnresolvable))\n                {\n                    noIgnoreUnresolvableCount++;\n                }\n                // There are more than one property placeholder and configuration is prune to failure\n                if (noIgnoreUnresolvableCount > 1)\n                {\n                    throw new MuleArtifactFactoryException(\"There are multiple property-placeholder elements with attribute \" + IGNORE_UNRESOLVABLE_ATTR + \" missing or set to false. It may be not possible to find all property values. Please fix your Mule configuration file.\");\n                }\n                rootElement.add(newPlaceHolder);\n            }\n            catch (ParserConfigurationException e)\n            {\n                throw new MuleArtifactFactoryException(\"Error parsing XML\", e);\n            }\n\n        }\n\n\n        // the parentElement is the parent of the element we are adding\n        Element parentElement = rootElement;\n        addSchemaLocation(rootElement, element, callback);\n        if (embedInFlow)\n        {\n            // Need to put the message processor in a valid flow. Our default flow is:\n            //            \"<flow name=\\\"CreateSingle\\\">\"\n            //          + \"<\/flow>\"\n            parentElement = rootElement.addElement(\"flow\", \"http://www.mulesoft.org/schema/mule/core\");\n            parentElement.addAttribute(\"name\", flowName);\n        }\n        try\n        {\n            parentElement.add(convert(element));\n\n            // Look for references in attributes and child elements (only first level)\n            processElement(element, callback, rootElement);\n\n            // For message sources to work, the flow should be valid, this means needs to have a MP\n            if (embedInFlow)\n            {\n                parentElement.addElement(\"logger\", \"http://www.mulesoft.org/schema/mule/core\");\n            }\n\n            return document.asXML();\n        }\n        catch (Throwable t)\n        {\n            throw new MuleArtifactFactoryException(\"Error generating minimal XML configuration.\", t);\n        }\n\n    }","id":25258,"modified_method":"protected String getArtifactMuleConfig(String flowName, org.w3c.dom.Element element, final XmlConfigurationCallback callback, boolean embedInFlow) throws MuleArtifactFactoryException\n    {\n        Document document = DocumentHelper.createDocument();\n\n        // the rootElement is the root of the document\n        Element rootElement = document.addElement(\"mule\", \"http://www.mulesoft.org/schema/mule/core\");\n\n        org.w3c.dom.Element[] placeholders = callback.getPropertyPlaceholders();\n        int noIgnoreUnresolvableCount = 0;\n        for (org.w3c.dom.Element placeholder : placeholders)\n        {\n            try\n            {\n                Element newPlaceHolder = convert(placeholder);\n                String ignoreUnresolvable = newPlaceHolder.attributeValue(IGNORE_UNRESOLVABLE_ATTR);\n                if (!\"true\".equalsIgnoreCase(ignoreUnresolvable))\n                {\n                    noIgnoreUnresolvableCount++;\n                }\n                // There are more than one property placeholder and configuration is prune to failure\n                if (noIgnoreUnresolvableCount > 1)\n                {\n                    throw new MuleArtifactFactoryException(\"There are multiple property-placeholder elements with attribute \" + IGNORE_UNRESOLVABLE_ATTR + \" missing or set to false. It may be not possible to find all property values. Please fix your Mule configuration file.\");\n                }\n                rootElement.add(newPlaceHolder);\n            }\n            catch (ParserConfigurationException e)\n            {\n                throw new MuleArtifactFactoryException(\"Error parsing XML\", e);\n            }\n\n        }\n\n\n        // the parentElement is the parent of the element we are adding\n        Element parentElement = rootElement;\n        addSchemaLocation(rootElement, element, callback);\n        if (embedInFlow)\n        {\n            // Need to put the message processor in a valid flow. Our default flow is:\n            //            \"<flow name=\\\"CreateSingle\\\">\"\n            //          + \"<\/flow>\"\n            parentElement = rootElement.addElement(\"flow\", \"http://www.mulesoft.org/schema/mule/core\");\n            parentElement.addAttribute(\"name\", flowName);\n        }\n        try\n        {\n            parentElement.add(convert(element));\n\n            processGlobalReferences(element, callback, rootElement);\n\n            // For message sources to work, the flow should be valid, this means needs to have a MP\n            if (embedInFlow)\n            {\n                parentElement.addElement(\"logger\", \"http://www.mulesoft.org/schema/mule/core\");\n            }\n            return document.asXML();\n        }\n        catch (Throwable t)\n        {\n            throw new MuleArtifactFactoryException(\"Error generating minimal XML configuration.\", t);\n        }\n\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"private void processElement(org.w3c.dom.Element element, XmlConfigurationCallback callback, Element rootElement) throws ParserConfigurationException\n    {\n        processGlobalReferencesInAttributes(element, callback, rootElement);\n\n        if (element != null && element.getChildNodes() != null)\n        {\n            // Look for references in first level of child nodes\n            for (int i = 0; i < element.getChildNodes().getLength(); i++)\n            {\n                processGlobalReferencesInAttributes(element.getChildNodes().item(i), callback, rootElement);\n            }\n        }\n    }","id":25259,"modified_method":"private void processGlobalReferences(org.w3c.dom.Element element, XmlConfigurationCallback callback, Element rootElement) throws ParserConfigurationException\n    {\n        processGlobalReferencesInAttributes(element, callback, rootElement);\n\n        processGlobalReferencesInChildElements(element, callback, rootElement);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"private void addReferencedGlobalElement(XmlConfigurationCallback callback, Element rootElement, org.w3c.dom.Element dependentElement) throws ParserConfigurationException\n    {\n        if (dependentElement != null)\n        {\n            // if the element is a spring bean, wrap the element in a top-level spring beans element\n            if (\"http://www.springframework.org/schema/beans\".equals(dependentElement.getNamespaceURI()))\n            {\n                String namespaceUri = dependentElement.getNamespaceURI();\n                Namespace namespace = new Namespace(dependentElement.getPrefix(), namespaceUri);\n                Element beans = rootElement.element(new QName(BEANS_ELEMENT, namespace));\n                if (beans == null)\n                {\n                    beans = rootElement.addElement(BEANS_ELEMENT, namespaceUri);\n                }\n                beans.add(convert(dependentElement));\n            }\n            else\n            {\n                rootElement.add(convert(dependentElement));\n                addSchemaLocation(rootElement, dependentElement, callback);\n            }\n            processElement(dependentElement, callback, rootElement);\n        }\n        // if missing a dependent element, try anyway because it might not be needed.\n    }","id":25260,"modified_method":"private void addReferencedGlobalElement(XmlConfigurationCallback callback, Element rootElement, org.w3c.dom.Element dependentElement) throws ParserConfigurationException\n    {\n        if (dependentElement != null)\n        {\n            if (isSpringBean(dependentElement))\n            {\n                wrapElementInSpringBeanContainer(rootElement, dependentElement);\n            }\n            else\n            {\n                rootElement.add(convert(dependentElement));\n                addSchemaLocation(rootElement, dependentElement, callback);\n            }\n            processGlobalReferences(dependentElement, callback, rootElement);\n        }\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doTest(Document document, XmlConfigurationCallback callback, boolean canConnect) throws MuleArtifactFactoryException\n    {\n        doTest(document, callback, TestResult.Status.SUCCESS, canConnect);\n    }","id":25261,"modified_method":"protected void doTest(Document document, XmlConfigurationCallback callback) throws MuleArtifactFactoryException\n    {\n        doTest(document, callback, TestResult.Status.SUCCESS);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doTestMessageProcessor(Document document, XmlConfigurationCallback callback, TestResult.Status expectedResult, boolean canConnect)\n            throws MuleArtifactFactoryException\n    {\n        XmlConfigurationMuleArtifactFactory factory = lookupArtifact();\n        MuleArtifact artifact = null;\n\n        try\n        {\n            artifact = factory.getArtifactForMessageProcessor(document.getDocumentElement(), callback);\n\n            Assert.assertNotNull(artifact);\n            Assert.assertTrue(artifact.hasCapability(OperationMetaDataEnabled.class));\n            Assert.assertTrue(artifact.getCapability(OperationMetaDataEnabled.class) instanceof OperationMetaDataEnabled);\n            if (canConnect)\n            {\n                OperationMetaDataEnabled m = artifact.getCapability(OperationMetaDataEnabled.class);\n                Assert.assertNull(m.getInputMetaData());\n                Assert.assertEquals(expectedResult, m.getOutputMetaData(null).getStatus());\n            }\n        }\n        finally\n        {\n            if (artifact != null)\n            {\n                factory.returnArtifact(artifact);\n            }\n        }\n\n    }","id":25262,"modified_method":"private void doTestMessageProcessor(Document document, XmlConfigurationCallback callback, TestResult.Status expectedResult)\n            throws MuleArtifactFactoryException\n    {\n        XmlConfigurationMuleArtifactFactory factory = lookupArtifact();\n        MuleArtifact artifact = null;\n\n        try\n        {\n            artifact = factory.getArtifactForMessageProcessor(document.getDocumentElement(), callback);\n\n            assertNotNull(artifact);\n            assertTrue(artifact.hasCapability(OperationMetaDataEnabled.class));\n            assertTrue(artifact.getCapability(OperationMetaDataEnabled.class) instanceof OperationMetaDataEnabled);\n            if (expectedResult != null)\n            {\n                OperationMetaDataEnabled m = artifact.getCapability(OperationMetaDataEnabled.class);\n                assertNull(m.getInputMetaData());\n                assertEquals(expectedResult, m.getOutputMetaData(null).getStatus());\n            }\n        }\n        finally\n        {\n            if (artifact != null)\n            {\n                factory.returnArtifact(artifact);\n            }\n        }\n\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doTestMessageProcessor(Document document, XmlConfigurationCallback callback, boolean canConnect) throws MuleArtifactFactoryException\n    {\n        doTestMessageProcessor(document, callback, TestResult.Status.SUCCESS, canConnect);\n    }","id":25263,"modified_method":"protected void doTestMessageProcessor(Document document, XmlConfigurationCallback callback) throws MuleArtifactFactoryException\n    {\n        doTestMessageProcessor(document, callback, TestResult.Status.SUCCESS);\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doTest(Document document, XmlConfigurationCallback callback, TestResult.Status expectedResult, boolean canConnect)\n            throws MuleArtifactFactoryException\n    {\n        XmlConfigurationMuleArtifactFactory factory = lookupArtifact();\n        MuleArtifact artifact = null;\n\n        try\n        {\n            artifact = factory.getArtifact(document.getDocumentElement(), callback);\n            Assert.assertNotNull(artifact);\n            Assert.assertTrue(artifact.hasCapability(Testable.class));\n            Assert.assertTrue(artifact.getCapability(Testable.class) instanceof Testable);\n            if (canConnect)\n            {\n                Testable t = artifact.getCapability(Testable.class);\n                Assert.assertEquals(expectedResult, t.test().getStatus());\n            }\n        }\n        finally\n        {\n            if (artifact != null)\n            {\n                factory.returnArtifact(artifact);\n            }\n        }\n\n    }","id":25264,"modified_method":"private void doTest(Document document, XmlConfigurationCallback callback, TestResult.Status expectedResult)\n            throws MuleArtifactFactoryException\n    {\n        XmlConfigurationMuleArtifactFactory factory = lookupArtifact();\n        MuleArtifact artifact = null;\n\n        try\n        {\n            artifact = factory.getArtifact(document.getDocumentElement(), callback);\n            assertNotNull(artifact);\n            assertTrue(artifact.hasCapability(Testable.class));\n            assertTrue(artifact.getCapability(Testable.class) instanceof Testable);\n            if (expectedResult != null)\n            {\n                Testable t = artifact.getCapability(Testable.class);\n                assertEquals(expectedResult, t.test().getStatus());\n            }\n        }\n        finally\n        {\n            if (artifact != null)\n            {\n                factory.returnArtifact(artifact);\n            }\n        }\n\n    }","commit_id":"09b6698ced2b59a55b34edc00abb95eec57a0827","url":"https://github.com/mulesoft/mule"},{"original_method":"public ExtensiblePolymorphicDomainObjectContainer<BinarySpec> getBinaries() {\n        return binaries;\n    }","id":25265,"modified_method":"@Override\n    public ModelMap<BinarySpec> getBinaries() {\n        return binariesMap;\n    }","commit_id":"9d316fe6464c9ca358863c0a8448d03c1d6d00cd","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void binaries(Action<? super NamedDomainObjectContainer<BinarySpec>> action) {\n        action.execute(binaries);\n    }","id":25266,"modified_method":"@Override\n    public void binaries(Action<? super ModelMap<BinarySpec>> action) {\n        action.execute(binariesMap);\n    }","commit_id":"9d316fe6464c9ca358863c0a8448d03c1d6d00cd","url":"https://github.com/gradle/gradle"},{"original_method":"private BaseComponentSpec(ComponentInfo info) {\n        if (info == null) {\n            throw new ModelInstantiationException(\"Direct instantiation of a BaseComponentSpec is not permitted. Use a ComponentTypeBuilder instead.\");\n        }\n\n        this.identifier = info.componentIdentifier;\n        this.typeName = info.typeName;\n        this.mainSourceSet = info.sourceSets;\n        this.source = ModelMapGroovyDecorator.alwaysMutable(\n            new NamedDomainObjectSetBackedModelMap<LanguageSourceSet>(\n                LanguageSourceSet.class,\n                mainSourceSet,\n                new NamedEntityInstantiator<LanguageSourceSet>() {\n                    public <S extends LanguageSourceSet> S create(String name, Class<S> type) {\n                        mainSourceSet.create(name, type);\n                        return null;\n                    }\n                },\n                new org.gradle.api.Namer<Object>() {\n                    public String determineName(Object object) {\n                        return Cast.cast(Named.class, object).getName();\n                    }\n                }\n            )\n        );\n        this.binaries = info.instantiator.newInstance(DefaultBinaryContainer.class, info.instantiator);\n    }","id":25267,"modified_method":"private BaseComponentSpec(ComponentInfo info) {\n        if (info == null) {\n            throw new ModelInstantiationException(\"Direct instantiation of a BaseComponentSpec is not permitted. Use a ComponentTypeBuilder instead.\");\n        }\n\n        this.identifier = info.componentIdentifier;\n        this.typeName = info.typeName;\n        this.mainSourceSet = info.sourceSets;\n        this.source = ModelMapGroovyDecorator.alwaysMutable(\n            NamedDomainObjectSetBackedModelMap.ofNamed(\n                LanguageSourceSet.class,\n                mainSourceSet,\n                new NamedEntityInstantiator<LanguageSourceSet>() {\n                    public <S extends LanguageSourceSet> S create(String name, Class<S> type) {\n                        mainSourceSet.create(name, type);\n                        return null;\n                    }\n                }\n            )\n        );\n        this.binaries = info.instantiator.newInstance(DefaultBinaryContainer.class, info.instantiator);\n        this.binariesMap = ModelMapGroovyDecorator.alwaysMutable(\n            NamedDomainObjectSetBackedModelMap.ofNamed(\n                BinarySpec.class,\n                this.binaries,\n                this.binaries\n            )\n        );\n    }","commit_id":"9d316fe6464c9ca358863c0a8448d03c1d6d00cd","url":"https://github.com/gradle/gradle"},{"original_method":"@Mutate\n        public void copyCUnitTestBinariesToGlobalContainer(final BinaryContainer binaries, TestSuiteContainer testSuites) {\n            for (final CUnitTestSuiteSpec cUnitTestSuite : testSuites.withType(CUnitTestSuiteSpec.class).values()) {\n                for (NativeBinarySpec testedBinary : cUnitTestSuite.getTestedComponent().getBinaries().withType(NativeBinarySpec.class)) {\n                    binaries.addAll(cUnitTestSuite.getBinaries().withType(CUnitTestSuiteBinarySpec.class));\n                }\n            }\n        }","id":25268,"modified_method":"@Mutate\n        public void copyCUnitTestBinariesToGlobalContainer(final BinaryContainer binaries, TestSuiteContainer testSuites) {\n            for (final CUnitTestSuiteSpec cUnitTestSuite : testSuites.withType(CUnitTestSuiteSpec.class).values()) {\n                for (NativeBinarySpec testedBinary : cUnitTestSuite.getTestedComponent().getBinaries().withType(NativeBinarySpec.class).values()) {\n                    binaries.addAll(cUnitTestSuite.getBinaries().withType(CUnitTestSuiteBinarySpec.class).values());\n                }\n            }\n        }","commit_id":"9d316fe6464c9ca358863c0a8448d03c1d6d00cd","url":"https://github.com/gradle/gradle"},{"original_method":"public void execute(final MutableModelNode modelNode, final ComponentSpecContainer componentSpecs, final List<ModelView<?>> modelMapRuleInputs) {\n            TriAction<MutableModelNode, C, List<ModelView<?>>> action = new TriAction<MutableModelNode, C, List<ModelView<?>>>() {\n                @Override\n                public void execute(MutableModelNode componentModelNode, C component, List<ModelView<?>> componentRuleInputs) {\n                    ComponentSpecInternal componentSpecInternal = uncheckedCast(componentModelNode.getPrivateData());\n                    MutableModelNode binariesNode = componentModelNode.getLink(\"binaries\");\n                    DefaultModelViewState binariesState = new DefaultModelViewState(DefaultModelMap.modelMapTypeOf(binaryType), getDescriptor());\n                    ModelMap<BinarySpec> binarySpecs = new ModelMapGroovyDecorator<BinarySpec>(\n                        new PolymorphicDomainObjectContainerBackedModelMap<BinarySpec>(\n                            componentSpecInternal.getBinaries(), ModelType.of(BinarySpec.class), binariesNode, getDescriptor()\n                        ),\n                        binariesState\n                    );\n                    try {\n                        invoke(componentRuleInputs, binarySpecs.withType(binaryType), componentSpecInternal);\n                    } finally {\n                        binariesState.close();\n                    }\n                }\n            };\n            modelNode.applyToAllLinks(ModelActionRole.Mutate, TriActionBackedModelAction.of(ModelReference.of(ModelType.of(componentType)), getDescriptor(), getInputs(), action));\n        }","id":25269,"modified_method":"public void execute(final MutableModelNode modelNode, final ComponentSpecContainer componentSpecs, final List<ModelView<?>> modelMapRuleInputs) {\n            TriAction<MutableModelNode, C, List<ModelView<?>>> action = new TriAction<MutableModelNode, C, List<ModelView<?>>>() {\n                @Override\n                public void execute(MutableModelNode componentModelNode, C component, List<ModelView<?>> componentRuleInputs) {\n                    ComponentSpecInternal componentSpecInternal = uncheckedCast(componentModelNode.getPrivateData());\n                    MutableModelNode binariesNode = componentModelNode.getLink(\"binaries\");\n                    DefaultModelViewState binariesState = new DefaultModelViewState(DefaultModelMap.modelMapTypeOf(binaryType), getDescriptor());\n                    ModelMap<BinarySpec> binarySpecs = new ModelMapGroovyDecorator<BinarySpec>(\n                        new PolymorphicDomainObjectContainerBackedModelMap<BinarySpec>(\n                            componentSpecInternal.getBinariesContainer(), ModelType.of(BinarySpec.class), binariesNode, getDescriptor()\n                        ),\n                        binariesState\n                    );\n                    try {\n                        invoke(componentRuleInputs, binarySpecs.withType(binaryType), componentSpecInternal);\n                    } finally {\n                        binariesState.close();\n                    }\n                }\n            };\n            modelNode.applyToAllLinks(ModelActionRole.Mutate, TriActionBackedModelAction.of(ModelReference.of(ModelType.of(componentType)), getDescriptor(), getInputs(), action));\n        }","commit_id":"9d316fe6464c9ca358863c0a8448d03c1d6d00cd","url":"https://github.com/gradle/gradle"},{"original_method":"@Defaults\n        void collectBinaries(BinaryContainer binaries, ComponentSpecContainer componentSpecs) {\n            for (ComponentSpec componentSpec : componentSpecs.values()) {\n                for (BinarySpec binary : componentSpec.getBinaries()) {\n                    binaries.add(binary);\n                }\n            }\n        }","id":25270,"modified_method":"@Defaults\n        void collectBinaries(BinaryContainer binaries, ComponentSpecContainer componentSpecs) {\n            for (ComponentSpec componentSpec : componentSpecs.values()) {\n                for (BinarySpec binary : componentSpec.getBinaries().values()) {\n                    binaries.add(binary);\n                }\n            }\n        }","commit_id":"9d316fe6464c9ca358863c0a8448d03c1d6d00cd","url":"https://github.com/gradle/gradle"},{"original_method":"@Defaults\n            void apply(ComponentSpec componentSpec, BinarySpecFactoryRegistry binaryFactoryRegistry) {\n                ComponentSpecInternal componentSpecInternal = uncheckedCast(componentSpec);\n                binaryFactoryRegistry.copyInto(componentSpecInternal.getBinaries());\n            }","id":25271,"modified_method":"@Defaults\n            void apply(ComponentSpec componentSpec, BinarySpecFactoryRegistry binaryFactoryRegistry) {\n                ComponentSpecInternal componentSpecInternal = uncheckedCast(componentSpec);\n                binaryFactoryRegistry.copyInto(componentSpecInternal.getBinariesContainer());\n            }","commit_id":"9d316fe6464c9ca358863c0a8448d03c1d6d00cd","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void render(ComponentSpec component, TextReportBuilder builder) {\n        builder.subheading(StringUtils.capitalize(component.getDisplayName()));\n        builder.getOutput().println();\n        builder.collection(\"Source sets\", component.getSource().values(), sourceSetRenderer, \"source sets\");\n        builder.getOutput().println();\n        builder.collection(\"Binaries\", CollectionUtils.sort(component.getBinaries(), new Comparator<BinarySpec>() {\n            public int compare(BinarySpec binary1, BinarySpec binary2) {\n                return binary1.getName().compareTo(binary2.getName());\n            }\n        }), binaryRenderer, \"binaries\");\n    }","id":25272,"modified_method":"@Override\n    public void render(ComponentSpec component, TextReportBuilder builder) {\n        builder.subheading(StringUtils.capitalize(component.getDisplayName()));\n        builder.getOutput().println();\n        builder.collection(\"Source sets\", component.getSource().values(), sourceSetRenderer, \"source sets\");\n        builder.getOutput().println();\n        builder.collection(\"Binaries\", CollectionUtils.sort(component.getBinaries().values(), new Comparator<BinarySpec>() {\n            public int compare(BinarySpec binary1, BinarySpec binary2) {\n                return binary1.getName().compareTo(binary2.getName());\n            }\n        }), binaryRenderer, \"binaries\");\n    }","commit_id":"9d316fe6464c9ca358863c0a8448d03c1d6d00cd","url":"https://github.com/gradle/gradle"},{"original_method":"public void renderComponents(Collection<ComponentSpec> components) {\n        if (components.isEmpty()) {\n            getTextOutput().withStyle(Info).println(\"No components defined for this project.\");\n            return;\n        }\n        boolean seen = false;\n        for (ComponentSpec component : components) {\n            if (seen) {\n                getBuilder().getOutput().println();\n            } else {\n                seen = true;\n            }\n            componentRenderer.render(component, getBuilder());\n            componentSourceSets.addAll(component.getSource().values());\n            componentBinaries.addAll(component.getBinaries());\n        }\n    }","id":25273,"modified_method":"public void renderComponents(Collection<ComponentSpec> components) {\n        if (components.isEmpty()) {\n            getTextOutput().withStyle(Info).println(\"No components defined for this project.\");\n            return;\n        }\n        boolean seen = false;\n        for (ComponentSpec component : components) {\n            if (seen) {\n                getBuilder().getOutput().println();\n            } else {\n                seen = true;\n            }\n            componentRenderer.render(component, getBuilder());\n            componentSourceSets.addAll(component.getSource().values());\n            componentBinaries.addAll(component.getBinaries().values());\n        }\n    }","commit_id":"9d316fe6464c9ca358863c0a8448d03c1d6d00cd","url":"https://github.com/gradle/gradle"},{"original_method":"private static BiAction<MutableModelNode, ComponentSpec> createAction() {\n        Transformer<NamedDomainObjectCollection<LanguageSourceSet>, ComponentSpecInternal> sourcesPropertyTransformer = new Transformer<NamedDomainObjectCollection<LanguageSourceSet>, ComponentSpecInternal>() {\n            public NamedDomainObjectCollection<LanguageSourceSet> transform(ComponentSpecInternal componentSpec) {\n                return componentSpec.getSources();\n            }\n        };\n        BiAction<MutableModelNode, ComponentSpec> sourcePropertyRegistrar = domainObjectCollectionModelRegistrar(\"sources\", namedDomainObjectCollectionOf(LanguageSourceSet.class),\n                sourcesPropertyTransformer);\n\n        Transformer<NamedDomainObjectCollection<BinarySpec>, ComponentSpecInternal> binariesPropertyTransformer = new Transformer<NamedDomainObjectCollection<BinarySpec>, ComponentSpecInternal>() {\n            public NamedDomainObjectCollection<BinarySpec> transform(ComponentSpecInternal componentSpec) {\n                return componentSpec.getBinaries();\n            }\n        };\n        ModelType<NamedDomainObjectCollection<BinarySpec>> binariesType = namedDomainObjectCollectionOf(BinarySpec.class);\n        BiAction<BinarySpec, ComponentSpecInternal> binaryInitializationAction = new BiAction<BinarySpec, ComponentSpecInternal>() {\n            public void execute(BinarySpec binary, ComponentSpecInternal component) {\n                BinarySpecInternal binaryInternal = uncheckedCast(binary);\n                binaryInternal.setBinarySources(component.getSources().copy(binary.getName()));\n            }\n        };\n        BiAction<MutableModelNode, ComponentSpec> binariesPropertyRegistrar = domainObjectCollectionModelRegistrar(\"binaries\", binariesType, binariesPropertyTransformer, binaryInitializationAction);\n        @SuppressWarnings(\"unchecked\")\n        BiAction<MutableModelNode, ComponentSpec> initializer = BiActions.composite(sourcePropertyRegistrar, binariesPropertyRegistrar);\n        return initializer;\n    }","id":25274,"modified_method":"private static BiAction<MutableModelNode, ComponentSpec> createAction() {\n        Transformer<NamedDomainObjectCollection<LanguageSourceSet>, ComponentSpecInternal> sourcesPropertyTransformer = new Transformer<NamedDomainObjectCollection<LanguageSourceSet>, ComponentSpecInternal>() {\n            public NamedDomainObjectCollection<LanguageSourceSet> transform(ComponentSpecInternal componentSpec) {\n                return componentSpec.getSources();\n            }\n        };\n        BiAction<MutableModelNode, ComponentSpec> sourcePropertyRegistrar = domainObjectCollectionModelRegistrar(\"sources\", namedDomainObjectCollectionOf(LanguageSourceSet.class),\n                sourcesPropertyTransformer);\n\n        Transformer<NamedDomainObjectCollection<BinarySpec>, ComponentSpecInternal> binariesPropertyTransformer = new Transformer<NamedDomainObjectCollection<BinarySpec>, ComponentSpecInternal>() {\n            public NamedDomainObjectCollection<BinarySpec> transform(ComponentSpecInternal componentSpec) {\n                return componentSpec.getBinariesContainer();\n            }\n        };\n        ModelType<NamedDomainObjectCollection<BinarySpec>> binariesType = namedDomainObjectCollectionOf(BinarySpec.class);\n        BiAction<BinarySpec, ComponentSpecInternal> binaryInitializationAction = new BiAction<BinarySpec, ComponentSpecInternal>() {\n            public void execute(BinarySpec binary, ComponentSpecInternal component) {\n                BinarySpecInternal binaryInternal = uncheckedCast(binary);\n                binaryInternal.setBinarySources(component.getSources().copy(binary.getName()));\n            }\n        };\n        BiAction<MutableModelNode, ComponentSpec> binariesPropertyRegistrar = domainObjectCollectionModelRegistrar(\"binaries\", binariesType, binariesPropertyTransformer, binaryInitializationAction);\n        @SuppressWarnings(\"unchecked\")\n        BiAction<MutableModelNode, ComponentSpec> initializer = BiActions.composite(sourcePropertyRegistrar, binariesPropertyRegistrar);\n        return initializer;\n    }","commit_id":"9d316fe6464c9ca358863c0a8448d03c1d6d00cd","url":"https://github.com/gradle/gradle"},{"original_method":"@Mutate\n        public void copyCUnitTestBinariesToGlobalContainer(final BinaryContainer binaries, TestSuiteContainer testSuites) {\n            for (GoogleTestTestSuiteSpec testSuite : testSuites.withType(GoogleTestTestSuiteSpec.class).values()) {\n                for (NativeBinarySpec testedBinary : testSuite.getTestedComponent().getBinaries().withType(NativeBinarySpec.class)) {\n                    binaries.addAll(testSuite.getBinaries().withType(GoogleTestTestSuiteBinarySpec.class));\n                }\n            }\n        }","id":25275,"modified_method":"@Mutate\n        public void copyCUnitTestBinariesToGlobalContainer(final BinaryContainer binaries, TestSuiteContainer testSuites) {\n            for (GoogleTestTestSuiteSpec testSuite : testSuites.withType(GoogleTestTestSuiteSpec.class).values()) {\n                for (NativeBinarySpec testedBinary : testSuite.getTestedComponent().getBinaries().withType(NativeBinarySpec.class).values()) {\n                    binaries.addAll(testSuite.getBinaries().withType(GoogleTestTestSuiteBinarySpec.class).values());\n                }\n            }\n        }","commit_id":"9d316fe6464c9ca358863c0a8448d03c1d6d00cd","url":"https://github.com/gradle/gradle"},{"original_method":"public DomainObjectSet<NativeLibraryBinary> getBinaries(NativeLibraryRequirement requirement) {\n        ProjectInternal project = findProject(requirement);\n        ModelRegistry modelRegistry = project.getModelRegistry();\n        ComponentSpecContainer components = modelRegistry.find(ModelPath.path(\"components\"), ModelType.of(ComponentSpecContainer.class));\n        if (components == null) {\n            throw new LibraryResolveException(String.format(\"Project does not have a libraries container: '%s'\", project.getPath()));\n        }\n        String libraryName = requirement.getLibraryName();\n        NativeLibrarySpec library = components.withType(NativeLibrarySpec.class).get(libraryName);\n        if (library == null) {\n            throw new UnknownDomainObjectException(String.format(\"%s with name '%s' not found.\", NativeLibrarySpec.class.getSimpleName(), libraryName));\n        }\n        NamedDomainObjectCollection<NativeBinarySpec> projectBinaries = library.getBinaries().withType(NativeBinarySpec.class);\n        DomainObjectSet<NativeLibraryBinary> binaries = new DefaultDomainObjectSet<NativeLibraryBinary>(NativeLibraryBinary.class);\n        // TODO:DAZ Convert, don't cast\n        for (NativeBinarySpec nativeBinarySpec : projectBinaries) {\n            binaries.add((NativeLibraryBinary) nativeBinarySpec);\n        }\n        return binaries;\n    }","id":25276,"modified_method":"public DomainObjectSet<NativeLibraryBinary> getBinaries(NativeLibraryRequirement requirement) {\n        ProjectInternal project = findProject(requirement);\n        ModelRegistry modelRegistry = project.getModelRegistry();\n        ComponentSpecContainer components = modelRegistry.find(ModelPath.path(\"components\"), ModelType.of(ComponentSpecContainer.class));\n        if (components == null) {\n            throw new LibraryResolveException(String.format(\"Project does not have a libraries container: '%s'\", project.getPath()));\n        }\n        String libraryName = requirement.getLibraryName();\n        NativeLibrarySpec library = components.withType(NativeLibrarySpec.class).get(libraryName);\n        if (library == null) {\n            throw new UnknownDomainObjectException(String.format(\"%s with name '%s' not found.\", NativeLibrarySpec.class.getSimpleName(), libraryName));\n        }\n        ModelMap<NativeBinarySpec> projectBinaries = library.getBinaries().withType(NativeBinarySpec.class);\n        DomainObjectSet<NativeLibraryBinary> binaries = new DefaultDomainObjectSet<NativeLibraryBinary>(NativeLibraryBinary.class);\n        // TODO:DAZ Convert, don't cast\n        for (NativeBinarySpec nativeBinarySpec : projectBinaries.values()) {\n            binaries.add((NativeLibraryBinary) nativeBinarySpec);\n        }\n        return binaries;\n    }","commit_id":"9d316fe6464c9ca358863c0a8448d03c1d6d00cd","url":"https://github.com/gradle/gradle"},{"original_method":"@NotNull\n  private static ISVNStatusFileProvider createFileProvider(@NotNull Map<String, SvnScopeZipper.MyDirNonRecursive> nonRecursiveMap) {\n    final Map<String, Map<String, File>> preparedMap = ContainerUtil.newHashMap();\n\n    for (SvnScopeZipper.MyDirNonRecursive item : nonRecursiveMap.values()) {\n      Map<String, File> result = ContainerUtil.newHashMap();\n\n      for (FilePath path : item.getChildrenList()) {\n        result.put(path.getName(), path.getIOFile());\n      }\n      preparedMap.put(item.getDir().getIOFile().getAbsolutePath(), result);\n    }\n\n    return new ISVNStatusFileProvider() {\n      @Override\n      public Map<String, File> getChildrenFiles(File parent) {\n        return preparedMap.get(parent.getAbsolutePath());\n      }\n    };\n  }","id":25277,"modified_method":"@NotNull\n  private static ISVNStatusFileProvider createFileProvider(@NotNull Map<String, SvnScopeZipper.MyDirNonRecursive> nonRecursiveMap) {\n    final Map<String, Map<String, File>> result = ContainerUtil.newHashMap();\n\n    for (SvnScopeZipper.MyDirNonRecursive item : nonRecursiveMap.values()) {\n      File file = item.getDir().getIOFile();\n\n      Map<String, File> fileMap = ContainerUtil.getOrCreate(result, file.getAbsolutePath(), NAME_TO_FILE_MAP_FACTORY);\n      for (FilePath path : item.getChildrenList()) {\n        fileMap.put(path.getName(), path.getIOFile());\n      }\n\n      // also add currently processed file to the map of its parent, as there are cases when SVNKit calls ISVNStatusFileProvider with file\n      // parent (and not file that was passed to doStatus()), gets null result and does not provide any status\n      // see http://issues.tmatesoft.com/issue/SVNKIT-567 for details\n      if (file.getParentFile() != null) {\n        Map<String, File> parentMap = ContainerUtil.getOrCreate(result, file.getParentFile().getAbsolutePath(), NAME_TO_FILE_MAP_FACTORY);\n\n        parentMap.put(file.getName(), file);\n      }\n    }\n\n    return new ISVNStatusFileProvider() {\n      @Override\n      public Map<String, File> getChildrenFiles(File parent) {\n        return result.get(parent.getAbsolutePath());\n      }\n    };\n  }","commit_id":"ddc19061b3f6eca0c69ff6e8a10b7dae36ba8c58","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getRenamedText() {\n    return VcsBundle.message(\"change.file.renamed.from.text\", myBeforeRevision.getFile().getName());\n  }","id":25278,"modified_method":"@Nullable\n  protected String getRenamedText() {\n    return VcsBundle.message(\"change.file.renamed.from.text\", myBeforeRevision.getFile().getName());\n  }","commit_id":"6d446a7b3689b99628c234b8e99c6bc6974a8f3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getMovedText(final Project project) {\n    return VcsBundle.message(\"change.file.moved.from.text\", getMoveRelativePath(project));\n  }","id":25279,"modified_method":"@Nullable\n  protected String getMovedText(final Project project) {\n    return VcsBundle.message(\"change.file.moved.from.text\", getMoveRelativePath(project));\n  }","commit_id":"6d446a7b3689b99628c234b8e99c6bc6974a8f3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void render(final ChangesBrowserNodeRenderer renderer, final boolean selected, final boolean expanded, final boolean hasFocus) {\n    final Change change = getUserObject();\n    final FilePath filePath = ChangesUtil.getFilePath(change);\n    final String fileName = filePath.getName();\n    VirtualFile vFile = filePath.getVirtualFile();\n    final Color changeColor = change.getFileStatus().getColor();\n    renderer.appendFileName(vFile, fileName, changeColor);\n\n    if (change.isRenamed()) {\n      renderer.append(\" \" + change.getRenamedText(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n    }\n    else if (change.isMoved()) {\n      renderer.append(\" \" + change.getMovedText(myProject), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n    }\n\n    if (renderer.isShowFlatten()) {\n      final File parentFile = filePath.getIOFile().getParentFile();\n      if (parentFile != null) {\n        renderer.append(\" (\" + parentFile.getPath() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      }\n      appendSwitched(renderer);\n    }\n    else if (getCount() != 1 || getDirectoryCount() != 0) {\n      appendSwitched(renderer);\n      appendCount(renderer);\n    }\n    else {\n      appendSwitched(renderer);\n    }\n\n    if (filePath.isDirectory() || !isLeaf()) {\n      renderer.setIcon(expanded ? Icons.DIRECTORY_OPEN_ICON : Icons.DIRECTORY_CLOSED_ICON);\n    }\n    else {\n      renderer.setIcon(filePath.getFileType().getIcon());\n    }\n  }","id":25280,"modified_method":"@Override\n  public void render(final ChangesBrowserNodeRenderer renderer, final boolean selected, final boolean expanded, final boolean hasFocus) {\n    final Change change = getUserObject();\n    final FilePath filePath = ChangesUtil.getFilePath(change);\n    final String fileName = filePath.getName();\n    VirtualFile vFile = filePath.getVirtualFile();\n    final Color changeColor = change.getFileStatus().getColor();\n    renderer.appendFileName(vFile, fileName, changeColor);\n\n    final String originText = change.getOriginText(myProject);\n    if (originText != null) {\n      renderer.append(\" \" + originText, SimpleTextAttributes.REGULAR_ATTRIBUTES);\n    }\n\n    if (renderer.isShowFlatten()) {\n      final File parentFile = filePath.getIOFile().getParentFile();\n      if (parentFile != null) {\n        renderer.append(\" (\" + parentFile.getPath() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      }\n      appendSwitched(renderer);\n    }\n    else if (getCount() != 1 || getDirectoryCount() != 0) {\n      appendSwitched(renderer);\n      appendCount(renderer);\n    }\n    else {\n      appendSwitched(renderer);\n    }\n\n    if (filePath.isDirectory() || !isLeaf()) {\n      renderer.setIcon(expanded ? Icons.DIRECTORY_OPEN_ICON : Icons.DIRECTORY_CLOSED_ICON);\n    }\n    else {\n      renderer.setIcon(filePath.getFileType().getIcon());\n    }\n  }","commit_id":"6d446a7b3689b99628c234b8e99c6bc6974a8f3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getRenamedText() {\n    return VcsBundle.message((getBeforeRevision() != null) ? \"change.file.renamed.to.text\" : \"change.file.renamed.from.text\", myRenamedTargetName);\n  }","id":25281,"modified_method":"@Nullable\n  protected String getRenamedText() {\n    if (myRenamedTargetName != null) {\n      return VcsBundle.message((getBeforeRevision() != null) ? \"change.file.renamed.to.text\" : \"change.file.renamed.from.text\", myRenamedTargetName);\n    }\n    return super.getRenamedText();\n  }","commit_id":"6d446a7b3689b99628c234b8e99c6bc6974a8f3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setRenamedOrMovedTarget(final FilePath target) {\n    myMoved = myRenamed = false;\n    \n    if ((getBeforeRevision() != null) && (getAfterRevision() != null)) {\n      // not external rename or move\n      return;\n    }\n    final FilePath localPath = ChangesUtil.getFilePath(this);\n    if (localPath.getIOFile().getAbsolutePath().equals(target.getIOFile().getAbsolutePath())) {\n      // not rename or move\n      return;\n    }\n\n    if (Comparing.equal(target.getParentPath(), localPath.getParentPath())) {\n      myRenamed = true;\n    } else {\n      myMoved = true;\n    }\n\n    myRenamedTargetName = target.getName();\n    myRenameOrMoveCached = true;\n  }","id":25282,"modified_method":"public void setRenamedOrMovedTarget(final FilePath target) {\n    myMoved = myRenamed = false;\n\n    if ((getBeforeRevision() != null) || (getAfterRevision() == null)) {\n      // not external rename or move\n      return;\n    }\n    final FilePath localPath = ChangesUtil.getFilePath(this);\n    if (localPath.getIOFile().getAbsolutePath().equals(target.getIOFile().getAbsolutePath())) {\n      // not rename or move\n      return;\n    }\n\n    if (Comparing.equal(target.getParentPath(), localPath.getParentPath())) {\n      myRenamed = true;\n    } else {\n      myMoved = true;\n    }\n    myCopied = false;\n\n    myRenamedTargetName = target.getName();\n    myRenameOrMoveCached = true;\n  }","commit_id":"6d446a7b3689b99628c234b8e99c6bc6974a8f3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ExternallyRenamedChange(final ContentRevision beforeRevision, final ContentRevision afterRevision) {\n    super(beforeRevision, afterRevision);\n  }","id":25283,"modified_method":"public ExternallyRenamedChange(final ContentRevision beforeRevision, final ContentRevision afterRevision, final String originUrl) {\n    super(beforeRevision, afterRevision);\n    myOriginUrl = originUrl;\n    myCopied = true;\n  }","commit_id":"6d446a7b3689b99628c234b8e99c6bc6974a8f3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getMovedText(final Project project) {\n    return VcsBundle.message((getBeforeRevision() != null) ? \"change.file.moved.to.text\" : \"change.file.moved.from.text\", myRenamedTargetName);\n  }","id":25284,"modified_method":"@Nullable\n  protected String getMovedText(final Project project) {\n    if (myRenamedTargetName != null) {\n      return VcsBundle.message((getBeforeRevision() != null) ? \"change.file.moved.to.text\" : \"change.file.moved.from.text\", myRenamedTargetName);\n    }\n    return super.getMovedText(project);\n  }","commit_id":"6d446a7b3689b99628c234b8e99c6bc6974a8f3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getPresentableRelativePath(final ContentRevision fromRevision, final ContentRevision toRevision) {\n    // need to use parent path because the old file is already not there\n    final VirtualFile oldFile = fromRevision.getFile().getParentPath().getVirtualFile();\n    final VirtualFile newFile = toRevision.getFile().getParentPath().getVirtualFile();\n    if (oldFile != null && newFile != null) {\n      Module oldModule = ModuleUtil.findModuleForFile(oldFile, myProject);\n      Module newModule = ModuleUtil.findModuleForFile(newFile, myProject);\n      if (oldModule != newModule) {\n        return getPresentableRelativePathFor(oldFile);\n      }\n    }\n    return FileUtil.getRelativePath(toRevision.getFile().getIOFile(), fromRevision.getFile().getIOFile());\n  }","id":25285,"modified_method":"public String getPresentableRelativePath(final ContentRevision fromRevision, final ContentRevision toRevision) {\n    // need to use parent path because the old file is already not there\n    final VirtualFile oldFile = fromRevision.getFile().getParentPath().getVirtualFile();\n    final VirtualFile newFile = toRevision.getFile().getParentPath().getVirtualFile();\n    if (oldFile != null && newFile != null) {\n      Module oldModule = ModuleUtil.findModuleForFile(oldFile, myProject);\n      Module newModule = ModuleUtil.findModuleForFile(newFile, myProject);\n      if (oldModule != newModule) {\n        return getPresentableRelativePathFor(oldFile);\n      }\n    }\n    final RelativePathCalculator calculator =\n      new RelativePathCalculator(toRevision.getFile().getIOFile().getAbsolutePath(), fromRevision.getFile().getIOFile().getAbsolutePath());\n    calculator.execute();\n    final String result = calculator.getResult();\n    return (result == null) ? null : result.replace(\"/\", File.separator);\n  }","commit_id":"6d446a7b3689b99628c234b8e99c6bc6974a8f3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void execute() {\n    final String[] baseParts = split(myBase);\n    final String[] shiftedParts = split(myShifted);\n\n    myRename = checkRename(baseParts, shiftedParts);\n\n    int cnt = 0;\n    while (true) {\n      if ((baseParts.length <= cnt) || (shiftedParts.length <= cnt)) {\n        // means that directory moved to a file or vise versa -> error\n        return;\n      }\n      if (! baseParts[cnt].equals(shiftedParts[cnt])) {\n        break;\n      }\n      ++ cnt;\n    }\n\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < (baseParts.length - cnt - 1); i++) {\n      sb.append(\"../\");\n    }\n\n    for (int i = cnt; i < shiftedParts.length; i++) {\n      final String shiftedPart = shiftedParts[i];\n      sb.append(shiftedPart);\n      if (i < (shiftedParts.length - 1)) {\n        sb.append('/');\n      }\n    }\n\n    myResult = sb.toString();\n  }","id":25286,"modified_method":"public void execute() {\n    if (myShifted == null || myBase == null) {\n      myResult = null;\n      return;\n    }\n    if (myShifted.equals(myBase)) {\n      myResult = \".\";\n      myRename = false;\n      return;\n    }\n    final String[] baseParts = split(myBase);\n    final String[] shiftedParts = split(myShifted);\n\n    myRename = checkRename(baseParts, shiftedParts);\n\n    int cnt = 0;\n    while (true) {\n      if ((baseParts.length <= cnt) || (shiftedParts.length <= cnt)) {\n        // means that directory moved to a file or vise versa -> error\n        return;\n      }\n      if (! baseParts[cnt].equals(shiftedParts[cnt])) {\n        break;\n      }\n      ++ cnt;\n    }\n\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < (baseParts.length - cnt - 1); i++) {\n      sb.append(\"../\");\n    }\n\n    for (int i = cnt; i < shiftedParts.length; i++) {\n      final String shiftedPart = shiftedParts[i];\n      sb.append(shiftedPart);\n      if (i < (shiftedParts.length - 1)) {\n        sb.append('/');\n      }\n    }\n\n    myResult = sb.toString();\n  }","commit_id":"6d446a7b3689b99628c234b8e99c6bc6974a8f3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test(groups=\"Integration\")\n    public void detectFailureIfTomcatCantBindToPort() throws Exception {\n        ServerSocket listener = new ServerSocket(DEFAULT_HTTP_PORT);\n        try {\n            app = (TestApplication) ApplicationBuilder.builder(TestApplication.class).manage();\n            tc = app.createAndManageChild(BasicEntitySpec.newInstance(TomcatServer.class).configure(\"httpPort\",DEFAULT_HTTP_PORT));\n            \n            try {\n                tc.start(ImmutableList.of(new LocalhostMachineProvisioningLocation()));\n                fail(\"Should have thrown start-exception\");\n            } catch (Exception e) {\n                // LocalhostMachineProvisioningLocation does NetworkUtils.isPortAvailable, so get -1\n                IllegalArgumentException iae = Throwables2.getFirstThrowableOfType(e, IllegalArgumentException.class);\n                if (iae == null || iae.getMessage() == null || !iae.getMessage().equals(\"port for httpPort is null\")) throw e;\n            } finally {\n                tc.stop();\n            }\n            assertFalse(tc.getAttribute(TomcatServerImpl.SERVICE_UP));\n        } finally {\n            listener.close();\n        }\n    }","id":25287,"modified_method":"@Test(groups=\"Integration\")\n    public void detectFailureIfTomcatCantBindToPort() throws Exception {\n        ServerSocket listener = new ServerSocket(DEFAULT_HTTP_PORT);\n        try {\n            app = ApplicationBuilder.builder(TestApplication.class).manage();\n            tc = app.createAndManageChild(BasicEntitySpec.newInstance(TomcatServer.class).configure(\"httpPort\",DEFAULT_HTTP_PORT));\n            \n            try {\n                tc.start(ImmutableList.of(new LocalhostMachineProvisioningLocation()));\n                fail(\"Should have thrown start-exception\");\n            } catch (Exception e) {\n                // LocalhostMachineProvisioningLocation does NetworkUtils.isPortAvailable, so get -1\n                IllegalArgumentException iae = Throwables2.getFirstThrowableOfType(e, IllegalArgumentException.class);\n                if (iae == null || iae.getMessage() == null || !iae.getMessage().equals(\"port for httpPort is null\")) throw e;\n            } finally {\n                tc.stop();\n            }\n            assertFalse(tc.getAttribute(TomcatServerImpl.SERVICE_UP));\n        } finally {\n            listener.close();\n        }\n    }","commit_id":"c5b353b4207e379d41ee3a19b487371996cc693a","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public final Application manage() {\n        return manage(Entities.newManagementContext());\n    }","id":25288,"modified_method":"public final StartableApplication manage() {\n        return manage(Entities.newManagementContext());\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static Builder<BasicApplication> builder() {\n        return new Builder<BasicApplication>().app(BasicEntitySpec.newInstance(BasicApplication.class));\n    }","id":25289,"modified_method":"public static Builder<StartableApplication> builder() {\n        return new Builder<StartableApplication>().app(BasicEntitySpec.newInstance(BasicApplication.class));\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public ApplicationBuilder(EntitySpec<? extends Application> appSpec) {\n        this.appSpec = WrappingEntitySpec.newInstance(appSpec);\n    }","id":25290,"modified_method":"public ApplicationBuilder(EntitySpec<? extends StartableApplication> appSpec) {\n        this.appSpec = WrappingEntitySpec.newInstance(appSpec);\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected final Application getApp() {\n        return checkNotNull(app, \"must only be called after manage()\");\n    }","id":25291,"modified_method":"protected final StartableApplication getApp() {\n        return checkNotNull(app, \"must only be called after manage()\");\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public final Application manage(ManagementContext managementContext) {\n        checkNotManaged();\n        this.app = managementContext.getEntityManager().createEntity(appSpec);\n        this.managementContext = managementContext;\n        doBuild();\n        Entities.startManagement(app, managementContext);\n        managed = true;\n        return app;\n    }","id":25292,"modified_method":"public final StartableApplication manage(ManagementContext managementContext) {\n        checkNotManaged();\n        this.app = managementContext.getEntityManager().createEntity(appSpec);\n        this.managementContext = managementContext;\n        doBuild();\n        Entities.startManagement(app, managementContext);\n        managed = true;\n        return app;\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String locations = CommandLineUtil.getCommandLineOption(args, \"--locations\", Joiner.on(\",\").join(DEFAULT_LOCATIONS));\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        // TODO instead use server.getManagementContext().getLocationRegistry().resolve(location)\n        List<Location> locs = new LocationRegistry().getLocationsById(Arrays.asList(locations));\n\n        BasicApplication app = (BasicApplication) new GlobalWebFabricExample()\n                .appDisplayName(\"Brooklyn Global Web Fabric Example\")\n                .manage(server.getManagementContext());\n        \n        app.start(locs);\n        \n        Entities.dumpInfo(app);\n    }","id":25293,"modified_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String locations = CommandLineUtil.getCommandLineOption(args, \"--locations\", Joiner.on(\",\").join(DEFAULT_LOCATIONS));\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        // TODO instead use server.getManagementContext().getLocationRegistry().resolve(location)\n        List<Location> locs = new LocationRegistry().getLocationsById(Arrays.asList(locations));\n\n        StartableApplication app = new GlobalWebFabricExample()\n                .appDisplayName(\"Brooklyn Global Web Fabric Example\")\n                .manage(server.getManagementContext());\n        \n        app.start(locs);\n        \n        Entities.dumpInfo(app);\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testCreatesEntity() throws Exception {\n        EntitySpec<BasicApplication> spec = BasicEntitySpec.newInstance(BasicApplication.class);\n        BasicApplicationImpl app = (BasicApplicationImpl) factory.createEntity(spec);\n        \n        Entity proxy = app.getProxy();\n        assertTrue(proxy instanceof Application, \"proxy=\"+app);\n        assertFalse(proxy instanceof BasicApplicationImpl, \"proxy=\"+app);\n        \n        assertEquals(proxy.getParent(), null);\n        assertSame(proxy.getApplication(), proxy);\n    }","id":25294,"modified_method":"@Test\n    public void testCreatesEntity() throws Exception {\n        EntitySpec<TestApplication> spec = BasicEntitySpec.newInstance(TestApplication.class);\n        TestApplicationImpl app = (TestApplicationImpl) factory.createEntity(spec);\n        \n        Entity proxy = app.getProxy();\n        assertTrue(proxy instanceof Application, \"proxy=\"+app);\n        assertFalse(proxy instanceof TestApplicationImpl, \"proxy=\"+app);\n        \n        assertEquals(proxy.getParent(), null);\n        assertSame(proxy.getApplication(), proxy);\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testCreatesProxy() throws Exception {\n        BasicApplication app = new BasicApplicationImpl();\n        Application proxy = factory.createEntityProxy(Application.class, app);\n        \n        assertFalse(proxy instanceof BasicApplication, \"proxy=\"+app);\n        assertTrue(proxy instanceof EntityProxy, \"proxy=\"+app);\n    }","id":25295,"modified_method":"@Test\n    public void testCreatesProxy() throws Exception {\n        TestApplication app = new TestApplicationImpl();\n        Application proxy = factory.createEntityProxy(Application.class, app);\n        \n        assertFalse(proxy instanceof TestApplication, \"proxy=\"+app);\n        assertTrue(proxy instanceof EntityProxy, \"proxy=\"+app);\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        BasicApplication app = (BasicApplication) new MovableCloudFoundryClusterExample()\n                .appDisplayName(\"Movable Web Cluster\")\n                .manage(server.getManagementContext());\n        \n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n    }","id":25296,"modified_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        StartableApplication app = new MovableCloudFoundryClusterExample()\n                .appDisplayName(\"Movable Web Cluster\")\n                .manage(server.getManagementContext());\n        \n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static void main(String[] argv) throws Exception {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        // TODO Want to parse, to handle multiple locations\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        BasicApplication app = ApplicationBuilder.builder()\n                .child(BasicEntitySpec.newInstance(JBoss7Server.class)\n                        .configure(\"war\", WAR_PATH)\n                        .configure(\"httpPort\", 8080))\n                .manage();\n        JBoss7Server web = (JBoss7Server) Iterables.getOnlyElement(app.getChildren());\n\n        LOG.info(\"created, now starting...\");\n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n        LOG.info(\"started, visit \"+web.getAttribute(JBoss7Server.ROOT_URL));\n    }","id":25297,"modified_method":"public static void main(String[] argv) throws Exception {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        // TODO Want to parse, to handle multiple locations\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        StartableApplication app = ApplicationBuilder.builder()\n                .child(BasicEntitySpec.newInstance(JBoss7Server.class)\n                        .configure(\"war\", WAR_PATH)\n                        .configure(\"httpPort\", 8080))\n                .manage();\n        JBoss7Server web = (JBoss7Server) Iterables.getOnlyElement(app.getChildren());\n\n        LOG.info(\"created, now starting...\");\n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n        LOG.info(\"started, visit \"+web.getAttribute(JBoss7Server.ROOT_URL));\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        BasicApplication app = (BasicApplication) new StandaloneBrokerExample()\n                .appDisplayName(\"Qpid app\")\n                .manage(server.getManagementContext());\n        \n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n    }","id":25298,"modified_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        StartableApplication app = new StandaloneBrokerExample()\n                .appDisplayName(\"Qpid app\")\n                .manage(server.getManagementContext());\n        \n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        BasicApplication app = (BasicApplication) new WebClusterDatabaseExample()\n                .appDisplayName(\"Brooklyn WebApp Cluster with Database example\")\n                .manage(server.getManagementContext());\n        \n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n    }","id":25299,"modified_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        StartableApplication app = new WebClusterDatabaseExample()\n                .appDisplayName(\"Brooklyn WebApp Cluster with Database example\")\n                .manage(server.getManagementContext());\n        \n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        BasicApplication app = (BasicApplication) new WebClusterDatabaseExampleAlt()\n                .appDisplayName(\"Brooklyn WebApp Cluster with Database example\")\n                .manage(server.getManagementContext());\n        \n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n    }","id":25300,"modified_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        StartableApplication app = new WebClusterDatabaseExampleAlt()\n                .appDisplayName(\"Brooklyn WebApp Cluster with Database example\")\n                .manage(server.getManagementContext());\n        \n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        // TODO Want to parse, to handle multiple locations\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        BasicApplication app = (BasicApplication) new WebClusterExample()\n                .appDisplayName(\"Brooklyn WebApp Cluster example\")\n                .manage(server.getManagementContext());\n\n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n    }","id":25301,"modified_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        // TODO Want to parse, to handle multiple locations\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        StartableApplication app = new WebClusterExample()\n                .appDisplayName(\"Brooklyn WebApp Cluster example\")\n                .manage(server.getManagementContext());\n\n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", Joiner.on(\",\").join(DEFAULT_LOCATIONS));\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        BasicApplication app = server.getManagementContext().getEntityManager().createEntity(BasicEntitySpec.newInstance(BasicApplication.class)\n                .displayName(\"Brooklyn Global Web Fabric with Hadoop Example\")\n                .impl(WebClusterWithHadoopExample.class));\n        Entities.startManagement(app, server.getManagementContext());\n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n    }","id":25302,"modified_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", Joiner.on(\",\").join(DEFAULT_LOCATIONS));\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        StartableApplication app = server.getManagementContext().getEntityManager().createEntity(BasicEntitySpec.newInstance(StartableApplication.class)\n                .displayName(\"Brooklyn Global Web Fabric with Hadoop Example\")\n                .impl(WebClusterWithHadoopExample.class));\n        Entities.startManagement(app, server.getManagementContext());\n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", Joiner.on(\",\").join(DEFAULT_LOCATIONS));\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        List<Location> locs = new LocationRegistry().getLocationsById(ImmutableList.of(location));\n\n        BasicApplication app = server.getManagementContext().getEntityManager().createEntity(BasicEntitySpec.newInstance(BasicApplication.class)\n                .displayName(\"Brooklyn Global Web Fabric with Hadoop Example\")\n                .impl(WebFabricWithHadoopExample.class));\n        Entities.startManagement(app, server.getManagementContext());\n        \n        log.info(\"starting WebFabricWithHadoop, locations {}, mgmt on port {}\", locs, port);\n        app.start(locs);\n        \n        Entities.dumpInfo(app);\n    }","id":25303,"modified_method":"public static void main(String[] argv) {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", Joiner.on(\",\").join(DEFAULT_LOCATIONS));\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        List<Location> locs = new LocationRegistry().getLocationsById(ImmutableList.of(location));\n\n        StartableApplication app = server.getManagementContext().getEntityManager().createEntity(BasicEntitySpec.newInstance(StartableApplication.class)\n                .displayName(\"Brooklyn Global Web Fabric with Hadoop Example\")\n                .impl(WebFabricWithHadoopExample.class));\n        Entities.startManagement(app, server.getManagementContext());\n        \n        log.info(\"starting WebFabricWithHadoop, locations {}, mgmt on port {}\", locs, port);\n        app.start(locs);\n        \n        Entities.dumpInfo(app);\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static void main(String[] argv) throws Exception {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        BasicApplication app = (BasicApplication) new WhirrExample()\n                .manage(server.getManagementContext());\n        \n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n        \n        LOG.info(\"Press return to shut down the cluster\");\n        System.in.read(); //wait for the user to type a key\n        app.stop();\n    }","id":25304,"modified_method":"public static void main(String[] argv) throws Exception {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        StartableApplication app = new WhirrExample()\n                .manage(server.getManagementContext());\n        \n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n        \n        LOG.info(\"Press return to shut down the cluster\");\n        System.in.read(); //wait for the user to type a key\n        app.stop();\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static void main(String[] argv) throws Exception {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        BasicApplication app = (BasicApplication) new WhirrHadoopExample()\n                .manage(server.getManagementContext());\n        \n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n        \n        LOG.info(\"Press return to shut down the cluster\");\n        System.in.read(); //wait for the user to type a key\n        app.stop();\n    }","id":25305,"modified_method":"public static void main(String[] argv) throws Exception {\n        List<String> args = Lists.newArrayList(argv);\n        String port =  CommandLineUtil.getCommandLineOption(args, \"--port\", \"8081+\");\n        String location = CommandLineUtil.getCommandLineOption(args, \"--location\", DEFAULT_LOCATION);\n\n        BrooklynServerDetails server = BrooklynLauncher.newLauncher()\n                .webconsolePort(port)\n                .launch();\n\n        Location loc = server.getManagementContext().getLocationRegistry().resolve(location);\n\n        StartableApplication app = new WhirrHadoopExample()\n                .manage(server.getManagementContext());\n        \n        app.start(ImmutableList.of(loc));\n        \n        Entities.dumpInfo(app);\n        \n        LOG.info(\"Press return to shut down the cluster\");\n        System.in.read(); //wait for the user to type a key\n        app.stop();\n    }","commit_id":"05997274aca9b30887ca73b64ec73e5923d85167","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n\t * Run all {@link BeforeTransaction &#064;BeforeTransaction methods} for the\n\t * specified {@link TestContext test context}. If one of the methods fails,\n\t * however, the caught exception will be rethrown in a wrapped\n\t * {@link RuntimeException}, and the remaining methods will <strong>not<\/strong>\n\t * be given a chance to execute.\n\t * @param testContext the current test context\n\t */\n\tprotected void runBeforeTransactionMethods(TestContext testContext) throws Exception {\n\t\ttry {\n\t\t\tList<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class);\n\t\t\tCollections.reverse(methods);\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Executing @BeforeTransaction method [\" + method + \"] for test context [\"\n\t\t\t\t\t\t\t+ testContext + \"]\");\n\t\t\t\t}\n\t\t\t\tmethod.invoke(testContext.getTestInstance());\n\t\t\t}\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tlogger.error(\"Exception encountered while executing @BeforeTransaction methods for test context [\"\n\t\t\t\t\t+ testContext + \"]\", ex.getTargetException());\n\t\t\tReflectionUtils.rethrowException(ex.getTargetException());\n\t\t}\n\t}","id":25306,"modified_method":"/**\n\t * Run all {@link BeforeTransaction &#064;BeforeTransaction methods} for the\n\t * specified {@link TestContext test context}. If one of the methods fails,\n\t * however, the caught exception will be rethrown in a wrapped\n\t * {@link RuntimeException}, and the remaining methods will <strong>not<\/strong>\n\t * be given a chance to execute.\n\t * @param testContext the current test context\n\t */\n\tprotected void runBeforeTransactionMethods(TestContext testContext) throws Exception {\n\t\ttry {\n\t\t\tList<Method> methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class);\n\t\t\tCollections.reverse(methods);\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Executing @BeforeTransaction method [\" + method + \"] for test context \" + testContext);\n\t\t\t\t}\n\t\t\t\tmethod.invoke(testContext.getTestInstance());\n\t\t\t}\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tlogger.error(\"Exception encountered while executing @BeforeTransaction methods for test context \"\n\t\t\t\t\t+ testContext + \".\", ex.getTargetException());\n\t\t\tReflectionUtils.rethrowException(ex.getTargetException());\n\t\t}\n\t}","commit_id":"f21fe33e74ac3844a5690f71266e07c78ec219dd","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Get the {@link PlatformTransactionManager transaction manager} to use\n\t * for the supplied {@link TestContext test context}.\n\t * @param testContext the test context for which the transaction manager\n\t * should be retrieved\n\t * @return the transaction manager to use, or <code>null<\/code> if not found\n\t * @throws BeansException if an error occurs while retrieving the transaction manager\n\t */\n\tprotected final PlatformTransactionManager getTransactionManager(TestContext testContext) {\n\t\tString tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName();\n\t\ttry {\n\t\t\treturn testContext.getApplicationContext().getBean(tmName, PlatformTransactionManager.class);\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Caught exception while retrieving transaction manager with bean name [\" + tmName\n\t\t\t\t\t\t+ \"] for test context [\" + testContext + \"]\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}","id":25307,"modified_method":"/**\n\t * Get the {@link PlatformTransactionManager transaction manager} to use\n\t * for the supplied {@link TestContext test context}.\n\t * @param testContext the test context for which the transaction manager\n\t * should be retrieved\n\t * @return the transaction manager to use, or <code>null<\/code> if not found\n\t * @throws BeansException if an error occurs while retrieving the transaction manager\n\t * @see #getTransactionManager(TestContext, String)\n\t */\n\tprotected final PlatformTransactionManager getTransactionManager(TestContext testContext) {\n\t\tBeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory();\n\t\tString tmName = retrieveConfigurationAttributes(testContext).getTransactionManagerName();\n\n\t\ttry {\n\t\t\t// look up by type and explicit name from @TransactionConfiguration\n\t\t\tif (StringUtils.hasText(tmName) && !DEFAULT_TRANSACTION_MANAGER_NAME.equals(tmName)) {\n\t\t\t\treturn bf.getBean(tmName, PlatformTransactionManager.class);\n\t\t\t}\n\n\t\t\t// look up single bean by type\n\t\t\tif (bf instanceof ListableBeanFactory) {\n\t\t\t\tListableBeanFactory lbf = (ListableBeanFactory) bf;\n\t\t\t\tMap<String, PlatformTransactionManager> beansOfType = BeanFactoryUtils.beansOfTypeIncludingAncestors(\n\t\t\t\t\tlbf, PlatformTransactionManager.class);\n\t\t\t\tif (beansOfType.size() == 1) {\n\t\t\t\t\treturn beansOfType.values().iterator().next();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look up by type and default name from @TransactionConfiguration\n\t\t\treturn bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class);\n\n\t\t} catch (BeansException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Caught exception while retrieving transaction manager for test context \" + testContext, ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}","commit_id":"f21fe33e74ac3844a5690f71266e07c78ec219dd","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Retrieves the {@link TransactionConfigurationAttributes} for the\n\t * specified {@link Class class} which may optionally declare or inherit a\n\t * {@link TransactionConfiguration &#064;TransactionConfiguration}. If a\n\t * {@link TransactionConfiguration} annotation is not present for the\n\t * supplied class, the <em>default values<\/em> for attributes defined in\n\t * {@link TransactionConfiguration} will be used instead.\n\t * @param clazz the Class object corresponding to the test class for which\n\t * the configuration attributes should be retrieved\n\t * @return a new TransactionConfigurationAttributes instance\n\t */\n\tprivate TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {\n\t\tif (this.configurationAttributes == null) {\n\t\t\tClass<?> clazz = testContext.getTestClass();\n\t\t\tClass<TransactionConfiguration> annotationType = TransactionConfiguration.class;\n\t\t\tTransactionConfiguration config = clazz.getAnnotation(annotationType);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Retrieved @TransactionConfiguration [\" + config + \"] for test class [\" + clazz + \"]\");\n\t\t\t}\n\n\t\t\tString transactionManagerName;\n\t\t\tboolean defaultRollback;\n\t\t\tif (config != null) {\n\t\t\t\ttransactionManagerName = config.transactionManager();\n\t\t\t\tdefaultRollback = config.defaultRollback();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttransactionManagerName = (String) AnnotationUtils.getDefaultValue(annotationType, \"transactionManager\");\n\t\t\t\tdefaultRollback = (Boolean) AnnotationUtils.getDefaultValue(annotationType, \"defaultRollback\");\n\t\t\t}\n\n\t\t\tTransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(\n\t\t\t\ttransactionManagerName, defaultRollback);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Retrieved TransactionConfigurationAttributes [\" + configAttributes + \"] for class [\"\n\t\t\t\t\t\t+ clazz + \"]\");\n\t\t\t}\n\t\t\tthis.configurationAttributes = configAttributes;\n\t\t}\n\t\treturn this.configurationAttributes;\n\t}","id":25308,"modified_method":"/**\n\t * Retrieves the {@link TransactionConfigurationAttributes} for the\n\t * specified {@link Class class} which may optionally declare or inherit\n\t * {@link TransactionConfiguration &#064;TransactionConfiguration}. If\n\t * {@code &#064;TransactionConfiguration} is not present for the supplied\n\t * class, the <em>default values<\/em> for attributes defined in\n\t * {@code &#064;TransactionConfiguration} will be used instead.\n\t * @param testContext the test context for which the configuration\n\t * attributes should be retrieved\n\t * @return a new TransactionConfigurationAttributes instance\n\t */\n\tprivate TransactionConfigurationAttributes retrieveConfigurationAttributes(TestContext testContext) {\n\t\tif (this.configurationAttributes == null) {\n\t\t\tClass<?> clazz = testContext.getTestClass();\n\t\t\tTransactionConfiguration config = clazz.getAnnotation(TransactionConfiguration.class);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Retrieved @TransactionConfiguration [\" + config + \"] for test class [\" + clazz + \"]\");\n\t\t\t}\n\n\t\t\tString transactionManagerName;\n\t\t\tboolean defaultRollback;\n\t\t\tif (config != null) {\n\t\t\t\ttransactionManagerName = config.transactionManager();\n\t\t\t\tdefaultRollback = config.defaultRollback();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttransactionManagerName = DEFAULT_TRANSACTION_MANAGER_NAME;\n\t\t\t\tdefaultRollback = DEFAULT_DEFAULT_ROLLBACK;\n\t\t\t}\n\n\t\t\tTransactionConfigurationAttributes configAttributes = new TransactionConfigurationAttributes(\n\t\t\t\ttransactionManagerName, defaultRollback);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Retrieved TransactionConfigurationAttributes \" + configAttributes + \" for class [\"\n\t\t\t\t\t\t+ clazz + \"]\");\n\t\t\t}\n\t\t\tthis.configurationAttributes = configAttributes;\n\t\t}\n\t\treturn this.configurationAttributes;\n\t}","commit_id":"f21fe33e74ac3844a5690f71266e07c78ec219dd","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Determine whether or not to rollback transactions for the supplied\n\t * {@link TestContext test context} by taking into consideration the\n\t * {@link #isDefaultRollback(TestContext) default rollback} flag and a\n\t * possible method-level override via the {@link Rollback} annotation.\n\t * @param testContext the test context for which the rollback flag\n\t * should be retrieved\n\t * @return the <em>rollback<\/em> flag for the supplied test context\n\t * @throws Exception if an error occurs while determining the rollback flag\n\t */\n\tprotected final boolean isRollback(TestContext testContext) throws Exception {\n\t\tboolean rollback = isDefaultRollback(testContext);\n\t\tRollback rollbackAnnotation = testContext.getTestMethod().getAnnotation(Rollback.class);\n\t\tif (rollbackAnnotation != null) {\n\t\t\tboolean rollbackOverride = rollbackAnnotation.value();\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Method-level @Rollback(\" + rollbackOverride + \") overrides default rollback [\" + rollback\n\t\t\t\t\t\t+ \"] for test context [\" + testContext + \"]\");\n\t\t\t}\n\t\t\trollback = rollbackOverride;\n\t\t}\n\t\telse {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"No method-level @Rollback override: using default rollback [\" + rollback\n\t\t\t\t\t\t+ \"] for test context [\" + testContext + \"]\");\n\t\t\t}\n\t\t}\n\t\treturn rollback;\n\t}","id":25309,"modified_method":"/**\n\t * Determine whether or not to rollback transactions for the supplied\n\t * {@link TestContext test context} by taking into consideration the\n\t * {@link #isDefaultRollback(TestContext) default rollback} flag and a\n\t * possible method-level override via the {@link Rollback} annotation.\n\t * @param testContext the test context for which the rollback flag\n\t * should be retrieved\n\t * @return the <em>rollback<\/em> flag for the supplied test context\n\t * @throws Exception if an error occurs while determining the rollback flag\n\t */\n\tprotected final boolean isRollback(TestContext testContext) throws Exception {\n\t\tboolean rollback = isDefaultRollback(testContext);\n\t\tRollback rollbackAnnotation = testContext.getTestMethod().getAnnotation(Rollback.class);\n\t\tif (rollbackAnnotation != null) {\n\t\t\tboolean rollbackOverride = rollbackAnnotation.value();\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Method-level @Rollback(\" + rollbackOverride + \") overrides default rollback [\" + rollback\n\t\t\t\t\t\t+ \"] for test context \" + testContext);\n\t\t\t}\n\t\t\trollback = rollbackOverride;\n\t\t}\n\t\telse {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"No method-level @Rollback override: using default rollback [\" + rollback\n\t\t\t\t\t\t+ \"] for test context \" + testContext);\n\t\t\t}\n\t\t}\n\t\treturn rollback;\n\t}","commit_id":"f21fe33e74ac3844a5690f71266e07c78ec219dd","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Immediately force a <em>commit<\/em> or <em>rollback<\/em> of the\n\t * transaction for the supplied {@link TestContext test context}, according\n\t * to the commit and rollback flags.\n\t * @param testContext the current test context\n\t * @throws Exception if an error occurs while retrieving the transaction manager\n\t */\n\tprivate void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {\n\t\tboolean rollback = isRollback(testContext);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Ending transaction for test context [\" + testContext + \"]; transaction manager [\"\n\t\t\t\t\t+ txContext.transactionStatus + \"]; rollback [\" + rollback + \"]\");\n\t\t}\n\t\ttxContext.endTransaction(rollback);\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info((rollback ? \"Rolled back\" : \"Committed\")\n\t\t\t\t\t+ \" transaction after test execution for test context [\" + testContext + \"]\");\n\t\t}\n\t}","id":25310,"modified_method":"/**\n\t * Immediately force a <em>commit<\/em> or <em>rollback<\/em> of the\n\t * transaction for the supplied {@link TestContext test context}, according\n\t * to the commit and rollback flags.\n\t * @param testContext the current test context\n\t * @throws Exception if an error occurs while retrieving the transaction manager\n\t */\n\tprivate void endTransaction(TestContext testContext, TransactionContext txContext) throws Exception {\n\t\tboolean rollback = isRollback(testContext);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Ending transaction for test context \" + testContext + \"; transaction manager [\"\n\t\t\t\t\t+ txContext.transactionStatus + \"]; rollback [\" + rollback + \"]\");\n\t\t}\n\t\ttxContext.endTransaction(rollback);\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info((rollback ? \"Rolled back\" : \"Committed\")\n\t\t\t\t\t+ \" transaction after test execution for test context \" + testContext);\n\t\t}\n\t}","commit_id":"f21fe33e74ac3844a5690f71266e07c78ec219dd","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Run all {@link AfterTransaction &#064;AfterTransaction methods} for the\n\t * specified {@link TestContext test context}. If one of the methods fails,\n\t * the caught exception will be logged as an error, and the remaining\n\t * methods will be given a chance to execute. After all methods have\n\t * executed, the first caught exception, if any, will be rethrown.\n\t * @param testContext the current test context\n\t */\n\tprotected void runAfterTransactionMethods(TestContext testContext) throws Exception {\n\t\tThrowable afterTransactionException = null;\n\n\t\tList<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class);\n\t\tfor (Method method : methods) {\n\t\t\ttry {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Executing @AfterTransaction method [\" + method + \"] for test context [\" + testContext\n\t\t\t\t\t\t\t+ \"]\");\n\t\t\t\t}\n\t\t\t\tmethod.invoke(testContext.getTestInstance());\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tThrowable targetException = ex.getTargetException();\n\t\t\t\tif (afterTransactionException == null) {\n\t\t\t\t\tafterTransactionException = targetException;\n\t\t\t\t}\n\t\t\t\tlogger.error(\"Exception encountered while executing @AfterTransaction method [\" + method\n\t\t\t\t\t\t+ \"] for test context [\" + testContext + \"]\", targetException);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (afterTransactionException == null) {\n\t\t\t\t\tafterTransactionException = ex;\n\t\t\t\t}\n\t\t\t\tlogger.error(\"Exception encountered while executing @AfterTransaction method [\" + method\n\t\t\t\t\t\t+ \"] for test context [\" + testContext + \"]\", ex);\n\t\t\t}\n\t\t}\n\n\t\tif (afterTransactionException != null) {\n\t\t\tReflectionUtils.rethrowException(afterTransactionException);\n\t\t}\n\t}","id":25311,"modified_method":"/**\n\t * Run all {@link AfterTransaction &#064;AfterTransaction methods} for the\n\t * specified {@link TestContext test context}. If one of the methods fails,\n\t * the caught exception will be logged as an error, and the remaining\n\t * methods will be given a chance to execute. After all methods have\n\t * executed, the first caught exception, if any, will be rethrown.\n\t * @param testContext the current test context\n\t */\n\tprotected void runAfterTransactionMethods(TestContext testContext) throws Exception {\n\t\tThrowable afterTransactionException = null;\n\n\t\tList<Method> methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class);\n\t\tfor (Method method : methods) {\n\t\t\ttry {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Executing @AfterTransaction method [\" + method + \"] for test context \" + testContext);\n\t\t\t\t}\n\t\t\t\tmethod.invoke(testContext.getTestInstance());\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tThrowable targetException = ex.getTargetException();\n\t\t\t\tif (afterTransactionException == null) {\n\t\t\t\t\tafterTransactionException = targetException;\n\t\t\t\t}\n\t\t\t\tlogger.error(\"Exception encountered while executing @AfterTransaction method [\" + method\n\t\t\t\t\t\t+ \"] for test context \" + testContext, targetException);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (afterTransactionException == null) {\n\t\t\t\t\tafterTransactionException = ex;\n\t\t\t\t}\n\t\t\t\tlogger.error(\"Exception encountered while executing @AfterTransaction method [\" + method\n\t\t\t\t\t\t+ \"] for test context \" + testContext, ex);\n\t\t\t}\n\t\t}\n\n\t\tif (afterTransactionException != null) {\n\t\t\tReflectionUtils.rethrowException(afterTransactionException);\n\t\t}\n\t}","commit_id":"f21fe33e74ac3844a5690f71266e07c78ec219dd","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * If the test method of the supplied {@link TestContext test context} is\n\t * configured to run within a transaction, this method will run\n\t * {@link BeforeTransaction &#064;BeforeTransaction methods} and start a new\n\t * transaction.\n\t * <p>Note that if a {@link BeforeTransaction &#064;BeforeTransaction method} fails,\n\t * remaining {@link BeforeTransaction &#064;BeforeTransaction methods} will not\n\t * be invoked, and a transaction will not be started.\n\t * @see org.springframework.transaction.annotation.Transactional\n\t * @see org.springframework.test.annotation.NotTransactional\n\t */\n\t@SuppressWarnings(\"serial\")\n\t@Override\n\tpublic void beforeTestMethod(TestContext testContext) throws Exception {\n\t\tfinal Method testMethod = testContext.getTestMethod();\n\t\tAssert.notNull(testMethod, \"The test method of the supplied TestContext must not be null\");\n\n\t\tif (this.transactionContextCache.remove(testMethod) != null) {\n\t\t\tthrow new IllegalStateException(\"Cannot start new transaction without ending existing transaction: \"\n\t\t\t\t\t+ \"Invoke endTransaction() before startNewTransaction().\");\n\t\t}\n\n\t\tif (testMethod.isAnnotationPresent(NotTransactional.class)) {\n\t\t\treturn;\n\t\t}\n\n\t\tTransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,\n\t\t\ttestContext.getTestClass());\n\t\tTransactionDefinition transactionDefinition = null;\n\t\tif (transactionAttribute != null) {\n\t\t\ttransactionDefinition = new DelegatingTransactionAttribute(transactionAttribute) {\n\n\t\t\t\tpublic String getName() {\n\t\t\t\t\treturn testMethod.getName();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tif (transactionDefinition != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Explicit transaction definition [\" + transactionDefinition + \"] found for test context [\"\n\t\t\t\t\t\t+ testContext + \"]\");\n\t\t\t}\n\t\t\tString qualifier = transactionAttribute.getQualifier();\n\t\t\tPlatformTransactionManager tm;\n\t\t\tif (StringUtils.hasLength(qualifier)) {\n\t\t\t\t// Use autowire-capable factory in order to support extended\n\t\t\t\t// qualifier matching (only exposed on the internal BeanFactory,\n\t\t\t\t// not on the ApplicationContext).\n\t\t\t\tBeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory();\n\t\t\t\ttm = BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf, PlatformTransactionManager.class, qualifier);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttm = getTransactionManager(testContext);\n\t\t\t}\n\t\t\tTransactionContext txContext = new TransactionContext(tm, transactionDefinition);\n\t\t\trunBeforeTransactionMethods(testContext);\n\t\t\tstartNewTransaction(testContext, txContext);\n\t\t\tthis.transactionContextCache.put(testMethod, txContext);\n\t\t}\n\t}","id":25312,"modified_method":"/**\n\t * If the test method of the supplied {@link TestContext test context} is\n\t * configured to run within a transaction, this method will run\n\t * {@link BeforeTransaction &#064;BeforeTransaction methods} and start a new\n\t * transaction.\n\t * <p>Note that if a {@code BeforeTransaction &#064;BeforeTransaction method} fails,\n\t * remaining {@code BeforeTransaction &#064;BeforeTransaction methods} will not\n\t * be invoked, and a transaction will not be started.\n\t * @see org.springframework.transaction.annotation.Transactional\n\t * @see org.springframework.test.annotation.NotTransactional\n\t * @see #getTransactionManager(TestContext, String)\n\t */\n\t@SuppressWarnings(\"serial\")\n\t@Override\n\tpublic void beforeTestMethod(TestContext testContext) throws Exception {\n\t\tfinal Method testMethod = testContext.getTestMethod();\n\t\tAssert.notNull(testMethod, \"The test method of the supplied TestContext must not be null\");\n\n\t\tif (this.transactionContextCache.remove(testMethod) != null) {\n\t\t\tthrow new IllegalStateException(\"Cannot start new transaction without ending existing transaction: \"\n\t\t\t\t\t+ \"Invoke endTransaction() before startNewTransaction().\");\n\t\t}\n\n\t\tif (testMethod.isAnnotationPresent(NotTransactional.class)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPlatformTransactionManager tm = null;\n\t\tTransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod,\n\t\t\ttestContext.getTestClass());\n\n\t\tif (transactionAttribute != null) {\n\t\t\ttransactionAttribute = new DelegatingTransactionAttribute(transactionAttribute) {\n\n\t\t\t\tpublic String getName() {\n\t\t\t\t\treturn testMethod.getName();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Explicit transaction definition [\" + transactionAttribute + \"] found for test context \"\n\t\t\t\t\t\t+ testContext);\n\t\t\t}\n\t\t\ttm = getTransactionManager(testContext, transactionAttribute.getQualifier());\n\t\t}\n\n\t\tif (tm != null) {\n\t\t\tTransactionContext txContext = new TransactionContext(tm, transactionAttribute);\n\t\t\trunBeforeTransactionMethods(testContext);\n\t\t\tstartNewTransaction(testContext, txContext);\n\t\t\tthis.transactionContextCache.put(testMethod, txContext);\n\t\t}\n\t}","commit_id":"f21fe33e74ac3844a5690f71266e07c78ec219dd","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * If a transaction is currently active for the test method of the supplied\n\t * {@link TestContext test context}, this method will end the transaction\n\t * and run {@link AfterTransaction &#064;AfterTransaction methods}.\n\t * <p>{@link AfterTransaction &#064;AfterTransaction methods} are guaranteed to be\n\t * invoked even if an error occurs while ending the transaction.\n\t */\n\t@Override\n\tpublic void afterTestMethod(TestContext testContext) throws Exception {\n\t\tMethod testMethod = testContext.getTestMethod();\n\t\tAssert.notNull(testMethod, \"The test method of the supplied TestContext must not be null\");\n\n\t\t// If the transaction is still active...\n\t\tTransactionContext txContext = this.transactionContextCache.remove(testMethod);\n\t\tif (txContext != null && !txContext.transactionStatus.isCompleted()) {\n\t\t\ttry {\n\t\t\t\tendTransaction(testContext, txContext);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\trunAfterTransactionMethods(testContext);\n\t\t\t}\n\t\t}\n\t}","id":25313,"modified_method":"/**\n\t * If a transaction is currently active for the test method of the supplied\n\t * {@link TestContext test context}, this method will end the transaction\n\t * and run {@link AfterTransaction &#064;AfterTransaction methods}.\n\t * <p>{@code AfterTransaction &#064;AfterTransaction methods} are guaranteed to be\n\t * invoked even if an error occurs while ending the transaction.\n\t */\n\t@Override\n\tpublic void afterTestMethod(TestContext testContext) throws Exception {\n\t\tMethod testMethod = testContext.getTestMethod();\n\t\tAssert.notNull(testMethod, \"The test method of the supplied TestContext must not be null\");\n\n\t\t// If the transaction is still active...\n\t\tTransactionContext txContext = this.transactionContextCache.remove(testMethod);\n\t\tif (txContext != null && !txContext.transactionStatus.isCompleted()) {\n\t\t\ttry {\n\t\t\t\tendTransaction(testContext, txContext);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\trunAfterTransactionMethods(testContext);\n\t\t\t}\n\t\t}\n\t}","commit_id":"f21fe33e74ac3844a5690f71266e07c78ec219dd","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n     * Returns the CamelContext which support OSGi\n     */\n    @Override\n    protected CamelContext createCamelContext() throws Exception {\n        SpringCamelContextFactory factory = new SpringCamelContextFactory();\n        factory.setApplicationContext(getApplicationContext());\n        factory.setBundleContext(getBundleContext());\n        return factory.createContext();\n    }","id":25314,"modified_method":"/**\n     * Returns the CamelContext which support Spring\n     */\n    @Override\n    protected CamelContext createCamelContext() throws Exception {\n        return new SpringCamelContext(getApplicationContext());\n    }","commit_id":"f32c0edf89ebb66ffe814ef9ee5ffed3167a0f93","url":"https://github.com/apache/camel"},{"original_method":"public GrailsPluginManager getManager() {\n\t\treturn null;\n\t}","id":25315,"modified_method":"public GrailsPluginManager getManager() {\n\t\treturn this.manager;\n\t}","commit_id":"a6acab511b9cc4747e92505aca6cca61198f65d5","url":"https://github.com/grails/grails-core"},{"original_method":"public void testGet() throws Exception {\n        GroovyClassLoader gcl = new GroovyClassLoader();\n        Class groovyClass = gcl.parseClass(\"package org.codehaus.groovy.grails.validation\\n\" +\n                \"class Test {\\n\" +\n                \" String name\\n\" +\n                \"}\");\n\n        ConstraintsEvaluatingDynamicProperty cp = new ConstraintsEvaluatingDynamicProperty();\n\n        Map constraints = (Map)cp.get(groovyClass.newInstance());\n\n        assertNotNull(constraints);\n        assertFalse(constraints.isEmpty());\n    }","id":25316,"modified_method":"public void testGet() throws Exception {\n        GroovyClassLoader gcl = new GroovyClassLoader();\n        Class groovyClass = gcl.parseClass(\"package org.codehaus.groovy.grails.validation\\n\" +\n                \"class Test {\\n\" +\n                \" String name\\n\" +\n                \"}\");\n\n        ConstraintsEvaluatingDynamicProperty cp = new ConstraintsEvaluatingDynamicProperty();\n\n        Map constraints = (Map)cp.get(groovyClass.newInstance());\n\n        assertNotNull(constraints);\n        assertTrue(constraints.isEmpty());\n    }","commit_id":"a6acab511b9cc4747e92505aca6cca61198f65d5","url":"https://github.com/grails/grails-core"},{"original_method":"private Class attemptClassReload(final Resource resource) {\n\t\tString className = GrailsResourceUtils.getClassName(resource);\n\t\tif(className != null) {\n\t\t\ttry {\n\t\t\t\treturn application.getClassLoader().loadClass(className,true,false);\n\t\t\t} catch (CompilationFailedException e) {\n\t\t\t\tLOG.error(\"Compilation error reloading plugin resource [\"+resource+\"]:\" + e.getMessage(),e);\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tLOG.error(\"Class not found error reloading plugin resource [\"+resource+\"]:\" + e.getMessage(),e);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}","id":25317,"modified_method":"private Class attemptClassReload(final Resource resource) {\n\t\tString className = GrailsResourceUtils.getClassName(resource);\n\t\tif(className != null) {\n\t\t\treturn attemptClassReload(className);\n\t\t}\t\t\n\t\treturn null;\n\t}","commit_id":"a6acab511b9cc4747e92505aca6cca61198f65d5","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * Monitors the plugin resources defined in the watchResources property for changes and \n\t * fires onChange events by calling an onChange closure defined in the plugin (if it exists)\n\t */\n\tpublic void checkForChanges() {\n\t\tif(onChangeListener!=null) {\n\t\t\ttry {\n\n\t\t\t\tcheckForNewResources(this);\n\t\t\t\t\n\t\t\t\tif(LOG.isDebugEnabled()) {\n\t\t\t\t\tLOG.debug(\"Plugin [\"+getName()+\"] checking [\"+watchedResources.length+\"] resources for changes..\");\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < watchedResources.length; i++) {\n\t\t\t\t\tfinal Resource r = watchedResources[i];\t\t\t\t\t\t\t\t\n                        URL url = watchedResources[i].getURL();\n                        URLConnection c = url.openConnection();\n                        c.setDoInput(false);\n                        c.setDoOutput(false);\n                        long lastModified = c.getLastModified();\n\t\t\t\t\t\tSystem.out.println(\"Checking modified for url \" + url);\n\t\t\t\t\t\tif(modifiedTimes[i] < lastModified) {\n\t\t\t\t\t\t\tif(LOG.isDebugEnabled())\n\t\t\t\t\t\t\t\tLOG.debug(\"[GrailsPlugin] plugin resource [\"+r+\"] changed, firing event if possible..\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tSystem.out.println(\"file changed firing event!\");\n\t\t\t\t\t\t\tfireModifiedEvent(r, this);\n\t\t\t\t\t\t\tmodifiedTimes[i] = lastModified;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOG.warn(\"Unable to read last modified date of plugin resource\" +e.getMessage(),e);\n\t\t\t}\t\t\t\n\t\t}\n\t}","id":25318,"modified_method":"/**\n\t * Monitors the plugin resources defined in the watchResources property for changes and \n\t * fires onChange events by calling an onChange closure defined in the plugin (if it exists)\n\t */\n\tpublic void checkForChanges() {\n\t\tif(onChangeListener!=null) {\n\t\t\t\ttry {\n\t\t\t\t\tcheckForNewResources(this);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLOG.error(\"Plugin \"+this+\"  was unable to check for new plugin resources: \" + e.getMessage(),e);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(LOG.isDebugEnabled()) {\n\t\t\t\t\tLOG.debug(\"Plugin \"+this+\" checking [\"+watchedResources.length+\"] resources for changes..\");\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < watchedResources.length; i++) {\n\t\t\t\t\tfinal Resource r = watchedResources[i];\t\n\t\t\t\t\tlong modifiedFlag = checkModified(r, modifiedTimes[i]) ;\n\t\t\t\t\tif( modifiedFlag > -1) {\n\t\t\t\t\t\tif(LOG.isDebugEnabled())\n\t\t\t\t\t\t\tLOG.debug(\"[GrailsPlugin] plugin resource [\"+r+\"] changed, firing event if possible..\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tfireModifiedEvent(r, this);\n\t\t\t\t\t\trefreshInfluencedPlugins();\n\t\t\t\t\t\tmodifiedTimes[i] = modifiedFlag;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t}\n\t}","commit_id":"a6acab511b9cc4747e92505aca6cca61198f65d5","url":"https://github.com/grails/grails-core"},{"original_method":"private void fireModifiedEvent(final Resource resource, final GrailsPlugin plugin) {\n\t\tClass loadedClass = null;\n\t\tloadedClass = attemptClassReload(resource);\n\t\tfinal Class resourceClass = loadedClass;\n\t\tMap event = new HashMap() {{\n\t\t\tif(resourceClass == null)\n\t\t\t\tput(PLUGIN_CHANGE_EVENT_SOURCE, resource);\n\t\t\telse\n\t\t\t\tput(PLUGIN_CHANGE_EVENT_SOURCE, resourceClass);\n\t\t\tput(PLUGIN_CHANGE_EVENT_PLUGIN, plugin);\n\t\t\tput(PLUGIN_CHANGE_EVENT_APPLICATION, application);\n\t\t\tput(PLUGIN_CHANGE_EVENT_CTX, applicationContext);\n\t\t}};\n\t\tonChangeListener.setDelegate(this);\n\t\tonChangeListener.call(new Object[]{event});\n\t}","id":25319,"modified_method":"private void fireModifiedEvent(final Resource resource, final GrailsPlugin plugin) {\n\t\tClass loadedClass = null;\n\t\tloadedClass = attemptClassReload(resource);\n\t\tif(loadedClass != null) {\n\t\t\tfinal Class resourceClass = loadedClass;\n\t\t\tMap event = new HashMap() {{\n\t\t\t\tif(resourceClass == null)\n\t\t\t\t\tput(PLUGIN_CHANGE_EVENT_SOURCE, resource);\n\t\t\t\telse\n\t\t\t\t\tput(PLUGIN_CHANGE_EVENT_SOURCE, resourceClass);\n\t\t\t\tput(PLUGIN_CHANGE_EVENT_PLUGIN, plugin);\n\t\t\t\tput(PLUGIN_CHANGE_EVENT_APPLICATION, application);\n\t\t\t\tput(PLUGIN_CHANGE_EVENT_CTX, applicationContext);\n\t\t\t}};\n\t\t\tonChangeListener.setDelegate(this);\n\t\t\tonChangeListener.call(new Object[]{event});\t\t\t\n\t\t}\n\t}","commit_id":"a6acab511b9cc4747e92505aca6cca61198f65d5","url":"https://github.com/grails/grails-core"},{"original_method":"public DefaultGrailsPlugin(Class pluginClass, GrailsApplication application) {\n\t\tsuper(pluginClass, application);\n\t\tthis.pluginGrailsClass = new GrailsPluginClass(pluginClass);\n\t\tthis.plugin = (GroovyObject)this.pluginGrailsClass.newInstance();\n\t\tthis.pluginBean = new BeanWrapperImpl(this.plugin);\n\t\tthis.dependencies = Collections.EMPTY_MAP;\n\t\tthis.parentCtx = application.getParentContext();\n\t\tif(this.pluginBean.isReadableProperty(DEPENDS_ON)) {\n\t\t\tthis.dependencies = (Map)GrailsClassUtils.getPropertyOrStaticPropertyOrFieldValue(this.plugin, DEPENDS_ON);\n\t\t\tthis.dependencyNames = (String[])this.dependencies.keySet().toArray(new String[this.dependencies.size()]);\n\t\t}\n\t\tif(this.pluginBean.isReadableProperty(PLUGIN_LOAD_AFTER_NAMES)) {\n\t\t\tList loadAfterNamesList = (List)GrailsClassUtils.getPropertyOrStaticPropertyOrFieldValue(this.plugin, PLUGIN_LOAD_AFTER_NAMES);\n\t\t\tif(loadAfterNamesList != null) {\n\t\t\t\tthis.loadAfterNames = (String[])loadAfterNamesList.toArray(new String[loadAfterNamesList.size()]);\n\t\t\t}\n\t\t}\n\t\tif(this.pluginBean.isReadableProperty(VERSION)) {\n\t\t\tBigDecimal bd = (BigDecimal)this.plugin.getProperty(\"version\");\n\t\t\tthis.version = bd;\n\t\t}\n\t\telse {\n\t\t\tthrow new PluginException(\"Plugin [\"+getName()+\"] must specify a version!\");\n\t\t}\n\t\tif(this.pluginBean.isReadableProperty(ON_CHANGE)) {\n\t\t\tthis.onChangeListener = (Closure)GrailsClassUtils.getPropertyOrStaticPropertyOrFieldValue(this.plugin, ON_CHANGE);\n\t\t\tObject referencedResources = GrailsClassUtils.getPropertyOrStaticPropertyOrFieldValue(this.plugin, WATCHED_RESOURCES);\n\t\t\tthis.resolver = new PathMatchingResourcePatternResolver();\n\t\t\ttry {\n\t\t\t\tif(referencedResources instanceof String) {\n\t\t\t\t\t this.resourcesReference = referencedResources.toString();\n\t\t\t\t\t watchedResources  = resolver.getResources(resourcesReference);\n\t\t\t\t}\n\t\t\t\telse if(referencedResources instanceof List) {\n\t\t\t\t\tList resourceList = (List)referencedResources;\n\n\t\t\t\t\tfor (int i = 0; i < resourceList.size(); i++) {\n\t\t\t\t\t\tString res = resourceList.get(i).toString();\n\t\t\t\t\t\tResource[] tmp = resolver.getResources(res);\n\t\t\t\t\t\tif(LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\tLOG.debug(\"Watching resource set [\"+(i+1)+\"]: \" + ArrayUtils.toString(tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t\twatchedResources = (Resource[])ArrayUtils.addAll(this.watchedResources, tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\tinitializeModifiedTimes();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOG.warn(\"I/O exception loading plug-in resource watch list: \" + e.getMessage(), e);\n\t\t\t}\t\t\t\t\n\n\t\t}\n\t}","id":25320,"modified_method":"public DefaultGrailsPlugin(Class pluginClass, GrailsApplication application) {\n\t\tsuper(pluginClass, application);\n\t\tthis.pluginGrailsClass = new GrailsPluginClass(pluginClass);\n\t\tthis.plugin = (GroovyObject)this.pluginGrailsClass.newInstance();\n\t\tthis.pluginBean = new BeanWrapperImpl(this.plugin);\n\t\tthis.dependencies = Collections.EMPTY_MAP;\n\t\tthis.parentCtx = application.getParentContext();\n\t\tif(this.pluginBean.isReadableProperty(DEPENDS_ON)) {\n\t\t\tthis.dependencies = (Map)GrailsClassUtils.getPropertyOrStaticPropertyOrFieldValue(this.plugin, DEPENDS_ON);\n\t\t\tthis.dependencyNames = (String[])this.dependencies.keySet().toArray(new String[this.dependencies.size()]);\n\t\t}\n\t\tif(this.pluginBean.isReadableProperty(PLUGIN_LOAD_AFTER_NAMES)) {\n\t\t\tList loadAfterNamesList = (List)GrailsClassUtils.getPropertyOrStaticPropertyOrFieldValue(this.plugin, PLUGIN_LOAD_AFTER_NAMES);\n\t\t\tif(loadAfterNamesList != null) {\n\t\t\t\tthis.loadAfterNames = (String[])loadAfterNamesList.toArray(new String[loadAfterNamesList.size()]);\n\t\t\t}\n\t\t}\n\t\tif(this.pluginBean.isReadableProperty(VERSION)) {\n\t\t\tBigDecimal bd = (BigDecimal)this.plugin.getProperty(\"version\");\n\t\t\tthis.version = bd;\n\t\t}\n\t\telse {\n\t\t\tthrow new PluginException(\"Plugin [\"+getName()+\"] must specify a version!\");\n\t\t}\n\t\tif(this.pluginBean.isReadableProperty(INFLUENCES)) {\n\t\t\tList influencedList = (List)this.pluginBean.getPropertyValue(INFLUENCES);\n\t\t\tif(influencedList != null) {\n\t\t\t\tthis.influencedPluginNames = (String[])influencedList.toArray(new String[influencedList.size()]);\n\t\t\t}\n\t\t}\n\t\tif(this.pluginBean.isReadableProperty(ON_CHANGE)) {\n\t\t\tthis.onChangeListener = (Closure)GrailsClassUtils.getPropertyOrStaticPropertyOrFieldValue(this.plugin, ON_CHANGE);\n\t\t\tObject referencedResources = GrailsClassUtils.getPropertyOrStaticPropertyOrFieldValue(this.plugin, WATCHED_RESOURCES);\n\t\t\tthis.resolver = new PathMatchingResourcePatternResolver();\n\t\t\ttry {\n\t\t\t\tif(referencedResources instanceof String) {\n\t\t\t\t\t this.resourcesReference = referencedResources.toString();\n\t\t\t\t\t watchedResources  = resolver.getResources(resourcesReference);\n\t\t\t\t}\n\t\t\t\telse if(referencedResources instanceof List) {\n\t\t\t\t\tList resourceList = (List)referencedResources;\n\n\t\t\t\t\tfor (int i = 0; i < resourceList.size(); i++) {\n\t\t\t\t\t\tString res = resourceList.get(i).toString();\n\t\t\t\t\t\tResource[] tmp = resolver.getResources(res);\n\t\t\t\t\t\tif(LOG.isDebugEnabled()) {\n\t\t\t\t\t\t\tLOG.debug(\"Watching resource set [\"+(i+1)+\"]: \" + ArrayUtils.toString(tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t\twatchedResources = (Resource[])ArrayUtils.addAll(this.watchedResources, tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\tinitializeModifiedTimes();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOG.warn(\"I/O exception loading plug-in resource watch list: \" + e.getMessage(), e);\n\t\t\t}\t\t\t\t\n\n\t\t}\n\t}","commit_id":"a6acab511b9cc4747e92505aca6cca61198f65d5","url":"https://github.com/grails/grails-core"},{"original_method":"private void registerPlugin(GrailsPlugin plugin) {\n\t\tif(plugin instanceof ParentApplicationContextAware) {\n\t\t\t((ParentApplicationContextAware)plugin).setParentApplicationContext(parentCtx);\n\t\t}\n\t\tpluginList .add(plugin);\n\t\tplugins.put(plugin.getName(), plugin);\n\t}","id":25321,"modified_method":"private void registerPlugin(GrailsPlugin plugin) {\n\t\tif(plugin instanceof ParentApplicationContextAware) {\n\t\t\t((ParentApplicationContextAware)plugin).setParentApplicationContext(parentCtx);\n\t\t}\n\t\tplugin.setManager(this);\n\t\tpluginList.add(plugin);\n\t\tplugins.put(plugin.getName(), plugin);\n\t}","commit_id":"a6acab511b9cc4747e92505aca6cca61198f65d5","url":"https://github.com/grails/grails-core"},{"original_method":"public WebApplicationContext configureDomainOnly() {\n\t\tRuntimeSpringConfiguration springConfig = parent != null ? new DefaultRuntimeSpringConfiguration(parent) : new DefaultRuntimeSpringConfiguration();\n\t\tspringConfig.setServletContext(new MockServletContext());\n\t\tthis.pluginManager.loadPlugins();\n\t\t\n\t\tif(pluginManager.hasGrailsPlugin(\"hibernate\"))\n\t\t\tpluginManager.doRuntimeConfiguration(\"hibernate\", springConfig);\n\t\t\n\t\treturn springConfig.getApplicationContext();\n\n\t}","id":25322,"modified_method":"public WebApplicationContext configureDomainOnly() {\n\t\tRuntimeSpringConfiguration springConfig = parent != null ? new DefaultRuntimeSpringConfiguration(parent) : new DefaultRuntimeSpringConfiguration();\n\t\tspringConfig.setServletContext(new MockServletContext());\n\t\tthis.pluginManager.loadPlugins();\n\t\t\n\t\tif(pluginManager.hasGrailsPlugin(\"hibernate\"))\n\t\t\tpluginManager.doRuntimeConfiguration(\"hibernate\", springConfig);\n\t\t\n\t\tWebApplicationContext ctx = springConfig.getApplicationContext();\n\n\t\tperformPostProcessing(ctx);\t\t\n\t\treturn ctx;\t\t\n\t}","commit_id":"a6acab511b9cc4747e92505aca6cca61198f65d5","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * Configures the Grails application context at runtime\n\t * \n\t * @return An ApplicationContext instance\n\t */\n\tpublic WebApplicationContext configure(ServletContext context) {\t\t\n\t\tRuntimeSpringConfiguration springConfig = parent != null ? new DefaultRuntimeSpringConfiguration(parent) : new DefaultRuntimeSpringConfiguration();\n\t\tif(context != null)\n\t\t\tspringConfig.setServletContext(context);\n\t\t\n\t\tthis.pluginManager.loadPlugins();\n\n        Assert.notNull(application);\n        \n        this.pluginManager.doRuntimeConfiguration(springConfig);\n        \n\t\t// configure scaffolding\n\t\tLOG.debug(\"[RuntimeConfiguration] Proccessing additional external configurations\");\n\t\tdoPostResourceConfiguration(springConfig);\n\t\n\t\treturn springConfig.getApplicationContext();\t\n\t}","id":25323,"modified_method":"/**\n\t * Configures the Grails application context at runtime\n\t * \n\t * @return An ApplicationContext instance\n\t */\n\tpublic WebApplicationContext configure(ServletContext context) {\t\t\n\t\tRuntimeSpringConfiguration springConfig = parent != null ? new DefaultRuntimeSpringConfiguration(parent) : new DefaultRuntimeSpringConfiguration();\n\t\tif(context != null)\n\t\t\tspringConfig.setServletContext(context);\n\t\t\n\t\tthis.pluginManager.loadPlugins();\n\n        Assert.notNull(application);\n        \n        this.pluginManager.doRuntimeConfiguration(springConfig);\n        \n\t\t// configure scaffolding\n\t\tLOG.debug(\"[RuntimeConfiguration] Proccessing additional external configurations\");\n\t\tdoPostResourceConfiguration(springConfig);\n\t\n\t\tWebApplicationContext ctx = springConfig.getApplicationContext();\n\t\t\n\t\tperformPostProcessing(ctx);\n\t\t\n\t\treturn ctx;\n\t}","commit_id":"a6acab511b9cc4747e92505aca6cca61198f65d5","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Synchronize current bug instance with the bug detail\n     * window (source view, details window, etc.)\n     */\n    private void synchBugInstance() {\n        // Get current bug instance\n        BugInstance selected = getCurrentBugInstance();\n        if (selected == null)\n            return;\n         \n        // If the details window is minimized, then the user can't see\n        // it and there is no point in updating it.\n        if (!viewBugDetailsItem.isSelected())\n             return;\n\n        // Get the current source line annotation.\n        // If the current leaf selected is not a source line annotation,\n        // use the default source line annotation from the current bug instance\n        // (if any).\n        SourceLineAnnotation srcLine = null;\n        TreePath selPath = bugTree.getSelectionPath();\n        if (selPath != null) {\n            Object leaf = ((DefaultMutableTreeNode)selPath.getLastPathComponent()).getUserObject();\n            if (leaf instanceof SourceLineAnnotation)\n                srcLine = (SourceLineAnnotation) leaf;\n            else\n                srcLine = selected.getPrimarySourceLineAnnotation();\n        }\n        \n        // Show source code.\n        if (srcLine != currentSourceLineAnnotation) {\n            Project project = getCurrentProject();\n            AnalysisRun analysisRun = getCurrentAnalysisRun();\n            if (project == null) throw new IllegalStateException(\"null project!\");\n            if (analysisRun == null) throw new IllegalStateException(\"null analysis run!\");\n            viewSource(project, analysisRun, srcLine);\n            \n            currentSourceLineAnnotation = srcLine;\n        }\n        \n        // Show bug info.\n        showBugInfo(selected);\n        \n        // Now the bug details are up to date.\n        currentBugInstance = selected;\n    }","id":25324,"modified_method":"/**\n     * Synchronize current bug instance with the bug detail\n     * window (source view, details window, etc.)\n     */\n    private void synchBugInstance() {\n        // Get current bug instance\n        BugInstance selected = getCurrentBugInstance();\n        if (selected == null)\n            return;\n         \n        // If the details window is minimized, then the user can't see\n        // it and there is no point in updating it.\n        if (!viewBugDetailsItem.isSelected())\n             return;\n\n        // Get the current source line annotation.\n        // If the current leaf selected is not a source line annotation,\n        // use the default source line annotation from the current bug instance\n        // (if any).\n        JTree bugTree = getCurrentBugTree();\n        SourceLineAnnotation srcLine = null;\n        TreePath selPath = bugTree.getSelectionPath();\n        if (selPath != null) {\n            Object leaf = ((DefaultMutableTreeNode)selPath.getLastPathComponent()).getUserObject();\n            if (leaf instanceof SourceLineAnnotation)\n                srcLine = (SourceLineAnnotation) leaf;\n            else\n                srcLine = selected.getPrimarySourceLineAnnotation();\n        }\n        \n        // Show source code.\n        if (srcLine != currentSourceLineAnnotation) {\n            Project project = getCurrentProject();\n            AnalysisRun analysisRun = getCurrentAnalysisRun();\n            if (project == null) throw new IllegalStateException(\"null project!\");\n            if (analysisRun == null) throw new IllegalStateException(\"null analysis run!\");\n            viewSource(project, analysisRun, srcLine);\n            \n            currentSourceLineAnnotation = srcLine;\n        }\n        \n        // Show bug info.\n        showBugInfo(selected);\n        \n        // Now the bug details are up to date.\n        currentBugInstance = selected;\n    }","commit_id":"66a16f7f1ca64e265fff738366574cb35dd3be24","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * This is called from the constructor to perform post-initialization\n     * of the components in the form.\n     */\n    private void postInitComponents() {\n\tlogger = new ConsoleLogger(this);\n\t\n\tviewPanelLayout = (CardLayout) viewPanel.getLayout();\n\n        // Console starts out disabled\n        consoleSplitter.setDividerLocation(1.0);\n        \n\tbugTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n\tbugTree.setCellRenderer(new FindBugsFrame.BugCellRenderer());\n\tbugTree.setRootVisible(false);\n\tbugTree.setShowsRootHandles(true);\n\tbugTree.addTreeSelectionListener(new TreeSelectionListener() {\n\t    public void valueChanged(TreeSelectionEvent e) {\n\t\tbugTreeSelectionChanged(e);\n\t    }\n\t});\n\t\n\tjarFileList.setModel(new DefaultListModel());\n\tsourceDirList.setModel(new DefaultListModel());\n\t\n//\tgroupByChooser.addItem(GROUP_BY_CLASS);\n//\tgroupByChooser.addItem(GROUP_BY_PACKAGE);\n//\tgroupByChooser.addItem(GROUP_BY_BUG_TYPE);\n\t\n        // We use a special highlight painter to ensure that the highlights cover\n        // complete source lines, even though the source text doesn't\n        // fill the lines completely.\n        final Highlighter.HighlightPainter painter =\n            new DefaultHighlighter.DefaultHighlightPainter(sourceTextArea.getSelectionColor()) {\n                public Shape paintLayer(Graphics g, int offs0, int offs1,\n\t\t    Shape bounds, JTextComponent c, View view) {\n                    try {\n                        Shape extent = view.modelToView(offs0, Position.Bias.Forward, offs1, Position.Bias.Backward, bounds);\n                        Rectangle rect = extent.getBounds();\n                        rect.x = 0;\n                        rect.width = bounds.getBounds().width;\n                        g.setColor(getColor());\n                        g.fillRect(rect.x, rect.y, rect.width, rect.height);\n                        return rect;\n                    } catch (BadLocationException e) {\n                        return null;\n                    }\n                }\n            };\n        Highlighter sourceHighlighter = new DefaultHighlighter() {\n            public Object addHighlight(int p0, int p1, Highlighter.HighlightPainter p)\n                throws BadLocationException {\n                return super.addHighlight(p0, p1, painter);\n            }\n        };\n        sourceTextArea.setHighlighter(sourceHighlighter);\n    }","id":25325,"modified_method":"/**\n     * This is called from the constructor to perform post-initialization\n     * of the components in the form.\n     */\n    private void postInitComponents() {\n\tlogger = new ConsoleLogger(this);\n\t\n\tviewPanelLayout = (CardLayout) viewPanel.getLayout();\n\n        // Console starts out disabled\n        consoleSplitter.setDividerLocation(1.0);\n\n        // List of bug group tabs.\n        // This must be in the same order as GROUP_BY_ORDER_LIST!\n        bugTreeList = new JTree[]{byClassBugTree, byPackageBugTree, byBugTypeBugTree};\n\n        // Configure bug trees\n        for (int i = 0; i < bugTreeList.length; ++i) {\n            JTree bugTree = bugTreeList[i];\n            bugTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n            bugTree.setCellRenderer(new FindBugsFrame.BugCellRenderer());\n            bugTree.setRootVisible(false);\n            bugTree.setShowsRootHandles(true);\n            bugTree.addTreeSelectionListener(new TreeSelectionListener() {\n                public void valueChanged(TreeSelectionEvent e) {\n                    bugTreeSelectionChanged(e);\n                }\n            });\n        }\n\t\n\tjarFileList.setModel(new DefaultListModel());\n\tsourceDirList.setModel(new DefaultListModel());\n\t\n        // We use a special highlight painter to ensure that the highlights cover\n        // complete source lines, even though the source text doesn't\n        // fill the lines completely.\n        final Highlighter.HighlightPainter painter =\n            new DefaultHighlighter.DefaultHighlightPainter(sourceTextArea.getSelectionColor()) {\n                public Shape paintLayer(Graphics g, int offs0, int offs1,\n\t\t    Shape bounds, JTextComponent c, View view) {\n                    try {\n                        Shape extent = view.modelToView(offs0, Position.Bias.Forward, offs1, Position.Bias.Backward, bounds);\n                        Rectangle rect = extent.getBounds();\n                        rect.x = 0;\n                        rect.width = bounds.getBounds().width;\n                        g.setColor(getColor());\n                        g.fillRect(rect.x, rect.y, rect.width, rect.height);\n                        return rect;\n                    } catch (BadLocationException e) {\n                        return null;\n                    }\n                }\n            };\n        Highlighter sourceHighlighter = new DefaultHighlighter() {\n            public Object addHighlight(int p0, int p1, Highlighter.HighlightPainter p)\n                throws BadLocationException {\n                return super.addHighlight(p0, p1, painter);\n            }\n        };\n        sourceTextArea.setHighlighter(sourceHighlighter);\n    }","commit_id":"66a16f7f1ca64e265fff738366574cb35dd3be24","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void fullDescriptionsItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fullDescriptionsItemActionPerformed\n        // Redisplay the visible bug instance nodes\n        DefaultTreeModel bugTreeModel = (DefaultTreeModel) bugTree.getModel();\n        \n        int firstVisibleRow = bugTree.getRowForLocation(0, 0);\n        int numVisibleRows = bugTree.getVisibleRowCount();\n        for (int i = firstVisibleRow; i < (firstVisibleRow + numVisibleRows); ++i) {\n            //System.out.println(\"Getting path for row \" + i);\n            TreePath path = bugTree.getPathForRow(i);\n            if (path == null)\n                continue;\n            DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();\n            if (node instanceof BugTreeNode)\n                bugTreeModel.valueForPathChanged(path, node.getUserObject());\n        }\n    }","id":25326,"modified_method":"private void fullDescriptionsItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fullDescriptionsItemActionPerformed\n        JTree bugTree = getCurrentBugTree();\n        \n        // Redisplay the visible bug instance nodes\n        DefaultTreeModel bugTreeModel = (DefaultTreeModel) bugTree.getModel();\n        \n        int firstVisibleRow = bugTree.getRowForLocation(0, 0);\n        int numVisibleRows = bugTree.getVisibleRowCount();\n        for (int i = firstVisibleRow; i < (firstVisibleRow + numVisibleRows); ++i) {\n            //System.out.println(\"Getting path for row \" + i);\n            TreePath path = bugTree.getPathForRow(i);\n            if (path == null)\n                continue;\n            DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();\n            if (node instanceof BugTreeNode)\n                bugTreeModel.valueForPathChanged(path, node.getUserObject());\n        }\n    }","commit_id":"66a16f7f1ca64e265fff738366574cb35dd3be24","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * Synchronize the bug tree with the given analysisRun object.\n     * @param analysisRun the selected analysis run\n     */\n    private void synchAnalysisRun(AnalysisRun analysisRun) {\n\tboolean modelChanged = false;\n\t\n\tif (analysisRun != currentAnalysisRun) {\n\t    modelChanged = true;\n\t    // If this is the first time the analysis run is being shown in\n\t    // the bug tree, it won't have a tree model yet.\n\t    if (analysisRun.getTreeModel() == null) {\n\t\tDefaultMutableTreeNode bugRootNode = new DefaultMutableTreeNode();\n\t\tDefaultTreeModel bugTreeModel = new DefaultTreeModel(bugRootNode);\n\t\tanalysisRun.setTreeModel(bugTreeModel);\n\t    }\n\t    \n\t}\n\t\n\t// Make sure that the sort order is correct.\n\t//String currentSortOrder = groupByChooser.getSelectedItem().toString();\n        String currentSortOrder = GROUP_BY_CLASS;\n\tif (!analysisRun.getSortOrder().equals(currentSortOrder)) {\n\t    populateAnalysisRunTreeModel(analysisRun, currentSortOrder);\n\t}\n\t\n\tif (modelChanged) {\n\t    bugTree.setModel(analysisRun.getTreeModel());\n\t    currentAnalysisRun = analysisRun;\n\t}\n\t\n\t// TODO: restore state of tree! I.e., which nodes expanded, and selection\n    }","id":25327,"modified_method":"/**\n     * Synchronize the bug trees with the given analysisRun object.\n     * @param analysisRun the selected analysis run\n     */\n    private void synchAnalysisRun(AnalysisRun analysisRun) {\n        // Create and populate tree models\n        for (int i = 0; i < GROUP_BY_ORDER_LIST.length; ++i) {\n            DefaultMutableTreeNode bugRootNode = new DefaultMutableTreeNode();\n            DefaultTreeModel bugTreeModel = new DefaultTreeModel(bugRootNode);\n            \n            String groupByOrder = GROUP_BY_ORDER_LIST[i];\n            analysisRun.setTreeModel(groupByOrder, bugTreeModel);\n            populateAnalysisRunTreeModel(analysisRun, groupByOrder);\n            if (i < bugTreeList.length)\n                bugTreeList[i].setModel(bugTreeModel);\n        }\n    }","commit_id":"66a16f7f1ca64e265fff738366574cb35dd3be24","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * Populate an analysis run's tree model for given sort order.\n     */\n    private void populateAnalysisRunTreeModel(AnalysisRun analysisRun, final String groupBy) {\n\t// Set busy cursor - this is potentially a time-consuming operation\n\tCursor orig = this.getCursor();\n\tthis.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n\t\n\tfinal DefaultTreeModel bugTreeModel = analysisRun.getTreeModel();\n\tfinal DefaultMutableTreeNode bugRootNode = (DefaultMutableTreeNode) bugTreeModel.getRoot();\n\t\n\t// Delete all children from root node\n\tbugRootNode.removeAllChildren();\n\t\n\t// Sort the instances\n\tTreeSet sortedCollection = new TreeSet(getBugInstanceComparator(groupBy));\n\tsortedCollection.addAll(analysisRun.getBugInstances());\n\t\n\t// The grouper callback is what actually adds the group and bug\n\t// nodes to the tree.\n\tGrouper.Callback callback = new Grouper.Callback() {\n\t    private BugInstanceGroup currentGroup;\n\t    private DefaultMutableTreeNode currentGroupNode;\n\t    \n\t    public void startGroup(Object member_) {\n\t\tBugInstance member = (BugInstance) member_;\n\t\tString groupName;\n\t\tif (groupBy == GROUP_BY_CLASS)\n\t\t    groupName = member.getPrimaryClass().getClassName();\n\t\telse if (groupBy == GROUP_BY_PACKAGE) {\n\t\t    groupName = member.getPrimaryClass().getPackageName();\n                    if (groupName.equals(\"\"))\n                        groupName = \"Unnamed package\";\n                } else if (groupBy == GROUP_BY_BUG_TYPE) {\n\t\t    String desc = member.toString();\n\t\t    String shortBugType = desc.substring(0, desc.indexOf(':'));\n                    String bugTypeDescription = I18N.instance().getBugTypeDescription(shortBugType);\n                    groupName = shortBugType + \": \" + bugTypeDescription;\n\t\t} else\n\t\t    throw new IllegalStateException(\"Unknown sort order: \" + groupBy);\n\t\tcurrentGroup = new BugInstanceGroup(groupBy, groupName);\n\t\tcurrentGroupNode = new DefaultMutableTreeNode(currentGroup);\n\t\tbugTreeModel.insertNodeInto(currentGroupNode, bugRootNode, bugRootNode.getChildCount());\n\t\t\n\t\tinsertIntoGroup(member);\n\t    }\n\t    \n\t    public void addToGroup(Object member_) {\n\t\tBugInstance member = (BugInstance) member_;\n\t\tinsertIntoGroup(member);\n\t    }\n\t    \n\t    private void insertIntoGroup(BugInstance member) {\n\t\tcurrentGroup.incrementMemberCount();\n\t\tDefaultMutableTreeNode bugNode = new BugTreeNode(member);\n\t\tbugTreeModel.insertNodeInto(bugNode, currentGroupNode, currentGroupNode.getChildCount());\n\n\t\t// Insert annotations\n\t\tIterator j = member.annotationIterator();\n\t\twhile (j.hasNext()) {\n\t\t    BugAnnotation annotation = (BugAnnotation) j.next();\n\t\t    DefaultMutableTreeNode annotationNode = new DefaultMutableTreeNode(annotation);\n\t\t    bugTreeModel.insertNodeInto(annotationNode, bugNode,  bugNode.getChildCount());\n\t\t}\n\t\t\n\t    }\n\t};\n\t\n\t// Create the grouper, and execute it to populate the bug tree\n\tGrouper grouper = new Grouper(callback);\n\tComparator groupComparator = getGroupComparator(groupBy);\n\tgrouper.group(sortedCollection, groupComparator);\n\t\n\t// Sort order is up to date now\n\tanalysisRun.setSortOrder(groupBy);\n\t\n\t// Let the tree know it needs to update itself\n\tbugTreeModel.nodeStructureChanged(bugRootNode);\n\t\n\t// Now we're done\n\tthis.setCursor(orig);\n    }","id":25328,"modified_method":"/**\n     * Populate an analysis run's tree model for given sort order.\n     */\n    private void populateAnalysisRunTreeModel(AnalysisRun analysisRun, final String groupBy) {\n        System.out.println(\"Populating bug tree for order \" + groupBy);\n        \n\t// Set busy cursor - this is potentially a time-consuming operation\n\tCursor orig = this.getCursor();\n\tthis.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n\t\n\tfinal DefaultTreeModel bugTreeModel = analysisRun.getTreeModel(groupBy);\n\tfinal DefaultMutableTreeNode bugRootNode = (DefaultMutableTreeNode) bugTreeModel.getRoot();\n\t\n\t// Delete all children from root node\n\tbugRootNode.removeAllChildren();\n\t\n\t// Sort the instances\n\tTreeSet sortedCollection = new TreeSet(getBugInstanceComparator(groupBy));\n\tsortedCollection.addAll(analysisRun.getBugInstances());\n\t\n\t// The grouper callback is what actually adds the group and bug\n\t// nodes to the tree.\n\tGrouper.Callback callback = new Grouper.Callback() {\n\t    private BugInstanceGroup currentGroup;\n\t    private DefaultMutableTreeNode currentGroupNode;\n\t    \n\t    public void startGroup(Object member_) {\n\t\tBugInstance member = (BugInstance) member_;\n\t\tString groupName;\n\t\tif (groupBy == GROUP_BY_CLASS)\n\t\t    groupName = member.getPrimaryClass().getClassName();\n\t\telse if (groupBy == GROUP_BY_PACKAGE) {\n\t\t    groupName = member.getPrimaryClass().getPackageName();\n                    if (groupName.equals(\"\"))\n                        groupName = \"Unnamed package\";\n                } else if (groupBy == GROUP_BY_BUG_TYPE) {\n\t\t    String desc = member.toString();\n\t\t    String shortBugType = desc.substring(0, desc.indexOf(':'));\n                    String bugTypeDescription = I18N.instance().getBugTypeDescription(shortBugType);\n                    groupName = shortBugType + \": \" + bugTypeDescription;\n\t\t} else\n\t\t    throw new IllegalStateException(\"Unknown sort order: \" + groupBy);\n\t\tcurrentGroup = new BugInstanceGroup(groupBy, groupName);\n\t\tcurrentGroupNode = new DefaultMutableTreeNode(currentGroup);\n\t\tbugTreeModel.insertNodeInto(currentGroupNode, bugRootNode, bugRootNode.getChildCount());\n\t\t\n\t\tinsertIntoGroup(member);\n\t    }\n\t    \n\t    public void addToGroup(Object member_) {\n\t\tBugInstance member = (BugInstance) member_;\n\t\tinsertIntoGroup(member);\n\t    }\n\t    \n\t    private void insertIntoGroup(BugInstance member) {\n\t\tcurrentGroup.incrementMemberCount();\n\t\tDefaultMutableTreeNode bugNode = new BugTreeNode(member);\n\t\tbugTreeModel.insertNodeInto(bugNode, currentGroupNode, currentGroupNode.getChildCount());\n\n\t\t// Insert annotations\n\t\tIterator j = member.annotationIterator();\n\t\twhile (j.hasNext()) {\n\t\t    BugAnnotation annotation = (BugAnnotation) j.next();\n\t\t    DefaultMutableTreeNode annotationNode = new DefaultMutableTreeNode(annotation);\n\t\t    bugTreeModel.insertNodeInto(annotationNode, bugNode,  bugNode.getChildCount());\n\t\t}\n\t\t\n\t    }\n\t};\n\t\n\t// Create the grouper, and execute it to populate the bug tree\n\tGrouper grouper = new Grouper(callback);\n\tComparator groupComparator = getGroupComparator(groupBy);\n\tgrouper.group(sortedCollection, groupComparator);\n\t\n\t// Let the tree know it needs to update itself\n\tbugTreeModel.nodeStructureChanged(bugRootNode);\n\t\n\t// Now we're done\n\tthis.setCursor(orig);\n    }","commit_id":"66a16f7f1ca64e265fff738366574cb35dd3be24","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * Get the bug instance currently selected in the bug tree.\n     */\n    private BugInstance getCurrentBugInstance() {\n\treturn (BugInstance) getTreeSelectionOf(bugTree, BugInstance.class);\n    }","id":25329,"modified_method":"/**\n     * Get the bug instance currently selected in the bug tree.\n     */\n    private BugInstance getCurrentBugInstance() {\n        JTree bugTree = getCurrentBugTree();\n\treturn (BugInstance) getTreeSelectionOf(bugTree, BugInstance.class);\n    }","commit_id":"66a16f7f1ca64e265fff738366574cb35dd3be24","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    private void initComponents() {//GEN-BEGIN:initComponents\n        java.awt.GridBagConstraints gridBagConstraints;\n\n        consoleSplitter = new javax.swing.JSplitPane();\n        viewPanel = new javax.swing.JPanel();\n        emptyPanel = new javax.swing.JPanel();\n        reportPanel = new javax.swing.JPanel();\n        editProjectPanel = new javax.swing.JPanel();\n        jarFileLabel = new javax.swing.JLabel();\n        jarNameTextField = new javax.swing.JTextField();\n        addJarButton = new javax.swing.JButton();\n        jarFileListLabel = new javax.swing.JLabel();\n        sourceDirLabel = new javax.swing.JLabel();\n        srcDirTextField = new javax.swing.JTextField();\n        addSourceDirButton = new javax.swing.JButton();\n        sourceDirListLabel = new javax.swing.JLabel();\n        removeJarButton = new javax.swing.JButton();\n        removeSrcDirButton = new javax.swing.JButton();\n        jSeparator1 = new javax.swing.JSeparator();\n        browseJarButton = new javax.swing.JButton();\n        browseSrcDirButton = new javax.swing.JButton();\n        editProjectLabel = new javax.swing.JLabel();\n        jSeparator2 = new javax.swing.JSeparator();\n        findBugsButton = new javax.swing.JButton();\n        jSeparator4 = new javax.swing.JSeparator();\n        jarFileListScrollPane = new javax.swing.JScrollPane();\n        jarFileList = new javax.swing.JList();\n        sourceDirListScrollPane = new javax.swing.JScrollPane();\n        sourceDirList = new javax.swing.JList();\n        bugTreePanel = new javax.swing.JPanel();\n        bugTreeBugDetailsSplitter = new javax.swing.JSplitPane();\n        groupByTabbedPane = new javax.swing.JTabbedPane();\n        bugTreeScrollPane = new javax.swing.JScrollPane();\n        bugTree = new javax.swing.JTree();\n        bugDetailsTabbedPane = new javax.swing.JTabbedPane();\n        bugDescriptionScrollPane = new javax.swing.JScrollPane();\n        bugDescriptionEditorPane = new javax.swing.JEditorPane();\n        sourceTextAreaScrollPane = new javax.swing.JScrollPane();\n        sourceTextArea = new javax.swing.JTextArea();\n        consoleScrollPane = new javax.swing.JScrollPane();\n        consoleMessageArea = new javax.swing.JTextArea();\n        theMenuBar = new javax.swing.JMenuBar();\n        fileMenu = new javax.swing.JMenu();\n        newProjectItem = new javax.swing.JMenuItem();\n        openProjectItem = new javax.swing.JMenuItem();\n        saveProjectItem = new javax.swing.JMenuItem();\n        closeProjectItem = new javax.swing.JMenuItem();\n        jSeparator3 = new javax.swing.JSeparator();\n        exitItem = new javax.swing.JMenuItem();\n        viewMenu = new javax.swing.JMenu();\n        viewConsoleItem = new javax.swing.JCheckBoxMenuItem();\n        viewBugDetailsItem = new javax.swing.JCheckBoxMenuItem();\n        fullDescriptionsItem = new javax.swing.JCheckBoxMenuItem();\n        helpMenu = new javax.swing.JMenu();\n        aboutItem = new javax.swing.JMenuItem();\n\n        setTitle(\"FindBugs\");\n        addWindowListener(new java.awt.event.WindowAdapter() {\n            public void windowClosing(java.awt.event.WindowEvent evt) {\n                exitForm(evt);\n            }\n        });\n\n        consoleSplitter.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);\n        consoleSplitter.setResizeWeight(1.0);\n        consoleSplitter.setOneTouchExpandable(true);\n        consoleSplitter.addPropertyChangeListener(new java.beans.PropertyChangeListener() {\n            public void propertyChange(java.beans.PropertyChangeEvent evt) {\n                consoleSplitterPropertyChange(evt);\n            }\n        });\n\n        viewPanel.setLayout(new java.awt.CardLayout());\n\n        viewPanel.add(emptyPanel, \"EmptyPanel\");\n\n        viewPanel.add(reportPanel, \"ReportPanel\");\n\n        editProjectPanel.setLayout(new java.awt.GridBagLayout());\n\n        jarFileLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileLabel.setText(\"Jar file:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileLabel, gridBagConstraints);\n\n        jarNameTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jarNameTextFieldActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(jarNameTextField, gridBagConstraints);\n\n        addJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        addJarButton.setText(\"Add\");\n        addJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(addJarButton, gridBagConstraints);\n\n        jarFileListLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileListLabel.setText(\"Jar Files:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileListLabel, gridBagConstraints);\n\n        sourceDirLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirLabel.setText(\"Source Dir:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirLabel, gridBagConstraints);\n\n        srcDirTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                srcDirTextFieldActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(srcDirTextField, gridBagConstraints);\n\n        addSourceDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        addSourceDirButton.setText(\"Add\");\n        addSourceDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addSourceDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(addSourceDirButton, gridBagConstraints);\n\n        sourceDirListLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirListLabel.setText(\"Source Dirs:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirListLabel, gridBagConstraints);\n\n        removeJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        removeJarButton.setText(\"Remove\");\n        removeJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(removeJarButton, gridBagConstraints);\n\n        removeSrcDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        removeSrcDirButton.setText(\"Remove\");\n        removeSrcDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeSrcDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(removeSrcDirButton, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 5;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator1, gridBagConstraints);\n\n        browseJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        browseJarButton.setText(\"Browse\");\n        browseJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(browseJarButton, gridBagConstraints);\n\n        browseSrcDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        browseSrcDirButton.setText(\"Browse\");\n        browseSrcDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseSrcDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(browseSrcDirButton, gridBagConstraints);\n\n        editProjectLabel.setBackground(new java.awt.Color(0, 0, 204));\n        editProjectLabel.setFont(new java.awt.Font(\"Dialog\", 1, 24));\n        editProjectLabel.setForeground(new java.awt.Color(255, 255, 255));\n        editProjectLabel.setText(\"Project\");\n        editProjectLabel.setOpaque(true);\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        editProjectPanel.add(editProjectLabel, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 2;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator2, gridBagConstraints);\n\n        findBugsButton.setMnemonic('F');\n        findBugsButton.setText(\"Find Bugs!\");\n        findBugsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                findBugsButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 9;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(findBugsButton, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 8;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator4, gridBagConstraints);\n\n        jarFileListScrollPane.setPreferredSize(new java.awt.Dimension(259, 1));\n        jarFileList.setBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\n        jarFileList.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        jarFileListScrollPane.setViewportView(jarFileList);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weighty = 0.7;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileListScrollPane, gridBagConstraints);\n\n        sourceDirListScrollPane.setPreferredSize(new java.awt.Dimension(259, 1));\n        sourceDirList.setBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\n        sourceDirList.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        sourceDirListScrollPane.setViewportView(sourceDirList);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weighty = 0.3;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirListScrollPane, gridBagConstraints);\n\n        viewPanel.add(editProjectPanel, \"EditProjectPanel\");\n\n        bugTreePanel.setLayout(new java.awt.GridBagLayout());\n\n        bugTreeBugDetailsSplitter.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);\n        bugTreeBugDetailsSplitter.setResizeWeight(1.0);\n        bugTreeBugDetailsSplitter.setOneTouchExpandable(true);\n        bugTreeBugDetailsSplitter.addPropertyChangeListener(new java.beans.PropertyChangeListener() {\n            public void propertyChange(java.beans.PropertyChangeEvent evt) {\n                bugTreeBugDetailsSplitterPropertyChange(evt);\n            }\n        });\n\n        bugTreeScrollPane.setViewportView(bugTree);\n\n        groupByTabbedPane.addTab(\"By Class\", bugTreeScrollPane);\n\n        bugTreeBugDetailsSplitter.setTopComponent(groupByTabbedPane);\n\n        bugDescriptionEditorPane.setEditable(false);\n        bugDescriptionScrollPane.setViewportView(bugDescriptionEditorPane);\n\n        bugDetailsTabbedPane.addTab(\"Details\", bugDescriptionScrollPane);\n\n        sourceTextAreaScrollPane.setMinimumSize(new java.awt.Dimension(22, 180));\n        sourceTextAreaScrollPane.setPreferredSize(new java.awt.Dimension(0, 100));\n        sourceTextArea.setEditable(false);\n        sourceTextArea.setFont(new java.awt.Font(\"Lucida Sans Typewriter\", 0, 12));\n        sourceTextAreaScrollPane.setViewportView(sourceTextArea);\n\n        bugDetailsTabbedPane.addTab(\"Source code\", sourceTextAreaScrollPane);\n\n        bugTreeBugDetailsSplitter.setBottomComponent(bugDetailsTabbedPane);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 1;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.weighty = 1.0;\n        bugTreePanel.add(bugTreeBugDetailsSplitter, gridBagConstraints);\n\n        viewPanel.add(bugTreePanel, \"BugTree\");\n\n        consoleSplitter.setTopComponent(viewPanel);\n\n        consoleScrollPane.setMinimumSize(new java.awt.Dimension(22, 100));\n        consoleScrollPane.setPreferredSize(new java.awt.Dimension(0, 100));\n        consoleMessageArea.setBackground(new java.awt.Color(204, 204, 204));\n        consoleMessageArea.setEditable(false);\n        consoleMessageArea.setFont(new java.awt.Font(\"Lucida Sans Typewriter\", 0, 12));\n        consoleMessageArea.setMinimumSize(new java.awt.Dimension(0, 0));\n        consoleMessageArea.setAutoscrolls(false);\n        consoleScrollPane.setViewportView(consoleMessageArea);\n\n        consoleSplitter.setBottomComponent(consoleScrollPane);\n\n        getContentPane().add(consoleSplitter, java.awt.BorderLayout.CENTER);\n\n        theMenuBar.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        fileMenu.setMnemonic('F');\n        fileMenu.setText(\"File\");\n        fileMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        newProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        newProjectItem.setMnemonic('N');\n        newProjectItem.setText(\"New Project\");\n        newProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(newProjectItem);\n\n        openProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        openProjectItem.setMnemonic('O');\n        openProjectItem.setText(\"Open Project\");\n        openProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                openProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(openProjectItem);\n\n        saveProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        saveProjectItem.setMnemonic('S');\n        saveProjectItem.setText(\"Save project\");\n        saveProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(saveProjectItem);\n\n        closeProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        closeProjectItem.setMnemonic('C');\n        closeProjectItem.setText(\"Close Project\");\n        fileMenu.add(closeProjectItem);\n\n        fileMenu.add(jSeparator3);\n\n        exitItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        exitItem.setMnemonic('X');\n        exitItem.setText(\"Exit\");\n        exitItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                exitItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(exitItem);\n\n        theMenuBar.add(fileMenu);\n\n        viewMenu.setMnemonic('V');\n        viewMenu.setText(\"View\");\n        viewMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        viewConsoleItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        viewConsoleItem.setMnemonic('C');\n        viewConsoleItem.setText(\"Console\");\n        viewConsoleItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                viewConsoleItemActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(viewConsoleItem);\n\n        viewBugDetailsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        viewBugDetailsItem.setMnemonic('D');\n        viewBugDetailsItem.setSelected(true);\n        viewBugDetailsItem.setText(\"Bug Details\");\n        viewBugDetailsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                viewBugDetailsItemActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(viewBugDetailsItem);\n\n        fullDescriptionsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        fullDescriptionsItem.setMnemonic('F');\n        fullDescriptionsItem.setText(\"Full Descriptions\");\n        fullDescriptionsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                fullDescriptionsItemActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(fullDescriptionsItem);\n\n        theMenuBar.add(viewMenu);\n\n        helpMenu.setMnemonic('H');\n        helpMenu.setText(\"Help\");\n        helpMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        aboutItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        aboutItem.setMnemonic('A');\n        aboutItem.setText(\"About\");\n        aboutItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                aboutItemActionPerformed(evt);\n            }\n        });\n\n        helpMenu.add(aboutItem);\n\n        theMenuBar.add(helpMenu);\n\n        setJMenuBar(theMenuBar);\n\n        pack();\n    }","id":25330,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    private void initComponents() {//GEN-BEGIN:initComponents\n        java.awt.GridBagConstraints gridBagConstraints;\n\n        consoleSplitter = new javax.swing.JSplitPane();\n        viewPanel = new javax.swing.JPanel();\n        emptyPanel = new javax.swing.JPanel();\n        reportPanel = new javax.swing.JPanel();\n        editProjectPanel = new javax.swing.JPanel();\n        jarFileLabel = new javax.swing.JLabel();\n        jarNameTextField = new javax.swing.JTextField();\n        addJarButton = new javax.swing.JButton();\n        jarFileListLabel = new javax.swing.JLabel();\n        sourceDirLabel = new javax.swing.JLabel();\n        srcDirTextField = new javax.swing.JTextField();\n        addSourceDirButton = new javax.swing.JButton();\n        sourceDirListLabel = new javax.swing.JLabel();\n        removeJarButton = new javax.swing.JButton();\n        removeSrcDirButton = new javax.swing.JButton();\n        jSeparator1 = new javax.swing.JSeparator();\n        browseJarButton = new javax.swing.JButton();\n        browseSrcDirButton = new javax.swing.JButton();\n        editProjectLabel = new javax.swing.JLabel();\n        jSeparator2 = new javax.swing.JSeparator();\n        findBugsButton = new javax.swing.JButton();\n        jSeparator4 = new javax.swing.JSeparator();\n        jarFileListScrollPane = new javax.swing.JScrollPane();\n        jarFileList = new javax.swing.JList();\n        sourceDirListScrollPane = new javax.swing.JScrollPane();\n        sourceDirList = new javax.swing.JList();\n        bugTreePanel = new javax.swing.JPanel();\n        bugTreeBugDetailsSplitter = new javax.swing.JSplitPane();\n        groupByTabbedPane = new javax.swing.JTabbedPane();\n        byClassScrollPane = new javax.swing.JScrollPane();\n        byClassBugTree = new javax.swing.JTree();\n        byPackageScrollPane = new javax.swing.JScrollPane();\n        byPackageBugTree = new javax.swing.JTree();\n        byBugTypeScrollPane = new javax.swing.JScrollPane();\n        byBugTypeBugTree = new javax.swing.JTree();\n        bugDetailsTabbedPane = new javax.swing.JTabbedPane();\n        bugDescriptionScrollPane = new javax.swing.JScrollPane();\n        bugDescriptionEditorPane = new javax.swing.JEditorPane();\n        sourceTextAreaScrollPane = new javax.swing.JScrollPane();\n        sourceTextArea = new javax.swing.JTextArea();\n        consoleScrollPane = new javax.swing.JScrollPane();\n        consoleMessageArea = new javax.swing.JTextArea();\n        theMenuBar = new javax.swing.JMenuBar();\n        fileMenu = new javax.swing.JMenu();\n        newProjectItem = new javax.swing.JMenuItem();\n        openProjectItem = new javax.swing.JMenuItem();\n        saveProjectItem = new javax.swing.JMenuItem();\n        closeProjectItem = new javax.swing.JMenuItem();\n        jSeparator3 = new javax.swing.JSeparator();\n        exitItem = new javax.swing.JMenuItem();\n        viewMenu = new javax.swing.JMenu();\n        viewConsoleItem = new javax.swing.JCheckBoxMenuItem();\n        viewBugDetailsItem = new javax.swing.JCheckBoxMenuItem();\n        fullDescriptionsItem = new javax.swing.JCheckBoxMenuItem();\n        helpMenu = new javax.swing.JMenu();\n        aboutItem = new javax.swing.JMenuItem();\n\n        setTitle(\"FindBugs\");\n        addWindowListener(new java.awt.event.WindowAdapter() {\n            public void windowClosing(java.awt.event.WindowEvent evt) {\n                exitForm(evt);\n            }\n        });\n\n        consoleSplitter.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);\n        consoleSplitter.setResizeWeight(1.0);\n        consoleSplitter.setOneTouchExpandable(true);\n        consoleSplitter.addPropertyChangeListener(new java.beans.PropertyChangeListener() {\n            public void propertyChange(java.beans.PropertyChangeEvent evt) {\n                consoleSplitterPropertyChange(evt);\n            }\n        });\n\n        viewPanel.setLayout(new java.awt.CardLayout());\n\n        viewPanel.add(emptyPanel, \"EmptyPanel\");\n\n        viewPanel.add(reportPanel, \"ReportPanel\");\n\n        editProjectPanel.setLayout(new java.awt.GridBagLayout());\n\n        jarFileLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileLabel.setText(\"Jar file:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileLabel, gridBagConstraints);\n\n        jarNameTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jarNameTextFieldActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(jarNameTextField, gridBagConstraints);\n\n        addJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        addJarButton.setText(\"Add\");\n        addJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(addJarButton, gridBagConstraints);\n\n        jarFileListLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileListLabel.setText(\"Jar Files:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileListLabel, gridBagConstraints);\n\n        sourceDirLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirLabel.setText(\"Source Dir:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirLabel, gridBagConstraints);\n\n        srcDirTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                srcDirTextFieldActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(srcDirTextField, gridBagConstraints);\n\n        addSourceDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        addSourceDirButton.setText(\"Add\");\n        addSourceDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addSourceDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(addSourceDirButton, gridBagConstraints);\n\n        sourceDirListLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirListLabel.setText(\"Source Dirs:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirListLabel, gridBagConstraints);\n\n        removeJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        removeJarButton.setText(\"Remove\");\n        removeJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(removeJarButton, gridBagConstraints);\n\n        removeSrcDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        removeSrcDirButton.setText(\"Remove\");\n        removeSrcDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeSrcDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(removeSrcDirButton, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 5;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator1, gridBagConstraints);\n\n        browseJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        browseJarButton.setText(\"Browse\");\n        browseJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(browseJarButton, gridBagConstraints);\n\n        browseSrcDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        browseSrcDirButton.setText(\"Browse\");\n        browseSrcDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseSrcDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(browseSrcDirButton, gridBagConstraints);\n\n        editProjectLabel.setBackground(new java.awt.Color(0, 0, 204));\n        editProjectLabel.setFont(new java.awt.Font(\"Dialog\", 1, 24));\n        editProjectLabel.setForeground(new java.awt.Color(255, 255, 255));\n        editProjectLabel.setText(\"Project\");\n        editProjectLabel.setOpaque(true);\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        editProjectPanel.add(editProjectLabel, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 2;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator2, gridBagConstraints);\n\n        findBugsButton.setMnemonic('F');\n        findBugsButton.setText(\"Find Bugs!\");\n        findBugsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                findBugsButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 9;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(findBugsButton, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 8;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator4, gridBagConstraints);\n\n        jarFileListScrollPane.setPreferredSize(new java.awt.Dimension(259, 1));\n        jarFileList.setBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\n        jarFileList.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        jarFileListScrollPane.setViewportView(jarFileList);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weighty = 0.7;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileListScrollPane, gridBagConstraints);\n\n        sourceDirListScrollPane.setPreferredSize(new java.awt.Dimension(259, 1));\n        sourceDirList.setBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\n        sourceDirList.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        sourceDirListScrollPane.setViewportView(sourceDirList);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weighty = 0.3;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirListScrollPane, gridBagConstraints);\n\n        viewPanel.add(editProjectPanel, \"EditProjectPanel\");\n\n        bugTreePanel.setLayout(new java.awt.GridBagLayout());\n\n        bugTreeBugDetailsSplitter.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);\n        bugTreeBugDetailsSplitter.setResizeWeight(1.0);\n        bugTreeBugDetailsSplitter.setOneTouchExpandable(true);\n        bugTreeBugDetailsSplitter.addPropertyChangeListener(new java.beans.PropertyChangeListener() {\n            public void propertyChange(java.beans.PropertyChangeEvent evt) {\n                bugTreeBugDetailsSplitterPropertyChange(evt);\n            }\n        });\n\n        byClassScrollPane.setViewportView(byClassBugTree);\n\n        groupByTabbedPane.addTab(\"By Class\", byClassScrollPane);\n\n        byPackageScrollPane.setViewportView(byPackageBugTree);\n\n        groupByTabbedPane.addTab(\"By Package\", byPackageScrollPane);\n\n        byBugTypeScrollPane.setViewportView(byBugTypeBugTree);\n\n        groupByTabbedPane.addTab(\"By Bug Type\", byBugTypeScrollPane);\n\n        bugTreeBugDetailsSplitter.setTopComponent(groupByTabbedPane);\n\n        bugDescriptionEditorPane.setEditable(false);\n        bugDescriptionScrollPane.setViewportView(bugDescriptionEditorPane);\n\n        bugDetailsTabbedPane.addTab(\"Details\", bugDescriptionScrollPane);\n\n        sourceTextAreaScrollPane.setMinimumSize(new java.awt.Dimension(22, 180));\n        sourceTextAreaScrollPane.setPreferredSize(new java.awt.Dimension(0, 100));\n        sourceTextArea.setEditable(false);\n        sourceTextArea.setFont(new java.awt.Font(\"Lucida Sans Typewriter\", 0, 12));\n        sourceTextAreaScrollPane.setViewportView(sourceTextArea);\n\n        bugDetailsTabbedPane.addTab(\"Source code\", sourceTextAreaScrollPane);\n\n        bugTreeBugDetailsSplitter.setBottomComponent(bugDetailsTabbedPane);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 1;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.weighty = 1.0;\n        bugTreePanel.add(bugTreeBugDetailsSplitter, gridBagConstraints);\n\n        viewPanel.add(bugTreePanel, \"BugTree\");\n\n        consoleSplitter.setTopComponent(viewPanel);\n\n        consoleScrollPane.setMinimumSize(new java.awt.Dimension(22, 100));\n        consoleScrollPane.setPreferredSize(new java.awt.Dimension(0, 100));\n        consoleMessageArea.setBackground(new java.awt.Color(204, 204, 204));\n        consoleMessageArea.setEditable(false);\n        consoleMessageArea.setFont(new java.awt.Font(\"Lucida Sans Typewriter\", 0, 12));\n        consoleMessageArea.setMinimumSize(new java.awt.Dimension(0, 0));\n        consoleMessageArea.setAutoscrolls(false);\n        consoleScrollPane.setViewportView(consoleMessageArea);\n\n        consoleSplitter.setBottomComponent(consoleScrollPane);\n\n        getContentPane().add(consoleSplitter, java.awt.BorderLayout.CENTER);\n\n        theMenuBar.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        fileMenu.setMnemonic('F');\n        fileMenu.setText(\"File\");\n        fileMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        newProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        newProjectItem.setMnemonic('N');\n        newProjectItem.setText(\"New Project\");\n        newProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(newProjectItem);\n\n        openProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        openProjectItem.setMnemonic('O');\n        openProjectItem.setText(\"Open Project\");\n        openProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                openProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(openProjectItem);\n\n        saveProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        saveProjectItem.setMnemonic('S');\n        saveProjectItem.setText(\"Save project\");\n        saveProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(saveProjectItem);\n\n        closeProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        closeProjectItem.setMnemonic('C');\n        closeProjectItem.setText(\"Close Project\");\n        fileMenu.add(closeProjectItem);\n\n        fileMenu.add(jSeparator3);\n\n        exitItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        exitItem.setMnemonic('X');\n        exitItem.setText(\"Exit\");\n        exitItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                exitItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(exitItem);\n\n        theMenuBar.add(fileMenu);\n\n        viewMenu.setMnemonic('V');\n        viewMenu.setText(\"View\");\n        viewMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        viewConsoleItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        viewConsoleItem.setMnemonic('C');\n        viewConsoleItem.setText(\"Console\");\n        viewConsoleItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                viewConsoleItemActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(viewConsoleItem);\n\n        viewBugDetailsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        viewBugDetailsItem.setMnemonic('D');\n        viewBugDetailsItem.setSelected(true);\n        viewBugDetailsItem.setText(\"Bug Details\");\n        viewBugDetailsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                viewBugDetailsItemActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(viewBugDetailsItem);\n\n        fullDescriptionsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        fullDescriptionsItem.setMnemonic('F');\n        fullDescriptionsItem.setText(\"Full Descriptions\");\n        fullDescriptionsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                fullDescriptionsItemActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(fullDescriptionsItem);\n\n        theMenuBar.add(viewMenu);\n\n        helpMenu.setMnemonic('H');\n        helpMenu.setText(\"Help\");\n        helpMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        aboutItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        aboutItem.setMnemonic('A');\n        aboutItem.setText(\"About\");\n        aboutItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                aboutItemActionPerformed(evt);\n            }\n        });\n\n        helpMenu.add(aboutItem);\n\n        theMenuBar.add(helpMenu);\n\n        setJMenuBar(theMenuBar);\n\n        pack();\n    }","commit_id":"66a16f7f1ca64e265fff738366574cb35dd3be24","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public ActionsTree() {\n    myRoot = new DefaultMutableTreeNode(ROOT);\n\n    myTree = new Tree(new MyModel(myRoot));\n    myTree.setCellRenderer(new ColoredTreeCellRenderer(){\n      public void customizeCellRenderer(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {\n        Keymap originalKeymap = myKeymap != null ? myKeymap.getParent() : null;\n        Icon icon = null;\n        String text;\n        boolean bound = false;\n        if (value instanceof DefaultMutableTreeNode) {\n          Object userObject = ((DefaultMutableTreeNode)value).getUserObject();\n          boolean changed;\n          if (userObject instanceof Group) {\n            Group group = (Group)userObject;\n            text = group.getName();\n\n            changed = originalKeymap != null && isGroupChanged(group, originalKeymap, myKeymap);\n            icon = expanded ? group.getOpenIcon() : group.getIcon();\n            if (icon == null){\n              icon = expanded ? OPEN_ICON : CLOSE_ICON;\n            }\n          }\n          else if (userObject instanceof String) {\n            String actionId = (String)userObject;\n            bound = myShowBoundActions && ((KeymapImpl)myKeymap).isActionBound(actionId);\n            AnAction action = ActionManager.getInstance().getActionOrStub(actionId);\n            if (action != null) {\n              text = action.getTemplatePresentation().getText();\n              if (text == null || text.length() == 0) { //fill dynamic presentation gaps \n                text = actionId;\n              }\n              Icon actionIcon = action.getTemplatePresentation().getIcon();\n              if (actionIcon != null) {\n                icon = actionIcon;\n              }\n            }\n            else {\n              text = actionId;\n            }\n            changed = originalKeymap != null && isActionChanged(actionId, originalKeymap, myKeymap);\n          }\n          else if (userObject instanceof QuickList) {\n            QuickList list = (QuickList)userObject;\n            icon = QUICK_LIST_ICON;\n            text = list.getDisplayName();\n\n            changed = originalKeymap != null && isActionChanged(list.getActionId(), originalKeymap, myKeymap);\n          }\n          else if (userObject instanceof Separator) {\n            // TODO[vova,anton]: beautify\n            changed = false;\n            text = \"-------------\";\n          }\n          else {\n            throw new IllegalArgumentException(\"unknown userObject: \" + userObject);\n          }\n\n          setIcon(ActionsTree.getEvenIcon(icon));\n\n          Color foreground;\n          if (selected && hasFocus) {\n            foreground = UIUtil.getTreeSelectionForeground();\n          }\n          else {\n            if (changed) {\n              foreground = Color.BLUE;\n            }\n            else {\n              foreground = UIUtil.getTreeForeground();\n            }\n\n            if (bound) {\n              foreground = Color.MAGENTA;\n            }\n          }\n          SearchUtil.appendFragments(myFilter, text, Font.PLAIN, foreground, selected ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeTextBackground(), this);\n        }\n      }\n    });\n\n    myTree.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n    myComponent = ScrollPaneFactory.createScrollPane(myTree);\n  }","id":25331,"modified_method":"public ActionsTree() {\n    myRoot = new DefaultMutableTreeNode(ROOT);\n\n    myTree = new Tree(new MyModel(myRoot));\n    myTree.setCellRenderer(new ColoredTreeCellRenderer(){\n      public void customizeCellRenderer(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {\n        Keymap originalKeymap = myKeymap != null ? myKeymap.getParent() : null;\n        Icon icon = null;\n        String text;\n        boolean bound = false;\n        if (value instanceof DefaultMutableTreeNode) {\n          Object userObject = ((DefaultMutableTreeNode)value).getUserObject();\n          boolean changed;\n          if (userObject instanceof Group) {\n            Group group = (Group)userObject;\n            text = group.getName();\n\n            changed = originalKeymap != null && isGroupChanged(group, originalKeymap, myKeymap);\n            icon = expanded ? group.getOpenIcon() : group.getIcon();\n            if (icon == null){\n              icon = expanded ? OPEN_ICON : CLOSE_ICON;\n            }\n          }\n          else if (userObject instanceof String) {\n            String actionId = (String)userObject;\n            bound = myShowBoundActions && ((KeymapImpl)myKeymap).isActionBound(actionId);\n            AnAction action = ActionManager.getInstance().getActionOrStub(actionId);\n            if (action != null) {\n              text = action.getTemplatePresentation().getText();\n              if (text == null || text.length() == 0) { //fill dynamic presentation gaps \n                text = actionId;\n              }\n              Icon actionIcon = action.getTemplatePresentation().getIcon();\n              if (actionIcon != null) {\n                icon = actionIcon;\n              }\n            }\n            else {\n              text = actionId;\n            }\n            changed = originalKeymap != null && isActionChanged(actionId, originalKeymap, myKeymap);\n          }\n          else if (userObject instanceof QuickList) {\n            QuickList list = (QuickList)userObject;\n            icon = QUICK_LIST_ICON;\n            text = list.getDisplayName();\n\n            changed = originalKeymap != null && isActionChanged(list.getActionId(), originalKeymap, myKeymap);\n          }\n          else if (userObject instanceof Separator) {\n            // TODO[vova,anton]: beautify\n            changed = false;\n            text = \"-------------\";\n          }\n          else {\n            throw new IllegalArgumentException(\"unknown userObject: \" + userObject);\n          }\n\n          setIcon(ActionsTree.getEvenIcon(icon));\n\n          Color foreground;\n          if (selected && hasFocus) {\n            foreground = UIUtil.getTreeSelectionForeground();\n          }\n          else {\n            if (changed) {\n              foreground = Color.BLUE;\n            }\n            else {\n              foreground = UIUtil.getTreeForeground();\n            }\n\n            if (bound) {\n              foreground = Color.MAGENTA;\n            }\n          }\n          SearchUtil.appendFragments(myFilter, text, Font.PLAIN, foreground, selected ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeTextBackground(), this);\n        }\n      }\n    });\n\n    myTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n\n    myComponent = ScrollPaneFactory.createScrollPane(myTree);\n  }","commit_id":"1353a943a340a29e09634d335462374a09367ed4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initComponents(Project project, String initialText, boolean classMode) {\n    myTabbedPane = new JTabbedPane(JTabbedPane.TOP);\n    myTabbedPane.setFocusable(false);\n\n    MavenArtifactSearchPanel.Listener l = new MavenArtifactSearchPanel.Listener() {\n      public void itemSelected() {\n        clickDefaultButton();\n      }\n\n      public void canSelectStateChanged(MavenArtifactSearchPanel from, boolean canSelect) {\n        myOkButtonStates.put(from, canSelect);\n        updateOkButtonState();\n      }\n    };\n\n    myArtifactsPanel = new MavenArtifactSearchPanel(project, !classMode ? initialText : \"\", false, l,getDisposable());\n    myClassesPanel = new MavenArtifactSearchPanel(project, classMode ? initialText : \"\", true, l,getDisposable());\n\n    myTabbedPane.addTab(\"Search for artifact\", myArtifactsPanel);\n    myTabbedPane.addTab(\"Search for class\", myClassesPanel);\n    myTabbedPane.setSelectedIndex(classMode ? 1 : 0);\n\n    myTabbedPane.setMnemonicAt(0, KeyEvent.VK_A);\n    myTabbedPane.setDisplayedMnemonicIndexAt(0, myTabbedPane.getTitleAt(0).indexOf(\"artifact\"));\n    myTabbedPane.setMnemonicAt(1, KeyEvent.VK_C);\n    myTabbedPane.setDisplayedMnemonicIndexAt(1, myTabbedPane.getTitleAt(1).indexOf(\"class\"));\n\n    myTabbedPane.setPreferredSize(new Dimension(600, 400));\n\n    myTabbedPane.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        updateOkButtonState();\n      }\n    });\n\n    updateOkButtonState();\n  }","id":25332,"modified_method":"private void initComponents(Project project, String initialText, boolean classMode) {\n    myTabbedPane = new JTabbedPane(JTabbedPane.TOP);\n    myTabbedPane.setFocusable(false);\n\n    MavenArtifactSearchPanel.Listener listener = new MavenArtifactSearchPanel.Listener() {\n      public void itemSelected() {\n        clickDefaultButton();\n      }\n\n      public void canSelectStateChanged(MavenArtifactSearchPanel from, boolean canSelect) {\n        myOkButtonStates.put(from, canSelect);\n        updateOkButtonState();\n      }\n    };\n\n    myArtifactsPanel = new MavenArtifactSearchPanel(project, !classMode ? initialText : \"\", false, listener, this);\n    myClassesPanel = new MavenArtifactSearchPanel(project, classMode ? initialText : \"\", true, listener, this);\n\n    myTabbedPane.addTab(\"Search for artifact\", myArtifactsPanel);\n    myTabbedPane.addTab(\"Search for class\", myClassesPanel);\n    myTabbedPane.setSelectedIndex(classMode ? 1 : 0);\n\n    myTabbedPane.setMnemonicAt(0, KeyEvent.VK_A);\n    myTabbedPane.setDisplayedMnemonicIndexAt(0, myTabbedPane.getTitleAt(0).indexOf(\"artifact\"));\n    myTabbedPane.setMnemonicAt(1, KeyEvent.VK_C);\n    myTabbedPane.setDisplayedMnemonicIndexAt(1, myTabbedPane.getTitleAt(1).indexOf(\"class\"));\n\n    myTabbedPane.setPreferredSize(new Dimension(900, 600));\n\n    myTabbedPane.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        updateOkButtonState();\n      }\n    });\n\n    updateOkButtonState();\n  }","commit_id":"1353a943a340a29e09634d335462374a09367ed4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void formatSearchResult(JTree tree, MavenArtifactSearchResult searchResult) {\n      MavenClassSearchResult classResult = (MavenClassSearchResult)searchResult;\n      MavenArtifactInfo info = searchResult.versions.get(0);\n\n      myLeftComponent.append(classResult.className, SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      myLeftComponent.append(\" (\" + classResult.packageName + \")\", SimpleTextAttributes.GRAY_ATTRIBUTES);\n\n      myRightComponent.append(\" \" + info.getGroupId() + \":\" + info.getArtifactId(),\n                              SimpleTextAttributes.GRAY_ATTRIBUTES);\n    }","id":25333,"modified_method":"@Override\n    protected void formatSearchResult(JTree tree, MavenArtifactSearchResult searchResult, boolean selected) {\n      MavenClassSearchResult classResult = (MavenClassSearchResult)searchResult;\n      MavenArtifactInfo info = searchResult.versions.get(0);\n\n      myLeftComponent.setIcon(CLASS_ICON);\n      myLeftComponent.append(classResult.className, SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      myLeftComponent.append(\" (\" + classResult.packageName + \")\", getGrayAttributes(selected));\n\n      myRightComponent.append(info.getGroupId() + \":\", getGrayAttributes(selected));\n      myRightComponent.append(info.getArtifactId(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      myRightComponent.append(\":\" + info.getVersion(), getGrayAttributes(selected));\n    }","commit_id":"1353a943a340a29e09634d335462374a09367ed4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isLeaf(Object node) {\n      return getList(node) == null;\n    }","id":25334,"modified_method":"public boolean isLeaf(Object node) {\n      return node != myItems && (getList(node) == null || getChildCount(node) < 2);\n    }","commit_id":"1353a943a340a29e09634d335462374a09367ed4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row,\n                                                  boolean hasFocus) {\n      myLeftComponent.clear();\n      myRightComponent.clear();\n\n      if (UIUtil.isUnderQuaquaLookAndFeel()) {\n        setBackground(selected ? UIUtil.getTreeSelectionBackground() : null);\n      }\n      else {\n        if (selected) {\n          setBackground(UIUtil.getTreeSelectionBackground());\n          setForeground(UIUtil.getTreeSelectionForeground());\n        }\n        else {\n          setBackground(null);\n          setForeground(tree.getForeground());\n        }\n      }\n\n      if (getFont() == null) setFont(tree.getFont());\n\n      if (value == tree.getModel().getRoot()) {\n        myLeftComponent.append(\"Results\", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      }\n      else if (value instanceof MavenArtifactSearchResult) {\n        formatSearchResult(tree, (MavenArtifactSearchResult)value);\n      }\n      else if (value instanceof MavenArtifactInfo) {\n        MavenArtifactInfo info = (MavenArtifactInfo)value;\n        myLeftComponent.append(info.getGroupId() + \":\" + info.getArtifactId() + \":\" + info.getVersion(),\n                               SimpleTextAttributes.GRAY_ATTRIBUTES);\n      }\n\n      removeAll();\n      add(myLeftComponent, BorderLayout.WEST);\n      JPanel spacer = new JPanel();\n      spacer.setBorder(BorderFactory.createEmptyBorder(0, 2, 0, 2));\n      spacer.setBackground(selected ? UIUtil.getTreeSelectionBackground() : tree.getBackground());\n      add(spacer, BorderLayout.CENTER);\n      add(myRightComponent, BorderLayout.EAST);\n      return this;\n    }","id":25335,"modified_method":"public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row,\n                                                  boolean hasFocus) {\n      myLeftComponent.clear();\n      myRightComponent.clear();\n\n      setBackground(selected ? UIUtil.getTreeSelectionBackground() : tree.getBackground());\n\n      myLeftComponent.setForeground(selected ? UIUtil.getTreeSelectionForeground() : null);\n      myRightComponent.setForeground(selected ? UIUtil.getTreeSelectionForeground() : null);\n\n      if (value == tree.getModel().getRoot()) {\n        myLeftComponent.append(\"Results\", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      }\n      else if (value instanceof MavenArtifactSearchResult) {\n        formatSearchResult(tree, (MavenArtifactSearchResult)value, selected);\n      }\n      else if (value instanceof MavenArtifactInfo) {\n        MavenArtifactInfo info = (MavenArtifactInfo)value;\n        myLeftComponent.append(info.getVersion(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      }\n\n      return this;\n    }","commit_id":"1353a943a340a29e09634d335462374a09367ed4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doSearch(String searchText) {\n    MavenSearcher searcher = myClassMode ? new MavenClassSearcher() : new MavenArtifactSearcher();\n    List<MavenArtifactSearchResult> result = searcher.search(myProject, searchText, 200);\n    final TreeModel model = new MyTreeModel(result);\n\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        if (!myResultList.isShowing()) return;\n        myResultList.getEmptyText().setText(\"No results\");\n        myResultList.setModel(model);\n        myResultList.setSelectionRow(0);\n        myResultList.setPaintBusy(false);\n      }\n    });\n  }","id":25336,"modified_method":"private void doSearch(String searchText) {\n    MavenSearcher searcher = myClassMode ? new MavenClassSearcher() : new MavenArtifactSearcher();\n    List<MavenArtifactSearchResult> result = searcher.search(myProject, searchText, 200);\n    final TreeModel model = new MyTreeModel(result);\n\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        if (!myDialog.isVisible()) return;\n\n        myResultList.getEmptyText().setText(\"No results\");\n        myResultList.setModel(model);\n        myResultList.setSelectionRow(0);\n        myResultList.setPaintBusy(false);\n      }\n    });\n  }","commit_id":"1353a943a340a29e09634d335462374a09367ed4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initComponents(String initialText) {\n    mySearchField = new JTextField(initialText);\n    myResultList = new Tree();\n    myResultList.getEmptyText().setText(\"Loading...\");\n\n    setLayout(new BorderLayout());\n    add(mySearchField, BorderLayout.NORTH);\n    add(ScrollPaneFactory.createScrollPane(myResultList), BorderLayout.CENTER);\n\n    mySearchField.getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        scheduleSearch();\n      }\n    });\n\n    myResultList.addTreeSelectionListener(new TreeSelectionListener() {\n      public void valueChanged(TreeSelectionEvent e) {\n        if (myAlarm.getActiveRequestCount() > 0) return;\n\n        boolean hasSelection = !myResultList.isSelectionEmpty();\n        myListener.canSelectStateChanged(MavenArtifactSearchPanel.this, hasSelection);\n      }\n    });\n\n    myResultList.addKeyListener(new KeyAdapter() {\n      @Override\n      public void keyPressed(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_ENTER && myResultList.getLastSelectedPathComponent() != null) {\n          myListener.itemSelected();\n          e.consume();\n        }\n      }\n    });\n\n    myResultList.setRootVisible(false);\n    myResultList.setShowsRootHandles(true);\n    myResultList.setModel(null);\n    myResultList.setCellRenderer(myClassMode ? new MyClassCellRenderer() : new MyArtifactCellRenderer());\n\n    myResultList.addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        if (e.getClickCount() == 2) {\n          Object sel = myResultList.getLastSelectedPathComponent();\n          if (sel != null && myResultList.getModel().isLeaf(sel)) {\n            myListener.itemSelected();\n            e.consume();\n          }\n        }\n      }\n    });\n  }","id":25337,"modified_method":"private void initComponents(String initialText) {\n    mySearchField = new JTextField(initialText);\n    myResultList = new Tree();\n    myResultList.getExpandableItemsHandler().setEnabled(false);\n    myResultList.getEmptyText().setText(\"Loading...\");\n    myResultList.setRootVisible(false);\n    myResultList.setShowsRootHandles(true);\n    myResultList.setModel(null);\n    myResultList.setCellRenderer(myClassMode ? new MyClassCellRenderer(myResultList)\n                                             : new MyArtifactCellRenderer(myResultList));\n    myResultList.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n\n    setLayout(new BorderLayout());\n    add(mySearchField, BorderLayout.NORTH);\n    JScrollPane pane = ScrollPaneFactory.createScrollPane(myResultList);\n    pane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n    add(pane, BorderLayout.CENTER);\n\n    mySearchField.getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        scheduleSearch();\n      }\n    });\n\n    myResultList.addTreeSelectionListener(new TreeSelectionListener() {\n      public void valueChanged(TreeSelectionEvent e) {\n        if (myAlarm.getActiveRequestCount() > 0) return;\n\n        boolean hasSelection = !myResultList.isSelectionEmpty();\n        myListener.canSelectStateChanged(MavenArtifactSearchPanel.this, hasSelection);\n      }\n    });\n\n    myResultList.addKeyListener(new KeyAdapter() {\n      @Override\n      public void keyPressed(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_ENTER && myResultList.getLastSelectedPathComponent() != null) {\n          myListener.itemSelected();\n          e.consume();\n        }\n      }\n    });\n\n    myResultList.addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        if (e.getClickCount() == 2) {\n          Object sel = myResultList.getLastSelectedPathComponent();\n          if (sel != null && myResultList.getModel().isLeaf(sel)) {\n            myListener.itemSelected();\n            e.consume();\n          }\n        }\n      }\n    });\n  }","commit_id":"1353a943a340a29e09634d335462374a09367ed4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void formatSearchResult(JTree tree, MavenArtifactSearchResult searchResult) {\n      MavenArtifactInfo first = searchResult.versions.get(0);\n      MavenArtifactInfo last = searchResult.versions.get(searchResult.versions.size() - 1);\n      myLeftComponent.append(first.getGroupId() + \":\" + first.getArtifactId(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      myLeftComponent.append(\":\" + last.getVersion() + \"-\" + first.getVersion(), SimpleTextAttributes.GRAY_ATTRIBUTES);\n    }","id":25338,"modified_method":"protected void formatSearchResult(JTree tree, MavenArtifactSearchResult searchResult, boolean selected) {\n      MavenArtifactInfo info = searchResult.versions.get(0);\n      myLeftComponent.setIcon(MavenIcons.DEPENDENCY_ICON);\n      myLeftComponent.append(info.getGroupId() + \":\", getGrayAttributes(selected));\n      myLeftComponent.append(info.getArtifactId(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      myLeftComponent.append(\":\" + info.getVersion(), getGrayAttributes(selected));\n    }","commit_id":"1353a943a340a29e09634d335462374a09367ed4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private MyArtifactCellRenderer() {\n      setLayout(new BorderLayout());\n    }","id":25339,"modified_method":"private MyArtifactCellRenderer(final Tree tree) {\n      myLeftComponent.setOpaque(false);\n      myRightComponent.setOpaque(false);\n      myLeftComponent.setIconOpaque(false);\n      myRightComponent.setIconOpaque(false);\n      add(myLeftComponent);\n      add(myRightComponent);\n\n      Font font = EditorColorsManager.getInstance().getGlobalScheme().getFont(EditorFontType.PLAIN);\n      myLeftComponent.setFont(font);\n      myRightComponent.setFont(font);\n\n      setPreferredSize(new Dimension(2000, myLeftComponent.getPreferredSize().height));\n\n      setLayout(new AbstractLayoutManager() {\n        @Override\n        public Dimension preferredLayoutSize(Container parent) {\n          return new Dimension(getVisibleWidth(), myLeftComponent.getPreferredSize().height);\n        }\n\n        @Override\n        public void layoutContainer(Container parent) {\n          int w = getVisibleWidth();\n\n          Dimension ls = myLeftComponent.getPreferredSize();\n          Dimension rs = myRightComponent.getPreferredSize();\n\n          int lw = w - rs.width - 10;\n          int rw = rs.width;\n\n          myLeftComponent.setBounds(0, 0, lw, ls.height);\n          myRightComponent.setBounds(w - rw, 0, rw, rs.height);\n        }\n\n        private int getVisibleWidth() {\n          int w = tree.getVisibleRect().width - 10;\n          Insets insets = tree.getInsets();\n          w -= insets.left + insets.right;\n\n          Container parent = tree.getParent();\n          if (parent != null) {\n            Container parentParent = parent.getParent();\n            if (parentParent instanceof JScrollPane) {\n              JScrollBar sb = ((JScrollPane)parentParent).getVerticalScrollBar();\n              if (sb != null) {\n                w -= sb.getWidth();\n              }\n            }\n          }\n          return w;\n        }\n      });\n    }","commit_id":"1353a943a340a29e09634d335462374a09367ed4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MavenArtifactSearchPanel(Project project, String initialText, boolean classMode, Listener listener, Disposable parent) {\n    myProject = project;\n    myClassMode = classMode;\n    myListener = listener;\n\n    initComponents(initialText);\n    myAlarm = new Alarm(Alarm.ThreadToUse.OWN_THREAD, parent);\n  }","id":25340,"modified_method":"public MavenArtifactSearchPanel(Project project,\n                                  String initialText,\n                                  boolean classMode,\n                                  Listener listener,\n                                  MavenArtifactSearchDialog dialog) {\n    myProject = project;\n    myDialog = dialog;\n    myClassMode = classMode;\n    myListener = listener;\n\n    initComponents(initialText);\n    myAlarm = new Alarm(Alarm.ThreadToUse.OWN_THREAD, dialog.getDisposable());\n  }","commit_id":"1353a943a340a29e09634d335462374a09367ed4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initComponents() {\n    myArchetypesTree = new Tree();\n    myArchetypesTree.setModel(new DefaultTreeModel(new DefaultMutableTreeNode()));\n    myArchetypesScrollPane = ScrollPaneFactory.createScrollPane(myArchetypesTree);\n\n    myLoadingIcon.setVisible(false);\n\n    myArchetypesPanel.setLayout(new MyLayout());\n    myArchetypesPanel.add(myArchetypesScrollPane);\n    myArchetypesPanel.add(myLoadingIcon);\n\n    mySelectAggregator.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        myAggregator = doSelectProject(myAggregator);\n        updateComponents();\n      }\n    });\n\n    mySelectParent.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        myParent = doSelectProject(myParent);\n        updateComponents();\n      }\n    });\n\n    ActionListener updatingListener = new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        updateComponents();\n      }\n    };\n    myInheritGroupIdCheckBox.addActionListener(updatingListener);\n    myInheritVersionCheckBox.addActionListener(updatingListener);\n\n    myUseArchetypeCheckBox.addActionListener(updatingListener);\n    myArchetypesTree.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n    myAddArchetypeButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        doAddArchetype();\n      }\n    });\n\n    myArchetypesTree.setRootVisible(false);\n    myArchetypesTree.setShowsRootHandles(true);\n    myArchetypesTree.setCellRenderer(new MyRenderer());\n    myArchetypesTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n\n    myArchetypesTree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener() {\n      public void valueChanged(TreeSelectionEvent e) {\n        updateArchetypeDescription();\n      }\n    });\n\n    new TreeSpeedSearch(myArchetypesTree, new Convertor<TreePath, String>() {\n      public String convert(TreePath path) {\n        MavenArchetype info = getArchetypeInfoFromPathComponent(path.getLastPathComponent());\n        return info.groupId + \":\" + info.artifactId + \":\" + info.version;\n      }\n    }).setComparator(new SpeedSearchBase.SpeedSearchComparator(false) {\n      @Override\n      public void translateCharacter(StringBuilder buf, char ch) {\n        if (ch == '*') {\n          buf.append(\"(.)*\");\n        }\n        else {\n          super.translateCharacter(buf, ch);\n        }\n      }\n    });\n\n    myArchetypeDescriptionField.setEditable(false);\n    myArchetypeDescriptionField.setBackground(UIUtil.getPanelBackground());\n  }","id":25341,"modified_method":"private void initComponents() {\n    myArchetypesTree = new Tree();\n    myArchetypesTree.setModel(new DefaultTreeModel(new DefaultMutableTreeNode()));\n    myArchetypesScrollPane = ScrollPaneFactory.createScrollPane(myArchetypesTree);\n\n    myLoadingIcon.setVisible(false);\n\n    myArchetypesPanel.setLayout(new MyLayout());\n    myArchetypesPanel.add(myArchetypesScrollPane);\n    myArchetypesPanel.add(myLoadingIcon);\n\n    mySelectAggregator.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        myAggregator = doSelectProject(myAggregator);\n        updateComponents();\n      }\n    });\n\n    mySelectParent.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        myParent = doSelectProject(myParent);\n        updateComponents();\n      }\n    });\n\n    ActionListener updatingListener = new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        updateComponents();\n      }\n    };\n    myInheritGroupIdCheckBox.addActionListener(updatingListener);\n    myInheritVersionCheckBox.addActionListener(updatingListener);\n\n    myUseArchetypeCheckBox.addActionListener(updatingListener);\n    myArchetypesTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n\n    myAddArchetypeButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        doAddArchetype();\n      }\n    });\n\n    myArchetypesTree.setRootVisible(false);\n    myArchetypesTree.setShowsRootHandles(true);\n    myArchetypesTree.setCellRenderer(new MyRenderer());\n    myArchetypesTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n\n    myArchetypesTree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener() {\n      public void valueChanged(TreeSelectionEvent e) {\n        updateArchetypeDescription();\n      }\n    });\n\n    new TreeSpeedSearch(myArchetypesTree, new Convertor<TreePath, String>() {\n      public String convert(TreePath path) {\n        MavenArchetype info = getArchetypeInfoFromPathComponent(path.getLastPathComponent());\n        return info.groupId + \":\" + info.artifactId + \":\" + info.version;\n      }\n    }).setComparator(new SpeedSearchBase.SpeedSearchComparator(false) {\n      @Override\n      public void translateCharacter(StringBuilder buf, char ch) {\n        if (ch == '*') {\n          buf.append(\"(.)*\");\n        }\n        else {\n          super.translateCharacter(buf, ch);\n        }\n      }\n    });\n\n    myArchetypeDescriptionField.setEditable(false);\n    myArchetypeDescriptionField.setBackground(UIUtil.getPanelBackground());\n  }","commit_id":"1353a943a340a29e09634d335462374a09367ed4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** Creates a new instance of HierarchyTreeWindow */\n    public FavoritesWindow(String displayName ) {\n        setLayout(new BorderLayout());\n        \n        \n        favoritesPane = new JTabbedPane();\n        \n        \n        File f  = new File(VueUtil.getDefaultUserFolder().getAbsolutePath()+File.separatorChar+ displayName+VueResources.getString(\"save.favorites\"));\n       \n        //System.out.println(\"I tried to open\" + f);\n     \n            try {\n            SaveVueJTree restorefavtree = unMarshallMap(f);\n            fileOpen = true;\n              favoritesTree =restorefavtree.restoreTree();\n            favoritesTree.setRootVisible(true);\n            favoritesTree.expandRow(0);\n            favoritesTree.setRootVisible(false);\n            \n            this.setFavoritesTree(favoritesTree);\n            }catch (Exception ex){\n               // System.out.println(\"I tried to open\" + f);\n                fileOpen = false;\n               \n            }\n            \n           if (!fileOpen){\n            //  System.out.println(\"Afte Unmarshalling \"+restorefavtree.getClass().getName()+ \" root\"+ restorefavtree.getSaveTreeRoot().getResourceName());\n          \n    \n            MapResource favResource = new MapResource(displayName);\n            favResource.setType(DataSource.FAVORITES);\n            \n            \n            FavoritesNode favRoot= new FavoritesNode(favResource);\n           \n            favoritesTree = new VueDandDTree(favRoot);\n            \n            favoritesTree.setRootVisible(true);\n            favoritesTree.expandRow(0);\n            favoritesTree.setRootVisible(false);\n            this.setFavoritesTree(favoritesTree);\n            \n         }\n        \n        \n        searchResultsPane = new JPanel();\n        JPanel favSearchPanel = createfavSearchPanel(favoritesTree,favoritesPane,searchResultsPane,displayName);\n        \n        favoritesPane.addTab(\"Search\",favSearchPanel);\n        favoritesPane.addTab(\"Search Results\",searchResultsPane);\n        browsePane = new JScrollPane(favoritesTree);\n        favoritesPane.add(\"Browse\", browsePane);\n        createPopupMenu();\n        favoritesPane.setSelectedIndex(2);\n        \n        add(favoritesPane,BorderLayout.CENTER);\n        \n    }","id":25342,"modified_method":"/** Creates a new instance of HierarchyTreeWindow */\n    public FavoritesWindow(String displayName ) {\n        setLayout(new BorderLayout());\n        \n        \n        favoritesPane = new JTabbedPane();\n        \n        \n        File f  = new File(VueUtil.getDefaultUserFolder().getAbsolutePath()+File.separatorChar+ displayName+VueResources.getString(\"save.favorites\"));\n       \n        //System.out.println(\"I tried to open\" + f);\n     \n            try {\n            SaveVueJTree restorefavtree = unMarshallMap(f);\n            fileOpen = true;\n              favoritesTree =restorefavtree.restoreTree();\n            favoritesTree.setRootVisible(true);\n            favoritesTree.expandRow(0);\n            favoritesTree.setRootVisible(false);\n            \n            this.setFavoritesTree(favoritesTree);\n            }catch (Exception ex){\n               // System.out.println(\"I tried to open\" + f);\n                fileOpen = false;\n               \n            }\n            \n           if (!fileOpen){\n            //  System.out.println(\"Afte Unmarshalling \"+restorefavtree.getClass().getName()+ \" root\"+ restorefavtree.getSaveTreeRoot().getResourceName());\n          \n    \n            MapResource favResource = new MapResource(displayName);\n            favResource.setType(1);\n            \n            \n            FavoritesNode favRoot= new FavoritesNode(favResource);\n           \n            favoritesTree = new VueDandDTree(favRoot);\n            \n            favoritesTree.setRootVisible(true);\n            favoritesTree.expandRow(0);\n            favoritesTree.setRootVisible(false);\n            this.setFavoritesTree(favoritesTree);\n            \n         }\n        \n        \n        searchResultsPane = new JPanel();\n        searchResultsPane.setLayout(new BorderLayout());\n        JScrollPane jsp = new JScrollPane();\n        searchResultsPane.add(jsp,BorderLayout.CENTER,0);\n        \n        \n        JPanel favSearchPanel = createfavSearchPanel(favoritesTree,favoritesPane,searchResultsPane,displayName);\n        \n        favoritesPane.addTab(\"Search\",favSearchPanel);\n        favoritesPane.addTab(\"Search Results\",searchResultsPane);\n        browsePane = new JScrollPane(favoritesTree);\n        favoritesPane.add(\"Browse\", browsePane);\n        createPopupMenu();\n        favoritesPane.setSelectedIndex(2);\n        \n        add(favoritesPane,BorderLayout.CENTER);\n        \n    }","commit_id":"efa3352bf650b9507935c4aa28e347394a1b5480","url":"https://github.com/VUE/VUE"},{"original_method":"public void performSearch(){\n        int index = 0;\n        \n        JScrollPane jsp = new JScrollPane();\n        \n        String searchString = keywords.getText();\n        VueDragTree serResultTree = new VueDragTree(\"Search\", \"No Hits\");\n        \n        if (!searchString.equals(\"\")){\n            \n            boolean foundit = false;\n            // VueDragTree serResultTree = new VueDragTree(\"Search\", \"Search Results\");\n            DefaultTreeModel serTreeModel = (DefaultTreeModel)serResultTree.getModel();\n            ResourceNode serRoot = (ResourceNode)serTreeModel.getRoot();\n            \n            TreeModel favTreeModel = this.favoritesTree.getModel();\n            ResourceNode favRoot = (ResourceNode)favTreeModel.getRoot();\n            int childCount = favRoot.getChildCount();\n            \n            \n            if (childCount > 0){\n                \n                for (int outi = 0; outi < childCount ; ++outi){\n                    \n                    if (favRoot.getChildAt(outi) instanceof FileNode){\n                        FileNode childNode = (FileNode)favRoot.getChildAt(outi);\n                        childNode.explore();\n                    }\n                    \n                    \n                    ResourceNode childNode = (ResourceNode)favRoot.getChildAt(outi);\n                    \n                    foundit = compareNode(searchString,childNode,serRoot,false);\n                  //  System.out.println(\"And here \"+ childNode.toString()+foundit);\n                    \n                }\n                \n            }\n            \n            \n            \n            \n            \n      \n            serResultTree.expandRow(0);\n           \n            serResultTree.setRootVisible(false);\n            serResultTree.setShowsRootHandles(true);\n           \n            \n            JScrollPane fPane = new JScrollPane(serResultTree);\n            \n            this.searchResultsPane.setLayout(new BorderLayout());\n            this.searchResultsPane.add(fPane,BorderLayout.NORTH,index);\n            index = index + 1;\n            \n            this.favoritesPane.setSelectedIndex(1);\n            \n            \n        }\n        \n        \n    }","id":25343,"modified_method":"public void performSearch(){\n        int index = 0;\n        \n        JScrollPane jsp = new JScrollPane();\n        \n        String searchString = keywords.getText();\n        VueDragTree serResultTree = new VueDragTree(\"Search\", \"No Hits\");\n        \n        if (!searchString.equals(\"\")){\n            \n            boolean foundit = false;\n            // VueDragTree serResultTree = new VueDragTree(\"Search\", \"Search Results\");\n            DefaultTreeModel serTreeModel = (DefaultTreeModel)serResultTree.getModel();\n            ResourceNode serRoot = (ResourceNode)serTreeModel.getRoot();\n            \n            TreeModel favTreeModel = this.favoritesTree.getModel();\n            ResourceNode favRoot = (ResourceNode)favTreeModel.getRoot();\n            int childCount = favRoot.getChildCount();\n            \n            \n            if (childCount > 0){\n                \n                for (int outi = 0; outi < childCount ; ++outi){\n                    \n                    if (favRoot.getChildAt(outi) instanceof FileNode){\n                        FileNode childNode = (FileNode)favRoot.getChildAt(outi);\n                        childNode.explore();\n                    }\n                    \n                    \n                    ResourceNode childNode = (ResourceNode)favRoot.getChildAt(outi);\n                    \n                    foundit = compareNode(searchString,childNode,serRoot,false);\n                //  System.out.println(\"And here \"+ childNode.toString()+foundit);\n                    \n                }\n                \n            }\n            \n            \n            \n            \n            \n      \n           serResultTree.setRootVisible(true);\n            serResultTree.setShowsRootHandles(true);\n             serResultTree.expandRow(0);\n              serResultTree.setRootVisible(false);\n           \n           \n            \n            JScrollPane fPane = new JScrollPane(serResultTree);\n              \n          \n            \n            //this.searchResultsPane.setLayout(new BorderLayout());\n           this.searchResultsPane.remove(0);\n         \n            this.searchResultsPane.add(fPane,BorderLayout.CENTER,0);\n            this.searchResultsPane.validate();\n          serResultTree.setRootVisible(false);\n           \n            \n            this.favoritesPane.setSelectedIndex(1);\n            \n            \n        }\n        \n        \n    }","commit_id":"efa3352bf650b9507935c4aa28e347394a1b5480","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n    public boolean shouldWait() {\n        boolean shouldWait = firstRun || !getLockStore().canAcquireLock(key, getCallerUuid(), threadId);\n        firstRun = false;\n        return shouldWait;\n    }","id":25344,"modified_method":"@Override\n    public boolean shouldWait() {\n        LockStoreImpl lockStore = getLockStore();\n        boolean canAcquireLock = lockStore.canAcquireLock(key, getCallerUuid(), threadId);\n\n        ConditionKey signalKey = lockStore.getSignalKey(key);\n        if (signalKey != null && conditionId.equals(signalKey.getConditionId()) && canAcquireLock) {\n            return false;\n        }\n\n        boolean shouldWait = firstRun || !canAcquireLock;\n        firstRun = false;\n        return shouldWait;\n    }","commit_id":"80ef4079f75c3eb85c7bf474ac756e14aa62e06b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Test for issue 267\n     */\n    @Test(timeout = 1000 * 100)\n    public void testHighConcurrentLockAndUnlock() {\n        final HazelcastInstance hz = createHazelcastInstance();\n        final String key = \"key\";\n        final int threadCount = 100;\n        final int lockCountPerThread = 5000;\n        final int locks = 50;\n        final CountDownLatch latch = new CountDownLatch(threadCount);\n        final AtomicInteger totalCount = new AtomicInteger();\n\n        class InnerTest implements Runnable {\n            public void run() {\n                boolean live = true;\n                Random rand = new Random();\n                try {\n                    for (int j = 0; j < lockCountPerThread && live; j++) {\n                        final Lock lock = hz.getLock(key + rand.nextInt(locks));\n                        lock.lock();\n                        try {\n                            if (j % 100 == 0) {\n                                System.out.println(Thread.currentThread().getName() + \" is at:\" + j);\n                            }\n                            totalCount.incrementAndGet();\n                            Thread.sleep(1);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                            break;\n                        } finally {\n                            try {\n                                lock.unlock();\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                                live = false;\n                            }\n                        }\n                    }\n                } finally {\n                    latch.countDown();\n                }\n            }\n        }\n\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        for (int i = 0; i < threadCount; i++) {\n            executorService.execute(new InnerTest());\n        }\n\n        try {\n            assertTrue(\"Lock tasks stuck!\", latch.await(2, TimeUnit.MINUTES));\n            assertEquals((threadCount * lockCountPerThread), totalCount.get());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                hz.getLifecycleService().terminate();\n            } catch (Throwable ignored) {\n            }\n            executorService.shutdownNow();\n        }\n    }","id":25345,"modified_method":"/**\n     * Test for issue 267\n     */\n    @Test(timeout = 1000 * 100)\n    public void testHighConcurrentLockAndUnlock() {\n        final HazelcastInstance hz = createHazelcastInstance();\n        final String key = \"key\";\n        final int threadCount = 100;\n        final int lockCountPerThread = 5000;\n        final int locks = 50;\n        final CountDownLatch latch = new CountDownLatch(threadCount);\n        final AtomicInteger totalCount = new AtomicInteger();\n\n        class InnerTest implements Runnable {\n            public void run() {\n                boolean live = true;\n                Random rand = new Random();\n                try {\n                    for (int j = 0; j < lockCountPerThread && live; j++) {\n                        final Lock lock = hz.getLock(key + rand.nextInt(locks));\n                        lock.lock();\n                        try {\n                            totalCount.incrementAndGet();\n                            Thread.sleep(1);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                            break;\n                        } finally {\n                            try {\n                                lock.unlock();\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                                live = false;\n                            }\n                        }\n                    }\n                } finally {\n                    latch.countDown();\n                }\n            }\n        }\n\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        for (int i = 0; i < threadCount; i++) {\n            executorService.execute(new InnerTest());\n        }\n\n        try {\n            assertTrue(\"Lock tasks stuck!\", latch.await(2, TimeUnit.MINUTES));\n            assertEquals((threadCount * lockCountPerThread), totalCount.get());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                hz.getLifecycleService().terminate();\n            } catch (Throwable ignored) {\n            }\n            executorService.shutdownNow();\n        }\n    }","commit_id":"80ef4079f75c3eb85c7bf474ac756e14aa62e06b","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public boolean shouldWait() {\n        final boolean shouldWait = firstRun || !getLockStore().canAcquireLock(key, getCallerUuid(), threadId);\n        firstRun = false;\n        return shouldWait;\n    }","id":25346,"modified_method":"public boolean shouldWait() {\n        LockStoreImpl lockStore = getLockStore();\n        boolean canAcquireLock = lockStore.canAcquireLock(key, getCallerUuid(), threadId);\n\n        ConditionKey signalKey = lockStore.getSignalKey(key);\n        if (signalKey != null && conditionId.equals(signalKey.getConditionId()) && canAcquireLock) {\n            return false;\n        }\n\n        boolean shouldWait = firstRun || !canAcquireLock;\n        firstRun = false;\n        return shouldWait;\n    }","commit_id":"2cfd115e631bb463e8ccfce5e131d6bf1785ac5f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public String getOwnerInfo(Data dataKey) {\n        LockStore lockStore = getLockStore();\n        return lockStore.getOwnerInfo(dataKey);\n    }","id":25347,"modified_method":"@Override\n    public String getOwnerInfo(Data dataKey) {\n        LockStore lockStore = getLockStoreOrNull();\n        if (lockStore == null) {\n            return \"<not-locked>\";\n        }\n        return lockStore.getOwnerInfo(dataKey);\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean extendLeaseTime(Data key, String caller, long threadId, long ttl) {\n        LockStore lockStore = getLockStore();\n        return lockStore.extendLeaseTime(key, caller, threadId, ttl);\n    }","id":25348,"modified_method":"@Override\n    public boolean extendLeaseTime(Data key, String caller, long threadId, long ttl) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.extendLeaseTime(key, caller, threadId, ttl);\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean unlock(Data key, String caller, long threadId) {\n        LockStore lockStore = getLockStore();\n        return lockStore.unlock(key, caller, threadId);\n    }","id":25349,"modified_method":"@Override\n    public boolean unlock(Data key, String caller, long threadId) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.unlock(key, caller, threadId);\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public int getLockCount(Data key) {\n        LockStore lockStore = getLockStore();\n        return lockStore.getLockCount(key);\n    }","id":25350,"modified_method":"@Override\n    public int getLockCount(Data key) {\n        LockStore lockStore = getLockStoreOrNull();\n        if (lockStore == null) {\n            return 0;\n        }\n        return lockStore.getLockCount(key);\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private LockStore getLockStore() {\n        return container.getLockStore(namespace);\n    }","id":25351,"modified_method":"private LockStore getLockStoreOrNull() {\n        return container.getLockStore(namespace);\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean isLocked(Data key) {\n        LockStore lockStore = getLockStore();\n        return lockStore.isLocked(key);\n    }","id":25352,"modified_method":"@Override\n    public boolean isLocked(Data key) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.isLocked(key);\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Set<Data> getLockedKeys() {\n        LockStore lockStore = getLockStore();\n        return lockStore.getLockedKeys();\n    }","id":25353,"modified_method":"@Override\n    public Set<Data> getLockedKeys() {\n        LockStore lockStore = getLockStoreOrNull();\n        if (lockStore == null) {\n            return Collections.emptySet();\n        }\n        return lockStore.getLockedKeys();\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean txnLock(Data key, String caller, long threadId, long ttl) {\n        LockStore lockStore = getLockStore();\n        return lockStore.txnLock(key, caller, threadId, ttl);\n    }","id":25354,"modified_method":"@Override\n    public boolean txnLock(Data key, String caller, long threadId, long ttl) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.txnLock(key, caller, threadId, ttl);\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getRemainingLeaseTime(Data key) {\n        LockStore lockStore = getLockStore();\n        return lockStore.getRemainingLeaseTime(key);\n    }","id":25355,"modified_method":"@Override\n    public long getRemainingLeaseTime(Data key) {\n        LockStore lockStore = getLockStoreOrNull();\n        if (lockStore == null) {\n            return 0;\n        }\n        return lockStore.getRemainingLeaseTime(key);\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean canAcquireLock(Data key, String caller, long threadId) {\n        LockStore lockStore = getLockStore();\n        return lockStore.canAcquireLock(key, caller, threadId);\n    }","id":25356,"modified_method":"@Override\n    public boolean canAcquireLock(Data key, String caller, long threadId) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.canAcquireLock(key, caller, threadId);\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean isLockedBy(Data key, String caller, long threadId) {\n        LockStore lockStore = getLockStore();\n        return lockStore.isLockedBy(key, caller, threadId);\n    }","id":25357,"modified_method":"@Override\n    public boolean isLockedBy(Data key, String caller, long threadId) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.isLockedBy(key, caller, threadId);\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean isTransactionallyLocked(Data key) {\n        LockStore lockStore = getLockStore();\n        return lockStore.isTransactionallyLocked(key);\n    }","id":25358,"modified_method":"@Override\n    public boolean isTransactionallyLocked(Data key) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.isTransactionallyLocked(key);\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean forceUnlock(Data key) {\n        LockStore lockStore = getLockStore();\n        return lockStore.forceUnlock(key);\n    }","id":25359,"modified_method":"@Override\n    public boolean forceUnlock(Data key) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.forceUnlock(key);\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean lock(Data key, String caller, long threadId, long ttl) {\n        LockStore lockStore = getLockStore();\n        return lockStore.lock(key, caller, threadId, ttl);\n    }","id":25360,"modified_method":"@Override\n    public boolean lock(Data key, String caller, long threadId, long ttl) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.lock(key, caller, threadId, ttl);\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void populateMap(IMap map, int numberOfItems) {\n        for (int i = 0; i < numberOfItems; i++) {\n            map.put(i, i);\n        }\n    }","id":25361,"modified_method":"private void populateMap(IMap map, int numberOfItems) {\n        populateMap(map, numberOfItems, 0);\n    }","commit_id":"7eb484332e1770c5f07771b599803256b2bf6c95","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public int getLockCount(Data key) {\n        LockStore lockStore = getLockStore();\n        return lockStore.getLockCount(key);\n    }","id":25362,"modified_method":"@Override\n    public int getLockCount(Data key) {\n        LockStore lockStore = getLockStoreOrNull();\n        if (lockStore == null) {\n            return 0;\n        }\n        return lockStore.getLockCount(key);\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean isLocked(Data key) {\n        LockStore lockStore = getLockStore();\n        return lockStore.isLocked(key);\n    }","id":25363,"modified_method":"@Override\n    public boolean isLocked(Data key) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.isLocked(key);\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean lock(Data key, String caller, long threadId, long ttl) {\n        LockStore lockStore = getLockStore();\n        return lockStore.lock(key, caller, threadId, ttl);\n    }","id":25364,"modified_method":"@Override\n    public boolean lock(Data key, String caller, long threadId, long ttl) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.lock(key, caller, threadId, ttl);\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public String getOwnerInfo(Data dataKey) {\n        LockStore lockStore = getLockStore();\n        return lockStore.getOwnerInfo(dataKey);\n    }","id":25365,"modified_method":"@Override\n    public String getOwnerInfo(Data dataKey) {\n        LockStore lockStore = getLockStoreOrNull();\n        if (lockStore == null) {\n            return \"<not-locked>\";\n        }\n        return lockStore.getOwnerInfo(dataKey);\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Set<Data> getLockedKeys() {\n        LockStore lockStore = getLockStore();\n        return lockStore.getLockedKeys();\n    }","id":25366,"modified_method":"@Override\n    public Set<Data> getLockedKeys() {\n        LockStore lockStore = getLockStoreOrNull();\n        if (lockStore == null) {\n            return Collections.emptySet();\n        }\n        return lockStore.getLockedKeys();\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean forceUnlock(Data key) {\n        LockStore lockStore = getLockStore();\n        return lockStore.forceUnlock(key);\n    }","id":25367,"modified_method":"@Override\n    public boolean forceUnlock(Data key) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.forceUnlock(key);\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean unlock(Data key, String caller, long threadId) {\n        LockStore lockStore = getLockStore();\n        return lockStore.unlock(key, caller, threadId);\n    }","id":25368,"modified_method":"@Override\n    public boolean unlock(Data key, String caller, long threadId) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.unlock(key, caller, threadId);\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private LockStore getLockStore() {\n        return container.getLockStore(namespace);\n    }","id":25369,"modified_method":"private LockStore getLockStoreOrNull() {\n        return container.getLockStore(namespace);\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean isLockedBy(Data key, String caller, long threadId) {\n        LockStore lockStore = getLockStore();\n        return lockStore.isLockedBy(key, caller, threadId);\n    }","id":25370,"modified_method":"@Override\n    public boolean isLockedBy(Data key, String caller, long threadId) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.isLockedBy(key, caller, threadId);\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean canAcquireLock(Data key, String caller, long threadId) {\n        LockStore lockStore = getLockStore();\n        return lockStore.canAcquireLock(key, caller, threadId);\n    }","id":25371,"modified_method":"@Override\n    public boolean canAcquireLock(Data key, String caller, long threadId) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.canAcquireLock(key, caller, threadId);\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean isTransactionallyLocked(Data key) {\n        LockStore lockStore = getLockStore();\n        return lockStore.isTransactionallyLocked(key);\n    }","id":25372,"modified_method":"@Override\n    public boolean isTransactionallyLocked(Data key) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.isTransactionallyLocked(key);\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean txnLock(Data key, String caller, long threadId, long ttl) {\n        LockStore lockStore = getLockStore();\n        return lockStore.txnLock(key, caller, threadId, ttl);\n    }","id":25373,"modified_method":"@Override\n    public boolean txnLock(Data key, String caller, long threadId, long ttl) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.txnLock(key, caller, threadId, ttl);\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getRemainingLeaseTime(Data key) {\n        LockStore lockStore = getLockStore();\n        return lockStore.getRemainingLeaseTime(key);\n    }","id":25374,"modified_method":"@Override\n    public long getRemainingLeaseTime(Data key) {\n        LockStore lockStore = getLockStoreOrNull();\n        if (lockStore == null) {\n            return 0;\n        }\n        return lockStore.getRemainingLeaseTime(key);\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean extendLeaseTime(Data key, String caller, long threadId, long ttl) {\n        LockStore lockStore = getLockStore();\n        return lockStore.extendLeaseTime(key, caller, threadId, ttl);\n    }","id":25375,"modified_method":"@Override\n    public boolean extendLeaseTime(Data key, String caller, long threadId, long ttl) {\n        LockStore lockStore = getLockStoreOrNull();\n        return lockStore != null && lockStore.extendLeaseTime(key, caller, threadId, ttl);\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void populateMap(IMap map, int numberOfItems) {\n        for (int i = 0; i < numberOfItems; i++) {\n            map.put(i, i);\n        }\n    }","id":25376,"modified_method":"private void populateMap(IMap map, int numberOfItems) {\n        populateMap(map, numberOfItems, 0);\n    }","commit_id":"44aab5e9deea57a47bb00890e6b302e6be66c441","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Returns the gallery search result list.<p>\n     *\n     * @param params the gallery search parameters\n     *\n     * @return the gallery search result list\n     */\n    public CmsGallerySearchResultList getResult(CmsGallerySearchParameters params) {\n\n        CmsGallerySearchResultList result = null;\n        if ((m_cms != null) && (m_index != null)) {\n\n            try {\n\n                result = m_index.searchGallery(m_cms, params);\n\n                if (result.size() > 0) {\n\n                    result.calculatePages(params.getResultPage(), params.getMatchesPerPage());\n\n                } else {\n                    result = new CmsGallerySearchResultList();\n                }\n            } catch (Exception exc) {\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(Messages.get().getBundle().key(Messages.LOG_SEARCHING_FAILED_0), exc);\n                }\n\n                m_lastException = exc;\n            }\n        }\n\n        return result;\n    }","id":25377,"modified_method":"/**\n     * Returns the gallery search result list.<p>\n     *\n     * @param params the gallery search parameters\n     *\n     * @return the gallery search result list\n     * \n     * @throws CmsException if the search failed\n     */\n    public CmsGallerySearchResultList getResult(CmsGallerySearchParameters params) throws CmsException {\n\n        CmsGallerySearchResultList result = null;\n        if ((m_cms == null) && (m_index == null)) {\n            throw new CmsException(Messages.get().container(Messages.ERR_SEARCH_NOT_INITIALIZED_0));\n        }\n\n        result = m_index.searchGallery(m_cms, params);\n\n        if (result.size() > 0) {\n\n            result.calculatePages(params.getResultPage(), params.getMatchesPerPage());\n\n        } else {\n            result = new CmsGallerySearchResultList();\n        }\n\n        return result;\n    }","commit_id":"b8c63de5f24abb0dd9683da1fa3051f8259a91d0","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes the bean with the provided OpenCms context object.<p>\n     * \n     * @param cms the OpenCms context to use for the search\n     */\n    public void init(CmsObject cms) {\n\n        m_cms = cms;\n        m_lastException = null;\n    }","id":25378,"modified_method":"/**\n     * Initializes the bean with the provided OpenCms context object.<p>\n     * \n     * @param cms the OpenCms context to use for the search\n     */\n    public void init(CmsObject cms) {\n\n        m_cms = cms;\n    }","commit_id":"b8c63de5f24abb0dd9683da1fa3051f8259a91d0","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Set the name of the index to search.<p>\n     * \n     * A former search result will be deleted.<p>\n     * \n     * @param indexName the name of the index\n     */\n    public void setIndex(String indexName) {\n\n        if (CmsStringUtil.isNotEmpty(indexName)) {\n            try {\n                CmsSearchIndex index = OpenCms.getSearchManager().getIndex(indexName);\n                if (index == null) {\n                    throw new CmsException(Messages.get().container(Messages.ERR_INDEX_NOT_FOUND_1, indexName));\n                }\n                if (!(index instanceof CmsGallerySearchIndex)) {\n                    throw new CmsException(Messages.get().container(\n                        Messages.ERR_INDEX_WRONG_CLASS_2,\n                        indexName,\n                        CmsGallerySearchIndex.class.getName()));\n                }\n                m_index = (CmsGallerySearchIndex)index;\n            } catch (Exception exc) {\n                m_lastException = exc;\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(Messages.get().getBundle().key(Messages.LOG_INDEX_ACCESS_FAILED_1, indexName), exc);\n                }\n            }\n        }\n    }","id":25379,"modified_method":"/**\n     * Set the name of the index to search.<p>\n     * \n     * A former search result will be deleted.<p>\n     * \n     * @param indexName the name of the index\n     * \n     * @throws CmsException if the index was not found or was not an instance of @link {@link org.opencms.search.galleries.CmsGallerySearchIndex}\n     */\n    public void setIndex(String indexName) throws CmsException {\n\n        if (CmsStringUtil.isEmpty(indexName)) {\n            throw new CmsException(Messages.get().container(Messages.ERR_INDEXSOURCE_CREATE_MISSING_NAME_0));\n        }\n        CmsSearchIndex index = OpenCms.getSearchManager().getIndex(indexName);\n        if (index == null) {\n            throw new CmsException(Messages.get().container(Messages.ERR_INDEX_NOT_FOUND_1, indexName));\n        }\n        if (!(index instanceof CmsGallerySearchIndex)) {\n            throw new CmsException(Messages.get().container(\n                Messages.ERR_INDEX_WRONG_CLASS_2,\n                indexName,\n                CmsGallerySearchIndex.class.getName()));\n        }\n        m_index = (CmsGallerySearchIndex)index;\n\n    }","commit_id":"b8c63de5f24abb0dd9683da1fa3051f8259a91d0","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the gallery search object containing the results for the current parameter.<p>\n     * \n     * @param searchObj the current search object \n     * \n     * @return the search result\n     */\n    private CmsGallerySearchBean search(CmsGallerySearchBean searchObj) {\n\n        CmsGallerySearchBean searchObjBean = new CmsGallerySearchBean(searchObj);\n        if (searchObj == null) {\n            return searchObjBean;\n        }\n        // search\n        CmsGallerySearchParameters params = prepareSearchParams(searchObj);\n        org.opencms.search.galleries.CmsGallerySearch searchBean = new org.opencms.search.galleries.CmsGallerySearch();\n        searchBean.init(getCmsObject());\n        searchBean.setIndex(CmsGallerySearchIndex.GALLERY_INDEX_NAME);\n        CmsGallerySearchResultList searchResults = searchBean.getResult(params);\n        // set only the result dependent search params for this search\n        // the user dependent params(galleries, types etc.) remain unchanged\n        searchObjBean.setSortOrder(params.getSortOrder().name());\n        searchObjBean.setScope(params.getScope());\n        searchObjBean.setResultCount(searchResults.getHitCount());\n        searchObjBean.setPage(params.getResultPage());\n        searchObjBean.setResults(buildSearchResultList(searchResults));\n\n        return searchObjBean;\n    }","id":25380,"modified_method":"/**\n     * Returns the gallery search object containing the results for the current parameter.<p>\n     * \n     * @param searchObj the current search object \n     * \n     * @return the search result\n     * \n     * @throws CmsException if the search fails \n     */\n    private CmsGallerySearchBean search(CmsGallerySearchBean searchObj) throws CmsException {\n\n        CmsGallerySearchBean searchObjBean = new CmsGallerySearchBean(searchObj);\n        if (searchObj == null) {\n            return searchObjBean;\n        }\n        // search\n        CmsGallerySearchParameters params = prepareSearchParams(searchObj);\n        org.opencms.search.galleries.CmsGallerySearch searchBean = new org.opencms.search.galleries.CmsGallerySearch();\n        searchBean.init(getCmsObject());\n        searchBean.setIndex(CmsGallerySearchIndex.GALLERY_INDEX_NAME);\n        CmsGallerySearchResultList searchResults = searchBean.getResult(params);\n        // set only the result dependent search params for this search\n        // the user dependent params(galleries, types etc.) remain unchanged\n        searchObjBean.setSortOrder(params.getSortOrder().name());\n        searchObjBean.setScope(params.getScope());\n        searchObjBean.setResultCount(searchResults.getHitCount());\n        searchObjBean.setPage(params.getResultPage());\n        searchObjBean.setResults(buildSearchResultList(searchResults));\n\n        return searchObjBean;\n    }","commit_id":"b8c63de5f24abb0dd9683da1fa3051f8259a91d0","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the search object containing the list with search results and the path to the specified resource.<p>\n     * \n     * @param resourceName the given resource\n     * @param data the gallery data bean \n     * \n     * @return the gallery search object containing the current search parameter and the search result list\n     */\n    private CmsGallerySearchBean findResourceInGallery(String resourceName, CmsGalleryDataBean data) {\n\n        CmsResource resource = null;\n        int pos = resourceName.indexOf(\"?\");\n        String resName = resourceName;\n        if (pos > -1) {\n            resName = resourceName.substring(0, pos);\n        }\n        try {\n            log(\"reading resource: \" + resName);\n            resource = getCmsObject().readResource(resName);\n        } catch (CmsException e) {\n            logError(e);\n            return null;\n        }\n        ArrayList<String> types = new ArrayList<String>();\n        String resType = OpenCms.getResourceManager().getResourceType(resource).getTypeName();\n        types.add(resType);\n        CmsGallerySearchBean initialSearchObj = new CmsGallerySearchBean();\n        initialSearchObj.setTypes(types);\n        ArrayList<String> galleries = new ArrayList<String>();\n        for (CmsGalleryFolderBean gallery : data.getGalleries()) {\n            if (gallery.getPath().equals(CmsResource.getFolderPath(resName))) {\n                galleries.add(gallery.getPath());\n                initialSearchObj.setGalleries(galleries);\n                break;\n            }\n        }\n        if (galleries.isEmpty()) {\n            ArrayList<String> vfsFolders = new ArrayList<String>();\n            vfsFolders.add(CmsResource.getFolderPath(resName));\n            initialSearchObj.setFolders(new HashSet<String>(vfsFolders));\n        }\n        initialSearchObj.setLocale(data.getLocale());\n        CmsGallerySearchBean searchObj = new CmsGallerySearchBean(initialSearchObj);\n        searchObj.setSortOrder(CmsGallerySearchParameters.CmsGallerySortParam.DEFAULT.toString());\n        int currentPage = 1;\n        boolean found = false;\n        searchObj.setPage(currentPage);\n        CmsGallerySearchParameters params = prepareSearchParams(searchObj);\n        org.opencms.search.galleries.CmsGallerySearch searchBean = new org.opencms.search.galleries.CmsGallerySearch();\n        searchBean.init(getCmsObject());\n        searchBean.setIndex(CmsGallerySearchIndex.GALLERY_INDEX_NAME);\n\n        CmsGallerySearchResultList searchResults = null;\n        while (!found) {\n            params.setResultPage(currentPage);\n            searchResults = searchBean.getResult(params);\n            Iterator<CmsGallerySearchResult> resultsIt = searchResults.listIterator();\n            while (resultsIt.hasNext()) {\n                CmsGallerySearchResult searchResult = resultsIt.next();\n                if (searchResult.getPath().equals(resource.getRootPath())) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found && ((searchResults.getHitCount() / (currentPage * params.getMatchesPerPage())) >= 1)) {\n                currentPage++;\n            } else {\n                break;\n            }\n        }\n        if (found && (searchResults != null)) {\n            initialSearchObj.setSortOrder(params.getSortOrder().name());\n            initialSearchObj.setResultCount(searchResults.getHitCount());\n            initialSearchObj.setPage(params.getResultPage());\n            initialSearchObj.setResults(buildSearchResultList(searchResults));\n            initialSearchObj.setPage(currentPage);\n            initialSearchObj.setTabId(I_CmsGalleryProviderConstants.GalleryTabId.cms_tab_results.name());\n            initialSearchObj.setResourcePath(resourceName);\n            initialSearchObj.setResourceType(resType);\n        } else {\n            log(\"could not find selected resource\");\n        }\n        return initialSearchObj;\n    }","id":25381,"modified_method":"/**\n     * Returns the search object containing the list with search results and the path to the specified resource.<p>\n     * \n     * @param resourceName the given resource\n     * @param data the gallery data bean \n     * \n     * @return the gallery search object containing the current search parameter and the search result list\n     * \n     * @throws CmsException if the search fails \n     */\n    private CmsGallerySearchBean findResourceInGallery(String resourceName, CmsGalleryDataBean data)\n    throws CmsException {\n\n        CmsResource resource = null;\n        int pos = resourceName.indexOf(\"?\");\n        String resName = resourceName;\n        if (pos > -1) {\n            resName = resourceName.substring(0, pos);\n        }\n        try {\n            log(\"reading resource: \" + resName);\n            resource = getCmsObject().readResource(resName);\n        } catch (CmsException e) {\n            logError(e);\n            return null;\n        }\n        ArrayList<String> types = new ArrayList<String>();\n        String resType = OpenCms.getResourceManager().getResourceType(resource).getTypeName();\n        types.add(resType);\n        CmsGallerySearchBean initialSearchObj = new CmsGallerySearchBean();\n        initialSearchObj.setTypes(types);\n        ArrayList<String> galleries = new ArrayList<String>();\n        for (CmsGalleryFolderBean gallery : data.getGalleries()) {\n            if (gallery.getPath().equals(CmsResource.getFolderPath(resName))) {\n                galleries.add(gallery.getPath());\n                initialSearchObj.setGalleries(galleries);\n                break;\n            }\n        }\n        if (galleries.isEmpty()) {\n            ArrayList<String> vfsFolders = new ArrayList<String>();\n            vfsFolders.add(CmsResource.getFolderPath(resName));\n            initialSearchObj.setFolders(new HashSet<String>(vfsFolders));\n        }\n        initialSearchObj.setLocale(data.getLocale());\n        CmsGallerySearchBean searchObj = new CmsGallerySearchBean(initialSearchObj);\n        searchObj.setSortOrder(CmsGallerySearchParameters.CmsGallerySortParam.DEFAULT.toString());\n        int currentPage = 1;\n        boolean found = false;\n        searchObj.setPage(currentPage);\n        CmsGallerySearchParameters params = prepareSearchParams(searchObj);\n        org.opencms.search.galleries.CmsGallerySearch searchBean = new org.opencms.search.galleries.CmsGallerySearch();\n        searchBean.init(getCmsObject());\n        searchBean.setIndex(CmsGallerySearchIndex.GALLERY_INDEX_NAME);\n\n        CmsGallerySearchResultList searchResults = null;\n        while (!found) {\n            params.setResultPage(currentPage);\n            searchResults = searchBean.getResult(params);\n            Iterator<CmsGallerySearchResult> resultsIt = searchResults.listIterator();\n            while (resultsIt.hasNext()) {\n                CmsGallerySearchResult searchResult = resultsIt.next();\n                if (searchResult.getPath().equals(resource.getRootPath())) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found && ((searchResults.getHitCount() / (currentPage * params.getMatchesPerPage())) >= 1)) {\n                currentPage++;\n            } else {\n                break;\n            }\n        }\n        if (found && (searchResults != null)) {\n            initialSearchObj.setSortOrder(params.getSortOrder().name());\n            initialSearchObj.setResultCount(searchResults.getHitCount());\n            initialSearchObj.setPage(params.getResultPage());\n            initialSearchObj.setResults(buildSearchResultList(searchResults));\n            initialSearchObj.setPage(currentPage);\n            initialSearchObj.setTabId(I_CmsGalleryProviderConstants.GalleryTabId.cms_tab_results.name());\n            initialSearchObj.setResourcePath(resourceName);\n            initialSearchObj.setResourceType(resType);\n        } else {\n            log(\"could not find selected resource\");\n        }\n        return initialSearchObj;\n    }","commit_id":"b8c63de5f24abb0dd9683da1fa3051f8259a91d0","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ade.galleries.shared.rpc.I_CmsGalleryService#getSearch(org.opencms.ade.galleries.shared.CmsGalleryDataBean)\n     */\n    public CmsGallerySearchBean getSearch(CmsGalleryDataBean data) {\n\n        CmsGallerySearchBean result = null;\n        // search within all available types\n        List<String> types = new ArrayList<String>();\n        for (CmsResourceTypeBean info : data.getTypes()) {\n            types.add(info.getType());\n        }\n        switch (data.getMode()) {\n            case editor:\n            case view:\n            case widget:\n                String currentelement = data.getCurrentElement();\n                if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(currentelement)) {\n                    log(\"looking up:\" + currentelement);\n                    // removing the servlet context if present\n                    if (currentelement.startsWith(OpenCms.getSystemInfo().getOpenCmsContext())) {\n                        currentelement = currentelement.substring(OpenCms.getSystemInfo().getOpenCmsContext().length());\n                        log(\"removed context - result: \" + currentelement);\n                    }\n                    // get search results given resource path\n                    result = findResourceInGallery(currentelement, data);\n                }\n                if ((result == null) || (result.getResults() == null) || result.getResults().isEmpty()) {\n                    result = new CmsGallerySearchBean();\n                    String gallery = data.getStartGallery();\n                    if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(gallery)) {\n                        List<String> galleries = new ArrayList<String>();\n                        galleries.add(gallery);\n                        result.setGalleries(galleries);\n                    }\n                    result.setTypes(types);\n                    result.setLocale(data.getLocale());\n                    result.setScope(CmsGallerySearchScope.siteShared);\n                    result = search(result);\n                }\n                // remove all types\n                result.setTypes(null);\n                break;\n            case ade:\n            default:\n                break;\n        }\n        return result;\n    }","id":25382,"modified_method":"/**\n     * @see org.opencms.ade.galleries.shared.rpc.I_CmsGalleryService#getSearch(org.opencms.ade.galleries.shared.CmsGalleryDataBean)\n     */\n    public CmsGallerySearchBean getSearch(CmsGalleryDataBean data) {\n\n        CmsGallerySearchBean result = null;\n        // search within all available types\n        List<String> types = new ArrayList<String>();\n        for (CmsResourceTypeBean info : data.getTypes()) {\n            types.add(info.getType());\n        }\n        switch (data.getMode()) {\n            case editor:\n            case view:\n            case widget:\n                String currentelement = data.getCurrentElement();\n                try {\n                    if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(currentelement)) {\n                        log(\"looking up:\" + currentelement);\n                        // removing the servlet context if present\n                        if (currentelement.startsWith(OpenCms.getSystemInfo().getOpenCmsContext())) {\n                            currentelement = currentelement.substring(OpenCms.getSystemInfo().getOpenCmsContext().length());\n                            log(\"removed context - result: \" + currentelement);\n                        }\n                        // get search results given resource path\n                        result = findResourceInGallery(currentelement, data);\n                    }\n                    if ((result == null) || (result.getResults() == null) || result.getResults().isEmpty()) {\n                        result = new CmsGallerySearchBean();\n                        String gallery = data.getStartGallery();\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(gallery)) {\n                            List<String> galleries = new ArrayList<String>();\n                            galleries.add(gallery);\n                            result.setGalleries(galleries);\n                        }\n                        result.setTypes(types);\n                        result.setLocale(data.getLocale());\n                        result.setScope(CmsGallerySearchScope.siteShared);\n                        result = search(result);\n                    }\n                    // remove all types\n                    result.setTypes(null);\n                } catch (CmsException e) {\n                    logError(e);\n                    result = null;\n                }\n                break;\n            case ade:\n            default:\n                break;\n        }\n        return result;\n    }","commit_id":"b8c63de5f24abb0dd9683da1fa3051f8259a91d0","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sends the given message to the given addresses.<p>\n     * \n     * @param cms the cms context\n     * \n     * @throws Exception if something goes wrong\n     */\n    public void sendEmail(CmsObject cms) throws Exception {\n\n        // create a plain text email\n        CmsSimpleMail theMail = new CmsSimpleMail();\n        theMail.setCharset(cms.getRequestContext().getEncoding());\n        theMail.setFrom(cms.getRequestContext().currentUser().getEmail(), getFrom());\n        theMail.setTo(createInternetAddresses(getTo()));\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(getCc())) {\n            theMail.setCc(createInternetAddresses(getCc()));\n        }\n        theMail.setSubject(\"[\" + OpenCms.getSystemInfo().getServerName() + \"] \" + getSubject());\n        theMail.setMsg(getMsg());\n        // send the mail\n        try {\n            theMail.send();\n        } catch (EmailException e) {\n            // check if original Exception is of type SendFailedException which\n            // should have been thrown by javax.mail.Transport.send()\n            if (e.getCause() instanceof SendFailedException) {\n                SendFailedException sfe = (SendFailedException)e.getCause();\n                // don't try to resend to successful Addresses: construct a new\n                // string with all unsent\n                StringBuffer newTo = new StringBuffer();\n                Address[] unsent = sfe.getValidUnsentAddresses();\n                if (unsent != null) {\n                    for (int i = unsent.length - 1; i >= 0; i--) {\n                        newTo.append(unsent[i].toString()).append(';');\n                    }\n                }\n                if (unsent != null) {\n                    unsent = sfe.getInvalidAddresses();\n                    for (int i = unsent.length - 1; i >= 0; i--) {\n                        newTo.append(unsent[i].toString()).append(';');\n                    }\n                }\n\n                setTo(newTo.toString());\n                // use the message of the internal cause: this is a localized\n                // CmsRuntimeException\n                throw (Exception)sfe.getCause();\n            }\n        }\n    }","id":25383,"modified_method":"/**\n     * Sends the given message to the given addresses.<p>\n     * \n     * @param cms the cms context\n     * \n     * @throws Exception if something goes wrong\n     */\n    public void sendEmail(CmsObject cms) throws Exception {\n\n        // create a plain text email\n        CmsSimpleMail theMail = new CmsSimpleMail();\n        theMail.setCharset(cms.getRequestContext().getEncoding());\n        theMail.setFrom(cms.getRequestContext().currentUser().getEmail(), getFrom());\n        theMail.setTo(createInternetAddresses(getTo()));\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(getCc())) {\n            theMail.setCc(createInternetAddresses(getCc()));\n        }\n        theMail.setSubject(\"[\" + OpenCms.getSystemInfo().getServerName() + \"] \" + getSubject());\n        theMail.setMsg(getMsg());\n        // send the mail\n        theMail.send();\n    }","commit_id":"a9f3e0428e9fd0f580105955dce391f0fec12cfa","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Default constructor of a CmsSimpleMail.<p>\n     * \n     * The mail host name and the mail from address are set to the OpenCms\n     * default values of the configuration.<p>\n     * \n     */\n    public CmsSimpleMail() {\n\n        // call super constructor\n        super();\n        // set the host to the default mail host\n        CmsMailHost host = OpenCms.getSystemInfo().getMailSettings().getDefaultMailHost();\n        setHostName(host.getHostname());\n\n        // check if username and password are provided\n        String userName = host.getUsername();\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(userName)) {\n            // authentication needed, set user name and password\n            setAuthentication(userName, host.getPassword());\n        }\n        try {\n            // set default mail from address\n            setFrom(OpenCms.getSystemInfo().getMailSettings().getMailFromDefault());\n        } catch (EmailException e) {\n            // default email address is not valid, log error\n            LOG.error(Messages.get().getBundle().key(Messages.LOG_INVALID_SENDER_ADDRESS_0), e);\n        }\n    }","id":25384,"modified_method":"/**\n     * Default constructor of a CmsSimpleMail.<p>\n     * \n     * The mail host name and the mail from address are set to the OpenCms\n     * default values of the configuration.<p>\n     * \n     */\n    public CmsSimpleMail() {\n\n        // call super constructor\n        super();\n        // set the host to the default mail host\n        CmsMailHost host = OpenCms.getSystemInfo().getMailSettings().getDefaultMailHost();\n        setHostName(host.getHostname());\n        this.setSmtpPort(host.getPort());\n\n        // check if username and password are provided\n        String userName = host.getUsername();\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(userName)) {\n            // authentication needed, set user name and password\n            setAuthentication(userName, host.getPassword());\n        }\n        try {\n            // set default mail from address\n            setFrom(OpenCms.getSystemInfo().getMailSettings().getMailFromDefault());\n        } catch (EmailException e) {\n            // default email address is not valid, log error\n            LOG.error(Messages.get().getBundle().key(Messages.LOG_INVALID_SENDER_ADDRESS_0), e);\n        }\n    }","commit_id":"a9f3e0428e9fd0f580105955dce391f0fec12cfa","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Overrides to add a layer for localization of exception / logging.<p>\n     * \n     * Please note that in case of a <code>{@link SendFailedException}<\/code>\n     * the cause of this message will contain a\n     * <code>{@link CmsRuntimeException}<\/code> as cause. The information of\n     * the <code>SendFailedException<\/code> should be used outside to remove\n     * recipients (e.g. from the beans that store them) in order to avoid\n     * duplicate sending of emails. The internal cause then just should be\n     * rethrown to allow localized output about the cause.<p>\n     * \n     * \n     * @see org.apache.commons.mail.Email#send()\n     * \n     * @throws EmailException if something goes wrong\n     */\n    public String send() throws EmailException {\n\n        String messageID = null;\n        try {\n            super.send();\n            messageID = this.getMimeMessage().getMessageID();\n        } catch (EmailException e) {\n            // check if original Exception is of type SendFailedException which\n            // should have been thrown by javax.mail.Transport.send()\n            if (e.getCause() instanceof SendFailedException) {\n                SendFailedException sfe = (SendFailedException)e.getCause();\n                // The specialized exception types (authentication, wrong host) are\n                // wrapped in this type:\n                MessagingException me = (MessagingException)sfe.getNextException();\n                CmsMailHost host = OpenCms.getSystemInfo().getMailSettings().getDefaultMailHost();\n                if (me instanceof AuthenticationFailedException) {\n                    // wrong user credentials in opencms-system.xml\n                    CmsRuntimeException rte = new CmsRuntimeException(Messages.get().container(\n                        Messages.ERR_SEND_EMAIL_AUTHENTICATE_2,\n                        host.getUsername(),\n                        host.getHostname()));\n                    sfe.initCause(rte);\n                    throw new EmailException(sfe);\n                }\n                // wrong hostname in opencms-system.xml\n                CmsRuntimeException rte = new CmsRuntimeException(Messages.get().container(\n                    Messages.ERR_SEND_EMAIL_HOSTNAME_1,\n                    host.getHostname()), me);\n                sfe.initCause(rte);\n                throw new EmailException(sfe);\n            }\n        } catch (MessagingException e) {\n            LOG.error(Messages.get().getBundle().key(Messages.LOG_MESSAGE_ID_ERR_0), e);\n        }\n        return messageID;\n    }","id":25385,"modified_method":"/**\n     * Overrides to add a better message for authentication exception.<p>\n     * \n     * @see org.apache.commons.mail.Email#send()\n     */\n    @Override\n    public String send() {\n\n        String messageID = null;\n        try {\n            messageID = super.send();\n        } catch (EmailException e) {\n            // check if original Exception is of type SendFailedException which\n            // should have been thrown by javax.mail.Transport.send()\n            if (e.getCause() instanceof AuthenticationFailedException) {\n                CmsMailHost host = OpenCms.getSystemInfo().getMailSettings().getDefaultMailHost();\n                // wrong user credentials in opencms-system.xml: mail api does not provide a message for authentication exception\n\n                CmsRuntimeException rte = new CmsRuntimeException(Messages.get().container(\n                    Messages.ERR_SEND_EMAIL_AUTHENTICATE_2,\n                    host.getUsername(),\n                    host.getHostname()));\n                rte.initCause(e);\n                throw rte;\n\n            } else {\n                CmsRuntimeException rte = new CmsRuntimeException(Messages.get().container(\n                    Messages.ERR_SEND_EMAIL_CONFIG_0));\n                rte.initCause(e);\n                throw rte;\n            }\n        }\n        return messageID;\n    }","commit_id":"a9f3e0428e9fd0f580105955dce391f0fec12cfa","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Rebuilds (if required creates) all configured indexes.<p>\n     * \n     * @param report the report object to write messages (or <code>null<\/code>)\n     * @param wait signals to wait until all the indexing threads are finished\n     * \n     * @throws CmsException if something goes wrong\n     */\n    public void rebuildAllIndexes(I_CmsReport report, boolean wait) throws CmsException {\n\n        for (int i = 0, n = m_indexes.size(); i < n; i++) {\n            // iterate all configured seach indexes\n            CmsSearchIndex searchIndex = (CmsSearchIndex)m_indexes.get(i);\n            // update the index \n            updateIndex(searchIndex, report, wait, null, null);\n        }\n    }","id":25386,"modified_method":"/**\n     * Rebuilds (if required creates) all configured indexes.<p>\n     * \n     * @param report the report object to write messages (or <code>null<\/code>)\n     * @param wait signals to wait until all the indexing threads are finished\n     * \n     * @throws CmsException if something goes wrong\n     */\n    public void rebuildAllIndexes(I_CmsReport report, boolean wait) throws CmsException {\n\n        CmsMessageContainer container = null;\n        for (int i = 0, n = m_indexes.size(); i < n; i++) {\n            // iterate all configured seach indexes\n            CmsSearchIndex searchIndex = (CmsSearchIndex)m_indexes.get(i);\n            try {\n                // update the index \n                updateIndex(searchIndex, report, wait, null, null);\n            } catch (CmsException e) {\n                container = new CmsMessageContainer(\n                    Messages.get(),\n                    Messages.ERR_INDEX_REBUILD_ALL_1,\n                    new Object[] {searchIndex.getName()});\n                LOG.error(Messages.get().getBundle().key(Messages.ERR_INDEX_REBUILD_ALL_1, searchIndex.getName()), e);\n            }\n        }\n        if (container != null) {\n            // throw stored exception\n            throw new CmsSearchException(container);\n        }\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Removes a search index from the configuration.<p>\n     * \n     * @param searchIndex the search index to remove\n     */\n    public void removeSearchIndex(CmsSearchIndex searchIndex) {\n\n        m_indexes.remove(searchIndex);\n\n        if (LOG.isInfoEnabled()) {\n            LOG.info(Messages.get().key(\n                Messages.LOG_REMOVE_SEARCH_INDEX_2,\n                searchIndex.getName(),\n                searchIndex.getProject()));\n        }\n    }","id":25387,"modified_method":"/**\n     * Removes a search index from the configuration.<p>\n     * \n     * @param searchIndex the search index to remove\n     */\n    public void removeSearchIndex(CmsSearchIndex searchIndex) {\n\n        m_indexes.remove(searchIndex);\n\n        if (LOG.isInfoEnabled()) {\n            LOG.info(Messages.get().getBundle().key(\n                Messages.LOG_REMOVE_SEARCH_INDEX_2,\n                searchIndex.getName(),\n                searchIndex.getProject()));\n        }\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes the search manager.<p>\n     * \n     * @param cms the cms object\n     */\n    public void initialize(CmsObject cms) {\n\n        // store the Admin cms to index Cms resources\n        m_adminCms = cms;\n\n        // init. the search result cache\n        LRUMap hashMap = new LRUMap(Integer.parseInt(m_resultCacheSize));\n        m_resultCache = Collections.synchronizedMap(hashMap);\n\n        if (OpenCms.getMemoryMonitor().enabled()) {\n            OpenCms.getMemoryMonitor().register(this.getClass().getName() + \".m_resultCache\", hashMap);\n        }\n\n        initializeIndexes();\n\n        // register the modified default similarity implementation\n        Similarity.setDefault(new CmsSearchSimilarity());\n\n        // register this object as event listener\n        OpenCms.addCmsEventListener(this, new int[] {\n            I_CmsEventListener.EVENT_CLEAR_CACHES,\n            I_CmsEventListener.EVENT_PUBLISH_PROJECT});\n    }","id":25388,"modified_method":"/**\n     * Initializes the search manager.<p>\n     * \n     * @param cms the cms object\n     * \n     * @throws CmsRoleViolationException in case the given opencms object does not have <code>{@link CmsRole#SEARCH_MANAGER}<\/code> permissions\n     */\n    public void initialize(CmsObject cms) throws CmsRoleViolationException {\n\n        cms.checkRole(CmsRole.SEARCH_MANAGER);\n        try {\n            // store the Admin cms to index Cms resources\n            m_adminCms = OpenCms.initCmsObject(cms);\n        } catch (CmsException e) {\n            // this should never happen\n        }\n        // make sure the site root is the root site\n        m_adminCms.getRequestContext().setSiteRoot(\"/\");\n\n        // init. the search result cache\n        LRUMap hashMap = new LRUMap(Integer.parseInt(m_resultCacheSize));\n        m_resultCache = Collections.synchronizedMap(hashMap);\n\n        if (OpenCms.getMemoryMonitor().enabled()) {\n            OpenCms.getMemoryMonitor().register(getClass().getName() + \".m_resultCache\", hashMap);\n        }\n\n        initializeIndexes();\n\n        // register the modified default similarity implementation\n        Similarity.setDefault(new CmsSearchSimilarity());\n\n        // register this object as event listener\n        OpenCms.addCmsEventListener(this, new int[] {\n            I_CmsEventListener.EVENT_CLEAR_CACHES,\n            I_CmsEventListener.EVENT_PUBLISH_PROJECT});\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds an analyzer.<p>\n     * \n     * @param analyzer an analyzer\n     */\n    public void addAnalyzer(CmsSearchAnalyzer analyzer) {\n\n        m_analyzers.put(analyzer.getLocale(), analyzer);\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().key(\n                Messages.INIT_ADD_ANALYZER_2,\n                analyzer.getLocale(),\n                analyzer.getClassName()));\n        }\n    }","id":25389,"modified_method":"/**\n     * Adds an analyzer.<p>\n     * \n     * @param analyzer an analyzer\n     */\n    public void addAnalyzer(CmsSearchAnalyzer analyzer) {\n\n        m_analyzers.put(analyzer.getLocale(), analyzer);\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(\n                Messages.INIT_ADD_ANALYZER_2,\n                analyzer.getLocale(),\n                analyzer.getClassName()));\n        }\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Implements the event listener of this class.<p>\n     * \n     * @see org.opencms.main.I_CmsEventListener#cmsEvent(org.opencms.main.CmsEvent)\n     */\n    public void cmsEvent(CmsEvent event) {\n\n        switch (event.getType()) {\n            case I_CmsEventListener.EVENT_CLEAR_CACHES:\n                if (m_resultCache != null) {\n                    m_resultCache.clear();\n                }\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(Messages.get().key(Messages.LOG_EVENT_CLEAR_CACHES_0));\n                }\n                break;\n            case I_CmsEventListener.EVENT_PUBLISH_PROJECT:\n                // event data contains a list of the published resources\n                CmsUUID publishHistoryId = new CmsUUID((String)event.getData().get(I_CmsEventListener.KEY_PUBLISHID));\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(Messages.get().key(Messages.LOG_EVENT_PUBLISH_PROJECT_1, publishHistoryId));\n                }\n                I_CmsReport report = (I_CmsReport)event.getData().get(I_CmsEventListener.KEY_REPORT);\n                updateAllIndexes(m_adminCms, publishHistoryId, report);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(Messages.get().key(Messages.LOG_EVENT_PUBLISH_PROJECT_FINISHED_1, publishHistoryId));\n                }\n                break;\n            default:\n                // no operation\n        }\n    }","id":25390,"modified_method":"/**\n     * Implements the event listener of this class.<p>\n     * \n     * @see org.opencms.main.I_CmsEventListener#cmsEvent(org.opencms.main.CmsEvent)\n     */\n    public void cmsEvent(CmsEvent event) {\n\n        switch (event.getType()) {\n            case I_CmsEventListener.EVENT_CLEAR_CACHES:\n                if (m_resultCache != null) {\n                    m_resultCache.clear();\n                }\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(Messages.get().getBundle().key(Messages.LOG_EVENT_CLEAR_CACHES_0));\n                }\n                break;\n            case I_CmsEventListener.EVENT_PUBLISH_PROJECT:\n                // event data contains a list of the published resources\n                CmsUUID publishHistoryId = new CmsUUID((String)event.getData().get(I_CmsEventListener.KEY_PUBLISHID));\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(Messages.get().getBundle().key(Messages.LOG_EVENT_PUBLISH_PROJECT_1, publishHistoryId));\n                }\n                I_CmsReport report = (I_CmsReport)event.getData().get(I_CmsEventListener.KEY_REPORT);\n                updateAllIndexes(m_adminCms, publishHistoryId, report);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(Messages.get().getBundle().key(\n                        Messages.LOG_EVENT_PUBLISH_PROJECT_FINISHED_1,\n                        publishHistoryId));\n                }\n                break;\n            default:\n        // no operation\n        }\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds a search index source configuration.<p>\n     * \n     * @param searchIndexSource a search index source configuration\n     */\n    public void addSearchIndexSource(CmsSearchIndexSource searchIndexSource) {\n\n        m_indexSources.put(searchIndexSource.getName(), searchIndexSource);\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().key(\n                Messages.INIT_SEARCH_INDEX_SOURCE_2,\n                searchIndexSource.getName(),\n                searchIndexSource.getIndexerClassName()));\n        }\n    }","id":25391,"modified_method":"/**\n     * Adds a search index source configuration.<p>\n     * \n     * @param searchIndexSource a search index source configuration\n     */\n    public void addSearchIndexSource(CmsSearchIndexSource searchIndexSource) {\n\n        m_indexSources.put(searchIndexSource.getName(), searchIndexSource);\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(\n                Messages.INIT_SEARCH_INDEX_SOURCE_2,\n                searchIndexSource.getName(),\n                searchIndexSource.getIndexerClassName()));\n        }\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sets the max. excerpt length.<p>\n     *\n     * @param maxExcerptLength the max. excerpt length to set\n     */\n    public void setMaxExcerptLength(String maxExcerptLength) {\n\n        try {\n            m_maxExcerptLength = Integer.parseInt(maxExcerptLength);\n        } catch (Exception e) {\n            LOG.error(Messages.get().key(Messages.LOG_PARSE_EXCERPT_LENGTH_FAILED_1, maxExcerptLength), e);\n            m_maxExcerptLength = 1024;\n        }\n    }","id":25392,"modified_method":"/**\n     * Sets the max. excerpt length.<p>\n     *\n     * @param maxExcerptLength the max. excerpt length to set\n     */\n    public void setMaxExcerptLength(String maxExcerptLength) {\n\n        try {\n            m_maxExcerptLength = Integer.parseInt(maxExcerptLength);\n        } catch (Exception e) {\n            LOG.error(Messages.get().getBundle().key(Messages.LOG_PARSE_EXCERPT_LENGTH_FAILED_1, maxExcerptLength), e);\n            m_maxExcerptLength = 1024;\n        }\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes the available Cms resource types to be indexed.<p>\n     * \n     * A map stores document factories keyed by a string representing\n     * a colon separated list of Cms resource types and/or mimetypes.<p>\n     * \n     * The keys of this map are used to trigger a document factory to convert \n     * a Cms resource into a Lucene index document.<p>\n     * \n     * A document factory is a class implementing the interface\n     * {@link org.opencms.search.documents.I_CmsDocumentFactory}.<p>\n     */\n    protected void initAvailableDocumentTypes() {\n\n        CmsSearchDocumentType documenttype = null;\n        String className = null;\n        String name = null;\n        I_CmsDocumentFactory documentFactory = null;\n        List resourceTypes = null;\n        List mimeTypes = null;\n        Class c = null;\n\n        m_documentTypes = new HashMap();\n\n        List keys = new ArrayList(m_documentTypeConfigs.keySet());\n        for (int i = 0, n = keys.size(); i < n; i++) {\n\n            documenttype = (CmsSearchDocumentType)(m_documentTypeConfigs.get(keys.get(i)));\n            name = documenttype.getName();\n\n            try {\n                className = documenttype.getClassName();\n                resourceTypes = documenttype.getResourceTypes();\n                mimeTypes = documenttype.getMimeTypes();\n\n                if (name == null) {\n                    throw new CmsIndexException(Messages.get().container(Messages.ERR_DOCTYPE_NO_NAME_0));\n                }\n                if (className == null) {\n                    throw new CmsIndexException(Messages.get().container(Messages.ERR_DOCTYPE_NO_CLASS_DEF_0));\n                }\n                if (resourceTypes.size() == 0) {\n                    throw new CmsIndexException(Messages.get().container(Messages.ERR_DOCTYPE_NO_RESOURCETYPE_DEF_0));\n                }\n\n                try {\n                    c = Class.forName(className);\n                    documentFactory = (I_CmsDocumentFactory)c.getConstructor(new Class[] {String.class}).newInstance(\n                        new Object[] {name});\n                } catch (ClassNotFoundException exc) {\n                    throw new CmsIndexException(\n                        Messages.get().container(Messages.ERR_DOCCLASS_NOT_FOUND_1, className),\n                        exc);\n                } catch (Exception exc) {\n                    throw new CmsIndexException(Messages.get().container(Messages.ERR_DOCCLASS_INIT_1, className), exc);\n                }\n\n                for (Iterator key = documentFactory.getDocumentKeys(resourceTypes, mimeTypes).iterator(); key.hasNext();) {\n                    m_documentTypes.put(key.next(), documentFactory);\n                }\n\n            } catch (CmsException e) {\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(Messages.get().key(Messages.LOG_DOCTYPE_CONFIG_FAILED_1, name), e);\n                }\n            }\n        }\n    }","id":25393,"modified_method":"/**\n     * Initializes the available Cms resource types to be indexed.<p>\n     * \n     * A map stores document factories keyed by a string representing\n     * a colon separated list of Cms resource types and/or mimetypes.<p>\n     * \n     * The keys of this map are used to trigger a document factory to convert \n     * a Cms resource into a Lucene index document.<p>\n     * \n     * A document factory is a class implementing the interface\n     * {@link org.opencms.search.documents.I_CmsDocumentFactory}.<p>\n     */\n    protected void initAvailableDocumentTypes() {\n\n        CmsSearchDocumentType documenttype = null;\n        String className = null;\n        String name = null;\n        I_CmsDocumentFactory documentFactory = null;\n        List resourceTypes = null;\n        List mimeTypes = null;\n        Class c = null;\n\n        m_documentTypes = new HashMap();\n\n        List keys = new ArrayList(m_documentTypeConfigs.keySet());\n        for (int i = 0, n = keys.size(); i < n; i++) {\n\n            documenttype = (CmsSearchDocumentType)(m_documentTypeConfigs.get(keys.get(i)));\n            name = documenttype.getName();\n\n            try {\n                className = documenttype.getClassName();\n                resourceTypes = documenttype.getResourceTypes();\n                mimeTypes = documenttype.getMimeTypes();\n\n                if (name == null) {\n                    throw new CmsIndexException(Messages.get().container(Messages.ERR_DOCTYPE_NO_NAME_0));\n                }\n                if (className == null) {\n                    throw new CmsIndexException(Messages.get().container(Messages.ERR_DOCTYPE_NO_CLASS_DEF_0));\n                }\n                if (resourceTypes.size() == 0) {\n                    throw new CmsIndexException(Messages.get().container(Messages.ERR_DOCTYPE_NO_RESOURCETYPE_DEF_0));\n                }\n\n                try {\n                    c = Class.forName(className);\n                    documentFactory = (I_CmsDocumentFactory)c.getConstructor(new Class[] {String.class}).newInstance(\n                        new Object[] {name});\n                } catch (ClassNotFoundException exc) {\n                    throw new CmsIndexException(\n                        Messages.get().container(Messages.ERR_DOCCLASS_NOT_FOUND_1, className),\n                        exc);\n                } catch (Exception exc) {\n                    throw new CmsIndexException(Messages.get().container(Messages.ERR_DOCCLASS_INIT_1, className), exc);\n                }\n\n                for (Iterator key = documentFactory.getDocumentKeys(resourceTypes, mimeTypes).iterator(); key.hasNext();) {\n                    m_documentTypes.put(key.next(), documentFactory);\n                }\n\n            } catch (CmsException e) {\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(Messages.get().getBundle().key(Messages.LOG_DOCTYPE_CONFIG_FAILED_1, name), e);\n                }\n            }\n        }\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Updates the indexes from as a scheduled job.<p> \n     * \n     * @param cms the OpenCms user context to use when reading resources from the VFS\n     * @param parameters the parameters for the scheduled job\n     * \n     * @throws Exception if something goes wrong\n     * \n     * @return the String to write in the scheduler log\n     * \n     * @see org.opencms.scheduler.I_CmsScheduledJob#launch(org.opencms.file.CmsObject, java.util.Map)\n     */\n    public final String launch(CmsObject cms, Map parameters) throws Exception {\n\n        CmsSearchManager manager = OpenCms.getSearchManager();\n\n        I_CmsReport report = null;\n        boolean writeLog = Boolean.valueOf((String)parameters.get(JOB_PARAM_WRITELOG)).booleanValue();\n\n        if (writeLog) {\n            report = new CmsLogReport(cms.getRequestContext().getLocale(), CmsSearchManager.class);\n        }\n\n        List updateList = null;\n        String indexList = (String)parameters.get(JOB_PARAM_INDEXLIST);\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(indexList)) {\n            // index list has been provided as job parameter\n            updateList = new ArrayList();\n            String[] indexNames = CmsStringUtil.splitAsArray(indexList, '|');\n            for (int i = 0; i < indexNames.length; i++) {\n                // check if the index actually exists\n                if (manager.getIndex(indexNames[i]) != null) {\n                    updateList.add(indexNames[i]);\n                } else {\n                    if (LOG.isWarnEnabled()) {\n                        LOG.warn(Messages.get().key(Messages.LOG_NO_INDEX_WITH_NAME_1, indexNames[i]));\n                    }\n                }\n            }\n        }\n\n        long startTime = System.currentTimeMillis();\n\n        if (updateList == null) {\n            // all indexes need to be updated\n            manager.rebuildAllIndexes(report);\n        } else {\n            // rebuild only the selected indexes\n            manager.rebuildIndexes(updateList, report);\n        }\n\n        long runTime = System.currentTimeMillis() - startTime;\n\n        String finishMessage = Messages.get().key(\n            Messages.LOG_REBUILD_INDEXES_FINISHED_1,\n            CmsStringUtil.formatRuntime(runTime));\n\n        if (LOG.isInfoEnabled()) {\n            LOG.info(finishMessage);\n        }\n        return finishMessage;\n    }","id":25394,"modified_method":"/**\n     * Updates the indexes from as a scheduled job.<p> \n     * \n     * @param cms the OpenCms user context to use when reading resources from the VFS\n     * @param parameters the parameters for the scheduled job\n     * \n     * @throws Exception if something goes wrong\n     * \n     * @return the String to write in the scheduler log\n     * \n     * @see org.opencms.scheduler.I_CmsScheduledJob#launch(org.opencms.file.CmsObject, java.util.Map)\n     */\n    public final String launch(CmsObject cms, Map parameters) throws Exception {\n\n        CmsSearchManager manager = OpenCms.getSearchManager();\n\n        I_CmsReport report = null;\n        boolean writeLog = Boolean.valueOf((String)parameters.get(JOB_PARAM_WRITELOG)).booleanValue();\n\n        if (writeLog) {\n            report = new CmsLogReport(cms.getRequestContext().getLocale(), CmsSearchManager.class);\n        }\n\n        List updateList = null;\n        String indexList = (String)parameters.get(JOB_PARAM_INDEXLIST);\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(indexList)) {\n            // index list has been provided as job parameter\n            updateList = new ArrayList();\n            String[] indexNames = CmsStringUtil.splitAsArray(indexList, '|');\n            for (int i = 0; i < indexNames.length; i++) {\n                // check if the index actually exists\n                if (manager.getIndex(indexNames[i]) != null) {\n                    updateList.add(indexNames[i]);\n                } else {\n                    if (LOG.isWarnEnabled()) {\n                        LOG.warn(Messages.get().getBundle().key(Messages.LOG_NO_INDEX_WITH_NAME_1, indexNames[i]));\n                    }\n                }\n            }\n        }\n\n        long startTime = System.currentTimeMillis();\n\n        if (updateList == null) {\n            // all indexes need to be updated\n            manager.rebuildAllIndexes(report);\n        } else {\n            // rebuild only the selected indexes\n            manager.rebuildIndexes(updateList, report);\n        }\n\n        long runTime = System.currentTimeMillis() - startTime;\n\n        String finishMessage = Messages.get().getBundle().key(\n            Messages.LOG_REBUILD_INDEXES_FINISHED_1,\n            CmsStringUtil.formatRuntime(runTime));\n\n        if (LOG.isInfoEnabled()) {\n            LOG.info(finishMessage);\n        }\n        return finishMessage;\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Default constructer when called as cron job.<p>\n     */\n    public CmsSearchManager() {\n\n        m_documentTypes = new HashMap();\n        m_documentTypeConfigs = new HashMap();\n        m_analyzers = new HashMap();\n        m_indexes = new ArrayList();\n        m_indexSources = new HashMap();\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().key(Messages.INIT_START_SEARCH_CONFIG_0));\n        }\n    }","id":25395,"modified_method":"/**\n     * Default constructer when called as cron job.<p>\n     */\n    public CmsSearchManager() {\n\n        m_documentTypes = new HashMap();\n        m_documentTypeConfigs = new HashMap();\n        m_analyzers = new HashMap();\n        m_indexes = new ArrayList();\n        m_indexSources = new HashMap();\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_START_SEARCH_CONFIG_0));\n        }\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds a document type.<p>\n     * \n     * @param documentType a document type\n     */\n    public void addDocumentTypeConfig(CmsSearchDocumentType documentType) {\n\n        m_documentTypeConfigs.put(documentType.getName(), documentType);\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().key(\n                Messages.INIT_SEARCH_DOC_TYPES_2,\n                documentType.getName(),\n                documentType.getClassName()));\n        }\n    }","id":25396,"modified_method":"/**\n     * Adds a document type.<p>\n     * \n     * @param documentType a document type\n     */\n    public void addDocumentTypeConfig(CmsSearchDocumentType documentType) {\n\n        m_documentTypeConfigs.put(documentType.getName(), documentType);\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(\n                Messages.INIT_SEARCH_DOC_TYPES_2,\n                documentType.getName(),\n                documentType.getClassName()));\n        }\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Rebuilds (if required creates) the List of indexes with the given name.<p>\n     * \n     * @param indexNames the names (String) of the index to rebuild\n     * @param report the report object to write messages (or <code>null<\/code>)\n     * \n     * @throws CmsException if something goes wrong\n     */\n    public void rebuildIndexes(List indexNames, I_CmsReport report) throws CmsException {\n\n        Iterator i = indexNames.iterator();\n        while (i.hasNext()) {\n            String indexName = (String)i.next();\n            // get the search index by name\n            CmsSearchIndex index = getIndex(indexName);\n            if (index != null) {\n                // update the index \n                updateIndex(index, report, false, null, null);\n            } else {\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(Messages.get().key(Messages.LOG_NO_INDEX_WITH_NAME_1, indexName));\n                }\n            }\n        }\n    }","id":25397,"modified_method":"/**\n     * Rebuilds (if required creates) the List of indexes with the given name.<p>\n     * \n     * @param indexNames the names (String) of the index to rebuild\n     * @param report the report object to write messages (or <code>null<\/code>)\n     * \n     * @throws CmsException if something goes wrong\n     */\n    public void rebuildIndexes(List indexNames, I_CmsReport report) throws CmsException {\n\n        Iterator i = indexNames.iterator();\n        while (i.hasNext()) {\n            String indexName = (String)i.next();\n            // get the search index by name\n            CmsSearchIndex index = getIndex(indexName);\n            if (index != null) {\n                // update the index \n                updateIndex(index, report, false, null, null);\n            } else {\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(Messages.get().getBundle().key(Messages.LOG_NO_INDEX_WITH_NAME_1, indexName));\n                }\n            }\n        }\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Removes all indexes included in the given list (which must contain the name of an index to remove).<p>\n     * \n     * @param indexNames the names of the index to remove\n     */\n    public void removeSearchIndexes(List indexNames) {\n\n        Iterator i = indexNames.iterator();\n        while (i.hasNext()) {\n            String indexName = (String)i.next();\n            // get the search index by name\n            CmsSearchIndex index = getIndex(indexName);\n            if (index != null) {\n                // remove the index \n                removeSearchIndex(index);\n            } else {\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(Messages.get().key(Messages.LOG_NO_INDEX_WITH_NAME_1, indexName));\n                }\n            }\n        }\n    }","id":25398,"modified_method":"/**\n     * Removes all indexes included in the given list (which must contain the name of an index to remove).<p>\n     * \n     * @param indexNames the names of the index to remove\n     */\n    public void removeSearchIndexes(List indexNames) {\n\n        Iterator i = indexNames.iterator();\n        while (i.hasNext()) {\n            String indexName = (String)i.next();\n            // get the search index by name\n            CmsSearchIndex index = getIndex(indexName);\n            if (index != null) {\n                // remove the index \n                removeSearchIndex(index);\n            } else {\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(Messages.get().getBundle().key(Messages.LOG_NO_INDEX_WITH_NAME_1, indexName));\n                }\n            }\n        }\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes the configured search indexes.<p>\n     * \n     * This initializes also the list of Cms resources types\n     * to be indexed by an index source.<p>\n     */\n    protected void initSearchIndexes() {\n\n        CmsSearchIndex index = null;\n        for (int i = 0, n = m_indexes.size(); i < n; i++) {\n            index = (CmsSearchIndex)m_indexes.get(i);\n            try {\n                index.initialize();\n            } catch (CmsException exc) {\n                if (CmsLog.INIT.isInfoEnabled()) {\n                    CmsLog.INIT.info(Messages.get().key(Messages.INIT_SEARCH_INIT_FAILED_1, index.getName()), exc);\n                }\n            }\n        }\n    }","id":25399,"modified_method":"/**\n     * Initializes the configured search indexes.<p>\n     * \n     * This initializes also the list of Cms resources types\n     * to be indexed by an index source.<p>\n     */\n    protected void initSearchIndexes() {\n\n        CmsSearchIndex index = null;\n        for (int i = 0, n = m_indexes.size(); i < n; i++) {\n            index = (CmsSearchIndex)m_indexes.get(i);\n            // reset disabled flag\n            index.setEnabled(true);\n            // check if the index has been configured correctly\n            if (index.checkConfiguration(m_adminCms)) {\n                // the index is configured correctly\n                try {\n                    index.initialize();\n                } catch (CmsException e) {\n                    // in this case the index will be disabled\n                    if (CmsLog.INIT.isInfoEnabled()) {\n                        CmsLog.INIT.info(Messages.get().getBundle().key(\n                            Messages.INIT_SEARCH_INIT_FAILED_1,\n                            index.getName()), e);\n                    }\n                }\n            }\n            if (CmsLog.INIT.isInfoEnabled()) {\n                // output a log message if the index was successfully configured or not\n                if (index.isEnabled()) {\n                    CmsLog.INIT.info(Messages.get().getBundle().key(\n                        Messages.INIT_INDEX_CONFIGURED_2,\n                        index.getName(),\n                        index.getProject()));\n                } else {\n                    CmsLog.INIT.info(Messages.get().getBundle().key(\n                        Messages.INIT_INDEX_NOT_CONFIGURED_2,\n                        index.getName(),\n                        index.getProject()));\n                }\n            }\n        }\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Incrementally updates all indexes that have their rebuild mode set to <code>\"auto\"<\/code>\n     * after resources have been published.<p> \n     * \n     * @param adminCms an OpenCms user context with Admin permissions\n     * @param publishHistoryId the history ID of the published project \n     * @param report the report to write the output to\n     */\n    protected synchronized void updateAllIndexes(CmsObject adminCms, CmsUUID publishHistoryId, I_CmsReport report) {\n\n        List publishedResources;\n        try {\n            // read the list of all published resources\n            publishedResources = adminCms.readPublishedResources(publishHistoryId);\n        } catch (CmsException e) {\n            LOG.error(Messages.get().key(Messages.LOG_READING_CHANGED_RESOURCES_FAILED_1, publishHistoryId), e);\n            return;\n        }\n\n        List updateResources = new ArrayList();\n        Iterator itPubRes = publishedResources.iterator();\n        while (itPubRes.hasNext()) {\n            CmsPublishedResource res = (CmsPublishedResource)itPubRes.next();\n            if (res.isFolder() || res.isUnChanged() || !res.isVfsResource()) {\n                // folders, unchanged resources and non vfs resources don't need to be indexed after publish\n                continue;\n            }\n            if (res.isDeleted() || res.isNew() || res.isChanged()) {\n                if (updateResources.contains(res)) {\n                    // resource may have been added as a sibling of another resource\n                    // in this case we make sure to use the value from the publih list because of the \"deleted\" flag\n                    updateResources.remove(res);\n                    // \"equals()\" implementation of published resource only checks for path, \n                    // so the removed value may have a different \"deleted\" or \"modified\" status value\n                    updateResources.add(res);\n                } else {\n                    // resource not yet contained in the list\n                    updateResources.add(res);\n                    // check for the siblings (not for deleted resources, these are already gone)\n                    if (!res.isDeleted() && (res.getSiblingCount() > 1)) {\n                        // this resource has siblings                    \n                        try {\n                            // read siblings from the online project\n                            List siblings = adminCms.readSiblings(res.getRootPath(), CmsResourceFilter.ALL);\n                            Iterator itSib = siblings.iterator();\n                            while (itSib.hasNext()) {\n                                // check all siblings\n                                CmsResource sibling = (CmsResource)itSib.next();\n                                CmsPublishedResource sib = new CmsPublishedResource(sibling);\n                                if (!updateResources.contains(sib)) {\n                                    // ensure sibling is added only once\n                                    updateResources.add(sib);\n                                }\n                            }\n                        } catch (CmsException e) {\n                            // ignore, just use the original resource\n                            if (LOG.isWarnEnabled()) {\n                                LOG.warn(\n                                    Messages.get().key(Messages.LOG_UNABLE_TO_READ_SIBLINGS_1, res.getRootPath()),\n                                    e);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // cache for the generated documents (to avoid multiple text extraction in case of overlapping indexes)\n        Map documentCache = Collections.synchronizedMap(new LRUMap(256));\n\n        if (!updateResources.isEmpty()) {\n            // sort the resource to update\n            Collections.sort(updateResources);\n            // only update the indexes if the list of remaining published resources is not empty\n            Iterator i = m_indexes.iterator();\n            while (i.hasNext()) {\n                CmsSearchIndex index = (CmsSearchIndex)i.next();\n                if (CmsSearchIndex.REBUILD_MODE_AUTO.equals(index.getRebuildMode())) {\n                    // only update indexes which have the rebuild mode set to \"auto\"\n                    try {\n                        updateIndex(index, report, false, updateResources, documentCache);\n                    } catch (CmsException e) {\n                        LOG.error(Messages.get().key(Messages.LOG_UPDATE_INDEX_FAILED_1, index.getName()), e);\n                    }\n                }\n            }\n        }\n    }","id":25400,"modified_method":"/**\n     * Incrementally updates all indexes that have their rebuild mode set to <code>\"auto\"<\/code>\n     * after resources have been published.<p> \n     * \n     * @param adminCms an OpenCms user context with Admin permissions\n     * @param publishHistoryId the history ID of the published project \n     * @param report the report to write the output to\n     */\n    protected synchronized void updateAllIndexes(CmsObject adminCms, CmsUUID publishHistoryId, I_CmsReport report) {\n\n        List publishedResources;\n        try {\n            // read the list of all published resources\n            publishedResources = adminCms.readPublishedResources(publishHistoryId);\n        } catch (CmsException e) {\n            LOG.error(\n                Messages.get().getBundle().key(Messages.LOG_READING_CHANGED_RESOURCES_FAILED_1, publishHistoryId),\n                e);\n            return;\n        }\n\n        List updateResources = new ArrayList();\n        Iterator itPubRes = publishedResources.iterator();\n        while (itPubRes.hasNext()) {\n            CmsPublishedResource res = (CmsPublishedResource)itPubRes.next();\n            if (res.isFolder() || res.isUnChanged() || !res.isVfsResource()) {\n                // folders, unchanged resources and non vfs resources don't need to be indexed after publish\n                continue;\n            }\n            if (res.isDeleted() || res.isNew() || res.isChanged()) {\n                if (updateResources.contains(res)) {\n                    // resource may have been added as a sibling of another resource\n                    // in this case we make sure to use the value from the publih list because of the \"deleted\" flag\n                    updateResources.remove(res);\n                    // \"equals()\" implementation of published resource only checks for path, \n                    // so the removed value may have a different \"deleted\" or \"modified\" status value\n                    updateResources.add(res);\n                } else {\n                    // resource not yet contained in the list\n                    updateResources.add(res);\n                    // check for the siblings (not for deleted resources, these are already gone)\n                    if (!res.isDeleted() && (res.getSiblingCount() > 1)) {\n                        // this resource has siblings                    \n                        try {\n                            // read siblings from the online project\n                            List siblings = adminCms.readSiblings(res.getRootPath(), CmsResourceFilter.ALL);\n                            Iterator itSib = siblings.iterator();\n                            while (itSib.hasNext()) {\n                                // check all siblings\n                                CmsResource sibling = (CmsResource)itSib.next();\n                                CmsPublishedResource sib = new CmsPublishedResource(sibling);\n                                if (!updateResources.contains(sib)) {\n                                    // ensure sibling is added only once\n                                    updateResources.add(sib);\n                                }\n                            }\n                        } catch (CmsException e) {\n                            // ignore, just use the original resource\n                            if (LOG.isWarnEnabled()) {\n                                LOG.warn(Messages.get().getBundle().key(\n                                    Messages.LOG_UNABLE_TO_READ_SIBLINGS_1,\n                                    res.getRootPath()), e);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // cache for the generated documents (to avoid multiple text extraction in case of overlapping indexes)\n        Map documentCache = Collections.synchronizedMap(new LRUMap(256));\n\n        if (!updateResources.isEmpty()) {\n            // sort the resource to update\n            Collections.sort(updateResources);\n            // only update the indexes if the list of remaining published resources is not empty\n            Iterator i = m_indexes.iterator();\n            while (i.hasNext()) {\n                CmsSearchIndex index = (CmsSearchIndex)i.next();\n                if (CmsSearchIndex.REBUILD_MODE_AUTO.equals(index.getRebuildMode())) {\n                    // only update indexes which have the rebuild mode set to \"auto\"\n                    try {\n                        updateIndex(index, report, false, updateResources, documentCache);\n                    } catch (CmsException e) {\n                        LOG.error(\n                            Messages.get().getBundle().key(Messages.LOG_UPDATE_INDEX_FAILED_1, index.getName()),\n                            e);\n                    }\n                }\n            }\n        }\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Updates (if required creates) the index with the given name.<p>\n     * \n     * If the optional List of <code>{@link CmsPublishedResource}<\/code> instances is provided, the index will be \n     * incrementally updated for these resources only. If this List is <code>null<\/code> or empty, \n     * the index will be fully rebuild.<p>\n     * \n     * @param index the index to update or rebuild\n     * @param report the report to write output messages to \n     * @param wait signals to wait until all the indexing threads are finished\n     * @param resourcesToIndex an (optional) list of <code>{@link CmsPublishedResource}<\/code> objects to update in the index\n     * @param documentCache a cache for the created search documents, to avoid multiple text extraction\n     * \n     * @throws CmsException if something goes wrong\n     */\n    protected synchronized void updateIndex(\n        CmsSearchIndex index,\n        I_CmsReport report,\n        boolean wait,\n        List resourcesToIndex,\n        Map documentCache) throws CmsException {\n\n        // copy the stored admin context for the indexing\n        CmsObject cms = OpenCms.initCmsObject(m_adminCms);\n        // make sure a report is available\n        if (report == null) {\n            report = new CmsLogReport(cms.getRequestContext().getLocale(), CmsSearchManager.class);\n        }\n        // set site root and project for this index\n        cms.getRequestContext().setSiteRoot(\"/\");\n        // switch to the index project\n        cms.getRequestContext().setCurrentProject(cms.readProject(index.getProject()));\n\n        if ((resourcesToIndex == null) || resourcesToIndex.isEmpty()) {\n            // rebuild the complete index\n\n            // create a new index writer\n            IndexWriter writer = index.getIndexWriter(true);\n\n            // create a new thread manager for the indexing threads\n            // please note: document cache _must_ be null for full rebuild \n            //              since there may be diffeences between online and offline projects,\n            //              which can only be ignored if a resource has just been published (then online=offline)\n            CmsIndexingThreadManager threadManager = new CmsIndexingThreadManager(\n                report,\n                Long.parseLong(m_timeout),\n                index.getName(),\n                null);\n\n            try {\n\n                // ouput start information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_REBUILD_BEGIN_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n\n                // iterate all configured index sources of this index\n                Iterator sources = index.getSources().iterator();\n                while (sources.hasNext()) {\n                    // get the next index source\n                    CmsSearchIndexSource source = (CmsSearchIndexSource)sources.next();\n                    // create the indexer\n                    I_CmsIndexer indexer = source.getIndexer().newInstance(cms, report, index);\n                    // new index creation, use all resources from the index source\n                    indexer.rebuildIndex(writer, threadManager, source);\n                }\n\n                // wait for indexing threads to finish\n                while (wait && threadManager.isRunning()) {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        // just continue with the loop after interruption\n                    }\n                }\n                // optimize the generated index\n                try {\n                    writer.optimize();\n                } catch (IOException e) {\n                    if (LOG.isWarnEnabled()) {\n                        LOG.warn(Messages.get().key(\n                            Messages.LOG_IO_INDEX_WRITER_OPTIMIZE_1,\n                            index.getPath(),\n                            index.getName()), e);\n                    }\n                }\n\n                // ouput finish information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_REBUILD_END_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n\n            } finally {\n                if (writer != null) {\n                    try {\n                        writer.close();\n                    } catch (IOException e) {\n                        if (LOG.isWarnEnabled()) {\n                            LOG.warn(Messages.get().key(\n                                Messages.LOG_IO_INDEX_WRITER_CLOSE_2,\n                                index.getPath(),\n                                index.getName()), e);\n                        }\n                    }\n                }\n            }\n\n            // show information about indexing runtime\n            threadManager.reportStatistics();\n\n        } else {\n            // update the existing index\n\n            List updateCollections = new ArrayList();\n\n            boolean hasResourcesToDelete = false;\n            boolean hasResourcesToUpdate = false;\n\n            // iterate all configured index sources of this index\n            Iterator sources = index.getSources().iterator();\n            while (sources.hasNext()) {\n                // get the next index source\n                CmsSearchIndexSource source = (CmsSearchIndexSource)sources.next();\n                // create the indexer\n                I_CmsIndexer indexer = source.getIndexer().newInstance(cms, report, index);\n                // collect the resources to update\n                CmsSearchIndexUpdateData updateData = indexer.getUpdateData(source, resourcesToIndex);\n                if (!updateData.isEmpty()) {\n                    // add the update collection to the internal pipeline\n                    updateCollections.add(updateData);\n                    hasResourcesToDelete = hasResourcesToDelete | updateData.hasResourcesToDelete();\n                    hasResourcesToUpdate = hasResourcesToUpdate | updateData.hasResourceToUpdate();\n                }\n            }\n\n            if (hasResourcesToDelete || hasResourcesToUpdate) {\n                // ouput start information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_UPDATE_BEGIN_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n            }\n\n            if (hasResourcesToDelete) {\n                // delete the resource from the index\n                IndexReader reader = null;\n                try {\n                    reader = IndexReader.open(index.getPath());\n                } catch (IOException e) {\n                    LOG.error(\n                        Messages.get().key(Messages.LOG_IO_INDEX_READER_OPEN_2, index.getPath(), index.getName()),\n                        e);\n                }\n                if (reader != null) {\n                    try {\n                        Iterator i = updateCollections.iterator();\n                        while (i.hasNext()) {\n                            CmsSearchIndexUpdateData updateCollection = (CmsSearchIndexUpdateData)i.next();\n                            if (updateCollection.hasResourcesToDelete()) {\n                                updateCollection.getIndexer().deleteResources(\n                                    reader,\n                                    updateCollection.getResourcesToDelete());\n                            }\n                        }\n                    } finally {\n                        try {\n                            // close the reader after all resources have been deleted\n                            reader.close();\n                        } catch (IOException e) {\n                            LOG.error(Messages.get().key(\n                                Messages.LOG_IO_INDEX_READER_CLOSE_2,\n                                index.getPath(),\n                                index.getName()), e);\n                        }\n                    }\n                }\n            }\n\n            if (hasResourcesToUpdate) {\n\n                // create an index writer that updates the current index\n                IndexWriter writer = index.getIndexWriter(false);\n\n                if (writer != null) {\n\n                    // create a new thread manager\n                    CmsIndexingThreadManager threadManager = new CmsIndexingThreadManager(\n                        report,\n                        Long.parseLong(m_timeout),\n                        index.getName(),\n                        documentCache);\n\n                    try {\n                        Iterator i = updateCollections.iterator();\n                        while (i.hasNext()) {\n                            CmsSearchIndexUpdateData updateCollection = (CmsSearchIndexUpdateData)i.next();\n                            if (updateCollection.hasResourceToUpdate()) {\n                                updateCollection.getIndexer().updateResources(\n                                    writer,\n                                    threadManager,\n                                    updateCollection.getResourcesToUpdate());\n                            }\n                        }\n                    } finally {\n                        try {\n                            writer.close();\n                        } catch (IOException e) {\n                            LOG.error(Messages.get().key(\n                                Messages.LOG_IO_INDEX_WRITER_CLOSE_2,\n                                index.getPath(),\n                                index.getName()), e);\n                        }\n                    }\n\n                    // wait for indexing threads to finish\n                    while (wait && threadManager.isRunning()) {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // just continue with the loop after interruption\n                        }\n                    }\n                }\n            }\n\n            if (hasResourcesToDelete || hasResourcesToUpdate) {\n                // ouput finish information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_UPDATE_END_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n            }\n\n        }\n\n        // clear the cache for search results\n        m_resultCache.clear();\n    }","id":25401,"modified_method":"/**\n     * Updates (if required creates) the index with the given name.<p>\n     * \n     * If the optional List of <code>{@link CmsPublishedResource}<\/code> instances is provided, the index will be \n     * incrementally updated for these resources only. If this List is <code>null<\/code> or empty, \n     * the index will be fully rebuild.<p>\n     * \n     * @param index the index to update or rebuild\n     * @param report the report to write output messages to \n     * @param wait signals to wait until all the indexing threads are finished\n     * @param resourcesToIndex an (optional) list of <code>{@link CmsPublishedResource}<\/code> objects to update in the index\n     * @param documentCache a cache for the created search documents, to avoid multiple text extraction\n     * \n     * @throws CmsException if something goes wrong\n     */\n    protected synchronized void updateIndex(\n        CmsSearchIndex index,\n        I_CmsReport report,\n        boolean wait,\n        List resourcesToIndex,\n        Map documentCache) throws CmsException {\n\n        // copy the stored admin context for the indexing\n        CmsObject cms = OpenCms.initCmsObject(m_adminCms);\n        // make sure a report is available\n        if (report == null) {\n            report = new CmsLogReport(cms.getRequestContext().getLocale(), CmsSearchManager.class);\n        }\n\n        // check if the index has been configured correctly\n        if (!index.checkConfiguration(cms)) {\n            // the index is disabled\n            return;\n        }\n\n        // set site root and project for this index\n        cms.getRequestContext().setSiteRoot(\"/\");\n        // switch to the index project\n        cms.getRequestContext().setCurrentProject(cms.readProject(index.getProject()));\n\n        if ((resourcesToIndex == null) || resourcesToIndex.isEmpty()) {\n            // rebuild the complete index\n\n            if (checkIndexLock(index, report)) {\n                // unable to lock the index for updating\n                try {\n                    // try to force unlock on the index (full rebuild is done anyway)\n                    IndexReader.unlock(FSDirectory.getDirectory(index.getPath(), false));\n                } catch (Exception e) {\n                    // unable to force unlock of Lucene index, we can't continue this way\n                    CmsMessageContainer msg = Messages.get().container(\n                        Messages.ERR_INDEX_LOCK_FAILED_1,\n                        index.getName());\n                    report.println(msg, I_CmsReport.FORMAT_ERROR);\n                    throw new CmsIndexException(msg, e);\n                }\n            }\n\n            // create a new thread manager for the indexing threads\n            // please note: document cache _must_ be null for full rebuild \n            //              since there may be diffeences between online and offline projects,\n            //              which can only be ignored if a resource has just been published (then online=offline)\n            CmsIndexingThreadManager threadManager = new CmsIndexingThreadManager(\n                report,\n                Long.parseLong(m_timeout),\n                index.getName(),\n                null);\n\n            IndexWriter writer = null;\n            try {\n                // create a new index writer\n                writer = index.getIndexWriter(true);\n\n                // ouput start information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_REBUILD_BEGIN_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n\n                // iterate all configured index sources of this index\n                Iterator sources = index.getSources().iterator();\n                while (sources.hasNext()) {\n                    // get the next index source\n                    CmsSearchIndexSource source = (CmsSearchIndexSource)sources.next();\n                    // create the indexer\n                    I_CmsIndexer indexer = source.getIndexer().newInstance(cms, report, index);\n                    // new index creation, use all resources from the index source\n                    indexer.rebuildIndex(writer, threadManager, source);\n                }\n\n                // wait for indexing threads to finish\n                while (wait && threadManager.isRunning()) {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        // just continue with the loop after interruption\n                    }\n                }\n                // optimize the generated index\n                try {\n                    writer.optimize();\n                } catch (IOException e) {\n                    if (LOG.isWarnEnabled()) {\n                        LOG.warn(Messages.get().getBundle().key(\n                            Messages.LOG_IO_INDEX_WRITER_OPTIMIZE_1,\n                            index.getPath(),\n                            index.getName()), e);\n                    }\n                }\n\n                // ouput finish information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_REBUILD_END_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n\n            } finally {\n                if (writer != null) {\n                    try {\n                        writer.close();\n                    } catch (IOException e) {\n                        if (LOG.isWarnEnabled()) {\n                            LOG.warn(Messages.get().getBundle().key(\n                                Messages.LOG_IO_INDEX_WRITER_CLOSE_2,\n                                index.getPath(),\n                                index.getName()), e);\n                        }\n                    }\n                }\n            }\n\n            // show information about indexing runtime\n            threadManager.reportStatistics();\n\n        } else {\n            // update the existing index\n\n            List updateCollections = new ArrayList();\n\n            boolean hasResourcesToDelete = false;\n            boolean hasResourcesToUpdate = false;\n\n            // iterate all configured index sources of this index\n            Iterator sources = index.getSources().iterator();\n            while (sources.hasNext()) {\n                // get the next index source\n                CmsSearchIndexSource source = (CmsSearchIndexSource)sources.next();\n                // create the indexer\n                I_CmsIndexer indexer = source.getIndexer().newInstance(cms, report, index);\n                // collect the resources to update\n                CmsSearchIndexUpdateData updateData = indexer.getUpdateData(source, resourcesToIndex);\n                if (!updateData.isEmpty()) {\n                    // add the update collection to the internal pipeline\n                    updateCollections.add(updateData);\n                    hasResourcesToDelete = hasResourcesToDelete | updateData.hasResourcesToDelete();\n                    hasResourcesToUpdate = hasResourcesToUpdate | updateData.hasResourceToUpdate();\n                }\n            }\n\n            if (hasResourcesToDelete || hasResourcesToUpdate) {\n                // ouput start information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_UPDATE_BEGIN_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n            }\n\n            if (checkIndexLock(index, report)) {\n                // unable to lock the index for updating\n                CmsMessageContainer msg = Messages.get().container(Messages.ERR_INDEX_LOCK_FAILED_1, index.getName());\n                report.println(msg, I_CmsReport.FORMAT_ERROR);\n                throw new CmsIndexException(msg);\n            }\n\n            if (hasResourcesToDelete) {\n                // delete the resource from the index\n                IndexReader reader = null;\n                try {\n                    reader = IndexReader.open(index.getPath());\n                } catch (IOException e) {\n                    LOG.error(Messages.get().getBundle().key(\n                        Messages.LOG_IO_INDEX_READER_OPEN_2,\n                        index.getPath(),\n                        index.getName()), e);\n                }\n                if (reader != null) {\n                    try {\n                        Iterator i = updateCollections.iterator();\n                        while (i.hasNext()) {\n                            CmsSearchIndexUpdateData updateCollection = (CmsSearchIndexUpdateData)i.next();\n                            if (updateCollection.hasResourcesToDelete()) {\n                                updateCollection.getIndexer().deleteResources(\n                                    reader,\n                                    updateCollection.getResourcesToDelete());\n                            }\n                        }\n                    } finally {\n                        try {\n                            // close the reader after all resources have been deleted\n                            reader.close();\n                        } catch (IOException e) {\n                            LOG.error(Messages.get().getBundle().key(\n                                Messages.LOG_IO_INDEX_READER_CLOSE_2,\n                                index.getPath(),\n                                index.getName()), e);\n                        }\n                    }\n                }\n            }\n\n            if (hasResourcesToUpdate) {\n\n                // create a new thread manager\n                CmsIndexingThreadManager threadManager = new CmsIndexingThreadManager(\n                    report,\n                    Long.parseLong(m_timeout),\n                    index.getName(),\n                    documentCache);\n\n                IndexWriter writer = null;\n                try {\n\n                    // create an index writer that updates the current index\n                    writer = index.getIndexWriter(false);\n\n                    Iterator i = updateCollections.iterator();\n                    while (i.hasNext()) {\n                        CmsSearchIndexUpdateData updateCollection = (CmsSearchIndexUpdateData)i.next();\n                        if (updateCollection.hasResourceToUpdate()) {\n                            updateCollection.getIndexer().updateResources(\n                                writer,\n                                threadManager,\n                                updateCollection.getResourcesToUpdate());\n                        }\n                    }\n\n                    // wait for indexing threads to finish\n                    while (wait && threadManager.isRunning()) {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // just continue with the loop after interruption\n                        }\n                    }\n\n                } finally {\n                    if (writer != null) {\n                        try {\n                            writer.close();\n                        } catch (IOException e) {\n                            LOG.error(Messages.get().getBundle().key(\n                                Messages.LOG_IO_INDEX_WRITER_CLOSE_2,\n                                index.getPath(),\n                                index.getName()), e);\n                        }\n                    }\n                }\n            }\n\n            if (hasResourcesToDelete || hasResourcesToUpdate) {\n                // ouput finish information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_UPDATE_END_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n            }\n        }\n\n        // clear the cache for search results\n        m_resultCache.clear();\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds a search index to the configuration.<p>\n     * \n     * @param searchIndex the search index to add\n     */\n    public void addSearchIndex(CmsSearchIndex searchIndex) {\n\n        m_indexes.add(searchIndex);\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().key(\n                Messages.INIT_ADD_SEARCH_INDEX_2,\n                searchIndex.getName(),\n                searchIndex.getProject()));\n        }\n    }","id":25402,"modified_method":"/**\n     * Adds a search index to the configuration.<p>\n     * \n     * @param searchIndex the search index to add\n     */\n    public void addSearchIndex(CmsSearchIndex searchIndex) {\n\n        if (searchIndex.getSources() == null || searchIndex.getPath() == null) {\n            if (OpenCms.getRunLevel() > OpenCms.RUNLEVEL_2_INITIALIZING) {\n                try {\n                    searchIndex.initialize();\n                } catch (CmsSearchException e) {\n                    // should never happen\n                }\n            }\n        }\n\n        // name: not null or emtpy and unique\n        String name = searchIndex.getName();\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(name)) {\n            throw new CmsIllegalArgumentException(Messages.get().container(\n                Messages.ERR_SEARCHINDEX_CREATE_MISSING_NAME_0));\n        }\n        if (m_indexSources.keySet().contains(name)) {\n            throw new CmsIllegalArgumentException(Messages.get().container(\n                Messages.ERR_SEARCHINDEX_CREATE_INVALID_NAME_1,\n                name));\n        }\n\n        m_indexes.add(searchIndex);\n\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(\n                Messages.INIT_ADD_SEARCH_INDEX_2,\n                searchIndex.getName(),\n                searchIndex.getProject()));\n        }\n    }","commit_id":"008558f2c68d7fde21d424877440d4b48fe7674b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void checkAllColumnFamilies() throws IOException\n    {\n        // perform estimates\n        for (String tableName : DatabaseDescriptor.getTables())\n        {\n            for (final ColumnFamilyStore cfs : Table.open(tableName).getColumnFamilyStores().values())\n            {\n                Runnable runnable = new Runnable()\n                {\n                    public void run ()\n                    {\n                        logger.debug(\"Estimating compactions for \" + cfs.columnFamily_);\n                        final Set<List<SSTableReader>> buckets = getCompactionBuckets(cfs.getSSTables(), 50L * 1024L * 1024L);\n                        updateEstimateFor(cfs, buckets);\n                    }\n                };\n                executor.submit(runnable);\n            }\n        }\n        \n        // actually schedule compactions.  done in a second pass so all the estimates occur before we\n        // bog down the executor in actual compactions.\n        for (String tableName : DatabaseDescriptor.getTables())\n        {\n            for (final ColumnFamilyStore cfs : Table.open(tableName).getColumnFamilyStores().values())\n            {\n                submitMinorIfNeeded(cfs);\n            }\n        }\n    }","id":25403,"modified_method":"public void checkAllColumnFamilies() throws IOException\n    {\n        // perform estimates\n        for (String tableName : DatabaseDescriptor.getTables())\n        {\n            for (final ColumnFamilyStore cfs : Table.open(tableName).getColumnFamilyStores())\n            {\n                Runnable runnable = new Runnable()\n                {\n                    public void run ()\n                    {\n                        logger.debug(\"Estimating compactions for \" + cfs.columnFamily_);\n                        final Set<List<SSTableReader>> buckets = getCompactionBuckets(cfs.getSSTables(), 50L * 1024L * 1024L);\n                        updateEstimateFor(cfs, buckets);\n                    }\n                };\n                executor.submit(runnable);\n            }\n        }\n        \n        // actually schedule compactions.  done in a second pass so all the estimates occur before we\n        // bog down the executor in actual compactions.\n        for (String tableName : DatabaseDescriptor.getTables())\n        {\n            for (final ColumnFamilyStore cfs : Table.open(tableName).getColumnFamilyStores())\n            {\n                submitMinorIfNeeded(cfs);\n            }\n        }\n    }","commit_id":"7e09822a332b27183f879ccf2aa989038330ed3f","url":"https://github.com/apache/cassandra"},{"original_method":"private static boolean sendMessage(InetAddress endPoint, String tableName, String key) throws IOException\n    {\n        if (!Gossiper.instance.isKnownEndpoint(endPoint))\n        {\n            logger_.warn(\"Hints found for endpoint \" + endPoint + \" which is not part of the gossip network.  discarding.\");\n            return true;\n        }\n        if (!FailureDetector.instance.isAlive(endPoint))\n        {\n            return false;\n        }\n\n        Table table = Table.open(tableName);\n        RowMutation rm = new RowMutation(tableName, key);\n        for (ColumnFamilyStore cfstore : table.getColumnFamilyStores().values())\n        {\n            ColumnFamily cf = cfstore.getColumnFamily(new IdentityQueryFilter(key, new QueryPath(cfstore.getColumnFamilyName())));\n            if (cf != null)\n                rm.add(cf);\n        }\n        Message message = rm.makeRowMutationMessage();\n        WriteResponseHandler responseHandler = new WriteResponseHandler(1);\n        MessagingService.instance.sendRR(message, new InetAddress[] { endPoint }, responseHandler);\n\n        try\n        {\n            responseHandler.get();\n        }\n        catch (TimeoutException e)\n        {\n            return false;\n        }\n        return true;\n    }","id":25404,"modified_method":"private static boolean sendMessage(InetAddress endPoint, String tableName, String key) throws IOException\n    {\n        if (!Gossiper.instance.isKnownEndpoint(endPoint))\n        {\n            logger_.warn(\"Hints found for endpoint \" + endPoint + \" which is not part of the gossip network.  discarding.\");\n            return true;\n        }\n        if (!FailureDetector.instance.isAlive(endPoint))\n        {\n            return false;\n        }\n\n        Table table = Table.open(tableName);\n        RowMutation rm = new RowMutation(tableName, key);\n        for (ColumnFamilyStore cfstore : table.getColumnFamilyStores())\n        {\n            ColumnFamily cf = cfstore.getColumnFamily(new IdentityQueryFilter(key, new QueryPath(cfstore.getColumnFamilyName())));\n            if (cf != null)\n                rm.add(cf);\n        }\n        Message message = rm.makeRowMutationMessage();\n        WriteResponseHandler responseHandler = new WriteResponseHandler(1);\n        MessagingService.instance.sendRR(message, new InetAddress[] { endPoint }, responseHandler);\n\n        try\n        {\n            responseHandler.get();\n        }\n        catch (TimeoutException e)\n        {\n            return false;\n        }\n        return true;\n    }","commit_id":"7e09822a332b27183f879ccf2aa989038330ed3f","url":"https://github.com/apache/cassandra"},{"original_method":"Map<String, ColumnFamilyStore> getColumnFamilyStores()\n    {\n        return columnFamilyStores;\n    }","id":25405,"modified_method":"Collection<ColumnFamilyStore> getColumnFamilyStores()\n    {\n        return Collections.unmodifiableCollection(columnFamilyStores.values());\n    }","commit_id":"7e09822a332b27183f879ccf2aa989038330ed3f","url":"https://github.com/apache/cassandra"},{"original_method":"protected void logStatistics()\n    {\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"active: [{}] (max: [{}]), idle: [{}] (max: [{}])\", this.ds.getNumActive(),\n                this.ds.getMaxActive(), this.ds.getNumIdle(), this.ds.getMaxIdle());\n        }\n    }","id":25406,"modified_method":"protected void logStatistics()\n    {\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"active: [{}] (max: [{}]), idle: [{}] (max: [{}])\", this.ds.getNumActive(),\n                this.ds.getMaxTotal(), this.ds.getNumIdle(), this.ds.getMaxIdle());\n        }\n    }","commit_id":"94098e68da94caca9ba0ffa9d82cf8543475716e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void configure(Properties props) throws HibernateException\n    {\n        try {\n            LOGGER.debug(\"Configure DBCPConnectionProvider\");\n\n            // DBCP properties used to create the BasicDataSource\n            Properties dbcpProperties = new Properties();\n\n            // DriverClass & url\n            String jdbcDriverClass = props.getProperty(Environment.DRIVER);\n            dbcpProperties.put(\"driverClassName\", jdbcDriverClass);\n\n            String jdbcUrl = System.getProperty(Environment.URL);\n            if (jdbcUrl == null) {\n                jdbcUrl = props.getProperty(Environment.URL);\n            }\n            dbcpProperties.put(\"url\", jdbcUrl);\n\n            // Username / password. Only put username and password if they're not null. This allows\n            // external authentication support (OS authenticated). It'll thus work if the hibernate\n            // config does not specify a username and/or password.\n            String username = props.getProperty(Environment.USER);\n            if (username != null) {\n                dbcpProperties.put(\"username\", username);\n            }\n            String password = props.getProperty(Environment.PASS);\n            if (password != null) {\n                dbcpProperties.put(\"password\", password);\n            }\n\n            // Isolation level\n            String isolationLevel = props.getProperty(Environment.ISOLATION);\n            if ((isolationLevel != null) && (isolationLevel.trim().length() > 0)) {\n                dbcpProperties.put(\"defaultTransactionIsolation\", isolationLevel);\n            }\n\n            // Turn off autocommit (unless autocommit property is set)\n            String autocommit = props.getProperty(AUTOCOMMIT);\n            if ((autocommit != null) && (autocommit.trim().length() > 0)) {\n                dbcpProperties.put(\"defaultAutoCommit\", autocommit);\n            } else {\n                dbcpProperties.put(\"defaultAutoCommit\", String.valueOf(Boolean.FALSE));\n            }\n\n            // Pool size\n            String poolSize = props.getProperty(Environment.POOL_SIZE);\n            if ((poolSize != null) && (poolSize.trim().length() > 0) && (Integer.parseInt(poolSize) > 0)) {\n                dbcpProperties.put(\"maxActive\", poolSize);\n            }\n\n            // Copy all \"driver\" properties into \"connectionProperties\"\n            Properties driverProps = ConnectionProviderFactory.getConnectionProperties(props);\n            if (driverProps.size() > 0) {\n                StringBuffer connectionProperties = new StringBuffer();\n                for (Iterator iter = driverProps.keySet().iterator(); iter.hasNext();) {\n                    String key = (String) iter.next();\n                    String value = driverProps.getProperty(key);\n                    connectionProperties.append(key).append('=').append(value);\n                    if (iter.hasNext()) {\n                        connectionProperties.append(';');\n                    }\n                }\n                dbcpProperties.put(\"connectionProperties\", connectionProperties.toString());\n            }\n\n            // Copy all DBCP properties removing the prefix\n            for (Object element : props.keySet()) {\n                String key = String.valueOf(element);\n                if (key.startsWith(PREFIX)) {\n                    String property = key.substring(PREFIX.length());\n                    String value = props.getProperty(key);\n                    dbcpProperties.put(property, value);\n                }\n            }\n\n            // Backward-compatibility\n            if (props.getProperty(DBCP_PS_MAXACTIVE) != null) {\n                dbcpProperties.put(\"poolPreparedStatements\", String.valueOf(Boolean.TRUE));\n                dbcpProperties.put(\"maxOpenPreparedStatements\", props.getProperty(DBCP_PS_MAXACTIVE));\n            }\n\n            // Some debug info\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Creating a DBCP BasicDataSource with the following DBCP factory properties:\");\n                StringWriter sw = new StringWriter();\n                dbcpProperties.list(new PrintWriter(sw, true));\n                LOGGER.debug(sw.toString());\n            }\n\n            // Let the factory create the pool\n            this.ds = (BasicDataSource) BasicDataSourceFactory.createDataSource(dbcpProperties);\n\n            // The BasicDataSource has lazy initialization\n            // borrowing a connection will start the DataSource\n            // and make sure it is configured correctly.\n            Connection conn = this.ds.getConnection();\n            conn.close();\n\n            // Log pool statistics before continuing.\n            logStatistics();\n        } catch (Exception e) {\n            String message =\n                \"Could not create a DBCP pool. \"\n                    + \"There is an error in the hibernate configuration file, please review it.\";\n            LOGGER.error(message, e);\n            if (this.ds != null) {\n                try {\n                    this.ds.close();\n                } catch (Exception e2) {\n                    // ignore\n                }\n                this.ds = null;\n            }\n            throw new HibernateException(message, e);\n        }\n        LOGGER.debug(\"Configure DBCPConnectionProvider complete\");\n    }","id":25407,"modified_method":"@Override\n    public void configure(Properties props) throws HibernateException\n    {\n        try {\n            LOGGER.debug(\"Configure DBCPConnectionProvider\");\n\n            // DBCP properties used to create the BasicDataSource\n            Properties dbcpProperties = new Properties();\n\n            // DriverClass & url\n            String jdbcDriverClass = props.getProperty(Environment.DRIVER);\n            dbcpProperties.put(\"driverClassName\", jdbcDriverClass);\n\n            String jdbcUrl = System.getProperty(Environment.URL);\n            if (jdbcUrl == null) {\n                jdbcUrl = props.getProperty(Environment.URL);\n            }\n            dbcpProperties.put(\"url\", jdbcUrl);\n\n            // Username / password. Only put username and password if they're not null. This allows\n            // external authentication support (OS authenticated). It'll thus work if the hibernate\n            // config does not specify a username and/or password.\n            String username = props.getProperty(Environment.USER);\n            if (username != null) {\n                dbcpProperties.put(\"username\", username);\n            }\n            String password = props.getProperty(Environment.PASS);\n            if (password != null) {\n                dbcpProperties.put(\"password\", password);\n            }\n\n            // Isolation level\n            String isolationLevel = props.getProperty(Environment.ISOLATION);\n            if ((isolationLevel != null) && (isolationLevel.trim().length() > 0)) {\n                dbcpProperties.put(\"defaultTransactionIsolation\", isolationLevel);\n            }\n\n            // Turn off autocommit (unless autocommit property is set)\n            // Note that this property will be overwritten below if the DBCP \"defaultAutoCommit\" property is defined.\n            String autocommit = props.getProperty(AUTOCOMMIT);\n            if ((autocommit != null) && (autocommit.trim().length() > 0)) {\n                dbcpProperties.put(\"defaultAutoCommit\", autocommit);\n            } else {\n                dbcpProperties.put(\"defaultAutoCommit\", String.valueOf(Boolean.FALSE));\n            }\n\n            // Pool size\n            String poolSize = props.getProperty(Environment.POOL_SIZE);\n            if ((poolSize != null) && (poolSize.trim().length() > 0) && (Integer.parseInt(poolSize) > 0)) {\n                dbcpProperties.put(\"maxTotal\", poolSize);\n            }\n\n            // Copy all \"driver\" properties into \"connectionProperties\"\n            Properties driverProps = ConnectionProviderFactory.getConnectionProperties(props);\n            if (driverProps.size() > 0) {\n                StringBuffer connectionProperties = new StringBuffer();\n                for (Iterator iter = driverProps.keySet().iterator(); iter.hasNext();) {\n                    String key = (String) iter.next();\n                    String value = driverProps.getProperty(key);\n                    connectionProperties.append(key).append('=').append(value);\n                    if (iter.hasNext()) {\n                        connectionProperties.append(';');\n                    }\n                }\n                dbcpProperties.put(\"connectionProperties\", connectionProperties.toString());\n            }\n\n            // Copy all DBCP properties removing the prefix\n            for (Object element : props.keySet()) {\n                String key = String.valueOf(element);\n                if (key.startsWith(PREFIX)) {\n                    String property = key.substring(PREFIX.length());\n                    String value = props.getProperty(key);\n\n                    // Handle backward compatibility\n                    switch (property) {\n                        case COMPATIBILITY_PS_MAXACTIVE:\n                            dbcpProperties.put(\"poolPreparedStatements\", String.valueOf(Boolean.TRUE));\n                            dbcpProperties.put(\"maxOpenPreparedStatements\", value);\n                            break;\n                        case COMPATIBILITY_MAXACTIVE:\n                            dbcpProperties.put(\"maxTotal\", value);\n                            break;\n                        case COMPATIBILITY_MAXWAIT:\n                            dbcpProperties.put(\"maxWaitMillis\", value);\n                            break;\n                        default:\n                            dbcpProperties.put(property, value);\n                    }\n                }\n            }\n\n            // Some debug info\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Creating a DBCP BasicDataSource with the following DBCP factory properties:\");\n                StringWriter sw = new StringWriter();\n                dbcpProperties.list(new PrintWriter(sw, true));\n                LOGGER.debug(sw.toString());\n            }\n\n            // Let the factory create the pool\n            this.ds = BasicDataSourceFactory.createDataSource(dbcpProperties);\n\n            // The BasicDataSource has lazy initialization\n            // borrowing a connection will start the DataSource\n            // and make sure it is configured correctly.\n            Connection conn = this.ds.getConnection();\n            conn.close();\n\n            // Log pool statistics before continuing.\n            logStatistics();\n        } catch (Exception e) {\n            String message = \"Could not create a DBCP pool. There is an error in the Hibernate configuration file, \"\n                + \"please review it.\";\n            LOGGER.error(message, e);\n            if (this.ds != null) {\n                try {\n                    this.ds.close();\n                } catch (Exception e2) {\n                    // ignore\n                }\n                this.ds = null;\n            }\n            throw new HibernateException(message, e);\n        }\n        LOGGER.debug(\"Configure DBCPConnectionProvider complete\");\n    }","commit_id":"94098e68da94caca9ba0ffa9d82cf8543475716e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void transferProperties() {\n        try {\n            Properties p = new Properties();\n            for (int i=0; i< ALL_PROPERTIES.length; i++) {\n                String name = \"get\" + Character.toUpperCase(ALL_PROPERTIES[i].charAt(0)) + ALL_PROPERTIES[i].substring(1);\n                String bname = \"is\" + name.substring(3);\n                Method get = null;\n                try {\n                    get = PoolProperties.class.getMethod(name, new Class[0]);\n                }catch (NoSuchMethodException x) {\n                    try {\n                        get = PoolProperties.class.getMethod(bname, new Class[0]);\n                    }catch (NoSuchMethodException x2) {\n                        String msg = x2.getMessage();\n                        if (msg.indexOf(\"isPoolPreparedStatements\")>=0) {\n                            //noop - ignore known missing properties\n                        } else if (msg.indexOf(\"isMaxOpenPreparedStatements\")>=0) {\n                            //noop - ignore known missing properties\n                        } else {\n                            System.err.println(\"Missing property:\"+x2.getMessage());\n                        }\n                    }\n                }\n                   if (get!=null) {\n                       Object value = get.invoke(datasource.getPoolProperties(), new Object[0]);\n                       if (value!=null) {\n                           p.setProperty(ALL_PROPERTIES[i], value.toString());\n                       }\n                }\n            }\n            tDatasource = (BasicDataSource) BasicDataSourceFactory.createDataSource(p);\n        }catch (Exception x) {\n            x.printStackTrace();\n        }\n    }","id":25408,"modified_method":"protected void transferProperties() {\n        try {\n            Properties p = new Properties();\n            for (int i=0; i< ALL_PROPERTIES.length; i++) {\n                String name = \"get\" + Character.toUpperCase(ALL_PROPERTIES[i].charAt(0)) + ALL_PROPERTIES[i].substring(1);\n                String bname = \"is\" + name.substring(3);\n                Method get = null;\n                try {\n                    get = PoolProperties.class.getMethod(name, new Class[0]);\n                }catch (NoSuchMethodException x) {\n                    try {\n                        get = PoolProperties.class.getMethod(bname, new Class[0]);\n                    }catch (NoSuchMethodException x2) {\n                        String msg = x2.getMessage();\n                        if (msg.indexOf(\"isPoolPreparedStatements\")>=0) {\n                            //noop - ignore known missing properties\n                        } else if (msg.indexOf(\"isMaxOpenPreparedStatements\")>=0) {\n                            //noop - ignore known missing properties\n                        } else {\n                            System.err.println(\"Missing property:\"+x2.getMessage());\n                        }\n                    }\n                }\n                   if (get!=null) {\n                       Object value = get.invoke(datasource.getPoolProperties(), new Object[0]);\n                       if (value!=null) {\n                           p.setProperty(ALL_PROPERTIES[i], value.toString());\n                       }\n                }\n            }\n            tDatasource = BasicDataSourceFactory.createDataSource(p);\n        }catch (Exception x) {\n            x.printStackTrace();\n        }\n    }","commit_id":"9883e94198acbb1c4dc2280dd36e7e75c958a921","url":"https://github.com/apache/tomcat"},{"original_method":"public List<MediaFormat> getSupportedFormats()\n    {\n        return\n            (captureDevice == null)\n                ? getSupportedFormats(captureDeviceInfo)\n                : getSupportedFormats(captureDevice);\n    }","id":25409,"modified_method":"public List<MediaFormat> getSupportedFormats()\n    {\n        Processor processor = getProcessor();\n        Set<Format> supportedFormats = new HashSet<Format>();\n\n        if (processor != null)\n        {\n            MediaType mediaType = getMediaType();\n\n            for (TrackControl trackControl : processor.getTrackControls())\n            {\n                if (!trackControl.isEnabled())\n                    continue;\n\n                for (Format supportedFormat : trackControl.getSupportedFormats())\n                    switch (mediaType)\n                    {\n                    case AUDIO:\n                        if (supportedFormat instanceof AudioFormat)\n                            supportedFormats.add(supportedFormat);\n                        break;\n                    case VIDEO:\n                        if (supportedFormat instanceof VideoFormat)\n                            supportedFormats.add(supportedFormat);\n                        break;\n                    }\n            }\n        }\n\n        List<MediaFormat> supportedMediaFormats\n            = new ArrayList<MediaFormat>(supportedFormats.size());\n\n        for (Format format : supportedFormats)\n            supportedMediaFormats.add(MediaFormatImpl.createInstance(format));\n        return supportedMediaFormats;\n    }","commit_id":"b28c62f5da728ff71d768ba21a5f186a2995af65","url":"https://github.com/jitsi/jitsi"},{"original_method":"public MediaDirection getDirection()\n    {\n        return MediaDirection.SENDONLY;\n    }","id":25410,"modified_method":"public MediaDirection getDirection()\n    {\n        return MediaDirection.SENDRECV;\n    }","commit_id":"b28c62f5da728ff71d768ba21a5f186a2995af65","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Gets the JMF <tt>CaptureDevice<\/tt> this instance wraps and provides an\n     * implementation of <tt>MediaDevice<\/tt> for.\n     *\n     * @return the JMF <tt>CaptureDevice<\/tt> this instance wraps and provides\n     * an implementation of <tt>MediaDevice<\/tt> for\n     */\n    private CaptureDevice getCaptureDevice()\n    {\n        if (captureDevice == null)\n            captureDevice\n                = (CaptureDevice)\n                    MediaControl\n                        .createDataSource(\n                            captureDeviceInfo.getLocator());\n        return captureDevice;\n    }","id":25411,"modified_method":"/**\n     * Gets the JMF <tt>CaptureDevice<\/tt> this instance wraps and provides an\n     * implementation of <tt>MediaDevice<\/tt> for.\n     *\n     * @return the JMF <tt>CaptureDevice<\/tt> this instance wraps and provides\n     * an implementation of <tt>MediaDevice<\/tt> for\n     */\n    private DataSource getCaptureDevice()\n    {\n        if (captureDevice == null)\n        {\n            try\n            {\n                captureDevice\n                    = Manager.createDataSource(captureDeviceInfo.getLocator());\n            }\n            catch (IOException ioe)\n            {\n                // TODO\n            }\n            catch (NoDataSourceException ndse)\n            {\n                // TODO\n            }\n        }\n        return captureDevice;\n    }","commit_id":"b28c62f5da728ff71d768ba21a5f186a2995af65","url":"https://github.com/jitsi/jitsi"},{"original_method":"public MediaFormat getFormat()\n    {\n        MediaType mediaType = getMediaType();\n\n        for (FormatControl formatControl\n                : getCaptureDevice().getFormatControls())\n        {\n            MediaFormat format\n                = MediaFormatImpl.createInstance(formatControl.getFormat());\n\n            if ((format != null) && format.getMediaType().equals(mediaType))\n                return format;\n        }\n        return null;\n    }","id":25412,"modified_method":"public MediaFormat getFormat()\n    {\n        Processor processor = getProcessor();\n\n        if (processor != null)\n        {\n            MediaType mediaType = getMediaType();\n\n            for (TrackControl trackControl : processor.getTrackControls())\n            {\n                if (!trackControl.isEnabled())\n                    continue;\n\n                MediaFormat format\n                    = MediaFormatImpl.createInstance(trackControl.getFormat());\n\n                if ((format != null) && format.getMediaType().equals(mediaType))\n                    return format;\n            }\n        }\n        return null;\n    }","commit_id":"b28c62f5da728ff71d768ba21a5f186a2995af65","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes a new <tt>CaptureMediaDevice<\/tt> instance which is to\n     * provide an implementation of <tt>MediaDevice<\/tt> for a specific\n     * <tt>CaptureDevice<\/tt> with a specific <tt>MediaType<\/tt>.\n     *\n     * @param captureDevice the JMF <tt>CaptureDevice<\/tt> the new instance is\n     * to provide an implementation of <tt>MediaDevice<\/tt> for\n     * @param mediaType the <tt>MediaType<\/tt> of the new instance\n     */\n    public CaptureMediaDevice(CaptureDevice captureDevice, MediaType mediaType)\n    {\n        if (captureDevice == null)\n            throw new NullPointerException(\"captureDevice\");\n        if (mediaType == null)\n            throw new NullPointerException(\"mediaType\");\n\n        this.captureDevice = captureDevice;\n        this.captureDeviceInfo = captureDevice.getCaptureDeviceInfo();\n        this.mediaType = mediaType;\n    }","id":25413,"modified_method":"/**\n     * Initializes a new <tt>CaptureMediaDevice<\/tt> instance which is to\n     * provide an implementation of <tt>MediaDevice<\/tt> for a specific\n     * <tt>CaptureDevice<\/tt> with a specific <tt>MediaType<\/tt>.\n     *\n     * @param captureDevice the JMF <tt>CaptureDevice<\/tt> the new instance is\n     * to provide an implementation of <tt>MediaDevice<\/tt> for\n     * @param mediaType the <tt>MediaType<\/tt> of the new instance\n     */\n    public CaptureMediaDevice(CaptureDevice captureDevice, MediaType mediaType)\n    {\n        if (captureDevice == null)\n            throw new NullPointerException(\"captureDevice\");\n        if (mediaType == null)\n            throw new NullPointerException(\"mediaType\");\n\n        this.captureDevice = (DataSource) captureDevice;\n        this.captureDeviceInfo = captureDevice.getCaptureDeviceInfo();\n        this.mediaType = mediaType;\n    }","commit_id":"b28c62f5da728ff71d768ba21a5f186a2995af65","url":"https://github.com/jitsi/jitsi"},{"original_method":"public MediaStream createMediaStream(\n            StreamConnector connector,\n            MediaDevice device)\n    {\n        // TODO Auto-generated method stub\n        return null;\n    }","id":25414,"modified_method":"public MediaStream createMediaStream(\n            StreamConnector connector,\n            MediaDevice device)\n    {\n        switch (device.getMediaType())\n        {\n        case AUDIO:\n            return new AudioMediaStreamImpl(connector, device);\n        case VIDEO:\n            return new VideoMediaStreamImpl(connector, device);\n        default:\n            return null;\n        }\n    }","commit_id":"b28c62f5da728ff71d768ba21a5f186a2995af65","url":"https://github.com/jitsi/jitsi"},{"original_method":"public List<MediaDevice> getDevices(MediaType mediaType)\n    {\n        CaptureDeviceInfo[] captureDeviceInfos;\n\n        switch (mediaType)\n        {\n        case AUDIO:\n            captureDeviceInfos\n                = mediaServiceImpl\n                    .getDeviceConfiguration().getAvailableAudioCaptureDevices();\n            break;\n        case VIDEO:\n            captureDeviceInfos\n                = mediaServiceImpl\n                    .getDeviceConfiguration().getAvailableVideoCaptureDevices();\n            break;\n        default:\n            captureDeviceInfos = null;\n            break;\n        }\n\n        List<MediaDevice> captureDevices;\n\n        if ((captureDeviceInfos == null) || (captureDeviceInfos.length == 0))\n            captureDevices = EMPTY_DEVICES;\n        else\n        {\n            captureDevices\n                = new ArrayList<MediaDevice>(captureDeviceInfos.length);\n            for (CaptureDeviceInfo captureDeviceInfo : captureDeviceInfos)\n                captureDevices\n                    .add(new CaptureMediaDevice(captureDeviceInfo, mediaType));\n        }\n        return captureDevices;\n    }","id":25415,"modified_method":"public List<MediaDevice> getDevices(MediaType mediaType)\n    {\n        CaptureDeviceInfo[] captureDeviceInfos;\n\n        switch (mediaType)\n        {\n        case AUDIO:\n            captureDeviceInfos\n                = getDeviceConfiguration().getAvailableAudioCaptureDevices();\n            break;\n        case VIDEO:\n            captureDeviceInfos\n                = getDeviceConfiguration().getAvailableVideoCaptureDevices();\n            break;\n        default:\n            captureDeviceInfos = null;\n            break;\n        }\n\n        List<MediaDevice> captureDevices;\n\n        if ((captureDeviceInfos == null) || (captureDeviceInfos.length == 0))\n            captureDevices = EMPTY_DEVICES;\n        else\n        {\n            captureDevices\n                = new ArrayList<MediaDevice>(captureDeviceInfos.length);\n            for (CaptureDeviceInfo captureDeviceInfo : captureDeviceInfos)\n                captureDevices\n                    .add(new CaptureMediaDevice(captureDeviceInfo, mediaType));\n        }\n        return captureDevices;\n    }","commit_id":"b28c62f5da728ff71d768ba21a5f186a2995af65","url":"https://github.com/jitsi/jitsi"},{"original_method":"public MediaDevice getDefaultDevice(MediaType mediaType)\n    {\n        CaptureDeviceInfo captureDeviceInfo;\n\n        switch (mediaType)\n        {\n        case AUDIO:\n            captureDeviceInfo\n                = mediaServiceImpl\n                    .getDeviceConfiguration().getAudioCaptureDevice();\n            break;\n        case VIDEO:\n            captureDeviceInfo\n                = mediaServiceImpl\n                    .getDeviceConfiguration().getVideoCaptureDevice();\n            break;\n        default:\n            captureDeviceInfo = null;\n            break;\n        }\n\n        return\n            (captureDeviceInfo == null)\n                ? null\n                : new CaptureMediaDevice(captureDeviceInfo, mediaType);\n    }","id":25416,"modified_method":"public MediaDevice getDefaultDevice(MediaType mediaType)\n    {\n        CaptureDeviceInfo captureDeviceInfo;\n\n        switch (mediaType)\n        {\n        case AUDIO:\n            captureDeviceInfo\n                = getDeviceConfiguration().getAudioCaptureDevice();\n            break;\n        case VIDEO:\n            captureDeviceInfo\n                = getDeviceConfiguration().getVideoCaptureDevice();\n            break;\n        default:\n            captureDeviceInfo = null;\n            break;\n        }\n\n        return\n            (captureDeviceInfo == null)\n                ? null\n                : new CaptureMediaDevice(captureDeviceInfo, mediaType);\n    }","commit_id":"b28c62f5da728ff71d768ba21a5f186a2995af65","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void setup() throws IOException, TTransportException {\n    if (mZookeeperMode) {\n      mEditLogProcessor.stop();\n    }\n    mMasterInfo.init();\n\n    mWebServer =\n        new UIWebServer(\"Tachyon Master Server\", new InetSocketAddress(\n            mMasterAddress.getHostName(), mWebPort), mMasterInfo);\n\n    mMasterServiceHandler = new MasterServiceHandler(mMasterInfo);\n    MasterService.Processor<MasterServiceHandler> masterServiceProcessor =\n        new MasterService.Processor<MasterServiceHandler>(mMasterServiceHandler);\n\n    // TODO This is for Thrift 0.8 or newer.\n    // mServer = new TThreadedSelectorServer(new TThreadedSelectorServer\n    // .Args(new TNonblockingServerSocket(address)).processor(processor)\n    // .selectorThreads(selectorThreads).acceptQueueSizePerThread(acceptQueueSizePerThreads)\n    // .workerThreads(workerThreads));\n\n    // This is for Thrift 0.7.0, for Hive compatibility.\n    mMasterServiceServer =\n        new THsHaServer(new THsHaServer.Args(new TNonblockingServerSocket(mMasterAddress))\n            .processor(masterServiceProcessor).workerThreads(mWorkerThreads));\n\n    mIsStarted = true;\n  }","id":25417,"modified_method":"private void setup() throws IOException, TTransportException {\n    if (mZookeeperMode) {\n      mEditLogProcessor.stop();\n    }\n    mMasterInfo.init();\n\n    mWebServer =\n        new UIWebServer(\"Tachyon Master Server\", new InetSocketAddress(\n            mMasterAddress.getHostName(), mWebPort), mMasterInfo);\n\n    mMasterServiceHandler = new MasterServiceHandler(mMasterInfo);\n    MasterService.Processor<MasterServiceHandler> masterServiceProcessor =\n        new MasterService.Processor<MasterServiceHandler>(mMasterServiceHandler);\n\n    mMasterServiceServer =\n        new TThreadedSelectorServer(new TThreadedSelectorServer.Args(new TNonblockingServerSocket(\n            mMasterAddress)).processor(masterServiceProcessor).selectorThreads(mSelectorThreads)\n            .acceptQueueSizePerThread(mAcceptQueueSizePerThread).workerThreads(mWorkerThreads));\n\n    mIsStarted = true;\n  }","commit_id":"968d86b53d4e6598757202cfcb27a7eef599c377","url":"https://github.com/amplab/tachyon"},{"original_method":"public TachyonMaster(InetSocketAddress address, int webPort, int selectorThreads,\n      int acceptQueueSizePerThreads, int workerThreads) {\n    if (CommonConf.get().USE_ZOOKEEPER) {\n      mZookeeperMode = true;\n    }\n\n    mIsStarted = false;\n    mWebPort = webPort;\n    mWorkerThreads = workerThreads;\n\n    try {\n      mMasterAddress = address;\n      String journalFolder = MasterConf.get().JOURNAL_FOLDER;\n      if (!isFormatted(journalFolder, MasterConf.get().FORMAT_FILE_PREFIX)) {\n        LOG.error(\"Tachyon was not formatted!\");\n        System.exit(-1);\n      }\n      mJournal = new Journal(journalFolder, \"image.data\", \"log.data\");\n      mMasterInfo = new MasterInfo(mMasterAddress, mJournal);\n\n      if (mZookeeperMode) {\n        CommonConf conf = CommonConf.get();\n        mLeaderSelectorClient =\n            new LeaderSelectorClient(conf.ZOOKEEPER_ADDRESS, conf.ZOOKEEPER_ELECTION_PATH,\n                conf.ZOOKEEPER_LEADER_PATH, address.getHostName() + \":\" + address.getPort());\n        mEditLogProcessor = new EditLogProcessor(mJournal, journalFolder, mMasterInfo);\n        Thread logProcessor = new Thread(mEditLogProcessor);\n        logProcessor.start();\n      }\n    } catch (Exception e) {\n      LOG.error(e.getMessage(), e);\n      System.exit(-1);\n    }\n  }","id":25418,"modified_method":"public TachyonMaster(InetSocketAddress address, int webPort, int selectorThreads,\n      int acceptQueueSizePerThreads, int workerThreads) {\n    if (CommonConf.get().USE_ZOOKEEPER) {\n      mZookeeperMode = true;\n    }\n\n    mIsStarted = false;\n    mWebPort = webPort;\n    mSelectorThreads = selectorThreads;\n    mAcceptQueueSizePerThread = acceptQueueSizePerThreads;\n    mWorkerThreads = workerThreads;\n\n    try {\n      mMasterAddress = address;\n      String journalFolder = MasterConf.get().JOURNAL_FOLDER;\n      if (!isFormatted(journalFolder, MasterConf.get().FORMAT_FILE_PREFIX)) {\n        LOG.error(\"Tachyon was not formatted!\");\n        System.exit(-1);\n      }\n      mJournal = new Journal(journalFolder, \"image.data\", \"log.data\");\n      mMasterInfo = new MasterInfo(mMasterAddress, mJournal);\n\n      if (mZookeeperMode) {\n        CommonConf conf = CommonConf.get();\n        mLeaderSelectorClient =\n            new LeaderSelectorClient(conf.ZOOKEEPER_ADDRESS, conf.ZOOKEEPER_ELECTION_PATH,\n                conf.ZOOKEEPER_LEADER_PATH, address.getHostName() + \":\" + address.getPort());\n        mEditLogProcessor = new EditLogProcessor(mJournal, journalFolder, mMasterInfo);\n        Thread logProcessor = new Thread(mEditLogProcessor);\n        logProcessor.start();\n      }\n    } catch (Exception e) {\n      LOG.error(e.getMessage(), e);\n      System.exit(-1);\n    }\n  }","commit_id":"968d86b53d4e6598757202cfcb27a7eef599c377","url":"https://github.com/amplab/tachyon"},{"original_method":"private TachyonWorker(InetSocketAddress masterAddress, InetSocketAddress workerAddress,\n      int dataPort, int selectorThreads, int acceptQueueSizePerThreads, int workerThreads,\n      String dataFolder, long memoryCapacityBytes) {\n    MasterAddress = masterAddress;\n    WorkerAddress = workerAddress;\n\n    mWorkerStorage =\n        new WorkerStorage(MasterAddress, WorkerAddress, dataFolder, memoryCapacityBytes);\n\n    mWorkerServiceHandler = new WorkerServiceHandler(mWorkerStorage);\n\n    mDataServer =\n        new DataServer(new InetSocketAddress(workerAddress.getHostName(), dataPort),\n            mWorkerStorage);\n    mDataServerThread = new Thread(mDataServer);\n\n    mHeartbeatThread = new Thread(this);\n    try {\n      LOG.info(\"The worker server tries to start @ \" + workerAddress);\n      WorkerService.Processor<WorkerServiceHandler> processor =\n          new WorkerService.Processor<WorkerServiceHandler>(mWorkerServiceHandler);\n\n      // TODO This is for Thrift 0.8 or newer.\n      // mServer = new TThreadedSelectorServer(new TThreadedSelectorServer\n      // .Args(new TNonblockingServerSocket(workerAddress)).processor(processor)\n      // .selectorThreads(selectorThreads).acceptQueueSizePerThread(acceptQueueSizePerThreads)\n      // .workerThreads(workerThreads));\n\n      // This is for Thrift 0.7.0, for Hive compatibility.\n      mServerTNonblockingServerSocket = new TNonblockingServerSocket(workerAddress);\n      mServer =\n          new THsHaServer(new THsHaServer.Args(mServerTNonblockingServerSocket).processor(\n              processor).workerThreads(workerThreads));\n    } catch (TTransportException e) {\n      LOG.error(e.getMessage(), e);\n      CommonUtils.runtimeException(e);\n    }\n  }","id":25419,"modified_method":"private TachyonWorker(InetSocketAddress masterAddress, InetSocketAddress workerAddress,\n      int dataPort, int selectorThreads, int acceptQueueSizePerThreads, int workerThreads,\n      String dataFolder, long memoryCapacityBytes) {\n    MasterAddress = masterAddress;\n    WorkerAddress = workerAddress;\n\n    mWorkerStorage =\n        new WorkerStorage(MasterAddress, WorkerAddress, dataFolder, memoryCapacityBytes);\n\n    mWorkerServiceHandler = new WorkerServiceHandler(mWorkerStorage);\n\n    mDataServer =\n        new DataServer(new InetSocketAddress(workerAddress.getHostName(), dataPort),\n            mWorkerStorage);\n    mDataServerThread = new Thread(mDataServer);\n\n    mHeartbeatThread = new Thread(this);\n    try {\n      LOG.info(\"The worker server tries to start @ \" + workerAddress);\n      WorkerService.Processor<WorkerServiceHandler> processor =\n          new WorkerService.Processor<WorkerServiceHandler>(mWorkerServiceHandler);\n\n      mServer =\n          new TThreadedSelectorServer(new TThreadedSelectorServer.Args(\n              new TNonblockingServerSocket(workerAddress)).processor(processor)\n              .selectorThreads(selectorThreads)\n              .acceptQueueSizePerThread(acceptQueueSizePerThreads).workerThreads(workerThreads));\n    } catch (TTransportException e) {\n      LOG.error(e.getMessage(), e);\n      CommonUtils.runtimeException(e);\n    }\n  }","commit_id":"968d86b53d4e6598757202cfcb27a7eef599c377","url":"https://github.com/amplab/tachyon"},{"original_method":"public TServer buildTServer(Args args)\n        {\n            if (DatabaseDescriptor.getClientEncryptionOptions().enabled)\n                throw new RuntimeException(\"Client SSL is not supported for non-blocking sockets (hsha). Please remove client ssl from the configuration.\");\n\n            final InetSocketAddress addr = args.addr;\n            TNonblockingServerTransport serverTransport;\n            try\n            {\n                serverTransport = new TCustomNonblockingServerSocket(addr, args.keepAlive, args.sendBufferSize, args.recvBufferSize);\n            }\n            catch (TTransportException e)\n            {\n                throw new RuntimeException(String.format(\"Unable to create thrift socket to %s:%s\", addr.getAddress(), addr.getPort()), e);\n            }\n\n            // This is NIO selector service but the invocation will be Multi-Threaded with the Executor service.\n            ExecutorService executorService = new JMXEnabledThreadPoolExecutor(DatabaseDescriptor.getRpcMinThreads(),\n                                                                               DatabaseDescriptor.getRpcMaxThreads(),\n                                                                               60L,\n                                                                               TimeUnit.SECONDS,\n                                                                               new SynchronousQueue<Runnable>(),\n                                                                               new NamedThreadFactory(\"RPC-Thread\"), \"RPC-THREAD-POOL\");\n           THsHaServer.Args serverArgs = new THsHaServer.Args(serverTransport).inputTransportFactory(args.inTransportFactory)\n                                                                               .outputTransportFactory(args.outTransportFactory)\n                                                                               .inputProtocolFactory(args.tProtocolFactory)\n                                                                               .outputProtocolFactory(args.tProtocolFactory)\n                                                                               .processor(args.processor)\n                                                                               .executorService(executorService);\n            // Check for available processors in the system which will be equal to the IO Threads.\n            return new CustomTHsHaServer(serverArgs);\n        }","id":25420,"modified_method":"public TServer buildTServer(Args args)\n        {\n            if (DatabaseDescriptor.getClientEncryptionOptions().enabled)\n                throw new RuntimeException(\"Client SSL is not supported for non-blocking sockets (hsha). Please remove client ssl from the configuration.\");\n\n            final InetSocketAddress addr = args.addr;\n            TNonblockingServerTransport serverTransport;\n            try\n            {\n                serverTransport = new TCustomNonblockingServerSocket(addr, args.keepAlive, args.sendBufferSize, args.recvBufferSize);\n            }\n            catch (TTransportException e)\n            {\n                throw new RuntimeException(String.format(\"Unable to create thrift socket to %s:%s\", addr.getAddress(), addr.getPort()), e);\n            }\n\n            // This is NIO selector service but the invocation will be Multi-Threaded with the Executor service.\n            ExecutorService executorService = new JMXEnabledThreadPoolExecutor(DatabaseDescriptor.getRpcMinThreads(),\n                                                                               DatabaseDescriptor.getRpcMaxThreads(),\n                                                                               60L,\n                                                                               TimeUnit.SECONDS,\n                                                                               new SynchronousQueue<Runnable>(),\n                                                                               new NamedThreadFactory(\"RPC-Thread\"), \"RPC-THREAD-POOL\");\n           TThreadedSelectorServer.Args serverArgs = new TThreadedSelectorServer.Args(serverTransport).inputTransportFactory(args.inTransportFactory)\n                                                                               .outputTransportFactory(args.outTransportFactory)\n                                                                               .inputProtocolFactory(args.tProtocolFactory)\n                                                                               .outputProtocolFactory(args.tProtocolFactory)\n                                                                               .processor(args.processor)\n                                                                               .selectorThreads(Runtime.getRuntime().availableProcessors())\n                                                                               .executorService(executorService);\n            // Check for available processors in the system which will be equal to the IO Threads.\n            return new CustomTHsHaServer(serverArgs);\n        }","commit_id":"5dad16045eaa71240b4d190ee9166ef7b1db2788","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Executes the compiler on the parsed arguments\n     */\n    @NotNull\n    public ExitCode exec(final PrintStream errStream, A arguments) {\n        if (arguments.isHelp()) {\n            usage(errStream);\n            return OK;\n        }\n        System.setProperty(\"java.awt.headless\", \"true\");\n        final MessageRenderer messageRenderer = getMessageRenderer(arguments);\n        errStream.print(messageRenderer.renderPreamble());\n        printVersionIfNeeded(errStream, arguments, messageRenderer);\n        try {\n            return doExecute(errStream, arguments, messageRenderer);\n        }\n        finally {\n            errStream.print(messageRenderer.renderConclusion());\n        }\n    }","id":25421,"modified_method":"/**\n     * Executes the compiler on the parsed arguments\n     */\n    @NotNull\n    public ExitCode exec(final PrintStream errStream, A arguments) {\n        if (arguments.isHelp()) {\n            usage(errStream);\n            return OK;\n        }\n        System.setProperty(\"java.awt.headless\", \"true\");\n        final MessageRenderer messageRenderer = getMessageRenderer(arguments);\n        errStream.print(messageRenderer.renderPreamble());\n        printVersionIfNeeded(errStream, arguments, messageRenderer);\n        PrintingMessageCollector messageCollector = new PrintingMessageCollector(errStream, messageRenderer, true);\n        Disposable rootDisposable = CompileEnvironmentUtil.createMockDisposable();\n        try {\n            return doExecute(arguments, messageCollector, rootDisposable);\n        }\n        finally {\n            messageCollector.printToErrStream();\n            errStream.print(messageRenderer.renderConclusion());\n            Disposer.dispose(rootDisposable);\n        }\n    }","commit_id":"3e3a22a5c92dbda5572e6f78eff5c12b4f5c728b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private MessageRenderer getMessageRenderer(@NotNull A arguments) {\n        return arguments.isTags() ? MessageRenderer.TAGS : MessageRenderer.PLAIN;\n    }","id":25422,"modified_method":"@NotNull\n    protected MessageRenderer getMessageRenderer(@NotNull A arguments) {\n        return arguments.isTags() ? MessageRenderer.TAGS : MessageRenderer.PLAIN;\n    }","commit_id":"3e3a22a5c92dbda5572e6f78eff5c12b4f5c728b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private static Integer execInProcess(@NotNull CompileContext context,\n            @NotNull CompilerEnvironment environment, @NotNull PrintStream out, @NotNull Module module) {\n        try {\n            VirtualFile[] roots = ModuleRootManager.getInstance(module).getSourceRoots();\n            if (roots.length != 1) {\n                context.addMessage(CompilerMessageCategory.ERROR, \"K2JSCompiler does not support module source roots.\", null, -1, -1);\n                return -1;\n            }\n            String[] commandLineArgs = {\"-tags\", \"-verbose\", \"-version\", \"-srcdir\", roots[0].getPath()};\n            Object rc = invokeExecMethod(environment, out, context, commandLineArgs, \"org.jetbrains.jet.cli.js.K2JSCompiler\");\n            return CompilerUtils.getReturnCodeFromObject(rc);\n        }\n        catch (Throwable e) {\n            context.addMessage(CompilerMessageCategory.ERROR, \"Fail!\", null, -1, -1);\n        }\n        return -1;\n    }","id":25423,"modified_method":"@NotNull\n    private static Integer execInProcess(@NotNull CompileContext context,\n            @NotNull CompilerEnvironment environment, @NotNull PrintStream out, @NotNull Module module) {\n        try {\n            VirtualFile[] roots = ModuleRootManager.getInstance(module).getSourceRoots();\n            if (roots.length != 1) {\n                context.addMessage(CompilerMessageCategory.ERROR, \"K2JSCompiler does not support multiple module source roots.\", null, -1,\n                                   -1);\n                return -1;\n            }\n            String[] commandLineArgs = constructArguments(context.getModuleOutputDirectory(module), roots[0]);\n            Object rc = invokeExecMethod(environment, out, context, commandLineArgs, \"org.jetbrains.jet.cli.js.K2JSCompiler\");\n            return CompilerUtils.getReturnCodeFromObject(rc);\n        }\n        catch (Throwable e) {\n             context.addMessage(CompilerMessageCategory.ERROR, \"Exception while executing: \" + e.getMessage(), null, -1, -1);\n        }\n        return -1;\n    }","commit_id":"3e3a22a5c92dbda5572e6f78eff5c12b4f5c728b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    protected ExitCode doExecute(PrintStream stream, K2JSCompilerArguments arguments, MessageRenderer renderer) {\n        PrintingMessageCollector messageCollector = new PrintingMessageCollector(stream, renderer, true);\n        if (arguments.module != null) {\n            stream.print(renderer.render(CompilerMessageSeverity.ERROR, \"Module arg is not supported\", NO_LOCATION));\n            return ExitCode.INTERNAL_ERROR;\n        }\n\n        if (arguments.srcdir == null) {\n            stream.print(renderer.render(CompilerMessageSeverity.ERROR, \"Specify sources location via -srcdir\", NO_LOCATION));\n            return ExitCode.INTERNAL_ERROR;\n        }\n\n        Disposable rootDisposable = CompileEnvironmentUtil.createMockDisposable();\n        final JetCoreEnvironment environmentForJS = JetCoreEnvironment.getCoreEnvironmentForJS(rootDisposable);\n        environmentForJS.addSources(arguments.srcdir);\n        AnalyzerWithCompilerReport analyzerWithCompilerReport = new AnalyzerWithCompilerReport(messageCollector);\n        final List<JetFile> sources = environmentForJS.getSourceFiles();\n        analyzerWithCompilerReport.analyzeAndReport(new Function0<AnalyzeExhaust>() {\n            @Override\n            public AnalyzeExhaust invoke() {\n                BindingContext context = AnalyzerFacadeForJS\n                        .analyzeFiles(sources, Predicates.<PsiFile>alwaysTrue(), new Config(environmentForJS.getProject()) {\n                            @NotNull\n                            @Override\n                            protected List<JetFile> generateLibFiles() {\n                                return Collections.emptyList();\n                            }\n                        });\n                return AnalyzeExhaust.success(context, JetStandardLibrary.getInstance());\n            }\n        }, sources);\n\n        stream.print(renderer.render(CompilerMessageSeverity.ERROR, \"Greeting\", NO_LOCATION));\n        return ExitCode.OK;\n    }","id":25424,"modified_method":"@NotNull\n    @Override\n    protected ExitCode doExecute(K2JSCompilerArguments arguments, PrintingMessageCollector messageCollector, Disposable rootDisposable) {\n\n        if (arguments.srcdir == null) {\n            messageCollector.report(CompilerMessageSeverity.ERROR, \"Specify sources location via -srcdir\", NO_LOCATION);\n            return ExitCode.INTERNAL_ERROR;\n        }\n\n        final JetCoreEnvironment environmentForJS = JetCoreEnvironment.getCoreEnvironmentForJS(rootDisposable);\n        environmentForJS.addSources(arguments.srcdir);\n        AnalyzerWithCompilerReport analyzerWithCompilerReport = new AnalyzerWithCompilerReport(messageCollector);\n        final List<JetFile> sources = environmentForJS.getSourceFiles();\n        final Config config = Config.getEmptyConfig(environmentForJS.getProject());\n        analyzerWithCompilerReport.analyzeAndReport(new Function0<AnalyzeExhaust>() {\n            @Override\n            public AnalyzeExhaust invoke() {\n                BindingContext context = AnalyzerFacadeForJS\n                        .analyzeFiles(sources, Predicates.<PsiFile>alwaysTrue(), config);\n                return AnalyzeExhaust.success(context, JetStandardLibrary.getInstance());\n            }\n        }, sources);\n        if (analyzerWithCompilerReport.hasErrors()) {\n\n            return ExitCode.COMPILATION_ERROR;\n        }\n\n        if (arguments.outputDir != null) {\n            try {\n                K2JSTranslator.translateWithCallToMainAndSaveToFile(environmentForJS.getSourceFiles(), arguments.outputDir, config, environmentForJS.getProject());\n            }\n            catch (Exception e) {\n                return ExitCode.INTERNAL_ERROR;\n            }\n        } else {\n            messageCollector.report(CompilerMessageSeverity.ERROR, \"Specify output directory via -output\", CompilerMessageLocation.NO_LOCATION);\n            return ExitCode.INTERNAL_ERROR;\n        }\n        return ExitCode.OK;\n    }","commit_id":"3e3a22a5c92dbda5572e6f78eff5c12b4f5c728b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    @NotNull\n    protected ExitCode doExecute(PrintStream errStream,\n            K2JVMCompilerArguments arguments,\n            MessageRenderer messageRenderer) {\n\n        CompilerSpecialMode mode = parseCompilerSpecialMode(arguments);\n        File jdkHeadersJar;\n        if (mode.includeJdkHeaders()) {\n            if (arguments.jdkHeaders != null) {\n                jdkHeadersJar = new File(arguments.jdkHeaders);\n            }\n            else {\n                jdkHeadersJar = PathUtil.getAltHeadersPath();\n            }\n        }\n        else {\n            jdkHeadersJar = null;\n        }\n        File runtimeJar;\n\n        if (mode.includeKotlinRuntime()) {\n            if (arguments.stdlib != null) {\n                runtimeJar = new File(arguments.stdlib);\n            }\n            else {\n                runtimeJar = PathUtil.getDefaultRuntimePath();\n            }\n        }\n        else {\n            runtimeJar = null;\n        }\n\n        CompilerDependencies dependencies = new CompilerDependencies(mode, CompilerDependencies.findRtJar(), jdkHeadersJar, runtimeJar);\n        PrintingMessageCollector messageCollector = new PrintingMessageCollector(errStream, messageRenderer, arguments.verbose);\n        Disposable rootDisposable = CompileEnvironmentUtil.createMockDisposable();\n\n        JetCoreEnvironment environment = JetCoreEnvironment.getCoreEnvironmentForJVM(rootDisposable, dependencies);\n        K2JVMCompileEnvironmentConfiguration configuration =\n                new K2JVMCompileEnvironmentConfiguration(environment, messageCollector);\n\n        messageCollector.report(CompilerMessageSeverity.LOGGING, \"Configuring the compilation environment\",\n                                CompilerMessageLocation.NO_LOCATION);\n        try {\n            configureEnvironment(configuration, arguments);\n\n            boolean noErrors;\n            if (arguments.module != null) {\n                List<Module> modules = CompileEnvironmentUtil\n                        .loadModuleScript(arguments.module, new PrintingMessageCollector(errStream, messageRenderer, false));\n                File directory = new File(arguments.module).getParentFile();\n                noErrors = KotlinToJVMBytecodeCompiler.compileModules(configuration, modules,\n                                                                      directory, arguments.jar, arguments.outputDir,\n                                                                      arguments.includeRuntime);\n            }\n            else {\n                // TODO ideally we'd unify to just having a single field that supports multiple files/dirs\n                if (arguments.getSourceDirs() != null) {\n                    noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSourceDirectories(configuration,\n                                                                                           arguments.getSourceDirs(), arguments.jar,\n                                                                                           arguments.outputDir,\n                                                                                           arguments.includeRuntime);\n                }\n                else {\n                    noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSources(configuration,\n                                                                                 arguments.src, arguments.jar, arguments.outputDir,\n                                                                                 arguments.includeRuntime);\n                }\n            }\n            return noErrors ? OK : COMPILATION_ERROR;\n        }\n        catch (CompilationException e) {\n            messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(e),\n                                    MessageUtil.psiElementToMessageLocation(e.getElement()));\n            return INTERNAL_ERROR;\n        }\n        catch (Throwable t) {\n            messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(t),\n                                    CompilerMessageLocation.NO_LOCATION);\n            return INTERNAL_ERROR;\n        }\n        finally {\n            Disposer.dispose(rootDisposable);\n            messageCollector.printToErrStream();\n        }\n    }","id":25425,"modified_method":"@Override\n    @NotNull\n    protected ExitCode doExecute(K2JVMCompilerArguments arguments, PrintingMessageCollector messageCollector, Disposable rootDisposable) {\n\n        CompilerSpecialMode mode = parseCompilerSpecialMode(arguments);\n        File jdkHeadersJar;\n        if (mode.includeJdkHeaders()) {\n            if (arguments.jdkHeaders != null) {\n                jdkHeadersJar = new File(arguments.jdkHeaders);\n            }\n            else {\n                jdkHeadersJar = PathUtil.getAltHeadersPath();\n            }\n        }\n        else {\n            jdkHeadersJar = null;\n        }\n        File runtimeJar;\n\n        if (mode.includeKotlinRuntime()) {\n            if (arguments.stdlib != null) {\n                runtimeJar = new File(arguments.stdlib);\n            }\n            else {\n                runtimeJar = PathUtil.getDefaultRuntimePath();\n            }\n        }\n        else {\n            runtimeJar = null;\n        }\n\n        CompilerDependencies dependencies = new CompilerDependencies(mode, CompilerDependencies.findRtJar(), jdkHeadersJar, runtimeJar);\n        JetCoreEnvironment environment = JetCoreEnvironment.getCoreEnvironmentForJVM(rootDisposable, dependencies);\n        K2JVMCompileEnvironmentConfiguration configuration =\n                new K2JVMCompileEnvironmentConfiguration(environment, messageCollector);\n\n        messageCollector.report(CompilerMessageSeverity.LOGGING, \"Configuring the compilation environment\",\n                                CompilerMessageLocation.NO_LOCATION);\n        try {\n            configureEnvironment(configuration, arguments);\n\n            boolean noErrors;\n            if (arguments.module != null) {\n                boolean oldVerbose = messageCollector.isVerbose();\n                messageCollector.setVerbose(false);\n                List<Module> modules = CompileEnvironmentUtil\n                        .loadModuleScript(arguments.module, messageCollector);\n                messageCollector.setVerbose(oldVerbose);\n                File directory = new File(arguments.module).getParentFile();\n                noErrors = KotlinToJVMBytecodeCompiler.compileModules(configuration, modules,\n                                                                      directory, arguments.jar, arguments.outputDir,\n                                                                      arguments.includeRuntime);\n            }\n            else {\n                // TODO ideally we'd unify to just having a single field that supports multiple files/dirs\n                if (arguments.getSourceDirs() != null) {\n                    noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSourceDirectories(configuration,\n                                                                                           arguments.getSourceDirs(), arguments.jar,\n                                                                                           arguments.outputDir,\n                                                                                           arguments.includeRuntime);\n                }\n                else {\n                    noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSources(configuration,\n                                                                                 arguments.src, arguments.jar, arguments.outputDir,\n                                                                                 arguments.includeRuntime);\n                }\n            }\n            return noErrors ? OK : COMPILATION_ERROR;\n        }\n        catch (CompilationException e) {\n            messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(e),\n                                    MessageUtil.psiElementToMessageLocation(e.getElement()));\n            return INTERNAL_ERROR;\n        }\n        catch (Throwable t) {\n            messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(t),\n                                    CompilerMessageLocation.NO_LOCATION);\n            return INTERNAL_ERROR;\n        }\n    }","commit_id":"3e3a22a5c92dbda5572e6f78eff5c12b4f5c728b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public ExitCode exec(@NotNull MessageCollector messageCollector, @NotNull Services services, @NotNull A arguments) {\n        GroupingMessageCollector groupingCollector = new GroupingMessageCollector(messageCollector);\n        try {\n            Disposable rootDisposable = Disposer.newDisposable();\n            try {\n                MessageSeverityCollector severityCollector = new MessageSeverityCollector(groupingCollector);\n                ExitCode code = doExecute(arguments, services, severityCollector, rootDisposable);\n                return severityCollector.anyReported(CompilerMessageSeverity.ERROR) ? COMPILATION_ERROR : code;\n            }\n            finally {\n                Disposer.dispose(rootDisposable);\n            }\n        }\n        catch (Throwable t) {\n            groupingCollector.report(CompilerMessageSeverity.EXCEPTION, OutputMessageUtil.renderException(t),\n                                     CompilerMessageLocation.NO_LOCATION);\n            return INTERNAL_ERROR;\n        }\n        finally {\n            groupingCollector.flush();\n        }\n    }","id":25426,"modified_method":"@NotNull\n    public ExitCode exec(@NotNull MessageCollector messageCollector, @NotNull Services services, @NotNull A arguments) {\n        printVersionIfNeeded(messageCollector, arguments);\n\n        if (arguments.suppressWarnings) {\n            messageCollector = new FilteringMessageCollector(messageCollector, Predicates.equalTo(CompilerMessageSeverity.WARNING));\n        }\n\n        GroupingMessageCollector groupingCollector = new GroupingMessageCollector(messageCollector);\n        try {\n            Disposable rootDisposable = Disposer.newDisposable();\n            try {\n                MessageSeverityCollector severityCollector = new MessageSeverityCollector(groupingCollector);\n                ExitCode code = doExecute(arguments, services, severityCollector, rootDisposable);\n                return severityCollector.anyReported(CompilerMessageSeverity.ERROR) ? COMPILATION_ERROR : code;\n            }\n            finally {\n                Disposer.dispose(rootDisposable);\n            }\n        }\n        catch (Throwable t) {\n            groupingCollector.report(CompilerMessageSeverity.EXCEPTION, OutputMessageUtil.renderException(t),\n                                     CompilerMessageLocation.NO_LOCATION);\n            return INTERNAL_ERROR;\n        }\n        finally {\n            groupingCollector.flush();\n        }\n    }","commit_id":"9e11b40fe12a8f287e715df112e5ed73033efd15","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private ExitCode exec(\n            @NotNull PrintStream errStream,\n            @NotNull Services services,\n            @NotNull MessageRenderer messageRenderer,\n            @NotNull String[] args\n    ) {\n        A arguments = parseArguments(errStream, messageRenderer, args);\n        if (arguments == null) {\n            return INTERNAL_ERROR;\n        }\n\n        if (arguments.help || arguments.extraHelp) {\n            usage(errStream, arguments.extraHelp);\n            return OK;\n        }\n\n        errStream.print(messageRenderer.renderPreamble());\n\n        printVersionIfNeeded(errStream, arguments, messageRenderer);\n\n        MessageCollector collector = new PrintingMessageCollector(errStream, messageRenderer, arguments.verbose);\n\n        if (arguments.suppressWarnings) {\n            collector = new FilteringMessageCollector(collector, Predicates.equalTo(CompilerMessageSeverity.WARNING));\n        }\n\n        try {\n            return exec(collector, services, arguments);\n        }\n        finally {\n            errStream.print(messageRenderer.renderConclusion());\n        }\n    }","id":25427,"modified_method":"@NotNull\n    private ExitCode exec(\n            @NotNull PrintStream errStream,\n            @NotNull Services services,\n            @NotNull MessageRenderer messageRenderer,\n            @NotNull String[] args\n    ) {\n        A arguments = parseArguments(errStream, messageRenderer, args);\n        if (arguments == null) {\n            return INTERNAL_ERROR;\n        }\n\n        if (arguments.help || arguments.extraHelp) {\n            usage(errStream, arguments.extraHelp);\n            return OK;\n        }\n\n        errStream.print(messageRenderer.renderPreamble());\n\n        MessageCollector collector = new PrintingMessageCollector(errStream, messageRenderer, arguments.verbose);\n\n        try {\n            return exec(collector, services, arguments);\n        }\n        finally {\n            errStream.print(messageRenderer.renderConclusion());\n        }\n    }","commit_id":"9e11b40fe12a8f287e715df112e5ed73033efd15","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected void printVersionIfNeeded(\n            @NotNull PrintStream errStream,\n            @NotNull A arguments,\n            @NotNull MessageRenderer messageRenderer\n    ) {\n        if (arguments.version) {\n            String versionMessage = messageRenderer.render(CompilerMessageSeverity.INFO,\n                                                           \"Kotlin Compiler version \" + KotlinVersion.VERSION,\n                                                           CompilerMessageLocation.NO_LOCATION);\n            errStream.println(versionMessage);\n        }\n    }","id":25428,"modified_method":"protected void printVersionIfNeeded(@NotNull MessageCollector messageCollector, @NotNull A arguments) {\n        if (!arguments.version) return;\n\n        messageCollector.report(CompilerMessageSeverity.INFO,\n                                \"Kotlin Compiler version \" + KotlinVersion.VERSION,\n                                CompilerMessageLocation.NO_LOCATION);\n    }","commit_id":"9e11b40fe12a8f287e715df112e5ed73033efd15","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void configureCompilerArguments(@NotNull A arguments) throws MojoExecutionException {\n        if (LOG.isDebugEnabled()) {\n            arguments.verbose = true;\n        }\n\n        List<String> sources = getSources();\n        if (sources == null || sources.isEmpty()) {\n            throw new MojoExecutionException(\"No source roots to compile\");\n        }\n\n        arguments.freeArgs.addAll(sources);\n        LOG.info(\"Compiling Kotlin sources from \" + sources );\n\n        configureSpecificCompilerArguments(arguments);\n\n        try {\n            Args.parse(arguments, ArrayUtil.toStringArray(args));\n        }\n        catch (IllegalArgumentException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n        if (arguments.noInline) {\n            LOG.info(\"Method inlining is turned off\");\n        }\n    }","id":25429,"modified_method":"private void configureCompilerArguments(@NotNull A arguments) throws MojoExecutionException {\n        if (LOG.isDebugEnabled()) {\n            arguments.verbose = true;\n        }\n\n        List<String> sources = getSources();\n        if (sources == null || sources.isEmpty()) {\n            throw new MojoExecutionException(\"No source roots to compile\");\n        }\n\n        arguments.suppressWarnings = nowarn;\n\n        arguments.freeArgs.addAll(sources);\n        LOG.info(\"Compiling Kotlin sources from \" + sources );\n\n        configureSpecificCompilerArguments(arguments);\n\n        try {\n            Args.parse(arguments, ArrayUtil.toStringArray(args));\n        }\n        catch (IllegalArgumentException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n        if (arguments.noInline) {\n            LOG.info(\"Method inlining is turned off\");\n        }\n    }","commit_id":"9e11b40fe12a8f287e715df112e5ed73033efd15","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected String normalizeOutput(String content) {\n        content = normalizePath(content, getTestDataDir(), \"[TestData]\");\n        content = normalizePath(content, tmpdir.getTmpDir(), \"[Temp]\");\n        content = normalizePath(content, getCompilerLib(), \"[CompilerLib]\");\n        content = StringUtil.convertLineSeparators(content);\n        return content;\n    }","id":25430,"modified_method":"protected String normalizeOutput(String content) {\n        content = normalizePath(content, getTestDataDir(), \"[TestData]\");\n        content = normalizePath(content, tmpdir.getTmpDir(), \"[Temp]\");\n        content = normalizePath(content, getCompilerLib(), \"[CompilerLib]\");\n        content = normalizePath(content, getKotlinProjectHome(), \"[KotlinProjectHome]\");\n        content = content.replaceAll(KotlinVersion.VERSION, \"[KotlinVersion]\");\n        content = StringUtil.convertLineSeparators(content);\n        return content;\n    }","commit_id":"9e11b40fe12a8f287e715df112e5ed73033efd15","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Method to get the source paths. If no source path is specified in the parameter, the compile source roots\n     * of the project will be used.\n     *\n     * @return a List of the project source paths\n     */\n    protected List getSourcePaths()\n    {\n        List sourcePaths;\n\n        if ( StringUtils.isEmpty( sourcepath ) )\n        {\n            sourcePaths = new ArrayList( getProjectSourceRoots( project ) );\n\n            if ( project.getExecutionProject() != null )\n            {\n                sourcePaths.addAll( getExecutionProjectSourceRoots( project ) );\n            }\n\n            if ( getJavadocDirectory() != null )\n            {\n                File javadocDir = new File( getJavadocDirectory() );\n                if ( javadocDir.exists() && javadocDir.isDirectory() )\n                {\n                    sourcePaths.add( getJavadocDirectory() );\n                }\n            }\n\n            if ( aggregate && project.isExecutionRoot() )\n            {\n                for ( Iterator i = reactorProjects.iterator(); i.hasNext(); )\n                {\n                    MavenProject subProject = (MavenProject) i.next();\n\n                    if ( subProject != project )\n                    {\n                        List sourceRoots = getProjectSourceRoots( subProject );\n\n                        if ( subProject.getExecutionProject() != null )\n                        {\n                            sourceRoots.addAll( getExecutionProjectSourceRoots( subProject ) );\n                        }\n\n                        ArtifactHandler artifactHandler = subProject.getArtifact().getArtifactHandler();\n                        if ( \"java\".equals( artifactHandler.getLanguage() ) )\n                        {\n                            sourcePaths.addAll( sourceRoots );\n                        }\n\n                        String javadocDirRelative = PathUtils.toRelative( project.getBasedir(), getJavadocDirectory() );\n                        File javadocDir = new File( subProject.getExecutionProject().getBasedir(), javadocDirRelative );\n                        if ( javadocDir.exists() && javadocDir.isDirectory() )\n                        {\n                            sourcePaths.add( javadocDir.getAbsolutePath() );\n                        }\n                    }\n                }\n            }\n\n            sourcePaths = pruneSourceDirs( sourcePaths );\n        }\n        else\n        {\n            sourcePaths = Arrays.asList( sourcepath.split( \"[;]\" ) );\n        }\n\n        return sourcePaths;\n    }","id":25431,"modified_method":"/**\n     * Method to get the source paths. If no source path is specified in the parameter, the compile source roots\n     * of the project will be used.\n     *\n     * @return a List of the project source paths\n     */\n    protected List getSourcePaths()\n    {\n        List sourcePaths;\n\n        if ( StringUtils.isEmpty( sourcepath ) )\n        {\n            sourcePaths = new ArrayList( getProjectSourceRoots( project ) );\n\n            if ( project.getExecutionProject() != null )\n            {\n                sourcePaths.addAll( getExecutionProjectSourceRoots( project ) );\n            }\n\n            if ( getJavadocDirectory() != null )\n            {\n                File javadocDir = getJavadocDirectory();\n                if ( javadocDir.exists() && javadocDir.isDirectory() )\n                {\n                    sourcePaths.add( getJavadocDirectory().getAbsolutePath() );\n                }\n            }\n\n            if ( aggregate && project.isExecutionRoot() )\n            {\n                for ( Iterator i = reactorProjects.iterator(); i.hasNext(); )\n                {\n                    MavenProject subProject = (MavenProject) i.next();\n\n                    if ( subProject != project )\n                    {\n                        List sourceRoots = getProjectSourceRoots( subProject );\n\n                        if ( subProject.getExecutionProject() != null )\n                        {\n                            sourceRoots.addAll( getExecutionProjectSourceRoots( subProject ) );\n                        }\n\n                        ArtifactHandler artifactHandler = subProject.getArtifact().getArtifactHandler();\n                        if ( \"java\".equals( artifactHandler.getLanguage() ) )\n                        {\n                            sourcePaths.addAll( sourceRoots );\n                        }\n\n                        String javadocDirRelative = PathUtils.toRelative( project.getBasedir(), getJavadocDirectory().getAbsolutePath() );\n                        File javadocDir = new File( subProject.getExecutionProject().getBasedir(), javadocDirRelative );\n                        if ( javadocDir.exists() && javadocDir.isDirectory() )\n                        {\n                            sourcePaths.add( javadocDir.getAbsolutePath() );\n                        }\n                    }\n                }\n            }\n\n            sourcePaths = pruneSourceDirs( sourcePaths );\n        }\n        else\n        {\n            sourcePaths = Arrays.asList( sourcepath.split( \"[;]\" ) );\n        }\n\n        return sourcePaths;\n    }","commit_id":"88d2b7fcca5f38f6fe600eb9c636ba70c9dc3950","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @return the overview documentation file from the user parameter or from the <code>javadocdirectory<\/code>\n     */\n    protected String getOverview()\n    {\n        return overview;\n    }","id":25432,"modified_method":"/**\n     * @return the overview documentation file from the user parameter or from the <code>javadocdirectory<\/code>\n     */\n    protected File getOverview()\n    {\n        return overview;\n    }","commit_id":"88d2b7fcca5f38f6fe600eb9c636ba70c9dc3950","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param locale\n     * @throws MavenReportException\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return;\n        }\n\n        List sourcePaths = getSourcePaths();\n\n        List files = getFiles( sourcePaths );\n\n        List packageNames = getPackageNames( sourcePaths, files );\n\n        List filesWithUnnamedPackages = getFilesWithUnnamedPackages( sourcePaths, files );\n\n        if ( !canGenerateReport( files ) )\n        {\n            return;\n        }\n\n        // ----------------------------------------------------------------------\n        // Find the javadoc executable and version\n        // ----------------------------------------------------------------------\n\n        String jExecutable;\n        try\n        {\n            jExecutable = getJavadocExecutable();\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc command: \" + e.getMessage(), e );\n        }\n\n        float jVersion;\n        try\n        {\n            jVersion = getJavadocVersion( new File( jExecutable ) );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc version: \" + e.getMessage(), e );\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc version: \" + e.getMessage(), e );\n        }\n        if ( StringUtils.isNotEmpty( javadocVersion ) )\n        {\n            try\n            {\n                fJavadocVersion = Float.parseFloat( javadocVersion );\n            }\n            catch ( NumberFormatException e )\n            {\n                throw new MavenReportException( \"Unable to parse javadoc version: \" + e.getMessage(), e );\n            }\n\n            if ( fJavadocVersion != jVersion )\n            {\n                getLog().warn( \"Are you sure about the <javadocVersion/> parameter? It seems to be \" + jVersion );\n            }\n        }\n        else\n        {\n            fJavadocVersion = jVersion;\n        }\n\n        File javadocOutputDirectory = new File( getOutputDirectory() );\n        javadocOutputDirectory.mkdirs();\n\n        // ----------------------------------------------------------------------\n        // Copy default resources\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            copyDefaultStylesheet( javadocOutputDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy default stylesheet: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Copy javadoc resources\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            copyJavadocResources( javadocOutputDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy javadoc resources: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc options\n        // ----------------------------------------------------------------------\n\n        StringBuffer options = new StringBuffer();\n        if ( StringUtils.isNotEmpty( this.locale ) )\n        {\n            options.append( \"-locale \" );\n            options.append( quotedArgument( this.locale ) );\n            options.append( SystemUtils.LINE_SEPARATOR );\n        }\n\n        String classpath = getClasspath();\n        if ( classpath.length() > 0 )\n        {\n            options.append( \"-classpath \" );\n            options.append( quotedPathArgument( classpath ) );\n            options.append( SystemUtils.LINE_SEPARATOR );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc arguments\n        // ----------------------------------------------------------------------\n\n        Commandline cmd = new Commandline();\n\n        // Set the proxy host and port\n        if ( StringUtils.isNotEmpty( proxyHost ) && proxyPort > 0 )\n        {\n            cmd.createArgument().setValue( \"-J-DproxyHost=\" + proxyHost );\n            cmd.createArgument().setValue( \"-J-DproxyPort=\" + proxyPort );\n        }\n\n        addMemoryArg( cmd, \"-Xmx\", this.maxmemory );\n\n        addMemoryArg( cmd, \"-Xms\", this.minmemory );\n\n        if ( StringUtils.isNotEmpty( additionalJOption ) )\n        {\n            cmd.createArgument().setValue( additionalJOption );\n        }\n\n        List arguments = new ArrayList();\n\n        cmd.setWorkingDirectory( javadocOutputDirectory.getAbsolutePath() );\n        cmd.setExecutable( jExecutable );\n\n        // General javadoc arguments\n        addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n        if ( StringUtils.isNotEmpty( doclet ) )\n        {\n            addArgIfNotEmpty( arguments, \"-doclet\", quotedArgument( doclet ) );\n            addArgIfNotEmpty( arguments, \"-docletpath\", quotedPathArgument( getDocletPath() ) );\n        }\n        addArgIfNotEmpty( arguments, \"-encoding\", quotedArgument( encoding ) );\n        addArgIfNotEmpty( arguments, \"-extdirs\", quotedPathArgument( extdirs ) );\n\n        if ( old && isJavaDocVersionAtLeast( SINCE_JAVADOC_1_4 ) )\n        {\n            getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n        }\n        else\n        {\n            addArgIf( arguments, old, \"-1.1\" );\n        }\n\n        if ( ( StringUtils.isNotEmpty( getOverview() ) ) && ( new File( getOverview() ).exists() ) )\n        {\n            addArgIfNotEmpty( arguments, \"-overview\", quotedPathArgument( getOverview() ) );\n        }\n        arguments.add( getAccessLevel() );\n        addArgIf( arguments, quiet, \"-quiet\", SINCE_JAVADOC_1_4 );\n        addArgIfNotEmpty( arguments, \"-source\", quotedArgument( source ), SINCE_JAVADOC_1_4 );\n        addArgIf( arguments, verbose, \"-verbose\" );\n        addArgIfNotEmpty( arguments, null, additionalparam );\n\n        if ( ( StringUtils.isEmpty( sourcepath ) ) && ( StringUtils.isNotEmpty( subpackages ) ) )\n        {\n            sourcepath = StringUtils.join( sourcePaths.iterator(), File.pathSeparator );\n        }\n\n        addArgIfNotEmpty( arguments, \"-sourcepath\", quotedPathArgument( getSourcePath( sourcePaths ) ) );\n\n        if ( StringUtils.isNotEmpty( sourcepath ) )\n        {\n            addArgIfNotEmpty( arguments, \"-subpackages\", subpackages, SINCE_JAVADOC_1_4 );\n        }\n\n        addArgIfNotEmpty( arguments, \"-exclude\", getExcludedPackages( sourcePaths ), SINCE_JAVADOC_1_4 );\n\n        // ----------------------------------------------------------------------\n        // Wrap arguments for default doclet\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isEmpty( doclet ) )\n        {\n            addArgIf( arguments, author, \"-author\" );\n            addArgIfNotEmpty( arguments, \"-bottom\", quotedArgument( getBottomText( project.getInceptionYear() ) ),\n                              false, false );\n            addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-charset\", quotedArgument( charset ) );\n            addArgIfNotEmpty( arguments, \"-d\", quotedPathArgument( javadocOutputDirectory.toString() ) );\n            addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-docencoding\", quotedArgument( docencoding ) );\n            addArgIfNotEmpty( arguments, \"-doctitle\", quotedArgument( getDoctitle() ), false, false );\n            addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", quotedPathArgument( excludedocfilessubdir ),\n                              SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-footer\", quotedArgument( footer ), false, false );\n            if ( groups != null )\n            {\n                for ( int i = 0; i < groups.length; i++ )\n                {\n                    if ( groups[i] == null || StringUtils.isEmpty( groups[i].getTitle() )\n                        || StringUtils.isEmpty( groups[i].getPackages() ) )\n                    {\n                        getLog().info( \"A group option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String groupTitle = StringUtils.replace( groups[i].getTitle(), \",\", \"&#44;\" );\n                        addArgIfNotEmpty( arguments, \"-group\", quotedArgument( groupTitle ) + \" \"\n                            + quotedArgument( groups[i].getPackages() ), true );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-header\", quotedArgument( header ), false, false );\n            addArgIfNotEmpty( arguments, \"-helpfile\", quotedPathArgument( helpfile ) );\n            addArgIf( arguments, keywords, \"-keywords\", SINCE_JAVADOC_1_4_2 );\n\n            if ( !isOffline )\n            {\n                addLinkArguments( arguments );\n            }\n            addLinkofflineArguments( arguments );\n\n            addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n            addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n            addArgIf( arguments, nocomment, \"-nocomment\", SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nohelp, \"-nohelp\" );\n            addArgIf( arguments, noindex, \"-noindex\" );\n            addArgIf( arguments, nonavbar, \"-nonavbar\" );\n            addArgIfNotEmpty( arguments, \"-noqualifier\", quotedArgument( noqualifier ), SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nosince, \"-nosince\" );\n            addArgIf( arguments, notimestamp, \"-notimestamp\", SINCE_JAVADOC_1_5 );\n            addArgIf( arguments, notree, \"-notree\" );\n            addArgIfNotEmpty( arguments, \"-packagesheader\", packagesheader, SINCE_JAVADOC_1_4_2 );\n            addArgIf( arguments, serialwarn, \"-serialwarn\" );\n            addArgIf( arguments, linksource, \"-linksource\", SINCE_JAVADOC_1_4 );\n            if ( fJavadocVersion == SINCE_JAVADOC_1_4_2 )\n            {\n                addArgIfNotEmpty( arguments, \"-linksourcetab\", sourcetab );\n            }\n            else\n            {\n                addArgIfNotEmpty( arguments, \"-sourcetab\", sourcetab, SINCE_JAVADOC_1_5 );\n            }\n            addArgIf( arguments, splitindex, \"-splitindex\" );\n            addArgIfNotEmpty( arguments, \"-stylesheetfile\",\n                              quotedPathArgument( getStylesheetFile( javadocOutputDirectory ) ) );\n\n            addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglet ), SINCE_JAVADOC_1_4 );\n            if ( taglets != null )\n            {\n                for ( int i = 0; i < taglets.length; i++ )\n                {\n                    if ( ( taglets[i] == null ) || ( StringUtils.isEmpty( taglets[i].getTagletClass() ) ) )\n                    {\n                        getLog().info( \"A taglet option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglets[i].getTagletClass() ),\n                                          SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-tagletpath\", quotedPathArgument( getTagletPath() ), SINCE_JAVADOC_1_4 );\n\n            if ( tags != null )\n            {\n                for ( int i = 0; i < tags.length; i++ )\n                {\n                    if ( StringUtils.isEmpty( tags[i].getName() ) )\n                    {\n                        getLog().info( \"A tag name is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String value = \"\\\"\" + tags[i].getName();\n                        if ( StringUtils.isNotEmpty( tags[i].getPlacement() ) )\n                        {\n                            value += \":\" + tags[i].getPlacement();\n                            if ( StringUtils.isNotEmpty( tags[i].getHead() ) )\n                            {\n                                value += \":\" + tags[i].getHead();\n                            }\n                        }\n                        value += \"\\\"\";\n                        addArgIfNotEmpty( arguments, \"-tag\", value, SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n\n            addArgIf( arguments, use, \"-use\" );\n            addArgIf( arguments, version, \"-version\" );\n            addArgIfNotEmpty( arguments, \"-windowtitle\", quotedArgument( getWindowtitle() ), false, false );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write options file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( options.length() > 0 )\n        {\n            addCommandLineOptions( cmd, options, arguments, javadocOutputDirectory );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write packages file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( !packageNames.isEmpty() )\n        {\n            addCommandLinePackages( cmd, javadocOutputDirectory, packageNames );\n\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !filesWithUnnamedPackages.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, filesWithUnnamedPackages );\n            }\n        }\n        else\n        {\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !files.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, files );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Execute command line\n        // ----------------------------------------------------------------------\n\n        getLog().debug( Commandline.toString( cmd.getCommandline() ) );\n\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + Commandline.toString( cmd.getCommandline() ) );\n                throw new MavenReportException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to execute javadoc command: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Handle Javadoc warnings\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( err.getOutput() ) )\n        {\n            getLog().info( \"Javadoc Warnings\" );\n\n            StringTokenizer token = new StringTokenizer( err.getOutput(), \"\\n\" );\n            while ( token.hasMoreTokens() )\n            {\n                String current = token.nextToken().trim();\n\n                getLog().warn( current );\n            }\n        }\n    }","id":25433,"modified_method":"/**\n     * @param locale\n     * @throws MavenReportException\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return;\n        }\n\n        List sourcePaths = getSourcePaths();\n\n        List files = getFiles( sourcePaths );\n\n        List packageNames = getPackageNames( sourcePaths, files );\n\n        List filesWithUnnamedPackages = getFilesWithUnnamedPackages( sourcePaths, files );\n\n        if ( !canGenerateReport( files ) )\n        {\n            return;\n        }\n\n        // ----------------------------------------------------------------------\n        // Find the javadoc executable and version\n        // ----------------------------------------------------------------------\n\n        String jExecutable;\n        try\n        {\n            jExecutable = getJavadocExecutable();\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc command: \" + e.getMessage(), e );\n        }\n\n        float jVersion;\n        try\n        {\n            jVersion = getJavadocVersion( new File( jExecutable ) );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc version: \" + e.getMessage(), e );\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to find javadoc version: \" + e.getMessage(), e );\n        }\n        if ( StringUtils.isNotEmpty( javadocVersion ) )\n        {\n            try\n            {\n                fJavadocVersion = Float.parseFloat( javadocVersion );\n            }\n            catch ( NumberFormatException e )\n            {\n                throw new MavenReportException( \"Unable to parse javadoc version: \" + e.getMessage(), e );\n            }\n\n            if ( fJavadocVersion != jVersion )\n            {\n                getLog().warn( \"Are you sure about the <javadocVersion/> parameter? It seems to be \" + jVersion );\n            }\n        }\n        else\n        {\n            fJavadocVersion = jVersion;\n        }\n\n        File javadocOutputDirectory = new File( getOutputDirectory() );\n        javadocOutputDirectory.mkdirs();\n\n        // ----------------------------------------------------------------------\n        // Copy default resources\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            copyDefaultStylesheet( javadocOutputDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy default stylesheet: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Copy javadoc resources\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            copyJavadocResources( javadocOutputDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy javadoc resources: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc options\n        // ----------------------------------------------------------------------\n\n        StringBuffer options = new StringBuffer();\n        if ( StringUtils.isNotEmpty( this.locale ) )\n        {\n            options.append( \"-locale \" );\n            options.append( quotedArgument( this.locale ) );\n            options.append( SystemUtils.LINE_SEPARATOR );\n        }\n\n        String classpath = getClasspath();\n        if ( classpath.length() > 0 )\n        {\n            options.append( \"-classpath \" );\n            options.append( quotedPathArgument( classpath ) );\n            options.append( SystemUtils.LINE_SEPARATOR );\n        }\n\n        // ----------------------------------------------------------------------\n        // Wrap javadoc arguments\n        // ----------------------------------------------------------------------\n\n        Commandline cmd = new Commandline();\n\n        // Set the proxy host and port\n        if ( StringUtils.isNotEmpty( proxyHost ) && proxyPort > 0 )\n        {\n            cmd.createArgument().setValue( \"-J-DproxyHost=\" + proxyHost );\n            cmd.createArgument().setValue( \"-J-DproxyPort=\" + proxyPort );\n        }\n\n        addMemoryArg( cmd, \"-Xmx\", this.maxmemory );\n\n        addMemoryArg( cmd, \"-Xms\", this.minmemory );\n\n        if ( StringUtils.isNotEmpty( additionalJOption ) )\n        {\n            cmd.createArgument().setValue( additionalJOption );\n        }\n\n        List arguments = new ArrayList();\n\n        cmd.setWorkingDirectory( javadocOutputDirectory.getAbsolutePath() );\n        cmd.setExecutable( jExecutable );\n\n        // General javadoc arguments\n        addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n        if ( StringUtils.isNotEmpty( doclet ) )\n        {\n            addArgIfNotEmpty( arguments, \"-doclet\", quotedArgument( doclet ) );\n            addArgIfNotEmpty( arguments, \"-docletpath\", quotedPathArgument( getDocletPath() ) );\n        }\n        addArgIfNotEmpty( arguments, \"-encoding\", quotedArgument( encoding ) );\n        addArgIfNotEmpty( arguments, \"-extdirs\", quotedPathArgument( extdirs ) );\n\n        if ( old && isJavaDocVersionAtLeast( SINCE_JAVADOC_1_4 ) )\n        {\n            getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n        }\n        else\n        {\n            addArgIf( arguments, old, \"-1.1\" );\n        }\n\n        if ( ( getOverview() != null ) && ( getOverview().exists() ) )\n        {\n            addArgIfNotEmpty( arguments, \"-overview\", quotedPathArgument( getOverview().getAbsolutePath() ) );\n        }\n        arguments.add( getAccessLevel() );\n        addArgIf( arguments, quiet, \"-quiet\", SINCE_JAVADOC_1_4 );\n        addArgIfNotEmpty( arguments, \"-source\", quotedArgument( source ), SINCE_JAVADOC_1_4 );\n        addArgIf( arguments, verbose, \"-verbose\" );\n        addArgIfNotEmpty( arguments, null, additionalparam );\n\n        if ( ( StringUtils.isEmpty( sourcepath ) ) && ( StringUtils.isNotEmpty( subpackages ) ) )\n        {\n            sourcepath = StringUtils.join( sourcePaths.iterator(), File.pathSeparator );\n        }\n\n        addArgIfNotEmpty( arguments, \"-sourcepath\", quotedPathArgument( getSourcePath( sourcePaths ) ) );\n\n        if ( StringUtils.isNotEmpty( sourcepath ) )\n        {\n            addArgIfNotEmpty( arguments, \"-subpackages\", subpackages, SINCE_JAVADOC_1_4 );\n        }\n\n        addArgIfNotEmpty( arguments, \"-exclude\", getExcludedPackages( sourcePaths ), SINCE_JAVADOC_1_4 );\n\n        // ----------------------------------------------------------------------\n        // Wrap arguments for default doclet\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isEmpty( doclet ) )\n        {\n            addArgIf( arguments, author, \"-author\" );\n            addArgIfNotEmpty( arguments, \"-bottom\", quotedArgument( getBottomText( project.getInceptionYear() ) ),\n                              false, false );\n            addArgIf( arguments, breakiterator, \"-breakiterator\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-charset\", quotedArgument( charset ) );\n            addArgIfNotEmpty( arguments, \"-d\", quotedPathArgument( javadocOutputDirectory.toString() ) );\n            addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-docencoding\", quotedArgument( docencoding ) );\n            addArgIfNotEmpty( arguments, \"-doctitle\", quotedArgument( getDoctitle() ), false, false );\n            addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", quotedPathArgument( excludedocfilessubdir ),\n                              SINCE_JAVADOC_1_4 );\n            addArgIfNotEmpty( arguments, \"-footer\", quotedArgument( footer ), false, false );\n            if ( groups != null )\n            {\n                for ( int i = 0; i < groups.length; i++ )\n                {\n                    if ( groups[i] == null || StringUtils.isEmpty( groups[i].getTitle() )\n                        || StringUtils.isEmpty( groups[i].getPackages() ) )\n                    {\n                        getLog().info( \"A group option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String groupTitle = StringUtils.replace( groups[i].getTitle(), \",\", \"&#44;\" );\n                        addArgIfNotEmpty( arguments, \"-group\", quotedArgument( groupTitle ) + \" \"\n                            + quotedArgument( groups[i].getPackages() ), true );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-header\", quotedArgument( header ), false, false );\n            addArgIfNotEmpty( arguments, \"-helpfile\", quotedPathArgument( helpfile ) );\n            addArgIf( arguments, keywords, \"-keywords\", SINCE_JAVADOC_1_4_2 );\n\n            if ( !isOffline )\n            {\n                addLinkArguments( arguments );\n            }\n            addLinkofflineArguments( arguments );\n\n            addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n            addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n            addArgIf( arguments, nocomment, \"-nocomment\", SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nohelp, \"-nohelp\" );\n            addArgIf( arguments, noindex, \"-noindex\" );\n            addArgIf( arguments, nonavbar, \"-nonavbar\" );\n            addArgIfNotEmpty( arguments, \"-noqualifier\", quotedArgument( noqualifier ), SINCE_JAVADOC_1_4 );\n            addArgIf( arguments, nosince, \"-nosince\" );\n            addArgIf( arguments, notimestamp, \"-notimestamp\", SINCE_JAVADOC_1_5 );\n            addArgIf( arguments, notree, \"-notree\" );\n            addArgIfNotEmpty( arguments, \"-packagesheader\", packagesheader, SINCE_JAVADOC_1_4_2 );\n            addArgIf( arguments, serialwarn, \"-serialwarn\" );\n            addArgIf( arguments, linksource, \"-linksource\", SINCE_JAVADOC_1_4 );\n            if ( fJavadocVersion == SINCE_JAVADOC_1_4_2 )\n            {\n                addArgIfNotEmpty( arguments, \"-linksourcetab\", sourcetab );\n            }\n            else\n            {\n                addArgIfNotEmpty( arguments, \"-sourcetab\", sourcetab, SINCE_JAVADOC_1_5 );\n            }\n            addArgIf( arguments, splitindex, \"-splitindex\" );\n            addArgIfNotEmpty( arguments, \"-stylesheetfile\",\n                              quotedPathArgument( getStylesheetFile( javadocOutputDirectory ) ) );\n\n            addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglet ), SINCE_JAVADOC_1_4 );\n            if ( taglets != null )\n            {\n                for ( int i = 0; i < taglets.length; i++ )\n                {\n                    if ( ( taglets[i] == null ) || ( StringUtils.isEmpty( taglets[i].getTagletClass() ) ) )\n                    {\n                        getLog().info( \"A taglet option is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglets[i].getTagletClass() ),\n                                          SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n            addArgIfNotEmpty( arguments, \"-tagletpath\", quotedPathArgument( getTagletPath() ), SINCE_JAVADOC_1_4 );\n\n            if ( tags != null )\n            {\n                for ( int i = 0; i < tags.length; i++ )\n                {\n                    if ( StringUtils.isEmpty( tags[i].getName() ) )\n                    {\n                        getLog().info( \"A tag name is empty. Ignore this option.\" );\n                    }\n                    else\n                    {\n                        String value = \"\\\"\" + tags[i].getName();\n                        if ( StringUtils.isNotEmpty( tags[i].getPlacement() ) )\n                        {\n                            value += \":\" + tags[i].getPlacement();\n                            if ( StringUtils.isNotEmpty( tags[i].getHead() ) )\n                            {\n                                value += \":\" + tags[i].getHead();\n                            }\n                        }\n                        value += \"\\\"\";\n                        addArgIfNotEmpty( arguments, \"-tag\", value, SINCE_JAVADOC_1_4 );\n                    }\n                }\n            }\n\n            addArgIf( arguments, use, \"-use\" );\n            addArgIf( arguments, version, \"-version\" );\n            addArgIfNotEmpty( arguments, \"-windowtitle\", quotedArgument( getWindowtitle() ), false, false );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write options file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( options.length() > 0 )\n        {\n            addCommandLineOptions( cmd, options, arguments, javadocOutputDirectory );\n        }\n\n        // ----------------------------------------------------------------------\n        // Write packages file and include it in the command line\n        // ----------------------------------------------------------------------\n\n        if ( !packageNames.isEmpty() )\n        {\n            addCommandLinePackages( cmd, javadocOutputDirectory, packageNames );\n\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !filesWithUnnamedPackages.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, filesWithUnnamedPackages );\n            }\n        }\n        else\n        {\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n\n            if ( !files.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, files );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Execute command line\n        // ----------------------------------------------------------------------\n\n        getLog().debug( Commandline.toString( cmd.getCommandline() ) );\n\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                StringBuffer msg = new StringBuffer( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n                msg.append( '\\n' );\n                msg.append( \"Command line was:\" + Commandline.toString( cmd.getCommandline() ) );\n                throw new MavenReportException( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to execute javadoc command: \" + e.getMessage(), e );\n        }\n\n        // ----------------------------------------------------------------------\n        // Handle Javadoc warnings\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isNotEmpty( err.getOutput() ) )\n        {\n            getLog().info( \"Javadoc Warnings\" );\n\n            StringTokenizer token = new StringTokenizer( err.getOutput(), \"\\n\" );\n            while ( token.hasMoreTokens() )\n            {\n                String current = token.nextToken().trim();\n\n                getLog().warn( current );\n            }\n        }\n    }","commit_id":"88d2b7fcca5f38f6fe600eb9c636ba70c9dc3950","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @return the current javadoc directory\n     */\n    protected String getJavadocDirectory()\n    {\n        return javadocDirectory;\n    }","id":25434,"modified_method":"/**\n     * @return the current javadoc directory\n     */\n    protected File getJavadocDirectory()\n    {\n        return javadocDirectory;\n    }","commit_id":"88d2b7fcca5f38f6fe600eb9c636ba70c9dc3950","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Method that copy all <code>doc-files<\/code> directories from <code>javadocDirectory<\/code> of\n     * the current projet or of the projects in the reactor to the <code>outputDirectory<\/code>.\n     *\n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/tooldocs/javadoc/whatsnew-1.2.html#docfiles\">Reference\n     * Guide, Copies new \"doc-files\" directory for holding images and examples<\/a>\n     *\n     * @param outputDirectory the output directory\n     * @throws java.io.IOException if any\n     */\n    private void copyJavadocResources( File outputDirectory )\n        throws IOException\n    {\n        if ( outputDirectory == null || !outputDirectory.exists() )\n        {\n            throw new IOException( \"The outputDirectory \" + outputDirectory + \" doesn't exists.\" );\n        }\n\n        if ( getJavadocDirectory() != null )\n        {\n            copyJavadocResources( outputDirectory, new File( getJavadocDirectory() ) );\n        }\n\n        if ( aggregate && project.isExecutionRoot() )\n        {\n            for ( Iterator i = reactorProjects.iterator(); i.hasNext(); )\n            {\n                MavenProject subProject = (MavenProject) i.next();\n\n                if ( subProject != project )\n                {\n                    String javadocDirRelative = PathUtils.toRelative( project.getBasedir(), getJavadocDirectory() );\n                    File javadocDir = new File( subProject.getBasedir(), javadocDirRelative );\n                    copyJavadocResources( outputDirectory, javadocDir );\n                }\n            }\n        }\n    }","id":25435,"modified_method":"/**\n     * Method that copy all <code>doc-files<\/code> directories from <code>javadocDirectory<\/code> of\n     * the current projet or of the projects in the reactor to the <code>outputDirectory<\/code>.\n     *\n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/tooldocs/javadoc/whatsnew-1.2.html#docfiles\">Reference\n     * Guide, Copies new \"doc-files\" directory for holding images and examples<\/a>\n     *\n     * @param outputDirectory the output directory\n     * @throws java.io.IOException if any\n     */\n    private void copyJavadocResources( File outputDirectory )\n        throws IOException\n    {\n        if ( outputDirectory == null || !outputDirectory.exists() )\n        {\n            throw new IOException( \"The outputDirectory \" + outputDirectory + \" doesn't exists.\" );\n        }\n\n        if ( getJavadocDirectory() != null )\n        {\n            copyJavadocResources( outputDirectory, getJavadocDirectory() );\n        }\n\n        if ( aggregate && project.isExecutionRoot() )\n        {\n            for ( Iterator i = reactorProjects.iterator(); i.hasNext(); )\n            {\n                MavenProject subProject = (MavenProject) i.next();\n\n                if ( subProject != project )\n                {\n                    String javadocDirRelative = PathUtils.toRelative( project.getBasedir(), getJavadocDirectory().getAbsolutePath() );\n                    File javadocDir = new File( subProject.getBasedir(), javadocDirRelative );\n                    copyJavadocResources( outputDirectory, javadocDir );\n                }\n            }\n        }\n    }","commit_id":"88d2b7fcca5f38f6fe600eb9c636ba70c9dc3950","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.plugin.javadoc.AbstractJavadocMojo#getOverview()\n     */\n    protected String getOverview()\n    {\n        return overview;\n    }","id":25436,"modified_method":"/**\n     * @see org.apache.maven.plugin.javadoc.AbstractJavadocMojo#getOverview()\n     */\n    protected File getOverview()\n    {\n        return overview;\n    }","commit_id":"88d2b7fcca5f38f6fe600eb9c636ba70c9dc3950","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.plugin.javadoc.AbstractJavadocMojo#getJavadocDirectory()\n     */\n    protected String getJavadocDirectory()\n    {\n        return javadocDirectory;\n    }","id":25437,"modified_method":"/**\n     * @see org.apache.maven.plugin.javadoc.AbstractJavadocMojo#getJavadocDirectory()\n     */\n    protected File getJavadocDirectory()\n    {\n        return javadocDirectory;\n    }","commit_id":"88d2b7fcca5f38f6fe600eb9c636ba70c9dc3950","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Encode OdbcResponse to byte array.\n     *\n     * @param msg Message.\n     * @return Byte array.\n     */\n    public byte[] encode(OdbcResponse msg) {\n        assert msg != null;\n\n        // Creating new binary writer\n        BinaryWriterExImpl writer = marsh.writer(new BinaryHeapOutputStream(INIT_CAP));\n\n        // Writing status.\n        writer.writeByte((byte) msg.status());\n\n        if (msg.status() != OdbcResponse.STATUS_SUCCESS) {\n            writer.writeString(msg.error());\n\n            return writer.array();\n        }\n\n        Object res0 = msg.response();\n\n        if (res0 == null)\n            return writer.array();\n        if (res0 instanceof OdbcHandshakeResult) {\n            OdbcHandshakeResult res = (OdbcHandshakeResult) res0;\n\n            if (log.isDebugEnabled())\n                log.debug(\"Handshake result: \" + (res.accepted() ? \"accepted\" : \"rejected\"));\n\n            verConfirmed = res.accepted();\n\n            if (res.accepted()) {\n                verConfirmed = true;\n\n                writer.writeBoolean(true);\n            }\n            else {\n                writer.writeBoolean(false);\n                writer.writeString(res.protocolVersionSince());\n                writer.writeString(res.currentVersion());\n            }\n        }\n        else if (res0 instanceof OdbcQueryExecuteResult) {\n            OdbcQueryExecuteResult res = (OdbcQueryExecuteResult) res0;\n\n            if (log.isDebugEnabled())\n                log.debug(\"Resulting query ID: \" + res.getQueryId());\n\n            writer.writeLong(res.getQueryId());\n\n            Collection<OdbcColumnMeta> metas = res.getColumnsMetadata();\n\n            assert metas != null;\n\n            writer.writeInt(metas.size());\n\n            for (OdbcColumnMeta meta : metas)\n                meta.write(writer);\n        }\n        else if (res0 instanceof OdbcQueryFetchResult) {\n            OdbcQueryFetchResult res = (OdbcQueryFetchResult) res0;\n\n            if (log.isDebugEnabled())\n                log.debug(\"Resulting query ID: \" + res.queryId());\n\n            writer.writeLong(res.queryId());\n\n            Collection<?> items0 = res.items();\n\n            assert items0 != null;\n\n            writer.writeBoolean(res.last());\n\n            writer.writeInt(items0.size());\n\n            for (Object row0 : items0) {\n                if (row0 != null) {\n                    Collection<?> row = (Collection<?>)row0;\n\n                    writer.writeInt(row.size());\n\n                    for (Object obj : row)\n                        writer.writeObjectDetached(obj);\n                }\n            }\n        }\n        else if (res0 instanceof OdbcQueryCloseResult) {\n            OdbcQueryCloseResult res = (OdbcQueryCloseResult) res0;\n\n            if (log.isDebugEnabled())\n                log.debug(\"Resulting query ID: \" + res.getQueryId());\n\n            writer.writeLong(res.getQueryId());\n        }\n        else if (res0 instanceof OdbcQueryGetColumnsMetaResult) {\n            OdbcQueryGetColumnsMetaResult res = (OdbcQueryGetColumnsMetaResult) res0;\n\n            Collection<OdbcColumnMeta> columnsMeta = res.meta();\n\n            assert columnsMeta != null;\n\n            writer.writeInt(columnsMeta.size());\n\n            for (OdbcColumnMeta columnMeta : columnsMeta)\n                columnMeta.write(writer);\n        }\n        else if (res0 instanceof OdbcQueryGetTablesMetaResult) {\n            OdbcQueryGetTablesMetaResult res = (OdbcQueryGetTablesMetaResult) res0;\n\n            Collection<OdbcTableMeta> tablesMeta = res.meta();\n\n            assert tablesMeta != null;\n\n            writer.writeInt(tablesMeta.size());\n\n            for (OdbcTableMeta tableMeta : tablesMeta)\n                tableMeta.writeBinary(writer);\n        }\n        else\n            assert false : \"Should not reach here.\";\n\n        return writer.array();\n    }","id":25438,"modified_method":"/**\n     * Encode OdbcResponse to byte array.\n     *\n     * @param msg Message.\n     * @return Byte array.\n     */\n    public byte[] encode(OdbcResponse msg) {\n        assert msg != null;\n\n        // Creating new binary writer\n        BinaryWriterExImpl writer = marsh.writer(new BinaryHeapOutputStream(INIT_CAP));\n\n        // Writing status.\n        writer.writeByte((byte) msg.status());\n\n        if (msg.status() != OdbcResponse.STATUS_SUCCESS) {\n            writer.writeString(msg.error());\n\n            return writer.array();\n        }\n\n        Object res0 = msg.response();\n\n        if (res0 == null)\n            return writer.array();\n        if (res0 instanceof OdbcHandshakeResult) {\n            OdbcHandshakeResult res = (OdbcHandshakeResult) res0;\n\n            if (log.isDebugEnabled())\n                log.debug(\"Handshake result: \" + (res.accepted() ? \"accepted\" : \"rejected\"));\n\n            verConfirmed = res.accepted();\n\n            if (res.accepted()) {\n                verConfirmed = true;\n\n                writer.writeBoolean(true);\n            }\n            else {\n                writer.writeBoolean(false);\n                writer.writeString(res.protocolVersionSince());\n                writer.writeString(res.currentVersion());\n            }\n        }\n        else if (res0 instanceof OdbcQueryExecuteResult) {\n            OdbcQueryExecuteResult res = (OdbcQueryExecuteResult) res0;\n\n            if (log.isDebugEnabled())\n                log.debug(\"Resulting query ID: \" + res.getQueryId());\n\n            writer.writeLong(res.getQueryId());\n\n            Collection<OdbcColumnMeta> metas = res.getColumnsMetadata();\n\n            assert metas != null;\n\n            writer.writeInt(metas.size());\n\n            for (OdbcColumnMeta meta : metas)\n                meta.write(writer);\n        }\n        else if (res0 instanceof OdbcQueryFetchResult) {\n            OdbcQueryFetchResult res = (OdbcQueryFetchResult) res0;\n\n            if (log.isDebugEnabled())\n                log.debug(\"Resulting query ID: \" + res.queryId());\n\n            writer.writeLong(res.queryId());\n\n            Collection<?> items0 = res.items();\n\n            assert items0 != null;\n\n            writer.writeBoolean(res.last());\n\n            writer.writeInt(items0.size());\n\n            for (Object row0 : items0) {\n                if (row0 != null) {\n                    Collection<?> row = (Collection<?>)row0;\n\n                    writer.writeInt(row.size());\n\n                    for (Object obj : row) {\n                        if (obj instanceof java.sql.Timestamp)\n                            writer.writeTimestamp((java.sql.Timestamp)obj);\n                        else if (obj instanceof java.util.Date)\n                            writer.writeDate((java.util.Date)obj);\n                        else\n                            writer.writeObjectDetached(obj);\n                    }\n                }\n            }\n        }\n        else if (res0 instanceof OdbcQueryCloseResult) {\n            OdbcQueryCloseResult res = (OdbcQueryCloseResult) res0;\n\n            if (log.isDebugEnabled())\n                log.debug(\"Resulting query ID: \" + res.getQueryId());\n\n            writer.writeLong(res.getQueryId());\n        }\n        else if (res0 instanceof OdbcQueryGetColumnsMetaResult) {\n            OdbcQueryGetColumnsMetaResult res = (OdbcQueryGetColumnsMetaResult) res0;\n\n            Collection<OdbcColumnMeta> columnsMeta = res.meta();\n\n            assert columnsMeta != null;\n\n            writer.writeInt(columnsMeta.size());\n\n            for (OdbcColumnMeta columnMeta : columnsMeta)\n                columnMeta.write(writer);\n        }\n        else if (res0 instanceof OdbcQueryGetTablesMetaResult) {\n            OdbcQueryGetTablesMetaResult res = (OdbcQueryGetTablesMetaResult) res0;\n\n            Collection<OdbcTableMeta> tablesMeta = res.meta();\n\n            assert tablesMeta != null;\n\n            writer.writeInt(tablesMeta.size());\n\n            for (OdbcTableMeta tableMeta : tablesMeta)\n                tableMeta.writeBinary(writer);\n        }\n        else\n            assert false : \"Should not reach here.\";\n\n        return writer.array();\n    }","commit_id":"a760918757bee71ab28495496f94e9067ef17888","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public <R> GridClientFutureAdapter<R> execute(String taskName, Object arg, UUID destNodeId,\n        final boolean keepPortables) throws GridClientConnectionResetException, GridClientClosedException {\n        GridClientTaskRequest msg = new GridClientTaskRequest();\n\n        msg.taskName(taskName);\n        msg.argument(arg);\n        msg.deserializePortables(!keepPortables);\n\n        return this.<GridClientTaskResultBean>makeRequest(msg, destNodeId).chain(\n            new GridClientFutureCallback<GridClientTaskResultBean, R>() {\n                @Override public R onComplete(GridClientFuture<GridClientTaskResultBean> fut)\n                    throws GridClientException {\n                    Object res = fut.get().getResult();\n\n                    if (!keepPortables && res instanceof GridPortableObject) {\n                        try {\n                            res = ((GridPortableObject)res).deserialize();\n                        }\n                        catch (GridPortableException e) {\n                            throw new GridClientException(\"Failed to deserialize task result.\", e);\n                        }\n                    }\n\n                    return (R)res;\n                }\n            });\n    }","id":25439,"modified_method":"/** {@inheritDoc} */\n    @Override public <R> GridClientFutureAdapter<R> execute(String taskName, Object arg, UUID destNodeId,\n        final boolean keepPortables) throws GridClientConnectionResetException, GridClientClosedException {\n        GridClientTaskRequest msg = new GridClientTaskRequest();\n\n        msg.taskName(taskName);\n        msg.argument(arg);\n        msg.deserializePortables(!keepPortables);\n\n        return this.<GridClientTaskResultBean>makeRequest(msg, destNodeId).chain(\n            new GridClientFutureCallback<GridClientTaskResultBean, R>() {\n                @Override public R onComplete(GridClientFuture<GridClientTaskResultBean> fut)\n                    throws GridClientException {\n                    return fut.get().getResult();\n                }\n            });\n    }","commit_id":"b81d3c626ea7e9eff3df14ed732901fc79046e1f","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void writePortable(GridPortableWriter writer) throws GridPortableException {\n        super.writePortable(writer);\n\n        GridPortableRawWriterEx raw = (GridPortableRawWriterEx)writer.rawWriter();\n\n        raw.writeString(taskName);\n        raw.writeObjectDetached(arg);\n        raw.writeBoolean(deserializePortables);\n    }","id":25440,"modified_method":"/** {@inheritDoc} */\n    @Override public void writePortable(GridPortableWriter writer) throws GridPortableException {\n        super.writePortable(writer);\n\n        GridPortableRawWriterEx raw = (GridPortableRawWriterEx)writer.rawWriter();\n\n        raw.writeString(taskName);\n        raw.writeBoolean(deserializePortables);\n\n        if (deserializePortables)\n            raw.writeObject(arg);\n        else\n            raw.writeObjectDetached(arg);\n    }","commit_id":"b81d3c626ea7e9eff3df14ed732901fc79046e1f","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void readPortable(GridPortableReader reader) throws GridPortableException {\n        super.readPortable(reader);\n\n        GridPortableRawReaderEx raw = (GridPortableRawReaderEx)reader.rawReader();\n\n        taskName = raw.readString();\n        arg = raw.readObjectDetached();\n        deserializePortables = raw.readBoolean();\n    }","id":25441,"modified_method":"/** {@inheritDoc} */\n    @Override public void readPortable(GridPortableReader reader) throws GridPortableException {\n        super.readPortable(reader);\n\n        GridPortableRawReaderEx raw = (GridPortableRawReaderEx)reader.rawReader();\n\n        taskName = raw.readString();\n        deserializePortables = raw.readBoolean();\n        arg = deserializePortables ? raw.readObject() : raw.readObjectDetached();\n    }","commit_id":"b81d3c626ea7e9eff3df14ed732901fc79046e1f","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void writePortable(GridPortableWriter writer) throws GridPortableException {\n        GridPortableRawWriterEx raw = (GridPortableRawWriterEx)writer.rawWriter();\n\n        raw.writeString(id);\n        raw.writeBoolean(finished);\n        raw.writeObjectDetached(res);\n        raw.writeString(error);\n    }","id":25442,"modified_method":"/** {@inheritDoc} */\n    @Override public void writePortable(GridPortableWriter writer) throws GridPortableException {\n        GridPortableRawWriterEx raw = (GridPortableRawWriterEx)writer.rawWriter();\n\n        raw.writeString(id);\n        raw.writeBoolean(finished);\n        raw.writeBoolean(deserializePortables);\n\n        if (deserializePortables)\n            raw.writeObject(res);\n        else\n            raw.writeObjectDetached(res);\n\n        raw.writeString(error);\n    }","commit_id":"b81d3c626ea7e9eff3df14ed732901fc79046e1f","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void readPortable(GridPortableReader reader) throws GridPortableException {\n        GridPortableRawReaderEx raw = (GridPortableRawReaderEx)reader.rawReader();\n\n        id = raw.readString();\n        finished = raw.readBoolean();\n        res = raw.readObjectDetached();\n        error = raw.readString();\n    }","id":25443,"modified_method":"/** {@inheritDoc} */\n    @Override public void readPortable(GridPortableReader reader) throws GridPortableException {\n        GridPortableRawReaderEx raw = (GridPortableRawReaderEx)reader.rawReader();\n\n        id = raw.readString();\n        finished = raw.readBoolean();\n        deserializePortables = raw.readBoolean();\n        res = deserializePortables ? raw.readObject() : raw.readObjectDetached();\n        error = raw.readString();\n    }","commit_id":"b81d3c626ea7e9eff3df14ed732901fc79046e1f","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param req Request.\n     * @return Future.\n     * @throws GridException On any handling exception.\n     */\n    private GridFuture<GridRestResponse> handleAsyncUnsafe(final GridRestRequest req) throws GridException {\n        assert req instanceof GridRestTaskRequest : \"Invalid command for topology handler: \" + req;\n\n        assert SUPPORTED_COMMANDS.contains(req.command());\n\n        if (log.isDebugEnabled())\n            log.debug(\"Handling task REST request: \" + req);\n\n        GridRestTaskRequest req0 = (GridRestTaskRequest) req;\n\n        final GridFutureAdapter<GridRestResponse> fut = new GridFutureAdapter<>(ctx);\n\n        final GridRestResponse res = new GridRestResponse();\n\n        final GridClientTaskResultBean taskRestRes = new GridClientTaskResultBean();\n\n        // Set ID placeholder for the case it wouldn't be available due to remote execution.\n        taskRestRes.setId('~' + ctx.localNodeId().toString());\n\n        final boolean locExec = req0.destinationId() == null || req0.destinationId().equals(ctx.localNodeId()) ||\n            ctx.discovery().node(req0.destinationId()) == null;\n\n        switch (req.command()) {\n            case EXE: {\n                final boolean async = req0.async();\n\n                final String name = req0.taskName();\n\n                if (F.isEmpty(name))\n                    throw new GridException(missingParameter(\"name\"));\n\n                final List<Object> params;\n\n                if (req0.deserializePortables() && !F.isEmpty(req0.params())) {\n                    params = new ArrayList<>(req0.params().size());\n\n                    for (Object param : req0.params()) {\n                        if (param instanceof GridPortableObject)\n                            param = ((GridPortableObject<?>)param).deserialize();\n\n                        params.add(param);\n                    }\n                }\n                else\n                    params = req0.params();\n\n                long timeout = req0.timeout();\n\n                final GridFuture<Object> taskFut =\n                    locExec ?\n                        ctx.grid().forSubjectId(req.clientId()).compute().withTimeout(timeout).execute(\n                            name,\n                            !F.isEmpty(params) ? params.size() == 1 ? params.get(0) : params.toArray() : null)\n                        :\n                        // Using predicate instead of node intentionally\n                        // in order to provide user well-structured EmptyProjectionException.\n                        ctx.grid().forPredicate(F.nodeForNodeId(req.destinationId())).\n                            compute().withNoFailover().call(new ExeCallable(name, params, timeout, req.clientId()));\n\n                if (async) {\n                    if (locExec) {\n                        assert taskFut instanceof GridComputeTaskFuture;\n\n                        GridUuid tid = ((GridComputeTaskFuture)taskFut).getTaskSession().getId();\n\n                        taskDescs.put(tid, new TaskDescriptor(false, null, null));\n\n                        taskRestRes.setId(tid.toString() + '~' + ctx.localNodeId().toString());\n\n                        res.setResponse(taskRestRes);\n                    }\n                    else\n                        res.setError(\"Asynchronous task execution is not supported for routing request.\");\n\n                    fut.onDone(res);\n                }\n\n                taskFut.listenAsync(new GridInClosure<GridFuture<Object>>() {\n                    @Override public void apply(GridFuture<Object> f) {\n                        try {\n                            TaskDescriptor desc;\n\n                            try {\n                                desc = new TaskDescriptor(true, f.get(), null);\n                            }\n                            catch (GridException e) {\n                                if (e.hasCause(GridTopologyException.class, GridEmptyProjectionException.class))\n                                    U.warn(log, \"Failed to execute task due to topology issues (are all mapped \" +\n                                        \"nodes alive?) [name=\" + name + \", clientId=\" + req.clientId() +\n                                        \", err=\" + e + ']');\n                                else\n                                    U.error(log, \"Failed to execute task [name=\" + name + \", clientId=\" +\n                                        req.clientId() + ']', e);\n\n                                desc = new TaskDescriptor(true, null, e);\n                            }\n\n                            if (async && locExec) {\n                                assert taskFut instanceof GridComputeTaskFuture;\n\n                                GridUuid tid = ((GridComputeTaskFuture)taskFut).getTaskSession().getId();\n\n                                taskDescs.put(tid, desc);\n                            }\n\n                            if (!async) {\n                                if (desc.error() == null) {\n                                    taskRestRes.setFinished(true);\n                                    taskRestRes.setResult(desc.result());\n\n                                    res.setResponse(taskRestRes);\n                                    fut.onDone(res);\n                                }\n                                else\n                                    fut.onDone(desc.error());\n                            }\n                        }\n                        finally {\n                            if (!async && !fut.isDone())\n                                fut.onDone(new GridException(\"Failed to execute task (see server logs for details).\"));\n                        }\n                    }\n                });\n\n                break;\n            }\n\n            case RESULT: {\n                String id = req0.taskId();\n\n                if (F.isEmpty(id))\n                    throw new GridException(missingParameter(\"id\"));\n\n                StringTokenizer st = new StringTokenizer(id, \"~\");\n\n                if (st.countTokens() != 2)\n                    throw new GridException(\"Failed to parse id parameter: \" + id);\n\n                String tidParam = st.nextToken();\n                String resHolderIdParam = st.nextToken();\n\n                taskRestRes.setId(id);\n\n                try {\n                    GridUuid tid = !F.isEmpty(tidParam) ? GridUuid.fromString(tidParam) : null;\n\n                    UUID resHolderId = !F.isEmpty(resHolderIdParam) ? UUID.fromString(resHolderIdParam) : null;\n\n                    if (tid == null || resHolderId == null)\n                        throw new GridException(\"Failed to parse id parameter: \" + id);\n\n                    if (ctx.localNodeId().equals(resHolderId)) {\n                        TaskDescriptor desc = taskDescs.get(tid);\n\n                        if (desc == null)\n                            throw new GridException(\"Task with provided id has never been started on provided node\" +\n                                \" [taskId=\" + tidParam + \", taskResHolderId=\" + resHolderIdParam + ']');\n\n                        taskRestRes.setFinished(desc.finished());\n\n                        if (desc.error() != null)\n                            throw new GridException(desc.error().getMessage());\n\n                        taskRestRes.setResult(desc.result());\n\n                        res.setResponse(taskRestRes);\n                    }\n                    else {\n                        GridBiTuple<String, GridTaskResultResponse> t = requestTaskResult(resHolderId, tid);\n\n                        if (t.get1() != null)\n                            throw new GridException(t.get1());\n\n                        GridTaskResultResponse taskRes = t.get2();\n\n                        assert taskRes != null;\n\n                        if (!taskRes.found())\n                            throw new GridException(\"Task with provided id has never been started on provided node \" +\n                                \"[taskId=\" + tidParam + \", taskResHolderId=\" + resHolderIdParam + ']');\n\n                        taskRestRes.setFinished(taskRes.finished());\n\n                        if (taskRes.error() != null)\n                            throw new GridException(taskRes.error());\n\n                        taskRestRes.setResult(taskRes.result());\n\n                        res.setResponse(taskRestRes);\n                    }\n                }\n                catch (IllegalArgumentException e) {\n                    String msg = \"Failed to parse parameters [taskId=\" + tidParam + \", taskResHolderId=\"\n                        + resHolderIdParam + \", err=\" + e.getMessage() + ']';\n\n                    if (log.isDebugEnabled())\n                        log.debug(msg);\n\n                    throw new GridException(msg, e);\n                }\n\n                fut.onDone(res);\n\n                break;\n            }\n\n            case NOOP: {\n                fut.onDone(new GridRestResponse());\n\n                break;\n            }\n\n            default:\n                assert false : \"Invalid command for task handler: \" + req;\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"Handled task REST request [res=\" + res + \", req=\" + req + ']');\n\n        return fut;\n    }","id":25444,"modified_method":"/**\n     * @param req Request.\n     * @return Future.\n     * @throws GridException On any handling exception.\n     */\n    private GridFuture<GridRestResponse> handleAsyncUnsafe(final GridRestRequest req) throws GridException {\n        assert req instanceof GridRestTaskRequest : \"Invalid command for topology handler: \" + req;\n\n        assert SUPPORTED_COMMANDS.contains(req.command());\n\n        if (log.isDebugEnabled())\n            log.debug(\"Handling task REST request: \" + req);\n\n        GridRestTaskRequest req0 = (GridRestTaskRequest) req;\n\n        final GridFutureAdapter<GridRestResponse> fut = new GridFutureAdapter<>(ctx);\n\n        final GridRestResponse res = new GridRestResponse();\n\n        final GridClientTaskResultBean taskRestRes = new GridClientTaskResultBean();\n\n        // Set ID placeholder for the case it wouldn't be available due to remote execution.\n        taskRestRes.setId('~' + ctx.localNodeId().toString());\n\n        final boolean locExec = req0.destinationId() == null || req0.destinationId().equals(ctx.localNodeId()) ||\n            ctx.discovery().node(req0.destinationId()) == null;\n\n        switch (req.command()) {\n            case EXE: {\n                final boolean async = req0.async();\n\n                final String name = req0.taskName();\n\n                if (F.isEmpty(name))\n                    throw new GridException(missingParameter(\"name\"));\n\n                final List<Object> params = req0.params();\n\n                final boolean deserializePortables = req0.deserializePortables();\n\n                long timeout = req0.timeout();\n\n                final GridFuture<Object> taskFut =\n                    locExec ?\n                        ctx.grid().forSubjectId(req.clientId()).compute().withTimeout(timeout).execute(\n                            name,\n                            !F.isEmpty(params) ? params.size() == 1 ? params.get(0) : params.toArray() : null)\n                        :\n                        // Using predicate instead of node intentionally\n                        // in order to provide user well-structured EmptyProjectionException.\n                        ctx.grid().forPredicate(F.nodeForNodeId(req.destinationId())).\n                            compute().withNoFailover().call(new ExeCallable(name, params, timeout, req.clientId()));\n\n                if (async) {\n                    if (locExec) {\n                        assert taskFut instanceof GridComputeTaskFuture;\n\n                        GridUuid tid = ((GridComputeTaskFuture)taskFut).getTaskSession().getId();\n\n                        taskDescs.put(tid, new TaskDescriptor(false, null, null));\n\n                        taskRestRes.setId(tid.toString() + '~' + ctx.localNodeId().toString());\n\n                        res.setResponse(taskRestRes);\n                    }\n                    else\n                        res.setError(\"Asynchronous task execution is not supported for routing request.\");\n\n                    fut.onDone(res);\n                }\n\n                taskFut.listenAsync(new GridInClosure<GridFuture<Object>>() {\n                    @Override public void apply(GridFuture<Object> f) {\n                        try {\n                            TaskDescriptor desc;\n\n                            try {\n                                desc = new TaskDescriptor(true, f.get(), null);\n                            }\n                            catch (GridException e) {\n                                if (e.hasCause(GridTopologyException.class, GridEmptyProjectionException.class))\n                                    U.warn(log, \"Failed to execute task due to topology issues (are all mapped \" +\n                                        \"nodes alive?) [name=\" + name + \", clientId=\" + req.clientId() +\n                                        \", err=\" + e + ']');\n                                else\n                                    U.error(log, \"Failed to execute task [name=\" + name + \", clientId=\" +\n                                        req.clientId() + ']', e);\n\n                                desc = new TaskDescriptor(true, null, e);\n                            }\n\n                            if (async && locExec) {\n                                assert taskFut instanceof GridComputeTaskFuture;\n\n                                GridUuid tid = ((GridComputeTaskFuture)taskFut).getTaskSession().getId();\n\n                                taskDescs.put(tid, desc);\n                            }\n\n                            if (!async) {\n                                if (desc.error() == null) {\n                                    taskRestRes.setFinished(true);\n                                    taskRestRes.setResult(desc.result());\n                                    taskRestRes.setDeserializePortables(deserializePortables);\n\n                                    res.setResponse(taskRestRes);\n                                    fut.onDone(res);\n                                }\n                                else\n                                    fut.onDone(desc.error());\n                            }\n                        }\n                        finally {\n                            if (!async && !fut.isDone())\n                                fut.onDone(new GridException(\"Failed to execute task (see server logs for details).\"));\n                        }\n                    }\n                });\n\n                break;\n            }\n\n            case RESULT: {\n                String id = req0.taskId();\n\n                if (F.isEmpty(id))\n                    throw new GridException(missingParameter(\"id\"));\n\n                StringTokenizer st = new StringTokenizer(id, \"~\");\n\n                if (st.countTokens() != 2)\n                    throw new GridException(\"Failed to parse id parameter: \" + id);\n\n                String tidParam = st.nextToken();\n                String resHolderIdParam = st.nextToken();\n\n                taskRestRes.setId(id);\n\n                try {\n                    GridUuid tid = !F.isEmpty(tidParam) ? GridUuid.fromString(tidParam) : null;\n\n                    UUID resHolderId = !F.isEmpty(resHolderIdParam) ? UUID.fromString(resHolderIdParam) : null;\n\n                    if (tid == null || resHolderId == null)\n                        throw new GridException(\"Failed to parse id parameter: \" + id);\n\n                    if (ctx.localNodeId().equals(resHolderId)) {\n                        TaskDescriptor desc = taskDescs.get(tid);\n\n                        if (desc == null)\n                            throw new GridException(\"Task with provided id has never been started on provided node\" +\n                                \" [taskId=\" + tidParam + \", taskResHolderId=\" + resHolderIdParam + ']');\n\n                        taskRestRes.setFinished(desc.finished());\n\n                        if (desc.error() != null)\n                            throw new GridException(desc.error().getMessage());\n\n                        taskRestRes.setResult(desc.result());\n\n                        res.setResponse(taskRestRes);\n                    }\n                    else {\n                        GridBiTuple<String, GridTaskResultResponse> t = requestTaskResult(resHolderId, tid);\n\n                        if (t.get1() != null)\n                            throw new GridException(t.get1());\n\n                        GridTaskResultResponse taskRes = t.get2();\n\n                        assert taskRes != null;\n\n                        if (!taskRes.found())\n                            throw new GridException(\"Task with provided id has never been started on provided node \" +\n                                \"[taskId=\" + tidParam + \", taskResHolderId=\" + resHolderIdParam + ']');\n\n                        taskRestRes.setFinished(taskRes.finished());\n\n                        if (taskRes.error() != null)\n                            throw new GridException(taskRes.error());\n\n                        taskRestRes.setResult(taskRes.result());\n\n                        res.setResponse(taskRestRes);\n                    }\n                }\n                catch (IllegalArgumentException e) {\n                    String msg = \"Failed to parse parameters [taskId=\" + tidParam + \", taskResHolderId=\"\n                        + resHolderIdParam + \", err=\" + e.getMessage() + ']';\n\n                    if (log.isDebugEnabled())\n                        log.debug(msg);\n\n                    throw new GridException(msg, e);\n                }\n\n                fut.onDone(res);\n\n                break;\n            }\n\n            case NOOP: {\n                fut.onDone(new GridRestResponse());\n\n                break;\n            }\n\n            default:\n                assert false : \"Invalid command for task handler: \" + req;\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"Handled task REST request [res=\" + res + \", req=\" + req + ']');\n\n        return fut;\n    }","commit_id":"b81d3c626ea7e9eff3df14ed732901fc79046e1f","url":"https://github.com/apache/ignite"},{"original_method":"public void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException{\n            final PsiElement methodIdentifier = descriptor.getPsiElement();\n            final PsiReferenceExpression methodExpression =\n                    (PsiReferenceExpression) methodIdentifier.getParent();\n            if (methodExpression == null){\n                return;\n            }\n            final PsiMethodCallExpression call =\n                    (PsiMethodCallExpression) methodExpression.getParent();\n            if (call == null){\n                return;\n            }\n            final PsiMethod method = call.resolveMethod();\n            if (method == null){\n                return;\n            }\n            final PsiCodeBlock body = method.getBody();\n            if (body == null){\n                return;\n            }\n            final PsiStatement[] statements = body.getStatements();\n            final PsiReturnStatement returnStatement =\n                    (PsiReturnStatement) statements[0];\n            final PsiReferenceExpression returnValue = (PsiReferenceExpression)\n                    returnStatement.getReturnValue();\n            if (returnValue == null){\n                return;\n            }\n            final PsiField field = (PsiField)returnValue.resolve();\n            if (field == null){\n                return;\n            }\n            final String fieldName = field.getName();\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if(qualifier == null){\n                final JavaPsiFacade facade = JavaPsiFacade.getInstance(call.getProject());\n                final PsiResolveHelper resolveHelper = facade.getResolveHelper();\n                final PsiVariable variable =\n                        resolveHelper.resolveReferencedVariable(fieldName,\n                                call);\n                if (variable == null){\n                    return;\n                }\n                if (variable.equals(field)){\n                    replaceExpression(call, fieldName);\n                } else{\n                    replaceExpression(call, \"this.\" + fieldName);\n                }\n            } else{\n                replaceExpression(call, qualifier.getText() + '.' + fieldName);\n            }\n        }","id":25445,"modified_method":"public void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException{\n            final PsiElement methodIdentifier = descriptor.getPsiElement();\n            final PsiReferenceExpression methodExpression =\n                    (PsiReferenceExpression) methodIdentifier.getParent();\n            if (methodExpression == null){\n                return;\n            }\n            final PsiMethodCallExpression call =\n                    (PsiMethodCallExpression) methodExpression.getParent();\n            if (call == null){\n                return;\n            }\n            final PsiMethod method = call.resolveMethod();\n            if (method == null){\n                return;\n            }\n            final PsiCodeBlock body = method.getBody();\n            if (body == null){\n                return;\n            }\n            final PsiStatement[] statements = body.getStatements();\n            final PsiReturnStatement returnStatement =\n                    (PsiReturnStatement) statements[0];\n            final PsiReferenceExpression returnValue = (PsiReferenceExpression)\n                    returnStatement.getReturnValue();\n            if (returnValue == null){\n                return;\n            }\n            final PsiField field = (PsiField)returnValue.resolve();\n            if (field == null){\n                return;\n            }\n            final String fieldName = field.getName();\n            if (fieldName == null) {\n                return;\n            }\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if(qualifier == null){\n                final JavaPsiFacade facade = JavaPsiFacade.getInstance(call.getProject());\n                final PsiResolveHelper resolveHelper = facade.getResolveHelper();\n                final PsiVariable variable =\n                        resolveHelper.resolveReferencedVariable(fieldName,\n                                call);\n                if (variable == null){\n                    return;\n                }\n                if (variable.equals(field)){\n                    replaceExpression(call, fieldName);\n                } else{\n                    replaceExpression(call, \"this.\" + fieldName);\n                }\n            } else{\n                replaceExpression(call, qualifier.getText() + '.' + fieldName);\n            }\n        }","commit_id":"eda3395a278ced7349efec1796f1b97f988e12b8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    protected InspectionGadgetsFix buildFix(PsiElement location) {\n        final PsiClass aClass = (PsiClass)location.getParent();\n        final PsiJavaFile file = (PsiJavaFile)aClass.getParent();\n        final String fileName = file.getName();\n        if (fileName == null) {\n            return null;\n        }\n        final int prefixIndex = fileName.indexOf((int)'.');\n        final String filenameWithoutPrefix = fileName.substring(0, prefixIndex);\n        final PsiClass[] classes = file.getClasses();\n        for (PsiClass psiClass : classes) {\n            final String className = psiClass.getName();\n            if (filenameWithoutPrefix.equals(className)) {\n                return null;\n            }\n        }\n        return new RenameFix(filenameWithoutPrefix);\n    }","id":25446,"modified_method":"@Nullable\n    protected InspectionGadgetsFix buildFix(PsiElement location) {\n        final PsiClass aClass = (PsiClass)location.getParent();\n        final PsiJavaFile file = (PsiJavaFile)aClass.getParent();\n        final String fileName = file.getName();\n        final int prefixIndex = fileName.indexOf((int)'.');\n        final String filenameWithoutPrefix = fileName.substring(0, prefixIndex);\n        final PsiClass[] classes = file.getClasses();\n        for (PsiClass psiClass : classes) {\n            final String className = psiClass.getName();\n            if (filenameWithoutPrefix.equals(className)) {\n                return null;\n            }\n        }\n        return new RenameFix(filenameWithoutPrefix);\n    }","commit_id":"eda3395a278ced7349efec1796f1b97f988e12b8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public void visitClass(@NotNull PsiClass aClass) {\n            // no call to super, so that it doesn't drill down to inner classes\n            if (PsiUtil.isInJspFile(aClass)) {\n                return;\n            }\n            final PsiElement parent = aClass.getParent();\n            if (!(parent instanceof PsiJavaFile)) {\n                return;\n            }\n            final PsiJavaFile file = (PsiJavaFile)parent;\n            final String className = aClass.getName();\n            if (className == null) {\n                return;\n            }\n            final String fileName = file.getName();\n            if (fileName == null) {\n                return;\n            }\n            final int prefixIndex = fileName.indexOf((int)'.');\n            if (prefixIndex < 0) {\n                return;\n            }\n            final String filenameWithoutPrefix =\n                    fileName.substring(0, prefixIndex);\n            if (className.equals(filenameWithoutPrefix)) {\n                return;\n            }\n            registerClassError(aClass);\n        }","id":25447,"modified_method":"@Override public void visitClass(@NotNull PsiClass aClass) {\n            // no call to super, so that it doesn't drill down to inner classes\n            if (PsiUtil.isInJspFile(aClass)) {\n                return;\n            }\n            final PsiElement parent = aClass.getParent();\n            if (!(parent instanceof PsiJavaFile)) {\n                return;\n            }\n            final PsiJavaFile file = (PsiJavaFile)parent;\n            final String className = aClass.getName();\n            if (className == null) {\n                return;\n            }\n            final String fileName = file.getName();\n            final int prefixIndex = fileName.indexOf((int)'.');\n            if (prefixIndex < 0) {\n                return;\n            }\n            final String filenameWithoutPrefix =\n                    fileName.substring(0, prefixIndex);\n            if (className.equals(filenameWithoutPrefix)) {\n                return;\n            }\n            registerClassError(aClass);\n        }","commit_id":"eda3395a278ced7349efec1796f1b97f988e12b8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException {\n            final PsiJavaToken classNameToken =\n                    (PsiJavaToken)descriptor.getPsiElement();\n            final PsiClass innerClass = (PsiClass)classNameToken.getParent();\n            assert innerClass != null;\n            final SearchScope useScope = innerClass.getUseScope();\n            final Query<PsiReference> query =\n                    ReferencesSearch.search(innerClass, useScope);\n            final Collection<PsiReference> references = query.findAll();\n            for (final PsiReference reference : references) {\n                final PsiElement element = reference.getElement();\n                final PsiElement parent = element.getParent();\n                if (!(parent instanceof PsiNewExpression)) {\n                    continue;\n                }\n                final PsiNewExpression newExpression =\n                        (PsiNewExpression)parent;\n                final PsiExpression qualifier =\n                        newExpression.getQualifier();\n                if (qualifier == null) {\n                    continue;\n                }\n                qualifier.delete();\n            }\n            final PsiModifierList modifiers = innerClass.getModifierList();\n            modifiers.setModifierProperty(PsiModifier.STATIC, true);\n        }","id":25448,"modified_method":"public void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException {\n            final PsiJavaToken classNameToken =\n                    (PsiJavaToken)descriptor.getPsiElement();\n            final PsiClass innerClass = (PsiClass)classNameToken.getParent();\n            assert innerClass != null;\n            final SearchScope useScope = innerClass.getUseScope();\n            final Query<PsiReference> query =\n                    ReferencesSearch.search(innerClass, useScope);\n            final Collection<PsiReference> references = query.findAll();\n            for (final PsiReference reference : references) {\n                final PsiElement element = reference.getElement();\n                final PsiElement parent = element.getParent();\n                if (!(parent instanceof PsiNewExpression)) {\n                    continue;\n                }\n                final PsiNewExpression newExpression =\n                        (PsiNewExpression)parent;\n                final PsiExpression qualifier =\n                        newExpression.getQualifier();\n                if (qualifier == null) {\n                    continue;\n                }\n                qualifier.delete();\n            }\n            final PsiModifierList modifiers = innerClass.getModifierList();\n            if (modifiers == null) {\n                return;\n            }\n            modifiers.setModifierProperty(PsiModifier.STATIC, true);\n        }","commit_id":"eda3395a278ced7349efec1796f1b97f988e12b8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void replaceExpressionWithReferenceTo(\n            @NotNull PsiExpression expression,\n            @NotNull PsiMember target)\n            throws IncorrectOperationException{\n        final PsiManager psiManager = expression.getManager();\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(psiManager.getProject()).getElementFactory();\n        final PsiReferenceExpression newExpression = (PsiReferenceExpression)factory.createExpressionFromText(\"xxx\", expression);\n        final PsiReferenceExpression replacementExpression = (PsiReferenceExpression)expression.replace(newExpression);\n      PsiElement element = replacementExpression.bindToElement(target);\n      final JavaCodeStyleManager styleManager = JavaCodeStyleManager.getInstance(psiManager.getProject());\n        styleManager.shortenClassReferences(element);\n    }","id":25449,"modified_method":"protected static void replaceExpressionWithReferenceTo(\n            @NotNull PsiExpression expression,\n            @NotNull PsiMember target)\n            throws IncorrectOperationException{\n        final PsiManager psiManager = expression.getManager();\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(psiManager.getProject()).getElementFactory();\n        final PsiReferenceExpression newExpression = (PsiReferenceExpression)factory.createExpressionFromText(\"xxx\", expression);\n        final PsiReferenceExpression replacementExpression = (PsiReferenceExpression)expression.replace(newExpression);\n      final PsiElement element = replacementExpression.bindToElement(target);\n      final JavaCodeStyleManager styleManager = JavaCodeStyleManager.getInstance(psiManager.getProject());\n        styleManager.shortenClassReferences(element);\n    }","commit_id":"eda3395a278ced7349efec1796f1b97f988e12b8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void replaceStatementAndShortenClassNames(\n            @NotNull PsiStatement statement,\n            @NotNull @NonNls String newStatementText)\n            throws IncorrectOperationException{\n        final PsiManager psiManager = statement.getManager();\n        PsiStatement newStatement;\n        final CodeStyleManager styleManager = psiManager.getCodeStyleManager();\n        if (PsiUtil.isInJspFile(statement)) {\n            final PsiDocumentManager documentManager =\n                    PsiDocumentManager.getInstance(psiManager.getProject());\n            final JspFile file = PsiUtil.getJspFile(statement);\n            final Document document = documentManager.getDocument(file);\n            if (document == null) {\n                return;\n            }\n            final TextRange textRange = statement.getTextRange();\n            document.replaceString(textRange.getStartOffset(),\n                    textRange.getEndOffset(), newStatementText);\n            documentManager.commitDocument(document);\n            final JspxFileViewProvider viewProvider = file.getViewProvider();\n            PsiElement elementAt =\n                    viewProvider.findElementAt(textRange.getStartOffset(),\n                            StdLanguages.JAVA);\n            if (elementAt == null) {\n                return;\n            }\n            final int endOffset = textRange.getStartOffset() +\n                    newStatementText.length();\n            while(elementAt.getTextRange().getEndOffset() < endOffset ||\n                    !(elementAt instanceof PsiStatement)) {\n                elementAt = elementAt.getParent();\n                if (elementAt == null) {\n                    LOG.error(\"Cannot decode statement\");\n                    return;\n                }\n            }\n            newStatement = (PsiStatement) elementAt;\n            JavaCodeStyleManager.getInstance(psiManager.getProject()).shortenClassReferences(newStatement);\n            final TextRange newTextRange = newStatement.getTextRange();\n            final PsiFile element = viewProvider.getPsi(\n                    viewProvider.getBaseLanguage());\n            styleManager.reformatRange(element, newTextRange.getStartOffset(),\n                newTextRange.getEndOffset());\n        } else {\n          final PsiElementFactory factory = JavaPsiFacade.getInstance(psiManager.getProject()).getElementFactory();\n            newStatement = factory.createStatementFromText(newStatementText,\n                    statement);\n            newStatement = (PsiStatement) statement.replace(newStatement);\n            JavaCodeStyleManager.getInstance(psiManager.getProject()).shortenClassReferences(newStatement);\n            styleManager.reformat(newStatement);\n        }\n    }","id":25450,"modified_method":"protected static void replaceStatementAndShortenClassNames(\n            @NotNull PsiStatement statement,\n            @NotNull @NonNls String newStatementText)\n            throws IncorrectOperationException{\n        final PsiManager psiManager = statement.getManager();\n        PsiStatement newStatement;\n        final CodeStyleManager styleManager = psiManager.getCodeStyleManager();\n        final Project project = psiManager.getProject();\n        final JavaCodeStyleManager javaStyleManager =\n                JavaCodeStyleManager.getInstance(project);\n        if (PsiUtil.isInJspFile(statement)) {\n            final PsiDocumentManager documentManager =\n                    PsiDocumentManager.getInstance(project);\n            final JspFile file = PsiUtil.getJspFile(statement);\n            final Document document = documentManager.getDocument(file);\n            if (document == null) {\n                return;\n            }\n            final TextRange textRange = statement.getTextRange();\n            document.replaceString(textRange.getStartOffset(),\n                    textRange.getEndOffset(), newStatementText);\n            documentManager.commitDocument(document);\n            final JspxFileViewProvider viewProvider = file.getViewProvider();\n            PsiElement elementAt =\n                    viewProvider.findElementAt(textRange.getStartOffset(),\n                            StdLanguages.JAVA);\n            if (elementAt == null) {\n                return;\n            }\n            final int endOffset = textRange.getStartOffset() +\n                    newStatementText.length();\n            while(elementAt.getTextRange().getEndOffset() < endOffset ||\n                    !(elementAt instanceof PsiStatement)) {\n                elementAt = elementAt.getParent();\n                if (elementAt == null) {\n                    LOG.error(\"Cannot decode statement\");\n                    return;\n                }\n            }\n            newStatement = (PsiStatement) elementAt;\n            javaStyleManager.shortenClassReferences(newStatement);\n            final TextRange newTextRange = newStatement.getTextRange();\n            final Language baseLanguage = viewProvider.getBaseLanguage();\n            final PsiFile element = viewProvider.getPsi(baseLanguage);\n            if (element != null) {\n                styleManager.reformatRange(element,\n                        newTextRange.getStartOffset(),\n                        newTextRange.getEndOffset());\n            }\n        } else {\n            final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n            final PsiElementFactory factory = facade.getElementFactory();\n            newStatement =\n                    factory.createStatementFromText(newStatementText, statement);\n            newStatement = (PsiStatement) statement.replace(newStatement);\n            javaStyleManager.shortenClassReferences(newStatement);\n            styleManager.reformat(newStatement);\n        }\n    }","commit_id":"eda3395a278ced7349efec1796f1b97f988e12b8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public void visitField(@NotNull PsiField field) {\n            super.visitField(field);\n            if (!childrenContainTypeElement(field)) {\n                return;\n            }\n            final List<PsiField> fields = getSiblingFields(field);\n            if (fields.size() > 1) {\n                final PsiField firstField = fields.get(0);\n                final PsiType baseType = firstField.getType();\n                boolean hasMultipleTypes = false;\n                for (int i = 1; i < fields.size(); i++) {\n                    final PsiField var = fields.get(i);\n                    final PsiType varType = var.getType();\n                    if (!varType.equals(baseType)) {\n                        hasMultipleTypes = true;\n                    }\n                }\n                if (hasMultipleTypes) {\n                    for (int i = 1; i < fields.size(); i++) {\n                        final PsiField var = fields.get(i);\n                        registerVariableError(var);\n                    }\n                }\n            }\n        }","id":25451,"modified_method":"@Override public void visitField(@NotNull PsiField field) {\n            super.visitField(field);\n            if (!childrenContainTypeElement(field)) {\n                return;\n            }\n            final List<PsiField> fields = getSiblingFields(field);\n            if (fields.size() > 1) {\n                final PsiField firstField = fields.get(0);\n                final PsiType baseType = firstField.getType();\n                boolean hasMultipleTypes = false;\n                for (int i = 1; i < fields.size(); i++) {\n                    final PsiField variable = fields.get(i);\n                    final PsiType variableType = variable.getType();\n                    if (!variableType.equals(baseType)) {\n                        hasMultipleTypes = true;\n                    }\n                }\n                if (hasMultipleTypes) {\n                    for (int i = 1; i < fields.size(); i++) {\n                        final PsiField var = fields.get(i);\n                        registerVariableError(var);\n                    }\n                }\n            }\n        }","commit_id":"eda3395a278ced7349efec1796f1b97f988e12b8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<PsiField> getSiblingFields(PsiField field) {\n            final List<PsiField> out = new ArrayList<PsiField>(5);\n            out.add(field);\n            PsiField nextfield =\n                    PsiTreeUtil.getNextSiblingOfType(field,\n                            PsiField.class);\n            while (nextfield != null &&\n                    nextfield.getTypeElement().equals(field.getTypeElement())) {\n                out.add(nextfield);\n                nextfield =\n                        PsiTreeUtil.getNextSiblingOfType(nextfield,\n                                PsiField.class);\n            }\n\n            return out;\n        }","id":25452,"modified_method":"public static List<PsiField> getSiblingFields(PsiField field) {\n            final List<PsiField> out = new ArrayList<PsiField>(5);\n            out.add(field);\n            PsiField nextField =\n                    PsiTreeUtil.getNextSiblingOfType(field,\n                            PsiField.class);\n            if (nextField != null) {\n                PsiTypeElement nextTypeElement = nextField.getTypeElement();\n                while (nextTypeElement != null &&\n                       nextTypeElement.equals(field.getTypeElement())) {\n                    out.add(nextField);\n                    nextField =\n                            PsiTreeUtil.getNextSiblingOfType(nextField,\n                                    PsiField.class);\n                    if (nextField == null) {\n                        break;\n                    }\n                    nextTypeElement = nextField.getTypeElement();\n                }\n            }\n            return out;\n        }","commit_id":"eda3395a278ced7349efec1796f1b97f988e12b8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static int getLogBaseTwo(PsiExpression rhs) {\n        final PsiLiteralExpression literal = (PsiLiteralExpression) rhs;\n        final Object value = literal.getValue();\n        int intValue = ((Number) value).intValue();\n        int log = 0;\n        while (intValue % 2 == 0) {\n            intValue >>= 1;\n            log++;\n        }\n        return log;\n    }","id":25453,"modified_method":"public static int getLogBaseTwo(PsiExpression rhs) {\n        final PsiLiteralExpression literal = (PsiLiteralExpression) rhs;\n        final Object value = literal.getValue();\n        int log = 0;\n        if (value == null) {\n            return log;\n        }\n        int intValue = ((Number) value).intValue();\n        while (intValue % 2 == 0) {\n            intValue >>= 1;\n            log++;\n        }\n        return log;\n    }","commit_id":"eda3395a278ced7349efec1796f1b97f988e12b8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrIntroduceFieldDialog(GrIntroduceContext context) {\n    super(context.getProject(), true);\n    myContext = context;\n\n    GrTypeDefinition clazz = (GrTypeDefinition)context.getScope();\n    myIsStatic = GrIntroduceFieldHandler.shouldBeStatic(context.getPlace(), clazz);\n\n    initVisibility();\n\n    ButtonGroup initialization = new ButtonGroup();\n    initialization.add(myCurrentMethodRadioButton);\n    initialization.add(myFieldDeclarationRadioButton);\n    initialization.add(myClassConstructorSRadioButton);\n    new RadioUpDownListener(myCurrentMethodRadioButton, myFieldDeclarationRadioButton, myClassConstructorSRadioButton);\n\n    myCanBeInitializedOutsideBlock = canBeInitializedOutsideBlock(context.getExpression(), (GrTypeDefinition)context.getScope());\n    /*if (!myCanBeInitializedOutsideBlock) {\n      myClassConstructorSRadioButton.setEnabled(false);\n      myFieldDeclarationRadioButton.setEnabled(false);\n    }*/\n    final GrMethod containingMethod = GrIntroduceFieldHandler.getContainingMethod(context.getPlace(), clazz);\n    if (containingMethod == null) {\n      myCurrentMethodRadioButton.setEnabled(false);\n    }\n\n    if (myCurrentMethodRadioButton.isEnabled()) {\n      myCurrentMethodRadioButton.setSelected(true);\n    }\n    else {\n      myFieldDeclarationRadioButton.setSelected(true);\n    }\n\n    myInvokedOnLocalVar  = context.getVar() == null ? getInvokedOnLocalVar(context.getExpression()) : context.getVar().getName();\n    if (myInvokedOnLocalVar != null) {\n      myReplaceAllOccurrencesCheckBox.setText(\"Replace all occurrences and remove variable '\" + myInvokedOnLocalVar + \"'\");\n      if (context.getVar() != null) {\n        myReplaceAllOccurrencesCheckBox.setEnabled(false);\n        myReplaceAllOccurrencesCheckBox.setSelected(true);\n      }\n    }\n    else if (context.getOccurrences().length == 1) {\n      myReplaceAllOccurrencesCheckBox.setSelected(false);\n      myReplaceAllOccurrencesCheckBox.setVisible(false);\n    }\n\n    myNameField.addDataChangedListener(new NameSuggestionsField.DataChanged() {\n      @Override\n      public void dataChanged() {\n        validateOKAction();\n      }\n    });\n\n    ItemListener l = new ItemListener() {\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        myNameField.requestFocusInWindow();\n        checkErrors();\n      }\n    };\n    myPrivateRadioButton.addItemListener(l);\n    myProtectedRadioButton.addItemListener(l);\n    myPublicRadioButton.addItemListener(l);\n    myPropertyRadioButton.addItemListener(l);\n    myCurrentMethodRadioButton.addItemListener(l);\n    myFieldDeclarationRadioButton.addItemListener(l);\n    myClassConstructorSRadioButton.addItemListener(l);\n    myDeclareFinalCheckBox.addItemListener(l);\n    myReplaceAllOccurrencesCheckBox.addItemListener(l);\n    myTypeComboBox.addItemListener(l);\n\n    isInvokedInAlwaysInvokedConstructor =\n      allOccurrencesInOneMethod(myContext.getOccurrences(), clazz) && isAlwaysInvokedConstructor(containingMethod, clazz);\n    hasLHSUsages = hasLhsUsages(myContext);\n\n    setTitle(REFACTORING_NAME);\n    init();\n    checkErrors();\n  }","id":25454,"modified_method":"public GrIntroduceFieldDialog(GrIntroduceContext context) {\n    super(context.getProject(), true);\n    myContext = context;\n\n    final PsiClass clazz = (PsiClass)context.getScope();\n    PsiElement scope = clazz instanceof GroovyScriptClass ? clazz.getContainingFile() : clazz;\n    myIsStatic = GrIntroduceFieldHandler.shouldBeStatic(context.getPlace(), scope);\n\n    initVisibility();\n\n    ButtonGroup initialization = new ButtonGroup();\n    initialization.add(myCurrentMethodRadioButton);\n    initialization.add(myFieldDeclarationRadioButton);\n    initialization.add(myClassConstructorSRadioButton);\n    new RadioUpDownListener(myCurrentMethodRadioButton, myFieldDeclarationRadioButton, myClassConstructorSRadioButton);\n\n    if (clazz instanceof GroovyScriptClass) {\n      myClassConstructorSRadioButton.setEnabled(false);\n    }\n\n    myCanBeInitializedOutsideBlock = canBeInitializedOutsideBlock(context.getExpression(), clazz);\n    /*if (!myCanBeInitializedOutsideBlock) {\n      myClassConstructorSRadioButton.setEnabled(false);\n      myFieldDeclarationRadioButton.setEnabled(false);\n    }*/\n    final GrMethod containingMethod = GrIntroduceFieldHandler.getContainingMethod(context.getPlace(), scope);\n    if (containingMethod == null) {\n      myCurrentMethodRadioButton.setEnabled(false);\n    }\n\n    if (myCurrentMethodRadioButton.isEnabled()) {\n      myCurrentMethodRadioButton.setSelected(true);\n    }\n    else {\n      myFieldDeclarationRadioButton.setSelected(true);\n    }\n\n    myInvokedOnLocalVar  = context.getVar() == null ? getInvokedOnLocalVar(context.getExpression()) : context.getVar().getName();\n    if (myInvokedOnLocalVar != null) {\n      myReplaceAllOccurrencesCheckBox.setText(\"Replace all occurrences and remove variable '\" + myInvokedOnLocalVar + \"'\");\n      if (context.getVar() != null) {\n        myReplaceAllOccurrencesCheckBox.setEnabled(false);\n        myReplaceAllOccurrencesCheckBox.setSelected(true);\n      }\n    }\n    else if (context.getOccurrences().length == 1) {\n      myReplaceAllOccurrencesCheckBox.setSelected(false);\n      myReplaceAllOccurrencesCheckBox.setVisible(false);\n    }\n\n    myNameField.addDataChangedListener(new NameSuggestionsField.DataChanged() {\n      @Override\n      public void dataChanged() {\n        validateOKAction();\n      }\n    });\n\n    ItemListener l = new ItemListener() {\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        myNameField.requestFocusInWindow();\n        checkErrors();\n      }\n    };\n    myPrivateRadioButton.addItemListener(l);\n    myProtectedRadioButton.addItemListener(l);\n    myPublicRadioButton.addItemListener(l);\n    myPropertyRadioButton.addItemListener(l);\n    myCurrentMethodRadioButton.addItemListener(l);\n    myFieldDeclarationRadioButton.addItemListener(l);\n    myClassConstructorSRadioButton.addItemListener(l);\n    myDeclareFinalCheckBox.addItemListener(l);\n    myReplaceAllOccurrencesCheckBox.addItemListener(l);\n    myTypeComboBox.addItemListener(l);\n\n    isInvokedInAlwaysInvokedConstructor =\n      allOccurrencesInOneMethod(myContext.getOccurrences(), scope) && isAlwaysInvokedConstructor(containingMethod, clazz);\n    hasLHSUsages = hasLhsUsages(myContext);\n\n    setTitle(REFACTORING_NAME);\n    init();\n    checkErrors();\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initVisibility() {\n    ButtonGroup visibility = new ButtonGroup();\n    visibility.add(myPrivateRadioButton);\n    visibility.add(myProtectedRadioButton);\n    visibility.add(myPublicRadioButton);\n    visibility.add(myPropertyRadioButton);\n\n    myPrivateRadioButton.setSelected(true);\n    new RadioUpDownListener(myPrivateRadioButton, myProtectedRadioButton, myPublicRadioButton, myPropertyRadioButton);\n  }","id":25455,"modified_method":"private void initVisibility() {\n    ButtonGroup visibility = new ButtonGroup();\n    visibility.add(myPrivateRadioButton);\n    visibility.add(myProtectedRadioButton);\n    visibility.add(myPublicRadioButton);\n    visibility.add(myPropertyRadioButton);\n\n    if (myContext.getScope() instanceof GroovyScriptClass) {\n      myPropertyRadioButton.setSelected(true);\n      myPrivateRadioButton.setEnabled(false);\n      myProtectedRadioButton.setEnabled(false);\n      myPublicRadioButton.setEnabled(false);\n      myPropertyRadioButton.setEnabled(false);\n    }\n    else {\n      myPrivateRadioButton.setSelected(true);\n    }\n    new RadioUpDownListener(myPrivateRadioButton, myProtectedRadioButton, myPublicRadioButton, myPropertyRadioButton);\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean canBeInitializedOutsideBlock(@Nullable GrExpression expression, final GrTypeDefinition scope) {\n    if (expression == null) return false;\n    expression = (GrExpression)PsiUtil.skipParentheses(expression, false);\n    if (expression == null) return false;\n\n    if (expression instanceof GrReferenceExpression) {\n      final PsiElement resolved = ((GrReferenceExpression)expression).resolve();\n      if (GroovyRefactoringUtil.isLocalVariable(resolved)) {\n        expression = ((GrVariable)resolved).getInitializerGroovy();\n        if (expression == null) return false;\n      }\n    }\n\n    final Ref<Boolean> ref = new Ref<Boolean>(Boolean.TRUE);\n    final GrExpression finalExpression = expression;\n    expression.accept(new GroovyRecursiveElementVisitor() {\n      @Override\n      public void visitReferenceExpression(GrReferenceExpression refExpr) {\n        super.visitReferenceExpression(refExpr);\n        final PsiElement resolved = refExpr.resolve();\n        if (!(resolved instanceof GrVariable)) return;\n        if (resolved instanceof GrField && scope.getManager().areElementsEquivalent(scope, ((GrField)resolved).getContainingClass())) {\n          return;\n        }\n        if (resolved instanceof PsiParameter &&\n            PsiTreeUtil.isAncestor(finalExpression, ((PsiParameter)resolved).getDeclarationScope(), false)) {\n          return;\n        }\n        ref.set(Boolean.FALSE);\n      }\n    });\n    return ref.get();\n  }","id":25456,"modified_method":"private static boolean canBeInitializedOutsideBlock(@Nullable GrExpression expression, final PsiClass clazz) {\n    if (expression == null) return false;\n    expression = (GrExpression)PsiUtil.skipParentheses(expression, false);\n    if (expression == null) return false;\n\n    if (expression instanceof GrReferenceExpression) {\n      final PsiElement resolved = ((GrReferenceExpression)expression).resolve();\n      if (GroovyRefactoringUtil.isLocalVariable(resolved)) {\n        expression = ((GrVariable)resolved).getInitializerGroovy();\n        if (expression == null) return false;\n      }\n    }\n\n    final Ref<Boolean> ref = new Ref<Boolean>(Boolean.TRUE);\n    final GrExpression finalExpression = expression;\n    expression.accept(new GroovyRecursiveElementVisitor() {\n      @Override\n      public void visitReferenceExpression(GrReferenceExpression refExpr) {\n        super.visitReferenceExpression(refExpr);\n        final PsiElement resolved = refExpr.resolve();\n        if (!(resolved instanceof GrVariable)) return;\n        if (resolved instanceof GrField && clazz.getManager().areElementsEquivalent(clazz, ((GrField)resolved).getContainingClass())) {\n          return;\n        }\n        if (resolved instanceof PsiParameter &&\n            PsiTreeUtil.isAncestor(finalExpression, ((PsiParameter)resolved).getDeclarationScope(), false)) {\n          return;\n        }\n        ref.set(Boolean.FALSE);\n      }\n    });\n    return ref.get();\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean allOccurrencesInOneMethod(PsiElement[] occurrences, GrTypeDefinition clazz) {\n    if (occurrences.length == 0) return true;\n    GrMethod method = GrIntroduceFieldHandler.getContainingMethod(occurrences[0], clazz);\n    if (method == null) return false;\n    for (int i = 1; i < occurrences.length; i++) {\n      GrMethod other = GrIntroduceFieldHandler.getContainingMethod(occurrences[i], clazz);\n      if (other != method) return false;\n    }\n    return true;\n  }","id":25457,"modified_method":"private static boolean allOccurrencesInOneMethod(PsiElement[] occurrences, PsiElement scope) {\n    if (occurrences.length == 0) return true;\n    GrMethod method = GrIntroduceFieldHandler.getContainingMethod(occurrences[0], scope);\n    if (method == null) return false;\n    for (int i = 1; i < occurrences.length; i++) {\n      GrMethod other = GrIntroduceFieldHandler.getContainingMethod(occurrences[i], scope);\n      if (other != method) return false;\n    }\n    return true;\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkErrors() {\n    List<String> errors = new ArrayList<String>();\n    if (myCurrentMethodRadioButton.isSelected() && myDeclareFinalCheckBox.isSelected() && !!isInvokedInAlwaysInvokedConstructor) {\n      errors.add(GroovyRefactoringBundle.message(\"final.field.cant.be.initialized.in.cur.method\"));\n    }\n    if (myDeclareFinalCheckBox.isSelected() && myReplaceAllOccurrencesCheckBox.isSelected() && myInvokedOnLocalVar != null && hasLHSUsages) {\n      errors.add(GroovyRefactoringBundle.message(\"Field.cannot.be.final.because.replaced.variable.has.lhs.usages\"));\n    }\n    if (!myCanBeInitializedOutsideBlock) {\n      if (myFieldDeclarationRadioButton.isSelected()) {\n        errors.add(GroovyRefactoringBundle.message(\"field.cannot.be.initialized.in.field.declaration\"));\n      }\n      else if (myClassConstructorSRadioButton.isSelected()) {\n        errors.add(GroovyRefactoringBundle.message(\"field.cannot.be.initialized.in.constructor(s)\"));\n      }\n    }\n    if (errors.size() == 0) {\n      setErrorText(null);\n    }\n    else {\n      setErrorText(StringUtil.join(errors, \"\\n\"));\n    }\n  }","id":25458,"modified_method":"private void checkErrors() {\n    List<String> errors = new ArrayList<String>();\n    if (myCurrentMethodRadioButton.isSelected() && myDeclareFinalCheckBox.isSelected() && !isInvokedInAlwaysInvokedConstructor) {\n      errors.add(GroovyRefactoringBundle.message(\"final.field.cant.be.initialized.in.cur.method\"));\n    }\n    if (myDeclareFinalCheckBox.isSelected() && myReplaceAllOccurrencesCheckBox.isSelected() && myInvokedOnLocalVar != null && hasLHSUsages) {\n      errors.add(GroovyRefactoringBundle.message(\"Field.cannot.be.final.because.replaced.variable.has.lhs.usages\"));\n    }\n    if (!myCanBeInitializedOutsideBlock) {\n      if (myFieldDeclarationRadioButton.isSelected()) {\n        errors.add(GroovyRefactoringBundle.message(\"field.cannot.be.initialized.in.field.declaration\"));\n      }\n      else if (myClassConstructorSRadioButton.isSelected()) {\n        errors.add(GroovyRefactoringBundle.message(\"field.cannot.be.initialized.in.constructor(s)\"));\n      }\n    }\n    if (errors.size() == 0) {\n      setErrorText(null);\n    }\n    else {\n      setErrorText(StringUtil.join(errors, \"\\n\"));\n    }\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isAlwaysInvokedConstructor(PsiMethod method, GrTypeDefinition clazz) {\n    if (method == null) return false;\n    if (!method.isConstructor()) return false;\n    final PsiMethod[] constructors = clazz.getConstructors();\n    if (constructors.length == 1) return true;\n    final GrConstructorInvocation invocation = PsiImplUtil.getChainingConstructorInvocation((GrMethod)method);\n    if (invocation != null && invocation.isThisCall()) return false;\n\n    for (PsiMethod constructor : constructors) {\n      if (constructor == method) continue;\n      final GrConstructorInvocation inv = PsiImplUtil.getChainingConstructorInvocation((GrMethod)constructor);\n      if (inv == null || inv.isSuperCall()) return false;\n    }\n    return true;\n  }","id":25459,"modified_method":"private static boolean isAlwaysInvokedConstructor(PsiMethod method, PsiClass clazz) {\n    if (method == null) return false;\n    if (!method.isConstructor()) return false;\n    final PsiMethod[] constructors = clazz.getConstructors();\n    if (constructors.length == 1) return true;\n    final GrConstructorInvocation invocation = PsiImplUtil.getChainingConstructorInvocation((GrMethod)method);\n    if (invocation != null && invocation.isThisCall()) return false;\n\n    for (PsiMethod constructor : constructors) {\n      if (constructor == method) continue;\n      final GrConstructorInvocation inv = PsiImplUtil.getChainingConstructorInvocation((GrMethod)constructor);\n      if (inv == null || inv.isSuperCall()) return false;\n    }\n    return true;\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void doOKAction() {\n    final GrTypeDefinition clazz = (GrTypeDefinition)myContext.getScope();\n    final String name = getName();\n    String message = RefactoringBundle.message(\"field.exists\", name, clazz.getQualifiedName());\n    if (clazz.findFieldByName(name, true) != null &&\n        showYesNoDialog(myContext.getProject(), message, REFACTORING_NAME, getWarningIcon()) != 0) {\n      return;\n    }\n    super.doOKAction();\n  }","id":25460,"modified_method":"@Override\n  protected void doOKAction() {\n    final PsiClass clazz = (PsiClass)myContext.getScope();\n    final String name = getName();\n    String message = RefactoringBundle.message(\"field.exists\", name, clazz.getQualifiedName());\n    if (clazz.findFieldByName(name, true) != null &&\n        showYesNoDialog(myContext.getProject(), message, REFACTORING_NAME, getWarningIcon()) != 0) {\n      return;\n    }\n    super.doOKAction();\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void checkContainingClass(PsiElement place) {\n    final GrTypeDefinition containingClass = PsiTreeUtil.getParentOfType(place, GrTypeDefinition.class);\n    if (containingClass == null) throw new GrRefactoringError(GroovyRefactoringBundle.message(\"cannot.introduce.field.in.script\"));\n    if (containingClass.isInterface()) {\n      throw new GrRefactoringError(GroovyRefactoringBundle.message(\"cannot.introduce.field.in.interface\"));\n    }\n    if (PsiUtil.skipParentheses(place, false) == null) {\n      throw new GrRefactoringError(GroovyRefactoringBundle.message(\"expression.contains.errors\"));\n    }\n  }","id":25461,"modified_method":"private static void checkContainingClass(PsiElement place) {\n    final PsiClass containingClass = findScopeImpl(place);\n    if (containingClass == null) throw new GrRefactoringError(GroovyRefactoringBundle.message(\"cannot.introduce.field.in.script\"));\n    if (containingClass.isInterface()) {\n      throw new GrRefactoringError(GroovyRefactoringBundle.message(\"cannot.introduce.field.in.interface\"));\n    }\n    if (PsiUtil.skipParentheses(place, false) == null) {\n      throw new GrRefactoringError(GroovyRefactoringBundle.message(\"expression.contains.errors\"));\n    }\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void generateAssignment(GrIntroduceContext context,\n                                         GrIntroduceFieldSettings settings,\n                                         GrField field,\n                                         @Nullable GrStatement anchor,\n                                         GrCodeBlock defaultContainer) {\n    final GrExpression initializer;\n    if (settings.removeLocalVar()) {\n      initializer = extractVarInitializer(context);\n    }\n    else {\n      initializer = context.getExpression();\n    }\n    GrAssignmentExpression init = (GrAssignmentExpression)GroovyPsiElementFactory.getInstance(context.getProject())\n      .createExpressionFromText(settings.getName() + \" = \" + initializer.getText());\n\n    GrCodeBlock block;\n    if (anchor != null) {\n      anchor = GroovyRefactoringUtil.addBlockIntoParent(anchor);\n      LOG.assertTrue(anchor.getParent() instanceof GrCodeBlock);\n      block = (GrCodeBlock)anchor.getParent();\n    }\n    else {\n      block = defaultContainer;\n    }\n    init = (GrAssignmentExpression)block.addStatementBefore(init, anchor);\n    replaceOccurrence(field, init.getLValue());\n  }","id":25462,"modified_method":"private static void generateAssignment(GrIntroduceContext context,\n                                         GrIntroduceFieldSettings settings,\n                                         GrVariable field,\n                                         @Nullable GrStatement anchor,\n                                         GrCodeBlock defaultContainer) {\n    final GrExpression initializer;\n    if (settings.removeLocalVar()) {\n      initializer = extractVarInitializer(context);\n    }\n    else {\n      initializer = context.getExpression();\n    }\n    GrAssignmentExpression init = (GrAssignmentExpression)GroovyPsiElementFactory.getInstance(context.getProject())\n      .createExpressionFromText(settings.getName() + \" = \" + initializer.getText());\n\n    GrCodeBlock block;\n    if (anchor != null) {\n      anchor = GroovyRefactoringUtil.addBlockIntoParent(anchor);\n      LOG.assertTrue(anchor.getParent() instanceof GrCodeBlock);\n      block = (GrCodeBlock)anchor.getParent();\n    }\n    else {\n      block = defaultContainer;\n    }\n    init = (GrAssignmentExpression)block.addStatementBefore(init, anchor);\n    replaceOccurrence(field, init.getLValue(), (PsiClass)context.getScope());\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  static GrMethod getContainingMethod(PsiElement place, GrTypeDefinition clazz) {\n    while (place != null && place != clazz) {\n      place = place.getParent();\n      if (place instanceof GrMethod) return (GrMethod)place;\n    }\n    return null;\n  }","id":25463,"modified_method":"@Nullable\n  static GrMethod getContainingMethod(PsiElement place, PsiElement scope) {\n    while (place != null && place != scope) {\n      place = place.getParent();\n      if (place instanceof GrMethod) return (GrMethod)place;\n    }\n    return null;\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected PsiElement[] findOccurrences(GrExpression expression, PsiElement scope) {\n    final PsiElement[] occurrences = super.findOccurrences(expression, scope);\n    GrTypeDefinition clazz = (GrTypeDefinition)scope;\n    if (shouldBeStatic(expression, clazz)) return occurrences;\n\n    List<PsiElement> filtered = new ArrayList<PsiElement>();\n    for (PsiElement occurrence : occurrences) {\n      if (!shouldBeStatic(occurrence, clazz)) {\n        filtered.add(occurrence);\n      }\n    }\n    return ContainerUtil.toArray(filtered, new PsiElement[filtered.size()]);\n  }","id":25464,"modified_method":"@Override\n  protected PsiElement[] findOccurrences(GrExpression expression, PsiElement scope) {\n    if (scope instanceof GroovyScriptClass) {\n      scope = scope.getContainingFile();\n    }\n    final PsiElement[] occurrences = super.findOccurrences(expression, scope);\n    if (shouldBeStatic(expression, scope)) return occurrences;\n\n    List<PsiElement> filtered = new ArrayList<PsiElement>();\n    for (PsiElement occurrence : occurrences) {\n      if (!shouldBeStatic(occurrence, scope)) {\n        filtered.add(occurrence);\n      }\n    }\n    return ContainerUtil.toArray(filtered, new PsiElement[filtered.size()]);\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected GrTypeDefinition findScope(GrExpression expression, GrVariable variable) {\n    PsiElement place = expression == null ? variable : expression;\n    final GrTypeDefinition scope = PsiTreeUtil.getParentOfType(place, GrTypeDefinition.class);\n    LOG.assertTrue(scope != null);\n    return scope;\n  }","id":25465,"modified_method":"@NotNull\n  @Override\n  protected PsiClass findScope(GrExpression expression, GrVariable variable) {\n    PsiElement place = expression == null ? variable : expression;\n    return ObjectUtils.assertNotNull(findScopeImpl(place));\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void initializeInMethod(GrIntroduceContext context, GrIntroduceFieldSettings settings, GrField field) {\n    if (context.getExpression() == null) return;\n    final GrExpression expression = context.getExpression();\n    final GrTypeDefinition scope = (GrTypeDefinition)context.getScope();\n    final GrMethod method = getContainingMethod(expression, scope);\n    LOG.assertTrue(method != null);\n\n    final GrStatement anchor;\n    if (settings.removeLocalVar()) {\n      GrVariable variable = resolveLocalVar(context);\n      anchor = PsiTreeUtil.getParentOfType(variable, GrStatement.class);\n    }\n    else {\n      anchor = (GrStatement)findAnchor(context, settings, context.getOccurrences(), method.getBlock());\n    }\n\n    generateAssignment(context, settings, field, anchor, method.getBlock());\n  }","id":25466,"modified_method":"private static void initializeInMethod(GrIntroduceContext context, GrIntroduceFieldSettings settings, GrVariable field) {\n    if (context.getExpression() == null) return;\n    final GrExpression expression = context.getExpression();\n    final PsiElement _scope = context.getScope();\n    final PsiElement scope = _scope instanceof GroovyScriptClass? _scope.getContainingFile(): _scope;\n    final GrMethod method = getContainingMethod(expression, scope);\n    LOG.assertTrue(method != null);\n\n    final GrStatement anchor;\n    if (settings.removeLocalVar()) {\n      GrVariable variable = resolveLocalVar(context);\n      anchor = PsiTreeUtil.getParentOfType(variable, GrStatement.class);\n    }\n    else {\n      anchor = (GrStatement)findAnchor(context, settings, context.getOccurrences(), method.getBlock());\n    }\n\n    generateAssignment(context, settings, field, anchor, method.getBlock());\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static boolean shouldBeStatic(PsiElement expr, GrTypeDefinition clazz) {\n    final GrMember method = getContainer(expr, clazz);\n    return method.hasModifierProperty(PsiModifier.STATIC);\n  }","id":25467,"modified_method":"static boolean shouldBeStatic(PsiElement expr, PsiElement clazz) {\n    final GrMember method = getContainer(expr, clazz);\n    if (method == null) return false;\n    return method.hasModifierProperty(PsiModifier.STATIC);\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void replaceOccurrence(GrField field, PsiElement occurrence) {\n    final GrReferenceExpression newExpr = createRefExpression(field, occurrence);\n    final PsiElement replaced;\n    if (occurrence instanceof GrExpression) {\n      replaced = ((GrExpression)occurrence).replaceWithExpression(newExpr, false);\n    } else {\n      replaced = occurrence.replace(newExpr);\n    }\n    if (replaced instanceof GrQualifiedReference<?>) {\n      GrReferenceAdjuster.shortenReference((GrQualifiedReference<?>)replaced);\n    }\n  }","id":25468,"modified_method":"private static void replaceOccurrence(GrVariable field, PsiElement occurrence, PsiClass containingClass) {\n    final GrReferenceExpression newExpr = createRefExpression(field, occurrence, containingClass);\n    final PsiElement replaced;\n    if (occurrence instanceof GrExpression) {\n      replaced = ((GrExpression)occurrence).replaceWithExpression(newExpr, false);\n    } else {\n      replaced = occurrence.replace(newExpr);\n    }\n    if (replaced instanceof GrQualifiedReference<?>) {\n      GrReferenceAdjuster.shortenReference((GrQualifiedReference<?>)replaced);\n    }\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public GrField runRefactoring(GrIntroduceContext context, GrIntroduceFieldSettings settings) {\n    final PsiClass targetClass = (PsiClass)context.getScope();\n\n    if (targetClass == null) return null;\n\n    final GrVariableDeclaration declaration = createField(context, settings);\n\n    final GrVariableDeclaration added;\n    if (targetClass instanceof GrEnumTypeDefinition) {\n      final GrEnumConstantList enumConstants = ((GrEnumTypeDefinition)targetClass).getEnumConstantList();\n      added = (GrVariableDeclaration)targetClass.addAfter(declaration, enumConstants);\n    }\n    else {\n      added = ((GrVariableDeclaration)targetClass.add(declaration));\n    }\n\n    final GrField field = (GrField)added.getVariables()[0];\n    GrIntroduceFieldSettings.Init i = settings.initializeIn();\n\n    if (i == CONSTRUCTOR) {\n      initializeInConstructor(context, settings, field);\n    }\n    else if (i == CUR_METHOD) {\n      initializeInMethod(context, settings, field);\n    }\n\n    GrReferenceAdjuster.shortenReferences(added);\n    \n    //var can be invalid if it was removed while initialization\n    if (settings.removeLocalVar()) {\n      deleteLocalVar(context);\n    }\n\n    if (settings.replaceAllOccurrences()) {\n      GroovyRefactoringUtil.sortOccurrences(context.getOccurrences());\n      for (PsiElement occurrence : context.getOccurrences()) {\n        replaceOccurrence(field, occurrence);\n      }\n    }\n    else {\n      final GrExpression expression = context.getExpression();\n      if (PsiUtil.isExpressionStatement(expression)) {\n        expression.delete();\n      }\n      else {\n        replaceOccurrence(field, expression);\n      }\n    }\n    return field;\n  }","id":25469,"modified_method":"@Override\n  public GrVariable runRefactoring(GrIntroduceContext context, GrIntroduceFieldSettings settings) {\n    final PsiClass targetClass = (PsiClass)context.getScope();\n\n    if (targetClass == null) return null;\n\n    final GrVariableDeclaration declaration = createField(context, settings);\n\n    final GrVariableDeclaration added;\n    if (targetClass instanceof GrEnumTypeDefinition) {\n      final GrEnumConstantList enumConstants = ((GrEnumTypeDefinition)targetClass).getEnumConstantList();\n      added = (GrVariableDeclaration)targetClass.addAfter(declaration, enumConstants);\n    }\n    else {\n      if (targetClass instanceof GrTypeDefinition) {\n        final PsiMethod[] methods = targetClass.getMethods();\n        PsiElement anchor = getFirstElement(methods);\n        added = ((GrTypeDefinition)targetClass).addMemberDeclaration(declaration, anchor);\n      }\n      else {\n        assert targetClass instanceof GroovyScriptClass;\n        final GroovyFile file = (GroovyFile)targetClass.getContainingFile();\n        PsiElement[] elements = file.getMethods();\n        if (elements.length == 0) elements = file.getStatements();\n        final PsiElement anchor = getFirstElement(elements);\n        added = file.addMemberDeclaration(declaration, anchor);\n//        GrReferenceAdjuster.shortenReferences(added.getModifierList());\n      }\n    }\n\n    final GrVariable field = added.getVariables()[0];\n    GrIntroduceFieldSettings.Init i = settings.initializeIn();\n\n    if (i == CONSTRUCTOR) {\n      initializeInConstructor(context, settings, field);\n    }\n    else if (i == CUR_METHOD) {\n      initializeInMethod(context, settings, field);\n    }\n\n    GrReferenceAdjuster.shortenReferences(added);\n\n    //var can be invalid if it was removed while initialization\n    if (settings.removeLocalVar()) {\n      deleteLocalVar(context);\n    }\n\n    if (settings.replaceAllOccurrences()) {\n      GroovyRefactoringUtil.sortOccurrences(context.getOccurrences());\n      for (PsiElement occurrence : context.getOccurrences()) {\n        replaceOccurrence(field, occurrence, targetClass);\n      }\n    }\n    else {\n      final GrExpression expression = context.getExpression();\n      if (PsiUtil.isExpressionStatement(expression)) {\n        expression.delete();\n      }\n      else {\n        replaceOccurrence(field, expression, targetClass);\n      }\n    }\n    return field;\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static GrVariableDeclaration createField(GrIntroduceContext context, GrIntroduceFieldSettings settings) {\n    final String name = settings.getName();\n    final PsiType type = settings.getSelectedType();\n    final String modifier = settings.getVisibilityModifier();\n\n    final GrExpression initializer;\n    if (settings.initializeIn() == FIELD_DECLARATION) {\n      if (settings.removeLocalVar()) {\n        initializer = extractVarInitializer(context);\n      }\n      else {\n        initializer = context.getExpression();\n      }\n    }\n    else {\n      initializer = null;\n    }\n\n    final GrVariableDeclaration fieldDeclaration = GroovyPsiElementFactory.getInstance(context.getProject()).createFieldDeclaration(EMPTY_STRING_ARRAY, name, initializer, type);\n\n    fieldDeclaration.getModifierList().setModifierProperty(modifier, true);\n    if (settings.isStatic()) {\n      fieldDeclaration.getModifierList().setModifierProperty(PsiModifier.STATIC, true);\n    }\n    if (settings.declareFinal()) {\n      fieldDeclaration.getModifierList().setModifierProperty(PsiModifier.FINAL, true);\n    }\n    return fieldDeclaration;\n  }","id":25470,"modified_method":"private static GrVariableDeclaration createField(GrIntroduceContext context, GrIntroduceFieldSettings settings) {\n    final String name = settings.getName();\n    final PsiType type = settings.getSelectedType();\n    final String modifier = settings.getVisibilityModifier();\n\n    final GrExpression initializer;\n    if (settings.initializeIn() == FIELD_DECLARATION) {\n      if (settings.removeLocalVar()) {\n        initializer = extractVarInitializer(context);\n      }\n      else {\n        initializer = context.getExpression();\n      }\n    }\n    else {\n      initializer = null;\n    }\n\n    List<String> modifiers = new ArrayList<String>();\n    if (context.getScope() instanceof GroovyScriptClass) modifiers.add(\"@\"+GroovyCommonClassNames.GROOVY_TRANSFORM_FIELD);\n    if (settings.isStatic()) modifiers.add(PsiModifier.STATIC);\n    if (!PsiModifier.PACKAGE_LOCAL.equals(modifier)) modifiers.add(modifier);\n    if (settings.declareFinal()) modifiers.add(PsiModifier.FINAL);\n\n    final String[] arr_modifiers = ArrayUtil.toStringArray(modifiers);\n    final GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(context.getProject());\n    if (context.getScope() instanceof GroovyScriptClass) {\n      return factory.createVariableDeclaration(arr_modifiers, initializer, type, name);\n    }\n    else {\n      return factory.createFieldDeclaration(arr_modifiers, name, initializer, type);\n    }\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  static GrMember getContainer(PsiElement place, GrTypeDefinition clazz) {\n    while (place != null && place != clazz) {\n      place = place.getParent();\n      if (place instanceof GrMember) return (GrMember)place;\n    }\n    LOG.error(\"container cannot be null\");\n    return null;\n  }","id":25471,"modified_method":"@Nullable\n  static GrMember getContainer(PsiElement place, PsiElement clazz) {\n    while (place != null && place != clazz) {\n      place = place.getParent();\n      if (place instanceof GrMember) return (GrMember)place;\n    }\n    return null;\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static GrReferenceExpression createRefExpression(GrField field, PsiElement place) {\n    final PsiClass containingClass = field.getContainingClass();\n    LOG.assertTrue(containingClass != null);\n    final String qname = containingClass.getQualifiedName();\n    final String prefix = qname != null ? qname + \".\" : \"\";\n    final String refText;\n    if (field.hasModifierProperty(PsiModifier.STATIC)) {\n      refText = prefix + field.getName();\n    }\n    else {\n      refText = prefix + \"this.\" + field.getName();\n    }\n    return GroovyPsiElementFactory.getInstance(place.getProject()).createReferenceExpressionFromText(refText, place);\n  }","id":25472,"modified_method":"private static GrReferenceExpression createRefExpression(GrVariable field, PsiElement place, PsiClass containingClass) {\n    final String qname = containingClass.getQualifiedName();\n    final String prefix = qname != null ? qname + \".\" : \"\";\n    final String refText;\n    if (field.hasModifierProperty(PsiModifier.STATIC)) {\n      refText = prefix + field.getName();\n    }\n    else {\n      refText = prefix + \"this.\" + field.getName();\n    }\n    return GroovyPsiElementFactory.getInstance(place.getProject()).createReferenceExpressionFromText(refText, place);\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void initializeInConstructor(GrIntroduceContext context, GrIntroduceFieldSettings settings, GrField field) {\n    final GrTypeDefinition scope = (GrTypeDefinition)context.getScope();\n    final GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(context.getProject());\n\n    if (scope instanceof GrAnonymousClassDefinition) {\n      final GrClassInitializer[] initializers = scope.getInitializers();\n      final GrClassInitializer initializer;\n      if (initializers.length == 0) {\n        initializer = (GrClassInitializer)scope.add(factory.createClassInitializer());\n      }\n      else {\n        initializer = initializers[0];\n      }\n\n      final PsiElement anchor = findAnchor(context, settings, initializer.getBlock());\n      generateAssignment(context, settings, field, (GrStatement)anchor, initializer.getBlock());\n      return;\n    }\n\n    PsiMethod[] constructors = scope.getConstructors();\n    if (constructors.length == 0) {\n      final String name = scope.getName();\n      LOG.assertTrue(name != null, scope.getText());\n      final GrMethod constructor = factory.createConstructorFromText(name, EMPTY_STRING_ARRAY, EMPTY_STRING_ARRAY, \"{}\", scope);\n      final PsiElement added = scope.add(constructor);\n      constructors = new PsiMethod[]{(PsiMethod)added};\n    }\n    for (PsiMethod constructor : constructors) {\n      final GrConstructorInvocation invocation = PsiImplUtil.getChainingConstructorInvocation((GrMethod)constructor);\n      if (invocation != null && invocation.isThisCall()) continue;\n      final PsiElement anchor = findAnchor(context, settings, ((GrMethod)constructor).getBlock());\n\n      generateAssignment(context, settings, field, (GrStatement)anchor, ((GrMethod)constructor).getBlock());\n    }\n  }","id":25473,"modified_method":"private static void initializeInConstructor(GrIntroduceContext context, GrIntroduceFieldSettings settings, GrVariable field) {\n    final PsiClass scope = (PsiClass)context.getScope();\n    final GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(context.getProject());\n\n    if (scope instanceof GrAnonymousClassDefinition) {\n      final GrClassInitializer[] initializers = ((GrAnonymousClassDefinition)scope).getInitializers();\n      final GrClassInitializer initializer;\n      if (initializers.length == 0) {\n        initializer = (GrClassInitializer)scope.add(factory.createClassInitializer());\n      }\n      else {\n        initializer = initializers[0];\n      }\n\n      final PsiElement anchor = findAnchor(context, settings, initializer.getBlock());\n      generateAssignment(context, settings, field, (GrStatement)anchor, initializer.getBlock());\n      return;\n    }\n\n    PsiMethod[] constructors = scope.getConstructors();\n    if (constructors.length == 0) {\n      final String name = scope.getName();\n      LOG.assertTrue(name != null, scope.getText());\n      final GrMethod constructor = factory.createConstructorFromText(name, EMPTY_STRING_ARRAY, EMPTY_STRING_ARRAY, \"{}\", scope);\n      final PsiElement added = scope.add(constructor);\n      constructors = new PsiMethod[]{(PsiMethod)added};\n    }\n    for (PsiMethod constructor : constructors) {\n      final GrConstructorInvocation invocation = PsiImplUtil.getChainingConstructorInvocation((GrMethod)constructor);\n      if (invocation != null && invocation.isThisCall()) continue;\n      final PsiElement anchor = findAnchor(context, settings, ((GrMethod)constructor).getBlock());\n\n      generateAssignment(context, settings, field, (GrStatement)anchor, ((GrMethod)constructor).getBlock());\n    }\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public <T extends GrMembersDeclaration> T addMemberDeclaration(@NotNull T decl, PsiElement anchorBefore)\n    throws IncorrectOperationException {\n    T result = (T)addBefore(decl, anchorBefore);\n    CodeStyleManager styleManager = CodeStyleManager.getInstance(getManager().getProject());\n    PsiElement parent = result.getContainingFile();\n    TextRange range = result.getTextRange();\n    styleManager.reformatRange(parent, range.getEndOffset() - 1, range.getEndOffset() + 1);\n    styleManager.reformatRange(parent, range.getStartOffset() - 1, range.getStartOffset() + 1);\n\n    return result;\n  }","id":25474,"modified_method":"public <T extends GrMembersDeclaration> T addMemberDeclaration(@NotNull T decl, PsiElement anchorBefore)\n    throws IncorrectOperationException {\n    T result = (T)addBefore(decl, anchorBefore);\n    CodeStyleManager styleManager = CodeStyleManager.getInstance(getManager().getProject());\n    PsiElement parent = result.getContainingFile();\n    TextRange range = result.getTextRange();\n    if (checkRange(parent, range.getEndOffset())) {\n      styleManager.reformatRange(parent, range.getEndOffset() - 1, range.getEndOffset() + 1);\n    }\n    if (checkRange(parent, range.getStartOffset())) {\n      styleManager.reformatRange(parent, range.getStartOffset() - 1, range.getStartOffset() + 1);\n    }\n\n    return result;\n  }","commit_id":"5f1ccc9c45085b604d6cf94d4c3c3872f64211be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void writeGlobalState(String reason, MetaData metaData) throws Exception {\n        logger.trace(\"{} writing state, reason [{}]\", GLOBAL_STATE_LOG_TYPE, reason);\n        final MetaDataStateFormat<MetaData> writer = globalStateFormat(format, gatewayModeFormatParams, true);\n        try {\n            writer.write(metaData, GLOBAL_STATE_FILE_PREFIX, metaData.version(), nodeEnv.nodeDataLocations());\n        } catch (Throwable ex) {\n            logger.warn(\"{}: failed to write global state\", ex, GLOBAL_STATE_LOG_TYPE);\n            throw new IOException(\"failed to write global state\", ex);\n        }\n    }","id":25475,"modified_method":"private void writeGlobalState(String reason, MetaData metaData) throws Exception {\n        logger.trace(\"{} writing state, reason [{}]\", GLOBAL_STATE_LOG_TYPE, reason);\n        final MetaDataStateFormat<MetaData> writer = globalStateFormat(format, gatewayModeFormatParams, true);\n        try {\n            writer.write(metaData, GLOBAL_STATE_FILE_PREFIX, metaData.version(), nodeEnv.nodeDataPaths());\n        } catch (Throwable ex) {\n            logger.warn(\"{}: failed to write global state\", ex, GLOBAL_STATE_LOG_TYPE);\n            throw new IOException(\"failed to write global state\", ex);\n        }\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void writeIndex(String reason, IndexMetaData indexMetaData, @Nullable IndexMetaData previousIndexMetaData) throws Exception {\n        logger.trace(\"[{}] writing state, reason [{}]\", indexMetaData.index(), reason);\n        final boolean deleteOldFiles = previousIndexMetaData != null && previousIndexMetaData.version() != indexMetaData.version();\n        final MetaDataStateFormat<IndexMetaData> writer = indexStateFormat(format, formatParams, deleteOldFiles);\n        try {\n            writer.write(indexMetaData, INDEX_STATE_FILE_PREFIX, indexMetaData.version(), nodeEnv.indexLocations(new Index(indexMetaData.index())));\n        } catch (Throwable ex) {\n            logger.warn(\"[{}]: failed to write index state\", ex, indexMetaData.index());\n            throw new IOException(\"failed to write state for [\" + indexMetaData.index() + \"]\", ex);\n        }\n    }","id":25476,"modified_method":"private void writeIndex(String reason, IndexMetaData indexMetaData, @Nullable IndexMetaData previousIndexMetaData) throws Exception {\n        logger.trace(\"[{}] writing state, reason [{}]\", indexMetaData.index(), reason);\n        final boolean deleteOldFiles = previousIndexMetaData != null && previousIndexMetaData.version() != indexMetaData.version();\n        final MetaDataStateFormat<IndexMetaData> writer = indexStateFormat(format, formatParams, deleteOldFiles);\n        try {\n            writer.write(indexMetaData, INDEX_STATE_FILE_PREFIX, indexMetaData.version(), nodeEnv.indexPaths(new Index(indexMetaData.index())));\n        } catch (Throwable ex) {\n            logger.warn(\"[{}]: failed to write index state\", ex, indexMetaData.index());\n            throw new IOException(\"failed to write state for [\" + indexMetaData.index() + \"]\", ex);\n        }\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void clusterChanged(ClusterChangedEvent event) {\n        if (event.state().blocks().disableStatePersistence()) {\n            // reset the current metadata, we need to start fresh...\n            this.currentMetaData = null;\n            return;\n        }\n\n        MetaData newMetaData = event.state().metaData();\n        // we don't check if metaData changed, since we might be called several times and we need to check dangling...\n\n        boolean success = true;\n        // only applied to master node, writing the global and index level states\n        if (event.state().nodes().localNode().masterNode()) {\n            // check if the global state changed?\n            if (currentMetaData == null || !MetaData.isGlobalStateEquals(currentMetaData, newMetaData)) {\n                try {\n                    writeGlobalState(\"changed\", newMetaData);\n                } catch (Throwable e) {\n                    success = false;\n                }\n            }\n\n            // check and write changes in indices\n            for (IndexMetaData indexMetaData : newMetaData) {\n                String writeReason = null;\n                IndexMetaData currentIndexMetaData;\n                if (currentMetaData == null) {\n                    // a new event..., check from the state stored\n                    currentIndexMetaData = loadIndexState(indexMetaData.index());\n                } else {\n                    currentIndexMetaData = currentMetaData.index(indexMetaData.index());\n                }\n                if (currentIndexMetaData == null) {\n                    writeReason = \"freshly created\";\n                } else if (currentIndexMetaData.version() != indexMetaData.version()) {\n                    writeReason = \"version changed from [\" + currentIndexMetaData.version() + \"] to [\" + indexMetaData.version() + \"]\";\n                }\n\n                // we update the writeReason only if we really need to write it\n                if (writeReason == null) {\n                    continue;\n                }\n\n                try {\n                    writeIndex(writeReason, indexMetaData, currentIndexMetaData);\n                } catch (Throwable e) {\n                    success = false;\n                }\n            }\n        }\n\n        // delete indices that were there before, but are deleted now\n        // we need to do it so they won't be detected as dangling\n        if (currentMetaData != null) {\n            // only delete indices when we already received a state (currentMetaData != null)\n            // and we had a go at processing dangling indices at least once\n            // this will also delete the _state of the index itself\n            for (IndexMetaData current : currentMetaData) {\n                if (danglingIndices.containsKey(current.index())) {\n                    continue;\n                }\n                if (!newMetaData.hasIndex(current.index())) {\n                    logger.debug(\"[{}] deleting index that is no longer part of the metadata (indices: [{}])\", current.index(), newMetaData.indices().keys());\n                    if (nodeEnv.hasNodeFile()) {\n                        try {\n                            final Index idx = new Index(current.index());\n                            MetaDataStateFormat.deleteMetaState(nodeEnv.indexPaths(idx));\n                            nodeEnv.deleteIndexDirectorySafe(idx);\n                        } catch (LockObtainFailedException ex) {\n                            logger.debug(\"[{}] failed to delete index - at least one shards is still locked\", ex, current.index());\n                        } catch (Exception ex) {\n                            logger.warn(\"[{}] failed to delete index\", ex, current.index());\n                        }\n                    }\n                    try {\n                        nodeIndexDeletedAction.nodeIndexStoreDeleted(event.state(), current.index(), event.state().nodes().localNodeId());\n                    } catch (Throwable e) {\n                        logger.debug(\"[{}] failed to notify master on local index store deletion\", e, current.index());\n                    }\n                }\n            }\n        }\n\n        // handle dangling indices, we handle those for all nodes that have a node file (data or master)\n        if (nodeEnv.hasNodeFile()) {\n            if (danglingTimeout.millis() >= 0) {\n                synchronized (danglingMutex) {\n                    for (String danglingIndex : danglingIndices.keySet()) {\n                        if (newMetaData.hasIndex(danglingIndex)) {\n                            logger.debug(\"[{}] no longer dangling (created), removing\", danglingIndex);\n                            DanglingIndex removed = danglingIndices.remove(danglingIndex);\n                            FutureUtils.cancel(removed.future);\n                        }\n                    }\n                    // delete indices that are no longer part of the metadata\n                    try {\n                        for (String indexName : nodeEnv.findAllIndices()) {\n                            // if we have the index on the metadata, don't delete it\n                            if (newMetaData.hasIndex(indexName)) {\n                                continue;\n                            }\n                            if (danglingIndices.containsKey(indexName)) {\n                                // already dangling, continue\n                                continue;\n                            }\n                            final IndexMetaData indexMetaData = loadIndexState(indexName);\n                            final Index index = new Index(indexName);\n                            if (indexMetaData != null) {\n                                try {\n                                    // the index deletion might not have worked due to shards still being locked\n                                    // we have three cases here:\n                                    //  - we acquired all shards locks here --> we can import the dangeling index\n                                    //  - we failed to acquire the lock --> somebody else uses it - DON'T IMPORT\n                                    //  - we acquired successfully but the lock list is empty --> no shards present - DON'T IMPORT\n                                    // in the last case we should in-fact try to delete the directory since it might be a leftover...\n                                    final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index);\n                                    if (shardLocks.isEmpty()) {\n                                        // no shards - try to remove the directory\n                                        nodeEnv.deleteIndexDirectorySafe(index);\n                                        continue;\n                                    }\n                                    IOUtils.closeWhileHandlingException(shardLocks);\n                                } catch (IOException ex) {\n                                    logger.warn(\"[{}] skipping locked dangling index, exists on local file system, but not in cluster metadata, auto import to cluster state is set to [{}]\", ex, indexName, autoImportDangled);\n                                    continue;\n                                }\n                                if(autoImportDangled.shouldImport()){\n                                    logger.info(\"[{}] dangling index, exists on local file system, but not in cluster metadata, auto import to cluster state [{}]\", indexName, autoImportDangled);\n                                    danglingIndices.put(indexName, new DanglingIndex(indexName, null));\n                                } else if (danglingTimeout.millis() == 0) {\n                                    logger.info(\"[{}] dangling index, exists on local file system, but not in cluster metadata, timeout set to 0, deleting now\", indexName);\n                                    try {\n                                        nodeEnv.deleteIndexDirectorySafe(index);\n                                    } catch (LockObtainFailedException ex) {\n                                        logger.debug(\"[{}] failed to delete index - at least one shards is still locked\", ex, indexName);\n                                    } catch (Exception ex) {\n                                        logger.warn(\"[{}] failed to delete dangling index\", ex, indexName);\n                                    }\n                                } else {\n                                    logger.info(\"[{}] dangling index, exists on local file system, but not in cluster metadata, scheduling to delete in [{}], auto import to cluster state [{}]\", indexName, danglingTimeout, autoImportDangled);\n                                    danglingIndices.put(indexName, new DanglingIndex(indexName, threadPool.schedule(danglingTimeout, ThreadPool.Names.SAME, new RemoveDanglingIndex(index))));\n                                }\n                            }\n                        }\n                    } catch (Throwable e) {\n                        logger.warn(\"failed to find dangling indices\", e);\n                    }\n                }\n            }\n            if (autoImportDangled.shouldImport() && !danglingIndices.isEmpty()) {\n                final List<IndexMetaData> dangled = Lists.newArrayList();\n                for (String indexName : danglingIndices.keySet()) {\n                    IndexMetaData indexMetaData = loadIndexState(indexName);\n                    if (indexMetaData == null) {\n                        logger.debug(\"failed to find state for dangling index [{}]\", indexName);\n                        continue;\n                    }\n                    // we might have someone copying over an index, renaming the directory, handle that\n                    if (!indexMetaData.index().equals(indexName)) {\n                        logger.info(\"dangled index directory name is [{}], state name is [{}], renaming to directory name\", indexName, indexMetaData.index());\n                        indexMetaData = IndexMetaData.builder(indexMetaData).index(indexName).build();\n                    }\n                    if (autoImportDangled == AutoImportDangledState.CLOSED) {\n                        indexMetaData = IndexMetaData.builder(indexMetaData).state(IndexMetaData.State.CLOSE).build();\n                    }\n                    if (indexMetaData != null) {\n                        dangled.add(indexMetaData);\n                    }\n                }\n                IndexMetaData[] dangledIndices = dangled.toArray(new IndexMetaData[dangled.size()]);\n                try {\n                    allocateDangledIndices.allocateDangled(dangledIndices, new LocalAllocateDangledIndices.Listener() {\n                        @Override\n                        public void onResponse(LocalAllocateDangledIndices.AllocateDangledResponse response) {\n                            logger.trace(\"allocated dangled\");\n                        }\n\n                        @Override\n                        public void onFailure(Throwable e) {\n                            logger.info(\"failed to send allocated dangled\", e);\n                        }\n                    });\n                } catch (Throwable e) {\n                    logger.warn(\"failed to send allocate dangled\", e);\n                }\n            }\n        }\n\n        if (success) {\n            currentMetaData = newMetaData;\n        }\n    }","id":25477,"modified_method":"@Override\n    public void clusterChanged(ClusterChangedEvent event) {\n        if (event.state().blocks().disableStatePersistence()) {\n            // reset the current metadata, we need to start fresh...\n            this.currentMetaData = null;\n            return;\n        }\n\n        MetaData newMetaData = event.state().metaData();\n        // we don't check if metaData changed, since we might be called several times and we need to check dangling...\n\n        boolean success = true;\n        // only applied to master node, writing the global and index level states\n        if (event.state().nodes().localNode().masterNode()) {\n            // check if the global state changed?\n            if (currentMetaData == null || !MetaData.isGlobalStateEquals(currentMetaData, newMetaData)) {\n                try {\n                    writeGlobalState(\"changed\", newMetaData);\n                } catch (Throwable e) {\n                    success = false;\n                }\n            }\n\n            // check and write changes in indices\n            for (IndexMetaData indexMetaData : newMetaData) {\n                String writeReason = null;\n                IndexMetaData currentIndexMetaData;\n                if (currentMetaData == null) {\n                    // a new event..., check from the state stored\n                    try {\n                        currentIndexMetaData = loadIndexState(indexMetaData.index());\n                    } catch (IOException ex) {\n                        throw new ElasticsearchException(\"failed to load index state\", ex);\n                    }\n                } else {\n                    currentIndexMetaData = currentMetaData.index(indexMetaData.index());\n                }\n                if (currentIndexMetaData == null) {\n                    writeReason = \"freshly created\";\n                } else if (currentIndexMetaData.version() != indexMetaData.version()) {\n                    writeReason = \"version changed from [\" + currentIndexMetaData.version() + \"] to [\" + indexMetaData.version() + \"]\";\n                }\n\n                // we update the writeReason only if we really need to write it\n                if (writeReason == null) {\n                    continue;\n                }\n\n                try {\n                    writeIndex(writeReason, indexMetaData, currentIndexMetaData);\n                } catch (Throwable e) {\n                    success = false;\n                }\n            }\n        }\n\n        // delete indices that were there before, but are deleted now\n        // we need to do it so they won't be detected as dangling\n        if (currentMetaData != null) {\n            // only delete indices when we already received a state (currentMetaData != null)\n            // and we had a go at processing dangling indices at least once\n            // this will also delete the _state of the index itself\n            for (IndexMetaData current : currentMetaData) {\n                if (danglingIndices.containsKey(current.index())) {\n                    continue;\n                }\n                if (!newMetaData.hasIndex(current.index())) {\n                    logger.debug(\"[{}] deleting index that is no longer part of the metadata (indices: [{}])\", current.index(), newMetaData.indices().keys());\n                    if (nodeEnv.hasNodeFile()) {\n                        try {\n                            final Index idx = new Index(current.index());\n                            MetaDataStateFormat.deleteMetaState(nodeEnv.indexPaths(idx));\n                            nodeEnv.deleteIndexDirectorySafe(idx);\n                        } catch (LockObtainFailedException ex) {\n                            logger.debug(\"[{}] failed to delete index - at least one shards is still locked\", ex, current.index());\n                        } catch (Exception ex) {\n                            logger.warn(\"[{}] failed to delete index\", ex, current.index());\n                        }\n                    }\n                    try {\n                        nodeIndexDeletedAction.nodeIndexStoreDeleted(event.state(), current.index(), event.state().nodes().localNodeId());\n                    } catch (Throwable e) {\n                        logger.debug(\"[{}] failed to notify master on local index store deletion\", e, current.index());\n                    }\n                }\n            }\n        }\n\n        // handle dangling indices, we handle those for all nodes that have a node file (data or master)\n        if (nodeEnv.hasNodeFile()) {\n            if (danglingTimeout.millis() >= 0) {\n                synchronized (danglingMutex) {\n                    for (String danglingIndex : danglingIndices.keySet()) {\n                        if (newMetaData.hasIndex(danglingIndex)) {\n                            logger.debug(\"[{}] no longer dangling (created), removing\", danglingIndex);\n                            DanglingIndex removed = danglingIndices.remove(danglingIndex);\n                            FutureUtils.cancel(removed.future);\n                        }\n                    }\n                    // delete indices that are no longer part of the metadata\n                    try {\n                        for (String indexName : nodeEnv.findAllIndices()) {\n                            // if we have the index on the metadata, don't delete it\n                            if (newMetaData.hasIndex(indexName)) {\n                                continue;\n                            }\n                            if (danglingIndices.containsKey(indexName)) {\n                                // already dangling, continue\n                                continue;\n                            }\n                            final IndexMetaData indexMetaData = loadIndexState(indexName);\n                            final Index index = new Index(indexName);\n                            if (indexMetaData != null) {\n                                try {\n                                    // the index deletion might not have worked due to shards still being locked\n                                    // we have three cases here:\n                                    //  - we acquired all shards locks here --> we can import the dangeling index\n                                    //  - we failed to acquire the lock --> somebody else uses it - DON'T IMPORT\n                                    //  - we acquired successfully but the lock list is empty --> no shards present - DON'T IMPORT\n                                    // in the last case we should in-fact try to delete the directory since it might be a leftover...\n                                    final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index);\n                                    if (shardLocks.isEmpty()) {\n                                        // no shards - try to remove the directory\n                                        nodeEnv.deleteIndexDirectorySafe(index);\n                                        continue;\n                                    }\n                                    IOUtils.closeWhileHandlingException(shardLocks);\n                                } catch (IOException ex) {\n                                    logger.warn(\"[{}] skipping locked dangling index, exists on local file system, but not in cluster metadata, auto import to cluster state is set to [{}]\", ex, indexName, autoImportDangled);\n                                    continue;\n                                }\n                                if(autoImportDangled.shouldImport()){\n                                    logger.info(\"[{}] dangling index, exists on local file system, but not in cluster metadata, auto import to cluster state [{}]\", indexName, autoImportDangled);\n                                    danglingIndices.put(indexName, new DanglingIndex(indexName, null));\n                                } else if (danglingTimeout.millis() == 0) {\n                                    logger.info(\"[{}] dangling index, exists on local file system, but not in cluster metadata, timeout set to 0, deleting now\", indexName);\n                                    try {\n                                        nodeEnv.deleteIndexDirectorySafe(index);\n                                    } catch (LockObtainFailedException ex) {\n                                        logger.debug(\"[{}] failed to delete index - at least one shards is still locked\", ex, indexName);\n                                    } catch (Exception ex) {\n                                        logger.warn(\"[{}] failed to delete dangling index\", ex, indexName);\n                                    }\n                                } else {\n                                    logger.info(\"[{}] dangling index, exists on local file system, but not in cluster metadata, scheduling to delete in [{}], auto import to cluster state [{}]\", indexName, danglingTimeout, autoImportDangled);\n                                    danglingIndices.put(indexName, new DanglingIndex(indexName, threadPool.schedule(danglingTimeout, ThreadPool.Names.SAME, new RemoveDanglingIndex(index))));\n                                }\n                            }\n                        }\n                    } catch (Throwable e) {\n                        logger.warn(\"failed to find dangling indices\", e);\n                    }\n                }\n            }\n            if (autoImportDangled.shouldImport() && !danglingIndices.isEmpty()) {\n                final List<IndexMetaData> dangled = Lists.newArrayList();\n                for (String indexName : danglingIndices.keySet()) {\n                    IndexMetaData indexMetaData;\n                    try {\n                        indexMetaData = loadIndexState(indexName);\n                    } catch (IOException ex) {\n                        throw new ElasticsearchException(\"failed to load index state\", ex);\n                    }\n                    if (indexMetaData == null) {\n                        logger.debug(\"failed to find state for dangling index [{}]\", indexName);\n                        continue;\n                    }\n                    // we might have someone copying over an index, renaming the directory, handle that\n                    if (!indexMetaData.index().equals(indexName)) {\n                        logger.info(\"dangled index directory name is [{}], state name is [{}], renaming to directory name\", indexName, indexMetaData.index());\n                        indexMetaData = IndexMetaData.builder(indexMetaData).index(indexName).build();\n                    }\n                    if (autoImportDangled == AutoImportDangledState.CLOSED) {\n                        indexMetaData = IndexMetaData.builder(indexMetaData).state(IndexMetaData.State.CLOSE).build();\n                    }\n                    if (indexMetaData != null) {\n                        dangled.add(indexMetaData);\n                    }\n                }\n                IndexMetaData[] dangledIndices = dangled.toArray(new IndexMetaData[dangled.size()]);\n                try {\n                    allocateDangledIndices.allocateDangled(dangledIndices, new LocalAllocateDangledIndices.Listener() {\n                        @Override\n                        public void onResponse(LocalAllocateDangledIndices.AllocateDangledResponse response) {\n                            logger.trace(\"allocated dangled\");\n                        }\n\n                        @Override\n                        public void onFailure(Throwable e) {\n                            logger.info(\"failed to send allocated dangled\", e);\n                        }\n                    });\n                } catch (Throwable e) {\n                    logger.warn(\"failed to send allocate dangled\", e);\n                }\n            }\n        }\n\n        if (success) {\n            currentMetaData = newMetaData;\n        }\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private MetaData loadGlobalState() {\n        return MetaDataStateFormat.loadLatestState(logger, globalStateFormat(format, gatewayModeFormatParams, true), GLOBAL_STATE_FILE_PATTERN, GLOBAL_STATE_LOG_TYPE, nodeEnv.nodeDataLocations());\n    }","id":25478,"modified_method":"private MetaData loadGlobalState() throws IOException {\n        return MetaDataStateFormat.loadLatestState(logger, globalStateFormat(format, gatewayModeFormatParams, true), GLOBAL_STATE_FILE_PATTERN, GLOBAL_STATE_LOG_TYPE, nodeEnv.nodeDataPaths());\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Nullable\n    private IndexMetaData loadIndexState(String index) {\n        return MetaDataStateFormat.loadLatestState(logger, indexStateFormat(format, formatParams, true), INDEX_STATE_FILE_PATTERN, \"[\" + index + \"]\", nodeEnv.indexLocations(new Index(index)));\n    }","id":25479,"modified_method":"@Nullable\n    private IndexMetaData loadIndexState(String index) throws IOException {\n        return MetaDataStateFormat.loadLatestState(logger, indexStateFormat(format, formatParams, true), INDEX_STATE_FILE_PATTERN, \"[\" + index + \"]\", nodeEnv.indexPaths(new Index(index)));\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void writeShardState(String reason, ShardId shardId, ShardStateInfo shardStateInfo, @Nullable ShardStateInfo previousStateInfo) throws Exception {\n        logger.trace(\"{} writing shard state, reason [{}]\", shardId, reason);\n        final boolean deleteOldFiles = previousStateInfo != null && previousStateInfo.version != shardStateInfo.version;\n        newShardStateInfoFormat(deleteOldFiles).write(shardStateInfo, SHARD_STATE_FILE_PREFIX, shardStateInfo.version, nodeEnv.shardLocations(shardId));\n    }","id":25480,"modified_method":"private void writeShardState(String reason, ShardId shardId, ShardStateInfo shardStateInfo, @Nullable ShardStateInfo previousStateInfo) throws Exception {\n        logger.trace(\"{} writing shard state, reason [{}]\", shardId, reason);\n        final boolean deleteOldFiles = previousStateInfo != null && previousStateInfo.version != shardStateInfo.version;\n        newShardStateInfoFormat(deleteOldFiles).write(shardStateInfo, SHARD_STATE_FILE_PREFIX, shardStateInfo.version, nodeEnv.shardPaths(shardId));\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private ShardStateInfo loadShardStateInfo(ShardId shardId) {\n        return MetaDataStateFormat.loadLatestState(logger, newShardStateInfoFormat(false), SHARD_STATE_FILE_PATTERN, shardId.toString(), nodeEnv.shardLocations(shardId));\n    }","id":25481,"modified_method":"private ShardStateInfo loadShardStateInfo(ShardId shardId) throws IOException {\n        return MetaDataStateFormat.loadLatestState(logger, newShardStateInfoFormat(false), SHARD_STATE_FILE_PATTERN, shardId.toString(), nodeEnv.shardPaths(shardId));\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public boolean apply(FileAndVersion input) {\n            return input.version == version && input.legacy == legacy;\n        }","id":25482,"modified_method":"@Override\n        public boolean apply(PathAndVersion input) {\n            return input.version == version && input.legacy == legacy;\n        }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected Directory newDirectory(File dir) throws IOException {\n        return new SimpleFSDirectory(dir.toPath());\n    }","id":25483,"modified_method":"protected Directory newDirectory(Path dir) throws IOException {\n        return new SimpleFSDirectory(dir);\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Reads the state from a given file and compares the expected version against the actual version of\n     * the state.\n     */\n    public final T read(File file, long expectedVersion) throws IOException {\n        try (Directory dir = newDirectory(file.getParentFile())) {\n            try (final IndexInput indexInput = dir.openInput(file.getName(), IOContext.DEFAULT)) {\n                 // We checksum the entire file before we even go and parse it. If it's corrupted we barf right here.\n                CodecUtil.checksumEntireFile(indexInput);\n                CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, STATE_FILE_VERSION, STATE_FILE_VERSION);\n                final XContentType xContentType = XContentType.values()[indexInput.readInt()];\n                final long version = indexInput.readLong();\n                if (version != expectedVersion) {\n                    throw new CorruptStateException(\"State version mismatch expected: \" + expectedVersion + \" but was: \" + version);\n                }\n                long filePointer = indexInput.getFilePointer();\n                long contentSize = indexInput.length() - CodecUtil.footerLength() - filePointer;\n                try (IndexInput slice = indexInput.slice(\"state_xcontent\", filePointer, contentSize)) {\n                    try (XContentParser parser = XContentFactory.xContent(xContentType).createParser(new InputStreamIndexInput(slice, contentSize))) {\n                        return fromXContent(parser);\n                    }\n                }\n            } catch(CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {\n                // we trick this into a dedicated exception with the original stacktrace\n                throw new CorruptStateException(ex);\n            }\n        }\n    }","id":25484,"modified_method":"/**\n     * Reads the state from a given file and compares the expected version against the actual version of\n     * the state.\n     */\n    public final T read(Path file, long expectedVersion) throws IOException {\n        try (Directory dir = newDirectory(file.getParent())) {\n            try (final IndexInput indexInput = dir.openInput(file.getFileName().toString(), IOContext.DEFAULT)) {\n                 // We checksum the entire file before we even go and parse it. If it's corrupted we barf right here.\n                CodecUtil.checksumEntireFile(indexInput);\n                CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, STATE_FILE_VERSION, STATE_FILE_VERSION);\n                final XContentType xContentType = XContentType.values()[indexInput.readInt()];\n                final long version = indexInput.readLong();\n                if (version != expectedVersion) {\n                    throw new CorruptStateException(\"State version mismatch expected: \" + expectedVersion + \" but was: \" + version);\n                }\n                long filePointer = indexInput.getFilePointer();\n                long contentSize = indexInput.length() - CodecUtil.footerLength() - filePointer;\n                try (IndexInput slice = indexInput.slice(\"state_xcontent\", filePointer, contentSize)) {\n                    try (XContentParser parser = XContentFactory.xContent(xContentType).createParser(new InputStreamIndexInput(slice, contentSize))) {\n                        return fromXContent(parser);\n                    }\n                }\n            } catch(CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {\n                // we trick this into a dedicated exception with the original stacktrace\n                throw new CorruptStateException(ex);\n            }\n        }\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tries to load the latest state from the given data-locations. It tries to load the latest state determined by\n     * the states version from one or more data directories and if none of the latest states can be loaded an exception\n     * is thrown to prevent accidentally loading a previous state and silently omitting the latest state.\n     *\n     * @param logger an elasticsearch logger instance\n     * @param format the actual metastate format to use\n     * @param pattern the file name pattern to identify files belonging to this pattern and to read the version from.\n     *                The first capture group should return the version of the file. If the second capture group is has a\n     *                null value the files is considered a legacy file and will be treated as if the file contains a plain\n     *                x-content payload.\n     * @param stateType the state type we are loading. used for logging contenxt only.\n     * @param dataLocations the data-locations to try.\n     * @return the latest state or <code>null<\/code> if no state was found.\n     */\n    public static <T> T loadLatestState(ESLogger logger, MetaDataStateFormat<T> format, Pattern pattern, String stateType, File... dataLocations) {\n        List<FileAndVersion> files = new ArrayList<>();\n        long maxVersion = -1;\n        boolean maxVersionIsLegacy = true;\n        if (dataLocations != null) { // select all eligable files first\n            for (File dataLocation : dataLocations) {\n                File stateDir = new File(dataLocation, MetaDataStateFormat.STATE_DIR_NAME);\n                if (!stateDir.exists() || !stateDir.isDirectory()) {\n                    continue;\n                }\n                // now, iterate over the current versions, and find latest one\n                File[] stateFiles = stateDir.listFiles();\n                if (stateFiles == null) {\n                    continue;\n                }\n                for (File stateFile : stateFiles) {\n                    final Matcher matcher = pattern.matcher(stateFile.getName());\n                    if (matcher.matches()) {\n                        final long version = Long.parseLong(matcher.group(1));\n                        maxVersion = Math.max(maxVersion, version);\n                        final boolean legacy = MetaDataStateFormat.STATE_FILE_EXTENSION.equals(matcher.group(2)) == false;\n                        maxVersionIsLegacy &= legacy; // on purpose, see NOTE below\n                        files.add(new FileAndVersion(stateFile, version, legacy));\n                    }\n                }\n            }\n        }\n        final List<Throwable> exceptions = new ArrayList<>();\n        T state = null;\n        // NOTE: we might have multiple version of the latest state if there are multiple data dirs.. for this case\n        //       we iterate only over the ones with the max version. If we have at least one state file that uses the\n        //       new format (ie. legacy == false) then we know that the latest version state ought to use this new format.\n        //       In case the state file with the latest version does not use the new format while older state files do,\n        //       the list below will be empty and loading the state will fail\n        for (FileAndVersion fileAndVersion : Collections2.filter(files, new VersionAndLegacyPredicate(maxVersion, maxVersionIsLegacy))) {\n            try {\n                final File stateFile = fileAndVersion.file;\n                final long version = fileAndVersion.version;\n                final XContentParser parser;\n                if (fileAndVersion.legacy) { // read the legacy format -- plain XContent\n                    try (FileInputStream stream = new FileInputStream(stateFile)) {\n                        final byte[] data = Streams.copyToByteArray(stream);\n                        if (data.length == 0) {\n                            logger.debug(\"{}: no data for [{}], ignoring...\", stateType, stateFile.getAbsolutePath());\n                            continue;\n                        }\n                        parser = XContentHelper.createParser(data, 0, data.length);\n                        state = format.fromXContent(parser);\n                        if (state == null) {\n                            logger.debug(\"{}: no data for [{}], ignoring...\", stateType, stateFile.getAbsolutePath());\n                        }\n                    }\n                } else {\n                    state = format.read(stateFile, version);\n                }\n                return state;\n            } catch (Throwable e) {\n                exceptions.add(e);\n                logger.debug(\"{}: failed to read [{}], ignoring...\", e, fileAndVersion.file.getAbsolutePath(), stateType);\n            }\n        }\n        // if we reach this something went wrong\n        ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions);\n        if (files.size() > 0) {\n            // We have some state files but none of them gave us a usable state\n            throw new ElasticsearchIllegalStateException(\"Could not find a state file to recover from among \" + files);\n        }\n        return state;\n    }","id":25485,"modified_method":"/**\n     * Tries to load the latest state from the given data-locations. It tries to load the latest state determined by\n     * the states version from one or more data directories and if none of the latest states can be loaded an exception\n     * is thrown to prevent accidentally loading a previous state and silently omitting the latest state.\n     *\n     * @param logger an elasticsearch logger instance\n     * @param format the actual metastate format to use\n     * @param pattern the file name pattern to identify files belonging to this pattern and to read the version from.\n     *                The first capture group should return the version of the file. If the second capture group is has a\n     *                null value the files is considered a legacy file and will be treated as if the file contains a plain\n     *                x-content payload.\n     * @param stateType the state type we are loading. used for logging contenxt only.\n     * @param dataLocations the data-locations to try.\n     * @return the latest state or <code>null<\/code> if no state was found.\n     */\n    public static <T> T loadLatestState(ESLogger logger, MetaDataStateFormat<T> format, Pattern pattern, String stateType, Path... dataLocations) throws IOException {\n        List<PathAndVersion> files = new ArrayList<>();\n        long maxVersion = -1;\n        boolean maxVersionIsLegacy = true;\n        if (dataLocations != null) { // select all eligable files first\n            for (Path dataLocation : dataLocations) {\n                final Path stateDir = dataLocation.resolve(STATE_DIR_NAME);\n                if (!Files.exists(stateDir) || !Files.isDirectory(stateDir)) {\n                    continue;\n                }\n                // now, iterate over the current versions, and find latest one\n                try (DirectoryStream<Path> paths = Files.newDirectoryStream(stateDir)) { // we don't pass a glob since we need the group part for parsing\n                    for (Path stateFile : paths) {\n                        final Matcher matcher = pattern.matcher(stateFile.getFileName().toString());\n                        if (matcher.matches()) {\n                            final long version = Long.parseLong(matcher.group(1));\n                            maxVersion = Math.max(maxVersion, version);\n                            final boolean legacy = MetaDataStateFormat.STATE_FILE_EXTENSION.equals(matcher.group(2)) == false;\n                            maxVersionIsLegacy &= legacy; // on purpose, see NOTE below\n                            files.add(new PathAndVersion(stateFile, version, legacy));\n                        }\n                    }\n                }\n            }\n        }\n        final List<Throwable> exceptions = new ArrayList<>();\n        T state = null;\n        // NOTE: we might have multiple version of the latest state if there are multiple data dirs.. for this case\n        //       we iterate only over the ones with the max version. If we have at least one state file that uses the\n        //       new format (ie. legacy == false) then we know that the latest version state ought to use this new format.\n        //       In case the state file with the latest version does not use the new format while older state files do,\n        //       the list below will be empty and loading the state will fail\n        for (PathAndVersion pathAndVersion : Collections2.filter(files, new VersionAndLegacyPredicate(maxVersion, maxVersionIsLegacy))) {\n            try {\n                final Path stateFile = pathAndVersion.file;\n                final long version = pathAndVersion.version;\n                final XContentParser parser;\n                if (pathAndVersion.legacy) { // read the legacy format -- plain XContent\n                    try (InputStream stream = Files.newInputStream(stateFile)) {\n                        final byte[] data = Streams.copyToByteArray(stream);\n                        if (data.length == 0) {\n                            logger.debug(\"{}: no data for [{}], ignoring...\", stateType, stateFile.toAbsolutePath());\n                            continue;\n                        }\n                        parser = XContentHelper.createParser(data, 0, data.length);\n                        state = format.fromXContent(parser);\n                        if (state == null) {\n                            logger.debug(\"{}: no data for [{}], ignoring...\", stateType, stateFile.toAbsolutePath());\n                        }\n                    }\n                } else {\n                    state = format.read(stateFile, version);\n                }\n                return state;\n            } catch (Throwable e) {\n                exceptions.add(e);\n                logger.debug(\"{}: failed to read [{}], ignoring...\", e, pathAndVersion.file.toAbsolutePath(), stateType);\n            }\n        }\n        // if we reach this something went wrong\n        ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions);\n        if (files.size() > 0) {\n            // We have some state files but none of them gave us a usable state\n            throw new ElasticsearchIllegalStateException(\"Could not find a state file to recover from among \" + files);\n        }\n        return state;\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Writes the given state to the given directories. The state is written to a\n     * state directory ({@value #STATE_DIR_NAME}) underneath each of the given file locations and is created if it\n     * doesn't exist. The state is serialized to a temporary file in that directory and is then atomically moved to\n     * it's target filename of the pattern <tt>{prefix}{version}.st<\/tt>.\n     *\n     * @param state the state object to write\n     * @param prefix the state names prefix used to compose the file name.\n     * @param version the version of the state\n     * @param locations the locations where the state should be written to.\n     * @throws IOException if an IOException occurs\n     */\n    public final void write(final T state, final String prefix, final long version, final File... locations) throws IOException {\n        Preconditions.checkArgument(locations != null, \"Locations must not be null\");\n        Preconditions.checkArgument(locations.length > 0, \"One or more locations required\");\n        String fileName = prefix + version + STATE_FILE_EXTENSION;\n        Path stateLocation = Paths.get(locations[0].getPath(), STATE_DIR_NAME);\n        Files.createDirectories(stateLocation);\n        final Path tmpStatePath = stateLocation.resolve(fileName + \".tmp\");\n        final Path finalStatePath = stateLocation.resolve(fileName);\n        try {\n            try (OutputStreamIndexOutput out = new OutputStreamIndexOutput(Files.newOutputStream(tmpStatePath), BUFFER_SIZE)) {\n                CodecUtil.writeHeader(out, STATE_FILE_CODEC, STATE_FILE_VERSION);\n                out.writeInt(format.index());\n                out.writeLong(version);\n                try (XContentBuilder builder = newXContentBuilder(format, new org.elasticsearch.common.lucene.store.OutputStreamIndexOutput(out) {\n                    @Override\n                    public void close() throws IOException {\n                        // this is important since some of the XContentBuilders write bytes on close.\n                        // in order to write the footer we need to prevent closing the actual index input.\n                    } })) {\n\n                    builder.startObject();\n                    {\n                        toXContent(builder, state);\n                    }\n                    builder.endObject();\n                }\n                CodecUtil.writeFooter(out);\n            }\n            IOUtils.fsync(tmpStatePath, false); // fsync the state file\n            Files.move(tmpStatePath, finalStatePath, StandardCopyOption.ATOMIC_MOVE);\n            IOUtils.fsync(stateLocation, true);\n            for (int i = 1; i < locations.length; i++) {\n                stateLocation = Paths.get(locations[i].getPath(), STATE_DIR_NAME);\n                Files.createDirectories(stateLocation);\n                Path tmpPath = stateLocation.resolve(fileName + \".tmp\");\n                Path finalPath = stateLocation.resolve(fileName);\n                try {\n                    Files.copy(finalStatePath, tmpPath);\n                    Files.move(tmpPath, finalPath, StandardCopyOption.ATOMIC_MOVE); // we are on the same FileSystem / Partition here we can do an atomic move\n                    IOUtils.fsync(stateLocation, true); // we just fsync the dir here..\n                } finally {\n                    Files.deleteIfExists(tmpPath);\n                }\n            }\n        } finally {\n            Files.deleteIfExists(tmpStatePath);\n        }\n        if (deleteOldFiles) {\n            cleanupOldFiles(prefix, fileName, locations);\n        }\n    }","id":25486,"modified_method":"/**\n     * Writes the given state to the given directories. The state is written to a\n     * state directory ({@value #STATE_DIR_NAME}) underneath each of the given file locations and is created if it\n     * doesn't exist. The state is serialized to a temporary file in that directory and is then atomically moved to\n     * it's target filename of the pattern <tt>{prefix}{version}.st<\/tt>.\n     *\n     * @param state the state object to write\n     * @param prefix the state names prefix used to compose the file name.\n     * @param version the version of the state\n     * @param locations the locations where the state should be written to.\n     * @throws IOException if an IOException occurs\n     */\n    public final void write(final T state, final String prefix, final long version, final Path... locations) throws IOException {\n        Preconditions.checkArgument(locations != null, \"Locations must not be null\");\n        Preconditions.checkArgument(locations.length > 0, \"One or more locations required\");\n        String fileName = prefix + version + STATE_FILE_EXTENSION;\n        Path stateLocation = locations[0].resolve(STATE_DIR_NAME);\n        Files.createDirectories(stateLocation);\n        final Path tmpStatePath = stateLocation.resolve(fileName + \".tmp\");\n        final Path finalStatePath = stateLocation.resolve(fileName);\n        try {\n            try (OutputStreamIndexOutput out = new OutputStreamIndexOutput(Files.newOutputStream(tmpStatePath), BUFFER_SIZE)) {\n                CodecUtil.writeHeader(out, STATE_FILE_CODEC, STATE_FILE_VERSION);\n                out.writeInt(format.index());\n                out.writeLong(version);\n                try (XContentBuilder builder = newXContentBuilder(format, new org.elasticsearch.common.lucene.store.OutputStreamIndexOutput(out) {\n                    @Override\n                    public void close() throws IOException {\n                        // this is important since some of the XContentBuilders write bytes on close.\n                        // in order to write the footer we need to prevent closing the actual index input.\n                    } })) {\n\n                    builder.startObject();\n                    {\n                        toXContent(builder, state);\n                    }\n                    builder.endObject();\n                }\n                CodecUtil.writeFooter(out);\n            }\n            IOUtils.fsync(tmpStatePath, false); // fsync the state file\n            Files.move(tmpStatePath, finalStatePath, StandardCopyOption.ATOMIC_MOVE);\n            IOUtils.fsync(stateLocation, true);\n            for (int i = 1; i < locations.length; i++) {\n                stateLocation = locations[i].resolve(STATE_DIR_NAME);\n                Files.createDirectories(stateLocation);\n                Path tmpPath = stateLocation.resolve(fileName + \".tmp\");\n                Path finalPath = stateLocation.resolve(fileName);\n                try {\n                    Files.copy(finalStatePath, tmpPath);\n                    Files.move(tmpPath, finalPath, StandardCopyOption.ATOMIC_MOVE); // we are on the same FileSystem / Partition here we can do an atomic move\n                    IOUtils.fsync(stateLocation, true); // we just fsync the dir here..\n                } finally {\n                    Files.deleteIfExists(tmpPath);\n                }\n            }\n        } finally {\n            Files.deleteIfExists(tmpStatePath);\n        }\n        if (deleteOldFiles) {\n            cleanupOldFiles(prefix, fileName, locations);\n        }\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void cleanupOldFiles(String prefix, String fileName, File[] locations) throws IOException {\n        // now clean up the old files\n        for (File dataLocation : locations) {\n            final File[] files = new File(dataLocation, STATE_DIR_NAME).listFiles();\n            if (files != null) {\n                for (File file : files) {\n                    if (!file.getName().startsWith(prefix)) {\n                        continue;\n                    }\n                    if (file.getName().equals(fileName)) {\n                        continue;\n                    }\n                    if (Files.exists(file.toPath())) {\n                        Files.delete(file.toPath());\n                    }\n                }\n            }\n        }\n    }","id":25487,"modified_method":"private void cleanupOldFiles(final String prefix, final String currentStateFile, Path[] locations) throws IOException {\n        final DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<Path>() {\n            @Override\n            public boolean accept(Path entry) throws IOException {\n                final String entryFileName = entry.getFileName().toString();\n                return Files.isRegularFile(entry)\n                        && entryFileName.startsWith(prefix) // only state files\n                        && currentStateFile.equals(entryFileName) == false; // keep the current state file around\n            }\n        };\n        // now clean up the old files\n        for (Path dataLocation : locations) {\n            try (DirectoryStream<Path> stream = Files.newDirectoryStream(dataLocation.resolve(STATE_DIR_NAME), filter)) {\n                for (Path stateFile : stream) {\n                    Files.deleteIfExists(stateFile);\n                }\n            }\n        }\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testLatestVersionDoesNotUseLegacy() throws IOException {\n        final ToXContent.Params params = ToXContent.EMPTY_PARAMS;\n        MetaDataStateFormat<MetaData> format = LocalGatewayMetaState.globalStateFormat(randomFrom(XContentType.values()), params, randomBoolean());\n        final File[] dirs = new File[2];\n        dirs[0] = newTempDir(LifecycleScope.TEST);\n        dirs[1] = newTempDir(LifecycleScope.TEST);\n        for (File dir : dirs) {\n            Files.createDirectories(new File(dir, MetaDataStateFormat.STATE_DIR_NAME).toPath());\n        }\n        final File dir1 = randomFrom(dirs);\n        final int v1 = randomInt(10);\n        // write a first state file in the new format\n        format.write(randomMeta(), LocalGatewayMetaState.GLOBAL_STATE_FILE_PREFIX, v1, dir1);\n\n        // write older state files in the old format but with a newer version\n        final int numLegacyFiles = randomIntBetween(1, 5);\n        for (int i = 0; i < numLegacyFiles; ++i) {\n            final File dir2 = randomFrom(dirs);\n            final int v2 = v1 + 1 + randomInt(10);\n            try (XContentBuilder xcontentBuilder = XContentFactory.contentBuilder(format.format(), new FileOutputStream(new File(new File(dir2, MetaDataStateFormat.STATE_DIR_NAME), LocalGatewayMetaState.GLOBAL_STATE_FILE_PREFIX + v2)))) {\n                xcontentBuilder.startObject();\n                MetaData.Builder.toXContent(randomMeta(), xcontentBuilder, params);\n                xcontentBuilder.endObject();\n            }\n        }\n\n        try {\n            MetaDataStateFormat.loadLatestState(logger, format, LocalGatewayMetaState.GLOBAL_STATE_FILE_PATTERN, \"foobar\", dirs);\n            fail(\"latest version can not be read\");\n        } catch (ElasticsearchIllegalStateException ex) {\n            assertThat(ex.getMessage(), startsWith(\"Could not find a state file to recover from among \"));\n        }\n    }","id":25488,"modified_method":"public void testLatestVersionDoesNotUseLegacy() throws IOException {\n        final ToXContent.Params params = ToXContent.EMPTY_PARAMS;\n        MetaDataStateFormat<MetaData> format = LocalGatewayMetaState.globalStateFormat(randomFrom(XContentType.values()), params, randomBoolean());\n        final Path[] dirs = new Path[2];\n        dirs[0] = newTempDir(LifecycleScope.TEST).toPath();\n        dirs[1] = newTempDir(LifecycleScope.TEST).toPath();\n        for (Path dir : dirs) {\n            Files.createDirectories(dir.resolve(MetaDataStateFormat.STATE_DIR_NAME));\n        }\n        final Path dir1 = randomFrom(dirs);\n        final int v1 = randomInt(10);\n        // write a first state file in the new format\n        format.write(randomMeta(), LocalGatewayMetaState.GLOBAL_STATE_FILE_PREFIX, v1, dir1);\n\n        // write older state files in the old format but with a newer version\n        final int numLegacyFiles = randomIntBetween(1, 5);\n        for (int i = 0; i < numLegacyFiles; ++i) {\n            final Path dir2 = randomFrom(dirs);\n            final int v2 = v1 + 1 + randomInt(10);\n            try (XContentBuilder xcontentBuilder = XContentFactory.contentBuilder(format.format(), Files.newOutputStream(dir2.resolve(MetaDataStateFormat.STATE_DIR_NAME).resolve(LocalGatewayMetaState.GLOBAL_STATE_FILE_PREFIX + v2)))) {\n                xcontentBuilder.startObject();\n                MetaData.Builder.toXContent(randomMeta(), xcontentBuilder, params);\n                xcontentBuilder.endObject();\n            }\n        }\n\n        try {\n            MetaDataStateFormat.loadLatestState(logger, format, LocalGatewayMetaState.GLOBAL_STATE_FILE_PATTERN, \"foobar\", dirs);\n            fail(\"latest version can not be read\");\n        } catch (ElasticsearchIllegalStateException ex) {\n            assertThat(ex.getMessage(), startsWith(\"Could not find a state file to recover from among \"));\n        }\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testReadWriteState() throws IOException {\n        File[] dirs = new File[randomIntBetween(1, 5)];\n        for (int i = 0; i < dirs.length; i++) {\n            dirs[i] = newTempDir(LifecycleScope.TEST);\n        }\n        final boolean deleteOldFiles = randomBoolean();\n        Format format = new Format(randomFrom(XContentType.values()), deleteOldFiles);\n        DummyState state = new DummyState(randomRealisticUnicodeOfCodepointLengthBetween(1, 1000), randomInt(), randomLong(), randomDouble(), randomBoolean());\n        int version = between(0, Integer.MAX_VALUE/2);\n        format.write(state, \"foo-\", version, dirs);\n        for (File file : dirs) {\n            File[] list = file.listFiles();\n            assertEquals(list.length, 1);\n            assertThat(list[0].getName(), equalTo(MetaDataStateFormat.STATE_DIR_NAME));\n            File stateDir = list[0];\n            assertThat(stateDir.isDirectory(), is(true));\n            list = stateDir.listFiles();\n            assertEquals(list.length, 1);\n            assertThat(list[0].getName(), equalTo(\"foo-\" + version + \".st\"));\n            DummyState read = format.read(list[0], version);\n            assertThat(read, equalTo(state));\n        }\n        final int version2 = between(version, Integer.MAX_VALUE);\n        DummyState state2 = new DummyState(randomRealisticUnicodeOfCodepointLengthBetween(1, 1000), randomInt(), randomLong(), randomDouble(), randomBoolean());\n        format.write(state2, \"foo-\", version2, dirs);\n\n        for (File file : dirs) {\n            File[] list = file.listFiles();\n            assertEquals(list.length, 1);\n            assertThat(list[0].getName(), equalTo(MetaDataStateFormat.STATE_DIR_NAME));\n            File stateDir = list[0];\n            assertThat(stateDir.isDirectory(), is(true));\n            list = stateDir.listFiles();\n            assertEquals(list.length, deleteOldFiles ? 1 : 2);\n            if (deleteOldFiles) {\n                assertThat(list[0].getName(), equalTo(\"foo-\" + version2 + \".st\"));\n                DummyState read = format.read(list[0], version2);\n                assertThat(read, equalTo(state2));\n            } else {\n                assertThat(list[0].getName(), anyOf(equalTo(\"foo-\" + version + \".st\"), equalTo(\"foo-\" + version2 + \".st\")));\n                assertThat(list[1].getName(), anyOf(equalTo(\"foo-\" + version + \".st\"), equalTo(\"foo-\" + version2 + \".st\")));\n                DummyState read = format.read(new File(stateDir, \"foo-\" + version2 + \".st\"), version2);\n                assertThat(read, equalTo(state2));\n                read = format.read(new File(stateDir, \"foo-\" + version + \".st\"), version);\n                assertThat(read, equalTo(state));\n            }\n\n        }\n    }","id":25489,"modified_method":"public void testReadWriteState() throws IOException {\n        Path[] dirs = new Path[randomIntBetween(1, 5)];\n        for (int i = 0; i < dirs.length; i++) {\n            dirs[i] = newTempDir(LifecycleScope.TEST).toPath();\n        }\n        final boolean deleteOldFiles = randomBoolean();\n        Format format = new Format(randomFrom(XContentType.values()), deleteOldFiles);\n        DummyState state = new DummyState(randomRealisticUnicodeOfCodepointLengthBetween(1, 1000), randomInt(), randomLong(), randomDouble(), randomBoolean());\n        int version = between(0, Integer.MAX_VALUE/2);\n        format.write(state, \"foo-\", version, dirs);\n        for (Path file : dirs) {\n            Path[] list = content(file);\n            assertEquals(list.length, 1);\n            assertThat(list[0].getFileName().toString(), equalTo(MetaDataStateFormat.STATE_DIR_NAME));\n            Path stateDir = list[0];\n            assertThat(Files.isDirectory(stateDir), is(true));\n            list = content(stateDir);\n            assertEquals(list.length, 1);\n            assertThat(list[0].getFileName().toString(), equalTo(\"foo-\" + version + \".st\"));\n            DummyState read = format.read(list[0], version);\n            assertThat(read, equalTo(state));\n        }\n        final int version2 = between(version, Integer.MAX_VALUE);\n        DummyState state2 = new DummyState(randomRealisticUnicodeOfCodepointLengthBetween(1, 1000), randomInt(), randomLong(), randomDouble(), randomBoolean());\n        format.write(state2, \"foo-\", version2, dirs);\n\n        for (Path file : dirs) {\n            Path[] list = content(file);\n            assertEquals(list.length, 1);\n            assertThat(list[0].getFileName().toString(), equalTo(MetaDataStateFormat.STATE_DIR_NAME));\n            Path stateDir = list[0];\n            assertThat(Files.isDirectory(stateDir), is(true));\n            list = content(stateDir);\n            assertEquals(list.length, deleteOldFiles ? 1 : 2);\n            if (deleteOldFiles) {\n                assertThat(list[0].getFileName().toString(), equalTo(\"foo-\" + version2 + \".st\"));\n                DummyState read = format.read(list[0], version2);\n                assertThat(read, equalTo(state2));\n            } else {\n                assertThat(list[0].getFileName().toString(), anyOf(equalTo(\"foo-\" + version + \".st\"), equalTo(\"foo-\" + version2 + \".st\")));\n                assertThat(list[1].getFileName().toString(), anyOf(equalTo(\"foo-\" + version + \".st\"), equalTo(\"foo-\" + version2 + \".st\")));\n                DummyState read = format.read(stateDir.resolve(\"foo-\" + version2 + \".st\"), version2);\n                assertThat(read, equalTo(state2));\n                read = format.read(stateDir.resolve(\"foo-\" + version + \".st\"), version);\n                assertThat(read, equalTo(state));\n            }\n\n        }\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static void corruptFile(File file, ESLogger logger) throws IOException {\n        File fileToCorrupt = file;\n        try (final SimpleFSDirectory dir = new SimpleFSDirectory(fileToCorrupt.getParentFile().toPath())) {\n            long checksumBeforeCorruption;\n            try (IndexInput input = dir.openInput(fileToCorrupt.getName(), IOContext.DEFAULT)) {\n                checksumBeforeCorruption = CodecUtil.retrieveChecksum(input);\n            }\n            try (RandomAccessFile raf = new RandomAccessFile(fileToCorrupt, \"rw\")) {\n                raf.seek(randomIntBetween(0, (int)Math.min(Integer.MAX_VALUE, raf.length()-1)));\n                long filePointer = raf.getFilePointer();\n                byte b = raf.readByte();\n                raf.seek(filePointer);\n                raf.writeByte(~b);\n                raf.getFD().sync();\n                logger.debug(\"Corrupting file {} --  flipping at position {} from {} to {} \", fileToCorrupt.getName(), filePointer, Integer.toHexString(b), Integer.toHexString(~b));\n            }\n        long checksumAfterCorruption;\n        long actualChecksumAfterCorruption;\n        try (ChecksumIndexInput input = dir.openChecksumInput(fileToCorrupt.getName(), IOContext.DEFAULT)) {\n            assertThat(input.getFilePointer(), is(0l));\n            input.seek(input.length() - 8); // one long is the checksum... 8 bytes\n            checksumAfterCorruption = input.getChecksum();\n            actualChecksumAfterCorruption = input.readLong();\n        }\n        StringBuilder msg = new StringBuilder();\n        msg.append(\"Checksum before: [\").append(checksumBeforeCorruption).append(\"]\");\n        msg.append(\" after: [\").append(checksumAfterCorruption).append(\"]\");\n        msg.append(\" checksum value after corruption: \").append(actualChecksumAfterCorruption).append(\"]\");\n        msg.append(\" file: \").append(fileToCorrupt.getName()).append(\" length: \").append(dir.fileLength(fileToCorrupt.getName()));\n        logger.debug(msg.toString());\n        assumeTrue(\"Checksum collision - \" + msg.toString(),\n                checksumAfterCorruption != checksumBeforeCorruption // collision\n                        || actualChecksumAfterCorruption != checksumBeforeCorruption); // checksum corrupted\n        }\n    }","id":25490,"modified_method":"public static void corruptFile(Path file, ESLogger logger) throws IOException {\n        Path fileToCorrupt = file;\n        try (final SimpleFSDirectory dir = new SimpleFSDirectory(fileToCorrupt.getParent())) {\n            long checksumBeforeCorruption;\n            try (IndexInput input = dir.openInput(fileToCorrupt.getFileName().toString(), IOContext.DEFAULT)) {\n                checksumBeforeCorruption = CodecUtil.retrieveChecksum(input);\n            }\n            try (RandomAccessFile raf = new RandomAccessFile(fileToCorrupt.toAbsolutePath().toString(), \"rw\")) {\n                raf.seek(randomIntBetween(0, (int)Math.min(Integer.MAX_VALUE, raf.length()-1)));\n                long filePointer = raf.getFilePointer();\n                byte b = raf.readByte();\n                raf.seek(filePointer);\n                raf.writeByte(~b);\n                raf.getFD().sync();\n                logger.debug(\"Corrupting file {} --  flipping at position {} from {} to {} \", fileToCorrupt.getFileName().toString(), filePointer, Integer.toHexString(b), Integer.toHexString(~b));\n            }\n        long checksumAfterCorruption;\n        long actualChecksumAfterCorruption;\n        try (ChecksumIndexInput input = dir.openChecksumInput(fileToCorrupt.getFileName().toString(), IOContext.DEFAULT)) {\n            assertThat(input.getFilePointer(), is(0l));\n            input.seek(input.length() - 8); // one long is the checksum... 8 bytes\n            checksumAfterCorruption = input.getChecksum();\n            actualChecksumAfterCorruption = input.readLong();\n        }\n        StringBuilder msg = new StringBuilder();\n        msg.append(\"Checksum before: [\").append(checksumBeforeCorruption).append(\"]\");\n        msg.append(\" after: [\").append(checksumAfterCorruption).append(\"]\");\n        msg.append(\" checksum value after corruption: \").append(actualChecksumAfterCorruption).append(\"]\");\n        msg.append(\" file: \").append(fileToCorrupt.getFileName().toString()).append(\" length: \").append(dir.fileLength(fileToCorrupt.getFileName().toString()));\n        logger.debug(msg.toString());\n        assumeTrue(\"Checksum collision - \" + msg.toString(),\n                checksumAfterCorruption != checksumBeforeCorruption // collision\n                        || actualChecksumAfterCorruption != checksumBeforeCorruption); // checksum corrupted\n        }\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        protected Directory newDirectory(File dir) throws IOException {\n            MockDirectoryWrapper  mock = new MockDirectoryWrapper(getRandom(), super.newDirectory(dir));\n            closeAfterSuite(new CloseableDirectory(mock, suiteFailureMarker));\n            return mock;\n        }","id":25491,"modified_method":"@Override\n        protected Directory newDirectory(Path dir) throws IOException {\n            MockDirectoryWrapper  mock = new MockDirectoryWrapper(getRandom(), super.newDirectory(dir));\n            closeAfterSuite(new CloseableDirectory(mock, suiteFailureMarker));\n            return mock;\n        }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testCorruption() throws IOException {\n        File[] dirs = new File[randomIntBetween(1, 5)];\n        for (int i = 0; i < dirs.length; i++) {\n            dirs[i] = newTempDir(LifecycleScope.TEST);\n        }\n        final boolean deleteOldFiles = randomBoolean();\n        Format format = new Format(randomFrom(XContentType.values()), deleteOldFiles);\n        DummyState state = new DummyState(randomRealisticUnicodeOfCodepointLengthBetween(1, 1000), randomInt(), randomLong(), randomDouble(), randomBoolean());\n        int version = between(0, Integer.MAX_VALUE/2);\n        format.write(state, \"foo-\", version, dirs);\n        for (File file : dirs) {\n            File[] list = file.listFiles();\n            assertEquals(list.length, 1);\n            assertThat(list[0].getName(), equalTo(MetaDataStateFormat.STATE_DIR_NAME));\n            File stateDir = list[0];\n            assertThat(stateDir.isDirectory(), is(true));\n            list = stateDir.listFiles();\n            assertEquals(list.length, 1);\n            assertThat(list[0].getName(), equalTo(\"foo-\" + version + \".st\"));\n            DummyState read = format.read(list[0], version);\n            assertThat(read, equalTo(state));\n            // now corrupt it\n            corruptFile(list[0], logger);\n            try {\n                format.read(list[0], version);\n                fail(\"corrupted file\");\n            } catch (CorruptStateException ex) {\n                // expected\n            }\n        }\n    }","id":25492,"modified_method":"public void testCorruption() throws IOException {\n        Path[] dirs = new Path[randomIntBetween(1, 5)];\n        for (int i = 0; i < dirs.length; i++) {\n            dirs[i] = newTempDir(LifecycleScope.TEST).toPath();\n        }\n        final boolean deleteOldFiles = randomBoolean();\n        Format format = new Format(randomFrom(XContentType.values()), deleteOldFiles);\n        DummyState state = new DummyState(randomRealisticUnicodeOfCodepointLengthBetween(1, 1000), randomInt(), randomLong(), randomDouble(), randomBoolean());\n        int version = between(0, Integer.MAX_VALUE/2);\n        format.write(state, \"foo-\", version, dirs);\n        for (Path file : dirs) {\n            Path[] list = content(file);\n            assertEquals(list.length, 1);\n            assertThat(list[0].getFileName().toString(), equalTo(MetaDataStateFormat.STATE_DIR_NAME));\n            Path stateDir = list[0];\n            assertThat(Files.isDirectory(stateDir), is(true));\n            list = content(stateDir);\n            assertEquals(list.length, 1);\n            assertThat(list[0].getFileName().toString(), equalTo(\"foo-\" + version + \".st\"));\n            DummyState read = format.read(list[0], version);\n            assertThat(read, equalTo(state));\n            // now corrupt it\n            corruptFile(list[0], logger);\n            try {\n                format.read(list[0], version);\n                fail(\"corrupted file\");\n            } catch (CorruptStateException ex) {\n                // expected\n            }\n        }\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testPrefersNewerFormat() throws IOException {\n        final ToXContent.Params params = ToXContent.EMPTY_PARAMS;\n        MetaDataStateFormat<MetaData> format = LocalGatewayMetaState.globalStateFormat(randomFrom(XContentType.values()), params, randomBoolean());\n        final File[] dirs = new File[2];\n        dirs[0] = newTempDir(LifecycleScope.TEST);\n        dirs[1] = newTempDir(LifecycleScope.TEST);\n        for (File dir : dirs) {\n            Files.createDirectories(new File(dir, MetaDataStateFormat.STATE_DIR_NAME).toPath());\n        }\n        final File dir1 = randomFrom(dirs);\n        final long v = randomInt(10);\n\n        MetaData meta = randomMeta();\n        String uuid = meta.uuid();\n\n        // write a first state file in the old format\n        final File dir2 = randomFrom(dirs);\n        MetaData meta2 = randomMeta();\n        assertFalse(meta2.uuid().equals(uuid));\n        try (XContentBuilder xcontentBuilder = XContentFactory.contentBuilder(format.format(), new FileOutputStream(new File(new File(dir2, MetaDataStateFormat.STATE_DIR_NAME), LocalGatewayMetaState.GLOBAL_STATE_FILE_PREFIX + v)))) {\n            xcontentBuilder.startObject();\n            MetaData.Builder.toXContent(randomMeta(), xcontentBuilder, params);\n            xcontentBuilder.endObject();\n        }\n\n        // write a second state file in the new format but with the same version\n        format.write(meta, LocalGatewayMetaState.GLOBAL_STATE_FILE_PREFIX, v, dir1);\n\n        MetaData state = MetaDataStateFormat.loadLatestState(logger, format, LocalGatewayMetaState.GLOBAL_STATE_FILE_PATTERN, \"foobar\", dirs);\n        assertThat(state.uuid(), equalTo(uuid));\n    }","id":25493,"modified_method":"public void testPrefersNewerFormat() throws IOException {\n        final ToXContent.Params params = ToXContent.EMPTY_PARAMS;\n        MetaDataStateFormat<MetaData> format = LocalGatewayMetaState.globalStateFormat(randomFrom(XContentType.values()), params, randomBoolean());\n        final Path[] dirs = new Path[2];\n        dirs[0] = newTempDir(LifecycleScope.TEST).toPath();\n        dirs[1] = newTempDir(LifecycleScope.TEST).toPath();\n        for (Path dir : dirs) {\n            Files.createDirectories(dir.resolve(MetaDataStateFormat.STATE_DIR_NAME));\n        }\n        final Path dir1 = randomFrom(dirs);\n        final long v = randomInt(10);\n\n        MetaData meta = randomMeta();\n        String uuid = meta.uuid();\n\n        // write a first state file in the old format\n        final Path dir2 = randomFrom(dirs);\n        MetaData meta2 = randomMeta();\n        assertFalse(meta2.uuid().equals(uuid));\n        try (XContentBuilder xcontentBuilder = XContentFactory.contentBuilder(format.format(), Files.newOutputStream(dir2.resolve(MetaDataStateFormat.STATE_DIR_NAME).resolve(LocalGatewayMetaState.GLOBAL_STATE_FILE_PREFIX + v)))) {\n            xcontentBuilder.startObject();\n            MetaData.Builder.toXContent(randomMeta(), xcontentBuilder, params);\n            xcontentBuilder.endObject();\n        }\n\n        // write a second state file in the new format but with the same version\n        format.write(meta, LocalGatewayMetaState.GLOBAL_STATE_FILE_PREFIX, v, dir1);\n\n        MetaData state = MetaDataStateFormat.loadLatestState(logger, format, LocalGatewayMetaState.GLOBAL_STATE_FILE_PATTERN, \"foobar\", dirs);\n        assertThat(state.uuid(), equalTo(uuid));\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLoadState() throws IOException {\n        final ToXContent.Params params = ToXContent.EMPTY_PARAMS;\n        final File[] dirs = new File[randomIntBetween(1, 5)];\n        int numStates = randomIntBetween(1, 5);\n        int numLegacy = randomIntBetween(0, numStates);\n        List<MetaData> meta = new ArrayList<>();\n        for (int i = 0; i < numStates; i++) {\n            meta.add(randomMeta());\n        }\n        Set<File> corruptedFiles = new HashSet<>();\n        MetaDataStateFormat<MetaData> format = LocalGatewayMetaState.globalStateFormat(randomFrom(XContentType.values()), params, randomBoolean());\n        for (int i = 0; i < dirs.length; i++) {\n            dirs[i] = newTempDir(LifecycleScope.TEST);\n            Files.createDirectories(new File(dirs[i], MetaDataStateFormat.STATE_DIR_NAME).toPath());\n            for (int j = 0; j < numLegacy; j++) {\n                XContentType type = format.format();\n                if (randomBoolean() && (j < numStates - 1 || dirs.length > 0 && i != 0)) {\n                    File file = new File(new File(dirs[i], MetaDataStateFormat.STATE_DIR_NAME), \"global-\"+j);\n                    Files.createFile(file.toPath()); // randomly create 0-byte files -- there is extra logic to skip them\n                } else {\n                    try (XContentBuilder xcontentBuilder = XContentFactory.contentBuilder(type, new FileOutputStream(new File(new File(dirs[i], MetaDataStateFormat.STATE_DIR_NAME), \"global-\" + j)))) {\n                        xcontentBuilder.startObject();\n                        MetaData.Builder.toXContent(meta.get(j), xcontentBuilder, params);\n                        xcontentBuilder.endObject();\n                    }\n                }\n            }\n            for (int j = numLegacy; j < numStates; j++) {\n                format.write(meta.get(j), LocalGatewayMetaState.GLOBAL_STATE_FILE_PREFIX, j, dirs[i]);\n                if (randomBoolean() && (j < numStates - 1 || dirs.length > 0 && i != 0)) {  // corrupt a file that we do not necessarily need here....\n                    File file = new File(new File(dirs[i], MetaDataStateFormat.STATE_DIR_NAME), \"global-\" + j + \".st\");\n                    corruptedFiles.add(file);\n                    MetaDataStateFormatTest.corruptFile(file, logger);\n                }\n            }\n\n        }\n        List<File> dirList = Arrays.asList(dirs);\n        Collections.shuffle(dirList, getRandom());\n        MetaData loadedMetaData = MetaDataStateFormat.loadLatestState(logger, format, LocalGatewayMetaState.GLOBAL_STATE_FILE_PATTERN, \"foobar\", dirList.toArray(new File[0]));\n        MetaData latestMetaData = meta.get(numStates-1);\n        assertThat(loadedMetaData.uuid(), not(equalTo(\"_na_\")));\n        assertThat(loadedMetaData.uuid(), equalTo(latestMetaData.uuid()));\n        ImmutableOpenMap<String,IndexMetaData> indices = loadedMetaData.indices();\n        assertThat(indices.size(), equalTo(latestMetaData.indices().size()));\n        for (IndexMetaData original : latestMetaData) {\n            IndexMetaData deserialized = indices.get(original.getIndex());\n            assertThat(deserialized, notNullValue());\n            assertThat(deserialized.version(), equalTo(original.version()));\n            assertThat(deserialized.numberOfReplicas(), equalTo(original.numberOfReplicas()));\n            assertThat(deserialized.numberOfShards(), equalTo(original.numberOfShards()));\n        }\n\n        // now corrupt all the latest ones and make sure we fail to load the state\n        if (numStates > numLegacy) {\n            for (int i = 0; i < dirs.length; i++) {\n                File file = new File(new File(dirs[i], MetaDataStateFormat.STATE_DIR_NAME), \"global-\" + (numStates-1) + \".st\");\n                if (corruptedFiles.contains(file)) {\n                    continue;\n                }\n                MetaDataStateFormatTest.corruptFile(file, logger);\n            }\n            try {\n                MetaDataStateFormat.loadLatestState(logger, format, LocalGatewayMetaState.GLOBAL_STATE_FILE_PATTERN, \"foobar\", dirList.toArray(new File[0]));\n                fail(\"latest version can not be read\");\n            } catch (ElasticsearchException ex) {\n                assertThat(ex.getCause(), instanceOf(CorruptStateException.class));\n            }\n        }\n\n    }","id":25494,"modified_method":"@Test\n    public void testLoadState() throws IOException {\n        final ToXContent.Params params = ToXContent.EMPTY_PARAMS;\n        final Path[] dirs = new Path[randomIntBetween(1, 5)];\n        int numStates = randomIntBetween(1, 5);\n        int numLegacy = randomIntBetween(0, numStates);\n        List<MetaData> meta = new ArrayList<>();\n        for (int i = 0; i < numStates; i++) {\n            meta.add(randomMeta());\n        }\n        Set<Path> corruptedFiles = new HashSet<>();\n        MetaDataStateFormat<MetaData> format = LocalGatewayMetaState.globalStateFormat(randomFrom(XContentType.values()), params, randomBoolean());\n        for (int i = 0; i < dirs.length; i++) {\n            dirs[i] = newTempDir(LifecycleScope.TEST).toPath();\n            Files.createDirectories(dirs[i].resolve(MetaDataStateFormat.STATE_DIR_NAME));\n            for (int j = 0; j < numLegacy; j++) {\n                XContentType type = format.format();\n                if (randomBoolean() && (j < numStates - 1 || dirs.length > 0 && i != 0)) {\n                    Path file = dirs[i].resolve(MetaDataStateFormat.STATE_DIR_NAME).resolve(\"global-\"+j);\n                    Files.createFile(file); // randomly create 0-byte files -- there is extra logic to skip them\n                } else {\n                    try (XContentBuilder xcontentBuilder = XContentFactory.contentBuilder(type, Files.newOutputStream(dirs[i].resolve(MetaDataStateFormat.STATE_DIR_NAME).resolve(\"global-\" + j)))) {\n                        xcontentBuilder.startObject();\n                        MetaData.Builder.toXContent(meta.get(j), xcontentBuilder, params);\n                        xcontentBuilder.endObject();\n                    }\n                }\n            }\n            for (int j = numLegacy; j < numStates; j++) {\n                format.write(meta.get(j), LocalGatewayMetaState.GLOBAL_STATE_FILE_PREFIX, j, dirs[i]);\n                if (randomBoolean() && (j < numStates - 1 || dirs.length > 0 && i != 0)) {  // corrupt a file that we do not necessarily need here....\n                    Path file = dirs[i].resolve(MetaDataStateFormat.STATE_DIR_NAME).resolve(\"global-\" + j + \".st\");\n                    corruptedFiles.add(file);\n                    MetaDataStateFormatTest.corruptFile(file, logger);\n                }\n            }\n\n        }\n        List<Path> dirList = Arrays.asList(dirs);\n        Collections.shuffle(dirList, getRandom());\n        MetaData loadedMetaData = MetaDataStateFormat.loadLatestState(logger, format, LocalGatewayMetaState.GLOBAL_STATE_FILE_PATTERN, \"foobar\", dirList.toArray(new Path[0]));\n        MetaData latestMetaData = meta.get(numStates-1);\n        assertThat(loadedMetaData.uuid(), not(equalTo(\"_na_\")));\n        assertThat(loadedMetaData.uuid(), equalTo(latestMetaData.uuid()));\n        ImmutableOpenMap<String,IndexMetaData> indices = loadedMetaData.indices();\n        assertThat(indices.size(), equalTo(latestMetaData.indices().size()));\n        for (IndexMetaData original : latestMetaData) {\n            IndexMetaData deserialized = indices.get(original.getIndex());\n            assertThat(deserialized, notNullValue());\n            assertThat(deserialized.version(), equalTo(original.version()));\n            assertThat(deserialized.numberOfReplicas(), equalTo(original.numberOfReplicas()));\n            assertThat(deserialized.numberOfShards(), equalTo(original.numberOfShards()));\n        }\n\n        // now corrupt all the latest ones and make sure we fail to load the state\n        if (numStates > numLegacy) {\n            for (int i = 0; i < dirs.length; i++) {\n                Path file = dirs[i].resolve(MetaDataStateFormat.STATE_DIR_NAME).resolve(\"global-\" + (numStates-1) + \".st\");\n                if (corruptedFiles.contains(file)) {\n                    continue;\n                }\n                MetaDataStateFormatTest.corruptFile(file, logger);\n            }\n            try {\n                MetaDataStateFormat.loadLatestState(logger, format, LocalGatewayMetaState.GLOBAL_STATE_FILE_PATTERN, \"foobar\", dirList.toArray(new Path[0]));\n                fail(\"latest version can not be read\");\n            } catch (ElasticsearchException ex) {\n                assertThat(ex.getCause(), instanceOf(CorruptStateException.class));\n            }\n        }\n\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testVersionMismatch() throws IOException {\n        File[] dirs = new File[randomIntBetween(1, 5)];\n        for (int i = 0; i < dirs.length; i++) {\n            dirs[i] = newTempDir(LifecycleScope.TEST);\n        }\n        final boolean deleteOldFiles = randomBoolean();\n        Format format = new Format(randomFrom(XContentType.values()), deleteOldFiles);\n        DummyState state = new DummyState(randomRealisticUnicodeOfCodepointLengthBetween(1, 1000), randomInt(), randomLong(), randomDouble(), randomBoolean());\n        int version = between(0, Integer.MAX_VALUE/2);\n        format.write(state, \"foo-\", version, dirs);\n        for (File file : dirs) {\n            File[] list = file.listFiles();\n            assertEquals(list.length, 1);\n            assertThat(list[0].getName(), equalTo(MetaDataStateFormat.STATE_DIR_NAME));\n            File stateDir = list[0];\n            assertThat(stateDir.isDirectory(), is(true));\n            list = stateDir.listFiles();\n            assertEquals(list.length, 1);\n            assertThat(list[0].getName(), equalTo(\"foo-\" + version + \".st\"));\n            try {\n                format.read(list[0], between(version+1, Integer.MAX_VALUE));\n                fail(\"corruption expected\");\n            } catch (CorruptStateException ex) {\n                // success\n            }\n            DummyState read = format.read(list[0], version);\n            assertThat(read, equalTo(state));\n        }\n    }","id":25495,"modified_method":"@Test\n    public void testVersionMismatch() throws IOException {\n        Path[] dirs = new Path[randomIntBetween(1, 5)];\n        for (int i = 0; i < dirs.length; i++) {\n            dirs[i] = newTempDir(LifecycleScope.TEST).toPath();\n        }\n        final boolean deleteOldFiles = randomBoolean();\n        Format format = new Format(randomFrom(XContentType.values()), deleteOldFiles);\n        DummyState state = new DummyState(randomRealisticUnicodeOfCodepointLengthBetween(1, 1000), randomInt(), randomLong(), randomDouble(), randomBoolean());\n        int version = between(0, Integer.MAX_VALUE/2);\n        format.write(state, \"foo-\", version, dirs);\n        for (Path file : dirs) {\n            Path[] list = content(file);\n            assertEquals(list.length, 1);\n            assertThat(list[0].getFileName().toString(), equalTo(MetaDataStateFormat.STATE_DIR_NAME));\n            Path stateDir = list[0];\n            assertThat(Files.isDirectory(stateDir), is(true));\n            list = content(stateDir);\n            assertEquals(list.length, 1);\n            assertThat(list[0].getFileName().toString(), equalTo(\"foo-\" + version + \".st\"));\n            try {\n                format.read(list[0], between(version+1, Integer.MAX_VALUE));\n                fail(\"corruption expected\");\n            } catch (CorruptStateException ex) {\n                // success\n            }\n            DummyState read = format.read(list[0], version);\n            assertThat(read, equalTo(state));\n        }\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Ensure we can read a pre-generated cluster state.\n     */\n    public void testReadClusterState() throws URISyntaxException, IOException {\n        final MetaDataStateFormat<MetaData> format = new MetaDataStateFormat<MetaData>(randomFrom(XContentType.values()), false) {\n\n            @Override\n            public void toXContent(XContentBuilder builder, MetaData state) throws IOException {\n                fail(\"this test doesn't write\");\n            }\n\n            @Override\n            public MetaData fromXContent(XContentParser parser) throws IOException {\n                return MetaData.Builder.fromXContent(parser);\n            }\n        };\n        Path tmp = newTempDir().toPath();\n        final InputStream resource = this.getClass().getResourceAsStream(\"global-3.st\");\n        assertThat(resource, notNullValue());\n        Path dst = tmp.resolve(\"global-3.st\");\n        Files.copy(resource, dst);\n        MetaData read = format.read(dst.toFile(), 3);\n        assertThat(read, notNullValue());\n        assertThat(read.uuid(), equalTo(\"3O1tDF1IRB6fSJ-GrTMUtg\"));\n        // indices are empty since they are serialized separately\n    }","id":25496,"modified_method":"/**\n     * Ensure we can read a pre-generated cluster state.\n     */\n    public void testReadClusterState() throws URISyntaxException, IOException {\n        final MetaDataStateFormat<MetaData> format = new MetaDataStateFormat<MetaData>(randomFrom(XContentType.values()), false) {\n\n            @Override\n            public void toXContent(XContentBuilder builder, MetaData state) throws IOException {\n                fail(\"this test doesn't write\");\n            }\n\n            @Override\n            public MetaData fromXContent(XContentParser parser) throws IOException {\n                return MetaData.Builder.fromXContent(parser);\n            }\n        };\n        Path tmp = newTempDir().toPath();\n        final InputStream resource = this.getClass().getResourceAsStream(\"global-3.st\");\n        assertThat(resource, notNullValue());\n        Path dst = tmp.resolve(\"global-3.st\");\n        Files.copy(resource, dst);\n        MetaData read = format.read(dst, 3);\n        assertThat(read, notNullValue());\n        assertThat(read.uuid(), equalTo(\"3O1tDF1IRB6fSJ-GrTMUtg\"));\n        // indices are empty since they are serialized separately\n    }","commit_id":"9e7b15b8f3b8b1f2405b233a042d842d80f64028","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Perform recovery on a list of commit log files.\n     *\n     * @param clogs   the list of commit log files to replay\n     * @return the number of mutations replayed\n     */\n    public int recover(File... clogs) throws IOException\n    {\n        CommitLogReplayer recovery = new CommitLogReplayer();\n        recovery.recover(clogs);\n        return recovery.blockForWrites();\n    }","id":25497,"modified_method":"/**\n     * Perform recovery on a list of commit log files.\n     *\n     * @param clogs   the list of commit log files to replay\n     * @return the number of mutations replayed\n     */\n    public int recover(File... clogs) throws IOException\n    {\n        try\n        {\n            CommitLogReplayer recovery = new CommitLogReplayer();\n            recovery.recover(clogs);\n            return recovery.blockForWrites();\n        }\n        catch (IOException e)\n        {\n            if (e instanceof UnknownColumnFamilyException)\n                logger.error(\"Commit log replay failed due to replaying a mutation for a missing table. This error can be ignored by providing -Dcassandra.commitlog.stop_on_missing_tables=false on the command line\");\n            if (e instanceof MalformedCommitLogException)\n                logger.error(\"Commit log replay failed due to a non-fatal exception. This error can be ignored by providing -Dcassandra.commitlog.stop_on_errors=false on the command line\");\n            throw e;\n        }\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"static void writeHeader(ByteBuffer out, CommitLogDescriptor descriptor)\n    {\n        out.putInt(0, descriptor.version);\n        out.putLong(4, descriptor.id);\n        PureJavaCrc32 crc = new PureJavaCrc32();\n        crc.updateInt(descriptor.version);\n        crc.updateInt((int) (descriptor.id & 0xFFFFFFFFL));\n        crc.updateInt((int) (descriptor.id >>> 32));\n        out.putInt(12, crc.getCrc());\n    }","id":25498,"modified_method":"@VisibleForTesting\n    public static void writeHeader(ByteBuffer out, CommitLogDescriptor descriptor)\n    {\n        out.putInt(0, descriptor.version);\n        out.putLong(4, descriptor.id);\n        PureJavaCrc32 crc = new PureJavaCrc32();\n        crc.updateInt(descriptor.version);\n        crc.updateInt((int) (descriptor.id & 0xFFFFFFFFL));\n        crc.updateInt((int) (descriptor.id >>> 32));\n        out.putInt(12, crc.getCrc());\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"public CommitLogReplayer()\n    {\n        this.keyspacesRecovered = new NonBlockingHashSet<Keyspace>();\n        this.futures = new ArrayList<Future<?>>();\n        this.buffer = new byte[4096];\n        this.invalidMutations = new HashMap<UUID, AtomicInteger>();\n        // count the number of replayed mutation. We don't really care about atomicity, but we need it to be a reference.\n        this.replayedCount = new AtomicInteger();\n        this.checksum = new PureJavaCrc32();\n\n        // compute per-CF and global replay positions\n        cfPositions = new HashMap<UUID, ReplayPosition>();\n        Ordering<ReplayPosition> replayPositionOrdering = Ordering.from(ReplayPosition.comparator);\n        for (ColumnFamilyStore cfs : ColumnFamilyStore.all())\n        {\n            // it's important to call RP.gRP per-cf, before aggregating all the positions w/ the Ordering.min call\n            // below: gRP will return NONE if there are no flushed sstables, which is important to have in the\n            // list (otherwise we'll just start replay from the first flush position that we do have, which is not correct).\n            ReplayPosition rp = ReplayPosition.getReplayPosition(cfs.getSSTables());\n\n            // but, if we've truncted the cf in question, then we need to need to start replay after the truncation\n            ReplayPosition truncatedAt = SystemKeyspace.getTruncatedPosition(cfs.metadata.cfId);\n            if (truncatedAt != null)\n                rp = replayPositionOrdering.max(Arrays.asList(rp, truncatedAt));\n\n            cfPositions.put(cfs.metadata.cfId, rp);\n        }\n        globalPosition = replayPositionOrdering.min(cfPositions.values());\n        logger.debug(\"Global replay position is {} from columnfamilies {}\", globalPosition, FBUtilities.toString(cfPositions));\n    }","id":25499,"modified_method":"public CommitLogReplayer()\n    {\n        this.keyspacesRecovered = new NonBlockingHashSet<>();\n        this.futures = new ArrayList<>();\n        this.buffer = new byte[4096];\n        this.invalidMutations = new HashMap<>();\n        // count the number of replayed mutation. We don't really care about atomicity, but we need it to be a reference.\n        this.replayedCount = new AtomicInteger();\n        this.checksum = new PureJavaCrc32();\n\n        // compute per-CF and global replay positions\n        cfPositions = new HashMap<>();\n        Ordering<ReplayPosition> replayPositionOrdering = Ordering.from(ReplayPosition.comparator);\n        for (ColumnFamilyStore cfs : ColumnFamilyStore.all())\n        {\n            // it's important to call RP.gRP per-cf, before aggregating all the positions w/ the Ordering.min call\n            // below: gRP will return NONE if there are no flushed sstables, which is important to have in the\n            // list (otherwise we'll just start replay from the first flush position that we do have, which is not correct).\n            ReplayPosition rp = ReplayPosition.getReplayPosition(cfs.getSSTables());\n\n            // but, if we've truncted the cf in question, then we need to need to start replay after the truncation\n            ReplayPosition truncatedAt = SystemKeyspace.getTruncatedPosition(cfs.metadata.cfId);\n            if (truncatedAt != null)\n                rp = replayPositionOrdering.max(Arrays.asList(rp, truncatedAt));\n\n            cfPositions.put(cfs.metadata.cfId, rp);\n        }\n        globalPosition = replayPositionOrdering.min(cfPositions.values());\n        logger.debug(\"Global replay position is {} from columnfamilies {}\", globalPosition, FBUtilities.toString(cfPositions));\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"public void recover(File file) throws IOException\n    {\n        final ReplayFilter replayFilter = ReplayFilter.create();\n        logger.info(\"Replaying {}\", file.getPath());\n        CommitLogDescriptor desc = CommitLogDescriptor.fromFileName(file.getName());\n        final long segmentId = desc.id;\n        logger.info(\"Replaying {} (CL version {}, messaging version {})\",\n                    file.getPath(),\n                    desc.version,\n                    desc.getMessagingVersion());\n        RandomAccessReader reader = RandomAccessReader.open(new File(file.getAbsolutePath()));\n\n        try\n        {\n            assert reader.length() <= Integer.MAX_VALUE;\n            int offset = getStartOffset(segmentId, desc.version);\n            if (offset < 0)\n            {\n                logger.debug(\"skipping replay of fully-flushed {}\", file);\n                return;\n            }\n\n            int prevEnd = CommitLogDescriptor.HEADER_SIZE;\n            main: while (true)\n            {\n\n                int end = prevEnd;\n                if (desc.version < CommitLogDescriptor.VERSION_21)\n                    end = Integer.MAX_VALUE;\n                else\n                {\n                    do { end = readSyncMarker(desc, end, reader); }\n                    while (end < offset && end > prevEnd);\n                }\n\n                if (end < prevEnd)\n                    break;\n\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Replaying {} between {} and {}\", file, offset, end);\n\n                reader.seek(offset);\n\n                 /* read the logs populate Mutation and apply */\n                while (reader.getPosition() < end && !reader.isEOF())\n                {\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"Reading mutation at {}\", reader.getFilePointer());\n\n                    long claimedCRC32;\n                    int serializedSize;\n                    try\n                    {\n                        // any of the reads may hit EOF\n                        serializedSize = reader.readInt();\n                        if (serializedSize == LEGACY_END_OF_SEGMENT_MARKER)\n                        {\n                            logger.debug(\"Encountered end of segment marker at {}\", reader.getFilePointer());\n                            break main;\n                        }\n\n                        // Mutation must be at LEAST 10 bytes:\n                        // 3 each for a non-empty Keyspace and Key (including the\n                        // 2-byte length from writeUTF/writeWithShortLength) and 4 bytes for column count.\n                        // This prevents CRC by being fooled by special-case garbage in the file; see CASSANDRA-2128\n                        if (serializedSize < 10)\n                            break main;\n\n                        long claimedSizeChecksum;\n                        if (desc.version < CommitLogDescriptor.VERSION_21)\n                            claimedSizeChecksum = reader.readLong();\n                        else\n                            claimedSizeChecksum = reader.readInt() & 0xffffffffL;\n                        checksum.reset();\n                        if (desc.version < CommitLogDescriptor.VERSION_20)\n                            checksum.update(serializedSize);\n                        else\n                            checksum.updateInt(serializedSize);\n\n                        if (checksum.getValue() != claimedSizeChecksum)\n                            break main; // entry wasn't synced correctly/fully. that's\n                        // ok.\n\n                        if (serializedSize > buffer.length)\n                            buffer = new byte[(int) (1.2 * serializedSize)];\n                        reader.readFully(buffer, 0, serializedSize);\n                        if (desc.version < CommitLogDescriptor.VERSION_21)\n                            claimedCRC32 = reader.readLong();\n                        else\n                            claimedCRC32 = reader.readInt() & 0xffffffffL;\n                    }\n                    catch (EOFException eof)\n                    {\n                        break main; // last CL entry didn't get completely written. that's ok.\n                    }\n\n                    checksum.update(buffer, 0, serializedSize);\n                    if (claimedCRC32 != checksum.getValue())\n                    {\n                        // this entry must not have been fsynced. probably the rest is bad too,\n                        // but just in case there is no harm in trying them (since we still read on an entry boundary)\n                        continue;\n                    }\n\n                    /* deserialize the commit log entry */\n                    FastByteArrayInputStream bufIn = new FastByteArrayInputStream(buffer, 0, serializedSize);\n                    final Mutation mutation;\n                    try\n                    {\n                        mutation = Mutation.serializer.deserialize(new DataInputStream(bufIn),\n                                                                   desc.getMessagingVersion(),\n                                                                   ColumnSerializer.Flag.LOCAL);\n                        // doublecheck that what we read is [still] valid for the current schema\n                        for (ColumnFamily cf : mutation.getColumnFamilies())\n                            for (Cell cell : cf)\n                                cf.getComparator().validate(cell.name());\n                    }\n                    catch (UnknownColumnFamilyException ex)\n                    {\n                        if (ex.cfId == null)\n                            continue;\n                        AtomicInteger i = invalidMutations.get(ex.cfId);\n                        if (i == null)\n                        {\n                            i = new AtomicInteger(1);\n                            invalidMutations.put(ex.cfId, i);\n                        }\n                        else\n                            i.incrementAndGet();\n                        continue;\n                    }\n                    catch (Throwable t)\n                    {\n                        File f = File.createTempFile(\"mutation\", \"dat\");\n                        DataOutputStream out = new DataOutputStream(new FileOutputStream(f));\n                        try\n                        {\n                            out.write(buffer, 0, serializedSize);\n                        }\n                        finally\n                        {\n                            out.close();\n                        }\n                        String st = String.format(\"Unexpected error deserializing mutation; saved to %s and ignored.  This may be caused by replaying a mutation against a table with the same name but incompatible schema.  Exception follows: \",\n                                                  f.getAbsolutePath());\n                        logger.error(st, t);\n                        continue;\n                    }\n\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"replaying mutation for {}.{}: {}\", mutation.getKeyspaceName(), ByteBufferUtil.bytesToHex(mutation.key()), \"{\" + StringUtils.join(mutation.getColumnFamilies().iterator(), \", \") + \"}\");\n\n                    final long entryLocation = reader.getFilePointer();\n                    Runnable runnable = new WrappedRunnable()\n                    {\n                        public void runMayThrow() throws IOException\n                        {\n                            if (Schema.instance.getKSMetaData(mutation.getKeyspaceName()) == null)\n                                return;\n                            if (pointInTimeExceeded(mutation))\n                                return;\n\n                            final Keyspace keyspace = Keyspace.open(mutation.getKeyspaceName());\n\n                            // Rebuild the mutation, omitting column families that\n                            //    a) the user has requested that we ignore,\n                            //    b) have already been flushed,\n                            // or c) are part of a cf that was dropped.\n                            // Keep in mind that the cf.name() is suspect. do every thing based on the cfid instead.\n                            Mutation newMutation = null;\n                            for (ColumnFamily columnFamily : replayFilter.filter(mutation))\n                            {\n                                if (Schema.instance.getCF(columnFamily.id()) == null)\n                                    continue; // dropped\n\n                                ReplayPosition rp = cfPositions.get(columnFamily.id());\n\n                                // replay if current segment is newer than last flushed one or,\n                                // if it is the last known segment, if we are after the replay position\n                                if (segmentId > rp.segment || (segmentId == rp.segment && entryLocation > rp.position))\n                                {\n                                    if (newMutation == null)\n                                        newMutation = new Mutation(mutation.getKeyspaceName(), mutation.key());\n                                    newMutation.add(columnFamily);\n                                    replayedCount.incrementAndGet();\n                                }\n                            }\n                            if (newMutation != null)\n                            {\n                                assert !newMutation.isEmpty();\n                                Keyspace.open(newMutation.getKeyspaceName()).apply(newMutation, false);\n                                keyspacesRecovered.add(keyspace);\n                            }\n                        }\n                    };\n                    futures.add(StageManager.getStage(Stage.MUTATION).submit(runnable));\n                    if (futures.size() > MAX_OUTSTANDING_REPLAY_COUNT)\n                    {\n                        FBUtilities.waitOnFutures(futures);\n                        futures.clear();\n                    }\n                }\n\n                if (desc.version < CommitLogDescriptor.VERSION_21)\n                    break;\n\n                offset = end + CommitLogSegment.SYNC_MARKER_SIZE;\n                prevEnd = end;\n            }\n        }\n        finally\n        {\n            FileUtils.closeQuietly(reader);\n            logger.info(\"Finished reading {}\", file);\n        }\n    }","id":25500,"modified_method":"public void recover(File file) throws IOException\n    {\n        final ReplayFilter replayFilter = ReplayFilter.create();\n        logger.info(\"Replaying {}\", file.getPath());\n        CommitLogDescriptor desc = CommitLogDescriptor.fromFileName(file.getName());\n        final long segmentId = desc.id;\n        logger.info(\"Replaying {} (CL version {}, messaging version {})\",\n                    file.getPath(),\n                    desc.version,\n                    desc.getMessagingVersion());\n        RandomAccessReader reader = RandomAccessReader.open(new File(file.getAbsolutePath()));\n\n        try\n        {\n            assert reader.length() <= Integer.MAX_VALUE;\n            int offset = getStartOffset(segmentId, desc.version);\n            if (offset < 0)\n            {\n                logger.debug(\"skipping replay of fully-flushed {}\", file);\n                return;\n            }\n\n            int prevEnd = CommitLogDescriptor.HEADER_SIZE;\n            main: while (true)\n            {\n\n                int end = prevEnd;\n                if (desc.version < CommitLogDescriptor.VERSION_21)\n                    end = Integer.MAX_VALUE;\n                else\n                {\n                    do { end = readSyncMarker(desc, end, reader); }\n                    while (end < offset && end > prevEnd);\n                }\n\n                if (end < prevEnd)\n                    break;\n\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Replaying {} between {} and {}\", file, offset, end);\n\n                reader.seek(offset);\n\n                 /* read the logs populate Mutation and apply */\n                while (reader.getPosition() < end && !reader.isEOF())\n                {\n                    long mutationStart = reader.getFilePointer();\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"Reading mutation at {}\", mutationStart);\n\n                    long claimedCRC32;\n                    int serializedSize;\n                    try\n                    {\n                        // any of the reads may hit EOF\n                        serializedSize = reader.readInt();\n                        if (serializedSize == LEGACY_END_OF_SEGMENT_MARKER)\n                        {\n                            logger.debug(\"Encountered end of segment marker at {}\", mutationStart);\n                            break main;\n                        }\n\n                        // Mutation must be at LEAST 10 bytes:\n                        // 3 each for a non-empty Keyspace and Key (including the\n                        // 2-byte length from writeUTF/writeWithShortLength) and 4 bytes for column count.\n                        // This prevents CRC by being fooled by special-case garbage in the file; see CASSANDRA-2128\n                        if (serializedSize < 10)\n                        {\n                            if (!IGNORE_ERRORS)\n                                throw new MalformedCommitLogException(\"Too small mutation encountered at position \" + mutationStart);\n                            break main;\n                        }\n\n                        long claimedSizeChecksum;\n                        if (desc.version < CommitLogDescriptor.VERSION_21)\n                            claimedSizeChecksum = reader.readLong();\n                        else\n                            claimedSizeChecksum = reader.readInt() & 0xffffffffL;\n                        checksum.reset();\n                        if (desc.version < CommitLogDescriptor.VERSION_20)\n                            checksum.update(serializedSize);\n                        else\n                            checksum.updateInt(serializedSize);\n\n                        if (checksum.getValue() != claimedSizeChecksum)\n                        {\n                            if (!IGNORE_ERRORS)\n                                throw new IOException(\"Invalid size checksum for mutation at position \" + mutationStart + \" of \" + file);\n                            break main; // entry wasn't synced correctly/fully. that's\n                        }\n                        // ok.\n\n                        if (serializedSize > buffer.length)\n                            buffer = new byte[(int) (1.2 * serializedSize)];\n                        reader.readFully(buffer, 0, serializedSize);\n                        if (desc.version < CommitLogDescriptor.VERSION_21)\n                            claimedCRC32 = reader.readLong();\n                        else\n                            claimedCRC32 = reader.readInt() & 0xffffffffL;\n                    }\n                    catch (EOFException eof)\n                    {\n                        if (!IGNORE_ERRORS)\n                            throw new MalformedCommitLogException(\"Encountered end-of-file unexpectedly\", eof);\n\n                        break main; // last CL entry didn't get completely written. that's ok.\n                    }\n\n                    checksum.update(buffer, 0, serializedSize);\n                    if (claimedCRC32 != checksum.getValue())\n                    {\n                        if (!IGNORE_ERRORS)\n                            throw new IOException(\"Invalid checksum for mutation at position \" + mutationStart + \" of \" + file);\n                        // this entry must not have been fsynced. probably the rest is bad too,\n                        // but just in case there is no harm in trying them (since we still read on an entry boundary)\n                        continue;\n                    }\n\n                    /* deserialize the commit log entry */\n                    FastByteArrayInputStream bufIn = new FastByteArrayInputStream(buffer, 0, serializedSize);\n                    final Mutation mutation;\n                    try\n                    {\n                        mutation = Mutation.serializer.deserialize(new DataInputStream(bufIn),\n                                                                   desc.getMessagingVersion(),\n                                                                   ColumnSerializer.Flag.LOCAL);\n                        // doublecheck that what we read is [still] valid for the current schema\n                        for (ColumnFamily cf : mutation.getColumnFamilies())\n                            for (Cell cell : cf)\n                                cf.getComparator().validate(cell.name());\n                    }\n                    catch (UnknownColumnFamilyException ex)\n                    {\n                        if (!IGNORE_MISSING_TABLES)\n                            throw ex;\n\n                        if (ex.cfId == null)\n                            continue;\n                        AtomicInteger i = invalidMutations.get(ex.cfId);\n                        if (i == null)\n                        {\n                            i = new AtomicInteger(1);\n                            invalidMutations.put(ex.cfId, i);\n                        }\n                        else\n                            i.incrementAndGet();\n                        continue;\n                    }\n                    catch (Throwable t)\n                    {\n                        if (!IGNORE_ERRORS)\n                            throw new MalformedCommitLogException(\"Encountered bad mutation\", t);\n\n                        File f = File.createTempFile(\"mutation\", \"dat\");\n                        try (DataOutputStream out = new DataOutputStream(new FileOutputStream(f)))\n                        {\n                            out.write(buffer, 0, serializedSize);\n                        }\n                        String st = String.format(\"Unexpected error deserializing mutation; saved to %s and ignored.  This may be caused by replaying a mutation against a table with the same name but incompatible schema.  Exception follows: \",\n                                                  f.getAbsolutePath());\n                        logger.error(st, t);\n                        continue;\n                    }\n\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"replaying mutation for {}.{}: {}\", mutation.getKeyspaceName(), ByteBufferUtil.bytesToHex(mutation.key()), \"{\" + StringUtils.join(mutation.getColumnFamilies().iterator(), \", \") + \"}\");\n\n                    final long entryLocation = reader.getFilePointer();\n                    Runnable runnable = new WrappedRunnable()\n                    {\n                        public void runMayThrow() throws IOException\n                        {\n                            if (Schema.instance.getKSMetaData(mutation.getKeyspaceName()) == null)\n                            {\n                                if (!IGNORE_MISSING_TABLES)\n                                    throw new UnknownColumnFamilyException(\"Keyspace for this table is missing\", mutation.getColumnFamilyIds().iterator().next());\n                                return;\n                            }\n                            if (pointInTimeExceeded(mutation))\n                                return;\n\n                            final Keyspace keyspace = Keyspace.open(mutation.getKeyspaceName());\n\n                            // Rebuild the mutation, omitting column families that\n                            //    a) the user has requested that we ignore,\n                            //    b) have already been flushed,\n                            // or c) are part of a cf that was dropped.\n                            // Keep in mind that the cf.name() is suspect. do every thing based on the cfid instead.\n                            Mutation newMutation = null;\n                            for (ColumnFamily columnFamily : replayFilter.filter(mutation))\n                            {\n                                if (Schema.instance.getCF(columnFamily.id()) == null)\n                                {\n                                    if (!IGNORE_MISSING_TABLES)\n                                        throw new UnknownColumnFamilyException(\"Missing table with cfid=\" + columnFamily.id(),\n                                                                               mutation.getColumnFamilyIds().iterator().next());\n                                    continue; // dropped\n                                }\n\n                                ReplayPosition rp = cfPositions.get(columnFamily.id());\n\n                                // replay if current segment is newer than last flushed one or,\n                                // if it is the last known segment, if we are after the replay position\n                                if (segmentId > rp.segment || (segmentId == rp.segment && entryLocation > rp.position))\n                                {\n                                    if (newMutation == null)\n                                        newMutation = new Mutation(mutation.getKeyspaceName(), mutation.key());\n                                    newMutation.add(columnFamily);\n                                    replayedCount.incrementAndGet();\n                                }\n                            }\n                            if (newMutation != null)\n                            {\n                                assert !newMutation.isEmpty();\n                                keyspace.apply(newMutation, false);\n                                keyspacesRecovered.add(keyspace);\n                            }\n                        }\n                    };\n                    futures.add(StageManager.getStage(Stage.MUTATION).submit(runnable));\n                    if (futures.size() > MAX_OUTSTANDING_REPLAY_COUNT)\n                    {\n                        FBUtilities.waitOnFutures(futures);\n                        futures.clear();\n                    }\n                }\n\n                if (desc.version < CommitLogDescriptor.VERSION_21)\n                    break;\n\n                offset = end + CommitLogSegment.SYNC_MARKER_SIZE;\n                prevEnd = end;\n            }\n        }\n        finally\n        {\n            FileUtils.closeQuietly(reader);\n            logger.info(\"Finished reading {}\", file);\n        }\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"private int readSyncMarker(CommitLogDescriptor descriptor, int offset, RandomAccessReader reader) throws IOException\n    {\n        if (offset > reader.length() - CommitLogSegment.SYNC_MARKER_SIZE)\n        {\n            if (offset != reader.length() && offset != Integer.MAX_VALUE)\n                logger.warn(\"Encountered bad header at position {} of Commit log {}; not enough room for a header\", offset, reader.getPath());\n            // cannot possibly be a header here. if we're == length(), assume it's a correctly written final segment\n            return -1;\n        }\n        reader.seek(offset);\n        PureJavaCrc32 crc = new PureJavaCrc32();\n        crc.updateInt((int) (descriptor.id & 0xFFFFFFFFL));\n        crc.updateInt((int) (descriptor.id >>> 32));\n        crc.updateInt((int) reader.getPosition());\n        int end = reader.readInt();\n        long filecrc;\n        if (descriptor.version < CommitLogDescriptor.VERSION_21)\n            filecrc = reader.readLong();\n        else\n            filecrc = reader.readInt() & 0xffffffffL;\n        if (crc.getValue() != filecrc)\n        {\n            if (end != 0 || filecrc != 0)\n            {\n                logger.warn(\"Encountered bad header at position {} of commit log {}, with invalid CRC. The end of segment marker should be zero.\", offset, reader.getPath());\n            }\n            return -1;\n        }\n        else if (end < offset || end > reader.length())\n        {\n            logger.warn(\"Encountered bad header at position {} of commit log {}, with bad position but valid CRC\", offset, reader.getPath());\n            return -1;\n        }\n        return end;\n    }","id":25501,"modified_method":"private int readSyncMarker(CommitLogDescriptor descriptor, int offset, RandomAccessReader reader) throws IOException\n    {\n        if (offset > reader.length() - CommitLogSegment.SYNC_MARKER_SIZE)\n        {\n            if (offset != reader.length() && offset != Integer.MAX_VALUE)\n            {\n                String message = String.format(\"Encountered bad header at position %d of Commit log %s; not enough room for a header\", offset, reader.getPath());\n                if (!IGNORE_ERRORS)\n                    throw new MalformedCommitLogException(message);\n                logger.warn(message);\n            }\n            // cannot possibly be a header here. if we're == length(), assume it's a correctly written final segment\n            return -1;\n        }\n        reader.seek(offset);\n        PureJavaCrc32 crc = new PureJavaCrc32();\n        crc.updateInt((int) (descriptor.id & 0xFFFFFFFFL));\n        crc.updateInt((int) (descriptor.id >>> 32));\n        crc.updateInt((int) reader.getPosition());\n        int end = reader.readInt();\n        long filecrc;\n        if (descriptor.version < CommitLogDescriptor.VERSION_21)\n            filecrc = reader.readLong();\n        else\n            filecrc = reader.readInt() & 0xffffffffL;\n        if (crc.getValue() != filecrc)\n        {\n            if (end != 0 || filecrc != 0)\n            {\n                String message = String.format(\"Encountered bad header at position %d of Commit log %s, with invalid CRC. The end of segment marker should be zero.\", offset, reader.getPath());\n                if (!IGNORE_ERRORS)\n                    throw new MalformedCommitLogException(message);\n                logger.warn(message);\n            }\n            return -1;\n        }\n        else if (end < offset || end > reader.length())\n        {\n            String message = String.format(\"Encountered bad header at position %d of Commit log %s, with bad position but valid CRC.\", offset, reader.getPath());\n            if (!IGNORE_ERRORS)\n                throw new MalformedCommitLogException(message);\n            logger.warn(message);\n            return -1;\n        }\n        return end;\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testRecoveryWithShortLog() throws Exception\n    {\n        // force EOF while reading log\n        testRecoveryWithBadSizeArgument(100, 10);\n    }","id":25502,"modified_method":"@Test\n    public void testRecoveryWithShortLog() throws Exception\n    {\n        // force EOF while reading log\n        testMalformed(badLogFile(100, 10));\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testRecoveryWithShortSize() throws Exception\n    {\n        testRecovery(new byte[2]);\n    }","id":25503,"modified_method":"@Test\n    public void testRecoveryWithShortSize() throws Exception\n    {\n        testMalformed(new byte[2]);\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"protected void testRecoveryWithBadSizeArgument(int size, int dataSize) throws Exception\n    {\n        Checksum checksum = new CRC32();\n        checksum.update(size);\n        testRecoveryWithBadSizeArgument(size, dataSize, checksum.getValue());\n    }","id":25504,"modified_method":"@Test\n    public void testRecoveryWithBadSize() throws Exception\n    {\n        Checksum checksum = new CRC32();\n        checksum.update(100);\n        testMalformed(badLogFile(120, checksum.getValue(), garbage(100)));\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"private static int getMaxRecordDataSize(String keyspace, ByteBuffer key, String table, CellName column)\n    {\n        Mutation rm = new Mutation(\"Keyspace1\", bytes(\"k\"));\n        rm.add(\"Standard1\", Util.cellname(\"c1\"), ByteBuffer.allocate(0), 0);\n\n        int max = (DatabaseDescriptor.getCommitLogSegmentSize() / 2);\n        max -= CommitLogSegment.ENTRY_OVERHEAD_SIZE; // log entry overhead\n        return max - (int) Mutation.serializer.serializedSize(rm, MessagingService.current_version);\n    }","id":25505,"modified_method":"private static int getMaxRecordDataSize(String keyspace, ByteBuffer key, String table, CellName column)\n    {\n        Mutation rm = new Mutation(keyspace, key);\n        rm.add(table, column, ByteBuffer.allocate(0), 0);\n\n        int max = (DatabaseDescriptor.getCommitLogSegmentSize() / 2);\n        max -= CommitLogSegment.ENTRY_OVERHEAD_SIZE; // log entry overhead\n        return max - (int) Mutation.serializer.serializedSize(rm, MessagingService.current_version);\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testRecoveryWithNegativeSizeArgument() throws Exception\n    {\n        // garbage from a partial/bad flush could be read as a negative size even if there is no EOF\n        testRecoveryWithBadSizeArgument(-10, 10); // negative size, but no EOF\n    }","id":25506,"modified_method":"@Test\n    public void testRecoveryWithNegativeSizeArgument() throws Exception\n    {\n        // garbage from a partial/bad flush could be read as a negative size even if there is no EOF\n        testMalformed(badLogFile(-10, 10)); // zero size, but no EOF\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testRecoveryWithZeroSegmentSizeArgument() throws Exception\n    {\n        // many different combinations of 4 bytes (garbage) will be read as zero by readInt()\n        testRecoveryWithBadSizeArgument(0, 10); // zero size, but no EOF\n    }","id":25507,"modified_method":"@Test\n    public void testRecoveryWithZeroSegmentSizeArgument() throws Exception\n    {\n        // many different combinations of 4 bytes (garbage) will be read as zero by readInt()\n        testMalformed(badLogFile(0, -1L, 10)); // zero size, but no EOF\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testRecoveryWithShortCheckSum() throws Exception\n    {\n        testRecovery(new byte[6]);\n    }","id":25508,"modified_method":"@Test\n    public void testRecoveryWithShortCheckSum() throws Exception\n    {\n        testMalformed(new byte[6]);\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testRecoveryWithEmptyLog() throws Exception\n    {\n        CommitLog.instance.recover(new File[]{ tmpFile() });\n    }","id":25509,"modified_method":"@Test\n    public void testRecoveryWithEmptyLog() throws Exception\n    {\n        testMalformed(badLogFile(new byte[0]));\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testRecoveryWithGarbageLog() throws Exception\n    {\n        byte[] garbage = new byte[100];\n        (new java.util.Random()).nextBytes(garbage);\n        testRecovery(garbage);\n    }","id":25510,"modified_method":"@Test\n    public void testRecoveryWithGarbageLog() throws Exception\n    {\n        testMalformed(garbage(100));\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testRecoveryWithBadSizeChecksum() throws Exception\n    {\n        Checksum checksum = new CRC32();\n        checksum.update(100);\n        testRecoveryWithBadSizeArgument(100, 100, ~checksum.getValue());\n    }","id":25511,"modified_method":"@Test\n    public void testRecoveryWithBadSizeChecksum() throws Exception\n    {\n        Checksum checksum = new CRC32();\n        checksum.update(100);\n        testMalformed(badLogFile(100, checksum.getValue(), new byte[100]));\n        testMalformed(badLogFile(100, checksum.getValue(), garbage(100)));\n    }","commit_id":"581ce631026b98ee9438d54ef144df89bc91100b","url":"https://github.com/apache/cassandra"},{"original_method":"private String encodeAuthnRequest(AuthnRequest authnRequest)\n            throws MarshallingException, IOException {\n\n        Marshaller marshaller = null;\n        org.w3c.dom.Element authDOM = null;\n        StringWriter requestWriter = null;\n        String requestMessage = null;\n        Deflater deflater = null;\n        ByteArrayOutputStream byteArrayOutputStream = null;\n        DeflaterOutputStream deflaterOutputStream = null;\n        String encodedRequestMessage = null;\n\n        marshaller = org.opensaml.Configuration.getMarshallerFactory()\n                .getMarshaller(authnRequest); // object to DOM converter\n\n        authDOM = marshaller.marshall(authnRequest); // converting to a DOM\n\n        requestWriter = new StringWriter();\n        XMLHelper.writeNode(authDOM, requestWriter);\n        requestMessage = requestWriter.toString(); // DOM to string\n\n        deflater = new Deflater(Deflater.DEFLATED, true);\n        byteArrayOutputStream = new ByteArrayOutputStream();\n        deflaterOutputStream = new DeflaterOutputStream(byteArrayOutputStream,\n                deflater);\n        deflaterOutputStream.write(requestMessage.getBytes()); // compressing\n        deflaterOutputStream.close();\n\n        encodedRequestMessage = Base64.encodeBytes(byteArrayOutputStream\n                .toByteArray(), Base64.DONT_BREAK_LINES);\n        encodedRequestMessage = URLEncoder.encode(encodedRequestMessage,\n                \"UTF-8\").trim(); // encoding string\n\n        return encodedRequestMessage;\n    }","id":25512,"modified_method":"private String encodeAuthnRequest(AuthnRequest authnRequest)\n            throws MarshallingException, IOException {\n        Marshaller marshaller = Configuration.getMarshallerFactory()\n                .getMarshaller(authnRequest);\n        Element authDOM = marshaller.marshall(authnRequest);\n        StringWriter requestWriter = new StringWriter();\n        XMLHelper.writeNode(authDOM, requestWriter);\n        String requestMessage = requestWriter.toString();\n        Deflater deflater = new Deflater(Deflater.DEFLATED, true);\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(byteArrayOutputStream, deflater);\n        deflaterOutputStream.write(requestMessage.getBytes());\n        deflaterOutputStream.close();\n        String encodedRequestMessage = Base64.encodeBytes(byteArrayOutputStream.toByteArray(), Base64.DONT_BREAK_LINES);\n        encodedRequestMessage = URLEncoder.encode(encodedRequestMessage, \"UTF-8\").trim();\n        return encodedRequestMessage;\n    }","commit_id":"a1dc9e8189ebdab3f7e8b849f1777f282a7a295b","url":"https://github.com/apache/cloudstack"},{"original_method":"public String processResponseMessage(String responseMessage) {\n\n        XMLObject responseObject = null;\n\n        try {\n\n            responseObject = this.unmarshall(responseMessage);\n\n        } catch (ConfigurationException | ParserConfigurationException | SAXException | IOException | UnmarshallingException e) {\n            e.printStackTrace();\n        }\n\n        return this.getResult(responseObject);\n    }","id":25513,"modified_method":"public Response processSAMLResponse(String responseMessage) {\n        XMLObject responseObject = null;\n        try {\n            responseObject = this.unmarshall(responseMessage);\n\n        } catch (ConfigurationException | ParserConfigurationException | SAXException | IOException | UnmarshallingException e) {\n            s_logger.error(\"SAMLResponse processing error: \" + e.getMessage());\n        }\n        return (Response) responseObject;\n    }","commit_id":"a1dc9e8189ebdab3f7e8b849f1777f282a7a295b","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public String authenticate(String command, Map<String, Object[]> params, HttpSession session, String remoteAddress, String responseType, StringBuilder auditTrailSb, final HttpServletResponse resp) throws ServerApiException {\n        String response = null;\n        try {\n            String redirectUrl = buildAuthnRequestUrl(\"http://localhost:8080/client/api?command=login\");\n            resp.sendRedirect(redirectUrl);\n\n            //resp.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY);\n            //resp.setHeader(\"Location\", redirectUrl);\n\n            // TODO: create and send assertion with the URL as GET params\n\n        } catch (IOException e) {\n            auditTrailSb.append(\"SP initiated SAML authentication using HTTP redirection failed:\");\n            auditTrailSb.append(e.getMessage());\n        }\n        return response;\n    }","id":25514,"modified_method":"@Override\n    public String authenticate(final String command, final Map<String, Object[]> params, final HttpSession session, final String remoteAddress, final String responseType, final StringBuilder auditTrailSb, final HttpServletResponse resp) throws ServerApiException {\n        try {\n            if (!params.containsKey(\"SAMLResponse\")) {\n                final String[] idps = (String[])params.get(\"idpurl\");\n                String redirectUrl = buildAuthnRequestUrl(\"http://localhost:8080/client/api?command=samlsso\", idps[0]);\n                resp.sendRedirect(redirectUrl);\n                return \"\";\n            } else {\n                final String samlResponse = ((String[])params.get(\"SAMLResponse\"))[0];\n                Response processedSAMLResponse = processSAMLResponse(samlResponse);\n                String statusCode = processedSAMLResponse.getStatus().getStatusCode().getValue();\n                if (!statusCode.equals(StatusCode.SUCCESS_URI)) {\n                    throw new ServerApiException(ApiErrorCode.ACCOUNT_ERROR, _apiServer.getSerializedApiError(ApiErrorCode.ACCOUNT_ERROR.getHttpCode(),\n                            \"Identity Provider send a non-successful authentication status code\",\n                            params, responseType));\n                }\n\n                Signature sig = processedSAMLResponse.getSignature();\n                //SignatureValidator validator = new SignatureValidator(credential);\n                //validator.validate(sig);\n\n                String uniqueUserId = null;\n                String accountName = \"admin\"; //GET from config, try, fail\n                Long domainId = 1L; // GET from config, try, fail\n                String username = null;\n                String password = \"\";\n                String firstName = \"\";\n                String lastName = \"\";\n                String timeZone = \"\";\n                String email = \"\";\n\n                Assertion assertion = processedSAMLResponse.getAssertions().get(0);\n                NameID nameId = assertion.getSubject().getNameID();\n\n                if (nameId.getFormat().equals(NameIDType.PERSISTENT) || nameId.getFormat().equals(NameIDType.EMAIL)) {\n                    username = nameId.getValue();\n                    uniqueUserId = \"saml-\" + username;\n                    if (nameId.getFormat().equals(NameIDType.EMAIL)) {\n                        email = username;\n                    }\n                }\n\n                String issuer = assertion.getIssuer().getValue();\n                String audience = assertion.getConditions().getAudienceRestrictions().get(0).getAudiences().get(0).getAudienceURI();\n                AttributeStatement attributeStatement = assertion.getAttributeStatements().get(0);\n                List<Attribute> attributes = attributeStatement.getAttributes();\n\n                // Try capturing standard LDAP attributes\n                for (Attribute attribute: attributes) {\n                    String attributeName = attribute.getName();\n                    String attributeValue = attribute.getAttributeValues().get(0).getDOM().getTextContent();\n                    if (attributeName.equalsIgnoreCase(\"uid\") && uniqueUserId == null) {\n                        username = attributeValue;\n                        uniqueUserId = \"saml-\" + username;\n                    } else if (attributeName.equalsIgnoreCase(\"givenName\")) {\n                        firstName = attributeValue;\n                    } else if (attributeName.equalsIgnoreCase((\"sn\"))) {\n                        lastName = attributeValue;\n                    } else if (attributeName.equalsIgnoreCase(\"mail\")) {\n                        email = attributeValue;\n                    }\n                }\n\n                User user = _entityMgr.findByUuid(User.class, uniqueUserId);\n                if (user == null && uniqueUserId != null && username != null\n                        && accountName != null && domainId != null) {\n                    CallContext.current().setEventDetails(\"UserName: \" + username + \", FirstName :\" + password + \", LastName: \" + lastName);\n                    user = _accountService.createUser(username, password, firstName, lastName, email, timeZone, accountName, domainId, uniqueUserId);\n                }\n\n                if (user != null) {\n                    try {\n                        if (_apiServer.verifyUser(user.getId())) {\n                            LoginCmdResponse loginResponse = (LoginCmdResponse) _apiServer.loginUser(session, username, user.getPassword(), domainId, null, remoteAddress, params);\n                            resp.addCookie(new Cookie(\"userid\", loginResponse.getUserId()));\n                            resp.addCookie(new Cookie(\"domainid\", loginResponse.getDomainId()));\n                            resp.addCookie(new Cookie(\"role\", loginResponse.getType()));\n                            resp.addCookie(new Cookie(\"username\", URLEncoder.encode(loginResponse.getUsername(), HttpUtils.UTF_8)));\n                            resp.addCookie(new Cookie(\"sessionKey\", URLEncoder.encode(loginResponse.getSessionKey(), HttpUtils.UTF_8)));\n                            resp.addCookie(new Cookie(\"account\", URLEncoder.encode(loginResponse.getAccount(), HttpUtils.UTF_8)));\n                            //resp.sendRedirect(\"http://localhost:8080/client\");\n                            return ApiResponseSerializer.toSerializedString(loginResponse, responseType);\n\n                        }\n                    } catch (final CloudAuthenticationException ignored) {\n                    }\n                }\n            }\n        } catch (IOException e) {\n            auditTrailSb.append(\"SP initiated SAML authentication using HTTP redirection failed:\");\n            auditTrailSb.append(e.getMessage());\n        }\n        throw new ServerApiException(ApiErrorCode.ACCOUNT_ERROR, _apiServer.getSerializedApiError(ApiErrorCode.ACCOUNT_ERROR.getHttpCode(),\n                \"Unable to authenticate or retrieve user while performing SAML based SSO\",\n                params, responseType));\n    }","commit_id":"a1dc9e8189ebdab3f7e8b849f1777f282a7a295b","url":"https://github.com/apache/cloudstack"},{"original_method":"private AuthnRequest buildAuthnRequestObject(String authnId, String idpUrl, String consumerUrl) {\n        // Issuer object\n        IssuerBuilder issuerBuilder = new IssuerBuilder();\n        Issuer issuer = issuerBuilder.buildObject();\n        //SAMLConstants.SAML20_NS,\n        //        \"Issuer\", \"samlp\");\n        issuer.setValue(\"apache-cloudstack\");\n\n        // NameIDPolicy\n        NameIDPolicyBuilder nameIdPolicyBuilder = new NameIDPolicyBuilder();\n        NameIDPolicy nameIdPolicy = nameIdPolicyBuilder.buildObject();\n        nameIdPolicy.setFormat(\"urn:oasis:names:tc:SAML:2.0:nameid-format:persistent\");\n        nameIdPolicy.setSPNameQualifier(\"Apache CloudStack\");\n        nameIdPolicy.setAllowCreate(true);\n\n        // AuthnContextClass\n        AuthnContextClassRefBuilder authnContextClassRefBuilder = new AuthnContextClassRefBuilder();\n        AuthnContextClassRef authnContextClassRef = authnContextClassRefBuilder.buildObject(\n                SAMLConstants.SAML20_NS,\n                \"AuthnContextClassRef\", \"saml\");\n        authnContextClassRef.setAuthnContextClassRef(\"urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport\");\n\n        // AuthnContex\n        RequestedAuthnContextBuilder requestedAuthnContextBuilder = new RequestedAuthnContextBuilder();\n        RequestedAuthnContext requestedAuthnContext = requestedAuthnContextBuilder.buildObject();\n        requestedAuthnContext\n                .setComparison(AuthnContextComparisonTypeEnumeration.EXACT);\n        requestedAuthnContext.getAuthnContextClassRefs().add(\n                authnContextClassRef);\n\n\n        // Creation of AuthRequestObject\n        AuthnRequestBuilder authRequestBuilder = new AuthnRequestBuilder();\n        AuthnRequest authnRequest = authRequestBuilder.buildObject();\n        //SAMLConstants.SAML20P_NS,\n        //        \"AuthnRequest\", \"samlp\");\n        authnRequest.setID(authnId);\n        authnRequest.setDestination(idpUrl);\n        authnRequest.setVersion(SAMLVersion.VERSION_20);\n        authnRequest.setForceAuthn(true);\n        authnRequest.setIsPassive(false);\n        authnRequest.setIssuer(issuer);\n        authnRequest.setIssueInstant(new DateTime());\n        authnRequest.setProviderName(\"Apache CloudStack\");\n        authnRequest.setProtocolBinding(SAMLConstants.SAML2_REDIRECT_BINDING_URI);\n        authnRequest.setAssertionConsumerServiceURL(consumerUrl);\n        //authnRequest.setNameIDPolicy(nameIdPolicy);\n        //authnRequest.setRequestedAuthnContext(requestedAuthnContext);\n\n        return authnRequest;\n    }","id":25515,"modified_method":"private AuthnRequest buildAuthnRequestObject(String authnId, String spId, String idpUrl, String consumerUrl) {\n        // Issuer object\n        IssuerBuilder issuerBuilder = new IssuerBuilder();\n        Issuer issuer = issuerBuilder.buildObject();\n        issuer.setValue(spId);\n\n        // NameIDPolicy\n        NameIDPolicyBuilder nameIdPolicyBuilder = new NameIDPolicyBuilder();\n        NameIDPolicy nameIdPolicy = nameIdPolicyBuilder.buildObject();\n        nameIdPolicy.setFormat(NameIDType.PERSISTENT);\n        nameIdPolicy.setSPNameQualifier(\"Apache CloudStack\");\n        nameIdPolicy.setAllowCreate(true);\n\n        // AuthnContextClass\n        AuthnContextClassRefBuilder authnContextClassRefBuilder = new AuthnContextClassRefBuilder();\n        AuthnContextClassRef authnContextClassRef = authnContextClassRefBuilder.buildObject(\n                SAMLConstants.SAML20_NS,\n                \"AuthnContextClassRef\", \"saml\");\n        authnContextClassRef.setAuthnContextClassRef(\"urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport\");\n\n        // AuthnContex\n        RequestedAuthnContextBuilder requestedAuthnContextBuilder = new RequestedAuthnContextBuilder();\n        RequestedAuthnContext requestedAuthnContext = requestedAuthnContextBuilder.buildObject();\n        requestedAuthnContext\n                .setComparison(AuthnContextComparisonTypeEnumeration.MINIMUM);\n        requestedAuthnContext.getAuthnContextClassRefs().add(\n                authnContextClassRef);\n\n        // Creation of AuthRequestObject\n        AuthnRequestBuilder authRequestBuilder = new AuthnRequestBuilder();\n        AuthnRequest authnRequest = authRequestBuilder.buildObject();\n        authnRequest.setID(authnId);\n        authnRequest.setDestination(idpUrl);\n        authnRequest.setVersion(SAMLVersion.VERSION_20);\n        authnRequest.setForceAuthn(true);\n        authnRequest.setIsPassive(false);\n        authnRequest.setIssuer(issuer);\n        authnRequest.setIssueInstant(new DateTime());\n        authnRequest.setProviderName(\"Apache CloudStack\");\n        authnRequest.setProtocolBinding(SAMLConstants.SAML2_REDIRECT_BINDING_URI); //SAML2_ARTIFACT_BINDING_URI);\n        authnRequest.setAssertionConsumerServiceURL(consumerUrl);\n        authnRequest.setNameIDPolicy(nameIdPolicy);\n        authnRequest.setRequestedAuthnContext(requestedAuthnContext);\n\n        return authnRequest;\n    }","commit_id":"a1dc9e8189ebdab3f7e8b849f1777f282a7a295b","url":"https://github.com/apache/cloudstack"},{"original_method":"public String buildAuthnRequestUrl(String resourceUrl) {\n        String randomId = new BigInteger(130, new SecureRandom()).toString(32);\n        // TODO: Add method to get this url from metadata\n        String identityProviderUrl = \"https://idp.ssocircle.com:443/sso/SSORedirect/metaAlias/ssocircle\";\n        String encodedAuthRequest = \"\";\n\n        try {\n            DefaultBootstrap.bootstrap();\n            AuthnRequest authnRequest = this.buildAuthnRequestObject(randomId, identityProviderUrl, resourceUrl); // SAML AuthRequest\n            encodedAuthRequest = encodeAuthnRequest(authnRequest);\n        } catch (ConfigurationException | FactoryConfigurationError | MarshallingException | IOException e) {\n            s_logger.error(\"SAML AuthnRequest message building error: \" + e.getMessage());\n        }\n        return identityProviderUrl + \"?SAMLRequest=\" + encodedAuthRequest; // + \"&RelayState=\" + relayState;\n    }","id":25516,"modified_method":"public String buildAuthnRequestUrl(String consumerUrl, String identityProviderUrl) {\n        String randomId = new BigInteger(130, new SecureRandom()).toString(32);\n        String spId = \"org.apache.cloudstack\";\n        String redirectUrl = \"\";\n        try {\n            DefaultBootstrap.bootstrap();\n            AuthnRequest authnRequest = this.buildAuthnRequestObject(randomId, spId, identityProviderUrl, consumerUrl);\n            redirectUrl = identityProviderUrl + \"?SAMLRequest=\" + encodeAuthnRequest(authnRequest);\n        } catch (ConfigurationException | FactoryConfigurationError | MarshallingException | IOException e) {\n            s_logger.error(\"SAML AuthnRequest message building error: \" + e.getMessage());\n        }\n        return redirectUrl;\n    }","commit_id":"a1dc9e8189ebdab3f7e8b849f1777f282a7a295b","url":"https://github.com/apache/cloudstack"},{"original_method":"private XMLObject unmarshall(String responseMessage)\n            throws ConfigurationException, ParserConfigurationException,\n            SAXException, IOException, UnmarshallingException {\n\n        DocumentBuilderFactory documentBuilderFactory = null;\n        DocumentBuilder docBuilder = null;\n        Document document = null;\n        Element element = null;\n        UnmarshallerFactory unmarshallerFactory = null;\n        Unmarshaller unmarshaller = null;\n\n        DefaultBootstrap.bootstrap();\n\n        documentBuilderFactory = DocumentBuilderFactory.newInstance();\n\n        documentBuilderFactory.setNamespaceAware(true);\n\n        docBuilder = documentBuilderFactory.newDocumentBuilder();\n\n        document = docBuilder.parse(new ByteArrayInputStream(responseMessage\n                .trim().getBytes())); // response to DOM\n\n        element = document.getDocumentElement(); // the DOM element\n\n        unmarshallerFactory = Configuration.getUnmarshallerFactory();\n\n        unmarshaller = unmarshallerFactory.getUnmarshaller(element);\n\n        return unmarshaller.unmarshall(element); // Response object\n\n    }","id":25517,"modified_method":"private XMLObject unmarshall(String responseMessage)\n            throws ConfigurationException, ParserConfigurationException,\n            SAXException, IOException, UnmarshallingException {\n        try {\n            DefaultBootstrap.bootstrap();\n        } catch (ConfigurationException | FactoryConfigurationError e) {\n            s_logger.error(\"SAML response message decoding error: \" + e.getMessage());\n        }\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        documentBuilderFactory.setNamespaceAware(true);\n        DocumentBuilder docBuilder = documentBuilderFactory.newDocumentBuilder();\n        byte[] base64DecodedResponse = Base64.decode(responseMessage);\n        Document document = docBuilder.parse(new ByteArrayInputStream(base64DecodedResponse));\n        Element element = document.getDocumentElement();\n        UnmarshallerFactory unmarshallerFactory = Configuration.getUnmarshallerFactory();\n        Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element);\n        return unmarshaller.unmarshall(element);\n    }","commit_id":"a1dc9e8189ebdab3f7e8b849f1777f282a7a295b","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\r\n\t\t * @see wicket.spring.ISpringContextLocator#getSpringContext()\r\n\t\t */\r\n\t\tpublic ApplicationContext getSpringContext()\r\n\t\t{\r\n\t\t\tif (context == null)\r\n\t\t\t{\r\n\t\t\t\tcontext = ((ApplicationContextHolder) Application.get().getMetaData(\r\n\t\t\t\t\t\tCONTEXT_KEY)).getContext();\r\n\t\t\t}\r\n\t\t\treturn context;\r\n\t\t}","id":25518,"modified_method":"/**\r\n\t\t * @see wicket.spring.ISpringContextLocator#getSpringContext()\r\n\t\t */\r\n\t\tpublic ApplicationContext getSpringContext()\r\n\t\t{\r\n\t\t\tif (context == null)\r\n\t\t\t{\r\n\t\t\t\tcontext = Application.get().getMetaData(CONTEXT_KEY).getContext();\r\n\t\t\t}\r\n\t\t\treturn context;\r\n\t\t}","commit_id":"de8e7c74ff8b195ec04f26fec1728b8b1ab684f5","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * @see org.apache.wicket.markup.html.IHeaderContributor#renderHead(IHeaderResponse)\n\t\t */\n\t\t@Override\n\t\tpublic final void renderHead(final IHeaderResponse headResponse)\n\t\t{\n\t\t\tResponse response = headResponse.getResponse();\n\t\t\tfinal WebRequestCycle cycle = (WebRequestCycle)RequestCycle.get();\n\t\t\tfinal IRequestTarget target = cycle.getRequestTarget();\n\n\t\t\t// we don't want to render this for stateless pages\n\t\t\tif (webPage.isPageStateless())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tIPageMap pageMap = webPage.getPageMap();\n\t\t\tString name = pageMap.getName();\n\t\t\tif (name == null)\n\t\t\t{\n\t\t\t\tname = \"wicket:default\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tname = name.replace('\"', '_');\n\t\t\t}\n\n\t\t\tSession session = Session.get();\n\n\t\t\tSession.PageMapAccessMetaData meta = (Session.PageMapAccessMetaData)session.getMetaData(Session.PAGEMAP_ACCESS_MDK);\n\t\t\tif (meta == null)\n\t\t\t{\n\t\t\t\tmeta = new Session.PageMapAccessMetaData();\n\t\t\t\tsession.setMetaData(Session.PAGEMAP_ACCESS_MDK, meta);\n\t\t\t}\n\t\t\tboolean firstAccess = meta.add(pageMap);\n\n\t\t\tif (firstAccess)\n\t\t\t{\n\t\t\t\t// this is the first access to the pagemap, set window.name\n\t\t\t\tJavascriptUtils.writeOpenTag(response);\n\t\t\t\tresponse.write(\"if (window.name=='' || window.name.indexOf('wicket') > -1) { window.name=\\\"\");\n\t\t\t\tresponse.write(\"wicket-\" + name);\n\t\t\t\tresponse.write(\"\\\"; }\");\n\t\t\t\tJavascriptUtils.writeCloseTag(response);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Here is our trickery to detect whether the current request\n\t\t\t\t// was made in a new window/ tab, in which case it should go in\n\t\t\t\t// a different page map so that we don't intermingle the history\n\t\t\t\t// of those windows\n\t\t\t\tCharSequence url = null;\n\t\t\t\tif (target instanceof IBookmarkablePageRequestTarget)\n\t\t\t\t{\n\t\t\t\t\tIBookmarkablePageRequestTarget current = (IBookmarkablePageRequestTarget)target;\n\t\t\t\t\tBookmarkablePageRequestTarget redirect = new BookmarkablePageRequestTarget(\n\t\t\t\t\t\tsession.createAutoPageMapName(), current.getPageClass(),\n\t\t\t\t\t\tcurrent.getPageParameters());\n\t\t\t\t\turl = cycle.urlFor(redirect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\turl = webPage.urlFor(INewBrowserWindowListener.INTERFACE);\n\t\t\t\t}\n\t\t\t\tJavascriptUtils.writeOpenTag(response);\n\t\t\t\tresponse.write(\"if (window.name=='' || (window.name.indexOf('wicket') > -1 && window.name!='\" +\n\t\t\t\t\t\"wicket-\" + name + \"')) { window.location=\\\"\");\n\t\t\t\tresponse.write(url);\n\t\t\t\tresponse.write(\"\\\" + (window.location.hash != null ? window.location.hash : \\\"\\\"); }\");\n\t\t\t\tJavascriptUtils.writeCloseTag(response);\n\t\t\t}\n\t\t}","id":25519,"modified_method":"/**\n\t\t * @see org.apache.wicket.markup.html.IHeaderContributor#renderHead(IHeaderResponse)\n\t\t */\n\t\t@Override\n\t\tpublic final void renderHead(final IHeaderResponse headResponse)\n\t\t{\n\t\t\tResponse response = headResponse.getResponse();\n\t\t\tfinal WebRequestCycle cycle = (WebRequestCycle)RequestCycle.get();\n\t\t\tfinal IRequestTarget target = cycle.getRequestTarget();\n\n\t\t\t// we don't want to render this for stateless pages\n\t\t\tif (webPage.isPageStateless())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tIPageMap pageMap = webPage.getPageMap();\n\t\t\tString name = pageMap.getName();\n\t\t\tif (name == null)\n\t\t\t{\n\t\t\t\tname = \"wicket:default\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tname = name.replace('\"', '_');\n\t\t\t}\n\n\t\t\tSession session = Session.get();\n\n\t\t\tSession.PageMapAccessMetaData meta = session.getMetaData(Session.PAGEMAP_ACCESS_MDK);\n\t\t\tif (meta == null)\n\t\t\t{\n\t\t\t\tmeta = new Session.PageMapAccessMetaData();\n\t\t\t\tsession.setMetaData(Session.PAGEMAP_ACCESS_MDK, meta);\n\t\t\t}\n\t\t\tboolean firstAccess = meta.add(pageMap);\n\n\t\t\tif (firstAccess)\n\t\t\t{\n\t\t\t\t// this is the first access to the pagemap, set window.name\n\t\t\t\tJavascriptUtils.writeOpenTag(response);\n\t\t\t\tresponse.write(\"if (window.name=='' || window.name.indexOf('wicket') > -1) { window.name=\\\"\");\n\t\t\t\tresponse.write(\"wicket-\" + name);\n\t\t\t\tresponse.write(\"\\\"; }\");\n\t\t\t\tJavascriptUtils.writeCloseTag(response);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Here is our trickery to detect whether the current request\n\t\t\t\t// was made in a new window/ tab, in which case it should go in\n\t\t\t\t// a different page map so that we don't intermingle the history\n\t\t\t\t// of those windows\n\t\t\t\tCharSequence url = null;\n\t\t\t\tif (target instanceof IBookmarkablePageRequestTarget)\n\t\t\t\t{\n\t\t\t\t\tIBookmarkablePageRequestTarget current = (IBookmarkablePageRequestTarget)target;\n\t\t\t\t\tBookmarkablePageRequestTarget redirect = new BookmarkablePageRequestTarget(\n\t\t\t\t\t\tsession.createAutoPageMapName(), current.getPageClass(),\n\t\t\t\t\t\tcurrent.getPageParameters());\n\t\t\t\t\turl = cycle.urlFor(redirect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\turl = webPage.urlFor(INewBrowserWindowListener.INTERFACE);\n\t\t\t\t}\n\t\t\t\tJavascriptUtils.writeOpenTag(response);\n\t\t\t\tresponse.write(\"if (window.name=='' || (window.name.indexOf('wicket') > -1 && window.name!='\" +\n\t\t\t\t\t\"wicket-\" + name + \"')) { window.location=\\\"\");\n\t\t\t\tresponse.write(url);\n\t\t\t\tresponse.write(\"\\\" + (window.location.hash != null ? window.location.hash : \\\"\\\"); }\");\n\t\t\t\tJavascriptUtils.writeCloseTag(response);\n\t\t\t}\n\t\t}","commit_id":"ce27149904e0969dbcbd665421c0c26da1437076","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tprotected void onAfterRender()\n\t{\n\t\tsuper.onAfterRender();\n\t\tif (getApplication().getConfigurationType() == Application.DEVELOPMENT)\n\t\t{\n\t\t\tHtmlHeaderContainer header = (HtmlHeaderContainer)visitChildren(new IVisitor<Component< ? >>()\n\t\t\t{\n\t\t\t\tpublic Object component(Component< ? > component)\n\t\t\t\t{\n\t\t\t\t\tif (component instanceof HtmlHeaderContainer)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn component;\n\t\t\t\t\t}\n\t\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (header == null)\n\t\t\t{\n\t\t\t\t// the markup must at least contain a <body> tag for wicket to automatically\n\t\t\t\t// create a HtmlHeaderContainer. Log an error if no header container\n\t\t\t\t// was created but any of the components or behavior want to contribute\n\t\t\t\t// something to the header.\n\t\t\t\theader = new HtmlHeaderContainer(HtmlHeaderSectionHandler.HEADER_ID);\n\t\t\t\tadd(header);\n\n\t\t\t\tResponse orgResponse = getRequestCycle().getResponse();\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tfinal StringResponse response = new StringResponse();\n\t\t\t\t\tgetRequestCycle().setResponse(response);\n\n\t\t\t\t\t// Render all header sections of all components on the page\n\t\t\t\t\trenderHead(header);\n\n\t\t\t\t\t// Make sure all Components interested in contributing to the header\n\t\t\t\t\t// and there attached behaviors are asked.\n\t\t\t\t\tfinal HtmlHeaderContainer finalHeader = header;\n\t\t\t\t\tvisitChildren(new IVisitor<Component< ? >>()\n\t\t\t\t\t{\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @see org.apache.wicket.Component.IVisitor#component(org.apache.wicket.Component)\n\t\t\t\t\t\t */\n\t\t\t\t\t\tpublic Object component(Component< ? > component)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcomponent.renderHead(finalHeader);\n\t\t\t\t\t\t\treturn CONTINUE_TRAVERSAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tresponse.close();\n\n\t\t\t\t\tif (response.getBuffer().length() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// @TODO it is not yet working properly. JDo to fix it\n\t\t\t\t\t\tlog.error(\"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\");\n\t\t\t\t\t\tlog.error(\"You probably forgot to add a <body> or <header> tag to your markup since no Header Container was \\n\" +\n\t\t\t\t\t\t\t\"found but components where found which want to write to the <head> section.\\n\" +\n\t\t\t\t\t\t\tresponse.getBuffer());\n\t\t\t\t\t\tlog.error(\"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\t// just swallow this exception, there isn't much we can do about.\n\t\t\t\t\tlog.error(\"header/body check throws exception\", e);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tthis.remove(header);\n\t\t\t\t\tgetRequestCycle().setResponse(orgResponse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":25520,"modified_method":"@Override\n\tprotected void onAfterRender()\n\t{\n\t\tsuper.onAfterRender();\n\t\tif (Application.DEVELOPMENT.equals(getApplication().getConfigurationType()))\n\t\t{\n\t\t\tHtmlHeaderContainer header = (HtmlHeaderContainer)visitChildren(new IVisitor<Component<?>>()\n\t\t\t{\n\t\t\t\tpublic Object component(Component<?> component)\n\t\t\t\t{\n\t\t\t\t\tif (component instanceof HtmlHeaderContainer)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn component;\n\t\t\t\t\t}\n\t\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (header == null)\n\t\t\t{\n\t\t\t\t// the markup must at least contain a <body> tag for wicket to automatically\n\t\t\t\t// create a HtmlHeaderContainer. Log an error if no header container\n\t\t\t\t// was created but any of the components or behavior want to contribute\n\t\t\t\t// something to the header.\n\t\t\t\theader = new HtmlHeaderContainer(HtmlHeaderSectionHandler.HEADER_ID);\n\t\t\t\tadd(header);\n\n\t\t\t\tResponse orgResponse = getRequestCycle().getResponse();\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tfinal StringResponse response = new StringResponse();\n\t\t\t\t\tgetRequestCycle().setResponse(response);\n\n\t\t\t\t\t// Render all header sections of all components on the page\n\t\t\t\t\trenderHead(header);\n\n\t\t\t\t\t// Make sure all Components interested in contributing to the header\n\t\t\t\t\t// and there attached behaviors are asked.\n\t\t\t\t\tfinal HtmlHeaderContainer finalHeader = header;\n\t\t\t\t\tvisitChildren(new IVisitor<Component<?>>()\n\t\t\t\t\t{\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @see org.apache.wicket.Component.IVisitor#component(org.apache.wicket.Component)\n\t\t\t\t\t\t */\n\t\t\t\t\t\tpublic Object component(Component<?> component)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcomponent.renderHead(finalHeader);\n\t\t\t\t\t\t\treturn CONTINUE_TRAVERSAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tresponse.close();\n\n\t\t\t\t\tif (response.getBuffer().length() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// @TODO it is not yet working properly. JDo to fix it\n\t\t\t\t\t\tlog.error(\"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\");\n\t\t\t\t\t\tlog.error(\"You probably forgot to add a <body> or <header> tag to your markup since no Header Container was \\n\" +\n\t\t\t\t\t\t\t\"found but components where found which want to write to the <head> section.\\n\" +\n\t\t\t\t\t\t\tresponse.getBuffer());\n\t\t\t\t\t\tlog.error(\"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\t// just swallow this exception, there isn't much we can do about.\n\t\t\t\t\tlog.error(\"header/body check throws exception\", e);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tthis.remove(header);\n\t\t\t\t\tgetRequestCycle().setResponse(orgResponse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"ce27149904e0969dbcbd665421c0c26da1437076","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Creates a new Wicket GuiceComponentInjector instance, using the provided Guice\n\t * {@link Injector} instance.\n\t * \n\t * @param app\n\t * @param injector\n\t */\n\tpublic GuiceComponentInjector(Application app, Injector injector)\n\t{\n\t\tapp.setMetaData(GuiceInjectorHolder.INJECTOR_KEY, new GuiceInjectorHolder(injector));\n\t\tapp.setMetaData(GuiceTypeStore.TYPESTORE_KEY, new GuiceTypeStore());\n\t}","id":25521,"modified_method":"/**\n\t * Creates a new Wicket GuiceComponentInjector instance, using the provided Guice\n\t * {@link Injector} instance.\n\t * \n\t * @param app\n\t * @param injector\n\t */\n\tpublic GuiceComponentInjector(Application app, Injector injector)\n\t{\n\t\tapp.setMetaData(GuiceInjectorHolder.INJECTOR_KEY, new GuiceInjectorHolder(injector));\n\t}","commit_id":"a64eef6795b264b4f1bfddbf541eceded0f941a1","url":"https://github.com/apache/wicket"},{"original_method":"public void inject(Object object)\n\t{\n\t\tClass< ? > current = object.getClass();\n\t\tdo\n\t\t{\n\t\t\tField[] currentFields = current.getDeclaredFields();\n\t\t\tfor (final Field field : currentFields)\n\t\t\t{\n\t\t\t\tif (!Modifier.isStatic(field.getModifiers()) &&\n\t\t\t\t\t\tfield.getAnnotation(Inject.class) != null)\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tAnnotation bindingAnnotation = findBindingAnnotation(field.getAnnotations());\n\t\t\t\t\t\tObject proxy = LazyInitProxyFactory.createProxy(field.getType(),\n\t\t\t\t\t\t\t\tnew GuiceProxyTargetLocator(field.getGenericType(),\n\t\t\t\t\t\t\t\t\t\tbindingAnnotation));\n\n\t\t\t\t\t\tif (!field.isAccessible())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield.setAccessible(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfield.set(object, proxy);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalAccessException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(\"Error Guice-injecting field \" +\n\t\t\t\t\t\t\t\tfield.getName() + \" in \" + object, e);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (MoreThanOneBindingException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\"Can't have more than one BindingAnnotation on field \" +\n\t\t\t\t\t\t\t\t\t\tfield.getName() + \" of class \" +\n\t\t\t\t\t\t\t\t\t\tobject.getClass().getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] currentMethods = current.getDeclaredMethods();\n\t\t\tfor (final Method method : currentMethods)\n\t\t\t{\n\t\t\t\tif (!Modifier.isStatic(method.getModifiers()) &&\n\t\t\t\t\t\tmethod.getAnnotation(Inject.class) != null)\n\t\t\t\t{\n\t\t\t\t\tAnnotation[][] paramAnnotations = method.getParameterAnnotations();\n\t\t\t\t\tClass< ? >[] paramTypes = method.getParameterTypes();\n\t\t\t\t\tType[] genericParamTypes = method.getGenericParameterTypes();\n\t\t\t\t\tObject[] args = new Object[paramTypes.length];\n\t\t\t\t\tfor (int i = 0; i < paramTypes.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tType paramType;\n\t\t\t\t\t\tif (genericParamTypes[i] instanceof ParameterizedType)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparamType = ((ParameterizedType)genericParamTypes[i]).getRawType();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparamType = paramTypes[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAnnotation bindingAnnotation = findBindingAnnotation(paramAnnotations[i]);\n\t\t\t\t\t\t\targs[i] = LazyInitProxyFactory.createProxy(paramTypes[i],\n\t\t\t\t\t\t\t\t\tnew GuiceProxyTargetLocator(genericParamTypes[i],\n\t\t\t\t\t\t\t\t\t\t\tbindingAnnotation));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (MoreThanOneBindingException e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\"Can't have more than one BindingAnnotation on parameter \" + i +\n\t\t\t\t\t\t\t\t\t\t\t\"(\" + paramType + \") of method \" + method.getName() +\n\t\t\t\t\t\t\t\t\t\t\t\" of class \" + object.getClass().getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tmethod.invoke(object, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalAccessException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.getSuperclass();\n\t\t}\n\t\t// Do a null check in case Object isn't in the current classloader.\n\t\twhile (current != null && current != Object.class);\n\t}","id":25522,"modified_method":"public void inject(Object object)\n\t{\n\t\tClass< ? > current = object.getClass();\n\t\tdo\n\t\t{\n\t\t\tField[] currentFields = current.getDeclaredFields();\n\t\t\tfor (final Field field : currentFields)\n\t\t\t{\n\t\t\t\tif (!Modifier.isStatic(field.getModifiers()) &&\n\t\t\t\t\t\tfield.getAnnotation(Inject.class) != null)\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tAnnotation bindingAnnotation = findBindingAnnotation(field.getAnnotations());\n\t\t\t\t\t\tObject proxy = LazyInitProxyFactory.createProxy(field.getType(),\n\t\t\t\t\t\t\t\tnew GuiceProxyTargetLocator(field, bindingAnnotation));\n\n\t\t\t\t\t\tif (!field.isAccessible())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield.setAccessible(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfield.set(object, proxy);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalAccessException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(\"Error Guice-injecting field \" +\n\t\t\t\t\t\t\t\tfield.getName() + \" in \" + object, e);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (MoreThanOneBindingException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\"Can't have more than one BindingAnnotation on field \" +\n\t\t\t\t\t\t\t\t\t\tfield.getName() + \" of class \" +\n\t\t\t\t\t\t\t\t\t\tobject.getClass().getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] currentMethods = current.getDeclaredMethods();\n\t\t\tfor (final Method method : currentMethods)\n\t\t\t{\n\t\t\t\tif (!Modifier.isStatic(method.getModifiers()) &&\n\t\t\t\t\t\tmethod.getAnnotation(Inject.class) != null)\n\t\t\t\t{\n\t\t\t\t\tAnnotation[][] paramAnnotations = method.getParameterAnnotations();\n\t\t\t\t\tClass< ? >[] paramTypes = method.getParameterTypes();\n\t\t\t\t\tType[] genericParamTypes = method.getGenericParameterTypes();\n\t\t\t\t\tObject[] args = new Object[paramTypes.length];\n\t\t\t\t\tfor (int i = 0; i < paramTypes.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tType paramType;\n\t\t\t\t\t\tif (genericParamTypes[i] instanceof ParameterizedType)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparamType = ((ParameterizedType)genericParamTypes[i]).getRawType();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparamType = paramTypes[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAnnotation bindingAnnotation = findBindingAnnotation(paramAnnotations[i]);\n\t\t\t\t\t\t\targs[i] = LazyInitProxyFactory.createProxy(paramTypes[i],\n\t\t\t\t\t\t\t\t\tnew GuiceProxyTargetLocator(method, i, bindingAnnotation));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (MoreThanOneBindingException e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\"Can't have more than one BindingAnnotation on parameter \" + i +\n\t\t\t\t\t\t\t\t\t\t\t\"(\" + paramType + \") of method \" + method.getName() +\n\t\t\t\t\t\t\t\t\t\t\t\" of class \" + object.getClass().getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tmethod.invoke(object, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalAccessException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.getSuperclass();\n\t\t}\n\t\t// Do a null check in case Object isn't in the current classloader.\n\t\twhile (current != null && current != Object.class);\n\t}","commit_id":"a64eef6795b264b4f1bfddbf541eceded0f941a1","url":"https://github.com/apache/wicket"},{"original_method":"public Object locateProxyTarget()\n\t{\n\t\tfinal GuiceInjectorHolder holder = (GuiceInjectorHolder)Application.get().getMetaData(\n\t\t\t\tGuiceInjectorHolder.INJECTOR_KEY);\n\n\t\tfinal GuiceTypeStore typeStore = (GuiceTypeStore)Application.get().getMetaData(\n\t\t\t\tGuiceTypeStore.TYPESTORE_KEY);\n\t\tfinal Type type = typeStore.getType(typeName);\n\n\t\t// using TypeLiteral to retrieve the key gives us automatic support for\n\t\t// Providers and other injectable TypeLiterals\n\t\tfinal Key< ? > key;\n\n\t\tif (bindingAnnotation == null)\n\t\t{\n\t\t\tkey = Key.get(TypeLiteral.get(type));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tkey = Key.get(TypeLiteral.get(type), bindingAnnotation);\n\t\t}\n\t\treturn holder.getInjector().getInstance(key);\n\t}","id":25523,"modified_method":"public Object locateProxyTarget()\n\t{\n\t\tfinal GuiceInjectorHolder holder = Application.get().getMetaData(\n\t\t\t\tGuiceInjectorHolder.INJECTOR_KEY);\n\n\t\tfinal Type type;\n\t\ttry\n\t\t{\n\n\t\t\tClass< ? > clazz = Class.forName(data[0]);\n\t\t\tif (argIndex < 0)\n\t\t\t{\n\t\t\t\tfinal Field field = clazz.getDeclaredField(data[1]);\n\t\t\t\ttype = field.getGenericType();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tClass< ? >[] paramTypes = new Class[data.length - 2];\n\t\t\t\tfor (int i = 2; i < data.length; i++)\n\t\t\t\t{\n\t\t\t\t\tparamTypes[2 - i] = Class.forName(data[i]);\n\t\t\t\t}\n\t\t\t\tfinal Method method = clazz.getDeclaredMethod(data[1], paramTypes);\n\t\t\t\ttype = method.getGenericParameterTypes()[argIndex];\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"Error accessing member: \" + data[1] + \" of class: \" +\n\t\t\t\t\tdata[0], e);\n\t\t}\n\n\t\t// using TypeLiteral to retrieve the key gives us automatic support for\n\t\t// Providers and other injectable TypeLiterals\n\t\tfinal Key< ? > key;\n\n\t\tif (bindingAnnotation == null)\n\t\t{\n\t\t\tkey = Key.get(TypeLiteral.get(type));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tkey = Key.get(TypeLiteral.get(type), bindingAnnotation);\n\t\t}\n\t\treturn holder.getInjector().getInstance(key);\n\t}","commit_id":"a64eef6795b264b4f1bfddbf541eceded0f941a1","url":"https://github.com/apache/wicket"},{"original_method":"GuiceProxyTargetLocator(Type type, Annotation bindingAnnotation)\n\t{\n\t\t// I'm not too happy about\n\t\ttypeName = type.toString();\n\t\tthis.bindingAnnotation = bindingAnnotation;\n\n\t\tGuiceTypeStore typeStore = (GuiceTypeStore)Application.get().getMetaData(\n\t\t\t\tGuiceTypeStore.TYPESTORE_KEY);\n\t\ttypeStore.setType(typeName, type);\n\t}","id":25524,"modified_method":"GuiceProxyTargetLocator(Field field, Annotation bindingAnnotation)\n\t{\n\t\tthis.bindingAnnotation = bindingAnnotation;\n\t\tdata = new String[2];\n\t\tdata[0] = field.getDeclaringClass().getName();\n\t\tdata[1] = field.getName();\n\t\targIndex = -1;\n\t}","commit_id":"a64eef6795b264b4f1bfddbf541eceded0f941a1","url":"https://github.com/apache/wicket"},{"original_method":"/**\r\n\t * @see org.apache.wicket.guice.GuiceComponentInjector#inject(java.lang.Object)\r\n\t */\r\n\t@Override\r\n\tpublic void inject(final Object object)\r\n\t{\r\n\t\tClass< ? > current = object.getClass();\r\n\t\tBoolean doInject = classToDoInject.get(current);\r\n\t\tif (doInject != null && !doInject.booleanValue())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tboolean actualDoInject = false;\r\n\r\n\t\tdo\r\n\t\t{\r\n\t\t\tField[] currentFields = current.getDeclaredFields();\r\n\t\t\tfor (final Field field : currentFields)\r\n\t\t\t{\r\n\t\t\t\tif (field.getAnnotation(Inject.class) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tactualDoInject = true;\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tAnnotation bindingAnnotation = findBindingAnnotation(field.getAnnotations());\r\n\t\t\t\t\t\tObject proxy = LazyInitProxyFactory.createProxy(field.getType(),\r\n\t\t\t\t\t\t\t\tnew GuiceProxyTargetLocator(field.getGenericType(),\r\n\t\t\t\t\t\t\t\t\t\tbindingAnnotation));\r\n\t\t\t\t\t\tif (!field.isAccessible())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tfield.setAccessible(true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfield.set(object, proxy);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (IllegalAccessException e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new WicketRuntimeException(\"Error Guice-injecting field \" +\r\n\t\t\t\t\t\t\t\tfield.getName() + \" in \" + object, e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (MoreThanOneBindingException e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new RuntimeException(\r\n\t\t\t\t\t\t\t\t\"Can't have more than one BindingAnnotation on field \" +\r\n\t\t\t\t\t\t\t\t\t\tfield.getName() + \" of class \" +\r\n\t\t\t\t\t\t\t\t\t\tobject.getClass().getName());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tMethod[] currentMethods = current.getDeclaredMethods();\r\n\t\t\tfor (final Method method : currentMethods)\r\n\t\t\t{\r\n\t\t\t\tif (method.getAnnotation(Inject.class) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tactualDoInject = true;\r\n\t\t\t\t\tAnnotation[][] paramAnnotations = method.getParameterAnnotations();\r\n\t\t\t\t\tClass< ? >[] paramTypes = method.getParameterTypes();\r\n\t\t\t\t\tType[] genericParamTypes = method.getGenericParameterTypes();\r\n\t\t\t\t\tObject[] args = new Object[paramTypes.length];\r\n\t\t\t\t\tfor (int i = 0; i < paramTypes.length; i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tType paramType;\r\n\t\t\t\t\t\tif (genericParamTypes[i] instanceof ParameterizedType)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tparamType = ((ParameterizedType)genericParamTypes[i]).getRawType();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tparamType = paramTypes[i];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tAnnotation bindingAnnotation = findBindingAnnotation(paramAnnotations[i]);\r\n\t\t\t\t\t\t\targs[i] = LazyInitProxyFactory.createProxy(paramTypes[i],\r\n\t\t\t\t\t\t\t\t\tnew GuiceProxyTargetLocator(genericParamTypes[i],\r\n\t\t\t\t\t\t\t\t\t\t\tbindingAnnotation));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch (MoreThanOneBindingException e)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthrow new RuntimeException(\r\n\t\t\t\t\t\t\t\t\t\"Can't have more than one BindingAnnotation on parameter \" + i +\r\n\t\t\t\t\t\t\t\t\t\t\t\"(\" + paramType + \") of method \" + method.getName() +\r\n\t\t\t\t\t\t\t\t\t\t\t\" of class \" + object.getClass().getName());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmethod.invoke(object, args);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (IllegalAccessException e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new WicketRuntimeException(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (InvocationTargetException e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new WicketRuntimeException(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcurrent = current.getSuperclass();\r\n\t\t}\r\n\r\n\t\t// Do a null check in case Object isn't in the current classloader.\r\n\t\twhile (current != null && current != Object.class);\r\n\t\tif (doInject == null)\r\n\t\t{\r\n\t\t\tclassToDoInject.put(object.getClass(), new Boolean(actualDoInject));\r\n\t\t}\r\n\t}","id":25525,"modified_method":"/**\r\n\t * @see org.apache.wicket.guice.GuiceComponentInjector#inject(java.lang.Object)\r\n\t */\r\n\t@Override\r\n\tpublic void inject(final Object object)\r\n\t{\r\n\t\tClass< ? > current = object.getClass();\r\n\t\tBoolean doInject = classToDoInject.get(current);\r\n\t\tif (doInject != null && !doInject.booleanValue())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tboolean actualDoInject = false;\r\n\r\n\t\tdo\r\n\t\t{\r\n\t\t\tField[] currentFields = current.getDeclaredFields();\r\n\t\t\tfor (final Field field : currentFields)\r\n\t\t\t{\r\n\t\t\t\tif (field.getAnnotation(Inject.class) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tactualDoInject = true;\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tAnnotation bindingAnnotation = findBindingAnnotation(field.getAnnotations());\r\n\t\t\t\t\t\tObject proxy = LazyInitProxyFactory.createProxy(field.getType(),\r\n\t\t\t\t\t\t\t\tnew GuiceProxyTargetLocator(field, bindingAnnotation));\r\n\t\t\t\t\t\tif (!field.isAccessible())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tfield.setAccessible(true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfield.set(object, proxy);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (IllegalAccessException e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new WicketRuntimeException(\"Error Guice-injecting field \" +\r\n\t\t\t\t\t\t\t\tfield.getName() + \" in \" + object, e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (MoreThanOneBindingException e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new RuntimeException(\r\n\t\t\t\t\t\t\t\t\"Can't have more than one BindingAnnotation on field \" +\r\n\t\t\t\t\t\t\t\t\t\tfield.getName() + \" of class \" +\r\n\t\t\t\t\t\t\t\t\t\tobject.getClass().getName());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tMethod[] currentMethods = current.getDeclaredMethods();\r\n\t\t\tfor (final Method method : currentMethods)\r\n\t\t\t{\r\n\t\t\t\tif (method.getAnnotation(Inject.class) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tactualDoInject = true;\r\n\t\t\t\t\tAnnotation[][] paramAnnotations = method.getParameterAnnotations();\r\n\t\t\t\t\tClass< ? >[] paramTypes = method.getParameterTypes();\r\n\t\t\t\t\tType[] genericParamTypes = method.getGenericParameterTypes();\r\n\t\t\t\t\tObject[] args = new Object[paramTypes.length];\r\n\t\t\t\t\tfor (int i = 0; i < paramTypes.length; i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tType paramType;\r\n\t\t\t\t\t\tif (genericParamTypes[i] instanceof ParameterizedType)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tparamType = ((ParameterizedType)genericParamTypes[i]).getRawType();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tparamType = paramTypes[i];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tAnnotation bindingAnnotation = findBindingAnnotation(paramAnnotations[i]);\r\n\t\t\t\t\t\t\targs[i] = LazyInitProxyFactory.createProxy(paramTypes[i],\r\n\t\t\t\t\t\t\t\t\tnew GuiceProxyTargetLocator(method, i, bindingAnnotation));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch (MoreThanOneBindingException e)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthrow new RuntimeException(\r\n\t\t\t\t\t\t\t\t\t\"Can't have more than one BindingAnnotation on parameter \" + i +\r\n\t\t\t\t\t\t\t\t\t\t\t\"(\" + paramType + \") of method \" + method.getName() +\r\n\t\t\t\t\t\t\t\t\t\t\t\" of class \" + object.getClass().getName());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmethod.invoke(object, args);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (IllegalAccessException e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new WicketRuntimeException(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (InvocationTargetException e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new WicketRuntimeException(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcurrent = current.getSuperclass();\r\n\t\t}\r\n\r\n\t\t// Do a null check in case Object isn't in the current classloader.\r\n\t\twhile (current != null && current != Object.class);\r\n\t\tif (doInject == null)\r\n\t\t{\r\n\t\t\tclassToDoInject.put(object.getClass(), new Boolean(actualDoInject));\r\n\t\t}\r\n\t}","commit_id":"a64eef6795b264b4f1bfddbf541eceded0f941a1","url":"https://github.com/apache/wicket"},{"original_method":"public void testFailsIfBeanWithIdIsNotFound() throws Exception\n\t{\n\t\tInjectableWithReferenceToNonexistingBean obj = new InjectableWithReferenceToNonexistingBean();\n\t\tField field = obj.getClass().getDeclaredField(\"nonExisting\");\n\t\ttry\n\t\t{\n\t\t\tfactory.getFieldValue(field, obj);\n\t\t\tfail();\n\t\t}\n\t\tcatch (RuntimeException e)\n\t\t{\n\t\t}\n\t}","id":25526,"modified_method":"/**\n\t * @throws Exception\n\t */\n\tpublic void testFailsIfBeanWithIdIsNotFound() throws Exception\n\t{\n\t\tInjectableWithReferenceToNonexistingBean obj = new InjectableWithReferenceToNonexistingBean();\n\t\tField field = obj.getClass().getDeclaredField(\"nonExisting\");\n\t\ttry\n\t\t{\n\t\t\tfactory.getFieldValue(field, obj);\n\t\t\tfail();\n\t\t}\n\t\tcatch (RuntimeException e)\n\t\t{\n\t\t}\n\t}","commit_id":"23d6a317a856fdc214919dbc8715ea2a6131d054","url":"https://github.com/apache/wicket"},{"original_method":"public Bean getBeanByClass()\n\t{\n\t\treturn beanByClass;\n\t}","id":25527,"modified_method":"/**\n\t * @return test bean\n\t */\n\tpublic Bean getBeanByClass()\n\t{\n\t\treturn beanByClass;\n\t}","commit_id":"23d6a317a856fdc214919dbc8715ea2a6131d054","url":"https://github.com/apache/wicket"},{"original_method":"public Bean2 getBeanByName()\n\t{\n\t\treturn beanByName;\n\t}","id":25528,"modified_method":"/**\n\t * @return test bean\n\t */\n\tpublic Bean2 getBeanByName()\n\t{\n\t\treturn beanByName;\n\t}","commit_id":"23d6a317a856fdc214919dbc8715ea2a6131d054","url":"https://github.com/apache/wicket"},{"original_method":"public Bean getNobean()\n\t{\n\t\treturn nobean;\n\t}","id":25529,"modified_method":"/**\n\t * @return test bean\n\t */\n\tpublic Bean getNobean()\n\t{\n\t\treturn nobean;\n\t}","commit_id":"23d6a317a856fdc214919dbc8715ea2a6131d054","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param beanType\n\t *            bean class\n\t * @param locator\n\t *            spring context locator\n\t */\n\tpublic SpringBeanLocator(Class beanType, ISpringContextLocator locator)\n\t{\n\t\tthis(null, beanType, locator);\n\t}","id":25530,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param beanType\n\t *            bean class\n\t * @param locator\n\t *            spring context locator\n\t */\n\tpublic SpringBeanLocator(Class< ? > beanType, ISpringContextLocator locator)\n\t{\n\t\tthis(null, beanType, locator);\n\t}","commit_id":"23d6a317a856fdc214919dbc8715ea2a6131d054","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns the name of the Bean as registered to Spring. Throws IllegalState exception if none\n\t * or more then one beans are found.\n\t * \n\t * @param ctx\n\t *            spring application context\n\t * @param clazz\n\t *            bean class\n\t * @throws IllegalStateException\n\t * @return spring name of the bean\n\t */\n\tprivate final String getBeanNameOfClass(ApplicationContext ctx, Class clazz)\n\t{\n\t\tString[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(ctx, clazz);\n\t\tif (names.length == 0)\n\t\t{\n\t\t\tthrow new IllegalStateException(\"bean of type [\" + clazz.getName() + \"] not found\");\n\t\t}\n\t\tif (names.length > 1)\n\t\t{\n\t\t\tStringBuffer msg = new StringBuffer();\n\t\t\tmsg.append(\"more then one bean of type [\");\n\t\t\tmsg.append(clazz.getName());\n\t\t\tmsg.append(\"] found, you have to specify the name of the bean \");\n\t\t\tmsg.append(\"(@SpringBean(name=\\\"foo\\\")) in order to resolve this conflict. \");\n\n\t\t\tmsg.append(\"Matched beans: \");\n\t\t\tmsg.append(Strings.join(\",\", names));\n\n\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t}\n\t\treturn names[0];\n\t}","id":25531,"modified_method":"/**\n\t * Returns the name of the Bean as registered to Spring. Throws IllegalState exception if none\n\t * or more then one beans are found.\n\t * \n\t * @param ctx\n\t *            spring application context\n\t * @param clazz\n\t *            bean class\n\t * @throws IllegalStateException\n\t * @return spring name of the bean\n\t */\n\tprivate final String getBeanNameOfClass(ApplicationContext ctx, Class< ? > clazz)\n\t{\n\t\tString[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(ctx, clazz);\n\t\tif (names.length == 0)\n\t\t{\n\t\t\tthrow new IllegalStateException(\"bean of type [\" + clazz.getName() + \"] not found\");\n\t\t}\n\t\tif (names.length > 1)\n\t\t{\n\t\t\tStringBuffer msg = new StringBuffer();\n\t\t\tmsg.append(\"more then one bean of type [\");\n\t\t\tmsg.append(clazz.getName());\n\t\t\tmsg.append(\"] found, you have to specify the name of the bean \");\n\t\t\tmsg.append(\"(@SpringBean(name=\\\"foo\\\")) in order to resolve this conflict. \");\n\n\t\t\tmsg.append(\"Matched beans: \");\n\t\t\tmsg.append(Strings.join(\",\", names));\n\n\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t}\n\t\treturn names[0];\n\t}","commit_id":"23d6a317a856fdc214919dbc8715ea2a6131d054","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param beanName\n\t *            bean name\n\t * @param beanType\n\t *            bean class\n\t * @param locator\n\t *            spring context locator\n\t */\n\tpublic SpringBeanLocator(String beanName, Class beanType, ISpringContextLocator locator)\n\t{\n\t\tif (locator == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"[locator] argument cannot be null\");\n\t\t}\n\t\tif (beanType == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"[beanType] argument cannot be null\");\n\t\t}\n\n\t\tthis.beanTypeCache = new WeakReference(beanType);\n\t\tthis.beanTypeName = beanType.getName();\n\t\tthis.springContextLocator = locator;\n\t\tthis.beanName = beanName;\n\t\tthis.springContextLocator = locator;\n\t}","id":25532,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param beanName\n\t *            bean name\n\t * @param beanType\n\t *            bean class\n\t * @param locator\n\t *            spring context locator\n\t */\n\tpublic SpringBeanLocator(String beanName, Class< ? > beanType, ISpringContextLocator locator)\n\t{\n\t\tif (locator == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"[locator] argument cannot be null\");\n\t\t}\n\t\tif (beanType == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"[beanType] argument cannot be null\");\n\t\t}\n\n\t\tbeanTypeCache = new WeakReference<Class< ? >>(beanType);\n\t\tbeanTypeName = beanType.getName();\n\t\tspringContextLocator = locator;\n\t\tthis.beanName = beanName;\n\t\tspringContextLocator = locator;\n\t}","commit_id":"23d6a317a856fdc214919dbc8715ea2a6131d054","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Looks up a bean by its name and class. Throws IllegalState exception if bean not found.\n\t * \n\t * @param ctx\n\t *            spring application context\n\t * \n\t * @param name\n\t *            bean name\n\t * @param clazz\n\t *            bean class\n\t * @throws IllegalStateException\n\t * @return found bean\n\t */\n\tprivate static Object lookupSpringBean(ApplicationContext ctx, String name, Class clazz)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn ctx.getBean(name, clazz);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException e)\n\t\t{\n\t\t\tthrow new IllegalStateException(\"bean with name [\" + name + \"] and class [\" +\n\t\t\t\t\tclazz.getName() + \"] not found\");\n\t\t}\n\t}","id":25533,"modified_method":"/**\n\t * Looks up a bean by its name and class. Throws IllegalState exception if bean not found.\n\t * \n\t * @param ctx\n\t *            spring application context\n\t * \n\t * @param name\n\t *            bean name\n\t * @param clazz\n\t *            bean class\n\t * @throws IllegalStateException\n\t * @return found bean\n\t */\n\tprivate static Object lookupSpringBean(ApplicationContext ctx, String name, Class< ? > clazz)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn ctx.getBean(name, clazz);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException e)\n\t\t{\n\t\t\tthrow new IllegalStateException(\"bean with name [\" + name + \"] and class [\" +\n\t\t\t\t\tclazz.getName() + \"] not found\");\n\t\t}\n\t}","commit_id":"23d6a317a856fdc214919dbc8715ea2a6131d054","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Looks up a bean by its class. Throws IllegalState exception if none or more then one beans\n\t * are found.\n\t * \n\t * @param ctx\n\t *            spring application context\n\t * \n\t * @param clazz\n\t *            bean class\n\t * @throws IllegalStateException\n\t * @return found bean\n\t */\n\tprivate final Object lookupSpringBean(ApplicationContext ctx, Class clazz)\n\t{\n\t\treturn lookupSpringBean(ctx, getBeanNameOfClass(ctx, clazz), clazz);\n\t}","id":25534,"modified_method":"/**\n\t * Looks up a bean by its class. Throws IllegalState exception if none or more then one beans\n\t * are found.\n\t * \n\t * @param ctx\n\t *            spring application context\n\t * \n\t * @param clazz\n\t *            bean class\n\t * @throws IllegalStateException\n\t * @return found bean\n\t */\n\tprivate final Object lookupSpringBean(ApplicationContext ctx, Class< ? > clazz)\n\t{\n\t\treturn lookupSpringBean(ctx, getBeanNameOfClass(ctx, clazz), clazz);\n\t}","commit_id":"23d6a317a856fdc214919dbc8715ea2a6131d054","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return bean class this locator is configured with\n\t */\n\tpublic Class getBeanType()\n\t{\n\t\tClass clazz = beanTypeCache == null ? null : (Class)beanTypeCache.get();\n\t\tif (clazz == null)\n\t\t{\n\t\t\tbeanTypeCache = new WeakReference(clazz = Classes.resolveClass(beanTypeName));\n\t\t\tif (clazz == null)\n\t\t\t{\n\t\t\t\tthrow new RuntimeException(\"SpringBeanLocator could not find class [\" +\n\t\t\t\t\t\tbeanTypeName + \"] needed to locate the [\" +\n\t\t\t\t\t\t((beanName != null) ? (beanName) : (\"bean name not specified\")) + \"] bean\");\n\t\t\t}\n\t\t}\n\t\treturn clazz;\n\t}","id":25535,"modified_method":"/**\n\t * @return bean class this locator is configured with\n\t */\n\tpublic Class< ? > getBeanType()\n\t{\n\t\tClass< ? > clazz = beanTypeCache == null ? null : (Class< ? >)beanTypeCache.get();\n\t\tif (clazz == null)\n\t\t{\n\t\t\tbeanTypeCache = new WeakReference<Class< ? >>(clazz = Classes\n\t\t\t\t\t.resolveClass(beanTypeName));\n\t\t\tif (clazz == null)\n\t\t\t{\n\t\t\t\tthrow new RuntimeException(\"SpringBeanLocator could not find class [\" +\n\t\t\t\t\t\tbeanTypeName + \"] needed to locate the [\" +\n\t\t\t\t\t\t((beanName != null) ? (beanName) : (\"bean name not specified\")) + \"] bean\");\n\t\t\t}\n\t\t}\n\t\treturn clazz;\n\t}","commit_id":"23d6a317a856fdc214919dbc8715ea2a6131d054","url":"https://github.com/apache/wicket"},{"original_method":"public ApplicationContext getSpringContext()\n\t\t{\n\t\t\tif (context == null)\n\t\t\t{\n\t\t\t\tcontext = ((ApplicationContextHolder)Application.get().getMetaData(CONTEXT_KEY))\n\t\t\t\t\t\t.getContext();\n\t\t\t}\n\t\t\treturn context;\n\t\t}","id":25536,"modified_method":"public ApplicationContext getSpringContext()\n\t\t{\n\t\t\tif (context == null)\n\t\t\t{\n\t\t\t\tcontext = (Application.get().getMetaData(CONTEXT_KEY)).getContext();\n\t\t\t}\n\t\t\treturn context;\n\t\t}","commit_id":"23d6a317a856fdc214919dbc8715ea2a6131d054","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Creates a proxy for a spring bean that is safe to put into session and serialize\n\t * \n\t * @param clazz\n\t *            class of spring bean\n\t * @return proxy representing the spring bean\n\t */\n\tprotected Object createSpringBeanProxy(Class clazz)\n\t{\n\t\treturn LazyInitProxyFactory.createProxy(clazz, new SpringBeanLocator(clazz,\n\t\t\t\tgetSpringContextLocator()));\n\t}","id":25537,"modified_method":"/**\n\t * Creates a proxy for a spring bean that is safe to put into session and serialize\n\t * \n\t * @param clazz\n\t *            class of spring bean\n\t * @return proxy representing the spring bean\n\t */\n\tprotected Object createSpringBeanProxy(Class< ? > clazz)\n\t{\n\t\treturn LazyInitProxyFactory.createProxy(clazz, new SpringBeanLocator(clazz,\n\t\t\t\tgetSpringContextLocator()));\n\t}","commit_id":"23d6a317a856fdc214919dbc8715ea2a6131d054","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Creates a proxy for a spring bean that is safe to put into session and serialize\n\t * \n\t * @param clazz\n\t *            class of spring bean\n\t * @param beanName\n\t *            name of spring bean\n\t * @return proxy representing the spring bean\n\t */\n\tprotected Object createSpringBeanProxy(Class clazz, String beanName)\n\t{\n\t\treturn LazyInitProxyFactory.createProxy(clazz, new SpringBeanLocator(beanName, clazz,\n\t\t\t\tgetSpringContextLocator()));\n\t}","id":25538,"modified_method":"/**\n\t * Creates a proxy for a spring bean that is safe to put into session and serialize\n\t * \n\t * @param clazz\n\t *            class of spring bean\n\t * @param beanName\n\t *            name of spring bean\n\t * @return proxy representing the spring bean\n\t */\n\tprotected Object createSpringBeanProxy(Class< ? > clazz, String beanName)\n\t{\n\t\treturn LazyInitProxyFactory.createProxy(clazz, new SpringBeanLocator(beanName, clazz,\n\t\t\t\tgetSpringContextLocator()));\n\t}","commit_id":"23d6a317a856fdc214919dbc8715ea2a6131d054","url":"https://github.com/apache/wicket"},{"original_method":"private WebApplication createApplication(ApplicationContext ac, String beanName)\n\t{\n\t\tif (beanName != null)\n\t\t{\n\t\t\tWebApplication application = (WebApplication)ac.getBean(beanName);\n\t\t\tif (application == null)\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Unable to find WebApplication bean with name [\" + beanName + \"]\");\n\t\t\t}\n\t\t\treturn application;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMap beans = BeanFactoryUtils.beansOfTypeIncludingAncestors(ac, WebApplication.class,\n\t\t\t\t\tfalse, false);\n\t\t\tif (beans.size() == 0)\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"bean of type [\" + WebApplication.class.getName() +\n\t\t\t\t\t\t\"] not found\");\n\t\t\t}\n\t\t\tif (beans.size() > 1)\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"more then one bean of type [\" +\n\t\t\t\t\t\tWebApplication.class.getName() + \"] found, must have only one\");\n\t\t\t}\n\t\t\treturn (WebApplication)beans.values().iterator().next();\n\t\t}\n\t}","id":25539,"modified_method":"private WebApplication createApplication(ApplicationContext ac, String beanName)\n\t{\n\t\tif (beanName != null)\n\t\t{\n\t\t\tWebApplication application = (WebApplication)ac.getBean(beanName);\n\t\t\tif (application == null)\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Unable to find WebApplication bean with name [\" + beanName + \"]\");\n\t\t\t}\n\t\t\treturn application;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMap< ? , ? > beans = BeanFactoryUtils.beansOfTypeIncludingAncestors(ac,\n\t\t\t\t\tWebApplication.class, false, false);\n\t\t\tif (beans.size() == 0)\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"bean of type [\" + WebApplication.class.getName() +\n\t\t\t\t\t\t\"] not found\");\n\t\t\t}\n\t\t\tif (beans.size() > 1)\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"more then one bean of type [\" +\n\t\t\t\t\t\tWebApplication.class.getName() + \"] found, must have only one\");\n\t\t\t}\n\t\t\treturn (WebApplication)beans.values().iterator().next();\n\t\t}\n\t}","commit_id":"23d6a317a856fdc214919dbc8715ea2a6131d054","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t */\n\tpublic AutoCompletePage()\n\t{\n\t\tForm form = new Form(\"form\");\n\t\tadd(form);\n\n\t\tfinal AutoCompleteTextField field = new AutoCompleteTextField(\"ac\", new Model(\"\"))\n\t\t{\n\t\t\tprotected Iterator getChoices(String input)\n\t\t\t{\n\t\t\t\tif (Strings.isEmpty(input))\n\t\t\t\t{\n\t\t\t\t\treturn Collections.EMPTY_LIST.iterator();\n\t\t\t\t}\n\n\t\t\t\tList choices = new ArrayList(10);\n\n\t\t\t\tLocale[] locales = Locale.getAvailableLocales();\n\n\t\t\t\tfor (int i = 0; i < locales.length; i++)\n\t\t\t\t{\n\t\t\t\t\tfinal Locale locale = locales[i];\n\t\t\t\t\tfinal String country = locale.getDisplayCountry();\n\n\t\t\t\t\tif (country.toUpperCase().startsWith(input.toUpperCase()))\n\t\t\t\t\t{\n\t\t\t\t\t\tchoices.add(country);\n\t\t\t\t\t\tif (choices.size() == 10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn choices.iterator();\n\t\t\t}\n\t\t};\n\t\tform.add(field);\n\n\t\tfinal Label label = new Label(\"selectedValue\", field.getModel());\n\t\tlabel.setOutputMarkupId(true);\n\t\tform.add(label);\n\n\t\tfield.add(new AjaxFormSubmitBehavior(form, \"onchange\")\n\t\t{\n\t\t\tprotected void onSubmit(AjaxRequestTarget target)\n\t\t\t{\n\t\t\t\ttarget.addComponent(label);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onError(AjaxRequestTarget target)\n\t\t\t{\n\t\t\t}\n\t\t});\n\t}","id":25540,"modified_method":"/**\n\t * Constructor\n\t */\n\tpublic AutoCompletePage()\n\t{\n\t\tForm form = new Form(\"form\");\n\t\tadd(form);\n\n\t\tfinal AutoCompleteTextField<String> field = new AutoCompleteTextField<String>(\"ac\",\n\t\t\tnew Model<String>(\"\"))\n\t\t{\n\t\t\t@Override\n\t\t\tprotected Iterator<String> getChoices(String input)\n\t\t\t{\n\t\t\t\tif (Strings.isEmpty(input))\n\t\t\t\t{\n\t\t\t\t\tList<String> emptyList = Collections.emptyList();\n\t\t\t\t\treturn emptyList.iterator();\n\t\t\t\t}\n\n\t\t\t\tList<String> choices = new ArrayList<String>(10);\n\n\t\t\t\tLocale[] locales = Locale.getAvailableLocales();\n\n\t\t\t\tfor (int i = 0; i < locales.length; i++)\n\t\t\t\t{\n\t\t\t\t\tfinal Locale locale = locales[i];\n\t\t\t\t\tfinal String country = locale.getDisplayCountry();\n\n\t\t\t\t\tif (country.toUpperCase().startsWith(input.toUpperCase()))\n\t\t\t\t\t{\n\t\t\t\t\t\tchoices.add(country);\n\t\t\t\t\t\tif (choices.size() == 10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn choices.iterator();\n\t\t\t}\n\t\t};\n\t\tform.add(field);\n\n\t\tfinal Label label = new Label(\"selectedValue\", field.getModel());\n\t\tlabel.setOutputMarkupId(true);\n\t\tform.add(label);\n\n\t\tfield.add(new AjaxFormSubmitBehavior(form, \"onchange\")\n\t\t{\n\t\t\t@Override\n\t\t\tprotected void onSubmit(AjaxRequestTarget target)\n\t\t\t{\n\t\t\t\ttarget.addComponent(label);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onError(AjaxRequestTarget target)\n\t\t\t{\n\t\t\t}\n\t\t});\n\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * @see org.apache.wicket.model.Model#getObject()\n\t\t */\n\t\tpublic Object getObject()\n\t\t{\n\t\t\treturn RequestCycle.get().urlFor(PageMap.forName(RIGHT_FRAME_NAME),\n\t\t\t\t\tframeTarget.getFrameClass(), null);\n\t\t}","id":25541,"modified_method":"/**\n\t\t * @see org.apache.wicket.model.Model#getObject()\n\t\t */\n\t\tpublic CharSequence getObject()\n\t\t{\n\t\t\treturn RequestCycle.get().urlFor(PageMap.forName(RIGHT_FRAME_NAME),\n\t\t\t\tframeTarget.getFrameClass(), null);\n\t\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * Construct.\n\t\t * \n\t\t * @param id\n\t\t *            component id\n\t\t */\n\t\tpublic LocaleDropDownChoice(String id)\n\t\t{\n\t\t\tsuper(id);\n\t\t\t// sort locales on strings of selected locale\n\t\t\tsetChoices(new AbstractReadOnlyModel()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic Object getObject()\n\t\t\t\t{\n\t\t\t\t\tgetSelectedLocale();\n\t\t\t\t\tList<Locale> locales = new ArrayList<Locale>(LOCALES);\n\t\t\t\t\tCollections.sort(locales, new Comparator<Locale>()\n\t\t\t\t\t{\n\t\t\t\t\t\tpublic int compare(Locale o1, Locale o2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn o1.getDisplayName(selectedLocale).compareTo(\n\t\t\t\t\t\t\t\to2.getDisplayName(selectedLocale));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn locales;\n\t\t\t\t}\n\t\t\t});\n\t\t\tsetChoiceRenderer(new LocaleChoiceRenderer());\n\t\t\tsetModel(new PropertyModel(DatesPage.this, \"selectedLocale\"));\n\t\t}","id":25542,"modified_method":"/**\n\t\t * Construct.\n\t\t * \n\t\t * @param id\n\t\t *            component id\n\t\t */\n\t\tpublic LocaleDropDownChoice(String id)\n\t\t{\n\t\t\tsuper(id);\n\t\t\t// sort locales on strings of selected locale\n\t\t\tsetChoices(new AbstractReadOnlyModel<List<Locale>>()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic List<Locale> getObject()\n\t\t\t\t{\n\t\t\t\t\tgetSelectedLocale();\n\t\t\t\t\tList<Locale> locales = new ArrayList<Locale>(LOCALES);\n\t\t\t\t\tCollections.sort(locales, new Comparator<Locale>()\n\t\t\t\t\t{\n\t\t\t\t\t\tpublic int compare(Locale o1, Locale o2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn o1.getDisplayName(selectedLocale).compareTo(\n\t\t\t\t\t\t\t\to2.getDisplayName(selectedLocale));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn locales;\n\t\t\t\t}\n\t\t\t});\n\t\t\tsetChoiceRenderer(new LocaleChoiceRenderer());\n\t\t\tsetModel(new PropertyModel<Locale>(DatesPage.this, \"selectedLocale\"));\n\t\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * @see org.apache.wicket.markup.html.form.IChoiceRenderer#getDisplayValue(Object)\n\t\t */\n\t\t@Override\n\t\tpublic Object getDisplayValue(Object object)\n\t\t{\n\t\t\tLocale locale = (Locale)object;\n\t\t\tString enName = locale.getDisplayName(LOCALE_EN);\n\t\t\tString localizedName = locale.getDisplayName(selectedLocale);\n\t\t\treturn localizedName + (!enName.equals(localizedName) ? (\" (\" + enName + \")\") : \"\");\n\t\t}","id":25543,"modified_method":"/**\n\t\t * @see org.apache.wicket.markup.html.form.IChoiceRenderer#getDisplayValue(Object)\n\t\t */\n\t\t@Override\n\t\tpublic Object getDisplayValue(Locale locale)\n\t\t{\n\t\t\tString enName = locale.getDisplayName(LOCALE_EN);\n\t\t\tString localizedName = locale.getDisplayName(selectedLocale);\n\t\t\treturn localizedName + (!enName.equals(localizedName) ? (\" (\" + enName + \")\") : \"\");\n\t\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Create the guess page.\n\t */\n\tpublic Guess()\n\t{\n\t\t// Components for displaying the guesses remaining & the hangman\n\t\tadd(new Label(\"guessesRemaining\", new PropertyModel(getGame(), \"guessesRemaining\")));\n\n\t\t// Components for displaying the current word\n\t\tadd(new Label(\"word\", new Model()\n\t\t{\n\t\t\tpublic Object getObject()\n\t\t\t{\n\t\t\t\treturn getGame().getWord().asString(true);\n\t\t\t}\n\t\t}));\n\n\t\t// Show the game's letters\n\t\tadd(new ListView(\"letters\", getGame().getLetters())\n\t\t{\n\t\t\tprotected void populateItem(final ListItem listItem)\n\t\t\t{\n\t\t\t\tfinal Letter letter = (Letter)listItem.getModelObject();\n\t\t\t\tfinal Link link = new Link(\"letter\")\n\t\t\t\t{\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onBeforeRender()\n\t\t\t\t\t{\n\t\t\t\t\t\tsuper.onBeforeRender();\n\t\t\t\t\t\t// Set enable state of link\n\t\t\t\t\t\tsetAutoEnable(false);\n\t\t\t\t\t\tsetEnabled(!letter.isGuessed());\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic void onClick()\n\t\t\t\t\t{\n\t\t\t\t\t\t// Guess the letter\n\t\t\t\t\t\tgetGame().guess(letter);\n\n\t\t\t\t\t\t// Is the game over?\n\t\t\t\t\t\tif (getGame().isWon())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Redirect to win page\n\t\t\t\t\t\t\tsetResponsePage(new Win());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (getGame().isLost())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Redirect to lose page\n\t\t\t\t\t\t\tsetResponsePage(new Lose());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Return to guess page with new state to display\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tlink.add(new Image(\"image\", letter.getSharedImageResource()));\n\t\t\t\tlistItem.add(link);\n\n\t\t\t\t// append id attribute to link for unit tests\n\t\t\t\tlink.add(new SimpleAttributeModifier(\"id\", \"letter_\" + letter.asString()));\n\n\n\t\t\t}\n\t\t});\n\t}","id":25544,"modified_method":"/**\n\t * Create the guess page.\n\t */\n\tpublic Guess()\n\t{\n\t\t// Components for displaying the guesses remaining & the hangman\n\t\tadd(new Label(\"guessesRemaining\", new PropertyModel(getGame(), \"guessesRemaining\")));\n\n\t\t// Components for displaying the current word\n\t\tadd(new Label(\"word\", new Model<String>()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic String getObject()\n\t\t\t{\n\t\t\t\treturn getGame().getWord().asString(true);\n\t\t\t}\n\t\t}));\n\n\t\t// Show the game's letters\n\t\tadd(new ListView(\"letters\", getGame().getLetters())\n\t\t{\n\t\t\t@Override\n\t\t\tprotected void populateItem(final ListItem listItem)\n\t\t\t{\n\t\t\t\tfinal Letter letter = (Letter)listItem.getModelObject();\n\t\t\t\tfinal Link link = new Link(\"letter\")\n\t\t\t\t{\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onBeforeRender()\n\t\t\t\t\t{\n\t\t\t\t\t\tsuper.onBeforeRender();\n\t\t\t\t\t\t// Set enable state of link\n\t\t\t\t\t\tsetAutoEnable(false);\n\t\t\t\t\t\tsetEnabled(!letter.isGuessed());\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick()\n\t\t\t\t\t{\n\t\t\t\t\t\t// Guess the letter\n\t\t\t\t\t\tgetGame().guess(letter);\n\n\t\t\t\t\t\t// Is the game over?\n\t\t\t\t\t\tif (getGame().isWon())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Redirect to win page\n\t\t\t\t\t\t\tsetResponsePage(new Win());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (getGame().isLost())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Redirect to lose page\n\t\t\t\t\t\t\tsetResponsePage(new Lose());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Return to guess page with new state to display\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tlink.add(new Image(\"image\", letter.getSharedImageResource()));\n\t\t\t\tlistItem.add(link);\n\n\t\t\t\t// append id attribute to link for unit tests\n\t\t\t\tlink.add(new SimpleAttributeModifier(\"id\", \"letter_\" + letter.asString()));\n\n\n\t\t\t}\n\t\t});\n\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t */\n\tpublic LabelPage()\n\t{\n\t\t// add a static label\n\t\tadd(new Label(\"staticLabel\", \"static text\"));\n\n\t\t// add a dynamic label. For this example, we create an annonymous\n\t\t// subclass\n\t\t// of Model (just because it is less work then directly implementing\n\t\t// IModel)\n\t\t// that returns a new java.util.Date on each invocation\n\t\tadd(new Label(\"dynamicLabel\", new Model()\n\t\t{\n\t\t\tpublic Object getObject()\n\t\t\t{\n\t\t\t\treturn new Date();\n\t\t\t}\n\t\t}));\n\n\t\t// add a label with a model that gets its display text from a resource\n\t\t// bundle\n\t\t// (which is in this case LabelPage.properties)\n\t\t// We use key 'label.current.locale' and provide a the current locale\n\t\t// for\n\t\t// parameter substitution.\n\t\tStringResourceModel stringResourceModel = new StringResourceModel(\"label.current.locale\",\n\t\t\t\tthis, null, new Object[] { getLocale() });\n\t\tadd(new Label(\"resourceLabel\", stringResourceModel));\n\n\t\t// and here we add a label that contains markup. Normally, this markup\n\t\t// would be converted\n\t\t// to HTML escape characters so that e.g. a & really dislays as that\n\t\t// literal char wihout\n\t\t// our browser trying to resolve it to an HTML entity. But it this case\n\t\t// we actually want\n\t\t// our browser to interpret it as real markup, so we set the\n\t\t// escapeModelString property\n\t\t// to false\n\t\tLabel markupLabel = new Label(\"markupLabel\",\n\t\t\t\t\"now <i>that<\/i> is a pretty <b>bold<\/b> statement!\");\n\t\tmarkupLabel.setEscapeModelStrings(false);\n\t\tadd(markupLabel);\n\t}","id":25545,"modified_method":"/**\n\t * Constructor\n\t */\n\tpublic LabelPage()\n\t{\n\t\t// add a static label\n\t\tadd(new Label(\"staticLabel\", \"static text\"));\n\n\t\t// add a dynamic label. For this example, we create an annonymous\n\t\t// subclass\n\t\t// of Model (just because it is less work then directly implementing\n\t\t// IModel)\n\t\t// that returns a new java.util.Date on each invocation\n\t\tadd(new Label(\"dynamicLabel\", new Model<Date>()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic Date getObject()\n\t\t\t{\n\t\t\t\treturn new Date();\n\t\t\t}\n\t\t}));\n\n\t\t// add a label with a model that gets its display text from a resource\n\t\t// bundle\n\t\t// (which is in this case LabelPage.properties)\n\t\t// We use key 'label.current.locale' and provide a the current locale\n\t\t// for\n\t\t// parameter substitution.\n\t\tStringResourceModel stringResourceModel = new StringResourceModel(\"label.current.locale\",\n\t\t\tthis, null, new Object[] { getLocale() });\n\t\tadd(new Label(\"resourceLabel\", stringResourceModel));\n\n\t\t// and here we add a label that contains markup. Normally, this markup\n\t\t// would be converted\n\t\t// to HTML escape characters so that e.g. a & really dislays as that\n\t\t// literal char wihout\n\t\t// our browser trying to resolve it to an HTML entity. But it this case\n\t\t// we actually want\n\t\t// our browser to interpret it as real markup, so we set the\n\t\t// escapeModelString property\n\t\t// to false\n\t\tLabel markupLabel = new Label(\"markupLabel\",\n\t\t\t\"now <i>that<\/i> is a pretty <b>bold<\/b> statement!\");\n\t\tmarkupLabel.setEscapeModelStrings(false);\n\t\tadd(markupLabel);\n\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * Construct.\n\t\t * \n\t\t * @param id\n\t\t *            component id\n\t\t * @param clickCount\n\t\t *            the count object\n\t\t */\n\t\tpublic ClickCountLabel(String id, final ClickCount clickCount)\n\t\t{\n\t\t\t// call super with a simple annonymous class model that displays the\n\t\t\t// current number of clicks\n\t\t\tsuper(id, new Model()\n\t\t\t{\n\t\t\t\tpublic Object getObject()\n\t\t\t\t{\n\t\t\t\t\treturn Integer.toString(clickCount.clicks);\n\t\t\t\t}\n\t\t\t});\n\t\t}","id":25546,"modified_method":"/**\n\t\t * Construct.\n\t\t * \n\t\t * @param id\n\t\t *            component id\n\t\t * @param clickCount\n\t\t *            the count object\n\t\t */\n\t\tpublic ClickCountLabel(String id, final ClickCount clickCount)\n\t\t{\n\t\t\t// call super with a simple annonymous class model that displays the\n\t\t\t// current number of clicks\n\t\t\tsuper(id, new Model<String>()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic String getObject()\n\t\t\t\t{\n\t\t\t\t\treturn Integer.toString(clickCount.clicks);\n\t\t\t\t}\n\t\t\t});\n\t\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t */\n\tpublic LinkPage()\n\t{\n\t\t// power to the annonymous classes!\n\n\t\t// first create a simple value holder object\n\t\tfinal ClickCount count1 = new ClickCount();\n\n\t\t// add a link which, when clicked, increases our counter\n\t\t// when a link is clicked, its onClick method is called\n\t\tLink link1 = new Link(\"link1\")\n\t\t{\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tcount1.clicks++;\n\t\t\t}\n\t\t};\n\t\tadd(link1);\n\t\t// add a counter label to the link so that we can display it in the body\n\t\t// of the link\n\t\tlink1.add(new Label(\"label1\", new Model()\n\t\t{\n\t\t\tpublic Object getObject()\n\t\t\t{\n\t\t\t\treturn Integer.toString(count1.clicks);\n\t\t\t}\n\t\t}));\n\n\t\tfinal ClickCount count2 = new ClickCount();\n\t\t// Same idea as above, but now we record a state change. Note that the\n\t\t// URL will change because of this, and pressing the back button and\n\t\t// clicking the link again would revert to the older value.\n\t\t// The same thing could have been achieved by using setModelObject,\n\t\t// which implicitly registers a state change (of type\n\t\t// ComponentModelChange).\n\t\tLink linkWithStateChange = new Link(\"linkWithStateChange\")\n\t\t{\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tfinal int count = count1.clicks;\n\t\t\t\tcount2.clicks++;\n\t\t\t\taddStateChange(new Change()\n\t\t\t\t{\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void undo()\n\t\t\t\t\t{\n\t\t\t\t\t\t// revert\n\t\t\t\t\t\tcount2.clicks = count;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t\tadd(linkWithStateChange);\n\t\tlinkWithStateChange.add(new Label(\"label\", new PropertyModel(count2, \"clicks\")));\n\n\t\t// we can attach Link components to any HTML tag we want. If it is an\n\t\t// anchor (<a href...),\n\t\t// the url to this component is put in the href attribute. For other\n\t\t// components, a\n\t\t// onclick javascript event handler is created that triggers the round\n\t\t// trip\n\n\t\t// it is of course possible to - instead of the above approach - hide as\n\t\t// much of the component as possible within a class.\n\t\tclass CustomLink extends Link\n\t\t{\n\t\t\tfinal ClickCount count2;\n\n\t\t\t/**\n\t\t\t * Construct.\n\t\t\t * \n\t\t\t * @param id\n\t\t\t */\n\t\t\tpublic CustomLink(String id)\n\t\t\t{\n\t\t\t\tsuper(id);\n\t\t\t\tcount2 = new ClickCount();\n\t\t\t\tadd(new ClickCountLabel(\"label2\", count2));\n\t\t\t}\n\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tcount2.clicks++;\n\t\t\t}\n\t\t}\n\t\tadd(new CustomLink(\"link2\"));\n\n\t\t// and if we know we are going to attach it to a <input type=\"button>\n\t\t// tag, we shouldn't\n\t\t// use a label, but an AttributeModifier instead.\n\t\tclass ButtonLink extends Link\n\t\t{\n\t\t\tfinal ClickCount count3;\n\n\t\t\t/**\n\t\t\t * Construct.\n\t\t\t * \n\t\t\t * @param id\n\t\t\t */\n\t\t\tpublic ButtonLink(String id)\n\t\t\t{\n\t\t\t\tsuper(id);\n\t\t\t\tcount3 = new ClickCount();\n\t\t\t\tadd(new AttributeModifier(\"value\", new Model()\n\t\t\t\t{\n\t\t\t\t\tpublic Object getObject()\n\t\t\t\t\t{\n\t\t\t\t\t\t// we just replace the whole string. You could use\n\t\t\t\t\t\t// custom\n\t\t\t\t\t\t// AttributeModifiers to e.g. just replace one part of\n\t\t\t\t\t\t// the\n\t\t\t\t\t\t// string if you want\n\t\t\t\t\t\treturn \"this button is clicked \" + count3.clicks + \" times\";\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tcount3.clicks++;\n\t\t\t}\n\t\t}\n\t\tadd(new ButtonLink(\"link3\"));\n\t}","id":25547,"modified_method":"/**\n\t * Constructor\n\t */\n\tpublic LinkPage()\n\t{\n\t\t// power to the annonymous classes!\n\n\t\t// first create a simple value holder object\n\t\tfinal ClickCount count1 = new ClickCount();\n\n\t\t// add a link which, when clicked, increases our counter\n\t\t// when a link is clicked, its onClick method is called\n\t\tLink link1 = new Link(\"link1\")\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tcount1.clicks++;\n\t\t\t}\n\t\t};\n\t\tadd(link1);\n\t\t// add a counter label to the link so that we can display it in the body\n\t\t// of the link\n\t\tlink1.add(new Label(\"label1\", new Model<String>()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic String getObject()\n\t\t\t{\n\t\t\t\treturn Integer.toString(count1.clicks);\n\t\t\t}\n\t\t}));\n\n\t\tfinal ClickCount count2 = new ClickCount();\n\t\t// Same idea as above, but now we record a state change. Note that the\n\t\t// URL will change because of this, and pressing the back button and\n\t\t// clicking the link again would revert to the older value.\n\t\t// The same thing could have been achieved by using setModelObject,\n\t\t// which implicitly registers a state change (of type\n\t\t// ComponentModelChange).\n\t\tLink linkWithStateChange = new Link(\"linkWithStateChange\")\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tfinal int count = count1.clicks;\n\t\t\t\tcount2.clicks++;\n\t\t\t\taddStateChange(new Change()\n\t\t\t\t{\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void undo()\n\t\t\t\t\t{\n\t\t\t\t\t\t// revert\n\t\t\t\t\t\tcount2.clicks = count;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t\tadd(linkWithStateChange);\n\t\tlinkWithStateChange.add(new Label(\"label\", new PropertyModel(count2, \"clicks\")));\n\n\t\t// we can attach Link components to any HTML tag we want. If it is an\n\t\t// anchor (<a href...),\n\t\t// the url to this component is put in the href attribute. For other\n\t\t// components, a\n\t\t// onclick javascript event handler is created that triggers the round\n\t\t// trip\n\n\t\t// it is of course possible to - instead of the above approach - hide as\n\t\t// much of the component as possible within a class.\n\t\tclass CustomLink extends Link\n\t\t{\n\t\t\tfinal ClickCount count2;\n\n\t\t\t/**\n\t\t\t * Construct.\n\t\t\t * \n\t\t\t * @param id\n\t\t\t */\n\t\t\tpublic CustomLink(String id)\n\t\t\t{\n\t\t\t\tsuper(id);\n\t\t\t\tcount2 = new ClickCount();\n\t\t\t\tadd(new ClickCountLabel(\"label2\", count2));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tcount2.clicks++;\n\t\t\t}\n\t\t}\n\t\tadd(new CustomLink(\"link2\"));\n\n\t\t// and if we know we are going to attach it to a <input type=\"button>\n\t\t// tag, we shouldn't\n\t\t// use a label, but an AttributeModifier instead.\n\t\tclass ButtonLink extends Link\n\t\t{\n\t\t\tfinal ClickCount count3;\n\n\t\t\t/**\n\t\t\t * Construct.\n\t\t\t * \n\t\t\t * @param id\n\t\t\t */\n\t\t\tpublic ButtonLink(String id)\n\t\t\t{\n\t\t\t\tsuper(id);\n\t\t\t\tcount3 = new ClickCount();\n\t\t\t\tadd(new AttributeModifier(\"value\", new Model<String>()\n\t\t\t\t{\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String getObject()\n\t\t\t\t\t{\n\t\t\t\t\t\t// we just replace the whole string. You could use\n\t\t\t\t\t\t// custom\n\t\t\t\t\t\t// AttributeModifiers to e.g. just replace one part of\n\t\t\t\t\t\t// the\n\t\t\t\t\t\t// string if you want\n\t\t\t\t\t\treturn \"this button is clicked \" + count3.clicks + \" times\";\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tcount3.clicks++;\n\t\t\t}\n\t\t}\n\t\tadd(new ButtonLink(\"link3\"));\n\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t */\n\tpublic LiveSessionsPage()\n\t{\n\t\tadd(new Image(\"bug\"));\n\n\t\tadd(new ApplicationView(\"application\", Application.get()));\n\n\t\tLink link = new Link(\"togglelink\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tWebApplication webApplication = (WebApplication)Application.get();\n\t\t\t\twebApplication.getRequestLoggerSettings().setRequestsWindowSize(500);\n\t\t\t\tboolean enabled = webApplication.getRequestLoggerSettings()\n\t\t\t\t\t\t.isRequestLoggerEnabled();\n\t\t\t\twebApplication.getRequestLoggerSettings().setRequestLoggerEnabled(!enabled);\n\t\t\t}\n\t\t};\n\t\tlink.add(new Label(\"toggletext\", new Model()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic Object getObject()\n\t\t\t{\n\t\t\t\tWebApplication webApplication = (WebApplication)Application.get();\n\t\t\t\tIRequestLogger requestLogger = webApplication.getRequestLogger();\n\t\t\t\tif (requestLogger == null)\n\t\t\t\t{\n\t\t\t\t\treturn \"Enable request recording\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn \"Disable request recording\";\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\tadd(link);\n\t\tadd(new Label(\"totalSessions\", new Model()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic Object getObject()\n\t\t\t{\n\t\t\t\treturn getRequestLogger().getTotalCreatedSessions();\n\t\t\t}\n\t\t}));\n\t\tadd(new Label(\"peakSessions\", new Model()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic Object getObject()\n\t\t\t{\n\t\t\t\treturn getRequestLogger().getPeakSessions();\n\t\t\t}\n\t\t}));\n\t\tadd(new Label(\"liveSessions\", new Model()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic Object getObject()\n\t\t\t{\n\t\t\t\treturn getRequestLogger().getPeakSessions();\n\t\t\t}\n\t\t}));\n\n\t\tModel sessionModel = new Model()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic Object getObject()\n\t\t\t{\n\t\t\t\treturn Arrays.asList(getRequestLogger().getLiveSessions());\n\t\t\t}\n\t\t};\n\t\tPageableListView listView = new PageableListView(\"sessions\", sessionModel, 50)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprivate final SimpleDateFormat sdf = new SimpleDateFormat(\"dd MMM hh:mm:ss.SSS\");\n\n\t\t\tprotected void populateItem(ListItem item)\n\t\t\t{\n\t\t\t\tfinal SessionData sd = (SessionData)item.getModelObject();\n\t\t\t\tLink link = new Link(\"id\")\n\t\t\t\t{\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @see org.apache.wicket.markup.html.link.Link#onClick()\n\t\t\t\t\t */\n\t\t\t\t\tpublic void onClick()\n\t\t\t\t\t{\n\t\t\t\t\t\tsetResponsePage(new RequestsPage(sd));\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tlink.add(new Label(\"id\", new Model(sd.getSessionId())));\n\t\t\t\titem.add(link);\n\t\t\t\titem.add(new Label(\"lastRequestTime\", new Model(sdf.format(sd.getLastActive()))));\n\t\t\t\titem.add(new Label(\"requestCount\", new Model(sd.getNumberOfRequests())));\n\t\t\t\titem.add(new Label(\"requestsTime\", new Model(sd.getTotalTimeTaken())));\n\t\t\t\titem.add(new Label(\"sessionSize\", new Model(Bytes.bytes(sd.getSessionSize()))));\n\t\t\t}\n\t\t};\n\t\tadd(listView);\n\n\t\tPagingNavigator navigator = new PagingNavigator(\"navigator\", listView);\n\t\tadd(navigator);\n\t}","id":25548,"modified_method":"/**\n\t * Construct.\n\t */\n\tpublic LiveSessionsPage()\n\t{\n\t\tadd(new Image(\"bug\"));\n\n\t\tadd(new ApplicationView(\"application\", Application.get()));\n\n\t\tLink link = new Link(\"togglelink\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tWebApplication webApplication = (WebApplication)Application.get();\n\t\t\t\twebApplication.getRequestLoggerSettings().setRequestsWindowSize(500);\n\t\t\t\tboolean enabled = webApplication.getRequestLoggerSettings()\n\t\t\t\t\t.isRequestLoggerEnabled();\n\t\t\t\twebApplication.getRequestLoggerSettings().setRequestLoggerEnabled(!enabled);\n\t\t\t}\n\t\t};\n\t\tlink.add(new Label(\"toggletext\", new Model<String>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic String getObject()\n\t\t\t{\n\t\t\t\tWebApplication webApplication = (WebApplication)Application.get();\n\t\t\t\tIRequestLogger requestLogger = webApplication.getRequestLogger();\n\t\t\t\tif (requestLogger == null)\n\t\t\t\t{\n\t\t\t\t\treturn \"Enable request recording\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn \"Disable request recording\";\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\tadd(link);\n\t\tadd(new Label(\"totalSessions\", new Model<Integer>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Integer getObject()\n\t\t\t{\n\t\t\t\treturn getRequestLogger().getTotalCreatedSessions();\n\t\t\t}\n\t\t}));\n\t\tadd(new Label(\"peakSessions\", new Model<Integer>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Integer getObject()\n\t\t\t{\n\t\t\t\treturn getRequestLogger().getPeakSessions();\n\t\t\t}\n\t\t}));\n\t\tadd(new Label(\"liveSessions\", new Model<Integer>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Integer getObject()\n\t\t\t{\n\t\t\t\treturn getRequestLogger().getPeakSessions();\n\t\t\t}\n\t\t}));\n\n\t\tModel<ArrayList<SessionData>> sessionModel = new Model<ArrayList<SessionData>>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic ArrayList<SessionData> getObject()\n\t\t\t{\n\t\t\t\treturn new ArrayList<SessionData>(\n\t\t\t\t\tArrays.asList(getRequestLogger().getLiveSessions()));\n\t\t\t}\n\t\t};\n\t\tPageableListView listView = new PageableListView(\"sessions\", sessionModel, 50)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprivate final SimpleDateFormat sdf = new SimpleDateFormat(\"dd MMM hh:mm:ss.SSS\");\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(ListItem item)\n\t\t\t{\n\t\t\t\tfinal SessionData sd = (SessionData)item.getModelObject();\n\t\t\t\tLink link = new Link(\"id\")\n\t\t\t\t{\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @see org.apache.wicket.markup.html.link.Link#onClick()\n\t\t\t\t\t */\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick()\n\t\t\t\t\t{\n\t\t\t\t\t\tsetResponsePage(new RequestsPage(sd));\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tlink.add(new Label(\"id\", new Model<String>(sd.getSessionId())));\n\t\t\t\titem.add(link);\n\t\t\t\titem.add(new Label(\"lastRequestTime\", new Model<String>(\n\t\t\t\t\tsdf.format(sd.getLastActive()))));\n\t\t\t\titem.add(new Label(\"requestCount\", new Model<Long>(sd.getNumberOfRequests())));\n\t\t\t\titem.add(new Label(\"requestsTime\", new Model<Long>(sd.getTotalTimeTaken())));\n\t\t\t\titem.add(new Label(\"sessionSize\",\n\t\t\t\t\tnew Model<Bytes>(Bytes.bytes(sd.getSessionSize()))));\n\t\t\t}\n\t\t};\n\t\tadd(listView);\n\n\t\tPagingNavigator navigator = new PagingNavigator(\"navigator\", listView);\n\t\tadd(navigator);\n\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the roles for creation of the given component class, or null if none were registered.\n\t *\n\t * @param componentClass\n\t *            the component class\n\t * @return the roles that are authorized for creation of the componentClass, or null if no\n\t *         specific authorization was configured\n\t */\n\tprivate static Roles rolesAuthorizedToInstantiate(\n\t\t\tfinal Class< ? extends Component> componentClass)\n\t{\n\t\tfinal InstantiationPermissions permissions = (InstantiationPermissions)Application.get()\n\t\t\t\t.getMetaData(INSTANTIATION_PERMISSIONS);\n\t\tif (permissions != null)\n\t\t{\n\t\t\treturn permissions.authorizedRoles(componentClass);\n\t\t}\n\t\treturn null;\n\t}","id":25549,"modified_method":"/**\n\t * Gets the roles for creation of the given component class, or null if none were registered.\n\t * \n\t * @param componentClass\n\t *            the component class\n\t * @return the roles that are authorized for creation of the componentClass, or null if no\n\t *         specific authorization was configured\n\t */\n\tprivate static Roles rolesAuthorizedToInstantiate(\n\t\t\tfinal Class< ? extends Component> componentClass)\n\t{\n\t\tfinal InstantiationPermissions permissions = Application.get().getMetaData(\n\t\t\t\tINSTANTIATION_PERMISSIONS);\n\t\tif (permissions != null)\n\t\t{\n\t\t\treturn permissions.authorizedRoles(componentClass);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Authorizes the given role to create component instances of type componentClass. This\n\t * authorization is added to any previously authorized roles.\n\t *\n\t * @param componentClass\n\t *            The component type that is subject for the authorization\n\t * @param roles\n\t *            The comma separated roles that are authorized to create component instances of\n\t *            type componentClass\n\t */\n\tpublic static final void authorize(final Class< ? extends Component> componentClass,\n\t\t\tfinal String roles)\n\t{\n\t\tfinal Application application = Application.get();\n\t\tInstantiationPermissions permissions = (InstantiationPermissions)application\n\t\t\t\t.getMetaData(INSTANTIATION_PERMISSIONS);\n\t\tif (permissions == null)\n\t\t{\n\t\t\tpermissions = new InstantiationPermissions();\n\t\t\tapplication.setMetaData(INSTANTIATION_PERMISSIONS, permissions);\n\t\t}\n\t\tpermissions.authorize(componentClass, new Roles(roles));\n\t}","id":25550,"modified_method":"/**\n\t * Authorizes the given role to create component instances of type componentClass. This\n\t * authorization is added to any previously authorized roles.\n\t * \n\t * @param componentClass\n\t *            The component type that is subject for the authorization\n\t * @param roles\n\t *            The comma separated roles that are authorized to create component instances of\n\t *            type componentClass\n\t */\n\tpublic static final void authorize(final Class< ? extends Component> componentClass,\n\t\t\tfinal String roles)\n\t{\n\t\tfinal Application application = Application.get();\n\t\tInstantiationPermissions permissions = application.getMetaData(INSTANTIATION_PERMISSIONS);\n\t\tif (permissions == null)\n\t\t{\n\t\t\tpermissions = new InstantiationPermissions();\n\t\t\tapplication.setMetaData(INSTANTIATION_PERMISSIONS, permissions);\n\t\t}\n\t\tpermissions.authorize(componentClass, new Roles(roles));\n\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Removes permission for the given roles to create instances of the given component class.\n\t * There is no danger in removing authorization by calling this method. If the last\n\t * authorization grant is removed for a given componentClass, the internal role NO_ROLE will\n\t * automatically be added, effectively denying access to all roles (if this was not done, all\n\t * roles would suddenly have access since no authorization is equivalent to full access).\n\t *\n\t * @param componentClass\n\t *            The component type\n\t * @param roles\n\t *            The comma separated list of roles that are no longer to be authorized to create\n\t *            instances of type componentClass\n\t */\n\tpublic static final void unauthorize(final Class< ? extends Component> componentClass,\n\t\t\tfinal String roles)\n\t{\n\t\tfinal InstantiationPermissions permissions = (InstantiationPermissions)Application.get()\n\t\t\t\t.getMetaData(INSTANTIATION_PERMISSIONS);\n\t\tif (permissions != null)\n\t\t{\n\t\t\tpermissions.unauthorize(componentClass, new Roles(roles));\n\t\t}\n\t}","id":25551,"modified_method":"/**\n\t * Removes permission for the given roles to create instances of the given component class.\n\t * There is no danger in removing authorization by calling this method. If the last\n\t * authorization grant is removed for a given componentClass, the internal role NO_ROLE will\n\t * automatically be added, effectively denying access to all roles (if this was not done, all\n\t * roles would suddenly have access since no authorization is equivalent to full access).\n\t * \n\t * @param componentClass\n\t *            The component type\n\t * @param roles\n\t *            The comma separated list of roles that are no longer to be authorized to create\n\t *            instances of type componentClass\n\t */\n\tpublic static final void unauthorize(final Class< ? extends Component> componentClass,\n\t\t\tfinal String roles)\n\t{\n\t\tfinal InstantiationPermissions permissions = Application.get().getMetaData(\n\t\t\t\tINSTANTIATION_PERMISSIONS);\n\t\tif (permissions != null)\n\t\t{\n\t\t\tpermissions.unauthorize(componentClass, new Roles(roles));\n\t\t}\n\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Grants permission to all roles to create instances of the given component class.\n\t *\n\t * @param componentClass\n\t *            The component class\n\t */\n\tpublic static final void authorizeAll(final Class< ? extends Component> componentClass)\n\t{\n\t\tApplication application = Application.get();\n\t\tInstantiationPermissions authorizedRoles = (InstantiationPermissions)application\n\t\t\t\t.getMetaData(INSTANTIATION_PERMISSIONS);\n\t\tif (authorizedRoles != null)\n\t\t{\n\t\t\tauthorizedRoles.authorizeAll(componentClass);\n\t\t}\n\t}","id":25552,"modified_method":"/**\n\t * Grants permission to all roles to create instances of the given component class.\n\t * \n\t * @param componentClass\n\t *            The component class\n\t */\n\tpublic static final void authorizeAll(final Class< ? extends Component> componentClass)\n\t{\n\t\tApplication application = Application.get();\n\t\tInstantiationPermissions authorizedRoles = application\n\t\t\t\t.getMetaData(INSTANTIATION_PERMISSIONS);\n\t\tif (authorizedRoles != null)\n\t\t{\n\t\t\tauthorizedRoles.authorizeAll(componentClass);\n\t\t}\n\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param sessionData\n\t */\n\tpublic RequestsPage(final SessionData sessionData)\n\t{\n\t\tadd(new Image(\"bug\"));\n\t\tif (sessionData == null)\n\t\t{\n\t\t\tadd(new Label(\"id\").setVisible(false));\n\t\t\tadd(new Label(\"sessionInfo\").setVisible(false));\n\t\t\tadd(new Label(\"startDate\").setVisible(false));\n\t\t\tadd(new Label(\"lastRequestTime\").setVisible(false));\n\t\t\tadd(new Label(\"numberOfRequests\").setVisible(false));\n\t\t\tadd(new Label(\"totalTimeTaken\").setVisible(false));\n\t\t\tadd(new Label(\"size\").setVisible(false));\n\t\t\tadd(new WebMarkupContainer(\"sessionid\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tadd(new Label(\"id\", new Model(sessionData.getSessionId())));\n\t\t\tadd(new Label(\"sessionInfo\", new Model((Serializable)sessionData.getSessionInfo())));\n\t\t\tadd(new Label(\"startDate\", new Model(sdf.format(sessionData.getStartDate()))));\n\t\t\tadd(new Label(\"lastRequestTime\", new Model(sdf.format(sessionData.getLastActive()))));\n\t\t\tadd(new Label(\"numberOfRequests\",\n\t\t\t\t\tnew Model(sessionData.getNumberOfRequests())));\n\t\t\tadd(new Label(\"totalTimeTaken\", new Model(sessionData.getTotalTimeTaken())));\n\t\t\tadd(new Label(\"size\", new Model(Bytes.bytes(sessionData.getSessionSize()))));\n\t\t\tadd(new WebMarkupContainer(\"sessionid\").setVisible(false));\n\t\t}\n\n\t\tIModel requestsModel = new Model()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic Object getObject()\n\t\t\t{\n\t\t\t\tList requests = getRequestLogger().getRequests();\n\t\t\t\tif (sessionData != null)\n\t\t\t\t{\n\t\t\t\t\tList returnValues = new ArrayList();\n\t\t\t\t\tfor (int i = 0; i < requests.size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tRequestData data = (RequestData)requests.get(i);\n\t\t\t\t\t\tif (sessionData.getSessionId().equals(data.getSessionId()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturnValues.add(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn returnValues;\n\t\t\t\t}\n\t\t\t\treturn requests;\n\t\t\t}\n\t\t};\n\t\tPageableListView listView = new PageableListView(\"requests\", requestsModel, 50)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void populateItem(ListItem item)\n\t\t\t{\n\t\t\t\tRequestData rd = (RequestData)item.getModelObject();\n\t\t\t\titem.add(new Label(\"id\", new Model(rd.getSessionId()))\n\t\t\t\t\t\t.setVisible(sessionData == null));\n\t\t\t\titem.add(new Label(\"startDate\", new Model(sdf.format(rd.getStartDate()))));\n\t\t\t\titem.add(new Label(\"timeTaken\", new Model(rd.getTimeTaken())));\n\t\t\t\titem.add(new Label(\"eventTarget\", new Model(rd.getEventTarget())));\n\t\t\t\titem.add(new Label(\"responseTarget\", new Model(rd.getResponseTarget())));\n\t\t\t\titem.add(new Label(\"alteredObjects\", new Model(rd.getAlteredObjects())))\n\t\t\t\t\t\t.setEscapeModelStrings(false);\n\t\t\t\titem.add(new Label(\"sessionSize\", new Model(Bytes.bytes(rd.getSessionSize()\n\t\t\t\t\t\t.longValue()))));\n\t\t\t}\n\t\t};\n\t\tadd(listView);\n\n\t\tPagingNavigator navigator = new PagingNavigator(\"navigator\", listView);\n\t\tadd(navigator);\n\t}","id":25553,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param sessionData\n\t */\n\tpublic RequestsPage(final SessionData sessionData)\n\t{\n\t\tadd(new Image(\"bug\"));\n\t\tif (sessionData == null)\n\t\t{\n\t\t\tadd(new Label(\"id\").setVisible(false));\n\t\t\tadd(new Label(\"sessionInfo\").setVisible(false));\n\t\t\tadd(new Label(\"startDate\").setVisible(false));\n\t\t\tadd(new Label(\"lastRequestTime\").setVisible(false));\n\t\t\tadd(new Label(\"numberOfRequests\").setVisible(false));\n\t\t\tadd(new Label(\"totalTimeTaken\").setVisible(false));\n\t\t\tadd(new Label(\"size\").setVisible(false));\n\t\t\tadd(new WebMarkupContainer(\"sessionid\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tadd(new Label(\"id\", new Model(sessionData.getSessionId())));\n\t\t\tadd(new Label(\"sessionInfo\", new Model((Serializable)sessionData.getSessionInfo())));\n\t\t\tadd(new Label(\"startDate\", new Model(sdf.format(sessionData.getStartDate()))));\n\t\t\tadd(new Label(\"lastRequestTime\", new Model(sdf.format(sessionData.getLastActive()))));\n\t\t\tadd(new Label(\"numberOfRequests\", new Model(sessionData.getNumberOfRequests())));\n\t\t\tadd(new Label(\"totalTimeTaken\", new Model(sessionData.getTotalTimeTaken())));\n\t\t\tadd(new Label(\"size\", new Model(Bytes.bytes(sessionData.getSessionSize()))));\n\t\t\tadd(new WebMarkupContainer(\"sessionid\").setVisible(false));\n\t\t}\n\n\t\tIModel<ArrayList<RequestData>> requestsModel = new Model<ArrayList<RequestData>>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic ArrayList<RequestData> getObject()\n\t\t\t{\n\t\t\t\tList<RequestData> requests = getRequestLogger().getRequests();\n\t\t\t\tif (sessionData != null)\n\t\t\t\t{\n\t\t\t\t\tArrayList<RequestData> returnValues = new ArrayList<RequestData>();\n\t\t\t\t\tfor (int i = 0; i < requests.size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tRequestData data = requests.get(i);\n\t\t\t\t\t\tif (sessionData.getSessionId().equals(data.getSessionId()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturnValues.add(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn returnValues;\n\t\t\t\t}\n\t\t\t\treturn new ArrayList<RequestData>(requests);\n\t\t\t}\n\t\t};\n\t\tPageableListView listView = new PageableListView(\"requests\", requestsModel, 50)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(ListItem item)\n\t\t\t{\n\t\t\t\tRequestData rd = (RequestData)item.getModelObject();\n\t\t\t\titem.add(new Label(\"id\", new Model(rd.getSessionId())).setVisible(sessionData == null));\n\t\t\t\titem.add(new Label(\"startDate\", new Model(sdf.format(rd.getStartDate()))));\n\t\t\t\titem.add(new Label(\"timeTaken\", new Model(rd.getTimeTaken())));\n\t\t\t\titem.add(new Label(\"eventTarget\", new Model(rd.getEventTarget())));\n\t\t\t\titem.add(new Label(\"responseTarget\", new Model(rd.getResponseTarget())));\n\t\t\t\titem.add(new Label(\"alteredObjects\", new Model(rd.getAlteredObjects())))\n\t\t\t\t\t.setEscapeModelStrings(false);\n\t\t\t\titem.add(new Label(\"sessionSize\", new Model(Bytes.bytes(rd.getSessionSize()\n\t\t\t\t\t.longValue()))));\n\t\t\t}\n\t\t};\n\t\tadd(listView);\n\n\t\tPagingNavigator navigator = new PagingNavigator(\"navigator\", listView);\n\t\tadd(navigator);\n\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @see Component#Component(String)\n\t */\n\tpublic SessionView(final String id, final Session session)\n\t{\n\t\tsuper(id);\n\n\t\t// Basic attributes\n\t\tadd(new Label(\"id\", session.getId()));\n\t\tadd(new Label(\"locale\", session.getLocale().toString()));\n\t\tadd(new Label(\"style\", session.getStyle() == null ? \"[None]\" : session.getStyle()));\n\t\tadd(new Label(\"size\", new Model()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic Object getObject()\n\t\t\t{\n\t\t\t\treturn Bytes.bytes(Objects.sizeof(session));\n\t\t\t}\n\t\t}));\n\t\tadd(new Label(\"totalSize\", new Model()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic Object getObject()\n\t\t\t{\n\t\t\t\treturn Bytes.bytes(session.getSizeInBytes());\n\t\t\t}\n\t\t}));\n\n\t\t// Get pagemaps\n\t\tfinal List pagemaps = session.getPageMaps();\n\n\t\t// Create the table containing the list the components\n\t\tadd(new ListView(\"pagemaps\", pagemaps)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t/**\n\t\t\t * Populate the table with Wicket elements\n\t\t\t */\n\t\t\tprotected void populateItem(final ListItem listItem)\n\t\t\t{\n\t\t\t\tIPageMap p = (IPageMap)listItem.getModelObject();\n\t\t\t\tlistItem.add(new PageMapView(\"pagemap\", p));\n\t\t\t}\n\t\t});\n\t}","id":25554,"modified_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @see Component#Component(String)\n\t */\n\tpublic SessionView(final String id, final Session session)\n\t{\n\t\tsuper(id);\n\n\t\t// Basic attributes\n\t\tadd(new Label(\"id\", session.getId()));\n\t\tadd(new Label(\"locale\", session.getLocale().toString()));\n\t\tadd(new Label(\"style\", session.getStyle() == null ? \"[None]\" : session.getStyle()));\n\t\tadd(new Label(\"size\", new Model<Bytes>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Bytes getObject()\n\t\t\t{\n\t\t\t\treturn Bytes.bytes(Objects.sizeof(session));\n\t\t\t}\n\t\t}));\n\t\tadd(new Label(\"totalSize\", new Model<Bytes>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Bytes getObject()\n\t\t\t{\n\t\t\t\treturn Bytes.bytes(session.getSizeInBytes());\n\t\t\t}\n\t\t}));\n\n\t\t// Get pagemaps\n\t\tfinal List pagemaps = session.getPageMaps();\n\n\t\t// Create the table containing the list the components\n\t\tadd(new ListView(\"pagemaps\", pagemaps)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t/**\n\t\t\t * Populate the table with Wicket elements\n\t\t\t */\n\t\t\t@Override\n\t\t\tprotected void populateItem(final ListItem listItem)\n\t\t\t{\n\t\t\t\tIPageMap p = (IPageMap)listItem.getModelObject();\n\t\t\t\tlistItem.add(new PageMapView(\"pagemap\", p));\n\t\t\t}\n\t\t});\n\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * @see org.apache.wicket.model.IModel#setObject(java.lang.Object)\n\t\t */\n\t\tpublic void setObject(Object object)\n\t\t{\n\t\t\t// Ignore. We are not interested in updating any value,\n\t\t\t// and we don't want to throw an exception like\n\t\t\t// AbstractReadOnlyModel either. Alternatively, we\n\t\t\t// could have overriden updateModel of FormInputComponent\n\t\t\t// and ignore any input there.\n\t\t}","id":25555,"modified_method":"/**\n\t\t * @see org.apache.wicket.model.IModel#setObject(java.lang.Object)\n\t\t */\n\t\t@Override\n\t\tpublic void setObject(String object)\n\t\t{\n\t\t\t// Ignore. We are not interested in updating any value,\n\t\t\t// and we don't want to throw an exception like\n\t\t\t// AbstractReadOnlyModel either. Alternatively, we\n\t\t\t// could have overriden updateModel of FormInputComponent\n\t\t\t// and ignore any input there.\n\t\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * @see org.apache.wicket.model.IModel#getObject()\n\t\t */\n\t\tpublic Object getObject()\n\t\t{\n\t\t\tString result;\n\t\t\tif (TO_ESCAPED_UNICODE.equals(translationType))\n\t\t\t{\n\t\t\t\tresult = Strings.toEscapedUnicode(source);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = Strings.fromEscapedUnicode(source);\n\t\t\t}\n\t\t\treturn result;\n\t\t}","id":25556,"modified_method":"/**\n\t\t * @see org.apache.wicket.model.IModel#getObject()\n\t\t */\n\t\t@Override\n\t\tpublic String getObject()\n\t\t{\n\t\t\tString result;\n\t\t\tif (TO_ESCAPED_UNICODE.equals(translationType))\n\t\t\t{\n\t\t\t\tresult = Strings.toEscapedUnicode(source);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = Strings.fromEscapedUnicode(source);\n\t\t\t}\n\t\t\treturn result;\n\t\t}","commit_id":"42a24f6586f2ecb074f8a047e78afa6516f16015","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Grants permission to all roles to create instances of the given component\n\t * class.\n\t * \n\t * @param componentClass\n\t *            The component class\n\t */\n\tpublic static final void authorizeAll(final Class< ? extends Component> componentClass)\n\t{\n\t\tApplication application = Application.get();\n\t\tInstantiationPermissions authorizedRoles = (InstantiationPermissions)application\n\t\t\t\t.getMetaData(INSTANTIATION_PERMISSIONS);\n\t\tif (authorizedRoles != null)\n\t\t{\n\t\t\tauthorizedRoles.authorizeAll(componentClass);\n\t\t}\n\t}","id":25557,"modified_method":"/**\n\t * Grants permission to all roles to create instances of the given component\n\t * class.\n\t * \n\t * @param componentClass\n\t *            The component class\n\t */\n\tpublic static final void authorizeAll(final Class< ? extends Component> componentClass)\n\t{\n\t\tApplication application = Application.get();\n\t\tInstantiationPermissions authorizedRoles = application.getMetaData(INSTANTIATION_PERMISSIONS);\n\t\tif (authorizedRoles != null)\n\t\t{\n\t\t\tauthorizedRoles.authorizeAll(componentClass);\n\t\t}\n\t}","commit_id":"8bb659fb7da4a75ed60bfddaa647b6cb6e9562d2","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Removes permission for the given role to perform the given action on the\n\t * given component. There is no danger in removing authorization by calling\n\t * this method. If the last authorization grant is removed for a given\n\t * action, the internal role NO_ROLE will automatically be added,\n\t * effectively denying access to all roles (if this was not done, all roles\n\t * would suddenly have access since no authorization is equivalent to full\n\t * access).\n\t * \n\t * @param component\n\t *            The component\n\t * @param action\n\t *            The action\n\t * @param roles\n\t *            The comma separated list of roles that are no longer allowed\n\t *            to perform the given action\n\t */\n\tpublic static final void unauthorize(final Component component, final Action action,\n\t\t\tfinal String roles)\n\t{\n\t\tfinal ActionPermissions permissions = (ActionPermissions)component\n\t\t\t\t.getMetaData(ACTION_PERMISSIONS);\n\t\tif (permissions != null)\n\t\t{\n\t\t\tpermissions.unauthorize(action, new Roles(roles));\n\t\t}\n\t}","id":25558,"modified_method":"/**\n\t * Removes permission for the given role to perform the given action on the\n\t * given component. There is no danger in removing authorization by calling\n\t * this method. If the last authorization grant is removed for a given\n\t * action, the internal role NO_ROLE will automatically be added,\n\t * effectively denying access to all roles (if this was not done, all roles\n\t * would suddenly have access since no authorization is equivalent to full\n\t * access).\n\t * \n\t * @param component\n\t *            The component\n\t * @param action\n\t *            The action\n\t * @param roles\n\t *            The comma separated list of roles that are no longer allowed\n\t *            to perform the given action\n\t */\n\tpublic static final void unauthorize(final Component<?> component, final Action action,\n\t\t\tfinal String roles)\n\t{\n\t\tfinal ActionPermissions permissions = component.getMetaData(ACTION_PERMISSIONS);\n\t\tif (permissions != null)\n\t\t{\n\t\t\tpermissions.unauthorize(action, new Roles(roles));\n\t\t}\n\t}","commit_id":"8bb659fb7da4a75ed60bfddaa647b6cb6e9562d2","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Removes permission for the given roles to create instances of the given\n\t * component class. There is no danger in removing authorization by calling\n\t * this method. If the last authorization grant is removed for a given\n\t * componentClass, the internal role NO_ROLE will automatically be added,\n\t * effectively denying access to all roles (if this was not done, all roles\n\t * would suddenly have access since no authorization is equivalent to full\n\t * access).\n\t * \n\t * @param componentClass\n\t *            The component type\n\t * @param roles\n\t *            The comma separated list of roles that are no longer to be\n\t *            authorized to create instances of type componentClass\n\t */\n\tpublic static final void unauthorize(final Class< ? extends Component> componentClass,\n\t\t\tfinal String roles)\n\t{\n\t\tfinal InstantiationPermissions permissions = (InstantiationPermissions)Application.get()\n\t\t\t\t.getMetaData(INSTANTIATION_PERMISSIONS);\n\t\tif (permissions != null)\n\t\t{\n\t\t\tpermissions.unauthorize(componentClass, new Roles(roles));\n\t\t}\n\t}","id":25559,"modified_method":"/**\n\t * Removes permission for the given roles to create instances of the given\n\t * component class. There is no danger in removing authorization by calling\n\t * this method. If the last authorization grant is removed for a given\n\t * componentClass, the internal role NO_ROLE will automatically be added,\n\t * effectively denying access to all roles (if this was not done, all roles\n\t * would suddenly have access since no authorization is equivalent to full\n\t * access).\n\t * \n\t * @param componentClass\n\t *            The component type\n\t * @param roles\n\t *            The comma separated list of roles that are no longer to be\n\t *            authorized to create instances of type componentClass\n\t */\n\tpublic static final void unauthorize(final Class< ? extends Component> componentClass,\n\t\t\tfinal String roles)\n\t{\n\t\tfinal InstantiationPermissions permissions = Application.get().getMetaData(INSTANTIATION_PERMISSIONS);\n\t\tif (permissions != null)\n\t\t{\n\t\t\tpermissions.unauthorize(componentClass, new Roles(roles));\n\t\t}\n\t}","commit_id":"8bb659fb7da4a75ed60bfddaa647b6cb6e9562d2","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Grants permission to all roles to perform the given action on the given\n\t * component.\n\t * \n\t * @param component\n\t *            The component that is subject to the authorization\n\t * @param action\n\t *            The action to authorize\n\t */\n\tpublic static final void authorizeAll(final Component component, final Action action)\n\t{\n\t\tActionPermissions permissions = (ActionPermissions)component\n\t\t\t\t.getMetaData(ACTION_PERMISSIONS);\n\t\tif (permissions != null)\n\t\t{\n\t\t\tpermissions.authorizeAll(action);\n\t\t}\n\t}","id":25560,"modified_method":"/**\n\t * Grants permission to all roles to perform the given action on the given\n\t * component.\n\t * \n\t * @param component\n\t *            The component that is subject to the authorization\n\t * @param action\n\t *            The action to authorize\n\t */\n\tpublic static final void authorizeAll(final Component<?> component, final Action action)\n\t{\n\t\tActionPermissions permissions = component.getMetaData(ACTION_PERMISSIONS);\n\t\tif (permissions != null)\n\t\t{\n\t\t\tpermissions.authorizeAll(action);\n\t\t}\n\t}","commit_id":"8bb659fb7da4a75ed60bfddaa647b6cb6e9562d2","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Authorizes the given role to perform the given action on the given\n\t * component.\n\t * \n\t * @param component\n\t *            The component that is subject to the authorization\n\t * @param action\n\t *            The action to authorize\n\t * @param roles\n\t *            The comma separated roles to authorize\n\t */\n\tpublic static final void authorize(final Component component, final Action action,\n\t\t\tfinal String roles)\n\t{\n\t\tActionPermissions permissions = (ActionPermissions)component\n\t\t\t\t.getMetaData(ACTION_PERMISSIONS);\n\t\tif (permissions == null)\n\t\t{\n\t\t\tpermissions = new ActionPermissions();\n\t\t\tcomponent.setMetaData(ACTION_PERMISSIONS, permissions);\n\t\t}\n\t\tpermissions.authorize(action, new Roles(roles));\n\t}","id":25561,"modified_method":"/**\n\t * Authorizes the given role to perform the given action on the given\n\t * component.\n\t * \n\t * @param component\n\t *            The component that is subject to the authorization\n\t * @param action\n\t *            The action to authorize\n\t * @param roles\n\t *            The comma separated roles to authorize\n\t */\n\tpublic static final void authorize(final Component<?> component, final Action action,\n\t\t\tfinal String roles)\n\t{\n\t\tActionPermissions permissions = component.getMetaData(ACTION_PERMISSIONS);\n\t\tif (permissions == null)\n\t\t{\n\t\t\tpermissions = new ActionPermissions();\n\t\t\tcomponent.setMetaData(ACTION_PERMISSIONS, permissions);\n\t\t}\n\t\tpermissions.authorize(action, new Roles(roles));\n\t}","commit_id":"8bb659fb7da4a75ed60bfddaa647b6cb6e9562d2","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Adds a group.\n\t *\n\t * @param  userId the primary key of the group's creator/owner\n\t * @param  parentGroupId the primary key of the parent group\n\t * @param  className the entity's class name\n\t * @param  classPK the primary key of the entity's instance\n\t * @param  liveGroupId the primary key of the live group\n\t * @param  name the entity's name\n\t * @param  description the group's description (optionally\n\t *         <code>null<\/code>)\n\t * @param  type the group's type. For more information see {@link\n\t *         com.liferay.portal.model.GroupConstants}\n\t * @param  friendlyURL the group's friendlyURL (optionally\n\t *         <code>null<\/code>)\n\t * @param  site whether the group is to be associated with a main site\n\t * @param  active whether the group is active\n\t * @param  serviceContext the service context to be applied (optionally\n\t *         <code>null<\/code>). Can set asset category IDs and asset tag\n\t *         names for the group, and whether the group is for staging.\n\t * @return the group\n\t * @throws PortalException if a creator could not be found, if the group's\n\t *         information was invalid, if a layout could not be found, or if a\n\t *         valid friendly URL could not be created for the group\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Group addGroup(\n\t\t\tlong userId, long parentGroupId, String className, long classPK,\n\t\t\tlong liveGroupId, String name, String description, int type,\n\t\t\tString friendlyURL, boolean site, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Group\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tclassName = GetterUtil.getString(className);\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tString friendlyName = name;\n\n\t\tlong groupId = 0;\n\n\t\twhile (true) {\n\t\t\tgroupId = counterLocalService.increment();\n\n\t\t\tUser screenNameUser = userPersistence.fetchByC_SN(\n\t\t\t\tuser.getCompanyId(), String.valueOf(groupId));\n\n\t\t\tif (screenNameUser == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tboolean staging = isStaging(serviceContext);\n\n\t\tlong groupClassNameId = PortalUtil.getClassNameId(Group.class);\n\n\t\tif ((classNameId <= 0) || className.equals(Group.class.getName())) {\n\t\t\tclassName = Group.class.getName();\n\t\t\tclassNameId = groupClassNameId;\n\t\t\tclassPK = groupId;\n\t\t}\n\t\telse if (className.equals(Organization.class.getName())) {\n\t\t\tname = getOrgGroupName(classPK, name);\n\t\t}\n\t\telse if (!GroupConstants.USER_PERSONAL_SITE.equals(name)) {\n\t\t\tname = String.valueOf(classPK);\n\t\t}\n\n\t\tif (className.equals(Organization.class.getName()) && staging) {\n\t\t\tclassPK = liveGroupId;\n\t\t}\n\n\t\tif (className.equals(Layout.class.getName())) {\n\t\t\tLayout layout = layoutLocalService.getLayout(classPK);\n\n\t\t\tparentGroupId = layout.getGroupId();\n\t\t}\n\n\t\tfriendlyURL = getFriendlyURL(\n\t\t\tuser.getCompanyId(), groupId, classNameId, classPK, friendlyName,\n\t\t\tfriendlyURL);\n\n\t\tif (staging) {\n\t\t\tname = name.concat(\" (Staging)\");\n\t\t\tfriendlyURL = friendlyURL.concat(\"-staging\");\n\t\t}\n\n\t\tif (className.equals(Group.class.getName())) {\n\t\t\tif (!site && (liveGroupId == 0)) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\t\telse if (!className.equals(Organization.class.getName()) &&\n\t\t\t\t className.startsWith(\"com.liferay.portal.model.\")) {\n\n\t\t\tif (site) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\tif ((classNameId <= 0) || className.equals(Group.class.getName())) {\n\t\t\tvalidateName(groupId, user.getCompanyId(), name, site);\n\t\t}\n\n\t\tvalidateFriendlyURL(\n\t\t\tuser.getCompanyId(), groupId, classNameId, classPK, friendlyURL);\n\n\t\tGroup group = groupPersistence.create(groupId);\n\n\t\tgroup.setCompanyId(user.getCompanyId());\n\t\tgroup.setCreatorUserId(userId);\n\t\tgroup.setClassNameId(classNameId);\n\t\tgroup.setClassPK(classPK);\n\t\tgroup.setParentGroupId(parentGroupId);\n\t\tgroup.setLiveGroupId(liveGroupId);\n\t\tgroup.setName(name);\n\t\tgroup.setDescription(description);\n\t\tgroup.setType(type);\n\t\tgroup.setFriendlyURL(friendlyURL);\n\t\tgroup.setSite(site);\n\t\tgroup.setActive(active);\n\n\t\tgroupPersistence.update(group, false);\n\n\t\t// Layout sets\n\n\t\tlayoutSetLocalService.addLayoutSet(groupId, true);\n\n\t\tlayoutSetLocalService.addLayoutSet(groupId, false);\n\n\t\tif ((classNameId == groupClassNameId) && !user.isDefaultUser()) {\n\n\t\t\t// Resources\n\n\t\t\tresourceLocalService.addResources(\n\t\t\t\tgroup.getCompanyId(), 0, 0, Group.class.getName(),\n\t\t\t\tgroup.getGroupId(), false, false, false);\n\n\t\t\t// Site roles\n\n\t\t\tRole role = roleLocalService.getRole(\n\t\t\t\tgroup.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\t\tuserGroupRoleLocalService.addUserGroupRoles(\n\t\t\t\tuserId, groupId, new long[] {role.getRoleId()});\n\n\t\t\t// User\n\n\t\t\tuserLocalService.addGroupUsers(\n\t\t\t\tgroup.getGroupId(), new long[] {userId});\n\n\t\t\t// Asset\n\n\t\t\tif (serviceContext != null) {\n\t\t\t\tupdateAsset(\n\t\t\t\t\tuserId, group, serviceContext.getAssetCategoryIds(),\n\t\t\t\t\tserviceContext.getAssetTagNames());\n\t\t\t}\n\n\t\t\t// Expando\n\n\t\t\tif (serviceContext != null) {\n\t\t\t\tgroup.setExpandoBridgeAttributes(serviceContext);\n\t\t\t}\n\t\t}\n\t\telse if (className.equals(Organization.class.getName()) &&\n\t\t\t\t !user.isDefaultUser()) {\n\n\t\t\t// Resources\n\n\t\t\tresourceLocalService.addResources(\n\t\t\t\tgroup.getCompanyId(), 0, 0, Group.class.getName(),\n\t\t\t\tgroup.getGroupId(), false, false, false);\n\t\t}\n\n\t\treturn group;\n\t}","id":25562,"modified_method":"/**\n\t * Adds a group.\n\t *\n\t * @param  userId the primary key of the group's creator/owner\n\t * @param  parentGroupId the primary key of the parent group\n\t * @param  className the entity's class name\n\t * @param  classPK the primary key of the entity's instance\n\t * @param  liveGroupId the primary key of the live group\n\t * @param  name the entity's name\n\t * @param  description the group's description (optionally\n\t *         <code>null<\/code>)\n\t * @param  type the group's type. For more information see {@link\n\t *         com.liferay.portal.model.GroupConstants}\n\t * @param  friendlyURL the group's friendlyURL (optionally\n\t *         <code>null<\/code>)\n\t * @param  site whether the group is to be associated with a main site\n\t * @param  active whether the group is active\n\t * @param  serviceContext the service context to be applied (optionally\n\t *         <code>null<\/code>). Can set asset category IDs and asset tag\n\t *         names for the group, and whether the group is for staging.\n\t * @return the group\n\t * @throws PortalException if a creator could not be found, if the group's\n\t *         information was invalid, if a layout could not be found, or if a\n\t *         valid friendly URL could not be created for the group\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Group addGroup(\n\t\t\tlong userId, long parentGroupId, String className, long classPK,\n\t\t\tlong liveGroupId, String name, String description, int type,\n\t\t\tString friendlyURL, boolean site, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Group\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tclassName = GetterUtil.getString(className);\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tString friendlyName = name;\n\n\t\tlong groupId = 0;\n\n\t\twhile (true) {\n\t\t\tgroupId = counterLocalService.increment();\n\n\t\t\tUser screenNameUser = userPersistence.fetchByC_SN(\n\t\t\t\tuser.getCompanyId(), String.valueOf(groupId));\n\n\t\t\tif (screenNameUser == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tboolean staging = isStaging(serviceContext);\n\n\t\tlong groupClassNameId = PortalUtil.getClassNameId(Group.class);\n\n\t\tif ((classNameId <= 0) || className.equals(Group.class.getName())) {\n\t\t\tclassName = Group.class.getName();\n\t\t\tclassNameId = groupClassNameId;\n\t\t\tclassPK = groupId;\n\t\t}\n\t\telse if (className.equals(Organization.class.getName())) {\n\t\t\tname = getOrgGroupName(classPK, name);\n\t\t}\n\t\telse if (!GroupConstants.USER_PERSONAL_SITE.equals(name)) {\n\t\t\tname = String.valueOf(classPK);\n\t\t}\n\n\t\tif (className.equals(Organization.class.getName()) && staging) {\n\t\t\tclassPK = liveGroupId;\n\t\t}\n\n\t\tif (className.equals(Layout.class.getName())) {\n\t\t\tLayout layout = layoutLocalService.getLayout(classPK);\n\n\t\t\tparentGroupId = layout.getGroupId();\n\t\t}\n\n\t\tfriendlyURL = getFriendlyURL(\n\t\t\tuser.getCompanyId(), groupId, classNameId, classPK, friendlyName,\n\t\t\tfriendlyURL);\n\n\t\tif (staging) {\n\t\t\tname = name.concat(\" (Staging)\");\n\t\t\tfriendlyURL = friendlyURL.concat(\"-staging\");\n\t\t}\n\n\t\tif (className.equals(Group.class.getName())) {\n\t\t\tif (!site && (liveGroupId == 0)) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\t\telse if (!className.equals(Organization.class.getName()) &&\n\t\t\t\t className.startsWith(\"com.liferay.portal.model.\")) {\n\n\t\t\tif (site) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\tif ((classNameId <= 0) || className.equals(Group.class.getName())) {\n\t\t\tvalidateName(groupId, user.getCompanyId(), name, site);\n\t\t}\n\n\t\tvalidateFriendlyURL(\n\t\t\tuser.getCompanyId(), groupId, classNameId, classPK, friendlyURL);\n\n\t\tGroup group = groupPersistence.create(groupId);\n\n\t\tgroup.setCompanyId(user.getCompanyId());\n\t\tgroup.setCreatorUserId(userId);\n\t\tgroup.setClassNameId(classNameId);\n\t\tgroup.setClassPK(classPK);\n\t\tgroup.setParentGroupId(parentGroupId);\n\t\tgroup.setLiveGroupId(liveGroupId);\n\t\tgroup.setName(name);\n\t\tgroup.setDescription(description);\n\t\tgroup.setType(type);\n\t\tgroup.setFriendlyURL(friendlyURL);\n\t\tgroup.setSite(site);\n\t\tgroup.setActive(active);\n\n\t\tif ((serviceContext != null) && (classNameId == groupClassNameId) &&\n\t\t\t!user.isDefaultUser()) {\n\n\t\t\tgroup.setExpandoBridgeAttributes(serviceContext);\n\t\t}\n\n\t\tgroupPersistence.update(group, false);\n\n\t\t// Layout sets\n\n\t\tlayoutSetLocalService.addLayoutSet(groupId, true);\n\n\t\tlayoutSetLocalService.addLayoutSet(groupId, false);\n\n\t\tif ((classNameId == groupClassNameId) && !user.isDefaultUser()) {\n\n\t\t\t// Resources\n\n\t\t\tresourceLocalService.addResources(\n\t\t\t\tgroup.getCompanyId(), 0, 0, Group.class.getName(),\n\t\t\t\tgroup.getGroupId(), false, false, false);\n\n\t\t\t// Site roles\n\n\t\t\tRole role = roleLocalService.getRole(\n\t\t\t\tgroup.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\t\tuserGroupRoleLocalService.addUserGroupRoles(\n\t\t\t\tuserId, groupId, new long[] {role.getRoleId()});\n\n\t\t\t// User\n\n\t\t\tuserLocalService.addGroupUsers(\n\t\t\t\tgroup.getGroupId(), new long[] {userId});\n\n\t\t\t// Asset\n\n\t\t\tif (serviceContext != null) {\n\t\t\t\tupdateAsset(\n\t\t\t\t\tuserId, group, serviceContext.getAssetCategoryIds(),\n\t\t\t\t\tserviceContext.getAssetTagNames());\n\t\t\t}\n\t\t}\n\t\telse if (className.equals(Organization.class.getName()) &&\n\t\t\t\t !user.isDefaultUser()) {\n\n\t\t\t// Resources\n\n\t\t\tresourceLocalService.addResources(\n\t\t\t\tgroup.getCompanyId(), 0, 0, Group.class.getName(),\n\t\t\t\tgroup.getGroupId(), false, false, false);\n\t\t}\n\n\t\treturn group;\n\t}","commit_id":"1aed0c438672d4200851ba3b802764c2efe2c0b1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Updates the group.\n\t *\n\t * @param  groupId the primary key of the group\n\t * @param  parentGroupId the primary key of the parent group\n\t * @param  name the group's new name\n\t * @param  description the group's new description (optionally\n\t *         <code>null<\/code>)\n\t * @param  type the group's new type. For more information see {@link\n\t *         com.liferay.portal.model.GroupConstants}\n\t * @param  friendlyURL the group's new friendlyURL (optionally\n\t *         <code>null<\/code>)\n\t * @param  active whether the group is active\n\t * @param  serviceContext the service context to be applied (optionally\n\t *         <code>null<\/code>). Can set asset category IDs and asset tag\n\t *         names for the group.\n\t * @return the group\n\t * @throws PortalException if a group with the primary key could not be\n\t *         found or if the friendly URL was invalid or could one not be\n\t *         created\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Group updateGroup(\n\t\t\tlong groupId, long parentGroupId, String name, String description,\n\t\t\tint type, String friendlyURL, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\tString className = group.getClassName();\n\t\tlong classNameId = group.getClassNameId();\n\t\tlong classPK = group.getClassPK();\n\t\tfriendlyURL = getFriendlyURL(\n\t\t\tgroup.getCompanyId(), groupId, classNameId, classPK,\n\t\t\tStringPool.BLANK, friendlyURL);\n\n\t\tif ((classNameId <= 0) || className.equals(Group.class.getName())) {\n\t\t\tvalidateName(\n\t\t\t\tgroup.getGroupId(), group.getCompanyId(), name, group.isSite());\n\t\t}\n\t\telse if (className.equals(Organization.class.getName())) {\n\t\t\tname = getOrgGroupName(classPK, name);\n\t\t}\n\t\telse if (!GroupConstants.USER_PERSONAL_SITE.equals(name)) {\n\t\t\tname = String.valueOf(classPK);\n\t\t}\n\n\t\tif (PortalUtil.isSystemGroup(group.getName()) &&\n\t\t\t!name.equals(group.getName())) {\n\n\t\t\tthrow new RequiredGroupException(\n\t\t\t\tString.valueOf(group.getGroupId()),\n\t\t\t\tRequiredGroupException.SYSTEM_GROUP);\n\t\t}\n\n\t\tvalidateFriendlyURL(\n\t\t\tgroup.getCompanyId(), group.getGroupId(), group.getClassNameId(),\n\t\t\tgroup.getClassPK(), friendlyURL);\n\n\t\tgroup.setParentGroupId(parentGroupId);\n\t\tgroup.setName(name);\n\t\tgroup.setDescription(description);\n\t\tgroup.setType(type);\n\t\tgroup.setFriendlyURL(friendlyURL);\n\t\tgroup.setActive(active);\n\n\t\tgroupPersistence.update(group, false);\n\n\t\tif ((serviceContext != null) && group.isSite()) {\n\n\t\t\t// Asset\n\n\t\t\tUser user = null;\n\n\t\t\ttry {\n\t\t\t\tuser = userPersistence.findByPrimaryKey(\n\t\t\t\t\tgroup.getCreatorUserId());\n\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue1) {\n\t\t\t\ttry {\n\t\t\t\t\tuser = userPersistence.findByPrimaryKey(\n\t\t\t\t\t\tserviceContext.getUserId());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchUserException nsue2) {\n\t\t\t\t\tuser = userLocalService.getDefaultUser(\n\t\t\t\t\t\tgroup.getCompanyId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tupdateAsset(\n\t\t\t\tuser.getUserId(), group, serviceContext.getAssetCategoryIds(),\n\t\t\t\tserviceContext.getAssetTagNames());\n\n\t\t\t// Expando\n\n\t\t\tgroup.setExpandoBridgeAttributes(serviceContext);\n\t\t}\n\n\t\treturn group;\n\t}","id":25563,"modified_method":"/**\n\t * Updates the group.\n\t *\n\t * @param  groupId the primary key of the group\n\t * @param  parentGroupId the primary key of the parent group\n\t * @param  name the group's new name\n\t * @param  description the group's new description (optionally\n\t *         <code>null<\/code>)\n\t * @param  type the group's new type. For more information see {@link\n\t *         com.liferay.portal.model.GroupConstants}\n\t * @param  friendlyURL the group's new friendlyURL (optionally\n\t *         <code>null<\/code>)\n\t * @param  active whether the group is active\n\t * @param  serviceContext the service context to be applied (optionally\n\t *         <code>null<\/code>). Can set asset category IDs and asset tag\n\t *         names for the group.\n\t * @return the group\n\t * @throws PortalException if a group with the primary key could not be\n\t *         found or if the friendly URL was invalid or could one not be\n\t *         created\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Group updateGroup(\n\t\t\tlong groupId, long parentGroupId, String name, String description,\n\t\t\tint type, String friendlyURL, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\tString className = group.getClassName();\n\t\tlong classNameId = group.getClassNameId();\n\t\tlong classPK = group.getClassPK();\n\t\tfriendlyURL = getFriendlyURL(\n\t\t\tgroup.getCompanyId(), groupId, classNameId, classPK,\n\t\t\tStringPool.BLANK, friendlyURL);\n\n\t\tif ((classNameId <= 0) || className.equals(Group.class.getName())) {\n\t\t\tvalidateName(\n\t\t\t\tgroup.getGroupId(), group.getCompanyId(), name, group.isSite());\n\t\t}\n\t\telse if (className.equals(Organization.class.getName())) {\n\t\t\tname = getOrgGroupName(classPK, name);\n\t\t}\n\t\telse if (!GroupConstants.USER_PERSONAL_SITE.equals(name)) {\n\t\t\tname = String.valueOf(classPK);\n\t\t}\n\n\t\tif (PortalUtil.isSystemGroup(group.getName()) &&\n\t\t\t!name.equals(group.getName())) {\n\n\t\t\tthrow new RequiredGroupException(\n\t\t\t\tString.valueOf(group.getGroupId()),\n\t\t\t\tRequiredGroupException.SYSTEM_GROUP);\n\t\t}\n\n\t\tvalidateFriendlyURL(\n\t\t\tgroup.getCompanyId(), group.getGroupId(), group.getClassNameId(),\n\t\t\tgroup.getClassPK(), friendlyURL);\n\n\t\tgroup.setParentGroupId(parentGroupId);\n\t\tgroup.setName(name);\n\t\tgroup.setDescription(description);\n\t\tgroup.setType(type);\n\t\tgroup.setFriendlyURL(friendlyURL);\n\t\tgroup.setActive(active);\n\n\t\tif ((serviceContext != null) && group.isSite()) {\n\t\t\tgroup.setExpandoBridgeAttributes(serviceContext);\n\t\t}\n\n\t\tgroupPersistence.update(group, false);\n\n\t\t// Asset\n\n\t\tif ((serviceContext != null) && group.isSite()) {\n\t\t\tUser user = null;\n\n\t\t\ttry {\n\t\t\t\tuser = userPersistence.findByPrimaryKey(\n\t\t\t\t\tgroup.getCreatorUserId());\n\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue1) {\n\t\t\t\ttry {\n\t\t\t\t\tuser = userPersistence.findByPrimaryKey(\n\t\t\t\t\t\tserviceContext.getUserId());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchUserException nsue2) {\n\t\t\t\t\tuser = userLocalService.getDefaultUser(\n\t\t\t\t\t\tgroup.getCompanyId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tupdateAsset(\n\t\t\t\tuser.getUserId(), group, serviceContext.getAssetCategoryIds(),\n\t\t\t\tserviceContext.getAssetTagNames());\n\t\t}\n\n\t\treturn group;\n\t}","commit_id":"1aed0c438672d4200851ba3b802764c2efe2c0b1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\tpublic DLFileEntry deleteFileVersion(\n\t\t\tlong userId, long fileEntryId, String version)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (Validator.isNull(version) ||\n\t\t\tversion.equals(DLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION)) {\n\n\t\t\tthrow new InvalidFileVersionException();\n\t\t}\n\n\t\tif (!hasFileEntryLock(userId, fileEntryId)) {\n\t\t\tlockFileEntry(userId, fileEntryId);\n\t\t}\n\n\t\tboolean latestVersion = false;\n\n\t\tDLFileEntry dlFileEntry = null;\n\n\t\ttry {\n\t\t\tDLFileVersion dlFileVersion = dlFileVersionPersistence.findByF_V(\n\t\t\t\tfileEntryId, version);\n\n\t\t\tif (!dlFileVersion.isApproved()) {\n\t\t\t\tthrow new InvalidFileVersionException(\n\t\t\t\t\t\"Cannot delete an unapproved file version\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint count = dlFileVersionPersistence.countByF_S(\n\t\t\t\t\tfileEntryId, WorkflowConstants.STATUS_APPROVED);\n\n\t\t\t\tif (count <= 1) {\n\t\t\t\t\tthrow new InvalidFileVersionException(\n\t\t\t\t\t\t\"Cannot delete the only approved file version\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlFileVersionPersistence.remove(dlFileVersion);\n\n\t\t\texpandoValueLocalService.deleteValues(\n\t\t\t\tDLFileVersion.class.getName(),\n\t\t\t\tdlFileVersion.getFileVersionId());\n\n\t\t\tdlFileEntry = dlFileEntryPersistence.findByPrimaryKey(fileEntryId);\n\n\t\t\tlatestVersion = version.equals(dlFileEntry.getVersion());\n\n\t\t\tif (latestVersion) {\n\t\t\t\ttry {\n\t\t\t\t\tDLFileVersion dlLatestFileVersion =\n\t\t\t\t\t\tdlFileVersionLocalService.getLatestFileVersion(\n\t\t\t\t\t\t\tdlFileEntry.getFileEntryId(), true);\n\n\t\t\t\t\tdlFileEntry.setVersionUserId(\n\t\t\t\t\t\tdlLatestFileVersion.getUserId());\n\t\t\t\t\tdlFileEntry.setVersionUserName(\n\t\t\t\t\t\tdlLatestFileVersion.getUserName());\n\t\t\t\t\tdlFileEntry.setModifiedDate(\n\t\t\t\t\t\tdlLatestFileVersion.getCreateDate());\n\t\t\t\t\tdlFileEntry.setExtension(\n\t\t\t\t\t\tdlLatestFileVersion.getExtension());\n\t\t\t\t\tdlFileEntry.setMimeType(dlLatestFileVersion.getMimeType());\n\t\t\t\t\tdlFileEntry.setTitle(dlLatestFileVersion.getTitle());\n\t\t\t\t\tdlFileEntry.setDescription(\n\t\t\t\t\t\tdlLatestFileVersion.getDescription());\n\t\t\t\t\tdlFileEntry.setExtraSettings(\n\t\t\t\t\t\tdlLatestFileVersion.getExtraSettings());\n\t\t\t\t\tdlFileEntry.setFileEntryTypeId(\n\t\t\t\t\t\tdlLatestFileVersion.getFileEntryTypeId());\n\t\t\t\t\tdlFileEntry.setVersion(dlLatestFileVersion.getVersion());\n\t\t\t\t\tdlFileEntry.setSize(dlLatestFileVersion.getSize());\n\n\t\t\t\t\tdlFileEntry = dlFileEntryPersistence.update(dlFileEntry);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileVersionException nsfve) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tDLStoreUtil.deleteFile(\n\t\t\t\t\tdlFileEntry.getCompanyId(),\n\t\t\t\t\tdlFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\t\t\tversion);\n\t\t\t}\n\t\t\tcatch (NoSuchModelException nsme) {\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tunlockFileEntry(fileEntryId);\n\t\t}\n\n\t\tif (latestVersion) {\n\t\t\treturn dlFileEntry;\n\t\t}\n\n\t\treturn null;\n\t}","id":25564,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\tpublic DLFileEntry deleteFileVersion(\n\t\t\tlong userId, long fileEntryId, String version)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (Validator.isNull(version) ||\n\t\t\tversion.equals(DLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION)) {\n\n\t\t\tthrow new InvalidFileVersionException();\n\t\t}\n\n\t\tif (!hasFileEntryLock(userId, fileEntryId)) {\n\t\t\tlockFileEntry(userId, fileEntryId);\n\t\t}\n\n\t\tboolean latestVersion = false;\n\n\t\tDLFileEntry dlFileEntry = null;\n\n\t\ttry {\n\t\t\tDLFileVersion dlFileVersion = dlFileVersionPersistence.findByF_V(\n\t\t\t\tfileEntryId, version);\n\n\t\t\tif (!dlFileVersion.isApproved()) {\n\t\t\t\tthrow new InvalidFileVersionException(\n\t\t\t\t\t\"Cannot delete an unapproved file version\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint count = dlFileVersionPersistence.countByF_S(\n\t\t\t\t\tfileEntryId, WorkflowConstants.STATUS_APPROVED);\n\n\t\t\t\tif (count <= 1) {\n\t\t\t\t\tthrow new InvalidFileVersionException(\n\t\t\t\t\t\t\"Cannot delete the only approved file version\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlFileVersionPersistence.remove(dlFileVersion);\n\n\t\t\texpandoValueLocalService.deleteValues(\n\t\t\t\tDLFileEntry.class.getName(), dlFileVersion.getFileVersionId());\n\n\t\t\tdlFileEntry = dlFileEntryPersistence.findByPrimaryKey(fileEntryId);\n\n\t\t\tlatestVersion = version.equals(dlFileEntry.getVersion());\n\n\t\t\tif (latestVersion) {\n\t\t\t\ttry {\n\t\t\t\t\tDLFileVersion dlLatestFileVersion =\n\t\t\t\t\t\tdlFileVersionLocalService.getLatestFileVersion(\n\t\t\t\t\t\t\tdlFileEntry.getFileEntryId(), true);\n\n\t\t\t\t\tdlFileEntry.setVersionUserId(\n\t\t\t\t\t\tdlLatestFileVersion.getUserId());\n\t\t\t\t\tdlFileEntry.setVersionUserName(\n\t\t\t\t\t\tdlLatestFileVersion.getUserName());\n\t\t\t\t\tdlFileEntry.setModifiedDate(\n\t\t\t\t\t\tdlLatestFileVersion.getCreateDate());\n\t\t\t\t\tdlFileEntry.setExtension(\n\t\t\t\t\t\tdlLatestFileVersion.getExtension());\n\t\t\t\t\tdlFileEntry.setMimeType(dlLatestFileVersion.getMimeType());\n\t\t\t\t\tdlFileEntry.setTitle(dlLatestFileVersion.getTitle());\n\t\t\t\t\tdlFileEntry.setDescription(\n\t\t\t\t\t\tdlLatestFileVersion.getDescription());\n\t\t\t\t\tdlFileEntry.setExtraSettings(\n\t\t\t\t\t\tdlLatestFileVersion.getExtraSettings());\n\t\t\t\t\tdlFileEntry.setFileEntryTypeId(\n\t\t\t\t\t\tdlLatestFileVersion.getFileEntryTypeId());\n\t\t\t\t\tdlFileEntry.setVersion(dlLatestFileVersion.getVersion());\n\t\t\t\t\tdlFileEntry.setSize(dlLatestFileVersion.getSize());\n\n\t\t\t\t\tdlFileEntry = dlFileEntryPersistence.update(dlFileEntry);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileVersionException nsfve) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tDLStoreUtil.deleteFile(\n\t\t\t\t\tdlFileEntry.getCompanyId(),\n\t\t\t\t\tdlFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\t\t\tversion);\n\t\t\t}\n\t\t\tcatch (NoSuchModelException nsme) {\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tunlockFileEntry(fileEntryId);\n\t\t}\n\n\t\tif (latestVersion) {\n\t\t\treturn dlFileEntry;\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"a5c5cbc86524042543af55d7fb3344c7b0149eca","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic DLFileEntry deleteFileEntry(DLFileEntry dlFileEntry)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tdlFileEntryPersistence.remove(dlFileEntry);\n\n\t\t// Resources\n\n\t\tresourceLocalService.deleteResource(\n\t\t\tdlFileEntry.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL, dlFileEntry.getFileEntryId());\n\n\t\t// WebDAVProps\n\n\t\twebDAVPropsLocalService.deleteWebDAVProps(\n\t\t\tDLFileEntry.class.getName(), dlFileEntry.getFileEntryId());\n\n\t\t// File entry metadata\n\n\t\tdlFileEntryMetadataLocalService.deleteFileEntryMetadata(\n\t\t\tdlFileEntry.getFileEntryId());\n\n\t\t// File versions\n\n\t\tList<DLFileVersion> dlFileVersions =\n\t\t\tdlFileVersionPersistence.findByFileEntryId(\n\t\t\t\tdlFileEntry.getFileEntryId());\n\n\t\tfor (DLFileVersion dlFileVersion : dlFileVersions) {\n\t\t\tdlFileVersionPersistence.remove(dlFileVersion);\n\n\t\t\texpandoValueLocalService.deleteValues(\n\t\t\t\tDLFileVersion.class.getName(),\n\t\t\t\tdlFileVersion.getFileVersionId());\n\n\t\t\tworkflowInstanceLinkLocalService.deleteWorkflowInstanceLinks(\n\t\t\t\tdlFileEntry.getCompanyId(), dlFileEntry.getGroupId(),\n\t\t\t\tDLFileEntry.class.getName(), dlFileVersion.getFileVersionId());\n\t\t}\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tDLFileEntry.class.getName(), dlFileEntry.getFileEntryId());\n\n\t\t// Lock\n\n\t\tunlockFileEntry(dlFileEntry.getFileEntryId());\n\n\t\t// File\n\n\t\ttry {\n\t\t\tDLStoreUtil.deleteFile(\n\t\t\t\tdlFileEntry.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\t\t}\n\n\t\treturn dlFileEntry;\n\t}","id":25565,"modified_method":"@Indexable(type = IndexableType.DELETE)\n\tpublic DLFileEntry deleteFileEntry(DLFileEntry dlFileEntry)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tdlFileEntryPersistence.remove(dlFileEntry);\n\n\t\t// Resources\n\n\t\tresourceLocalService.deleteResource(\n\t\t\tdlFileEntry.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL, dlFileEntry.getFileEntryId());\n\n\t\t// WebDAVProps\n\n\t\twebDAVPropsLocalService.deleteWebDAVProps(\n\t\t\tDLFileEntry.class.getName(), dlFileEntry.getFileEntryId());\n\n\t\t// File entry metadata\n\n\t\tdlFileEntryMetadataLocalService.deleteFileEntryMetadata(\n\t\t\tdlFileEntry.getFileEntryId());\n\n\t\t// File versions\n\n\t\tList<DLFileVersion> dlFileVersions =\n\t\t\tdlFileVersionPersistence.findByFileEntryId(\n\t\t\t\tdlFileEntry.getFileEntryId());\n\n\t\tfor (DLFileVersion dlFileVersion : dlFileVersions) {\n\t\t\tdlFileVersionPersistence.remove(dlFileVersion);\n\n\t\t\texpandoValueLocalService.deleteValues(\n\t\t\t\tDLFileEntry.class.getName(), dlFileVersion.getFileVersionId());\n\n\t\t\tworkflowInstanceLinkLocalService.deleteWorkflowInstanceLinks(\n\t\t\t\tdlFileEntry.getCompanyId(), dlFileEntry.getGroupId(),\n\t\t\t\tDLFileEntry.class.getName(), dlFileVersion.getFileVersionId());\n\t\t}\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tDLFileEntry.class.getName(), dlFileEntry.getFileEntryId());\n\n\t\t// Lock\n\n\t\tunlockFileEntry(dlFileEntry.getFileEntryId());\n\n\t\t// File\n\n\t\ttry {\n\t\t\tDLStoreUtil.deleteFile(\n\t\t\t\tdlFileEntry.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\t\t}\n\n\t\treturn dlFileEntry;\n\t}","commit_id":"a5c5cbc86524042543af55d7fb3344c7b0149eca","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLFileEntry checkOutFileEntry(\n\t\t\tlong userId, long fileEntryId, String owner, long expirationTime,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\tboolean hasLock = hasFileEntryLock(userId, fileEntryId);\n\n\t\tif (!hasLock) {\n\t\t\tif ((expirationTime <= 0) ||\n\t\t\t\t(expirationTime > DLFileEntryImpl.LOCK_EXPIRATION_TIME)) {\n\n\t\t\t\texpirationTime = DLFileEntryImpl.LOCK_EXPIRATION_TIME;\n\t\t\t}\n\n\t\t\tlockLocalService.lock(\n\t\t\t\tuserId, DLFileEntry.class.getName(), fileEntryId, owner, false,\n\t\t\t\texpirationTime);\n\t\t}\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tserviceContext.setCompanyId(user.getCompanyId());\n\n\t\tDLFileVersion dlFileVersion =\n\t\t\tdlFileVersionLocalService.getLatestFileVersion(fileEntryId, false);\n\n\t\tlong dlFileVersionId = dlFileVersion.getFileVersionId();\n\n\t\tExpandoBridge expandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\tserviceContext.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\tdlFileVersionId);\n\n\t\tserviceContext.setExpandoBridgeAttributes(\n\t\t\texpandoBridge.getAttributes());\n\t\tserviceContext.setUserId(userId);\n\n\t\tboolean manualCheckinRequired = GetterUtil.getBoolean(\n\t\t\tserviceContext.getAttribute(DL.MANUAL_CHECK_IN_REQUIRED));\n\n\t\tdlFileEntry.setManualCheckInRequired(manualCheckinRequired);\n\n\t\tdlFileEntryPersistence.update(dlFileEntry);\n\n\t\tString version = dlFileVersion.getVersion();\n\n\t\tif (!version.equals(\n\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION)) {\n\n\t\t\tlong existingDLFileVersionId = ParamUtil.getLong(\n\t\t\t\tserviceContext, \"existingDLFileVersionId\");\n\n\t\t\tif (existingDLFileVersionId > 0) {\n\t\t\t\tDLFileVersion existingDLFileVersion =\n\t\t\t\t\tdlFileVersionPersistence.findByPrimaryKey(\n\t\t\t\t\t\texistingDLFileVersionId);\n\n\t\t\t\tdlFileVersion = updateFileVersion(\n\t\t\t\t\tuser, existingDLFileVersion, null,\n\t\t\t\t\texistingDLFileVersion.getExtension(),\n\t\t\t\t\texistingDLFileVersion.getMimeType(),\n\t\t\t\t\texistingDLFileVersion.getTitle(),\n\t\t\t\t\texistingDLFileVersion.getDescription(),\n\t\t\t\t\texistingDLFileVersion.getChangeLog(),\n\t\t\t\t\texistingDLFileVersion.getExtraSettings(),\n\t\t\t\t\texistingDLFileVersion.getFileEntryTypeId(), null,\n\t\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION,\n\t\t\t\t\texistingDLFileVersion.getSize(),\n\t\t\t\t\tWorkflowConstants.STATUS_DRAFT, new Date(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong oldDLFileVersionId = dlFileVersion.getFileVersionId();\n\n\t\t\t\tdlFileVersion = addFileVersion(\n\t\t\t\t\tuser, dlFileEntry, new Date(), dlFileVersion.getExtension(),\n\t\t\t\t\tdlFileVersion.getMimeType(), dlFileVersion.getTitle(),\n\t\t\t\t\tdlFileVersion.getDescription(),\n\t\t\t\t\tdlFileVersion.getChangeLog(),\n\t\t\t\t\tdlFileVersion.getExtraSettings(),\n\t\t\t\t\tdlFileVersion.getFileEntryTypeId(), null,\n\t\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION,\n\t\t\t\t\tdlFileVersion.getSize(), WorkflowConstants.STATUS_DRAFT,\n\t\t\t\t\tserviceContext);\n\n\t\t\t\tcopyExpandoRowModifiedDate(\n\t\t\t\t\tdlFileEntry.getCompanyId(), oldDLFileVersionId,\n\t\t\t\t\tdlFileVersion.getFileVersionId());\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tDLStoreUtil.deleteFile(\n\t\t\t\t\tdlFileEntry.getCompanyId(),\n\t\t\t\t\tdlFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION);\n\t\t\t}\n\t\t\tcatch (NoSuchModelException nsme) {\n\t\t\t}\n\n\t\t\tDLStoreUtil.copyFileVersion(\n\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName(), version,\n\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION);\n\n\t\t\tcopyFileEntryMetadata(\n\t\t\t\tdlFileEntry.getCompanyId(), dlFileVersion.getFileEntryTypeId(),\n\t\t\t\tfileEntryId, dlFileVersionId, dlFileVersion.getFileVersionId(),\n\t\t\t\tserviceContext);\n\t\t}\n\n\t\tif (dlFileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tDLFolder dlFolder = dlFolderPersistence.findByPrimaryKey(\n\t\t\t\tdlFileEntry.getFolderId());\n\n\t\t\tdlFolder.setLastPostDate(dlFileVersion.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(dlFolder);\n\t\t}\n\n\t\treturn dlFileEntry;\n\t}","id":25566,"modified_method":"public DLFileEntry checkOutFileEntry(\n\t\t\tlong userId, long fileEntryId, String owner, long expirationTime,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\tboolean hasLock = hasFileEntryLock(userId, fileEntryId);\n\n\t\tif (!hasLock) {\n\t\t\tif ((expirationTime <= 0) ||\n\t\t\t\t(expirationTime > DLFileEntryImpl.LOCK_EXPIRATION_TIME)) {\n\n\t\t\t\texpirationTime = DLFileEntryImpl.LOCK_EXPIRATION_TIME;\n\t\t\t}\n\n\t\t\tlockLocalService.lock(\n\t\t\t\tuserId, DLFileEntry.class.getName(), fileEntryId, owner, false,\n\t\t\t\texpirationTime);\n\t\t}\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tserviceContext.setCompanyId(user.getCompanyId());\n\n\t\tDLFileVersion dlFileVersion =\n\t\t\tdlFileVersionLocalService.getLatestFileVersion(fileEntryId, false);\n\n\t\tlong dlFileVersionId = dlFileVersion.getFileVersionId();\n\n\t\tMap<String, Serializable> serviceContextExpandoValuesMap =\n\t\t\tserviceContext.getExpandoBridgeAttributes();\n\n\t\tif (serviceContextExpandoValuesMap.isEmpty()) {\n\t\t\tExpandoBridge expandoBridge =\n\t\t\t\tExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tserviceContext.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\t\t\tdlFileVersionId);\n\n\t\t\tserviceContext.setExpandoBridgeAttributes(\n\t\t\t\texpandoBridge.getAttributes());\n\t\t}\n\n\t\tserviceContext.setUserId(userId);\n\n\t\tboolean manualCheckinRequired = GetterUtil.getBoolean(\n\t\t\tserviceContext.getAttribute(DL.MANUAL_CHECK_IN_REQUIRED));\n\n\t\tdlFileEntry.setManualCheckInRequired(manualCheckinRequired);\n\n\t\tdlFileEntryPersistence.update(dlFileEntry);\n\n\t\tString version = dlFileVersion.getVersion();\n\n\t\tif (!version.equals(\n\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION)) {\n\n\t\t\tlong existingDLFileVersionId = ParamUtil.getLong(\n\t\t\t\tserviceContext, \"existingDLFileVersionId\");\n\n\t\t\tif (existingDLFileVersionId > 0) {\n\t\t\t\tDLFileVersion existingDLFileVersion =\n\t\t\t\t\tdlFileVersionPersistence.findByPrimaryKey(\n\t\t\t\t\t\texistingDLFileVersionId);\n\n\t\t\t\tdlFileVersion = updateFileVersion(\n\t\t\t\t\tuser, existingDLFileVersion, null,\n\t\t\t\t\texistingDLFileVersion.getExtension(),\n\t\t\t\t\texistingDLFileVersion.getMimeType(),\n\t\t\t\t\texistingDLFileVersion.getTitle(),\n\t\t\t\t\texistingDLFileVersion.getDescription(),\n\t\t\t\t\texistingDLFileVersion.getChangeLog(),\n\t\t\t\t\texistingDLFileVersion.getExtraSettings(),\n\t\t\t\t\texistingDLFileVersion.getFileEntryTypeId(), null,\n\t\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION,\n\t\t\t\t\texistingDLFileVersion.getSize(),\n\t\t\t\t\tWorkflowConstants.STATUS_DRAFT, new Date(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong oldDLFileVersionId = dlFileVersion.getFileVersionId();\n\n\t\t\t\tdlFileVersion = addFileVersion(\n\t\t\t\t\tuser, dlFileEntry, new Date(), dlFileVersion.getExtension(),\n\t\t\t\t\tdlFileVersion.getMimeType(), dlFileVersion.getTitle(),\n\t\t\t\t\tdlFileVersion.getDescription(),\n\t\t\t\t\tdlFileVersion.getChangeLog(),\n\t\t\t\t\tdlFileVersion.getExtraSettings(),\n\t\t\t\t\tdlFileVersion.getFileEntryTypeId(), null,\n\t\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION,\n\t\t\t\t\tdlFileVersion.getSize(), WorkflowConstants.STATUS_DRAFT,\n\t\t\t\t\tserviceContext);\n\n\t\t\t\tcopyExpandoRowModifiedDate(\n\t\t\t\t\tdlFileEntry.getCompanyId(), oldDLFileVersionId,\n\t\t\t\t\tdlFileVersion.getFileVersionId());\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tDLStoreUtil.deleteFile(\n\t\t\t\t\tdlFileEntry.getCompanyId(),\n\t\t\t\t\tdlFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION);\n\t\t\t}\n\t\t\tcatch (NoSuchModelException nsme) {\n\t\t\t}\n\n\t\t\tDLStoreUtil.copyFileVersion(\n\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName(), version,\n\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION);\n\n\t\t\tcopyFileEntryMetadata(\n\t\t\t\tdlFileEntry.getCompanyId(), dlFileVersion.getFileEntryTypeId(),\n\t\t\t\tfileEntryId, dlFileVersionId, dlFileVersion.getFileVersionId(),\n\t\t\t\tserviceContext);\n\t\t}\n\n\t\tif (dlFileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tDLFolder dlFolder = dlFolderPersistence.findByPrimaryKey(\n\t\t\t\tdlFileEntry.getFolderId());\n\n\t\t\tdlFolder.setLastPostDate(dlFileVersion.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(dlFolder);\n\t\t}\n\n\t\treturn dlFileEntry;\n\t}","commit_id":"a5c5cbc86524042543af55d7fb3344c7b0149eca","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void removeFileVersion(\n\t\t\tDLFileEntry dlFileEntry, DLFileVersion dlFileVersion)\n\t\tthrows PortalException, SystemException {\n\n\t\tdlFileVersionPersistence.remove(dlFileVersion);\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tDLFileVersion.class.getName(), dlFileVersion.getFileVersionId());\n\n\t\tdlFileEntryMetadataLocalService.deleteFileVersionFileEntryMetadata(\n\t\t\tdlFileVersion.getFileVersionId());\n\n\t\ttry {\n\t\t\tDLStoreUtil.deleteFile(\n\t\t\t\tdlFileEntry.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName(),\n\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION);\n\t\t}\n\t\tcatch (NoSuchModelException nsme) {\n\t\t}\n\n\t\tunlockFileEntry(dlFileEntry.getFileEntryId());\n\t}","id":25567,"modified_method":"protected void removeFileVersion(\n\t\t\tDLFileEntry dlFileEntry, DLFileVersion dlFileVersion)\n\t\tthrows PortalException, SystemException {\n\n\t\tdlFileVersionPersistence.remove(dlFileVersion);\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tDLFileEntry.class.getName(), dlFileVersion.getFileVersionId());\n\n\t\tdlFileEntryMetadataLocalService.deleteFileVersionFileEntryMetadata(\n\t\t\tdlFileVersion.getFileVersionId());\n\n\t\ttry {\n\t\t\tDLStoreUtil.deleteFile(\n\t\t\t\tdlFileEntry.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName(),\n\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION);\n\t\t}\n\t\tcatch (NoSuchModelException nsme) {\n\t\t}\n\n\t\tunlockFileEntry(dlFileEntry.getFileEntryId());\n\t}","commit_id":"a5c5cbc86524042543af55d7fb3344c7b0149eca","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static Result success()\n    {\n        return () -> System.exit( 0 );\n    }","id":25568,"modified_method":"private void success()\n    {\n        outsideWorld.exit( 0 );\n    }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( String[] args )\n    {\n        Path homeDir = Paths.get( System.getenv( \"NEO4J_HOME\" ) );\n        Path configDir = Paths.get( System.getenv( \"NEO4J_CONF\" ) );\n        boolean debug = System.getenv( \"NEO4J_DEBUG\" ) != null;\n\n        AdminTool tool = new AdminTool( CommandLocator.fromServiceLocator(), System.out::println, debug );\n        Result result = tool.execute( homeDir, configDir, args );\n        result.exit();\n    }","id":25569,"modified_method":"public static void main( String[] args )\n    {\n        Path homeDir = Paths.get( System.getenv( \"NEO4J_HOME\" ) );\n        Path configDir = Paths.get( System.getenv( \"NEO4J_CONF\" ) );\n        boolean debug = System.getenv( \"NEO4J_DEBUG\" ) != null;\n\n        new AdminTool( CommandLocator.fromServiceLocator(), new RealOutsideWorld(), debug )\n                .execute( homeDir, configDir, args );\n    }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Result execute( Path homeDir, Path configDir, String... args )\n    {\n        try\n        {\n            if ( args.length == 0 )\n            {\n                return badUsage( \"you must provide a command\" );\n            }\n            String name = args[0];\n            String[] commandArgs = Arrays.copyOfRange( args, 1, args.length );\n\n            AdminCommand.Provider provider;\n            try\n            {\n                provider = locator.findProvider( name );\n            }\n            catch ( NoSuchElementException e )\n            {\n                return badUsage( format( \"unrecognized command: %s\", name ) );\n            }\n\n            AdminCommand command = provider.create( homeDir, configDir );\n            try\n            {\n                command.execute( commandArgs );\n                return success();\n            }\n            catch ( IncorrectUsage e )\n            {\n                return badUsage( provider, e );\n            }\n            catch ( CommandFailed e )\n            {\n                return failure( e );\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            return unexpected( e );\n        }\n    }","id":25570,"modified_method":"public void execute( Path homeDir, Path configDir, String... args )\n    {\n        try\n        {\n            if ( args.length == 0 )\n            {\n                badUsage( \"you must provide a command\" );\n                return;\n            }\n            String name = args[0];\n            String[] commandArgs = Arrays.copyOfRange( args, 1, args.length );\n\n            AdminCommand.Provider provider;\n            try\n            {\n                provider = locator.findProvider( name );\n            }\n            catch ( NoSuchElementException e )\n            {\n                badUsage( format( \"unrecognized command: %s\", name ) );\n                return;\n            }\n\n            AdminCommand command = provider.create( homeDir, configDir );\n            try\n            {\n                command.execute( commandArgs );\n                success();\n            }\n            catch ( IncorrectUsage e )\n            {\n                badUsage( provider, e );\n            }\n            catch ( CommandFailed e )\n            {\n                commandFailed( e );\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            unexpected( e );\n        }\n    }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Result unexpected( RuntimeException e )\n    {\n        return failure( e, \"unexpected error: \" + e.getMessage() );\n    }","id":25571,"modified_method":"private void unexpected( RuntimeException e )\n    {\n        failure( \"unexpected error\", e );\n    }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Result badUsage( String message )\n    {\n        usage.print();\n        return failure( message );\n    }","id":25572,"modified_method":"private void badUsage( String message )\n    {\n        usage.print();\n        failure( message );\n    }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Result badUsage( AdminCommand.Provider command, IncorrectUsage e )\n    {\n        new Usage.CommandUsage( command, out, scriptName ).print();\n        return failure( e.getMessage() );\n    }","id":25573,"modified_method":"private void badUsage( AdminCommand.Provider command, IncorrectUsage e )\n    {\n        new Usage.CommandUsage( command, outsideWorld, scriptName ).print();\n        failure( e.getMessage() );\n    }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"public AdminTool( CommandLocator locator, Output out, boolean debug )\n    {\n        this.locator = CommandLocator.withAdditionalCommand( help(), locator );\n        this.out = out;\n        this.debug = debug;\n        this.usage = new Usage( scriptName, out, this.locator );\n    }","id":25574,"modified_method":"public AdminTool( CommandLocator locator, OutsideWorld outsideWorld, boolean debug )\n    {\n        this.locator = CommandLocator.withAdditionalCommand( help(), locator );\n        this.outsideWorld = outsideWorld;\n        this.debug = debug;\n        this.usage = new Usage( scriptName, outsideWorld, this.locator );\n    }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static Result failure( String message )\n    {\n        return () -> {\n            System.err.println( message );\n            System.exit( 1 );\n        };\n    }","id":25575,"modified_method":"private void failure( String message )\n    {\n        outsideWorld.stdOutLine( message );\n        outsideWorld.exit( 1 );\n    }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAddTheHelpCommand()\n    {\n        Output output = mock( Output.class );\n        new AdminTool( new NullCommandLocator(), output, false ).execute( null, null, \"help\" );\n        verify( output ).line( \"neo4j-admin help\" );\n    }","id":25576,"modified_method":"@Test\n    public void shouldAddTheHelpCommandToThoseProvidedByTheLocator()\n    {\n        OutsideWorld outsideWorld = mock( OutsideWorld.class );\n        new AdminTool( new NullCommandLocator(), outsideWorld, false ).execute( null, null, \"help\" );\n        verify( outsideWorld ).stdOutLine( \"neo4j-admin help\" );\n    }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldProvideErrorMessageWhenNoCommandIsProvided()\n    {\n        Output output = mock( Output.class );\n        new AdminTool( new NullCommandLocator(), output, false ).execute( null, null, new String[]{} );\n\n        verify( output ).line( \"Usage:\" );\n    }","id":25577,"modified_method":"@Test\n    public void shouldPrintUsageWhenNoCommandIsProvided()\n    {\n        OutsideWorld outsideWorld = mock( OutsideWorld.class );\n        new AdminTool( new NullCommandLocator(), outsideWorld, false ).execute( null, null );\n        verify( outsideWorld ).stdOutLine( \"Usage:\" );\n    }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldExecuteTheCommand()\n    {\n        RecordingCommand command = new RecordingCommand();\n        AdminCommand.Provider provider = command.provider();\n        AdminTool tool = new AdminTool( new CannedLocator( provider ), new NullOutput(), false );\n        tool.execute( null, null, provider.name() );\n        assertThat( command.executed, is( true ) );\n    }","id":25578,"modified_method":"@Test\n    public void shouldExecuteTheCommand()\n    {\n        RecordingCommand command = new RecordingCommand();\n        AdminCommand.Provider provider = command.provider();\n        AdminTool tool = new AdminTool( new CannedLocator( provider ), new NullOutsideWorld(), false );\n        tool.execute( null, null, provider.name() );\n        assertThat( command.executed, is( true ) );\n    }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Usage( String scriptName, Output out, CommandLocator commands )\n    {\n        this.scriptName = scriptName;\n        this.out = out;\n        this.commands = commands;\n    }","id":25579,"modified_method":"public Usage( String scriptName, OutsideWorld out, CommandLocator commands )\n    {\n        this.scriptName = scriptName;\n        this.out = out;\n        this.commands = commands;\n    }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void print()\n        {\n            String arguments = command.arguments().map( ( s ) -> \" \" + s ).orElse( \"\" );\n            out.line( format( \"%s %s%s\", scriptName, command.name(), arguments ) );\n            out.line( \"\" );\n            for ( String line : splitLongLine( command.description(), 80 ) )\n            {\n                out.line( \"    \" + line );\n            }\n            out.line( \"\" );\n        }","id":25580,"modified_method":"public void print()\n        {\n            String arguments = command.arguments().map( ( s ) -> \" \" + s ).orElse( \"\" );\n            out.stdOutLine( format( \"%s %s%s\", scriptName, command.name(), arguments ) );\n            out.stdOutLine( \"\" );\n            for ( String line : splitLongLine( command.description(), 80 ) )\n            {\n                out.stdOutLine( \"    \" + line );\n            }\n            out.stdOutLine( \"\" );\n        }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"public CommandUsage( AdminCommand.Provider command, Output out, String scriptName )\n        {\n            this.command = command;\n            this.out = out;\n            this.scriptName = scriptName;\n        }","id":25581,"modified_method":"public CommandUsage( AdminCommand.Provider command, OutsideWorld out, String scriptName )\n        {\n            this.command = command;\n            this.out = out;\n            this.scriptName = scriptName;\n        }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void print()\n    {\n        out.line( \"Usage:\" );\n        out.line( \"\" );\n\n        for ( AdminCommand.Provider command : commands.getAllProviders() )\n        {\n            new CommandUsage( command, out, scriptName ).print();\n        }\n    }","id":25582,"modified_method":"public void print()\n    {\n        out.stdOutLine( \"Usage:\" );\n        out.stdOutLine( \"\" );\n\n        for ( AdminCommand.Provider command : commands.getAllProviders() )\n        {\n            new CommandUsage( command, out, scriptName ).print();\n        }\n    }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldPrintUsageForAllCommands()\n    {\n        Output out = mock( Output.class );\n\n        AdminCommand.Provider[] commands = new AdminCommand.Provider[]\n                {\n                        new StubProvider( \"restore\",\n                                Optional.of( \"---from <backup-directory> --database=<database-name> [--force]\" ),\n                                \"Restores a database backed up using the neo4j-backup tool.\" ),\n                        new StubProvider( \"bam\", Optional.empty(), \"Some description\" )\n                };\n        new Usage( \"neo4j-admin\", out, new CannedLocator( commands ) ).print();\n\n        InOrder ordered = inOrder( out );\n        ordered.verify( out ).line( \"Usage:\" );\n        ordered.verify( out ).line( \"\" );\n        ordered.verify( out )\n                .line( \"neo4j-admin restore ---from <backup-directory> --database=<database-name> [--force]\" );\n        ordered.verify( out ).line( \"\" );\n        ordered.verify( out ).line( \"    Restores a database backed up using the neo4j-backup tool.\" );\n        ordered.verify( out ).line( \"\" );\n        ordered.verify( out ).line( \"neo4j-admin bam\" );\n        ordered.verify( out ).line( \"\" );\n        ordered.verify( out ).line( \"    Some description\" );\n        ordered.verify( out ).line( \"\" );\n        ordered.verifyNoMoreInteractions();\n    }","id":25583,"modified_method":"@Test\n    public void shouldPrintUsageForAllCommands()\n    {\n        OutsideWorld out = mock( OutsideWorld.class );\n\n        AdminCommand.Provider[] commands = new AdminCommand.Provider[]\n                {\n                        new StubProvider( \"restore\",\n                                Optional.of( \"---from <backup-directory> --database=<database-name> [--force]\" ),\n                                \"Restores a database backed up using the neo4j-backup tool.\" ),\n                        new StubProvider( \"bam\", Optional.empty(), \"Some description\" )\n                };\n        new Usage( \"neo4j-admin\", out, new CannedLocator( commands ) ).print();\n\n        InOrder ordered = inOrder( out );\n        ordered.verify( out ).stdOutLine( \"Usage:\" );\n        ordered.verify( out ).stdOutLine( \"\" );\n        ordered.verify( out )\n                .stdOutLine( \"neo4j-admin restore ---from <backup-directory> --database=<database-name> [--force]\" );\n        ordered.verify( out ).stdOutLine( \"\" );\n        ordered.verify( out ).stdOutLine( \"    Restores a database backed up using the neo4j-backup tool.\" );\n        ordered.verify( out ).stdOutLine( \"\" );\n        ordered.verify( out ).stdOutLine( \"neo4j-admin bam\" );\n        ordered.verify( out ).stdOutLine( \"\" );\n        ordered.verify( out ).stdOutLine( \"    Some description\" );\n        ordered.verify( out ).stdOutLine( \"\" );\n        ordered.verifyNoMoreInteractions();\n    }","commit_id":"ad3e0fe75d5d202d80e4d804a60fad1100aca308","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void checkMethodNameDependency(InspectionManager manager, PsiClass psiClass, String methodName, PsiNameValuePair dep, List<ProblemDescriptor> problemDescriptors) {\n        LOGGER.debug(\"Found dependsOnMethods with text: \" + methodName);\n        if (methodName.length() > 0 && methodName.charAt(methodName.length() - 1) == ')') {\n\n            LOGGER.debug(\"dependsOnMethods contains ()\" + psiClass.getName());\n            // TODO Add quick fix for removing brackets on annotation\n            ProblemDescriptor descriptor = manager.createProblemDescriptor(dep,\n                                                               \"Method '\" + methodName + \"' should not include () characters.\",\n                                                               (LocalQuickFix) null,\n                                                               ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n\n            problemDescriptors.add(descriptor);\n\n        } else {\n            boolean methodExists = false;\n            PsiMethod[] methods = psiClass.getMethods();\n            PsiMethod foundMethod = null;\n            for (PsiMethod method : methods) {\n                LOGGER.debug(\"Checking method with name: \" + method.getName());\n                if (method.getName().equals(methodName)) {\n                    methodExists = true;\n                    break;\n                }\n            }\n\n            if (!methodExists) {\n                LOGGER.debug(\"dependsOnMethods method doesn't exist:\" + methodName);\n                ProblemDescriptor descriptor = manager.createProblemDescriptor(dep,\n                                                                   \"Method '\" + methodName + \"' unknown.\",\n                                                                   (LocalQuickFix) null,\n                                                                   ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n                problemDescriptors.add(descriptor);\n\n            } else if(foundMethod != null && !TestNGUtil.hasTest(foundMethod) && !!TestNGUtil.hasConfig(foundMethod)) {\n                ProblemDescriptor descriptor = manager.createProblemDescriptor(dep,\n                                                                   \"Method '\" + methodName + \"' is not a test or configuration method.\",\n                                                                   (LocalQuickFix) null,\n                                                                   ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n                problemDescriptors.add(descriptor);\n            }\n        }\n    }","id":25584,"modified_method":"private static void checkMethodNameDependency(InspectionManager manager, PsiClass psiClass, String methodName, PsiNameValuePair dep, List<ProblemDescriptor> problemDescriptors) {\n        LOGGER.debug(\"Found dependsOnMethods with text: \" + methodName);\n        if (methodName.length() > 0 && methodName.charAt(methodName.length() - 1) == ')') {\n\n            LOGGER.debug(\"dependsOnMethods contains ()\" + psiClass.getName());\n            // TODO Add quick fix for removing brackets on annotation\n            ProblemDescriptor descriptor = manager.createProblemDescriptor(dep,\n                                                               \"Method '\" + methodName + \"' should not include () characters.\",\n                                                               (LocalQuickFix) null,\n                                                               ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n\n            problemDescriptors.add(descriptor);\n\n        } else {\n            PsiMethod[] foundMethods = psiClass.findMethodsByName(methodName, true);\n\n            if (foundMethods.length == 0) {\n                LOGGER.debug(\"dependsOnMethods method doesn't exist:\" + methodName);\n                ProblemDescriptor descriptor = manager.createProblemDescriptor(dep,\n                                                                   \"Method '\" + methodName + \"' unknown.\",\n                                                                   (LocalQuickFix) null,\n                                                                   ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n                problemDescriptors.add(descriptor);\n\n            } else {\n              boolean hasTestsOrConfigs = false;\n              for (PsiMethod foundMethod : foundMethods) {\n                 hasTestsOrConfigs |= TestNGUtil.hasTest(foundMethod) || TestNGUtil.hasConfig(foundMethod);\n              }\n              if (!hasTestsOrConfigs) {\n                ProblemDescriptor descriptor = manager.createProblemDescriptor(dep,\n                                                                     \"Method '\" + methodName + \"' is not a test or configuration method.\",\n                                                                     (LocalQuickFix) null,\n                                                                     ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n                problemDescriptors.add(descriptor);\n              }\n            }\n        }\n    }","commit_id":"9d83cd7f920c40d1c7485298c710baba197ce83d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Filter the specified collection of classes to return only ones that contain any of the specified values in the\n     * specified annotation parameter. For example, this method can be used to return all classes that contain all tesng\n     * annotations that are in the groups 'foo' or 'bar'.\n     */\n    public static Map<PsiClass, Collection<PsiMethod>> filterAnnotations(String parameter, Set<String> values, PsiClass[] classes) {\n        Map<PsiClass, Collection<PsiMethod>> results = new HashMap<PsiClass, Collection<PsiMethod>>();\n        Set<String> test = new HashSet<String>(1);\n        test.add(TEST_ANNOTATION_FQN);\n        test.addAll(Arrays.asList(CONFIG_ANNOTATIONS_FQN));\n        for (PsiClass psiClass : classes) {\n            //Ignore these, they cause an NPE inside of AnnotationUtil, at least up until IDEA 6.0.2\n            if (psiClass instanceof PsiAnonymousClass) continue;\n            PsiAnnotation annotation = AnnotationUtil.findAnnotation(psiClass, test);\n            if (annotation != null) {\n                PsiNameValuePair[] pair = annotation.getParameterList().getAttributes();\n                OUTER:\n                for (PsiNameValuePair aPair : pair) {\n                    if (parameter.equals(aPair.getName())) {\n                        Collection<String> matches = extractValuesFromParameter(aPair);\n                        //check if any matches are in our values\n                        for (String s : matches) {\n                            if (values.contains(s)) {\n\n                                results.put(psiClass, new HashSet<PsiMethod>());\n                                break OUTER;\n                            }\n                        }\n                    }\n                }\n            } else {\n                Collection<String> matches = extractAnnotationValuesFromJavaDoc(getTextJavaDoc(psiClass), parameter);\n                for (String s : matches) {\n                    if (values.contains(s)) {\n                        results.put(psiClass, new HashSet<PsiMethod>());\n                        break;\n                    }\n                }\n            }\n\n            //we already have the class, no need to look through its methods\n            PsiMethod[] methods = psiClass.getMethods();\n            for (PsiMethod method : methods) {\n                annotation = AnnotationUtil.findAnnotation(method, test);\n                if (annotation != null) {\n                    PsiNameValuePair[] pair = annotation.getParameterList().getAttributes();\n                    OUTER:\n                    for (PsiNameValuePair aPair : pair) {\n                        if (parameter.equals(aPair.getName())) {\n                            Collection<String> matches = extractValuesFromParameter(aPair);\n                            for (String s : matches) {\n                                if (values.contains(s)) {\n                                    if (results.get(psiClass) == null) results.put(psiClass, new HashSet<PsiMethod>());\n                                    results.get(psiClass).add(method);\n                                    break OUTER;\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    Collection<String> matches = extractAnnotationValuesFromJavaDoc(getTextJavaDoc(psiClass), parameter);\n                    for (String s : matches) {\n                        if (values.contains(s)) {\n                            results.get(psiClass).add(method);\n                        }\n                    }\n                }\n            }\n        }\n        return results;\n    }","id":25585,"modified_method":"/**\n     * Filter the specified collection of classes to return only ones that contain any of the specified values in the\n     * specified annotation parameter. For example, this method can be used to return all classes that contain all tesng\n     * annotations that are in the groups 'foo' or 'bar'.\n     */\n    public static Map<PsiClass, Collection<PsiMethod>> filterAnnotations(String parameter, Set<String> values, PsiClass[] classes) {\n        Map<PsiClass, Collection<PsiMethod>> results = new HashMap<PsiClass, Collection<PsiMethod>>();\n        Set<String> test = new HashSet<String>(1);\n        test.add(TEST_ANNOTATION_FQN);\n        test.addAll(Arrays.asList(CONFIG_ANNOTATIONS_FQN));\n        for (PsiClass psiClass : classes) {\n            //Ignore these, they cause an NPE inside of AnnotationUtil, at least up until IDEA 6.0.2\n            if (psiClass == null || psiClass instanceof PsiAnonymousClass) continue;\n            PsiAnnotation annotation = AnnotationUtil.findAnnotation(psiClass, test);\n            if (annotation != null) {\n                PsiNameValuePair[] pair = annotation.getParameterList().getAttributes();\n                OUTER:\n                for (PsiNameValuePair aPair : pair) {\n                    if (parameter.equals(aPair.getName())) {\n                        Collection<String> matches = extractValuesFromParameter(aPair);\n                        //check if any matches are in our values\n                        for (String s : matches) {\n                            if (values.contains(s)) {\n\n                                results.put(psiClass, new HashSet<PsiMethod>());\n                                break OUTER;\n                            }\n                        }\n                    }\n                }\n            } else {\n                Collection<String> matches = extractAnnotationValuesFromJavaDoc(getTextJavaDoc(psiClass), parameter);\n                for (String s : matches) {\n                    if (values.contains(s)) {\n                        results.put(psiClass, new HashSet<PsiMethod>());\n                        break;\n                    }\n                }\n            }\n\n            //we already have the class, no need to look through its methods\n            PsiMethod[] methods = psiClass.getMethods();\n            for (PsiMethod method : methods) {\n                if (method != null) {\n                    annotation = AnnotationUtil.findAnnotation(method, test);\n                    if (annotation != null) {\n                        PsiNameValuePair[] pair = annotation.getParameterList().getAttributes();\n                        OUTER:\n                        for (PsiNameValuePair aPair : pair) {\n                            if (parameter.equals(aPair.getName())) {\n                                Collection<String> matches = extractValuesFromParameter(aPair);\n                                for (String s : matches) {\n                                    if (values.contains(s)) {\n                                        if (results.get(psiClass) == null) results.put(psiClass, new HashSet<PsiMethod>());\n                                        results.get(psiClass).add(method);\n                                        break OUTER;\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        Collection<String> matches = extractAnnotationValuesFromJavaDoc(getTextJavaDoc(psiClass), parameter);\n                        for (String s : matches) {\n                            if (values.contains(s)) {\n                                results.get(psiClass).add(method);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return results;\n    }","commit_id":"cb3e66e33bc4883491d3e6bb4b989d421b2f7b6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Set<String> getAnnotationValues(String parameter, PsiClass... classes) {\n        Set<String> results = new HashSet<String>();\n        Set<String> test = new HashSet<String>(1);\n        test.add(TEST_ANNOTATION_FQN);\n        test.addAll(Arrays.asList(CONFIG_ANNOTATIONS_FQN));\n        for (PsiClass psiClass : classes) {\n            if (hasTest(psiClass)) {\n                PsiAnnotation annotation = AnnotationUtil.findAnnotation(psiClass, test);\n                if (annotation != null) {\n                    PsiNameValuePair[] pair = annotation.getParameterList().getAttributes();\n                    for (PsiNameValuePair aPair : pair) {\n                        if (parameter.equals(aPair.getName())) {\n                            results.addAll(extractValuesFromParameter(aPair));\n                        }\n                    }\n                } else {\n                    results.addAll(extractAnnotationValuesFromJavaDoc(getTextJavaDoc(psiClass), parameter));\n                }\n\n                PsiMethod[] methods = psiClass.getMethods();\n                for (PsiMethod method : methods) {\n                    annotation = AnnotationUtil.findAnnotation(method, test);\n                    if (annotation != null) {\n                        PsiNameValuePair[] pair = annotation.getParameterList().getAttributes();\n                        for (PsiNameValuePair aPair : pair) {\n                            if (parameter.equals(aPair.getName())) {\n                                results.addAll(extractValuesFromParameter(aPair));\n                            }\n                        }\n                    } else {\n                        results.addAll(extractAnnotationValuesFromJavaDoc(getTextJavaDoc(method), parameter));\n                    }\n                }\n            }\n        }\n        return results;\n    }","id":25586,"modified_method":"public static Set<String> getAnnotationValues(String parameter, PsiClass... classes) {\n        Set<String> results = new HashSet<String>();\n        Set<String> test = new HashSet<String>(1);\n        test.add(TEST_ANNOTATION_FQN);\n        test.addAll(Arrays.asList(CONFIG_ANNOTATIONS_FQN));\n        for (PsiClass psiClass : classes) {\n            if (psiClass != null && hasTest(psiClass)) {\n                PsiAnnotation annotation = AnnotationUtil.findAnnotation(psiClass, test);\n                if (annotation != null) {\n                    PsiNameValuePair[] pair = annotation.getParameterList().getAttributes();\n                    for (PsiNameValuePair aPair : pair) {\n                        if (parameter.equals(aPair.getName())) {\n                            results.addAll(extractValuesFromParameter(aPair));\n                        }\n                    }\n                } else {\n                    results.addAll(extractAnnotationValuesFromJavaDoc(getTextJavaDoc(psiClass), parameter));\n                }\n\n                PsiMethod[] methods = psiClass.getMethods();\n                for (PsiMethod method : methods) {\n                    if (method != null) {\n                        annotation = AnnotationUtil.findAnnotation(method, test);\n                        if (annotation != null) {\n                            PsiNameValuePair[] pair = annotation.getParameterList().getAttributes();\n                            for (PsiNameValuePair aPair : pair) {\n                                if (parameter.equals(aPair.getName())) {\n                                    results.addAll(extractValuesFromParameter(aPair));\n                                }\n                            }\n                        } else {\n                            results.addAll(extractAnnotationValuesFromJavaDoc(getTextJavaDoc(method), parameter));\n                        }\n                    }\n                }\n            }\n        }\n        return results;\n    }","commit_id":"cb3e66e33bc4883491d3e6bb4b989d421b2f7b6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    public PsiElement resolve() {\n      @NonNls String val = getValue();\n      final String methodName = StringUtil.getShortName(val);\n      PsiClass cls = getDependsClass(val);\n      if (cls != null) {\n        PsiMethod[] methods = cls.findMethodsByName(methodName, true);\n        for (PsiMethod method : methods) {\n          if (TestNGUtil.hasTest(method)) {\n            return method;\n          }\n        }\n      }\n      return null;\n    }","id":25587,"modified_method":"@Nullable\n    public PsiElement resolve() {\n      @NonNls String val = getValue();\n      final String methodName = StringUtil.getShortName(val);\n      PsiClass cls = getDependsClass(val);\n      if (cls != null) {\n        PsiMethod[] methods = cls.findMethodsByName(methodName, true);\n        for (PsiMethod method : methods) {\n          if (TestNGUtil.hasTest(method) || TestNGUtil.hasConfig(method)) {\n            return method;\n          }\n        }\n      }\n      return null;\n    }","commit_id":"1804dcccad021d0e96791c58b721601a811a37dc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void refreshFileSynchronously(IFile modelFile) {\n    LocalFileSystem.getInstance().refreshAndFindFileByIoFile(modelFile.toFile());\n  }","id":25588,"modified_method":"public static VirtualFile refreshFileSynchronously(IFile modelFile) {\n    VirtualFile file = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(modelFile.toFile());\n    if (file != null) {\n      file.refresh(true, false);\n    }\n    return file;\n  }","commit_id":"39ae185ef3de5f4fb0e1add6a772f779722918fd","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String loadTemplate(@NotNull final ClassLoader loader,\n                                    @NotNull final String templateName,\n                                    @Nullable final Map<String, String> variables) throws IOException {\n    final InputStream stream = loader.getResourceAsStream(templateName);\n    if (stream == null) {\n      throw new IOException(\"Template '\" + templateName + \"' not found by \" + loader);\n    }\n\n    final String template = FileUtil.loadTextAndClose(stream);\n    if (variables == null || variables.size() == 0) {\n      return template;\n    }\n\n    final StringBuilder buffer = new StringBuilder(template);\n    for (Map.Entry<String, String> var : variables.entrySet()) {\n      final String name = var.getKey();\n      final int pos = buffer.indexOf(name);\n      if (pos >= 0) {\n        buffer.replace(pos, pos + name.length(), var.getValue());\n      }\n    }\n    return buffer.toString();\n  }","id":25589,"modified_method":"public static String loadTemplate(@NotNull final ClassLoader loader,\n                                    @NotNull final String templateName,\n                                    @Nullable final Map<String, String> variables) throws IOException {\n    @SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\") final InputStream stream = loader.getResourceAsStream(templateName);\n    if (stream == null) {\n      throw new IOException(\"Template '\" + templateName + \"' not found by \" + loader);\n    }\n\n    final String template = FileUtil.loadTextAndClose(stream);\n    if (variables == null || variables.size() == 0) {\n      return template;\n    }\n\n    final StringBuilder buffer = new StringBuilder(template);\n    for (Map.Entry<String, String> var : variables.entrySet()) {\n      final String name = var.getKey();\n      final int pos = buffer.indexOf(name);\n      if (pos >= 0) {\n        buffer.replace(pos, pos + name.length(), var.getValue());\n      }\n    }\n    return buffer.toString();\n  }","commit_id":"e6a53e548252a83a2f6d1b2f0a30bacbd3a89c9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Bombed(month = 12, day = 13, user = \"roman.shevchenko\")\n  public void testHardLinks() throws Exception {\n    if (SystemInfo.isWindows) {\n      File dir = FileUtil.createTempDirectory(\"hardlinks\", \"\");\n      File oldfile = new File(dir, \"oldfile\");\n      assertTrue(oldfile.createNewFile());\n      File newfile = new File(dir, \"newfile\");\n      Process process = Runtime.getRuntime().exec(\n        new String[]{\"fsutil\", \"hardlink\", \"create\", '\"' + newfile.getPath() + '\"', '\"' + oldfile.getPath() + '\"'});\n      InputStream stream = process.getInputStream();\n      System.out.println(new String(FileUtil.loadBytes(stream)));\n      process.waitFor();\n      VirtualFile file = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(oldfile);\n      assertNotNull(file);\n      file.setBinaryContent(\"hello\".getBytes(), 0, 0, new SafeWriteRequestor() {});\n      VirtualFile check = LocalFileSystem.getInstance().findFileByIoFile(newfile);\n      assertNotNull(check);\n      assertEquals(\"hello\", VfsUtil.loadText(check));\n    }\n  }","id":25590,"modified_method":"public void testHardLinks() throws Exception {\n    if (!SystemInfo.isWindows && !SystemInfo.isUnix) return;\n\n    final boolean safeWrite = GeneralSettings.getInstance().isUseSafeWrite();\n    final File dir = FileUtil.createTempDirectory(\"hardlinks\", \"\");\n    try {\n      GeneralSettings.getInstance().setUseSafeWrite(false);\n\n      final File targetFile = new File(dir, \"targetFile\");\n      assertTrue(targetFile.createNewFile());\n      final File hardLinkFile = new File(dir, \"hardLinkFile\");\n\n      if (SystemInfo.isWindows) {\n        assertEquals(\"target=\" + targetFile + \" link=\" + hardLinkFile,\n                     0, ExecUtil.execAndGetResult(\"fsutil\", \"hardlink\", \"create\", hardLinkFile.getPath(), targetFile.getPath()));\n      }\n      else if (SystemInfo.isUnix) {\n        assertEquals(\"target=\" + targetFile + \" link=\" + hardLinkFile,\n                     0, ExecUtil.execAndGetResult(\"ln\", targetFile.getPath(), hardLinkFile.getPath()));\n      }\n\n      final VirtualFile file = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(targetFile);\n      assertNotNull(file);\n      file.setBinaryContent(\"hello\".getBytes(), 0, 0, new SafeWriteRequestor() {});\n\n      final VirtualFile check = LocalFileSystem.getInstance().findFileByIoFile(hardLinkFile);\n      assertNotNull(check);\n      assertEquals(\"hello\", VfsUtil.loadText(check));\n    }\n    finally {\n      GeneralSettings.getInstance().setUseSafeWrite(safeWrite);\n      FileUtil.delete(dir);\n    }\n  }","commit_id":"e6a53e548252a83a2f6d1b2f0a30bacbd3a89c9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testGermanLetters() throws Exception{\n    final File dirFile = createTempDirectory();\n\n    final String name = \"te\\u00dft123123123.txt\";\n    final File childFile = new File(dirFile, name);\n    childFile.createNewFile();\n\n    ApplicationManager.getApplication().runWriteAction(\n      new Runnable() {\n        @Override\n        public void run() {\n          try{\n            final VirtualFile dir = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(dirFile);\n            assertNotNull(dir);\n\n            final VirtualFile child = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(childFile);\n            assertNotNull(child);\n\n          }\n          catch(Exception e){\n            LOG.error(e);\n          }\n        }\n      }\n    );\n\n\n    assertTrue(childFile.delete());\n  }","id":25591,"modified_method":"public void testGermanLetters() throws Exception{\n    final File dirFile = createTempDirectory();\n\n    final String name = \"te\\u00dft123123123.txt\";\n    final File childFile = new File(dirFile, name);\n    assert childFile.createNewFile() || childFile.exists() : childFile;\n\n    ApplicationManager.getApplication().runWriteAction(\n      new Runnable() {\n        @Override\n        public void run() {\n          try{\n            final VirtualFile dir = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(dirFile);\n            assertNotNull(dir);\n\n            final VirtualFile child = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(childFile);\n            assertNotNull(child);\n\n          }\n          catch(Exception e){\n            LOG.error(e);\n          }\n        }\n      }\n    );\n\n    assertTrue(childFile.delete());\n  }","commit_id":"e6a53e548252a83a2f6d1b2f0a30bacbd3a89c9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testCopyDir() throws Exception{\n    ApplicationManager.getApplication().runWriteAction(\n      new Runnable() {\n        @Override\n        public void run() {\n          try{\n            File fromDir = createTempDirectory();\n            File toDir = createTempDirectory();\n\n            VirtualFile fromVDir = LocalFileSystem.getInstance().findFileByPath(fromDir.getPath().replace(File.separatorChar, '/'));\n            VirtualFile toVDir = LocalFileSystem.getInstance().findFileByPath(toDir.getPath().replace(File.separatorChar, '/'));\n            assertNotNull(fromVDir);\n            assertNotNull(toVDir);\n            final VirtualFile dirToCopy = fromVDir.createChildDirectory(null, \"dir\");\n            final VirtualFile file = dirToCopy.createChildData(null, \"temp_file\");\n            file.setBinaryContent(new byte[]{0, 1, 2, 3});\n            final String newName = \"dir\";\n            final VirtualFile dirCopy = dirToCopy.copy(null, toVDir, newName);\n            assertEquals(newName, dirCopy.getName());\n            IdeaTestUtil.assertDirectoriesEqual(toVDir, fromVDir, null);\n          }\n          catch(Exception e){\n            LOG.error(e);\n          }\n        }\n      }\n    );\n  }","id":25592,"modified_method":"public void testCopyDir() throws Exception{\n    ApplicationManager.getApplication().runWriteAction(\n      new Runnable() {\n        @Override\n        public void run() {\n          try{\n            File fromDir = createTempDirectory();\n            File toDir = createTempDirectory();\n\n            VirtualFile fromVDir = LocalFileSystem.getInstance().findFileByPath(fromDir.getPath().replace(File.separatorChar, '/'));\n            VirtualFile toVDir = LocalFileSystem.getInstance().findFileByPath(toDir.getPath().replace(File.separatorChar, '/'));\n            assertNotNull(fromVDir);\n            assertNotNull(toVDir);\n            final VirtualFile dirToCopy = fromVDir.createChildDirectory(null, \"dir\");\n            final VirtualFile file = dirToCopy.createChildData(null, \"temp_file\");\n            file.setBinaryContent(new byte[]{0, 1, 2, 3});\n            final String newName = \"dir\";\n            final VirtualFile dirCopy = dirToCopy.copy(null, toVDir, newName);\n            assertEquals(newName, dirCopy.getName());\n            PlatformTestUtil.assertDirectoriesEqual(toVDir, fromVDir, null);\n          }\n          catch(Exception e){\n            LOG.error(e);\n          }\n        }\n      }\n    );\n  }","commit_id":"e6a53e548252a83a2f6d1b2f0a30bacbd3a89c9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void setContentOnDisk(File file, byte[] bom, String content, Charset charset) throws IOException {\n    FileOutputStream stream = new FileOutputStream(file);\n    if (bom != null) {\n      stream.write(bom);\n    }\n    OutputStreamWriter writer = new OutputStreamWriter(stream, charset);\n    writer.write(content);\n    writer.close();\n  }","id":25593,"modified_method":"public static void setContentOnDisk(File file, byte[] bom, String content, Charset charset) throws IOException {\n    FileOutputStream stream = new FileOutputStream(file);\n    if (bom != null) {\n      stream.write(bom);\n    }\n    OutputStreamWriter writer = new OutputStreamWriter(stream, charset);\n    try {\n      writer.write(content);\n    }\n    finally {\n      writer.close();\n    }\n  }","commit_id":"e6a53e548252a83a2f6d1b2f0a30bacbd3a89c9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static VirtualFile createTempFile(@NonNls String ext, @Nullable byte[] bom, @NonNls String content, Charset charset) throws IOException {\n    File temp = FileUtil.createTempFile(\"copy\", \".\" + ext);\n    setContentOnDisk(temp, bom, content, charset);\n\n    myFilesToDelete.add(temp);\n    return LocalFileSystem.getInstance().refreshAndFindFileByIoFile(temp);\n  }","id":25594,"modified_method":"public static VirtualFile createTempFile(@NonNls String ext, @Nullable byte[] bom, @NonNls String content, Charset charset) throws IOException {\n    File temp = FileUtil.createTempFile(\"copy\", \".\" + ext);\n    setContentOnDisk(temp, bom, content, charset);\n\n    myFilesToDelete.add(temp);\n    final VirtualFile file = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(temp);\n    assert file != null : temp;\n    return file;\n  }","commit_id":"e6a53e548252a83a2f6d1b2f0a30bacbd3a89c9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private VirtualFile getContentRoot() {\n    File file = getTestContentFile();\n    VirtualFile content = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(file);\n    return content;\n  }","id":25595,"modified_method":"protected VirtualFile getContentRoot() {\n    File file = getTestContentFile();\n    return LocalFileSystem.getInstance().refreshAndFindFileByIoFile(file);\n  }","commit_id":"ae9339a8cca5ef823b6bedb7aa5e73ddaebc580c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyTo(JTree tree) {\n    applyExpanded(tree);\n  }","id":25596,"modified_method":"public void applyTo(JTree tree) {\n    applyExpanded(tree, tree.getModel().getRoot());\n  }","commit_id":"ae9339a8cca5ef823b6bedb7aa5e73ddaebc580c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyTo(final JTree tree, final DefaultMutableTreeNode node) {\n    applyExpanded(tree);\n    applySelected(tree, node);\n  }","id":25597,"modified_method":"public void applyTo(final JTree tree, final DefaultMutableTreeNode node) {\n    applyExpanded(tree, node);\n    applySelected(tree, node);\n  }","commit_id":"ae9339a8cca5ef823b6bedb7aa5e73ddaebc580c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void applyExpanded(final JTree tree) {\n    for (final List<PathElement> myPath : myExpandedPaths) {\n      applyTo(myPath, tree);\n    }\n  }","id":25598,"modified_method":"private void applyExpanded(final JTree tree, final Object root) {\n    if (!(root instanceof DefaultMutableTreeNode)) {\n      return;\n    }\n    final DefaultMutableTreeNode nodeRoot = ((DefaultMutableTreeNode)root);\n    final TreeNode[] nodePath = nodeRoot.getPath();\n    if (nodePath.length > 0) {\n      for (final List<PathElement> path : myExpandedPaths) {\n        applyTo(nodePath.length - 1,path, root, tree);\n      }\n    }\n  }","commit_id":"ae9339a8cca5ef823b6bedb7aa5e73ddaebc580c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<PathElement> createPath(final TreePath treePath) {\n    final ArrayList<PathElement> result = new ArrayList<PathElement>();\n    for (int i = 0; i < treePath.getPathCount(); i++) {\n      final Object pathComponent = treePath.getPathComponent(i);\n      if (pathComponent instanceof DefaultMutableTreeNode) {\n        final Object userObject = ((DefaultMutableTreeNode)pathComponent).getUserObject();\n        if (userObject instanceof NodeDescriptor) {\n          final NodeDescriptor nodeDescriptor = (NodeDescriptor)userObject;\n          //nodeDescriptor.update();\n          result.add(new PathElement(getDescriptorKey(nodeDescriptor), getDescriptorType(nodeDescriptor), nodeDescriptor.getIndex(), nodeDescriptor));\n        }\n        else {\n          result.add(new PathElement(\"\", \"\", 0, userObject));\n        }\n      }\n      else {\n        return null;\n      }\n    }\n    return result;\n  }","id":25599,"modified_method":"private static List<PathElement> createPath(final TreePath treePath) {\n    final ArrayList<PathElement> result = new ArrayList<PathElement>();\n    for (int i = 0; i < treePath.getPathCount(); i++) {\n      final Object pathComponent = treePath.getPathComponent(i);\n      if (pathComponent instanceof DefaultMutableTreeNode) {\n        final DefaultMutableTreeNode node = (DefaultMutableTreeNode)pathComponent;\n        final TreeNode parent = node.getParent();\n\n        final Object userObject = node.getUserObject();\n        if (userObject instanceof NodeDescriptor) {\n          final NodeDescriptor nodeDescriptor = (NodeDescriptor)userObject;\n          //nodeDescriptor.update();\n          final int childIndex = parent != null ? parent.getIndex(node) : 0;\n          result.add(new PathElement(getDescriptorKey(nodeDescriptor), getDescriptorType(nodeDescriptor), childIndex, nodeDescriptor));\n        }\n        else {\n          result.add(new PathElement(\"\", \"\", 0, userObject));\n        }\n      }\n      else {\n        return null;\n      }\n    }\n    return result;\n  }","commit_id":"ae9339a8cca5ef823b6bedb7aa5e73ddaebc580c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Switches to Improving state\n     *\n     * @param targetWay Way that is going to be improved\n     */\n    public void startImproving(Way targetWay) {\n        state = State.improving;\n\n        List<OsmPrimitive> currentSelection = (List<OsmPrimitive>) getCurrentDataSet().getSelected();\n        if (currentSelection.size() != 1\n                || !currentSelection.get(0).equals(targetWay)) {\n            selectionChangedBlocked = true;\n            getCurrentDataSet().clearSelection();\n            getCurrentDataSet().setSelected(targetWay.getPrimitiveId());\n            selectionChangedBlocked = false;\n        }\n\n        this.targetWay = targetWay;\n        this.candidateNode = null;\n        this.candidateSegment = null;\n\n        mv.repaint();\n        updateStatusLine();\n    }","id":25600,"modified_method":"/**\n     * Switches to Improving state\n     *\n     * @param targetWay Way that is going to be improved\n     */\n    public void startImproving(Way targetWay) {\n        state = State.improving;\n\n        Collection<OsmPrimitive> currentSelection = getCurrentDataSet().getSelected();\n        if (currentSelection.size() != 1\n                || !currentSelection.iterator().next().equals(targetWay)) {\n            selectionChangedBlocked = true;\n            getCurrentDataSet().clearSelection();\n            getCurrentDataSet().setSelected(targetWay.getPrimitiveId());\n            selectionChangedBlocked = false;\n        }\n\n        this.targetWay = targetWay;\n        this.candidateNode = null;\n        this.candidateSegment = null;\n\n        mv.repaint();\n        updateStatusLine();\n    }","commit_id":"79943e96fdc04bd68440144bd4678ebfb008b50c","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Nullable\n  private static PyType parseSingleNumpyDocType(@NotNull PsiElement anchor, @NotNull String typeString) {\n    final PyPsiFacade facade = getPsiFacade(anchor);\n    final String realTypeName = NUMPY_ALIAS_TO_REAL_TYPE.get(typeString);\n    if (realTypeName != null) {\n      final PyType type = facade.parseTypeAnnotation(realTypeName, anchor);\n      if (type != null) {\n        return type;\n      }\n    }\n    return facade.parseTypeAnnotation(typeString, anchor);\n  }","id":25601,"modified_method":"@Nullable\n  private static PyType parseSingleNumpyDocType(@NotNull PsiElement anchor, @NotNull String typeString) {\n    final PyPsiFacade facade = getPsiFacade(anchor);\n    final String realTypeName = NUMPY_ALIAS_TO_REAL_TYPE.get(typeString);\n    if (realTypeName != null) {\n      final PyType type = facade.parseTypeAnnotation(realTypeName, anchor);\n      if (type != null) {\n        return type;\n      }\n    }\n    final PyType type = facade.parseTypeAnnotation(typeString, anchor);\n    if (type != null) {\n      return type;\n    }\n    return getNominalType(anchor, typeString);\n  }","commit_id":"e11bf5c91127f700532b48223b7c3425826b3299","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PyType parseSingleNumpyDocType(@NotNull PsiElement anchor, @NotNull String typeString) {\n    final PyPsiFacade facade = getPsiFacade(anchor);\n    typeString = getNumpyRealTypeName(typeString);\n\n    final PyType type = facade.parseTypeAnnotation(typeString, anchor);\n    if (type != null) {\n      return type;\n    }\n    return getNominalType(anchor, typeString);\n  }","id":25602,"modified_method":"@Nullable\n  private static PyType parseSingleNumpyDocType(@NotNull PsiElement anchor, @NotNull String typeString) {\n    final PyPsiFacade facade = getPsiFacade(anchor);\n    final String realTypeName = getNumpyRealTypeName(typeString);\n    PyType type = facade.parseTypeAnnotation(realTypeName, anchor);\n    if (type != null) {\n      return type;\n    }\n\n    type = facade.parseTypeAnnotation(typeString, anchor);\n    if (type != null) {\n      return type;\n    }\n    return getNominalType(anchor, typeString);\n  }","commit_id":"4eb12db5fbe1e65c5ed4432e8498366cbcaa2c46","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PyType getParameterType(@NotNull PyFunction function, @NotNull String parameterName) {\n    final NumPyDocString docString = NumPyDocString.forFunction(function, function);\n    if (docString != null) {\n      NumPyDocStringParameter parameter = docString.getNamedParameter(parameterName);\n\n      // If parameter name starts with \"p_\", and we failed to obtain it from the docstring,\n      // try to obtain parameter named without such prefix.\n      if (parameter == null && parameterName.startsWith(\"p_\")) {\n        parameter = docString.getNamedParameter(parameterName.substring(2));\n      }\n      if (parameter != null) {\n        final PyType numberType = getPsiFacade(function).parseTypeAnnotation(\"T <= numbers.Number|numpy.core.multiarray.ndarray\", function);\n        if (isUfuncType(function, parameter.getType())) return numberType;\n        return parseNumpyDocType(function, parameter.getType());\n      }\n    }\n    return null;\n  }","id":25603,"modified_method":"@Nullable\n  private static PyType getParameterType(@NotNull PyFunction function, @NotNull String parameterName) {\n    final NumPyDocString docString = NumPyDocString.forFunction(function, function);\n    if (docString != null) {\n      NumPyDocStringParameter parameter = docString.getNamedParameter(parameterName);\n\n      // If parameter name starts with \"p_\", and we failed to obtain it from the docstring,\n      // try to obtain parameter named without such prefix.\n      if (parameter == null && parameterName.startsWith(\"p_\")) {\n        parameter = docString.getNamedParameter(parameterName.substring(2));\n      }\n      if (parameter != null) {\n        if (isUfuncType(function, parameter.getType())) {\n          return getPsiFacade(function).parseTypeAnnotation(\"T <= numbers.Number|numpy.core.multiarray.ndarray\", function);\n        }\n        final PyType numpyDocType = parseNumpyDocType(function, parameter.getType());\n        if (\"size\".equals(parameterName)) {\n          return getPsiFacade(function).createUnionType(Lists.newArrayList(numpyDocType, PyBuiltinCache.getInstance(function).getIntType()));\n        }\n        return numpyDocType;\n      }\n    }\n    return null;\n  }","commit_id":"60d853e324de7d52d1a898eee8a24dffb2f10245","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isUfuncType(@NotNull PsiElement anchor, @NotNull final String typeString) {\n    for (String typeName : NumPyDocString.getNumpyUnionType(typeString)) {\n      if (anchor instanceof PyFunction && NumpyUfuncs.isUFunc(((PyFunction)anchor).getName()) &&\n          (typeName.equals(\"array_like\") || typeName.equals(\"ndarray\"))) {\n        return true;\n      }\n    }\n    return false;\n  }","id":25604,"modified_method":"private static boolean isUfuncType(@NotNull PsiElement anchor, @NotNull final String typeString) {\n    for (String typeName : NumPyDocString.getNumpyUnionType(typeString)) {\n      if (anchor instanceof PyFunction && NumpyUfuncs.isUFunc(((PyFunction)anchor).getName()) &&\n          (\"array_like\".equals(typeName) || \"ndarray\".equals(typeName))) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"60d853e324de7d52d1a898eee8a24dffb2f10245","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void checkSchema(final ODatabase<?> iDatabase) {\r\n    // FORCE NON DISTRIBUTION ON CREATION\r\n    OScenarioThreadLocal.INSTANCE.set(OScenarioThreadLocal.RUN_MODE.RUNNING_DISTRIBUTED);\r\n    try {\r\n\r\n      // iDatabase.getMetadata().getSchema().getOrCreateClass(OMVRBTreeRIDProvider.PERSISTENT_CLASS_NAME);\r\n\r\n      final OSchema schema = iDatabase.getMetadata().getSchema();\r\n\r\n      schema.reload();\r\n\r\n      OClass vertexBaseClass = schema.getClass(\"V\");\r\n      OClass edgeBaseClass = schema.getClass(\"E\");\r\n\r\n      if (vertexBaseClass == null) {\r\n        // CREATE THE META MODEL USING THE ORIENT SCHEMA\r\n        vertexBaseClass = schema.createClass(\"V\");\r\n        vertexBaseClass.setOverSize(2);\r\n      }\r\n\r\n      if (edgeBaseClass == null)\r\n        schema.createClass(\"E\");\r\n    } finally {\r\n      OScenarioThreadLocal.INSTANCE.set(OScenarioThreadLocal.RUN_MODE.DEFAULT);\r\n    }\r\n  }","id":25605,"modified_method":"public void checkSchema(final ODatabase<?> iDatabase) {\r\n    // FORCE NON DISTRIBUTION ON CREATION\r\n    OScenarioThreadLocal.INSTANCE.set(OScenarioThreadLocal.RUN_MODE.RUNNING_DISTRIBUTED);\r\n    try {\r\n\r\n      final OSchema schema = iDatabase.getMetadata().getSchema();\r\n      OClass vertexBaseClass;\r\n\r\n      try {\r\n        vertexBaseClass = schema.getOrCreateClass(\"V\");\r\n      } catch (OException e) {\r\n        // that is possible in case of remote client connection.\r\n        schema.reload();\r\n        vertexBaseClass = schema.getOrCreateClass(\"V\");\r\n      }\r\n\r\n      OClass edgeBaseClass;\r\n\r\n      try {\r\n        edgeBaseClass = schema.getOrCreateClass(\"E\");\r\n      } catch (OException e) {\r\n        // that is possible in case of remote client connection\r\n        schema.reload();\r\n        edgeBaseClass = schema.getOrCreateClass(\"E\");\r\n      }\r\n\r\n      assert edgeBaseClass != null;\r\n      assert vertexBaseClass != null;\r\n\r\n      if (vertexBaseClass.getOverSize() < 2)\r\n        vertexBaseClass.setOverSize(2);\r\n    } finally {\r\n      OScenarioThreadLocal.INSTANCE.set(OScenarioThreadLocal.RUN_MODE.DEFAULT);\r\n    }\r\n  }","commit_id":"83a47d599a268e2fc0faa08df3f183e08ec143f6","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            UserFactory.init();\n        } catch (Exception e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserFactory userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Exception e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(UserFactory.encryptPassword(password));\n\n            HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }","id":25606,"modified_method":"public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            UserFactory.init();\n        } catch (Exception e) {\n            throw new ServletException(\"AddNewUserServlet: Error initialising user factory.\" + e);\n        }\n        UserFactory userFactory = UserFactory.getInstance();\n\n        String userID = request.getParameter(\"userID\");\n        String password = request.getParameter(\"pass1\");\n\n        boolean hasUser = false;\n        try {\n            hasUser = userFactory.hasUser(userID);\n        } catch (Exception e) {\n            throw new ServletException(\"can't determine if user \" + userID + \" already exists in users.xml.\", e);\n        }\n\n        if (hasUser) {\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/newUser.jsp?action=redo\");\n            dispatcher.forward(request, response);\n        } else {\n            User newUser = new User();\n            newUser.setUserId(userID);\n            newUser.setPassword(UserFactory.getInstance().encryptedPassword(password));\n\n            HttpSession userSession = request.getSession(false);\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/admin/userGroupView/users/modifyUser.jsp\");\n            dispatcher.forward(request, response);\n        }\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    private NotificationTask makeUserTask(long sendTime, Map parameters, int noticeId, String targetName, String[] commandList, List siblings) throws IOException, MarshalException, ValidationException {\n        NotificationTask task = null;\n\n        try {\n            task = new NotificationTask(sendTime, parameters, siblings);\n\n            User user = UserFactory.getInstance().getUser(targetName);\n\n            Command commands[] = new Command[commandList.length];\n            for (int i = 0; i < commandList.length; i++) {\n                commands[i] = NotificationCommandFactory.getInstance().getCommand(commandList[i]);\n            }\n\n            // if either piece of information is missing don't add the task to\n            // the notifier\n            if (user == null) {\n                ThreadCategory.getInstance(getClass()).error(\"user \" + targetName + \" is not a valid user, not adding this user to escalation thread\");\n                return null;\n            }\n\n            task.setUser(user);\n            task.setCommands(commands);\n            task.setNoticeId(noticeId);\n        } catch (SQLException e) {\n            ThreadCategory.getInstance(getClass()).error(\"Couldn't create user notification task\", e);\n        }\n\n        return task;\n    }","id":25607,"modified_method":"/**\n     * \n     */\n    private NotificationTask makeUserTask(long sendTime, Map parameters, int noticeId, String targetName, String[] commandList, List siblings) throws IOException, MarshalException, ValidationException {\n        NotificationTask task = null;\n\n        try {\n            task = new NotificationTask(m_notifd, sendTime, parameters, siblings);\n\n            User user = UserFactory.getInstance().getUser(targetName);\n\n            Command commands[] = new Command[commandList.length];\n            for (int i = 0; i < commandList.length; i++) {\n                commands[i] = NotificationCommandFactory.getInstance().getCommand(commandList[i]);\n            }\n\n            // if either piece of information is missing don't add the task to\n            // the notifier\n            if (user == null) {\n                ThreadCategory.getInstance(getClass()).error(\"user \" + targetName + \" is not a valid user, not adding this user to escalation thread\");\n                return null;\n            }\n\n            task.setUser(user);\n            task.setCommands(commands);\n            task.setNoticeId(noticeId);\n        } catch (SQLException e) {\n            ThreadCategory.getInstance(getClass()).error(\"Couldn't create user notification task\", e);\n        }\n\n        return task;\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    private Map buildParameterMap(Notification notification, Event event, int noticeId) {\n        Map paramMap = new HashMap();\n        Parameter[] parameters = notification.getParameter();\n        for (int i = 0; i < parameters.length; i++) {\n            paramMap.put(parameters[i].getName(), parameters[i].getValue());\n        }\n\n        // expand the event parameters for the messages\n        String text = (notification.getTextMessage() != null ? notification.getTextMessage() : \"No text message supplied.\");\n        String numeric = (notification.getNumericMessage() != null ? notification.getNumericMessage() : \"111-\" + noticeId);\n        String subject = (notification.getSubject() != null ? notification.getSubject() : \"Notice #\" + noticeId);\n\n        paramMap.put(\"noticeid\", Integer.toString(noticeId));\n        paramMap.put(NotificationFactory.PARAM_NODE, String.valueOf(event.getNodeid()));\n        paramMap.put(NotificationFactory.PARAM_INTERFACE, event.getInterface());\n        paramMap.put(NotificationFactory.PARAM_SERVICE, event.getService());\n        paramMap.put(\"eventID\", String.valueOf(event.getDbid()));\n        paramMap.put(\"eventUEI\", event.getUei());\n\n        // call the notid expansion method before the event expansion because\n        // event expansion will\n        // throw away any expanion strings it doesn't recognize!\n        String textMessage = expandNotifParms(text, paramMap);\n        String numericMessage = expandNotifParms(numeric, paramMap);\n        String subjectLine = expandNotifParms(subject, paramMap);\n\n        String finalTextMessage = EventUtil.expandParms(textMessage, event);\n        if (finalTextMessage == null)\n            paramMap.put(NotificationFactory.PARAM_TEXT_MSG, textMessage);\n        else\n            paramMap.put(NotificationFactory.PARAM_TEXT_MSG, finalTextMessage);\n\n        String finalNumericMessage = EventUtil.expandParms(numericMessage, event);\n        if (finalNumericMessage == null)\n            paramMap.put(NotificationFactory.PARAM_NUM_MSG, numericMessage);\n        else\n            paramMap.put(NotificationFactory.PARAM_NUM_MSG, finalNumericMessage);\n\n        String finalSubjectLine = EventUtil.expandParms(subjectLine, event);\n        if (finalSubjectLine == null)\n            paramMap.put(NotificationFactory.PARAM_SUBJECT, subjectLine);\n        else\n            paramMap.put(NotificationFactory.PARAM_SUBJECT, finalSubjectLine);\n\n        return paramMap;\n    }","id":25608,"modified_method":"/**\n     * \n     */\n    private Map buildParameterMap(Notification notification, Event event, int noticeId) {\n        Map paramMap = new HashMap();\n        Parameter[] parameters = notification.getParameter();\n        for (int i = 0; i < parameters.length; i++) {\n            paramMap.put(parameters[i].getName(), parameters[i].getValue());\n        }\n\n        // expand the event parameters for the messages\n        String text = (notification.getTextMessage() != null ? notification.getTextMessage() : \"No text message supplied.\");\n        String numeric = (notification.getNumericMessage() != null ? notification.getNumericMessage() : \"111-\" + noticeId);\n        String subject = (notification.getSubject() != null ? notification.getSubject() : \"Notice #\" + noticeId);\n\n        paramMap.put(\"noticeid\", Integer.toString(noticeId));\n        paramMap.put(NotificationManager.PARAM_NODE, String.valueOf(event.getNodeid()));\n        paramMap.put(NotificationManager.PARAM_INTERFACE, event.getInterface());\n        paramMap.put(NotificationManager.PARAM_SERVICE, event.getService());\n        paramMap.put(\"eventID\", String.valueOf(event.getDbid()));\n        paramMap.put(\"eventUEI\", event.getUei());\n\n        // call the notid expansion method before the event expansion because\n        // event expansion will\n        // throw away any expanion strings it doesn't recognize!\n        String textMessage = expandNotifParms(text, paramMap);\n        String numericMessage = expandNotifParms(numeric, paramMap);\n        String subjectLine = expandNotifParms(subject, paramMap);\n\n        String finalTextMessage = EventUtil.expandParms(textMessage, event);\n        if (finalTextMessage == null)\n            paramMap.put(NotificationManager.PARAM_TEXT_MSG, textMessage);\n        else\n            paramMap.put(NotificationManager.PARAM_TEXT_MSG, finalTextMessage);\n\n        String finalNumericMessage = EventUtil.expandParms(numericMessage, event);\n        if (finalNumericMessage == null)\n            paramMap.put(NotificationManager.PARAM_NUM_MSG, numericMessage);\n        else\n            paramMap.put(NotificationManager.PARAM_NUM_MSG, finalNumericMessage);\n\n        String finalSubjectLine = EventUtil.expandParms(subjectLine, event);\n        if (finalSubjectLine == null)\n            paramMap.put(NotificationManager.PARAM_SUBJECT, subjectLine);\n        else\n            paramMap.put(NotificationManager.PARAM_SUBJECT, finalSubjectLine);\n\n        return paramMap;\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    private void automaticAcknowledge(Event event) {\n        try {\n            Collection ueis = getConfigManager().getConfiguration().getAutoAcknowledgeCollection();\n\n            // see if this event has an auto acknowledge for a notice\n            Iterator i = ueis.iterator();\n            while (i.hasNext()) {\n                AutoAcknowledge curAck = (AutoAcknowledge) i.next();\n                if (curAck.getUei().equals(event.getUei())) {\n                    try {\n                        ThreadCategory.getInstance(getClass()).debug(\"Acknowledging event \" + curAck.getAcknowledge() + \" \" + event.getNodeid() + \":\" + event.getInterface() + \":\" + event.getService());\n                        NotificationFactory.getInstance().acknowledgeNotice(event, curAck.getAcknowledge(), curAck.getMatch());\n                    } catch (SQLException e) {\n                        ThreadCategory.getInstance(getClass()).error(\"Failed to auto acknowledge notice.\", e);\n                    }\n                }\n                // if the clear flag is set, swap the event uei as the ack uei\n                // and ack the second notice\n                if (curAck.getUei().equals(event.getUei()) && curAck.getClear()) {\n                    try {\n                        ThreadCategory.getInstance(getClass()).debug(\"Acknowledging source event \" + event.getUei() + \" \" + event.getNodeid() + \":\" + event.getInterface() + \":\" + event.getService());\n                        NotificationFactory.getInstance().acknowledgeNotice(event, event.getUei(), curAck.getMatch());\n                    } catch (SQLException e) {\n                        ThreadCategory.getInstance(getClass()).error(\"Failed to auto acknowledge source notice.\", e);\n                    }\n                }\n\n            }\n        } catch (Exception e) {\n            ThreadCategory.getInstance(getClass()).error(\"Unable to auto acknowledge notice due to exception.\", e);\n        }\n    }","id":25609,"modified_method":"/**\n     * \n     */\n    private void automaticAcknowledge(Event event) {\n        try {\n            Collection ueis = getConfigManager().getConfiguration().getAutoAcknowledgeCollection();\n\n            // see if this event has an auto acknowledge for a notice\n            Iterator i = ueis.iterator();\n            while (i.hasNext()) {\n                AutoAcknowledge curAck = (AutoAcknowledge) i.next();\n                if (curAck.getUei().equals(event.getUei())) {\n                    try {\n                        ThreadCategory.getInstance(getClass()).debug(\"Acknowledging event \" + curAck.getAcknowledge() + \" \" + event.getNodeid() + \":\" + event.getInterface() + \":\" + event.getService());\n                        getNotificationManager().acknowledgeNotice(event, curAck.getAcknowledge(), curAck.getMatch());\n                    } catch (SQLException e) {\n                        ThreadCategory.getInstance(getClass()).error(\"Failed to auto acknowledge notice.\", e);\n                    }\n                }\n                // if the clear flag is set, swap the event uei as the ack uei\n                // and ack the second notice\n                if (curAck.getUei().equals(event.getUei()) && curAck.getClear()) {\n                    try {\n                        ThreadCategory.getInstance(getClass()).debug(\"Acknowledging source event \" + event.getUei() + \" \" + event.getNodeid() + \":\" + event.getInterface() + \":\" + event.getService());\n                        getNotificationManager().acknowledgeNotice(event, event.getUei(), curAck.getMatch());\n                    } catch (SQLException e) {\n                        ThreadCategory.getInstance(getClass()).error(\"Failed to auto acknowledge source notice.\", e);\n                    }\n                }\n\n            }\n        } catch (Exception e) {\n            ThreadCategory.getInstance(getClass()).error(\"Unable to auto acknowledge notice due to exception.\", e);\n        }\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    private NotificationTask makeEmailTask(long sendTime, Map parameters, int noticeId, String address, String[] commandList, List siblings) throws IOException, MarshalException, ValidationException {\n        NotificationTask task = null;\n\n        try {\n            task = new NotificationTask(sendTime, parameters, siblings);\n\n            User user = new User();\n            user.setUserId(\"email-address\");\n            Contact contact = new Contact();\n            contact.setType(\"email\");\n            // contact.setType(\"javaEmail\");\n            ThreadCategory.getInstance(getClass()).debug(\"email address = \" + address);\n            contact.setInfo(address);\n            user.addContact(contact);\n\n            Command commands[] = new Command[commandList.length];\n            for (int i = 0; i < commandList.length; i++) {\n                commands[i] = NotificationCommandFactory.getInstance().getCommand(commandList[i]);\n            }\n\n            task.setUser(user);\n            task.setCommands(commands);\n            task.setNoticeId(noticeId);\n        } catch (SQLException e) {\n            ThreadCategory.getInstance(getClass()).error(\"Couldn't create email notification task\", e);\n        }\n\n        return task;\n    }","id":25610,"modified_method":"/**\n     * \n     */\n    private NotificationTask makeEmailTask(long sendTime, Map parameters, int noticeId, String address, String[] commandList, List siblings) throws IOException, MarshalException, ValidationException {\n        NotificationTask task = null;\n\n        try {\n            task = new NotificationTask(m_notifd, sendTime, parameters, siblings);\n\n            User user = new User();\n            user.setUserId(\"email-address\");\n            Contact contact = new Contact();\n            contact.setType(\"email\");\n            // contact.setType(\"javaEmail\");\n            ThreadCategory.getInstance(getClass()).debug(\"email address = \" + address);\n            contact.setInfo(address);\n            user.addContact(contact);\n\n            Command commands[] = new Command[commandList.length];\n            for (int i = 0; i < commandList.length; i++) {\n                commands[i] = NotificationCommandFactory.getInstance().getCommand(commandList[i]);\n            }\n\n            task.setUser(user);\n            task.setCommands(commands);\n            task.setNoticeId(noticeId);\n        } catch (SQLException e) {\n            ThreadCategory.getInstance(getClass()).error(\"Couldn't create email notification task\", e);\n        }\n\n        return task;\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     */\n    private void scheduleNoticesForEvent(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        boolean mapsToNotice = false;\n\n        try {\n            mapsToNotice = NotificationFactory.getInstance().hasUei(event.getUei());\n        } catch (Exception e) {\n            log.error(\"Couldn't map uei \" + event.getUei() + \" to a notification entry, not scheduling notice.\", e);\n            return;\n        }\n\n        if (mapsToNotice) {\n            // check to see if notices are turned on for the interface/service\n            // in the event\n            if (continueWithNotice(event)) {\n                Notification[] notifications = null;\n\n                try {\n                    notifications = NotificationFactory.getInstance().getNotifForEvent(event);\n                } catch (Exception e) {\n                    log.error(\"Couldn't get notification mapping for event \" + event.getUei() + \", not scheduling notice.\", e);\n                    return;\n                }\n\n                if (notifications != null) {\n                    for (int i = 0; i < notifications.length; i++) {\n\n                        Notification notification = notifications[i];\n\n                        boolean parmsmatched = matchNotificationParameters(event, notification);\n\n                        if (!parmsmatched) {\n                            log.debug(\"Event \" + event.getUei() + \" did not match parameters for notice \" + notification.getName());\n                            return;\n                        }\n\n                        log.debug(\"Event \" + event.getUei() + \" matched notice \" + notification.getName());\n\n                        int noticeId = 0;\n\n                        try {\n                            noticeId = NotificationFactory.getInstance().getNoticeId();\n                        } catch (Exception e) {\n                            log.error(\"Failed to get a unique id # for notification, exiting this notification\", e);\n                            return;\n                        }\n\n                        Map paramMap = buildParameterMap(notification, event, noticeId);\n                        String queueID = (notification.getNoticeQueue() != null ? notification.getNoticeQueue() : \"default\");\n\n                        log.debug(\"destination : \" + notification.getDestinationPath());\n                        log.debug(\"text message: \" + (String) paramMap.get(NotificationFactory.PARAM_TEXT_MSG));\n                        log.debug(\"num message : \" + (String) paramMap.get(NotificationFactory.PARAM_NUM_MSG));\n                        log.debug(\"subject     : \" + (String) paramMap.get(NotificationFactory.PARAM_SUBJECT));\n                        log.debug(\"node        : \" + (String) paramMap.get(NotificationFactory.PARAM_NODE));\n                        log.debug(\"interface   : \" + (String) paramMap.get(NotificationFactory.PARAM_INTERFACE));\n                        log.debug(\"service     : \" + (String) paramMap.get(NotificationFactory.PARAM_SERVICE));\n\n                        // get the target and escalation information\n                        Path path = null;\n                        try {\n                            path = DestinationPathFactory.getInstance().getPath(notification.getDestinationPath());\n                            if (path == null) {\n                                log.warn(\"Unknown destination path \" + notification.getDestinationPath() + \". Please check the <destinationPath> tag for the notification \" + notification.getName() + \" in the notification.xml file.\");\n                                return;\n                            }\n                        } catch (Exception e) {\n                            log.error(\"Could not get destination path for \" + notification.getDestinationPath() + \", please check the destinationPath.xml for errors.\", e);\n                            return;\n                        }\n                        String initialDelay = (path.getInitialDelay() == null ? \"0s\" : path.getInitialDelay());\n                        Target[] targets = path.getTarget();\n                        Escalate[] escalations = path.getEscalate();\n\n                        // now check to see if any users are to receive the\n                        // notification, if none then generate an event a exit\n                        try {\n                            if (getUserCount(targets, escalations) == 0) {\n                                log.warn(\"The path \" + notification.getDestinationPath() + \" assigned to notification \" + notification.getName() + \" has no targets or escalations specified, not sending notice.\");\n                                sendNotifEvent(EventConstants.NOTIFICATION_WITHOUT_USERS, \"The path \" + notification.getDestinationPath() + \" assigned to notification \" + notification.getName() + \" has no targets or escalations specified.\", \"The message of the notification is as follows: \" + (String) paramMap.get(NotificationFactory.PARAM_TEXT_MSG));\n                                return;\n                            }\n                        } catch (Exception e) {\n                            log.error(\"Failed to get count of users in destination path \" + notification.getDestinationPath() + \", exiting notification.\", e);\n                            return;\n                        }\n\n                        try {\n                            NotificationFactory.getInstance().insertNotice(noticeId, paramMap);\n                        } catch (SQLException e) {\n                            log.error(\"Failed to enter notification into database, exiting this notification\", e);\n                            return;\n                        }\n\n                        long startTime = System.currentTimeMillis() + TimeConverter.convertToMillis(initialDelay);\n                        List targetSiblings = new ArrayList();\n\n                        try {\n                            NoticeQueue noticeQueue = (NoticeQueue) m_noticeQueues.get(queueID);\n                            processTargets(targets, targetSiblings, noticeQueue, startTime, paramMap, noticeId);\n                            processEscalations(escalations, targetSiblings, noticeQueue, startTime, paramMap, noticeId);\n                        } catch (Exception e) {\n                            log.error(\"notice not scheduled due to error: \", e);\n                        }\n\n                    }\n                } else {\n                    log.debug(\"Event doesn't match a notice: \" + event.getUei() + \" : \" + event.getNodeid() + \" : \" + event.getInterface() + \" : \" + event.getService());\n                }\n            }\n        } else {\n            log.debug(\"No notice match for uei: \" + event.getUei());\n        }\n    }","id":25611,"modified_method":"/**\n     */\n    private void scheduleNoticesForEvent(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        boolean mapsToNotice = false;\n\n        try {\n            mapsToNotice = getNotificationManager().hasUei(event.getUei());\n        } catch (Exception e) {\n            log.error(\"Couldn't map uei \" + event.getUei() + \" to a notification entry, not scheduling notice.\", e);\n            return;\n        }\n\n        if (mapsToNotice) {\n            // check to see if notices are turned on for the interface/service\n            // in the event\n            if (continueWithNotice(event)) {\n                Notification[] notifications = null;\n\n                try {\n                    notifications = getNotificationManager().getNotifForEvent(event);\n                } catch (Exception e) {\n                    log.error(\"Couldn't get notification mapping for event \" + event.getUei() + \", not scheduling notice.\", e);\n                    return;\n                }\n\n                if (notifications != null) {\n                    for (int i = 0; i < notifications.length; i++) {\n\n                        Notification notification = notifications[i];\n\n                        boolean parmsmatched = matchNotificationParameters(event, notification);\n\n                        if (!parmsmatched) {\n                            log.debug(\"Event \" + event.getUei() + \" did not match parameters for notice \" + notification.getName());\n                            return;\n                        }\n\n                        log.debug(\"Event \" + event.getUei() + \" matched notice \" + notification.getName());\n\n                        int noticeId = 0;\n\n                        try {\n                            noticeId = getNotificationManager().getNoticeId();\n                        } catch (Exception e) {\n                            log.error(\"Failed to get a unique id # for notification, exiting this notification\", e);\n                            return;\n                        }\n\n                        Map paramMap = buildParameterMap(notification, event, noticeId);\n                        String queueID = (notification.getNoticeQueue() != null ? notification.getNoticeQueue() : \"default\");\n\n                        log.debug(\"destination : \" + notification.getDestinationPath());\n                        log.debug(\"text message: \" + (String) paramMap.get(NotificationManager.PARAM_TEXT_MSG));\n                        log.debug(\"num message : \" + (String) paramMap.get(NotificationManager.PARAM_NUM_MSG));\n                        log.debug(\"subject     : \" + (String) paramMap.get(NotificationManager.PARAM_SUBJECT));\n                        log.debug(\"node        : \" + (String) paramMap.get(NotificationManager.PARAM_NODE));\n                        log.debug(\"interface   : \" + (String) paramMap.get(NotificationManager.PARAM_INTERFACE));\n                        log.debug(\"service     : \" + (String) paramMap.get(NotificationManager.PARAM_SERVICE));\n\n                        // get the target and escalation information\n                        Path path = null;\n                        try {\n                            path = DestinationPathFactory.getInstance().getPath(notification.getDestinationPath());\n                            if (path == null) {\n                                log.warn(\"Unknown destination path \" + notification.getDestinationPath() + \". Please check the <destinationPath> tag for the notification \" + notification.getName() + \" in the notification.xml file.\");\n                                return;\n                            }\n                        } catch (Exception e) {\n                            log.error(\"Could not get destination path for \" + notification.getDestinationPath() + \", please check the destinationPath.xml for errors.\", e);\n                            return;\n                        }\n                        String initialDelay = (path.getInitialDelay() == null ? \"0s\" : path.getInitialDelay());\n                        Target[] targets = path.getTarget();\n                        Escalate[] escalations = path.getEscalate();\n\n                        // now check to see if any users are to receive the\n                        // notification, if none then generate an event a exit\n                        try {\n                            if (getUserCount(targets, escalations) == 0) {\n                                log.warn(\"The path \" + notification.getDestinationPath() + \" assigned to notification \" + notification.getName() + \" has no targets or escalations specified, not sending notice.\");\n                                sendNotifEvent(EventConstants.NOTIFICATION_WITHOUT_USERS, \"The path \" + notification.getDestinationPath() + \" assigned to notification \" + notification.getName() + \" has no targets or escalations specified.\", \"The message of the notification is as follows: \" + (String) paramMap.get(NotificationManager.PARAM_TEXT_MSG));\n                                return;\n                            }\n                        } catch (Exception e) {\n                            log.error(\"Failed to get count of users in destination path \" + notification.getDestinationPath() + \", exiting notification.\", e);\n                            return;\n                        }\n\n                        try {\n                            getNotificationManager().insertNotice(noticeId, paramMap);\n                        } catch (SQLException e) {\n                            log.error(\"Failed to enter notification into database, exiting this notification\", e);\n                            return;\n                        }\n\n                        long startTime = System.currentTimeMillis() + TimeConverter.convertToMillis(initialDelay);\n                        List targetSiblings = new ArrayList();\n\n                        try {\n                            NoticeQueue noticeQueue = (NoticeQueue) m_noticeQueues.get(queueID);\n                            processTargets(targets, targetSiblings, noticeQueue, startTime, paramMap, noticeId);\n                            processEscalations(escalations, targetSiblings, noticeQueue, startTime, paramMap, noticeId);\n                        } catch (Exception e) {\n                            log.error(\"notice not scheduled due to error: \", e);\n                        }\n\n                    }\n                } else {\n                    log.debug(\"Event doesn't match a notice: \" + event.getUei() + \" : \" + event.getNodeid() + \" : \" + event.getInterface() + \" : \" + event.getService());\n                }\n            }\n        } else {\n            log.debug(\"No notice match for uei: \" + event.getUei());\n        }\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This constructor is called to initilize the event receiver. A connection\n     * to the message server is opened and this instance is setup as the\n     * endpoint for broadcast events. When a new event arrives it is processed\n     * and the appropriate action is taken.\n     * \n     */\n    BroadcastEventProcessor(Notifd notifd, Map noticeQueues) {\n        // set up the exectuable queue first\n        //\n        m_notifd = notifd;\n        m_noticeQueues = noticeQueues;\n\n        // initialize the factory instances\n        try {\n            GroupFactory.init();\n            UserFactory.init();\n            NotificationFactory.init();\n            DestinationPathFactory.init();\n            NotificationCommandFactory.init();\n        } catch (Exception e) {\n            ThreadCategory.getInstance(getClass()).error(\"Error getting group, user notification or command factory instances: \" + e.getMessage(), e);\n            return;\n        }\n\n        // start to listen for events\n        getEventManager().addEventListener(this);\n    }","id":25612,"modified_method":"/**\n     * This constructor is called to initilize the event receiver. A connection\n     * to the message server is opened and this instance is setup as the\n     * endpoint for broadcast events. When a new event arrives it is processed\n     * and the appropriate action is taken.\n     * \n     */\n    BroadcastEventProcessor(Notifd notifd, Map noticeQueues) {\n        // set up the exectuable queue first\n        //\n        m_notifd = notifd;\n        m_noticeQueues = noticeQueues;\n\n        // initialize the factory instances\n        try {\n            \n            /*\n             * TODO: these need to be removed\n             */\n            UserFactory.init();\n            DestinationPathFactory.init();\n            NotificationCommandFactory.init();\n        } catch (Exception e) {\n            ThreadCategory.getInstance(getClass()).error(\"Error getting group, user notification or command factory instances: \" + e.getMessage(), e);\n            return;\n        }\n\n        // start to listen for events\n        getEventManager().addEventListener(this);\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method determines if the notice should continue based on the status\n     * of the notify\n     */\n    private boolean continueWithNotice(Event event) {\n        String nodeID = String.valueOf(event.getNodeid());\n        String ipAddr = event.getInterface();\n        String service = event.getService();\n\n        boolean continueNotice = false;\n\n        // can't check the database if any of these are null, so let the notice\n        // continue\n        if (nodeID == null || ipAddr == null || service == null) {\n            ThreadCategory.getInstance(getClass()).debug(\"nodeID=\" + nodeID + \" ipAddr=\" + ipAddr + \" service=\" + service + \". Not checking DB, allowing notice to continue.\");\n            return true;\n        }\n\n        try {\n            // check the database to see if notices were turned off for this\n            // service\n            String notify = NotificationFactory.getInstance().getServiceNoticeStatus(nodeID, ipAddr, service);\n            if (\"Y\".equals(notify)) {\n                continueNotice = true;\n                ThreadCategory.getInstance(getClass()).debug(\"notify status for service \" + service + \" on interface/node \" + ipAddr + \"/\" + nodeID + \" is 'Y', continuing...\");\n            } else {\n                ThreadCategory.getInstance(getClass()).debug(\"notify status for service \" + service + \" on interface/node \" + ipAddr + \"/\" + nodeID + \" is \" + notify + \", not continuing...\");\n            }\n        } catch (Exception e) {\n            continueNotice = true;\n            ThreadCategory.getInstance(getClass()).error(\"Not able to get notify status for service \" + service + \" on interface/node \" + ipAddr + \"/\" + nodeID + \". Continuing notice... \" + e.getMessage());\n        }\n\n        // in case of a error we will return false\n        return continueNotice;\n    }","id":25613,"modified_method":"/**\n     * This method determines if the notice should continue based on the status\n     * of the notify\n     */\n    private boolean continueWithNotice(Event event) {\n        String nodeID = String.valueOf(event.getNodeid());\n        String ipAddr = event.getInterface();\n        String service = event.getService();\n\n        boolean continueNotice = false;\n\n        // can't check the database if any of these are null, so let the notice\n        // continue\n        if (nodeID == null || ipAddr == null || service == null) {\n            ThreadCategory.getInstance(getClass()).debug(\"nodeID=\" + nodeID + \" ipAddr=\" + ipAddr + \" service=\" + service + \". Not checking DB, allowing notice to continue.\");\n            return true;\n        }\n\n        try {\n            // check the database to see if notices were turned off for this\n            // service\n            String notify = getNotificationManager().getServiceNoticeStatus(nodeID, ipAddr, service);\n            if (\"Y\".equals(notify)) {\n                continueNotice = true;\n                ThreadCategory.getInstance(getClass()).debug(\"notify status for service \" + service + \" on interface/node \" + ipAddr + \"/\" + nodeID + \" is 'Y', continuing...\");\n            } else {\n                ThreadCategory.getInstance(getClass()).debug(\"notify status for service \" + service + \" on interface/node \" + ipAddr + \"/\" + nodeID + \" is \" + notify + \", not continuing...\");\n            }\n        } catch (Exception e) {\n            continueNotice = true;\n            ThreadCategory.getInstance(getClass()).error(\"Not able to get notify status for service \" + service + \" on interface/node \" + ipAddr + \"/\" + nodeID + \". Continuing notice... \" + e.getMessage());\n        }\n\n        // in case of a error we will return false\n        return continueNotice;\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructor which parses the file\n     */\n    private GroupFactory() {\n    }","id":25614,"modified_method":"/**\n     * Constructor which parses the file\n     */\n    public GroupFactory() {\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method extracts the to, subject, and message text from the\n     * parameters passed in the notification.\n     * \n     * @param arguments\n     */\n    private JavaMailer buildMessage(List arguments) {\n\n        JavaMailer jm = new JavaMailer();\n\n        for (int i = 0; i < arguments.size(); i++) {\n\n            Argument arg = (Argument) arguments.get(i);\n            log.debug(\"Current arg switch: \" + i + \" of \" + arguments.size() + \" is: \" + arg.getSwitch());\n            log.debug(\"Current arg  value: \" + i + \" of \" + arguments.size() + \" is: \" + arg.getValue());\n\n            /*\n             * Note: The recipient gets set by whichever of the two switches:\n             * (PARAM_EMAIL or PARAM_PAGER_EMAIL) are specified last in the\n             * notificationCommands.xml file\n             */\n            if (NotificationFactory.PARAM_EMAIL.equals(arg.getSwitch())) {\n                log.debug(\"Found: PARAM_EMAIL\");\n                jm.setTo(arg.getValue());\n            } else if (NotificationFactory.PARAM_PAGER_EMAIL.equals(arg.getSwitch())) {\n                log.debug(\"Found: PARAM_PAGER_EMAIL\");\n                jm.setTo(arg.getValue());\n            } else if (NotificationFactory.PARAM_SUBJECT.equals(arg.getSwitch())) {\n                log.debug(\"Found: PARAM_SUBJECT\");\n                jm.setSubject(arg.getValue());\n            } else if (NotificationFactory.PARAM_TEXT_MSG.equals(arg.getSwitch())) {\n                log.debug(\"Found: PARAM_TEXT_MSG\");\n                jm.setMessageText(arg.getValue());\n            }\n        }\n\n        return jm;\n    }","id":25615,"modified_method":"/**\n     * This method extracts the to, subject, and message text from the\n     * parameters passed in the notification.\n     * \n     * @param arguments\n     */\n    private JavaMailer buildMessage(List arguments) {\n\n        JavaMailer jm = new JavaMailer();\n\n        for (int i = 0; i < arguments.size(); i++) {\n\n            Argument arg = (Argument) arguments.get(i);\n            log.debug(\"Current arg switch: \" + i + \" of \" + arguments.size() + \" is: \" + arg.getSwitch());\n            log.debug(\"Current arg  value: \" + i + \" of \" + arguments.size() + \" is: \" + arg.getValue());\n\n            /*\n             * Note: The recipient gets set by whichever of the two switches:\n             * (PARAM_EMAIL or PARAM_PAGER_EMAIL) are specified last in the\n             * notificationCommands.xml file\n             */\n            if (NotificationManager.PARAM_EMAIL.equals(arg.getSwitch())) {\n                log.debug(\"Found: PARAM_EMAIL\");\n                jm.setTo(arg.getValue());\n            } else if (NotificationManager.PARAM_PAGER_EMAIL.equals(arg.getSwitch())) {\n                log.debug(\"Found: PARAM_PAGER_EMAIL\");\n                jm.setTo(arg.getValue());\n            } else if (NotificationManager.PARAM_SUBJECT.equals(arg.getSwitch())) {\n                log.debug(\"Found: PARAM_SUBJECT\");\n                jm.setSubject(arg.getValue());\n            } else if (NotificationManager.PARAM_TEXT_MSG.equals(arg.getSwitch())) {\n                log.debug(\"Found: PARAM_TEXT_MSG\");\n                jm.setMessageText(arg.getValue());\n            }\n        }\n\n        return jm;\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void init() {\n        EventIpcManagerFactory.init();\n\n        try {\n            NotifdConfigFactory.init();\n        } catch (Throwable t) {\n            ThreadCategory.getInstance(getClass()).warn(\"start: Failed to init NotifdConfigFactory.\", t);\n        }\n        \n        try {\n            DatabaseConnectionFactory.init();\n        } catch (Exception e) {\n            ThreadCategory.getInstance(getClass()).warn(\"start: Failed to init database connection factory.\", e);\n        }\n\n        getNotifd().setDbConnectionFactory(DatabaseConnectionFactory.getInstance());\n        getNotifd().setEventManager(EventIpcManagerFactory.getInstance().getManager());\n        \n        getNotifd().setConfigManager(NotifdConfigFactory.getInstance());\n        getNotifd().init();\n        \n    }","id":25616,"modified_method":"public void init() {\n        EventIpcManagerFactory.init();\n\n        try {\n            NotifdConfigFactory.init();\n        } catch (Throwable t) {\n            ThreadCategory.getInstance(getClass()).warn(\"start: Failed to init NotifdConfigFactory.\", t);\n        }\n        \n        try {\n            NotificationFactory.init();\n        } catch( Throwable t) {\n            ThreadCategory.getInstance(getClass()).warn(\"start: Failed to init NotificationFactory.\", t);\n        }\n        \n        try {\n            DatabaseConnectionFactory.init();\n        } catch (Exception e) {\n            ThreadCategory.getInstance(getClass()).warn(\"start: Failed to init database connection factory.\", e);\n        }\n\n        getNotifd().setDbConnectionFactory(DatabaseConnectionFactory.getInstance());\n        getNotifd().setEventManager(EventIpcManagerFactory.getInstance().getManager());\n        \n        getNotifd().setConfigManager(NotifdConfigFactory.getInstance());\n        getNotifd().setNotificationManager(NotificationFactory.getInstance());\n        getNotifd().setGroupManager(GroupFactory.getInstance());\n        getNotifd().setUserManager(UserFactory.getInstance());\n        getNotifd().init();\n        \n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void setUp() throws Exception {\n        super.setUp();\n\n        MockUtil.setupLogging();\n        MockUtil.resetLogLevel();\n        \n        m_eventMgr = new MockEventIpcManager();\n        \n        m_notifd = new Notifd();\n        m_notifdConfig = new MockNotifdConfigManager(m_configString);\n        // FIXME: Needed to comment these out so the build worked\n        m_notifd.setEventManager(m_eventMgr);\n        m_notifd.setConfigManager(m_notifdConfig);\n        //m_notifd.init();\n        //m_notifd.start();\n    }","id":25617,"modified_method":"protected void setUp() throws Exception {\n        super.setUp();\n\n        MockUtil.setupLogging();\n        MockUtil.resetLogLevel();\n        \n        m_eventMgr = new MockEventIpcManager();\n        \n        m_notifd = new Notifd();\n        m_notifdConfig = new MockNotifdConfigManager(m_configString);\n        m_notifd.setEventManager(m_eventMgr);\n        m_notifd.setConfigManager(m_notifdConfig);\n        \n        m_notificationManager = new MockNotificationManager(m_notifdConfig, NOTIFICATION_MANAGER);\n        m_notifd.setNotificationManager(m_notificationManager);\n        \n        // FIXME: Needed to comment these out so the build worked\n        //m_notifd.init();\n        //m_notifd.start();\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    public static synchronized void reload() throws IOException, MarshalException, ValidationException {\n        m_noticeConfFile = ConfigFileConstants.getFile(ConfigFileConstants.NOTIFICATIONS_CONF_FILE_NAME);\n\n        InputStream configIn = new FileInputStream(m_noticeConfFile);\n        m_lastModified = m_noticeConfFile.lastModified();\n\n        m_notifications = (Notifications) Unmarshaller.unmarshal(Notifications.class, new InputStreamReader(configIn));\n        oldHeader = m_notifications.getHeader();\n    }","id":25618,"modified_method":"/**\n     * \n     */\n    public synchronized void reload() throws IOException, MarshalException, ValidationException {\n        m_noticeConfFile = ConfigFileConstants.getFile(ConfigFileConstants.NOTIFICATIONS_CONF_FILE_NAME);\n\n        InputStream configIn = new FileInputStream(m_noticeConfFile);\n        m_lastModified = m_noticeConfFile.lastModified();\n\n        Reader reader = new InputStreamReader(configIn);\n        parseXML(reader);\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    static synchronized public NotificationFactory getInstance() {\n        if (!initialized)\n            return null;\n\n        if (instance == null) {\n            instance = new NotificationFactory();\n        }\n\n        return instance;\n    }","id":25619,"modified_method":"/**\n     * \n     */\n    static synchronized public NotificationFactory getInstance() {\n        if (!initialized)\n            return null;\n\n        return instance;\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    private void updateFromFile() throws IOException, MarshalException, ValidationException {\n        if (m_lastModified != m_noticeConfFile.lastModified()) {\n            reload();\n        }\n    }","id":25620,"modified_method":"/**\n     * \n     */\n    protected void update() throws IOException, MarshalException, ValidationException {\n        if (m_lastModified != m_noticeConfFile.lastModified()) {\n            reload();\n        }\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    public static synchronized void init() throws IOException, FileNotFoundException, MarshalException, ValidationException, ClassNotFoundException {\n        if (!initialized) {\n            DatabaseConnectionFactory.init();\n            reload();\n            initialized = true;\n        }\n    }","id":25621,"modified_method":"/**\n     * \n     */\n    public static synchronized void init() throws IOException, FileNotFoundException, MarshalException, ValidationException, ClassNotFoundException {\n        if (!initialized) {\n            DatabaseConnectionFactory.init();\n            instance = new NotificationFactory();\n            instance.reload();\n            initialized = true;\n        }\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    private NotificationFactory() {\n    }","id":25622,"modified_method":"/**\n     * \n     */\n    private NotificationFactory() {\n        super(NotifdConfigFactory.getInstance());\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     */\n    public void run() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        boolean responded = false;\n        try {\n            responded = NotificationFactory.getInstance().noticeOutstanding(m_notifyId);\n        } catch (Exception e) {\n            log.error(\"Unable to get response status on notice #\" + m_notifyId, e);\n        }\n\n        // check to see if someone has responded, if so remove all the brothers\n        if (responded) {\n            try {\n                if (UserFactory.getInstance().isUserOnDuty(m_user.getUserId(), Calendar.getInstance())) {\n                    // send the notice\n\n                    ExecutorStrategy command = null;\n\n                    for (int i = 0; i < m_commands.length; i++) {\n                        try {\n                            NotificationFactory.getInstance().updateNoticeWithUserInfo(m_user.getUserId(), m_notifyId, m_commands[i].getName(), UserFactory.getInstance().getContactInfo(m_user.getUserId(), m_commands[i].getName()));\n                        } catch (SQLException e) {\n                            log.error(\"Could not insert notice info into database, aborting send notice...\", e);\n                            continue;\n                        }\n                        String binaryCommand = m_commands[i].getBinary();\n                        if (binaryCommand == null) {\n                            log.error(\"binary flag not set for command: \" + m_commands[i].getExecute() + \".  Guessing false.\");\n                            binaryCommand = \"false\";\n                        }\n                        if (binaryCommand.equals(\"true\")) {\n                            command = new CommandExecutor();\n                        } else {\n                            command = new ClassExecutor();\n                        }\n                        log.debug(\"Class created is: \" + command.getClass());\n\n                        int returnCode = command.execute(m_commands[i].getExecute(), getArgumentList(m_commands[i]));\n                        log.debug(\"command \" + m_commands[i].getName() + \" return code = \" + returnCode);\n                    }\n                } else {\n                    log.debug(\"User \" + m_user.getUserId() + \" is not on duty, skipping...\");\n                }\n            } catch (IOException e) {\n                log.debug(\"Could not get user duty schedule information: \", e);\n            } catch (MarshalException e) {\n                log.debug(\"Could not get user duty schedule information: \", e);\n            } catch (ValidationException e) {\n                log.debug(\"Could not get user duty schedule information: \", e);\n            }\n        } else {\n            // remove all the related notices that have yet to be sent\n            for (int i = 0; i < m_siblings.size(); i++) {\n                NotificationTask task = (NotificationTask) m_siblings.get(i);\n\n                // FIXME: Reported on discuss list and not found to ever\n                // be initialized anywhere.\n                // m_notifTree.remove(task);\n            }\n        }\n    }","id":25623,"modified_method":"/**\n     */\n    public void run() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        boolean responded = false;\n        try {\n            responded = m_notifd.getNotificationManager().noticeOutstanding(m_notifyId);\n        } catch (Exception e) {\n            log.error(\"Unable to get response status on notice #\" + m_notifyId, e);\n        }\n\n        // check to see if someone has responded, if so remove all the brothers\n        if (responded) {\n            try {\n                if (m_notifd.getUserManager().isUserOnDuty(m_user.getUserId(), Calendar.getInstance())) {\n                    // send the notice\n\n                    ExecutorStrategy command = null;\n\n                    for (int i = 0; i < m_commands.length; i++) {\n                        try {\n                            m_notifd.getNotificationManager().updateNoticeWithUserInfo(m_user.getUserId(), m_notifyId, m_commands[i].getName(), m_notifd.getUserManager().getContactInfo(m_user.getUserId(), m_commands[i].getName()));\n                        } catch (SQLException e) {\n                            log.error(\"Could not insert notice info into database, aborting send notice...\", e);\n                            continue;\n                        }\n                        String binaryCommand = m_commands[i].getBinary();\n                        if (binaryCommand == null) {\n                            log.error(\"binary flag not set for command: \" + m_commands[i].getExecute() + \".  Guessing false.\");\n                            binaryCommand = \"false\";\n                        }\n                        if (binaryCommand.equals(\"true\")) {\n                            command = new CommandExecutor();\n                        } else {\n                            command = new ClassExecutor();\n                        }\n                        log.debug(\"Class created is: \" + command.getClass());\n\n                        int returnCode = command.execute(m_commands[i].getExecute(), getArgumentList(m_commands[i]));\n                        log.debug(\"command \" + m_commands[i].getName() + \" return code = \" + returnCode);\n                    }\n                } else {\n                    log.debug(\"User \" + m_user.getUserId() + \" is not on duty, skipping...\");\n                }\n            } catch (IOException e) {\n                log.debug(\"Could not get user duty schedule information: \", e);\n            } catch (MarshalException e) {\n                log.debug(\"Could not get user duty schedule information: \", e);\n            } catch (ValidationException e) {\n                log.debug(\"Could not get user duty schedule information: \", e);\n            }\n        } else {\n            // remove all the related notices that have yet to be sent\n            for (int i = 0; i < m_siblings.size(); i++) {\n                NotificationTask task = (NotificationTask) m_siblings.get(i);\n\n                // FIXME: Reported on discuss list and not found to ever\n                // be initialized anywhere.\n                // m_notifTree.remove(task);\n            }\n        }\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructor, initializes some information\n     * \n     * @param someParams\n     *            the parameters from Notify\n     */\n    public NotificationTask(long sendTime, Map someParams, List siblings) throws SQLException {\n        m_sendTime = sendTime;\n        m_params = new HashMap(someParams);\n        m_siblings = siblings;\n\n        try {\n            UserFactory.init();\n            NotificationFactory.init();\n        } catch (Exception e) {\n            ThreadCategory.getInstance(getClass()).error(\"Error initializing UserFactory or NotificationFactory\", e);\n            throw new UndeclaredThrowableException(e);\n        }\n    }","id":25624,"modified_method":"/**\n     * Constructor, initializes some information\n     * \n     * @param someParams\n     *            the parameters from Notify\n     */\n    public NotificationTask(Notifd notifd, long sendTime, Map someParams, List siblings) throws SQLException {\n        m_notifd = notifd;\n        m_sendTime = sendTime;\n        m_params = new HashMap(someParams);\n        m_siblings = siblings;\n\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    private String getArgumentValue(String aSwitch) {\n        String value = \"\";\n\n        try {\n            if (NotificationFactory.PARAM_DESTINATION.equals(aSwitch)) {\n                value = m_user.getUserId();\n            } else if (NotificationFactory.PARAM_EMAIL.equals(aSwitch)) {\n                value = getEmail(m_user);\n            } else if (NotificationFactory.PARAM_PAGER_EMAIL.equals(aSwitch)) {\n                value = UserFactory.getInstance().getPagerEmail(m_user.getUserId());\n            } else if (NotificationFactory.PARAM_TEXT_PAGER_PIN.equals(aSwitch)) {\n                value = UserFactory.getInstance().getTextPin(m_user.getUserId());\n            } else if (NotificationFactory.PARAM_NUM_PAGER_PIN.equals(aSwitch)) {\n                value = UserFactory.getInstance().getNumericPin(m_user.getUserId());\n            } else if (m_params.containsKey(aSwitch)) {\n                value = (String) m_params.get(aSwitch);\n            }\n        } catch (Exception e) {\n            ThreadCategory.getInstance(getClass()).error(\"unable to get value for parameter \" + aSwitch);\n        }\n\n        return value;\n    }","id":25625,"modified_method":"/**\n     * \n     */\n    private String getArgumentValue(String aSwitch) {\n        String value = \"\";\n\n        try {\n            if (NotificationManager.PARAM_DESTINATION.equals(aSwitch)) {\n                value = m_user.getUserId();\n            } else if (NotificationManager.PARAM_EMAIL.equals(aSwitch)) {\n                value = getEmail(m_user);\n            } else if (NotificationManager.PARAM_PAGER_EMAIL.equals(aSwitch)) {\n                value = m_notifd.getUserManager().getPagerEmail(m_user.getUserId());\n            } else if (NotificationManager.PARAM_TEXT_PAGER_PIN.equals(aSwitch)) {\n                value = m_notifd.getUserManager().getTextPin(m_user.getUserId());\n            } else if (NotificationManager.PARAM_NUM_PAGER_PIN.equals(aSwitch)) {\n                value = m_notifd.getUserManager().getNumericPin(m_user.getUserId());\n            } else if (m_params.containsKey(aSwitch)) {\n                value = (String) m_params.get(aSwitch);\n            }\n        } catch (Exception e) {\n            ThreadCategory.getInstance(getClass()).error(\"unable to get value for parameter \" + aSwitch);\n        }\n\n        return value;\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return the password of this Principal.\n     */\n    public boolean comparePasswords(String password) {\n        return (this.userInfo.getPassword().equals(UserFactory.encryptPassword(password)));\n    }","id":25626,"modified_method":"/**\n     * Return the password of this Principal.\n     */\n    public boolean comparePasswords(String password) {\n        return (this.userInfo.getPassword().equals(UserFactory.getInstance().encryptedPassword(password)));\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Checks the last modified time of the user and magic users files against\n     * the last known last modified time. If the times are different, then the\n     * files must be reparsed.\n     * \n     * <p>\n     * Note that the <code>lastModified<\/code> variables are not set here.\n     * This is in case there is a problem parsing either file. If we set the\n     * value here, and then try to parse and fail, then we will not try to parse\n     * again until the file changes again. Instead, when we see the file\n     * changes, we continue parsing attempts until the parsing succeeds.\n     * <\/p>\n     */\n    protected boolean isParseNecessary() {\n        boolean necessary = false;\n\n        if (UserFactory.updateNeeded()) {\n            necessary = true;\n        }\n\n        if (this.magicUsersFile != null && this.magicUsersFile.lastModified() != this.magicUsersLastModified) {\n            necessary = true;\n        }\n\n        return (necessary);\n    }","id":25627,"modified_method":"/**\n     * Checks the last modified time of the user and magic users files against\n     * the last known last modified time. If the times are different, then the\n     * files must be reparsed.\n     * \n     * <p>\n     * Note that the <code>lastModified<\/code> variables are not set here.\n     * This is in case there is a problem parsing either file. If we set the\n     * value here, and then try to parse and fail, then we will not try to parse\n     * again until the file changes again. Instead, when we see the file\n     * changes, we continue parsing attempts until the parsing succeeds.\n     * <\/p>\n     */\n    protected boolean isParseNecessary() {\n        boolean necessary = false;\n\n        if (UserFactory.getInstance().isUpdateNeeded()) {\n            necessary = true;\n        }\n\n        if (this.magicUsersFile != null && this.magicUsersFile.lastModified() != this.magicUsersLastModified) {\n            necessary = true;\n        }\n\n        return (necessary);\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Convenience method for parsing the users.xml file.\n     * \n     * <p>\n     * This method is synchronized so only one thread at a time can parse the\n     * users.xml file and create the <code>principal<\/code> instance variable.\n     * <\/p>\n     */\n    protected synchronized void parse() {\n        // reset the principals cache\n        this.principals = new HashMap();\n\n        try {\n            // load the regular users\n            UserFactory.reload();\n            UserFactory factory = UserFactory.getInstance();\n            this.log.debug(\"Reloaded the users.xml file into memory\");\n\n            Map map = factory.getUsers();\n            this.log.debug(\"Loaded \" + map.size() + \" users into memory\");\n\n            Iterator iterator = map.keySet().iterator();\n\n            while (iterator.hasNext()) {\n                String key = (String) iterator.next();\n                OpenNMSPrincipal principal = new OpenNMSPrincipal((User) map.get(key));\n                this.principals.put(key, principal);\n            }\n\n            this.log.debug(\"Loaded the regular users into the principal cache\");\n        } catch (MarshalException e) {\n            this.log.error(\"Could not parse the users.xml file\", e);\n        } catch (ValidationException e) {\n            this.log.error(\"Could not parse the users.xml file\", e);\n        } catch (FileNotFoundException e) {\n            this.log.error(\"Could not find the users.xml file\", e);\n        } catch (Exception e) {\n            this.log.error(\"Unexpected exception parsing users.xml file\", e);\n        }\n\n        try {\n            // load the \"magic\" users\n            Map[] maps = this.parseMagicUsers();\n            Map magicUserToPasswordMapping = maps[0];\n            this.magicRoleMapping = maps[1];\n            this.log.debug(\"Loaded the magic user config file\");\n\n            Iterator iterator = magicUserToPasswordMapping.keySet().iterator();\n\n            while (iterator.hasNext()) {\n                String name = (String) iterator.next();\n                String password = (String) magicUserToPasswordMapping.get(name);\n\n                User magicUser = new User();\n                magicUser.setUserId(name);\n                magicUser.setPassword(UserFactory.encryptPassword(password));\n\n                this.principals.put(name, new OpenNMSPrincipal(magicUser));\n            }\n\n            this.log.debug(\"Loaded the magic users into the principal cache\");\n\n            this.magicUsersLastModified = this.magicUsersFile.lastModified();\n            this.log.debug(\"Updated the magic user file last modified time stamp to \" + this.magicUsersLastModified);\n        } catch (FileNotFoundException e) {\n            this.log.error(\"Could not find the magic users file\", e);\n        } catch (IOException e) {\n            this.log.error(\"Could not read the magic users file\", e);\n        } catch (Exception e) {\n            this.log.error(\"Unexpected exception parsing users.xml file\", e);\n        }\n    }","id":25628,"modified_method":"/**\n     * Convenience method for parsing the users.xml file.\n     * \n     * <p>\n     * This method is synchronized so only one thread at a time can parse the\n     * users.xml file and create the <code>principal<\/code> instance variable.\n     * <\/p>\n     */\n    protected synchronized void parse() {\n        // reset the principals cache\n        this.principals = new HashMap();\n\n        try {\n            UserFactory.getInstance().reload();\n            UserFactory factory = UserFactory.getInstance();\n            this.log.debug(\"Reloaded the users.xml file into memory\");\n\n            Map map = factory.getUsers();\n            this.log.debug(\"Loaded \" + map.size() + \" users into memory\");\n\n            Iterator iterator = map.keySet().iterator();\n\n            while (iterator.hasNext()) {\n                String key = (String) iterator.next();\n                OpenNMSPrincipal principal = new OpenNMSPrincipal((User) map.get(key));\n                this.principals.put(key, principal);\n            }\n\n            this.log.debug(\"Loaded the regular users into the principal cache\");\n        } catch (MarshalException e) {\n            this.log.error(\"Could not parse the users.xml file\", e);\n        } catch (ValidationException e) {\n            this.log.error(\"Could not parse the users.xml file\", e);\n        } catch (FileNotFoundException e) {\n            this.log.error(\"Could not find the users.xml file\", e);\n        } catch (Exception e) {\n            this.log.error(\"Unexpected exception parsing users.xml file\", e);\n        }\n\n        try {\n            // load the \"magic\" users\n            Map[] maps = this.parseMagicUsers();\n            Map magicUserToPasswordMapping = maps[0];\n            this.magicRoleMapping = maps[1];\n            this.log.debug(\"Loaded the magic user config file\");\n\n            Iterator iterator = magicUserToPasswordMapping.keySet().iterator();\n\n            while (iterator.hasNext()) {\n                String name = (String) iterator.next();\n                String password = (String) magicUserToPasswordMapping.get(name);\n\n                User magicUser = new User();\n                magicUser.setUserId(name);\n                magicUser.setPassword(UserFactory.getInstance().encryptedPassword(password));\n\n                this.principals.put(name, new OpenNMSPrincipal(magicUser));\n            }\n\n            this.log.debug(\"Loaded the magic users into the principal cache\");\n\n            this.magicUsersLastModified = this.magicUsersFile.lastModified();\n            this.log.debug(\"Updated the magic user file last modified time stamp to \" + this.magicUsersLastModified);\n        } catch (FileNotFoundException e) {\n            this.log.error(\"Could not find the magic users file\", e);\n        } catch (IOException e) {\n            this.log.error(\"Could not read the magic users file\", e);\n        } catch (Exception e) {\n            this.log.error(\"Unexpected exception parsing users.xml file\", e);\n        }\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession userSession = request.getSession(false);\n\n        if (userSession != null) {\n            User newUser = (User) userSession.getAttribute(\"user.modifyUser.jsp\");\n            UserFactory userFactory;\n            try {\n                UserFactory.init();\n            } catch (Exception e) {\n                throw new ServletException(\"UpdateUserServlet:init Error initialising UserFactory \" + e);\n            }\n            userFactory = UserFactory.getInstance();\n\n            // get the rest of the user information from the form\n            newUser.setFullName(request.getParameter(\"fullName\"));\n            newUser.setUserComments(request.getParameter(\"comments\"));\n\n            String password = request.getParameter(\"password\");\n            if (password != null && !password.trim().equals(\"\")) {\n                newUser.setPassword(UserFactory.encryptPassword(password));\n            }\n\n            String userid = newUser.getUserId();\n            String email = request.getParameter(\"email\");\n            String pagerEmail = request.getParameter(\"pemail\");\n            String numericPage = request.getParameter(\"numericalService\");\n            String numericPin = request.getParameter(\"numericalPin\");\n            String textPage = request.getParameter(\"textService\");\n            String textPin = request.getParameter(\"textPin\");\n\n            newUser.clearContact();\n\n            Contact tmpContact = new Contact();\n            tmpContact.setInfo(email);\n            tmpContact.setType(\"email\");\n            newUser.addContact(tmpContact);\n\n            tmpContact = new Contact();\n            tmpContact.setInfo(pagerEmail);\n            tmpContact.setType(\"pagerEmail\");\n            newUser.addContact(tmpContact);\n\n            tmpContact = new Contact();\n            tmpContact.setInfo(numericPin);\n            tmpContact.setServiceProvider(numericPage);\n            tmpContact.setType(\"numericPage\");\n            newUser.addContact(tmpContact);\n\n            tmpContact = new Contact();\n            tmpContact.setInfo(textPin);\n            tmpContact.setServiceProvider(textPage);\n            tmpContact.setType(\"textPage\");\n            newUser.addContact(tmpContact);\n\n            // build the duty schedule data structure\n            Vector newSchedule = new Vector();\n            ChoiceFormat days = new ChoiceFormat(\"0#Mo|1#Tu|2#We|3#Th|4#Fr|5#Sa|6#Su\");\n\n            Collection dutySchedules = newUser.getDutyScheduleCollection();\n            dutySchedules.clear();\n\n            int dutyCount = Integer.parseInt(request.getParameter(\"dutySchedules\"));\n            for (int duties = 0; duties < dutyCount; duties++) {\n                newSchedule.clear();\n                String deleteFlag = request.getParameter(\"deleteDuty\" + duties);\n                // don't save any duties that were marked for deletion\n                if (deleteFlag == null) {\n                    for (int i = 0; i < 7; i++) {\n                        String curDayFlag = request.getParameter(\"duty\" + duties + days.format(i));\n                        if (curDayFlag != null) {\n                            newSchedule.addElement(new Boolean(true));\n                        } else {\n                            newSchedule.addElement(new Boolean(false));\n                        }\n                    }\n\n                    newSchedule.addElement(request.getParameter(\"duty\" + duties + \"Begin\"));\n                    newSchedule.addElement(request.getParameter(\"duty\" + duties + \"End\"));\n\n                    DutySchedule newDuty = new DutySchedule(newSchedule);\n                    dutySchedules.add(newDuty.toString());\n                }\n            }\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n        }\n\n        // forward the request for proper display\n        RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(request.getParameter(\"redirect\"));\n        dispatcher.forward(request, response);\n    }","id":25629,"modified_method":"public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession userSession = request.getSession(false);\n\n        if (userSession != null) {\n            User newUser = (User) userSession.getAttribute(\"user.modifyUser.jsp\");\n            UserFactory userFactory;\n            try {\n                UserFactory.init();\n            } catch (Exception e) {\n                throw new ServletException(\"UpdateUserServlet:init Error initialising UserFactory \" + e);\n            }\n            userFactory = UserFactory.getInstance();\n\n            // get the rest of the user information from the form\n            newUser.setFullName(request.getParameter(\"fullName\"));\n            newUser.setUserComments(request.getParameter(\"comments\"));\n\n            String password = request.getParameter(\"password\");\n            if (password != null && !password.trim().equals(\"\")) {\n                newUser.setPassword(UserFactory.getInstance().encryptedPassword(password));\n            }\n\n            String userid = newUser.getUserId();\n            String email = request.getParameter(\"email\");\n            String pagerEmail = request.getParameter(\"pemail\");\n            String numericPage = request.getParameter(\"numericalService\");\n            String numericPin = request.getParameter(\"numericalPin\");\n            String textPage = request.getParameter(\"textService\");\n            String textPin = request.getParameter(\"textPin\");\n\n            newUser.clearContact();\n\n            Contact tmpContact = new Contact();\n            tmpContact.setInfo(email);\n            tmpContact.setType(\"email\");\n            newUser.addContact(tmpContact);\n\n            tmpContact = new Contact();\n            tmpContact.setInfo(pagerEmail);\n            tmpContact.setType(\"pagerEmail\");\n            newUser.addContact(tmpContact);\n\n            tmpContact = new Contact();\n            tmpContact.setInfo(numericPin);\n            tmpContact.setServiceProvider(numericPage);\n            tmpContact.setType(\"numericPage\");\n            newUser.addContact(tmpContact);\n\n            tmpContact = new Contact();\n            tmpContact.setInfo(textPin);\n            tmpContact.setServiceProvider(textPage);\n            tmpContact.setType(\"textPage\");\n            newUser.addContact(tmpContact);\n\n            // build the duty schedule data structure\n            Vector newSchedule = new Vector();\n            ChoiceFormat days = new ChoiceFormat(\"0#Mo|1#Tu|2#We|3#Th|4#Fr|5#Sa|6#Su\");\n\n            Collection dutySchedules = newUser.getDutyScheduleCollection();\n            dutySchedules.clear();\n\n            int dutyCount = Integer.parseInt(request.getParameter(\"dutySchedules\"));\n            for (int duties = 0; duties < dutyCount; duties++) {\n                newSchedule.clear();\n                String deleteFlag = request.getParameter(\"deleteDuty\" + duties);\n                // don't save any duties that were marked for deletion\n                if (deleteFlag == null) {\n                    for (int i = 0; i < 7; i++) {\n                        String curDayFlag = request.getParameter(\"duty\" + duties + days.format(i));\n                        if (curDayFlag != null) {\n                            newSchedule.addElement(new Boolean(true));\n                        } else {\n                            newSchedule.addElement(new Boolean(false));\n                        }\n                    }\n\n                    newSchedule.addElement(request.getParameter(\"duty\" + duties + \"Begin\"));\n                    newSchedule.addElement(request.getParameter(\"duty\" + duties + \"End\"));\n\n                    DutySchedule newDuty = new DutySchedule(newSchedule);\n                    dutySchedules.add(newDuty.toString());\n                }\n            }\n            userSession.setAttribute(\"user.modifyUser.jsp\", newUser);\n        }\n\n        // forward the request for proper display\n        RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(request.getParameter(\"redirect\"));\n        dispatcher.forward(request, response);\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Singleton static call to get the only instance that should exist for the\n     * UserFactory\n     * \n     * @return the single user factory instance\n     */\n    static synchronized public UserFactory getInstance() {\n        if (!initialized)\n            return null;\n\n        if (instance == null) {\n            instance = new UserFactory();\n        }\n\n        return instance;\n    }","id":25630,"modified_method":"/**\n     * Singleton static call to get the only instance that should exist for the\n     * UserFactory\n     * \n     * @return the single user factory instance\n     */\n    static synchronized public UserFactory getInstance() {\n        if (!initialized)\n            return null;\n\n        return instance;\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Initializes the factory\n     */\n    public UserFactory() {\n    }","id":25631,"modified_method":"/**\n     * Initializes the factory\n     */\n    public UserFactory() {\n        groupFactory = GroupFactory.getInstance();\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static synchronized void init() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        if (!initialized) {\n            reload();\n        }\n        GroupFactory.init();\n        // ViewFactory.init();\n        groupFactory = GroupFactory.getInstance();\n        // viewFactory = ViewFactory.getInstance();\n\n    }","id":25632,"modified_method":"public static synchronized void init() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        if (!initialized) {\n            GroupFactory.init();\n            instance = new UserFactory();\n            instance.reload();\n            \n        }\n        // ViewFactory.init();\n        // viewFactory = ViewFactory.getInstance();\n\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the users.xml via the Castor classes\n     */\n    public static synchronized void reload() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        // Form the complete filename for the config file\n        //\n        m_usersConfFile = ConfigFileConstants.getFile(ConfigFileConstants.USERS_CONF_FILE_NAME);\n\n        InputStream configIn = new FileInputStream(m_usersConfFile);\n        m_lastModified = m_usersConfFile.lastModified();\n\n        Userinfo userinfo = (Userinfo) Unmarshaller.unmarshal(Userinfo.class, new InputStreamReader(configIn));\n        Users users = userinfo.getUsers();\n        oldHeader = userinfo.getHeader();\n        Collection usersList = users.getUserCollection();\n        m_users = new HashMap();\n\n        Iterator i = usersList.iterator();\n        while (i.hasNext()) {\n            User curUser = (User) i.next();\n            m_users.put(curUser.getUserId(), curUser);\n        }\n\n        buildDutySchedules(m_users);\n\n        initialized = true;\n    }","id":25633,"modified_method":"/**\n     * @throws IOException\n     * @throws FileNotFoundException\n     * @throws MarshalException\n     * @throws ValidationException\n     */\n    public void reload() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        // Form the complete filename for the config file\n        //\n        m_usersConfFile = ConfigFileConstants.getFile(ConfigFileConstants.USERS_CONF_FILE_NAME);\n\n        InputStream configIn = new FileInputStream(m_usersConfFile);\n        m_lastModified = m_usersConfFile.lastModified();\n\n        Reader reader = new InputStreamReader(configIn);\n        parseXML(reader);\n        \n        initialized = true;\n\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    private static void updateFromFile() throws IOException, MarshalException, ValidationException {\n        if (updateNeeded()) {\n            reload();\n        }\n    }","id":25634,"modified_method":"/**\n     * @throws IOException\n     * @throws FileNotFoundException\n     * @throws MarshalException\n     * @throws ValidationException\n     */\n    protected void update() throws IOException, FileNotFoundException, MarshalException, ValidationException {\n        if (isUpdateNeeded()) {\n            reload();\n        }\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    public static boolean updateNeeded() {\n        if (m_usersConfFile == null) {\n            return true;\n        }\n        if (m_lastModified != m_usersConfFile.lastModified()) {\n            return true;\n        }\n        return false;\n    }","id":25635,"modified_method":"/**\n     * @return\n     */\n    public boolean isUpdateNeeded() {\n        if (m_usersConfFile == null) {\n            return true;\n        }\n        if (m_lastModified != m_usersConfFile.lastModified()) {\n            return true;\n        }\n        return false;\n    }","commit_id":"b6e633e45d754b326d067f00f60cd3ccc9d93c5d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\r\n  public boolean onRecordBeforeDelete(final ODocument iDocument) {\r\n    if (iDocument.fields() == 0)\r\n      // FORCE LOADING OF CLASS+FIELDS TO USE IT AFTER ON onRecordAfterDelete METHOD\r\n      iDocument.reload();\r\n    return false;\r\n  }","id":25636,"modified_method":"@Override\r\n  public boolean onRecordBeforeDelete(final ODocument iDocument) {\r\n    final int version = iDocument.getVersion(); // Cache the transaction-provided value\r\n    if (iDocument.fields() == 0) {\r\n      // FORCE LOADING OF CLASS+FIELDS TO USE IT AFTER ON onRecordAfterDelete METHOD\r\n      iDocument.reload();\r\n      if (version > -1 && iDocument.getVersion() != version) // check for record version errors\r\n        throw new OConcurrentModificationException(\r\n            \"Cannot delete the record \"\r\n                + iDocument.getIdentity()\r\n                + \"' because the version is not the latest. Probably you are deleting an old record or it has been modified by another user (db=v\"\r\n                + iDocument.getVersion() + \" your=v\" + version + \")\", iDocument.getIdentity(), iDocument.getVersion(), version);\r\n    }\r\n\r\n    return false;\r\n  }","commit_id":"ba72a4a2bf988058a7d13c1ef4e62672a29b2ea1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void reload(DeployedApplication app) {\n        if(log.isInfoEnabled())\n            log.info(sm.getString(\"hostConfig.reload\", app.name));\n        Context context = (Context) host.findChild(app.name);\n        if (context.getState().isAvailable()) {\n            // Reload catches and logs exceptions\n            context.reload();\n        } else {\n            // If the context was not started (for example an error\n            // in web.xml) we'll still get to try to start\n            try {\n                context.start();\n            } catch (Exception e) {\n                log.warn(sm.getString\n                         (\"hostConfig.context.restart\", app.name), e);\n            }\n        }\n    }","id":25637,"modified_method":"private void reload(DeployedApplication app, File fileToRemove, String newDocBase) {\n        if(log.isInfoEnabled())\n            log.info(sm.getString(\"hostConfig.reload\", app.name));\n        Context context = (Context) host.findChild(app.name);\n        if (context.getState().isAvailable()) {\n            if (fileToRemove != null && newDocBase != null) {\n                context.addLifecycleListener(\n                        new ExpandedDirectoryRemovalListener(fileToRemove, newDocBase));\n            }\n            // Reload catches and logs exceptions\n            context.reload();\n        } else {\n            // If the context was not started (for example an error\n            // in web.xml) we'll still get to try to start\n            if (fileToRemove != null && newDocBase != null) {\n                ExpandWar.delete(fileToRemove);\n                context.setDocBase(newDocBase);\n            }\n            try {\n                context.start();\n            } catch (Exception e) {\n                log.warn(sm.getString\n                         (\"hostConfig.context.restart\", app.name), e);\n            }\n        }\n    }","commit_id":"07b0ab07bb9b0d8170f2596bbc7218b458010f75","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Check resources for redeployment and reloading.\n     */\n    protected synchronized void checkResources(DeployedApplication app) {\n        String[] resources =\n            app.redeployResources.keySet().toArray(new String[0]);\n        // Offset the current time by the resolution of File.lastModified()\n        long currentTimeWithResolutionOffset =\n                System.currentTimeMillis() - FILE_MODIFICATION_RESOLUTION_MS;\n        for (int i = 0; i < resources.length; i++) {\n            File resource = new File(resources[i]);\n            if (log.isDebugEnabled())\n                log.debug(\"Checking context[\" + app.name +\n                        \"] redeploy resource \" + resource);\n            long lastModified =\n                    app.redeployResources.get(resources[i]).longValue();\n            if (resource.exists() || lastModified == 0) {\n                // File.lastModified() has a resolution of 1s (1000ms). The last\n                // modified time has to be more than 1000ms ago to ensure that\n                // modifications that take place in the same second are not\n                // missed. See Bug 57765.\n                if (resource.lastModified() != lastModified && (!host.getAutoDeploy() ||\n                        resource.lastModified() < currentTimeWithResolutionOffset)) {\n                    if (resource.isDirectory()) {\n                        // No action required for modified directory\n                        app.redeployResources.put(resources[i],\n                                Long.valueOf(resource.lastModified()));\n                    } else if (app.hasDescriptor &&\n                            resource.getName().toLowerCase(\n                                    Locale.ENGLISH).endsWith(\".war\")) {\n                        // Modified WAR triggers a reload if there is an XML\n                        // file present\n                        // The only resource that should be deleted is the\n                        // expanded WAR (if any)\n                        Context context = (Context) host.findChild(app.name);\n                        String docBase = context.getDocBase();\n                        if (!docBase.toLowerCase(Locale.ENGLISH).endsWith(\".war\")) {\n                            // This is an expanded directory\n                            File docBaseFile = new File(docBase);\n                            if (!docBaseFile.isAbsolute()) {\n                                docBaseFile = new File(host.getAppBaseFile(),\n                                        docBase);\n                            }\n                            ExpandWar.delete(docBaseFile);\n                            // Reset the docBase to trigger re-expansion of the\n                            // WAR\n                            context.setDocBase(resource.getAbsolutePath());\n                        }\n                        reload(app);\n                        // Update times\n                        app.redeployResources.put(resources[i],\n                                Long.valueOf(resource.lastModified()));\n                        app.timestamp = System.currentTimeMillis();\n                        boolean unpackWAR = unpackWARs;\n                        if (unpackWAR && context instanceof StandardContext) {\n                            unpackWAR = ((StandardContext) context).getUnpackWAR();\n                        }\n                        if (unpackWAR) {\n                            addWatchedResources(app, context.getDocBase(), context);\n                        } else {\n                            addWatchedResources(app, null, context);\n                        }\n                        return;\n                    } else {\n                        // Everything else triggers a redeploy\n                        // (just need to undeploy here, deploy will follow)\n                        undeploy(app);\n                        deleteRedeployResources(app, resources, i, false);\n                        return;\n                    }\n                }\n            } else {\n                // There is a chance the the resource was only missing\n                // temporarily eg renamed during a text editor save\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e1) {\n                    // Ignore\n                }\n                // Recheck the resource to see if it was really deleted\n                if (resource.exists()) {\n                    continue;\n                }\n                if (lastModified == 0L) {\n                    continue;\n                }\n                // Undeploy application\n                undeploy(app);\n                deleteRedeployResources(app, resources, i, true);\n                return;\n            }\n        }\n        resources = app.reloadResources.keySet().toArray(new String[0]);\n        boolean update = false;\n        for (int i = 0; i < resources.length; i++) {\n            File resource = new File(resources[i]);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Checking context[\" + app.name + \"] reload resource \" + resource);\n            }\n            long lastModified = app.reloadResources.get(resources[i]).longValue();\n            // File.lastModified() has a resolution of 1s (1000ms). The last\n            // modified time has to be more than 1000ms ago to ensure that\n            // modifications that take place in the same second are not\n            // missed. See Bug 57765.\n            if ((resource.lastModified() != lastModified &&\n                    (!host.getAutoDeploy() ||\n                            resource.lastModified() < currentTimeWithResolutionOffset)) ||\n                    update) {\n                if (!update) {\n                    // Reload application\n                    reload(app);\n                    update = true;\n                }\n                // Update times. More than one file may have been updated. We\n                // don't want to trigger a series of reloads.\n                app.reloadResources.put(resources[i],\n                        Long.valueOf(resource.lastModified()));\n            }\n            app.timestamp = System.currentTimeMillis();\n        }\n    }","id":25638,"modified_method":"/**\n     * Check resources for redeployment and reloading.\n     */\n    protected synchronized void checkResources(DeployedApplication app) {\n        String[] resources =\n            app.redeployResources.keySet().toArray(new String[0]);\n        // Offset the current time by the resolution of File.lastModified()\n        long currentTimeWithResolutionOffset =\n                System.currentTimeMillis() - FILE_MODIFICATION_RESOLUTION_MS;\n        for (int i = 0; i < resources.length; i++) {\n            File resource = new File(resources[i]);\n            if (log.isDebugEnabled())\n                log.debug(\"Checking context[\" + app.name +\n                        \"] redeploy resource \" + resource);\n            long lastModified =\n                    app.redeployResources.get(resources[i]).longValue();\n            if (resource.exists() || lastModified == 0) {\n                // File.lastModified() has a resolution of 1s (1000ms). The last\n                // modified time has to be more than 1000ms ago to ensure that\n                // modifications that take place in the same second are not\n                // missed. See Bug 57765.\n                if (resource.lastModified() != lastModified && (!host.getAutoDeploy() ||\n                        resource.lastModified() < currentTimeWithResolutionOffset)) {\n                    if (resource.isDirectory()) {\n                        // No action required for modified directory\n                        app.redeployResources.put(resources[i],\n                                Long.valueOf(resource.lastModified()));\n                    } else if (app.hasDescriptor &&\n                            resource.getName().toLowerCase(\n                                    Locale.ENGLISH).endsWith(\".war\")) {\n                        // Modified WAR triggers a reload if there is an XML\n                        // file present\n                        // The only resource that should be deleted is the\n                        // expanded WAR (if any)\n                        Context context = (Context) host.findChild(app.name);\n                        String docBase = context.getDocBase();\n                        if (!docBase.toLowerCase(Locale.ENGLISH).endsWith(\".war\")) {\n                            // This is an expanded directory\n                            File docBaseFile = new File(docBase);\n                            if (!docBaseFile.isAbsolute()) {\n                                docBaseFile = new File(host.getAppBaseFile(),\n                                        docBase);\n                            }\n                            reload(app, docBaseFile, resource.getAbsolutePath());\n                        } else {\n                            reload(app, null, null);\n                        }\n                        // Update times\n                        app.redeployResources.put(resources[i],\n                                Long.valueOf(resource.lastModified()));\n                        app.timestamp = System.currentTimeMillis();\n                        boolean unpackWAR = unpackWARs;\n                        if (unpackWAR && context instanceof StandardContext) {\n                            unpackWAR = ((StandardContext) context).getUnpackWAR();\n                        }\n                        if (unpackWAR) {\n                            addWatchedResources(app, context.getDocBase(), context);\n                        } else {\n                            addWatchedResources(app, null, context);\n                        }\n                        return;\n                    } else {\n                        // Everything else triggers a redeploy\n                        // (just need to undeploy here, deploy will follow)\n                        undeploy(app);\n                        deleteRedeployResources(app, resources, i, false);\n                        return;\n                    }\n                }\n            } else {\n                // There is a chance the the resource was only missing\n                // temporarily eg renamed during a text editor save\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e1) {\n                    // Ignore\n                }\n                // Recheck the resource to see if it was really deleted\n                if (resource.exists()) {\n                    continue;\n                }\n                if (lastModified == 0L) {\n                    continue;\n                }\n                // Undeploy application\n                undeploy(app);\n                deleteRedeployResources(app, resources, i, true);\n                return;\n            }\n        }\n        resources = app.reloadResources.keySet().toArray(new String[0]);\n        boolean update = false;\n        for (int i = 0; i < resources.length; i++) {\n            File resource = new File(resources[i]);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Checking context[\" + app.name + \"] reload resource \" + resource);\n            }\n            long lastModified = app.reloadResources.get(resources[i]).longValue();\n            // File.lastModified() has a resolution of 1s (1000ms). The last\n            // modified time has to be more than 1000ms ago to ensure that\n            // modifications that take place in the same second are not\n            // missed. See Bug 57765.\n            if ((resource.lastModified() != lastModified &&\n                    (!host.getAutoDeploy() ||\n                            resource.lastModified() < currentTimeWithResolutionOffset)) ||\n                    update) {\n                if (!update) {\n                    // Reload application\n                    reload(app, null, null);\n                    update = true;\n                }\n                // Update times. More than one file may have been updated. We\n                // don't want to trigger a series of reloads.\n                app.reloadResources.put(resources[i],\n                        Long.valueOf(resource.lastModified()));\n            }\n            app.timestamp = System.currentTimeMillis();\n        }\n    }","commit_id":"07b0ab07bb9b0d8170f2596bbc7218b458010f75","url":"https://github.com/apache/tomcat"},{"original_method":"protected boolean executeSearchRecord(final OIdentifiable id, final OCommandContext iContext) {\r\n    if (id == null)\r\n      return false;\r\n\r\n    final ORID identity = id.getIdentity();\r\n\r\n    if (uniqueResult != null) {\r\n      if (uniqueResult.containsKey(identity))\r\n        return true;\r\n\r\n      if (identity.isValid())\r\n        uniqueResult.put(identity, identity);\r\n    }\r\n\r\n    if (!checkInterruption())\r\n      return false;\r\n\r\n    final LOCKING_STRATEGY contextLockingStrategy = iContext.getVariable(\"$locking\") != null\r\n        ? (LOCKING_STRATEGY) iContext.getVariable(\"$locking\") : null;\r\n\r\n    final LOCKING_STRATEGY localLockingStrategy = contextLockingStrategy != null ? contextLockingStrategy : lockingStrategy;\r\n\r\n    if (localLockingStrategy != null\r\n        && !(localLockingStrategy == LOCKING_STRATEGY.DEFAULT || localLockingStrategy == LOCKING_STRATEGY.NONE\r\n        || localLockingStrategy == LOCKING_STRATEGY.EXCLUSIVE_LOCK || localLockingStrategy == LOCKING_STRATEGY.SHARED_LOCK))\r\n      throw new IllegalStateException(\"Unsupported locking strategy \" + localLockingStrategy);\r\n\r\n    final ORecord record;\r\n    if (!(id instanceof ORecord)) {\r\n      record = getDatabase().load(id.getIdentity(), null, !isUseCache());\r\n      if (id instanceof OContextualRecordId && ((OContextualRecordId) id).getContext() != null) {\r\n        Map<String, Object> ridContext = ((OContextualRecordId) id).getContext();\r\n        for (String key : ridContext.keySet()) {\r\n          context.setVariable(key, ridContext.get(key));\r\n        }\r\n      }\r\n    } else {\r\n      record = (ORecord) id;\r\n    }\r\n\r\n    iContext.updateMetric(\"recordReads\", +1);\r\n\r\n    if (record == null || ORecordInternal.getRecordType(record) != ODocument.RECORD_TYPE)\r\n      // SKIP IT\r\n      return true;\r\n\r\n    iContext.updateMetric(\"documentReads\", +1);\r\n\r\n    if (localLockingStrategy == LOCKING_STRATEGY.SHARED_LOCK) {\r\n      record.lock(false);\r\n      record.reload(null, true, false);\r\n    } else if (localLockingStrategy == LOCKING_STRATEGY.EXCLUSIVE_LOCK) {\r\n      record.lock(true);\r\n      record.reload(null, true, false);\r\n    }\r\n\r\n    try {\r\n      iContext.setVariable(\"current\", record);\r\n\r\n      if (filter(record, iContext)) {\r\n        if (parallel) {\r\n          {\r\n            try {\r\n              applyGroupBy(record, iContext);\r\n              resultQueue.put(new AsyncResult(record, iContext));\r\n            } catch (InterruptedException e) {\r\n              Thread.interrupted();\r\n              return false;\r\n            }\r\n            tmpQueueOffer.incrementAndGet();\r\n          }\r\n        } else {\r\n          applyGroupBy(record, iContext);\r\n\r\n          if (!handleResult(record, iContext)) {\r\n            // LIMIT REACHED\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n    } finally {\r\n      if (localLockingStrategy != null && record.isLocked()) {\r\n        // CONTEXT LOCK: lock must be released (no matter if filtered or not)\r\n        if (localLockingStrategy == LOCKING_STRATEGY.EXCLUSIVE_LOCK || localLockingStrategy == LOCKING_STRATEGY.SHARED_LOCK) {\r\n          record.unlock();\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }","id":25639,"modified_method":"protected boolean executeSearchRecord(final OIdentifiable id, final OCommandContext iContext) {\r\n    if (id == null)\r\n      return false;\r\n\r\n    final ORID identity = id.getIdentity();\r\n\r\n    if (uniqueResult != null) {\r\n      if (uniqueResult.containsKey(identity))\r\n        return true;\r\n\r\n      if (identity.isValid())\r\n        uniqueResult.put(identity, identity);\r\n    }\r\n\r\n    if (!checkInterruption())\r\n      return false;\r\n\r\n    final LOCKING_STRATEGY contextLockingStrategy =\r\n        iContext.getVariable(\"$locking\") != null ? (LOCKING_STRATEGY) iContext.getVariable(\"$locking\") : null;\r\n\r\n    final LOCKING_STRATEGY localLockingStrategy = contextLockingStrategy != null ? contextLockingStrategy : lockingStrategy;\r\n\r\n    if (localLockingStrategy != null && !(localLockingStrategy == LOCKING_STRATEGY.DEFAULT\r\n        || localLockingStrategy == LOCKING_STRATEGY.NONE || localLockingStrategy == LOCKING_STRATEGY.EXCLUSIVE_LOCK\r\n        || localLockingStrategy == LOCKING_STRATEGY.SHARED_LOCK))\r\n      throw new IllegalStateException(\"Unsupported locking strategy \" + localLockingStrategy);\r\n\r\n    if (localLockingStrategy == LOCKING_STRATEGY.SHARED_LOCK) {\r\n      id.lock(false);\r\n\r\n      if (id instanceof ORecord) {\r\n        final ORecord record = (ORecord) id;\r\n        record.reload(null, true, false);\r\n      }\r\n\r\n    } else if (localLockingStrategy == LOCKING_STRATEGY.EXCLUSIVE_LOCK) {\r\n      id.lock(true);\r\n\r\n      if (id instanceof ORecord) {\r\n        final ORecord record = (ORecord) id;\r\n        record.reload(null, true, false);\r\n      }\r\n    }\r\n\r\n    ORecord record = null;\r\n    try {\r\n      if (!(id instanceof ORecord)) {\r\n        record = getDatabase().load(id.getIdentity(), null, !isUseCache());\r\n        if (id instanceof OContextualRecordId && ((OContextualRecordId) id).getContext() != null) {\r\n          Map<String, Object> ridContext = ((OContextualRecordId) id).getContext();\r\n          for (String key : ridContext.keySet()) {\r\n            context.setVariable(key, ridContext.get(key));\r\n          }\r\n        }\r\n      } else {\r\n        record = (ORecord) id;\r\n      }\r\n\r\n      iContext.updateMetric(\"recordReads\", +1);\r\n\r\n      if (record == null || ORecordInternal.getRecordType(record) != ODocument.RECORD_TYPE)\r\n        // SKIP IT\r\n        return true;\r\n\r\n      iContext.updateMetric(\"documentReads\", +1);\r\n\r\n      iContext.setVariable(\"current\", record);\r\n\r\n      if (filter(record, iContext)) {\r\n        if (parallel) {\r\n          {\r\n            try {\r\n              applyGroupBy(record, iContext);\r\n              resultQueue.put(new AsyncResult(record, iContext));\r\n            } catch (InterruptedException e) {\r\n              Thread.interrupted();\r\n              return false;\r\n            }\r\n            tmpQueueOffer.incrementAndGet();\r\n          }\r\n        } else {\r\n          applyGroupBy(record, iContext);\r\n\r\n          if (!handleResult(record, iContext)) {\r\n            // LIMIT REACHED\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n    } finally {\r\n\r\n      if (localLockingStrategy != null && record != null && record.isLocked()) {\r\n        // CONTEXT LOCK: lock must be released (no matter if filtered or not)\r\n        if (localLockingStrategy == LOCKING_STRATEGY.EXCLUSIVE_LOCK || localLockingStrategy == LOCKING_STRATEGY.SHARED_LOCK) {\r\n          record.unlock();\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }","commit_id":"95e4fc07529c2653f546fe1c3d64215b55420486","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void load(LWComponent c)\n    {\n        mLastLoad = c;\n        //btnSlide.setEnabled(true);\n\n        LWComponent focal;\n\n        // If no slide available, disable slide button, even if don't want it!\n\n        if (c == null) {\n            mZoomBorder = false;\n            mZoomContent = null;\n            inFocal = false;\n            focal = null;\n        } else {\n            focal = getFocalAndConfigure(c);\n        }\n        \n        super.loadFocal(focal);\n        reshapeImpl(0,0,0,0);\n        out(\"\\nSlideViewer: focused is now \" + mFocal + \" from map \" + mMap);\n    }","id":25640,"modified_method":"protected void load(LWComponent c)\n    {\n        if (DEBUG.Enabled) out(\"\\nSlideViewer: loading \" + c);\n        mLastLoad = c;\n        //btnSlide.setEnabled(true);\n\n        LWComponent focal;\n\n        // If no slide available, disable slide button, even if don't want it!\n\n        if (c == null && !btnMaster.isSelected()) {\n            mZoomBorder = false;\n            mZoomContent = null;\n            inFocal = false;\n            focal = null;\n        } else {\n            focal = getFocalAndConfigure(c);\n        }\n        \n        super.loadFocal(focal);\n        reshapeImpl(0,0,0,0);\n        if (DEBUG.Enabled) out(\"SlideViewer: focused is now \" + mFocal + \" from map \" + mMap);\n    }","commit_id":"1f2137ca3be585f0b08df08f559c534bf151c4d4","url":"https://github.com/VUE/VUE"},{"original_method":"protected void drawSlide(DrawContext dc) {\n        \n        final LWSlide master = VUE.getActiveMap().getActivePathway().getMasterSlide();\n\n        if (btnMaster.isSelected()) {\n            // When editing the master, allow us to see stuff outside of it\n            // (no need to clip);\n            master.draw(dc);\n            return;\n        }\n        \n        final Shape curClip = dc.g.getClip();\n\n        // When just filling the background with the master, only draw\n        // what's in the containment box\n        dc.g.setClip(master.getBounds());\n        master.draw(dc);\n        dc.g.setClip(curClip);\n\n        //for (LWComponent c : mFocal.getChildList()) out(\"child to draw: \" + c);\n        \n        // Now draw the actual slide\n        mFocal.draw(dc);\n    }","id":25641,"modified_method":"protected void drawSlide(DrawContext dc) {\n        \n        final LWSlide master = VUE.getActiveMap().getActivePathway().getMasterSlide();\n\n        if (btnMaster.isSelected()) {\n            // When editing the master, allow us to see stuff outside of it\n            // (no need to clip);\n            master.setLocation(0,0);// TODO: hack till we can lock these properties\n            master.draw(dc);\n            return;\n        }\n        \n        final Shape curClip = dc.g.getClip();\n\n        // When just filling the background with the master, only draw\n        // what's in the containment box\n        master.setLocation(0,0);// TODO: hack till we can lock these properties\n        dc.g.setClip(master.getBounds());\n        master.draw(dc);\n        dc.g.setClip(curClip);\n\n        //for (LWComponent c : mFocal.getChildList()) out(\"child to draw: \" + c);\n        \n        // Now draw the actual slide\n        mFocal.draw(dc);\n    }","commit_id":"1f2137ca3be585f0b08df08f559c534bf151c4d4","url":"https://github.com/VUE/VUE"},{"original_method":"public void activePathwayChanged(LWPathway p) {\n        if (inPathwaySlide) {\n            reload();\n        }\n    }","id":25642,"modified_method":"public void activePathwayChanged(LWPathway path) {\n        if (mCurrentPath != null)\n            mCurrentPath.removeLWCListener(this);\n        mCurrentPath = path;\n        mCurrentPath.addLWCListener(this);\n        reload();\n    }","commit_id":"1f2137ca3be585f0b08df08f559c534bf151c4d4","url":"https://github.com/VUE/VUE"},{"original_method":"public void selectionChanged(LWSelection s) {\n        super.selectionChanged(s);\n\n        if (btnLocked.isSelected())\n            return;\n            \n        if (s.getSource() != this && s.size() == 1) {\n            final LWComponent c = s.first();\n            if (btnMaster.isSelected())\n                mLastLoad = c;\n            else if (btnSlide.isSelected()) {\n                if (c.getSlideForPathway(c.getMap().getActivePathway()) != null)\n                    load(c);\n                else\n                    ; // do nothing for now: allows us to select non-slideworthy on map to drag into slide\n            } else\n                load(c);\n        }\n    }","id":25643,"modified_method":"public void selectionChanged(LWSelection s) {\n        super.selectionChanged(s);\n\n        if (btnLocked.isSelected())\n            return;\n            \n        if (s.getSource() != this && s.size() == 1) {\n            final LWComponent c = s.first();\n            if (btnMaster.isSelected())\n                mLastLoad = c;\n            else if (btnSlide.isSelected()) {\n                if (true || c.getSlideForPathway(c.getMap().getActivePathway()) != null)\n                    load(c);\n                else\n                    ; // do nothing for now: allows us to select non-slideworthy on map to drag into slide\n            } else\n                load(c);\n        }\n    }","commit_id":"1f2137ca3be585f0b08df08f559c534bf151c4d4","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(ActionEvent e) {\n            //out(e);\n            reload();\n        }","id":25644,"modified_method":"public void actionPerformed(ActionEvent e) {\n            if (DEBUG.PRESENT) out(e);\n            reload();\n        }","commit_id":"1f2137ca3be585f0b08df08f559c534bf151c4d4","url":"https://github.com/VUE/VUE"},{"original_method":"public void LWCChanged(LWCEvent e) {\n        if (DEBUG.Enabled) out(\"SLIDEVIEWER LWCChanged \" + e);\n        super.LWCChanged(e);\n        if (true||e.getComponent() == mFocal) {\n            zoomToContents();\n        }\n    }","id":25645,"modified_method":"public void LWCChanged(LWCEvent e) {\n        if (DEBUG.Enabled) out(\"SLIDEVIEWER LWCChanged \" + e);\n\n        if (e.getComponent() instanceof LWPathway) {\n            // If we're displaying a slide for a node, and\n            // the pathway has changed, it may be that the\n            // node was just added to the pathway and we\n            // need to load it's new slide (or it was\n            // removed, and we also need to display that)\n            reload();\n        } else {\n            super.LWCChanged(e);\n            if (true||e.getComponent() == mFocal) {\n                zoomToContents();\n            }\n        }\n    }","commit_id":"1f2137ca3be585f0b08df08f559c534bf151c4d4","url":"https://github.com/VUE/VUE"},{"original_method":"protected void manageNeedRetryException(OBaseWorkLoadContext context, ONeedRetryException e) {\n    ((OWorkLoadContext) context).lastVertexToConnect.reload();\n  }","id":25646,"modified_method":"protected void manageNeedRetryException(OBaseWorkLoadContext context, ONeedRetryException e) {\n    if (((OWorkLoadContext) context).lastVertexToConnect.getIdentity().isPersistent())\n      ((OWorkLoadContext) context).lastVertexToConnect.reload();\n  }","commit_id":"171e8eabba6289036c0aac7a9cbeceaef7f9f2d7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void execute(final OStressTesterSettings settings, final ODatabaseIdentifier databaseIdentifier) {\n    connectionStrategy = settings.loadBalancing;\n\n    final List<OBaseWorkLoadContext> contexts = executeOperation(databaseIdentifier, resultVertices, settings.concurrencyLevel,\n        settings.operationsPerTransaction, new OCallable<Void, OBaseWorkLoadContext>() {\n          @Override\n          public Void call(final OBaseWorkLoadContext context) {\n            final OWorkLoadContext graphContext = ((OWorkLoadContext) context);\n            final OrientBaseGraph graph = graphContext.graph;\n\n            final OrientVertex v = graph.addVertex(null, \"_id\", resultVertices.current.get());\n\n            if (graphContext.lastVertexToConnect != null) {\n              v.addEdge(\"E\", graphContext.lastVertexToConnect);\n              resultEdges.current.incrementAndGet();\n\n              graphContext.lastVertexEdges++;\n\n              if (graphContext.lastVertexEdges > factor) {\n                graphContext.lastVertexEdges = 0;\n                if (strategy == STRATEGIES.LAST)\n                  graphContext.lastVertexToConnect = v;\n                else if (strategy == STRATEGIES.RANDOM) {\n                  do {\n                    final int[] totalClusters = graph.getVertexBaseType().getClusterIds();\n                    final int randomCluster = totalClusters[new Random().nextInt(totalClusters.length)];\n                    long totClusterRecords = graph.getRawGraph().countClusterElements(randomCluster);\n                    if (totClusterRecords > 0) {\n                      final ORecordId randomRid = new ORecordId(randomCluster, new Random().nextInt((int) totClusterRecords));\n                      graphContext.lastVertexToConnect = graph.getVertex(randomRid);\n                      break;\n                    }\n\n                  } while (true);\n                } else if (strategy == STRATEGIES.SUPERNODE) {\n                  final int[] totalClusters = graph.getVertexBaseType().getClusterIds();\n                  final int firstCluster = totalClusters[0];\n                  long totClusterRecords = graph.getRawGraph().countClusterElements(firstCluster);\n                  if (totClusterRecords > 0) {\n                    final ORecordId randomRid = new ORecordId(firstCluster, 0);\n                    graphContext.lastVertexToConnect = graph.getVertex(randomRid);\n                  }\n                }\n              }\n            } else\n              graphContext.lastVertexToConnect = v;\n\n            resultVertices.current.incrementAndGet();\n            return null;\n          }\n        });\n\n    final OrientBaseGraph graph = settings.operationsPerTransaction > 0 ? getGraph(databaseIdentifier)\n        : getGraphNoTx(databaseIdentifier);\n    try {\n      // CONNECTED ALL THE SUB GRAPHS\n      OrientVertex lastVertex = null;\n      for (OBaseWorkLoadContext context : contexts) {\n        for (int retry = 0; retry < 100; ++retry)\n          try {\n            if (lastVertex != null)\n              lastVertex.addEdge(\"E\", ((OWorkLoadContext) context).lastVertexToConnect);\n\n            lastVertex = ((OWorkLoadContext) context).lastVertexToConnect;\n          } catch (ONeedRetryException e) {\n            lastVertex.reload();\n            ((OWorkLoadContext) context).lastVertexToConnect.reload();\n          }\n      }\n    } finally {\n      graph.shutdown();\n    }\n  }","id":25647,"modified_method":"@Override\n  public void execute(final OStressTesterSettings settings, final ODatabaseIdentifier databaseIdentifier) {\n    connectionStrategy = settings.loadBalancing;\n\n    final List<OBaseWorkLoadContext> contexts = executeOperation(databaseIdentifier, resultVertices, settings.concurrencyLevel,\n        settings.operationsPerTransaction, new OCallable<Void, OBaseWorkLoadContext>() {\n          @Override\n          public Void call(final OBaseWorkLoadContext context) {\n            final OWorkLoadContext graphContext = ((OWorkLoadContext) context);\n            final OrientBaseGraph graph = graphContext.graph;\n\n            final OrientVertex v = graph.addVertex(null, \"_id\", resultVertices.current.get());\n\n            if (graphContext.lastVertexToConnect != null) {\n              v.addEdge(\"E\", graphContext.lastVertexToConnect);\n              resultEdges.current.incrementAndGet();\n\n              graphContext.lastVertexEdges++;\n\n              if (graphContext.lastVertexEdges > factor) {\n                graphContext.lastVertexEdges = 0;\n                if (strategy == STRATEGIES.LAST)\n                  graphContext.lastVertexToConnect = v;\n                else if (strategy == STRATEGIES.RANDOM) {\n                  do {\n                    final int[] totalClusters = graph.getVertexBaseType().getClusterIds();\n                    final int randomCluster = totalClusters[new Random().nextInt(totalClusters.length)];\n                    long totClusterRecords = graph.getRawGraph().countClusterElements(randomCluster);\n                    if (totClusterRecords > 0) {\n                      final ORecordId randomRid = new ORecordId(randomCluster, new Random().nextInt((int) totClusterRecords));\n                      graphContext.lastVertexToConnect = graph.getVertex(randomRid);\n                      break;\n                    }\n\n                  } while (true);\n                } else if (strategy == STRATEGIES.SUPERNODE) {\n                  final int[] totalClusters = graph.getVertexBaseType().getClusterIds();\n                  final int firstCluster = totalClusters[0];\n                  long totClusterRecords = graph.getRawGraph().countClusterElements(firstCluster);\n                  if (totClusterRecords > 0) {\n                    final ORecordId randomRid = new ORecordId(firstCluster, 0);\n                    graphContext.lastVertexToConnect = graph.getVertex(randomRid);\n                  }\n                }\n              }\n            } else\n              graphContext.lastVertexToConnect = v;\n\n            resultVertices.current.incrementAndGet();\n            return null;\n          }\n        });\n\n    final OrientBaseGraph graph = settings.operationsPerTransaction > 0 ? getGraph(databaseIdentifier)\n        : getGraphNoTx(databaseIdentifier);\n    try {\n      // CONNECTED ALL THE SUB GRAPHS\n      OrientVertex lastVertex = null;\n      for (OBaseWorkLoadContext context : contexts) {\n        for (int retry = 0; retry < 100; ++retry)\n          try {\n            if (lastVertex != null)\n              lastVertex.addEdge(\"E\", ((OWorkLoadContext) context).lastVertexToConnect);\n\n            lastVertex = ((OWorkLoadContext) context).lastVertexToConnect;\n          } catch (ONeedRetryException e) {\n            if (lastVertex.getIdentity().isPersistent())\n              lastVertex.reload();\n\n            if (((OWorkLoadContext) context).lastVertexToConnect.getIdentity().isPersistent())\n              ((OWorkLoadContext) context).lastVertexToConnect.reload();\n          }\n      }\n    } finally {\n      graph.shutdown();\n    }\n  }","commit_id":"171e8eabba6289036c0aac7a9cbeceaef7f9f2d7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public JSONWebServiceDiscoverAction(HttpServletRequest request) {\n\t\t_basePath = request.getServletPath();\n\t\t_baseURL = request.getRequestURL().toString();\n\t\t_contextPath = request.getContextPath();\n\n\t\tString discover = request.getParameter(\"discover\");\n\n\t\t_discover = StringUtil.split(discover);\n\t}","id":25648,"modified_method":"public JSONWebServiceDiscoverAction(HttpServletRequest request) {\n\t\t_basePath = request.getServletPath();\n\t\t_baseURL = request.getRequestURL().toString();\n\n\t\t_contextPath = ParamUtil.getString(\n\t\t\trequest, \"contextPath\", request.getContextPath());\n\n\t\tString discover = request.getParameter(\"discover\");\n\n\t\t_discover = StringUtil.split(discover);\n\t}","commit_id":"6324482fdbadb2bf995b3b8c9d9d85748e97ba77","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n   * put your documentation comment here\n   * @param req\n   * @param res\n   * @exception ServletException, IOException\n   */\n  public void doGet (HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n    // forwarding\n    ServletContext sc = this.getServletContext();\n    HttpSession session = req.getSession();\n    if (session != null) {\n      // LogService.instance().log(LogService.DEBUG, \"PortalSessionManager::doGet() : request path \\\"\"+req.getServletPath()+\"\\\".\");\n      String redirectBase = null;\n      RequestParamWrapper myReq = new RequestParamWrapper(req);\n      myReq.setBaseRequest(req);\n      if ((redirectBase = this.doRedirect(myReq)) != null) {\n        // cache request\n        sc.setAttribute(\"oreqp_\" + session.getId(), myReq);\n        // initial request, requeres forwarding\n        session.setAttribute(\"forwarded\", new Boolean(true));\n        // forward\n        // LogService.instance().log(LogService.DEBUG,\"PortalSessionManager::doGet() : caching request, sending redirect\");\n        //this.getServletContext().getRequestDispatcher(\"/render.uP\").forward(req,res);\n        res.sendRedirect(req.getContextPath() + redirectBase);\n      }\n      else {\n        // delete old request\n        Boolean forwarded = (Boolean)session.getAttribute(\"forwarded\");\n        if (forwarded != null)\n          session.removeAttribute(\"forwarded\");\n        // proceed with rendering\n        //\t\t    LogService.instance().log(LogService.DEBUG,\"PortalSessionManager::doGet() : processing redirected (clean) request\");\n        // look if the UserInstance object is already in the session, otherwise\n        // make a new one\n        UserInstance layout = (UserInstance)session.getAttribute(\"UserInstance\");\n        if (layout == null) {\n          layout = UserInstanceFactory.getUserInstance(myReq);\n          session.setAttribute(\"UserInstance\", layout);\n          // LogService.instance().log(LogService.DEBUG,\"PortalSessionManager;:doGet() : instantiating new UserInstance\");\n        }\n        RequestParamWrapper oreqp = null;\n        if (forwarded != null && forwarded.booleanValue())\n          oreqp = (RequestParamWrapper)sc.getAttribute(\"oreqp_\" + session.getId());\n        if (oreqp != null) {\n          oreqp.setBaseRequest(req);\n          layout.writeContent(oreqp, res, res.getWriter());\n        }\n        else {\n          layout.writeContent(myReq, res, res.getWriter());\n        }\n      }\n    }\n    else {\n      res.setContentType(\"text/html\");\n      PrintWriter out = res.getWriter();\n      out.println(\"<html>\");\n      out.println(\"<body>\");\n      out.println(\"<h1>\" + getServletConfig().getServletName() + \"<\/h1>\");\n      out.println(\"Session object is null !??\");\n      out.println(\"<\/body><\/html>\");\n    }\n  }","id":25649,"modified_method":"/**\n   * put your documentation comment here\n   * @param req\n   * @param res\n   * @exception ServletException, IOException\n   */\n  public void doGet (HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n    // forwarding\n    ServletContext sc = this.getServletContext();\n    HttpSession session = req.getSession();\n    if (session != null) {\n      // LogService.instance().log(LogService.DEBUG, \"PortalSessionManager::doGet() : request path \\\"\"+req.getServletPath()+\"\\\".\");\n      String redirectBase = null;\n      RequestParamWrapper myReq = new RequestParamWrapper(req);\n      myReq.setBaseRequest(req);\n      if ((redirectBase = this.doRedirect(myReq)) != null) {\n        // cache request\n        sc.setAttribute(\"oreqp_\" + session.getId(), myReq);\n        // initial request, requeres forwarding\n        session.setAttribute(\"forwarded\", new Boolean(true));\n        // forward\n        // LogService.instance().log(LogService.DEBUG,\"PortalSessionManager::doGet() : caching request, sending redirect\");\n        //this.getServletContext().getRequestDispatcher(\"/render.uP\").forward(req,res);\n        res.sendRedirect(\"http://\" + req.getServerName() + \":\" + req.getServerPort() + req.getContextPath() + redirectBase);\n      }\n      else {\n        // delete old request\n        Boolean forwarded = (Boolean)session.getAttribute(\"forwarded\");\n        if (forwarded != null)\n          session.removeAttribute(\"forwarded\");\n        // proceed with rendering\n        //\t\t    LogService.instance().log(LogService.DEBUG,\"PortalSessionManager::doGet() : processing redirected (clean) request\");\n        // look if the UserInstance object is already in the session, otherwise\n        // make a new one\n        UserInstance layout = (UserInstance)session.getAttribute(\"UserInstance\");\n        if (layout == null) {\n          layout = UserInstanceFactory.getUserInstance(myReq);\n          session.setAttribute(\"UserInstance\", layout);\n          // LogService.instance().log(LogService.DEBUG,\"PortalSessionManager;:doGet() : instantiating new UserInstance\");\n        }\n        RequestParamWrapper oreqp = null;\n        if (forwarded != null && forwarded.booleanValue())\n          oreqp = (RequestParamWrapper)sc.getAttribute(\"oreqp_\" + session.getId());\n        if (oreqp != null) {\n          oreqp.setBaseRequest(req);\n          layout.writeContent(oreqp, res, res.getWriter());\n        }\n        else {\n          layout.writeContent(myReq, res, res.getWriter());\n        }\n      }\n    }\n    else {\n      res.setContentType(\"text/html\");\n      PrintWriter out = res.getWriter();\n      out.println(\"<html>\");\n      out.println(\"<body>\");\n      out.println(\"<h1>\" + getServletConfig().getServletName() + \"<\/h1>\");\n      out.println(\"Session object is null !??\");\n      out.println(\"<\/body><\/html>\");\n    }\n  }","commit_id":"ee5df9c907584c737b6c4c19cba63dbee6a4f6df","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n   * Process the incoming HttpServletRequest\n   * @param request\n   * @param response\n   * @exception ServletException\n   * @exception IOException\n   */\n  public void service (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  \tCommonUtils.setNoCache(response);\n\n    // Call to setCharacterEncoding method should be done before any call to req.getParameter() method.\n    try {\n        request.setCharacterEncoding(\"UTF-8\");\n    } catch (UnsupportedEncodingException uee) {\n        log.error(\"Unable to set UTF-8 character encoding!\", uee);\n    }\n\n    final IPersonManager personManager = PersonManagerFactory.getPersonManagerInstance();\n    \n    // Clear out the existing session for the user if they have one\n    String targetUid = null;\n    String originalUid = null;\n    boolean swap = false;\n    if (request.isRequestedSessionIdValid()) {\n    \ttry {\n            HttpSession s = request.getSession(false);\n    \t    //Check if this is a swapped user hitting the Login servlet\n    \t    originalUid = (String)s.getAttribute(SWAP_ORIGINAL_UID);\n\n    \t    //No original person in session so check for swap request\n    \t    if (originalUid == null) {\n        \t    targetUid = (String)s.getAttribute(SWAP_TARGET_UID);\n        \t    if (targetUid != null) {\n        \t        final IPerson person = personManager.getPerson(request);\n        \t        originalUid = person.getName();\n        \t        swap = true;\n        \t    }\n    \t    }\n    \t    else {\n    \t        final IPerson person = personManager.getPerson(request);\n    \t        targetUid = person.getName();\n    \t    }\n\n            s.invalidate();\n    \t} catch (IllegalStateException ise) {\n    \t\t// ISE indicates session was already invalidated.\n    \t\t// This is fine.  This servlet trying to guarantee that the session has been invalidated;\n    \t\t// it doesn't have to insist that it is the one that invalidated it.\n    \t\tif (log.isTraceEnabled()) {\n    \t\t\tlog.trace(\"LoginServlet attempted to invalidate an already invalid session.\", ise);\n    \t\t}\n    \t}\n    }\n\n  \t//  Create the user's session\n    HttpSession s = request.getSession(true);\n    \n  \tIPerson person = null;\n    try {\n        final HashMap principals;\n        final HashMap credentials;\n        \n        // Get the person object associated with the request\n        person = personManager.getPerson(request);\n        \n        //If doing an identity swap\n        if (targetUid != null && originalUid != null) {\n            if (swap) {\n                swapperLog.warn(\"Swapping identity for '\" + originalUid + \"' to '\" + targetUid + \"'\");\n\n                //Track the originating user\n                s.setAttribute(SWAP_ORIGINAL_UID, originalUid);\n                \n                //Setup the swapped person\n                person.setUserName(targetUid);\n            }\n            else {\n                swapperLog.warn(\"Reverting swapped identity from '\" + targetUid + \"' to '\" + originalUid + \"'\");\n                \n                person.setUserName(originalUid);\n            }\n            \n            //Setup the custom security context\n            final IdentitySwapperPrincipal identitySwapperPrincipal = new IdentitySwapperPrincipal(person);\n            final IdentitySwapperSecurityContext identitySwapperSecurityContext = new IdentitySwapperSecurityContext(identitySwapperPrincipal);\n            person.setSecurityContext(identitySwapperSecurityContext);\n            \n            principals = new HashMap();\n            credentials = new HashMap();\n        }\n        //Norm authN path\n        else {\n          // WE grab all of the principals and credentials from the request and load\n          // them into their respective HashMaps.\n          principals = getPropertyFromRequest (principalTokens, request);\n          credentials = getPropertyFromRequest (credentialTokens, request);\n        }\n\n      // Attempt to authenticate using the incoming request\n      m_authenticationService.authenticate(principals, credentials, person);\n    } catch (Exception e) {\n      // Log the exception\n      log.error(\"Exception authenticating the request\", e);\n      // Reset everything\n      request.getSession(false).invalidate();\n      // Add the authentication failure\n      request.getSession(true).setAttribute(\"up_authenticationError\", \"true\");\n      person = null;\n    }\n    \n    /* Grab the target functional name, if any, off the login request.\n     * Also any arguments for the target\n     * We will pass them  along after authentication.\n     */\n    String targetFname = request.getParameter(\"uP_fname\");\n    String targetArgs = request.getParameter(\"uP_args\");\n    \n    // create the redirect URL, adding fname and args parameters if necessary\n    String redirectTarget = null;\n\tif (targetFname == null){\n\t\tredirectTarget = request.getContextPath() + \"/\" + redirectString;\n\t} else {\n\t\tredirectTarget = request.getContextPath() + \"/\" +\n\t\t\"tag.idempotent.\" +  redirectString + \"?uP_fname=\" + URLEncoder.encode(targetFname, \"UTF-8\");\n\t\tif (targetArgs != null) {\n\t\t\tredirectTarget = redirectTarget + \"&uP_args=\" + URLEncoder.encode(targetArgs, \"UTF-8\");\n\t\t}\n\t}\n\n\tif (person == null || !person.getSecurityContext().isAuthenticated()) {\n     if ( request.getMethod().equals(\"POST\") )\n         request.getSession(false).setAttribute(\"up_authenticationAttempted\", \"true\");\n     // Preserve the attempted username so it can be redisplayed to the user by CLogin\n     String attemptedUserName = request.getParameter(\"userName\");\n     if (attemptedUserName != null)\n     \trequest.getSession(false).setAttribute(\"up_attemptedUserName\", request.getParameter(\"userName\"));\t\t\n\t}\n\n\tfinal String encodedRedirectURL = response.encodeRedirectURL(redirectTarget);\n    response.sendRedirect(encodedRedirectURL);\n\n  }","id":25650,"modified_method":"/**\n   * Process the incoming HttpServletRequest\n   * @param request\n   * @param response\n   * @exception ServletException\n   * @exception IOException\n   */\n  public void service (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  \tCommonUtils.setNoCache(response);\n\n    // Call to setCharacterEncoding method should be done before any call to req.getParameter() method.\n    try {\n        request.setCharacterEncoding(\"UTF-8\");\n    } catch (UnsupportedEncodingException uee) {\n        log.error(\"Unable to set UTF-8 character encoding!\", uee);\n    }\n\n    final IPersonManager personManager = PersonManagerFactory.getPersonManagerInstance();\n    \n    // Clear out the existing session for the user if they have one\n    String targetUid = null;\n    String originalUid = null;\n    boolean swap = false;\n    if (request.isRequestedSessionIdValid()) {\n    \ttry {\n            HttpSession s = request.getSession(false);\n    \t    //Check if this is a swapped user hitting the Login servlet\n    \t    originalUid = (String)s.getAttribute(SWAP_ORIGINAL_UID);\n\n    \t    //No original person in session so check for swap request\n    \t    if (originalUid == null) {\n        \t    targetUid = (String)s.getAttribute(SWAP_TARGET_UID);\n        \t    if (targetUid != null) {\n        \t        final IPerson person = personManager.getPerson(request);\n        \t        originalUid = person.getName();\n        \t        swap = true;\n        \t    }\n    \t    }\n    \t    else {\n    \t        final IPerson person = personManager.getPerson(request);\n    \t        targetUid = person.getName();\n    \t    }\n\n            s.invalidate();\n    \t} catch (IllegalStateException ise) {\n    \t\t// ISE indicates session was already invalidated.\n    \t\t// This is fine.  This servlet trying to guarantee that the session has been invalidated;\n    \t\t// it doesn't have to insist that it is the one that invalidated it.\n    \t\tif (log.isTraceEnabled()) {\n    \t\t\tlog.trace(\"LoginServlet attempted to invalidate an already invalid session.\", ise);\n    \t\t}\n    \t}\n    }\n\n  \t//  Create the user's session\n    HttpSession s = request.getSession(true);\n    \n  \tIPerson person = null;\n    try {\n        final HashMap principals;\n        final HashMap credentials;\n        \n        // Get the person object associated with the request\n        person = personManager.getPerson(request);\n        \n        //If doing an identity swap\n        if (targetUid != null && originalUid != null) {\n            if (swap) {\n                swapperLog.warn(\"Swapping identity for '\" + originalUid + \"' to '\" + targetUid + \"'\");\n\n                //Track the originating user\n                s.setAttribute(SWAP_ORIGINAL_UID, originalUid);\n                \n                //Setup the swapped person\n                person.setUserName(targetUid);\n            }\n            else {\n                swapperLog.warn(\"Reverting swapped identity from '\" + targetUid + \"' to '\" + originalUid + \"'\");\n                \n                person.setUserName(originalUid);\n            }\n            \n            //Setup the custom security context\n            final IdentitySwapperPrincipal identitySwapperPrincipal = new IdentitySwapperPrincipal(person);\n            final IdentitySwapperSecurityContext identitySwapperSecurityContext = new IdentitySwapperSecurityContext(identitySwapperPrincipal);\n            person.setSecurityContext(identitySwapperSecurityContext);\n            \n            principals = new HashMap();\n            credentials = new HashMap();\n        }\n        //Norm authN path\n        else {\n          // WE grab all of the principals and credentials from the request and load\n          // them into their respective HashMaps.\n          principals = getPropertyFromRequest (principalTokens, request);\n          credentials = getPropertyFromRequest (credentialTokens, request);\n        }\n\n      // Attempt to authenticate using the incoming request\n      m_authenticationService.authenticate(principals, credentials, person);\n    } catch (Exception e) {\n      // Log the exception\n      log.error(\"Exception authenticating the request\", e);\n      // Reset everything\n      request.getSession(false).invalidate();\n      // Add the authentication failure\n      request.getSession(true).setAttribute(\"up_authenticationError\", \"true\");\n      person = null;\n    }\n    \n    /* Grab the target functional name, if any, off the login request.\n     * Also any arguments for the target\n     * We will pass them  along after authentication.\n     */\n    String targetFname = request.getParameter(\"uP_fname\");\n    \n    // create the redirect URL, adding fname and args parameters if necessary\n    String redirectTarget = null;\n\tif (targetFname == null){\n\t\tredirectTarget = request.getContextPath() + \"/\" + redirectString;\n\t} else {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(request.getContextPath());\n\t\tsb.append(\"/tag.idempotent.\");\n\t\tsb.append(redirectString);\n\t\tsb.append(\"?uP_fname=\");\n\t\tsb.append(URLEncoder.encode(targetFname, \"UTF-8\"));\n\t\tEnumeration<String> e = request.getParameterNames();\n\t\twhile(e.hasMoreElements()){\n\t\t\tString paramName = e.nextElement();\n\t\t\tif(!paramName.equals(\"uP_fname\")){\n\t\t\t\tsb.append('&');\n\t\t\t\tsb.append(paramName);\n\t\t\t\tsb.append('=');\n\t\t\t\tsb.append(URLEncoder.encode(request.getParameter(paramName),\"UTF-8\"));\n\t\t\t}\n\t\t}\t\t\n\t\tredirectTarget = sb.toString();\n\t}\n\n\tif (person == null || !person.getSecurityContext().isAuthenticated()) {\n     if ( request.getMethod().equals(\"POST\") )\n         request.getSession(false).setAttribute(\"up_authenticationAttempted\", \"true\");\n     // Preserve the attempted username so it can be redisplayed to the user by CLogin\n     String attemptedUserName = request.getParameter(\"userName\");\n     if (attemptedUserName != null)\n     \trequest.getSession(false).setAttribute(\"up_attemptedUserName\", request.getParameter(\"userName\"));\t\t\n\t}\n\n\tfinal String encodedRedirectURL = response.encodeRedirectURL(redirectTarget);\n    response.sendRedirect(encodedRedirectURL);\n\n  }","commit_id":"a6c1a2c92d87aa9bee40c227cb0eb5c666372015","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n   * Process the incoming HttpServletRequest\n   * @param request\n   * @param response\n   * @exception ServletException\n   * @exception IOException\n   */\n  public void service (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  \tCommonUtils.setNoCache(response);\n\n    // Call to setCharacterEncoding method should be done before any call to req.getParameter() method.\n    try {\n        request.setCharacterEncoding(\"UTF-8\");\n    } catch (UnsupportedEncodingException uee) {\n        log.error(\"Unable to set UTF-8 character encoding!\", uee);\n    }\n\n    final IPersonManager personManager = PersonManagerFactory.getPersonManagerInstance();\n    \n    // Clear out the existing session for the user if they have one\n    String targetUid = null;\n    String originalUid = null;\n    boolean swap = false;\n    if (request.isRequestedSessionIdValid()) {\n    \ttry {\n            HttpSession s = request.getSession(false);\n    \t    //Check if this is a swapped user hitting the Login servlet\n    \t    originalUid = (String)s.getAttribute(SWAP_ORIGINAL_UID);\n\n    \t    //No original person in session so check for swap request\n    \t    if (originalUid == null) {\n        \t    targetUid = (String)s.getAttribute(SWAP_TARGET_UID);\n        \t    if (targetUid != null) {\n        \t        final IPerson person = personManager.getPerson(request);\n        \t        originalUid = person.getName();\n        \t        swap = true;\n        \t    }\n    \t    }\n    \t    else {\n    \t        final IPerson person = personManager.getPerson(request);\n    \t        targetUid = person.getName();\n    \t    }\n\n            s.invalidate();\n    \t} catch (IllegalStateException ise) {\n    \t\t// ISE indicates session was already invalidated.\n    \t\t// This is fine.  This servlet trying to guarantee that the session has been invalidated;\n    \t\t// it doesn't have to insist that it is the one that invalidated it.\n    \t\tif (log.isTraceEnabled()) {\n    \t\t\tlog.trace(\"LoginServlet attempted to invalidate an already invalid session.\", ise);\n    \t\t}\n    \t}\n    }\n\n  \t//  Create the user's session\n    HttpSession s = request.getSession(true);\n    \n  \tIPerson person = null;\n    try {\n        final HashMap principals;\n        final HashMap credentials;\n        \n        // Get the person object associated with the request\n        person = personManager.getPerson(request);\n        \n        //If doing an identity swap\n        if (targetUid != null && originalUid != null) {\n            if (swap) {\n                swapperLog.warn(\"Swapping identity for '\" + originalUid + \"' to '\" + targetUid + \"'\");\n\n                //Track the originating user\n                s.setAttribute(SWAP_ORIGINAL_UID, originalUid);\n                \n                //Setup the swapped person\n                person.setUserName(targetUid);\n            }\n            else {\n                swapperLog.warn(\"Reverting swapped identity from '\" + targetUid + \"' to '\" + originalUid + \"'\");\n                \n                person.setUserName(originalUid);\n            }\n            \n            //Setup the custom security context\n            final IdentitySwapperPrincipal identitySwapperPrincipal = new IdentitySwapperPrincipal(person);\n            final IdentitySwapperSecurityContext identitySwapperSecurityContext = new IdentitySwapperSecurityContext(identitySwapperPrincipal);\n            person.setSecurityContext(identitySwapperSecurityContext);\n            \n            principals = new HashMap();\n            credentials = new HashMap();\n        }\n        //Norm authN path\n        else {\n          // WE grab all of the principals and credentials from the request and load\n          // them into their respective HashMaps.\n          principals = getPropertyFromRequest (principalTokens, request);\n          credentials = getPropertyFromRequest (credentialTokens, request);\n        }\n\n      // Attempt to authenticate using the incoming request\n      m_authenticationService.authenticate(principals, credentials, person);\n    } catch (Exception e) {\n      // Log the exception\n      log.error(\"Exception authenticating the request\", e);\n      // Reset everything\n      request.getSession(false).invalidate();\n      // Add the authentication failure\n      request.getSession(true).setAttribute(\"up_authenticationError\", \"true\");\n      person = null;\n    }\n    \n    /* Grab the target functional name, if any, off the login request.\n     * Also any arguments for the target\n     * We will pass them  along after authentication.\n     */\n    String targetFname = request.getParameter(\"uP_fname\");\n    \n    // create the redirect URL, adding fname and args parameters if necessary\n    String redirectTarget = null;\n\tif (targetFname == null){\n\t\tredirectTarget = request.getContextPath() + \"/\" + redirectString;\n\t} else {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(request.getContextPath());\n\t\tsb.append(\"/tag.idempotent.\");\n\t\tsb.append(redirectString);\n\t\tsb.append(\"?uP_fname=\");\n\t\tsb.append(URLEncoder.encode(targetFname, \"UTF-8\"));\n\t\tEnumeration<String> e = request.getParameterNames();\n\t\twhile(e.hasMoreElements()){\n\t\t\tString paramName = e.nextElement();\n\t\t\tif(!paramName.equals(\"uP_fname\")){\n\t\t\t\tsb.append('&');\n\t\t\t\tsb.append(paramName);\n\t\t\t\tsb.append('=');\n\t\t\t\tsb.append(URLEncoder.encode(request.getParameter(paramName),\"UTF-8\"));\n\t\t\t}\n\t\t}\t\t\n\t\tredirectTarget = sb.toString();\n\t}\n\n\tif (person == null || !person.getSecurityContext().isAuthenticated()) {\n     if ( request.getMethod().equals(\"POST\") )\n         request.getSession(false).setAttribute(\"up_authenticationAttempted\", \"true\");\n     // Preserve the attempted username so it can be redisplayed to the user by CLogin\n     String attemptedUserName = request.getParameter(\"userName\");\n     if (attemptedUserName != null)\n     \trequest.getSession(false).setAttribute(\"up_attemptedUserName\", request.getParameter(\"userName\"));\t\t\n\t}\n\n\tfinal String encodedRedirectURL = response.encodeRedirectURL(redirectTarget);\n    response.sendRedirect(encodedRedirectURL);\n\n  }","id":25651,"modified_method":"/**\n   * Process the incoming HttpServletRequest\n   * @param request\n   * @param response\n   * @exception ServletException\n   * @exception IOException\n   */\n  public void service (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  \tCommonUtils.setNoCache(response);\n\n    // Call to setCharacterEncoding method should be done before any call to req.getParameter() method.\n    try {\n        request.setCharacterEncoding(\"UTF-8\");\n    } catch (UnsupportedEncodingException uee) {\n        log.error(\"Unable to set UTF-8 character encoding!\", uee);\n    }\n\n    final IPersonManager personManager = PersonManagerFactory.getPersonManagerInstance();\n    \n    // Clear out the existing session for the user if they have one\n    String targetUid = null;\n    String originalUid = null;\n    boolean swap = false;\n    if (request.isRequestedSessionIdValid()) {\n    \ttry {\n            HttpSession s = request.getSession(false);\n    \t    //Check if this is a swapped user hitting the Login servlet\n    \t    originalUid = (String)s.getAttribute(SWAP_ORIGINAL_UID);\n\n    \t    //No original person in session so check for swap request\n    \t    if (originalUid == null) {\n        \t    targetUid = (String)s.getAttribute(SWAP_TARGET_UID);\n        \t    if (targetUid != null) {\n        \t        final IPerson person = personManager.getPerson(request);\n        \t        originalUid = person.getName();\n        \t        swap = true;\n        \t    }\n    \t    }\n    \t    else {\n    \t        final IPerson person = personManager.getPerson(request);\n    \t        targetUid = person.getName();\n    \t    }\n\n            s.invalidate();\n    \t} catch (IllegalStateException ise) {\n    \t\t// ISE indicates session was already invalidated.\n    \t\t// This is fine.  This servlet trying to guarantee that the session has been invalidated;\n    \t\t// it doesn't have to insist that it is the one that invalidated it.\n    \t\tif (log.isTraceEnabled()) {\n    \t\t\tlog.trace(\"LoginServlet attempted to invalidate an already invalid session.\", ise);\n    \t\t}\n    \t}\n    }\n\n  \t//  Create the user's session\n    HttpSession s = request.getSession(true);\n    \n  \tIPerson person = null;\n    try {\n        final HashMap principals;\n        final HashMap credentials;\n        \n        // Get the person object associated with the request\n        person = personManager.getPerson(request);\n        \n        //If doing an identity swap\n        if (targetUid != null && originalUid != null) {\n            if (swap) {\n                swapperLog.warn(\"Swapping identity for '\" + originalUid + \"' to '\" + targetUid + \"'\");\n\n                //Track the originating user\n                s.setAttribute(SWAP_ORIGINAL_UID, originalUid);\n                \n                //Setup the swapped person\n                person.setUserName(targetUid);\n            }\n            else {\n                swapperLog.warn(\"Reverting swapped identity from '\" + targetUid + \"' to '\" + originalUid + \"'\");\n                \n                person.setUserName(originalUid);\n            }\n            \n            //Setup the custom security context\n            final IdentitySwapperPrincipal identitySwapperPrincipal = new IdentitySwapperPrincipal(person);\n            final IdentitySwapperSecurityContext identitySwapperSecurityContext = new IdentitySwapperSecurityContext(identitySwapperPrincipal);\n            person.setSecurityContext(identitySwapperSecurityContext);\n            \n            principals = new HashMap();\n            credentials = new HashMap();\n        }\n        //Norm authN path\n        else {\n          // WE grab all of the principals and credentials from the request and load\n          // them into their respective HashMaps.\n          principals = getPropertyFromRequest (principalTokens, request);\n          credentials = getPropertyFromRequest (credentialTokens, request);\n        }\n\n      // Attempt to authenticate using the incoming request\n      m_authenticationService.authenticate(principals, credentials, person);\n    } catch (Exception e) {\n      // Log the exception\n      log.error(\"Exception authenticating the request\", e);\n      // Reset everything\n      request.getSession(false).invalidate();\n      // Add the authentication failure\n      request.getSession(true).setAttribute(\"up_authenticationError\", \"true\");\n      person = null;\n    }\n    \n    \n    \n    // create the redirect URL, adding fname and args parameters if necessary\n    String redirectTarget = null;\n\n    final String refUrl = request.getParameter(\"refUrl\");\n    if (refUrl != null) {\n        if (refUrl.startsWith(\"/\")) {\n            redirectTarget = refUrl;\n        }\n        else {\n            log.warn(\"Refernce URL passed in does not start with a / and will be ignored: \" + refUrl);\n        }\n    }\n    \n    if (redirectTarget == null) {\n        /* Grab the target functional name, if any, off the login request.\n         * Also any arguments for the target\n         * We will pass them  along after authentication.\n         */\n        String targetFname = request.getParameter(\"uP_fname\");\n        \n    \tif (targetFname == null){\n    \t\tredirectTarget = request.getContextPath() + \"/\" + redirectString;\n    \t} else {\n    \t\tStringBuilder sb = new StringBuilder();\n    \t\tsb.append(request.getContextPath());\n    \t\tsb.append(\"/tag.idempotent.\");\n    \t\tsb.append(redirectString);\n    \t\tsb.append(\"?uP_fname=\");\n    \t\tsb.append(URLEncoder.encode(targetFname, \"UTF-8\"));\n    \t\tEnumeration<String> e = request.getParameterNames();\n    \t\twhile(e.hasMoreElements()){\n    \t\t\tString paramName = e.nextElement();\n    \t\t\tif(!paramName.equals(\"uP_fname\")){\n    \t\t\t\tsb.append('&');\n    \t\t\t\tsb.append(paramName);\n    \t\t\t\tsb.append('=');\n    \t\t\t\tsb.append(URLEncoder.encode(request.getParameter(paramName),\"UTF-8\"));\n    \t\t\t}\n    \t\t}\t\t\n    \t\tredirectTarget = sb.toString();\n    \t}\n    }\n\n\tif (person == null || !person.getSecurityContext().isAuthenticated()) {\n     if ( request.getMethod().equals(\"POST\") )\n         request.getSession(false).setAttribute(\"up_authenticationAttempted\", \"true\");\n     // Preserve the attempted username so it can be redisplayed to the user by CLogin\n     String attemptedUserName = request.getParameter(\"userName\");\n     if (attemptedUserName != null)\n     \trequest.getSession(false).setAttribute(\"up_attemptedUserName\", request.getParameter(\"userName\"));\t\t\n\t}\n\n\tfinal String encodedRedirectURL = response.encodeRedirectURL(redirectTarget);\n    response.sendRedirect(encodedRedirectURL);\n\n  }","commit_id":"45f920320605a051907dc41f5f6e9989635226f0","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Internal method just to clarify that the writableRequest should be used from here on out.\n     */\n    protected void doGetInternal(IWritableHttpServletRequest writableRequest, HttpServletResponse res) {\n        // Send the uPortal version in a header\n        final VersionsManager versionManager = VersionsManager.getInstance();\n        final Version version = versionManager.getVersion(IPermission.PORTAL_FRAMEWORK);\n        res.setHeader(\"uPortal-version\", \"uPortal_rel-\" + version.getMajor() + \"-\" + version.getMinor() + \"-\" + version.getMicro());\n\n        //Check if the servlet failed to initialize\n        if (fatalError) {\n            try {\n                final String encodedRedirectURL = res.encodeRedirectURL(\"error/fatal.htm\");\n                res.sendRedirect(encodedRedirectURL);\n            } catch (IOException e) {\n                ExceptionHelper.genericTopHandler(Errors.bug,e);\n            }\n            return;\n        }\n\n        // Call to setCharacterEncoding method should be done before any call to req.getParameter() method.\n        try {\n            writableRequest.setCharacterEncoding(\"UTF-8\");\n        } catch (UnsupportedEncodingException uee) {\n            log.error(\"Unable to set UTF-8 character encoding!\", uee);\n        }\n\n        //Get the user's session\n        final HttpSession session = writableRequest.getSession(false);\n        if (session == null) {\n            try {\n                //Session is null, redirect to Login servlet\n                final String encodedRedirectURL = res.encodeRedirectURL(writableRequest.getContextPath() + \"/Login\");\n                res.sendRedirect(encodedRedirectURL);\n            }\n            catch (Exception e) {\n                ExceptionHelper.genericTopHandler(Errors.bug, e);\n                ExceptionHelper.generateErrorPage(res, e);\n            }\n            \n            return;\n        }\n        \n        final IPersonManager personManager = PersonManagerLocator.getPersonManager();\n\n        // Update the session timeout for an unauthenticated user.\n        final IPerson person = personManager.getPerson(writableRequest);\n        if (person != null && !person.getSecurityContext().isAuthenticated()) {\n\n            if (unauthenticatedUserSessionTimeout != 0) {\n                session.setMaxInactiveInterval(unauthenticatedUserSessionTimeout);\n                \n                if (log.isDebugEnabled()) {\n                    log.debug(\"Unauthenticated user session timeout set to: \" + unauthenticatedUserSessionTimeout);\n                }\n            }\n        }\n        \n        try {\n            final IRequestParameterProcessorController requestProcessorController = RequestParameterProcessorControllerLocator.getRequestParameterProcessorController();\n            requestProcessorController.processParameters(writableRequest, res);\n\n            // Retrieve the user's UserInstance object\n            final IUserInstanceManager userInstanceManager = UserInstanceManagerLocator.getUserInstanceManager();\n            final IUserInstance userInstance = userInstanceManager.getUserInstance(writableRequest);\n            \n            // fire away\n            final IPortalRenderingPipeline portalRenderingPipeline = PortalRenderingPipelineLocator.getPortalRenderingPipeline();\n            portalRenderingPipeline.renderState(writableRequest, res, userInstance);\n        }\n        catch (Exception e) {\n            ExceptionHelper.genericTopHandler(Errors.bug, e);\n            ExceptionHelper.generateErrorPage(res, e);\n            return;\n        }\n    }","id":25652,"modified_method":"/**\n     * Internal method just to clarify that the writableRequest should be used from here on out.\n     */\n    protected void doGetInternal(IWritableHttpServletRequest writableRequest, HttpServletResponse res) {\n        // Send the uPortal version in a header\n        final VersionsManager versionManager = VersionsManager.getInstance();\n        final Version version = versionManager.getVersion(IPermission.PORTAL_FRAMEWORK);\n        res.setHeader(\"uPortal-version\", \"uPortal_rel-\" + version.getMajor() + \"-\" + version.getMinor() + \"-\" + version.getMicro());\n\n        //Check if the servlet failed to initialize\n        if (fatalError) {\n            try {\n                final String encodedRedirectURL = res.encodeRedirectURL(\"error/fatal.htm\");\n                res.sendRedirect(encodedRedirectURL);\n            } catch (IOException e) {\n                ExceptionHelper.genericTopHandler(Errors.bug,e);\n            }\n            return;\n        }\n\n        // Call to setCharacterEncoding method should be done before any call to req.getParameter() method.\n        try {\n            writableRequest.setCharacterEncoding(\"UTF-8\");\n        } catch (UnsupportedEncodingException uee) {\n            log.error(\"Unable to set UTF-8 character encoding!\", uee);\n        }\n\n        //Get the user's session\n        final HttpSession session = writableRequest.getSession(false);\n        if (session == null) {\n            try {\n                //Session is null, redirect to Login servlet\n                final StringBuilder loginRedirect = new StringBuilder();\n                \n                loginRedirect.append(writableRequest.getContextPath());\n                loginRedirect.append(\"/Login?refUrl=\");\n                \n                final String requestEncoding = writableRequest.getCharacterEncoding();\n                loginRedirect.append(URLEncoder.encode(writableRequest.getRequestURI(), requestEncoding));\n                \n                final String queryString = writableRequest.getQueryString();\n                if (queryString != null) {\n                    loginRedirect.append(URLEncoder.encode(\"?\", requestEncoding));\n                    loginRedirect.append(URLEncoder.encode(queryString, requestEncoding));\n                }\n                \n                final String encodedRedirectURL = res.encodeRedirectURL(loginRedirect.toString());\n                res.sendRedirect(encodedRedirectURL);\n            }\n            catch (Exception e) {\n                ExceptionHelper.genericTopHandler(Errors.bug, e);\n                ExceptionHelper.generateErrorPage(res, e);\n            }\n            \n            return;\n        }\n        \n        final IPersonManager personManager = PersonManagerLocator.getPersonManager();\n\n        // Update the session timeout for an unauthenticated user.\n        final IPerson person = personManager.getPerson(writableRequest);\n        if (person != null && !person.getSecurityContext().isAuthenticated()) {\n\n            if (unauthenticatedUserSessionTimeout != 0) {\n                session.setMaxInactiveInterval(unauthenticatedUserSessionTimeout);\n                \n                if (log.isDebugEnabled()) {\n                    log.debug(\"Unauthenticated user session timeout set to: \" + unauthenticatedUserSessionTimeout);\n                }\n            }\n        }\n        \n        try {\n            final IRequestParameterProcessorController requestProcessorController = RequestParameterProcessorControllerLocator.getRequestParameterProcessorController();\n            requestProcessorController.processParameters(writableRequest, res);\n\n            // Retrieve the user's UserInstance object\n            final IUserInstanceManager userInstanceManager = UserInstanceManagerLocator.getUserInstanceManager();\n            final IUserInstance userInstance = userInstanceManager.getUserInstance(writableRequest);\n            \n            // fire away\n            final IPortalRenderingPipeline portalRenderingPipeline = PortalRenderingPipelineLocator.getPortalRenderingPipeline();\n            portalRenderingPipeline.renderState(writableRequest, res, userInstance);\n        }\n        catch (Exception e) {\n            ExceptionHelper.genericTopHandler(Errors.bug, e);\n            ExceptionHelper.generateErrorPage(res, e);\n            return;\n        }\n    }","commit_id":"45f920320605a051907dc41f5f6e9989635226f0","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n\t * Prepare a builder by copying the scheme, host, port, path, and\n\t * query string of an HttpServletRequest.\n\t */\n\tpublic static ServletUriComponentsBuilder fromRequest(HttpServletRequest request) {\n\t\tString scheme = request.getScheme();\n\t\tString host = request.getServerName();\n\t\tint port = request.getServerPort();\n\t\tString path = request.getRequestURI();\n\n\t\tString hostHeader = request.getHeader(\"X-Forwarded-Host\");\n\t\tif (StringUtils.hasText(hostHeader)) {\n\t\t\tString[] hosts = StringUtils.commaDelimitedListToStringArray(hostHeader);\n\t\t\tString hostToUse = hosts[0];\n\t\t\tif (hostToUse.contains(\":\")) {\n\t\t\t\tString[] hostAndPort = StringUtils.split(hostToUse, \":\");\n\t\t\t\thost  = hostAndPort[0];\n\t\t\t\tport = Integer.parseInt(hostAndPort[1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\thost = hostToUse;\n\t\t\t\tport = -1;\n\t\t\t}\n\t\t}\n\n\t\tString portHeader = request.getHeader(\"X-Forwarded-Port\");\n\t\tif (StringUtils.hasText(portHeader)) {\n\t\t\tport = Integer.parseInt(portHeader);\n\t\t}\n\n\t\tString protocolHeader = request.getHeader(\"X-Forwarded-Proto\");\n\t\tif (StringUtils.hasText(protocolHeader)) {\n\t\t\tscheme = protocolHeader;\n\t\t}\n\n\t\tString prefix = request.getHeader(\"X-Forwarded-Prefix\");\n\t\tif (StringUtils.hasText(prefix)) {\n\t\t\tpath = prefix + path;\n\t\t}\n\n\t\tServletUriComponentsBuilder builder = new ServletUriComponentsBuilder();\n\t\tbuilder.scheme(scheme);\n\t\tbuilder.host(host);\n\t\tif (scheme.equals(\"http\") && port != 80 || scheme.equals(\"https\") && port != 443) {\n\t\t\tbuilder.port(port);\n\t\t}\n\t\tbuilder.initPath(path);\n\t\tbuilder.query(request.getQueryString());\n\t\treturn builder;\n\t}","id":25653,"modified_method":"/**\n\t * Prepare a builder by copying the scheme, host, port, path, and\n\t * query string of an HttpServletRequest.\n\t */\n\tpublic static ServletUriComponentsBuilder fromRequest(HttpServletRequest request) {\n\t\tString scheme = request.getScheme();\n\t\tString host = request.getServerName();\n\t\tint port = request.getServerPort();\n\n\t\tString hostHeader = request.getHeader(\"X-Forwarded-Host\");\n\t\tif (StringUtils.hasText(hostHeader)) {\n\t\t\tString[] hosts = StringUtils.commaDelimitedListToStringArray(hostHeader);\n\t\t\tString hostToUse = hosts[0];\n\t\t\tif (hostToUse.contains(\":\")) {\n\t\t\t\tString[] hostAndPort = StringUtils.split(hostToUse, \":\");\n\t\t\t\thost  = hostAndPort[0];\n\t\t\t\tport = Integer.parseInt(hostAndPort[1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\thost = hostToUse;\n\t\t\t\tport = -1;\n\t\t\t}\n\t\t}\n\n\t\tString portHeader = request.getHeader(\"X-Forwarded-Port\");\n\t\tif (StringUtils.hasText(portHeader)) {\n\t\t\tport = Integer.parseInt(portHeader);\n\t\t}\n\n\t\tString protocolHeader = request.getHeader(\"X-Forwarded-Proto\");\n\t\tif (StringUtils.hasText(protocolHeader)) {\n\t\t\tscheme = protocolHeader;\n\t\t}\n\n\t\tString path = request.getRequestURI();\n\t\tpath = prependForwardedPrefix(request, path);\n\n\t\tServletUriComponentsBuilder builder = new ServletUriComponentsBuilder();\n\t\tbuilder.scheme(scheme);\n\t\tbuilder.host(host);\n\t\tif (scheme.equals(\"http\") && port != 80 || scheme.equals(\"https\") && port != 443) {\n\t\t\tbuilder.port(port);\n\t\t}\n\t\tbuilder.initPath(path);\n\t\tbuilder.query(request.getQueryString());\n\t\treturn builder;\n\t}","commit_id":"7f11c1ee2f802b3a2a5b821c821b15c6705dc085","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Prepare a builder from the host, port, scheme, and context path of\n\t * an HttpServletRequest.\n\t */\n\tpublic static ServletUriComponentsBuilder fromContextPath(HttpServletRequest request) {\n\t\tServletUriComponentsBuilder builder = fromRequest(request);\n\t\tbuilder.replacePath(request.getContextPath());\n\t\tbuilder.replaceQuery(null);\n\t\treturn builder;\n\t}","id":25654,"modified_method":"/**\n\t * Prepare a builder from the host, port, scheme, and context path of\n\t * an HttpServletRequest.\n\t */\n\tpublic static ServletUriComponentsBuilder fromContextPath(HttpServletRequest request) {\n\t\tString path = request.getContextPath();\n\t\tpath = prependForwardedPrefix(request, path);\n\t\tServletUriComponentsBuilder builder = fromRequest(request);\n\t\tbuilder.replacePath(path);\n\t\tbuilder.replaceQuery(null);\n\t\treturn builder;\n\t}","commit_id":"7f11c1ee2f802b3a2a5b821c821b15c6705dc085","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void run(String[] args, Observer observer) {\n        if (args.length == 0) {\n            logger.info(\"No configuration file specified!\");\n            return;\n        }\n\n        String shutdownHookOption = System.getProperty(\"exist.register-shutdown-hook\", \"true\");\n        boolean registerShutdownHook = shutdownHookOption.equals(\"true\");\n\n        Properties sysProperties = new Properties();\n\t\ttry\n\t\t{\n\t\t\tsysProperties.load(GetVersion.class.getClassLoader().getResourceAsStream(\"org/exist/system.properties\"));\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\n        // configure database\n        logger.info(\"Configuring eXist from \" + SingleInstanceConfiguration.getPath());\n        logger.info(\"\");\n        logger.info(\"Running with Java \"+\n                System.getProperty(\"java.version\", \"(unknown java.version)\") + \" [\" +\n                System.getProperty(\"java.vendor\", \"(unknown java.vendor)\") + \" (\" +\n                System.getProperty(\"java.vm.name\", \"(unknown java.vm.name)\") + \") in \" +\n                System.getProperty(\"java.home\", \"(unknown java.home)\") +\"]\");\n        logger.info(\"\");\n\n        String msg;\n        msg = \"[eXist Version : \" + sysProperties.get(\"product-version\") + \"]\";\n        logger.info(msg);\n        msg = \"[eXist Build : \" + sysProperties.get(\"product-build\") + \"]\";\n        logger.info(msg);\n        msg = \"[eXist Home : \" + System.getProperty(\"exist.home\") + \"]\";\n        logger.info(msg);\n        msg = \"[SVN Revision : \" + sysProperties.get(\"svn-revision\") + \"]\";\n        logger.info(msg);\n        msg = \"[Operating System : \" +\n        \t\tSystem.getProperty(\"os.name\") +\n        \t\t\" \" +\n        \t\tSystem.getProperty(\"os.version\") +\n                \" \" +\n                System.getProperty(\"os.arch\") +\n                \"]\";\n        logger.info(msg);\n\n        msg = \"[jetty.home : \" + System.getProperty(\"jetty.home\") + \"]\";\n        logger.info(msg);\n        msg = \"[log4j.configuration : \" + System.getProperty(\"log4j.configuration\") + \"]\";\n        logger.info(msg);\n\n        try {\n            // we register our own shutdown hook\n            BrokerPool.setRegisterShutdownHook(false);\n\n            // configure the database instance\n            SingleInstanceConfiguration config;\n            if (args.length == 2) {\n                config = new SingleInstanceConfiguration(args[1]);\n            } else {\n                config = new SingleInstanceConfiguration();\n            }\n\n            if (observer != null){\n                BrokerPool.registerStatusObserver(observer);\n            }\n\n            BrokerPool.configure(1, 5, config);\n\n            // register the XMLDB driver\n            Database xmldb = new DatabaseImpl();\n            xmldb.setProperty(\"create-database\", \"false\");\n            DatabaseManager.registerDatabase(xmldb);\n\n            configureCluster(config);\n\n        } catch (Exception e) {\n            logger.error(\"configuration error: \" + e.getMessage(), e);\n            e.printStackTrace();\n            return;\n        }\n\n        // start Jetty\n        final Server server;\n        int port = 8080;\n        try {\n            server = new Server();\n            InputStream is = new FileInputStream(args[0]);\n            XmlConfiguration configuration = new XmlConfiguration(is);\n            configuration.configure(server);\n            \n            server.setStopAtShutdown(true);\n            server.addLifeCycleListener(this);\n            BrokerPool.getInstance().registerShutdownListener(new ShutdownListenerImpl(server));\n            server.start();\n\n            Connector[] connectors = server.getConnectors();\n            if (connectors.length > 0) {\n                port = connectors[0].getPort();\n            }\n            \n            //TODO: use plaggable interface\n            Class<?> openid = null;\n            try {\n            \topenid = Class.forName(\"org.exist.security.openid.servlet.AuthenticatorOpenId\");\n            } catch (ClassNotFoundException e) {\n\t\t\t}\n            //*************************************************************\n\n            logger.info(\"-----------------------------------------------------\");\n            logger.info(\"Server has started on port \" + port + \". Configured contexts:\");\n\n            HandlerCollection rootHandler = (HandlerCollection)server.getHandler();\n            Handler[] handlers = rootHandler.getHandlers();\n            for (Handler handler: handlers) {\n            \tif (handler instanceof ContextHandler) {\n\t\t\t\t\tContextHandler contextHandler = (ContextHandler) handler;\n\t            \tlogger.info(\"http://localhost:\" + port + contextHandler.getContextPath());\n            \t}\n            \t\n            \t//TODO: pluggable in future\n            \tif (openid != null)\n            \t\tif (handler instanceof ServletContextHandler) {\n            \t\t\tServletContextHandler contextHandler = (ServletContextHandler) handler;\n            \t\t\tcontextHandler.addServlet(new ServletHolder(openid),\"/openid\");\n            \t\t\tlogger.info(\"http://localhost:\" + port + contextHandler.getContextPath() + \"/openid\");\n            \t\t}\n                //*************************************************************\n            }\n\n            logger.info(\"-----------------------------------------------------\");\n\n            if (registerShutdownHook) {\n                // register a shutdown hook for the server\n                shutdownHook = new Thread() {\n\n                    @Override\n                    public void run() {\n                        setName(\"Shutdown\");\n                        BrokerPool.stopAll(true);\n                        if (server.isStopping() || server.isStopped())\n                            return;\n                        try {\n                            server.stop();\n                        } catch (Exception e) {\n                        }\n//                        try {\n//                            Thread.sleep(1000);\n//                        } catch (Exception e) {\n//                            e.printStackTrace();\n//                        }\n                    }\n                };\n                Runtime.getRuntime().addShutdownHook(shutdownHook);\n            }\n            \n        } catch (MultiException e) {\n\n            // Mute the BindExceptions\n\n            boolean hasBindException = false;\n            for (Object t : e.getThrowables()) {\n                if (t instanceof java.net.BindException) {\n                    hasBindException = true;\n                    logger.info(\"----------------------------------------------------------\");\n                    logger.info(\"ERROR: Could not bind to port because \" +\n                        ((Exception) t).getMessage());\n                    logger.info(t.toString());\n                    logger.info(\"----------------------------------------------------------\");\n                }\n            }\n\n            // If it is another error, print stacktrace\n            if (!hasBindException) {\n                e.printStackTrace();\n            }\n        } catch (SocketException e) {\n            logger.info(\"----------------------------------------------------------\");\n            logger.info(\"ERROR: Could not bind to port because \" +\n                        e.getMessage());\n            logger.info(e.toString());\n            logger.info(\"----------------------------------------------------------\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","id":25655,"modified_method":"public void run(String[] args, Observer observer) {\n        if (args.length == 0) {\n            logger.info(\"No configuration file specified!\");\n            return;\n        }\n\n        String shutdownHookOption = System.getProperty(\"exist.register-shutdown-hook\", \"true\");\n        boolean registerShutdownHook = shutdownHookOption.equals(\"true\");\n\n        Properties sysProperties = new Properties();\n\t\ttry\n\t\t{\n\t\t\tsysProperties.load(GetVersion.class.getClassLoader().getResourceAsStream(\"org/exist/system.properties\"));\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\n        // configure database\n        logger.info(\"Configuring eXist from \" + SingleInstanceConfiguration.getPath());\n        logger.info(\"\");\n        logger.info(\"Running with Java \"+\n                System.getProperty(\"java.version\", \"(unknown java.version)\") + \" [\" +\n                System.getProperty(\"java.vendor\", \"(unknown java.vendor)\") + \" (\" +\n                System.getProperty(\"java.vm.name\", \"(unknown java.vm.name)\") + \") in \" +\n                System.getProperty(\"java.home\", \"(unknown java.home)\") +\"]\");\n        logger.info(\"\");\n\n        String msg;\n        msg = \"[eXist Version : \" + sysProperties.get(\"product-version\") + \"]\";\n        logger.info(msg);\n        msg = \"[eXist Build : \" + sysProperties.get(\"product-build\") + \"]\";\n        logger.info(msg);\n        msg = \"[eXist Home : \" + System.getProperty(\"exist.home\") + \"]\";\n        logger.info(msg);\n        msg = \"[SVN Revision : \" + sysProperties.get(\"svn-revision\") + \"]\";\n        logger.info(msg);\n        msg = \"[Operating System : \" +\n        \t\tSystem.getProperty(\"os.name\") +\n        \t\t\" \" +\n        \t\tSystem.getProperty(\"os.version\") +\n                \" \" +\n                System.getProperty(\"os.arch\") +\n                \"]\";\n        logger.info(msg);\n\n        msg = \"[jetty.home : \" + System.getProperty(\"jetty.home\") + \"]\";\n        logger.info(msg);\n        msg = \"[log4j.configuration : \" + System.getProperty(\"log4j.configuration\") + \"]\";\n        logger.info(msg);\n\n        try {\n            // we register our own shutdown hook\n            BrokerPool.setRegisterShutdownHook(false);\n\n            // configure the database instance\n            SingleInstanceConfiguration config;\n            if (args.length == 2) {\n                config = new SingleInstanceConfiguration(args[1]);\n            } else {\n                config = new SingleInstanceConfiguration();\n            }\n\n            if (observer != null){\n                BrokerPool.registerStatusObserver(observer);\n            }\n\n            BrokerPool.configure(1, 5, config);\n\n            // register the XMLDB driver\n            Database xmldb = new DatabaseImpl();\n            xmldb.setProperty(\"create-database\", \"false\");\n            DatabaseManager.registerDatabase(xmldb);\n\n            configureCluster(config);\n\n        } catch (Exception e) {\n            logger.error(\"configuration error: \" + e.getMessage(), e);\n            e.printStackTrace();\n            return;\n        }\n\n        // start Jetty\n        final Server server;\n        int port = 8080;\n        try {\n            server = new Server();\n            InputStream is = new FileInputStream(args[0]);\n            XmlConfiguration configuration = new XmlConfiguration(is);\n            configuration.configure(server);\n            \n            server.setStopAtShutdown(true);\n            server.addLifeCycleListener(this);\n            BrokerPool.getInstance().registerShutdownListener(new ShutdownListenerImpl(server));\n            server.start();\n\n            Connector[] connectors = server.getConnectors();\n            if (connectors.length > 0) {\n                port = connectors[0].getPort();\n            }\n            \n            //TODO: use plaggable interface\n            Class<?> openid = null;\n            try {\n            \topenid = Class.forName(\"org.exist.security.openid.servlet.AuthenticatorOpenId\");\n            } catch (ClassNotFoundException e) {\n\t\t\t}\n            //*************************************************************\n\n            logger.info(\"-----------------------------------------------------\");\n            logger.info(\"Server has started on port \" + port + \". Configured contexts:\");\n\n            HandlerCollection rootHandler = (HandlerCollection)server.getHandler();\n            Handler[] handlers = rootHandler.getHandlers();\n            for (Handler handler: handlers) {\n            \tif (handler instanceof ContextHandler) {\n\t\t\t\t\tContextHandler contextHandler = (ContextHandler) handler;\n\t            \tlogger.info(\"http://localhost:\" + port + contextHandler.getContextPath());\n            \t}\n            \t\n            \t//TODO: pluggable in future\n            \tif (openid != null)\n            \t\tif (handler instanceof ServletContextHandler) {\n            \t\t\tServletContextHandler contextHandler = (ServletContextHandler) handler;\n            \t\t\tString suffix;\n            \t\t\tif (contextHandler.getContextPath().equals(\"/\"))\n            \t\t\t\tsuffix = \"*.openid\";\n            \t\t\telse \n            \t\t\t\tsuffix = \"/openid\";\n            \t\t\t\t\n            \t\t\tcontextHandler.addServlet(new ServletHolder(openid), suffix);\n            \t\t\tlogger.info(\"http://localhost:\" + port + contextHandler.getContextPath() + suffix);\n            \t\t}\n                //*************************************************************\n            }\n\n            logger.info(\"-----------------------------------------------------\");\n\n            if (registerShutdownHook) {\n                // register a shutdown hook for the server\n                shutdownHook = new Thread() {\n\n                    @Override\n                    public void run() {\n                        setName(\"Shutdown\");\n                        BrokerPool.stopAll(true);\n                        if (server.isStopping() || server.isStopped())\n                            return;\n                        try {\n                            server.stop();\n                        } catch (Exception e) {\n                        }\n//                        try {\n//                            Thread.sleep(1000);\n//                        } catch (Exception e) {\n//                            e.printStackTrace();\n//                        }\n                    }\n                };\n                Runtime.getRuntime().addShutdownHook(shutdownHook);\n            }\n            \n        } catch (MultiException e) {\n\n            // Mute the BindExceptions\n\n            boolean hasBindException = false;\n            for (Object t : e.getThrowables()) {\n                if (t instanceof java.net.BindException) {\n                    hasBindException = true;\n                    logger.info(\"----------------------------------------------------------\");\n                    logger.info(\"ERROR: Could not bind to port because \" +\n                        ((Exception) t).getMessage());\n                    logger.info(t.toString());\n                    logger.info(\"----------------------------------------------------------\");\n                }\n            }\n\n            // If it is another error, print stacktrace\n            if (!hasBindException) {\n                e.printStackTrace();\n            }\n        } catch (SocketException e) {\n            logger.info(\"----------------------------------------------------------\");\n            logger.info(\"ERROR: Could not bind to port because \" +\n                        e.getMessage());\n            logger.info(e.toString());\n            logger.info(\"----------------------------------------------------------\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","commit_id":"c4e791974ad3bfb217eb15079008147941f33d30","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * Convert model to request parameters and redirect to the given URL.\n\t * @see #appendQueryProperties\n\t * @see #sendRedirect\n\t */\n\t@Override\n\tprotected void renderMergedOutputModel(\n\t\t\tMap<String, Object> model, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows IOException {\n\n\t\t// Prepare target URL.\n\t\tStringBuilder targetUrl = new StringBuilder();\n\t\tif (this.contextRelative && getUrl().startsWith(\"/\")) {\n\t\t\t// Do not apply context path to relative URLs.\n\t\t\ttargetUrl.append(request.getContextPath());\n\t\t}\n\t\ttargetUrl.append(getUrl());\n\t\tif (this.exposeModelAttributes) {\n\t\t\tString enc = this.encodingScheme;\n\t\t\tif (enc == null) {\n\t\t\t\tenc = request.getCharacterEncoding();\n\t\t\t}\n\t\t\tif (enc == null) {\n\t\t\t\tenc = WebUtils.DEFAULT_CHARACTER_ENCODING;\n\t\t\t}\n\t\t\tappendQueryProperties(targetUrl, model, enc);\n\t\t}\n\n\t\tsendRedirect(request, response, targetUrl.toString(), this.http10Compatible);\n\t}","id":25656,"modified_method":"/**\n\t * Convert model to request parameters and redirect to the given URL.\n\t * @see #appendQueryProperties\n\t * @see #sendRedirect\n\t */\n\t@Override\n\tprotected void renderMergedOutputModel(\n\t\t\tMap<String, Object> model, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows IOException {\n\n\t\tString encoding = getEncoding(request);\n\n\t\t// Prepare target URL.\n\t\tStringBuilder targetUrl = new StringBuilder();\n\t\tif (this.contextRelative && getUrl().startsWith(\"/\")) {\n\t\t\t// Do not apply context path to relative URLs.\n\t\t\ttargetUrl.append(UriUtils.encodePath(request.getContextPath(), encoding));\n\t\t\ttargetUrl.append(UriUtils.encodePath(getUrl(), encoding));\n\t\t}\n\t\telse {\n\t\t\ttargetUrl.append(UriUtils.encodeUri(getUrl(), encoding));\n\t\t}\n\t\tif (this.exposeModelAttributes) {\n\t\t\tappendQueryProperties(targetUrl, model, encoding);\n\t\t}\n\n\t\tsendRedirect(request, response, targetUrl.toString(), this.http10Compatible);\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Append query properties to the redirect URL.\n\t * Stringifies, URL-encodes and formats model attributes as query properties.\n\t * @param targetUrl the StringBuilder to append the properties to\n\t * @param model Map that contains model attributes\n\t * @param encodingScheme the encoding scheme to use\n\t * @throws UnsupportedEncodingException if string encoding failed\n\t * @see #queryProperties\n\t */\n\tprotected void appendQueryProperties(StringBuilder targetUrl, Map<String, Object> model, String encodingScheme)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\t// Extract anchor fragment, if any.\n\t\tString fragment = null;\n\t\tint anchorIndex = targetUrl.indexOf(\"#\");\n\t\tif (anchorIndex > -1) {\n\t\t\tfragment = targetUrl.substring(anchorIndex);\n\t\t\ttargetUrl.delete(anchorIndex, targetUrl.length());\n\t\t}\n\n\t\t// If there aren't already some parameters, we need a \"?\".\n\t\tboolean first = (getUrl().indexOf('?') < 0);\n\t\tfor (Map.Entry<String, Object> entry : queryProperties(model).entrySet()) {\n\t\t\tObject rawValue = entry.getValue();\n\t\t\tIterator valueIter = null;\n\t\t\tif (rawValue != null && rawValue.getClass().isArray()) {\n\t\t\t\tvalueIter = Arrays.asList(ObjectUtils.toObjectArray(rawValue)).iterator();\n\t\t\t}\n\t\t\telse if (rawValue instanceof Collection) {\n\t\t\t\tvalueIter = ((Collection) rawValue).iterator();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueIter = Collections.singleton(rawValue).iterator();\n\t\t\t}\n\t\t\twhile (valueIter.hasNext()) {\n\t\t\t\tObject value = valueIter.next();\n\t\t\t\tif (first) {\n\t\t\t\t\ttargetUrl.append('?');\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttargetUrl.append('&');\n\t\t\t\t}\n\t\t\t\tString encodedKey = urlEncode(entry.getKey(), encodingScheme);\n\t\t\t\tString encodedValue = (value != null ? urlEncode(value.toString(), encodingScheme) : \"\");\n\t\t\t\ttargetUrl.append(encodedKey).append('=').append(encodedValue);\n\t\t\t}\n\t\t}\n\n\t\t// Append anchor fragment, if any, to end of URL.\n\t\tif (fragment != null) {\n\t\t\ttargetUrl.append(fragment);\n\t\t}\n\t}","id":25657,"modified_method":"/**\n\t * Append query properties to the redirect URL.\n\t * Stringifies, URL-encodes and formats model attributes as query properties.\n\t * @param targetUrl the StringBuilder to append the properties to\n\t * @param model Map that contains model attributes\n\t * @param encodingScheme the encoding scheme to use\n\t * @throws UnsupportedEncodingException if string encoding failed\n\t * @see #queryProperties\n\t */\n\tprotected void appendQueryProperties(StringBuilder targetUrl, Map<String, Object> model, String encodingScheme)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\t// Extract anchor fragment, if any.\n\t\tString fragment = null;\n\t\tint anchorIndex = targetUrl.indexOf(\"#\");\n\t\tif (anchorIndex > -1) {\n\t\t\tfragment = targetUrl.substring(anchorIndex);\n\t\t\ttargetUrl.delete(anchorIndex, targetUrl.length());\n\t\t}\n\n\t\t// If there aren't already some parameters, we need a \"?\".\n\t\tboolean first = (getUrl().indexOf('?') < 0);\n\t\tfor (Map.Entry<String, Object> entry : queryProperties(model).entrySet()) {\n\t\t\tObject rawValue = entry.getValue();\n\t\t\tIterator valueIter = null;\n\t\t\tif (rawValue != null && rawValue.getClass().isArray()) {\n\t\t\t\tvalueIter = Arrays.asList(ObjectUtils.toObjectArray(rawValue)).iterator();\n\t\t\t}\n\t\t\telse if (rawValue instanceof Collection) {\n\t\t\t\tvalueIter = ((Collection) rawValue).iterator();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueIter = Collections.singleton(rawValue).iterator();\n\t\t\t}\n\t\t\twhile (valueIter.hasNext()) {\n\t\t\t\tObject value = valueIter.next();\n\t\t\t\tif (first) {\n\t\t\t\t\ttargetUrl.append('?');\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttargetUrl.append('&');\n\t\t\t\t}\n\t\t\t\tString encodedKey = UriUtils.encodeQueryParam(entry.getKey(), encodingScheme);\n\t\t\t\tString encodedValue = (value != null ? UriUtils.encodeQueryParam(value.toString(), encodingScheme) : \"\");\n\t\t\t\ttargetUrl.append(encodedKey).append('=').append(encodedValue);\n\t\t\t}\n\t\t}\n\n\t\t// Append anchor fragment, if any, to end of URL.\n\t\tif (fragment != null) {\n\t\t\ttargetUrl.append(fragment);\n\t}\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void twoParams() throws Exception {\n\t\tString url = \"http://url.somewhere.com\";\n\t\tString key = \"foo\";\n\t\tString val = \"bar\";\n\t\tString key2 = \"thisIsKey2\";\n\t\tString val2 = \"andThisIsVal2\";\n\t\tMap model = new HashMap();\n\t\tmodel.put(key, val);\n\t\tmodel.put(key2, val2);\n\t\ttry {\n\t\t\tString expectedUrlForEncoding = \"http://url.somewhere.com?\" + key + \"=\" + val + \"&\" + key2 + \"=\" + val2;\n\t\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t\t}\n\t\tcatch (AssertionFailedError err) {\n\t\t\t// OK, so it's the other order... probably on Sun JDK 1.6 or IBM JDK 1.5\n\t\t\tString expectedUrlForEncoding = \"http://url.somewhere.com?\" + key2 + \"=\" + val2 + \"&\" + key + \"=\" + val;\n\t\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t\t}\n\t}","id":25658,"modified_method":"@Test\n\tpublic void twoParams() throws Exception {\n\t\tString url = \"http://url.somewhere.com\";\n\t\tString key = \"foo\";\n\t\tString val = \"bar\";\n\t\tString key2 = \"thisIsKey2\";\n\t\tString val2 = \"andThisIsVal2\";\n\t\tMap<String, String> model = new HashMap<String, String>();\n\t\tmodel.put(key, val);\n\t\tmodel.put(key2, val2);\n\t\ttry {\n\t\t\tString expectedUrlForEncoding = \"http://url.somewhere.com?\" + key + \"=\" + val + \"&\" + key2 + \"=\" + val2;\n\t\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t\t}\n\t\tcatch (AssertionFailedError err) {\n\t\t\t// OK, so it's the other order... probably on Sun JDK 1.6 or IBM JDK 1.5\n\t\t\tString expectedUrlForEncoding = \"http://url.somewhere.com?\" + key2 + \"=\" + val2 + \"&\" + key + \"=\" + val;\n\t\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t\t}\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void objectConversion() throws Exception {\n\t\tString url = \"http://url.somewhere.com\";\n\t\tString key = \"foo\";\n\t\tString val = \"bar\";\n\t\tString key2 = \"int2\";\n\t\tObject val2 = new Long(611);\n\t\tObject key3 = \"tb\";\n\t\tObject val3 = new TestBean();\n\t\tMap model = new LinkedHashMap();\n\t\tmodel.put(key, val);\n\t\tmodel.put(key2, val2);\n\t\tmodel.put(key3, val3);\n\t\tString expectedUrlForEncoding = \"http://url.somewhere.com?\" + key + \"=\" + val + \"&\" + key2 + \"=\" + val2;\n\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t}","id":25659,"modified_method":"@Test\n\tpublic void objectConversion() throws Exception {\n\t\tString url = \"http://url.somewhere.com\";\n\t\tString key = \"foo\";\n\t\tString val = \"bar\";\n\t\tString key2 = \"int2\";\n\t\tObject val2 = new Long(611);\n\t\tString key3 = \"tb\";\n\t\tObject val3 = new TestBean();\n\t\tMap<String, Object> model = new HashMap<String, Object>();\n\t\tmodel.put(key, val);\n\t\tmodel.put(key2, val2);\n\t\tmodel.put(key3, val3);\n\t\tString expectedUrlForEncoding = \"http://url.somewhere.com?\" + key + \"=\" + val + \"&\" + key2 + \"=\" + val2;\n\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void doTest(final Map<String, ?> map, final String url, final boolean contextRelative,\n\t\t\tfinal boolean exposeModelAttributes, String expectedUrlForEncoding) throws Exception {\n\n\t\tclass TestRedirectView extends RedirectView {\n\n\t\t\tpublic boolean queryPropertiesCalled = false;\n\n\t\t\t/**\n\t\t\t * Test whether this callback method is called with correct args\n\t\t\t */\n\t\t\tprotected Map queryProperties(Map model) {\n\t\t\t\t// They may not be the same model instance, but they're still equal\n\t\t\t\tassertTrue(\"Map and model must be equal.\", map.equals(model));\n\t\t\t\tthis.queryPropertiesCalled = true;\n\t\t\t\treturn super.queryProperties(model);\n\t\t\t}\n\t\t}\n\n\t\tTestRedirectView rv = new TestRedirectView();\n\t\trv.setUrl(url);\n\t\trv.setContextRelative(contextRelative);\n\t\trv.setExposeModelAttributes(exposeModelAttributes);\n\n\t\tMockControl requestControl = MockControl.createControl(HttpServletRequest.class);\n\t\tHttpServletRequest request = (HttpServletRequest) requestControl.getMock();\n\t\trequest.getCharacterEncoding();\n\t\trequestControl.setReturnValue(null, 1);\n\t\tif (contextRelative) {\n\t\t\texpectedUrlForEncoding = \"/context\" + expectedUrlForEncoding;\n\t\t\trequest.getContextPath();\n\t\t\trequestControl.setReturnValue(\"/context\");\n\t\t}\n\t\trequestControl.replay();\n\n\t\tMockControl responseControl = MockControl.createControl(HttpServletResponse.class);\n\t\tHttpServletResponse resp = (HttpServletResponse) responseControl.getMock();\n\t\tresp.encodeRedirectURL(expectedUrlForEncoding);\n\t\tresponseControl.setReturnValue(expectedUrlForEncoding);\n\t\tresp.sendRedirect(expectedUrlForEncoding);\n\t\tresponseControl.setVoidCallable(1);\n\t\tresponseControl.replay();\n\n\t\trv.render(map, request, resp);\n\t\tif (exposeModelAttributes) {\n\t\t\tassertTrue(\"queryProperties() should have been called.\", rv.queryPropertiesCalled);\n\t\t}\n\t\tresponseControl.verify();\n\t}","id":25660,"modified_method":"private void doTest(final Map<String, ?> map, final String url, final boolean contextRelative,\n\t\t\tfinal boolean exposeModelAttributes, String expectedUrlForEncoding) throws Exception {\n\n\t\tclass TestRedirectView extends RedirectView {\n\n\t\t\tpublic boolean queryPropertiesCalled = false;\n\n\t\t\t/**\n\t\t\t * Test whether this callback method is called with correct args\n\t\t\t */\n\t\t\t@Override\n\t\t\tprotected Map<String, Object> queryProperties(Map<String, Object> model) {\n\t\t\t\t// They may not be the same model instance, but they're still equal\n\t\t\t\tassertTrue(\"Map and model must be equal.\", map.equals(model));\n\t\t\t\tthis.queryPropertiesCalled = true;\n\t\t\t\treturn super.queryProperties(model);\n\t\t\t}\n\t\t}\n\n\t\tTestRedirectView rv = new TestRedirectView();\n\t\trv.setUrl(url);\n\t\trv.setContextRelative(contextRelative);\n\t\trv.setExposeModelAttributes(exposeModelAttributes);\n\n\t\tHttpServletRequest request = createNiceMock(\"request\", HttpServletRequest.class);\n\t\tif (exposeModelAttributes) {\n\t\t\texpect(request.getCharacterEncoding()).andReturn(WebUtils.DEFAULT_CHARACTER_ENCODING);\n\t\t}\n\t\tif (contextRelative) {\n\t\t\texpectedUrlForEncoding = \"/context\" + expectedUrlForEncoding;\n\t\t\texpect(request.getContextPath()).andReturn(\"/context\");\n\t\t}\n\n\t\tHttpServletResponse response = createMock(\"response\", HttpServletResponse.class);\n\t\texpect(response.encodeRedirectURL(expectedUrlForEncoding)).andReturn(expectedUrlForEncoding);\n\t\tresponse.sendRedirect(expectedUrlForEncoding);\n\n\t\treplay(request, response);\n\n\t\trv.render(map, request, response);\n\t\tif (exposeModelAttributes) {\n\t\t\tassertTrue(\"queryProperties() should have been called.\", rv.queryPropertiesCalled);\n\t\t}\n\n\t\tverify(request, response);\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void emptyMap() throws Exception {\n\t\tString url = \"/myUrl\";\n\t\tdoTest(new HashMap(), url, false, url);\n\t}","id":25661,"modified_method":"@Test\n\tpublic void emptyMap() throws Exception {\n\t\tString url = \"/myUrl\";\n\t\tdoTest(new HashMap<String, Object>(), url, false, url);\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void paramWithAnchor() throws Exception {\n\t\tString url = \"http://url.somewhere.com/test.htm#myAnchor\";\n\t\tString key = \"foo\";\n\t\tString val = \"bar\";\n\t\tMap model = new HashMap();\n\t\tmodel.put(key, val);\n\t\tString expectedUrlForEncoding = \"http://url.somewhere.com/test.htm\" + \"?\" + key + \"=\" + val + \"#myAnchor\";\n\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t}","id":25662,"modified_method":"@Test\n\tpublic void paramWithAnchor() throws Exception {\n\t\tString url = \"http://url.somewhere.com/test.htm#myAnchor\";\n\t\tString key = \"foo\";\n\t\tString val = \"bar\";\n\t\tMap<String, String> model = new HashMap<String, String>();\n\t\tmodel.put(key, val);\n\t\tString expectedUrlForEncoding = \"http://url.somewhere.com/test.htm\" + \"?\" + key + \"=\" + val + \"#myAnchor\";\n\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void doTest(Map map, String url, boolean contextRelative, String expectedUrlForEncoding)\n\t\t\tthrows Exception {\n\t\tdoTest(map, url, contextRelative, true, expectedUrlForEncoding);\n\t}","id":25663,"modified_method":"private void doTest(Map<String, ?> map, String url, boolean contextRelative, String expectedUrlForEncoding)\n\t\t\tthrows Exception {\n\t\tdoTest(map, url, contextRelative, true, expectedUrlForEncoding);\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void explicitStatusCode() throws Exception {\n\t\tRedirectView rv = new RedirectView();\n\t\trv.setUrl(\"http://url.somewhere.com\");\n\t\trv.setHttp10Compatible(false);\n\t\trv.setStatusCode(HttpStatus.CREATED);\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\trv.render(new HashMap(), request, response);\n\t\tassertEquals(201, response.getStatus());\n\t\tassertEquals(\"http://url.somewhere.com\", response.getHeader(\"Location\"));\n\t}","id":25664,"modified_method":"@Test\n\tpublic void explicitStatusCode() throws Exception {\n\t\tRedirectView rv = new RedirectView();\n\t\trv.setUrl(\"http://url.somewhere.com\");\n\t\trv.setHttp10Compatible(false);\n\t\trv.setStatusCode(HttpStatus.CREATED);\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\trv.render(new HashMap<String, Object>(), request, response);\n\t\tassertEquals(201, response.getStatus());\n\t\tassertEquals(\"http://url.somewhere.com\", response.getHeader(\"Location\"));\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void singleParamWithoutExposingModelAttributes() throws Exception {\n\t\tString url = \"http://url.somewhere.com\";\n\t\tString key = \"foo\";\n\t\tString val = \"bar\";\n\t\tMap model = new HashMap();\n\t\tmodel.put(key, val);\n\t\tString expectedUrlForEncoding = url; // + \"?\" + key + \"=\" + val;\n\t\tdoTest(model, url, false, false, expectedUrlForEncoding);\n\t}","id":25665,"modified_method":"@Test\n\tpublic void singleParamWithoutExposingModelAttributes() throws Exception {\n\t\tString url = \"http://url.somewhere.com\";\n\t\tString key = \"foo\";\n\t\tString val = \"bar\";\n\t\tMap<String, String> model = new HashMap<String, String>();\n\t\tmodel.put(key, val);\n\t\tString expectedUrlForEncoding = url; // + \"?\" + key + \"=\" + val;\n\t\tdoTest(model, url, false, false, expectedUrlForEncoding);\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void arrayParam() throws Exception {\n\t\tString url = \"http://url.somewhere.com\";\n\t\tString key = \"foo\";\n\t\tString[] val = new String[] {\"bar\", \"baz\"};\n\t\tMap model = new HashMap();\n\t\tmodel.put(key, val);\n\t\ttry {\n\t\t\tString expectedUrlForEncoding = \"http://url.somewhere.com?\" + key + \"=\" + val[0] + \"&\" + key + \"=\" + val[1];\n\t\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t\t}\n\t\tcatch (AssertionFailedError err) {\n\t\t\t// OK, so it's the other order... probably on Sun JDK 1.6 or IBM JDK 1.5\n\t\t\tString expectedUrlForEncoding = \"http://url.somewhere.com?\" + key + \"=\" + val[1] + \"&\" + key + \"=\" + val[0];\n\t\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t\t}\n\t}","id":25666,"modified_method":"@Test\n\tpublic void arrayParam() throws Exception {\n\t\tString url = \"http://url.somewhere.com\";\n\t\tString key = \"foo\";\n\t\tString[] val = new String[] {\"bar\", \"baz\"};\n\t\tMap<String, String[]> model = new HashMap<String, String[]>();\n\t\tmodel.put(key, val);\n\t\ttry {\n\t\t\tString expectedUrlForEncoding = \"http://url.somewhere.com?\" + key + \"=\" + val[0] + \"&\" + key + \"=\" + val[1];\n\t\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t\t}\n\t\tcatch (AssertionFailedError err) {\n\t\t\t// OK, so it's the other order... probably on Sun JDK 1.6 or IBM JDK 1.5\n\t\t\tString expectedUrlForEncoding = \"http://url.somewhere.com?\" + key + \"=\" + val[1] + \"&\" + key + \"=\" + val[0];\n\t\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t\t}\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void attributeStatusCode() throws Exception {\n\t\tRedirectView rv = new RedirectView();\n\t\trv.setUrl(\"http://url.somewhere.com\");\n\t\trv.setHttp10Compatible(false);\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, HttpStatus.CREATED);\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\trv.render(new HashMap(), request, response);\n\t\tassertEquals(201, response.getStatus());\n\t\tassertEquals(\"http://url.somewhere.com\", response.getHeader(\"Location\"));\n\t}","id":25667,"modified_method":"@Test\n\tpublic void attributeStatusCode() throws Exception {\n\t\tRedirectView rv = new RedirectView();\n\t\trv.setUrl(\"http://url.somewhere.com\");\n\t\trv.setHttp10Compatible(false);\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, HttpStatus.CREATED);\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\trv.render(new HashMap<String, Object>(), request, response);\n\t\tassertEquals(201, response.getStatus());\n\t\tassertEquals(\"http://url.somewhere.com\", response.getHeader(\"Location\"));\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void emptyMapWithContextRelative() throws Exception {\n\t\tString url = \"/myUrl\";\n\t\tdoTest(new HashMap(), url, true, url);\n\t}","id":25668,"modified_method":"@Test\n\tpublic void emptyMapWithContextRelative() throws Exception {\n\t\tString url = \"/myUrl\";\n\t\tdoTest(new HashMap<String, Object>(), url, true, url);\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void collectionParam() throws Exception {\n\t\tString url = \"http://url.somewhere.com\";\n\t\tString key = \"foo\";\n\t\tList val = new ArrayList();\n\t\tval.add(\"bar\");\n\t\tval.add(\"baz\");\n\t\tMap model = new HashMap();\n\t\tmodel.put(key, val);\n\t\ttry {\n\t\t\tString expectedUrlForEncoding = \"http://url.somewhere.com?\" + key + \"=\" + val.get(0) + \"&\" + key + \"=\" + val.get(1);\n\t\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t\t}\n\t\tcatch (AssertionFailedError err) {\n\t\t\t// OK, so it's the other order... probably on Sun JDK 1.6 or IBM JDK 1.5\n\t\t\tString expectedUrlForEncoding = \"http://url.somewhere.com?\" + key + \"=\" + val.get(1) + \"&\" + key + \"=\" + val.get(0);\n\t\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t\t}\n\t}","id":25669,"modified_method":"@Test\n\tpublic void collectionParam() throws Exception {\n\t\tString url = \"http://url.somewhere.com\";\n\t\tString key = \"foo\";\n\t\tList<String> val = new ArrayList<String>();\n\t\tval.add(\"bar\");\n\t\tval.add(\"baz\");\n\t\tMap<String, List<String>> model = new HashMap<String, List<String>>();\n\t\tmodel.put(key, val);\n\t\ttry {\n\t\t\tString expectedUrlForEncoding = \"http://url.somewhere.com?\" + key + \"=\" + val.get(0) + \"&\" + key + \"=\" + val.get(1);\n\t\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t\t}\n\t\tcatch (AssertionFailedError err) {\n\t\t\t// OK, so it's the other order... probably on Sun JDK 1.6 or IBM JDK 1.5\n\t\t\tString expectedUrlForEncoding = \"http://url.somewhere.com?\" + key + \"=\" + val.get(1) + \"&\" + key + \"=\" + val.get(0);\n\t\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t\t}\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void http11() throws Exception {\n\t\tRedirectView rv = new RedirectView();\n\t\trv.setUrl(\"http://url.somewhere.com\");\n\t\trv.setHttp10Compatible(false);\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\trv.render(new HashMap(), request, response);\n\t\tassertEquals(303, response.getStatus());\n\t\tassertEquals(\"http://url.somewhere.com\", response.getHeader(\"Location\"));\n\t}","id":25670,"modified_method":"@Test\n\tpublic void http11() throws Exception {\n\t\tRedirectView rv = new RedirectView();\n\t\trv.setUrl(\"http://url.somewhere.com\");\n\t\trv.setHttp10Compatible(false);\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\trv.render(new HashMap<String, Object>(), request, response);\n\t\tassertEquals(303, response.getStatus());\n\t\tassertEquals(\"http://url.somewhere.com\", response.getHeader(\"Location\"));\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void singleParam() throws Exception {\n\t\tString url = \"http://url.somewhere.com\";\n\t\tString key = \"foo\";\n\t\tString val = \"bar\";\n\t\tMap model = new HashMap();\n\t\tmodel.put(key, val);\n\t\tString expectedUrlForEncoding = url + \"?\" + key + \"=\" + val;\n\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t}","id":25671,"modified_method":"@Test\n\tpublic void singleParam() throws Exception {\n\t\tString url = \"http://url.somewhere.com\";\n\t\tString key = \"foo\";\n\t\tString val = \"bar\";\n\t\tMap<String, String> model = new HashMap<String, String>();\n\t\tmodel.put(key, val);\n\t\tString expectedUrlForEncoding = url + \"?\" + key + \"=\" + val;\n\t\tdoTest(model, url, false, expectedUrlForEncoding);\n\t}","commit_id":"6e303d25c4e49f05096b8abac64c6bddc127b39c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public static String getContextPath(ServletContext servletContext) {\n\t\treturn getContextPath(servletContext.getContextPath());\n\t}","id":25672,"modified_method":"public static String getContextPath(ServletContext servletContext) {\n\t\tString contextPath;\n\n\t\tif (ServletVersionDetector.is2_5()) {\n\t\t\tcontextPath = servletContext.getContextPath();\n\t\t}\n\t\telse {\n\t\t\tcontextPath = (String)servletContext.getAttribute(WebKeys.CTX_PATH);\n\t\t}\n\n\t\treturn getContextPath(contextPath);\n\t}","commit_id":"6474a3e98b4da0abfe83a2d730b6d7ecb1ca4029","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void service(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows IOException, ServletException {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Process service request\");\n\t\t}\n\n\t\tif (processShutdownRequest(request, response)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Processed shutdown request\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (processMaintenanceRequest(request, response)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Processed maintenance request\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Get company id\");\n\t\t}\n\n\t\tlong companyId = getCompanyId(request);\n\n\t\tif (processCompanyInactiveRequest(request, response, companyId)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Processed company inactive request\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Set portal port\");\n\t\t}\n\n\t\tsetPortalPort(request);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Check variables\");\n\t\t}\n\n\t\tcheckServletContext(request);\n\t\tcheckPortletSessionTracker(request);\n\t\tcheckPortletRequestProcessor(request);\n\t\tcheckTilesDefinitionsFactory();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Encrypt request\");\n\t\t}\n\n\t\trequest = encryptRequest(request, companyId);\n\n\t\tlong userId = getUserId(request);\n\n\t\tString remoteUser = getRemoteUser(request, userId);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Protect request\");\n\t\t}\n\n\t\trequest = protectRequest(request, remoteUser);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Set principal\");\n\t\t}\n\n\t\tString password = getPassword(request);\n\n\t\tsetPrincipal(userId, remoteUser, password);\n\n\t\ttry {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Authenticate user id \" + userId + \" and remote user \" +\n\t\t\t\t\t\tremoteUser);\n\t\t\t}\n\n\t\t\tuserId = loginUser(request, response, userId, remoteUser);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Authenticated user id \" + userId);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Set session thread local\");\n\t\t}\n\n\t\tPortalSessionThreadLocal.setHttpSession(request.getSession());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Process service pre events\");\n\t\t}\n\n\t\tif (processServicePre(request, response, userId)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Processing service pre events has errors\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (hasAbsoluteRedirect(request)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Current URL \" + currentURL + \" has absolute redirect\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hasThemeDisplay(request)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Current URL \" + currentURL +\n\t\t\t\t\t\t\" does not have a theme display\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Call parent service\");\n\t\t\t}\n\n\t\t\tcallParentService(request, response);\n\t\t}\n\t\tfinally {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Process service post events\");\n\t\t\t}\n\n\t\t\tprocessServicePost(request, response);\n\t\t}\n\t}","id":25673,"modified_method":"@Override\n\tpublic void service(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows IOException, ServletException {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Process service request\");\n\t\t}\n\n\t\tif (processShutdownRequest(request, response)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Processed shutdown request\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (processMaintenanceRequest(request, response)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Processed maintenance request\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Get company id\");\n\t\t}\n\n\t\tlong companyId = getCompanyId(request);\n\n\t\tif (processCompanyInactiveRequest(request, response, companyId)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Processed company inactive request\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Set portal port\");\n\t\t}\n\n\t\tsetPortalPort(request);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Check variables\");\n\t\t}\n\n\t\tcheckServletContext(request);\n\t\tcheckContextPath(request);\n\t\tcheckPortletSessionTracker(request);\n\t\tcheckPortletRequestProcessor(request);\n\t\tcheckTilesDefinitionsFactory();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Encrypt request\");\n\t\t}\n\n\t\trequest = encryptRequest(request, companyId);\n\n\t\tlong userId = getUserId(request);\n\n\t\tString remoteUser = getRemoteUser(request, userId);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Protect request\");\n\t\t}\n\n\t\trequest = protectRequest(request, remoteUser);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Set principal\");\n\t\t}\n\n\t\tString password = getPassword(request);\n\n\t\tsetPrincipal(userId, remoteUser, password);\n\n\t\ttry {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Authenticate user id \" + userId + \" and remote user \" +\n\t\t\t\t\t\tremoteUser);\n\t\t\t}\n\n\t\t\tuserId = loginUser(request, response, userId, remoteUser);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Authenticated user id \" + userId);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Set session thread local\");\n\t\t}\n\n\t\tPortalSessionThreadLocal.setHttpSession(request.getSession());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Process service pre events\");\n\t\t}\n\n\t\tif (processServicePre(request, response, userId)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Processing service pre events has errors\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (hasAbsoluteRedirect(request)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Current URL \" + currentURL + \" has absolute redirect\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hasThemeDisplay(request)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Current URL \" + currentURL +\n\t\t\t\t\t\t\" does not have a theme display\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Call parent service\");\n\t\t\t}\n\n\t\t\tcallParentService(request, response);\n\t\t}\n\t\tfinally {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Process service post events\");\n\t\t\t}\n\n\t\t\tprocessServicePost(request, response);\n\t\t}\n\t}","commit_id":"6474a3e98b4da0abfe83a2d730b6d7ecb1ca4029","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static String escapeXml(final String input) {\n        if (input == null) {\n            return null;\n        }\n\n        final StringBuilder b = new StringBuilder(input.length());\n        for(int i = 0;i  < input.length(); i++) {\n            final char c = input.charAt(i);\n            if(c == '&') {\n                b.append(\"&amp;\");\n            } else if(c == '<') {\n                b.append(\"&lt;\");\n            } else if(c == '>') {\n                b.append(\"&gt;\");\n            } else {\n                b.append(c);\n            }\n        }\n        return b.toString();\n    }","id":25674,"modified_method":"/**\n     * Escape the output.\n     * This method does a simple XML escaping for '<', '>' and '&'\n     * and also escapes single and double quotes.\n     * As these characters should never occur in a url this encoding should\n     * be fine.\n     */\n    private static String escape(final String input) {\n        if (input == null) {\n            return null;\n        }\n\n        final StringBuilder b = new StringBuilder(input.length());\n        for(int i = 0;i  < input.length(); i++) {\n            final char c = input.charAt(i);\n            if(c == '&') {\n                b.append(\"&amp;\");\n            } else if (c == '<') {\n                b.append(\"&lt;\");\n            } else if (c == '>') {\n                b.append(\"&gt;\");\n            } else if (c == '\"') {\n                b.append(\"%22\");\n            } else if (c == '\\'') {\n                b.append(\"%27\");\n            } else {\n                b.append(c);\n            }\n        }\n        return b.toString();\n    }","commit_id":"6256d8bcbe9e99855ae2c78b8c8d0e80fa9b10b8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns the form to be sent back to the client for login providing an\n     * optional informational message and the optional target to redirect to\n     * after successfully logging in.\n     *\n     * @param request The request providing parameters indicating the\n     *            informational message and redirection target.\n     * @return The login form to be returned to the client\n     * @throws IOException If the login form cannot be loaded\n     */\n    protected String getForm(final HttpServletRequest request)\n            throws IOException {\n        String form = getRawForm();\n\n        form = form.replace(\"${resource}\", escapeXml(getResource(request)));\n        form = form.replace(\"${j_reason}\", escapeXml(getReason(request)));\n        form = form.replace(\"${requestContextPath}\", escapeXml(getContextPath(request)));\n        form = form.replace(\"${contextPath}\", escapeXml(request.getContextPath()));\n\n        return form;\n    }","id":25675,"modified_method":"/**\n     * Returns the form to be sent back to the client for login providing an\n     * optional informational message and the optional target to redirect to\n     * after successfully logging in.\n     *\n     * @param request The request providing parameters indicating the\n     *            informational message and redirection target.\n     * @return The login form to be returned to the client\n     * @throws IOException If the login form cannot be loaded\n     */\n    protected String getForm(final HttpServletRequest request)\n            throws IOException {\n        String form = getRawForm();\n\n        final String resource = cleanse(request, getResource(request));\n        final String reason = getReason(request);\n        final String resourceContextPath = cleanse(request, getContextPath(request));\n        final String contextPath = request.getContextPath();\n\n        // replace form placeholders with checked and filtered values\n        form = form.replace(\"${resource}\", escape(resource));\n        form = form.replace(\"${j_reason}\", escape(reason));\n        form = form.replace(\"${requestContextPath}\", escape(resourceContextPath));\n        form = form.replace(\"${contextPath}\", escape(contextPath));\n\n        return form;\n    }","commit_id":"6256d8bcbe9e99855ae2c78b8c8d0e80fa9b10b8","url":"https://github.com/apache/sling"},{"original_method":"public TreeElement parseDocCommentText(PsiManager manager, char[] buffer, int startOffset, int endOffset) {\n    Lexer originalLexer = new JavaDocLexer(manager.getEffectiveLanguageLevel().hasEnumKeywordAndAutoboxing()); // we need caching lexer because the lexer has states\n\n    FilterLexer lexer = new FilterLexer(originalLexer, new FilterLexer.SetFilter(TOKEN_FILTER));\n    lexer.start(buffer, startOffset, endOffset);\n    final FileElement dummyRoot = new DummyHolder(manager, null, myContext.getCharTable()).getTreeElement();\n\n    while (true) {\n      IElementType tokenType = lexer.getTokenType();\n      if (tokenType == null) break;\n      if (tokenType == JavaDocTokenType.DOC_TAG_NAME) {\n        CompositeElement tag = parseTag(manager, lexer);\n        TreeUtil.addChildren(dummyRoot, tag);\n      }\n      else {\n        TreeElement element = parseDataItem(manager, lexer, null, false);\n        TreeUtil.addChildren(dummyRoot, element);\n      }\n    }\n\n    ParseUtil.insertMissingTokens(dummyRoot, originalLexer, startOffset, endOffset, -1, new TokenProcessor(this), myContext);\n    return (TreeElement)dummyRoot.getFirstChildNode();\n  }","id":25676,"modified_method":"public TreeElement parseDocCommentText(PsiManager manager, char[] buffer, int startOffset, int endOffset) {\n    Lexer originalLexer = new JavaDocLexer(manager.getEffectiveLanguageLevel().hasEnumKeywordAndAutoboxing()); // we need caching lexer because the lexer has states\n\n    FilterLexer lexer = new FilterLexer(originalLexer, new FilterLexer.SetFilter(TOKEN_FILTER));\n    lexer.start(buffer, startOffset, endOffset);\n    final FileElement dummyRoot = new DummyHolder(manager, null, myContext.getCharTable()).getTreeElement();\n\n    while (true) {\n      IElementType tokenType = lexer.getTokenType();\n      if (tokenType == null) break;\n      if (tokenType == JavaDocTokenType.DOC_TAG_NAME) {\n        CompositeElement tag = parseTag(manager, lexer);\n        TreeUtil.addChildren(dummyRoot, tag);\n      }\n      else {\n        TreeElement element = parseDataItem(manager, lexer, null, false);\n        TreeUtil.addChildren(dummyRoot, element);\n      }\n    }\n\n    ParseUtil.insertMissingTokens(dummyRoot, originalLexer, startOffset, endOffset, -1, new TokenProcessor(this), myContext);\n    return dummyRoot.getFirstChildNode();\n  }","commit_id":"1a69113eb4f9f8b2e11cec7db3e1517fb13b31a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private TreeElement parseDataItem(PsiManager manager, Lexer lexer, String tagName, boolean isInlineItem) {\n    if (lexer.getTokenType() == JavaDocTokenType.DOC_INLINE_TAG_START) {\n      LeafElement justABrace = Factory.createLeafElement(JavaDocTokenType.DOC_COMMENT_DATA,\n                                                         lexer.getBuffer(),\n                                                         lexer.getTokenStart(),\n                                                         lexer.getTokenEnd(), lexer.getState(), myContext.getCharTable());\n      justABrace.setState(lexer.getState());\n      CompositeElement tag = Factory.createCompositeElement(DOC_INLINE_TAG);\n      final LeafElement leafElement = Factory.createLeafElement(JavaDocTokenType.DOC_INLINE_TAG_START, lexer.getBuffer(),\n                                                                lexer.getTokenStart(), lexer.getTokenEnd(), lexer.getState(),\n                                                                myContext.getCharTable());\n      leafElement.setState(lexer.getState());\n      TreeUtil.addChildren(tag, leafElement);\n\n      lexer.advance();\n\n      if (myBraceScope > 0) {\n        myBraceScope++;\n        return justABrace;\n      }\n\n      if (lexer.getTokenType() != JavaDocTokenType.DOC_TAG_NAME &&\n          lexer.getTokenType() != JavaDocTokenType.DOC_COMMENT_BAD_CHARACTER) {\n        return justABrace;\n      }\n\n      myBraceScope++;\n\n      String inlineTagName = \"\";\n\n      while (true) {\n        IElementType tokenType = lexer.getTokenType();\n        if (tokenType == JavaDocTokenType.DOC_TAG_NAME) {\n          inlineTagName = new String(lexer.getBuffer(), lexer.getTokenStart(), lexer.getTokenEnd() - lexer.getTokenStart());\n        }\n\n        if (tokenType == null || tokenType == JavaDocTokenType.DOC_COMMENT_END) break;\n        TreeElement element = parseDataItem(manager, lexer, inlineTagName, true);\n        TreeUtil.addChildren(tag, element);\n        if (tokenType == JavaDocTokenType.DOC_INLINE_TAG_END) {\n          if (myBraceScope > 0) myBraceScope--;\n          if (myBraceScope == 0) break;\n        }\n      }\n      return tag;\n    }\n    else if (TAG_VALUE.contains(lexer.getTokenType())) {\n      if (SEE_TAG.equals(tagName) && !isInlineItem) {\n        return parseSeeTagValue(lexer);\n      }\n      else if (LINK_TAG.equals(tagName) && isInlineItem) {\n        return parseSeeTagValue(lexer);\n      }\n      else if (manager.getEffectiveLanguageLevel().compareTo(LanguageLevel.JDK_1_4) >= 0 &&\n               LINKPLAIN_TAG.equals(tagName) && isInlineItem) {\n        return parseSeeTagValue(lexer);\n      }\n      else if (!isInlineItem && (THROWS_TAG.equals(tagName) || EXCEPTION_TAG.equals(tagName))) {\n        final LeafElement element = parseReferenceOrType(lexer.getBuffer(), lexer.getTokenStart(), lexer.getTokenEnd(), false,\n                                                         lexer.getState());\n        element.setState(lexer.getState());\n        lexer.advance();\n        final CompositeElement tagValue = Factory.createCompositeElement(DOC_TAG_VALUE_TOKEN);\n        TreeUtil.addChildren(tagValue, element);\n        return tagValue;\n      }\n      else if (!isInlineItem && tagName != null && tagName.equals(PARAM_TAG)) {\n        return parseParamTagValue(lexer);\n      }\n      else if (manager.getEffectiveLanguageLevel().compareTo(LanguageLevel.JDK_1_5) >= 0 &&\n               VALUE_TAG.equals(tagName) && isInlineItem) {\n        return parseSeeTagValue(lexer);\n      }\n      else {\n        return parseSimpleTagValue(lexer);\n      }\n    }\n    else {\n      TreeElement token = createTokenElement(lexer);\n      lexer.advance();\n      return token;\n    }\n  }","id":25677,"modified_method":"private TreeElement parseDataItem(PsiManager manager, Lexer lexer, String tagName, boolean isInlineItem) {\n    if (lexer.getTokenType() == JavaDocTokenType.DOC_INLINE_TAG_START) {\n      LeafElement justABrace = Factory.createLeafElement(JavaDocTokenType.DOC_COMMENT_DATA,\n                                                         lexer.getBuffer(),\n                                                         lexer.getTokenStart(),\n                                                         lexer.getTokenEnd(), lexer.getState(), myContext.getCharTable());\n      justABrace.setState(lexer.getState());\n      CompositeElement tag = Factory.createCompositeElement(DOC_INLINE_TAG);\n      final LeafElement leafElement = Factory.createLeafElement(JavaDocTokenType.DOC_INLINE_TAG_START, lexer.getBuffer(),\n                                                                lexer.getTokenStart(), lexer.getTokenEnd(), lexer.getState(),\n                                                                myContext.getCharTable());\n      leafElement.setState(lexer.getState());\n      TreeUtil.addChildren(tag, leafElement);\n\n      lexer.advance();\n\n      if (myBraceScope > 0) {\n        myBraceScope++;\n        return justABrace;\n      }\n\n      if (lexer.getTokenType() != JavaDocTokenType.DOC_TAG_NAME &&\n          lexer.getTokenType() != JavaDocTokenType.DOC_COMMENT_BAD_CHARACTER) {\n        return justABrace;\n      }\n\n      myBraceScope++;\n\n      String inlineTagName = \"\";\n\n      while (true) {\n        IElementType tokenType = lexer.getTokenType();\n        if (tokenType == JavaDocTokenType.DOC_TAG_NAME) {\n          inlineTagName = StringFactory.createStringFromConstantArray(lexer.getBuffer(), lexer.getTokenStart(), lexer.getTokenEnd() - lexer.getTokenStart());\n        }\n\n        if (tokenType == null || tokenType == JavaDocTokenType.DOC_COMMENT_END) break;\n        TreeElement element = parseDataItem(manager, lexer, inlineTagName, true);\n        TreeUtil.addChildren(tag, element);\n        if (tokenType == JavaDocTokenType.DOC_INLINE_TAG_END) {\n          if (myBraceScope > 0) myBraceScope--;\n          if (myBraceScope == 0) break;\n        }\n      }\n      return tag;\n    }\n    else if (TAG_VALUE.contains(lexer.getTokenType())) {\n      if (SEE_TAG.equals(tagName) && !isInlineItem) {\n        return parseSeeTagValue(lexer);\n      }\n      else if (LINK_TAG.equals(tagName) && isInlineItem) {\n        return parseSeeTagValue(lexer);\n      }\n      else if (manager.getEffectiveLanguageLevel().compareTo(LanguageLevel.JDK_1_4) >= 0 &&\n               LINKPLAIN_TAG.equals(tagName) && isInlineItem) {\n        return parseSeeTagValue(lexer);\n      }\n      else if (!isInlineItem && (THROWS_TAG.equals(tagName) || EXCEPTION_TAG.equals(tagName))) {\n        final LeafElement element = parseReferenceOrType(lexer.getBuffer(), lexer.getTokenStart(), lexer.getTokenEnd(), false,\n                                                         lexer.getState());\n        element.setState(lexer.getState());\n        lexer.advance();\n        final CompositeElement tagValue = Factory.createCompositeElement(DOC_TAG_VALUE_TOKEN);\n        TreeUtil.addChildren(tagValue, element);\n        return tagValue;\n      }\n      else if (!isInlineItem && tagName != null && tagName.equals(PARAM_TAG)) {\n        return parseParamTagValue(lexer);\n      }\n      else if (manager.getEffectiveLanguageLevel().compareTo(LanguageLevel.JDK_1_5) >= 0 &&\n               VALUE_TAG.equals(tagName) && isInlineItem) {\n        return parseSeeTagValue(lexer);\n      }\n      else {\n        return parseSimpleTagValue(lexer);\n      }\n    }\n    else {\n      TreeElement token = createTokenElement(lexer);\n      lexer.advance();\n      return token;\n    }\n  }","commit_id":"1a69113eb4f9f8b2e11cec7db3e1517fb13b31a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeElement parseJavaDocReference(char[] myBuffer,\n                                           CharTable charTable,\n                                           Lexer originalLexer,\n                                           int state,\n                                           boolean isType,\n                                           PsiManager manager) {\n    FilterLexer lexer = new FilterLexer(originalLexer, new FilterLexer.SetFilter(ElementType.WHITE_SPACE_OR_COMMENT_BIT_SET));\n    lexer.start(myBuffer, 0, myBuffer.length, state);\n\n    final FileElement dummyRoot = new DummyHolder(manager, null, myContext.getCharTable()).getTreeElement();\n    final CompositeElement element;\n\n    if (isType){\n      element = parseTypeWithEllipsis(lexer, true, false);\n    }\n    else{\n      element = myContext.getStatementParsing().parseJavaCodeReference(lexer, true, true);\n    }\n\n    if (element != null){\n      TreeUtil.addChildren(dummyRoot, element);\n    }\n    while(lexer.getTokenType() != null){\n      TreeUtil.addChildren(dummyRoot, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n      lexer.advance();\n    }\n\n    ParseUtil.insertMissingTokens(dummyRoot, originalLexer, 0, myBuffer.length, state, ParseUtil.WhiteSpaceAndCommentsProcessor.INSTANCE, myContext);\n    return (TreeElement)dummyRoot.getFirstChildNode();\n  }","id":25678,"modified_method":"public TreeElement parseJavaDocReference(char[] myBuffer,\n                                           CharTable charTable,\n                                           Lexer originalLexer,\n                                           int state,\n                                           boolean isType,\n                                           PsiManager manager) {\n    FilterLexer lexer = new FilterLexer(originalLexer, new FilterLexer.SetFilter(ElementType.WHITE_SPACE_OR_COMMENT_BIT_SET));\n    lexer.start(myBuffer, 0, myBuffer.length, state);\n\n    final FileElement dummyRoot = new DummyHolder(manager, null, myContext.getCharTable()).getTreeElement();\n    final CompositeElement element;\n\n    if (isType){\n      element = parseTypeWithEllipsis(lexer, true, false);\n    }\n    else{\n      element = myContext.getStatementParsing().parseJavaCodeReference(lexer, true, true);\n    }\n\n    if (element != null){\n      TreeUtil.addChildren(dummyRoot, element);\n    }\n    while(lexer.getTokenType() != null){\n      TreeUtil.addChildren(dummyRoot, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n      lexer.advance();\n    }\n\n    ParseUtil.insertMissingTokens(dummyRoot, originalLexer, 0, myBuffer.length, state, ParseUtil.WhiteSpaceAndCommentsProcessor.INSTANCE, myContext);\n    return dummyRoot.getFirstChildNode();\n  }","commit_id":"1a69113eb4f9f8b2e11cec7db3e1517fb13b31a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private CompositeElement parseTag(PsiManager manager, Lexer lexer) {\n    if (lexer.getTokenType() != JavaDocTokenType.DOC_TAG_NAME) return null;\n    CompositeElement tag = Factory.createCompositeElement(DOC_TAG);\n    TreeUtil.addChildren(tag, createTokenElement(lexer));\n    String tagName = new String(lexer.getBuffer(), lexer.getTokenStart(), lexer.getTokenEnd() - lexer.getTokenStart());\n    lexer.advance();\n    while (true) {\n      IElementType tokenType = lexer.getTokenType();\n      if (tokenType == null || tokenType == JavaDocTokenType.DOC_TAG_NAME || tokenType == JavaDocTokenType.DOC_COMMENT_END) break;\n      TreeElement element = parseDataItem(manager, lexer, tagName, false);\n      TreeUtil.addChildren(tag, element);\n    }\n    return tag;\n  }","id":25679,"modified_method":"private CompositeElement parseTag(PsiManager manager, Lexer lexer) {\n    if (lexer.getTokenType() != JavaDocTokenType.DOC_TAG_NAME) return null;\n    CompositeElement tag = Factory.createCompositeElement(DOC_TAG);\n    TreeUtil.addChildren(tag, createTokenElement(lexer));\n    String tagName = StringFactory.createStringFromConstantArray(lexer.getBuffer(), lexer.getTokenStart(), lexer.getTokenEnd() - lexer.getTokenStart());\n    lexer.advance();\n    while (true) {\n      IElementType tokenType = lexer.getTokenType();\n      if (tokenType == null || tokenType == JavaDocTokenType.DOC_TAG_NAME || tokenType == JavaDocTokenType.DOC_COMMENT_END) break;\n      TreeElement element = parseDataItem(manager, lexer, tagName, false);\n      TreeUtil.addChildren(tag, element);\n    }\n    return tag;\n  }","commit_id":"1a69113eb4f9f8b2e11cec7db3e1517fb13b31a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeElement process(TreeElement element, boolean addImports, boolean uncompleteCode) {\n    IElementType elementType = element.getElementType();\n    if (elementType == JAVA_CODE_REFERENCE || elementType == REFERENCE_EXPRESSION) {\n      if (elementType == JAVA_CODE_REFERENCE || element.getTreeParent().getElementType() == REFERENCE_EXPRESSION || uncompleteCode) {\n        final PsiJavaCodeReferenceElement ref = (PsiJavaCodeReferenceElement)SourceTreeToPsiMap.treeElementToPsi(element);\n        final PsiReferenceParameterList parameterList = ref.getParameterList();\n        if (parameterList != null) {\n          final PsiTypeElement[] typeParameters = parameterList.getTypeParameterElements();\n          for (PsiTypeElement typeParameter : typeParameters) {\n            process((TreeElement)SourceTreeToPsiMap.psiElementToTree(typeParameter), addImports, uncompleteCode);\n          }\n        }\n\n        boolean rightKind = true;\n        if (elementType == JAVA_CODE_REFERENCE) {\n          int kind = ((PsiJavaCodeReferenceElementImpl)element).getKind();\n          rightKind = kind == PsiJavaCodeReferenceElementImpl.CLASS_NAME_KIND ||\n            kind == PsiJavaCodeReferenceElementImpl.CLASS_OR_PACKAGE_NAME_KIND;\n        }\n\n        if (rightKind) {\n          boolean isInsideDocComment = TreeUtil.findParent(element, JavaDocElementType.DOC_COMMENT) != null;\n          boolean isShort = !((SourceJavaCodeReference)element).isQualified();\n          if (!makeFQ(isInsideDocComment)) {\n            if (isShort) return element; // short name already, no need to change\n          }\n          PsiElement refElement;\n          if (!uncompleteCode) {\n            refElement = ref.resolve();\n          }\n          else {\n            PsiResolveHelper helper = element.getManager().getResolveHelper();\n            refElement = helper.resolveReferencedClass(\n                ((SourceJavaCodeReference)element).getClassNameText(),\n              SourceTreeToPsiMap.treeElementToPsi(element)\n            );\n          }\n          if (refElement instanceof PsiClass) {\n            if (makeFQ(isInsideDocComment)) {\n              String qName = ((PsiClass)refElement).getQualifiedName();\n              if (qName == null) return element;\n              PsiFile file = SourceTreeToPsiMap.treeElementToPsi(element).getContainingFile();\n              if (ImportHelper.isImplicitlyImported(qName, file)) {\n                if (isShort) return element;\n                return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n              }\n              if (file instanceof PsiJavaFile) {\n                String thisPackageName = ((PsiJavaFile)file).getPackageName();\n                if (ImportHelper.hasPackage(qName, thisPackageName)) {\n                  if (!isShort) {\n                    return (TreeElement)makeShortReference(\n                      (CompositeElement)element,\n                      (PsiClass)refElement,\n                      addImports,\n                      uncompleteCode\n                    );\n                  }\n                }\n              }\n              return (TreeElement)replaceReferenceWithFQ(element, (PsiClass)refElement);\n            }\n            else {\n              return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n            }\n          }\n        }\n      }\n    }\n\n    if (element instanceof CompositeElement) {\n      ChameleonTransforming.transformChildren(element);\n      for (TreeElement child = (TreeElement)element.getFirstChildNode(); child != null; child = child.getTreeNext()) {\n        child = process(child, addImports, uncompleteCode);\n      }\n    }\n\n    return element;\n  }","id":25680,"modified_method":"public TreeElement process(TreeElement element, boolean addImports, boolean uncompleteCode) {\n    IElementType elementType = element.getElementType();\n    if (elementType == JAVA_CODE_REFERENCE || elementType == REFERENCE_EXPRESSION) {\n      if (elementType == JAVA_CODE_REFERENCE || element.getTreeParent().getElementType() == REFERENCE_EXPRESSION || uncompleteCode) {\n        final PsiJavaCodeReferenceElement ref = (PsiJavaCodeReferenceElement)SourceTreeToPsiMap.treeElementToPsi(element);\n        final PsiReferenceParameterList parameterList = ref.getParameterList();\n        if (parameterList != null) {\n          final PsiTypeElement[] typeParameters = parameterList.getTypeParameterElements();\n          for (PsiTypeElement typeParameter : typeParameters) {\n            process((TreeElement)SourceTreeToPsiMap.psiElementToTree(typeParameter), addImports, uncompleteCode);\n          }\n        }\n\n        boolean rightKind = true;\n        if (elementType == JAVA_CODE_REFERENCE) {\n          int kind = ((PsiJavaCodeReferenceElementImpl)element).getKind();\n          rightKind = kind == PsiJavaCodeReferenceElementImpl.CLASS_NAME_KIND ||\n            kind == PsiJavaCodeReferenceElementImpl.CLASS_OR_PACKAGE_NAME_KIND;\n        }\n\n        if (rightKind) {\n          boolean isInsideDocComment = TreeUtil.findParent(element, JavaDocElementType.DOC_COMMENT) != null;\n          boolean isShort = !((SourceJavaCodeReference)element).isQualified();\n          if (!makeFQ(isInsideDocComment)) {\n            if (isShort) return element; // short name already, no need to change\n          }\n          PsiElement refElement;\n          if (!uncompleteCode) {\n            refElement = ref.resolve();\n          }\n          else {\n            PsiResolveHelper helper = element.getManager().getResolveHelper();\n            refElement = helper.resolveReferencedClass(\n                ((SourceJavaCodeReference)element).getClassNameText(),\n              SourceTreeToPsiMap.treeElementToPsi(element)\n            );\n          }\n          if (refElement instanceof PsiClass) {\n            if (makeFQ(isInsideDocComment)) {\n              String qName = ((PsiClass)refElement).getQualifiedName();\n              if (qName == null) return element;\n              PsiFile file = SourceTreeToPsiMap.treeElementToPsi(element).getContainingFile();\n              if (ImportHelper.isImplicitlyImported(qName, file)) {\n                if (isShort) return element;\n                return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n              }\n              if (file instanceof PsiJavaFile) {\n                String thisPackageName = ((PsiJavaFile)file).getPackageName();\n                if (ImportHelper.hasPackage(qName, thisPackageName)) {\n                  if (!isShort) {\n                    return (TreeElement)makeShortReference(\n                      (CompositeElement)element,\n                      (PsiClass)refElement,\n                      addImports,\n                      uncompleteCode\n                    );\n                  }\n                }\n              }\n              return (TreeElement)replaceReferenceWithFQ(element, (PsiClass)refElement);\n            }\n            else {\n              return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n            }\n          }\n        }\n      }\n    }\n\n    if (element instanceof CompositeElement) {\n      ChameleonTransforming.transformChildren(element);\n      for (TreeElement child = element.getFirstChildNode(); child != null; child = child.getTreeNext()) {\n        child = process(child, addImports, uncompleteCode);\n      }\n    }\n\n    return element;\n  }","commit_id":"fa99003f6848115daa6a9dda1e5b2b8edda970dd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addReferencesInRange(ArrayList<ASTNode> array, TreeElement parent, int startOffset, int endOffset) {\n    if (parent.getElementType() == ElementType.JAVA_CODE_REFERENCE || parent.getElementType() == ElementType.REFERENCE_EXPRESSION) {\n      array.add(parent);\n      return;\n    }\n    if (parent instanceof CompositeElement) {\n      ChameleonTransforming.transformChildren(parent);\n      int offset = 0;\n      for (TreeElement child = (TreeElement)parent.getFirstChildNode(); child != null; child = child.getTreeNext()) {\n        int length = child.getTextLength();\n        if (startOffset <= offset + length && offset <= endOffset) {\n          if (startOffset <= offset && offset + length <= endOffset) {\n            array.add(child);\n          }\n          addReferencesInRange(array, child, startOffset - offset, endOffset - offset);\n        }\n        offset += length;\n      }\n    }\n  }","id":25681,"modified_method":"private static void addReferencesInRange(ArrayList<ASTNode> array, TreeElement parent, int startOffset, int endOffset) {\n    if (parent.getElementType() == ElementType.JAVA_CODE_REFERENCE || parent.getElementType() == ElementType.REFERENCE_EXPRESSION) {\n      array.add(parent);\n      return;\n    }\n    if (parent instanceof CompositeElement) {\n      ChameleonTransforming.transformChildren(parent);\n      int offset = 0;\n      for (TreeElement child = parent.getFirstChildNode(); child != null; child = child.getTreeNext()) {\n        int length = child.getTextLength();\n        if (startOffset <= offset + length && offset <= endOffset) {\n          if (startOffset <= offset && offset + length <= endOffset) {\n            array.add(child);\n          }\n          addReferencesInRange(array, child, startOffset - offset, endOffset - offset);\n        }\n        offset += length;\n      }\n    }\n  }","commit_id":"fa99003f6848115daa6a9dda1e5b2b8edda970dd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeElement process(Lexer lexer, ParsingContext context) {\n      TreeElement first = null;\n      TreeElement last = null;\n      while (isTokenValid(lexer.getTokenType())) {\n        TreeElement tokenElement = ParseUtil.createTokenElement(lexer, context.getCharTable());\n        IElementType type = lexer.getTokenType();\n        if (!WHITE_SPACE_OR_COMMENT_BIT_SET.isInSet(type)) {\n          LOG.error(\"Missed token should be white space or comment:\" + tokenElement);\n          throw new RuntimeException();\n        }\n        if (last != null) {\n          last.setTreeNext(tokenElement);\n          tokenElement.setTreePrev(last);\n          last = tokenElement;\n        }\n        else {\n          first = last = tokenElement;\n        }\n        lexer.advance();\n      }\n      return first;\n    }","id":25682,"modified_method":"public TreeElement process(Lexer lexer, ParsingContext context) {\n      TreeElement first = null;\n      TreeElement last = null;\n      while (isTokenValid(lexer.getTokenType())) {\n        TreeElement tokenElement = ParseUtil.createTokenElement(lexer, context.getCharTable());\n        IElementType type = lexer.getTokenType();\n        if (!WHITE_SPACE_OR_COMMENT_BIT_SET.contains(type)) {\n          LOG.error(\"Missed token should be white space or comment:\" + tokenElement);\n          throw new RuntimeException();\n        }\n        if (last != null) {\n          last.setTreeNext(tokenElement);\n          tokenElement.setTreePrev(last);\n          last = tokenElement;\n        }\n        else {\n          first = last = tokenElement;\n        }\n        lexer.advance();\n      }\n      return first;\n    }","commit_id":"a1bc5bbba4921d7a0be469ee59f779a0cf6b8415","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean bindPrecedingComment(TreeElement comment) {\n    ASTNode element = TreeUtil.skipElements(comment, PRECEDING_COMMENT_OR_SPACE_BIT_SET);\n    if (element == null) return false;\n\n    if (element.getElementType() == IMPORT_LIST && element.getTextLength() == 0) {\n      element = element.getTreeNext();\n    }\n\n    if (element != null && BIND_PRECEDING_COMMENT_BIT_SET.isInSet(element.getElementType())) {\n      for (ASTNode child = comment; child != element; child = child.getTreeNext()) {\n        if (child.getElementType() == WHITE_SPACE) {\n          int count = StringUtil.getLineBreakCount(child.getText());\n          if (count > 1) return false;\n        }\n        else {\n          if (comment.getTreePrev() != null && comment.getTreePrev().getElementType() == ElementType.WHITE_SPACE) {\n            LeafElement prev = (LeafElement)comment.getTreePrev();\n            char lastC = prev.charAt(prev.getTextLength() - 1);\n            if (lastC == '\\n' || lastC == '\\r') return false;\n          }\n          else {\n            return false;\n          }\n        }\n      }\n\n      // check if the comment is on separate line\n      if (comment.getTreePrev() != null) {\n        ASTNode prev = comment.getTreePrev();\n        if (prev.getElementType() != ElementType.WHITE_SPACE) {\n          return false;\n        }\n        else {\n          if (!prev.textContains('\\n')) return false;\n        }\n      }\n\n      TreeElement first = (TreeElement)element.getFirstChildNode();\n      TreeElement child = comment;\n      while (child != element) {\n        TreeElement next = child.getTreeNext();\n        if (child.getElementType() != IMPORT_LIST) {\n          TreeUtil.remove(child);\n          TreeUtil.insertBefore(first, child);\n        }\n        child = next;\n      }\n      return true;\n    }\n    return false;\n  }","id":25683,"modified_method":"private static boolean bindPrecedingComment(TreeElement comment) {\n    ASTNode element = TreeUtil.skipElements(comment, PRECEDING_COMMENT_OR_SPACE_BIT_SET);\n    if (element == null) return false;\n\n    if (element.getElementType() == IMPORT_LIST && element.getTextLength() == 0) {\n      element = element.getTreeNext();\n    }\n\n    if (element != null && BIND_PRECEDING_COMMENT_BIT_SET.contains(element.getElementType())) {\n      for (ASTNode child = comment; child != element; child = child.getTreeNext()) {\n        if (child.getElementType() == WHITE_SPACE) {\n          int count = StringUtil.getLineBreakCount(child.getText());\n          if (count > 1) return false;\n        }\n        else {\n          if (comment.getTreePrev() != null && comment.getTreePrev().getElementType() == ElementType.WHITE_SPACE) {\n            LeafElement prev = (LeafElement)comment.getTreePrev();\n            char lastC = prev.charAt(prev.getTextLength() - 1);\n            if (lastC == '\\n' || lastC == '\\r') return false;\n          }\n          else {\n            return false;\n          }\n        }\n      }\n\n      // check if the comment is on separate line\n      if (comment.getTreePrev() != null) {\n        ASTNode prev = comment.getTreePrev();\n        if (prev.getElementType() != ElementType.WHITE_SPACE) {\n          return false;\n        }\n        else {\n          if (!prev.textContains('\\n')) return false;\n        }\n      }\n\n      TreeElement first = (TreeElement)element.getFirstChildNode();\n      TreeElement child = comment;\n      while (child != element) {\n        TreeElement next = child.getTreeNext();\n        if (child.getElementType() != IMPORT_LIST) {\n          TreeUtil.remove(child);\n          TreeUtil.insertBefore(first, child);\n        }\n        child = next;\n      }\n      return true;\n    }\n    return false;\n  }","commit_id":"a1bc5bbba4921d7a0be469ee59f779a0cf6b8415","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean bindTrailingComment(TreeElement comment) {\n    TreeElement element = comment.getTreePrev();\n    if (element == null) return false;\n    TreeElement space = null;\n    if (element.getElementType() == WHITE_SPACE) {\n      space = element;\n      element = element.getTreePrev();\n    }\n    if (element != null && BIND_TRAILING_COMMENT_BIT_SET.isInSet(element.getElementType())) {\n      if (space == null || (!space.textContains('\\n') && !space.textContains('\\r'))) {\n        if (!comment.textContains('\\n') && !comment.textContains('\\r')) {\n          if (space != null) {\n            TreeUtil.remove(space);\n            TreeUtil.addChildren((CompositeElement)element, space);\n          }\n          TreeUtil.remove(comment);\n          TreeUtil.addChildren((CompositeElement)element, comment);\n          return true;\n        }\n      }\n    }\n    return false;\n  }","id":25684,"modified_method":"private static boolean bindTrailingComment(TreeElement comment) {\n    TreeElement element = comment.getTreePrev();\n    if (element == null) return false;\n    TreeElement space = null;\n    if (element.getElementType() == WHITE_SPACE) {\n      space = element;\n      element = element.getTreePrev();\n    }\n    if (element != null && BIND_TRAILING_COMMENT_BIT_SET.contains(element.getElementType())) {\n      if (space == null || (!space.textContains('\\n') && !space.textContains('\\r'))) {\n        if (!comment.textContains('\\n') && !comment.textContains('\\r')) {\n          if (space != null) {\n            TreeUtil.remove(space);\n            TreeUtil.addChildren((CompositeElement)element, space);\n          }\n          TreeUtil.remove(comment);\n          TreeUtil.addChildren((CompositeElement)element, comment);\n          return true;\n        }\n      }\n    }\n    return false;\n  }","commit_id":"a1bc5bbba4921d7a0be469ee59f779a0cf6b8415","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void insertMissingTokens(CompositeElement root,\n                                         Lexer lexer,\n                                         int startOffset,\n                                         int endOffset, int state,\n                                         TokenProcessor processor, ParsingContext context) {\n    if (state < 0) {\n      lexer.start(lexer.getBuffer(), startOffset, endOffset);\n    }\n    else {\n      lexer.start(lexer.getBuffer(), startOffset, endOffset, state);\n    }\n\n    boolean gt = lexer instanceof JavaLexer || lexer instanceof JavaWithJspTemplateDataLexer;\n    LeafElement leaf = TreeUtil.findFirstLeaf(root);\n    if (leaf == null) {\n      final TreeElement firstMissing = processor.process(lexer, context);\n      if (firstMissing != null) {\n        TreeUtil.addChildren(root, firstMissing);\n      }\n      return;\n    }\n    {\n      // Missing in the begining\n      final IElementType tokenType = gt ? GTTokens.getTokenType(lexer) : lexer.getTokenType();\n      if (tokenType != leaf.getElementType() && processor.isTokenValid(tokenType)) {\n        final TreeElement firstMissing = processor.process(lexer, context);\n        if (firstMissing != null) {\n          TreeUtil.insertBefore((TreeElement)root.getFirstChildNode(), firstMissing);\n        }\n      }\n      passTokenOrChameleon(leaf, lexer, gt);\n    }\n    // Missing in tree body\n    insertMissingTokensInTreeBody(leaf, gt, lexer, processor, context, null);\n    if(lexer.getTokenType() != null){\n      // whitespaces at the end of the file\n      final TreeElement firstMissing = processor.process(lexer, context);\n      if(firstMissing != null){\n        ASTNode current = root;\n        while(current instanceof CompositeElement){\n          if(current.getUserData(UNCLOSED_ELEMENT_PROPERTY) != null) break;\n          current = current.getLastChildNode();\n        }\n        if(current instanceof CompositeElement){\n          TreeUtil.addChildren((CompositeElement)current, firstMissing);\n        }\n        else{\n          TreeUtil.insertAfter((TreeElement)root.getLastChildNode(), firstMissing);\n        }\n      }\n    }\n    bindComments(root);\n  }","id":25685,"modified_method":"public static void insertMissingTokens(CompositeElement root,\n                                         Lexer lexer,\n                                         int startOffset,\n                                         int endOffset, int state,\n                                         TokenProcessor processor, ParsingContext context) {\n    if (state < 0) {\n      lexer.start(lexer.getBuffer(), startOffset, endOffset);\n    }\n    else {\n      lexer.start(lexer.getBuffer(), startOffset, endOffset, state);\n    }\n\n    boolean gt = lexer instanceof JavaLexer || lexer instanceof JavaWithJspTemplateDataLexer;\n    LeafElement leaf = TreeUtil.findFirstLeaf(root);\n    if (leaf == null) {\n      final TreeElement firstMissing = processor.process(lexer, context);\n      if (firstMissing != null) {\n        TreeUtil.addChildren(root, firstMissing);\n      }\n      return;\n    }\n    {\n      // Missing in the begining\n      final IElementType tokenType = gt ? GTTokens.getTokenType(lexer) : lexer.getTokenType();\n      if (tokenType != leaf.getElementType() && processor.isTokenValid(tokenType)) {\n        final TreeElement firstMissing = processor.process(lexer, context);\n        if (firstMissing != null) {\n          TreeUtil.insertBefore(root.getFirstChildNode(), firstMissing);\n        }\n      }\n      passTokenOrChameleon(leaf, lexer, gt);\n    }\n    // Missing in tree body\n    insertMissingTokensInTreeBody(leaf, gt, lexer, processor, context, null);\n    if(lexer.getTokenType() != null){\n      // whitespaces at the end of the file\n      final TreeElement firstMissing = processor.process(lexer, context);\n      if(firstMissing != null){\n        ASTNode current = root;\n        while(current instanceof CompositeElement){\n          if(current.getUserData(UNCLOSED_ELEMENT_PROPERTY) != null) break;\n          current = current.getLastChildNode();\n        }\n        if(current instanceof CompositeElement){\n          TreeUtil.addChildren((CompositeElement)current, firstMissing);\n        }\n        else{\n          TreeUtil.insertAfter(root.getLastChildNode(), firstMissing);\n        }\n      }\n    }\n    bindComments(root);\n  }","commit_id":"a1bc5bbba4921d7a0be469ee59f779a0cf6b8415","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isTokenValid(IElementType tokenType) {\n      return tokenType != null && WHITE_SPACE_OR_COMMENT_BIT_SET.isInSet(tokenType);\n    }","id":25686,"modified_method":"public boolean isTokenValid(IElementType tokenType) {\n      return tokenType != null && WHITE_SPACE_OR_COMMENT_BIT_SET.contains(tokenType);\n    }","commit_id":"a1bc5bbba4921d7a0be469ee59f779a0cf6b8415","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean bindDocComment(TreeElement docComment) {\n    TreeElement element = docComment.getTreeNext();\n    if (element == null) return false;\n    TreeElement startSpaces = null;\n    TreeElement lastSpace = null;\n\n    TreeElement importList = null;\n    // Bypass meaningless tokens and hold'em in hands\n    while (element.getElementType() == WHITE_SPACE ||\n           element.getElementType() == C_STYLE_COMMENT ||\n           element.getElementType() == END_OF_LINE_COMMENT ||\n           (element.getElementType() == IMPORT_LIST && element.getTextLength() == 0)\n      ) {\n      if (element.getElementType() == IMPORT_LIST) importList = element;\n      if (startSpaces == null) startSpaces = element;\n      lastSpace = element;\n      element = element.getTreeNext();\n      if (element == null) return false;\n    }\n\n    if (element.getElementType() == CLASS || element.getElementType() == FIELD || element.getElementType() == METHOD ||\n        element.getElementType() == ENUM_CONSTANT) {\n      TreeElement first = (TreeElement)element.getFirstChildNode();\n      if (startSpaces != null) {\n        TreeUtil.removeRange(docComment, element);\n      } else {\n        TreeUtil.remove(docComment);\n      }\n\n      TreeUtil.insertBefore(first, docComment);\n\n      if (importList != null) {\n        TreeUtil.remove(importList);\n        TreeUtil.insertBefore(element, importList);\n      }\n\n      return true;\n    }\n    return false;\n  }","id":25687,"modified_method":"private static boolean bindDocComment(TreeElement docComment) {\n    TreeElement element = docComment.getTreeNext();\n    if (element == null) return false;\n    TreeElement startSpaces = null;\n\n      TreeElement importList = null;\n    // Bypass meaningless tokens and hold'em in hands\n    while (element.getElementType() == WHITE_SPACE ||\n           element.getElementType() == C_STYLE_COMMENT ||\n           element.getElementType() == END_OF_LINE_COMMENT ||\n           (element.getElementType() == IMPORT_LIST && element.getTextLength() == 0)\n      ) {\n      if (element.getElementType() == IMPORT_LIST) importList = element;\n      if (startSpaces == null) startSpaces = element;\n        element = element.getTreeNext();\n      if (element == null) return false;\n    }\n\n    if (element.getElementType() == CLASS || element.getElementType() == FIELD || element.getElementType() == METHOD ||\n        element.getElementType() == ENUM_CONSTANT) {\n      TreeElement first = element.getFirstChildNode();\n      if (startSpaces != null) {\n        TreeUtil.removeRange(docComment, element);\n      } else {\n        TreeUtil.remove(docComment);\n      }\n\n      TreeUtil.insertBefore(first, docComment);\n\n      if (importList != null) {\n        TreeUtil.remove(importList);\n        TreeUtil.insertBefore(element, importList);\n      }\n\n      return true;\n    }\n    return false;\n  }","commit_id":"a1bc5bbba4921d7a0be469ee59f779a0cf6b8415","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static TreeElement findFirstLeaf(TreeElement element, IElementType searchedType, CommonParentState commonParent) {\n    if(commonParent != null){\n      initStrongWhitespaceHolder(commonParent, element, false);\n    }\n    if (element instanceof LeafElement || element.getElementType() == searchedType){\n      return element;\n    }\n    else{\n      for(TreeElement child = (TreeElement)element.getFirstChildNode(); child != null; child = child.getTreeNext()){\n        TreeElement leaf = findFirstLeaf(child, searchedType, commonParent);\n        if (leaf != null) return leaf;\n      }\n      return null;\n    }\n  }","id":25688,"modified_method":"private static TreeElement findFirstLeaf(TreeElement element, IElementType searchedType, CommonParentState commonParent) {\n    if(commonParent != null){\n      initStrongWhitespaceHolder(commonParent, element, false);\n    }\n    if (element instanceof LeafElement || element.getElementType() == searchedType){\n      return element;\n    }\n    else{\n      for(TreeElement child = element.getFirstChildNode(); child != null; child = child.getTreeNext()){\n        TreeElement leaf = findFirstLeaf(child, searchedType, commonParent);\n        if (leaf != null) return leaf;\n      }\n      return null;\n    }\n  }","commit_id":"a1bc5bbba4921d7a0be469ee59f779a0cf6b8415","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void insertMissingTokensInTreeBody(TreeElement leaf,\n                                                   boolean gt,\n                                                   Lexer lexer,\n                                                   TokenProcessor processor,\n                                                   ParsingContext context,\n                                                   ASTNode endToken) {\n    final CommonParentState commonParents = new CommonParentState();\n    while(leaf != null){\n      commonParents.strongWhiteSpaceHolder = null;\n      final IElementType tokenType = gt ? GTTokens.getTokenType(lexer) : lexer.getTokenType();\n      final TreeElement next;\n      if (tokenType instanceof IChameleonElementType) {\n        next = nextLeaf(leaf, commonParents, tokenType);\n      }\n      else {\n        next = nextLeaf(leaf, commonParents, null);\n      }\n\n      if (next == null || tokenType == null || next == endToken) break;\n      if (tokenType != next.getElementType() && processor.isTokenValid(tokenType)) {\n        final TreeElement firstMissing = processor.process(lexer, context);\n        final CompositeElement unclosedElement = commonParents.strongWhiteSpaceHolder;\n        if (unclosedElement != null) {\n          if(commonParents.isStrongElementOnRisingSlope || unclosedElement.getFirstChildNode() == null) {\n            TreeUtil.addChildren(unclosedElement, firstMissing);\n          }\n          else {\n            TreeUtil.insertBefore((TreeElement)unclosedElement.getFirstChildNode(), firstMissing);\n          }\n        }\n        else {\n          final ASTNode insertBefore = commonParents.nextLeafBranchStart;\n          TreeElement insertAfter = commonParents.startLeafBranchStart;\n          TreeElement current = commonParents.startLeafBranchStart;\n          while (current != insertBefore) {\n            final TreeElement treeNext = current.getTreeNext();\n            if (treeNext == insertBefore) {\n              insertAfter = current;\n              break;\n            }\n            if (treeNext instanceof ModifierListElement) {\n              insertAfter = current;\n              break;\n            }\n            if (treeNext.getUserData(UNCLOSED_ELEMENT_PROPERTY) != null) {\n              insertAfter = null;\n              TreeUtil.addChildren((CompositeElement)treeNext, firstMissing);\n              break;\n            }\n            current = treeNext;\n          }\n          if (insertAfter != null) TreeUtil.insertAfter(insertAfter, firstMissing);\n        }\n      }\n      passTokenOrChameleon(next, lexer, gt);\n      leaf = next;\n    }\n  }","id":25689,"modified_method":"public static void insertMissingTokensInTreeBody(TreeElement leaf,\n                                                   boolean gt,\n                                                   Lexer lexer,\n                                                   TokenProcessor processor,\n                                                   ParsingContext context,\n                                                   ASTNode endToken) {\n    final CommonParentState commonParents = new CommonParentState();\n    while(leaf != null){\n      commonParents.strongWhiteSpaceHolder = null;\n      final IElementType tokenType = gt ? GTTokens.getTokenType(lexer) : lexer.getTokenType();\n      final TreeElement next;\n      if (tokenType instanceof IChameleonElementType) {\n        next = nextLeaf(leaf, commonParents, tokenType);\n      }\n      else {\n        next = nextLeaf(leaf, commonParents, null);\n      }\n\n      if (next == null || tokenType == null || next == endToken) break;\n      if (tokenType != next.getElementType() && processor.isTokenValid(tokenType)) {\n        final TreeElement firstMissing = processor.process(lexer, context);\n        final CompositeElement unclosedElement = commonParents.strongWhiteSpaceHolder;\n        if (unclosedElement != null) {\n          if(commonParents.isStrongElementOnRisingSlope || unclosedElement.getFirstChildNode() == null) {\n            TreeUtil.addChildren(unclosedElement, firstMissing);\n          }\n          else {\n            TreeUtil.insertBefore(unclosedElement.getFirstChildNode(), firstMissing);\n          }\n        }\n        else {\n          final ASTNode insertBefore = commonParents.nextLeafBranchStart;\n          TreeElement insertAfter = commonParents.startLeafBranchStart;\n          TreeElement current = commonParents.startLeafBranchStart;\n          while (current != insertBefore) {\n            final TreeElement treeNext = current.getTreeNext();\n            if (treeNext == insertBefore) {\n              insertAfter = current;\n              break;\n            }\n            if (treeNext instanceof ModifierListElement) {\n              insertAfter = current;\n              break;\n            }\n            if (treeNext.getUserData(UNCLOSED_ELEMENT_PROPERTY) != null) {\n              insertAfter = null;\n              TreeUtil.addChildren((CompositeElement)treeNext, firstMissing);\n              break;\n            }\n            current = treeNext;\n          }\n          if (insertAfter != null) TreeUtil.insertAfter(insertAfter, firstMissing);\n        }\n      }\n      passTokenOrChameleon(next, lexer, gt);\n      leaf = next;\n    }\n  }","commit_id":"a1bc5bbba4921d7a0be469ee59f779a0cf6b8415","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeElement parseStatements(PsiManager manager,\n                                     Lexer lexer,\n                                     char[] buffer,\n                                     int startOffset,\n                                     int endOffset,\n                                     int state) {\n    if (lexer == null){\n      lexer = new JavaLexer(myContext.getLanguageLevel());\n    }\n    final FilterLexer filterLexer = new FilterLexer(lexer, new FilterLexer.SetFilter(WHITE_SPACE_OR_COMMENT_BIT_SET));\n    if (state < 0) filterLexer.start(buffer, startOffset, endOffset);\n    else filterLexer.start(buffer, startOffset, endOffset, state);\n\n    final FileElement dummyRoot = new DummyHolder(manager, null, myContext.getCharTable()).getTreeElement();\n    parseStatements(dummyRoot, filterLexer, RBRACE_IS_ERROR);\n\n    ParseUtil.insertMissingTokens(dummyRoot,\n                                  lexer,\n                                  startOffset,\n                                  endOffset,\n                                  state,\n                                  ParseUtil.WhiteSpaceAndCommentsProcessor.INSTANCE, myContext);\n    return (TreeElement)dummyRoot.getFirstChildNode();\n  }","id":25690,"modified_method":"public TreeElement parseStatements(PsiManager manager,\n                                     Lexer lexer,\n                                     char[] buffer,\n                                     int startOffset,\n                                     int endOffset,\n                                     int state) {\n    if (lexer == null){\n      lexer = new JavaLexer(myContext.getLanguageLevel());\n    }\n    final FilterLexer filterLexer = new FilterLexer(lexer, new FilterLexer.SetFilter(WHITE_SPACE_OR_COMMENT_BIT_SET));\n    if (state < 0) filterLexer.start(buffer, startOffset, endOffset);\n    else filterLexer.start(buffer, startOffset, endOffset, state);\n\n    final FileElement dummyRoot = new DummyHolder(manager, null, myContext.getCharTable()).getTreeElement();\n    parseStatements(dummyRoot, filterLexer, RBRACE_IS_ERROR);\n\n    ParseUtil.insertMissingTokens(dummyRoot,\n                                  lexer,\n                                  startOffset,\n                                  endOffset,\n                                  state,\n                                  ParseUtil.WhiteSpaceAndCommentsProcessor.INSTANCE, myContext);\n    return dummyRoot.getFirstChildNode();\n  }","commit_id":"ac0e52b95a0cce434cf5f10b5f750a53ba752bd6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static LeafElement createSingleLeafElement(IElementType type, CharSequence buffer, int startOffset, int endOffset, CharTable table, PsiManager manager, boolean generatedFlag) {\n    final LeafElement newElement;\n    final FileElement holderElement = DummyHolderFactory.createHolder(manager, table, type.getLanguage()).getTreeElementNoLock();\n    newElement = ASTFactory.leaf(type, buffer, startOffset, endOffset, holderElement.getCharTable());\n    TreeUtil.addChildren(holderElement, newElement);\n    if(generatedFlag) CodeEditUtil.setNodeGenerated(newElement, true);\n    return newElement;\n  }","id":25691,"modified_method":"public static LeafElement createSingleLeafElement(IElementType type, CharSequence buffer, int startOffset, int endOffset, CharTable table, PsiManager manager, boolean generatedFlag) {\n    final FileElement holderElement = DummyHolderFactory.createHolder(manager, table, type.getLanguage()).getTreeElementNoLock();\n    final LeafElement newElement = ASTFactory.leaf(type, buffer, startOffset, endOffset, holderElement.getCharTable());\n    TreeUtil.addChildren(holderElement, newElement);\n    if(generatedFlag) CodeEditUtil.setNodeGenerated(newElement, true);\n    return newElement;\n  }","commit_id":"ae79a18033eb8c0587d29d445c2b8397b8100421","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeElement parseMarkupDecl(Lexer originalLexer, CharSequence text, int start, int end, PsiManager manager) {\n    final Lexer lexer = new FilterLexer(originalLexer, new FilterLexer.SetFilter(XML_WHITE_SPACE_OR_COMMENT_BIT_SET));\n    lexer.start(text, start, end, _OldXmlLexer.DOCTYPE);\n\n    final FileElement dummyRoot = DummyHolderFactory.createHolder(manager, null, myContext.getCharTable()).getTreeElement();\n    parseMarkupContent(lexer, dummyRoot);\n    while (lexer.getTokenType() != null) {\n      final TreeElement children;\n\n      if(lexer.getTokenType() == XML_ENTITY_REF_TOKEN) {\n        children = parseEntityRef(lexer);\n      } else if (lexer.getTokenType() == XML_ENTITY_DECL_START) {\n        children = parseEntityDecl(lexer);\n      } else {\n        children = createTokenElement(lexer, dummyRoot.getCharTable());\n        lexer.advance();\n      }\n\n      TreeUtil.addChildren(dummyRoot, children);\n    }\n    originalLexer.start(text, start, end, _OldXmlLexer.DOCTYPE);\n    insertMissingTokens(dummyRoot, originalLexer, start, end, _OldXmlLexer.DOCTYPE,\n                                  WhiteSpaceAndCommentsProcessor.INSTANCE, myContext);\n    return (TreeElement)dummyRoot.getFirstChildNode();\n  }","id":25692,"modified_method":"public TreeElement parseMarkupDecl(Lexer originalLexer, CharSequence text, int start, int end, PsiManager manager) {\n    final Lexer lexer = new FilterLexer(originalLexer, new FilterLexer.SetFilter(XML_WHITE_SPACE_OR_COMMENT_BIT_SET));\n    lexer.start(text, start, end, _OldXmlLexer.DOCTYPE);\n\n    final FileElement dummyRoot = DummyHolderFactory.createHolder(manager, null, myContext.getCharTable()).getTreeElement();\n    parseMarkupContent(lexer, dummyRoot);\n    while (lexer.getTokenType() != null) {\n      final TreeElement children;\n\n      if(lexer.getTokenType() == XML_ENTITY_REF_TOKEN) {\n        children = parseEntityRef(lexer);\n      } else if (lexer.getTokenType() == XML_ENTITY_DECL_START) {\n        children = parseEntityDecl(lexer);\n      } else {\n        children = createTokenElement(lexer, dummyRoot.getCharTable());\n        lexer.advance();\n      }\n\n      TreeUtil.addChildren(dummyRoot, children);\n    }\n    originalLexer.start(text, start, end, _OldXmlLexer.DOCTYPE);\n    insertMissingTokens(dummyRoot, originalLexer, start, end, _OldXmlLexer.DOCTYPE,\n                                  WhiteSpaceAndCommentsProcessor.INSTANCE, myContext);\n    return dummyRoot.getFirstChildNode();\n  }","commit_id":"ae79a18033eb8c0587d29d445c2b8397b8100421","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean _parseTag(CompositeElement parent, Lexer lexer, Set<String> names) {\n    if (lexer.getTokenType() != XML_START_TAG_START) {\n      return false;\n    }\n\n    CompositeElement tag = ASTFactory.composite(XML_TAG);\n    TreeUtil.addChildren(parent, tag);\n\n    addToken(tag, lexer);\n\n    if (lexer.getTokenType() != XML_TAG_NAME) {\n      return true;\n    }\n\n    final String openedName = lexer.getBufferSequence().subSequence(lexer.getTokenStart(),lexer.getTokenEnd()).toString();\n    addToken(tag, lexer);\n\n    parseAttributeList(tag, lexer);\n\n    while (lexer.getTokenType() == XML_BAD_CHARACTER || lexer.getTokenType() == XML_NAME) {\n      addToken(tag, lexer);\n      parseAttributeList(tag, lexer);\n    }\n    TreeElement tagEnd;\n    if (lexer.getTokenType() == XML_TAG_END) {\n      tagEnd = addToken(tag, lexer);\n      boolean setFlag = false;\n      if (!names.contains(openedName)) {\n        names.add(openedName);\n        setFlag = true;\n      }\n      \n      CompositeElement text = null;\n      while (true) {\n        if (parseProcessingInstruction(tag, lexer)) {\n        }\n        else if (_parseTag(tag, lexer, names)) {\n        }\n        else if (lexer.getTokenType() == XML_DATA_CHARACTERS) {\n          if (text == null) {\n            text = ASTFactory.composite(XML_TEXT);\n            TreeUtil.addChildren(tag, text);\n          }\n          addToken(text, lexer);\n        }\n        else if (lexer.getTokenType() == XML_CDATA_START) {\n          addToken(tag, lexer);\n        }\n        else if (lexer.getTokenType() == XML_CDATA_END) {\n          addToken(tag, lexer);\n        }\n        else if (lexer.getTokenType() == XML_CHAR_ENTITY_REF) {\n          addToken(tag, lexer);\n        }\n        else if (lexer.getTokenType() == XML_ENTITY_REF_TOKEN) {\n          TreeUtil.addChildren(tag, parseEntityRef(lexer));\n        }\n        else {\n          break;\n        }\n      }\n      if (setFlag) {\n        names.remove(openedName);\n      }\n\n      final LexerPosition pos = lexer.getCurrentPosition();\n\n      if (lexer.getTokenType() != XML_END_TAG_START) {\n        TreeUtil.insertAfter(tagEnd, Factory.createErrorElement(XmlErrorMessages.message(\"element.is.not.closed\")));\n\n        return false;\n      }\n      TreeElement endTagStart = createTokenElement(lexer, myContext.getCharTable());\n      lexer.advance();\n\n      if (lexer.getTokenType() != XML_TAG_NAME) {\n        TreeUtil.addChildren(tag, endTagStart);\n        return true;\n      }\n\n      final String closingName = lexer.getBufferSequence().subSequence(lexer.getTokenStart(),\n                                                                         lexer.getTokenEnd()).toString();\n\n      if (!closingName.equals(openedName) && names.contains(closingName)) {\n        lexer.restore(pos);\n        if (tagEnd != null) {\n          final TreeElement start = tagEnd.getTreeNext();\n          tagEnd.setTreeNext(null);\n          if (start != null) {\n            TreeUtil.addChildren(parent, start);\n          }\n        }\n        TreeUtil.insertAfter(tagEnd, Factory.createErrorElement(XmlErrorMessages.message(\"element.is.not.closed\")));\n        return true;\n      }\n\n      TreeUtil.addChildren(tag, endTagStart);\n      addToken(tag, lexer);\n\n      if (lexer.getTokenType() != XML_TAG_END) {\n        return true;\n      }\n\n      addToken(tag, lexer);\n    }\n    else if (lexer.getTokenType() == XML_EMPTY_ELEMENT_END) {\n      addToken(tag, lexer);\n    }\n    else {\n      TreeUtil.insertAfter((TreeElement)tag.getLastChildNode(), Factory.createErrorElement(XmlErrorMessages.message(\"element.is.not.closed\")));\n    }\n\n    return true;\n  }","id":25693,"modified_method":"private boolean _parseTag(CompositeElement parent, Lexer lexer, Set<String> names) {\n    if (lexer.getTokenType() != XML_START_TAG_START) {\n      return false;\n    }\n\n    CompositeElement tag = ASTFactory.composite(XML_TAG);\n    TreeUtil.addChildren(parent, tag);\n\n    addToken(tag, lexer);\n\n    if (lexer.getTokenType() != XML_TAG_NAME) {\n      return true;\n    }\n\n    final String openedName = lexer.getBufferSequence().subSequence(lexer.getTokenStart(),lexer.getTokenEnd()).toString();\n    addToken(tag, lexer);\n\n    parseAttributeList(tag, lexer);\n\n    while (lexer.getTokenType() == XML_BAD_CHARACTER || lexer.getTokenType() == XML_NAME) {\n      addToken(tag, lexer);\n      parseAttributeList(tag, lexer);\n    }\n    TreeElement tagEnd;\n    if (lexer.getTokenType() == XML_TAG_END) {\n      tagEnd = addToken(tag, lexer);\n      boolean setFlag = false;\n      if (!names.contains(openedName)) {\n        names.add(openedName);\n        setFlag = true;\n      }\n      \n      CompositeElement text = null;\n      while (true) {\n        if (parseProcessingInstruction(tag, lexer)) {\n        }\n        else if (_parseTag(tag, lexer, names)) {\n        }\n        else if (lexer.getTokenType() == XML_DATA_CHARACTERS) {\n          if (text == null) {\n            text = ASTFactory.composite(XML_TEXT);\n            TreeUtil.addChildren(tag, text);\n          }\n          addToken(text, lexer);\n        }\n        else if (lexer.getTokenType() == XML_CDATA_START) {\n          addToken(tag, lexer);\n        }\n        else if (lexer.getTokenType() == XML_CDATA_END) {\n          addToken(tag, lexer);\n        }\n        else if (lexer.getTokenType() == XML_CHAR_ENTITY_REF) {\n          addToken(tag, lexer);\n        }\n        else if (lexer.getTokenType() == XML_ENTITY_REF_TOKEN) {\n          TreeUtil.addChildren(tag, parseEntityRef(lexer));\n        }\n        else {\n          break;\n        }\n      }\n      if (setFlag) {\n        names.remove(openedName);\n      }\n\n      final LexerPosition pos = lexer.getCurrentPosition();\n\n      if (lexer.getTokenType() != XML_END_TAG_START) {\n        TreeUtil.insertAfter(tagEnd, Factory.createErrorElement(XmlErrorMessages.message(\"element.is.not.closed\")));\n\n        return false;\n      }\n      TreeElement endTagStart = createTokenElement(lexer, myContext.getCharTable());\n      lexer.advance();\n\n      if (lexer.getTokenType() != XML_TAG_NAME) {\n        TreeUtil.addChildren(tag, endTagStart);\n        return true;\n      }\n\n      final String closingName = lexer.getBufferSequence().subSequence(lexer.getTokenStart(),\n                                                                         lexer.getTokenEnd()).toString();\n\n      if (!closingName.equals(openedName) && names.contains(closingName)) {\n        lexer.restore(pos);\n        if (tagEnd != null) {\n          final TreeElement start = tagEnd.getTreeNext();\n          tagEnd.setTreeNext(null);\n          if (start != null) {\n            TreeUtil.addChildren(parent, start);\n          }\n        }\n        TreeUtil.insertAfter(tagEnd, Factory.createErrorElement(XmlErrorMessages.message(\"element.is.not.closed\")));\n        return true;\n      }\n\n      TreeUtil.addChildren(tag, endTagStart);\n      addToken(tag, lexer);\n\n      if (lexer.getTokenType() != XML_TAG_END) {\n        return true;\n      }\n\n      addToken(tag, lexer);\n    }\n    else if (lexer.getTokenType() == XML_EMPTY_ELEMENT_END) {\n      addToken(tag, lexer);\n    }\n    else {\n      TreeUtil.insertAfter(tag.getLastChildNode(), Factory.createErrorElement(XmlErrorMessages.message(\"element.is.not.closed\")));\n    }\n\n    return true;\n  }","commit_id":"ae79a18033eb8c0587d29d445c2b8397b8100421","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void makeFullParse(ASTNode parent,\n                             char[] newFileText,\n                             int textLength,\n                             final PsiFileImpl fileImpl,\n                             FileType fileType) {\n    if(parent instanceof CodeFragmentElement){\n      final FileElement holderElement = new DummyHolder(fileImpl.getManager(), null).getTreeElement();\n      TreeUtil.addChildren(holderElement, fileImpl.createContentLeafElement(newFileText, 0, textLength, holderElement.getCharTable()));\n      parent.replaceAllChildrenToChildrenOf(holderElement);\n    }\n    else{\n      final PsiManagerImpl manager = (PsiManagerImpl)fileImpl.getManager();\n      final PsiFileImpl newFile = (PsiFileImpl)PsiElementFactoryImpl.createFileFromText(manager, fileType, fileImpl.getName(), newFileText, 0, textLength);\n      newFile.setOriginalFile(fileImpl);\n      final ASTNode newFileElement = newFile.getTreeElement();\n      final RepositoryManager repositoryManager = manager.getRepositoryManager();\n      final FileElement fileElement = (FileElement)fileImpl.getNode();\n      final int oldLength = fileElement.getTextLength();\n      sendPsiBeforeEvent(fileImpl);\n      if(repositoryManager != null) repositoryManager.beforeChildAddedOrRemoved(fileImpl, fileElement);\n      if(fileElement.getFirstChildNode() != null)\n        TreeUtil.removeRange((TreeElement)fileElement.getFirstChildNode(), null);\n      TreeUtil.addChildren((CompositeElement)fileElement, (TreeElement)newFileElement.getFirstChildNode());\n      if(repositoryManager != null) repositoryManager.beforeChildAddedOrRemoved(fileImpl, fileElement);\n      manager.invalidateFile(fileImpl);\n      fileElement.subtreeChanged();\n      sendPsiAfterEvent(fileImpl, oldLength);\n    }\n  }","id":25694,"modified_method":"private void makeFullParse(ASTNode parent,\n                             char[] newFileText,\n                             int textLength,\n                             final PsiFileImpl fileImpl,\n                             FileType fileType) {\n    if(parent instanceof CodeFragmentElement){\n      final FileElement holderElement = new DummyHolder(fileImpl.getManager(), null).getTreeElement();\n      TreeUtil.addChildren(holderElement, fileImpl.createContentLeafElement(newFileText, 0, textLength, holderElement.getCharTable()));\n      parent.replaceAllChildrenToChildrenOf(holderElement);\n    }\n    else{\n      final PsiManagerImpl manager = (PsiManagerImpl)fileImpl.getManager();\n      final PsiFileImpl newFile = (PsiFileImpl)PsiElementFactoryImpl.createFileFromText(manager, fileType, fileImpl.getName(), newFileText, 0, textLength);\n      newFile.setOriginalFile(fileImpl);\n      final ASTNode newFileElement = newFile.getTreeElement();\n      final RepositoryManager repositoryManager = manager.getRepositoryManager();\n      final FileElement fileElement = (FileElement)fileImpl.getNode();\n      final int oldLength = fileElement.getTextLength();\n      sendPsiBeforeEvent(fileImpl);\n      if(repositoryManager != null) repositoryManager.beforeChildAddedOrRemoved(fileImpl, fileElement);\n      if(fileElement.getFirstChildNode() != null)\n        TreeUtil.removeRange((TreeElement)fileElement.getFirstChildNode(), null);\n      final ASTNode firstChildNode = newFileElement.getFirstChildNode();\n      if (firstChildNode != null)\n        TreeUtil.addChildren(fileElement, (TreeElement)firstChildNode);\n\n      if(repositoryManager != null) repositoryManager.beforeChildAddedOrRemoved(fileImpl, fileElement);\n      manager.invalidateFile(fileImpl);\n      fileElement.subtreeChanged();\n      sendPsiAfterEvent(fileImpl, oldLength);\n    }\n  }","commit_id":"65c4954d2297339b33a677e83c755446ea0b0f60","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static TreeElement parseJavaCodeReferenceText(PsiManager manager,\n                                                       char[] buffer,\n                                                       int startOffset,\n                                                       int endOffset,\n                                                       CharTable table,\n                                                       boolean eatAll) {\n    Lexer originalLexer = new JavaLexer(manager.getEffectiveLanguageLevel());\n    FilterLexer lexer = new FilterLexer(originalLexer, new FilterLexer.SetFilter(WHITE_SPACE_OR_COMMENT_BIT_SET));\n    lexer.start(buffer, startOffset, endOffset);\n\n    JavaParsingContext context = new JavaParsingContext(table, manager.getEffectiveLanguageLevel());\n    CompositeElement ref = context.getStatementParsing().parseJavaCodeReference(lexer, false, true);\n    final FileElement dummyRoot = new DummyHolder(manager, null, table).getTreeElement();\n    if (ref == null) {\n      if (!eatAll) return null;\n    } else {\n      TreeUtil.addChildren(dummyRoot, ref);\n    }\n\n    if (lexer.getTokenType() != null) {\n      if (!eatAll) return null;\n      final CompositeElement errorElement = Factory.createErrorElement(JavaErrorMessages.message(\"unexpected.tokens\"));\n      while (lexer.getTokenType() != null) {\n        final TreeElement token = ParseUtil.createTokenElement(lexer, context.getCharTable());\n        TreeUtil.addChildren(errorElement, token);\n        lexer.advance();\n      }\n      TreeUtil.addChildren(dummyRoot, errorElement);\n    }\n\n    ParseUtil.insertMissingTokens(dummyRoot, originalLexer, startOffset, endOffset, -1, ParseUtil.WhiteSpaceAndCommentsProcessor.INSTANCE, context);\n    return (TreeElement)dummyRoot.getFirstChildNode();\n  }","id":25695,"modified_method":"public static TreeElement parseJavaCodeReferenceText(PsiManager manager,\n                                                       char[] buffer,\n                                                       int startOffset,\n                                                       int endOffset,\n                                                       CharTable table,\n                                                       boolean eatAll) {\n    Lexer originalLexer = new JavaLexer(manager.getEffectiveLanguageLevel());\n    FilterLexer lexer = new FilterLexer(originalLexer, new FilterLexer.SetFilter(WHITE_SPACE_OR_COMMENT_BIT_SET));\n    lexer.start(buffer, startOffset, endOffset);\n\n    JavaParsingContext context = new JavaParsingContext(table, manager.getEffectiveLanguageLevel());\n    CompositeElement ref = context.getStatementParsing().parseJavaCodeReference(lexer, false, true);\n    final FileElement dummyRoot = new DummyHolder(manager, null, table).getTreeElement();\n    if (ref == null) {\n      if (!eatAll) return null;\n    } else {\n      TreeUtil.addChildren(dummyRoot, ref);\n    }\n\n    if (lexer.getTokenType() != null) {\n      if (!eatAll) return null;\n      final CompositeElement errorElement = Factory.createErrorElement(JavaErrorMessages.message(\"unexpected.tokens\"));\n      while (lexer.getTokenType() != null) {\n        final TreeElement token = ParseUtil.createTokenElement(lexer, context.getCharTable());\n        TreeUtil.addChildren(errorElement, token);\n        lexer.advance();\n      }\n      TreeUtil.addChildren(dummyRoot, errorElement);\n    }\n\n    ParseUtil.insertMissingTokens(dummyRoot, originalLexer, startOffset, endOffset, -1, ParseUtil.WhiteSpaceAndCommentsProcessor.INSTANCE, context);\n    return dummyRoot.getFirstChildNode();\n  }","commit_id":"00dbe7782171bc3dff128457d2bd4343cf698ea9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static TreeElement parseTypeText(PsiManager manager,\n                                          Lexer lexer,\n                                          char[] buffer,\n                                          int startOffset,\n                                          int endOffset,\n                                          int state,\n                                          CharTable table) {\n    if (lexer == null){\n      lexer = new JavaLexer(manager.getEffectiveLanguageLevel());\n    }\n    FilterLexer filterLexer = new FilterLexer(lexer, new FilterLexer.SetFilter(WHITE_SPACE_OR_COMMENT_BIT_SET));\n    if (state < 0) filterLexer.start(buffer, startOffset, endOffset);\n    else filterLexer.start(buffer, startOffset, endOffset, state);\n    final JavaParsingContext context = new JavaParsingContext(table, manager.getEffectiveLanguageLevel());\n    final FileElement dummyRoot = new DummyHolder(manager, null, context.getCharTable()).getTreeElement();\n    final CompositeElement root = context.getStatementParsing().parseType(filterLexer);\n    if (root != null) {\n      TreeUtil.addChildren(dummyRoot, root);\n    }\n\n    if (filterLexer.getTokenType() == ELLIPSIS) {\n      TreeUtil.addChildren(dummyRoot, ParseUtil.createTokenElement(filterLexer, context.getCharTable()));\n      filterLexer.advance();\n    }\n\n    if (filterLexer.getTokenType() != null) {\n      final CompositeElement errorElement = Factory.createErrorElement(JavaErrorMessages.message(\"unexpected.tokens\"));\n      while (filterLexer.getTokenType() != null) {\n        final TreeElement token = ParseUtil.createTokenElement(lexer, context.getCharTable());\n        TreeUtil.addChildren(errorElement, token);\n        filterLexer.advance();\n      }\n      TreeUtil.addChildren(dummyRoot, errorElement);\n    }\n\n    ParseUtil.insertMissingTokens(\n      dummyRoot,\n      lexer,\n      startOffset,\n      endOffset, state,\n      ParseUtil.WhiteSpaceAndCommentsProcessor.INSTANCE, context);\n    return (TreeElement)dummyRoot.getFirstChildNode();\n }","id":25696,"modified_method":"public static TreeElement parseTypeText(PsiManager manager,\n                                          Lexer lexer,\n                                          char[] buffer,\n                                          int startOffset,\n                                          int endOffset,\n                                          int state,\n                                          CharTable table) {\n    if (lexer == null){\n      lexer = new JavaLexer(manager.getEffectiveLanguageLevel());\n    }\n    FilterLexer filterLexer = new FilterLexer(lexer, new FilterLexer.SetFilter(WHITE_SPACE_OR_COMMENT_BIT_SET));\n    if (state < 0) filterLexer.start(buffer, startOffset, endOffset);\n    else filterLexer.start(buffer, startOffset, endOffset, state);\n    final JavaParsingContext context = new JavaParsingContext(table, manager.getEffectiveLanguageLevel());\n    final FileElement dummyRoot = new DummyHolder(manager, null, context.getCharTable()).getTreeElement();\n    final CompositeElement root = context.getStatementParsing().parseType(filterLexer);\n    if (root != null) {\n      TreeUtil.addChildren(dummyRoot, root);\n    }\n\n    if (filterLexer.getTokenType() == ELLIPSIS) {\n      TreeUtil.addChildren(dummyRoot, ParseUtil.createTokenElement(filterLexer, context.getCharTable()));\n      filterLexer.advance();\n    }\n\n    if (filterLexer.getTokenType() != null) {\n      final CompositeElement errorElement = Factory.createErrorElement(JavaErrorMessages.message(\"unexpected.tokens\"));\n      while (filterLexer.getTokenType() != null) {\n        final TreeElement token = ParseUtil.createTokenElement(lexer, context.getCharTable());\n        TreeUtil.addChildren(errorElement, token);\n        filterLexer.advance();\n      }\n      TreeUtil.addChildren(dummyRoot, errorElement);\n    }\n\n    ParseUtil.insertMissingTokens(\n      dummyRoot,\n      lexer,\n      startOffset,\n      endOffset, state,\n      ParseUtil.WhiteSpaceAndCommentsProcessor.INSTANCE, context);\n    return dummyRoot.getFirstChildNode();\n }","commit_id":"00dbe7782171bc3dff128457d2bd4343cf698ea9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void makeFullParse(ASTNode parent,\n                             char[] newFileText,\n                             int textLength,\n                             final PsiFileImpl fileImpl,\n                             FileType fileType) {\n    if(parent instanceof CodeFragmentElement){\n      final FileElement holderElement = new DummyHolder(fileImpl.getManager(), null).getTreeElement();\n      TreeUtil.addChildren(holderElement, fileImpl.createContentLeafElement(newFileText, 0, textLength, holderElement.getCharTable()));\n      parent.replaceAllChildrenToChildrenOf(holderElement);\n    }\n    else{\n      final PsiManagerImpl manager = (PsiManagerImpl)fileImpl.getManager();\n      final PsiFileImpl newFile = (PsiFileImpl)PsiElementFactoryImpl.createFileFromText(manager, fileType, fileImpl.getName(), newFileText, 0, textLength);\n      newFile.setOriginalFile(fileImpl);\n      final ASTNode newFileElement = newFile.getTreeElement();\n      final RepositoryManager repositoryManager = manager.getRepositoryManager();\n      final FileElement fileElement = (FileElement)fileImpl.getNode();\n      final int oldLength = fileElement.getTextLength();\n      sendPsiBeforeEvent(fileImpl);\n      if(repositoryManager != null) repositoryManager.beforeChildAddedOrRemoved(fileImpl, fileElement);\n      if(fileElement.getFirstChildNode() != null)\n        TreeUtil.removeRange((TreeElement)fileElement.getFirstChildNode(), null);\n      final ASTNode firstChildNode = newFileElement.getFirstChildNode();\n      if (firstChildNode != null)\n        TreeUtil.addChildren(fileElement, (TreeElement)firstChildNode);\n\n      if(repositoryManager != null) repositoryManager.beforeChildAddedOrRemoved(fileImpl, fileElement);\n      manager.invalidateFile(fileImpl);\n      fileElement.subtreeChanged();\n      sendPsiAfterEvent(fileImpl, oldLength);\n    }\n  }","id":25697,"modified_method":"private static void makeFullParse(ASTNode parent,\n                             char[] newFileText,\n                             int textLength,\n                             final PsiFileImpl fileImpl,\n                             FileType fileType) {\n    if(parent instanceof CodeFragmentElement){\n      final FileElement holderElement = new DummyHolder(fileImpl.getManager(), null).getTreeElement();\n      TreeUtil.addChildren(holderElement, fileImpl.createContentLeafElement(newFileText, 0, textLength, holderElement.getCharTable()));\n      parent.replaceAllChildrenToChildrenOf(holderElement);\n    }\n    else{\n      final PsiManagerImpl manager = (PsiManagerImpl)fileImpl.getManager();\n      final PsiFileImpl newFile = (PsiFileImpl)PsiElementFactoryImpl.createFileFromText(manager, fileType, fileImpl.getName(), newFileText, 0, textLength);\n      newFile.setOriginalFile(fileImpl);\n      final ASTNode newFileElement = newFile.getTreeElement();\n      final RepositoryManager repositoryManager = manager.getRepositoryManager();\n      final FileElement fileElement = (FileElement)fileImpl.getNode();\n      final int oldLength = fileElement.getTextLength();\n      sendPsiBeforeEvent(fileImpl);\n      if(repositoryManager != null) repositoryManager.beforeChildAddedOrRemoved(fileImpl, fileElement);\n      if(fileElement.getFirstChildNode() != null)\n        TreeUtil.removeRange(fileElement.getFirstChildNode(), null);\n      final ASTNode firstChildNode = newFileElement.getFirstChildNode();\n      if (firstChildNode != null)\n        TreeUtil.addChildren(fileElement, (TreeElement)firstChildNode);\n\n      if(repositoryManager != null) repositoryManager.beforeChildAddedOrRemoved(fileImpl, fileElement);\n      manager.invalidateFile(fileImpl);\n      fileElement.subtreeChanged();\n      sendPsiAfterEvent(fileImpl, oldLength);\n    }\n  }","commit_id":"72477ad961b86e9e0982792c0dfa7216f6636a6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reparseRangeInternal(PsiFile file, int startOffset, int endOffset, int lengthShift, char[] newFileText){\n    final PsiFileImpl fileImpl = (PsiFileImpl)file;\n    Project project = fileImpl.getProject();\n    final CharTable charTable = fileImpl.getTreeElement().getCharTable();\n    // hack\n    final int textLength = file.getTextLength() + lengthShift;\n\n    if(fileImpl.getFileType() == StdFileTypes.JSP){\n      makeFullParse(fileImpl.getTreeElement(), newFileText, textLength, fileImpl, fileImpl.getFileType());\n      return;\n    }\n    final FileElement treeFileElement = fileImpl.getTreeElement();\n\n    final ASTNode leafAtStart = treeFileElement.findLeafElementAt(startOffset);\n    final ASTNode leafAtEnd = treeFileElement.findLeafElementAt(endOffset);\n    ASTNode parent = leafAtStart != null && leafAtEnd != null ? TreeUtil.findCommonParent(leafAtStart, leafAtEnd) : treeFileElement;\n\n    int minErrorLevel = Integer.MAX_VALUE;\n    ASTNode bestReparseable = null;\n    ASTNode prevReparseable = null;\n    boolean theOnlyReparseable = false;\n\n    while(parent != null && !(parent instanceof FileElement)){\n      if(parent.getElementType() instanceof IChameleonElementType){\n        final TextRange textRange = parent.getTextRange();\n        final IChameleonElementType reparseable = (IChameleonElementType)parent.getElementType();\n        boolean languageChanged = false;\n        if(prevReparseable != null){\n          languageChanged = prevReparseable.getElementType().getLanguage() != reparseable.getLanguage();\n        }\n\n        final String newTextStr = StringFactory.createStringFromConstantArray(newFileText, textRange.getStartOffset(), textRange.getLength() + lengthShift);\n        if(reparseable.isParsable(newTextStr, project)){\n          final ChameleonElement chameleon =\n            (ChameleonElement)Factory.createSingleLeafElement(reparseable, newFileText, textRange.getStartOffset(),\n                                                              textRange.getEndOffset() + lengthShift, charTable, file.getManager());\n          ChangeUtil.replaceAllChildren((CompositeElement)parent, reparseable.parseContents(chameleon).getTreeParent());\n          return;\n        }\n        else if(reparseable instanceof IErrorCounterChameleonElementType){\n          int currentErrorLevel = ((IErrorCounterChameleonElementType)reparseable).getErrorsCount(newTextStr, project);\n          if(currentErrorLevel == IErrorCounterChameleonElementType.FATAL_ERROR){\n            prevReparseable = parent;\n          }\n          else if(Math.abs(currentErrorLevel) < Math.abs(minErrorLevel)){\n            theOnlyReparseable = bestReparseable == null;\n            bestReparseable = parent;\n            minErrorLevel = currentErrorLevel;\n            if (languageChanged) break;\n          }\n        }\n        // invalid content;\n      }\n      parent = parent.getTreeParent();\n    }\n\n    if(bestReparseable != null && !theOnlyReparseable){\n      // best reparseable available\n      final ASTNode treeElement = bestReparseable;\n      final TextRange textRange = treeElement.getTextRange();\n      final ChameleonElement chameleon =\n        (ChameleonElement)Factory.createLeafElement(bestReparseable.getElementType(), newFileText, textRange.getStartOffset(),\n                                                    textRange.getEndOffset() + lengthShift, -1, treeFileElement.getCharTable());\n      chameleon.putUserData(CharTable.CHAR_TABLE_KEY, treeFileElement.getCharTable());\n      chameleon.setTreeParent((CompositeElement)parent);\n      treeElement.replaceAllChildrenToChildrenOf(chameleon.transform(treeFileElement.getCharTable(), fileImpl.createLexer(), project).getTreeParent());\n    }\n    else{\n      // file reparse\n      FileType fileType = file.getFileType();\n      if (file instanceof PsiPlainTextFile){\n        fileType = StdFileTypes.PLAIN_TEXT;\n      }\n      //\n      final Grammar grammarByFileType = GrammarUtil.getGrammarByFileType(fileType);\n      if(grammarByFileType != null){\n        ParsingUtil.reparse(grammarByFileType, treeFileElement.getCharTable(), treeFileElement, newFileText, startOffset, endOffset, lengthShift);\n      }\n      else{\n        makeFullParse(parent, newFileText, textLength, fileImpl, fileType);\n      }\n    }\n  }","id":25698,"modified_method":"private static void reparseRangeInternal(PsiFile file, int startOffset, int endOffset, int lengthShift, char[] newFileText){\n    final PsiFileImpl fileImpl = (PsiFileImpl)file;\n    Project project = fileImpl.getProject();\n    final CharTable charTable = fileImpl.getTreeElement().getCharTable();\n    // hack\n    final int textLength = file.getTextLength() + lengthShift;\n\n    if(fileImpl.getFileType() == StdFileTypes.JSP){\n      makeFullParse(fileImpl.getTreeElement(), newFileText, textLength, fileImpl, fileImpl.getFileType());\n      return;\n    }\n    final FileElement treeFileElement = fileImpl.getTreeElement();\n\n    final ASTNode leafAtStart = treeFileElement.findLeafElementAt(startOffset);\n    final ASTNode leafAtEnd = treeFileElement.findLeafElementAt(endOffset);\n    ASTNode parent = leafAtStart != null && leafAtEnd != null ? TreeUtil.findCommonParent(leafAtStart, leafAtEnd) : treeFileElement;\n\n    int minErrorLevel = Integer.MAX_VALUE;\n    ASTNode bestReparseable = null;\n    ASTNode prevReparseable = null;\n    boolean theOnlyReparseable = false;\n\n    while(parent != null && !(parent instanceof FileElement)){\n      if(parent.getElementType() instanceof IChameleonElementType){\n        final TextRange textRange = parent.getTextRange();\n        final IChameleonElementType reparseable = (IChameleonElementType)parent.getElementType();\n        boolean languageChanged = false;\n        if(prevReparseable != null){\n          languageChanged = prevReparseable.getElementType().getLanguage() != reparseable.getLanguage();\n        }\n\n        final String newTextStr = StringFactory.createStringFromConstantArray(newFileText, textRange.getStartOffset(), textRange.getLength() + lengthShift);\n        if(reparseable.isParsable(newTextStr, project)){\n          final ChameleonElement chameleon =\n            (ChameleonElement)Factory.createSingleLeafElement(reparseable, newFileText, textRange.getStartOffset(),\n                                                              textRange.getEndOffset() + lengthShift, charTable, file.getManager());\n          ChangeUtil.replaceAllChildren((CompositeElement)parent, reparseable.parseContents(chameleon).getTreeParent());\n          return;\n        }\n        else if(reparseable instanceof IErrorCounterChameleonElementType){\n          int currentErrorLevel = ((IErrorCounterChameleonElementType)reparseable).getErrorsCount(newTextStr, project);\n          if(currentErrorLevel == IErrorCounterChameleonElementType.FATAL_ERROR){\n            prevReparseable = parent;\n          }\n          else if(Math.abs(currentErrorLevel) < Math.abs(minErrorLevel)){\n            theOnlyReparseable = bestReparseable == null;\n            bestReparseable = parent;\n            minErrorLevel = currentErrorLevel;\n            if (languageChanged) break;\n          }\n        }\n        // invalid content;\n      }\n      parent = parent.getTreeParent();\n    }\n\n    if(bestReparseable != null && !theOnlyReparseable){\n      // best reparseable available\n      final ASTNode treeElement = bestReparseable;\n      final TextRange textRange = treeElement.getTextRange();\n      final ChameleonElement chameleon =\n        (ChameleonElement)Factory.createLeafElement(bestReparseable.getElementType(), newFileText, textRange.getStartOffset(),\n                                                    textRange.getEndOffset() + lengthShift, -1, treeFileElement.getCharTable());\n      chameleon.putUserData(CharTable.CHAR_TABLE_KEY, treeFileElement.getCharTable());\n      chameleon.setTreeParent((CompositeElement)parent);\n      treeElement.replaceAllChildrenToChildrenOf(chameleon.transform(treeFileElement.getCharTable(), fileImpl.createLexer(), project).getTreeParent());\n    }\n    else{\n      boolean leafChangeOptimized = false;\n      Document document = PsiDocumentManager.getInstance(project).getDocument(fileImpl);\n      if (document != null) {\n        int changedOffset;\n        synchronized (document) {\n          Integer offset = document.getUserData(LexerEditorHighlighter.CHANGED_TOKEN_START_OFFSET);\n          changedOffset = offset == null ? -1 : offset.intValue();\n          document.putUserData(LexerEditorHighlighter.CHANGED_TOKEN_START_OFFSET, null);\n        }\n        leafChangeOptimized = changedOffset != -1 && optimizeLeafChange(treeFileElement, newFileText, startOffset, endOffset, lengthShift, changedOffset);\n      }\n      if (leafChangeOptimized) {\n        return;\n      }\n\n      // file reparse\n      FileType fileType = file.getFileType();\n      if (file instanceof PsiPlainTextFile){\n        fileType = StdFileTypes.PLAIN_TEXT;\n      }\n\n      final Grammar grammarByFileType = GrammarUtil.getGrammarByFileType(fileType);\n      if(grammarByFileType != null){\n        ParsingUtil.reparse(grammarByFileType, treeFileElement.getCharTable(), treeFileElement, newFileText, startOffset, endOffset, lengthShift);\n      }\n      else{\n        makeFullParse(parent, newFileText, textLength, fileImpl, fileType);\n      }\n    }\n  }","commit_id":"72477ad961b86e9e0982792c0dfa7216f6636a6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setText(CharSequence text) {\n    int startOffset = 0;\n    char[] chars = CharArrayUtil.fromSequence(text);\n    if(myLexer instanceof JspHighlightLexer && myEditor != null && myEditor.getProject() != null){\n      final PsiDocumentManager instance = PsiDocumentManager.getInstance(myEditor.getProject());\n      final PsiFile psiFile = instance.getPsiFile(myEditor.getDocument());\n      if(psiFile instanceof JspFile) ((JspHighlightLexer)myLexer).setBaseFile((JspFile)psiFile);\n    }\n    myLexer.start(chars, startOffset, text.length());\n    int i = 0;\n    mySegments.removeAll();\n    while(myLexer.getTokenType() != null) {\n      int data = packData(myLexer.getTokenType(), myLexer.getState());\n      mySegments.setElementAt(i, myLexer.getTokenStart(), myLexer.getTokenEnd(), data);\n      i++;\n      myLexer.advance();\n    }\n\n    checkUpdateCorrect(text.length());\n\n    if(myEditor != null) {\n      ((EditorEx) myEditor).repaint(0, text.length());\n    }\n  }","id":25699,"modified_method":"public void setText(CharSequence text) {\n    char[] chars = CharArrayUtil.fromSequence(text);\n    if(myLexer instanceof JspHighlightLexer && myEditor != null && myEditor.getProject() != null){\n      final PsiDocumentManager instance = PsiDocumentManager.getInstance(myEditor.getProject());\n      final PsiFile psiFile = instance.getPsiFile(myEditor.getDocument());\n      if(psiFile instanceof JspFile) ((JspHighlightLexer)myLexer).setBaseFile((JspFile)psiFile);\n    }\n    int startOffset = 0;\n    myLexer.start(chars, startOffset, text.length());\n    mySegments.removeAll();\n    int i = 0;\n    while(myLexer.getTokenType() != null) {\n      int data = packData(myLexer.getTokenType(), myLexer.getState());\n      mySegments.setElementAt(i, myLexer.getTokenStart(), myLexer.getTokenEnd(), data);\n      i++;\n      myLexer.advance();\n    }\n\n    checkUpdateCorrect(text.length());\n\n    if(myEditor != null) {\n      ((EditorEx) myEditor).repaint(0, text.length());\n    }\n  }","commit_id":"72477ad961b86e9e0982792c0dfa7216f6636a6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void documentChanged(DocumentEvent e) {\n    Document document = e.getDocument();\n    if(myLexer instanceof JspHighlightLexer && myEditor != null && myEditor.getProject() != null){\n      final PsiDocumentManager instance = PsiDocumentManager.getInstance(myEditor.getProject());\n      final PsiFile psiFile = instance.getPsiFile(document);\n      if(psiFile instanceof JspFile) ((JspHighlightLexer)myLexer).setBaseFile((JspFile)psiFile);\n    }\n    if(mySegments.getSegmentCount() == 0) {\n      setText(document.getCharsSequence());\n      return;\n    }\n    CharSequence text = document.getCharsSequence();\n    int oldStartOffset = e.getOffset();\n\n    final int oldStartIndex = Math.max(0, mySegments.findSegmentIndex(oldStartOffset) - 2);\n    int startIndex = oldStartIndex;\n\n    int data;\n    do {\n      data = mySegments.getSegmentData(startIndex);\n      if (isInitialState(data)|| startIndex == 0) break;\n      startIndex--;\n    }\n    while (true);\n\n    int startOffset = mySegments.getSegmentStart(startIndex);\n    int newEndOffset = e.getOffset() + e.getNewLength();\n\n    myLexer.start(CharArrayUtil.fromSequence(text), startOffset, text.length(), myInitialState);\n    SegmentArrayWithData insertSegments = new SegmentArrayWithData();\n    int oldEndIndex = -1;\n    int insertSegmentCount = 0;\n    int repaintEnd = -1;\n\n    int lastTokenStart = -1;\n    int lastLexerState = -1;\n\n    while (myLexer.getTokenType() != null) {\n      if (startIndex >= oldStartIndex) break;\n\n      int tokenStart = myLexer.getTokenStart();\n      int lexerState = myLexer.getState();\n\n      if (tokenStart == lastTokenStart && lexerState == lastLexerState) {\n        throw new IllegalStateException(\"Error while updating lexer: \" + e + \" document text: \" + e.getDocument().getText());\n      }\n\n      int tokenEnd = myLexer.getTokenEnd();\n      data = packData(myLexer.getTokenType(), lexerState);\n      if (mySegments.getSegmentStart(startIndex) != tokenStart ||\n          mySegments.getSegmentEnd(startIndex) != tokenEnd ||\n          mySegments.getSegmentData(startIndex) != data) {\n        break;\n      }\n      startIndex++;\n      myLexer.advance();\n      lastTokenStart = tokenStart;\n      lastLexerState = lexerState;\n    }\n\n    startOffset = mySegments.getSegmentStart(startIndex);\n\n    while(myLexer.getTokenType() != null) {\n      int tokenStart = myLexer.getTokenStart();\n      int lexerState = myLexer.getState();\n\n      if (tokenStart == lastTokenStart && lexerState == lastLexerState) {\n        throw new IllegalStateException(\"Error while updating lexer: \" + e + \" document text: \" + e.getDocument().getText());\n      }\n\n      lastTokenStart = tokenStart;\n      lastLexerState = lexerState;\n\n      int tokenEnd = myLexer.getTokenEnd();\n      data = packData(myLexer.getTokenType(), lexerState);\n      if(tokenStart >= newEndOffset && lexerState == myInitialState) {\n        int shiftedTokenStart = tokenStart - e.getNewLength() + e.getOldLength();\n        int index = mySegments.findSegmentIndex(shiftedTokenStart);\n        if (mySegments.getSegmentStart(index) == shiftedTokenStart && mySegments.getSegmentData(index) == data) {\n          repaintEnd = tokenStart;\n          oldEndIndex = index;\n          break;\n        }\n      }\n      insertSegments.setElementAt(insertSegmentCount, tokenStart, tokenEnd, data);\n      insertSegmentCount++;\n      myLexer.advance();\n    }\n\n    final int shift = e.getNewLength() - e.getOldLength();\n    if (repaintEnd > 0) {\n      while (insertSegmentCount > 0 && oldEndIndex > startIndex) {\n        if (!segmentsEqual(mySegments, oldEndIndex - 1, insertSegments, insertSegmentCount - 1, shift)) {\n          break;\n        }\n        insertSegmentCount--;\n        oldEndIndex--;\n        repaintEnd = insertSegments.getSegmentStart(insertSegmentCount);\n        insertSegments.remove(insertSegmentCount, insertSegmentCount + 1);\n      }\n    }\n\n    if(repaintEnd == -1) {\n      repaintEnd = text.length();\n    }\n\n    if (oldEndIndex < 0){\n      oldEndIndex = mySegments.getSegmentCount();\n    }\n    mySegments.shiftSegments(oldEndIndex, shift);\n    mySegments.remove(startIndex, oldEndIndex);\n    mySegments.insert(insertSegments, startIndex);\n\n    int lastDocOffset = e.getDocument().getTextLength();\n    checkUpdateCorrect(lastDocOffset);\n\n    if (insertSegmentCount == 0 ||\n        oldEndIndex == startIndex + 1 && insertSegmentCount == 1 && data == mySegments.getSegmentData(startIndex)) {\n      return;\n    }\n\n    ((EditorEx) myEditor).repaint(startOffset, repaintEnd);\n  }","id":25700,"modified_method":"public synchronized void documentChanged(DocumentEvent e) {\n    Document document = e.getDocument();\n\n    if(myLexer instanceof JspHighlightLexer && myEditor != null && myEditor.getProject() != null){\n      final PsiDocumentManager instance = PsiDocumentManager.getInstance(myEditor.getProject());\n      final PsiFile psiFile = instance.getPsiFile(document);\n      if(psiFile instanceof JspFile) ((JspHighlightLexer)myLexer).setBaseFile((JspFile)psiFile);\n    }\n    if(mySegments.getSegmentCount() == 0) {\n      setText(document.getCharsSequence());\n      return;\n    }\n    CharSequence text = document.getCharsSequence();\n    int oldStartOffset = e.getOffset();\n\n    final int oldStartIndex = Math.max(0, mySegments.findSegmentIndex(oldStartOffset) - 2);\n    int startIndex = oldStartIndex;\n\n    int data;\n    do {\n      data = mySegments.getSegmentData(startIndex);\n      if (isInitialState(data)|| startIndex == 0) break;\n      startIndex--;\n    }\n    while (true);\n\n    int startOffset = mySegments.getSegmentStart(startIndex);\n    int newEndOffset = e.getOffset() + e.getNewLength();\n\n    myLexer.start(CharArrayUtil.fromSequence(text), startOffset, text.length(), myInitialState);\n\n    int lastTokenStart = -1;\n    int lastLexerState = -1;\n\n    while (myLexer.getTokenType() != null) {\n      if (startIndex >= oldStartIndex) break;\n\n      int tokenStart = myLexer.getTokenStart();\n      int lexerState = myLexer.getState();\n\n      if (tokenStart == lastTokenStart && lexerState == lastLexerState) {\n        throw new IllegalStateException(\"Error while updating lexer: \" + e + \" document text: \" + document.getText());\n      }\n\n      int tokenEnd = myLexer.getTokenEnd();\n      data = packData(myLexer.getTokenType(), lexerState);\n      if (mySegments.getSegmentStart(startIndex) != tokenStart ||\n          mySegments.getSegmentEnd(startIndex) != tokenEnd ||\n          mySegments.getSegmentData(startIndex) != data) {\n        break;\n      }\n      startIndex++;\n      myLexer.advance();\n      lastTokenStart = tokenStart;\n      lastLexerState = lexerState;\n    }\n\n    startOffset = mySegments.getSegmentStart(startIndex);\n    int repaintEnd = -1;\n    int insertSegmentCount = 0;\n    int oldEndIndex = -1;\n    SegmentArrayWithData insertSegments = new SegmentArrayWithData();\n\n    while(myLexer.getTokenType() != null) {\n      int tokenStart = myLexer.getTokenStart();\n      int lexerState = myLexer.getState();\n\n      if (tokenStart == lastTokenStart && lexerState == lastLexerState) {\n        throw new IllegalStateException(\"Error while updating lexer: \" + e + \" document text: \" + document.getText());\n      }\n\n      lastTokenStart = tokenStart;\n      lastLexerState = lexerState;\n\n      int tokenEnd = myLexer.getTokenEnd();\n      data = packData(myLexer.getTokenType(), lexerState);\n      if(tokenStart >= newEndOffset && lexerState == myInitialState) {\n        int shiftedTokenStart = tokenStart - e.getNewLength() + e.getOldLength();\n        int index = mySegments.findSegmentIndex(shiftedTokenStart);\n        if (mySegments.getSegmentStart(index) == shiftedTokenStart && mySegments.getSegmentData(index) == data) {\n          repaintEnd = tokenStart;\n          oldEndIndex = index;\n          break;\n        }\n      }\n      insertSegments.setElementAt(insertSegmentCount, tokenStart, tokenEnd, data);\n      insertSegmentCount++;\n      myLexer.advance();\n    }\n\n    final int shift = e.getNewLength() - e.getOldLength();\n    if (repaintEnd > 0) {\n      while (insertSegmentCount > 0 && oldEndIndex > startIndex) {\n        if (!segmentsEqual(mySegments, oldEndIndex - 1, insertSegments, insertSegmentCount - 1, shift)) {\n          break;\n        }\n        insertSegmentCount--;\n        oldEndIndex--;\n        repaintEnd = insertSegments.getSegmentStart(insertSegmentCount);\n        insertSegments.remove(insertSegmentCount, insertSegmentCount + 1);\n      }\n    }\n\n    if(repaintEnd == -1) {\n      repaintEnd = text.length();\n    }\n\n    if (oldEndIndex < 0){\n      oldEndIndex = mySegments.getSegmentCount();\n    }\n    int changedIndex = changedOffsetIndex(startIndex, oldEndIndex, insertSegments);\n    mySegments.shiftSegments(oldEndIndex, shift);\n    mySegments.remove(startIndex, oldEndIndex);\n    mySegments.insert(insertSegments, startIndex);\n    synchronized (document) {\n      int tokenStartOffset;\n      if (changedIndex == -1) {\n        tokenStartOffset = -1;\n      }\n      else {\n        tokenStartOffset = mySegments.getSegmentStart(changedIndex);\n        Integer oldTokenStartOffset = document.getUserData(CHANGED_TOKEN_START_OFFSET);\n        if (oldTokenStartOffset != null && oldTokenStartOffset.intValue() != tokenStartOffset) {\n          tokenStartOffset = -1;\n        }\n      }\n      document.putUserData(CHANGED_TOKEN_START_OFFSET, new Integer(tokenStartOffset));\n    }\n\n    int lastDocOffset = document.getTextLength();\n    checkUpdateCorrect(lastDocOffset);\n\n    if (insertSegmentCount == 0 ||\n        oldEndIndex == startIndex + 1 && insertSegmentCount == 1 && data == mySegments.getSegmentData(startIndex)) {\n      return;\n    }\n\n    ((EditorEx) myEditor).repaint(startOffset, repaintEnd);\n  }","commit_id":"72477ad961b86e9e0982792c0dfa7216f6636a6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private TextAttributes convertAttributes(TextAttributesKey[] keys) {\n    EditorColorsScheme scheme = myScheme;\n    TextAttributes attrs = scheme.getAttributes(HighlighterColors.TEXT);\n    for (int i = 0; i < keys.length; i++) {\n      TextAttributesKey key = keys[i];\n      TextAttributes attrs2 = scheme.getAttributes(key);\n      if (attrs2 != null) {\n        attrs = TextAttributes.merge(attrs, attrs2);\n      }\n    }\n    return attrs;\n  }","id":25701,"modified_method":"private TextAttributes convertAttributes(TextAttributesKey[] keys) {\n    EditorColorsScheme scheme = myScheme;\n    TextAttributes attrs = scheme.getAttributes(HighlighterColors.TEXT);\n    for (TextAttributesKey key : keys) {\n      TextAttributes attrs2 = scheme.getAttributes(key);\n      if (attrs2 != null) {\n        attrs = TextAttributes.merge(attrs, attrs2);\n      }\n    }\n    return attrs;\n  }","commit_id":"72477ad961b86e9e0982792c0dfa7216f6636a6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateByChange(PsiElement child) {\n    final Editor editor = FileEditorManager.getInstance(myProject).getSelectedTextEditor();\n    if (editor != null) {\n      ApplicationManager.getApplication().invokeLater(new Runnable(){\n        public void run() {\n          EditorMarkupModel markupModel = (EditorMarkupModel) editor.getMarkupModel();\n          markupModel.setErrorStripeRenderer(markupModel.getErrorStripeRenderer());\n        }\n      },ModalityState.stateForComponent(editor.getComponent()));\n    }\n\n    PsiFile file = child.getContainingFile();\n    if (file == null) {\n      myDaemonCodeAnalyzer.getFileStatusMap().markAllFilesDirty();\n      return;\n    }\n    Document document = PsiDocumentManager.getInstance(myProject).getCachedDocument(file);\n    if (document == null) return;\n\n    // optimization:\n    PsiElement parent = child;\n    while (true) {\n      if (parent instanceof PsiFile || parent instanceof PsiDirectory) {\n        myDaemonCodeAnalyzer.getFileStatusMap().markAllFilesDirty();\n        return;\n      }\n      PsiElement pparent = parent.getParent();\n\n      if(parent instanceof XmlTag){\n        PsiElement dirtyScope = pparent;\n\n        if (pparent instanceof XmlTag &&\n            HEAD_TAG.equals(((XmlTag)pparent).getLocalName())) {\n          final PsiFile containingFile = parent.getContainingFile();\n          final FileType fileType = (containingFile != null)? containingFile.getFileType() : null;\n\n          if (fileType == StdFileTypes.JSP ||\n              fileType == StdFileTypes.JSPX ||\n              fileType == StdFileTypes.HTML ||\n              fileType == StdFileTypes.XHTML\n             ) {\n            // change in head will result in changes for css/javascript code highlighting\n            dirtyScope = containingFile;\n          }\n        }\n\n        myDaemonCodeAnalyzer.getFileStatusMap().markFileScopeDirty(document, dirtyScope);\n        return;\n      }\n\n      if (parent instanceof PsiCodeBlock\n          && pparent instanceof PsiMethod\n          && !((PsiMethod) pparent).isConstructor()\n          && pparent.getParent() instanceof PsiClass\n          && !(pparent.getParent() instanceof PsiAnonymousClass)) {\n        // do not use this optimization for constructors and class initializers - to update non-initialized fields\n        myDaemonCodeAnalyzer.getFileStatusMap().markFileScopeDirty(document, pparent);\n        return;\n      }\n      parent = pparent;\n    }\n  }","id":25702,"modified_method":"private void updateByChange(PsiElement child) {\n    printDiff(child.getContainingFile());\n    final Editor editor = FileEditorManager.getInstance(myProject).getSelectedTextEditor();\n    if (editor != null) {\n      ApplicationManager.getApplication().invokeLater(new Runnable(){\n        public void run() {\n          EditorMarkupModel markupModel = (EditorMarkupModel) editor.getMarkupModel();\n          markupModel.setErrorStripeRenderer(markupModel.getErrorStripeRenderer());\n        }\n      },ModalityState.stateForComponent(editor.getComponent()));\n    }\n\n    PsiFile file = child.getContainingFile();\n    if (file == null) {\n      myDaemonCodeAnalyzer.getFileStatusMap().markAllFilesDirty();\n      return;\n    }\n    Document document = PsiDocumentManager.getInstance(myProject).getCachedDocument(file);\n    if (document == null) return;\n    // optimization\n    if (child instanceof PsiWhiteSpace \n        || child instanceof PsiComment\n        || child instanceof PsiDocToken\n        || PropertiesTokenTypes.PROPERTIES_TYPES_TO_IGNORE.contains(child.getNode().getElementType())) {\n      return;\n    }\n\n    // optimization:\n    PsiElement parent = child;\n    while (true) {\n      if (parent instanceof PsiFile || parent instanceof PsiDirectory) {\n        myDaemonCodeAnalyzer.getFileStatusMap().markAllFilesDirty();\n        return;\n      }\n      PsiElement pparent = parent.getParent();\n\n      if(parent instanceof XmlTag){\n        PsiElement dirtyScope = pparent;\n\n        if (pparent instanceof XmlTag &&\n            \"head\".equals(((XmlTag)pparent).getLocalName())) {\n          final PsiFile containingFile = parent.getContainingFile();\n          final FileType fileType = containingFile == null ? null : containingFile.getFileType();\n\n          if (fileType == StdFileTypes.JSP ||\n              fileType == StdFileTypes.JSPX ||\n              fileType == StdFileTypes.HTML ||\n              fileType == StdFileTypes.XHTML\n             ) {\n            // change in head will result in changes for css/javascript code highlighting\n            dirtyScope = containingFile;\n          }\n        }\n\n        myDaemonCodeAnalyzer.getFileStatusMap().markFileScopeDirty(document, dirtyScope);\n        return;\n      }\n\n      if (parent instanceof PsiCodeBlock\n          && pparent instanceof PsiMethod\n          && !((PsiMethod) pparent).isConstructor()\n          && pparent.getParent() instanceof PsiClass\n          && !(pparent.getParent() instanceof PsiAnonymousClass)) {\n        // do not use this optimization for constructors and class initializers - to update non-initialized fields\n        myDaemonCodeAnalyzer.getFileStatusMap().markFileScopeDirty(document, pparent);\n        return;\n      }\n      parent = pparent;\n    }\n  }","commit_id":"72477ad961b86e9e0982792c0dfa7216f6636a6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void saveIndents(ASTNode first, final ASTNode lastChild, final Collection<PsiElement> dirtyElements, final PsiFile file) {\n    first = transform(first);\n    final PsiFile newElementFile = transformToPsiElement(first).getContainingFile();\n    final Language language = newElementFile.getLanguage();\n    final FormattingModelBuilder builder = language.getFormattingModelBuilder();\n    if (builder != null) {\n      final CodeStyleSettings settings = CodeStyleSettingsManager.getSettings(file.getProject());\n      final FormattingModel model = builder.createModel(newElementFile, settings);\n      ASTNode current = first;\n      while (current != null && current != lastChild) {\n        final IElementType elementType = current.getElementType();\n        if (elementType != ElementType.WHITE_SPACE\n          && elementType != ElementType.DOC_COMMENT_LEADING_ASTERISKS\n          && elementType != ElementType.DOC_TAG\n          && current.getTextLength() > 0) {\n          FormatterEx.getInstanceEx().saveIndents(model, current.getTextRange(),\n            new MyIndentInfoStorage(newElementFile, dirtyElements),\n            settings,\n            settings.getIndentOptions(file.getFileType()));\n        }\n        current = current.getTreeNext();\n      }\n\n    }\n  }","id":25703,"modified_method":"private static void saveIndents(ASTNode first, final ASTNode lastChild, final Collection<PsiElement> dirtyElements, final PsiFile file) {\n    first = transform(first);\n    final PsiFile newElementFile = getTreeElementContainingFile(first);\n    final Language language = newElementFile.getLanguage();\n    final FormattingModelBuilder builder = language.getFormattingModelBuilder();\n    if (builder != null) {\n      final CodeStyleSettings settings = CodeStyleSettingsManager.getSettings(file.getProject());\n      final FormattingModel model = builder.createModel(newElementFile, settings);\n      ASTNode current = first;\n      while (current != null && current != lastChild) {\n        final IElementType elementType = current.getElementType();\n        if (elementType != ElementType.WHITE_SPACE && elementType != ElementType.DOC_COMMENT_LEADING_ASTERISKS &&\n            elementType != ElementType.DOC_TAG && current.getTextLength() > 0) {\n          FormatterEx.getInstanceEx().saveIndents(model, current.getTextRange(), new MyIndentInfoStorage(newElementFile, dirtyElements),\n                                                  settings, settings.getIndentOptions(file.getFileType()));\n        }\n        current = current.getTreeNext();\n      }\n\n    }\n  }","commit_id":"96735ca7ff93fd7888903ef0019b76e8c47ac172","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void adjustWhiteSpaceBefore(ASTNode first,\n                                             final boolean keepBlankLines,\n                                             final boolean keepLineBreaks,\n                                             final boolean changeWSBeforeFirstElement, final boolean changeLineFeedsBeforeFirstElement,\n                                             final PsiFile file) {\n    first = transform(first);\n    if (first != null) {\n      final PsiElement psi = first.getPsi();\n      CodeStyleSettings settings = CodeStyleSettingsManager.getSettings(psi.getProject());\n      final FormattingModelBuilder builder = file.getLanguage().getFormattingModelBuilder();\n      final FormattingModelBuilder elementBuilder = psi.getLanguage().getFormattingModelBuilder();\n\n      final boolean keepWhiteSpaces = settings.HTML_KEEP_WHITESPACES;\n      boolean canModifyWhiteSpaces = canModifyWS(file);\n      if (!canModifyWhiteSpaces) {\n        settings.HTML_KEEP_WHITESPACES = true;\n      }\n\n      try {\n        if (builder != null && elementBuilder != null) {\n          ASTNode firstNonSpaceLeaf = TreeUtil.findFirstLeaf(first);\n          while (firstNonSpaceLeaf != null && firstNonSpaceLeaf.getElementType() == ElementType.WHITE_SPACE) {\n            firstNonSpaceLeaf = TreeUtil.nextLeaf(firstNonSpaceLeaf);\n          }\n          if (firstNonSpaceLeaf != null) {\n            final int startOffset = firstNonSpaceLeaf.getStartOffset();\n            final int endOffset = first.getTextRange().getEndOffset();\n            if (startOffset < endOffset) {\n              FormatterEx.getInstanceEx().adjustTextRange(builder.createModel(file, settings), settings,\n                                                          settings.getIndentOptions(file.getFileType()),\n                                                          new TextRange(startOffset, endOffset),\n                                                          keepBlankLines,\n                                                          keepLineBreaks,\n                                                          changeWSBeforeFirstElement,\n                                                          changeLineFeedsBeforeFirstElement,\n                                                          canModifyWhiteSpaces ? new MyIndentInfoStorage(file, null) : null);\n            }\n          }\n        }\n      }\n      finally {\n        settings.HTML_KEEP_WHITESPACES = keepWhiteSpaces;\n      }\n    }\n  }","id":25704,"modified_method":"private static void adjustWhiteSpaceBefore(ASTNode first,\n                                             final boolean keepBlankLines,\n                                             final boolean keepLineBreaks,\n                                             final boolean changeWSBeforeFirstElement,\n                                             final boolean changeLineFeedsBeforeFirstElement,\n                                             final PsiFile file) {\n    first = transform(first);\n    if (first != null) {\n      final PsiElement psi = first.getPsi();\n      CodeStyleSettings settings = CodeStyleSettingsManager.getSettings(psi.getProject());\n      final FormattingModelBuilder builder = file.getViewProvider().getBaseLanguage().getFormattingModelBuilder();\n      final FormattingModelBuilder elementBuilder = psi.getLanguage().getFormattingModelBuilder();\n\n      final boolean keepWhiteSpaces = settings.HTML_KEEP_WHITESPACES;\n      boolean canModifyWhiteSpaces = canModifyWS(file);\n      if (!canModifyWhiteSpaces) {\n        settings.HTML_KEEP_WHITESPACES = true;\n      }\n\n      try {\n        if (builder != null && elementBuilder != null) {\n          ASTNode firstNonSpaceLeaf = TreeUtil.findFirstLeaf(first);\n          while (firstNonSpaceLeaf != null && firstNonSpaceLeaf.getElementType() == ElementType.WHITE_SPACE) {\n            firstNonSpaceLeaf = TreeUtil.nextLeaf(firstNonSpaceLeaf);\n          }\n          if (firstNonSpaceLeaf != null) {\n            final int startOffset = firstNonSpaceLeaf.getStartOffset();\n            final int endOffset = first.getTextRange().getEndOffset();\n            if (startOffset < endOffset) {\n              FormatterEx.getInstanceEx().adjustTextRange(builder.createModel(file, settings), settings,\n                                                          settings.getIndentOptions(file.getFileType()),\n                                                          new TextRange(startOffset, endOffset), keepBlankLines, keepLineBreaks,\n                                                          changeWSBeforeFirstElement, changeLineFeedsBeforeFirstElement,\n                                                          canModifyWhiteSpaces ? new MyIndentInfoStorage(file, null) : null);\n            }\n          }\n        }\n      }\n      finally {\n        settings.HTML_KEEP_WHITESPACES = keepWhiteSpaces;\n      }\n    }\n  }","commit_id":"96735ca7ff93fd7888903ef0019b76e8c47ac172","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static TreeElement returnFirstChangedNode(final List<ASTNode> treePrev, final CompositeElement parent) {\n    if (treePrev == null) {\n      return (TreeElement) parent.getFirstChildNode();\n    } else {\n      ASTNode firstValid = findFirstValid(treePrev);\n      if (firstValid == null) {\n        return (TreeElement) parent.getFirstChildNode();\n      } else {\n        return (TreeElement) firstValid.getTreeNext();\n      }\n    }\n  }","id":25705,"modified_method":"private static TreeElement returnFirstChangedNode(final List<ASTNode> treePrev, final CompositeElement parent) {\n    if (treePrev == null) {\n      return parent.getFirstChildNode();\n    }\n    else {\n      ASTNode firstValid = findFirstValid(treePrev);\n      if (firstValid == null) {\n        return parent.getFirstChildNode();\n      }\n      else {\n        return (TreeElement)firstValid.getTreeNext();\n      }\n    }\n  }","commit_id":"96735ca7ff93fd7888903ef0019b76e8c47ac172","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String getStringWhiteSpaceBetweenTokens(ASTNode first, ASTNode second, Language language) {\n    final FormattingModelBuilder modelBuilder = language.getFormattingModelBuilder();\n    if (modelBuilder == null) {\n      final LeafElement leafElement = ParseUtil.nextLeaf((TreeElement) first, null);\n      if (leafElement != second) {\n        return leafElement.getText();\n      } else {\n        return null;\n      }\n    } else {\n      final PsiElement secondAsPsiElement = transformToPsiElement(second);\n      LOG.assertTrue(secondAsPsiElement != null);\n      final PsiFile file = secondAsPsiElement.getContainingFile();\n      final Project project = secondAsPsiElement.getProject();\n      final CodeStyleSettings settings = CodeStyleSettingsManager.getInstance(project).getCurrentSettings();\n      return getWhiteSpaceBeforeToken(second, language, true).generateNewWhiteSpace(settings.getIndentOptions(file.getFileType()));\n    }\n\n  }","id":25706,"modified_method":"public static String getStringWhiteSpaceBetweenTokens(ASTNode first, ASTNode second, Language language) {\n    final FormattingModelBuilder modelBuilder = language.getFormattingModelBuilder();\n    if (modelBuilder == null) {\n      final LeafElement leafElement = ParseUtil.nextLeaf((TreeElement)first, null);\n      if (leafElement != second) {\n        return leafElement.getText();\n      }\n      else {\n        return null;\n      }\n    }\n    else {\n      final PsiFile file = getTreeElementContainingFile(second);\n      final CodeStyleSettings settings = CodeStyleSettingsManager.getInstance(file.getProject()).getCurrentSettings();\n      return getWhiteSpaceBeforeToken(second, language, true).generateNewWhiteSpace(settings.getIndentOptions(file.getFileType()));\n    }\n\n  }","commit_id":"96735ca7ff93fd7888903ef0019b76e8c47ac172","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean canStickJavaTokens(PsiJavaToken token1, PsiJavaToken token2) {\n    IElementType type1 = token1.getTokenType();\n    IElementType type2 = token2.getTokenType();\n\n    Pair<IElementType, IElementType> pair = new Pair<IElementType, IElementType>(type1, type2);\n    Boolean res = myCanStickJavaTokensMatrix.get(pair);\n    if (res == null) {\n      if (!checkToken(token1) || !checkToken(token2)) return true;\n      String text = token1.getText() + token2.getText();\n      Lexer lexer = new JavaLexer(LanguageLevel.HIGHEST);\n      lexer.start(text.toCharArray(), 0, text.length());\n      boolean canMerge = lexer.getTokenType() == type1;\n      lexer.advance();\n      canMerge &= lexer.getTokenType() == type2;\n      res = Boolean.valueOf(canMerge);\n      myCanStickJavaTokensMatrix.put(pair, res);\n    }\n    return res;\n  }","id":25707,"modified_method":"public static boolean canStickJavaTokens(PsiJavaToken token1, PsiJavaToken token2) {\n    IElementType type1 = token1.getTokenType();\n    IElementType type2 = token2.getTokenType();\n\n    Pair<IElementType, IElementType> pair = new Pair<IElementType, IElementType>(type1, type2);\n    Boolean res = myCanStickJavaTokensMatrix.get(pair);\n    if (res == null) {\n      if (!checkToken(token1) || !checkToken(token2)) return true;\n      String text = token1.getText() + token2.getText();\n      Lexer lexer = new JavaLexer(LanguageLevel.HIGHEST);\n      lexer.start(text.toCharArray(), 0, text.length());\n      boolean canMerge = lexer.getTokenType() == type1;\n      lexer.advance();\n      canMerge &= lexer.getTokenType() == type2;\n      res = canMerge;\n      myCanStickJavaTokensMatrix.put(pair, res);\n    }\n    return res.booleanValue();\n  }","commit_id":"96735ca7ff93fd7888903ef0019b76e8c47ac172","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static IndentInfo getWhiteSpaceBeforeToken(final ASTNode tokenNode,\n                                                    final Language language,\n                                                    final boolean mayChangeLineFeeds) {\n    LOG.assertTrue(tokenNode != null);\n    final PsiElement secondAsPsiElement = transformToPsiElement(tokenNode);\n    LOG.assertTrue(secondAsPsiElement != null);\n    final PsiFile file = secondAsPsiElement.getContainingFile();\n    final Project project = secondAsPsiElement.getProject();\n    final CodeStyleSettings settings = CodeStyleSettingsManager.getInstance(project).getCurrentSettings();\n    final int tokenStartOffset = tokenNode.getStartOffset();\n\n    final boolean oldValue = settings.XML_KEEP_LINE_BREAKS;\n    final int oldKeepBlankLines = settings.XML_KEEP_BLANK_LINES;\n    settings.XML_KEEP_BLANK_LINES = 0;\n    try {\n      final FormattingModelBuilder builder = language.getFormattingModelBuilder();\n      final PsiElement element = file.findElementAt(tokenStartOffset);\n\n      if (builder != null && element.getLanguage().getFormattingModelBuilder() != null) {\n\n        final TextRange textRange = element.getTextRange();\n        final FormattingModel model = builder.createModel(file, settings);\n        return FormatterEx.getInstanceEx().getWhiteSpaceBefore(model.getDocumentModel(),\n          model.getRootBlock(),\n          settings, settings.getIndentOptions(file.getFileType()), textRange,\n          mayChangeLineFeeds);\n      } else {\n        return new IndentInfo(0, 0, 0);\n      }\n\n    }\n    finally {\n      settings.XML_KEEP_LINE_BREAKS = oldValue;\n      settings.XML_KEEP_BLANK_LINES = oldKeepBlankLines;\n    }\n  }","id":25708,"modified_method":"public static IndentInfo getWhiteSpaceBeforeToken(final ASTNode tokenNode, final Language language, final boolean mayChangeLineFeeds) {\n    LOG.assertTrue(tokenNode != null);\n    final PsiFile file = getTreeElementContainingFile(tokenNode);\n    final Project project = file.getProject();\n    final CodeStyleSettings settings = CodeStyleSettingsManager.getInstance(project).getCurrentSettings();\n    final int tokenStartOffset = tokenNode.getStartOffset();\n\n    final boolean oldValue = settings.XML_KEEP_LINE_BREAKS;\n    final int oldKeepBlankLines = settings.XML_KEEP_BLANK_LINES;\n    settings.XML_KEEP_BLANK_LINES = 0;\n    try {\n      final FormattingModelBuilder builder = language.getFormattingModelBuilder();\n      final PsiElement element = file.findElementAt(tokenStartOffset);\n\n      if (builder != null && element.getLanguage().getFormattingModelBuilder() != null) {\n\n        final TextRange textRange = element.getTextRange();\n        final FormattingModel model = builder.createModel(file, settings);\n        return FormatterEx.getInstanceEx().getWhiteSpaceBefore(model.getDocumentModel(), model.getRootBlock(), settings,\n                                                               settings.getIndentOptions(file.getFileType()), textRange,\n                                                               mayChangeLineFeeds);\n      }\n      else {\n        return new IndentInfo(0, 0, 0);\n      }\n\n    }\n    finally {\n      settings.XML_KEEP_LINE_BREAKS = oldValue;\n      settings.XML_KEEP_BLANK_LINES = oldKeepBlankLines;\n    }\n  }","commit_id":"96735ca7ff93fd7888903ef0019b76e8c47ac172","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void removeChildren(CompositeElement parent, ASTNode first, ASTNode last) {\n    if (FormatterEx.getInstanceEx().isDisabled()) {\n      parent.removeRange(first, findLastChild(last));\n    } else {\n      checkAllWhiteSpaces(parent);\n      removeChildrenAndAdjustWhiteSpaces(first, last, parent, parent.getPsi().getContainingFile());\n    }\n  }","id":25709,"modified_method":"public static void removeChildren(CompositeElement parent, ASTNode first, ASTNode last) {\n    if (FormatterEx.getInstanceEx().isDisabled()) {\n      parent.removeRange(first, findLastChild(last));\n    }\n    else {\n      checkAllWhiteSpaces(parent);\n      removeChildrenAndAdjustWhiteSpaces(first, last, parent, getTreeElementContainingFile(parent));\n    }\n  }","commit_id":"96735ca7ff93fd7888903ef0019b76e8c47ac172","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static IndentInfo getIndentWhiteSpaceBeforeToken(final ASTNode tokenNode,\n                                                          final Language language) {\n    return getWhiteSpaceBeforeToken(tokenNode,\n                                    chooseLanguage(tokenNode, language, transformToPsiElement(tokenNode).getContainingFile()),\n                                    false);\n  }","id":25710,"modified_method":"public static IndentInfo getIndentWhiteSpaceBeforeToken(final ASTNode tokenNode, final Language language) {\n    return getWhiteSpaceBeforeToken(tokenNode, chooseLanguage(tokenNode, language, getTreeElementContainingFile(tokenNode)), false);\n  }","commit_id":"96735ca7ff93fd7888903ef0019b76e8c47ac172","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static ASTNode replaceChild(CompositeElement parent, ASTNode oldChild, ASTNode newChild) {\n    if (FormatterEx.getInstanceEx().isDisabled()) {\n      parent.replaceChild(oldChild, newChild);\n      return newChild;\n    } else {\n      checkAllWhiteSpaces(parent);\n      return replaceAndAdjustWhiteSpaces(oldChild, newChild, parent, parent.getPsi().getContainingFile());\n    }\n  }","id":25711,"modified_method":"public static ASTNode replaceChild(CompositeElement parent, ASTNode oldChild, ASTNode newChild) {\n    if (FormatterEx.getInstanceEx().isDisabled()) {\n      parent.replaceChild(oldChild, newChild);\n      return newChild;\n    }\n    else {\n      checkAllWhiteSpaces(parent);\n      return replaceAndAdjustWhiteSpaces(oldChild, newChild, parent, getTreeElementContainingFile(parent));\n    }\n  }","commit_id":"96735ca7ff93fd7888903ef0019b76e8c47ac172","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static TreeElement addChildren(CompositeElement parent, ASTNode first, ASTNode last, ASTNode anchorBefore) {\n    LOG.assertTrue(first != null);\n\n    ASTNode lastChild = last != null ? last.getTreeNext() : null;\n\n    if (FormatterEx.getInstanceEx().isDisabled()) {\n      parent.addChildren(first, lastChild, anchorBefore);\n      return (TreeElement) first;\n    } else {\n      checkAllWhiteSpaces(parent);\n      TreeElement element = addChildrenAndAdjustWhiteSpaces(first, lastChild, anchorBefore, parent, parent.getPsi().getContainingFile());\n      return element;\n    }\n  }","id":25712,"modified_method":"public static TreeElement addChildren(CompositeElement parent, ASTNode first, ASTNode last, ASTNode anchorBefore) {\n    LOG.assertTrue(first != null);\n\n    ASTNode lastChild = last != null ? last.getTreeNext() : null;\n\n    if (FormatterEx.getInstanceEx().isDisabled()) {\n      parent.addChildren(first, lastChild, anchorBefore);\n      return (TreeElement)first;\n    }\n    else {\n      checkAllWhiteSpaces(parent);\n      return addChildrenAndAdjustWhiteSpaces(first, lastChild, anchorBefore, parent, getTreeElementContainingFile(parent));\n    }\n  }","commit_id":"96735ca7ff93fd7888903ef0019b76e8c47ac172","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeElement parseParameter(Lexer lexer, boolean allowEllipsis) {\n    final LexerPosition pos = lexer.getCurrentPosition();\n\n    CompositeElement modifierList = parseModifierList(lexer);\n\n    CompositeElement type = allowEllipsis ? parseTypeWithEllipsis(lexer) : parseType(lexer);\n    if (type == null){\n      lexer.restore(pos);\n      return null;\n    }\n\n    CompositeElement param = Factory.createCompositeElement(PARAMETER);\n    TreeUtil.addChildren(param, modifierList);\n    TreeUtil.addChildren(param, type);\n\n    if (lexer.getTokenType() == IDENTIFIER){\n      TreeUtil.addChildren(param, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n      lexer.advance();\n\n      while(lexer.getTokenType() == LBRACKET){\n        TreeUtil.addChildren(param, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n        lexer.advance();\n        if (lexer.getTokenType() != RBRACKET){\n          TreeUtil.addChildren(param, Factory.createErrorElement(JavaErrorMessages.message(\"expected.rbracket\")));\n          break;\n        }\n        TreeUtil.addChildren(param, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n        lexer.advance();\n      }\n\n      return param;\n    } else{\n      TreeUtil.addChildren(param, Factory.createErrorElement(JavaErrorMessages.message(\"expected.identifier\")));\n      return (TreeElement)param.getFirstChildNode();\n    }\n  }","id":25713,"modified_method":"public TreeElement parseParameter(Lexer lexer, boolean allowEllipsis) {\n    final LexerPosition pos = lexer.getCurrentPosition();\n\n    CompositeElement modifierList = parseModifierList(lexer);\n\n    CompositeElement type = allowEllipsis ? parseTypeWithEllipsis(lexer) : parseType(lexer);\n    if (type == null){\n      lexer.restore(pos);\n      return null;\n    }\n\n    CompositeElement param = Factory.createCompositeElement(PARAMETER);\n    TreeUtil.addChildren(param, modifierList);\n    TreeUtil.addChildren(param, type);\n\n    if (lexer.getTokenType() == IDENTIFIER){\n      TreeUtil.addChildren(param, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n      lexer.advance();\n\n      while(lexer.getTokenType() == LBRACKET){\n        TreeUtil.addChildren(param, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n        lexer.advance();\n        if (lexer.getTokenType() != RBRACKET){\n          TreeUtil.addChildren(param, Factory.createErrorElement(JavaErrorMessages.message(\"expected.rbracket\")));\n          break;\n        }\n        TreeUtil.addChildren(param, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n        lexer.advance();\n      }\n\n      return param;\n    } else{\n      TreeUtil.addChildren(param, Factory.createErrorElement(JavaErrorMessages.message(\"expected.identifier\")));\n      return param.getFirstChildNode();\n    }\n  }","commit_id":"5e0cea3cdd4b50415f20d0b36292773a6bf14f58","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CompositeElement parseReferenceList(Lexer lexer, IElementType elementType, IElementType referenceDelimiter, IElementType keyword) {\n    if (lexer.getTokenType() != keyword) return null;\n\n    CompositeElement list = Factory.createCompositeElement(elementType);\n    TreeUtil.addChildren(list, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n    lexer.advance();\n\n    TreeElement classReference = parseJavaCodeReference(lexer, true, true);\n    if (classReference != null){\n      TreeUtil.addChildren(list, classReference);\n      while(true){\n        if (lexer.getTokenType() != referenceDelimiter) break;\n        TreeElement comma = ParseUtil.createTokenElement(lexer, myContext.getCharTable());\n        lexer.advance();\n        TreeUtil.addChildren(list, comma);\n\n        classReference = parseJavaCodeReference(lexer, true, true);\n        if (classReference == null){\n          TreeUtil.addChildren(list, Factory.createErrorElement(JavaErrorMessages.message(\"expected.identifier\")));\n          break;\n        }\n        TreeUtil.addChildren(list, classReference);\n      }\n    }\n    else{\n      TreeUtil.addChildren(list, Factory.createErrorElement(JavaErrorMessages.message(\"expected.identifier\")));\n    }\n\n    return list;\n  }","id":25714,"modified_method":"public CompositeElement parseReferenceList(Lexer lexer, IElementType elementType, IElementType referenceDelimiter, IElementType keyword) {\n    if (lexer.getTokenType() != keyword) return null;\n\n    CompositeElement list = Factory.createCompositeElement(elementType);\n    TreeUtil.addChildren(list, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n    lexer.advance();\n\n    while (true) {\n      TreeElement classReference = parseJavaCodeReference(lexer, true, true);\n      if (classReference == null) {\n        classReference = Factory.createErrorElement(JavaErrorMessages.message(\"expected.identifier\"));\n      }\n      TreeUtil.addChildren(list, classReference);\n      if (lexer.getTokenType() != referenceDelimiter) break;\n      TreeElement delimiter = ParseUtil.createTokenElement(lexer, myContext.getCharTable());\n      lexer.advance();\n      TreeUtil.addChildren(list, delimiter);\n    }\n\n    return list;\n  }","commit_id":"5e0cea3cdd4b50415f20d0b36292773a6bf14f58","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeElement parseExpressionText(final Lexer originalLexer,\n                                         final char[] buffer,\n                                         final int startOffset,\n                                         final int endOffset,\n                                         PsiManager manager) {\n    FilterLexer lexer = new FilterLexer(originalLexer, new FilterLexer.SetFilter(WHITE_SPACE_OR_COMMENT_BIT_SET));\n    lexer.start(buffer, startOffset, endOffset);\n    CharTable table = myContext.getCharTable();\n    final FileElement dummyRoot = new DummyHolder(manager, null, table).getTreeElement();\n    CompositeElement expression = parseExpression(lexer);\n    if (expression != null)\n      TreeUtil.addChildren(dummyRoot, expression);\n\n    while(lexer.getTokenType() != null){\n      TreeUtil.addChildren(dummyRoot, ParseUtil.createTokenElement(lexer, table));\n      lexer.advance();\n    }\n\n    ParseUtil.insertMissingTokens(dummyRoot, originalLexer, 0, buffer.length, -1, ParseUtil.WhiteSpaceAndCommentsProcessor.INSTANCE, myContext);\n    return (TreeElement)dummyRoot.getFirstChildNode();\n  }","id":25715,"modified_method":"public TreeElement parseExpressionText(final Lexer originalLexer,\n                                         final char[] buffer,\n                                         final int startOffset,\n                                         final int endOffset,\n                                         PsiManager manager) {\n    FilterLexer lexer = new FilterLexer(originalLexer, new FilterLexer.SetFilter(WHITE_SPACE_OR_COMMENT_BIT_SET));\n    lexer.start(buffer, startOffset, endOffset);\n    CharTable table = myContext.getCharTable();\n    final FileElement dummyRoot = new DummyHolder(manager, null, table).getTreeElement();\n    CompositeElement expression = parseExpression(lexer);\n    if (expression != null)\n      TreeUtil.addChildren(dummyRoot, expression);\n\n    if(lexer.getTokenType() != null){\n      final CompositeElement errorElement = Factory.createErrorElement(\"Unexpected tokens\");\n      TreeUtil.addChildren(dummyRoot, errorElement);\n      while(lexer.getTokenType() != null){\n        TreeUtil.addChildren(errorElement, ParseUtil.createTokenElement(lexer, table));\n        lexer.advance();\n      }\n    }\n\n    ParseUtil.insertMissingTokens(dummyRoot, originalLexer, 0, buffer.length, -1, ParseUtil.WhiteSpaceAndCommentsProcessor.INSTANCE, myContext);\n    return dummyRoot.getFirstChildNode();\n  }","commit_id":"450f0c330c815e728adbb998ae28905ebef738b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private CompositeElement parseNewExpression(FilterLexer lexer,\n                                              TreeElement qualifier,\n                                              TreeElement dot/*, TreeElement referenceParameterList*/) {\n    LOG.assertTrue(lexer.getTokenType() == NEW_KEYWORD);\n\n    CompositeElement element = Factory.createCompositeElement(NEW_EXPRESSION);\n\n    if (qualifier != null) {\n      TreeUtil.addChildren(element, qualifier);\n      TreeUtil.addChildren(element, dot);\n    }\n\n    TreeUtil.addChildren(element, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n    lexer.advance();\n    TreeUtil.addChildren(element, parseReferenceParameterList(lexer, false));\n\n    boolean isPrimitive;\n    TreeElement refOrType;\n    if (lexer.getTokenType() == IDENTIFIER) {\n      isPrimitive = false;\n      refOrType = parseJavaCodeReference(lexer, true, true);\n    }\n    else if (lexer.getTokenType() != null && PRIMITIVE_TYPE_BIT_SET.contains(lexer.getTokenType())) {\n      isPrimitive = true;\n      refOrType = ParseUtil.createTokenElement(lexer, myContext.getCharTable());\n      lexer.advance();\n    }\n    else {\n      TreeUtil.addChildren(element, Factory.createErrorElement(JavaErrorMessages.message(\"expected.identifier\")));\n      return element;\n    }\n\n    if (!isPrimitive && lexer.getTokenType() == LPARENTH) {\n      TreeElement argumentList = parseArgumentList(lexer);\n      if (lexer.getTokenType() == LBRACE && refOrType.getElementType() == JAVA_CODE_REFERENCE) { // anonymous class\n        CompositeElement classElement = Factory.createCompositeElement(ANONYMOUS_CLASS);\n        TreeUtil.addChildren(element, classElement);\n        TreeUtil.addChildren(classElement, refOrType);\n        TreeUtil.addChildren(classElement, argumentList);\n        myContext.getDeclarationParsing().parseClassBodyWithBraces(classElement, lexer, false, false);\n      }\n      else {\n        TreeUtil.addChildren(element, refOrType);\n        TreeUtil.addChildren(element, argumentList);\n      }\n    }\n    else {\n      TreeUtil.addChildren(element, refOrType);\n\n      if (lexer.getTokenType() != LBRACKET) {\n        String description = isPrimitive ?\n                             JavaErrorMessages.message(\"expected.lbracket\") :\n                             JavaErrorMessages.message(\"expected.lparen.or.lbracket\");\n        TreeUtil.addChildren(element, Factory.createErrorElement(description));\n        return element;\n      }\n\n      int bracketCount = 0;\n      int dimCount = 0;\n      while (true) {\n        if (lexer.getTokenType() != LBRACKET) break;\n\n        TreeUtil.addChildren(element, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n        lexer.advance();\n\n        TreeElement dimExpr = null;\n        if (bracketCount == dimCount) {\n          dimExpr = parseExpression(lexer);\n          if (dimExpr != null) {\n            TreeUtil.addChildren(element, dimExpr);\n            dimCount++;\n          }\n        }\n        bracketCount++;\n\n        if (lexer.getTokenType() != RBRACKET) {\n          TreeUtil.addChildren(element, Factory.createErrorElement(JavaErrorMessages.message(\"expected.rbracket\")));\n          return element;\n        }\n\n        TreeUtil.addChildren(element, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n        lexer.advance();\n      }\n\n      if (dimCount == 0) {\n        if (lexer.getTokenType() == LBRACE) {\n          TreeElement initializer = parseArrayInitializerExpression(lexer);\n          if (initializer != null) {\n            TreeUtil.addChildren(element, initializer);\n          }\n        }\n        else {\n          TreeUtil.addChildren(element, Factory.createErrorElement(JavaErrorMessages.message(\"expected.array.initializer\")));\n        }\n      }\n    }\n\n    return element;\n  }","id":25716,"modified_method":"private CompositeElement parseNewExpression(FilterLexer lexer,\n                                              TreeElement qualifier,\n                                              TreeElement dot/*, TreeElement referenceParameterList*/) {\n    LOG.assertTrue(lexer.getTokenType() == NEW_KEYWORD);\n\n    CompositeElement element = Factory.createCompositeElement(NEW_EXPRESSION);\n\n    if (qualifier != null) {\n      TreeUtil.addChildren(element, qualifier);\n      TreeUtil.addChildren(element, dot);\n    }\n\n    TreeUtil.addChildren(element, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n    lexer.advance();\n    TreeUtil.addChildren(element, parseReferenceParameterList(lexer, false));\n\n    boolean isPrimitive;\n    TreeElement refOrType;\n    if (lexer.getTokenType() == IDENTIFIER) {\n      isPrimitive = false;\n      refOrType = parseJavaCodeReference(lexer, true, true);\n    }\n    else if (lexer.getTokenType() != null && PRIMITIVE_TYPE_BIT_SET.contains(lexer.getTokenType())) {\n      isPrimitive = true;\n      refOrType = ParseUtil.createTokenElement(lexer, myContext.getCharTable());\n      lexer.advance();\n    }\n    else {\n      TreeUtil.addChildren(element, Factory.createErrorElement(JavaErrorMessages.message(\"expected.identifier\")));\n      return element;\n    }\n\n    if (!isPrimitive && lexer.getTokenType() == LPARENTH) {\n      TreeElement argumentList = parseArgumentList(lexer);\n      if (lexer.getTokenType() == LBRACE && refOrType.getElementType() == JAVA_CODE_REFERENCE) { // anonymous class\n        CompositeElement classElement = Factory.createCompositeElement(ANONYMOUS_CLASS);\n        TreeUtil.addChildren(element, classElement);\n        TreeUtil.addChildren(classElement, refOrType);\n        TreeUtil.addChildren(classElement, argumentList);\n        myContext.getDeclarationParsing().parseClassBodyWithBraces(classElement, lexer, false, false);\n      }\n      else {\n        TreeUtil.addChildren(element, refOrType);\n        TreeUtil.addChildren(element, argumentList);\n      }\n    }\n    else {\n      TreeUtil.addChildren(element, refOrType);\n\n      if (lexer.getTokenType() != LBRACKET) {\n        String description = isPrimitive ?\n                             JavaErrorMessages.message(\"expected.lbracket\") :\n                             JavaErrorMessages.message(\"expected.lparen.or.lbracket\");\n        TreeUtil.addChildren(element, Factory.createErrorElement(description));\n        return element;\n      }\n\n      int bracketCount = 0;\n      int dimCount = 0;\n      while (true) {\n        if (lexer.getTokenType() != LBRACKET) break;\n\n        TreeUtil.addChildren(element, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n        lexer.advance();\n\n        TreeElement dimExpr;\n        if (bracketCount == dimCount) {\n          dimExpr = parseExpression(lexer);\n          if (dimExpr != null) {\n            TreeUtil.addChildren(element, dimExpr);\n            dimCount++;\n          }\n        }\n        bracketCount++;\n\n        if (lexer.getTokenType() != RBRACKET) {\n          TreeUtil.addChildren(element, Factory.createErrorElement(JavaErrorMessages.message(\"expected.rbracket\")));\n          return element;\n        }\n\n        TreeUtil.addChildren(element, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n        lexer.advance();\n      }\n\n      if (dimCount == 0) {\n        if (lexer.getTokenType() == LBRACE) {\n          TreeElement initializer = parseArrayInitializerExpression(lexer);\n          if (initializer != null) {\n            TreeUtil.addChildren(element, initializer);\n          }\n        }\n        else {\n          TreeUtil.addChildren(element, Factory.createErrorElement(JavaErrorMessages.message(\"expected.array.initializer\")));\n        }\n      }\n    }\n\n    return element;\n  }","commit_id":"450f0c330c815e728adbb998ae28905ebef738b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeElement parseExpressionTextFragment(PsiManager manager, char[] buffer, int startOffset, int endOffset, int state) {\n    Lexer originalLexer = new JavaLexer(manager.getEffectiveLanguageLevel());\n    FilterLexer lexer = new FilterLexer(originalLexer, new FilterLexer.SetFilter(WHITE_SPACE_OR_COMMENT_BIT_SET));\n    if (state >= 0) {\n      lexer.start(buffer, startOffset, endOffset, state);\n    }\n    else {\n      lexer.start(buffer, startOffset, endOffset);\n    }\n\n    final FileElement dummyRoot = new DummyHolder(manager, null, myContext.getCharTable()).getTreeElement();\n\n    CompositeElement expression = parseExpression(lexer);\n    if (expression != null) {\n      TreeUtil.addChildren(dummyRoot, expression);\n    }\n\n    if (lexer.getTokenType() != null) {\n      TreeUtil.addChildren(dummyRoot, Factory.createErrorElement(JavaErrorMessages.message(\"unexpected.tokens.beyond.the.end.of.expression\")));\n      while (lexer.getTokenType() != null) {\n        TreeUtil.addChildren(dummyRoot, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n        lexer.advance();\n      }\n    }\n\n    ParseUtil.insertMissingTokens(dummyRoot, originalLexer, 0, buffer.length, state, ParseUtil.WhiteSpaceAndCommentsProcessor.INSTANCE,\n                                  myContext);\n    return (TreeElement)dummyRoot.getFirstChildNode();\n  }","id":25717,"modified_method":"public TreeElement parseExpressionTextFragment(PsiManager manager, char[] buffer, int startOffset, int endOffset, int state) {\n    Lexer originalLexer = new JavaLexer(manager.getEffectiveLanguageLevel());\n    FilterLexer lexer = new FilterLexer(originalLexer, new FilterLexer.SetFilter(WHITE_SPACE_OR_COMMENT_BIT_SET));\n    if (state >= 0) {\n      lexer.start(buffer, startOffset, endOffset, state);\n    }\n    else {\n      lexer.start(buffer, startOffset, endOffset);\n    }\n\n    final FileElement dummyRoot = new DummyHolder(manager, null, myContext.getCharTable()).getTreeElement();\n\n    CompositeElement expression = parseExpression(lexer);\n    if (expression != null) {\n      TreeUtil.addChildren(dummyRoot, expression);\n    }\n\n    if (lexer.getTokenType() != null) {\n      TreeUtil.addChildren(dummyRoot, Factory.createErrorElement(JavaErrorMessages.message(\"unexpected.tokens.beyond.the.end.of.expression\")));\n      while (lexer.getTokenType() != null) {\n        TreeUtil.addChildren(dummyRoot, ParseUtil.createTokenElement(lexer, myContext.getCharTable()));\n        lexer.advance();\n      }\n    }\n\n    ParseUtil.insertMissingTokens(dummyRoot, originalLexer, 0, buffer.length, state, ParseUtil.WhiteSpaceAndCommentsProcessor.INSTANCE,\n                                  myContext);\n    return dummyRoot.getFirstChildNode();\n  }","commit_id":"450f0c330c815e728adbb998ae28905ebef738b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JavaImportListElementType() {\n    super(\"IMPORT_LIST\", true);\n  }","id":25718,"modified_method":"public JavaImportListElementType() {\n    super(\"IMPORT_LIST\");\n  }","commit_id":"047bbdd65d56bb18bb5a38a7521894f7b18cda03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void bindPrecedingComment(TreeElement comment, ASTNode bindTo) {\n      if (bindTo == null ||\n          !BIND_PRECEDING_COMMENT_BIT_SET.contains(bindTo.getElementType()) ||\n          (bindTo.getFirstChildNode() != null && bindTo.getFirstChildNode().getElementType() == JavaDocElementType.DOC_COMMENT) ||\n          !isBindingComment(comment)) return;\n\n      final TreeElement first = (TreeElement)bindTo.getFirstChildNode();\n      TreeElement child = comment;\n      while (child != bindTo) {\n        final TreeElement next = child.getTreeNext();\n        child.rawRemove();\n        first.rawInsertBeforeMe(child);\n        child = next;\n      }\n    }","id":25719,"modified_method":"private static void bindPrecedingComment(TreeElement comment, ASTNode bindTo) {\n      if (bindTo == null ||\n          !BIND_PRECEDING_COMMENT_BIT_SET.contains(bindTo.getElementType()) ||\n          (bindTo.getFirstChildNode() != null && bindTo.getFirstChildNode().getElementType() == JavaDocElementType.DOC_COMMENT) ||\n          !isBindingComment(comment)) return;\n\n      final TreeElement first = (TreeElement)bindTo.getFirstChildNode();\n      TreeElement child = comment;\n      while (child != bindTo) {\n        final TreeElement next = child.getTreeNext();\n        if (!isEmptyImportList(child)) {\n          child.rawRemove();\n          first.rawInsertBeforeMe(child);\n        }\n        child = next;\n      }\n    }","commit_id":"047bbdd65d56bb18bb5a38a7521894f7b18cda03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void bindComments(ASTNode root) {\n      if (TreeUtil.isLeafOrCollapsedChameleon(root)) return;\n\n      final List<ASTNode> comments = new SmartList<ASTNode>();\n      ((TreeElement)root).acceptTree(new RecursiveTreeElementWalkingVisitor(false) {\n        @Override\n        protected void visitNode(TreeElement child) {\n          if (ElementType.JAVA_COMMENT_BIT_SET.contains(child.getElementType())) {\n            comments.add(child);\n          }\n          if (TreeUtil.isLeafOrCollapsedChameleon(child)) return;\n\n          super.visitNode(child);\n        }\n      });\n      ListIterator<ASTNode> iterator;\n\n      // we'll only bind additional preceding comments in pass 2 when the declaration does not yet have a \"doc comment\"\n      iterator = comments.listIterator();\n      while (iterator.hasNext()) {\n        ASTNode child = iterator.next();\n        IElementType type = child.getElementType();\n        if (type == JavaDocElementType.DOC_COMMENT) {\n          if (bindDocComment((TreeElement)child)) iterator.remove();\n        }\n        // bind \"trailing comments\" (like \"int a; // comment\")\n        else if (type == JavaTokenType.END_OF_LINE_COMMENT || type == JavaTokenType.C_STYLE_COMMENT) {\n          if (bindTrailingComment((TreeElement)child)) iterator.remove();\n        }\n      }\n\n      // pass 2: bind preceding comments (like \"// comment \\n void f();\")\n      iterator = comments.listIterator(comments.size());\n      while (iterator.hasPrevious()) {\n        ASTNode child = iterator.previous();\n        TreeElement next = (TreeElement)TreeUtil.skipElements(child.getTreeNext(), ElementType.JAVA_WHITESPACE_BIT_SET);\n        bindPrecedingComment((TreeElement)child, next);\n      }\n    }","id":25720,"modified_method":"private static void bindComments(ASTNode root) {\n      if (TreeUtil.isLeafOrCollapsedChameleon(root)) return;\n\n      final List<ASTNode> comments = new SmartList<ASTNode>();\n      ((TreeElement)root).acceptTree(new RecursiveTreeElementWalkingVisitor(false) {\n        @Override\n        protected void visitNode(TreeElement child) {\n          if (ElementType.JAVA_COMMENT_BIT_SET.contains(child.getElementType())) {\n            comments.add(child);\n          }\n          if (TreeUtil.isLeafOrCollapsedChameleon(child)) return;\n\n          super.visitNode(child);\n        }\n      });\n      ListIterator<ASTNode> iterator;\n\n      // we'll only bind additional preceding comments in pass 2 when the declaration does not yet have a \"doc comment\"\n      iterator = comments.listIterator();\n      while (iterator.hasNext()) {\n        ASTNode comment = iterator.next();\n        IElementType type = comment.getElementType();\n        if (type == JavaDocElementType.DOC_COMMENT) {\n          if (bindDocComment((TreeElement)comment)) iterator.remove();\n        }\n        // bind \"trailing comments\" (like \"int a; // comment\")\n        else if (type == JavaTokenType.END_OF_LINE_COMMENT || type == JavaTokenType.C_STYLE_COMMENT) {\n          if (bindTrailingComment((TreeElement)comment)) iterator.remove();\n        }\n      }\n\n      // pass 2: bind preceding comments (like \"// comment \\n void f();\")\n      iterator = comments.listIterator(comments.size());\n      while (iterator.hasPrevious()) {\n        final ASTNode comment = iterator.previous();\n\n        TreeElement next = (TreeElement)TreeUtil.skipElements(comment.getTreeNext(), ElementType.JAVA_WHITESPACE_BIT_SET);\n        if (next != null && isEmptyImportList(next)) {\n          next = (TreeElement)TreeUtil.skipElements(next.getTreeNext(), ElementType.JAVA_WHITESPACE_BIT_SET);\n        }\n\n        bindPrecedingComment((TreeElement)comment, next);\n      }\n    }","commit_id":"047bbdd65d56bb18bb5a38a7521894f7b18cda03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void moveEmptyImportList(ASTNode root) {\n      TreeElement first = (TreeElement)root.getFirstChildNode();\n      TreeElement next = (TreeElement)TreeUtil.skipElements(first, ElementType.JAVA_COMMENT_OR_WHITESPACE_BIT_SET);\n      if (next == null) return;\n\n      if (next.getElementType() == JavaElementType.PACKAGE_STATEMENT) {\n        first = next.getTreeNext();\n        next = (TreeElement)TreeUtil.skipElements(first, ElementType.JAVA_COMMENT_OR_WHITESPACE_BIT_SET);\n      }\n\n      if (next != null && next != first && isEmptyImportList(next)) {\n        next.rawRemove();\n        first.rawInsertBeforeMe(next);\n      }\n    }","id":25721,"modified_method":"private static void moveEmptyImportList(final ASTNode root) {\n      final TreeElement anImport = (TreeElement)TreeUtil.skipElements(root.getFirstChildNode(), BEFORE_IMPORT_BIT_SET);\n      if (anImport == null || !isEmptyImportList(anImport)) return;\n\n      final TreeElement next = (TreeElement)TreeUtil.skipElements(anImport.getTreeNext(), ElementType.JAVA_COMMENT_OR_WHITESPACE_BIT_SET);\n      if (next != null && next != anImport) {\n        anImport.rawRemove();\n        next.rawInsertBeforeMe(anImport);\n      }\n    }","commit_id":"047bbdd65d56bb18bb5a38a7521894f7b18cda03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isBindingComment(final ASTNode comment) {\n      ASTNode prev = comment.getTreePrev();\n      if (isEmptyImportList(prev)) prev = prev.getTreePrev();\n      final boolean prevOk = prev == null ||\n                             (prev.getElementType() == TokenType.WHITE_SPACE && prev.textContains('\\n'));\n\n      final ASTNode next = comment.getTreeNext();\n      final boolean nextOk = next != null &&\n                             next.getElementType() == TokenType.WHITE_SPACE &&\n                             StringUtil.getLineBreakCount(next.getText()) < 2;\n\n      return prevOk && nextOk;\n    }","id":25722,"modified_method":"private static boolean isBindingComment(final ASTNode comment) {\n      final ASTNode prev = comment.getTreePrev();\n      final boolean prevOk = prev == null ||\n                             (prev.getElementType() == TokenType.WHITE_SPACE && prev.textContains('\\n'));\n\n      final ASTNode next = comment.getTreeNext();\n      final boolean nextOk = next != null &&\n                             (next.getElementType() != TokenType.WHITE_SPACE || StringUtil.getLineBreakCount(next.getText()) < 2);\n\n      return prevOk && nextOk;\n    }","commit_id":"047bbdd65d56bb18bb5a38a7521894f7b18cda03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Before\n   public void beforeMethod()\n   {\n      homePage = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n   }","id":25723,"modified_method":"@Before\n   public void beforeMethod()\n   {\n      dashboardPage = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public ManageLanguagePage goToManageLanguagePage()\n   {\n      manageLanguagePage = homePage.goToAdministration().goToManageLanguagePage();\n      return manageLanguagePage;\n   }","id":25724,"modified_method":"public ManageLanguagePage goToManageLanguagePage()\n   {\n      manageLanguagePage = dashboardPage.goToAdministration().goToManageLanguagePage();\n      return manageLanguagePage;\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void changePasswordCancel()\n   {\n      MyAccountPage myAccountPage = new LoginWorkFlow().signIn(\"translator\", \"translator\")\n            .goToMyProfile()\n            .goToChangePassword()\n            .enterOldPassword(\"translator\")\n            .enterNewPassword(\"notnewpassword\")\n            .enterConfirmNewPassword(\"notnewpassword\")\n            .cancelChangePassword();\n\n      HomePage homePage = myAccountPage.logout();\n      assertThat(\"User is logged out\", !homePage.hasLoggedIn());\n      homePage = new LoginWorkFlow().signIn(\"translator\", \"translator\");\n      assertThat(\"User has logged in with the original password\", homePage.hasLoggedIn());\n   }","id":25725,"modified_method":"@Test\n   public void changePasswordCancel()\n   {\n      MyAccountPage myAccountPage = new LoginWorkFlow().signIn(\"translator\", \"translator\")\n            .goToMyProfile()\n            .goToChangePassword()\n            .enterOldPassword(\"translator\")\n            .enterNewPassword(\"notnewpassword\")\n            .enterConfirmNewPassword(\"notnewpassword\")\n            .cancelChangePassword();\n\n      HomePage homePage = myAccountPage.logout();\n      assertThat(\"User is logged out\", !homePage.hasLoggedIn());\n      DashboardPage dashboardPage = new LoginWorkFlow().signIn(\"translator\", \"translator\");\n      assertThat(\"User has logged in with the original password\", dashboardPage.hasLoggedIn());\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   @Category(BasicAcceptanceTest.class)\n   public void changePasswordSuccessful()\n   {\n      MyAccountPage myAccountPage = new LoginWorkFlow().signIn(\"translator\", \"translator\")\n            .goToMyProfile()\n            .goToChangePassword()\n            .enterOldPassword(\"translator\")\n            .enterNewPassword(\"newpassword\")\n            .enterConfirmNewPassword(\"newpassword\")\n            .changePassword();\n\n      assertThat(\"Confirmation message is displayed\", myAccountPage.getNotificationMessage(),\n            Matchers.equalTo(\"Your password has been successfully changed.\"));\n\n      HomePage homePage = myAccountPage.logout();\n      assertThat(\"User is logged out\", !homePage.hasLoggedIn());\n      homePage = new LoginWorkFlow().signIn(\"translator\", \"newpassword\");\n      assertThat(\"User has logged in with the new password\", homePage.hasLoggedIn());\n   }","id":25726,"modified_method":"@Test\n   @Category(BasicAcceptanceTest.class)\n   public void changePasswordSuccessful()\n   {\n      MyAccountPage myAccountPage = new LoginWorkFlow().signIn(\"translator\", \"translator\")\n            .goToMyProfile()\n            .goToChangePassword()\n            .enterOldPassword(\"translator\")\n            .enterNewPassword(\"newpassword\")\n            .enterConfirmNewPassword(\"newpassword\")\n            .changePassword();\n\n      assertThat(\"Confirmation message is displayed\", myAccountPage.getNotificationMessage(),\n            Matchers.equalTo(\"Your password has been successfully changed.\"));\n\n      HomePage homePage = myAccountPage.logout();\n      assertThat(\"User is logged out\", !homePage.hasLoggedIn());\n      DashboardPage dashboardPage = new LoginWorkFlow().signIn(\"translator\", \"newpassword\");\n      assertThat(\"User has logged in with the new password\", dashboardPage.hasLoggedIn());\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean hasMyActivitiesSection()\n   {\n      return homePage.containActivityListSection();\n   }","id":25727,"modified_method":"public boolean hasMyActivitiesSection()\n   {\n      return dashboardPage.containActivityListSection();\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean maintainedProjectNotEmpty()\n   {\n      return !homePage.getMyMaintainedProject().isEmpty();\n   }","id":25728,"modified_method":"public boolean maintainedProjectNotEmpty()\n   {\n      return !dashboardPage.getMyMaintainedProject().isEmpty();\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean myActivitiesListNotEmpty()\n   {\n      return !homePage.getMyActivityList().isEmpty();\n   }","id":25729,"modified_method":"public boolean myActivitiesListNotEmpty()\n   {\n      return !dashboardPage.getMyActivityList().isEmpty();\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public int myActivitiesCount()\n   {\n      return homePage.getMyActivityList().size();\n   }","id":25730,"modified_method":"public int myActivitiesCount()\n   {\n      return dashboardPage.getMyActivityList().size();\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean myActivitiesCountIsMoreThan(int compareTo)\n   {\n      return homePage.getMyActivityList().size() > compareTo;\n   }","id":25731,"modified_method":"public boolean myActivitiesCountIsMoreThan(int compareTo)\n   {\n      return dashboardPage.getMyActivityList().size() > compareTo;\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void clickMoreActivity()\n   {\n      homePage.clickMoreActivity();\n   }","id":25732,"modified_method":"public void clickMoreActivity()\n   {\n      dashboardPage.clickMoreActivity();\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean hasMaintainedProjectsSection()\n   {\n      return homePage.containMyMaintainedProjectsSection();\n   }","id":25733,"modified_method":"public boolean hasMaintainedProjectsSection()\n   {\n      return dashboardPage.containMyMaintainedProjectsSection();\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean signInAs(String username, String password)\n   {\n      homePage = new LoginWorkFlow().signIn(username, password);\n\n      return homePage.hasLoggedIn();\n   }","id":25734,"modified_method":"public boolean signInAs(String username, String password)\n   {\n      dashboardPage = new LoginWorkFlow().signIn(username, password);\n\n      return dashboardPage.hasLoggedIn();\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean signInAs(String username, String password)\n   {\n      HomePage homePage = new LoginWorkFlow().signIn(username, password);\n\n      return homePage.hasLoggedIn();\n   }","id":25735,"modified_method":"public boolean signInAs(String username, String password)\n   {\n      DashboardPage dashboardPage = new LoginWorkFlow().signIn(username, password);\n\n      return dashboardPage.hasLoggedIn();\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   @Ignore(\"Cannot access the editor via WebDriver\")\n   public void goToEditPageContent()\n   {\n      EditHomeContentPage editHomeContentPage = new LoginWorkFlow().signIn(\"admin\", \"admin\").goToEditPageContent();\n      assertThat(\"Correct page\", editHomeContentPage.getTitle(), Matchers.equalTo(\"Zanata: Edit Home Page\"));\n      editHomeContentPage = editHomeContentPage.enterText(\"Test\");\n      HomePage homePage = editHomeContentPage.update();\n      editHomeContentPage = homePage.goToEditPageContent();\n      editHomeContentPage.cancelUpdate();\n   }","id":25736,"modified_method":"@Test\n   @Ignore(\"Cannot access the editor via WebDriver\")\n   public void goToEditPageContent()\n   {\n      DashboardPage dashboard = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n      EditHomeContentPage editHomeContentPage = dashboard.goToHomePage().goToEditPageContent();\n\n      assertThat(\"Correct page\", editHomeContentPage.getTitle(), Matchers.equalTo(\"Zanata: Edit Home Page\"));\n      editHomeContentPage = editHomeContentPage.enterText(\"Test\");\n      HomePage homePage = editHomeContentPage.update();\n      editHomeContentPage = homePage.goToEditPageContent();\n      editHomeContentPage.cancelUpdate();\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(expected = AssertionError.class) // RHBZ-988162 - not updating immediately\n  \n   public void goToEditPageCode()\n   {\n      EditHomeCodePage editHomeCodePage = new LoginWorkFlow().signIn(\"admin\", \"admin\").goToEditPageCode();\n      assertThat(\"Correct page\", editHomeCodePage.getTitle(), Matchers.equalTo(\"Zanata: Edit Page Code\"));\n      HomePage homePage  = editHomeCodePage.enterText(\"Test\").update();\n      assertThat(\"Message displayed\", homePage.getNotificationMessage(),\n            Matchers.equalTo(\"Home content was successfully updated.\"));\n      editHomeCodePage = homePage.goToEditPageCode();\n      homePage = editHomeCodePage.cancelUpdate();\n      assertThat(\"Homepage text has been updated\", homePage.getMainBodyContent(), Matchers.equalTo(\"Test\"));\n   }","id":25737,"modified_method":"public void goToEditPageCode()\n   {\n      DashboardPage dashboard = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n      EditHomeCodePage editHomeCodePage = dashboard.goToHomePage().goToEditPageCode();\n\n      assertThat(\"Correct page\", editHomeCodePage.getTitle(), Matchers.equalTo(\"Zanata: Edit Page Code\"));\n      HomePage homePage = editHomeCodePage.enterText(\"Test\").update();\n      assertThat(\"Message displayed\", homePage.getNotificationMessage(),\n            Matchers.equalTo(\"Home content was successfully updated.\"));\n      editHomeCodePage = homePage.goToEditPageCode();\n      homePage = editHomeCodePage.cancelUpdate();\n      assertThat(\"Homepage text has been updated\", homePage.getMainBodyContent(), Matchers.equalTo(\"Test\"));\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean signInAs(String username, String password)\n   {\n      HomePage homePage = new LoginWorkFlow().signIn(username, password);\n\n      return homePage.hasLoggedIn();\n   }","id":25738,"modified_method":"public boolean signInAs(String username, String password)\n   {\n      DashboardPage dashboardPage = new LoginWorkFlow().signIn(username, password);\n\n      return dashboardPage.hasLoggedIn();\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public HomePage signIn(String username, String password)\n   {\n      // System.getProperties().put(\"webdriver.firefox.useExisting\", \"true\");\n      log.info(\"accessing zanata at: {}\", hostUrl);\n\n      HomePage homePage = new HomePage(driver);\n      if (homePage.hasLoggedIn())\n      {\n         log.info(\"already logged in as {}\", username);\n         if (homePage.loggedInAs().equals(username))\n         {\n            return homePage;\n         }\n         log.info(\"sign out first then sign back in as {}\", username);\n         homePage = homePage.logout();\n      }\n\n      SignInPage signInPage = homePage.clickSignInLink();\n      return signInPage.signInAndGoToPage(username, password, HomePage.class);\n   }","id":25739,"modified_method":"public DashboardPage signIn(String username, String password)\n   {\n      log.info(\"accessing zanata at: {}\", hostUrl);\n\n      DashboardPage dashboardPage = new DashboardPage(driver);\n      if (dashboardPage.hasLoggedIn())\n      {\n         log.info(\"already logged in as {}\", username);\n         if (dashboardPage.loggedInAs().equals(username))\n         {\n            return dashboardPage;\n         }\n         log.info(\"sign out first then sign back in as {}\", username);\n         dashboardPage.logout();\n      }\n\n      SignInPage signInPage = dashboardPage.clickSignInLink();\n      return signInPage.signInAndGoToPage(username, password, DashboardPage.class);\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void changeAUsersUsername()\n   {\n      String username = \"administratornamechange\";\n      ManageUserPage manageUserPage = homePage.goToAdministration().goToManageUserPage();\n\n      ManageUserAccountPage manageUserAccountPage = manageUserPage.editUserAccount(\"admin\");\n      manageUserPage = manageUserAccountPage.clearFields().enterUsername(username).saveUser();\n      assertThat(\"Administrator is displayed\", manageUserPage.getUserList(), Matchers.hasItem(username));\n   }","id":25740,"modified_method":"@Test\n   public void changeAUsersUsername()\n   {\n      String username = \"administratornamechange\";\n      ManageUserPage manageUserPage = dashboardPage.goToAdministration().goToManageUserPage();\n\n      ManageUserAccountPage manageUserAccountPage = manageUserPage.editUserAccount(\"admin\");\n      manageUserPage = manageUserAccountPage.clearFields().enterUsername(username).saveUser();\n      assertThat(\"Administrator is displayed\", manageUserPage.getUserList(), Matchers.hasItem(username));\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Before\n   public void before()\n   {\n      homePage = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n   }","id":25741,"modified_method":"@Before\n   public void before()\n   {\n      dashboardPage = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public ManageUserPage goToUserAdministration()\n   {\n      return homePage.goToAdministration().goToManageUserPage();\n   }","id":25742,"modified_method":"public ManageUserPage goToUserAdministration()\n   {\n      return dashboardPage.goToAdministration().goToManageUserPage();\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Before\n   public void before()\n   {\n      homePage = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n   }","id":25743,"modified_method":"@Before\n   public void before()\n   {\n      dashboardPage = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   @Category(BasicAcceptanceTest.class)\n   public void signInSuccessful()\n   {\n      HomePage homePage = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n      assertThat(\"User is logged in\", homePage.loggedInAs(), Matchers.equalTo(\"admin\"));\n   }","id":25744,"modified_method":"@Test\n   @Category(BasicAcceptanceTest.class)\n   public void signInSuccessful()\n   {\n      DashboardPage dashboardPage = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n      assertThat(\"User is logged in\", dashboardPage.loggedInAs(), Matchers.equalTo(\"admin\"));\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Before\n   public void beforeMethod()\n   {\n      homePage = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n   }","id":25745,"modified_method":"@Before\n   public void beforeMethod()\n   {\n      dashboardPage = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void goToManageLanguagePage()\n   {\n      manageLanguagePage = homePage.goToAdministration().goToManageLanguagePage();\n   }","id":25746,"modified_method":"public void goToManageLanguagePage()\n   {\n      manageLanguagePage = dashboardPage.goToAdministration().goToManageLanguagePage();\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public VersionGroupsPage createNewVersionGroup(String groupId, String groupName, String groupDesc, String groupStatus)\n   {\n      VersionGroupsPage versionGroupsPage = homePage.goToGroups();\n      return versionGroupsPage.createNewGroup().inputGroupId(groupId).inputGroupName(groupName).inputGroupDescription(groupDesc).selectStatus(groupStatus).saveGroup();\n   }","id":25747,"modified_method":"public VersionGroupsPage createNewVersionGroup(String groupId, String groupName, String groupDesc, String groupStatus)\n   {\n      VersionGroupsPage versionGroupsPage = dashboardPage.goToGroups();\n      return versionGroupsPage.createNewGroup().inputGroupId(groupId).inputGroupName(groupName)\n            .inputGroupDescription(groupDesc).selectStatus(groupStatus).saveGroup();\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public CreateVersionGroupPage invalidCharacters(String groupId)\n   {\n      VersionGroupsPage versionGroupsPage = homePage.goToGroups();\n      // we toggle the status here to trigger and wait for the validation of group id to happen\n      return versionGroupsPage.createNewGroup().inputGroupId(groupId).selectStatus(\"OBSOLETE\").selectStatus(\"ACTIVE\");\n   }","id":25748,"modified_method":"public CreateVersionGroupPage invalidCharacters(String groupId)\n   {\n      VersionGroupsPage versionGroupsPage = dashboardPage.goToGroups();\n      // we toggle the status here to trigger and wait for the validation of group id to happen\n      return versionGroupsPage.createNewGroup().inputGroupId(groupId).selectStatus(\"OBSOLETE\").selectStatus(\"ACTIVE\");\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"public CreateVersionGroupPage groupIDAlreadyExists(String groupId, String groupName, String groupDesc, String groupStatus)\n   {\n      VersionGroupsPage versionGroupsPage = homePage.goToGroups();\n      List<String> groupNames = versionGroupsPage.getGroupNames();\n      assertThat(\"Group does not exist, preconditions not met\", groupNames.contains(groupName));\n      return versionGroupsPage.createNewGroup().inputGroupId(groupId).inputGroupName(groupName).inputGroupDescription(groupDesc).selectStatus(groupStatus).saveGroupFailure();\n   }","id":25749,"modified_method":"public CreateVersionGroupPage groupIDAlreadyExists(String groupId, String groupName, String groupDesc,\n         String groupStatus)\n   {\n      VersionGroupsPage versionGroupsPage = dashboardPage.goToGroups();\n      List<String> groupNames = versionGroupsPage.getGroupNames();\n      assertThat(\"Group does not exist, preconditions not met\", groupNames.contains(groupName));\n      return versionGroupsPage.createNewGroup().inputGroupId(groupId).inputGroupName(groupName)\n            .inputGroupDescription(groupDesc).selectStatus(groupStatus).saveGroupFailure();\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Before\n   public void before()\n   {\n      homePage = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n   }","id":25750,"modified_method":"@Before\n   public void before()\n   {\n      dashboardPage = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void groupIDFieldSize()\n   {\n      String errorMsg = \"size must be between 1 and 40\";\n      String groupID = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmno\";\n      String groupName = \"verifyIDFieldSizeName\";\n\n      CreateVersionGroupPage groupPage = homePage.goToGroups().createNewGroup();\n      groupPage.inputGroupId(groupID).inputGroupName(groupName).saveGroupFailure();\n      assertThat(\"Invalid length error is shown\", groupPage.getErrors(), Matchers.contains(errorMsg));\n\n      groupPage.clearFields();\n      groupID = groupID.substring(0, 40);\n      assertThat(\"GroupID is now 40 characters long\", groupID.length(), Matchers.equalTo(40));\n      groupPage.inputGroupId(groupID).inputGroupName(groupName);\n      VersionGroupsPage versionGroupsPage = groupPage.saveGroup();\n      assertThat(\"A group ID of 40 chars is valid\", versionGroupsPage.getGroupNames(), Matchers.hasItem(groupName));\n   }","id":25751,"modified_method":"@Test\n   public void groupIDFieldSize()\n   {\n      String errorMsg = \"size must be between 1 and 40\";\n      String groupID = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmno\";\n      String groupName = \"verifyIDFieldSizeName\";\n\n      CreateVersionGroupPage groupPage = dashboardPage.goToGroups().createNewGroup();\n      groupPage.inputGroupId(groupID).inputGroupName(groupName).saveGroupFailure();\n      assertThat(\"Invalid length error is shown\", groupPage.getErrors(), Matchers.contains(errorMsg));\n\n      groupPage.clearFields();\n      groupID = groupID.substring(0, 40);\n      assertThat(\"GroupID is now 40 characters long\", groupID.length(), Matchers.equalTo(40));\n      groupPage.inputGroupId(groupID).inputGroupName(groupName);\n      VersionGroupsPage versionGroupsPage = groupPage.saveGroup();\n      assertThat(\"A group ID of 40 chars is valid\", versionGroupsPage.getGroupNames(), Matchers.hasItem(groupName));\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Before\n   public void before()\n   {\n      homePage = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n   }","id":25752,"modified_method":"@Before\n   public void before()\n   {\n      dashboardPage = new LoginWorkFlow().signIn(\"admin\", \"admin\");\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void groupDescriptionFieldSize()\n   {\n      String errorMsg = \"size must be between 0 and 100\";\n      String groupID = \"verifyDescriptionFieldSizeID\";\n      String groupName = \"verifyDescriptionFieldSizeName\";\n      String groupDescription =\n         \"This text is to test that the description field takes no more than exactly 100 characters - actually.\";\n\n      assertThat(\"Description length is greater than 100 characters\", groupDescription.length(), Matchers.equalTo(101));\n      CreateVersionGroupPage groupPage = homePage.goToGroups().createNewGroup();\n      groupPage.inputGroupId(groupID).inputGroupName(groupName).inputGroupDescription(groupDescription);\n      groupPage.saveGroupFailure();\n      assertThat(\"Invalid length error is shown\", groupPage.getErrors(), Matchers.contains(errorMsg));\n\n      groupPage.clearFields();\n      groupDescription = groupDescription.substring(0, 100);\n      assertThat(\"Description length is now 100 characters\", groupDescription.length(), Matchers.equalTo(100));\n      groupPage.inputGroupId(\"verifyDescriptionFieldSizeID\").inputGroupName(groupName);\n      VersionGroupsPage verGroupsPage = groupPage.inputGroupDescription(groupDescription).saveGroup();\n      assertThat(\"A group description of 100 chars is valid\", verGroupsPage.getGroupNames(), Matchers.hasItem(groupName));\n\n   }","id":25753,"modified_method":"@Test\n   public void groupDescriptionFieldSize()\n   {\n      String errorMsg = \"size must be between 0 and 100\";\n      String groupID = \"verifyDescriptionFieldSizeID\";\n      String groupName = \"verifyDescriptionFieldSizeName\";\n      String groupDescription =\n         \"This text is to test that the description field takes no more than exactly 100 characters - actually.\";\n\n      assertThat(\"Description length is greater than 100 characters\", groupDescription.length(), Matchers.equalTo(101));\n      CreateVersionGroupPage groupPage = dashboardPage.goToGroups().createNewGroup();\n      groupPage.inputGroupId(groupID).inputGroupName(groupName).inputGroupDescription(groupDescription);\n      groupPage.saveGroupFailure();\n      assertThat(\"Invalid length error is shown\", groupPage.getErrors(), Matchers.contains(errorMsg));\n\n      groupPage.clearFields();\n      groupDescription = groupDescription.substring(0, 100);\n      assertThat(\"Description length is now 100 characters\", groupDescription.length(), Matchers.equalTo(100));\n      groupPage.inputGroupId(\"verifyDescriptionFieldSizeID\").inputGroupName(groupName);\n      VersionGroupsPage verGroupsPage = groupPage.inputGroupDescription(groupDescription).saveGroup();\n      assertThat(\"A group description of 100 chars is valid\", verGroupsPage.getGroupNames(), Matchers.hasItem(groupName));\n\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void requiredFields()\n   {\n      String errorMsg = \"value is required\";\n      String groupID = \"verifyRequiredFieldsGroupID\";\n      String groupName = \"verifyRequiredFieldsGroupName\";\n\n      CreateVersionGroupPage groupPage = homePage.goToGroups().createNewGroup().saveGroupFailure();\n      assertThat(\"The two errors are value is required\", groupPage.getErrors(), Matchers.contains(errorMsg, errorMsg));\n\n      groupPage = groupPage.clearFields().inputGroupName(groupName).saveGroupFailure();\n      assertThat(\"The value required error shown\", groupPage.getErrors(), Matchers.contains(errorMsg));\n\n      groupPage = groupPage.clearFields().inputGroupId(groupID).saveGroupFailure();\n      assertThat(\"The value required error shown\", groupPage.getErrors(), Matchers.contains(errorMsg));\n   }","id":25754,"modified_method":"@Test\n   public void requiredFields()\n   {\n      String errorMsg = \"value is required\";\n      String groupID = \"verifyRequiredFieldsGroupID\";\n      String groupName = \"verifyRequiredFieldsGroupName\";\n\n      CreateVersionGroupPage groupPage = dashboardPage.goToGroups().createNewGroup().saveGroupFailure();\n      assertThat(\"The two errors are value is required\", groupPage.getErrors(), Matchers.contains(errorMsg, errorMsg));\n\n      groupPage = groupPage.clearFields().inputGroupName(groupName).saveGroupFailure();\n      assertThat(\"The value required error shown\", groupPage.getErrors(), Matchers.contains(errorMsg));\n\n      groupPage = groupPage.clearFields().inputGroupId(groupID).saveGroupFailure();\n      assertThat(\"The value required error shown\", groupPage.getErrors(), Matchers.contains(errorMsg));\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   @Category(BasicAcceptanceTest.class)\n   public void createABasicGroup()\n   {\n      String groupID = \"basic-group\";\n      String groupName = \"A Basic Group\";\n\n      CreateVersionGroupPage createVersionGroupPage = homePage.goToGroups().createNewGroup();\n      createVersionGroupPage.inputGroupId(groupID);\n      createVersionGroupPage.inputGroupName(groupName);\n      createVersionGroupPage.inputGroupDescription(\"A basic group can be saved\");\n      createVersionGroupPage.selectStatus(\"ACTIVE\");\n      VersionGroupsPage versionGroupsPage = createVersionGroupPage.saveGroup();\n      assertThat(\"Group was created\", versionGroupsPage.getGroupNames().contains(groupName));\n      VersionGroupPage groupView = versionGroupsPage.goToGroup(groupName);\n      assertThat(\"The group is displayed\", groupView.getTitle(), Matchers.equalTo(\"Zanata: Groups:\".concat(groupName)));\n   }","id":25755,"modified_method":"@Test\n   @Category(BasicAcceptanceTest.class)\n   public void createABasicGroup()\n   {\n      String groupID = \"basic-group\";\n      String groupName = \"A Basic Group\";\n\n      CreateVersionGroupPage createVersionGroupPage = dashboardPage.goToGroups().createNewGroup();\n      createVersionGroupPage.inputGroupId(groupID);\n      createVersionGroupPage.inputGroupName(groupName);\n      createVersionGroupPage.inputGroupDescription(\"A basic group can be saved\");\n      createVersionGroupPage.selectStatus(\"ACTIVE\");\n      VersionGroupsPage versionGroupsPage = createVersionGroupPage.saveGroup();\n      assertThat(\"Group was created\", versionGroupsPage.getGroupNames().contains(groupName));\n      VersionGroupPage groupView = versionGroupsPage.goToGroup(groupName);\n      assertThat(\"The group is displayed\", groupView.getTitle(), Matchers.equalTo(\"Zanata: Groups:\".concat(groupName)));\n   }","commit_id":"5eeb1faedc6a8b5885e7a5be95e7352cdd021aa8","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Accepts submission from the configuration page.\n     */\n    @RequirePOST\n    public synchronized void doConfigSubmit(StaplerRequest req,\n            StaplerResponse rsp) throws IOException, ServletException, FormException {\n        checkPermission(CONFIGURE);\n\n        description = req.getParameter(\"description\");\n\n        keepDependencies = req.getParameter(\"keepDependencies\") != null;\n\n        try {\n            JSONObject json = req.getSubmittedForm();\n\n            setDisplayName(json.optString(\"displayNameOrNull\"));\n\n            if (json.optBoolean(\"logrotate\"))\n                logRotator = req.bindJSON(BuildDiscarder.class, json.optJSONObject(\"buildDiscarder\"));\n            else\n                logRotator = null;\n\n            DescribableList<JobProperty<?>, JobPropertyDescriptor> t = new DescribableList<JobProperty<?>, JobPropertyDescriptor>(NOOP,getAllProperties());\n            t.rebuild(req,json.optJSONObject(\"properties\"),JobPropertyDescriptor.getPropertyDescriptors(Job.this.getClass()));\n            properties.clear();\n            for (JobProperty p : t) {\n                p.setOwner(this);\n                properties.add(p);\n            }\n\n            submit(req, rsp);\n\n            save();\n            ItemListener.fireOnUpdated(this);\n\n            String newName = req.getParameter(\"name\");\n            final ProjectNamingStrategy namingStrategy = Jenkins.getInstance().getProjectNamingStrategy();\n            if (newName != null && !newName.equals(name)) {\n                // check this error early to avoid HTTP response splitting.\n                Jenkins.checkGoodName(newName);\n                namingStrategy.checkName(newName);\n                if (FormApply.isApply(req)) {\n                    FormApply.applyResponse(\"notificationBar.show(\" + QuotedStringTokenizer.quote(Messages.Job_you_must_use_the_save_button_if_you_wish()) + \",notificationBar.WARNING)\").generateResponse(req, rsp, null);\n                } else {\n                    rsp.sendRedirect(\"rename?newName=\" + URLEncoder.encode(newName, \"UTF-8\"));\n                }\n            } else {\n                if(namingStrategy.isForceExistingJobs()){\n                    namingStrategy.checkName(name);\n                }\n                FormApply.success(\".\").generateResponse(req, rsp, null);\n            }\n        } catch (JSONException e) {\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            pw.println(\"Failed to parse form data. Please report this problem as a bug\");\n            pw.println(\"JSON=\" + req.getSubmittedForm());\n            pw.println();\n            e.printStackTrace(pw);\n\n            rsp.setStatus(SC_BAD_REQUEST);\n            sendError(sw.toString(), req, rsp, true);\n        }\n    }","id":25756,"modified_method":"/**\n     * Accepts submission from the configuration page.\n     */\n    @RequirePOST\n    public synchronized void doConfigSubmit(StaplerRequest req,\n            StaplerResponse rsp) throws IOException, ServletException, FormException {\n        checkPermission(CONFIGURE);\n\n        description = req.getParameter(\"description\");\n\n        keepDependencies = req.getParameter(\"keepDependencies\") != null;\n\n        try {\n            JSONObject json = req.getSubmittedForm();\n\n            setDisplayName(json.optString(\"displayNameOrNull\"));\n\n            if (json.optBoolean(\"logrotate\"))\n                logRotator = req.bindJSON(BuildDiscarder.class, json.optJSONObject(\"buildDiscarder\"));\n            else\n                logRotator = null;\n\n            DescribableList<JobProperty<?>, JobPropertyDescriptor> t = new DescribableList<JobProperty<?>, JobPropertyDescriptor>(NOOP,getAllProperties());\n            JSONObject jsonProperties = json.optJSONObject(\"properties\");\n            if (jsonProperties != null) {\n              t.rebuild(req,jsonProperties,JobPropertyDescriptor.getPropertyDescriptors(Job.this.getClass()));\n            } else {\n              t.clear();\n            }\n            properties.clear();\n            for (JobProperty p : t) {\n                p.setOwner(this);\n                properties.add(p);\n            }\n\n            submit(req, rsp);\n\n            save();\n            ItemListener.fireOnUpdated(this);\n\n            String newName = req.getParameter(\"name\");\n            final ProjectNamingStrategy namingStrategy = Jenkins.getInstance().getProjectNamingStrategy();\n            if (newName != null && !newName.equals(name)) {\n                // check this error early to avoid HTTP response splitting.\n                Jenkins.checkGoodName(newName);\n                namingStrategy.checkName(newName);\n                if (FormApply.isApply(req)) {\n                    FormApply.applyResponse(\"notificationBar.show(\" + QuotedStringTokenizer.quote(Messages.Job_you_must_use_the_save_button_if_you_wish()) + \",notificationBar.WARNING)\").generateResponse(req, rsp, null);\n                } else {\n                    rsp.sendRedirect(\"rename?newName=\" + URLEncoder.encode(newName, \"UTF-8\"));\n                }\n            } else {\n                if(namingStrategy.isForceExistingJobs()){\n                    namingStrategy.checkName(name);\n                }\n                FormApply.success(\".\").generateResponse(req, rsp, null);\n            }\n        } catch (JSONException e) {\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            pw.println(\"Failed to parse form data. Please report this problem as a bug\");\n            pw.println(\"JSON=\" + req.getSubmittedForm());\n            pw.println();\n            e.printStackTrace(pw);\n\n            rsp.setStatus(SC_BAD_REQUEST);\n            sendError(sw.toString(), req, rsp, true);\n        }\n    }","commit_id":"b00aeddf4bc58a35d0aca67eced5ea89a78b1bf2","url":"https://github.com/kohsuke/hudson"},{"original_method":"public Map<PsiFile, Map<DependencyRule, Set<PsiFile>>> getIllegalDependencies(){\n    Map<PsiFile, Map<DependencyRule, Set<PsiFile>>> result = new HashMap<PsiFile, Map<DependencyRule, Set<PsiFile>>>();\n    DependencyValidationManager validator = DependencyValidationManager.getInstance(myProject);\n    for (PsiFile file : myDependencies.keySet()) {\n      Set<PsiFile> deps = myDependencies.get(file);\n      Map<DependencyRule, Set<PsiFile>> illegal = null;\n      for (PsiFile dependency : deps) {\n        final DependencyRule rule = isBackward() ?\n                                    validator.getViolatorDependencyRule(dependency, file) :\n                                    validator.getViolatorDependencyRule(file, dependency);\n        if (rule != null) {\n          if (illegal == null) {\n            illegal = new HashMap<DependencyRule, Set<PsiFile>>();\n            result.put(file, illegal);\n          }\n          Set<PsiFile> illegalFilesByRule = illegal.get(rule);\n          if (illegalFilesByRule == null) {\n            illegalFilesByRule = new HashSet<PsiFile>();\n          }\n          illegalFilesByRule.add(dependency);\n          illegal.put(rule, illegalFilesByRule);\n        }\n      }\n    }\n    return result;\n  }","id":25757,"modified_method":"public Map<PsiFile, Map<DependencyRule, Set<PsiFile>>> getIllegalDependencies(){\n    Map<PsiFile, Map<DependencyRule, Set<PsiFile>>> result = new HashMap<PsiFile, Map<DependencyRule, Set<PsiFile>>>();\n    DependencyValidationManager validator = DependencyValidationManager.getInstance(myProject);\n    for (PsiFile file : getDirectDependencies().keySet()) {\n      Set<PsiFile> deps = getDirectDependencies().get(file);\n      Map<DependencyRule, Set<PsiFile>> illegal = null;\n      for (PsiFile dependency : deps) {\n        final DependencyRule rule = isBackward() ?\n                                    validator.getViolatorDependencyRule(dependency, file) :\n                                    validator.getViolatorDependencyRule(file, dependency);\n        if (rule != null) {\n          if (illegal == null) {\n            illegal = new HashMap<DependencyRule, Set<PsiFile>>();\n            result.put(file, illegal);\n          }\n          Set<PsiFile> illegalFilesByRule = illegal.get(rule);\n          if (illegalFilesByRule == null) {\n            illegalFilesByRule = new HashSet<PsiFile>();\n          }\n          illegalFilesByRule.add(dependency);\n          illegal.put(rule, illegalFilesByRule);\n        }\n      }\n    }\n    return result;\n  }","commit_id":"3856b54911f2e6fb466169eab3fb2b5fd6bc01fe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n      final PackageDependenciesNode leftNode = myLeftTree.getSelectedNode();\n      final PackageDependenciesNode rightNode = myRightTree.getSelectedNode();\n      if (leftNode != null && rightNode != null) {\n        PackageSet leftPackageSet = ScopeEditorPanel.getNodePackageSet(leftNode, true);\n        if (leftPackageSet == null) {\n          leftPackageSet = ScopeEditorPanel.getNodePackageSet(leftNode, false);\n        }\n        LOG.assertTrue(leftPackageSet != null);\n        PackageSet rightPackageSet = ScopeEditorPanel.getNodePackageSet(rightNode, true);\n        if (rightPackageSet == null) {\n          rightPackageSet = ScopeEditorPanel.getNodePackageSet(rightNode, false);\n        }\n        LOG.assertTrue(rightPackageSet != null);\n        DependencyValidationManager.getInstance(myProject)\n          .addRule(new DependencyRule(new NamedScope.UnnamedScope(leftPackageSet),\n                                      new NamedScope.UnnamedScope(rightPackageSet), true));\n        rebuild();\n      }\n    }","id":25758,"modified_method":"public void actionPerformed(AnActionEvent e) {\n      final PackageDependenciesNode leftNode = myLeftTree.getSelectedNode();\n      final PackageDependenciesNode rightNode = myRightTree.getSelectedNode();\n      if (leftNode != null && rightNode != null) {\n        boolean hasDirectDependencies = !myTransitive;\n        if (myTransitive) {\n          final Set<PsiFile> searchIn = getSelectedScope(myLeftTree);\n          final Set<PsiFile> searchFor = getSelectedScope(myRightTree);\n          for (DependenciesBuilder builder : myBuilders) {\n            if (hasDirectDependencies) break;\n            for (PsiFile from : searchIn) {\n              if (hasDirectDependencies) break;\n              for (PsiFile to : searchFor) {\n                if (hasDirectDependencies) break;\n                final List<List<PsiFile>> paths = builder.findPaths(from, to);\n                for (List<PsiFile> path : paths) {\n                  if (path.isEmpty()) {\n                    hasDirectDependencies = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n        PackageSet leftPackageSet = ScopeEditorPanel.getNodePackageSet(leftNode, true);\n        if (leftPackageSet == null) {\n          leftPackageSet = ScopeEditorPanel.getNodePackageSet(leftNode, false);\n        }\n        LOG.assertTrue(leftPackageSet != null);\n        PackageSet rightPackageSet = ScopeEditorPanel.getNodePackageSet(rightNode, true);\n        if (rightPackageSet == null) {\n          rightPackageSet = ScopeEditorPanel.getNodePackageSet(rightNode, false);\n        }\n        LOG.assertTrue(rightPackageSet != null);\n        if (hasDirectDependencies) {\n          DependencyValidationManager.getInstance(myProject)\n            .addRule(new DependencyRule(new NamedScope.UnnamedScope(leftPackageSet),\n                                        new NamedScope.UnnamedScope(rightPackageSet), true));\n          rebuild();\n        } else {\n          Messages.showErrorDialog(DependenciesPanel.this, \"Rule was not added.\\n There is no direct dependency between \\'\" + leftPackageSet.getText() + \"\\' and \\'\" + rightPackageSet.getText() + \"\\'\",\n                                   AnalysisScopeBundle.message(\"mark.dependency.illegal.text\"));\n        }\n      }\n    }","commit_id":"3856b54911f2e6fb466169eab3fb2b5fd6bc01fe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public OIndexInternal<T> loadFromConfiguration(final ODocument iConfig) {\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      final ORID rid = (ORID) iConfig.field(CONFIG_MAP_RID, ORID.class);\r\n      if (rid == null)\r\n        throw new OIndexException(\"Error during deserialization of index definition: '\" + CONFIG_MAP_RID + \"' attribute is null\");\r\n\r\n      configuration = iConfig;\r\n      name = configuration.field(OIndexInternal.CONFIG_NAME);\r\n\r\n      final ODocument indexDefinitionDoc = configuration.field(OIndexInternal.INDEX_DEFINITION);\r\n      if (indexDefinitionDoc != null) {\r\n        try {\r\n          final String indexDefClassName = configuration.field(OIndexInternal.INDEX_DEFINITION_CLASS);\r\n          final Class<?> indexDefClass = Class.forName(indexDefClassName);\r\n          indexDefinition = (OIndexDefinition) indexDefClass.getDeclaredConstructor().newInstance();\r\n          indexDefinition.fromStream(indexDefinitionDoc);\r\n\r\n        } catch (final ClassNotFoundException e) {\r\n          throw new OIndexException(\"Error during deserialization of index definition\", e);\r\n        } catch (final NoSuchMethodException e) {\r\n          throw new OIndexException(\"Error during deserialization of index definition\", e);\r\n        } catch (final InvocationTargetException e) {\r\n          throw new OIndexException(\"Error during deserialization of index definition\", e);\r\n        } catch (final InstantiationException e) {\r\n          throw new OIndexException(\"Error during deserialization of index definition\", e);\r\n        } catch (final IllegalAccessException e) {\r\n          throw new OIndexException(\"Error during deserialization of index definition\", e);\r\n        }\r\n      } else {\r\n        // @COMPATIBILITY 1.0rc6 new index model was implemented\r\n        final Boolean isAutomatic = configuration.field(OIndexInternal.CONFIG_AUTOMATIC);\r\n        if (Boolean.TRUE.equals(isAutomatic)) {\r\n          final int pos = name.lastIndexOf('.');\r\n          if (pos < 0)\r\n            throw new OIndexException(\"Can not convert from old index model to new one. \"\r\n                + \"Invalid index name. Dot (.) separator should be present.\");\r\n          final String className = name.substring(0, pos);\r\n          final String propertyName = name.substring(pos + 1);\r\n\r\n          final String keyTypeStr = configuration.field(OIndexInternal.CONFIG_KEYTYPE);\r\n          if (keyTypeStr == null)\r\n            throw new OIndexException(\"Can not convert from old index model to new one. \" + \"Index key type is absent.\");\r\n          final OType keyType = OType.valueOf(keyTypeStr.toUpperCase(Locale.ENGLISH));\r\n          indexDefinition = new OPropertyIndexDefinition(className, propertyName, keyType);\r\n\r\n          configuration.removeField(OIndexInternal.CONFIG_AUTOMATIC);\r\n          configuration.removeField(OIndexInternal.CONFIG_KEYTYPE);\r\n        } else if (configuration.field(OIndexInternal.CONFIG_KEYTYPE) != null) {\r\n          final String keyTypeStr = configuration.field(OIndexInternal.CONFIG_KEYTYPE);\r\n          final OType keyType = OType.valueOf(keyTypeStr.toUpperCase(Locale.ENGLISH));\r\n\r\n          indexDefinition = new OSimpleKeyIndexDefinition(keyType);\r\n\r\n          configuration.removeField(OIndexInternal.CONFIG_KEYTYPE);\r\n        }\r\n      }\r\n\r\n      clustersToIndex.clear();\r\n      maxUpdatesBeforeSave = lazyUpdates();\r\n\r\n      final Collection<? extends String> clusters = configuration.field(CONFIG_CLUSTERS);\r\n      if (clusters != null)\r\n        clustersToIndex.addAll(clusters);\r\n\r\n      map = new OMVRBTreeDatabaseLazySave<Object, T>(getDatabase(), rid, maxUpdatesBeforeSave);\r\n      try {\r\n        map.load();\r\n      } catch (Exception e) {\r\n        if (onCorruptionRepairDatabase(null, \"load\", \"Index will be rebuilt\")) {\r\n          if (isAutomatic())\r\n            // AUTOMATIC REBUILD IT\r\n            OLogManager.instance().warn(this, \"Cannot load index '%s' from storage (rid=%s): rebuilt it from scratch\", getName(),\r\n                rid);\r\n          rebuild();\r\n        }\r\n      }\r\n\r\n      installHooks(iConfig.getDatabase());\r\n\r\n      return this;\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","id":25759,"modified_method":"public OIndexInternal<T> loadFromConfiguration(final ODocument iConfig) {\r\n    acquireExclusiveLock();\r\n    try {\r\n\r\n      final ORID rid = (ORID) iConfig.field(CONFIG_MAP_RID, ORID.class);\r\n      if (rid == null)\r\n        throw new OIndexException(\"Error during deserialization of index definition: '\" + CONFIG_MAP_RID + \"' attribute is null\");\r\n\r\n      configuration = iConfig;\r\n      name = configuration.field(OIndexInternal.CONFIG_NAME);\r\n\r\n      final ODocument indexDefinitionDoc = configuration.field(OIndexInternal.INDEX_DEFINITION);\r\n      if (indexDefinitionDoc != null) {\r\n        try {\r\n          final String indexDefClassName = configuration.field(OIndexInternal.INDEX_DEFINITION_CLASS);\r\n          final Class<?> indexDefClass = Class.forName(indexDefClassName);\r\n          indexDefinition = (OIndexDefinition) indexDefClass.getDeclaredConstructor().newInstance();\r\n          indexDefinition.fromStream(indexDefinitionDoc);\r\n\r\n        } catch (final ClassNotFoundException e) {\r\n          throw new OIndexException(\"Error during deserialization of index definition\", e);\r\n        } catch (final NoSuchMethodException e) {\r\n          throw new OIndexException(\"Error during deserialization of index definition\", e);\r\n        } catch (final InvocationTargetException e) {\r\n          throw new OIndexException(\"Error during deserialization of index definition\", e);\r\n        } catch (final InstantiationException e) {\r\n          throw new OIndexException(\"Error during deserialization of index definition\", e);\r\n        } catch (final IllegalAccessException e) {\r\n          throw new OIndexException(\"Error during deserialization of index definition\", e);\r\n        }\r\n      } else {\r\n        // @COMPATIBILITY 1.0rc6 new index model was implemented\r\n        final Boolean isAutomatic = configuration.field(OIndexInternal.CONFIG_AUTOMATIC);\r\n        if (Boolean.TRUE.equals(isAutomatic)) {\r\n          final int pos = name.lastIndexOf('.');\r\n          if (pos < 0)\r\n            throw new OIndexException(\"Can not convert from old index model to new one. \"\r\n                + \"Invalid index name. Dot (.) separator should be present.\");\r\n          final String className = name.substring(0, pos);\r\n          final String propertyName = name.substring(pos + 1);\r\n\r\n          final String keyTypeStr = configuration.field(OIndexInternal.CONFIG_KEYTYPE);\r\n          if (keyTypeStr == null)\r\n            throw new OIndexException(\"Can not convert from old index model to new one. \" + \"Index key type is absent.\");\r\n          final OType keyType = OType.valueOf(keyTypeStr.toUpperCase(Locale.ENGLISH));\r\n          indexDefinition = new OPropertyIndexDefinition(className, propertyName, keyType);\r\n\r\n          configuration.removeField(OIndexInternal.CONFIG_AUTOMATIC);\r\n          configuration.removeField(OIndexInternal.CONFIG_KEYTYPE);\r\n        } else if (configuration.field(OIndexInternal.CONFIG_KEYTYPE) != null) {\r\n          final String keyTypeStr = configuration.field(OIndexInternal.CONFIG_KEYTYPE);\r\n          final OType keyType = OType.valueOf(keyTypeStr.toUpperCase(Locale.ENGLISH));\r\n\r\n          indexDefinition = new OSimpleKeyIndexDefinition(keyType);\r\n\r\n          configuration.removeField(OIndexInternal.CONFIG_KEYTYPE);\r\n        }\r\n      }\r\n\r\n      clustersToIndex.clear();\r\n      maxUpdatesBeforeSave = lazyUpdates();\r\n\r\n      final Collection<? extends String> clusters = configuration.field(CONFIG_CLUSTERS);\r\n      if (clusters != null)\r\n        clustersToIndex.addAll(clusters);\r\n\r\n      map = new OMVRBTreeDatabaseLazySave<Object, T>(getDatabase(), rid, maxUpdatesBeforeSave);\r\n      try {\r\n        map.load();\r\n      } catch (Exception e) {\r\n        if (onCorruptionRepairDatabase(null, \"load\", \"Index will be rebuilt\")) {\r\n          if (isAutomatic())\r\n            // AUTOMATIC REBUILD IT\r\n            OLogManager.instance().warn(this, \"Cannot load index '%s' from storage (rid=%s): rebuilt it from scratch\", getName(),\r\n                rid);\r\n          try {\r\n            rebuild();\r\n          } catch (Throwable t) {\r\n            OLogManager.instance().error(this,\r\n                \"Cannot rebuild index '%s' from storage (rid=%s). The index will be removed in configuration\", getName(), rid);\r\n            getDatabase().getMetadata().getIndexManager().dropIndex(name);\r\n          }\r\n        }\r\n      }\r\n\r\n      installHooks(iConfig.getDatabase());\r\n\r\n      return this;\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","commit_id":"89a10465d56d08c57981d19222e68ce8abf49bf2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public GossipRouter(int port, String bindAddressString) {\n        this.port=port;\n        this.bindAddressString=bindAddressString;\n        connectionTearListeners.add(new FailureDetectionListener());\n    }","id":25760,"modified_method":"public GossipRouter(int port, String bindAddressString) {\n        this(port,bindAddressString,false,0);\n    }","commit_id":"ed50b8471afd7c1631e46487c86c1ee59efcbc73","url":"https://github.com/belaban/JGroups"},{"original_method":"private void readLoop() {\n            while(isRunning()) {\n                GossipData request;\n                Address addr;\n                String group;\n                try {                   \n                    request=new GossipData();\n                    request.readFrom(input);\n                    byte command=request.getType();\n                    addr=request.getAddress();\n                    group=request.getGroup();\n                    known_groups.add(group);\n\n\n                    if(log.isTraceEnabled())\n                        log.trace(this + \" received \" + request);\n                    \n                    switch(command) {\n\n                        case GossipRouter.CONNECT:\n                            handleConnect(request, addr, group);\n                            break;\n\n                        case GossipRouter.PING:\n                            // do nothing here - client doesn't expect response data\n                            break;\n\n                        case GossipRouter.MESSAGE:\n                            if(request.buffer == null || request.buffer.length == 0) {\n                                if(log.isWarnEnabled())\n                                    log.warn(this +\" received null message\");\n                                break;\n                            }\n\n                            try {\n                                route(addr, request.getGroup(), request.getBuffer());\n                            }\n                            catch(Exception e) {\n                                if(log.isErrorEnabled())\n                                    log.error(this +\" failed in routing request to \" + addr, e);\n                            }\n                            break;\n\n                        case GossipRouter.GOSSIP_GET:\n                            Set<PhysicalAddress> physical_addrs;\n                            List<PingData> mbrs=new ArrayList<PingData>();\n                            ConcurrentMap<Address,ConnectionHandler> map=routingTable.get(group);\n                            if(map != null) {\n                                for(Address logical_addr: map.keySet()) {\n                                    physical_addrs=address_mappings.get(logical_addr);\n                                    PingData rsp=new PingData(logical_addr, null, true, UUID.get(logical_addr),\n                                                              physical_addrs != null? new ArrayList<PhysicalAddress>(physical_addrs) : null);\n                                    mbrs.add(rsp);\n                                }\n                            }\n                            output.writeShort(mbrs.size());\n                            for(PingData data: mbrs)\n                                data.writeTo(output);\n                            output.flush();\n                            if(log.isDebugEnabled())\n                                log.debug(this + \" responded to GOSSIP_GET with \" + mbrs);\n                            break;\n\n                        case GossipRouter.DISCONNECT:\n                            try {\n                                removeEntry(group, addr);\n                                sendData(new GossipData(DISCONNECT_OK));\n                                if(log.isDebugEnabled())\n                                    log.debug(this + \" disconnect completed\");\n                            }\n                            catch(Exception e) {\n                                sendData(new GossipData(OP_FAIL));\n                            }\n                            break;\n                            \n                        case GossipRouter.CLOSE:\n                            close();\n                            break;\n                            \n                        case -1: // EOF\n                            notifyAbnormalConnectionTear(this, new EOFException(\"Connection broken\"));\n                            break;\n                    }\n                    if(log.isTraceEnabled())\n                        log.trace(this + \" processed  \" + request);\n                }\n                catch(SocketTimeoutException ste) {\n                }                \n                catch(IOException ioex) {\n                    notifyAbnormalConnectionTear(this, ioex);\n                    break;\n                }                \n                catch(Exception ex) {\n                    if (active.get()) {\n                        if (log.isWarnEnabled())\n                            log.warn(\"Exception in ConnectionHandler thread\", ex);\n                    }\n                    break;\n                }\n            }\n        }","id":25761,"modified_method":"private void readLoop() {\n            while(isRunning()) {\n                GossipData request;\n                Address addr;\n                String group;\n                try {                   \n                    request=new GossipData();\n                    request.readFrom(input);\n                    byte command=request.getType();\n                    addr=request.getAddress();\n                    group=request.getGroup();\n                    known_groups.add(group);\n\n                    timestamp = System.currentTimeMillis();\n                    if(log.isTraceEnabled())\n                        log.trace(this + \" received \" + request);\n                    \n                    switch(command) {\n\n                        case GossipRouter.CONNECT:\n                            handleConnect(request, addr, group);\n                            break;\n\n                        case GossipRouter.PING:\n                            // do nothing here - client doesn't expect response data\n                            break;\n\n                        case GossipRouter.MESSAGE:\n                            if(request.buffer == null || request.buffer.length == 0) {\n                                if(log.isWarnEnabled())\n                                    log.warn(this +\" received null message\");\n                                break;\n                            }\n\n                            try {\n                                route(addr, request.getGroup(), request.getBuffer());\n                            }\n                            catch(Exception e) {\n                                if(log.isErrorEnabled())\n                                    log.error(this +\" failed in routing request to \" + addr, e);\n                            }\n                            break;\n\n                        case GossipRouter.GOSSIP_GET:\n                            Set<PhysicalAddress> physical_addrs;\n                            List<PingData> mbrs=new ArrayList<PingData>();\n                            ConcurrentMap<Address,ConnectionHandler> map=routingTable.get(group);\n                            if(map != null) {\n                                for(Address logical_addr: map.keySet()) {\n                                    physical_addrs=address_mappings.get(logical_addr);\n                                    PingData rsp=new PingData(logical_addr, null, true, UUID.get(logical_addr),\n                                                              physical_addrs != null? new ArrayList<PhysicalAddress>(physical_addrs) : null);\n                                    mbrs.add(rsp);\n                                }\n                            }\n                            output.writeShort(mbrs.size());\n                            for(PingData data: mbrs)\n                                data.writeTo(output);\n                            output.flush();\n                            if(log.isDebugEnabled())\n                                log.debug(this + \" responded to GOSSIP_GET with \" + mbrs);\n                            break;\n\n                        case GossipRouter.DISCONNECT:\n                            try {\n                                removeEntry(group, addr);\n                                sendData(new GossipData(DISCONNECT_OK));\n                                if(log.isDebugEnabled())\n                                    log.debug(this + \" disconnect completed\");\n                            }\n                            catch(Exception e) {\n                                sendData(new GossipData(OP_FAIL));\n                            }\n                            break;\n                            \n                        case GossipRouter.CLOSE:\n                            close();\n                            break;\n                            \n                        case -1: // EOF\n                            notifyAbnormalConnectionTear(this, new EOFException(\"Connection broken\"));\n                            break;\n                    }\n                    if(log.isTraceEnabled())\n                        log.trace(this + \" processed  \" + request);\n                }\n                catch(SocketTimeoutException ste) {\n                }                \n                catch(IOException ioex) {\n                    notifyAbnormalConnectionTear(this, ioex);\n                    break;\n                }                \n                catch(Exception ex) {\n                    if (active.get()) {\n                        if (log.isWarnEnabled())\n                            log.warn(\"Exception in ConnectionHandler thread\", ex);\n                    }\n                    break;\n                }\n            }\n        }","commit_id":"ed50b8471afd7c1631e46487c86c1ee59efcbc73","url":"https://github.com/belaban/JGroups"},{"original_method":"public GossipRouter(int port, String bindAddressString, boolean jmx) {\n        this(port, bindAddressString);\n        this.jmx=jmx;\n    }","id":25762,"modified_method":"public GossipRouter(int port, String bindAddressString, boolean jmx) {\n        this(port, bindAddressString,jmx,0);    \n    }","commit_id":"ed50b8471afd7c1631e46487c86c1ee59efcbc73","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Lifecycle operation. Called after create(). When this method is called, the managed attributes\n     * have already been set.<br>\n     * Brings the Router into a fully functional state.\n     */\n    @ManagedOperation(description=\"Lifecycle operation. Called after create(). When this method is called, \"\n            + \"the managed attributes have already been set. Brings the Router into a fully functional state.\")\n    public void start() throws Exception {\n        if(running.compareAndSet(false, true)) {           \n            if(jmx && !registered) {\n                MBeanServer server=Util.getMBeanServer();\n                JmxConfigurator.register(this, server, \"jgroups:name=GossipRouter\");\n                registered=true;\n            }\n    \n            if(bindAddressString != null) {\n                bindAddress=InetAddress.getByName(bindAddressString);\n                srvSock=new ServerSocket(port, backlog, bindAddress);\n            }\n            else {\n                srvSock=new ServerSocket(port, backlog);\n            }       \n    \n            Runtime.getRuntime().addShutdownHook(new Thread() {\n                public void run() {\n                    GossipRouter.this.stop();\n                }\n            });\n    \n            // start the main server thread\n            new Thread(new Runnable() {\n                public void run() {\n                    mainLoop();\n                }\n            }, \"GossipRouter\").start();\n        } else {\n            throw new Exception(\"Router already started.\");\n        }\n    }","id":25763,"modified_method":"/**\n     * Lifecycle operation. Called after create(). When this method is called, the managed attributes\n     * have already been set.<br>\n     * Brings the Router into a fully functional state.\n     */\n    @ManagedOperation(description=\"Lifecycle operation. Called after create(). When this method is called, \"\n            + \"the managed attributes have already been set. Brings the Router into a fully functional state.\")\n    public void start() throws Exception {\n        if(running.compareAndSet(false, true)) {           \n            if(jmx && !registered) {\n                MBeanServer server=Util.getMBeanServer();\n                JmxConfigurator.register(this, server, \"jgroups:name=GossipRouter\");\n                registered=true;\n            }\n    \n            if(bindAddressString != null) {\n                bindAddress=InetAddress.getByName(bindAddressString);\n                srvSock=new ServerSocket(port, backlog, bindAddress);\n            }\n            else {\n                srvSock=new ServerSocket(port, backlog);\n            }       \n    \n            Runtime.getRuntime().addShutdownHook(new Thread() {\n                public void run() {\n                    GossipRouter.this.stop();\n                }\n            });\n    \n            // start the main server thread\n            new Thread(new Runnable() {\n                public void run() {\n                    mainLoop();\n                }\n            }, \"GossipRouter\").start();\n            \n            long expiryTime = getExpiryTime();\n            if (expiryTime > 0) {\n                timer = new Timer(true);\n                timer.schedule(new TimerTask() {\n                    public void run() {\n                        sweep();\n                    }\n                }, expiryTime, expiryTime);\n            }            \n        } else {\n            throw new Exception(\"Router already started.\");\n        }\n    }","commit_id":"ed50b8471afd7c1631e46487c86c1ee59efcbc73","url":"https://github.com/belaban/JGroups"},{"original_method":"@Deprecated\n    public void setExpiryTime(long expiryTime) {\n\n    }","id":25764,"modified_method":"public void setExpiryTime(long expiryTime) {\n        this.expiryTime = expiryTime;\n    }","commit_id":"ed50b8471afd7c1631e46487c86c1ee59efcbc73","url":"https://github.com/belaban/JGroups"},{"original_method":"@Deprecated\n    public static long getExpiryTime() {\n        return 0;\n    }","id":25765,"modified_method":"public long getExpiryTime() {\n        return expiryTime;\n    }","commit_id":"ed50b8471afd7c1631e46487c86c1ee59efcbc73","url":"https://github.com/belaban/JGroups"},{"original_method":"public void startReconnecting(final RouterStub stub) {\n        reconnectorLock.lock();\n        try {\n            Future<?> reconnectorFuture = reconnectFutures.get(stub.getGossipRouterAddress());\n            if (reconnectorFuture == null || reconnectorFuture.isDone()) {\n                final Runnable reconnector = new Runnable() {\n                    public void run() {\n                        try {\n                            if (log.isTraceEnabled()) {\n                                log.trace(\"Reconnecting \" + stub);\n                            }\n\n                            String logical_name = org.jgroups.util.UUID.get(logicalAddress);\n                            PhysicalAddress physical_addr = (PhysicalAddress) owner.down(new Event(\n                                            Event.GET_PHYSICAL_ADDRESS, logicalAddress));\n                            List<PhysicalAddress> physical_addrs = Arrays.asList(physical_addr);\n                            stub.connect(channelName, logicalAddress, logical_name, physical_addrs);\n                            if (log.isTraceEnabled()) {\n                                log.trace(\"Reconnected \" + stub);\n                            }\n\n                        } catch (Throwable ex) {\n                            if (log.isWarnEnabled())\n                                log.warn(\"failed reconnecting stub to GR at \" + stub.getGossipRouterAddress() + \": \" + ex);\n                        }\n                    }\n                };\n                reconnectorFuture = timer.scheduleWithFixedDelay(reconnector, 0, interval,TimeUnit.MILLISECONDS);\n                reconnectFutures.put(stub.getGossipRouterAddress(), reconnectorFuture);\n            }\n        } finally {\n            reconnectorLock.unlock();\n        }\n    }","id":25766,"modified_method":"public void startReconnecting(final RouterStub stub) {\n        reconnectorLock.lock();\n        try {\n            InetSocketAddress routerAddress = stub.getGossipRouterAddress();\n            Future<?> f = futures.get(routerAddress);\n            if (f != null) {\n                f.cancel(true);\n                futures.remove(routerAddress);\n            }\n\n            final Runnable reconnector = new Runnable() {\n                public void run() {\n                    try {\n                        if (log.isTraceEnabled()) log.trace(\"Reconnecting \" + stub);                        \n                        String logical_name = org.jgroups.util.UUID.get(logicalAddress);\n                        PhysicalAddress physical_addr = (PhysicalAddress) owner.down(new Event(\n                                        Event.GET_PHYSICAL_ADDRESS, logicalAddress));\n                        List<PhysicalAddress> physical_addrs = Arrays.asList(physical_addr);\n                        stub.connect(channelName, logicalAddress, logical_name, physical_addrs);\n                        if (log.isTraceEnabled()) log.trace(\"Reconnected \" + stub);                        \n                    } catch (Throwable ex) {\n                        if (log.isWarnEnabled())\n                            log.warn(\"failed reconnecting stub to GR at \"+ stub.getGossipRouterAddress() + \": \" + ex);\n                    }\n                }\n            };\n            f = timer.scheduleWithFixedDelay(reconnector, 0, interval, TimeUnit.MILLISECONDS);\n            futures.put(stub.getGossipRouterAddress(), f);\n        } finally {\n            reconnectorLock.unlock();\n        }\n    }","commit_id":"ed50b8471afd7c1631e46487c86c1ee59efcbc73","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stopReconnecting(final RouterStub stub) {\n        stopReconnecting(stub.getGossipRouterAddress());\n    }","id":25767,"modified_method":"public void stopReconnecting(final RouterStub stub) {\n        reconnectorLock.lock();\n        try {\n            InetSocketAddress routerAddress = stub.getGossipRouterAddress();\n            Future<?> f = futures.get(stub.getGossipRouterAddress());\n            if (f != null) {\n                f.cancel(true);\n                futures.remove(routerAddress);\n            }\n\n            final Runnable pinger = new Runnable() {\n                public void run() {\n                    try {\n                        if(log.isTraceEnabled()) log.trace(\"Pinging \" + stub);                        \n                        stub.checkConnection();\n                        if(log.isTraceEnabled()) log.trace(\"Pinged \" + stub);                        \n                    } catch (Throwable ex) {\n                        if (log.isWarnEnabled())\n                            log.warn(\"failed pinging stub, GR at \" + stub.getGossipRouterAddress()+ \": \" + ex);\n                    }\n                }\n            };\n            f = timer.scheduleWithFixedDelay(pinger, 0, interval, TimeUnit.MILLISECONDS);\n            futures.put(stub.getGossipRouterAddress(), f);\n        } finally {\n            reconnectorLock.unlock();\n        }\n    }","commit_id":"ed50b8471afd7c1631e46487c86c1ee59efcbc73","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedOperation\n    public boolean removeInitialHost(String hostname, int port) {\n        InetSocketAddress isa = new InetSocketAddress(hostname, port);\n        stubManager.stopReconnecting(isa);\n        stubManager.unregisterAndDestroyStub(isa);\n        return initial_hosts.remove(isa);        \n    }","id":25768,"modified_method":"@ManagedOperation\n    public boolean removeInitialHost(String hostname, int port) {\n        InetSocketAddress isa = new InetSocketAddress(hostname, port);        \n        RouterStub unregisterStub = stubManager.unregisterStub(isa);\n        if(unregisterStub != null) {\n            stubManager.stopReconnecting(unregisterStub);\n            unregisterStub.destroy();\n        }\n        return initial_hosts.remove(isa);        \n    }","commit_id":"ed50b8471afd7c1631e46487c86c1ee59efcbc73","url":"https://github.com/belaban/JGroups"},{"original_method":"private void readLoop() {\n            while(isRunning()) {\n                GossipData request;\n                Address addr;\n                String group;\n                try {                   \n                    request=new GossipData();\n                    request.readFrom(input);\n                    byte command=request.getType();\n                    addr=request.getAddress();\n                    group=request.getGroup();\n                    known_groups.add(group);\n\n\n                    if(log.isTraceEnabled())\n                        log.trace(this + \" received \" + request);\n                    \n                    switch(command) {\n\n                        case GossipRouter.CONNECT:\n                            handleConnect(request, addr, group);\n                            break;\n\n                        case GossipRouter.PING:\n                            // do nothing here - client doesn't expect response data\n                            break;\n\n                        case GossipRouter.MESSAGE:\n                            if(request.buffer == null || request.buffer.length == 0) {\n                                if(log.isWarnEnabled())\n                                    log.warn(this +\" received null message\");\n                                break;\n                            }\n\n                            try {\n                                route(addr, request.getGroup(), request.getBuffer());\n                            }\n                            catch(Exception e) {\n                                if(log.isErrorEnabled())\n                                    log.error(this +\" failed in routing request to \" + addr, e);\n                            }\n                            break;\n\n                        case GossipRouter.GOSSIP_GET:\n                            Set<PhysicalAddress> physical_addrs;\n                            List<PingData> mbrs=new ArrayList<PingData>();\n                            ConcurrentMap<Address,ConnectionHandler> map=routingTable.get(group);\n                            if(map != null) {\n                                for(Address logical_addr: map.keySet()) {\n                                    physical_addrs=address_mappings.get(logical_addr);\n                                    PingData rsp=new PingData(logical_addr, null, true, UUID.get(logical_addr),\n                                                              physical_addrs != null? new ArrayList<PhysicalAddress>(physical_addrs) : null);\n                                    mbrs.add(rsp);\n                                }\n                            }\n                            output.writeShort(mbrs.size());\n                            for(PingData data: mbrs)\n                                data.writeTo(output);\n                            output.flush();\n                            if(log.isDebugEnabled())\n                                log.debug(this + \" responded to GOSSIP_GET with \" + mbrs);\n                            break;\n\n                        case GossipRouter.DISCONNECT:\n                            try {\n                                removeEntry(group, addr);\n                                sendData(new GossipData(DISCONNECT_OK));\n                                if(log.isDebugEnabled())\n                                    log.debug(this + \" disconnect completed\");\n                            }\n                            catch(Exception e) {\n                                sendData(new GossipData(OP_FAIL));\n                            }\n                            break;\n                            \n                        case GossipRouter.CLOSE:\n                            close();\n                            break;\n                            \n                        case -1: // EOF\n                            notifyAbnormalConnectionTear(this, new EOFException(\"Connection broken\"));\n                            break;\n                    }\n                    if(log.isTraceEnabled())\n                        log.trace(this + \" processed  \" + request);\n                }\n                catch(SocketTimeoutException ste) {\n                }                \n                catch(IOException ioex) {\n                    notifyAbnormalConnectionTear(this, ioex);\n                    break;\n                }                \n                catch(Exception ex) {\n                    if (active.get()) {\n                        if (log.isWarnEnabled())\n                            log.warn(\"Exception in ConnectionHandler thread\", ex);\n                    }\n                    break;\n                }\n            }\n        }","id":25769,"modified_method":"private void readLoop() {\n            while(isRunning()) {\n                GossipData request;\n                Address addr;\n                String group;\n                try {                   \n                    request=new GossipData();\n                    request.readFrom(input);\n                    byte command=request.getType();\n                    addr=request.getAddress();\n                    group=request.getGroup();\n                    known_groups.add(group);\n\n                    timestamp = System.currentTimeMillis();\n                    if(log.isTraceEnabled())\n                        log.trace(this + \" received \" + request);\n                    \n                    switch(command) {\n\n                        case GossipRouter.CONNECT:\n                            handleConnect(request, addr, group);\n                            break;\n\n                        case GossipRouter.PING:\n                            // do nothing here - client doesn't expect response data\n                            break;\n\n                        case GossipRouter.MESSAGE:\n                            if(request.buffer == null || request.buffer.length == 0) {\n                                if(log.isWarnEnabled())\n                                    log.warn(this +\" received null message\");\n                                break;\n                            }\n\n                            try {\n                                route(addr, request.getGroup(), request.getBuffer());\n                            }\n                            catch(Exception e) {\n                                if(log.isErrorEnabled())\n                                    log.error(this +\" failed in routing request to \" + addr, e);\n                            }\n                            break;\n\n                        case GossipRouter.GOSSIP_GET:\n                            Set<PhysicalAddress> physical_addrs;\n                            List<PingData> mbrs=new ArrayList<PingData>();\n                            ConcurrentMap<Address,ConnectionHandler> map=routingTable.get(group);\n                            if(map != null) {\n                                for(Address logical_addr: map.keySet()) {\n                                    physical_addrs=address_mappings.get(logical_addr);\n                                    PingData rsp=new PingData(logical_addr, null, true, UUID.get(logical_addr),\n                                                              physical_addrs != null? new ArrayList<PhysicalAddress>(physical_addrs) : null);\n                                    mbrs.add(rsp);\n                                }\n                            }\n                            output.writeShort(mbrs.size());\n                            for(PingData data: mbrs)\n                                data.writeTo(output);\n                            output.flush();\n                            if(log.isDebugEnabled())\n                                log.debug(this + \" responded to GOSSIP_GET with \" + mbrs);\n                            break;\n\n                        case GossipRouter.DISCONNECT:\n                            try {\n                                removeEntry(group, addr);\n                                sendData(new GossipData(DISCONNECT_OK));\n                                if(log.isDebugEnabled())\n                                    log.debug(this + \" disconnect completed\");\n                            }\n                            catch(Exception e) {\n                                sendData(new GossipData(OP_FAIL));\n                            }\n                            break;\n                            \n                        case GossipRouter.CLOSE:\n                            close();\n                            break;\n                            \n                        case -1: // EOF\n                            notifyAbnormalConnectionTear(this, new EOFException(\"Connection broken\"));\n                            break;\n                    }\n                    if(log.isTraceEnabled())\n                        log.trace(this + \" processed  \" + request);\n                }\n                catch(SocketTimeoutException ste) {\n                }                \n                catch(IOException ioex) {\n                    notifyAbnormalConnectionTear(this, ioex);\n                    break;\n                }                \n                catch(Exception ex) {\n                    if (active.get()) {\n                        if (log.isWarnEnabled())\n                            log.warn(\"Exception in ConnectionHandler thread\", ex);\n                    }\n                    break;\n                }\n            }\n        }","commit_id":"ba1a7e18c0e9d1e0cd88d80ef5aeb98b8a7674a3","url":"https://github.com/belaban/JGroups"},{"original_method":"@Deprecated\n    public static long getExpiryTime() {\n        return 0;\n    }","id":25770,"modified_method":"public long getExpiryTime() {\n        return expiryTime;\n    }","commit_id":"ba1a7e18c0e9d1e0cd88d80ef5aeb98b8a7674a3","url":"https://github.com/belaban/JGroups"},{"original_method":"public GossipRouter(int port, String bindAddressString) {\n        this.port=port;\n        this.bindAddressString=bindAddressString;\n        connectionTearListeners.add(new FailureDetectionListener());\n    }","id":25771,"modified_method":"public GossipRouter(int port, String bindAddressString) {\n        this(port,bindAddressString,false,0);\n    }","commit_id":"ba1a7e18c0e9d1e0cd88d80ef5aeb98b8a7674a3","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Lifecycle operation. Called after create(). When this method is called, the managed attributes\n     * have already been set.<br>\n     * Brings the Router into a fully functional state.\n     */\n    @ManagedOperation(description=\"Lifecycle operation. Called after create(). When this method is called, \"\n            + \"the managed attributes have already been set. Brings the Router into a fully functional state.\")\n    public void start() throws Exception {\n        if(running.compareAndSet(false, true)) {           \n            if(jmx && !registered) {\n                MBeanServer server=Util.getMBeanServer();\n                JmxConfigurator.register(this, server, \"jgroups:name=GossipRouter\");\n                registered=true;\n            }\n    \n            if(bindAddressString != null) {\n                bindAddress=InetAddress.getByName(bindAddressString);\n                srvSock=new ServerSocket(port, backlog, bindAddress);\n            }\n            else {\n                srvSock=new ServerSocket(port, backlog);\n            }       \n    \n            Runtime.getRuntime().addShutdownHook(new Thread() {\n                public void run() {\n                    GossipRouter.this.stop();\n                }\n            });\n    \n            // start the main server thread\n            new Thread(new Runnable() {\n                public void run() {\n                    mainLoop();\n                }\n            }, \"GossipRouter\").start();\n        } else {\n            throw new Exception(\"Router already started.\");\n        }\n    }","id":25772,"modified_method":"/**\n     * Lifecycle operation. Called after create(). When this method is called, the managed attributes\n     * have already been set.<br>\n     * Brings the Router into a fully functional state.\n     */\n    @ManagedOperation(description=\"Lifecycle operation. Called after create(). When this method is called, \"\n            + \"the managed attributes have already been set. Brings the Router into a fully functional state.\")\n    public void start() throws Exception {\n        if(running.compareAndSet(false, true)) {           \n            if(jmx && !registered) {\n                MBeanServer server=Util.getMBeanServer();\n                JmxConfigurator.register(this, server, \"jgroups:name=GossipRouter\");\n                registered=true;\n            }\n    \n            if(bindAddressString != null) {\n                bindAddress=InetAddress.getByName(bindAddressString);\n                srvSock=new ServerSocket(port, backlog, bindAddress);\n            }\n            else {\n                srvSock=new ServerSocket(port, backlog);\n            }       \n    \n            Runtime.getRuntime().addShutdownHook(new Thread() {\n                public void run() {\n                    GossipRouter.this.stop();\n                }\n            });\n    \n            // start the main server thread\n            new Thread(new Runnable() {\n                public void run() {\n                    mainLoop();\n                }\n            }, \"GossipRouter\").start();\n            \n            long expiryTime = getExpiryTime();\n            if (expiryTime > 0) {\n                timer = new Timer(true);\n                timer.schedule(new TimerTask() {\n                    public void run() {\n                        sweep();\n                    }\n                }, expiryTime, expiryTime);\n            }            \n        } else {\n            throw new Exception(\"Router already started.\");\n        }\n    }","commit_id":"ba1a7e18c0e9d1e0cd88d80ef5aeb98b8a7674a3","url":"https://github.com/belaban/JGroups"},{"original_method":"public GossipRouter(int port, String bindAddressString, boolean jmx) {\n        this(port, bindAddressString);\n        this.jmx=jmx;\n    }","id":25773,"modified_method":"public GossipRouter(int port, String bindAddressString, boolean jmx) {\n        this(port, bindAddressString,jmx,0);    \n    }","commit_id":"ba1a7e18c0e9d1e0cd88d80ef5aeb98b8a7674a3","url":"https://github.com/belaban/JGroups"},{"original_method":"@Deprecated\n    public void setExpiryTime(long expiryTime) {\n\n    }","id":25774,"modified_method":"public void setExpiryTime(long expiryTime) {\n        this.expiryTime = expiryTime;\n    }","commit_id":"ba1a7e18c0e9d1e0cd88d80ef5aeb98b8a7674a3","url":"https://github.com/belaban/JGroups"},{"original_method":"public void startReconnecting(final RouterStub stub) {\n        reconnectorLock.lock();\n        try {\n            Future<?> reconnectorFuture = reconnectFutures.get(stub.getGossipRouterAddress());\n            if (reconnectorFuture == null || reconnectorFuture.isDone()) {\n                final Runnable reconnector = new Runnable() {\n                    public void run() {\n                        try {\n                            if (log.isTraceEnabled()) {\n                                log.trace(\"Reconnecting \" + stub);\n                            }\n\n                            String logical_name = org.jgroups.util.UUID.get(logicalAddress);\n                            PhysicalAddress physical_addr = (PhysicalAddress) owner.down(new Event(\n                                            Event.GET_PHYSICAL_ADDRESS, logicalAddress));\n                            List<PhysicalAddress> physical_addrs = Arrays.asList(physical_addr);\n                            stub.connect(channelName, logicalAddress, logical_name, physical_addrs);\n                            if (log.isTraceEnabled()) {\n                                log.trace(\"Reconnected \" + stub);\n                            }\n\n                        } catch (Throwable ex) {\n                            if (log.isWarnEnabled())\n                                log.warn(\"failed reconnecting stub to GR at \" + stub.getGossipRouterAddress() + \": \" + ex);\n                        }\n                    }\n                };\n                reconnectorFuture = timer.scheduleWithFixedDelay(reconnector, 0, interval,TimeUnit.MILLISECONDS);\n                reconnectFutures.put(stub.getGossipRouterAddress(), reconnectorFuture);\n            }\n        } finally {\n            reconnectorLock.unlock();\n        }\n    }","id":25775,"modified_method":"public void startReconnecting(final RouterStub stub) {\n        reconnectorLock.lock();\n        try {\n            InetSocketAddress routerAddress = stub.getGossipRouterAddress();\n            Future<?> f = futures.get(routerAddress);\n            if (f != null) {\n                f.cancel(true);\n                futures.remove(routerAddress);\n            }\n\n            final Runnable reconnector = new Runnable() {\n                public void run() {\n                    try {\n                        if (log.isTraceEnabled()) log.trace(\"Reconnecting \" + stub);                        \n                        String logical_name = org.jgroups.util.UUID.get(logicalAddress);\n                        PhysicalAddress physical_addr = (PhysicalAddress) owner.down(new Event(\n                                        Event.GET_PHYSICAL_ADDRESS, logicalAddress));\n                        List<PhysicalAddress> physical_addrs = Arrays.asList(physical_addr);\n                        stub.connect(channelName, logicalAddress, logical_name, physical_addrs);\n                        if (log.isTraceEnabled()) log.trace(\"Reconnected \" + stub);                        \n                    } catch (Throwable ex) {\n                        if (log.isWarnEnabled())\n                            log.warn(\"failed reconnecting stub to GR at \"+ stub.getGossipRouterAddress() + \": \" + ex);\n                    }\n                }\n            };\n            f = timer.scheduleWithFixedDelay(reconnector, 0, interval, TimeUnit.MILLISECONDS);\n            futures.put(stub.getGossipRouterAddress(), f);\n        } finally {\n            reconnectorLock.unlock();\n        }\n    }","commit_id":"ba1a7e18c0e9d1e0cd88d80ef5aeb98b8a7674a3","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stopReconnecting(final RouterStub stub) {\n        stopReconnecting(stub.getGossipRouterAddress());\n    }","id":25776,"modified_method":"public void stopReconnecting(final RouterStub stub) {\n        reconnectorLock.lock();\n        try {\n            InetSocketAddress routerAddress = stub.getGossipRouterAddress();\n            Future<?> f = futures.get(stub.getGossipRouterAddress());\n            if (f != null) {\n                f.cancel(true);\n                futures.remove(routerAddress);\n            }\n\n            final Runnable pinger = new Runnable() {\n                public void run() {\n                    try {\n                        if(log.isTraceEnabled()) log.trace(\"Pinging \" + stub);                        \n                        stub.checkConnection();\n                        if(log.isTraceEnabled()) log.trace(\"Pinged \" + stub);                        \n                    } catch (Throwable ex) {\n                        if (log.isWarnEnabled())\n                            log.warn(\"failed pinging stub, GR at \" + stub.getGossipRouterAddress()+ \": \" + ex);\n                    }\n                }\n            };\n            f = timer.scheduleWithFixedDelay(pinger, 0, interval, TimeUnit.MILLISECONDS);\n            futures.put(stub.getGossipRouterAddress(), f);\n        } finally {\n            reconnectorLock.unlock();\n        }\n    }","commit_id":"ba1a7e18c0e9d1e0cd88d80ef5aeb98b8a7674a3","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedOperation\n    public boolean removeInitialHost(String hostname, int port) {\n        InetSocketAddress isa = new InetSocketAddress(hostname, port);\n        stubManager.stopReconnecting(isa);\n        stubManager.unregisterAndDestroyStub(isa);\n        return initial_hosts.remove(isa);        \n    }","id":25777,"modified_method":"@ManagedOperation\n    public boolean removeInitialHost(String hostname, int port) {\n        InetSocketAddress isa = new InetSocketAddress(hostname, port);        \n        RouterStub unregisterStub = stubManager.unregisterStub(isa);\n        if(unregisterStub != null) {\n            stubManager.stopReconnecting(unregisterStub);\n            unregisterStub.destroy();\n        }\n        return initial_hosts.remove(isa);        \n    }","commit_id":"ba1a7e18c0e9d1e0cd88d80ef5aeb98b8a7674a3","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Register this process with the router under <code>groupname<\/code>.\n     * \n     * @param groupname\n     *                The name of the group under which to register\n     */\n    public synchronized void connect(String groupname, Address localAddress) throws Exception {\n        if(groupname == null || groupname.length() == 0)\n            throw new Exception(\"groupname is null\");\n        \n        if(localAddress == null)\n            throw new Exception(\"localAddress is null\");\n\n        if(!isConnected()){\n            this.groupname = groupname;\n            try{\n                sock = new Socket();\n                sock.bind(new InetSocketAddress(bind_addr,0));\n                sock.setSoTimeout(sock_read_timeout);\n                sock.setSoLinger(true, 5);\n                sock.connect(new InetSocketAddress(router_host,router_port), sock_conn_timeout);\n                output = new DataOutputStream(sock.getOutputStream());\n                \n                if(local_addr == null){\n                \tlocal_addr = localAddress;\n                }\n                \n                GossipData req = new GossipData(GossipRouter.CONNECT,\n                                                groupname,\n                                                localAddress,\n                                                null);\n                req.writeTo(output);\n                output.flush();\n                input = new DataInputStream(sock.getInputStream());\n                boolean connectedOk = input.readBoolean();\n                if(connectedOk)\n                    connectionStateChanged(STATUS_CONNECTED);\n                else\n                    throw new Exception(\"Failed to get connection ack from gossip router\");\n            }catch(Exception e){\n                if(log.isWarnEnabled())\n                    log.warn(this + \" failed connecting to \" + router_host + \":\" + router_port);\n                Util.close(sock);\n                Util.close(input);\n                Util.close(output);\n                connectionStateChanged(STATUS_DISCONNECTED);\n                throw e;\n            }\n        }\n    }","id":25778,"modified_method":"/**\n     * Register this process with the router under <code>groupname<\/code>.\n     * \n     * @param groupname\n     *                The name of the group under which to register\n     */\n    public synchronized void connect(String groupname, Address localAddress) throws Exception {\n        if(groupname == null || groupname.length() == 0)\n            throw new Exception(\"groupname is null\");\n        \n        if(localAddress == null)\n            throw new Exception(\"localAddress is null\");\n\n        if(!isConnected()){\n            this.groupname = groupname;\n            try{\n                sock = new Socket();\n                sock.bind(new InetSocketAddress(bind_addr,0));\n                sock.setSoTimeout(sock_read_timeout);\n                sock.setSoLinger(true, 2);\n                sock.connect(new InetSocketAddress(router_host,router_port), sock_conn_timeout);\n                output = new DataOutputStream(sock.getOutputStream());\n                \n                if(local_addr == null){\n                \tlocal_addr = localAddress;\n                }\n                \n                GossipData req = new GossipData(GossipRouter.CONNECT,\n                                                groupname,\n                                                localAddress,\n                                                null);\n                req.writeTo(output);\n                output.flush();\n                input = new DataInputStream(sock.getInputStream());\n                boolean connectedOk = input.readBoolean();\n                if(connectedOk)\n                    connectionStateChanged(STATUS_CONNECTED);\n                else\n                    throw new Exception(\"Failed to get connection ack from gossip router\");\n            }catch(Exception e){\n                if(log.isWarnEnabled())\n                    log.warn(this + \" failed connecting to \" + router_host + \":\" + router_port);\n                Util.close(sock);\n                Util.close(input);\n                Util.close(output);\n                connectionStateChanged(STATUS_DISCONNECTED);\n                throw e;\n            }\n        }\n    }","commit_id":"ad923e12aa27dd5bb01e70eee57881e09e1c5c0b","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendToAllMembers(List<RouterStub> stubs, byte[] data, int offset, int length) {\t\n\t\t\tfor(RouterStub stub:stubs){\n\t\t\t\ttry{\n\t\t\t\t\tstub.sendToAllMembers(data, offset, length);\n\t\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\t\tlog.debug(\"Sent to all GR at \" + stub.getGossipRouterAddress());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcatch(Exception e){\t\t\n\t\t\t\t\tlog.warn(\"Failed sending to all GR at \" + stub.getGossipRouterAddress());\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t\n\t\t}","id":25779,"modified_method":"public void sendToAllMembers(List<RouterStub> stubs, byte[] data,\n\t\t\t\tint offset, int length) {\n\t\t\tfor (RouterStub stub : stubs) {\n\t\t\t\ttry {\n\t\t\t\t\tstub.sendToAllMembers(data, offset, length);\n\t\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\t\tlog.debug(stub.getLocalAddress()\n\t\t\t\t\t\t\t\t+ \" sent a message to all members, GR used \"\n\t\t\t\t\t\t\t\t+ stub.getGossipRouterAddress());\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlog.warn(stub.getLocalAddress()\n\t\t\t\t\t\t\t\t+ \" failed sending a message to all members, GR used \"\n\t\t\t\t\t\t\t\t+ stub.getGossipRouterAddress());\n\t\t\t\t\t} catch (SocketException e1) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}","commit_id":"ad923e12aa27dd5bb01e70eee57881e09e1c5c0b","url":"https://github.com/belaban/JGroups"},{"original_method":"private void startReconnecting(final RouterStub stub) {\n        reconnectorLock.lock();\n        try{\n        \tFuture<?>reconnectorFuture = reconnectFutures.get(stub.getGossipRouterAddress());\n            if(reconnectorFuture == null || reconnectorFuture.isDone()){\n                final Runnable reconnector = new Runnable() {\n                    public void run() {\n                        try{\n                            if(!stub.isIntentionallyDisconnected()){\n                                if(log.isDebugEnabled()){\n                                    log.debug(\"Reconnecting \" + getLocalAddress()\n                                              + \" to router at \"\n                                              + router_host\n                                              + \":\"\n                                              + router_port);\n                                }\n                                stub.connect(channel_name);\n                            }\n                        }catch(Exception ex){\n                            if(log.isTraceEnabled())\n                                log.trace(\"failed reconnecting\", ex);\n                        }\n                    }\n                };\n                reconnectorFuture = timer.scheduleWithFixedDelay(reconnector,\n                                                                 0,\n                                                                 reconnect_interval,\n                                                                 TimeUnit.MILLISECONDS);\n                reconnectFutures.put(stub.getGossipRouterAddress(), reconnectorFuture);\n            }\n        }finally{\n            reconnectorLock.unlock();\n        }\n    }","id":25780,"modified_method":"private void startReconnecting(final RouterStub stub) {\n        reconnectorLock.lock();\n        try{\n        \tFuture<?>reconnectorFuture = reconnectFutures.get(stub.getGossipRouterAddress());\n            if(reconnectorFuture == null || reconnectorFuture.isDone()){\n                final Runnable reconnector = new Runnable() {\n                    public void run() {\n                        try{\n                            if(!stub.isIntentionallyDisconnected()){\n                                if(log.isDebugEnabled()){\n                                    log.debug(\"Reconnecting \" + getLocalAddress()\n                                              + \" to router at \"\n                                              + stub.getGossipRouterAddress());\n                                }\n                                stub.connect(channel_name);\n                            }\n                        } catch (Exception ex) {\n\t\t\t\t\t\t\tif (log.isWarnEnabled())\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tlog.warn(\"failed reconnecting \"\n\t\t\t\t\t\t\t\t\t\t\t+ stub.getLocalAddress() + \" to GR at \"\n\t\t\t\t\t\t\t\t\t\t\t+ stub.getGossipRouterAddress(), ex);\n\t\t\t\t\t\t\t\t} catch (SocketException e) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n                    }\n                };\n                reconnectorFuture = timer.scheduleWithFixedDelay(reconnector,\n                                                                 0,\n                                                                 reconnect_interval,\n                                                                 TimeUnit.MILLISECONDS);\n                reconnectFutures.put(stub.getGossipRouterAddress(), reconnectorFuture);\n            }\n        }finally{\n            reconnectorLock.unlock();\n        }\n    }","commit_id":"ad923e12aa27dd5bb01e70eee57881e09e1c5c0b","url":"https://github.com/belaban/JGroups"},{"original_method":"public void init() throws Exception {        \n        super.init();\n        if(timer == null)\n            throw new Exception(\"TUNNEL.init(): timer cannot be retrieved from protocol stack\");\n        \n        if(log.isDebugEnabled()){\n            log.debug(\"router_host=\" + router_host + \";router_port=\" + router_port);\n        }\n\n        if((router_host == null || router_port == 0) && gossip_router_hosts.isEmpty()){\n            throw new Exception(\"Either router_host and router_port have to be set or a list of gossip routers\");            \n        }\n        \n        if(router_host != null && router_port != 0 && !gossip_router_hosts.isEmpty()){ \n        \tthrow new Exception(\"Cannot specify both router host and port along with gossip_router_hosts\");\n        }\n        \n        if(router_host != null && router_port != 0 && gossip_router_hosts.isEmpty()){\n        \tgossip_router_hosts.add(new InetSocketAddress(router_host,router_port));\n        }\n    }","id":25781,"modified_method":"public void init() throws Exception {        \n        super.init();\n        if(timer == null)\n            throw new Exception(\"TUNNEL.init(): timer cannot be retrieved from protocol stack\");\n\n        if((router_host == null || router_port == 0) && gossip_router_hosts.isEmpty()){\n            throw new Exception(\"Either router_host and router_port have to be set or a list of gossip routers\");            \n        }\n        \n        if(router_host != null && router_port != 0 && !gossip_router_hosts.isEmpty()){ \n        \tthrow new Exception(\"Cannot specify both router host and port along with gossip_router_hosts\");\n        }\n        \n        if(router_host != null && router_port != 0 && gossip_router_hosts.isEmpty()){\n        \tgossip_router_hosts.add(new InetSocketAddress(router_host,router_port));\n        }\n        \n        if(log.isDebugEnabled()){\n            log.debug(\"Target GRs are:\" + gossip_router_hosts.toString());\n        }\n    }","commit_id":"ad923e12aa27dd5bb01e70eee57881e09e1c5c0b","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendToSingleMembers(List<RouterStub> stubs, Address dest,byte[] data, int offset, int length) {\n\t\t\tfor(RouterStub stub:stubs){\n\t\t\t\ttry{\n\t\t\t\t\tstub.sendToSingleMember(dest, data, offset, length);\n\t\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\t\tlog.debug(\"Sent to GR at \" + stub.getGossipRouterAddress());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcatch(Exception e){\t\t\n\t\t\t\t\tlog.warn(\"Failed sending to GR at \" + stub.getGossipRouterAddress());\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t}","id":25782,"modified_method":"public void sendToSingleMembers(List<RouterStub> stubs, Address dest,\n\t\t\t\tbyte[] data, int offset, int length) {\n\t\t\tfor (RouterStub stub : stubs) {\n\t\t\t\ttry {\n\t\t\t\t\tstub.sendToSingleMember(dest, data, offset, length);\n\t\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\t\tlog.debug(stub.getLocalAddress()\n\t\t\t\t\t\t\t\t+ \" sent a message to \" + dest + \", GR used \"\n\t\t\t\t\t\t\t\t+ stub.getGossipRouterAddress());\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlog.warn(stub.getLocalAddress()\n\t\t\t\t\t\t\t\t+ \" failed sending a message to \" + dest\n\t\t\t\t\t\t\t\t+ \", GR used \" + stub.getGossipRouterAddress());\n\t\t\t\t\t} catch (SocketException e1) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"ad923e12aa27dd5bb01e70eee57881e09e1c5c0b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Register this process with the router under <code>groupname<\/code>.\n     * \n     * @param groupname\n     *                The name of the group under which to register\n     */\n    public synchronized void connect(String groupname, Address localAddress) throws Exception {\n        if(groupname == null || groupname.length() == 0)\n            throw new Exception(\"groupname is null\");\n        \n        if(localAddress == null)\n            throw new Exception(\"localAddress is null\");\n\n        if(!isConnected()){\n            this.groupname = groupname;\n            try{\n                sock = new Socket();\n                sock.bind(new InetSocketAddress(bind_addr,0));\n                sock.setSoTimeout(sock_read_timeout);\n                sock.setSoLinger(true, 5);\n                sock.connect(new InetSocketAddress(router_host,router_port), sock_conn_timeout);\n                output = new DataOutputStream(sock.getOutputStream());\n                \n                if(local_addr == null){\n                \tlocal_addr = localAddress;\n                }\n                \n                GossipData req = new GossipData(GossipRouter.CONNECT,\n                                                groupname,\n                                                localAddress,\n                                                null);\n                req.writeTo(output);\n                output.flush();\n                input = new DataInputStream(sock.getInputStream());\n                boolean connectedOk = input.readBoolean();\n                if(connectedOk)\n                    connectionStateChanged(STATUS_CONNECTED);\n                else\n                    throw new Exception(\"Failed to get connection ack from gossip router\");\n            }catch(Exception e){\n                if(log.isWarnEnabled())\n                    log.warn(this + \" failed connecting to \" + router_host + \":\" + router_port);\n                Util.close(sock);\n                Util.close(input);\n                Util.close(output);\n                connectionStateChanged(STATUS_DISCONNECTED);\n                throw e;\n            }\n        }\n    }","id":25783,"modified_method":"/**\n     * Register this process with the router under <code>groupname<\/code>.\n     * \n     * @param groupname\n     *                The name of the group under which to register\n     */\n    public synchronized void connect(String groupname, Address localAddress) throws Exception {\n        if(groupname == null || groupname.length() == 0)\n            throw new Exception(\"groupname is null\");\n        \n        if(localAddress == null)\n            throw new Exception(\"localAddress is null\");\n\n        if(!isConnected()){\n            this.groupname = groupname;\n            try{\n                sock = new Socket();\n                sock.bind(new InetSocketAddress(bind_addr,0));\n                sock.setSoTimeout(sock_read_timeout);\n                sock.setSoLinger(true, 2);\n                sock.connect(new InetSocketAddress(router_host,router_port), sock_conn_timeout);\n                output = new DataOutputStream(sock.getOutputStream());\n                \n                if(local_addr == null){\n                \tlocal_addr = localAddress;\n                }\n                \n                GossipData req = new GossipData(GossipRouter.CONNECT,\n                                                groupname,\n                                                localAddress,\n                                                null);\n                req.writeTo(output);\n                output.flush();\n                input = new DataInputStream(sock.getInputStream());\n                boolean connectedOk = input.readBoolean();\n                if(connectedOk)\n                    connectionStateChanged(STATUS_CONNECTED);\n                else\n                    throw new Exception(\"Failed to get connection ack from gossip router\");\n            }catch(Exception e){\n                if(log.isWarnEnabled())\n                    log.warn(this + \" failed connecting to \" + router_host + \":\" + router_port);\n                Util.close(sock);\n                Util.close(input);\n                Util.close(output);\n                connectionStateChanged(STATUS_DISCONNECTED);\n                throw e;\n            }\n        }\n    }","commit_id":"54c75bc7d7e71941afbf921411e2e92585abd186","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendToAllMembers(List<RouterStub> stubs, byte[] data, int offset, int length) {\t\n\t\t\tfor(RouterStub stub:stubs){\n\t\t\t\ttry{\n\t\t\t\t\tstub.sendToAllMembers(data, offset, length);\n\t\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\t\tlog.debug(\"Sent to all GR at \" + stub.getGossipRouterAddress());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcatch(Exception e){\t\t\n\t\t\t\t\tlog.warn(\"Failed sending to all GR at \" + stub.getGossipRouterAddress());\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t\n\t\t}","id":25784,"modified_method":"public void sendToAllMembers(List<RouterStub> stubs, byte[] data,\n\t\t\t\tint offset, int length) {\n\t\t\tfor (RouterStub stub : stubs) {\n\t\t\t\ttry {\n\t\t\t\t\tstub.sendToAllMembers(data, offset, length);\n\t\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\t\tlog.debug(stub.getLocalAddress()\n\t\t\t\t\t\t\t\t+ \" sent a message to all members, GR used \"\n\t\t\t\t\t\t\t\t+ stub.getGossipRouterAddress());\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlog.warn(stub.getLocalAddress()\n\t\t\t\t\t\t\t\t+ \" failed sending a message to all members, GR used \"\n\t\t\t\t\t\t\t\t+ stub.getGossipRouterAddress());\n\t\t\t\t\t} catch (SocketException e1) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}","commit_id":"54c75bc7d7e71941afbf921411e2e92585abd186","url":"https://github.com/belaban/JGroups"},{"original_method":"public void init() throws Exception {        \n        super.init();\n        if(timer == null)\n            throw new Exception(\"TUNNEL.init(): timer cannot be retrieved from protocol stack\");\n        \n        if(log.isDebugEnabled()){\n            log.debug(\"router_host=\" + router_host + \";router_port=\" + router_port);\n        }\n\n        if((router_host == null || router_port == 0) && gossip_router_hosts.isEmpty()){\n            throw new Exception(\"Either router_host and router_port have to be set or a list of gossip routers\");            \n        }\n        \n        if(router_host != null && router_port != 0 && !gossip_router_hosts.isEmpty()){ \n        \tthrow new Exception(\"Cannot specify both router host and port along with gossip_router_hosts\");\n        }\n        \n        if(router_host != null && router_port != 0 && gossip_router_hosts.isEmpty()){\n        \tgossip_router_hosts.add(new InetSocketAddress(router_host,router_port));\n        }\n    }","id":25785,"modified_method":"public void init() throws Exception {        \n        super.init();\n        if(timer == null)\n            throw new Exception(\"TUNNEL.init(): timer cannot be retrieved from protocol stack\");\n\n        if((router_host == null || router_port == 0) && gossip_router_hosts.isEmpty()){\n            throw new Exception(\"Either router_host and router_port have to be set or a list of gossip routers\");            \n        }\n        \n        if(router_host != null && router_port != 0 && !gossip_router_hosts.isEmpty()){ \n        \tthrow new Exception(\"Cannot specify both router host and port along with gossip_router_hosts\");\n        }\n        \n        if(router_host != null && router_port != 0 && gossip_router_hosts.isEmpty()){\n        \tgossip_router_hosts.add(new InetSocketAddress(router_host,router_port));\n        }\n        \n        if(log.isDebugEnabled()){\n            log.debug(\"Target GRs are:\" + gossip_router_hosts.toString());\n        }\n    }","commit_id":"54c75bc7d7e71941afbf921411e2e92585abd186","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendToSingleMembers(List<RouterStub> stubs, Address dest,byte[] data, int offset, int length) {\n\t\t\tfor(RouterStub stub:stubs){\n\t\t\t\ttry{\n\t\t\t\t\tstub.sendToSingleMember(dest, data, offset, length);\n\t\t\t\t\tif(log.isDebugEnabled())\n\t\t\t\t\t\tlog.debug(\"Sent to GR at \" + stub.getGossipRouterAddress());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcatch(Exception e){\t\t\n\t\t\t\t\tlog.warn(\"Failed sending to GR at \" + stub.getGossipRouterAddress());\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t}","id":25786,"modified_method":"public void sendToSingleMembers(List<RouterStub> stubs, Address dest,\n\t\t\t\tbyte[] data, int offset, int length) {\n\t\t\tfor (RouterStub stub : stubs) {\n\t\t\t\ttry {\n\t\t\t\t\tstub.sendToSingleMember(dest, data, offset, length);\n\t\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\t\tlog.debug(stub.getLocalAddress()\n\t\t\t\t\t\t\t\t+ \" sent a message to \" + dest + \", GR used \"\n\t\t\t\t\t\t\t\t+ stub.getGossipRouterAddress());\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlog.warn(stub.getLocalAddress()\n\t\t\t\t\t\t\t\t+ \" failed sending a message to \" + dest\n\t\t\t\t\t\t\t\t+ \", GR used \" + stub.getGossipRouterAddress());\n\t\t\t\t\t} catch (SocketException e1) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"54c75bc7d7e71941afbf921411e2e92585abd186","url":"https://github.com/belaban/JGroups"},{"original_method":"private void startReconnecting(final RouterStub stub) {\n        reconnectorLock.lock();\n        try{\n        \tFuture<?>reconnectorFuture = reconnectFutures.get(stub.getGossipRouterAddress());\n            if(reconnectorFuture == null || reconnectorFuture.isDone()){\n                final Runnable reconnector = new Runnable() {\n                    public void run() {\n                        try{\n                            if(!stub.isIntentionallyDisconnected()){\n                                if(log.isDebugEnabled()){\n                                    log.debug(\"Reconnecting \" + getLocalAddress()\n                                              + \" to router at \"\n                                              + router_host\n                                              + \":\"\n                                              + router_port);\n                                }\n                                stub.connect(channel_name);\n                            }\n                        }catch(Exception ex){\n                            if(log.isTraceEnabled())\n                                log.trace(\"failed reconnecting\", ex);\n                        }\n                    }\n                };\n                reconnectorFuture = timer.scheduleWithFixedDelay(reconnector,\n                                                                 0,\n                                                                 reconnect_interval,\n                                                                 TimeUnit.MILLISECONDS);\n                reconnectFutures.put(stub.getGossipRouterAddress(), reconnectorFuture);\n            }\n        }finally{\n            reconnectorLock.unlock();\n        }\n    }","id":25787,"modified_method":"private void startReconnecting(final RouterStub stub) {\n        reconnectorLock.lock();\n        try{\n        \tFuture<?>reconnectorFuture = reconnectFutures.get(stub.getGossipRouterAddress());\n            if(reconnectorFuture == null || reconnectorFuture.isDone()){\n                final Runnable reconnector = new Runnable() {\n                    public void run() {\n                        try{\n                            if(!stub.isIntentionallyDisconnected()){\n                                if(log.isDebugEnabled()){\n                                    log.debug(\"Reconnecting \" + getLocalAddress()\n                                              + \" to router at \"\n                                              + stub.getGossipRouterAddress());\n                                }\n                                stub.connect(channel_name);\n                            }\n                        } catch (Exception ex) {\n\t\t\t\t\t\t\tif (log.isWarnEnabled())\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tlog.warn(\"failed reconnecting \"\n\t\t\t\t\t\t\t\t\t\t\t+ stub.getLocalAddress() + \" to GR at \"\n\t\t\t\t\t\t\t\t\t\t\t+ stub.getGossipRouterAddress(), ex);\n\t\t\t\t\t\t\t\t} catch (SocketException e) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n                    }\n                };\n                reconnectorFuture = timer.scheduleWithFixedDelay(reconnector,\n                                                                 0,\n                                                                 reconnect_interval,\n                                                                 TimeUnit.MILLISECONDS);\n                reconnectFutures.put(stub.getGossipRouterAddress(), reconnectorFuture);\n            }\n        }finally{\n            reconnectorLock.unlock();\n        }\n    }","commit_id":"54c75bc7d7e71941afbf921411e2e92585abd186","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * @see org.opencms.ade.galleries.shared.rpc.I_CmsGalleryService#getInitialSettings(org.opencms.ade.galleries.shared.CmsGalleryConfiguration)\n     */\n    public CmsGalleryDataBean getInitialSettings(CmsGalleryConfiguration conf) throws CmsRpcException {\n\n        CmsGalleryDataBean data = new CmsGalleryDataBean();\n        data.setMode(conf.getGalleryMode());\n        data.setLocales(buildLocalesMap());\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(conf.getLocale())) {\n            data.setLocale(conf.getLocale());\n        } else {\n            data.setLocale(getCmsObject().getRequestContext().getLocale().toString());\n        }\n        data.setVfsRootFolders(getRootEntries());\n        data.setScope(getWorkplaceSettings().getLastSearchScope());\n\n        List<CmsResourceTypeBean> types = null;\n        switch (conf.getGalleryMode()) {\n            case editor:\n            case view:\n            case widget:\n                data.setStartGallery(conf.getGalleryPath());\n                data.setCurrentElement(conf.getCurrentElement());\n                String referencePath = conf.getReferencePath();\n                if (CmsStringUtil.isEmptyOrWhitespaceOnly(referencePath)) {\n                    referencePath = data.getStartGallery();\n                }\n                data.setReferenceSitePath(referencePath);\n                types = getResourceTypeBeans(\n                    conf.getGalleryMode(),\n                    data.getReferenceSitePath(),\n                    conf.getResourceTypes());\n                data.setTypes(types);\n                Map<String, CmsGalleryTypeInfo> galleryTypeInfos = readGalleryInfosByTypeBeans(types);\n                // in case the 'gallerytypes' parameter is set, allow only the given galleries\n                if (conf.getGalleryTypes() != null) {\n                    Map<String, CmsGalleryTypeInfo> infos = new HashMap<String, CmsGalleryTypeInfo>();\n                    for (int i = 0; i < conf.getGalleryTypes().length; i++) {\n                        CmsGalleryTypeInfo typeInfo = galleryTypeInfos.get(conf.getGalleryTypes()[i]);\n                        if (typeInfo != null) {\n                            infos.put(conf.getGalleryTypes()[i], typeInfo);\n                        }\n                    }\n                    galleryTypeInfos = infos;\n                }\n                data.setGalleries(buildGalleriesList(galleryTypeInfos));\n                if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(conf.getStartFolder())) {\n                    try {\n                        CmsObject cloneCms = OpenCms.initCmsObject(getCmsObject());\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(conf.getStartSite())) {\n                            cloneCms.getRequestContext().setSiteRoot(conf.getStartSite());\n                        }\n                        if (cloneCms.existsResource(conf.getStartFolder(), CmsResourceFilter.ONLY_VISIBLE_NO_DELETED)) {\n                            data.setStartFolder(cloneCms.getRequestContext().addSiteRoot(conf.getStartFolder()));\n                        }\n                    } catch (CmsException e) {\n                        log(e.getMessage(), e);\n                    }\n                }\n                data.setStartTab(GalleryTabId.cms_tab_results);\n                if (CmsStringUtil.isEmptyOrWhitespaceOnly(data.getStartGallery()) && !types.isEmpty()) {\n                    String lastGallery = getWorkplaceSettings().getLastUsedGallery(types.get(0).getTypeId());\n                    // check if the gallery is available in this site and still exists\n                    if (getCmsObject().existsResource(lastGallery)) {\n                        data.setStartGallery(lastGallery);\n                    }\n                }\n                if (CmsStringUtil.isEmptyOrWhitespaceOnly(data.getStartGallery())\n                    && CmsStringUtil.isEmptyOrWhitespaceOnly(data.getCurrentElement())\n                    && CmsStringUtil.isEmptyOrWhitespaceOnly(data.getStartFolder())\n                    && (data.getTypes().size() > 1)) {\n                    data.setStartTab(GalleryTabId.cms_tab_galleries);\n                }\n                break;\n            case ade:\n                data.setReferenceSitePath(getCmsObject().getRequestContext().getUri());\n                types = getResourceTypeBeans(\n                    conf.getGalleryMode(),\n                    data.getReferenceSitePath(),\n                    conf.getResourceTypes());\n                data.setTypes(types);\n                Map<String, CmsGalleryTypeInfo> adeGalleryTypeInfos = readGalleryInfosByTypeBeans(types);\n                data.setGalleries(buildGalleriesList(adeGalleryTypeInfos));\n                data.setStartTab(GalleryTabId.cms_tab_types);\n                break;\n            default:\n                break;\n        }\n        CmsSiteSelectorOptionBuilder optionBuilder = new CmsSiteSelectorOptionBuilder(getCmsObject());\n        optionBuilder.addNormalSites(true);\n        optionBuilder.addSharedSite();\n        data.setVfsSiteSelectorOptions(optionBuilder.getOptions());\n\n        CmsSiteSelectorOptionBuilder sitemapOptionBuilder = new CmsSiteSelectorOptionBuilder(getCmsObject());\n        sitemapOptionBuilder.addNormalSites(false);\n        if (data.getReferenceSitePath() != null) {\n            sitemapOptionBuilder.addCurrentSubsite(getCmsObject().addSiteRoot(data.getReferenceSitePath()));\n        }\n        data.setSitemapSiteSelectorOptions(sitemapOptionBuilder.getOptions());\n\n        return data;\n    }","id":25788,"modified_method":"/**\n     * @see org.opencms.ade.galleries.shared.rpc.I_CmsGalleryService#getInitialSettings(org.opencms.ade.galleries.shared.CmsGalleryConfiguration)\n     */\n    public CmsGalleryDataBean getInitialSettings(CmsGalleryConfiguration conf) throws CmsRpcException {\n\n        CmsGalleryDataBean data = new CmsGalleryDataBean();\n        data.setMode(conf.getGalleryMode());\n        data.setLocales(buildLocalesMap());\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(conf.getLocale())) {\n            data.setLocale(conf.getLocale());\n        } else {\n            data.setLocale(getCmsObject().getRequestContext().getLocale().toString());\n        }\n        data.setVfsRootFolders(getRootEntries());\n        data.setScope(getWorkplaceSettings().getLastSearchScope());\n\n        List<CmsResourceTypeBean> types = null;\n        switch (conf.getGalleryMode()) {\n            case editor:\n            case view:\n            case widget:\n                data.setStartGallery(conf.getGalleryPath());\n                data.setCurrentElement(conf.getCurrentElement());\n                String referencePath = conf.getReferencePath();\n                if (CmsStringUtil.isEmptyOrWhitespaceOnly(referencePath)) {\n                    referencePath = data.getStartGallery();\n                }\n                data.setReferenceSitePath(referencePath);\n                types = getResourceTypeBeans(\n                    conf.getGalleryMode(),\n                    data.getReferenceSitePath(),\n                    conf.getResourceTypes());\n                data.setTypes(types);\n                Map<String, CmsGalleryTypeInfo> galleryTypeInfos = readGalleryInfosByTypeBeans(types);\n                // in case the 'gallerytypes' parameter is set, allow only the given galleries\n                if (conf.getGalleryTypes() != null) {\n                    Map<String, CmsGalleryTypeInfo> infos = new HashMap<String, CmsGalleryTypeInfo>();\n                    for (int i = 0; i < conf.getGalleryTypes().length; i++) {\n                        CmsGalleryTypeInfo typeInfo = galleryTypeInfos.get(conf.getGalleryTypes()[i]);\n                        if (typeInfo != null) {\n                            infos.put(conf.getGalleryTypes()[i], typeInfo);\n                        }\n                    }\n                    galleryTypeInfos = infos;\n                }\n                data.setGalleries(buildGalleriesList(galleryTypeInfos));\n                if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(conf.getStartFolder())) {\n                    try {\n                        CmsObject cloneCms = OpenCms.initCmsObject(getCmsObject());\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(conf.getStartSite())) {\n                            cloneCms.getRequestContext().setSiteRoot(conf.getStartSite());\n                        }\n                        if (cloneCms.existsResource(conf.getStartFolder(), CmsResourceFilter.ONLY_VISIBLE_NO_DELETED)) {\n                            data.setStartFolder(cloneCms.getRequestContext().addSiteRoot(conf.getStartFolder()));\n                        }\n                    } catch (CmsException e) {\n                        log(e.getMessage(), e);\n                    }\n                }\n                data.setStartTab(GalleryTabId.cms_tab_results);\n                if (CmsStringUtil.isEmptyOrWhitespaceOnly(data.getStartGallery()) && !types.isEmpty()) {\n                    String lastGallery = getWorkplaceSettings().getLastUsedGallery(types.get(0).getTypeId());\n                    // check if the gallery is available in this site and still exists\n                    if (getCmsObject().existsResource(lastGallery)) {\n                        data.setStartGallery(lastGallery);\n                    }\n                }\n                if (CmsStringUtil.isEmptyOrWhitespaceOnly(data.getStartGallery())\n                    && CmsStringUtil.isEmptyOrWhitespaceOnly(data.getCurrentElement())\n                    && CmsStringUtil.isEmptyOrWhitespaceOnly(data.getStartFolder())\n                    && (data.getTypes().size() > 1)) {\n                    data.setStartTab(GalleryTabId.cms_tab_galleries);\n                }\n                break;\n            case ade:\n                data.setReferenceSitePath(getCmsObject().getRequestContext().getUri());\n                types = getResourceTypeBeans(\n                    conf.getGalleryMode(),\n                    data.getReferenceSitePath(),\n                    conf.getResourceTypes());\n                data.setTypes(types);\n                Map<String, CmsGalleryTypeInfo> adeGalleryTypeInfos = readGalleryInfosByTypeBeans(types);\n                data.setGalleries(buildGalleriesList(adeGalleryTypeInfos));\n                data.setStartTab(GalleryTabId.cms_tab_types);\n                break;\n            default:\n                break;\n        }\n        CmsSiteSelectorOptionBuilder optionBuilder = new CmsSiteSelectorOptionBuilder(getCmsObject());\n        optionBuilder.addNormalSites(true, getWorkplaceSettings().getUserSettings().getStartFolder());\n        optionBuilder.addSharedSite();\n        data.setVfsSiteSelectorOptions(optionBuilder.getOptions());\n\n        CmsSiteSelectorOptionBuilder sitemapOptionBuilder = new CmsSiteSelectorOptionBuilder(getCmsObject());\n        sitemapOptionBuilder.addNormalSites(false, null);\n        if (data.getReferenceSitePath() != null) {\n            sitemapOptionBuilder.addCurrentSubsite(getCmsObject().addSiteRoot(data.getReferenceSitePath()));\n        }\n        data.setSitemapSiteSelectorOptions(sitemapOptionBuilder.getOptions());\n\n        return data;\n    }","commit_id":"7b7e85b4014db9fd9f0f769f7a65792d403f3408","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Adds 'normal' sites.<p>\r\n     * \r\n     * @param includeRoot if true, also adds the root site \r\n     */\r\n    public void addNormalSites(boolean includeRoot) {\r\n\r\n        CmsSiteManagerImpl siteManager = OpenCms.getSiteManager();\r\n        List<CmsSite> sites = siteManager.getAvailableSites(m_cms, true, false, m_cms.getRequestContext().getOuFqn());\r\n        try {\r\n            CmsObject rootCms = OpenCms.initCmsObject(m_cms);\r\n            rootCms.getRequestContext().setSiteRoot(\"/\");\r\n            for (CmsSite site : sites) {\r\n                String siteRoot = site.getSiteRoot();\r\n                if (rootCms.existsResource(siteRoot, CmsResourceFilter.ONLY_VISIBLE_NO_DELETED)) {\r\n                    Type type = Type.site;\r\n                    String message = siteRoot;\r\n                    if (siteRoot.equals(\"\")) {\r\n                        type = Type.root;\r\n                        message = \"/\";\r\n                        if (!includeRoot) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                    addOption(type, siteRoot, message);\r\n                }\r\n            }\r\n        } catch (CmsException e) {\r\n            // TODO: improve logging\r\n        }\r\n    }","id":25789,"modified_method":"/**\r\n     * Adds 'normal' sites.<p>\r\n     * \r\n     * @param includeRoot if true, also adds the root site \r\n     */\r\n    public void addNormalSites(boolean includeRoot, String startFolder) {\r\n\r\n        CmsSiteManagerImpl siteManager = OpenCms.getSiteManager();\r\n        List<CmsSite> sites = siteManager.getAvailableSites(m_cms, true, false, m_cms.getRequestContext().getOuFqn());\r\n        try {\r\n            CmsObject rootCms = OpenCms.initCmsObject(m_cms);\r\n            rootCms.getRequestContext().setSiteRoot(\"/\");\r\n            if (sites.isEmpty()) {\r\n                String siteRoot = m_cms.getRequestContext().getSiteRoot();\r\n                if (!rootCms.existsResource(siteRoot, CmsResourceFilter.ONLY_VISIBLE_NO_DELETED)) {\r\n                    if (startFolder != null) {\r\n                        siteRoot = CmsStringUtil.joinPaths(siteRoot, startFolder);\r\n                    }\r\n                    if ((startFolder == null)\r\n                        || !rootCms.existsResource(siteRoot, CmsResourceFilter.ONLY_VISIBLE_NO_DELETED)) {\r\n                        siteRoot = null;\r\n                    }\r\n                }\r\n                if (siteRoot != null) {\r\n                    Type type = Type.site;\r\n                    String message = siteRoot;\r\n                    addOption(type, siteRoot, message);\r\n                }\r\n            }\r\n            for (CmsSite site : sites) {\r\n                String siteRoot = site.getSiteRoot();\r\n                if (!rootCms.existsResource(siteRoot, CmsResourceFilter.ONLY_VISIBLE_NO_DELETED)) {\r\n                    if (startFolder != null) {\r\n                        siteRoot = CmsStringUtil.joinPaths(siteRoot, startFolder);\r\n                    }\r\n                    if ((startFolder == null)\r\n                        || !rootCms.existsResource(siteRoot, CmsResourceFilter.ONLY_VISIBLE_NO_DELETED)) {\r\n                        siteRoot = null;\r\n                    }\r\n                }\r\n                if (siteRoot != null) {\r\n                    Type type = Type.site;\r\n                    String message = siteRoot;\r\n                    if (siteRoot.equals(\"\")) {\r\n                        type = Type.root;\r\n                        message = \"/\";\r\n                        if (!includeRoot) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                    addOption(type, siteRoot, message);\r\n                }\r\n            }\r\n        } catch (CmsException e) {\r\n            // TODO: improve logging\r\n        }\r\n    }","commit_id":"7b7e85b4014db9fd9f0f769f7a65792d403f3408","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.file.wrapper.A_CmsResourceWrapper#readResource(CmsObject, String, CmsResourceFilter)\n     */\n    @Override\n    public CmsResource readResource(CmsObject cms, String resourcename, CmsResourceFilter filter) throws CmsException {\n\n        try {\n\n            // try to read the resource for the resource name\n            CmsResource res = cms.readResource(resourcename, filter);\n            if (CmsResourceTypeXmlPage.isXmlPage(res)) {\n                // return the xml page resource as a folder\n                return wrapResource(cms, res);\n            }\n\n            return null;\n        } catch (CmsVfsResourceNotFoundException ex) {\n\n            // find the xml page this is for\n            CmsResource xmlPage = findXmlPage(cms, resourcename);\n            if (xmlPage != null) {\n\n                // cut off trailing slash\n                if (resourcename.endsWith(\"/\")) {\n                    resourcename = resourcename.substring(0, resourcename.length() - 1);\n                }\n\n                // get the path below the xml page\n                String path = getSubPath(cms, xmlPage, resourcename);\n\n                CmsFile file = cms.readFile(xmlPage);\n                CmsXmlPage xml = CmsXmlPageFactory.unmarshal(cms, file);\n\n                String[] tokens = path.split(\"/\");\n                if (tokens.length == 1) {\n\n                    // check temp file table to remove deleted virtual files\n                    if (TMP_FILE_TABLE.contains(resourcename)) {\n                        return null;\n                    }\n\n                    // read the control code resource\n                    if (tokens[0].equals(NAME_ELEMENT_CONTROLCODE)) {\n\n                        CmsWrappedResource wrap = new CmsWrappedResource(xmlPage);\n                        wrap.setRootPath(xmlPage.getRootPath() + \"/\" + NAME_ELEMENT_CONTROLCODE);\n                        return wrap.getResource();\n                    } else {\n\n                        Locale locale = new Locale(tokens[0]);\n                        if (xml.hasLocale(locale) && (file.getLength() > 0)) {\n                            return getResourceForLocale(xmlPage, locale);\n                        }\n                    }\n                } else if (tokens.length == 2) {\n\n                    // cut off the html suffix\n                    String name = tokens[1];\n                    if (name.endsWith(\".\" + EXTENSION_ELEMENT)) {\n                        name = name.substring(0, name.length() - 5);\n                    }\n\n                    Locale locale = new Locale(tokens[0]);\n                    if (xml.hasValue(name, locale)) {\n                        String content = xml.getStringValue(cms, name, locale);\n                        String fullPath = xmlPage.getRootPath()\n                            + \"/\"\n                            + tokens[0]\n                            + \"/\"\n                            + name\n                            + \".\"\n                            + EXTENSION_ELEMENT;\n                        content = prepareContent(content, cms, xmlPage, fullPath);\n\n                        int length = content.length();\n                        try {\n                            length = content.getBytes(CmsLocaleManager.getResourceEncoding(cms, xmlPage)).length;\n                        } catch (UnsupportedEncodingException e) {\n                            // this will never happen since UTF-8 is always supported\n                        }\n\n                        return getResourceForElement(xmlPage, fullPath, length);\n                    }\n                }\n\n            }\n\n            return null;\n        }\n    }","id":25790,"modified_method":"/**\n     * @see org.opencms.file.wrapper.A_CmsResourceWrapper#readResource(CmsObject, String, CmsResourceFilter)\n     */\n    @Override\n    public CmsResource readResource(CmsObject cms, String resourcename, CmsResourceFilter filter) throws CmsException {\n\n        try {\n\n            // try to read the resource for the resource name\n            CmsResource res = null;\n            try {\n                // catch this exception to try to read the resource again if it fails\n                res = cms.readResource(resourcename, filter);\n            } catch (CmsException e) {\n                // read resource failed, so check if the resource name ends with a slash\n                if (resourcename.endsWith(\"/\")) {\n                    // try to read resource without a slash\n                    resourcename = CmsFileUtil.removeTrailingSeparator(resourcename);\n                    // try to read the resource name without ending slash\n                    res = cms.readResource(resourcename, filter);\n                } else {\n                    // throw the exception which caused this catch block\n                    throw e;\n                }\n            }\n            if (CmsResourceTypeXmlPage.isXmlPage(res)) {\n                // return the xml page resource as a folder\n                return wrapResource(cms, res);\n            }\n\n            return null;\n        } catch (CmsVfsResourceNotFoundException ex) {\n\n            // find the xml page this is for\n            CmsResource xmlPage = findXmlPage(cms, resourcename);\n            if (xmlPage != null) {\n\n                // cut off trailing slash\n                if (resourcename.endsWith(\"/\")) {\n                    resourcename = resourcename.substring(0, resourcename.length() - 1);\n                }\n\n                // get the path below the xml page\n                String path = getSubPath(cms, xmlPage, resourcename);\n\n                CmsFile file = cms.readFile(xmlPage);\n                CmsXmlPage xml = CmsXmlPageFactory.unmarshal(cms, file);\n\n                String[] tokens = path.split(\"/\");\n                if (tokens.length == 1) {\n\n                    // check temp file table to remove deleted virtual files\n                    if (TMP_FILE_TABLE.contains(resourcename)) {\n                        return null;\n                    }\n\n                    // read the control code resource\n                    if (tokens[0].equals(NAME_ELEMENT_CONTROLCODE)) {\n\n                        CmsWrappedResource wrap = new CmsWrappedResource(xmlPage);\n                        wrap.setRootPath(xmlPage.getRootPath() + \"/\" + NAME_ELEMENT_CONTROLCODE);\n                        return wrap.getResource();\n                    } else {\n\n                        Locale locale = new Locale(tokens[0]);\n                        if (xml.hasLocale(locale) && (file.getLength() > 0)) {\n                            return getResourceForLocale(xmlPage, locale);\n                        }\n                    }\n                } else if (tokens.length == 2) {\n\n                    // cut off the html suffix\n                    String name = tokens[1];\n                    if (name.endsWith(\".\" + EXTENSION_ELEMENT)) {\n                        name = name.substring(0, name.length() - 5);\n                    }\n\n                    Locale locale = new Locale(tokens[0]);\n                    if (xml.hasValue(name, locale)) {\n                        String content = xml.getStringValue(cms, name, locale);\n                        String fullPath = xmlPage.getRootPath()\n                            + \"/\"\n                            + tokens[0]\n                            + \"/\"\n                            + name\n                            + \".\"\n                            + EXTENSION_ELEMENT;\n                        content = prepareContent(content, cms, xmlPage, fullPath);\n\n                        int length = content.length();\n                        try {\n                            length = content.getBytes(CmsLocaleManager.getResourceEncoding(cms, xmlPage)).length;\n                        } catch (UnsupportedEncodingException e) {\n                            // this will never happen since UTF-8 is always supported\n                        }\n\n                        return getResourceForElement(xmlPage, fullPath, length);\n                    }\n                }\n\n            }\n\n            return null;\n        }\n    }","commit_id":"8e967b1ad6422808ef7789e149758113883fcbfc","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the {@link CmsResource} of the xml page which belongs to \n     * the given resource name (full path).<p>\n     * \n     * It works up the path till a resource for the path exists in the VFS. \n     * If the found resource is a xml page, this resource is returned. If \n     * the path does not belong to a xml page <code>null<\/code> will be returned.<p> \n     * \n     * @param cms the initialized CmsObject\n     * @param resourcename the name of the resource (full path) to check\n     * \n     * @return the found resource of type xml page or null if not found\n     */\n    private CmsResource findXmlPage(CmsObject cms, String resourcename) {\n\n        // get the full folder path of the resource to start from\n        String path = cms.getRequestContext().removeSiteRoot(resourcename);\n        do {\n\n            // check if the current folder exists\n            if (cms.existsResource(path)) {\n\n                try {\n                    CmsResource res = cms.readResource(path);\n                    I_CmsResourceType resType = OpenCms.getResourceManager().getResourceType(res.getTypeId());\n                    if (resType instanceof CmsResourceTypeXmlPage) {\n                        return res;\n                    } else {\n                        break;\n                    }\n                } catch (CmsException ex) {\n                    break;\n                }\n\n            } else {\n\n                // folder does not exist, go up one folder\n                path = CmsResource.getParentFolder(path);\n                if (path.endsWith(\"/\")) {\n                    path = path.substring(0, path.length() - 1);\n                }\n            }\n\n            if (CmsStringUtil.isEmpty(path)) {\n\n                // site root or root folder reached and no folder found\n                break;\n            }\n        } while (true);\n\n        return null;\n    }","id":25791,"modified_method":"/**\n     * Returns the {@link CmsResource} of the xml page which belongs to \n     * the given resource name (full path).<p>\n     * \n     * It works up the path till a resource for the path exists in the VFS. \n     * If the found resource is a xml page, this resource is returned. If \n     * the path does not belong to a xml page <code>null<\/code> will be returned.<p> \n     * \n     * @param cms the initialized CmsObject\n     * @param resourcename the name of the resource (full path) to check\n     * \n     * @return the found resource of type xml page or null if not found\n     */\n    private CmsResource findXmlPage(CmsObject cms, String resourcename) {\n\n        // get the full folder path of the resource to start from\n        String path = cms.getRequestContext().removeSiteRoot(resourcename);\n        // the path without the trailing slash\n        // for example: .../xmlpage.xml/ -> .../xmlpagepage.xml\n        String reducedPath = CmsFileUtil.removeTrailingSeparator(path);\n        do {\n\n            // check if a resource without the trailing shalsh exists\n            boolean existResource = cms.existsResource(reducedPath);\n            // check if the current folder exists\n            if (cms.existsResource(path) || existResource) {\n                // prove if a resource without the trailing slash does exist\n                if (existResource) {\n                    // a resource without the trailing slash does exist, so take the path without the trailing slash\n                    path = reducedPath;\n                }\n                try {\n                    CmsResource res = cms.readResource(path);\n                    I_CmsResourceType resType = OpenCms.getResourceManager().getResourceType(res.getTypeId());\n                    if (resType instanceof CmsResourceTypeXmlPage) {\n                        return res;\n                    } else {\n                        break;\n                    }\n                } catch (CmsException ex) {\n                    break;\n                }\n\n            } else {\n\n                // folder does not exist, go up one folder\n                path = CmsResource.getParentFolder(path);\n                if (path.endsWith(\"/\")) {\n                    path = path.substring(0, path.length() - 1);\n                }\n            }\n\n            if (CmsStringUtil.isEmpty(path)) {\n\n                // site root or root folder reached and no folder found\n                break;\n            }\n        } while (true);\n\n        return null;\n    }","commit_id":"8e967b1ad6422808ef7789e149758113883fcbfc","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Checks whether the given path/type combination belongs to a sitemap configuration.<p> \r\n     * \r\n     * @param rootPath the root path \r\n     * @param type the resource type id \r\n     * \r\n     * @return true if the path/type belong to an active sitemap configuration \r\n     */\r\n    protected boolean isSitemapConfiguration(String rootPath, int type) {\r\n\r\n        return rootPath.endsWith(\"/.content/.config\") && (type == m_configType.getTypeId());\r\n    }","id":25792,"modified_method":"/**\r\n     * Checks whether the given path/type combination belongs to a sitemap configuration.<p> \r\n     * \r\n     * @param rootPath the root path \r\n     * @param type the resource type id \r\n     * \r\n     * @return true if the path/type belong to an active sitemap configuration \r\n     */\r\n    protected boolean isSitemapConfiguration(String rootPath, int type) {\r\n\r\n        return rootPath.endsWith(CONFIG_SUFFIX) && (type == m_configType.getTypeId());\r\n    }","commit_id":"d3bb763f7b7bfb88317c776841979a52d6153f69","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ade.sitemap.shared.rpc.I_CmsSitemapService#mergeSubSitemap(java.lang.String, java.lang.String)\n     */\n    public CmsSitemapMergeInfo mergeSubSitemap(String entryPoint, String path) throws CmsRpcException {\n\n        CmsObject cms = getCmsObject();\n        try {\n            ensureSession();\n            String subSitemapPath = CmsResource.getFolderPath(path);\n            CmsResource subSitemapFolder = cms.readResource(subSitemapPath);\n            ensureLock(subSitemapFolder);\n            List<CmsProperty> propertyObjects = new ArrayList<CmsProperty>();\n            propertyObjects.add(new CmsProperty(CmsPropertyDefinition.PROPERTY_CONFIG_SITEMAP, \"\", \"\"));\n            cms.writePropertyObjects(subSitemapPath, propertyObjects);\n            subSitemapFolder.setType(OpenCms.getResourceManager().getResourceType(\n                CmsResourceTypeFolder.RESOURCE_TYPE_NAME).getTypeId());\n            tryUnlock(subSitemapFolder);\n            CmsSitemapClipboardData clipboard = getClipboardData();\n            CmsClientSitemapEntry entry = toClientEntry(getNavBuilder().getNavigationForResource(\n                cms.getSitePath(subSitemapFolder)), false);\n            clipboard.addModified(entry);\n            setClipboardData(clipboard);\n            return new CmsSitemapMergeInfo(getChildren(entryPoint, subSitemapPath, 1), System.currentTimeMillis());\n        } catch (Exception e) {\n            error(e);\n        }\n        return null;\n    }","id":25793,"modified_method":"/**\n     * @see org.opencms.ade.sitemap.shared.rpc.I_CmsSitemapService#mergeSubSitemap(java.lang.String, java.lang.String)\n     */\n    public CmsSitemapMergeInfo mergeSubSitemap(String entryPoint, String path) throws CmsRpcException {\n\n        CmsObject cms = getCmsObject();\n        try {\n            ensureSession();\n            String subSitemapPath = CmsResource.getFolderPath(path);\n            CmsResource subSitemapFolder = cms.readResource(subSitemapPath);\n            ensureLock(subSitemapFolder);\n            subSitemapFolder.setType(OpenCms.getResourceManager().getResourceType(\n                CmsResourceTypeFolder.RESOURCE_TYPE_NAME).getTypeId());\n            tryUnlock(subSitemapFolder);\n            CmsSitemapClipboardData clipboard = getClipboardData();\n            CmsClientSitemapEntry entry = toClientEntry(getNavBuilder().getNavigationForResource(\n                cms.getSitePath(subSitemapFolder)), false);\n            clipboard.addModified(entry);\n            setClipboardData(clipboard);\n            return new CmsSitemapMergeInfo(getChildren(entryPoint, subSitemapPath, 1), System.currentTimeMillis());\n        } catch (Exception e) {\n            error(e);\n        }\n        return null;\n    }","commit_id":"d3bb763f7b7bfb88317c776841979a52d6153f69","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ade.sitemap.shared.rpc.I_CmsSitemapService#createSubSitemap(java.lang.String, java.lang.String)\n     */\n    public CmsSubSitemapInfo createSubSitemap(String entryPoint, String path) throws CmsRpcException {\n\n        CmsObject cms = getCmsObject();\n        try {\n            ensureSession();\n            CmsResource subSitemapFolder = cms.readResource(path);\n            ensureLock(subSitemapFolder);\n            String folderName = CmsStringUtil.joinPaths(\"/\", \"_config\");\n            String sitemapConfigName = CmsStringUtil.joinPaths(folderName, \"sitemap_\"\n                + subSitemapFolder.getName()\n                + \".config\");\n            if (!cms.existsResource(folderName)) {\n                tryUnlock(cms.createResource(folderName, CmsResourceTypeFolder.getStaticTypeId()));\n            }\n            if (cms.existsResource(sitemapConfigName)) {\n                sitemapConfigName = OpenCms.getResourceManager().getNameGenerator().getNewFileName(\n                    cms,\n                    CmsStringUtil.joinPaths(folderName, \"sitemap_\" + subSitemapFolder.getName() + \"_%(number).config\"),\n                    2);\n            }\n            tryUnlock(cms.createResource(sitemapConfigName, OpenCms.getResourceManager().getResourceType(\n                \"sitemap_config\").getTypeId()));\n\n            List<CmsProperty> propertyObjects = new ArrayList<CmsProperty>();\n            propertyObjects.add(new CmsProperty(\n                CmsPropertyDefinition.PROPERTY_CONFIG_SITEMAP,\n                sitemapConfigName,\n                sitemapConfigName));\n            cms.writePropertyObjects(path, propertyObjects);\n            subSitemapFolder.setType(getEntryPointType());\n            cms.writeResource(subSitemapFolder);\n            tryUnlock(subSitemapFolder);\n\n            CmsSitemapClipboardData clipboard = getClipboardData();\n\n            CmsClientSitemapEntry entry = toClientEntry(getNavBuilder().getNavigationForResource(\n                cms.getSitePath(subSitemapFolder)), false);\n            clipboard.addModified(entry);\n            setClipboardData(clipboard);\n            return new CmsSubSitemapInfo(path, System.currentTimeMillis());\n        } catch (Exception e) {\n            error(e);\n        }\n        return null;\n    }","id":25794,"modified_method":"/**\n     * @see org.opencms.ade.sitemap.shared.rpc.I_CmsSitemapService#createSubSitemap(java.lang.String, java.lang.String)\n     */\n    public CmsSubSitemapInfo createSubSitemap(String entryPoint, String path) throws CmsRpcException {\n\n        CmsObject cms = getCmsObject();\n        try {\n            ensureSession();\n            CmsResource subSitemapFolder = cms.readResource(path);\n            ensureLock(subSitemapFolder);\n            String folderName = CmsStringUtil.joinPaths(path, CmsADEManager.CONFIG_FOLDER_NAME + \"/\");\n            String sitemapConfigName = CmsStringUtil.joinPaths(folderName, CmsADEManager.CONFIG_FILE_NAME);\n            if (!cms.existsResource(folderName)) {\n                tryUnlock(cms.createResource(folderName, CmsResourceTypeFolder.getStaticTypeId()));\n            }\n            I_CmsResourceType configType = OpenCms.getResourceManager().getResourceType(CmsADEManager.CONFIG_TYPE);\n            if (cms.existsResource(sitemapConfigName)) {\n                CmsResource configFile = cms.readResource(sitemapConfigName);\n                if (configFile.getTypeId() != configType.getTypeId()) {\n                    throw new CmsException(Messages.get().container(\n                        Messages.ERR_CREATING_SUB_SITEMAP_WRONG_CONFIG_FILE_TYPE_2,\n                        sitemapConfigName,\n                        CmsADEManager.CONFIG_TYPE));\n                }\n            } else {\n                cms.createResource(sitemapConfigName, OpenCms.getResourceManager().getResourceType(\n                    CmsADEManager.CONFIG_TYPE).getTypeId());\n            }\n            subSitemapFolder.setType(getEntryPointType());\n            cms.writeResource(subSitemapFolder);\n            tryUnlock(subSitemapFolder);\n            CmsSitemapClipboardData clipboard = getClipboardData();\n            CmsClientSitemapEntry entry = toClientEntry(getNavBuilder().getNavigationForResource(\n                cms.getSitePath(subSitemapFolder)), false);\n            clipboard.addModified(entry);\n            setClipboardData(clipboard);\n            return new CmsSubSitemapInfo(path, System.currentTimeMillis());\n        } catch (Exception e) {\n            error(e);\n        }\n        return null;\n    }","commit_id":"d3bb763f7b7bfb88317c776841979a52d6153f69","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void testLongHashcode() {\n\t\t\n\t\tbyte[] b1 = new byte[] { 1, 1, 2, 2, 3, 3 };\n\t\tbyte[] b2 = new byte[] { 2, 2, 3, 3, 4, 4 };\n\t\tbyte[] b3 = new byte[] { 1, 1, 2, 2, 3, 3 };\n\t\t\n\t\tLong l1 = new Long(Fields.longHashCode(b1));\n\t\tLong l2 = new Long(Fields.longHashCode(b2));\n\t\tLong l3 = new Long(Fields.longHashCode(b3));\n\n\t\tassertFalse(l1.equals(l2));\n\t\tassertFalse(l2.equals(l3));\n\t\tassertTrue(l3.equals(l1)); // should be same due to Fields.longHashcode\n\t}","id":25795,"modified_method":"public void testLongHashcode() {\n\t\t\n\t\tbyte[] b1 = new byte[] { 1, 1, 2, 2, 3, 3 };\n\t\tbyte[] b2 = new byte[] { 2, 2, 3, 3, 4, 4 };\n\t\tbyte[] b3 = new byte[] { 1, 1, 2, 2, 3, 3 };\n\t\t\n\t\tLong l1 = Fields.longHashCode(b1);\n\t\tLong l2 = Fields.longHashCode(b2);\n\t\tLong l3 = Fields.longHashCode(b3);\n\n\t\tassertFalse(l1.equals(l2));\n\t\tassertFalse(l2.equals(l3));\n\t\tassertTrue(l3.equals(l1)); // should be same due to Fields.longHashcode\n\t}","commit_id":"9286ce5afdc4bc39b265f18083655351d79dd242","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\t\t@SuppressWarnings(\"fallthrough\")\n\t\tpublic void run() {\n\t\t\tFile currentFilename = null;\n\t\t\tbyte[] o = null;\n\t\t\tlong thisTime;\n\t\t\tlong lastTime = -1;\n\t\t\tlong startTime;\n\t\t\tlong nextHour = -1;\n\t\t\tGregorianCalendar gc = null;\n\t\t\tif (baseFilename != null) {\n\t\t\t\tlatestFile = new File(baseFilename+\"-latest.log\");\n\t\t\t\tpreviousFile = new File(baseFilename+\"-previous.log\");\n\t\t\t\tfindOldLogFiles();\n\t\t\t\tgc = new GregorianCalendar();\n\t\t\t\tswitch (INTERVAL) {\n\t\t\t\t\tcase Calendar.YEAR :\n\t\t\t\t\t\tgc.set(Calendar.MONTH, 0);\n\t\t\t\t\tcase Calendar.MONTH :\n\t\t\t\t\t\tgc.set(Calendar.DAY_OF_MONTH, 0);\n\t\t\t\t\tcase Calendar.WEEK_OF_YEAR :\n\t\t\t\t\t\tif (INTERVAL == Calendar.WEEK_OF_YEAR)\n\t\t\t\t\t\t\tgc.set(Calendar.DAY_OF_WEEK, 0);\n\t\t\t\t\tcase Calendar.DAY_OF_MONTH :\n\t\t\t\t\t\tgc.set(Calendar.HOUR, 0);\n\t\t\t\t\tcase Calendar.HOUR :\n\t\t\t\t\t\tgc.set(Calendar.MINUTE, 0);\n\t\t\t\t\tcase Calendar.MINUTE :\n\t\t\t\t\t\tgc.set(Calendar.SECOND, 0);\n\t\t\t\t\t\tgc.set(Calendar.MILLISECOND, 0);\n\t\t\t\t}\n\t\t\t\tif(INTERVAL_MULTIPLIER > 1) {\n\t\t\t\t\tint x = gc.get(INTERVAL);\n\t\t\t\t\tgc.set(INTERVAL, (x / INTERVAL_MULTIPLIER) * INTERVAL_MULTIPLIER);\n\t\t\t\t}\n\t\t\t\tcurrentFilename = new File(getHourLogName(gc, true));\n\t\t\t\tsynchronized(logFiles) {\n\t\t\t\t\tif((!logFiles.isEmpty()) && logFiles.getLast().filename.equals(currentFilename)) {\n\t\t\t\t\t\tlogFiles.removeLast();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlogStream = openNewLogFile(currentFilename, true);\n\t\t\t\tif(latestFile != null) {\n\t\t\t\t\taltLogStream = openNewLogFile(latestFile, false);\n\t\t\t\t}\n\t\t\t\tSystem.err.println(\"Created log files\");\n\t\t\t\tstartTime = gc.getTimeInMillis();\n\t\t    \tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t    \t\tLogger.minor(this, \"Start time: \"+gc+\" -> \"+startTime);\n\t\t\t\tlastTime = startTime;\n\t\t\t\tgc.add(INTERVAL, INTERVAL_MULTIPLIER);\n\t\t\t\tnextHour = gc.getTimeInMillis();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\ttry {\n\t\t\t\t\tthisTime = System.currentTimeMillis();\n\t\t\t\t\tif (baseFilename != null) {\n\t\t\t\t\t\tif ((thisTime > nextHour) || switchedBaseFilename) {\n\t\t\t\t\t\t\tcurrentFilename = rotateLog(currentFilename, lastTime, nextHour, gc);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tgc.add(INTERVAL, INTERVAL_MULTIPLIER);\n\t\t\t\t\t\t\tlastTime = nextHour;\n\t\t\t\t\t\t\tnextHour = gc.getTimeInMillis();\n\n\t\t\t\t\t\t\tif(switchedBaseFilename) {\n\t\t\t\t\t\t\t\tsynchronized(FileLoggerHook.class) {\n\t\t\t\t\t\t\t\t\tswitchedBaseFilename = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(list.size() == 0) {\n\t\t\t\t\t\tif(currentFilename == null)\n\t\t\t\t\t\t\tmyWrite(logStream, null);\n\t\t\t\t        if(altLogStream != null)\n\t\t\t\t        \tmyWrite(altLogStream, null);\n\t\t\t\t\t}\n\t\t\t\t\tsynchronized (list) {\n\t\t\t\t\t\twhile (list.size() == 0) {\n\t\t\t\t\t\t\tif (closed) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.wait(500);\n\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\t// Ignored.\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\to = list.removeFirst();\n\t\t\t\t\t\tlistBytes -= o.length + LINE_OVERHEAD;\n\t\t\t\t\t}\n\t\t\t\t\tmyWrite(logStream,  o);\n\t\t\t        if(altLogStream != null)\n\t\t\t        \tmyWrite(altLogStream, o);\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\tSystem.err.println(e.getClass());\n\t\t\t\t\tSystem.err.println(e.getMessage());\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t    // FIXME\n\t\t\t\t\t//freenet.node.Main.dumpInterestingObjects();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tSystem.err.println(\"FileLoggerHook log writer caught \" + t);\n\t\t\t\t\tt.printStackTrace(System.err);\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":25796,"modified_method":"@Override\n\t\t@SuppressWarnings(\"fallthrough\")\n\t\tpublic void run() {\n\t\t\tFile currentFilename = null;\n\t\t\tbyte[] o = null;\n\t\t\tlong thisTime;\n\t\t\tlong lastTime = -1;\n\t\t\tlong startTime;\n\t\t\tlong nextHour = -1;\n\t\t\tGregorianCalendar gc = null;\n\t\t\tif (baseFilename != null) {\n\t\t\t\tlatestFile = new File(baseFilename+\"-latest.log\");\n\t\t\t\tpreviousFile = new File(baseFilename+\"-previous.log\");\n\t\t\t\tfindOldLogFiles();\n\t\t\t\tgc = new GregorianCalendar();\n\t\t\t\tswitch (INTERVAL) {\n\t\t\t\t\tcase Calendar.YEAR :\n\t\t\t\t\t\tgc.set(Calendar.MONTH, 0);\n\t\t\t\t\tcase Calendar.MONTH :\n\t\t\t\t\t\tgc.set(Calendar.DAY_OF_MONTH, 0);\n\t\t\t\t\tcase Calendar.WEEK_OF_YEAR :\n\t\t\t\t\t\tif (INTERVAL == Calendar.WEEK_OF_YEAR)\n\t\t\t\t\t\t\tgc.set(Calendar.DAY_OF_WEEK, 0);\n\t\t\t\t\tcase Calendar.DAY_OF_MONTH :\n\t\t\t\t\t\tgc.set(Calendar.HOUR, 0);\n\t\t\t\t\tcase Calendar.HOUR :\n\t\t\t\t\t\tgc.set(Calendar.MINUTE, 0);\n\t\t\t\t\tcase Calendar.MINUTE :\n\t\t\t\t\t\tgc.set(Calendar.SECOND, 0);\n\t\t\t\t\t\tgc.set(Calendar.MILLISECOND, 0);\n\t\t\t\t}\n\t\t\t\tif(INTERVAL_MULTIPLIER > 1) {\n\t\t\t\t\tint x = gc.get(INTERVAL);\n\t\t\t\t\tgc.set(INTERVAL, (x / INTERVAL_MULTIPLIER) * INTERVAL_MULTIPLIER);\n\t\t\t\t}\n\t\t\t\tcurrentFilename = new File(getHourLogName(gc, -1, true));\n\t\t\t\tsynchronized(logFiles) {\n\t\t\t\t\tif((!logFiles.isEmpty()) && logFiles.getLast().filename.equals(currentFilename)) {\n\t\t\t\t\t\tlogFiles.removeLast();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlogStream = openNewLogFile(currentFilename, true);\n\t\t\t\tif(latestFile != null) {\n\t\t\t\t\taltLogStream = openNewLogFile(latestFile, false);\n\t\t\t\t}\n\t\t\t\tSystem.err.println(\"Created log files\");\n\t\t\t\tstartTime = gc.getTimeInMillis();\n\t\t    \tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t    \t\tLogger.minor(this, \"Start time: \"+gc+\" -> \"+startTime);\n\t\t\t\tlastTime = startTime;\n\t\t\t\tgc.add(INTERVAL, INTERVAL_MULTIPLIER);\n\t\t\t\tnextHour = gc.getTimeInMillis();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\ttry {\n\t\t\t\t\tthisTime = System.currentTimeMillis();\n\t\t\t\t\tif (baseFilename != null) {\n\t\t\t\t\t\tif ((thisTime > nextHour) || switchedBaseFilename) {\n\t\t\t\t\t\t\tcurrentFilename = rotateLog(currentFilename, lastTime, nextHour, gc);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tgc.add(INTERVAL, INTERVAL_MULTIPLIER);\n\t\t\t\t\t\t\tlastTime = nextHour;\n\t\t\t\t\t\t\tnextHour = gc.getTimeInMillis();\n\n\t\t\t\t\t\t\tif(switchedBaseFilename) {\n\t\t\t\t\t\t\t\tsynchronized(FileLoggerHook.class) {\n\t\t\t\t\t\t\t\t\tswitchedBaseFilename = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(list.size() == 0) {\n\t\t\t\t\t\tif(currentFilename == null)\n\t\t\t\t\t\t\tmyWrite(logStream, null);\n\t\t\t\t        if(altLogStream != null)\n\t\t\t\t        \tmyWrite(altLogStream, null);\n\t\t\t\t\t}\n\t\t\t\t\tsynchronized (list) {\n\t\t\t\t\t\twhile (list.size() == 0) {\n\t\t\t\t\t\t\tif (closed) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.wait(500);\n\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\t// Ignored.\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\to = list.removeFirst();\n\t\t\t\t\t\tlistBytes -= o.length + LINE_OVERHEAD;\n\t\t\t\t\t}\n\t\t\t\t\tmyWrite(logStream,  o);\n\t\t\t        if(altLogStream != null)\n\t\t\t        \tmyWrite(altLogStream, o);\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\tSystem.err.println(e.getClass());\n\t\t\t\t\tSystem.err.println(e.getMessage());\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t    // FIXME\n\t\t\t\t\t//freenet.node.Main.dumpInterestingObjects();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tSystem.err.println(\"FileLoggerHook log writer caught \" + t);\n\t\t\t\t\tt.printStackTrace(System.err);\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"9286ce5afdc4bc39b265f18083655351d79dd242","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * The extra parameter int digit is to be used for creating a logfile name\n\t * when a log exists already with the same date.\n\t * @param c\n\t * @param digit\n\t * @param compressed\n\t * @return\n\t */\n\tprotected String getHourLogName(Calendar c, int digit, boolean compressed){\n\t\tStringBuilder buf = new StringBuilder(50);\n\t\tbuf.append(baseFilename).append('-');\n\t\tbuf.append(Version.buildNumber());\n\t\tbuf.append('-');\n\t\tbuf.append(c.get(Calendar.YEAR)).append('-');\n\t\tpad2digits(buf, c.get(Calendar.MONTH) + 1);\n\t\tbuf.append('-');\n\t\tpad2digits(buf, c.get(Calendar.DAY_OF_MONTH));\n\t\tbuf.append('-');\n\t\tpad2digits(buf, c.get(Calendar.HOUR_OF_DAY));\n\t\tif (INTERVAL == Calendar.MINUTE) {\n\t\t\tbuf.append('-');\n\t\t\tpad2digits(buf, c.get(Calendar.MINUTE));\n\t\t}\n\t\tbuf.append(\"-\");\n\t\tbuf.append(digit);\n\t\tbuf.append(\".log\");\n\t\tif(compressed) buf.append(\".gz\");\n\t\treturn buf.toString();\n\t}","id":25797,"modified_method":"/**\n\t * The extra parameter int digit is to be used for creating a logfile name\n\t * when a log exists already with the same date.\n\t * @param c\n\t * @param digit\n\t *\t\t\tlog file name suffix. ignored if this is {@code < 0}\n\t * @param compressed\n\t * @return\n\t */\n\tprotected String getHourLogName(Calendar c, int digit, boolean compressed){\n\t\tStringBuilder buf = new StringBuilder(50);\n\t\tbuf.append(baseFilename).append('-');\n\t\tbuf.append(Version.buildNumber());\n\t\tbuf.append('-');\n\t\tbuf.append(c.get(Calendar.YEAR)).append('-');\n\t\tpad2digits(buf, c.get(Calendar.MONTH) + 1);\n\t\tbuf.append('-');\n\t\tpad2digits(buf, c.get(Calendar.DAY_OF_MONTH));\n\t\tbuf.append('-');\n\t\tpad2digits(buf, c.get(Calendar.HOUR_OF_DAY));\n\t\tif (INTERVAL == Calendar.MINUTE) {\n\t\t\tbuf.append('-');\n\t\t\tpad2digits(buf, c.get(Calendar.MINUTE));\n\t\t}\n\t\tif (digit > 0) {\n\t\t\tbuf.append(\"-\");\n\t\t\tbuf.append(digit);\n\t\t}\n\t\tbuf.append(\".log\");\n\t\tif(compressed) buf.append(\".gz\");\n\t\treturn buf.toString();\n\t}","commit_id":"9286ce5afdc4bc39b265f18083655351d79dd242","url":"https://github.com/freenet/fred"},{"original_method":"/** Initialize oldLogFiles */\n\tpublic void findOldLogFiles() {\n\t\tGregorianCalendar gc = new GregorianCalendar();\n\t\tFile currentFilename = new File(getHourLogName(gc, true));\n\t\tFile numericSameDateFilename;\n\t\tint slashIndex = baseFilename.lastIndexOf(File.separatorChar);\n\t\tFile dir;\n\t\tString prefix;\n\t\tif(slashIndex == -1) {\n\t\t\tdir = new File(System.getProperty(\"user.dir\"));\n\t\t\tprefix = baseFilename.toLowerCase();\n\t\t} else {\n\t\t\tdir = new File(baseFilename.substring(0, slashIndex));\n\t\t\tprefix = baseFilename.substring(slashIndex+1).toLowerCase();\n\t\t}\n\t\tFile[] files = dir.listFiles();\n\t\tif(files == null) return;\n\t\tjava.util.Arrays.sort(files);\n\t\tlong lastStartTime = -1;\n\t\tFile oldFile = null;\n        if(latestFile.exists())\n        \tFileUtil.renameTo(latestFile, previousFile);\n        \n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tfor(int i=0;i<files.length;i++) {\n\t\t\tFile f = files[i];\n\t\t\tString name = f.getName();\n\t\t\tif(name.toLowerCase().startsWith(prefix)) {\n\t\t\t\tif(name.equals(previousFile.getName()) || name.equals(latestFile.getName())) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!name.endsWith(\".log.gz\")) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Does not end in .log.gz: \"+name);\n\t\t\t\t\tf.delete();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tname = name.substring(0, name.length()-\".log.gz\".length());\n\t\t\t\t}\n\t\t\t\tname = name.substring(prefix.length());\n\t\t\t\tif((name.length() == 0) || (name.charAt(0) != '-')) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Deleting unrecognized: \"+name+\" (\"+f.getPath()+ ')');\n\t\t\t\t\tf.delete();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else\n\t\t\t\t\tname = name.substring(1);\n\t\t\t\tString[] tokens = name.split(\"-\");\n\t\t\t\tint[] nums = new int[tokens.length];\n\t\t\t\tfor(int j=0;j<tokens.length;j++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnums[j] = Integer.parseInt(tokens[j]);\n\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\tLogger.normal(this, \"Could not parse: \"+tokens[j]+\" into number from \"+name);\n\t\t\t\t\t\t// Broken\n\t\t\t\t\t\tf.delete();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// First field: version\n\t\t\t\tif(nums[0] != Version.buildNumber()) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Deleting old log from build \"+nums[0]+\", current=\"+Version.buildNumber());\n\t\t\t\t\t// Logs that old are useless\n\t\t\t\t\tf.delete();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(nums.length > 1)\n\t\t\t\t\tgc.set(Calendar.YEAR, nums[1]);\n\t\t\t\tif(nums.length > 2)\n\t\t\t\t\tgc.set(Calendar.MONTH, nums[2]-1);\n\t\t\t\tif(nums.length > 3)\n\t\t\t\t\tgc.set(Calendar.DAY_OF_MONTH, nums[3]);\n\t\t\t\tif(nums.length > 4)\n\t\t\t\t\tgc.set(Calendar.HOUR_OF_DAY, nums[4]);\n\t\t\t\tif(nums.length > 5)\n\t\t\t\t\tgc.set(Calendar.MINUTE, nums[5]);\n\t\t\t\tgc.set(Calendar.SECOND, 0);\n\t\t\t\tgc.set(Calendar.MILLISECOND, 0);\n\t\t\t\tlong startTime = gc.getTimeInMillis();\n\t\t\t\tif(oldFile != null) {\n\t\t\t\t\tlong l = oldFile.length();\n\t\t\t\t\tOldLogFile olf = new OldLogFile(oldFile, lastStartTime, startTime, l);\n\t\t\t\t\tsynchronized(logFiles) {\n\t\t\t\t\t\tlogFiles.addLast(olf);\n\t\t\t\t\t}\n\t\t\t\t\tsynchronized(trimOldLogFilesLock) {\n\t\t\t\t\t\toldLogFilesDiskSpaceUsage += l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastStartTime = startTime;\n\t\t\t\toldFile = f;\n\t\t\t} else {\n\t\t\t\t// Nothing to do with us\n\t\t\t\tLogger.normal(this, \"Unknown file: \"+name+\" in the log directory\");\n\t\t\t}\n\t\t}\n\t\t//If a compressed log file already exists for a given date,\n\t\t//add a number to the end of the file that already exists\n\t\tfor(int a = 1; currentFilename != null && currentFilename.exists(); a++){\n\t\t\tnumericSameDateFilename = new File(getHourLogName(gc, a, true));\n\t\t\tif(numericSameDateFilename != null && numericSameDateFilename.exists()){\n\t\t\t\tcurrentFilename = numericSameDateFilename;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tFileUtil.renameTo(currentFilename, numericSameDateFilename);\n\t\t\t\tcurrentFilename = numericSameDateFilename;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(oldFile != null) {\n\t\t\tlong l = oldFile.length();\n\t\t\tOldLogFile olf = new OldLogFile(oldFile, lastStartTime, System.currentTimeMillis(), l);\n\t\t\tsynchronized(logFiles) {\n\t\t\t\tlogFiles.addLast(olf);\n\t\t\t}\n\t\t\tsynchronized(trimOldLogFilesLock) {\n\t\t\t\toldLogFilesDiskSpaceUsage += l;\n\t\t\t}\n\t\t}\n\t\ttrimOldLogFiles();\n\t}","id":25798,"modified_method":"/** Initialize oldLogFiles */\n\tpublic void findOldLogFiles() {\n\t\tGregorianCalendar gc = new GregorianCalendar();\n\t\tFile currentFilename = new File(getHourLogName(gc, -1, true));\n\t\tFile numericSameDateFilename;\n\t\tint slashIndex = baseFilename.lastIndexOf(File.separatorChar);\n\t\tFile dir;\n\t\tString prefix;\n\t\tif(slashIndex == -1) {\n\t\t\tdir = new File(System.getProperty(\"user.dir\"));\n\t\t\tprefix = baseFilename.toLowerCase();\n\t\t} else {\n\t\t\tdir = new File(baseFilename.substring(0, slashIndex));\n\t\t\tprefix = baseFilename.substring(slashIndex+1).toLowerCase();\n\t\t}\n\t\tFile[] files = dir.listFiles();\n\t\tif(files == null) return;\n\t\tjava.util.Arrays.sort(files);\n\t\tlong lastStartTime = -1;\n\t\tFile oldFile = null;\n        if(latestFile.exists())\n        \tFileUtil.renameTo(latestFile, previousFile);\n        \n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tfor(int i=0;i<files.length;i++) {\n\t\t\tFile f = files[i];\n\t\t\tString name = f.getName();\n\t\t\tif(name.toLowerCase().startsWith(prefix)) {\n\t\t\t\tif(name.equals(previousFile.getName()) || name.equals(latestFile.getName())) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!name.endsWith(\".log.gz\")) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Does not end in .log.gz: \"+name);\n\t\t\t\t\tf.delete();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tname = name.substring(0, name.length()-\".log.gz\".length());\n\t\t\t\t}\n\t\t\t\tname = name.substring(prefix.length());\n\t\t\t\tif((name.length() == 0) || (name.charAt(0) != '-')) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Deleting unrecognized: \"+name+\" (\"+f.getPath()+ ')');\n\t\t\t\t\tf.delete();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else\n\t\t\t\t\tname = name.substring(1);\n\t\t\t\tString[] tokens = name.split(\"-\");\n\t\t\t\tint[] nums = new int[tokens.length];\n\t\t\t\tfor(int j=0;j<tokens.length;j++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnums[j] = Integer.parseInt(tokens[j]);\n\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\tLogger.normal(this, \"Could not parse: \"+tokens[j]+\" into number from \"+name);\n\t\t\t\t\t\t// Broken\n\t\t\t\t\t\tf.delete();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// First field: version\n\t\t\t\tif(nums[0] != Version.buildNumber()) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Deleting old log from build \"+nums[0]+\", current=\"+Version.buildNumber());\n\t\t\t\t\t// Logs that old are useless\n\t\t\t\t\tf.delete();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(nums.length > 1)\n\t\t\t\t\tgc.set(Calendar.YEAR, nums[1]);\n\t\t\t\tif(nums.length > 2)\n\t\t\t\t\tgc.set(Calendar.MONTH, nums[2]-1);\n\t\t\t\tif(nums.length > 3)\n\t\t\t\t\tgc.set(Calendar.DAY_OF_MONTH, nums[3]);\n\t\t\t\tif(nums.length > 4)\n\t\t\t\t\tgc.set(Calendar.HOUR_OF_DAY, nums[4]);\n\t\t\t\tif(nums.length > 5)\n\t\t\t\t\tgc.set(Calendar.MINUTE, nums[5]);\n\t\t\t\tgc.set(Calendar.SECOND, 0);\n\t\t\t\tgc.set(Calendar.MILLISECOND, 0);\n\t\t\t\tlong startTime = gc.getTimeInMillis();\n\t\t\t\tif(oldFile != null) {\n\t\t\t\t\tlong l = oldFile.length();\n\t\t\t\t\tOldLogFile olf = new OldLogFile(oldFile, lastStartTime, startTime, l);\n\t\t\t\t\tsynchronized(logFiles) {\n\t\t\t\t\t\tlogFiles.addLast(olf);\n\t\t\t\t\t}\n\t\t\t\t\tsynchronized(trimOldLogFilesLock) {\n\t\t\t\t\t\toldLogFilesDiskSpaceUsage += l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastStartTime = startTime;\n\t\t\t\toldFile = f;\n\t\t\t} else {\n\t\t\t\t// Nothing to do with us\n\t\t\t\tLogger.normal(this, \"Unknown file: \"+name+\" in the log directory\");\n\t\t\t}\n\t\t}\n\t\t//If a compressed log file already exists for a given date,\n\t\t//add a number to the end of the file that already exists\n\t\tfor(int a = 1; currentFilename != null && currentFilename.exists(); a++){\n\t\t\tnumericSameDateFilename = new File(getHourLogName(gc, a, true));\n\t\t\tif(numericSameDateFilename != null && numericSameDateFilename.exists()){\n\t\t\t\tcurrentFilename = numericSameDateFilename;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tFileUtil.renameTo(currentFilename, numericSameDateFilename);\n\t\t\t\tcurrentFilename = numericSameDateFilename;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(oldFile != null) {\n\t\t\tlong l = oldFile.length();\n\t\t\tOldLogFile olf = new OldLogFile(oldFile, lastStartTime, System.currentTimeMillis(), l);\n\t\t\tsynchronized(logFiles) {\n\t\t\t\tlogFiles.addLast(olf);\n\t\t\t}\n\t\t\tsynchronized(trimOldLogFilesLock) {\n\t\t\t\toldLogFilesDiskSpaceUsage += l;\n\t\t\t}\n\t\t}\n\t\ttrimOldLogFiles();\n\t}","commit_id":"9286ce5afdc4bc39b265f18083655351d79dd242","url":"https://github.com/freenet/fred"},{"original_method":"private File rotateLog(File currentFilename, long lastTime, long nextHour, GregorianCalendar gc) {\n\t        // Switch logs\n\t        try {\n\t        \tlogStream.flush();\n\t        \tif(altLogStream != null) altLogStream.flush();\n\t        } catch (IOException e) {\n\t        \tSystem.err.println(\n\t        \t\t\"Flushing on change caught \" + e);\n\t        }\n\t        try {\n\t        \tlogStream.close();\n\t        } catch (IOException e) {\n\t        \tSystem.err.println(\n\t        \t\t\t\"Closing on change caught \" + e);\n\t        }\n\t        long length = currentFilename.length();\n\t        OldLogFile olf = new OldLogFile(currentFilename, lastTime, nextHour, length);\n\t        synchronized(logFiles) {\n\t        \tlogFiles.addLast(olf);\n\t        }\n\t        oldLogFilesDiskSpaceUsage += length;\n\t        trimOldLogFiles();\n\t        // Rotate primary log stream\n\t        currentFilename = new File(getHourLogName(gc, true));\n\t        logStream = openNewLogFile(currentFilename, true);\n\t        if(latestFile != null) {\n\t        \ttry {\n\t        \t\taltLogStream.close();\n\t        \t} catch (IOException e) {\n\t        \t\tSystem.err.println(\n\t        \t\t\t\t\"Closing alt on change caught \" + e);\n\t        \t}\n\t        \tif(previousFile != null && previousFile.exists())\n\t        \t\tFileUtil.renameTo(latestFile, previousFile);\n\t        \tlatestFile.delete();\n\t        \taltLogStream = openNewLogFile(latestFile, false);\n\t        }\n\t        return currentFilename;\n        }","id":25799,"modified_method":"private File rotateLog(File currentFilename, long lastTime, long nextHour, GregorianCalendar gc) {\n\t        // Switch logs\n\t        try {\n\t        \tlogStream.flush();\n\t        \tif(altLogStream != null) altLogStream.flush();\n\t        } catch (IOException e) {\n\t        \tSystem.err.println(\n\t        \t\t\"Flushing on change caught \" + e);\n\t        }\n\t        try {\n\t        \tlogStream.close();\n\t        } catch (IOException e) {\n\t        \tSystem.err.println(\n\t        \t\t\t\"Closing on change caught \" + e);\n\t        }\n\t        long length = currentFilename.length();\n\t        OldLogFile olf = new OldLogFile(currentFilename, lastTime, nextHour, length);\n\t        synchronized(logFiles) {\n\t        \tlogFiles.addLast(olf);\n\t        }\n\t        oldLogFilesDiskSpaceUsage += length;\n\t        trimOldLogFiles();\n\t        // Rotate primary log stream\n\t        currentFilename = new File(getHourLogName(gc, -1, true));\n\t        logStream = openNewLogFile(currentFilename, true);\n\t        if(latestFile != null) {\n\t        \ttry {\n\t        \t\taltLogStream.close();\n\t        \t} catch (IOException e) {\n\t        \t\tSystem.err.println(\n\t        \t\t\t\t\"Closing alt on change caught \" + e);\n\t        \t}\n\t        \tif(previousFile != null && previousFile.exists())\n\t        \t\tFileUtil.renameTo(latestFile, previousFile);\n\t        \tlatestFile.delete();\n\t        \taltLogStream = openNewLogFile(latestFile, false);\n\t        }\n\t        return currentFilename;\n        }","commit_id":"9286ce5afdc4bc39b265f18083655351d79dd242","url":"https://github.com/freenet/fred"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public static List<Class> getDaoClasses() {\n    return ImmutableList.<Class>of(\n      ActionPlanDao.class,\n      ActionPlanStatsDao.class,\n      ActiveDashboardDao.class,\n      ActiveRuleDao.class,\n      AuthorDao.class,\n      AuthorizationDao.class,\n      DashboardDao.class,\n      DuplicationDao.class,\n      GroupMembershipDao.class,\n      IssueDao.class,\n      IssueChangeDao.class,\n      IssueFilterDao.class,\n      IssueFilterFavouriteDao.class,\n      LoadedTemplateDao.class,\n      NotificationQueueDao.class,\n      PermissionDao.class,\n      PermissionTemplateDao.class,\n      PropertiesDao.class,\n      QualityProfileDao.class,\n      PurgeDao.class,\n      CharacteristicDao.class,\n      ResourceIndexerDao.class,\n      ResourceDao.class,\n      ResourceKeyUpdaterDao.class,\n      RoleDao.class,\n      RuleDao.class,\n      SemaphoreDao.class,\n      UserDao.class\n      );\n  }","id":25800,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public static List<Class> getDaoClasses() {\n    return ImmutableList.<Class>of(\n      ActionPlanDao.class,\n      ActionPlanStatsDao.class,\n      ActiveDashboardDao.class,\n      ActiveRuleDao.class,\n      AuthorDao.class,\n      AuthorizationDao.class,\n      DashboardDao.class,\n      DuplicationDao.class,\n      GroupMembershipDao.class,\n      IssueDao.class,\n      IssueChangeDao.class,\n      IssueFilterDao.class,\n      IssueFilterFavouriteDao.class,\n      LoadedTemplateDao.class,\n      NotificationQueueDao.class,\n      PermissionDao.class,\n      PermissionTemplateDao.class,\n      PropertiesDao.class,\n      QualityGateConditionDao.class,\n      QualityProfileDao.class,\n      PurgeDao.class,\n      CharacteristicDao.class,\n      ResourceIndexerDao.class,\n      ResourceDao.class,\n      ResourceKeyUpdaterDao.class,\n      RoleDao.class,\n      RuleDao.class,\n      SemaphoreDao.class,\n      UserDao.class\n      );\n  }","commit_id":"021bf45623b748e70f20d956e86d595191241786","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public DbClient(Database db, MyBatis myBatis, DaoComponent... daoComponents) {\n    this.db = db;\n    this.myBatis = myBatis;\n\n    Map<Class, DaoComponent> map = new IdentityHashMap<>();\n    for (DaoComponent daoComponent : daoComponents) {\n      map.put(daoComponent.getClass(), daoComponent);\n    }\n    ruleDao = getDao(map, RuleDao.class);\n    activeRuleDao = getDao(map, ActiveRuleDao.class);\n    debtCharacteristicDao = getDao(map, CharacteristicDao.class);\n    qualityProfileDao = getDao(map, QualityProfileDao.class);\n    loadedTemplateDao = getDao(map, LoadedTemplateDao.class);\n    propertiesDao = getDao(map, PropertiesDao.class);\n    componentDao = getDao(map, ComponentDao.class);\n    snapshotDao = getDao(map, SnapshotDao.class);\n    resourceDao = getDao(map, ResourceDao.class);\n    measureDao = getDao(map, MeasureDao.class);\n    metricDao = getDao(map, MetricDao.class);\n    customMeasureDao = getDao(map, CustomMeasureDao.class);\n    activityDao = getDao(map, ActivityDao.class);\n    authorizationDao = getDao(map, AuthorizationDao.class);\n    userDao = getDao(map, UserDao.class);\n    groupDao = getDao(map, GroupDao.class);\n    userGroupDao = getDao(map, UserGroupDao.class);\n    groupMembershipDao = getDao(map, GroupMembershipDao.class);\n    roleDao = getDao(map, RoleDao.class);\n    permissionTemplateDao = getDao(map, PermissionTemplateDao.class);\n    issueDao = getDao(map, IssueDao.class);\n    issueFilterDao = getDao(map, IssueFilterDao.class);\n    issueChangeDao = getDao(map, IssueChangeDao.class);\n    actionPlanDao = getDao(map, ActionPlanDao.class);\n    analysisReportDao = getDao(map, AnalysisReportDao.class);\n    dashboardDao = getDao(map, DashboardDao.class);\n    widgetDao = getDao(map, WidgetDao.class);\n    widgetPropertyDao = getDao(map, WidgetPropertyDao.class);\n    fileSourceDao = getDao(map, FileSourceDao.class);\n    authorDao = getDao(map, AuthorDao.class);\n    componentIndexDao = getDao(map, ComponentIndexDao.class);\n    componentLinkDao = getDao(map, ComponentLinkDao.class);\n    eventDao = getDao(map, EventDao.class);\n    purgeDao = getDao(map, PurgeDao.class);\n  }","id":25801,"modified_method":"public DbClient(Database db, MyBatis myBatis, DaoComponent... daoComponents) {\n    this.db = db;\n    this.myBatis = myBatis;\n\n    Map<Class, DaoComponent> map = new IdentityHashMap<>();\n    for (DaoComponent daoComponent : daoComponents) {\n      map.put(daoComponent.getClass(), daoComponent);\n    }\n    ruleDao = getDao(map, RuleDao.class);\n    activeRuleDao = getDao(map, ActiveRuleDao.class);\n    debtCharacteristicDao = getDao(map, CharacteristicDao.class);\n    qualityProfileDao = getDao(map, QualityProfileDao.class);\n    loadedTemplateDao = getDao(map, LoadedTemplateDao.class);\n    propertiesDao = getDao(map, PropertiesDao.class);\n    componentDao = getDao(map, ComponentDao.class);\n    snapshotDao = getDao(map, SnapshotDao.class);\n    resourceDao = getDao(map, ResourceDao.class);\n    measureDao = getDao(map, MeasureDao.class);\n    metricDao = getDao(map, MetricDao.class);\n    customMeasureDao = getDao(map, CustomMeasureDao.class);\n    activityDao = getDao(map, ActivityDao.class);\n    authorizationDao = getDao(map, AuthorizationDao.class);\n    userDao = getDao(map, UserDao.class);\n    groupDao = getDao(map, GroupDao.class);\n    userGroupDao = getDao(map, UserGroupDao.class);\n    groupMembershipDao = getDao(map, GroupMembershipDao.class);\n    roleDao = getDao(map, RoleDao.class);\n    permissionTemplateDao = getDao(map, PermissionTemplateDao.class);\n    issueDao = getDao(map, IssueDao.class);\n    issueFilterDao = getDao(map, IssueFilterDao.class);\n    issueChangeDao = getDao(map, IssueChangeDao.class);\n    actionPlanDao = getDao(map, ActionPlanDao.class);\n    analysisReportDao = getDao(map, AnalysisReportDao.class);\n    dashboardDao = getDao(map, DashboardDao.class);\n    widgetDao = getDao(map, WidgetDao.class);\n    widgetPropertyDao = getDao(map, WidgetPropertyDao.class);\n    fileSourceDao = getDao(map, FileSourceDao.class);\n    authorDao = getDao(map, AuthorDao.class);\n    componentIndexDao = getDao(map, ComponentIndexDao.class);\n    componentLinkDao = getDao(map, ComponentLinkDao.class);\n    eventDao = getDao(map, EventDao.class);\n    purgeDao = getDao(map, PurgeDao.class);\n    gateConditionDao = getDao(map, QualityGateConditionDao.class);\n  }","commit_id":"021bf45623b748e70f20d956e86d595191241786","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request request, Response response) throws Exception {\n    userSession.checkLoggedIn().checkGlobalPermission(GlobalPermissions.SYSTEM_ADMIN);\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      List<Integer> ids = loadIds(dbSession, request);\n      dbClient.metricDao().disable(dbSession, ids);\n      dbClient.customMeasureDao().deleteByMetricIds(dbSession, ids);\n      dbSession.commit();\n    } finally {\n      MyBatis.closeQuietly(dbSession);\n    }\n\n    response.noContent();\n    rubyBridge.metricCache().invalidate();\n  }","id":25802,"modified_method":"@Override\n  public void handle(Request request, Response response) throws Exception {\n    userSession.checkLoggedIn().checkGlobalPermission(GlobalPermissions.SYSTEM_ADMIN);\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      List<Integer> ids = loadIds(dbSession, request);\n      dbClient.metricDao().disableByIds(dbSession, ids);\n      dbClient.customMeasureDao().deleteByMetricIds(dbSession, ids);\n      dbSession.commit();\n    } finally {\n      MyBatis.closeQuietly(dbSession);\n    }\n\n    response.noContent();\n    rubyBridge.metricCache().invalidate();\n  }","commit_id":"021bf45623b748e70f20d956e86d595191241786","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void disable(final DbSession session, List<Integer> ids) {\n    DaoUtils.executeLargeInputsWithoutOutput(ids, new Function<List<Integer>, Void>() {\n      @Override\n      public Void apply(@Nonnull List<Integer> input) {\n        mapper(session).disable(input);\n        return null;\n      }\n    });\n  }","id":25803,"modified_method":"public void disableByIds(final DbSession session, List<Integer> ids) {\n    DaoUtils.executeLargeInputsWithoutOutput(ids, new Function<List<Integer>, Void>() {\n      @Override\n      public Void apply(@Nonnull List<Integer> input) {\n        mapper(session).disableByIds(input);\n        return null;\n      }\n    });\n  }","commit_id":"021bf45623b748e70f20d956e86d595191241786","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  protected void configureLevel() {\n    add(\n      PluginDownloader.class,\n      ChartFactory.class,\n      DistributionBarChart.class,\n      DistributionAreaChart.class,\n      Views.class,\n      ResourceTypes.class,\n      DefaultResourceTypes.get(),\n      SettingsChangeNotifier.class,\n      PageDecorations.class,\n      Periods.class,\n      ServerWs.class,\n      BackendCleanup.class,\n      IndexDefinitions.class,\n      IndexCreator.class,\n\n      // Activity\n      ActivityService.class,\n      ActivityIndexDefinition.class,\n      ActivityIndexer.class,\n      ActivityIndex.class,\n\n      // batch\n      BatchWsModule.class,\n\n      // Dashboard\n      DashboardsWs.class,\n      org.sonar.server.dashboard.ws.ShowAction.class,\n      ProjectDefaultDashboard.class,\n      ProjectIssuesDashboard.class,\n      ProjectTimeMachineDashboard.class,\n      GlobalDefaultDashboard.class,\n      AlertsWidget.class,\n      CoverageWidget.class,\n      ItCoverageWidget.class,\n      DescriptionWidget.class,\n      ComplexityWidget.class,\n      IssuesWidget.class,\n      SizeWidget.class,\n      EventsWidget.class,\n      CustomMeasuresWidget.class,\n      TimelineWidget.class,\n      BubbleChartWidget.class,\n      TimeMachineWidget.class,\n      HotspotMetricWidget.class,\n      TreemapWidget.class,\n      MeasureFilterListWidget.class,\n      MeasureFilterAsTreemapWidget.class,\n      WelcomeWidget.class,\n      DocumentationCommentsWidget.class,\n      DuplicationsWidget.class,\n      TechnicalDebtPyramidWidget.class,\n      MeasureFilterAsPieChartWidget.class,\n      MeasureFilterAsCloudWidget.class,\n      MeasureFilterAsHistogramWidget.class,\n      MeasureFilterAsBubbleChartWidget.class,\n      ProjectFileCloudWidget.class,\n      DebtOverviewWidget.class,\n      ActionPlansWidget.class,\n      IssueFilterWidget.class,\n      ProjectIssueFilterWidget.class,\n      IssueTagCloudWidget.class,\n\n      // update center\n      UpdateCenterClient.class,\n      UpdateCenterMatrixFactory.class,\n      UpdateCenterWs.class,\n\n      // quality profile\n      XMLProfileParser.class,\n      XMLProfileSerializer.class,\n      AnnotationProfileParser.class,\n      QProfiles.class,\n      QProfileLookup.class,\n      QProfileProjectOperations.class,\n      QProfileProjectLookup.class,\n      QProfileComparison.class,\n      BuiltInProfiles.class,\n      RestoreBuiltInAction.class,\n      org.sonar.server.qualityprofile.ws.SearchAction.class,\n      SetDefaultAction.class,\n      ProjectsAction.class,\n      org.sonar.server.qualityprofile.ws.DeleteAction.class,\n      RenameAction.class,\n      CopyAction.class,\n      BackupAction.class,\n      RestoreAction.class,\n      CreateAction.class,\n      ImportersAction.class,\n      InheritanceAction.class,\n      ChangeParentAction.class,\n      ChangelogAction.class,\n      CompareAction.class,\n      ExportAction.class,\n      ExportersAction.class,\n      QProfilesWs.class,\n      ProfilesWs.class,\n      RuleActivationActions.class,\n      BulkRuleActivationActions.class,\n      ProjectAssociationActions.class,\n      RuleActivator.class,\n      QProfileLoader.class,\n      QProfileExporters.class,\n      QProfileService.class,\n      RuleActivatorContextFactory.class,\n      QProfileFactory.class,\n      QProfileCopier.class,\n      QProfileBackuper.class,\n      QProfileReset.class,\n      RubyQProfileActivityService.class,\n\n      // rule\n      AnnotationRuleParser.class,\n      XMLRuleParser.class,\n      DefaultRuleFinder.class,\n      RuleOperations.class,\n      RubyRuleService.class,\n      RuleRepositories.class,\n      DeprecatedRulesDefinitionLoader.class,\n      RuleDefinitionsLoader.class,\n      RulesDefinitionXmlLoader.class,\n      RuleService.class,\n      RuleUpdater.class,\n      RuleCreator.class,\n      RuleDeleter.class,\n      org.sonar.server.rule.ws.UpdateAction.class,\n      RulesWs.class,\n      org.sonar.server.rule.ws.SearchAction.class,\n      org.sonar.server.rule.ws.ShowAction.class,\n      org.sonar.server.rule.ws.CreateAction.class,\n      org.sonar.server.rule.ws.DeleteAction.class,\n      TagsAction.class,\n      RuleMapping.class,\n      ActiveRuleCompleter.class,\n      RepositoriesAction.class,\n      org.sonar.server.rule.ws.AppAction.class,\n\n      // languages\n      Languages.class,\n      LanguageWs.class,\n      org.sonar.server.language.ws.ListAction.class,\n\n      // activity\n      ActivitiesWs.class,\n      org.sonar.server.activity.ws.SearchAction.class,\n      ActivityMapping.class,\n\n      // measure\n      MeasuresDao.class,\n\n      MeasureFilterFactory.class,\n      MeasureFilterExecutor.class,\n      MeasureFilterEngine.class,\n      ManualMeasuresWs.class,\n      MetricsWsModule.class,\n      CustomMeasuresWsModule.class,\n      ProjectFilter.class,\n      MyFavouritesFilter.class,\n      CoreCustomMetrics.class,\n      DefaultMetricFinder.class,\n      TimeMachineWs.class,\n\n      // quality gates\n      QualityGateDao.class,\n      QualityGateConditionDao.class,\n      QualityGates.class,\n      ProjectQgateAssociationDao.class,\n      QgateProjectFinder.class,\n\n      org.sonar.server.qualitygate.ws.ListAction.class,\n      org.sonar.server.qualitygate.ws.SearchAction.class,\n      org.sonar.server.qualitygate.ws.ShowAction.class,\n      org.sonar.server.qualitygate.ws.CreateAction.class,\n      org.sonar.server.qualitygate.ws.RenameAction.class,\n      org.sonar.server.qualitygate.ws.CopyAction.class,\n      DestroyAction.class,\n      SetAsDefaultAction.class,\n      UnsetDefaultAction.class,\n      SelectAction.class,\n      DeselectAction.class,\n      CreateConditionAction.class,\n      DeleteConditionAction.class,\n      UpdateConditionAction.class,\n      org.sonar.server.qualitygate.ws.AppAction.class,\n      QGatesWs.class,\n\n      // web services\n      WebServiceEngine.class,\n      ListingWs.class,\n\n      // localization\n      L10nWs.class,\n\n      // authentication\n      AuthenticationWs.class,\n\n      // users\n      SecurityRealmFactory.class,\n      DeprecatedUserFinder.class,\n      NewUserNotifier.class,\n      DefaultUserFinder.class,\n      DefaultUserService.class,\n      UserJsonWriter.class,\n      UsersWs.class,\n      org.sonar.server.user.ws.CreateAction.class,\n      org.sonar.server.user.ws.UpdateAction.class,\n      org.sonar.server.user.ws.DeactivateAction.class,\n      org.sonar.server.user.ws.ChangePasswordAction.class,\n      CurrentAction.class,\n      org.sonar.server.user.ws.SearchAction.class,\n      org.sonar.server.user.ws.GroupsAction.class,\n      org.sonar.server.issue.ws.AuthorsAction.class,\n      FavoritesWs.class,\n      UserPropertiesWs.class,\n      UserIndexDefinition.class,\n      UserIndexer.class,\n      UserIndex.class,\n      UserUpdater.class,\n\n      // groups\n      GroupMembershipService.class,\n      GroupMembershipFinder.class,\n      UserGroupsModule.class,\n\n      // permissions\n      PermissionFacade.class,\n      InternalPermissionService.class,\n      InternalPermissionTemplateService.class,\n      PermissionFinder.class,\n      PermissionsWs.class,\n\n      // components\n      ProjectsWsModule.class,\n      DefaultComponentFinder.class,\n      DefaultRubyComponentService.class,\n      ComponentService.class,\n      ResourcesWs.class,\n      ComponentsWs.class,\n      org.sonar.server.component.ws.AppAction.class,\n      org.sonar.server.component.ws.SearchAction.class,\n      EventsWs.class,\n      NewAlerts.class,\n      NewAlerts.newMetadata(),\n      ComponentCleanerService.class,\n\n      // views\n      ViewIndexDefinition.class,\n      ViewIndexer.class,\n      ViewIndex.class,\n\n      // issues\n      IssueIndexDefinition.class,\n      IssueIndexer.class,\n      IssueAuthorizationIndexer.class,\n      ServerIssueStorage.class,\n      IssueUpdater.class,\n      FunctionExecutor.class,\n      IssueWorkflow.class,\n      IssueCommentService.class,\n      InternalRubyIssueService.class,\n      IssueChangelogService.class,\n      ActionService.class,\n      Actions.class,\n      IssueBulkChangeService.class,\n      IssueChangelogFormatter.class,\n      IssuesWs.class,\n      IssueJsonWriter.class,\n      IssueComponentHelper.class,\n      org.sonar.server.issue.ws.ShowAction.class,\n      org.sonar.server.issue.ws.SearchAction.class,\n      org.sonar.server.issue.ws.TagsAction.class,\n      SetTagsAction.class,\n      ComponentTagsAction.class,\n      IssueService.class,\n      IssueActionsWriter.class,\n      IssueQueryService.class,\n      NewIssuesEmailTemplate.class,\n      MyNewIssuesEmailTemplate.class,\n      IssueChangesEmailTemplate.class,\n      ChangesOnMyIssueNotificationDispatcher.class,\n      ChangesOnMyIssueNotificationDispatcher.newMetadata(),\n      NewIssuesNotificationDispatcher.class,\n      NewIssuesNotificationDispatcher.newMetadata(),\n      MyNewIssuesNotificationDispatcher.class,\n      MyNewIssuesNotificationDispatcher.newMetadata(),\n      DoNotFixNotificationDispatcher.class,\n      DoNotFixNotificationDispatcher.newMetadata(),\n      NewIssuesNotificationFactory.class,\n      EmailNotificationChannel.class,\n      AlertsEmailTemplate.class,\n\n      // issue filters\n      IssueFilterService.class,\n      IssueFilterSerializer.class,\n      IssueFilterWs.class,\n      IssueFilterWriter.class,\n      org.sonar.server.issue.filter.AppAction.class,\n      org.sonar.server.issue.filter.ShowAction.class,\n      org.sonar.server.issue.filter.FavoritesAction.class,\n\n      // action plan\n      ActionPlanWs.class,\n      ActionPlanService.class,\n\n      // issues actions\n      AssignAction.class,\n      PlanAction.class,\n      SetSeverityAction.class,\n      CommentAction.class,\n      TransitionAction.class,\n      AddTagsAction.class,\n      RemoveTagsAction.class,\n\n      // technical debt\n      DebtModelService.class,\n      DebtModelOperations.class,\n      DebtModelLookup.class,\n      DebtModelBackup.class,\n      DebtModelPluginRepository.class,\n      DebtModelXMLExporter.class,\n      DebtRulesXMLImporter.class,\n      DebtCharacteristicsXMLImporter.class,\n\n      // source\n      HtmlSourceDecorator.class,\n      SourceService.class,\n      SourcesWs.class,\n      org.sonar.server.source.ws.ShowAction.class,\n      LinesAction.class,\n      HashAction.class,\n      RawAction.class,\n      IndexAction.class,\n      ScmAction.class,\n      SourceLineIndexDefinition.class,\n      SourceLineIndex.class,\n      SourceLineIndexer.class,\n\n      // Duplications\n      DuplicationsParser.class,\n      DuplicationsWs.class,\n      DuplicationsJsonWriter.class,\n      org.sonar.server.duplication.ws.ShowAction.class,\n\n      // text\n      MacroInterpreter.class,\n      RubyTextService.class,\n\n      // Notifications\n      EmailSettings.class,\n      NotificationService.class,\n      NotificationCenter.class,\n      DefaultNotificationManager.class,\n\n      // Tests\n      CoverageService.class,\n      TestsWs.class,\n      CoveredFilesAction.class,\n      org.sonar.server.test.ws.ListAction.class,\n      TestIndexDefinition.class,\n      TestIndex.class,\n      TestIndexer.class,\n\n      // Properties\n      PropertiesWs.class,\n\n      // Type validation\n      TypeValidations.class,\n      IntegerTypeValidation.class,\n      FloatTypeValidation.class,\n      BooleanTypeValidation.class,\n      TextTypeValidation.class,\n      StringTypeValidation.class,\n      StringListTypeValidation.class,\n\n      // System\n      RestartAction.class,\n      InfoAction.class,\n      UpgradesAction.class,\n      MigrateDbSystemAction.class,\n      StatusAction.class,\n      SystemWs.class,\n      SystemMonitor.class,\n      SonarQubeMonitor.class,\n      EsMonitor.class,\n      PluginsMonitor.class,\n      JvmPropertiesMonitor.class,\n      DatabaseMonitor.class,\n\n      // Plugins WS\n      PluginWSCommons.class,\n      PluginUpdateAggregator.class,\n      InstalledAction.class,\n      AvailableAction.class,\n      UpdatesAction.class,\n      PendingAction.class,\n      InstallAction.class,\n      org.sonar.server.plugins.ws.UpdateAction.class,\n      UninstallAction.class,\n      CancelAllAction.class,\n      PluginsWs.class,\n\n      // Compute engine\n      ReportQueue.class,\n      ComputationThreadLauncher.class,\n      ComputationWs.class,\n      IsQueueEmptyWs.class,\n      QueueAction.class,\n      HistoryAction.class,\n      DefaultPeriodCleaner.class,\n      ProjectCleaner.class,\n      ProjectSettingsFactory.class,\n      IndexPurgeListener.class,\n\n      // UI\n      GlobalNavigationAction.class,\n      SettingsNavigationAction.class,\n      ComponentNavigationAction.class,\n      NavigationWs.class);\n\n    addAll(level4AddedComponents);\n  }","id":25804,"modified_method":"@Override\n  protected void configureLevel() {\n    add(\n      PluginDownloader.class,\n      ChartFactory.class,\n      DistributionBarChart.class,\n      DistributionAreaChart.class,\n      Views.class,\n      ResourceTypes.class,\n      DefaultResourceTypes.get(),\n      SettingsChangeNotifier.class,\n      PageDecorations.class,\n      Periods.class,\n      ServerWs.class,\n      BackendCleanup.class,\n      IndexDefinitions.class,\n      IndexCreator.class,\n\n      // Activity\n      ActivityService.class,\n      ActivityIndexDefinition.class,\n      ActivityIndexer.class,\n      ActivityIndex.class,\n\n      // batch\n      BatchWsModule.class,\n\n      // Dashboard\n      DashboardsWs.class,\n      org.sonar.server.dashboard.ws.ShowAction.class,\n      ProjectDefaultDashboard.class,\n      ProjectIssuesDashboard.class,\n      ProjectTimeMachineDashboard.class,\n      GlobalDefaultDashboard.class,\n      AlertsWidget.class,\n      CoverageWidget.class,\n      ItCoverageWidget.class,\n      DescriptionWidget.class,\n      ComplexityWidget.class,\n      IssuesWidget.class,\n      SizeWidget.class,\n      EventsWidget.class,\n      CustomMeasuresWidget.class,\n      TimelineWidget.class,\n      BubbleChartWidget.class,\n      TimeMachineWidget.class,\n      HotspotMetricWidget.class,\n      TreemapWidget.class,\n      MeasureFilterListWidget.class,\n      MeasureFilterAsTreemapWidget.class,\n      WelcomeWidget.class,\n      DocumentationCommentsWidget.class,\n      DuplicationsWidget.class,\n      TechnicalDebtPyramidWidget.class,\n      MeasureFilterAsPieChartWidget.class,\n      MeasureFilterAsCloudWidget.class,\n      MeasureFilterAsHistogramWidget.class,\n      MeasureFilterAsBubbleChartWidget.class,\n      ProjectFileCloudWidget.class,\n      DebtOverviewWidget.class,\n      ActionPlansWidget.class,\n      IssueFilterWidget.class,\n      ProjectIssueFilterWidget.class,\n      IssueTagCloudWidget.class,\n\n      // update center\n      UpdateCenterClient.class,\n      UpdateCenterMatrixFactory.class,\n      UpdateCenterWs.class,\n\n      // quality profile\n      XMLProfileParser.class,\n      XMLProfileSerializer.class,\n      AnnotationProfileParser.class,\n      QProfiles.class,\n      QProfileLookup.class,\n      QProfileProjectOperations.class,\n      QProfileProjectLookup.class,\n      QProfileComparison.class,\n      BuiltInProfiles.class,\n      RestoreBuiltInAction.class,\n      org.sonar.server.qualityprofile.ws.SearchAction.class,\n      SetDefaultAction.class,\n      ProjectsAction.class,\n      org.sonar.server.qualityprofile.ws.DeleteAction.class,\n      RenameAction.class,\n      CopyAction.class,\n      BackupAction.class,\n      RestoreAction.class,\n      CreateAction.class,\n      ImportersAction.class,\n      InheritanceAction.class,\n      ChangeParentAction.class,\n      ChangelogAction.class,\n      CompareAction.class,\n      ExportAction.class,\n      ExportersAction.class,\n      QProfilesWs.class,\n      ProfilesWs.class,\n      RuleActivationActions.class,\n      BulkRuleActivationActions.class,\n      ProjectAssociationActions.class,\n      RuleActivator.class,\n      QProfileLoader.class,\n      QProfileExporters.class,\n      QProfileService.class,\n      RuleActivatorContextFactory.class,\n      QProfileFactory.class,\n      QProfileCopier.class,\n      QProfileBackuper.class,\n      QProfileReset.class,\n      RubyQProfileActivityService.class,\n\n      // rule\n      AnnotationRuleParser.class,\n      XMLRuleParser.class,\n      DefaultRuleFinder.class,\n      RuleOperations.class,\n      RubyRuleService.class,\n      RuleRepositories.class,\n      DeprecatedRulesDefinitionLoader.class,\n      RuleDefinitionsLoader.class,\n      RulesDefinitionXmlLoader.class,\n      RuleService.class,\n      RuleUpdater.class,\n      RuleCreator.class,\n      RuleDeleter.class,\n      org.sonar.server.rule.ws.UpdateAction.class,\n      RulesWs.class,\n      org.sonar.server.rule.ws.SearchAction.class,\n      org.sonar.server.rule.ws.ShowAction.class,\n      org.sonar.server.rule.ws.CreateAction.class,\n      org.sonar.server.rule.ws.DeleteAction.class,\n      TagsAction.class,\n      RuleMapping.class,\n      ActiveRuleCompleter.class,\n      RepositoriesAction.class,\n      org.sonar.server.rule.ws.AppAction.class,\n\n      // languages\n      Languages.class,\n      LanguageWs.class,\n      org.sonar.server.language.ws.ListAction.class,\n\n      // activity\n      ActivitiesWs.class,\n      org.sonar.server.activity.ws.SearchAction.class,\n      ActivityMapping.class,\n\n      // measure\n      MeasureFilterFactory.class,\n      MeasureFilterExecutor.class,\n      MeasureFilterEngine.class,\n      ManualMeasuresWs.class,\n      MetricsWsModule.class,\n      CustomMeasuresWsModule.class,\n      ProjectFilter.class,\n      MyFavouritesFilter.class,\n      CoreCustomMetrics.class,\n      DefaultMetricFinder.class,\n      TimeMachineWs.class,\n\n      // quality gates\n      QualityGateDao.class,\n      QualityGateConditionDao.class,\n      QualityGates.class,\n      ProjectQgateAssociationDao.class,\n      QgateProjectFinder.class,\n\n      org.sonar.server.qualitygate.ws.ListAction.class,\n      org.sonar.server.qualitygate.ws.SearchAction.class,\n      org.sonar.server.qualitygate.ws.ShowAction.class,\n      org.sonar.server.qualitygate.ws.CreateAction.class,\n      org.sonar.server.qualitygate.ws.RenameAction.class,\n      org.sonar.server.qualitygate.ws.CopyAction.class,\n      DestroyAction.class,\n      SetAsDefaultAction.class,\n      UnsetDefaultAction.class,\n      SelectAction.class,\n      DeselectAction.class,\n      CreateConditionAction.class,\n      DeleteConditionAction.class,\n      UpdateConditionAction.class,\n      org.sonar.server.qualitygate.ws.AppAction.class,\n      QGatesWs.class,\n\n      // web services\n      WebServiceEngine.class,\n      ListingWs.class,\n\n      // localization\n      L10nWs.class,\n\n      // authentication\n      AuthenticationWs.class,\n\n      // users\n      SecurityRealmFactory.class,\n      DeprecatedUserFinder.class,\n      NewUserNotifier.class,\n      DefaultUserFinder.class,\n      DefaultUserService.class,\n      UserJsonWriter.class,\n      UsersWs.class,\n      org.sonar.server.user.ws.CreateAction.class,\n      org.sonar.server.user.ws.UpdateAction.class,\n      org.sonar.server.user.ws.DeactivateAction.class,\n      org.sonar.server.user.ws.ChangePasswordAction.class,\n      CurrentAction.class,\n      org.sonar.server.user.ws.SearchAction.class,\n      org.sonar.server.user.ws.GroupsAction.class,\n      org.sonar.server.issue.ws.AuthorsAction.class,\n      FavoritesWs.class,\n      UserPropertiesWs.class,\n      UserIndexDefinition.class,\n      UserIndexer.class,\n      UserIndex.class,\n      UserUpdater.class,\n\n      // groups\n      GroupMembershipService.class,\n      GroupMembershipFinder.class,\n      UserGroupsModule.class,\n\n      // permissions\n      PermissionFacade.class,\n      InternalPermissionService.class,\n      InternalPermissionTemplateService.class,\n      PermissionFinder.class,\n      PermissionsWs.class,\n\n      // components\n      ProjectsWsModule.class,\n      DefaultComponentFinder.class,\n      DefaultRubyComponentService.class,\n      ComponentService.class,\n      ResourcesWs.class,\n      ComponentsWs.class,\n      org.sonar.server.component.ws.AppAction.class,\n      org.sonar.server.component.ws.SearchAction.class,\n      EventsWs.class,\n      NewAlerts.class,\n      NewAlerts.newMetadata(),\n      ComponentCleanerService.class,\n\n      // views\n      ViewIndexDefinition.class,\n      ViewIndexer.class,\n      ViewIndex.class,\n\n      // issues\n      IssueIndexDefinition.class,\n      IssueIndexer.class,\n      IssueAuthorizationIndexer.class,\n      ServerIssueStorage.class,\n      IssueUpdater.class,\n      FunctionExecutor.class,\n      IssueWorkflow.class,\n      IssueCommentService.class,\n      InternalRubyIssueService.class,\n      IssueChangelogService.class,\n      ActionService.class,\n      Actions.class,\n      IssueBulkChangeService.class,\n      IssueChangelogFormatter.class,\n      IssuesWs.class,\n      IssueJsonWriter.class,\n      IssueComponentHelper.class,\n      org.sonar.server.issue.ws.ShowAction.class,\n      org.sonar.server.issue.ws.SearchAction.class,\n      org.sonar.server.issue.ws.TagsAction.class,\n      SetTagsAction.class,\n      ComponentTagsAction.class,\n      IssueService.class,\n      IssueActionsWriter.class,\n      IssueQueryService.class,\n      NewIssuesEmailTemplate.class,\n      MyNewIssuesEmailTemplate.class,\n      IssueChangesEmailTemplate.class,\n      ChangesOnMyIssueNotificationDispatcher.class,\n      ChangesOnMyIssueNotificationDispatcher.newMetadata(),\n      NewIssuesNotificationDispatcher.class,\n      NewIssuesNotificationDispatcher.newMetadata(),\n      MyNewIssuesNotificationDispatcher.class,\n      MyNewIssuesNotificationDispatcher.newMetadata(),\n      DoNotFixNotificationDispatcher.class,\n      DoNotFixNotificationDispatcher.newMetadata(),\n      NewIssuesNotificationFactory.class,\n      EmailNotificationChannel.class,\n      AlertsEmailTemplate.class,\n\n      // issue filters\n      IssueFilterService.class,\n      IssueFilterSerializer.class,\n      IssueFilterWs.class,\n      IssueFilterWriter.class,\n      org.sonar.server.issue.filter.AppAction.class,\n      org.sonar.server.issue.filter.ShowAction.class,\n      org.sonar.server.issue.filter.FavoritesAction.class,\n\n      // action plan\n      ActionPlanWs.class,\n      ActionPlanService.class,\n\n      // issues actions\n      AssignAction.class,\n      PlanAction.class,\n      SetSeverityAction.class,\n      CommentAction.class,\n      TransitionAction.class,\n      AddTagsAction.class,\n      RemoveTagsAction.class,\n\n      // technical debt\n      DebtModelService.class,\n      DebtModelOperations.class,\n      DebtModelLookup.class,\n      DebtModelBackup.class,\n      DebtModelPluginRepository.class,\n      DebtModelXMLExporter.class,\n      DebtRulesXMLImporter.class,\n      DebtCharacteristicsXMLImporter.class,\n\n      // source\n      HtmlSourceDecorator.class,\n      SourceService.class,\n      SourcesWs.class,\n      org.sonar.server.source.ws.ShowAction.class,\n      LinesAction.class,\n      HashAction.class,\n      RawAction.class,\n      IndexAction.class,\n      ScmAction.class,\n      SourceLineIndexDefinition.class,\n      SourceLineIndex.class,\n      SourceLineIndexer.class,\n\n      // Duplications\n      DuplicationsParser.class,\n      DuplicationsWs.class,\n      DuplicationsJsonWriter.class,\n      org.sonar.server.duplication.ws.ShowAction.class,\n\n      // text\n      MacroInterpreter.class,\n      RubyTextService.class,\n\n      // Notifications\n      EmailSettings.class,\n      NotificationService.class,\n      NotificationCenter.class,\n      DefaultNotificationManager.class,\n\n      // Tests\n      CoverageService.class,\n      TestsWs.class,\n      CoveredFilesAction.class,\n      org.sonar.server.test.ws.ListAction.class,\n      TestIndexDefinition.class,\n      TestIndex.class,\n      TestIndexer.class,\n\n      // Properties\n      PropertiesWs.class,\n\n      // Type validation\n      TypeValidations.class,\n      IntegerTypeValidation.class,\n      FloatTypeValidation.class,\n      BooleanTypeValidation.class,\n      TextTypeValidation.class,\n      StringTypeValidation.class,\n      StringListTypeValidation.class,\n\n      // System\n      RestartAction.class,\n      InfoAction.class,\n      UpgradesAction.class,\n      MigrateDbSystemAction.class,\n      StatusAction.class,\n      SystemWs.class,\n      SystemMonitor.class,\n      SonarQubeMonitor.class,\n      EsMonitor.class,\n      PluginsMonitor.class,\n      JvmPropertiesMonitor.class,\n      DatabaseMonitor.class,\n\n      // Plugins WS\n      PluginWSCommons.class,\n      PluginUpdateAggregator.class,\n      InstalledAction.class,\n      AvailableAction.class,\n      UpdatesAction.class,\n      PendingAction.class,\n      InstallAction.class,\n      org.sonar.server.plugins.ws.UpdateAction.class,\n      UninstallAction.class,\n      CancelAllAction.class,\n      PluginsWs.class,\n\n      // Compute engine\n      ReportQueue.class,\n      ComputationThreadLauncher.class,\n      ComputationWs.class,\n      IsQueueEmptyWs.class,\n      QueueAction.class,\n      HistoryAction.class,\n      DefaultPeriodCleaner.class,\n      ProjectCleaner.class,\n      ProjectSettingsFactory.class,\n      IndexPurgeListener.class,\n\n      // UI\n      GlobalNavigationAction.class,\n      SettingsNavigationAction.class,\n      ComponentNavigationAction.class,\n      NavigationWs.class);\n\n    addAll(level4AddedComponents);\n  }","commit_id":"021bf45623b748e70f20d956e86d595191241786","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected void register(List<Metric> metrics) {\n    measuresDao.registerMetrics(metrics);\n  }","id":25805,"modified_method":"void register(Iterable<Metric> metrics) {\n    Profiler profiler = Profiler.create(LOG).startInfo(\"Register metrics\");\n    DbSession session = dbClient.openSession(false);\n    try {\n      save(session, metrics);\n      sanitizeQualityGates(session);\n      session.commit();\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n    profiler.stopDebug();\n  }","commit_id":"021bf45623b748e70f20d956e86d595191241786","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void start() {\n    Profiler profiler = Profiler.create(LOG).startInfo(\"Register metrics\");\n    measuresDao.disableAutomaticMetrics();\n\n    List<Metric> metricsToRegister = newArrayList();\n    metricsToRegister.addAll(CoreMetrics.getMetrics());\n    metricsToRegister.addAll(getMetricsRepositories());\n    register(metricsToRegister);\n    cleanAlerts();\n    profiler.stopDebug();\n  }","id":25806,"modified_method":"public void start() {\n    register(concat(CoreMetrics.getMetrics(), getPluginMetrics()));\n  }","commit_id":"021bf45623b748e70f20d956e86d595191241786","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void checkMetrics(Map<String, Metrics> metricsByRepository, Metrics metrics) {\n    for (Metric metric : metrics.getMetrics()) {\n      String metricKey = metric.getKey();\n      if (CoreMetrics.getMetrics().contains(metric)) {\n        throw new IllegalStateException(\"The following metric is already defined in sonar: \" + metricKey);\n      }\n      Metrics anotherRepository = metricsByRepository.get(metricKey);\n      if (anotherRepository != null) {\n        throw new IllegalStateException(\"The metric '\" + metricKey + \"' is already defined in the extension: \" + anotherRepository);\n      }\n      metricsByRepository.put(metricKey, metrics);\n    }\n  }","id":25807,"modified_method":"private void checkMetrics(Map<String, Metrics> metricsByRepository, Metrics metrics) {\n    for (Metric metric : metrics.getMetrics()) {\n      String metricKey = metric.getKey();\n      if (CoreMetrics.getMetrics().contains(metric)) {\n        throw new IllegalStateException(String.format(\"Metric [%s] is already defined by SonarQube\", metricKey));\n      }\n      Metrics anotherRepository = metricsByRepository.get(metricKey);\n      if (anotherRepository != null) {\n        throw new IllegalStateException(String.format(\"Metric [%s] is already defined by the repository [%s]\", metricKey, anotherRepository));\n      }\n      metricsByRepository.put(metricKey, metrics);\n    }\n  }","commit_id":"021bf45623b748e70f20d956e86d595191241786","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n        public String next() {\n            if (closed) {\n                throw new IllegalStateException(\"This iterator is closed\");\n            }\n            if (!init) {\n                fetchNext();\n                init = true;\n            }\n            String result = currentPath;\n            fetchNext();\n            if (pathContainsValue) {\n                String value = PathUtils.elements(result).iterator().next();\n                result = PathUtils.relativize(value, result);\n            }\n            return result;\n        }","id":25808,"modified_method":"@Override\n        public String next() {\n            if (closed) {\n                throw new IllegalStateException(\"This iterator is closed\");\n            }\n            if (!init) {\n                fetchNext();\n                init = true;\n            }\n            while (true) {\n                String result = currentPath;\n                fetchNext();\n                if (pathContainsValue) {\n                    String value = PathUtils.elements(result).iterator().next();\n                    result = PathUtils.relativize(value, result);\n                    // don't return duplicate paths:\n                    // Set.add returns true if the entry was new,\n                    // so if it returns false, it was already known\n                    if (!knownPaths.add(result)) {\n                        continue;\n                    }\n                }\n                return result;\n            }\n        }","commit_id":"9c797e8ad4e6e07aed838abbccd04b437175a327","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Iterable<String> query(final String indexName, \n            final NodeState index, final Iterable<String> values) {\n        return new Iterable<String>() {\n            @Override\n            public Iterator<String> iterator() {\n                PathIterator it = new PathIterator(indexName);\n                if (values == null) {\n                    it.setPathContainsValue(true);\n                    it.enqueue(index.getChildNodeEntries().iterator());\n                } else {\n                    for (String p : values) {\n                        NodeState property = index.getChildNode(p);\n                        if (property != null) {\n                            // we have an entry for this value, so use it\n                            it.enqueue(Iterators.singletonIterator(\n                                    new MemoryChildNodeEntry(\"\", property)));\n                        }\n                    }\n                }\n                // avoid duplicate entries\n                // TODO load entries lazily\n                Set<String> paths = Sets.newHashSet();\n                Iterators.addAll(paths, it);\n                return paths.iterator();\n            }\n        };\n    }","id":25809,"modified_method":"@Override\n    public Iterable<String> query(final String indexName, \n            final NodeState index, final Iterable<String> values) {\n        return new Iterable<String>() {\n            @Override\n            public Iterator<String> iterator() {\n                PathIterator it = new PathIterator(indexName);\n                if (values == null) {\n                    it.setPathContainsValue(true);\n                    it.enqueue(index.getChildNodeEntries().iterator());\n                } else {\n                    for (String p : values) {\n                        NodeState property = index.getChildNode(p);\n                        if (property != null) {\n                            // we have an entry for this value, so use it\n                            it.enqueue(Iterators.singletonIterator(\n                                    new MemoryChildNodeEntry(\"\", property)));\n                        }\n                    }\n                }\n                return it;\n            }\n        };\n    }","commit_id":"9c797e8ad4e6e07aed838abbccd04b437175a327","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates a {@link Cursor} over paths.\n     *\n     * @param paths the paths to iterate over.\n     * @return the Cursor.\n     */\n    public static Cursor newPathCursor(Iterable<String> paths) {\n        return new PathCursor(paths);\n    }","id":25810,"modified_method":"/**\n     * Creates a {@link Cursor} over paths.\n     *\n     * @param paths the paths to iterate over (must return distinct paths)\n     * @return the Cursor.\n     */\n    public static Cursor newPathCursor(Iterable<String> paths) {\n        return new PathCursor(paths, true);\n    }","commit_id":"9c797e8ad4e6e07aed838abbccd04b437175a327","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public PathCursor(Iterable<String> paths) {\n            this.iterator = paths.iterator();\n        }","id":25811,"modified_method":"public PathCursor(Iterable<String> paths, boolean distinct) {\n            Iterator<String> it = paths.iterator();\n            if (distinct) {\n                it = Iterators.filter(it, new Predicate<String>() {\n                    \n                    private final HashSet<String> known = new HashSet<String>();\n\n                    @Override\n                    public boolean apply(@Nullable String input) {\n                        // Set.add returns true for new entries\n                        return known.add(input);\n                    }\n                    \n                });\n            }\n            this.iterator = it;\n        }","commit_id":"9c797e8ad4e6e07aed838abbccd04b437175a327","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Cursor query(Filter filter, NodeState root) {\n        NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);\n        if (!hasNodeTypeRestriction(filter) || !lookup.isIndexed(filter.getPath())) {\n            throw new IllegalStateException(\n                    \"NodeType index is used even when no index is available for filter \" + filter);\n        }\n        return Cursors.newPathCursor(lookup.query(\n                resolveNodeType(root, filter.getNodeType())));\n    }","id":25812,"modified_method":"@Override\n    public Cursor query(Filter filter, NodeState root) {\n        NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);\n        if (!hasNodeTypeRestriction(filter) || !lookup.isIndexed(filter.getPath())) {\n            throw new IllegalStateException(\n                    \"NodeType index is used even when no index is available for filter \" + filter);\n        }\n        return Cursors.newPathCursorDistinct(lookup.query(\n                resolveNodeType(root, filter.getNodeType())));\n    }","commit_id":"9c797e8ad4e6e07aed838abbccd04b437175a327","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Returns the paths that match the given node types.\n     *\n     * @param nodeTypes the names of the node types to match.\n     * @return the set of matched paths.\n     */\n    public Iterable<String> query(Iterable<String> nodeTypes) {\n        // TODO currently, fetch all data to avoid duplicate entries:\n        // the following code sometimes returns duplicate entries:\n        // final PropertyValue ntNames = PropertyValues.newName(nodeTypes);\n        // Property2IndexLookup lookup = new Property2IndexLookup(root);\n        // return Iterables.concat(\n        //     lookup.query(JCR_PRIMARYTYPE, ntNames),\n        //     lookup.query(JCR_MIXINTYPES, ntNames));\n        Set<String> paths = Sets.newHashSet();\n        Property2IndexLookup lookup = new Property2IndexLookup(root);\n        PropertyValue ntNames = PropertyValues.newName(nodeTypes);\n        Iterables.addAll(paths, lookup.query(JCR_PRIMARYTYPE, ntNames));\n        Iterables.addAll(paths, lookup.query(JCR_MIXINTYPES, ntNames));\n        return paths;\n    }","id":25813,"modified_method":"/**\n     * Returns the paths that match the given node types.\n     *\n     * @param nodeTypes the names of the node types to match.\n     * @return the matched paths (the result might contain duplicate entries)\n     */\n    public Iterable<String> query(Iterable<String> nodeTypes) {\n        final PropertyValue ntNames = PropertyValues.newName(nodeTypes);\n        Property2IndexLookup lookup = new Property2IndexLookup(root);\n        return Iterables.concat(\n                lookup.query(JCR_PRIMARYTYPE, ntNames),\n                lookup.query(JCR_MIXINTYPES, ntNames));\n    }","commit_id":"9c797e8ad4e6e07aed838abbccd04b437175a327","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void validate() throws UnboundModelRulesException {\n        if (!binders.isEmpty()) {\n            List<ModelPath> availablePaths = CollectionUtils.toList(store.keySet());\n            availablePaths.addAll(creations.keySet());\n            ModelPathSuggestionProvider suggestionsProvider = new ModelPathSuggestionProvider(availablePaths);\n            List<UnboundRule> unboundRules = new UnboundRulesProcessor(binders, suggestionsProvider).process();\n            throw new UnboundModelRulesException(unboundRules);\n        }\n    }","id":25814,"modified_method":"public void validate() throws UnboundModelRulesException {\n        if (!binders.isEmpty()) {\n            ModelPathSuggestionProvider suggestionsProvider = new ModelPathSuggestionProvider(Iterables.concat(store.keySet(), creations.keySet()));\n            List<UnboundRule> unboundRules = new UnboundRulesProcessor(binders, suggestionsProvider).process();\n            throw new UnboundModelRulesException(unboundRules);\n        }\n    }","commit_id":"988304b57c026acc11ccc435fe980ad75199284b","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Send a small message, wait a second, then send a large message, pushing\n     * the first one through immediately, with the rest of the large one passed\n     * after a brief delay.\n     *\n     */\n    public void testBatched() {\n        TunnelGateway.Pending pending1 = createPending(10, false, false);\n        ArrayList messages = new ArrayList();\n        messages.add(pending1);\n        \n        TunnelGateway.Pending pending2 = createPending(1024, false, false);\n        \n        TunnelGateway.QueuePreprocessor pre = createPreprocessor(_context);\n        SenderImpl sender = new SenderImpl();\n        DefragmentedReceiverImpl handleReceiver = new DefragmentedReceiverImpl(pending1.getData(), pending2.getData());\n        FragmentHandler handler = new FragmentHandler(_context, handleReceiver);\n        ReceiverImpl receiver = new ReceiverImpl(handler, 0);\n        byte msg[] = pending1.getData();\n            \n        boolean keepGoing = true;\n        boolean alreadyAdded = false;\n        while (keepGoing) {\n            keepGoing = pre.preprocessQueue(messages, new SenderImpl(), receiver);\n            if (keepGoing) {\n                try { Thread.sleep(150); } catch (InterruptedException ie) {}\n\n                if (!alreadyAdded) { \n                    messages.add(pending2);\n                    alreadyAdded = true;\n                }\n            }\n        }\n        \n        assertTrue(handleReceiver.receivedOk());\n    }","id":25815,"modified_method":"/**\n     * Send a small message, wait a second, then send a large message, pushing\n     * the first one through immediately, with the rest of the large one passed\n     * after a brief delay.\n     *\n     */\n    public void testBatched() {\n        PendingGatewayMessage pending1 = createPending(10, false, false);\n        ArrayList messages = new ArrayList();\n        messages.add(pending1);\n        \n        PendingGatewayMessage pending2 = createPending(1024, false, false);\n        \n        TunnelGateway.QueuePreprocessor pre = createPreprocessor(_context);\n        SenderImpl sender = new SenderImpl();\n        DefragmentedReceiverImpl handleReceiver = new DefragmentedReceiverImpl(pending1.getData(), pending2.getData());\n        FragmentHandler handler = new FragmentHandler(_context, handleReceiver);\n        ReceiverImpl receiver = new ReceiverImpl(handler, 0);\n        byte msg[] = pending1.getData();\n            \n        boolean keepGoing = true;\n        boolean alreadyAdded = false;\n        while (keepGoing) {\n            keepGoing = pre.preprocessQueue(messages, new SenderImpl(), receiver);\n            if (keepGoing) {\n                try { Thread.sleep(150); } catch (InterruptedException ie) {}\n\n                if (!alreadyAdded) { \n                    messages.add(pending2);\n                    alreadyAdded = true;\n                }\n            }\n        }\n        \n        assertTrue(handleReceiver.receivedOk());\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void runBatch(TunnelGateway.Pending pending1, TunnelGateway.Pending pending2, TunnelGateway.Pending pending3) {\n        ArrayList messages = new ArrayList();\n        messages.add(pending1);\n        \n        TunnelGateway.QueuePreprocessor pre = createPreprocessor(_context);\n        SenderImpl sender = new SenderImpl();\n        DefragmentedReceiverImpl handleReceiver = new DefragmentedReceiverImpl(pending1.getData(), pending2.getData(), pending3.getData());\n        FragmentHandler handler = new FragmentHandler(_context, handleReceiver);\n        ReceiverImpl receiver = new ReceiverImpl(handler, 0);\n        byte msg[] = pending1.getData();\n            \n        boolean keepGoing = true;\n        int added = 0;\n        while (keepGoing) {\n            keepGoing = pre.preprocessQueue(messages, new SenderImpl(), receiver);\n            if ( (keepGoing) || ((messages.size() == 0) && (added < 2) ) ) {\n                try { Thread.sleep(150); } catch (InterruptedException ie) {}\n\n                if (added == 0) { \n                    messages.add(pending2);\n                    added++;\n                    keepGoing = true;\n                } else if (added == 1) {\n                    messages.add(pending3);\n                    added++;\n                    keepGoing = true;\n                }\n            }\n        }\n        \n        assertTrue(handleReceiver.receivedOk());\n    }","id":25816,"modified_method":"private void runBatch(PendingGatewayMessage pending1, PendingGatewayMessage pending2, PendingGatewayMessage pending3) {\n        ArrayList messages = new ArrayList();\n        messages.add(pending1);\n        \n        TunnelGateway.QueuePreprocessor pre = createPreprocessor(_context);\n        SenderImpl sender = new SenderImpl();\n        DefragmentedReceiverImpl handleReceiver = new DefragmentedReceiverImpl(pending1.getData(), pending2.getData(), pending3.getData());\n        FragmentHandler handler = new FragmentHandler(_context, handleReceiver);\n        ReceiverImpl receiver = new ReceiverImpl(handler, 0);\n        byte msg[] = pending1.getData();\n            \n        boolean keepGoing = true;\n        int added = 0;\n        while (keepGoing) {\n            keepGoing = pre.preprocessQueue(messages, new SenderImpl(), receiver);\n            if ( (keepGoing) || ((messages.size() == 0) && (added < 2) ) ) {\n                try { Thread.sleep(150); } catch (InterruptedException ie) {}\n\n                if (added == 0) { \n                    messages.add(pending2);\n                    added++;\n                    keepGoing = true;\n                } else if (added == 1) {\n                    messages.add(pending3);\n                    added++;\n                    keepGoing = true;\n                }\n            }\n        }\n        \n        assertTrue(handleReceiver.receivedOk());\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected TunnelGateway.QueuePreprocessor createPreprocessor(I2PAppContext ctx) {\n        return new BatchedPreprocessor(ctx);\n    }","id":25817,"modified_method":"protected TunnelGateway.QueuePreprocessor createPreprocessor(RouterContext ctx) {\n        return new BatchedPreprocessor(ctx, \"testBatchedPreprocessor\");\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void testBatched(int firstSize, boolean firstRouter, boolean firstTunnel, \n                            int secondSize, boolean secondRouter, boolean secondTunnel,\n                            int thirdSize, boolean thirdRouter, boolean thirdTunnel) {\n        TunnelGateway.Pending pending1 = createPending(firstSize, firstRouter, firstTunnel);\n        TunnelGateway.Pending pending2 = createPending(secondSize, secondRouter, secondTunnel);\n        TunnelGateway.Pending pending3 = createPending(thirdSize, thirdRouter, thirdTunnel);\n        \n        runBatch(pending1, pending2, pending3);\n    }","id":25818,"modified_method":"private void testBatched(int firstSize, boolean firstRouter, boolean firstTunnel, \n                            int secondSize, boolean secondRouter, boolean secondTunnel,\n                            int thirdSize, boolean thirdRouter, boolean thirdTunnel) {\n        PendingGatewayMessage pending1 = createPending(firstSize, firstRouter, firstTunnel);\n        PendingGatewayMessage pending2 = createPending(secondSize, secondRouter, secondTunnel);\n        PendingGatewayMessage pending3 = createPending(thirdSize, thirdRouter, thirdTunnel);\n        \n        runBatch(pending1, pending2, pending3);\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected boolean runVaried(int size, boolean includeRouter, boolean includeTunnel) {\n        TunnelGateway.Pending pending = createPending(size, includeRouter, includeTunnel);\n        ArrayList messages = new ArrayList();\n        messages.add(pending);\n        \n        DefragmentedReceiverImpl handleReceiver = new DefragmentedReceiverImpl(pending.getData());\n        TunnelGateway.QueuePreprocessor pre = createPreprocessor(_context);\n        SenderImpl sender = new SenderImpl();\n        FragmentHandler handler = new FragmentHandler(_context, handleReceiver);\n        ReceiverImpl receiver = new ReceiverImpl(handler, 0);\n        byte msg[] = pending.getData();\n            \n        boolean keepGoing = true;\n        while (keepGoing) {\n            keepGoing = pre.preprocessQueue(messages, new SenderImpl(), receiver);\n            if (keepGoing)\n                try { Thread.sleep(100); } catch (InterruptedException ie) {}\n        }\n        \n        return handleReceiver.receivedOk();\n    }","id":25819,"modified_method":"protected boolean runVaried(int size, boolean includeRouter, boolean includeTunnel) {\n        PendingGatewayMessage pending = createPending(size, includeRouter, includeTunnel);\n        ArrayList messages = new ArrayList();\n        messages.add(pending);\n        \n        DefragmentedReceiverImpl handleReceiver = new DefragmentedReceiverImpl(pending.getData());\n        TunnelGateway.QueuePreprocessor pre = createPreprocessor(_context);\n        SenderImpl sender = new SenderImpl();\n        FragmentHandler handler = new FragmentHandler(_context, handleReceiver);\n        ReceiverImpl receiver = new ReceiverImpl(handler, 0);\n        byte msg[] = pending.getData();\n            \n        boolean keepGoing = true;\n        while (keepGoing) {\n            keepGoing = pre.preprocessQueue(messages, new SenderImpl(), receiver);\n            if (keepGoing)\n                try { Thread.sleep(100); } catch (InterruptedException ie) {}\n        }\n        \n        return handleReceiver.receivedOk();\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void setUp() {\n        _context = I2PAppContext.getGlobalContext();\n        _context.random().nextBoolean();\n        FragmentHandler.MAX_DEFRAGMENT_TIME = 10*1000;\n    }","id":25820,"modified_method":"public void setUp() {\n        _context = (RouterContext) I2PAppContext.getGlobalContext();\n        _context.random().nextBoolean();\n        FragmentHandler.MAX_DEFRAGMENT_TIME = 10*1000;\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void receiveEncrypted(byte[] encrypted) {\n            _handler.receiveTunnelMessage(encrypted, 0, encrypted.length);\n            try { Thread.sleep(_delay); } catch (Exception e) {}\n        }","id":25821,"modified_method":"public long receiveEncrypted(byte[] encrypted) {\n            _handler.receiveTunnelMessage(encrypted, 0, encrypted.length);\n            try { Thread.sleep(_delay); } catch (Exception e) {}\n        }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Send a fragmented message, except wait a while between each fragment, causing\n     * the defragmentation to fail (since the fragments will expire)\n     *\n     */\n    public void runDelayed() {\n        TunnelGateway.Pending pending = createPending(2048, false, false);\n        ArrayList messages = new ArrayList();\n        messages.add(pending);\n        TunnelGateway.QueuePreprocessor pre = createPreprocessor(_context);\n        SenderImpl sender = new SenderImpl();\n        FragmentHandler handler = new FragmentHandler(_context, new DefragmentedReceiverImpl(pending.getData()));\n        ReceiverImpl receiver = new ReceiverImpl(handler, 11*1000);\n        byte msg[] = pending.getData();\n        \n        boolean keepGoing = true;\n        while (keepGoing) {\n            keepGoing = pre.preprocessQueue(messages, new SenderImpl(), receiver);\n            if (keepGoing)\n                try { Thread.sleep(100); } catch (InterruptedException ie) {}\n        }\n    }","id":25822,"modified_method":"/**\n     * Send a fragmented message, except wait a while between each fragment, causing\n     * the defragmentation to fail (since the fragments will expire)\n     *\n     */\n    public void runDelayed() {\n        PendingGatewayMessage pending = createPending(2048, false, false);\n        ArrayList messages = new ArrayList();\n        messages.add(pending);\n        TunnelGateway.QueuePreprocessor pre = createPreprocessor(_context);\n        SenderImpl sender = new SenderImpl();\n        FragmentHandler handler = new FragmentHandler(_context, new DefragmentedReceiverImpl(pending.getData()));\n        ReceiverImpl receiver = new ReceiverImpl(handler, 11*1000);\n        byte msg[] = pending.getData();\n        \n        boolean keepGoing = true;\n        while (keepGoing) {\n            keepGoing = pre.preprocessQueue(messages, new SenderImpl(), receiver);\n            if (keepGoing)\n                try { Thread.sleep(100); } catch (InterruptedException ie) {}\n        }\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected TunnelGateway.Pending createPending(int size, boolean includeRouter, boolean includeTunnel) {\n        DataMessage m = new DataMessage(_context);\n        byte data[] = new byte[size];\n        _context.random().nextBytes(data);\n        m.setData(data);\n        m.setUniqueId(_context.random().nextLong(I2NPMessage.MAX_ID_VALUE));\n        m.setMessageExpiration(_context.clock().now() + 60*1000);\n        \n        Hash toRouter = null;\n        TunnelId toTunnel = null;\n        if (includeRouter) {\n            toRouter = new Hash(new byte[Hash.HASH_LENGTH]);\n            _context.random().nextBytes(toRouter.getData());\n        }\n        if (includeTunnel)\n            toTunnel = new TunnelId(_context.random().nextLong(TunnelId.MAX_ID_VALUE));\n        return new TunnelGateway.Pending(m, toRouter, toTunnel);\n    }","id":25823,"modified_method":"protected PendingGatewayMessage createPending(int size, boolean includeRouter, boolean includeTunnel) {\n        DataMessage m = new DataMessage(_context);\n        byte data[] = new byte[size];\n        _context.random().nextBytes(data);\n        m.setData(data);\n        m.setUniqueId(_context.random().nextLong(I2NPMessage.MAX_ID_VALUE));\n        m.setMessageExpiration(_context.clock().now() + 60*1000);\n        \n        Hash toRouter = null;\n        TunnelId toTunnel = null;\n        if (includeRouter) {\n            toRouter = new Hash(new byte[Hash.HASH_LENGTH]);\n            _context.random().nextBytes(toRouter.getData());\n        }\n        if (includeTunnel)\n            toTunnel = new TunnelId(_context.random().nextLong(TunnelId.MAX_ID_VALUE));\n        return new PendingGatewayMessage(m, toRouter, toTunnel);\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Send a message with two fragments through with no delay\n     *\n     */\n    public void testMultiple() {\n        TunnelGateway.Pending pending = createPending(2048, false, false);\n        ArrayList messages = new ArrayList();\n        messages.add(pending);\n        \n        TunnelGateway.QueuePreprocessor pre = createPreprocessor(_context);\n        SenderImpl sender = new SenderImpl();\n        DefragmentedReceiverImpl handleReceiver = new DefragmentedReceiverImpl(pending.getData());\n        FragmentHandler handler = new FragmentHandler(_context, handleReceiver);\n        ReceiverImpl receiver = new ReceiverImpl(handler, 0);\n        byte msg[] = pending.getData();\n            \n        boolean keepGoing = true;\n        while (keepGoing) {\n            keepGoing = pre.preprocessQueue(messages, new SenderImpl(), receiver);\n            if (keepGoing)\n                try { Thread.sleep(100); } catch (InterruptedException ie) {}\n        }\n        assertTrue(handleReceiver.receivedOk());\n    }","id":25824,"modified_method":"/**\n     * Send a message with two fragments through with no delay\n     *\n     */\n    public void testMultiple() {\n        PendingGatewayMessage pending = createPending(2048, false, false);\n        ArrayList messages = new ArrayList();\n        messages.add(pending);\n        \n        TunnelGateway.QueuePreprocessor pre = createPreprocessor(_context);\n        SenderImpl sender = new SenderImpl();\n        DefragmentedReceiverImpl handleReceiver = new DefragmentedReceiverImpl(pending.getData());\n        FragmentHandler handler = new FragmentHandler(_context, handleReceiver);\n        ReceiverImpl receiver = new ReceiverImpl(handler, 0);\n        byte msg[] = pending.getData();\n            \n        boolean keepGoing = true;\n        while (keepGoing) {\n            keepGoing = pre.preprocessQueue(messages, new SenderImpl(), receiver);\n            if (keepGoing)\n                try { Thread.sleep(100); } catch (InterruptedException ie) {}\n        }\n        assertTrue(handleReceiver.receivedOk());\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void sendPreprocessed(byte[] preprocessed, TunnelGateway.Receiver receiver) {\n            receiver.receiveEncrypted(preprocessed);\n        }","id":25825,"modified_method":"public long sendPreprocessed(byte[] preprocessed, TunnelGateway.Receiver receiver) {\n            receiver.receiveEncrypted(preprocessed);\n        }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Send a message that fits inside a single fragment through\n     *\n     */\n    public void testSingle() {\n        TunnelGateway.Pending pending = createPending(949, false, false);\n        ArrayList messages = new ArrayList();\n        messages.add(pending);\n\n        TunnelGateway.QueuePreprocessor pre = createPreprocessor(_context);\n        SenderImpl sender = new SenderImpl();\n        DefragmentedReceiverImpl handleReceiver = new DefragmentedReceiverImpl(pending.getData());\n        FragmentHandler handler = new FragmentHandler(_context, handleReceiver);\n        ReceiverImpl receiver = new ReceiverImpl(handler, 0);\n        byte msg[] = pending.getData();\n        \n        boolean keepGoing = true;\n        while (keepGoing) {\n            keepGoing = pre.preprocessQueue(messages, new SenderImpl(), receiver);\n            if (keepGoing)\n                try { Thread.sleep(100); } catch (InterruptedException ie) {}\n        }\n        assertTrue(handleReceiver.receivedOk());\n    }","id":25826,"modified_method":"/**\n     * Send a message that fits inside a single fragment through\n     *\n     */\n    public void testSingle() {\n        PendingGatewayMessage pending = createPending(949, false, false);\n        ArrayList messages = new ArrayList();\n        messages.add(pending);\n\n        TunnelGateway.QueuePreprocessor pre = createPreprocessor(_context);\n        SenderImpl sender = new SenderImpl();\n        DefragmentedReceiverImpl handleReceiver = new DefragmentedReceiverImpl(pending.getData());\n        FragmentHandler handler = new FragmentHandler(_context, handleReceiver);\n        ReceiverImpl receiver = new ReceiverImpl(handler, 0);\n        byte msg[] = pending.getData();\n        \n        boolean keepGoing = true;\n        while (keepGoing) {\n            keepGoing = pre.preprocessQueue(messages, new SenderImpl(), receiver);\n            if (keepGoing)\n                try { Thread.sleep(100); } catch (InterruptedException ie) {}\n        }\n        assertTrue(handleReceiver.receivedOk());\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected TunnelGateway.QueuePreprocessor createPreprocessor(I2PAppContext ctx) {\n        return new TrivialPreprocessor(ctx);\n    }","id":25827,"modified_method":"protected TunnelGateway.QueuePreprocessor createPreprocessor(RouterContext ctx) {\n        return new TrivialPreprocessor(ctx);\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void receiveEncrypted(byte[] encrypted) {\n            // fake all the hops...\n            \n            for (int i = 1; i <= _config.getLength() - 2; i++) {\n                HopProcessor hop = new HopProcessor(_context, _config.getConfig(i));\n                assertTrue(hop.process(encrypted, 0, encrypted.length, _config.getConfig(i).getReceiveFrom()));\n            }\n            \n            // now handle it at the endpoint\n            InboundEndpointProcessor end = new InboundEndpointProcessor(_context, _config);\n            assertTrue(end.retrievePreprocessedData(encrypted, 0, encrypted.length, _config.getPeer(_config.getLength()-2)));\n            \n            \n            _handler.receiveTunnelMessage(encrypted, 0, encrypted.length);\n        }","id":25828,"modified_method":"public long receiveEncrypted(byte[] encrypted) {\n            // fake all the hops...\n            \n            for (int i = 1; i <= _config.getLength() - 2; i++) {\n                HopProcessor hop = new HopProcessor(_context, _config.getConfig(i));\n                assertTrue(hop.process(encrypted, 0, encrypted.length, _config.getConfig(i).getReceiveFrom()));\n            }\n            \n            // now handle it at the endpoint\n            InboundEndpointProcessor end = new InboundEndpointProcessor(_context, _config);\n            assertTrue(end.retrievePreprocessedData(encrypted, 0, encrypted.length, _config.getPeer(_config.getLength()-2)));\n            \n            \n            _handler.receiveTunnelMessage(encrypted, 0, encrypted.length);\n        }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void setUp() {\n        _context = I2PAppContext.getGlobalContext();\n        _config = prepareConfig(8);\n        _preprocessor = new TrivialPreprocessor(_context);\n        _sender = new InboundSender(_context, _config.getConfig(0));\n        _receiver = new TestReceiver(_config);\n        _gw = new TunnelGateway(_context, _preprocessor, _sender, _receiver);\n    }","id":25829,"modified_method":"public void setUp() {\n        _context = (RouterContext) I2PAppContext.getGlobalContext();\n        _config = prepareConfig(8);\n        _preprocessor = new TrivialPreprocessor(_context);\n        _sender = new InboundSender(_context, _config.getConfig(0));\n        _receiver = new TestReceiver(_config);\n        _gw = new TunnelGateway(_context, _preprocessor, _sender, _receiver);\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private TunnelCreatorConfig prepareConfig(int numHops) {\n        Hash peers[] = new Hash[numHops];\n        byte tunnelIds[][] = new byte[numHops][4];\n        for (int i = 0; i < numHops; i++) {\n            peers[i] = new Hash();\n            peers[i].setData(new byte[Hash.HASH_LENGTH]);\n            _context.random().nextBytes(peers[i].getData());\n            _context.random().nextBytes(tunnelIds[i]);\n        }\n        \n        TunnelCreatorConfig config = new TunnelCreatorConfig(numHops, false);\n        for (int i = 0; i < numHops; i++) {\n            config.setPeer(i, peers[i]);\n            HopConfig cfg = config.getConfig(i);\n            cfg.setExpiration(_context.clock().now() + 60000);\n            cfg.setIVKey(_context.keyGenerator().generateSessionKey());\n            cfg.setLayerKey(_context.keyGenerator().generateSessionKey());\n            if (i > 0)\n                cfg.setReceiveFrom(peers[i-1]);\n            else\n                cfg.setReceiveFrom(null);\n            cfg.setReceiveTunnelId(tunnelIds[i]);\n            if (i < numHops - 1) {\n                cfg.setSendTo(peers[i+1]);\n                cfg.setSendTunnelId(tunnelIds[i+1]);\n            } else {\n                cfg.setSendTo(null);\n                cfg.setSendTunnelId(null);\n            }\n        }\n        return config;\n    }","id":25830,"modified_method":"private TunnelCreatorConfig prepareConfig(int numHops) {\n        Hash peers[] = new Hash[numHops];\n        byte tunnelIds[][] = new byte[numHops][4];\n        for (int i = 0; i < numHops; i++) {\n            peers[i] = new Hash();\n            peers[i].setData(new byte[Hash.HASH_LENGTH]);\n            _context.random().nextBytes(peers[i].getData());\n            _context.random().nextBytes(tunnelIds[i]);\n        }\n        \n        TunnelCreatorConfig config = new TunnelCreatorConfig(_context, numHops, false);\n        for (int i = 0; i < numHops; i++) {\n            config.setPeer(i, peers[i]);\n            HopConfig cfg = config.getConfig(i);\n            cfg.setExpiration(_context.clock().now() + 60000);\n            cfg.setIVKey(_context.keyGenerator().generateSessionKey());\n            cfg.setLayerKey(_context.keyGenerator().generateSessionKey());\n            if (i > 0)\n                cfg.setReceiveFrom(peers[i-1]);\n            else\n                cfg.setReceiveFrom(null);\n            cfg.setReceiveTunnelId(tunnelIds[i]);\n            if (i < numHops - 1) {\n                cfg.setSendTo(peers[i+1]);\n                cfg.setSendTunnelId(tunnelIds[i+1]);\n            } else {\n                cfg.setSendTo(null);\n                cfg.setSendTunnelId(null);\n            }\n        }\n        return config;\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private TunnelCreatorConfig prepareConfig(int numHops) {\n        Hash peers[] = new Hash[numHops];\n        byte tunnelIds[][] = new byte[numHops][4];\n        for (int i = 0; i < numHops; i++) {\n            peers[i] = new Hash();\n            peers[i].setData(new byte[Hash.HASH_LENGTH]);\n            _context.random().nextBytes(peers[i].getData());\n            _context.random().nextBytes(tunnelIds[i]);\n        }\n        \n        TunnelCreatorConfig config = new TunnelCreatorConfig(numHops, false);\n        for (int i = 0; i < numHops; i++) {\n            config.setPeer(i, peers[i]);\n            HopConfig cfg = config.getConfig(i);\n            cfg.setExpiration(_context.clock().now() + 60000);\n            cfg.setIVKey(_context.keyGenerator().generateSessionKey());\n            cfg.setLayerKey(_context.keyGenerator().generateSessionKey());\n            if (i > 0)\n                cfg.setReceiveFrom(peers[i-1]);\n            else\n                cfg.setReceiveFrom(null);\n            cfg.setReceiveTunnelId(tunnelIds[i]);\n            if (i < numHops - 1) {\n                cfg.setSendTo(peers[i+1]);\n                cfg.setSendTunnelId(tunnelIds[i+1]);\n            } else {\n                cfg.setSendTo(null);\n                cfg.setSendTunnelId(null);\n            }\n        }\n        return config;\n    }","id":25831,"modified_method":"private TunnelCreatorConfig prepareConfig(int numHops) {\n        Hash peers[] = new Hash[numHops];\n        byte tunnelIds[][] = new byte[numHops][4];\n        for (int i = 0; i < numHops; i++) {\n            peers[i] = new Hash();\n            peers[i].setData(new byte[Hash.HASH_LENGTH]);\n            _context.random().nextBytes(peers[i].getData());\n            _context.random().nextBytes(tunnelIds[i]);\n        }\n        \n        TunnelCreatorConfig config = new TunnelCreatorConfig(_context, numHops, false);\n        for (int i = 0; i < numHops; i++) {\n            config.setPeer(i, peers[i]);\n            HopConfig cfg = config.getConfig(i);\n            cfg.setExpiration(_context.clock().now() + 60000);\n            cfg.setIVKey(_context.keyGenerator().generateSessionKey());\n            cfg.setLayerKey(_context.keyGenerator().generateSessionKey());\n            if (i > 0)\n                cfg.setReceiveFrom(peers[i-1]);\n            else\n                cfg.setReceiveFrom(null);\n            cfg.setReceiveTunnelId(tunnelIds[i]);\n            if (i < numHops - 1) {\n                cfg.setSendTo(peers[i+1]);\n                cfg.setSendTunnelId(tunnelIds[i+1]);\n            } else {\n                cfg.setSendTo(null);\n                cfg.setSendTunnelId(null);\n            }\n        }\n        return config;\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void setUp() {\n        _context = I2PAppContext.getGlobalContext();\n    }","id":25832,"modified_method":"public void setUp() {\n        _context = (RouterContext) I2PAppContext.getGlobalContext();\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void setUp() {\n        _context = I2PAppContext.getGlobalContext();\n        _config = prepareConfig(8);\n        _preprocessor = new TrivialPreprocessor(_context);\n        _sender = new OutboundSender(_context, _config);\n        _receiver = new TestReceiver(_config);\n        _gw = new TunnelGateway(_context, _preprocessor, _sender, _receiver);\n    }","id":25833,"modified_method":"public void setUp() {\n        _context = (RouterContext) I2PAppContext.getGlobalContext();\n        _config = prepareConfig(8);\n        _preprocessor = new TrivialPreprocessor(_context);\n        _sender = new OutboundSender(_context, _config);\n        _receiver = new TestReceiver(_config);\n        _gw = new TunnelGateway(_context, _preprocessor, _sender, _receiver);\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private TunnelCreatorConfig prepareConfig(int numHops) {\n        Hash peers[] = new Hash[numHops];\n        byte tunnelIds[][] = new byte[numHops][4];\n        for (int i = 0; i < numHops; i++) {\n            peers[i] = new Hash();\n            peers[i].setData(new byte[Hash.HASH_LENGTH]);\n            _context.random().nextBytes(peers[i].getData());\n            _context.random().nextBytes(tunnelIds[i]);\n        }\n        \n        TunnelCreatorConfig config = new TunnelCreatorConfig(numHops, false);\n        for (int i = 0; i < numHops; i++) {\n            config.setPeer(i, peers[i]);\n            HopConfig cfg = config.getConfig(i);\n            cfg.setExpiration(_context.clock().now() + 60000);\n            cfg.setIVKey(_context.keyGenerator().generateSessionKey());\n            cfg.setLayerKey(_context.keyGenerator().generateSessionKey());\n            if (i > 0)\n                cfg.setReceiveFrom(peers[i-1]);\n            else\n                cfg.setReceiveFrom(null);\n            cfg.setReceiveTunnelId(tunnelIds[i]);\n            if (i < numHops - 1) {\n                cfg.setSendTo(peers[i+1]);\n                cfg.setSendTunnelId(tunnelIds[i+1]);\n            } else {\n                cfg.setSendTo(null);\n                cfg.setSendTunnelId(null);\n            }\n        }\n        return config;\n    }","id":25834,"modified_method":"private TunnelCreatorConfig prepareConfig(int numHops) {\n        Hash peers[] = new Hash[numHops];\n        byte tunnelIds[][] = new byte[numHops][4];\n        for (int i = 0; i < numHops; i++) {\n            peers[i] = new Hash();\n            peers[i].setData(new byte[Hash.HASH_LENGTH]);\n            _context.random().nextBytes(peers[i].getData());\n            _context.random().nextBytes(tunnelIds[i]);\n        }\n        \n        TunnelCreatorConfig config = new TunnelCreatorConfig(_context, numHops, false);\n        for (int i = 0; i < numHops; i++) {\n            config.setPeer(i, peers[i]);\n            HopConfig cfg = config.getConfig(i);\n            cfg.setExpiration(_context.clock().now() + 60000);\n            cfg.setIVKey(_context.keyGenerator().generateSessionKey());\n            cfg.setLayerKey(_context.keyGenerator().generateSessionKey());\n            if (i > 0)\n                cfg.setReceiveFrom(peers[i-1]);\n            else\n                cfg.setReceiveFrom(null);\n            cfg.setReceiveTunnelId(tunnelIds[i]);\n            if (i < numHops - 1) {\n                cfg.setSendTo(peers[i+1]);\n                cfg.setSendTunnelId(tunnelIds[i+1]);\n            } else {\n                cfg.setSendTo(null);\n                cfg.setSendTunnelId(null);\n            }\n        }\n        return config;\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void receiveEncrypted(byte[] encrypted) {\n            // fake all the hops...\n            \n            for (int i = 1; i < _config.getLength(); i++) {\n                HopProcessor hop = new HopProcessor(_context, _config.getConfig(i));\n                assertTrue(hop.process(encrypted, 0, encrypted.length, _config.getConfig(i).getReceiveFrom()));\n                \n            }\n            \n\n            _handler.receiveTunnelMessage(encrypted, 0, encrypted.length);\n        }","id":25835,"modified_method":"public long receiveEncrypted(byte[] encrypted) {\n            // fake all the hops...\n            \n            for (int i = 1; i < _config.getLength(); i++) {\n                HopProcessor hop = new HopProcessor(_context, _config.getConfig(i));\n                assertTrue(hop.process(encrypted, 0, encrypted.length, _config.getConfig(i).getReceiveFrom()));\n                \n            }\n            \n\n            _handler.receiveTunnelMessage(encrypted, 0, encrypted.length);\n        }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private TunnelCreatorConfig prepareConfig(int numHops) {\n        Hash peers[] = new Hash[numHops];\n        byte tunnelIds[][] = new byte[numHops][4];\n        for (int i = 0; i < numHops; i++) {\n            peers[i] = new Hash();\n            peers[i].setData(new byte[Hash.HASH_LENGTH]);\n            _context.random().nextBytes(peers[i].getData());\n            _context.random().nextBytes(tunnelIds[i]);\n        }\n        \n        TunnelCreatorConfig config = new TunnelCreatorConfig(numHops, false);\n        for (int i = 0; i < numHops; i++) {\n        \tconfig.setPeer(i, peers[i]);\n            HopConfig cfg = config.getConfig(i);\n            cfg.setExpiration(_context.clock().now() + 60000);\n            cfg.setIVKey(_context.keyGenerator().generateSessionKey());\n            cfg.setLayerKey(_context.keyGenerator().generateSessionKey());\n            if (i > 0)\n                cfg.setReceiveFrom(peers[i-1]);\n            else\n                cfg.setReceiveFrom(null);\n            cfg.setReceiveTunnelId(tunnelIds[i]);\n            if (i < numHops - 1) {\n                cfg.setSendTo(peers[i+1]);\n                cfg.setSendTunnelId(tunnelIds[i+1]);\n            } else {\n                cfg.setSendTo(null);\n                cfg.setSendTunnelId(null);\n            }\n        }\n        return config;\n    }","id":25836,"modified_method":"private TunnelCreatorConfig prepareConfig(int numHops) {\n        Hash peers[] = new Hash[numHops];\n        byte tunnelIds[][] = new byte[numHops][4];\n        for (int i = 0; i < numHops; i++) {\n            peers[i] = new Hash();\n            peers[i].setData(new byte[Hash.HASH_LENGTH]);\n            _context.random().nextBytes(peers[i].getData());\n            _context.random().nextBytes(tunnelIds[i]);\n        }\n        \n        TunnelCreatorConfig config = new TunnelCreatorConfig(_context, numHops, false);\n        for (int i = 0; i < numHops; i++) {\n        \tconfig.setPeer(i, peers[i]);\n            HopConfig cfg = config.getConfig(i);\n            cfg.setExpiration(_context.clock().now() + 60000);\n            cfg.setIVKey(_context.keyGenerator().generateSessionKey());\n            cfg.setLayerKey(_context.keyGenerator().generateSessionKey());\n            if (i > 0)\n                cfg.setReceiveFrom(peers[i-1]);\n            else\n                cfg.setReceiveFrom(null);\n            cfg.setReceiveTunnelId(tunnelIds[i]);\n            if (i < numHops - 1) {\n                cfg.setSendTo(peers[i+1]);\n                cfg.setSendTunnelId(tunnelIds[i+1]);\n            } else {\n                cfg.setSendTo(null);\n                cfg.setSendTunnelId(null);\n            }\n        }\n        return config;\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void setUp() {\n        _context = I2PAppContext.getGlobalContext();\n    }","id":25837,"modified_method":"public void setUp() {\n        _context = (RouterContext) I2PAppContext.getGlobalContext();\n    }","commit_id":"dae66d7f73f07dea625851b62e146eb727c69742","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    public Object transformMessage(MuleMessage message, String outputEncoding) throws TransformerException\n    {\n        Object keyValue = identifierEvaluator.resolveValue(message);\n        String key = (keyValue == null ? null : keyValue.toString());\n        message.setProperty(key, valueEvaluator.resolveValue(message), getScope());\n\n        return message;\n    }","id":25838,"modified_method":"@Override\n    public Object transformMessage(MuleMessage message, String outputEncoding) throws TransformerException\n    {\n        Object keyValue = identifierEvaluator.resolveValue(message);\n        String key = (keyValue == null ? null : keyValue.toString());\n        if (key == null)\n        {\n            logger.error(\"Setting Null variable keys is not supported, this entry is being ignored\");\n        }\n        else\n        {\n            Object value = valueEvaluator.resolveValue(message);\n            if (value == null)\n            {\n                message.removeProperty(key, getScope());\n\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(MessageFormat.format(\n                            \"Variable with key \\\"{0}\\\", not found on message using \\\"{1}\\\". Since the value was marked optional, nothing was set on the message for this variable\",\n                            key, valueEvaluator.getRawValue()));\n                }\n            }\n            else\n            {\n                message.setProperty(key, value, getScope());\n            }\n        }\n        return message;\n    }","commit_id":"d960dc7d5ac044fe3d28786f99aea81714eb8ae3","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testAddVariableWithNullExpressionValueResult()\n        throws InitialisationException, TransformerException\n    {\n        addVariableTransformer.setIdentifier(PLAIN_STRING_KEY);\n        addVariableTransformer.setValue(NULL_EXPRESSION);\n        addVariableTransformer.initialise();\n        addVariableTransformer.transform(mockMessage, ENCODING);\n        Mockito.verify(mockMessage, VerificationModeFactory.times(1)).setProperty(anyString(), isNull(),\n            Matchers.<PropertyScope> anyObject());\n    }","id":25839,"modified_method":"@Test\n    public void testAddVariableWithNullExpressionValueResult()\n        throws InitialisationException, TransformerException\n    {\n        addVariableTransformer.setIdentifier(PLAIN_STRING_KEY);\n        addVariableTransformer.setValue(NULL_EXPRESSION);\n        addVariableTransformer.initialise();\n        addVariableTransformer.transform(mockMessage, ENCODING);\n        Mockito.verify(mockMessage, VerificationModeFactory.times(1)).removeProperty(PLAIN_STRING_KEY, scope);\n    }","commit_id":"d960dc7d5ac044fe3d28786f99aea81714eb8ae3","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testAddVariableWithNullExpressionKeyResult()\n        throws InitialisationException, TransformerException\n    {\n        addVariableTransformer.setIdentifier(NULL_EXPRESSION);\n        addVariableTransformer.setValue(PLAIN_STRING_VALUE);\n        addVariableTransformer.initialise();\n        addVariableTransformer.transform(mockMessage, ENCODING);\n        Mockito.verify(mockMessage, VerificationModeFactory.times(1)).setProperty((String) isNull(), anyString(),\n            Matchers.<PropertyScope> anyObject());\n    }","id":25840,"modified_method":"@Test\n    public void testAddVariableWithNullExpressionKeyResult()\n        throws InitialisationException, TransformerException\n    {\n        addVariableTransformer.setIdentifier(NULL_EXPRESSION);\n        addVariableTransformer.setValue(PLAIN_STRING_VALUE);\n        addVariableTransformer.initialise();\n        addVariableTransformer.transform(mockMessage, ENCODING);\n        Mockito.verify(mockMessage, VerificationModeFactory.times(0)).setProperty((String) isNull(), anyString(),\n            Matchers.<PropertyScope> anyObject());\n    }","commit_id":"d960dc7d5ac044fe3d28786f99aea81714eb8ae3","url":"https://github.com/mulesoft/mule"},{"original_method":"private InvocableHandlerMethod handlerMethod(String name, Class<?>... args) throws Exception {\n\t\tMethod method = ResolvableMethod.on(TestController.class).name(name).argumentTypes(args).resolve();\n\t\treturn new InvocableHandlerMethod(new HandlerMethod(new TestController(), method));\n\t}","id":25841,"modified_method":"private InvocableHandlerMethod handlerMethod(String name) throws Exception {\n\t\tMethod method = ResolvableMethod.on(TestController.class).name(name).resolve();\n\t\treturn new InvocableHandlerMethod(new HandlerMethod(new TestController(), method));\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void noMatchingResolver() throws Exception {\n\t\tInvocableHandlerMethod hm = handlerMethod(\"singleArg\", String.class);\n\t\tMono<HandlerResult> mono = hm.invokeForRequest(this.exchange, this.model);\n\n\t\tTestSubscriber.subscribe(mono)\n\t\t\t\t.assertError(IllegalStateException.class)\n\t\t\t\t.assertErrorMessage(\"No resolver for argument [0] of type [java.lang.String] \" +\n\t\t\t\t\t\t\"on method [\" + hm.getMethod().toGenericString() + \"]\");\n\t}","id":25842,"modified_method":"@Test\n\tpublic void noMatchingResolver() throws Exception {\n\t\tInvocableHandlerMethod hm = handlerMethod(\"singleArg\");\n\t\tMono<HandlerResult> mono = hm.invokeForRequest(this.exchange, this.model);\n\n\t\tTestSubscriber.subscribe(mono)\n\t\t\t\t.assertError(IllegalStateException.class)\n\t\t\t\t.assertErrorMessage(\"No resolver for argument [0] of type [java.lang.String] \" +\n\t\t\t\t\t\t\"on method [\" + hm.getMethod().toGenericString() + \"]\");\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void illegalArgumentExceptionIsWrappedWithInvocationDetails() throws Exception {\n\t\tInvocableHandlerMethod hm = handlerMethod(\"singleArg\", String.class);\n\t\taddResolver(hm, Mono.just(1));\n\t\tMono<HandlerResult> mono = hm.invokeForRequest(this.exchange, this.model);\n\n\t\tTestSubscriber.subscribe(mono)\n\t\t\t\t.assertError(IllegalStateException.class)\n\t\t\t\t.assertErrorMessage(\"Failed to invoke controller with resolved arguments: \" +\n\t\t\t\t\t\t\"[0][type=java.lang.Integer][value=1] \" +\n\t\t\t\t\t\t\"on method [\" + hm.getMethod().toGenericString() + \"]\");\n\t}","id":25843,"modified_method":"@Test\n\tpublic void illegalArgumentExceptionIsWrappedWithInvocationDetails() throws Exception {\n\t\tInvocableHandlerMethod hm = handlerMethod(\"singleArg\");\n\t\taddResolver(hm, Mono.just(1));\n\t\tMono<HandlerResult> mono = hm.invokeForRequest(this.exchange, this.model);\n\n\t\tTestSubscriber.subscribe(mono)\n\t\t\t\t.assertError(IllegalStateException.class)\n\t\t\t\t.assertErrorMessage(\"Failed to invoke controller with resolved arguments: \" +\n\t\t\t\t\t\t\"[0][type=java.lang.Integer][value=1] \" +\n\t\t\t\t\t\t\"on method [\" + hm.getMethod().toGenericString() + \"]\");\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resolverThrowsException() throws Exception {\n\t\tInvocableHandlerMethod hm = handlerMethod(\"singleArg\", String.class);\n\t\taddResolver(hm, Mono.error(new IllegalStateException(\"boo\")));\n\t\tMono<HandlerResult> mono = hm.invokeForRequest(this.exchange, this.model);\n\n\t\tTestSubscriber.subscribe(mono)\n\t\t\t\t.assertError(IllegalStateException.class)\n\t\t\t\t.assertErrorMessage(\"Error resolving argument [0] of type [java.lang.String] \" +\n\t\t\t\t\t\t\"on method [\" + hm.getMethod().toGenericString() + \"]\");\n\t}","id":25844,"modified_method":"@Test\n\tpublic void resolverThrowsException() throws Exception {\n\t\tInvocableHandlerMethod hm = handlerMethod(\"singleArg\");\n\t\taddResolver(hm, Mono.error(new IllegalStateException(\"boo\")));\n\t\tMono<HandlerResult> mono = hm.invokeForRequest(this.exchange, this.model);\n\n\t\tTestSubscriber.subscribe(mono)\n\t\t\t\t.assertError(IllegalStateException.class)\n\t\t\t\t.assertErrorMessage(\"Error resolving argument [0] of type [java.lang.String] \" +\n\t\t\t\t\t\t\"on method [\" + hm.getMethod().toGenericString() + \"]\");\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void invokeMethodWithValue() throws Exception {\n\t\tInvocableHandlerMethod hm = handlerMethod(\"singleArg\", String.class);\n\t\taddResolver(hm, Mono.just(\"value1\"));\n\t\tMono<HandlerResult> mono = hm.invokeForRequest(this.exchange, this.model);\n\n\t\tassertHandlerResultValue(mono, \"success:value1\");\n\t}","id":25845,"modified_method":"@Test\n\tpublic void invokeMethodWithValue() throws Exception {\n\t\tInvocableHandlerMethod hm = handlerMethod(\"singleArg\");\n\t\taddResolver(hm, Mono.just(\"value1\"));\n\t\tMono<HandlerResult> mono = hm.invokeForRequest(this.exchange, this.model);\n\n\t\tassertHandlerResultValue(mono, \"success:value1\");\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resolverWithErrorSignal() throws Exception {\n\t\tInvocableHandlerMethod hm = handlerMethod(\"singleArg\", String.class);\n\t\taddResolver(hm, Mono.error(new IllegalStateException(\"boo\")));\n\t\tMono<HandlerResult> mono = hm.invokeForRequest(this.exchange, this.model);\n\n\t\tTestSubscriber.subscribe(mono)\n\t\t\t\t.assertError(IllegalStateException.class)\n\t\t\t\t.assertErrorMessage(\"Error resolving argument [0] of type [java.lang.String] \" +\n\t\t\t\t\t\t\"on method [\" + hm.getMethod().toGenericString() + \"]\");\n\t}","id":25846,"modified_method":"@Test\n\tpublic void resolverWithErrorSignal() throws Exception {\n\t\tInvocableHandlerMethod hm = handlerMethod(\"singleArg\");\n\t\taddResolver(hm, Mono.error(new IllegalStateException(\"boo\")));\n\t\tMono<HandlerResult> mono = hm.invokeForRequest(this.exchange, this.model);\n\n\t\tTestSubscriber.subscribe(mono)\n\t\t\t\t.assertError(IllegalStateException.class)\n\t\t\t\t.assertErrorMessage(\"Error resolving argument [0] of type [java.lang.String] \" +\n\t\t\t\t\t\t\"on method [\" + hm.getMethod().toGenericString() + \"]\");\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test @SuppressWarnings(\"unchecked\")\n\tpublic void fluxTestBean() throws Exception {\n\t\tString body = \"[{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"},{\\\"bar\\\":\\\"b2\\\",\\\"foo\\\":\\\"f2\\\"}]\";\n\t\tFlux<TestBean> flux = (Flux<TestBean>) resolveValue(\"fluxTestBean\", Flux.class, body);\n\t\tassertEquals(Arrays.asList(new TestBean(\"f1\", \"b1\"), new TestBean(\"f2\", \"b2\")), flux.collectList().block());\n\t}","id":25847,"modified_method":"@Test @SuppressWarnings(\"unchecked\")\n\tpublic void fluxTestBean() throws Exception {\n\t\tString body = \"[{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"},{\\\"bar\\\":\\\"b2\\\",\\\"foo\\\":\\\"f2\\\"}]\";\n\t\tResolvableType type = forClassWithGenerics(Flux.class, TestBean.class);\n\t\tMethodParameter param = this.testMethod.resolveParam(type);\n\t\tFlux<TestBean> flux = (Flux<TestBean>) resolveValue(param, Flux.class, body);\n\n\t\tassertEquals(Arrays.asList(new TestBean(\"f1\", \"b1\"), new TestBean(\"f2\", \"b2\")),\n\t\t\t\tflux.collectList().block());\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test @SuppressWarnings(\"unchecked\")\n\tpublic void monoTestBean() throws Exception {\n\t\tString body = \"{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"}\";\n\t\tMono<TestBean> mono = (Mono<TestBean>) resolveValue(\"monoTestBean\", Mono.class, body);\n\t\tassertEquals(new TestBean(\"f1\", \"b1\"), mono.block());\n\t}","id":25848,"modified_method":"@Test @SuppressWarnings(\"unchecked\")\n\tpublic void monoTestBean() throws Exception {\n\t\tString body = \"{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"}\";\n\t\tResolvableType type = forClassWithGenerics(Mono.class, TestBean.class);\n\t\tMethodParameter param = this.testMethod.resolveParam(type);\n\t\tMono<TestBean> mono = (Mono<TestBean>) resolveValue(param, Mono.class, body);\n\n\t\tassertEquals(new TestBean(\"f1\", \"b1\"), mono.block());\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test @SuppressWarnings(\"unchecked\")\n\tpublic void futureTestBean() throws Exception {\n\t\tString body = \"{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"}\";\n\t\tassertEquals(new TestBean(\"f1\", \"b1\"), resolveValue(\"futureTestBean\", CompletableFuture.class, body).get());\n\t}","id":25849,"modified_method":"@Test @SuppressWarnings(\"unchecked\")\n\tpublic void futureTestBean() throws Exception {\n\t\tString body = \"{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"}\";\n\t\tResolvableType type = forClassWithGenerics(CompletableFuture.class, TestBean.class);\n\t\tMethodParameter param = this.testMethod.resolveParam(type);\n\t\tCompletableFuture future = resolveValue(param, CompletableFuture.class, body);\n\n\t\tassertEquals(new TestBean(\"f1\", \"b1\"), future.get());\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void testBean() throws Exception {\n\t\tString body = \"{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"}\";\n\t\tassertEquals(new TestBean(\"f1\", \"b1\"), resolveValue(\"testBean\", TestBean.class, body));\n\t}","id":25850,"modified_method":"@Test\n\tpublic void testBean() throws Exception {\n\t\tString body = \"{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"}\";\n\t\tMethodParameter param = this.testMethod.resolveParam(\n\t\t\t\tforClass(TestBean.class), p -> p.hasParameterAnnotation(RequestBody.class));\n\t\tTestBean value = resolveValue(param, TestBean.class, body);\n\n\t\tassertEquals(new TestBean(\"f1\", \"b1\"), value);\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void list() throws Exception {\n\t\tString body = \"[{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"},{\\\"bar\\\":\\\"b2\\\",\\\"foo\\\":\\\"f2\\\"}]\";\n\t\tassertEquals(Arrays.asList(new TestBean(\"f1\", \"b1\"), new TestBean(\"f2\", \"b2\")),\n\t\t\t\tresolveValue(\"list\", List.class, body));\n\t}","id":25851,"modified_method":"@Test\n\tpublic void list() throws Exception {\n\t\tString body = \"[{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"},{\\\"bar\\\":\\\"b2\\\",\\\"foo\\\":\\\"f2\\\"}]\";\n\t\tResolvableType type = forClassWithGenerics(List.class, TestBean.class);\n\t\tMethodParameter param = this.testMethod.resolveParam(type);\n\t\tList<?> list = resolveValue(param, List.class, body);\n\n\t\tassertEquals(Arrays.asList(new TestBean(\"f1\", \"b1\"), new TestBean(\"f2\", \"b2\")), list);\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test @SuppressWarnings(\"unchecked\")\n\tpublic void validateFluxTestBean() throws Exception {\n\t\tString body = \"[{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"},{\\\"bar\\\":\\\"b2\\\"}]\";\n\t\tFlux<TestBean> flux = (Flux<TestBean>) resolveValue(\"fluxTestBean\", Flux.class, body);\n\n\t\tTestSubscriber.subscribe(flux).assertValues(new TestBean(\"f1\", \"b1\"))\n\t\t\t\t.assertError(ServerWebInputException.class);\n\t}","id":25852,"modified_method":"@Test @SuppressWarnings(\"unchecked\")\n\tpublic void validateFluxTestBean() throws Exception {\n\t\tString body = \"[{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"},{\\\"bar\\\":\\\"b2\\\"}]\";\n\t\tResolvableType type = forClassWithGenerics(Flux.class, TestBean.class);\n\t\tMethodParameter param = this.testMethod.resolveParam(type);\n\t\tFlux<TestBean> flux = resolveValue(param, Flux.class, body);\n\n\t\tTestSubscriber.subscribe(flux)\n\t\t\t\t.assertValues(new TestBean(\"f1\", \"b1\"))\n\t\t\t\t.assertError(ServerWebInputException.class);\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tprivate <T> T resolveValue(String paramName, Class<T> valueType, String body) {\n\n\t\tthis.request.getHeaders().setContentType(MediaType.APPLICATION_JSON);\n\t\tthis.request.writeWith(Flux.just(dataBuffer(body)));\n\n\t\tMono<Object> result = this.resolver.resolveArgument(parameter(paramName), this.model, this.exchange);\n\t\tObject value = result.block(Duration.ofSeconds(5));\n\n\t\tassertNotNull(value);\n\t\tassertTrue(\"Actual type: \" + value.getClass(), valueType.isAssignableFrom(value.getClass()));\n\n\t\treturn (T) value;\n\t}","id":25853,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tprivate <T> T resolveValue(MethodParameter param, Class<T> valueType, String body) {\n\n\t\tthis.request.getHeaders().setContentType(MediaType.APPLICATION_JSON);\n\t\tthis.request.writeWith(Flux.just(dataBuffer(body)));\n\n\t\tMono<Object> result = this.resolver.resolveArgument(param, new ExtendedModelMap(), this.exchange);\n\t\tObject value = result.block(Duration.ofSeconds(5));\n\n\t\tassertNotNull(value);\n\t\tassertTrue(\"Actual type: \" + value.getClass(), valueType.isAssignableFrom(value.getClass()));\n\n\t\treturn (T) value;\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test @SuppressWarnings(\"unchecked\")\n\tpublic void singleTestBean() throws Exception {\n\t\tString body = \"{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"}\";\n\t\tSingle<TestBean> single = (Single<TestBean>) resolveValue(\"singleTestBean\", Single.class, body);\n\t\tassertEquals(new TestBean(\"f1\", \"b1\"), single.toBlocking().value());\n\t}","id":25854,"modified_method":"@Test @SuppressWarnings(\"unchecked\")\n\tpublic void singleTestBean() throws Exception {\n\t\tString body = \"{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"}\";\n\t\tResolvableType type = forClassWithGenerics(Single.class, TestBean.class);\n\t\tMethodParameter param = this.testMethod.resolveParam(type);\n\t\tSingle<TestBean> single = (Single<TestBean>) resolveValue(param, Single.class, body);\n\n\t\tassertEquals(new TestBean(\"f1\", \"b1\"), single.toBlocking().value());\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test @SuppressWarnings(\"unchecked\")\n\tpublic void validateMonoTestBean() throws Exception {\n\t\tString body = \"{\\\"bar\\\":\\\"b1\\\"}\";\n\t\tMono<TestBean> mono = (Mono<TestBean>) resolveValue(\"monoTestBean\", Mono.class, body);\n\t\tTestSubscriber.subscribe(mono).assertNoValues().assertError(ServerWebInputException.class);\n\t}","id":25855,"modified_method":"@Test @SuppressWarnings(\"unchecked\")\n\tpublic void validateMonoTestBean() throws Exception {\n\t\tString body = \"{\\\"bar\\\":\\\"b1\\\"}\";\n\t\tResolvableType type = forClassWithGenerics(Mono.class, TestBean.class);\n\t\tMethodParameter param = this.testMethod.resolveParam(type);\n\t\tMono<TestBean> mono = resolveValue(param, Mono.class, body);\n\n\t\tTestSubscriber.subscribe(mono)\n\t\t\t\t.assertNoValues()\n\t\t\t\t.assertError(ServerWebInputException.class);\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void map() throws Exception {\n\t\tString body = \"{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"}\";\n\t\tMap<String, String> map = new HashMap<>();\n\t\tmap.put(\"foo\", \"f1\");\n\t\tmap.put(\"bar\", \"b1\");\n\t\tassertEquals(map, resolveValue(\"map\", Map.class, body));\n\t}","id":25856,"modified_method":"@Test\n\tpublic void map() throws Exception {\n\t\tString body = \"{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"}\";\n\t\tMap<String, String> map = new HashMap<>();\n\t\tmap.put(\"foo\", \"f1\");\n\t\tmap.put(\"bar\", \"b1\");\n\t\tResolvableType type = forClassWithGenerics(Map.class, String.class, String.class);\n\t\tMethodParameter param = this.testMethod.resolveParam(type);\n\t\tMap actual = resolveValue(param, Map.class, body);\n\n\t\tassertEquals(map, actual);\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void missingContentType() throws Exception {\n\t\tString body = \"{\\\"bar\\\":\\\"BARBAR\\\",\\\"foo\\\":\\\"FOOFOO\\\"}\";\n\t\tthis.request.writeWith(Flux.just(dataBuffer(body)));\n\t\tMono<Object> result = this.resolver.resolveArgument(parameter(\"monoTestBean\"), this.model, this.exchange);\n\n\t\tTestSubscriber.subscribe(result)\n\t\t\t\t.assertError(UnsupportedMediaTypeStatusException.class);\n\t}","id":25857,"modified_method":"@Test\n\tpublic void missingContentType() throws Exception {\n\t\tString body = \"{\\\"bar\\\":\\\"BARBAR\\\",\\\"foo\\\":\\\"FOOFOO\\\"}\";\n\t\tthis.request.writeWith(Flux.just(dataBuffer(body)));\n\t\tResolvableType type = forClassWithGenerics(Mono.class, TestBean.class);\n\t\tMethodParameter param = this.testMethod.resolveParam(type);\n\t\tMono<Object> result = this.resolver.resolveArgument(param, new ExtendedModelMap(), this.exchange);\n\n\t\tTestSubscriber.subscribe(result)\n\t\t\t\t.assertError(UnsupportedMediaTypeStatusException.class);\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void supports() throws Exception {\n\t\tRequestBodyArgumentResolver resolver = resolver(new StringDecoder());\n\n\t\tassertTrue(resolver.supportsParameter(parameter(\"monoTestBean\")));\n\t\tassertFalse(resolver.supportsParameter(parameter(\"paramWithoutAnnotation\")));\n\t}","id":25858,"modified_method":"@Test\n\tpublic void supports() throws Exception {\n\t\tRequestBodyArgumentResolver resolver = resolver(new StringDecoder());\n\n\t\tResolvableType type = forClassWithGenerics(Mono.class, TestBean.class);\n\t\tMethodParameter param = this.testMethod.resolveParam(type);\n\t\tassertTrue(resolver.supportsParameter(param));\n\n\t\tMethodParameter parameter = this.testMethod.resolveParam(p -> !p.hasParameterAnnotations());\n\t\tassertFalse(resolver.supportsParameter(parameter));\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void array() throws Exception {\n\t\tString body = \"[{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"},{\\\"bar\\\":\\\"b2\\\",\\\"foo\\\":\\\"f2\\\"}]\";\n\t\tassertArrayEquals(new TestBean[] {new TestBean(\"f1\", \"b1\"), new TestBean(\"f2\", \"b2\")},\n\t\t\t\tresolveValue(\"array\", TestBean[].class, body));\n\t}","id":25859,"modified_method":"@Test\n\tpublic void array() throws Exception {\n\t\tString body = \"[{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"},{\\\"bar\\\":\\\"b2\\\",\\\"foo\\\":\\\"f2\\\"}]\";\n\t\tResolvableType type = forClass(TestBean[].class);\n\t\tMethodParameter param = this.testMethod.resolveParam(type);\n\t\tTestBean[] value = resolveValue(param, TestBean[].class, body);\n\n\t\tassertArrayEquals(new TestBean[] {new TestBean(\"f1\", \"b1\"), new TestBean(\"f2\", \"b2\")}, value);\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public TestBean(String foo, String bar) {\n\t\t\tthis.foo = foo;\n\t\t\tthis.bar = bar;\n\t\t}","id":25860,"modified_method":"TestBean(String foo, String bar) {\n\t\t\tthis.foo = foo;\n\t\t\tthis.bar = bar;\n\t\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tthis.resolver = resolver(new JacksonJsonDecoder());\n\t\tthis.request = new MockServerHttpRequest(HttpMethod.GET, new URI(\"/path\"));\n\t\tMockServerHttpResponse response = new MockServerHttpResponse();\n\t\tDefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\n\t\tthis.exchange = new DefaultServerWebExchange(this.request, response, sessionManager);\n\t\tthis.model = new ExtendedModelMap();\n\t}","id":25861,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tthis.request = new MockServerHttpRequest(HttpMethod.GET, new URI(\"/path\"));\n\t\tMockServerHttpResponse response = new MockServerHttpResponse();\n\t\tthis.exchange = new DefaultServerWebExchange(this.request, response, new MockWebSessionManager());\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test @SuppressWarnings(\"unchecked\")\n\tpublic void observableTestBean() throws Exception {\n\t\tString body = \"[{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"},{\\\"bar\\\":\\\"b2\\\",\\\"foo\\\":\\\"f2\\\"}]\";\n\t\tObservable<?> observable = (Observable<?>) resolveValue(\"observableTestBean\", Observable.class, body);\n\t\tassertEquals(Arrays.asList(new TestBean(\"f1\", \"b1\"), new TestBean(\"f2\", \"b2\")),\n\t\t\t\tobservable.toList().toBlocking().first());\n\t}","id":25862,"modified_method":"@Test @SuppressWarnings(\"unchecked\")\n\tpublic void observableTestBean() throws Exception {\n\t\tString body = \"[{\\\"bar\\\":\\\"b1\\\",\\\"foo\\\":\\\"f1\\\"},{\\\"bar\\\":\\\"b2\\\",\\\"foo\\\":\\\"f2\\\"}]\";\n\t\tResolvableType type = forClassWithGenerics(Observable.class, TestBean.class);\n\t\tMethodParameter param = this.testMethod.resolveParam(type);\n\t\tObservable<?> observable = (Observable<?>) resolveValue(param, Observable.class, body);\n\n\t\tassertEquals(Arrays.asList(new TestBean(\"f1\", \"b1\"), new TestBean(\"f2\", \"b2\")),\n\t\t\t\tobservable.toList().toBlocking().first());\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public Method resolve() {\n\t\t// String comparison (ResolvableType's with different providers)\n\t\tString expectedReturnType = getReturnType();\n\n\t\tSet<Method> methods = MethodIntrospector.selectMethods(this.targetClass,\n\t\t\t\t(ReflectionUtils.MethodFilter) method -> {\n\t\t\t\t\tif (this.methodName != null && !this.methodName.equals(method.getName())) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (getReturnType() != null) {\n\t\t\t\t\t\tString actual = ResolvableType.forMethodReturnType(method).toString();\n\t\t\t\t\t\tif (!actual.equals(getReturnType()) && !Object.class.equals(method.getDeclaringClass())) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!ObjectUtils.isEmpty(this.argumentTypes)) {\n\t\t\t\t\t\tif (!Arrays.areEqual(this.argumentTypes, method.getParameterTypes())) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (Class<? extends Annotation> annotationType : this.annotationTypes) {\n\t\t\t\t\t\tif (AnnotationUtils.findAnnotation(method, annotationType) == null) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\n\t\tAssert.isTrue(!methods.isEmpty(), \"No matching method: \" + this);\n\t\tAssert.isTrue(methods.size() == 1, \"Multiple matching methods: \" + this);\n\n\t\treturn methods.iterator().next();\n\t}","id":25863,"modified_method":"public Method resolve() {\n\t\tSet<Method> methods = MethodIntrospector.selectMethods(this.targetClass,\n\t\t\t\t(ReflectionUtils.MethodFilter) method -> {\n\t\t\t\t\tif (this.methodName != null && !this.methodName.equals(method.getName())) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (getReturnType() != null) {\n\t\t\t\t\t\t// String comparison (ResolvableType's with different providers)\n\t\t\t\t\t\tString actual = ResolvableType.forMethodReturnType(method).toString();\n\t\t\t\t\t\tif (!actual.equals(getReturnType()) && !Object.class.equals(method.getDeclaringClass())) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!ObjectUtils.isEmpty(this.argumentTypes)) {\n\t\t\t\t\t\tif (!Arrays.equals(this.argumentTypes, method.getParameterTypes())) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (Class<? extends Annotation> annotationType : this.annotationTypes) {\n\t\t\t\t\t\tif (AnnotationUtils.findAnnotation(method, annotationType) == null) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\n\t\tAssert.isTrue(!methods.isEmpty(), \"No matching method: \" + this);\n\t\tAssert.isTrue(methods.size() == 1, \"Multiple matching methods: \" + this);\n\n\t\treturn methods.iterator().next();\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void contentNegotiationWith406() throws Exception {\n\t\tTestBean value = new TestBean(\"Joe\");\n\t\tResolvableType type = ResolvableType.forClass(TestBean.class);\n\t\tExtendedModelMap model = new ExtendedModelMap();\n\t\tHandlerResult handlerResult = new HandlerResult(new Object(), value, returnType(type), model);\n\n\t\tthis.request.getHeaders().setAccept(Collections.singletonList(APPLICATION_JSON));\n\t\tthis.request.setUri(new URI(\"/account\"));\n\n\t\tViewResolutionResultHandler resultHandler = createResultHandler(new TestViewResolver(\"account\"));\n\t\tMono<Void> mono = resultHandler.handleResult(this.exchange, handlerResult);\n\t\tTestSubscriber.subscribe(mono).assertError(NotAcceptableStatusException.class);\n\t}","id":25864,"modified_method":"@Test\n\tpublic void contentNegotiationWith406() throws Exception {\n\t\tTestBean value = new TestBean(\"Joe\");\n\t\tResolvableType type = ResolvableType.forClass(TestBean.class);\n\t\tHandlerResult handlerResult = new HandlerResult(new Object(), value, returnType(type), this.model);\n\n\t\tthis.request.getHeaders().setAccept(Collections.singletonList(APPLICATION_JSON));\n\t\tthis.request.setUri(new URI(\"/account\"));\n\n\t\tViewResolutionResultHandler resultHandler = createResultHandler(new TestViewResolver(\"account\"));\n\t\tMono<Void> mono = resultHandler.handleResult(this.exchange, handlerResult);\n\t\tTestSubscriber.subscribe(mono).assertError(NotAcceptableStatusException.class);\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void testSupports(ResolvableMethod resolvableMethod, boolean result) {\n\t\tViewResolutionResultHandler resultHandler = createResultHandler(mock(ViewResolver.class));\n\t\tMethodParameter returnType = resolvableMethod.resolveReturnType();\n\t\tExtendedModelMap model = new ExtendedModelMap();\n\t\tHandlerResult handlerResult = new HandlerResult(new Object(), null, returnType, model);\n\t\tassertEquals(result, resultHandler.supports(handlerResult));\n\t}","id":25865,"modified_method":"private void testSupports(ResolvableMethod resolvableMethod, boolean result) {\n\t\tViewResolutionResultHandler resultHandler = createResultHandler(mock(ViewResolver.class));\n\t\tMethodParameter returnType = resolvableMethod.resolveReturnType();\n\t\tHandlerResult handlerResult = new HandlerResult(new Object(), null, returnType, this.model);\n\t\tassertEquals(result, resultHandler.supports(handlerResult));\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public TestView(String name, MediaType... mediaTypes) {\n\t\t\tthis.name = name;\n\t\t\tthis.mediaTypes = Arrays.asList(mediaTypes);\n\t\t}","id":25866,"modified_method":"TestView(String name, MediaType... mediaTypes) {\n\t\t\tthis.name = name;\n\t\t\tthis.mediaTypes = Arrays.asList(mediaTypes);\n\t\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void testSupports(ResolvableType type, boolean result) {\n\t\ttestSupports(resolvableMethod().returning(type), result);\n\t}","id":25867,"modified_method":"private void testSupports(ResolvableType type, boolean result) {\n\t\ttestSupports(ResolvableMethod.on(TestController.class).returning(type), result);\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void supports() throws Exception {\n\n\t\ttestSupports(ResolvableType.forClass(String.class), true);\n\t\ttestSupports(ResolvableType.forClass(View.class), true);\n\t\ttestSupports(ResolvableType.forClassWithGenerics(Mono.class, String.class), true);\n\t\ttestSupports(ResolvableType.forClassWithGenerics(Mono.class, View.class), true);\n\t\ttestSupports(ResolvableType.forClassWithGenerics(Single.class, String.class), true);\n\t\ttestSupports(ResolvableType.forClassWithGenerics(Single.class, View.class), true);\n\t\ttestSupports(ResolvableType.forClass(Model.class), true);\n\t\ttestSupports(ResolvableType.forClass(Map.class), true);\n\t\ttestSupports(ResolvableType.forClass(TestBean.class), true);\n\t\ttestSupports(ResolvableType.forClass(Integer.class), false);\n\n\t\ttestSupports(resolvableMethod().annotated(ModelAttribute.class), true);\n\t}","id":25868,"modified_method":"@Test\n\tpublic void supports() throws Exception {\n\n\t\ttestSupports(ResolvableType.forClass(String.class), true);\n\t\ttestSupports(ResolvableType.forClass(View.class), true);\n\t\ttestSupports(ResolvableType.forClassWithGenerics(Mono.class, String.class), true);\n\t\ttestSupports(ResolvableType.forClassWithGenerics(Mono.class, View.class), true);\n\t\ttestSupports(ResolvableType.forClassWithGenerics(Single.class, String.class), true);\n\t\ttestSupports(ResolvableType.forClassWithGenerics(Single.class, View.class), true);\n\t\ttestSupports(ResolvableType.forClass(Model.class), true);\n\t\ttestSupports(ResolvableType.forClass(Map.class), true);\n\t\ttestSupports(ResolvableType.forClass(TestBean.class), true);\n\t\ttestSupports(ResolvableType.forClass(Integer.class), false);\n\n\t\ttestSupports(ResolvableMethod.on(TestController.class).annotated(ModelAttribute.class), true);\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void contentNegotiation() throws Exception {\n\t\tTestBean value = new TestBean(\"Joe\");\n\t\tResolvableType type = ResolvableType.forClass(TestBean.class);\n\t\tExtendedModelMap model = new ExtendedModelMap();\n\t\tHandlerResult handlerResult = new HandlerResult(new Object(), value, returnType(type), model);\n\n\t\tthis.request.getHeaders().setAccept(Collections.singletonList(APPLICATION_JSON));\n\t\tthis.request.setUri(new URI(\"/account\"));\n\n\t\tTestView defaultView = new TestView(\"jsonView\", APPLICATION_JSON);\n\n\t\tcreateResultHandler(Collections.singletonList(defaultView), new TestViewResolver(\"account\"))\n\t\t\t\t.handleResult(this.exchange, handlerResult)\n\t\t\t\t.block(Duration.ofSeconds(5));\n\n\t\tassertEquals(APPLICATION_JSON, this.response.getHeaders().getContentType());\n\t\tassertResponseBody(\"jsonView: {testBean=TestBean[name=Joe]}\");\n\t}","id":25869,"modified_method":"@Test\n\tpublic void contentNegotiation() throws Exception {\n\t\tTestBean value = new TestBean(\"Joe\");\n\t\tResolvableType type = ResolvableType.forClass(TestBean.class);\n\t\tHandlerResult handlerResult = new HandlerResult(new Object(), value, returnType(type), this.model);\n\n\t\tthis.request.getHeaders().setAccept(Collections.singletonList(APPLICATION_JSON));\n\t\tthis.request.setUri(new URI(\"/account\"));\n\n\t\tTestView defaultView = new TestView(\"jsonView\", APPLICATION_JSON);\n\n\t\tcreateResultHandler(Collections.singletonList(defaultView), new TestViewResolver(\"account\"))\n\t\t\t\t.handleResult(this.exchange, handlerResult)\n\t\t\t\t.block(Duration.ofSeconds(5));\n\n\t\tassertEquals(APPLICATION_JSON, this.response.getHeaders().getContentType());\n\t\tassertResponseBody(\"jsonView: {testBean=TestBean[name=Joe]}\");\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void testHandle(String path, ResolvableType returnType, Object returnValue,\n\t\t\tString responseBody, ViewResolver... resolvers) throws URISyntaxException {\n\n\t\ttestHandle(path, resolvableMethod().returning(returnType), returnValue, responseBody, resolvers);\n\t}","id":25870,"modified_method":"private void testHandle(String path, ResolvableType returnType, Object returnValue,\n\t\t\tString responseBody, ViewResolver... resolvers) throws URISyntaxException {\n\n\t\ttestHandle(path,  ResolvableMethod.on(TestController.class).returning(returnType),\n\t\t\t\treturnValue, responseBody, resolvers);\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public TestBean(String name) {\n\t\t\tthis.name = name;\n\t\t}","id":25871,"modified_method":"TestBean(String name) {\n\t\t\tthis.name = name;\n\t\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private MethodParameter returnType(ResolvableType type) {\n\t\treturn resolvableMethod().returning(type).resolveReturnType();\n\t}","id":25872,"modified_method":"private MethodParameter returnType(ResolvableType type) {\n\t\treturn ResolvableMethod.on(TestController.class).returning(type).resolveReturnType();\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleReturnValueTypes() throws Exception {\n\t\tObject returnValue;\n\t\tResolvableType returnType;\n\t\tViewResolver resolver = new TestViewResolver(\"account\");\n\n\t\treturnType = ResolvableType.forClass(View.class);\n\t\treturnValue = new TestView(\"account\");\n\t\ttestHandle(\"/path\", returnType, returnValue, \"account: {id=123}\");\n\n\t\treturnType = ResolvableType.forClassWithGenerics(Mono.class, View.class);\n\t\treturnValue = Mono.just(new TestView(\"account\"));\n\t\ttestHandle(\"/path\", returnType, returnValue, \"account: {id=123}\");\n\n\t\treturnType = ResolvableType.forClass(String.class);\n\t\treturnValue = \"account\";\n\t\ttestHandle(\"/path\", returnType, returnValue, \"account: {id=123}\", resolver);\n\n\t\treturnType = ResolvableType.forClassWithGenerics(Mono.class, String.class);\n\t\treturnValue = Mono.just(\"account\");\n\t\ttestHandle(\"/path\", returnType, returnValue, \"account: {id=123}\", resolver);\n\n\t\treturnType = ResolvableType.forClass(Model.class);\n\t\treturnValue = new ExtendedModelMap().addAttribute(\"name\", \"Joe\");\n\t\ttestHandle(\"/account\", returnType, returnValue, \"account: {id=123, name=Joe}\", resolver);\n\n\t\treturnType = ResolvableType.forClass(Map.class);\n\t\treturnValue = Collections.singletonMap(\"name\", \"Joe\");\n\t\ttestHandle(\"/account\", returnType, returnValue, \"account: {id=123, name=Joe}\", resolver);\n\n\t\treturnType = ResolvableType.forClass(TestBean.class);\n\t\treturnValue = new TestBean(\"Joe\");\n\t\tString responseBody = \"account: {id=123, testBean=TestBean[name=Joe]}\";\n\t\ttestHandle(\"/account\", returnType, returnValue, responseBody, resolver);\n\n\t\ttestHandle(\"/account\", resolvableMethod().annotated(ModelAttribute.class),\n\t\t\t\t99L, \"account: {id=123, num=99}\", resolver);\n\t}","id":25873,"modified_method":"@Test\n\tpublic void handleReturnValueTypes() throws Exception {\n\t\tObject returnValue;\n\t\tResolvableType returnType;\n\t\tViewResolver resolver = new TestViewResolver(\"account\");\n\n\t\treturnType = ResolvableType.forClass(View.class);\n\t\treturnValue = new TestView(\"account\");\n\t\ttestHandle(\"/path\", returnType, returnValue, \"account: {id=123}\");\n\n\t\treturnType = ResolvableType.forClassWithGenerics(Mono.class, View.class);\n\t\treturnValue = Mono.just(new TestView(\"account\"));\n\t\ttestHandle(\"/path\", returnType, returnValue, \"account: {id=123}\");\n\n\t\treturnType = ResolvableType.forClass(String.class);\n\t\treturnValue = \"account\";\n\t\ttestHandle(\"/path\", returnType, returnValue, \"account: {id=123}\", resolver);\n\n\t\treturnType = ResolvableType.forClassWithGenerics(Mono.class, String.class);\n\t\treturnValue = Mono.just(\"account\");\n\t\ttestHandle(\"/path\", returnType, returnValue, \"account: {id=123}\", resolver);\n\n\t\treturnType = ResolvableType.forClass(Model.class);\n\t\treturnValue = new ExtendedModelMap().addAttribute(\"name\", \"Joe\");\n\t\ttestHandle(\"/account\", returnType, returnValue, \"account: {id=123, name=Joe}\", resolver);\n\n\t\treturnType = ResolvableType.forClass(Map.class);\n\t\treturnValue = Collections.singletonMap(\"name\", \"Joe\");\n\t\ttestHandle(\"/account\", returnType, returnValue, \"account: {id=123, name=Joe}\", resolver);\n\n\t\treturnType = ResolvableType.forClass(TestBean.class);\n\t\treturnValue = new TestBean(\"Joe\");\n\t\tString responseBody = \"account: {id=123, testBean=TestBean[name=Joe]}\";\n\t\ttestHandle(\"/account\", returnType, returnValue, responseBody, resolver);\n\n\t\ttestHandle(\"/account\", ResolvableMethod.on(TestController.class).annotated(ModelAttribute.class),\n\t\t\t\t99L, \"account: {id=123, num=99}\", resolver);\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void unresolvedViewName() throws Exception {\n\t\tString returnValue = \"account\";\n\t\tResolvableType type = ResolvableType.forClass(String.class);\n\t\tExtendedModelMap model = new ExtendedModelMap();\n\t\tHandlerResult handlerResult = new HandlerResult(new Object(), returnValue, returnType(type), model);\n\n\t\tthis.request.setUri(new URI(\"/path\"));\n\t\tMono<Void> mono = createResultHandler().handleResult(this.exchange, handlerResult);\n\n\t\tTestSubscriber.subscribe(mono).assertErrorMessage(\"Could not resolve view with name 'account'.\");\n\t}","id":25874,"modified_method":"@Test\n\tpublic void unresolvedViewName() throws Exception {\n\t\tString returnValue = \"account\";\n\t\tResolvableType type = ResolvableType.forClass(String.class);\n\t\tHandlerResult handlerResult = new HandlerResult(new Object(), returnValue, returnType(type), this.model);\n\n\t\tthis.request.setUri(new URI(\"/path\"));\n\t\tMono<Void> mono = createResultHandler().handleResult(this.exchange, handlerResult);\n\n\t\tTestSubscriber.subscribe(mono).assertErrorMessage(\"Could not resolve view with name 'account'.\");\n\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public TestViewResolver(String... viewNames) {\n\t\t\tArrays.stream(viewNames).forEach(name -> this.views.put(name, new TestView(name)));\n\t\t}","id":25875,"modified_method":"TestViewResolver(String... viewNames) {\n\t\t\tArrays.stream(viewNames).forEach(name -> this.views.put(name, new TestView(name)));\n\t\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void setOrder(int order) {\n\t\t\tthis.order = order;\n\t\t}","id":25876,"modified_method":"void setOrder(int order) {\n\t\t\tthis.order = order;\n\t\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public TestView(String name) {\n\t\t\tthis.name = name;\n\t\t\tthis.mediaTypes = Collections.singletonList(MediaType.TEXT_HTML);\n\t\t}","id":25877,"modified_method":"TestView(String name) {\n\t\t\tthis.name = name;\n\t\t\tthis.mediaTypes = Collections.singletonList(MediaType.TEXT_HTML);\n\t\t}","commit_id":"9ee4f6ee305b82b68b61576bfd60bbc178657917","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n     * Creates the message tag.\n     *\n     * @param messageID the identifier of the message\n     * @param contactName the name of the sender\n     * @param message the message content\n     * @param contentType the content type (html or plain text)\n     * @param date the date on which the message was sent\n     * @param isEdited indicates if the given message has been edited\n     * @param isHistory indicates if this is a message coming from history\n     * @return the newly constructed message tag\n     */\n    private static String createSimpleMessageTag(String messageID,\n                                                String contactName,\n                                                String message,\n                                                String contentType,\n                                                Date date,\n                                                boolean isEdited,\n                                                boolean isHistory)\n    {\n        StringBuilder messageTag = new StringBuilder();\n\n        SimpleDateFormat sdf = new SimpleDateFormat(HistoryService.DATE_FORMAT);\n        messageTag.append(String.format(\"<div id='%s' %s = '%s' \",\n                MESSAGE_TEXT_ID + messageID, NAME_ATTRIBUTE,\n                contactName));\n        messageTag.append(DATE_ATTRIBUTE + \"=\\\"\" + sdf.format(date) + \"\\\" \");\n        messageTag.append(String.format(\"%s = '%s' \",\n                ORIGINAL_MESSAGE_ATTRIBUTE, GuiUtils.escapeHTMLChars(message)));\n        messageTag.append(IncomingMessageStyle\n            .createSingleMessageStyle(isHistory, isEdited, true));\n        messageTag.append(\">\");\n        messageTag.append(createStartPlainTextTag(contentType));\n        messageTag.append(message);\n        if (isEdited)\n            messageTag.append(\"    \");\n        messageTag.append(createEndPlainTextTag(contentType));\n        if (isEdited)\n            messageTag.append(createEditedAt(date));\n        messageTag.append(\"<\/div>\");\n\n        return messageTag.toString();\n    }","id":25878,"modified_method":"/**\n     * Creates the message tag.\n     *\n     * @param messageID the identifier of the message\n     * @param contactName the name of the sender\n     * @param message the message content\n     * @param contentType the content type (html or plain text)\n     * @param date the date on which the message was sent\n     * @param isEdited indicates if the given message has been edited\n     * @param isHistory indicates if this is a message coming from history\n     * @return the newly constructed message tag\n     */\n    private static String createSimpleMessageTag(String messageID,\n                                                String contactName,\n                                                String message,\n                                                String contentType,\n                                                Date date,\n                                                boolean isEdited,\n                                                boolean isHistory)\n    {\n        StringBuilder messageTag = new StringBuilder();\n\n        SimpleDateFormat sdf = new SimpleDateFormat(HistoryService.DATE_FORMAT);\n        messageTag.append(String.format(\"<div id='%s' %s = '%s' \",\n                MESSAGE_TEXT_ID + messageID, NAME_ATTRIBUTE,\n                contactName));\n        messageTag.append(DATE_ATTRIBUTE).append(\"=\\\"\")\n            .append(sdf.format(date)).append(\"\\\" \");\n        messageTag.append(String.format(\"%s = '%s' \",\n                ORIGINAL_MESSAGE_ATTRIBUTE, GuiUtils.escapeHTMLChars(message)));\n        messageTag.append(IncomingMessageStyle\n            .createSingleMessageStyle(isHistory, isEdited, true));\n        messageTag.append(\">\");\n        messageTag.append(createStartPlainTextTag(contentType));\n        messageTag.append(message);\n        if (isEdited)\n            messageTag.append(\"    \");\n        messageTag.append(createEndPlainTextTag(contentType));\n        if (isEdited)\n            messageTag.append(createEditedAt(date));\n        messageTag.append(\"<\/div>\");\n\n        return messageTag.toString();\n    }","commit_id":"81c8c4ee18b9b036d95647e058255dddb6256c82","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Create an outgoing message tag.\n     *\n     * @param messageID the identifier of the message\n     * @param contactName the name of the account sending the message\n     * @param contactDisplayName the display name of the account sending the\n     * message\n     * @param avatarPath the path to the avatar image\n     * @param date the date, when the message was sent\n     * @param message the content of the message\n     * @param contentType the content type HTML or PLAIN_TEXT\n     * @param isHistory indicates if this is a message coming from history\n     * @return the created outgoing message tag\n     */\n    private static String createSimpleOutgoingMessageTag( String messageID,\n                                                    String contactName,\n                                                    String contactDisplayName,\n                                                    String avatarPath,\n                                                    Date date,\n                                                    String message,\n                                                    String contentType,\n                                                    boolean isHistory)\n    {\n        StringBuffer headerBuffer = new StringBuffer();\n\n\n        SimpleDateFormat sdf = new SimpleDateFormat(HistoryService.DATE_FORMAT);\n        headerBuffer.append(\"<h3 id=\\\"\" + MESSAGE_HEADER_ID + \"\\\" \");\n        headerBuffer.append(DATE_ATTRIBUTE + \"='\"\n            + sdf.format(date) + \"'\" + \">\");\n        headerBuffer.append(\"<a style=\\\"color:#535353;\");\n        headerBuffer.append(\"font-weight:bold;\");\n        headerBuffer.append(\"text-decoration:none;\\\" \");\n        headerBuffer.append(\"href=\\\"\" + contactName + \"\\\">\");\n        headerBuffer.append(contactDisplayName\n                + createEditedAtTag(messageID, -1));\n        headerBuffer.append(\"<\/a>\");\n        headerBuffer.append(\"<\/h3>\");\n\n        StringBuffer messageBuff = new StringBuffer();\n\n        messageBuff.append(\"<table width=\\\"100%\\\" \");\n        messageBuff.append(NAME_ATTRIBUTE + \"=\\\"\"\n                            +  Tag.TABLE.toString()\n                            + \"\\\" id=\\\"messageHeader\\\"\");\n        messageBuff.append(\"style=\\\"background-color:\");\n        messageBuff.append(MSG_NAME_BACKGROUND).append(\";\\\">\");\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td align=\\\"left\\\" >\");\n        messageBuff.append(headerBuffer.toString());\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<td align=\\\"right\\\"><h3>\");\n        messageBuff.append(getDateString(date) + GuiUtils.formatTime(date));\n        messageBuff.append(\"<\/h3><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n        messageBuff.append(\"<\/table>\");\n        messageBuff.append(\n            createSimpleMessageTag( messageID,\n                                    contactName,\n                                    message,\n                                    contentType,\n                                    date,\n                                    false,\n                                    isHistory));\n\n        return messageBuff.toString();\n    }","id":25879,"modified_method":"/**\n     * Create an outgoing message tag.\n     *\n     * @param messageID the identifier of the message\n     * @param contactName the name of the account sending the message\n     * @param contactDisplayName the display name of the account sending the\n     * message\n     * @param avatarPath the path to the avatar image\n     * @param date the date, when the message was sent\n     * @param message the content of the message\n     * @param contentType the content type HTML or PLAIN_TEXT\n     * @param isHistory indicates if this is a message coming from history\n     * @return the created outgoing message tag\n     */\n    private static String createSimpleOutgoingMessageTag( String messageID,\n                                                    String contactName,\n                                                    String contactDisplayName,\n                                                    String avatarPath,\n                                                    Date date,\n                                                    String message,\n                                                    String contentType,\n                                                    boolean isHistory)\n    {\n        StringBuilder headerBuffer = new StringBuilder();\n\n\n        SimpleDateFormat sdf = new SimpleDateFormat(HistoryService.DATE_FORMAT);\n        headerBuffer.append(\"<h3 id=\\\"\").append(MESSAGE_HEADER_ID).append(\"\\\" \");\n        headerBuffer.append(DATE_ATTRIBUTE).append(\"='\")\n            .append(sdf.format(date)).append(\"'>\");\n        headerBuffer.append(\"<a style=\\\"color:#535353;\");\n        headerBuffer.append(\"font-weight:bold;\");\n        headerBuffer.append(\"text-decoration:none;\\\" \");\n        headerBuffer.append(\"href=\\\"\").append(contactName).append(\"\\\">\");\n        headerBuffer.append(contactDisplayName)\n            .append(createEditedAtTag(messageID, -1));\n        headerBuffer.append(\"<\/a>\");\n        headerBuffer.append(\"<\/h3>\");\n\n        StringBuffer messageBuff = new StringBuffer();\n\n        messageBuff.append(\"<table width=\\\"100%\\\" \");\n        messageBuff.append(NAME_ATTRIBUTE).append(\"=\\\"\")\n            .append(Tag.TABLE.toString())\n            .append(\"\\\" id=\\\"messageHeader\\\"\");\n        messageBuff.append(\"style=\\\"background-color:\");\n        messageBuff.append(MSG_NAME_BACKGROUND).append(\";\\\">\");\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td align=\\\"left\\\" >\");\n        messageBuff.append(headerBuffer.toString());\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<td align=\\\"right\\\"><h3>\");\n        messageBuff.append(getDateString(date))\n            .append(GuiUtils.formatTime(date));\n        messageBuff.append(\"<\/h3><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n        messageBuff.append(\"<\/table>\");\n        messageBuff.append(\n            createSimpleMessageTag( messageID,\n                                    contactName,\n                                    message,\n                                    contentType,\n                                    date,\n                                    false,\n                                    isHistory));\n\n        return messageBuff.toString();\n    }","commit_id":"81c8c4ee18b9b036d95647e058255dddb6256c82","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an incoming message tag.\n     *\n     * @param messageID the identifier\n     * @param contactName the name of the contact sending the message\n     * @param contactDisplayName the display name of the contact sending the\n     * message\n     * @param avatarPath the path to the avatar file\n     * @param date the date, when the message was sent\n     * @param message the message content\n     * @param contentType the content type HTML or PLAIN_TEXT\n     * @param isHistory indicates if this is a message coming from history\n     * @return the created incoming message tag\n     */\n    private static String createAdvancedIncomingMessageTag(\n        String messageID,\n        String contactName,\n        String contactDisplayName,\n        String avatarPath,\n        Date date,\n        String message,\n        String contentType,\n        boolean isHistory)\n    {\n        StringBuffer headerBuffer = new StringBuffer();\n\n        SimpleDateFormat sdf = new SimpleDateFormat(HistoryService.DATE_FORMAT);\n        headerBuffer.append(\"<h2 id=\\\"\" + MESSAGE_HEADER_ID + \"\\\" \");\n        headerBuffer.append(DATE_ATTRIBUTE + \"='\" + sdf.format(date) + \"' \");\n        headerBuffer.append(IncomingMessageStyle.createHeaderStyle() + \">\");\n        headerBuffer.append(\"<a style=\\\"color:\");\n        headerBuffer.append(MSG_IN_NAME_FOREGROUND).append(\";\");\n        headerBuffer.append(\"font-weight:bold;\");\n        headerBuffer.append(\"text-decoration:none;\\\" \");\n        headerBuffer.append(\"href=\\\"\" + contactName + \"\\\">\");\n        headerBuffer.append(\n            contactDisplayName + createEditedAtTag(messageID, -1));\n        headerBuffer.append(\"<\/a><\/h2>\");\n\n        StringBuffer messageBuff = new StringBuffer();\n\n        messageBuff.append(\"<table width=\\\"100%\\\" \");\n        messageBuff.append(NAME_ATTRIBUTE + \"=\\\"\"\n            +  Tag.TABLE.toString() + \"\\\" id=\\\"messageHeader\\\">\");\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td valign=\\\"top\\\">\");\n        messageBuff.append(\n            \"<table \" + IncomingMessageStyle.createTableBubbleStyle()\n            + \" cellspacing=\\\"0px\\\" cellpadding=\\\"0px\\\">\");\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td style=\\\"width:26px;\\\"><\/td>\");\n        messageBuff.append(\"<td style=\\\"width:9px;\\\"><\/td>\");\n        messageBuff.append(\"<td \"\n            + IncomingMessageStyle.createTableBubbleTlStyle() + \">\");\n        messageBuff.append(\n            createAdvancedMessageHeaderTag(headerBuffer.toString(), date));\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<td \"\n            + IncomingMessageStyle.createTableBubbleTrStyle() + \"><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n\n        // Third row.\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td><img src=\\\"\" + avatarPath\n            + \"\\\" width=\\\"26px\\\" height=\\\"26px\\\"/> <\/td>\");\n        messageBuff.append(\"<td \"\n            + IncomingMessageStyle.createIndicatorStyle() +\"><\/td>\");\n        messageBuff.append(\"<td \"\n            + IncomingMessageStyle.createTableBubbleMessageStyle() + \">\");\n\n        messageBuff.append(\n            createAdvancedMessageTag(   messageID,\n                                        contactName,\n                                        message,\n                                        contentType,\n                                        date,\n                                        false,\n                                        isHistory));\n\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<td \"\n            + IncomingMessageStyle.createTableBubbleMessageRightStyle()\n            + \"><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n\n        //Forth row.\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td style=\\\"width:26px;\\\"><\/td>\");\n        messageBuff.append(\"<td style=\\\"width:9px;\\\"><\/td>\");\n        messageBuff.append(\"<td \"\n            + IncomingMessageStyle.createTableBubbleBlStyle() + \"><\/td>\");\n        messageBuff.append(\"<td \"\n            + IncomingMessageStyle.createTableBubbleBrStyle() + \"><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n\n        messageBuff.append(\"<\/table>\");\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<\/tr>\");\n        messageBuff.append(\"<\/table>\");\n\n        return messageBuff.toString();\n    }","id":25880,"modified_method":"/**\n     * Creates an incoming message tag.\n     *\n     * @param messageID the identifier\n     * @param contactName the name of the contact sending the message\n     * @param contactDisplayName the display name of the contact sending the\n     * message\n     * @param avatarPath the path to the avatar file\n     * @param date the date, when the message was sent\n     * @param message the message content\n     * @param contentType the content type HTML or PLAIN_TEXT\n     * @param isHistory indicates if this is a message coming from history\n     * @return the created incoming message tag\n     */\n    private static String createAdvancedIncomingMessageTag(\n        String messageID,\n        String contactName,\n        String contactDisplayName,\n        String avatarPath,\n        Date date,\n        String message,\n        String contentType,\n        boolean isHistory)\n    {\n        StringBuilder headerBuffer = new StringBuilder();\n\n        SimpleDateFormat sdf = new SimpleDateFormat(HistoryService.DATE_FORMAT);\n        headerBuffer.append(\"<h2 id=\\\"\").append(MESSAGE_HEADER_ID).append(\"\\\" \");\n        headerBuffer.append(DATE_ATTRIBUTE).append(\"='\")\n            .append(sdf.format(date)).append(\"' \");\n        headerBuffer.append(IncomingMessageStyle.createHeaderStyle())\n            .append(\">\");\n        headerBuffer.append(\"<a style=\\\"color:\");\n        headerBuffer.append(MSG_IN_NAME_FOREGROUND).append(\";\");\n        headerBuffer.append(\"font-weight:bold;\");\n        headerBuffer.append(\"text-decoration:none;\\\" \");\n        headerBuffer.append(\"href=\\\"\").append(contactName).append(\"\\\">\");\n        headerBuffer.append(\n            contactDisplayName).append(createEditedAtTag(messageID, -1));\n        headerBuffer.append(\"<\/a><\/h2>\");\n\n        StringBuffer messageBuff = new StringBuffer();\n\n        messageBuff.append(\"<table width=\\\"100%\\\" \");\n        messageBuff.append(NAME_ATTRIBUTE).append(\"=\\\"\")\n            .append(Tag.TABLE.toString()).append(\"\\\" id=\\\"messageHeader\\\">\");\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td valign=\\\"top\\\">\");\n        messageBuff.append(\n            \"<table \").append(IncomingMessageStyle.createTableBubbleStyle())\n            .append(\" cellspacing=\\\"0px\\\" cellpadding=\\\"0px\\\">\");\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td style=\\\"width:26px;\\\"><\/td>\");\n        messageBuff.append(\"<td style=\\\"width:9px;\\\"><\/td>\");\n        messageBuff.append(\"<td \").append(\n            IncomingMessageStyle.createTableBubbleTlStyle()).append(\">\");\n        messageBuff.append(\n            createAdvancedMessageHeaderTag(headerBuffer.toString(), date));\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<td \").append(\n            IncomingMessageStyle.createTableBubbleTrStyle()).append(\"><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n\n        // Third row.\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td><img src=\\\"\").append(avatarPath).append(\n            \"\\\" width=\\\"26px\\\" height=\\\"26px\\\"/> <\/td>\");\n        messageBuff.append(\"<td \").append(\n            IncomingMessageStyle.createIndicatorStyle()).append(\"><\/td>\");\n        messageBuff.append(\"<td \").append(\n            IncomingMessageStyle.createTableBubbleMessageStyle()).append(\">\");\n\n        messageBuff.append(\n            createAdvancedMessageTag(   messageID,\n                                        contactName,\n                                        message,\n                                        contentType,\n                                        date,\n                                        false,\n                                        isHistory));\n\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<td \").append(\n            IncomingMessageStyle.createTableBubbleMessageRightStyle()).append(\n            \"><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n\n        //Forth row.\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td style=\\\"width:26px;\\\"><\/td>\");\n        messageBuff.append(\"<td style=\\\"width:9px;\\\"><\/td>\");\n        messageBuff.append(\"<td \").append(\n            IncomingMessageStyle.createTableBubbleBlStyle()).append(\"><\/td>\");\n        messageBuff.append(\"<td \").append(\n            IncomingMessageStyle.createTableBubbleBrStyle()).append(\"><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n\n        messageBuff.append(\"<\/table>\");\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<\/tr>\");\n        messageBuff.append(\"<\/table>\");\n\n        return messageBuff.toString();\n    }","commit_id":"81c8c4ee18b9b036d95647e058255dddb6256c82","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates a message table tag, representing the message header.\n     *\n     * @param nameHeader the name of the header.\n     * @param date the date, when the message was sent or received\n     * @return the message header tag\n     */\n    private static String createAdvancedMessageHeaderTag(String nameHeader,\n                                                        Date date)\n    {\n        StringBuffer messageHeader = new StringBuffer();\n\n        messageHeader.append(\"<table width=\\\"100%\\\">\");\n        messageHeader.append(\"<tr>\");\n        messageHeader.append(\"<td nowrap=\\\"nowrap\\\">\");\n        messageHeader.append(nameHeader);\n        messageHeader.append(\"<\/td>\");\n        messageHeader.append(\"<td nowrap=\\\"nowrap\\\" \"\n                + OutgoingMessageStyle.createDateStyle() + \">\");\n        messageHeader.append(getDateString(date));\n        messageHeader.append(GuiUtils.formatTime(date));\n        messageHeader.append(\"<\/td>\");\n        messageHeader.append(\"<\/tr>\");\n        messageHeader.append(\"<\/table>\");\n\n        return messageHeader.toString();\n    }","id":25881,"modified_method":"/**\n     * Creates a message table tag, representing the message header.\n     *\n     * @param nameHeader the name of the header.\n     * @param date the date, when the message was sent or received\n     * @return the message header tag\n     */\n    private static String createAdvancedMessageHeaderTag(String nameHeader,\n                                                        Date date)\n    {\n        StringBuilder messageHeader = new StringBuilder();\n\n        messageHeader.append(\"<table width=\\\"100%\\\">\");\n        messageHeader.append(\"<tr>\");\n        messageHeader.append(\"<td nowrap=\\\"nowrap\\\">\");\n        messageHeader.append(nameHeader);\n        messageHeader.append(\"<\/td>\");\n        messageHeader.append(\"<td nowrap=\\\"nowrap\\\" \").append(\n                OutgoingMessageStyle.createDateStyle()).append(\">\");\n        messageHeader.append(getDateString(date));\n        messageHeader.append(GuiUtils.formatTime(date));\n        messageHeader.append(\"<\/td>\");\n        messageHeader.append(\"<\/tr>\");\n        messageHeader.append(\"<\/table>\");\n\n        return messageHeader.toString();\n    }","commit_id":"81c8c4ee18b9b036d95647e058255dddb6256c82","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates the message tag.\n     *\n     * @param messageID the identifier of the message\n     * @param contactName the name of the sender\n     * @param message the message content\n     * @param contentType the content type (html or plain text)\n     * @param date the date on which the message was sent\n     * @param isEdited indicates if the given message has been edited\n     * @param isHistory indicates if this is a message coming from history\n     * @return the newly constructed message tag\n     */\n    private static String createAdvancedMessageTag( String messageID,\n                                                    String contactName,\n                                                    String message,\n                                                    String contentType,\n                                                    Date date,\n                                                    boolean isEdited,\n                                                    boolean isHistory)\n    {\n        StringBuilder messageTag = new StringBuilder();\n\n        SimpleDateFormat sdf = new SimpleDateFormat(HistoryService.DATE_FORMAT);\n        messageTag.append(String.format(\"<div id='%s' %s = '%s' \",\n                MESSAGE_TEXT_ID + messageID, NAME_ATTRIBUTE,\n                contactName));\n        messageTag.append(DATE_ATTRIBUTE + \"=\\\"\" + sdf.format(date) + \"\\\" \");\n        messageTag.append(String.format(\"%s = '%s' \",\n                ORIGINAL_MESSAGE_ATTRIBUTE, GuiUtils.escapeHTMLChars(message)));\n        messageTag.append(IncomingMessageStyle\n            .createSingleMessageStyle(isHistory, isEdited, false));\n        messageTag.append(\">\");\n        messageTag.append(createStartPlainTextTag(contentType));\n        messageTag.append(message);\n        if (isEdited)\n            messageTag.append(\"    \");\n        messageTag.append(createEndPlainTextTag(contentType));\n        if (isEdited)\n            messageTag.append(createEditedAt(date));\n        messageTag.append(\"<\/div>\");\n\n        return messageTag.toString();\n    }","id":25882,"modified_method":"/**\n     * Creates the message tag.\n     *\n     * @param messageID the identifier of the message\n     * @param contactName the name of the sender\n     * @param message the message content\n     * @param contentType the content type (html or plain text)\n     * @param date the date on which the message was sent\n     * @param isEdited indicates if the given message has been edited\n     * @param isHistory indicates if this is a message coming from history\n     * @return the newly constructed message tag\n     */\n    private static String createAdvancedMessageTag( String messageID,\n                                                    String contactName,\n                                                    String message,\n                                                    String contentType,\n                                                    Date date,\n                                                    boolean isEdited,\n                                                    boolean isHistory)\n    {\n        StringBuilder messageTag = new StringBuilder();\n\n        SimpleDateFormat sdf = new SimpleDateFormat(HistoryService.DATE_FORMAT);\n        messageTag.append(String.format(\"<div id='%s' %s = '%s' \",\n                MESSAGE_TEXT_ID + messageID, NAME_ATTRIBUTE,\n                contactName));\n        messageTag.append(DATE_ATTRIBUTE).append(\"=\\\"\")\n            .append(sdf.format(date)).append(\"\\\" \");\n        messageTag.append(String.format(\"%s = '%s' \",\n                ORIGINAL_MESSAGE_ATTRIBUTE, GuiUtils.escapeHTMLChars(message)));\n        messageTag.append(IncomingMessageStyle\n            .createSingleMessageStyle(isHistory, isEdited, false));\n        messageTag.append(\">\");\n        messageTag.append(createStartPlainTextTag(contentType));\n        messageTag.append(message);\n        if (isEdited)\n            messageTag.append(\"    \");\n        messageTag.append(createEndPlainTextTag(contentType));\n        if (isEdited)\n            messageTag.append(createEditedAt(date));\n        messageTag.append(\"<\/div>\");\n\n        return messageTag.toString();\n    }","commit_id":"81c8c4ee18b9b036d95647e058255dddb6256c82","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Create an outgoing message tag.\n     *\n     * @param messageID the identifier of the message\n     * @param contactName the name of the account sending the message\n     * @param contactDisplayName the display name of the account sending the\n     * message\n     * @param avatarPath the path to the avatar image\n     * @param date the date, when the message was sent\n     * @param message the content of the message\n     * @param contentType the content type HTML or PLAIN_TEXT\n     * @param isHistory indicates if this is a message coming from history\n     * @return the created outgoing message tag\n     */\n    private static String createAdvancedOutgoingMessageTag( String messageID,\n                                                    String contactName,\n                                                    String contactDisplayName,\n                                                    String avatarPath,\n                                                    Date date,\n                                                    String message,\n                                                    String contentType,\n                                                    boolean isHistory)\n    {\n        StringBuffer headerBuffer = new StringBuffer();\n\n        SimpleDateFormat sdf = new SimpleDateFormat(HistoryService.DATE_FORMAT);\n        headerBuffer.append(\"<h3 id=\\\"\" + MESSAGE_HEADER_ID + \"\\\" \");\n        headerBuffer.append(DATE_ATTRIBUTE + \"='\" + sdf.format(date) + \"' \");\n        headerBuffer.append(IncomingMessageStyle.createHeaderStyle() + \">\");\n        headerBuffer.append(\"<a style=\\\"color:#6a6868;\");\n        headerBuffer.append(\"font-weight:bold;\");\n        headerBuffer.append(\"float:left;\");\n        headerBuffer.append(\"text-decoration:none;\\\" \");\n        headerBuffer.append(\"href=\\\"\" + contactName + \"\\\">\");\n        headerBuffer.append(contactDisplayName\n                + createEditedAtTag(messageID, -1));\n        headerBuffer.append(\"<\/a><\/h3>\");\n\n        StringBuffer messageBuff = new StringBuffer();\n\n        // Construct the message.\n        messageBuff.append(\"<table width=\\\"100%\\\" \");\n        messageBuff.append(NAME_ATTRIBUTE + \"=\\\"\"\n                            +  Tag.TABLE.toString()\n                            + \"\\\" id=\\\"messageHeader\\\">\");\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td valign=\\\"top\\\">\");\n        messageBuff.append(\n            \"<table \" + OutgoingMessageStyle.createTableBubbleStyle()\n            + \" cellspacing=\\\"0px\\\" cellpadding=\\\"0px\\\">\");\n\n        // First row.\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td \"\n            + OutgoingMessageStyle.createTableBubbleTlStyle() + \">\");\n        messageBuff.append(\n            createAdvancedMessageHeaderTag(headerBuffer.toString(), date));\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<td \"\n            + OutgoingMessageStyle.createTableBubbleTrStyle() + \"><\/td>\");\n        messageBuff.append(\"<td style=\\\"width:9px;\\\"><\/td>\");\n        messageBuff.append(\"<td style=\\\"width:26px;\\\"><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n\n        // Third row.\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td \"\n            + OutgoingMessageStyle.createTableBubbleMessageStyle() + \">\");\n\n        messageBuff.append(\n            createAdvancedMessageTag(   messageID,\n                                        contactName,\n                                        message,\n                                        contentType,\n                                        date,\n                                        false,\n                                        isHistory));\n\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<td \"\n            + OutgoingMessageStyle.createTableBubbleMessageRightStyle()\n            + \"><\/td>\");\n        messageBuff.append(\"<td \"\n            + OutgoingMessageStyle.createIndicatorStyle() +\"><\/td>\");\n        messageBuff.append(\"<td><div width=\\\"26px\\\" height=\\\"26px\\\"><img src=\\\"\"\n                + avatarPath\n                + \"\\\" width=\\\"26px\\\" height=\\\"26px\\\"/><\/div><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n\n        // Forth row.\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td \"\n            + OutgoingMessageStyle.createTableBubbleBlStyle() + \"><\/td>\");\n        messageBuff.append(\"<td \"\n            + OutgoingMessageStyle.createTableBubbleBrStyle() + \"><\/td>\");\n        messageBuff.append(\"<td style=\\\"width:9px;\\\"><\/td>\");\n        messageBuff.append(\"<td style=\\\"width:26px;\\\"><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n        messageBuff.append(\"<\/table>\");\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<\/tr>\");\n        messageBuff.append(\"<\/table>\");\n\n        return messageBuff.toString();\n    }","id":25883,"modified_method":"/**\n     * Create an outgoing message tag.\n     *\n     * @param messageID the identifier of the message\n     * @param contactName the name of the account sending the message\n     * @param contactDisplayName the display name of the account sending the\n     * message\n     * @param avatarPath the path to the avatar image\n     * @param date the date, when the message was sent\n     * @param message the content of the message\n     * @param contentType the content type HTML or PLAIN_TEXT\n     * @param isHistory indicates if this is a message coming from history\n     * @return the created outgoing message tag\n     */\n    private static String createAdvancedOutgoingMessageTag( String messageID,\n                                                    String contactName,\n                                                    String contactDisplayName,\n                                                    String avatarPath,\n                                                    Date date,\n                                                    String message,\n                                                    String contentType,\n                                                    boolean isHistory)\n    {\n        StringBuilder headerBuffer = new StringBuilder();\n\n        SimpleDateFormat sdf = new SimpleDateFormat(HistoryService.DATE_FORMAT);\n        headerBuffer.append(\"<h3 id=\\\"\").append(MESSAGE_HEADER_ID).append(\"\\\" \");\n        headerBuffer.append(DATE_ATTRIBUTE).append(\"='\")\n            .append(sdf.format(date)).append(\"' \");\n        headerBuffer.append(IncomingMessageStyle.createHeaderStyle())\n            .append(\">\");\n        headerBuffer.append(\"<a style=\\\"color:#6a6868;\");\n        headerBuffer.append(\"font-weight:bold;\");\n        headerBuffer.append(\"float:left;\");\n        headerBuffer.append(\"text-decoration:none;\\\" \");\n        headerBuffer.append(\"href=\\\"\").append(contactName).append(\"\\\">\");\n        headerBuffer.append(contactDisplayName).append(\n                createEditedAtTag(messageID, -1));\n        headerBuffer.append(\"<\/a><\/h3>\");\n\n        StringBuffer messageBuff = new StringBuffer();\n\n        // Construct the message.\n        messageBuff.append(\"<table width=\\\"100%\\\" \");\n        messageBuff.append(NAME_ATTRIBUTE).append(\"=\\\"\").append(\n                            Tag.TABLE.toString()).append(\n                            \"\\\" id=\\\"messageHeader\\\">\");\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td valign=\\\"top\\\">\");\n        messageBuff.append(\n            \"<table \").append(OutgoingMessageStyle.createTableBubbleStyle())\n            .append(\" cellspacing=\\\"0px\\\" cellpadding=\\\"0px\\\">\");\n\n        // First row.\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td \").append(\n            OutgoingMessageStyle.createTableBubbleTlStyle()).append(\">\");\n        messageBuff.append(\n            createAdvancedMessageHeaderTag(headerBuffer.toString(), date));\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<td \").append(\n            OutgoingMessageStyle.createTableBubbleTrStyle()).append(\"><\/td>\");\n        messageBuff.append(\"<td style=\\\"width:9px;\\\"><\/td>\");\n        messageBuff.append(\"<td style=\\\"width:26px;\\\"><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n\n        // Third row.\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td \").append(\n            OutgoingMessageStyle.createTableBubbleMessageStyle()).append(\">\");\n\n        messageBuff.append(\n            createAdvancedMessageTag(   messageID,\n                                        contactName,\n                                        message,\n                                        contentType,\n                                        date,\n                                        false,\n                                        isHistory));\n\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<td \").append(\n            OutgoingMessageStyle.createTableBubbleMessageRightStyle()).append(\n            \"><\/td>\");\n        messageBuff.append(\"<td \").append(\n            OutgoingMessageStyle.createIndicatorStyle()).append(\"><\/td>\");\n        messageBuff.append(\"<td><div width=\\\"26px\\\" height=\\\"26px\\\"><img src=\\\"\")\n            .append(avatarPath)\n            .append(\"\\\" width=\\\"26px\\\" height=\\\"26px\\\"/><\/div><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n\n        // Forth row.\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td \").append(\n            OutgoingMessageStyle.createTableBubbleBlStyle()).append(\"><\/td>\");\n        messageBuff.append(\"<td \").append(\n            OutgoingMessageStyle.createTableBubbleBrStyle()).append(\"><\/td>\");\n        messageBuff.append(\"<td style=\\\"width:9px;\\\"><\/td>\");\n        messageBuff.append(\"<td style=\\\"width:26px;\\\"><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n        messageBuff.append(\"<\/table>\");\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<\/tr>\");\n        messageBuff.append(\"<\/table>\");\n\n        return messageBuff.toString();\n    }","commit_id":"81c8c4ee18b9b036d95647e058255dddb6256c82","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an incoming message tag.\n     *\n     * @param messageID the identifier\n     * @param contactName the name of the contact sending the message\n     * @param contactDisplayName the display name of the contact sending the\n     * message\n     * @param avatarPath the path to the avatar file\n     * @param date the date, when the message was sent\n     * @param message the message content\n     * @param contentType the content type HTML or PLAIN_TEXT\n     * @param isHistory indicates if this is a message coming from history\n     * @return the created incoming message tag\n     */\n    private static String createSimpleIncomingMessageTag(\n        String messageID,\n        String contactName,\n        String contactDisplayName,\n        String avatarPath,\n        Date date,\n        String message,\n        String contentType,\n        boolean isHistory)\n    {\n        StringBuffer headerBuffer = new StringBuffer();\n\n\n        SimpleDateFormat sdf = new SimpleDateFormat(HistoryService.DATE_FORMAT);\n        headerBuffer.append(\"<h2 id=\\\"\" + MESSAGE_HEADER_ID + \"\\\" \");\n        headerBuffer.append(DATE_ATTRIBUTE + \"='\"\n            + sdf.format(date) + \"'\" + \">\");\n        headerBuffer.append(\"<a style=\\\"color:\");\n        headerBuffer.append(MSG_IN_NAME_FOREGROUND).append(\";\");\n        headerBuffer.append(\"font-weight:bold;\");\n        headerBuffer.append(\"text-decoration:none;\\\" \");\n        headerBuffer.append(\"href=\\\"\" + contactName + \"\\\">\");\n        headerBuffer.append(\n            contactDisplayName + createEditedAtTag(messageID, -1));\n        headerBuffer.append(\"<\/a>\");\n        headerBuffer.append(\"<\/h2>\");\n\n        StringBuffer messageBuff = new StringBuffer();\n\n        messageBuff.append(\"<table width=\\\"100%\\\" \");\n        messageBuff.append(NAME_ATTRIBUTE + \"=\\\"\"\n                            +  Tag.TABLE.toString()\n                            + \"\\\" id=\\\"messageHeader\\\"\");\n        messageBuff.append(\"style=\\\"background-color:\");\n        messageBuff.append(MSG_NAME_BACKGROUND).append(\";\\\">\");\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td align=\\\"left\\\" >\");\n        messageBuff.append(headerBuffer.toString());\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<td align=\\\"right\\\"><h2>\");\n        messageBuff.append(getDateString(date) + GuiUtils.formatTime(date));\n        messageBuff.append(\"<\/h2><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n        messageBuff.append(\"<\/table>\");\n        messageBuff.append(\n            createSimpleMessageTag( messageID,\n                                    contactName,\n                                    message,\n                                    contentType,\n                                    date,\n                                    false,\n                                    isHistory));\n\n        return messageBuff.toString();\n    }","id":25884,"modified_method":"/**\n     * Creates an incoming message tag.\n     *\n     * @param messageID the identifier\n     * @param contactName the name of the contact sending the message\n     * @param contactDisplayName the display name of the contact sending the\n     * message\n     * @param avatarPath the path to the avatar file\n     * @param date the date, when the message was sent\n     * @param message the message content\n     * @param contentType the content type HTML or PLAIN_TEXT\n     * @param isHistory indicates if this is a message coming from history\n     * @return the created incoming message tag\n     */\n    private static String createSimpleIncomingMessageTag(\n        String messageID,\n        String contactName,\n        String contactDisplayName,\n        String avatarPath,\n        Date date,\n        String message,\n        String contentType,\n        boolean isHistory)\n    {\n        StringBuilder headerBuffer = new StringBuilder();\n\n\n        SimpleDateFormat sdf = new SimpleDateFormat(HistoryService.DATE_FORMAT);\n        headerBuffer.append(\"<h2 id=\\\"\").append(MESSAGE_HEADER_ID).append(\"\\\" \");\n        headerBuffer.append(DATE_ATTRIBUTE).append(\"='\")\n            .append(sdf.format(date)).append(\"'>\");\n        headerBuffer.append(\"<a style=\\\"color:\");\n        headerBuffer.append(MSG_IN_NAME_FOREGROUND).append(\";\");\n        headerBuffer.append(\"font-weight:bold;\");\n        headerBuffer.append(\"text-decoration:none;\\\" \");\n        headerBuffer.append(\"href=\\\"\").append(contactName).append(\"\\\">\");\n        headerBuffer.append(\n            contactDisplayName).append(createEditedAtTag(messageID, -1));\n        headerBuffer.append(\"<\/a>\");\n        headerBuffer.append(\"<\/h2>\");\n\n        StringBuffer messageBuff = new StringBuffer();\n\n        messageBuff.append(\"<table width=\\\"100%\\\" \");\n        messageBuff.append(NAME_ATTRIBUTE).append(\"=\\\"\")\n            .append(Tag.TABLE.toString())\n            .append(\"\\\" id=\\\"messageHeader\\\"\");\n        messageBuff.append(\"style=\\\"background-color:\");\n        messageBuff.append(MSG_NAME_BACKGROUND).append(\";\\\">\");\n        messageBuff.append(\"<tr>\");\n        messageBuff.append(\"<td align=\\\"left\\\" >\");\n        messageBuff.append(headerBuffer.toString());\n        messageBuff.append(\"<\/td>\");\n        messageBuff.append(\"<td align=\\\"right\\\"><h2>\");\n        messageBuff.append(getDateString(date))\n            .append(GuiUtils.formatTime(date));\n        messageBuff.append(\"<\/h2><\/td>\");\n        messageBuff.append(\"<\/tr>\");\n        messageBuff.append(\"<\/table>\");\n        messageBuff.append(\n            createSimpleMessageTag( messageID,\n                                    contactName,\n                                    message,\n                                    contentType,\n                                    date,\n                                    false,\n                                    isHistory));\n\n        return messageBuff.toString();\n    }","commit_id":"81c8c4ee18b9b036d95647e058255dddb6256c82","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void init(Object context, Configuration config) {\n\t\tif (_config != null)\n\t\t\tthrow new IllegalStateException(\"Cannot be initialized twice\");\n\t\tif (config == null)\n\t\t\tthrow new IllegalArgumentException(\"null\");\n\t\tfinal WebApp oldwapp = config.getWebApp();\n\t\tif (oldwapp != null && oldwapp != this)\n\t\t\tthrow new IllegalArgumentException(\"config already belongs to other Web app, \"+oldwapp);\n\t\t_config = config;\n\t\t_config.setWebApp(this);\n\n\t\tDefinitionLoaders.setZkVersion(getVersion());\n\n\t\tClass cls = _config.getUiEngineClass();\n\t\tif (cls == null) {\n\t\t\t_engine = new UiEngineImpl();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t_engine = (UiEngine)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\tcls = _config.getDesktopCacheProviderClass();\n\t\tif (cls == null) {\n\t\t\t_provider = new SessionDesktopCacheProvider();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t_provider = (DesktopCacheProvider)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\tcls = _config.getUiFactoryClass();\n\t\tif (cls == null) {\n\t\t\t_factory = new SimpleUiFactory();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t_factory = (UiFactory)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\tcls = _config.getFailoverManagerClass();\n\t\tif (cls != null) {\n\t\t\ttry {\n\t\t\t\t_failover = (FailoverManager)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\t\tcls = _config.getIdGeneratorClass();\n\t\tif (cls != null) {\n\t\t\ttry {\n\t\t\t\t_idgen = (IdGenerator)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\t_engine.start(this);\n\t\t_provider.start(this);\n\t\t_factory.start(this);\n\n\t\t_config.invokeWebAppInits();\n\t}","id":25885,"modified_method":"public void init(Object context, Configuration config) {\n\t\tif (_config != null)\n\t\t\tthrow new IllegalStateException(\"Cannot be initialized twice\");\n\t\tif (config == null)\n\t\t\tthrow new IllegalArgumentException(\"null\");\n\t\tfinal WebApp oldwapp = config.getWebApp();\n\t\tif (oldwapp != null && oldwapp != this)\n\t\t\tthrow new IllegalArgumentException(\"config already belongs to other Web app, \"+oldwapp);\n\t\t_config = config;\n\t\t_config.setWebApp(this);\n\n\t\tClass cls = _config.getUiEngineClass();\n\t\tif (cls == null) {\n\t\t\t_engine = new UiEngineImpl();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t_engine = (UiEngine)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\tcls = _config.getDesktopCacheProviderClass();\n\t\tif (cls == null) {\n\t\t\t_provider = new SessionDesktopCacheProvider();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t_provider = (DesktopCacheProvider)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\tcls = _config.getUiFactoryClass();\n\t\tif (cls == null) {\n\t\t\t_factory = new SimpleUiFactory();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t_factory = (UiFactory)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\tcls = _config.getFailoverManagerClass();\n\t\tif (cls != null) {\n\t\t\ttry {\n\t\t\t\t_failover = (FailoverManager)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\t\tcls = _config.getIdGeneratorClass();\n\t\tif (cls != null) {\n\t\t\ttry {\n\t\t\t\t_idgen = (IdGenerator)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\t_engine.start(this);\n\t\t_provider.start(this);\n\t\t_factory.start(this);\n\n\t\t_config.invokeWebAppInits();\n\t}","commit_id":"889426ef1771719f4c5972a65d40ff535f1c1c81","url":"https://github.com/zkoss/zk"},{"original_method":"public final String getVersion() {\n\t\treturn \"2.5.0-FL\";\n\t}","id":25886,"modified_method":"public final String getVersion() {\n\t\treturn Version.RELEASE;\n\t}","commit_id":"889426ef1771719f4c5972a65d40ff535f1c1c81","url":"https://github.com/zkoss/zk"},{"original_method":"private static void load0() {\n\t\tfinal ClassLocator locator = new ClassLocator();\n\n\t\t//1. process config.xml (no particular dependency)\n\t\ttry {\n\t\t\tfor (Enumeration en = locator.getResources(\"metainfo/zk/config.xml\");\n\t\t\ten.hasMoreElements();) {\n\t\t\t\tfinal URL url = (URL)en.nextElement();\n\t\t\t\tif (log.debugable()) log.debug(\"Loading \"+url);\n\t\t\t\ttry {\n\t\t\t\t\tfinal Document doc = new SAXBuilder(false, false, true).build(url);\n\t\t\t\t\tif (checkVersion(url, doc))\n\t\t\t\t\t\tparseConfig(doc.getRootElement());\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tthrow UiException.Aide.wrap(ex, \"Failed to load \"+url);\n\t\t\t\t\t\t//abort since it is hardly to work then\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tthrow UiException.Aide.wrap(ex); //abort\n\t\t}\n\n\t\t//2. process lang.xml (no particular dependency)\n\t\ttry {\n\t\t\tfor (Enumeration en = locator.getResources(\"metainfo/zk/lang.xml\");\n\t\t\ten.hasMoreElements();) {\n\t\t\t\tfinal URL url = (URL)en.nextElement();\n\t\t\t\tif (log.debugable()) log.debug(\"Loading \"+url);\n\t\t\t\ttry {\n\t\t\t\t\tfinal Document doc = new SAXBuilder(false, false, true).build(url);\n\t\t\t\t\tif (checkVersion(url, doc))\n\t\t\t\t\t\tparseLang(doc, locator, false);\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tthrow UiException.Aide.wrap(ex, \"Failed to load \"+url);\n\t\t\t\t\t\t//abort since it is hardly to work then\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tthrow UiException.Aide.wrap(ex); //abort\n\t\t}\n\n\t\t//3. process lang-addon.xml (with dependency)\n\t\ttry {\n\t\t\tfinal List xmls = locator.getDependentXMLResources(\n\t\t\t\t\"metainfo/zk/lang-addon.xml\", \"addon-name\", \"depends\");\n\t\t\tfor (Iterator it = xmls.iterator(); it.hasNext();) {\n\t\t\t\tfinal ClassLocator.Resource res = (ClassLocator.Resource)it.next();\n\t\t\t\ttry {\n\t\t\t\t\tif (checkVersion(res.url, res.document))\n\t\t\t\t\t\tparseLang(res.document, locator, true);\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tlog.error(\"Failed to load addon\", ex);\n\t\t\t\t\t//keep running\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"Failed to load addon\", ex);\n\t\t\t//keep running\n\t\t}\n\n\t\t//4. process other addon (from addAddon)\n\t\tif (_addons != null) {\n\t\t\tfor (Iterator it = _addons.iterator(); it.hasNext();) {\n\t\t\t\tfinal Object[] p = (Object[])it.next();\n\t\t\t\tloadAddon((Locator)p[0], (URL)p[1]);\n\t\t\t}\n\t\t\t_addons = null; //free memory\n\t\t}\n\t}","id":25887,"modified_method":"private static void load0() {\n\t\tfinal ClassLocator locator = new ClassLocator();\n\n\t\tfinal int[] zkver = new int[MAX_VERSION_SEGMENT];\n\t\tfor (int j = 0; j < MAX_VERSION_SEGMENT; ++j)\n\t\t\tzkver[j] = Utils.getSubversion(Version.UID, j);\n\n\t\t//1. process config.xml (no particular dependency)\n\t\ttry {\n\t\t\tfor (Enumeration en = locator.getResources(\"metainfo/zk/config.xml\");\n\t\t\ten.hasMoreElements();) {\n\t\t\t\tfinal URL url = (URL)en.nextElement();\n\t\t\t\tif (log.debugable()) log.debug(\"Loading \"+url);\n\t\t\t\ttry {\n\t\t\t\t\tfinal Document doc = new SAXBuilder(false, false, true).build(url);\n\t\t\t\t\tif (checkVersion(zkver, url, doc))\n\t\t\t\t\t\tparseConfig(doc.getRootElement());\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tthrow UiException.Aide.wrap(ex, \"Failed to load \"+url);\n\t\t\t\t\t\t//abort since it is hardly to work then\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tthrow UiException.Aide.wrap(ex); //abort\n\t\t}\n\n\t\t//2. process lang.xml (no particular dependency)\n\t\ttry {\n\t\t\tfor (Enumeration en = locator.getResources(\"metainfo/zk/lang.xml\");\n\t\t\ten.hasMoreElements();) {\n\t\t\t\tfinal URL url = (URL)en.nextElement();\n\t\t\t\tif (log.debugable()) log.debug(\"Loading \"+url);\n\t\t\t\ttry {\n\t\t\t\t\tfinal Document doc = new SAXBuilder(false, false, true).build(url);\n\t\t\t\t\tif (checkVersion(zkver, url, doc))\n\t\t\t\t\t\tparseLang(doc, locator, false);\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tthrow UiException.Aide.wrap(ex, \"Failed to load \"+url);\n\t\t\t\t\t\t//abort since it is hardly to work then\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tthrow UiException.Aide.wrap(ex); //abort\n\t\t}\n\n\t\t//3. process lang-addon.xml (with dependency)\n\t\ttry {\n\t\t\tfinal List xmls = locator.getDependentXMLResources(\n\t\t\t\t\"metainfo/zk/lang-addon.xml\", \"addon-name\", \"depends\");\n\t\t\tfor (Iterator it = xmls.iterator(); it.hasNext();) {\n\t\t\t\tfinal ClassLocator.Resource res = (ClassLocator.Resource)it.next();\n\t\t\t\ttry {\n\t\t\t\t\tif (checkVersion(zkver, res.url, res.document))\n\t\t\t\t\t\tparseLang(res.document, locator, true);\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tlog.error(\"Failed to load addon\", ex);\n\t\t\t\t\t//keep running\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"Failed to load addon\", ex);\n\t\t\t//keep running\n\t\t}\n\n\t\t//4. process other addon (from addAddon)\n\t\tif (_addons != null) {\n\t\t\tfor (Iterator it = _addons.iterator(); it.hasNext();) {\n\t\t\t\tfinal Object[] p = (Object[])it.next();\n\t\t\t\tloadAddon((Locator)p[0], (URL)p[1]);\n\t\t\t}\n\t\t\t_addons = null; //free memory\n\t\t}\n\t}","commit_id":"889426ef1771719f4c5972a65d40ff535f1c1c81","url":"https://github.com/zkoss/zk"},{"original_method":"/** Checks and returns whether the loaded document's version is correct.\n\t */\n\tprivate static boolean checkVersion(URL url, Document doc) throws Exception {\n\t\tfinal Element el = doc.getRootElement().getElement(\"version\");\n\t\tif (el != null) {\n\t\t\tfinal String zkver = el.getElementValue(\"zk-version\", true);\n\t\t\tif (!checkZkVersion(zkver)) {\n\t\t\t\tlog.info(\"Ignore \"+url+\"\\nCause: ZK version must be \"+zkver+\" or later, not \"+_zkver);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfinal String clsnm = IDOMs.getRequiredElementValue(el, \"version-class\");\n\t\t\tfinal String uid = IDOMs.getRequiredElementValue(el, \"version-uid\");\n\t\t\tfinal Class cls = Classes.forNameByThread(clsnm);\n\t\t\tfinal Field fld = cls.getField(\"UID\");\n\t\t\tfinal String uidInClass = (String)fld.get(null);\n\t\t\tif (uid.equals(uidInClass)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tlog.info(\"Ignore \"+url+\"\\nCause: version not matched; expected=\"+uidInClass+\", xml=\"+uid);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tlog.info(\"Ignore \"+url+\"\\nCause: version not specified\");\n\t\t\treturn false; //backward compatible\n\t\t}\n\t}","id":25888,"modified_method":"/** Checks and returns whether the loaded document's version is correct.\n\t */\n\tprivate static boolean checkVersion(int[] zkver, URL url, Document doc)\n\tthrows Exception {\n\t\tfinal Element el = doc.getRootElement().getElement(\"version\");\n\t\tif (el != null) {\n\t\t\tfinal String reqzkver = el.getElementValue(\"zk-version\", true);\n\t\t\tif (reqzkver != null) {\n\t\t\t\tfor (int j = 0; j < MAX_VERSION_SEGMENT; ++j) {\n\t\t\t\t\tint v = Utils.getSubversion(reqzkver, j);\n\t\t\t\t\tif (v < zkver[j]) break; //ok\n\t\t\t\t\tif (v > zkver[j]) {//failed\n\t\t\t\t\t\tlog.info(\"Ignore \"+url+\"\\nCause: ZK version must be \"+zkver+\" or later, not \"+Version.UID);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal String clsnm = IDOMs.getRequiredElementValue(el, \"version-class\");\n\t\t\tfinal String uid = IDOMs.getRequiredElementValue(el, \"version-uid\");\n\t\t\tfinal Class cls = Classes.forNameByThread(clsnm);\n\t\t\tfinal Field fld = cls.getField(\"UID\");\n\t\t\tfinal String uidInClass = (String)fld.get(null);\n\t\t\tif (uid.equals(uidInClass)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tlog.info(\"Ignore \"+url+\"\\nCause: version not matched; expected=\"+uidInClass+\", xml=\"+uid);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tlog.info(\"Ignore \"+url+\"\\nCause: version not specified\");\n\t\t\treturn false; //backward compatible\n\t\t}\n\t}","commit_id":"889426ef1771719f4c5972a65d40ff535f1c1c81","url":"https://github.com/zkoss/zk"},{"original_method":"private HRegion createAregion(Text startKey, Text endKey, int firstRow,\n      int nrows) throws IOException {\n    \n    HRegion region = createNewHRegion(desc, startKey, endKey);\n    \n    System.out.println(\"created region \" + region.getRegionName());\n\n    HRegionIncommon r = new HRegionIncommon(region);\n    for(int i = firstRow; i < firstRow + nrows; i++) {\n      long lockid = r.startUpdate(new Text(\"row_\"\n          + String.format(\"%1$05d\", i)));\n\n      r.put(lockid, COLUMN_NAME, value.get());\n      r.commit(lockid, System.currentTimeMillis());\n      if(i % 10000 == 0) {\n        System.out.println(\"Flushing write #\" + i);\n        r.flushcache();\n      }\n    }\n    region.compactIfNeeded();\n    region.close();\n    region.getLog().closeAndDelete();\n    region.getRegionInfo().setOffline(true);\n    return region;\n  }","id":25889,"modified_method":"private HRegion createAregion(Text startKey, Text endKey, int firstRow,\n      int nrows) throws IOException {\n    \n    HRegion region = createNewHRegion(desc, startKey, endKey);\n    \n    System.out.println(\"created region \" + region.getRegionName());\n\n    HRegionIncommon r = new HRegionIncommon(region);\n    for(int i = firstRow; i < firstRow + nrows; i++) {\n      long lockid = r.startUpdate(new Text(\"row_\"\n          + String.format(\"%1$05d\", i)));\n\n      r.put(lockid, COLUMN_NAME, value.get());\n      r.commit(lockid, System.currentTimeMillis());\n      if(i % 10000 == 0) {\n        System.out.println(\"Flushing write #\" + i);\n        r.flushcache();\n      }\n    }\n    region.close();\n    region.getLog().closeAndDelete();\n    region.getRegionInfo().setOffline(true);\n    return region;\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Verifies current version of file system\n   * \n   * @param fs\n   * @param rootdir\n   * @return true if the current file system is the correct version\n   * @throws IOException\n   */\n  public static boolean checkVersion(FileSystem fs, Path rootdir) throws IOException {\n    Path versionFile = new Path(rootdir, HConstants.VERSION_FILE_NAME);\n    boolean versionOk = false;\n    if (fs.exists(versionFile)) {\n      FSDataInputStream s =\n        fs.open(new Path(rootdir, HConstants.VERSION_FILE_NAME));\n      String version = DataInputStream.readUTF(s);\n      s.close();\n      versionOk = version.compareTo(HConstants.FILE_SYSTEM_VERSION) == 0;\n    }\n    return versionOk;\n  }","id":25890,"modified_method":"/**\n   * Verifies current version of file system\n   * \n   * @param fs\n   * @param rootdir\n   * @return null if no version file exists, version string otherwise.\n   * @throws IOException\n   */\n  public static String checkVersion(FileSystem fs, Path rootdir) throws IOException {\n    Path versionFile = new Path(rootdir, HConstants.VERSION_FILE_NAME);\n    String version = null;\n    if (fs.exists(versionFile)) {\n      FSDataInputStream s =\n        fs.open(new Path(rootdir, HConstants.VERSION_FILE_NAME));\n      version = DataInputStream.readUTF(s);\n      s.close();\n    }\n    return version;\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"/** \n   * Build the HMaster\n   * @param rd base directory of this HBase instance.  Must be fully\n   * qualified so includes filesystem to use.\n   * @param address server address and port number\n   * @param conf configuration\n   * \n   * @throws IOException\n   */\n  public HMaster(Path rd, HServerAddress address, HBaseConfiguration conf)\n  throws IOException {\n    this.conf = conf;\n    this.rootdir = rd;\n    // The filesystem hbase wants to use is probably not what is set into\n    // fs.default.name; its value is probably the default.\n    this.conf.set(\"fs.default.name\", this.rootdir.toString());\n    this.fs = FileSystem.get(conf);\n    this.conf.set(HConstants.HBASE_DIR, this.rootdir.toString());\n    this.rand = new Random();\n    Path rootRegionDir =\n      HRegion.getRegionDir(rootdir, HRegionInfo.rootRegionInfo);\n    LOG.info(\"Root region dir: \" + rootRegionDir.toString());\n\n    try {\n      // Make sure the root directory exists!\n      if(! fs.exists(rootdir)) {\n        fs.mkdirs(rootdir);\n        FSUtils.setVersion(fs, rootdir);\n      } else if (!FSUtils.checkVersion(fs, rootdir)) {\n        // Output on stdout so user sees it in terminal.\n        String message = \"The HBase data files stored on the FileSystem are \" +\n          \"from an earlier version of HBase. You need to run \" +\n          \"'${HBASE_HOME}/bin/hbase migrate' to bring your installation\"  +\n          \"up-to-date.\";\n        System.out.println(\"WARNING! \" + message + \" Master shutting down...\");\n        throw new IOException(message);\n      }\n\n      if (!fs.exists(rootRegionDir)) {\n        LOG.info(\"bootstrap: creating ROOT and first META regions\");\n        try {\n          HRegion root = HRegion.createHRegion(HRegionInfo.rootRegionInfo,\n              this.rootdir, this.conf);\n          HRegion meta = HRegion.createHRegion(HRegionInfo.firstMetaRegionInfo,\n            this.rootdir, this.conf);\n\n          // Add first region from the META table to the ROOT region.\n          HRegion.addRegionToMETA(root, meta);\n          root.close();\n          root.getLog().closeAndDelete();\n          meta.close();\n          meta.getLog().closeAndDelete();\n        } catch (IOException e) {\n          e = RemoteExceptionHandler.checkIOException(e);\n          LOG.error(\"bootstrap\", e);\n          throw e;\n        }\n      }\n    } catch (IOException e) {\n      LOG.fatal(\"Not starting HMaster because:\", e);\n      throw e;\n    }\n\n    this.threadWakeFrequency = conf.getInt(THREAD_WAKE_FREQUENCY, 10 * 1000);\n    this.numRetries =  conf.getInt(\"hbase.client.retries.number\", 2);\n    this.maxRegionOpenTime =\n      conf.getLong(\"hbase.hbasemaster.maxregionopen\", 30 * 1000);\n\n    this.leaseTimeout = conf.getInt(\"hbase.master.lease.period\", 30 * 1000);\n    this.serverLeases = new Leases(this.leaseTimeout, \n        conf.getInt(\"hbase.master.lease.thread.wakefrequency\", 15 * 1000));\n    \n    this.server = HbaseRPC.getServer(this, address.getBindAddress(),\n        address.getPort(), conf.getInt(\"hbase.regionserver.handler.count\", 10),\n        false, conf);\n\n    //  The rpc-server port can be ephemeral... ensure we have the correct info\n    this.address = new HServerAddress(server.getListenerAddress());\n    conf.set(MASTER_ADDRESS, address.toString());\n\n    this.connection = HConnectionManager.getConnection(conf);\n\n    this.metaRescanInterval =\n      conf.getInt(\"hbase.master.meta.thread.rescanfrequency\", 60 * 1000);\n\n    // The root region\n    this.rootScannerThread = new RootScanner(this);\n\n    // Scans the meta table\n    this.metaScannerThread = new MetaScanner(this);\n    \n    unassignRootRegion();\n\n    this.sleeper = new Sleeper(this.threadWakeFrequency, this.closed);\n    \n    // We're almost open for business\n    this.closed.set(false);\n    LOG.info(\"HMaster initialized on \" + this.address.toString());\n  }","id":25891,"modified_method":"/** \n   * Build the HMaster\n   * @param rd base directory of this HBase instance.  Must be fully\n   * qualified so includes filesystem to use.\n   * @param address server address and port number\n   * @param conf configuration\n   * \n   * @throws IOException\n   */\n  public HMaster(Path rd, HServerAddress address, HBaseConfiguration conf)\n  throws IOException {\n    this.conf = conf;\n    this.rootdir = rd;\n    // The filesystem hbase wants to use is probably not what is set into\n    // fs.default.name; its value is probably the default.\n    this.conf.set(\"fs.default.name\", this.rootdir.toString());\n    this.fs = FileSystem.get(conf);\n    this.conf.set(HConstants.HBASE_DIR, this.rootdir.toString());\n    this.rand = new Random();\n    Path rootRegionDir =\n      HRegion.getRegionDir(rootdir, HRegionInfo.rootRegionInfo);\n    LOG.info(\"Root region dir: \" + rootRegionDir.toString());\n\n    try {\n      // Make sure the root directory exists!\n      if(! fs.exists(rootdir)) {\n        fs.mkdirs(rootdir); \n        FSUtils.setVersion(fs, rootdir);\n      } else {\n        String fsversion = FSUtils.checkVersion(fs, rootdir);\n        if (fsversion == null ||\n            fsversion.compareTo(FILE_SYSTEM_VERSION) != 0) {\n          // Output on stdout so user sees it in terminal.\n          String message = \"The HBase data files stored on the FileSystem \" +\n          \"are from an earlier version of HBase. You need to run \" +\n          \"'${HBASE_HOME}/bin/hbase migrate' to bring your installation \" +\n          \"up-to-date.\";\n          // Output on stdout so user sees it in terminal.\n          System.out.println(\"WARNING! \" + message + \" Master shutting down...\");\n          throw new IOException(message);\n        }\n      }\n\n      if (!fs.exists(rootRegionDir)) {\n        LOG.info(\"bootstrap: creating ROOT and first META regions\");\n        try {\n          HRegion root = HRegion.createHRegion(HRegionInfo.rootRegionInfo,\n              this.rootdir, this.conf);\n          HRegion meta = HRegion.createHRegion(HRegionInfo.firstMetaRegionInfo,\n            this.rootdir, this.conf);\n\n          // Add first region from the META table to the ROOT region.\n          HRegion.addRegionToMETA(root, meta);\n          root.close();\n          root.getLog().closeAndDelete();\n          meta.close();\n          meta.getLog().closeAndDelete();\n        } catch (IOException e) {\n          e = RemoteExceptionHandler.checkIOException(e);\n          LOG.error(\"bootstrap\", e);\n          throw e;\n        }\n      }\n    } catch (IOException e) {\n      LOG.fatal(\"Not starting HMaster because:\", e);\n      throw e;\n    }\n\n    this.threadWakeFrequency = conf.getInt(THREAD_WAKE_FREQUENCY, 10 * 1000);\n    this.numRetries =  conf.getInt(\"hbase.client.retries.number\", 2);\n    this.maxRegionOpenTime =\n      conf.getLong(\"hbase.hbasemaster.maxregionopen\", 30 * 1000);\n\n    this.leaseTimeout = conf.getInt(\"hbase.master.lease.period\", 30 * 1000);\n    this.serverLeases = new Leases(this.leaseTimeout, \n        conf.getInt(\"hbase.master.lease.thread.wakefrequency\", 15 * 1000));\n    \n    this.server = HbaseRPC.getServer(this, address.getBindAddress(),\n        address.getPort(), conf.getInt(\"hbase.regionserver.handler.count\", 10),\n        false, conf);\n\n    //  The rpc-server port can be ephemeral... ensure we have the correct info\n    this.address = new HServerAddress(server.getListenerAddress());\n    conf.set(MASTER_ADDRESS, address.toString());\n\n    this.connection = HConnectionManager.getConnection(conf);\n\n    this.metaRescanInterval =\n      conf.getInt(\"hbase.master.meta.thread.rescanfrequency\", 60 * 1000);\n\n    // The root region\n    this.rootScannerThread = new RootScanner(this);\n\n    // Scans the meta table\n    this.metaScannerThread = new MetaScanner(this);\n    \n    unassignRootRegion();\n\n    this.sleeper = new Sleeper(this.threadWakeFrequency, this.closed);\n    \n    // We're almost open for business\n    this.closed.set(false);\n    LOG.info(\"HMaster initialized on \" + this.address.toString());\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"public InfoServer getInfoServer() {\n    return infoServer;\n  }","id":25892,"modified_method":"/** @return InfoServer object */\n  public InfoServer getInfoServer() {\n    return infoServer;\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"private void migrateRegionDir(FileSystem fs, Path rootdir, Text tableName,\n      Path oldPath) throws IOException {\n\n    // Create directory where table will live\n\n    Path tableDir = new Path(rootdir, tableName.toString());\n    fs.mkdirs(tableDir);\n\n    // Move the old region directory under the table directory\n\n    Path newPath =\n      new Path(tableDir, oldPath.getName().substring(OLD_PREFIX.length()));\n    fs.rename(oldPath, newPath);\n\n    processRegionSubDirs(fs, newPath);\n  }","id":25893,"modified_method":"private void migrateRegionDir(Text tableName, Path oldPath)\n  throws IOException {\n\n    // Create directory where table will live\n\n    Path tableDir = new Path(rootdir, tableName.toString());\n    fs.mkdirs(tableDir);\n\n    // Move the old region directory under the table directory\n\n    Path newPath =\n      new Path(tableDir, oldPath.getName().substring(OLD_PREFIX.length()));\n    fs.rename(oldPath, newPath);\n\n    processRegionSubDirs(fs, newPath);\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"private void usage() {\n    System.err.println(\"Usage: bin/hbase migrate { check | upgrade } [options]\\n\");\n    System.err.println(\"  check                            perform upgrade checks only.\");\n    System.err.println(\"  upgrade                          perform upgrade checks and modify hbase.\\n\");\n    System.err.println(\"  Options are:\");\n    System.err.println(\"    -logfiles={abort|ignore|delete|prompt}\");\n    System.err.println(\"                                   action to take when unrecovered region\");\n    System.err.println(\"                                   server log files are found.\\n\");\n    System.err.println(\"    -extrafiles={abort|ignore|delete|prompt}\");\n    System.err.println(\"                                   action to take if \\\"extra\\\" files are found.\\n\");\n    System.err.println(\"    -conf <configuration file>     specify an application configuration file\");\n    System.err.println(\"    -D <property=value>            use value for given property\");\n    System.err.println(\"    -fs <local|namenode:port>      specify a namenode\");\n  }","id":25894,"modified_method":"private void usage() {\n    System.err.println(\"Usage: bin/hbase migrate { check | upgrade } [options]\\n\");\n    System.err.println(\"  check                            perform upgrade checks only.\");\n    System.err.println(\"  upgrade                          perform upgrade checks and modify hbase.\\n\");\n    System.err.println(\"  Options are:\");\n    System.err.println(\"    -extrafiles={abort|ignore|delete|prompt}\");\n    System.err.println(\"                                   action to take if \\\"extra\\\" files are found.\\n\");\n    System.err.println(\"    -conf <configuration file>     specify an application configuration file\");\n    System.err.println(\"    -D <property=value>            use value for given property\");\n    System.err.println(\"    -fs <local|namenode:port>      specify a namenode\");\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"private void checkNewRootRegionDirExists(FileSystem fs, Path rootdir)\n  throws IOException {\n    Path rootRegionDir =\n      HRegion.getRegionDir(rootdir, HRegionInfo.rootRegionInfo);\n    newRootRegion = fs.exists(rootRegionDir);\n    migrationNeeded = !newRootRegion;\n  }","id":25895,"modified_method":"private void checkNewRootRegionDirExists() throws IOException {\n    Path rootRegionDir =\n      HRegion.getRegionDir(rootdir, HRegionInfo.rootRegionInfo);\n    newRootRegion = fs.exists(rootRegionDir);\n    migrationNeeded = !newRootRegion;\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"private void scanMetaRegion(FileSystem fs, Path rootdir, HLog log,\n      HRegionInfo info) throws IOException {\n\n    HRegion metaRegion = new HRegion(\n        new Path(rootdir, info.getTableDesc().getName().toString()), log, fs,\n        conf, info, null, null);\n\n    try {\n      HScannerInterface metaScanner = metaRegion.getScanner(\n          HConstants.COL_REGIONINFO_ARRAY, HConstants.EMPTY_START_ROW,\n          HConstants.LATEST_TIMESTAMP, null);\n\n      try {\n        HStoreKey key = new HStoreKey();\n        SortedMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n        while (metaScanner.next(key, results)) {\n          HRegionInfo region = Writables.getHRegionInfoOrNull(\n              results.get(HConstants.COL_REGIONINFO));\n          if (region == null) {\n            LOG.warn(\"region info is null for row \" + key.getRow() +\n                \" in table \" + HConstants.META_TABLE_NAME);\n            continue;\n          }\n\n          // Move the region to where it should be and rename\n          // subdirectories as necessary\n\n          migrateRegionDir(fs, rootdir, region.getTableDesc().getName(),\n              new Path(rootdir, OLD_PREFIX + region.getEncodedName()));\n\n          results.clear();\n        }\n\n      } finally {\n        metaScanner.close();\n      }\n\n    } finally {\n      metaRegion.close();\n    }\n  }","id":25896,"modified_method":"private void scanMetaRegion(HLog log, HRegionInfo info) throws IOException {\n\n    HRegion metaRegion = new HRegion(\n        new Path(rootdir, info.getTableDesc().getName().toString()), log, fs,\n        conf, info, null, null);\n\n    try {\n      HScannerInterface metaScanner = metaRegion.getScanner(\n          HConstants.COL_REGIONINFO_ARRAY, HConstants.EMPTY_START_ROW,\n          HConstants.LATEST_TIMESTAMP, null);\n\n      try {\n        HStoreKey key = new HStoreKey();\n        SortedMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n        while (metaScanner.next(key, results)) {\n          HRegionInfo region = Writables.getHRegionInfoOrNull(\n              results.get(HConstants.COL_REGIONINFO));\n          if (region == null) {\n            LOG.warn(\"region info is null for row \" + key.getRow() +\n                \" in table \" + HConstants.META_TABLE_NAME);\n            continue;\n          }\n\n          // Move the region to where it should be and rename\n          // subdirectories as necessary\n\n          migrateRegionDir(region.getTableDesc().getName(),\n              new Path(rootdir, OLD_PREFIX + region.getEncodedName()));\n\n          results.clear();\n        }\n\n      } finally {\n        metaScanner.close();\n      }\n\n    } finally {\n      metaRegion.close();\n    }\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"private void scanRootRegion(FileSystem fs, Path rootdir) throws IOException {\n    HLog log = new HLog(fs, new Path(rootdir, HConstants.HREGION_LOGDIR_NAME),\n        conf, null);\n\n    try {\n      // Open root region so we can scan it\n\n      HRegion rootRegion = new HRegion(\n          new Path(rootdir, HConstants.ROOT_TABLE_NAME.toString()), log, fs, conf,\n          HRegionInfo.rootRegionInfo, null, null);\n\n      try {\n        HScannerInterface rootScanner = rootRegion.getScanner(\n            HConstants.COL_REGIONINFO_ARRAY, HConstants.EMPTY_START_ROW,\n            HConstants.LATEST_TIMESTAMP, null);\n\n        try {\n          HStoreKey key = new HStoreKey();\n          SortedMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n          while (rootScanner.next(key, results)) {\n            HRegionInfo info = Writables.getHRegionInfoOrNull(\n                results.get(HConstants.COL_REGIONINFO));\n            if (info == null) {\n              LOG.warn(\"region info is null for row \" + key.getRow() +\n                  \" in table \" + HConstants.ROOT_TABLE_NAME);\n              continue;\n            }\n\n            // First move the meta region to where it should be and rename\n            // subdirectories as necessary\n\n            migrateRegionDir(fs, rootdir, HConstants.META_TABLE_NAME,\n                new Path(rootdir, OLD_PREFIX + info.getEncodedName()));\n\n            // Now scan and process the meta table\n\n            scanMetaRegion(fs, rootdir, log, info);\n          }\n\n        } finally {\n          rootScanner.close();\n        }\n\n      } finally {\n        rootRegion.close();\n      }\n\n    } finally {\n      log.closeAndDelete();\n    }\n  }","id":25897,"modified_method":"private void scanRootRegion() throws IOException {\n    HLog log = new HLog(fs, new Path(rootdir, HConstants.HREGION_LOGDIR_NAME),\n        conf, null);\n\n    try {\n      // Open root region so we can scan it\n\n      HRegion rootRegion = new HRegion(\n          new Path(rootdir, HConstants.ROOT_TABLE_NAME.toString()), log, fs, conf,\n          HRegionInfo.rootRegionInfo, null, null);\n\n      try {\n        HScannerInterface rootScanner = rootRegion.getScanner(\n            HConstants.COL_REGIONINFO_ARRAY, HConstants.EMPTY_START_ROW,\n            HConstants.LATEST_TIMESTAMP, null);\n\n        try {\n          HStoreKey key = new HStoreKey();\n          SortedMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\n          while (rootScanner.next(key, results)) {\n            HRegionInfo info = Writables.getHRegionInfoOrNull(\n                results.get(HConstants.COL_REGIONINFO));\n            if (info == null) {\n              LOG.warn(\"region info is null for row \" + key.getRow() +\n                  \" in table \" + HConstants.ROOT_TABLE_NAME);\n              continue;\n            }\n\n            // First move the meta region to where it should be and rename\n            // subdirectories as necessary\n\n            migrateRegionDir(HConstants.META_TABLE_NAME,\n                new Path(rootdir, OLD_PREFIX + info.getEncodedName()));\n\n            // Now scan and process the meta table\n\n            scanMetaRegion(log, info);\n          }\n\n        } finally {\n          rootScanner.close();\n        }\n\n      } finally {\n        rootRegion.close();\n      }\n\n    } finally {\n      log.closeAndDelete();\n    }\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\n  public int run(String[] args) {\n    if (parseArgs(args) != 0) {\n      return -1;\n    }\n\n    try {\n      FileSystem fs = FileSystem.get(conf);               // get DFS handle\n\n      LOG.info(\"Verifying that file system is available...\");\n      if (!FSUtils.isFileSystemAvailable(fs)) {\n        throw new IOException(\n            \"Filesystem must be available for upgrade to run.\");\n      }\n\n      LOG.info(\"Verifying that HBase is not running...\");\n      try {\n        HBaseAdmin admin = new HBaseAdmin(conf);\n        if (admin.isMasterRunning()) {\n          throw new IllegalStateException(\n            \"HBase cluster must be off-line during upgrade.\");\n        }\n      } catch (MasterNotRunningException e) {\n        // ignore\n      }\n\n      LOG.info(\"Starting upgrade\" + (readOnly ? \" check\" : \"\"));\n\n      Path rootdir =\n        fs.makeQualified(new Path(this.conf.get(HConstants.HBASE_DIR)));\n\n      if (!fs.exists(rootdir)) {\n        throw new FileNotFoundException(\"HBase root directory \" +\n            rootdir.toString() + \" does not exist.\");\n      }\n\n      // See if there is a file system version file\n\n      if (FSUtils.checkVersion(fs, rootdir)) {\n        LOG.info(\"No upgrade necessary.\");\n        return 0;\n      }\n\n      // check to see if new root region dir exists\n\n      checkNewRootRegionDirExists(fs, rootdir);\n\n      // check for \"extra\" files and for old upgradable regions\n\n      extraFiles(fs, rootdir);\n\n      if (!newRootRegion) {\n        // find root region\n\n        Path rootRegion = new Path(rootdir, \n            OLD_PREFIX + HRegionInfo.rootRegionInfo.getEncodedName());\n\n        if (!fs.exists(rootRegion)) {\n          throw new IOException(\"Cannot find root region \" +\n              rootRegion.toString());\n        } else if (readOnly) {\n          migrationNeeded = true;\n        } else {\n          migrateRegionDir(fs, rootdir, HConstants.ROOT_TABLE_NAME, rootRegion);\n          scanRootRegion(fs, rootdir);\n\n          // scan for left over regions\n\n          extraRegions(fs, rootdir);\n        }\n      }\n\n      if (!readOnly) {\n        // set file system version\n        LOG.info(\"Setting file system version.\");\n        FSUtils.setVersion(fs, rootdir);\n        LOG.info(\"Upgrade successful.\");\n      } else if (migrationNeeded) {\n        LOG.info(\"Upgrade needed.\");\n      }\n      return 0;\n    } catch (Exception e) {\n      LOG.fatal(\"Upgrade\" +  (readOnly ? \" check\" : \"\") + \" failed\", e);\n      return -1;\n    }\n  }","id":25898,"modified_method":"/** {@inheritDoc} */\n  public int run(String[] args) {\n    if (parseArgs(args) != 0) {\n      return -1;\n    }\n\n    try {\n      fs = FileSystem.get(conf);                        // get DFS handle\n\n      LOG.info(\"Verifying that file system is available...\");\n      if (!FSUtils.isFileSystemAvailable(fs)) {\n        throw new IOException(\n            \"Filesystem must be available for upgrade to run.\");\n      }\n\n      LOG.info(\"Verifying that HBase is not running...\");\n      try {\n        HBaseAdmin admin = new HBaseAdmin(conf);\n        if (admin.isMasterRunning()) {\n          throw new IllegalStateException(\n            \"HBase cluster must be off-line during upgrade.\");\n        }\n      } catch (MasterNotRunningException e) {\n        // ignore\n      }\n\n      LOG.info(\"Starting upgrade\" + (readOnly ? \" check\" : \"\"));\n\n      rootdir = fs.makeQualified(new Path(this.conf.get(HConstants.HBASE_DIR)));\n\n      if (!fs.exists(rootdir)) {\n        throw new FileNotFoundException(\"HBase root directory \" +\n            rootdir.toString() + \" does not exist.\");\n      }\n\n      // See if there is a file system version file\n\n      String version = FSUtils.checkVersion(fs, rootdir);\n      if (version != null && \n          version.compareTo(HConstants.FILE_SYSTEM_VERSION) == 0) {\n        LOG.info(\"No upgrade necessary.\");\n        return 0;\n      }\n\n      // Get contents of root directory\n      \n      FileStatus[] rootFiles = getRootDirFiles();\n\n      if (version == null) {\n        migrateFromNoVersion(rootFiles);\n        migrateToV2(rootFiles);\n      } else if (version.compareTo(\"0.1\") == 0) {\n        migrateToV2(rootFiles);\n      } else if (version.compareTo(\"2\") == 0) {\n        // Nothing to do (yet)\n      } else {\n        throw new IOException(\"Unrecognized version: \" + version);\n      }\n      \n      if (!readOnly) {\n        // set file system version\n        LOG.info(\"Setting file system version.\");\n        FSUtils.setVersion(fs, rootdir);\n        LOG.info(\"Upgrade successful.\");\n      } else if (migrationNeeded) {\n        LOG.info(\"Upgrade needed.\");\n      }\n      return 0;\n    } catch (Exception e) {\n      LOG.fatal(\"Upgrade\" +  (readOnly ? \" check\" : \"\") + \" failed\", e);\n      return -1;\n    }\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"private void extraFile(ACTION action, String message, FileSystem fs,\n      Path p) throws IOException {\n    \n    if (action == ACTION.ABORT) {\n      throw new IOException(message + \" aborting\");\n    } else if (action == ACTION.IGNORE) {\n      LOG.info(message + \" ignoring\");\n    } else if (action == ACTION.DELETE) {\n      LOG.info(message + \" deleting\");\n      fs.delete(p);\n    } else {\n      // ACTION.PROMPT\n      String response = prompt(message + \" delete? [y/n]\");\n      if (response.startsWith(\"Y\") || response.startsWith(\"y\")) {\n        LOG.info(message + \" deleting\");\n        fs.delete(p);\n      }\n    }\n  }","id":25899,"modified_method":"private void extraFile(ACTION action, String message, Path p)\n  throws IOException {\n    \n    if (action == ACTION.ABORT) {\n      throw new IOException(message + \" aborting\");\n    } else if (action == ACTION.IGNORE) {\n      LOG.info(message + \" ignoring\");\n    } else if (action == ACTION.DELETE) {\n      LOG.info(message + \" deleting\");\n      fs.delete(p);\n    } else {\n      // ACTION.PROMPT\n      String response = prompt(message + \" delete? [y/n]\");\n      if (response.startsWith(\"Y\") || response.startsWith(\"y\")) {\n        LOG.info(message + \" deleting\");\n        fs.delete(p);\n      }\n    }\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"private void extraFiles(FileSystem fs, Path rootdir) throws IOException {\n    FileStatus[] stats = fs.listStatus(rootdir);\n    if (stats == null || stats.length == 0) {\n      throw new IOException(\"No files found under root directory \" +\n          rootdir.toString());\n    }\n    for (int i = 0; i < stats.length; i++) {\n      String name = stats[i].getPath().getName();\n      if (name.startsWith(OLD_PREFIX)) {\n        if (!newRootRegion) {\n          // We need to migrate if the new root region directory doesn't exist\n          migrationNeeded = true;\n          String regionName = name.substring(OLD_PREFIX.length());\n          try {\n            Integer.parseInt(regionName);\n\n          } catch (NumberFormatException e) {\n            extraFile(otherFiles, \"Old region format can not be upgraded: \" +\n                name, fs, stats[i].getPath());\n          }\n        } else {\n          // Since the new root region directory exists, we assume that this\n          // directory is not necessary\n          extraFile(otherFiles, \"Old region directory found: \" + name, fs,\n              stats[i].getPath());\n        }\n      } else {\n        // File name does not start with \"hregion_\"\n        if (name.startsWith(\"log_\")) {\n          String message = \"Unrecovered region server log file \" + name +\n            \" this file can be recovered by the master when it starts.\"; \n          extraFile(logFiles, message, fs, stats[i].getPath());\n        } else if (!newRootRegion) {\n          // new root region directory does not exist. This is an extra file\n          String message = \"Unrecognized file \" + name;\n          extraFile(otherFiles, message, fs, stats[i].getPath());\n        }\n      }\n    }\n  }","id":25900,"modified_method":"private void extraFiles(FileStatus[] stats) throws IOException {\n    for (int i = 0; i < stats.length; i++) {\n      String name = stats[i].getPath().getName();\n      if (name.startsWith(OLD_PREFIX)) {\n        if (!newRootRegion) {\n          // We need to migrate if the new root region directory doesn't exist\n          migrationNeeded = true;\n          String regionName = name.substring(OLD_PREFIX.length());\n          try {\n            Integer.parseInt(regionName);\n\n          } catch (NumberFormatException e) {\n            extraFile(otherFiles, \"Old region format can not be upgraded: \" +\n                name, stats[i].getPath());\n          }\n        } else {\n          // Since the new root region directory exists, we assume that this\n          // directory is not necessary\n          extraFile(otherFiles, \"Old region directory found: \" + name,\n              stats[i].getPath());\n        }\n      } else {\n        // File name does not start with \"hregion_\"\n        if (!newRootRegion) {\n          // new root region directory does not exist. This is an extra file\n          String message = \"Unrecognized file \" + name;\n          extraFile(otherFiles, message, stats[i].getPath());\n        }\n      }\n    }\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"@SuppressWarnings(\"static-access\")\n  private int parseArgs(String[] args) {\n    Options opts = new Options();\n    Option logFiles = OptionBuilder.withArgName(ACTIONS)\n    .hasArg()\n    .withDescription(\n        \"disposition of unrecovered region server logs: {abort|ignore|delete|prompt}\")\n    .create(\"logfiles\");\n\n    Option extraFiles = OptionBuilder.withArgName(ACTIONS)\n    .hasArg()\n    .withDescription(\"disposition of 'extra' files: {abort|ignore|delete|prompt}\")\n    .create(\"extrafiles\");\n    \n    opts.addOption(logFiles);\n    opts.addOption(extraFiles);\n    \n    GenericOptionsParser parser =\n      new GenericOptionsParser(this.getConf(), opts, args);\n    \n    String[] remainingArgs = parser.getRemainingArgs();\n    if (remainingArgs.length != 1) {\n      usage();\n      return -1;\n    }\n    if (remainingArgs[0].compareTo(\"check\") == 0) {\n      this.readOnly = true;\n    } else if (remainingArgs[0].compareTo(\"upgrade\") != 0) {\n      usage();\n      return -1;\n    }\n\n    if (readOnly) {\n      this.logFiles = ACTION.IGNORE;\n      this.otherFiles = ACTION.IGNORE;\n\n    } else {\n      CommandLine commandLine = parser.getCommandLine();\n\n      ACTION action = null;\n      if (commandLine.hasOption(\"logfiles\")) {\n        action = options.get(commandLine.getOptionValue(\"logfiles\"));\n        if (action == null) {\n          usage();\n          return -1;\n        }\n        this.logFiles = action;\n      }\n      if (commandLine.hasOption(\"extrafiles\")) {\n        action = options.get(commandLine.getOptionValue(\"extrafiles\"));\n        if (action == null) {\n          usage();\n          return -1;\n        }\n        this.otherFiles = action;\n      }\n    }\n    return 0;\n  }","id":25901,"modified_method":"@SuppressWarnings(\"static-access\")\n  private int parseArgs(String[] args) {\n    Options opts = new Options();\n    Option extraFiles = OptionBuilder.withArgName(ACTIONS)\n    .hasArg()\n    .withDescription(\"disposition of 'extra' files: {abort|ignore|delete|prompt}\")\n    .create(\"extrafiles\");\n    \n    opts.addOption(extraFiles);\n    \n    GenericOptionsParser parser =\n      new GenericOptionsParser(this.getConf(), opts, args);\n    \n    String[] remainingArgs = parser.getRemainingArgs();\n    if (remainingArgs.length != 1) {\n      usage();\n      return -1;\n    }\n    if (remainingArgs[0].compareTo(\"check\") == 0) {\n      this.readOnly = true;\n    } else if (remainingArgs[0].compareTo(\"upgrade\") != 0) {\n      usage();\n      return -1;\n    }\n\n    if (readOnly) {\n      this.otherFiles = ACTION.IGNORE;\n\n    } else {\n      CommandLine commandLine = parser.getCommandLine();\n\n      ACTION action = null;\n      if (commandLine.hasOption(\"extrafiles\")) {\n        action = options.get(commandLine.getOptionValue(\"extrafiles\"));\n        if (action == null) {\n          usage();\n          return -1;\n        }\n        this.otherFiles = action;\n      }\n    }\n    return 0;\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Initializes parameters used in the test environment:\n   * \n   * Sets the configuration parameter TEST_DIRECTORY_KEY if not already set.\n   * Sets the boolean debugging if \"DEBUGGING\" is set in the environment.\n   * If debugging is enabled, reconfigures loggin so that the root log level is\n   * set to WARN and the logging level for the package is set to DEBUG.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static void initialize() {\n    String value = null;\n    \n    if (System.getProperty(TEST_DIRECTORY_KEY) == null) {\n      System.setProperty(TEST_DIRECTORY_KEY, new File(\n          \"build/hbase/test\").getAbsolutePath());\n    }\n    \n    value = System.getenv(\"DEBUGGING\");\n    if(value != null && value.equalsIgnoreCase(\"TRUE\")) {\n      debugging = true;\n    }\n      \n    Logger rootLogger = Logger.getRootLogger();\n    rootLogger.setLevel(Level.WARN);\n    \n    Level logLevel = Level.DEBUG;\n    value = System.getenv(\"LOGGING_LEVEL\");\n    if(value != null && value.length() != 0) {\n      if(value.equalsIgnoreCase(\"ALL\")) {\n        logLevel = Level.ALL;\n      } else if(value.equalsIgnoreCase(\"DEBUG\")) {\n        logLevel = Level.DEBUG;\n      } else if(value.equalsIgnoreCase(\"ERROR\")) {\n        logLevel = Level.ERROR;\n      } else if(value.equalsIgnoreCase(\"FATAL\")) {\n        logLevel = Level.FATAL;\n      } else if(value.equalsIgnoreCase(\"INFO\")) {\n        logLevel = Level.INFO;\n      } else if(value.equalsIgnoreCase(\"OFF\")) {\n        logLevel = Level.OFF;\n      } else if(value.equalsIgnoreCase(\"TRACE\")) {\n        logLevel = Level.TRACE;\n      } else if(value.equalsIgnoreCase(\"WARN\")) {\n        logLevel = Level.WARN;\n      }\n    }\n\n    ConsoleAppender consoleAppender = null;\n    for(Enumeration<Appender> e = rootLogger.getAllAppenders();\n    e.hasMoreElements();) {\n\n      Appender a = e.nextElement();\n      if(a instanceof ConsoleAppender) {\n        consoleAppender = (ConsoleAppender)a;\n        break;\n      }\n    }\n    if(consoleAppender != null) {\n      Layout layout = consoleAppender.getLayout();\n      if(layout instanceof PatternLayout) {\n        PatternLayout consoleLayout = (PatternLayout)layout;\n        consoleLayout.setConversionPattern(\"%d %-5p [%t] %C{2}(%L): %m%n\");\n      }\n    }\n    LOG.setLevel(logLevel);\n\n    if (!debugging) {\n      // Turn off all the filter logging unless debug is set.\n      // It is way too noisy.\n      Logger.getLogger(\"org.apache.hadoop.hbase.filter\").setLevel(Level.INFO);\n    }\n    // Enable mapreduce loggging for the mapreduce jobs.\n    Logger.getLogger(\"org.apache.hadoop.mapred\").setLevel(Level.DEBUG);\n  }","id":25902,"modified_method":"/**\n   * Initializes parameters used in the test environment:\n   * \n   * Sets the configuration parameter TEST_DIRECTORY_KEY if not already set.\n   * Sets the boolean debugging if \"DEBUGGING\" is set in the environment.\n   * If debugging is enabled, reconfigures loggin so that the root log level is\n   * set to WARN and the logging level for the package is set to DEBUG.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static void initialize() {\n    String value = null;\n    \n    if (System.getProperty(TEST_DIRECTORY_KEY) == null) {\n      System.setProperty(TEST_DIRECTORY_KEY, new File(\n          \"build/hbase/test\").getAbsolutePath());\n    }\n    \n    value = System.getenv(\"DEBUGGING\");\n    if(value != null && value.equalsIgnoreCase(\"TRUE\")) {\n      debugging = true;\n    }\n      \n    Logger rootLogger = Logger.getRootLogger();\n    rootLogger.setLevel(Level.WARN);\n    \n    Level logLevel = Level.DEBUG;\n    value = System.getenv(\"LOGGING_LEVEL\");\n    if(value != null && value.length() != 0) {\n      if(value.equalsIgnoreCase(\"ALL\")) {\n        logLevel = Level.ALL;\n      } else if(value.equalsIgnoreCase(\"DEBUG\")) {\n        logLevel = Level.DEBUG;\n      } else if(value.equalsIgnoreCase(\"ERROR\")) {\n        logLevel = Level.ERROR;\n      } else if(value.equalsIgnoreCase(\"FATAL\")) {\n        logLevel = Level.FATAL;\n      } else if(value.equalsIgnoreCase(\"INFO\")) {\n        logLevel = Level.INFO;\n      } else if(value.equalsIgnoreCase(\"OFF\")) {\n        logLevel = Level.OFF;\n      } else if(value.equalsIgnoreCase(\"TRACE\")) {\n        logLevel = Level.TRACE;\n      } else if(value.equalsIgnoreCase(\"WARN\")) {\n        logLevel = Level.WARN;\n      }\n    }\n\n    ConsoleAppender consoleAppender = null;\n    for(Enumeration<Appender> e = rootLogger.getAllAppenders();\n    e.hasMoreElements();) {\n\n      Appender a = e.nextElement();\n      if(a instanceof ConsoleAppender) {\n        consoleAppender = (ConsoleAppender)a;\n        break;\n      }\n    }\n    if(consoleAppender != null) {\n      Layout layout = consoleAppender.getLayout();\n      if(layout instanceof PatternLayout) {\n        PatternLayout consoleLayout = (PatternLayout)layout;\n        consoleLayout.setConversionPattern(\"%d %-5p [%t] %C{2}(%L): %m%n\");\n      }\n    }\n    LOG.setLevel(logLevel);\n\n    if (!debugging) {\n      // Turn off all the and connection logging unless debug is set.\n      // It is way too noisy.\n      Logger.getLogger(\"org.apache.hadoop.hbase.filter\").setLevel(Level.INFO);\n      Logger.getLogger(\"org.apache.hadoop.hbase.client\").setLevel(Level.INFO);\n    }\n    // Enable mapreduce loggging for the mapreduce jobs.\n    Logger.getLogger(\"org.apache.hadoop.mapred\").setLevel(Level.DEBUG);\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"/** constructor */\n  public TestBloomFilters() {\n    super();\n    conf.set(\"hbase.hregion.memcache.flush.size\", \"100\");// flush cache every 100 bytes\n    conf.set(\"hbase.regionserver.maxlogentries\", \"90\"); // and roll log too\n  }","id":25903,"modified_method":"/** constructor */\n  public TestBloomFilters() {\n    super();\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Test that specifies explicit parameters for the bloom filter\n   * @throws IOException\n   */\n  public void testExplicitParameters() throws IOException {\n    HTable table = null;\n\n    // Setup\n    \n    HTableDescriptor desc = new HTableDescriptor(getName());\n    BloomFilterDescriptor bloomFilter =\n      new BloomFilterDescriptor(              // if we insert 1000 values\n          BloomFilterDescriptor.BloomFilterType.BLOOMFILTER,  // plain old bloom filter\n          12499,                              // number of bits\n          4                                   // number of hash functions\n      );\n\n    desc.addFamily(\n        new HColumnDescriptor(CONTENTS,               // Column name\n            1,                                        // Max versions\n            HColumnDescriptor.CompressionType.NONE,   // no compression\n            HColumnDescriptor.DEFAULT_IN_MEMORY,      // not in memory\n            HColumnDescriptor.DEFAULT_BLOCK_CACHE_ENABLED,\n            HColumnDescriptor.DEFAULT_MAX_VALUE_LENGTH,\n            bloomFilter\n        )\n    );\n\n    // Create the table\n\n    HBaseAdmin admin = new HBaseAdmin(conf);\n    admin.createTable(desc);\n\n    // Open table\n\n    table = new HTable(conf, desc.getName());\n\n    // Store some values\n\n    for(int i = 0; i < 100; i++) {\n      Text row = rows[i];\n      String value = row.toString();\n      long lockid = table.startUpdate(rows[i]);\n      table.put(lockid, CONTENTS, value.getBytes(HConstants.UTF8_ENCODING));\n      table.commit(lockid);\n    }\n    try {\n      // Give cache flusher and log roller a chance to run\n      // Otherwise we'll never hit the bloom filter, just the memcache\n      Thread.sleep(conf.getLong(HConstants.THREAD_WAKE_FREQUENCY, 10 * 1000) * 2);\n      \n    } catch (InterruptedException e) {\n      // ignore\n    }\n\n    \n    for(int i = 0; i < testKeys.length; i++) {\n      byte[] value = table.get(testKeys[i], CONTENTS);\n      if(value != null && value.length != 0) {\n        LOG.info(\"non existant key: \" + testKeys[i] + \" returned value: \" +\n            new String(value, HConstants.UTF8_ENCODING));\n      }\n    }\n  }","id":25904,"modified_method":"/**\n   * Test that specifies explicit parameters for the bloom filter\n   * @throws IOException\n   */\n  public void testExplicitParameters() throws IOException {\n    HTable table = null;\n\n    // Setup\n    \n    HTableDescriptor desc = new HTableDescriptor(getName());\n    BloomFilterDescriptor bloomFilter =\n      new BloomFilterDescriptor(              // if we insert 1000 values\n          BloomFilterDescriptor.BloomFilterType.BLOOMFILTER,  // plain old bloom filter\n          12499,                              // number of bits\n          4                                   // number of hash functions\n      );\n\n    desc.addFamily(\n        new HColumnDescriptor(CONTENTS,               // Column name\n            1,                                        // Max versions\n            HColumnDescriptor.CompressionType.NONE,   // no compression\n            HColumnDescriptor.DEFAULT_IN_MEMORY,      // not in memory\n            HColumnDescriptor.DEFAULT_BLOCK_CACHE_ENABLED,\n            HColumnDescriptor.DEFAULT_MAX_VALUE_LENGTH,\n            bloomFilter\n        )\n    );\n\n    // Create the table\n\n    HBaseAdmin admin = new HBaseAdmin(conf);\n    admin.createTable(desc);\n\n    // Open table\n\n    table = new HTable(conf, desc.getName());\n\n    // Store some values\n\n    for(int i = 0; i < 100; i++) {\n      Text row = rows[i];\n      String value = row.toString();\n      BatchUpdate b = new BatchUpdate(row);\n      b.put(CONTENTS, value.getBytes(HConstants.UTF8_ENCODING));\n      table.commit(b);\n    }\n    try {\n      // Give cache flusher and log roller a chance to run\n      // Otherwise we'll never hit the bloom filter, just the memcache\n      Thread.sleep(conf.getLong(HConstants.THREAD_WAKE_FREQUENCY, 10 * 1000) * 2);\n      \n    } catch (InterruptedException e) {\n      // ignore\n    }\n\n    \n    for(int i = 0; i < testKeys.length; i++) {\n      byte[] value = table.get(testKeys[i], CONTENTS);\n      if(value != null && value.length != 0) {\n        LOG.info(\"non existant key: \" + testKeys[i] + \" returned value: \" +\n            new String(value, HConstants.UTF8_ENCODING));\n      }\n    }\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Test that uses computed for the bloom filter\n   * @throws IOException\n   */\n  public void testComputedParameters() throws IOException {\n    HTable table = null;\n\n    // Setup\n    \n    HTableDescriptor desc = new HTableDescriptor(getName());\n      \n    BloomFilterDescriptor bloomFilter =\n      new BloomFilterDescriptor(\n          BloomFilterDescriptor.BloomFilterType.BLOOMFILTER,  // plain old bloom filter\n          1000                                  // estimated number of entries\n      );\n    LOG.info(\"vector size: \" + bloomFilter.vectorSize);\n\n    desc.addFamily(\n        new HColumnDescriptor(CONTENTS,               // Column name\n            1,                                        // Max versions\n            HColumnDescriptor.CompressionType.NONE,   // no compression\n            HColumnDescriptor.DEFAULT_IN_MEMORY,      // not in memory\n            HColumnDescriptor.DEFAULT_BLOCK_CACHE_ENABLED,\n            HColumnDescriptor.DEFAULT_MAX_VALUE_LENGTH,\n            bloomFilter\n        )\n    );\n\n    // Create the table\n\n    HBaseAdmin admin = new HBaseAdmin(conf);\n    admin.createTable(desc);\n\n    // Open table\n\n    table = new HTable(conf, desc.getName());\n\n    // Store some values\n\n    for(int i = 0; i < 100; i++) {\n      Text row = rows[i];\n      String value = row.toString();\n      long lockid = table.startUpdate(rows[i]);\n      table.put(lockid, CONTENTS, value.getBytes(HConstants.UTF8_ENCODING));\n      table.commit(lockid);\n    }\n    try {\n      // Give cache flusher and log roller a chance to run\n      // Otherwise we'll never hit the bloom filter, just the memcache\n      Thread.sleep(conf.getLong(HConstants.THREAD_WAKE_FREQUENCY, 10 * 1000) * 2);\n      \n    } catch (InterruptedException e) {\n      // ignore\n    }\n    \n    for(int i = 0; i < testKeys.length; i++) {\n      byte[] value = table.get(testKeys[i], CONTENTS);\n      if(value != null && value.length != 0) {\n        LOG.info(\"non existant key: \" + testKeys[i] + \" returned value: \" +\n            new String(value, HConstants.UTF8_ENCODING));\n      }\n    }\n  }","id":25905,"modified_method":"/**\n   * Test that uses computed for the bloom filter\n   * @throws IOException\n   */\n  public void testComputedParameters() throws IOException {\n    HTable table = null;\n\n    // Setup\n    \n    HTableDescriptor desc = new HTableDescriptor(getName());\n      \n    BloomFilterDescriptor bloomFilter =\n      new BloomFilterDescriptor(\n          BloomFilterDescriptor.BloomFilterType.BLOOMFILTER,  // plain old bloom filter\n          1000                                  // estimated number of entries\n      );\n    LOG.info(\"vector size: \" + bloomFilter.vectorSize);\n\n    desc.addFamily(\n        new HColumnDescriptor(CONTENTS,               // Column name\n            1,                                        // Max versions\n            HColumnDescriptor.CompressionType.NONE,   // no compression\n            HColumnDescriptor.DEFAULT_IN_MEMORY,      // not in memory\n            HColumnDescriptor.DEFAULT_BLOCK_CACHE_ENABLED,\n            HColumnDescriptor.DEFAULT_MAX_VALUE_LENGTH,\n            bloomFilter\n        )\n    );\n\n    // Create the table\n\n    HBaseAdmin admin = new HBaseAdmin(conf);\n    admin.createTable(desc);\n\n    // Open table\n\n    table = new HTable(conf, desc.getName());\n\n    // Store some values\n\n    for(int i = 0; i < 100; i++) {\n      Text row = rows[i];\n      String value = row.toString();\n      BatchUpdate b = new BatchUpdate(row);\n      b.put(CONTENTS, value.getBytes(HConstants.UTF8_ENCODING));\n      table.commit(b);\n    }\n    try {\n      // Give cache flusher and log roller a chance to run\n      // Otherwise we'll never hit the bloom filter, just the memcache\n      Thread.sleep(conf.getLong(HConstants.THREAD_WAKE_FREQUENCY, 10 * 1000) * 2);\n      \n    } catch (InterruptedException e) {\n      // ignore\n    }\n    \n    for(int i = 0; i < testKeys.length; i++) {\n      byte[] value = table.get(testKeys[i], CONTENTS);\n      if(value != null && value.length != 0) {\n        LOG.info(\"non existant key: \" + testKeys[i] + \" returned value: \" +\n            new String(value, HConstants.UTF8_ENCODING));\n      }\n    }\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * @throws IOException\n   */\n  public void testApi() throws IOException {\n    final String tableName = getName();\n\n    // Create table\n    \n    HBaseAdmin admin = new HBaseAdmin(conf);\n    HTableDescriptor tableDesc = new HTableDescriptor(tableName);\n    for (int i = 0; i < columns.length; i++) {\n      tableDesc.addFamily(new HColumnDescriptor(columns[i].toString()));\n    }\n    admin.createTable(tableDesc);\n\n    // Insert values\n    \n    HTable table = new HTable(conf, new Text(getName()));\n\n    for (Map.Entry<Text, SortedMap<Text, byte[]>> row: values.entrySet()) {\n      long lockid = table.startUpdate(row.getKey());\n      for (Map.Entry<Text, byte[]> val: row.getValue().entrySet()) {\n        table.put(lockid, val.getKey(), val.getValue());\n      }\n      table.commit(lockid);\n    }\n\n    HRegion region = null;\n    try {\n      SortedMap<Text, HRegion> regions =\n        cluster.getRegionThreads().get(0).getRegionServer().getOnlineRegions();\n      for (Map.Entry<Text, HRegion> e: regions.entrySet()) {\n        if (!e.getValue().getRegionInfo().isMetaRegion()) {\n          region = e.getValue();\n        }\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n      IOException iox = new IOException(\"error finding region\");\n      iox.initCause(e);\n      throw iox;\n    }\n    @SuppressWarnings(\"null\")\n    HScannerInterface scanner = \n      region.getScanner(columns, startRow, System.currentTimeMillis(), null);\n    try {\n      verify(scanner);\n    } finally {\n      scanner.close();\n    }\n    \n    scanner = table.obtainScanner(columns, startRow);\n    try {\n      verify(scanner);\n    } finally {\n      scanner.close();\n    }\n    scanner = table.obtainScanner(columns, startRow);\n    try {\n      for (Iterator<Map.Entry<HStoreKey, SortedMap<Text, byte[]>>> iterator =\n        scanner.iterator();\n      iterator.hasNext();\n      ) {\n        Map.Entry<HStoreKey, SortedMap<Text, byte[]>> row = iterator.next();\n        HStoreKey key = row.getKey();\n        assertTrue(\"row key\", values.containsKey(key.getRow()));\n\n        SortedMap<Text, byte[]> results = row.getValue();\n        SortedMap<Text, byte[]> columnValues = values.get(key.getRow());\n        assertEquals(columnValues.size(), results.size());\n        for (Map.Entry<Text, byte[]> e: columnValues.entrySet()) {\n          Text column = e.getKey();\n          assertTrue(\"column\", results.containsKey(column));\n          assertTrue(\"value\", Arrays.equals(columnValues.get(column),\n              results.get(column)));\n        }\n      }\n    } finally {\n      scanner.close();\n    }\n  }","id":25906,"modified_method":"/**\n   * @throws IOException\n   */\n  public void testApi() throws IOException {\n    final String tableName = getName();\n\n    // Create table\n    \n    HBaseAdmin admin = new HBaseAdmin(conf);\n    HTableDescriptor tableDesc = new HTableDescriptor(tableName);\n    for (int i = 0; i < columns.length; i++) {\n      tableDesc.addFamily(new HColumnDescriptor(columns[i].toString()));\n    }\n    admin.createTable(tableDesc);\n\n    // Insert values\n    \n    HTable table = new HTable(conf, new Text(getName()));\n\n    for (Map.Entry<Text, SortedMap<Text, byte[]>> row: values.entrySet()) {\n      BatchUpdate b = new BatchUpdate(row.getKey());\n      for (Map.Entry<Text, byte[]> val: row.getValue().entrySet()) {\n        b.put(val.getKey(), val.getValue());\n      }\n      table.commit(b);\n    }\n\n    HRegion region = null;\n    try {\n      Map<Text, HRegion> regions =\n        cluster.getRegionThreads().get(0).getRegionServer().getOnlineRegions();\n      for (Map.Entry<Text, HRegion> e: regions.entrySet()) {\n        if (!e.getValue().getRegionInfo().isMetaRegion()) {\n          region = e.getValue();\n        }\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n      IOException iox = new IOException(\"error finding region\");\n      iox.initCause(e);\n      throw iox;\n    }\n    @SuppressWarnings(\"null\")\n    HScannerInterface scanner = \n      region.getScanner(columns, startRow, System.currentTimeMillis(), null);\n    try {\n      verify(scanner);\n    } finally {\n      scanner.close();\n    }\n    \n    scanner = table.obtainScanner(columns, startRow);\n    try {\n      verify(scanner);\n    } finally {\n      scanner.close();\n    }\n    scanner = table.obtainScanner(columns, startRow);\n    try {\n      for (Iterator<Map.Entry<HStoreKey, SortedMap<Text, byte[]>>> iterator =\n        scanner.iterator();\n      iterator.hasNext();\n      ) {\n        Map.Entry<HStoreKey, SortedMap<Text, byte[]>> row = iterator.next();\n        HStoreKey key = row.getKey();\n        assertTrue(\"row key\", values.containsKey(key.getRow()));\n\n        SortedMap<Text, byte[]> results = row.getValue();\n        SortedMap<Text, byte[]> columnValues = values.get(key.getRow());\n        assertEquals(columnValues.size(), results.size());\n        for (Map.Entry<Text, byte[]> e: columnValues.entrySet()) {\n          Text column = e.getKey();\n          assertTrue(\"column\", results.containsKey(column));\n          assertTrue(\"value\", Arrays.equals(columnValues.get(column),\n              results.get(column)));\n        }\n      }\n    } finally {\n      scanner.close();\n    }\n  }","commit_id":"30e6c8c0705cdeeeceaa28149ecad2e9b67d1cb8","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public PsiElement getOriginalElement() {\n    final PsiClass containingClass = getContainingClass();\n    if (containingClass != null) {\n      final PsiMethod originalMethod = ((PsiClass)containingClass.getOriginalElement()).findMethodBySignature(this, false);\n      if (originalMethod != null) {\n        return originalMethod;\n      }\n    }\n    return this;\n  }","id":25907,"modified_method":"@Override\n  public PsiElement getOriginalElement() {\n    final PsiClass containingClass = getContainingClass();\n    if (containingClass != null) {\n      PsiElement original = containingClass.getOriginalElement();\n      if (original != containingClass) {\n        final PsiMethod originalMethod = ((PsiClass)original).findMethodBySignature(this, false);\n        if (originalMethod != null) {\n          return originalMethod;\n        }\n      }\n    }\n    return this;\n  }","commit_id":"bc2af62065388a544039b9b383d9aa8ecfcec5f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement getOriginalElement() {\n    final PsiClass scriptClass = getScriptClass();\n    if (scriptClass != null) {\n      return scriptClass.getOriginalElement();\n    }\n    return this;\n  }","id":25908,"modified_method":"public PsiElement getOriginalElement() {\n    final PsiClass scriptClass = getScriptClass();\n    if (scriptClass != null) {\n      final PsiElement originalElement = scriptClass.getOriginalElement();\n      if (originalElement != scriptClass) {\n        return originalElement.getContainingFile();\n      }\n    }\n    return this;\n  }","commit_id":"7ecc1df1078191b9bb2bcdf602e90fdb7a708534","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isDeprecated() {\n    final GrTypeDefinitionStub stub = getStub();\n    if (stub != null) {\n      return stub.isDeprecatedByDoc() || com.intellij.psi.impl.PsiImplUtil.isDeprecatedByAnnotation(this);\n    }\n    return com.intellij.psi.impl.PsiImplUtil.isDeprecatedByDocTag(this) || com.intellij.psi.impl.PsiImplUtil.isDeprecatedByAnnotation(this);\n  }","id":25909,"modified_method":"@Override\n  public boolean isDeprecated() {\n    final GrTypeDefinitionStub stub = getStub();\n    if (stub != null) {\n      return stub.isDeprecatedByDoc() || PsiImplUtil.isDeprecatedByAnnotation(this);\n    }\n    return PsiImplUtil.isDeprecatedByDocTag(this) || PsiImplUtil.isDeprecatedByAnnotation(this);\n  }","commit_id":"2fe5331563f02c4b4759297c7618b1cb539e2ab5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String getName() {\n    final GrTypeDefinitionStub stub = getStub();\n    if (stub != null) {\n      return stub.getName();\n    }\n    return PsiImplUtil.getName(this);\n  }","id":25910,"modified_method":"@Override\n  public String getName() {\n    final GrTypeDefinitionStub stub = getStub();\n    if (stub != null) {\n      return stub.getName();\n    }\n    return org.jetbrains.plugins.groovy.lang.psi.impl.PsiImplUtil.getName(this);\n  }","commit_id":"2fe5331563f02c4b4759297c7618b1cb539e2ab5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public PsiElement getOriginalElement() {\n    return PsiImplUtil.getOriginalElement(this, getContainingFile());\n  }","id":25911,"modified_method":"@Nullable\n  @Override\n  public PsiElement getOriginalElement() {\n    return org.jetbrains.plugins.groovy.lang.psi.impl.PsiImplUtil.getOriginalElement(this, getContainingFile());\n  }","commit_id":"2fe5331563f02c4b4759297c7618b1cb539e2ab5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiElement setName(@NonNls @NotNull String name) throws IncorrectOperationException {\n    boolean renameFile = isRenameFileOnClassRenaming();\n\n    final String oldName = getName();\n    PsiImplUtil.setName(name, getNameIdentifierGroovy());\n\n    final GrTypeDefinitionBody body = getBody();\n    if (body != null) {\n      for (PsiMethod method : body.getMethods()) {\n        if (method.isConstructor() && method.getName().equals(oldName)) method.setName(name);\n      }\n    }\n\n    if (renameFile) {\n      final PsiFile file = getContainingFile();\n      final VirtualFile virtualFile = file.getVirtualFile();\n      final String ext;\n      if (virtualFile != null) {\n        ext = virtualFile.getExtension();\n      } else {\n        ext = GroovyFileType.GROOVY_FILE_TYPE.getDefaultExtension();\n      }\n      file.setName(name + \".\" + ext);\n    }\n\n    return this;\n  }","id":25912,"modified_method":"@Override\n  public PsiElement setName(@NonNls @NotNull String name) throws IncorrectOperationException {\n    boolean renameFile = isRenameFileOnClassRenaming();\n\n    final String oldName = getName();\n    org.jetbrains.plugins.groovy.lang.psi.impl.PsiImplUtil.setName(name, getNameIdentifierGroovy());\n\n    final GrTypeDefinitionBody body = getBody();\n    if (body != null) {\n      for (PsiMethod method : body.getMethods()) {\n        if (method.isConstructor() && method.getName().equals(oldName)) method.setName(name);\n      }\n    }\n\n    if (renameFile) {\n      final PsiFile file = getContainingFile();\n      final VirtualFile virtualFile = file.getVirtualFile();\n      final String ext;\n      if (virtualFile != null) {\n        ext = virtualFile.getExtension();\n      } else {\n        ext = GroovyFileType.GROOVY_FILE_TYPE.getDefaultExtension();\n      }\n      file.setName(name + \".\" + ext);\n    }\n\n    return this;\n  }","commit_id":"2fe5331563f02c4b4759297c7618b1cb539e2ab5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void checkMaxChallenges(Integer count)\n\t\tthrows CaptchaMaxChallengesException {\n\n\t\tif ((count != null) && (count > PropsValues.CAPTCHA_MAX_CHALLENGES)) {\n\t\t\tthrow new CaptchaMaxChallengesException();\n\t\t}\n\t}","id":25913,"modified_method":"protected boolean isMaxChallenges(Integer count) {\n\n\t\tif ((count != null) && (count >= PropsValues.CAPTCHA_MAX_CHALLENGES)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"1bb5a371ee59582eb090ca610f49b7150a76fec4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void check(PortletRequest portletRequest) throws CaptchaException {\n\t\tif (!isEnabled(portletRequest)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!validateChallenge(portletRequest)) {\n\t\t\tincrementCounter(portletRequest);\n\n\t\t\tcheckMaxChallenges(portletRequest);\n\n\t\t\tthrow new CaptchaTextException();\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"CAPTCHA text is valid\");\n\t\t}\n\t}","id":25914,"modified_method":"@Override\n\tpublic void check(PortletRequest portletRequest) throws CaptchaException {\n\t\tif (!isEnabled(portletRequest)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!validateChallenge(portletRequest)) {\n\t\t\tthrow new CaptchaTextException();\n\t\t}\n\t\telse {\n\t\t\tincrementCounter(portletRequest);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"CAPTCHA text is valid\");\n\t\t}\n\t}","commit_id":"1bb5a371ee59582eb090ca610f49b7150a76fec4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean isEnabled(HttpServletRequest request)\n\t\tthrows CaptchaException {\n\n\t\tcheckMaxChallenges(request);\n\n\t\tif (PropsValues.CAPTCHA_MAX_CHALLENGES >= 0) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","id":25915,"modified_method":"@Override\n\tpublic boolean isEnabled(HttpServletRequest request) {\n\n\t\tif (isMaxChallenges(request)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (PropsValues.CAPTCHA_MAX_CHALLENGES >= 0) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"1bb5a371ee59582eb090ca610f49b7150a76fec4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void check(HttpServletRequest request) throws CaptchaException {\n\t\tif (!isEnabled(request)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!validateChallenge(request)) {\n\t\t\tincrementCounter(request);\n\n\t\t\tcheckMaxChallenges(request);\n\n\t\t\tthrow new CaptchaTextException();\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"CAPTCHA text is valid\");\n\t\t}\n\t}","id":25916,"modified_method":"@Override\n\tpublic void check(HttpServletRequest request) throws CaptchaException {\n\t\tif (!isEnabled(request)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!validateChallenge(request)) {\n\t\t\tthrow new CaptchaTextException();\n\t\t}\n\t\telse {\n\t\t\tincrementCounter(request);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"CAPTCHA text is valid\");\n\t\t}\n\t}","commit_id":"1bb5a371ee59582eb090ca610f49b7150a76fec4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void checkMaxChallenges(PortletRequest portletRequest)\n\t\tthrows CaptchaMaxChallengesException {\n\n\t\tif (PropsValues.CAPTCHA_MAX_CHALLENGES > 0) {\n\t\t\tPortletSession portletSession = portletRequest.getPortletSession();\n\n\t\t\tInteger count = (Integer)portletSession.getAttribute(\n\t\t\t\tWebKeys.CAPTCHA_COUNT);\n\n\t\t\tcheckMaxChallenges(count);\n\t\t}\n\t}","id":25917,"modified_method":"protected boolean isMaxChallenges(PortletRequest portletRequest) {\n\n\t\tif (PropsValues.CAPTCHA_MAX_CHALLENGES > 0) {\n\t\t\tPortletSession portletSession = portletRequest.getPortletSession();\n\n\t\t\tInteger count = (Integer)portletSession.getAttribute(\n\t\t\t\tWebKeys.CAPTCHA_COUNT);\n\n\t\t\treturn isMaxChallenges(count);\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"1bb5a371ee59582eb090ca610f49b7150a76fec4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void checkMaxChallenges(HttpServletRequest request)\n\t\tthrows CaptchaMaxChallengesException {\n\n\t\tif (PropsValues.CAPTCHA_MAX_CHALLENGES > 0) {\n\t\t\tHttpSession session = request.getSession();\n\n\t\t\tInteger count = (Integer)session.getAttribute(\n\t\t\t\tWebKeys.CAPTCHA_COUNT);\n\n\t\t\tcheckMaxChallenges(count);\n\t\t}\n\t}","id":25918,"modified_method":"protected boolean isMaxChallenges(HttpServletRequest request) {\n\t\tif (PropsValues.CAPTCHA_MAX_CHALLENGES > 0) {\n\t\t\tHttpSession session = request.getSession();\n\n\t\t\tInteger count = (Integer)session.getAttribute(\n\t\t\t\tWebKeys.CAPTCHA_COUNT);\n\n\t\t\treturn isMaxChallenges(count);\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"1bb5a371ee59582eb090ca610f49b7150a76fec4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean isEnabled(PortletRequest portletRequest)\n\t\tthrows CaptchaException {\n\n\t\tcheckMaxChallenges(portletRequest);\n\n\t\tif (PropsValues.CAPTCHA_MAX_CHALLENGES >= 0) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","id":25919,"modified_method":"@Override\n\tpublic boolean isEnabled(PortletRequest portletRequest) {\n\n\t\tif (isMaxChallenges(portletRequest)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (PropsValues.CAPTCHA_MAX_CHALLENGES >= 0) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"1bb5a371ee59582eb090ca610f49b7150a76fec4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    protected void doConfigure(MuleContext muleContext) throws Exception\n    {\n        MuleRegistry registry = muleContext.getRegistry();\n\n        registry.registerObject(MuleProperties.OBJECT_MULE_SIMPLE_REGISTRY_BOOTSTRAP,\n            new SimpleRegistryBootstrap());\n\n        configureQueueManager(muleContext);\n\n        registry.registerObject(MuleProperties.OBJECT_SECURITY_MANAGER, new MuleSecurityManager());\n\n        registry.registerObject(MuleProperties.OBJECT_STORE_DEFAULT_IN_MEMORY_NAME, DefaultObjectStoreFactoryBean.createDefaultInMemoryObjectStore());\n        registry.registerObject(MuleProperties.OBJECT_STORE_DEFAULT_PERSISTENT_NAME, DefaultObjectStoreFactoryBean.createDefaultPersistentObjectStore());\n        registry.registerObject(MuleProperties.QUEUE_STORE_DEFAULT_IN_MEMORY_NAME, DefaultObjectStoreFactoryBean.createDefaultInMemoryQueueStore());\n        registry.registerObject(MuleProperties.QUEUE_STORE_DEFAULT_PERSISTENT_NAME, DefaultObjectStoreFactoryBean.createDefaultPersistentQueueStore());\n        registry.registerObject(MuleProperties.DEFAULT_USER_OBJECT_STORE_NAME, DefaultObjectStoreFactoryBean.createDefaultUserObjectStore());\n        registry.registerObject(MuleProperties.OBJECT_STORE_MANAGER, new MuleObjectStoreManager());\n\n        registry.registerObject(MuleProperties.OBJECT_MULE_ENDPOINT_FACTORY, new DefaultEndpointFactory());\n        registry.registerObject(MuleProperties.OBJECT_MULE_STREAM_CLOSER_SERVICE, new DefaultStreamCloserService());\n\n        configureThreadingProfiles(registry);\n\n        registry.registerObject(MuleProperties.OBJECT_DEFAULT_RETRY_POLICY_TEMPLATE, new NoRetryPolicyTemplate());\n        registry.registerObject(MuleProperties.OBJECT_CONVERTER_RESOLVER, new DynamicDataTypeConversionResolver(muleContext));\n\n        configureSystemModel(registry);\n        \n        registry.registerObject(MuleProperties.OBJECT_EXPRESSION_LANGUAGE, new MVELExpressionLanguage(muleContext));\n    }","id":25920,"modified_method":"@Override\n    protected void doConfigure(MuleContext muleContext) throws Exception\n    {\n        MuleRegistry registry = muleContext.getRegistry();\n\n        registry.registerObject(MuleProperties.OBJECT_MULE_SIMPLE_REGISTRY_BOOTSTRAP,\n            new SimpleRegistryBootstrap());\n\n        configureQueueManager(muleContext);\n\n        registry.registerObject(MuleProperties.OBJECT_SECURITY_MANAGER, new MuleSecurityManager());\n\n        registry.registerObject(MuleProperties.OBJECT_STORE_DEFAULT_IN_MEMORY_NAME, DefaultObjectStoreFactoryBean.createDefaultInMemoryObjectStore());\n        registry.registerObject(MuleProperties.OBJECT_STORE_DEFAULT_PERSISTENT_NAME, DefaultObjectStoreFactoryBean.createDefaultPersistentObjectStore());\n        registry.registerObject(MuleProperties.QUEUE_STORE_DEFAULT_IN_MEMORY_NAME, DefaultObjectStoreFactoryBean.createDefaultInMemoryQueueStore());\n        registry.registerObject(MuleProperties.QUEUE_STORE_DEFAULT_PERSISTENT_NAME, DefaultObjectStoreFactoryBean.createDefaultPersistentQueueStore());\n        registry.registerObject(MuleProperties.DEFAULT_USER_OBJECT_STORE_NAME, DefaultObjectStoreFactoryBean.createDefaultUserObjectStore());\n        registry.registerObject(MuleProperties.OBJECT_STORE_MANAGER, new MuleObjectStoreManager());\n        registry.registerObject(MuleProperties.OBJECT_STORE_DEFAULT_LOCKER, new MuleServerEntryLocker());\n        registry.registerObject(MuleProperties.OBJECT_MULE_ENDPOINT_FACTORY, new DefaultEndpointFactory());\n        registry.registerObject(MuleProperties.OBJECT_MULE_STREAM_CLOSER_SERVICE, new DefaultStreamCloserService());\n\n        configureThreadingProfiles(registry);\n\n        registry.registerObject(MuleProperties.OBJECT_DEFAULT_RETRY_POLICY_TEMPLATE, new NoRetryPolicyTemplate());\n        registry.registerObject(MuleProperties.OBJECT_CONVERTER_RESOLVER, new DynamicDataTypeConversionResolver(muleContext));\n\n        configureSystemModel(registry);\n        \n        registry.registerObject(MuleProperties.OBJECT_EXPRESSION_LANGUAGE, new MVELExpressionLanguage(muleContext));\n    }","commit_id":"5721c349e5e4ea76958575a9bf07d7bc4b21165b","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public void dispose()\n    {\n        super.dispose();\n\n        if (store != null)\n        {\n            store.dispose();\n            store = null;\n        }\n\n        if (deadLetterQueue instanceof Disposable)\n        {\n            ((Disposable) deadLetterQueue).dispose();\n        }\n    }","id":25921,"modified_method":"@Override\n    public void dispose()\n    {\n        super.dispose();\n\n        if (store != null)\n        {\n            if (store instanceof ObjectStorePartition)\n            {\n                try\n                {\n                    ((ObjectStorePartition)store).close();\n                }\n                catch (ObjectStoreException e)\n                {\n                    logger.warn(\"error closing object store: \" + e.getMessage(), e);\n                }\n            }\n            store = null;\n        }\n\n        if (deadLetterQueue instanceof Disposable)\n        {\n            ((Disposable) deadLetterQueue).dispose();\n        }\n    }","commit_id":"5721c349e5e4ea76958575a9bf07d7bc4b21165b","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        boolean exceptionSeen = false;\n        boolean tooMany = false;\n        AtomicInteger counter = null;\n\n        String messageId = null;\n        try\n        {\n            messageId = getIdForEvent(event);\n        }\n        catch (TransformerException e)\n        {\n            logger.warn(\"The message cannot be processed because the digest could not be generated. Either make the payload serializable or use an expression.\");\n            return null;\n        }\n        catch (Exception ex)\n        {\n            exceptionSeen = true;\n        }\n\n        if (!exceptionSeen)\n        {\n            counter = getCounter(messageId, null, false);\n            tooMany = counter != null && counter.get() > maxRedeliveryCount;\n        }\n\n        if (tooMany || exceptionSeen)\n        {\n            try\n            {\n                if (deadLetterQueue != null)\n                {\n                    return deadLetterQueue.process(event);\n                }\n                else\n                {\n                    throw new MessageRedeliveredException(messageId,counter.get(),maxRedeliveryCount,null,event);\n                }\n            }\n            catch (MessageRedeliveredException ex)\n            {\n                throw ex;\n            }\n            catch (Exception ex)\n            {\n                logger.info(\"Exception thrown from failed message processing for message \" + messageId, ex);\n            }\n            return null;\n        }\n\n        try\n        {\n            MuleEvent returnEvent = processNext(event);\n            counter = getCounter(messageId, counter, false);\n            if (counter != null)\n            {\n                counter.set(0);\n            }\n            return returnEvent;\n        }\n        catch (MuleException ex)\n        {\n            incrementCounter(messageId, counter);\n            throw ex;\n        }\n        catch (RuntimeException ex)\n        {\n            incrementCounter(messageId, counter);\n            throw ex;\n        }\n    }","id":25922,"modified_method":"@Override\n    public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        boolean exceptionSeen = false;\n        boolean tooMany = false;\n        AtomicInteger counter = null;\n\n        String messageId = null;\n        try\n        {\n            messageId = getIdForEvent(event);\n        }\n        catch (TransformerException e)\n        {\n            logger.warn(\"The message cannot be processed because the digest could not be generated. Either make the payload serializable or use an expression.\");\n            return null;\n        }\n        catch (Exception ex)\n        {\n            exceptionSeen = true;\n        }\n\n        try\n        {\n            store.lockEntry(messageId);\n\n            if (!exceptionSeen)\n            {\n                counter = findCounter(messageId);\n                tooMany = counter != null && counter.get() > maxRedeliveryCount;\n            }\n\n            if (tooMany || exceptionSeen)\n            {\n                try\n                {\n                    if (deadLetterQueue != null)\n                    {\n                        return deadLetterQueue.process(event);\n                    }\n                    else\n                    {\n                        throw new MessageRedeliveredException(messageId,counter.get(),maxRedeliveryCount,null,event);\n                    }\n                }\n                catch (MessageRedeliveredException ex)\n                {\n                    throw ex;\n                }\n                catch (Exception ex)\n                {\n                    logger.info(\"Exception thrown from failed message processing for message \" + messageId, ex);\n                }\n                return null;\n            }\n\n            try\n            {\n                MuleEvent returnEvent = processNext(event);\n                counter = findCounter(messageId);\n                if (counter != null)\n                {\n                    resetCounter(messageId);\n                }\n                return returnEvent;\n            }\n            catch (MuleException ex)\n            {\n                incrementCounter(messageId);\n                throw ex;\n            }\n            catch (RuntimeException ex)\n            {\n                incrementCounter(messageId);\n                throw ex;\n            }\n        }\n        finally\n        {\n            store.releaseEntry(messageId);\n        }\n    }","commit_id":"5721c349e5e4ea76958575a9bf07d7bc4b21165b","url":"https://github.com/mulesoft/mule"},{"original_method":"private AbstractMonitoredObjectStore<AtomicInteger> createStore() throws InitialisationException\n    {\n        AbstractMonitoredObjectStore s = new InMemoryObjectStore<AtomicInteger>();\n        s.setName(flowConstruct.getName() + \".\" + getClass().getName());\n        s.setMaxEntries(-1);\n        s.setEntryTTL(60 * 5 * 1000);\n        s.setExpirationInterval(6000);\n        s.initialise();\n        return s;\n    }","id":25923,"modified_method":"private LockableObjectStore<AtomicInteger> createStore() throws InitialisationException\n    {\n        ObjectStoreManager objectStoreManager = (ObjectStoreManager) muleContext.getRegistry().get(\n                                MuleProperties.OBJECT_STORE_MANAGER);\n        return objectStoreManager.getLockableObjectStore(objectStoreManager.getObjectStore(flowConstruct.getName() + \".\" + getClass().getName(),\n                OBJECT_STORE_NO_PERSISTENCE, OBJECT_STORE_NO_ENTRY_LIMIT, OBJECT_STORE_FIVE_MINUTES_TTL, OBJECT_STORE_EXPIRATION_INTERVAL));\n    }","commit_id":"5721c349e5e4ea76958575a9bf07d7bc4b21165b","url":"https://github.com/mulesoft/mule"},{"original_method":"private AtomicInteger incrementCounter(String messageId, AtomicInteger counter) throws ObjectStoreException\n    {\n        counter = getCounter(messageId,  counter, true);\n        counter.incrementAndGet();\n        return counter;\n    }","id":25924,"modified_method":"private AtomicInteger incrementCounter(String messageId) throws ObjectStoreException\n    {\n        AtomicInteger counter = findCounter(messageId);\n        if (counter == null)\n        {\n            counter = new AtomicInteger();\n        }\n        else\n        {\n            store.remove(messageId);\n        }\n        counter.incrementAndGet();\n        store.store(messageId,counter);\n        return counter;\n    }","commit_id":"5721c349e5e4ea76958575a9bf07d7bc4b21165b","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void messageDigestFailure() throws Exception\n    {\n        IdempotentRedeliveryPolicy irp = new IdempotentRedeliveryPolicy();\n        irp.setUseSecureHash(true);\n        irp.setFlowConstruct(mock(FlowConstruct.class));\n        irp.initialise();\n\n        MuleMessage message = mock(MuleMessage.class);\n        when(message.getPayload()).thenReturn(new Object());\n        MuleEvent event = mock(MuleEvent.class);\n        when(event.getMessage()).thenReturn(message);\n        MuleEvent process = irp.process(event);\n        Assert.assertNull(process);\n    }","id":25925,"modified_method":"@Test\n    public void messageDigestFailure() throws Exception\n    {\n        when(message.getPayload()).thenReturn(new Object());\n        irp.initialise();\n        MuleEvent process = irp.process(event);\n        Assert.assertNull(process);\n    }","commit_id":"5721c349e5e4ea76958575a9bf07d7bc4b21165b","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n * @return int\n * @param tableName java.lang.String\n * @param conn java.sql.Connection\n * @exception java.sql.SQLException\n */\nprivate int getCurrentCounterValue(String tableName, Connection conn)\nthrows SQLException\n{\n    ResultSet rs = null;\n    RDBMServices.PreparedStatement ps = null;\n    try\n    {\n        ps = new RDBMServices.PreparedStatement( conn, getSelectCounterSql() );\n        try\n        {\n            ps.setString(1, tableName);\n            LogService.instance().log(LogService.DEBUG,\n                \"ReferenceSequenceGenerator.getNextInt(): \" + ps + \"(\" + tableName + \")\");\n            rs = ps.executeQuery();\n            int currentInt = ( rs.next() ) ? rs.getInt(VALUE_COLUMN) : NO_COUNTER_VALUE;\n            return currentInt;\n        }\n        finally\n        {\n            if ( rs != null )\n                { rs.close(); }\n        }\n    }\n\n    finally\n    {\n        if ( ps != null )\n            { ps.close(); }\n    }\n}","id":25926,"modified_method":"/**\n * @return int\n * @param tableName java.lang.String\n * @param conn java.sql.Connection\n * @exception java.sql.SQLException\n */\nprivate int getCurrentCounterValue(String tableName, Connection conn)\nthrows SQLException\n{\n    ResultSet rs = null;\n    RDBMServices.PreparedStatement ps = null;\n    try\n    {\n        ps = new RDBMServices.PreparedStatement( conn, getSelectCounterSql() );\n        try\n        {\n            ps.setString(1, tableName);\n            LogService.instance().log(LogService.DEBUG,\n                \"ReferenceSequenceGenerator.getNextInt(): \" + ps + \" (\" + tableName + \")\");\n            rs = ps.executeQuery();\n            int currentInt = ( rs.next() ) ? rs.getInt(VALUE_COLUMN) : NO_COUNTER_VALUE;\n            return currentInt;\n        }\n        finally\n        {\n            if ( rs != null )\n                { rs.close(); }\n        }\n    }\n\n    finally\n    {\n        if ( ps != null )\n            { ps.close(); }\n    }\n}","commit_id":"90b79c66800fa5d9ade12c4ba878ffb9f4fa814a","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n * @param tableName java.lang.String\n * @exception java.lang.SQLException\n */\nprivate void createCounter (String tableName, Connection conn) throws SQLException\n{\n    Statement stmt = null;\n    try\n    {\n        stmt = conn.createStatement();\n        String sql = getCreateCounterSql(tableName);\n\n        LogService.instance().log\n            (LogService.DEBUG, \"ReferenceSequenceGenerator.createCounter: \" + sql);\n\n        stmt.executeUpdate(getCreateCounterSql(tableName));\n    }\n    catch ( SQLException sqle )\n    {\n        LogService.instance().log\n            (LogService.ERROR, \"ReferenceSequenceGenerator::createCounter(): \" + sqle.getMessage());\n        throw sqle;\n    }\n    finally\n    {\n        if ( stmt != null )\n            { stmt.close(); }\n    }\n}","id":25927,"modified_method":"/**\n * @param tableName java.lang.String\n * @exception java.lang.SQLException\n */\nprivate void createCounter (String tableName, Connection conn) throws SQLException\n{\n    Statement stmt = null;\n    try\n    {\n        stmt = conn.createStatement();\n        String sql = getCreateCounterSql(tableName);\n\n        LogService.instance().log\n            (LogService.DEBUG, \"ReferenceSequenceGenerator.createCounter: \" + sql);\n\n        int rc = stmt.executeUpdate(getCreateCounterSql(tableName));\n        if (rc != 1)\n            { throw new DataIntegrityException(\"Data integrity error; could not update counter.\"); }\n\n    }\n    catch ( SQLException sqle )\n    {\n        LogService.instance().log\n            (LogService.ERROR, \"ReferenceSequenceGenerator::createCounter(): \" + sqle.getMessage());\n        throw sqle;\n    }\n    finally\n    {\n        if ( stmt != null )\n            { stmt.close(); }\n    }\n}","commit_id":"90b79c66800fa5d9ade12c4ba878ffb9f4fa814a","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n * @param tableName java.lang.String\n * @param current int\n * @param conn java.sql.Connection\n * @exception java.sql.SQLException\n */\nprivate void incrementCounter(String tableName, int currentCounterValue, Connection conn)\nthrows SQLException\n{\n    RDBMServices.PreparedStatement ps = null;\n    int nextCounterValue = currentCounterValue + 1;\n    try\n    {\n        ps = new RDBMServices.PreparedStatement( conn, getUpdateCounterForIncrementSql() );\n        try\n        {\n            ps.setInt(1, nextCounterValue);\n            ps.setString(2, tableName);\n            ps.setInt(3, currentCounterValue);\n            LogService.instance().log(LogService.DEBUG,\n                \"ReferenceSequenceGenerator.incrementCounter(): \" + ps +\n                  \"(\" + nextCounterValue + \", \" + tableName + \", \" + currentCounterValue + \")\");\n            int rc = ps.executeUpdate();\n            if (rc != 1)\n                { throw new SQLException(\"Data integrity error; could not update counter.\"); }\n        }\n        catch (SQLException sqle)\n        {\n            LogService.instance().log(LogService.ERROR, sqle.getMessage());\n            throw sqle;\n        }\n    }\n\n    finally\n    {\n        if ( ps != null )\n            { ps.close(); }\n    }\n}","id":25928,"modified_method":"/**\n * Try to increment the counter for <code>tableName<\/code>.  If we catch a\n * <code>DataIntegrityException<\/code> -- which probably means some other\n * process is trying to increment the counter at the same time -- try again,\n * up to 5 times.  That should do it.\n *\n * @param tableName java.lang.String\n * @param current int\n * @param conn java.sql.Connection\n * @exception java.sql.SQLException\n */\nprivate int incrementCounter(String tableName, int currentCounterValue, Connection conn)\nthrows SQLException\n{\n    int current = currentCounterValue;\n    boolean incremented=false;\n    for (int i=0; i<5 && ! incremented; i++)\n    {\n        try\n        {\n            primIncrementCounter(tableName, current, conn);\n            incremented = true;\n        }\n        catch ( DataIntegrityException die )\n        {\n            current = getCurrentCounterValue(tableName, conn);\n        }\n    }\n    if ( incremented )\n        { return ++current; }\n    else\n        { throw new DataIntegrityException(\"Could not increment counter.\"); }\n}","commit_id":"90b79c66800fa5d9ade12c4ba878ffb9f4fa814a","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n * Increments the counter and returns the incremented value.  If the counter\n * does not exist, creates and then increments it to verify that it has been\n * created successfully.\n * @return int\n * @param tableName java.lang.String\n * @exception java.lang.Exception\n */\npublic synchronized int getNextInt(String tableName) throws Exception\n{\n    Connection conn = null;\n    try\n    {\n        conn = RDBMServices.getConnection();\n        int current = getCurrentCounterValue(tableName, conn);\n\n        if ( current == NO_COUNTER_VALUE )\n        {\n            createCounter(tableName, conn);\n            current = INITIAL_COUNTER_VALUE;\n        }\n\n        incrementCounter(tableName, current, conn);\n        return ++current;\n    }\n\n    catch ( SQLException sqle )\n    {\n        LogService.instance().log\n            (LogService.ERROR, \"ReferenceSequenceGenerator::incrementCounter(): \" + sqle.getMessage());\n        throw sqle;\n    }\n\n    finally\n        { RDBMServices.releaseConnection(conn); }\n}","id":25929,"modified_method":"/**\n * Increments the counter and returns the incremented value.  If the counter\n * does not exist, creates and then increments it to verify that it has been\n * created successfully.\n * @return int\n * @param tableName java.lang.String\n * @exception java.lang.Exception\n */\npublic synchronized int getNextInt(String tableName) throws Exception\n{\n    Connection conn = null;\n    try\n    {\n        conn = RDBMServices.getConnection();\n        int current = getCurrentCounterValue(tableName, conn);\n\n        if ( current == NO_COUNTER_VALUE )\n        {\n            createCounter(tableName, conn);\n            current = INITIAL_COUNTER_VALUE;\n        }\n\n        return incrementCounter(tableName, current, conn);\n    }\n\n    catch ( SQLException sqle )\n    {\n        LogService.instance().log\n            (LogService.ERROR, \"ReferenceSequenceGenerator.getNextInt(): \" + sqle.getMessage());\n        throw sqle;\n    }\n\n    finally\n        { RDBMServices.releaseConnection(conn); }\n}","commit_id":"90b79c66800fa5d9ade12c4ba878ffb9f4fa814a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public static void insertParentheses(final InsertionContext context,\n                                       final LookupElement item,\n                                       boolean overloadsMatter,\n                                       boolean hasParams,\n                                       final boolean forceClosingParenthesis) {\n    final Editor editor = context.getEditor();\n    final char completionChar = context.getCompletionChar();\n    final PsiFile file = context.getFile();\n\n    final TailType tailType = completionChar == '(' ? TailType.NONE :\n                              completionChar == ':' ? TailType.COND_EXPR_COLON :\n                              LookupItem.handleCompletionChar(context.getEditor(), item, completionChar);\n    final boolean hasTail = tailType != TailType.NONE && tailType != TailType.UNKNOWN;\n    final boolean smart = completionChar == Lookup.COMPLETE_STATEMENT_SELECT_CHAR;\n\n    if (completionChar == '(' || completionChar == '.' || completionChar == ',' || completionChar == ';' || completionChar == ':' || completionChar == ' ') {\n      context.setAddCompletionChar(false);\n    }\n\n    final boolean needRightParenth = forceClosingParenthesis || !smart && (CodeInsightSettings.getInstance().AUTOINSERT_PAIR_BRACKET || hasTail);\n    if (hasTail) {\n      hasParams = false;\n    }\n\n    PsiDocumentManager.getInstance(context.getProject()).commitDocument(context.getDocument());\n\n    final CommonCodeStyleSettings styleSettings = context.getCodeStyleSettings();\n    ParenthesesInsertHandler.getInstance(hasParams,\n                                         styleSettings.SPACE_BEFORE_METHOD_CALL_PARENTHESES,\n                                         styleSettings.SPACE_WITHIN_METHOD_CALL_PARENTHESES && hasParams,\n                                         needRightParenth,\n                                         styleSettings.METHOD_PARAMETERS_LPAREN_ON_NEXT_LINE\n    ).handleInsert(context, item);\n\n    if (hasParams) {\n      // Invoke parameters popup\n      AutoPopupController.getInstance(file.getProject()).autoPopupParameterInfo(editor, overloadsMatter ? null : (PsiElement)item.getObject());\n    }\n\n    if (smart || !needRightParenth || !insertTail(context, item, tailType, hasTail)) {\n      return;\n    }\n\n    if (completionChar == '.') {\n      AutoPopupController.getInstance(file.getProject()).autoPopupMemberLookup(context.getEditor(), null);\n    } else if (completionChar == ',') {\n      AutoPopupController.getInstance(file.getProject()).autoPopupParameterInfo(context.getEditor(), null);\n    }\n  }","id":25930,"modified_method":"public static void insertParentheses(final InsertionContext context,\n                                       final LookupElement item,\n                                       boolean overloadsMatter,\n                                       boolean hasParams,\n                                       final boolean forceClosingParenthesis) {\n    final Editor editor = context.getEditor();\n    final char completionChar = context.getCompletionChar();\n    final PsiFile file = context.getFile();\n\n    final TailType tailType = completionChar == '(' ? TailType.NONE :\n                              completionChar == ':' ? TailType.COND_EXPR_COLON :\n                              LookupItem.handleCompletionChar(context.getEditor(), item, completionChar);\n    final boolean hasTail = tailType != TailType.NONE && tailType != TailType.UNKNOWN;\n    final boolean smart = completionChar == Lookup.COMPLETE_STATEMENT_SELECT_CHAR;\n\n    if (completionChar == '(' || completionChar == '.' || completionChar == ',' || completionChar == ';' || completionChar == ':' || completionChar == ' ') {\n      context.setAddCompletionChar(false);\n    }\n\n    final boolean needRightParenth = forceClosingParenthesis || !smart && (CodeInsightSettings.getInstance().AUTOINSERT_PAIR_BRACKET || hasTail);\n    if (hasTail) {\n      hasParams = false;\n    }\n\n    PsiDocumentManager.getInstance(context.getProject()).commitDocument(context.getDocument());\n\n    final CommonCodeStyleSettings styleSettings = context.getCodeStyleSettings();\n    final PsiElement elementAt = file.findElementAt(context.getStartOffset());\n    if (elementAt == null || !(elementAt.getParent() instanceof PsiMethodReferenceExpression)) {\n      ParenthesesInsertHandler.getInstance(hasParams,\n                                           styleSettings.SPACE_BEFORE_METHOD_CALL_PARENTHESES,\n                                           styleSettings.SPACE_WITHIN_METHOD_CALL_PARENTHESES && hasParams,\n                                           needRightParenth,\n                                           styleSettings.METHOD_PARAMETERS_LPAREN_ON_NEXT_LINE\n      ).handleInsert(context, item);\n    }\n\n    if (hasParams) {\n      // Invoke parameters popup\n      AutoPopupController.getInstance(file.getProject()).autoPopupParameterInfo(editor, overloadsMatter ? null : (PsiElement)item.getObject());\n    }\n\n    if (smart || !needRightParenth || !insertTail(context, item, tailType, hasTail)) {\n      return;\n    }\n\n    if (completionChar == '.') {\n      AutoPopupController.getInstance(file.getProject()).autoPopupMemberLookup(context.getEditor(), null);\n    } else if (completionChar == ',') {\n      AutoPopupController.getInstance(file.getProject()).autoPopupParameterInfo(context.getEditor(), null);\n    }\n  }","commit_id":"485459f8bf2cfc249f41331a0923d61425699152","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void processVariants(final PsiScopeProcessor processor) {\n    // todo[r.sh]: implement\n  }","id":25931,"modified_method":"@Override\n  public void processVariants(final PsiScopeProcessor processor) {\n    final FilterScopeProcessor proc = new FilterScopeProcessor(ElementClassFilter.METHOD, processor);\n    PsiScopesUtil.resolveAndWalk(proc, this, null, true);\n  }","commit_id":"485459f8bf2cfc249f41331a0923d61425699152","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void handleInsert(final InsertionContext context) {\n    final PsiFile file = context.getFile();\n    ((PsiJavaFile)file).importClass(myPsiClass);\n    final PsiElement caretElement = file.findElementAt(context.getEditor().getCaretModel().getOffset());\n    if (caretElement == null) {\n      throw new NullPointerException();\n    }\n    final PsiStatement statement = (PsiStatement) caretElement.getPrevSibling();\n    final PsiCodeBlock codeBlock = PsiTreeUtil.getParentOfType(statement, PsiCodeBlock.class);\n    if (codeBlock == null) {\n      throw new NullPointerException();\n    }\n    final Project project = context.getProject();\n    final Ref<PsiElement> insertedStatementRef = Ref.create();\n    final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    new WriteCommandAction.Simple(project, file) {\n      @Override\n      protected void run() throws Throwable {\n        final PsiStatement statementFromText = elementFactory.createStatementFromText(String.format(\"%s %s = null;\", myPsiClass.getName(), myNewVarName), null);\n        insertedStatementRef.set(codeBlock.addBefore(statementFromText, statement));\n      }\n    }.execute();\n    final PsiLiteralExpression nullKeyword = findNull(insertedStatementRef.get());\n\n    context.commitDocument();\n    PsiDocumentManager.getInstance(context.getProject()).doPostponedOperationsAndUnblockDocument(context.getDocument());\n    getDelegate().handleInsert(context);\n    final int offset = nullKeyword.getTextOffset();\n    final int endOffset = offset + nullKeyword.getTextLength();\n    context.getEditor().getSelectionModel().setSelection(offset, endOffset);\n    context.getEditor().getCaretModel().moveToOffset(offset);\n  }","id":25932,"modified_method":"@Override\n  public void handleInsert(final InsertionContext context) {\n    final RangeMarker rangeMarker = context.getDocument().createRangeMarker(context.getStartOffset(), context.getStartOffset());\n    getDelegate().handleInsert(context);\n    final PsiFile file = context.getFile();\n    ((PsiJavaFile)file).importClass(myPsiClass);\n    final PsiElement caretElement = file.findElementAt(context.getEditor().getCaretModel().getOffset());\n    if (caretElement == null) {\n      log.error(\"element on caret position MUST BE not null\");\n      return;\n    }\n    final PsiStatement statement = (PsiStatement) caretElement.getPrevSibling();\n    final PsiCodeBlock codeBlock = PsiTreeUtil.getParentOfType(statement, PsiCodeBlock.class);\n    if (codeBlock == null) {\n      log.error(\"code block MUST BE not null\");\n      return;\n    }\n    final Project project = context.getProject();\n    final Ref<PsiElement> insertedStatementRef = Ref.create();\n    final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    context.commitDocument();\n    new WriteCommandAction.Simple(project, file) {\n      @Override\n      protected void run() throws Throwable {\n        final PsiStatement statementFromText = elementFactory.createStatementFromText(String.format(\"%s %s = null;\", myPsiClass.getName(), myNewVarName), null);\n        insertedStatementRef.set(codeBlock.addBefore(statementFromText, statement));\n      }\n    }.execute();\n    final PsiLiteralExpression nullKeyword = findNull(insertedStatementRef.get());\n    PsiDocumentManager.getInstance(context.getProject()).doPostponedOperationsAndUnblockDocument(context.getDocument());\n    context.getDocument().insertString(rangeMarker.getStartOffset(), myNewVarName + \".\");\n    context.commitDocument();\n    final int offset = nullKeyword.getTextOffset();\n    final int endOffset = offset + nullKeyword.getTextLength();\n    context.getEditor().getSelectionModel().setSelection(offset, endOffset);\n    context.getEditor().getCaretModel().moveToOffset(offset);\n  }","commit_id":"ca4af156d60d34af82dedb36f7e4c786183ce8c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public String getLookupString() {\n    return myNewVarName + \".\" + getDelegate().getLookupString();\n  }","id":25933,"modified_method":"@NotNull\n  @Override\n  public String getLookupString() {\n    return getDelegate().getLookupString();\n  }","commit_id":"ca4af156d60d34af82dedb36f7e4c786183ce8c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ChainRelevance(final int chainSize,\n                        final int lastMethodOccurrences,\n                        final int unreachableParametersCount,\n                        final int notMatchedStringVars,\n                        final boolean hasCallingVariableInContext,\n                        final boolean firstMethodStatic) {\n    myChainSize = chainSize;\n    myLastMethodOccurrences = lastMethodOccurrences;\n    myUnreachableParametersCount = unreachableParametersCount;\n    myNotMatchedStringVars = notMatchedStringVars;\n    myHasCallingVariableInContext = hasCallingVariableInContext;\n    myFirstMethodStatic = firstMethodStatic;\n  }","id":25934,"modified_method":"public ChainRelevance(final int chainSize,\n                        final int lastMethodOccurrences,\n                        final int unreachableParametersCount,\n                        final int notMatchedStringVars,\n                        final boolean hasCallingVariableInContext,\n                        final boolean firstMethodStatic,\n                        final int parametersInContext) {\n    myChainSize = chainSize;\n    myLastMethodOccurrences = lastMethodOccurrences;\n    myUnreachableParametersCount = unreachableParametersCount;\n    myNotMatchedStringVars = notMatchedStringVars;\n    myHasCallingVariableInContext = hasCallingVariableInContext;\n    myFirstMethodStatic = firstMethodStatic;\n    myParametersInContext = parametersInContext;\n  }","commit_id":"ca4af156d60d34af82dedb36f7e4c786183ce8c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int compareTo(@NotNull final ChainRelevance that) {\n    if (myFirstMethodStatic && !that.myFirstMethodStatic) {\n      return -1;\n    }\n    if (that.myFirstMethodStatic && !myFirstMethodStatic) {\n      return 1;\n    }\n    if (myHasCallingVariableInContext && !that.myHasCallingVariableInContext) {\n      return 1;\n    }\n    if (that.myHasCallingVariableInContext && !myHasCallingVariableInContext) {\n      return -1;\n    }\n    int sub = myLastMethodOccurrences - that.myLastMethodOccurrences;\n    if (sub != 0) return sub;\n    sub = myUnreachableParametersCount - that.myUnreachableParametersCount;\n    if (sub != 0) return -sub;\n    return 0;\n  }","id":25935,"modified_method":"@Override\n  public int compareTo(@NotNull final ChainRelevance that) {\n    if (myHasCallingVariableInContext && !that.myHasCallingVariableInContext) {\n      return 1;\n    }\n    if (that.myHasCallingVariableInContext && !myHasCallingVariableInContext) {\n      return -1;\n    }\n    if (myFirstMethodStatic && !that.myFirstMethodStatic) {\n      return -1;\n    }\n    if (that.myFirstMethodStatic && !myFirstMethodStatic) {\n      return 1;\n    }\n    if (myParametersInContext > that.myParametersInContext) {\n      return 1;\n    }\n    if (myParametersInContext <= that.myParametersInContext) {\n      return -1;\n    }\n    int sub = myLastMethodOccurrences - that.myLastMethodOccurrences;\n    if (sub != 0) return sub;\n    sub = myUnreachableParametersCount - that.myUnreachableParametersCount;\n    if (sub != 0) return -sub;\n    return 0;\n  }","commit_id":"ca4af156d60d34af82dedb36f7e4c786183ce8c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testResultRelevance3() {\n    final List<WeightableChainLookupElement> weightableChainLookupElements = doCompletion();\n    assertSize(2, weightableChainLookupElements);\n    assertEquals(\"e.getProject1\", weightableChainLookupElements.get(0).getLookupString());\n    assertEquals(\"psiManager.getProject\", weightableChainLookupElements.get(1).getLookupString());\n  }","id":25936,"modified_method":"public void testResultRelevance3() {\n    final List<WeightableChainLookupElement> weightableChainLookupElements = doCompletion();\n    assertSize(2, weightableChainLookupElements);\n    assertEquals(\"e.getProject1\", weightableChainLookupElements.get(0).getLookupString());\n    assertEquals(\"getProject\", weightableChainLookupElements.get(1).getLookupString());\n  }","commit_id":"ca4af156d60d34af82dedb36f7e4c786183ce8c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MethodChainsSearchService(final Project project) {\n    myMethodsUsageIndex = MethodsUsageIndex.getInstance(project);\n    myBigramMethodsUsageIndex = BigramMethodsUsageIndex.getInstance(project);\n    myProject = project;\n  }","id":25937,"modified_method":"public MethodChainsSearchService(final Project project, final boolean useBigrams) {\n    myUseBigrams = useBigrams;\n    myMethodsUsageIndex = MethodsUsageIndex.getInstance(project);\n    myBigramMethodsUsageIndex = BigramMethodsUsageIndex.getInstance(project);\n    myProject = project;\n  }","commit_id":"ca4af156d60d34af82dedb36f7e4c786183ce8c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @SuppressWarnings(\"unchecked\")\n  public SortedSet<UsageIndexValue> getBigram(final MethodIncompleteSignature methodIncompleteSignature) {\n    final TreeSet<UsageIndexValue> value = myBigramMethodsUsageIndex.getValues(methodIncompleteSignature);\n    if (value != null) {\n      return value;\n    }\n    return EMPTY_SORTED_SET;\n  }","id":25938,"modified_method":"@NotNull\n  @SuppressWarnings(\"unchecked\")\n  public SortedSet<UsageIndexValue> getBigram(final MethodIncompleteSignature methodIncompleteSignature) {\n    final TreeSet<UsageIndexValue> values = myUseBigrams\n                                            ? myBigramMethodsUsageIndex.getValues(methodIncompleteSignature)\n                                            : myMethodsUsageIndex.getValues(methodIncompleteSignature.getOwner());\n    if (values != null) {\n      return values;\n    }\n    return EMPTY_SORTED_SET;\n  }","commit_id":"ca4af156d60d34af82dedb36f7e4c786183ce8c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static MethodProcResult processMethod(@NotNull final PsiMethod method,\n                                                @Nullable final PsiClass qualifierClass,\n                                                final ChainCompletionContext context,\n                                                final int weight,\n                                                final boolean isHeadMethod,\n                                                final NullableNotNullManager nullableNotNullManager) {\n    int unreachableParametersCount = 0;\n    int notMatchedStringVars = 0;\n    boolean hasCallingVariableInContext = false;\n    boolean introduceNewVariable = false;\n    final PsiParameterList parameterList = method.getParameterList();\n    final TIntObjectHashMap<SubLookupElement> parametersMap = new TIntObjectHashMap<SubLookupElement>(parameterList.getParametersCount());\n    final PsiParameter[] parameters = parameterList.getParameters();\n    for (int i = 0; i < parameters.length; i++) {\n      final PsiParameter parameter = parameters[i];\n      final String typeQName = parameter.getType().getCanonicalText();\n      if (typeQName != null) {\n        if (JAVA_LANG_STRING.equals(typeQName)) {\n          final PsiVariable relevantStringVar = context.findRelevantStringInContext(parameter.getName());\n          if (relevantStringVar == null) {\n            notMatchedStringVars++;\n          }\n          else {\n            parametersMap.put(i, new VariableSubLookupElement(relevantStringVar));\n          }\n        }\n        else if (!ChainCompletionStringUtil.isPrimitiveOrArrayOfPrimitives(typeQName)) {\n          final Collection<PsiVariable> contextVariables = context.getVariables(typeQName);\n          final PsiVariable contextVariable = ContainerUtil.getFirstItem(contextVariables, null);\n          if (contextVariable != null) {\n            if (contextVariables.size() == 1) parametersMap.put(i, new VariableSubLookupElement(contextVariable));\n            continue;\n          }\n          final Collection<ContextRelevantVariableGetter> relevantVariablesGetters = context.getRelevantVariablesGetters(typeQName);\n          final ContextRelevantVariableGetter contextVariableGetter = ContainerUtil.getFirstItem(relevantVariablesGetters, null);\n          if (contextVariableGetter != null) {\n            if (relevantVariablesGetters.size() == 1) parametersMap.put(i, contextVariableGetter.createSubLookupElement());\n            continue;\n          }\n          final Collection<PsiMethod> containingClassMethods = context.getContainingClassMethods(typeQName);\n          final PsiMethod contextRelevantGetter = ContainerUtil.getFirstItem(containingClassMethods, null);\n          if (contextRelevantGetter != null) {\n            if (containingClassMethods.size() == 1) parametersMap.put(i, new GetterLookupSubLookupElement(method.getName()));\n            continue;\n          }\n          final ContextRelevantStaticMethod contextRelevantStaticMethod =\n            ContainerUtil.getFirstItem(context.getRelevantStaticMethods(typeQName, weight), null);\n          if (contextRelevantStaticMethod != null) {\n            //\n            // In most cases it is not really relevant\n            //\n            //parametersMap.put(i, contextRelevantStaticMethod.createLookupElement());\n            continue;\n          }\n          if (!nullableNotNullManager.isNullable(parameter, true)) {\n            unreachableParametersCount++;\n          }\n        }\n      }\n    }\n    final LookupElement lookupElement;\n    if (isHeadMethod) {\n      if (method.hasModifierProperty(PsiModifier.STATIC)) {\n        lookupElement = createLookupElement(method, parametersMap);\n      }\n      else if (method.isConstructor()) {\n        return null;\n      }\n      else {\n        @SuppressWarnings(\"ConstantConditions\")\n        final String classQName = qualifierClass.getQualifiedName();\n        if (classQName == null) return null;\n        final Object e = ContainerUtil.getFirstItem(context.getContextRefElements(classQName), null);\n        if (e != null) {\n          final LookupElement firstChainElement;\n          if (e instanceof PsiVariable) {\n            hasCallingVariableInContext = true;\n            firstChainElement = new VariableLookupItem((PsiVariable)e);\n          }\n          else if (e instanceof PsiMethod) {\n            firstChainElement = createLookupElement((PsiMethod)e, null);\n          }\n          else if (e instanceof LookupElement) {\n            firstChainElement = (LookupElement)e;\n          }\n          else {\n            throw new AssertionError();\n          }\n          lookupElement = new JavaChainLookupElement(firstChainElement, createLookupElement(method, parametersMap));\n        }\n        else {\n          lookupElement = createLookupElement(method, parametersMap);\n          if (!context.getContainingClassQNames().contains(classQName)) {\n            introduceNewVariable = true;\n          }\n        }\n      }\n    }\n    else {\n      lookupElement = createLookupElement(method, parametersMap);\n    }\n    return new MethodProcResult(lookupElement, unreachableParametersCount, notMatchedStringVars, hasCallingVariableInContext, introduceNewVariable);\n  }","id":25939,"modified_method":"@Nullable\n  private static MethodProcResult processMethod(@NotNull final PsiMethod method,\n                                                @Nullable final PsiClass qualifierClass,\n                                                final ChainCompletionContext context,\n                                                final int weight,\n                                                final boolean isHeadMethod,\n                                                final NullableNotNullManager nullableNotNullManager) {\n    int unreachableParametersCount = 0;\n    int notMatchedStringVars = 0;\n    int matchedParametersInContext = 0;\n    boolean hasCallingVariableInContext = false;\n    boolean introduceNewVariable = false;\n    final PsiParameterList parameterList = method.getParameterList();\n    final TIntObjectHashMap<SubLookupElement> parametersMap = new TIntObjectHashMap<SubLookupElement>(parameterList.getParametersCount());\n    final PsiParameter[] parameters = parameterList.getParameters();\n    for (int i = 0; i < parameters.length; i++) {\n      final PsiParameter parameter = parameters[i];\n      final String typeQName = parameter.getType().getCanonicalText();\n      if (typeQName != null) {\n        if (JAVA_LANG_STRING.equals(typeQName)) {\n          final PsiVariable relevantStringVar = context.findRelevantStringInContext(parameter.getName());\n          if (relevantStringVar == null) {\n            notMatchedStringVars++;\n          }\n          else {\n            parametersMap.put(i, new VariableSubLookupElement(relevantStringVar));\n          }\n        }\n        else if (!ChainCompletionStringUtil.isPrimitiveOrArrayOfPrimitives(typeQName)) {\n          final Collection<PsiVariable> contextVariables = context.getVariables(typeQName);\n          final PsiVariable contextVariable = ContainerUtil.getFirstItem(contextVariables, null);\n          if (contextVariable != null) {\n            if (contextVariables.size() == 1) parametersMap.put(i, new VariableSubLookupElement(contextVariable));\n            matchedParametersInContext++;\n            continue;\n          }\n          final Collection<ContextRelevantVariableGetter> relevantVariablesGetters = context.getRelevantVariablesGetters(typeQName);\n          final ContextRelevantVariableGetter contextVariableGetter = ContainerUtil.getFirstItem(relevantVariablesGetters, null);\n          if (contextVariableGetter != null) {\n            if (relevantVariablesGetters.size() == 1) parametersMap.put(i, contextVariableGetter.createSubLookupElement());\n            matchedParametersInContext++;\n            continue;\n          }\n          final Collection<PsiMethod> containingClassMethods = context.getContainingClassMethods(typeQName);\n          final PsiMethod contextRelevantGetter = ContainerUtil.getFirstItem(containingClassMethods, null);\n          if (contextRelevantGetter != null) {\n            if (containingClassMethods.size() == 1) parametersMap.put(i, new GetterLookupSubLookupElement(method.getName()));\n            matchedParametersInContext++;\n            continue;\n          }\n          final ContextRelevantStaticMethod contextRelevantStaticMethod =\n            ContainerUtil.getFirstItem(context.getRelevantStaticMethods(typeQName, weight), null);\n          if (contextRelevantStaticMethod != null) {\n            //\n            // In most cases it is not really relevant\n            //\n            //parametersMap.put(i, contextRelevantStaticMethod.createLookupElement());\n            matchedParametersInContext++;\n            continue;\n          }\n          if (!nullableNotNullManager.isNullable(parameter, true)) {\n            unreachableParametersCount++;\n          }\n        }\n      }\n    }\n    final LookupElement lookupElement;\n    if (isHeadMethod) {\n      if (method.hasModifierProperty(PsiModifier.STATIC)) {\n        hasCallingVariableInContext = true;\n        lookupElement = createLookupElement(method, parametersMap);\n      }\n      else if (method.isConstructor()) {\n        return null;\n      }\n      else {\n        @SuppressWarnings(\"ConstantConditions\")\n        final String classQName = qualifierClass.getQualifiedName();\n        if (classQName == null) return null;\n        final Object e = ContainerUtil.getFirstItem(context.getContextRefElements(classQName), null);\n        if (e != null) {\n          final LookupElement firstChainElement;\n          if (e instanceof PsiVariable) {\n            hasCallingVariableInContext = true;\n            firstChainElement = new VariableLookupItem((PsiVariable)e);\n          }\n          else if (e instanceof PsiMethod) {\n            firstChainElement = createLookupElement((PsiMethod)e, null);\n          }\n          else if (e instanceof LookupElement) {\n            firstChainElement = (LookupElement)e;\n          }\n          else {\n            throw new AssertionError();\n          }\n          lookupElement = new JavaChainLookupElement(firstChainElement, createLookupElement(method, parametersMap));\n        }\n        else {\n          lookupElement = createLookupElement(method, parametersMap);\n          if (!context.getContainingClassQNames().contains(classQName)) {\n            introduceNewVariable = true;\n          }\n        }\n      }\n    }\n    else {\n      lookupElement = createLookupElement(method, parametersMap);\n    }\n    return new MethodProcResult(lookupElement,\n                                unreachableParametersCount,\n                                notMatchedStringVars,\n                                hasCallingVariableInContext,\n                                introduceNewVariable,\n                                matchedParametersInContext);\n  }","commit_id":"ca4af156d60d34af82dedb36f7e4c786183ce8c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings(\"ConstantConditions\")\n  @Nullable\n  private static WeightableChainLookupElement chainToWeightableLookupElement(final MethodsChain chain,\n                                                                             final ChainCompletionContext context) {\n    final int chainSize = chain.size();\n    assert chainSize != 0;\n    final int lastMethodWeight = chain.getChainWeight();\n    int unreachableParametersCount = 0;\n    int notMatchedStringVars = 0;\n    Boolean isFirstMethodStatic = null;\n    Boolean hasCallingVariableInContext = null;\n    LookupElement chainLookupElement = null;\n    PsiClass newVariableClass = null;\n    final NullableNotNullManager nullableNotNullManager = NullableNotNullManager.getInstance(context.getProject());\n\n    for (final PsiMethod[] psiMethods : chain.getPath()) {\n      final PsiMethod method =\n        MethodChainsSearchUtil.getMethodWithMinNotPrimitiveParameters(psiMethods, Collections.singleton(context.getTargetQName()));\n      if (method == null) {\n        return null;\n      }\n      if (isFirstMethodStatic == null) {\n        isFirstMethodStatic = psiMethods[0].hasModifierProperty(PsiModifier.STATIC);\n      }\n      final PsiClass qualifierClass;\n      final boolean isHead = chainLookupElement == null;\n      if (isHead) {\n        final String qualifierClassName = chain.getQualifierClassName();\n        qualifierClass = JavaPsiFacade.getInstance(context.getProject()).\n          findClass(qualifierClassName, context.getResolveScope());\n      }\n      else {\n        qualifierClass = null;\n      }\n\n      final MethodProcResult procResult = processMethod(method, qualifierClass, context, lastMethodWeight, isHead, nullableNotNullManager);\n      if (procResult == null) {\n        return null;\n      }\n      if (hasCallingVariableInContext == null) {\n        hasCallingVariableInContext = procResult.hasCallingVariableInContext();\n      }\n      if (isHead && procResult.isIntroduceNewVariable()) {\n        newVariableClass = qualifierClass;\n      }\n      unreachableParametersCount += procResult.getUnreachableParametersCount();\n      notMatchedStringVars += procResult.getNotMatchedStringVars();\n      chainLookupElement = isHead ? procResult.getLookupElement() : new JavaChainLookupElement(chainLookupElement, procResult.getLookupElement());\n    }\n\n    if (newVariableClass != null) {\n      chainLookupElement = ChainCompletionNewVariableLookupElement.create(newVariableClass, chainLookupElement);\n    }\n\n    final ChainRelevance relevance =\n      new ChainRelevance(chainSize,\n                         lastMethodWeight,\n                         unreachableParametersCount,\n                         notMatchedStringVars,\n                         hasCallingVariableInContext,\n                         isFirstMethodStatic);\n\n    return new WeightableChainLookupElement(chainLookupElement, relevance);\n  }","id":25940,"modified_method":"@SuppressWarnings(\"ConstantConditions\")\n  @Nullable\n  private static WeightableChainLookupElement chainToWeightableLookupElement(final MethodsChain chain,\n                                                                             final ChainCompletionContext context) {\n    final int chainSize = chain.size();\n    assert chainSize != 0;\n    final int lastMethodWeight = chain.getChainWeight();\n    int unreachableParametersCount = 0;\n    int notMatchedStringVars = 0;\n    int matchedParametersInContext = 0;\n    Boolean isFirstMethodStatic = null;\n    Boolean hasCallingVariableInContext = null;\n    LookupElement chainLookupElement = null;\n    PsiClass newVariableClass = null;\n    final NullableNotNullManager nullableNotNullManager = NullableNotNullManager.getInstance(context.getProject());\n\n    for (final PsiMethod[] psiMethods : chain.getPath()) {\n      final PsiMethod method =\n        MethodChainsSearchUtil.getMethodWithMinNotPrimitiveParameters(psiMethods, Collections.singleton(context.getTargetQName()));\n      if (method == null) {\n        return null;\n      }\n      if (isFirstMethodStatic == null) {\n        isFirstMethodStatic = psiMethods[0].hasModifierProperty(PsiModifier.STATIC);\n      }\n      final PsiClass qualifierClass;\n      final boolean isHead = chainLookupElement == null;\n      if (isHead) {\n        final String qualifierClassName = chain.getQualifierClassName();\n        qualifierClass = JavaPsiFacade.getInstance(context.getProject()).\n          findClass(qualifierClassName, context.getResolveScope());\n      }\n      else {\n        qualifierClass = null;\n      }\n\n      final MethodProcResult procResult = processMethod(method, qualifierClass, context, lastMethodWeight, isHead, nullableNotNullManager);\n      if (procResult == null) {\n        return null;\n      }\n      if (hasCallingVariableInContext == null) {\n        hasCallingVariableInContext = procResult.hasCallingVariableInContext();\n      }\n      if (isHead && procResult.isIntroduceNewVariable()) {\n        newVariableClass = qualifierClass;\n      }\n      matchedParametersInContext += procResult.getMatchedParametersInContext();\n      unreachableParametersCount += procResult.getUnreachableParametersCount();\n      notMatchedStringVars += procResult.getNotMatchedStringVars();\n      chainLookupElement =\n        isHead ? procResult.getLookupElement() : new JavaChainLookupElement(chainLookupElement, procResult.getLookupElement());\n    }\n\n    if (newVariableClass != null) {\n      chainLookupElement = ChainCompletionNewVariableLookupElement.create(newVariableClass, chainLookupElement);\n    }\n\n    final ChainRelevance relevance =\n      new ChainRelevance(chainSize, lastMethodWeight, unreachableParametersCount, notMatchedStringVars, hasCallingVariableInContext,\n                         isFirstMethodStatic, matchedParametersInContext);\n\n    return new WeightableChainLookupElement(chainLookupElement, relevance);\n  }","commit_id":"ca4af156d60d34af82dedb36f7e4c786183ce8c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private MethodProcResult(final LookupElement methodLookup,\n                             final int unreachableParametersCount,\n                             final int notMatchedStringVars,\n                             final boolean hasCallingVariableInContext,\n                             final boolean introduceNewVariable) {\n      myMethodLookup = methodLookup;\n      myUnreachableParametersCount = unreachableParametersCount;\n      myNotMatchedStringVars = notMatchedStringVars;\n      myHasCallingVariableInContext = hasCallingVariableInContext;\n      myIntroduceNewVariable = introduceNewVariable;\n    }","id":25941,"modified_method":"private MethodProcResult(final LookupElement methodLookup,\n                             final int unreachableParametersCount,\n                             final int notMatchedStringVars,\n                             final boolean hasCallingVariableInContext,\n                             final boolean introduceNewVariable,\n                             final int matchedParametersInContext) {\n      myMethodLookup = methodLookup;\n      myUnreachableParametersCount = unreachableParametersCount;\n      myNotMatchedStringVars = notMatchedStringVars;\n      myHasCallingVariableInContext = hasCallingVariableInContext;\n      myIntroduceNewVariable = introduceNewVariable;\n      myMatchedParametersInContext = matchedParametersInContext;\n    }","commit_id":"ca4af156d60d34af82dedb36f7e4c786183ce8c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<LookupElement> searchForLookups(final String targetClassQName,\n                                                      final Set<String> contextRelevantTypes,\n                                                      final ChainCompletionContext completionContext) {\n    final MethodChainsSearchService searchService = new MethodChainsSearchService(completionContext.getProject());\n    final List<MethodsChain> searchResult =\n      searchChains(targetClassQName, contextRelevantTypes, MAX_SEARCH_RESULT_SIZE, MAX_CHAIN_SIZE, completionContext, searchService);\n    if (searchResult.size() < MAX_SEARCH_RESULT_SIZE) {\n      final PsiClass aClass = JavaPsiFacade.getInstance(completionContext.getProject())\n        .findClass(targetClassQName, GlobalSearchScope.allScope(completionContext.getProject()));\n      if (aClass != null) {\n        DirectClassInheritorsSearch.search(aClass).forEach(new Processor<PsiClass>() {\n          @Override\n          public boolean process(final PsiClass psiClass) {\n            final String inheritorQName = psiClass.getQualifiedName();\n            if (!StringUtil.isEmpty(inheritorQName)) {\n              final List<MethodsChain> inheritorFilteredSearchResult = new SmartList<MethodsChain>();\n              //noinspection ConstantConditions\n              for (final MethodsChain chain : searchChains(inheritorQName, contextRelevantTypes, MAX_SEARCH_RESULT_SIZE, MAX_CHAIN_SIZE,\n                                                           completionContext, searchService)) {\n                boolean insert = true;\n                for (final MethodsChain baseChain : searchResult) {\n                  final MethodsChain.CompareResult r = MethodsChain.compare(baseChain, chain, completionContext);\n                  if (r != MethodsChain.CompareResult.NOT_EQUAL) {\n                    insert = false;\n                    break;\n                  }\n                }\n                if (insert) {\n                  inheritorFilteredSearchResult.add(chain);\n                }\n              }\n              searchResult.addAll(inheritorFilteredSearchResult);\n            }\n            return true;\n          }\n        });\n      }\n    }\n    final List<MethodsChain> chains = searchResult.size() > MAX_CHAIN_SIZE ? chooseHead(searchResult) : searchResult;\n    return MethodsChainLookupRangingHelper\n      .chainsToWeightableLookupElements(filterTailAndGetSumLastMethodOccurrence(chains), completionContext);\n  }","id":25942,"modified_method":"private static List<LookupElement> searchForLookups(final String targetClassQName,\n                                                      final Set<String> contextRelevantTypes,\n                                                      final ChainCompletionContext completionContext,\n                                                      final boolean useBigrams) {\n    final MethodChainsSearchService searchService = new MethodChainsSearchService(completionContext.getProject(), useBigrams);\n    final List<MethodsChain> searchResult =\n      searchChains(targetClassQName, contextRelevantTypes, MAX_SEARCH_RESULT_SIZE, MAX_CHAIN_SIZE, completionContext, searchService);\n    if (searchResult.size() < MAX_SEARCH_RESULT_SIZE) {\n      final PsiClass aClass = JavaPsiFacade.getInstance(completionContext.getProject())\n        .findClass(targetClassQName, GlobalSearchScope.allScope(completionContext.getProject()));\n      if (aClass != null) {\n        DirectClassInheritorsSearch.search(aClass).forEach(new Processor<PsiClass>() {\n          @Override\n          public boolean process(final PsiClass psiClass) {\n            final String inheritorQName = psiClass.getQualifiedName();\n            if (!StringUtil.isEmpty(inheritorQName)) {\n              final List<MethodsChain> inheritorFilteredSearchResult = new SmartList<MethodsChain>();\n              //noinspection ConstantConditions\n              for (final MethodsChain chain : searchChains(inheritorQName, contextRelevantTypes, MAX_SEARCH_RESULT_SIZE, MAX_CHAIN_SIZE,\n                                                           completionContext, searchService)) {\n                boolean insert = true;\n                for (final MethodsChain baseChain : searchResult) {\n                  final MethodsChain.CompareResult r = MethodsChain.compare(baseChain, chain, completionContext);\n                  if (r != MethodsChain.CompareResult.NOT_EQUAL) {\n                    insert = false;\n                    break;\n                  }\n                }\n                if (insert) {\n                  inheritorFilteredSearchResult.add(chain);\n                }\n              }\n              searchResult.addAll(inheritorFilteredSearchResult);\n            }\n            return true;\n          }\n        });\n      }\n    }\n    final List<MethodsChain> chains = searchResult.size() > MAX_CHAIN_SIZE ? chooseHead(searchResult) : searchResult;\n    return MethodsChainLookupRangingHelper\n      .chainsToWeightableLookupElements(filterTailAndGetSumLastMethodOccurrence(chains), completionContext);\n  }","commit_id":"ca4af156d60d34af82dedb36f7e4c786183ce8c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public MethodsChainsCompletionContributor() {\n    final ElementPattern<PsiElement> pattern =\n      or(CompletionContributorPatternUtil.patternForMethodParameter(), CompletionContributorPatternUtil.patternForVariableAssignment());\n    extend(CompletionType.BASIC, pattern, new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(final @NotNull CompletionParameters parameters,\n                                    final ProcessingContext context,\n                                    final @NotNull CompletionResultSet result) {\n\n        final ChainCompletionContext completionContext = extractContext(parameters);\n        if (completionContext == null) return;\n\n\n        final String targetClassQName = completionContext.getTargetQName();\n        final Set<String> contextTypesKeysSet = completionContext.getContextTypes();\n        final Set<String> contextRelevantTypes = new HashSet<String>(contextTypesKeysSet.size() + 1);\n        for (final String type : contextTypesKeysSet) {\n          if (!ChainCompletionStringUtil.isPrimitiveOrArrayOfPrimitives(type)) {\n            contextRelevantTypes.add(type);\n          }\n        }\n        contextRelevantTypes.remove(targetClassQName);\n\n        final List<LookupElement> foundElements = searchForLookups(targetClassQName, contextRelevantTypes, completionContext);\n        result.addAllElements(foundElements);\n      }\n    });\n  }","id":25943,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public MethodsChainsCompletionContributor() {\n    final ElementPattern<PsiElement> pattern =\n      or(CompletionContributorPatternUtil.patternForMethodParameter(), CompletionContributorPatternUtil.patternForVariableAssignment());\n    extend(CompletionType.BASIC, pattern, new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(final @NotNull CompletionParameters parameters,\n                                    final ProcessingContext context,\n                                    final @NotNull CompletionResultSet result) {\n\n        final ChainCompletionContext completionContext = extractContext(parameters);\n        if (completionContext == null) return;\n\n\n        final String targetClassQName = completionContext.getTargetQName();\n        final Set<String> contextTypesKeysSet = completionContext.getContextTypes();\n        final Set<String> contextRelevantTypes = new HashSet<String>(contextTypesKeysSet.size() + 1);\n        for (final String type : contextTypesKeysSet) {\n          if (!ChainCompletionStringUtil.isPrimitiveOrArrayOfPrimitives(type)) {\n            contextRelevantTypes.add(type);\n          }\n        }\n        contextRelevantTypes.remove(targetClassQName);\n\n        //final boolean useBigrams = ApplicationManager.getApplication().isUnitTestMode() || parameters.getInvocationCount() == 3;\n        final boolean useBigrams = true;\n        final List<LookupElement> foundElements = searchForLookups(targetClassQName, contextRelevantTypes, completionContext, useBigrams);\n        result.addAllElements(foundElements);\n      }\n    });\n  }","commit_id":"ca4af156d60d34af82dedb36f7e4c786183ce8c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doTest() throws Throwable {\n    final List<String> stringList = TestUtils.readInput(getTestDataPath() + \"/\" + getTestName(true) + \".test\");\n    final String fileName = getTestName(true) + \".\" + getExtension();\n    myFixture.addFileToProject(fileName, stringList.get(0));\n    myFixture.configureByFile(fileName);\n\n    CompositeCompletionData.restrictCompletion(addReferenceVariants(), addKeywords());\n\n    boolean old = CodeInsightSettings.getInstance().AUTOCOMPLETE_COMMON_PREFIX;\n    CodeInsightSettings.getInstance().AUTOCOMPLETE_COMMON_PREFIX = false;\n    CodeInsightSettings.getInstance().AUTOCOMPLETE_ON_CODE_COMPLETION = false;\n\n\n    String result = \"\";\n    try {\n      myFixture.completeBasic();\n\n      final LookupImpl lookup = (LookupImpl)LookupManager.getActiveLookup(myFixture.getEditor());\n      if (lookup != null) {\n        LookupElement[] items = lookup.getItems();\n        Arrays.sort(items);\n        result = \"\";\n        for (LookupElement item : items) {\n          result = result + \"\\n\" + item.getLookupString();\n        }\n        result = result.trim();\n        LookupManager.getInstance(myFixture.getProject()).hideActiveLookup();\n      }\n\n    }\n    finally {\n      CodeInsightSettings.getInstance().AUTOCOMPLETE_ON_CODE_COMPLETION = true;\n      CodeInsightSettings.getInstance().AUTOCOMPLETE_COMMON_PREFIX = old;\n      CompositeCompletionData.restrictCompletion(true, true);\n    }\n    assertEquals(stringList.get(1), result);\n  }","id":25944,"modified_method":"protected void doTest() throws Throwable {\n    final List<String> stringList = TestUtils.readInput(getTestDataPath() + \"/\" + getTestName(true) + \".test\");\n    final String fileName = getTestName(true) + \".\" + getExtension();\n    myFixture.addFileToProject(fileName, stringList.get(0));\n    myFixture.configureByFile(fileName);\n\n    CompositeCompletionData.restrictCompletion(addReferenceVariants(), addKeywords());\n\n    boolean old = CodeInsightSettings.getInstance().AUTOCOMPLETE_COMMON_PREFIX;\n    CodeInsightSettings.getInstance().AUTOCOMPLETE_COMMON_PREFIX = false;\n    CodeInsightSettings.getInstance().AUTOCOMPLETE_ON_CODE_COMPLETION = false;\n\n\n    String result = \"\";\n    try {\n      myFixture.completeBasic();\n\n      final LookupImpl lookup = (LookupImpl)LookupManager.getActiveLookup(myFixture.getEditor());\n      if (lookup != null) {\n        LookupElement[] items = lookup.getItems();\n        Arrays.sort(items, new Comparator<LookupElement>() {\n          public int compare(LookupElement o1, LookupElement o2) {\n            return o1.getLookupString().compareTo(o2.getLookupString());\n          }\n        });\n        result = \"\";\n        for (LookupElement item : items) {\n          result = result + \"\\n\" + item.getLookupString();\n        }\n        result = result.trim();\n        LookupManager.getInstance(myFixture.getProject()).hideActiveLookup();\n      }\n\n    }\n    finally {\n      CodeInsightSettings.getInstance().AUTOCOMPLETE_ON_CODE_COMPLETION = true;\n      CodeInsightSettings.getInstance().AUTOCOMPLETE_COMMON_PREFIX = old;\n      CompositeCompletionData.restrictCompletion(true, true);\n    }\n    assertEquals(stringList.get(1), result);\n  }","commit_id":"4df562ca330c284e826f82053e5ac389e6818d7a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void completeReference(final PsiReference reference,\n                                final Set<LookupElement> set,\n                                @NotNull final PsiElement position,\n                                final PsiFile file,\n                                final int offset) {\n    super.completeReference(reference, set, position, file, offset);\n    for (final LookupElement element : set) {\n      ((LookupItem)element).setInsertHandler(new GroovyInsertHandlerAdapter());\n    }\n  }","id":25945,"modified_method":"@Override\n  public void completeReference(final PsiReference reference,\n                                final Set<LookupElement> set,\n                                @NotNull final PsiElement position,\n                                final PsiFile file,\n                                final int offset) {\n    super.completeReference(reference, set, position, file, offset);\n    for (final LookupElement element : new ArrayList<LookupElement>(set)) {\n      if (element instanceof LookupItem) {\n        ((LookupItem)element).setInsertHandler(new GroovyInsertHandlerAdapter());\n      } else {\n        final LookupElementBuilder builder = (LookupElementBuilder)element;\n        set.remove(builder);\n        set.add(builder.setInsertHandler(new GroovyInsertHandlerAdapter()));\n      }\n    }\n  }","commit_id":"4df562ca330c284e826f82053e5ac389e6818d7a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void handleInsert(InsertionContext context, LookupElement item) {\n    @NonNls Object obj = item.getObject();\n    if (obj instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)obj;\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      Editor editor = context.getEditor();\n      Document document = editor.getDocument();\n      if (context.getCompletionChar() == Lookup.REPLACE_SELECT_CHAR) {\n        handleOverwrite(editor.getCaretModel().getOffset(), document);\n      }\n\n      CaretModel caretModel = editor.getCaretModel();\n      int offset = context.getStartOffset() + method.getName().length();\n      PsiFile file = PsiDocumentManager.getInstance(method.getProject()).getPsiFile(document);\n      PsiElement elementAt = file.findElementAt(context.getStartOffset());\n      PsiElement parent = elementAt != null ? elementAt.getParent() : null;\n      if (parent instanceof GrReferenceExpression &&\n          ((GrReferenceExpression)parent).getDotTokenType() == GroovyElementTypes.mMEMBER_POINTER) {\n        return;\n      }\n\n      if (parent instanceof GrAnnotationNameValuePair || parent.getParent() instanceof GrAnnotationNameValuePair) {\n        document.insertString(offset, \" = \");\n        caretModel.moveToOffset(offset + 3);\n        return;\n      }\n\n      if (PsiTreeUtil.getParentOfType(elementAt, GrImportStatement.class) != null) return;\n\n      if (parameters.length == 1 && CLOSURE_CLASS.equals(parameters[0].getType().getCanonicalText())) {\n        document.insertString(offset, \" {}\");\n        caretModel.moveToOffset(offset + 2);\n        return;\n      }\n\n      PsiDocumentManager docManager = PsiDocumentManager.getInstance(method.getProject());\n      docManager.commitDocument(document);\n      PsiFile psiFile = docManager.getPsiFile(document);\n      if (isExpressionStatement(psiFile, context.getStartOffset()) && PsiType.VOID.equals(method.getReturnType()) && '(' != context.getCompletionChar() && parameters.length > 0) {\n        TailType.insertChar(editor, offset, ' ');\n        return;\n      }\n\n      new MethodParenthesesHandler(method, true).handleInsert(context, item);\n      return;\n    }\n\n    if (obj instanceof String && !\"assert\".equals(obj)) {\n      Editor editor = context.getEditor();\n      Document document = editor.getDocument();\n      if (context.getCompletionChar() == Lookup.REPLACE_SELECT_CHAR) {\n        handleOverwrite(editor.getCaretModel().getOffset(), document);\n      }\n    } else if (obj instanceof PsiClass) {\n      final PsiClass clazz = (PsiClass)obj;\n      Editor editor = context.getEditor();\n      Document document = editor.getDocument();\n      PsiFile file = PsiDocumentManager.getInstance(clazz.getProject()).getPsiFile(document);\n      PsiElement elementAt = file.findElementAt(context.getStartOffset());\n      CaretModel caretModel = editor.getCaretModel();\n      int offset = context.getStartOffset() + clazz.getName().length();\n\n      final String text = document.getText();\n      final PsiElement parent = elementAt.getParent();\n      if (parent instanceof GrCodeReferenceElement &&\n          parent.getParent() instanceof GrNewExpression &&\n          (offset == text.length() || !text.substring(offset).trim().startsWith(\"(\"))) {\n        document.insertString(offset, \"()\");\n        final PsiMethod[] methods = clazz.getConstructors();\n        for (PsiMethod method : methods) {\n          if (method.getParameterList().getParameters().length > 0) {\n            caretModel.moveToOffset(offset + 1);\n            return;\n          }\n        }\n        caretModel.moveToOffset(offset + 2);\n        return;\n      }\n    }\n\n    addTailType((MutableLookupElement)item);\n    super.handleInsert(context, item);\n\n  }","id":25946,"modified_method":"public void handleInsert(InsertionContext context, LookupElement item) {\n    @NonNls Object obj = item.getObject();\n    if (obj instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)obj;\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      Editor editor = context.getEditor();\n      Document document = editor.getDocument();\n      if (context.getCompletionChar() == Lookup.REPLACE_SELECT_CHAR) {\n        handleOverwrite(editor.getCaretModel().getOffset(), document);\n      }\n\n      CaretModel caretModel = editor.getCaretModel();\n      int offset = context.getStartOffset() + method.getName().length();\n      PsiFile file = PsiDocumentManager.getInstance(method.getProject()).getPsiFile(document);\n      PsiElement elementAt = file.findElementAt(context.getStartOffset());\n      PsiElement parent = elementAt != null ? elementAt.getParent() : null;\n      if (parent instanceof GrReferenceExpression &&\n          ((GrReferenceExpression)parent).getDotTokenType() == GroovyElementTypes.mMEMBER_POINTER) {\n        return;\n      }\n\n      if (parent instanceof GrAnnotationNameValuePair || parent.getParent() instanceof GrAnnotationNameValuePair) {\n        document.insertString(offset, \" = \");\n        caretModel.moveToOffset(offset + 3);\n        return;\n      }\n\n      if (PsiTreeUtil.getParentOfType(elementAt, GrImportStatement.class) != null) return;\n\n      if (parameters.length == 1 && CLOSURE_CLASS.equals(parameters[0].getType().getCanonicalText())) {\n        document.insertString(offset, \" {}\");\n        caretModel.moveToOffset(offset + 2);\n        return;\n      }\n\n      PsiDocumentManager docManager = PsiDocumentManager.getInstance(method.getProject());\n      docManager.commitDocument(document);\n      PsiFile psiFile = docManager.getPsiFile(document);\n      if (isExpressionStatement(psiFile, context.getStartOffset()) && PsiType.VOID.equals(method.getReturnType()) && '(' != context.getCompletionChar() && parameters.length > 0) {\n        TailType.insertChar(editor, offset, ' ');\n        return;\n      }\n\n      new MethodParenthesesHandler(method, true).handleInsert(context, item);\n      return;\n    }\n\n    if (obj instanceof String && !\"assert\".equals(obj)) {\n      Editor editor = context.getEditor();\n      Document document = editor.getDocument();\n      if (context.getCompletionChar() == Lookup.REPLACE_SELECT_CHAR) {\n        handleOverwrite(editor.getCaretModel().getOffset(), document);\n      }\n    } else if (obj instanceof PsiClass) {\n      final PsiClass clazz = (PsiClass)obj;\n      Editor editor = context.getEditor();\n      Document document = editor.getDocument();\n      PsiFile file = PsiDocumentManager.getInstance(clazz.getProject()).getPsiFile(document);\n      PsiElement elementAt = file.findElementAt(context.getStartOffset());\n      CaretModel caretModel = editor.getCaretModel();\n      int offset = context.getStartOffset() + clazz.getName().length();\n\n      final String text = document.getText();\n      final PsiElement parent = elementAt.getParent();\n      if (parent instanceof GrCodeReferenceElement &&\n          parent.getParent() instanceof GrNewExpression &&\n          (offset == text.length() || !text.substring(offset).trim().startsWith(\"(\"))) {\n        document.insertString(offset, \"()\");\n        final PsiMethod[] methods = clazz.getConstructors();\n        for (PsiMethod method : methods) {\n          if (method.getParameterList().getParameters().length > 0) {\n            caretModel.moveToOffset(offset + 1);\n            return;\n          }\n        }\n        caretModel.moveToOffset(offset + 2);\n        return;\n      }\n    }\n\n    if (item instanceof LookupItem) {\n      addTailType((MutableLookupElement)item);\n      super.handleInsert(context, item);\n    }\n\n  }","commit_id":"4df562ca330c284e826f82053e5ac389e6818d7a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Bundle getMockBundle()\n    {\n        BundleContext bc = (BundleContext) EasyMock.createNiceMock(BundleContext.class);\n        Bundle b = (Bundle) EasyMock.createNiceMock(Bundle.class);\n        EasyMock.expect(b.getBundleContext()).andReturn(bc).anyTimes();\n        b.getState();\n        EasyMock.expectLastCall().andReturn(Integer.valueOf(Bundle.ACTIVE)).anyTimes();\n\n        EasyMock.expect(bc.getBundle()).andReturn(b).anyTimes();\n\n        EasyMock.replay(new Object[]\n            {\n                bc, b\n            });\n\n        return b;\n    }","id":25947,"modified_method":"private Bundle getMockBundle()\n    {\n        BundleContext bc = EasyMock.createNiceMock(BundleContext.class);\n        Bundle b = EasyMock.createNiceMock(Bundle.class);\n        EasyMock.expect(b.getBundleContext()).andReturn(bc).anyTimes();\n        b.getState();\n        EasyMock.expectLastCall().andReturn(Integer.valueOf(Bundle.ACTIVE)).anyTimes();\n\n        EasyMock.expect(bc.getBundle()).andReturn(b).anyTimes();\n\n        EasyMock.replay(new Object[]\n            {\n                bc, b\n            });\n\n        return b;\n    }","commit_id":"b9875285b592f83f575021a3f9c9b54f8ad6089f","url":"https://github.com/apache/felix"},{"original_method":"public void testFireServiceEvent()\n    {\n        final Bundle b1 = getMockBundle();\n        final Bundle b2 = getMockBundle();\n        final Bundle b3 = getMockBundle();\n        final Bundle b4 = getMockBundle();\n\n        final Set calledHooks = new HashSet();\n        final EventHook eh1 = new EventHook()\n        {\n            public void event(ServiceEvent event, Collection contexts)\n            {\n                calledHooks.add(this);\n            }\n        };\n        final EventHook eh2 = new EventHook()\n        {\n            public void event(ServiceEvent event, Collection contexts)\n            {\n                calledHooks.add(this);\n                for (Iterator it = contexts.iterator(); it.hasNext();)\n                {\n                    BundleContext bc = (BundleContext) it.next();\n                    if (bc.getBundle() == b1)\n                    {\n                        it.remove();\n                    }\n                    if (bc.getBundle() == b2)\n                    {\n                        it.remove();\n                    }\n                }\n            }\n        };\n\n        Logger logger = new Logger();\n        ServiceRegistry registry = new ServiceRegistry(logger, null);\n        registry.registerService(b4.getBundleContext(), new String [] {EventHook.class.getName()}, eh1, new Hashtable());\n        registry.registerService(b4.getBundleContext(), new String [] {EventHook.class.getName()}, eh2, new Hashtable());\n\n        // -- Set up event dispatcher\n        EventDispatcher ed = new EventDispatcher(logger, registry);\n\n        // -- Register some listeners\n        final List fired = Collections.synchronizedList(new ArrayList());\n        ServiceListener sl1 = new ServiceListener()\n        {\n            public void serviceChanged(ServiceEvent arg0)\n            {\n                fired.add(this);\n                System.out.println(\"*** sl1\");\n            }\n        };\n        ed.addListener(b1.getBundleContext(), ServiceListener.class, sl1, null);\n\n        ServiceListener sl2 = new ServiceListener()\n        {\n            public void serviceChanged(ServiceEvent arg0)\n            {\n                fired.add(this);\n                System.out.println(\"*** sl2\");\n            }\n        };\n        ed.addListener(b2.getBundleContext(), ServiceListener.class, sl2, null);\n\n        ServiceListener sl3 = new ServiceListener()\n        {\n            public void serviceChanged(ServiceEvent arg0)\n            {\n                fired.add(this);\n                System.out.println(\"*** sl3\");\n            }\n        };\n        ed.addListener(b3.getBundleContext(), ServiceListener.class, sl3, null);\n\n        // --- make the invocation\n        ServiceReference sr = (ServiceReference) EasyMock.createNiceMock(ServiceReference.class);\n        EasyMock.expect(sr.getProperty(Constants.OBJECTCLASS)).andReturn(new String[]\n            {\n                \"java.lang.String\"\n            }).anyTimes();\n        sr.isAssignableTo(b1, String.class.getName());\n        EasyMock.expectLastCall().andReturn(Boolean.TRUE).anyTimes();\n        sr.isAssignableTo(b2, String.class.getName());\n        EasyMock.expectLastCall().andReturn(Boolean.TRUE).anyTimes();\n        sr.isAssignableTo(b3, String.class.getName());\n        EasyMock.expectLastCall().andReturn(Boolean.TRUE).anyTimes();\n        EasyMock.replay(new Object[]\n            {\n                sr\n            });\n\n        ServiceEvent event = new ServiceEvent(ServiceEvent.REGISTERED, sr);\n\n        assertEquals(\"Precondition failed\", 0, fired.size());\n\n        Framework framework = (Framework) EasyMock.createNiceMock(Framework.class);\n        EasyMock.replay(new Object[]\n            {\n                framework\n            });\n\n        ed.fireServiceEvent(event, null, framework);\n        assertEquals(1, fired.size());\n        assertSame(sl3, fired.iterator().next());\n\n        assertEquals(2, calledHooks.size());\n        assertTrue(calledHooks.contains(eh1));\n        assertTrue(calledHooks.contains(eh2));\n    }","id":25948,"modified_method":"public void testFireServiceEvent()\n    {\n        final Bundle b1 = getMockBundle();\n        final Bundle b2 = getMockBundle();\n        final Bundle b3 = getMockBundle();\n        final Bundle b4 = getMockBundle();\n\n        final Set calledHooks = new HashSet();\n        final EventHook eh1 = new EventHook()\n        {\n            public void event(ServiceEvent event, Collection contexts)\n            {\n                calledHooks.add(this);\n            }\n        };\n        final EventHook eh2 = new EventHook()\n        {\n            public void event(ServiceEvent event, Collection contexts)\n            {\n                calledHooks.add(this);\n                for (Iterator it = contexts.iterator(); it.hasNext();)\n                {\n                    BundleContext bc = (BundleContext) it.next();\n                    if (bc.getBundle() == b1)\n                    {\n                        it.remove();\n                    }\n                    if (bc.getBundle() == b2)\n                    {\n                        it.remove();\n                    }\n                }\n            }\n        };\n\n        Logger logger = new Logger();\n        ServiceRegistry registry = new ServiceRegistry(logger, null);\n        registry.registerService(b4.getBundleContext(), new String [] {EventHook.class.getName()}, eh1, new Hashtable());\n        registry.registerService(b4.getBundleContext(), new String [] {EventHook.class.getName()}, eh2, new Hashtable());\n\n        // -- Set up event dispatcher\n        EventDispatcher ed = new EventDispatcher(logger, registry);\n\n        // -- Register some listeners\n        final List fired = Collections.synchronizedList(new ArrayList());\n        ServiceListener sl1 = new ServiceListener()\n        {\n            public void serviceChanged(ServiceEvent arg0)\n            {\n                fired.add(this);\n            }\n        };\n        ed.addListener(b1.getBundleContext(), ServiceListener.class, sl1, null);\n\n        ServiceListener sl2 = new ServiceListener()\n        {\n            public void serviceChanged(ServiceEvent arg0)\n            {\n                fired.add(this);\n            }\n        };\n        ed.addListener(b2.getBundleContext(), ServiceListener.class, sl2, null);\n\n        ServiceListener sl3 = new ServiceListener()\n        {\n            public void serviceChanged(ServiceEvent arg0)\n            {\n                fired.add(this);\n            }\n        };\n        ed.addListener(b3.getBundleContext(), ServiceListener.class, sl3, null);\n\n        // --- make the invocation\n        ServiceReference sr = EasyMock.createNiceMock(ServiceReference.class);\n        EasyMock.expect(sr.getProperty(Constants.OBJECTCLASS)).andReturn(new String[]\n            {\n                \"java.lang.String\"\n            }).anyTimes();\n        sr.isAssignableTo(b1, String.class.getName());\n        EasyMock.expectLastCall().andReturn(Boolean.TRUE).anyTimes();\n        sr.isAssignableTo(b2, String.class.getName());\n        EasyMock.expectLastCall().andReturn(Boolean.TRUE).anyTimes();\n        sr.isAssignableTo(b3, String.class.getName());\n        EasyMock.expectLastCall().andReturn(Boolean.TRUE).anyTimes();\n        EasyMock.replay(new Object[]\n            {\n                sr\n            });\n\n        ServiceEvent event = new ServiceEvent(ServiceEvent.REGISTERED, sr);\n\n        assertEquals(\"Precondition failed\", 0, fired.size());\n\n        Framework framework = EasyMock.createNiceMock(Framework.class);\n        EasyMock.replay(new Object[]\n            {\n                framework\n            });\n\n        ed.fireServiceEvent(event, null, framework);\n        assertEquals(1, fired.size());\n        assertSame(sl3, fired.iterator().next());\n\n        assertEquals(2, calledHooks.size());\n        assertTrue(calledHooks.contains(eh1));\n        assertTrue(calledHooks.contains(eh2));\n    }","commit_id":"b9875285b592f83f575021a3f9c9b54f8ad6089f","url":"https://github.com/apache/felix"},{"original_method":"private void deleteSelectedAccounts( ) {\n    if ( currentSelected != null ) {\n      final ArrayList<String> ids = Lists.newArrayList( ); \n      for ( SearchResultRow row : currentSelected ) {\n        ids.add( row.getField( 0 ) );\n      }\n      \n      clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.LOADING, \"Deleting accounts ...\", 0 );\n      \n      clientFactory.getBackendService( ).deleteAccounts( clientFactory.getLocalSession( ).getSession( ), ids, new AsyncCallback<Void>( ) {\n\n        @Override\n        public void onFailure( Throwable caught ) {\n          String error = \"Failed to delete some accounts: \" + caught.getMessage( );\n          clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.ERROR, error, FooterView.DEFAULT_STATUS_CLEAR_DELAY );\n          clientFactory.getShellView( ).getLogView( ).log( LogType.ERROR, error );\n        }\n\n        @Override\n        public void onSuccess( Void arg0 ) {\n          String info = \"Accounts \" + ids + \" deleted\";\n          clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.NONE, info, FooterView.DEFAULT_STATUS_CLEAR_DELAY );\n          clientFactory.getShellView( ).getLogView( ).log( LogType.INFO, info );\n          reloadCurrentRange( );\n        }\n        \n      } );\n    }\n  }","id":25949,"modified_method":"private void deleteSelectedAccounts( ) {\n    if ( currentSelected != null ) {\n      final ArrayList<String> ids = Lists.newArrayList( ); \n      for ( SearchResultRow row : currentSelected ) {\n        ids.add( row.getField( 0 ) );\n      }\n      \n      clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.LOADING, \"Deleting accounts ...\", 0 );\n      \n      clientFactory.getBackendService( ).deleteAccounts( clientFactory.getLocalSession( ).getSession( ), ids, new AsyncCallback<Void>( ) {\n\n        @Override\n        public void onFailure( Throwable caught ) {\n          String error = \"Failure in deleting accounts: \" + caught.getMessage( );\n          clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.ERROR, error, FooterView.DEFAULT_STATUS_CLEAR_DELAY );\n          clientFactory.getShellView( ).getLogView( ).log( LogType.ERROR, error );\n        }\n\n        @Override\n        public void onSuccess( Void arg0 ) {\n          String info = \"Accounts \" + ids + \" deleted\";\n          clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.NONE, info, FooterView.DEFAULT_STATUS_CLEAR_DELAY );\n          clientFactory.getShellView( ).getLogView( ).log( LogType.INFO, info );\n          reloadCurrentRange( );\n        }\n        \n      } );\n    }\n  }","commit_id":"3764314f795ce73a83456c84230b5744bd6c7a80","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void doCreateAccount( final String value ) {\n    this.clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.LOADING, \"Creating account \" + value + \" ...\", 0 );\n    \n    this.clientFactory.getBackendService( ).createAccount( this.clientFactory.getLocalSession( ).getSession( ), value, new AsyncCallback<Void>( ) {\n\n      @Override\n      public void onFailure( Throwable caught ) {\n        String error = \"Failed to create account \" + value + \": \" + caught.getMessage( );\n        clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.ERROR, error, FooterView.DEFAULT_STATUS_CLEAR_DELAY );\n        clientFactory.getShellView( ).getLogView( ).log( LogType.ERROR, error );\n      }\n\n      @Override\n      public void onSuccess( Void arg0 ) {\n        String info = \"Account \" + value + \" created\";\n        clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.NONE, info, FooterView.DEFAULT_STATUS_CLEAR_DELAY );\n        clientFactory.getShellView( ).getLogView( ).log( LogType.INFO, info );\n        reloadCurrentRange( );\n      }\n      \n    } );\n  }","id":25950,"modified_method":"@Override\n  public void doCreateAccount( final String value ) {\n    this.clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.LOADING, \"Creating account \" + value + \" ...\", 0 );\n    \n    this.clientFactory.getBackendService( ).createAccount( this.clientFactory.getLocalSession( ).getSession( ), value, new AsyncCallback<String>( ) {\n\n      @Override\n      public void onFailure( Throwable caught ) {\n        String error = \"Failed to create account \" + value + \": \" + caught.getMessage( );\n        clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.ERROR, error, FooterView.DEFAULT_STATUS_CLEAR_DELAY );\n        clientFactory.getShellView( ).getLogView( ).log( LogType.ERROR, error );\n      }\n\n      @Override\n      public void onSuccess( String accountId ) {\n        String info = \"Account \" + accountId + \" created\";\n        clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.NONE, info, FooterView.DEFAULT_STATUS_CLEAR_DELAY );\n        clientFactory.getShellView( ).getLogView( ).log( LogType.INFO, info );\n        reloadCurrentRange( );\n      }\n      \n    } );\n  }","commit_id":"3764314f795ce73a83456c84230b5744bd6c7a80","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void createAccount( String accountName ) throws EucalyptusServiceException {\n    try {\n      Accounts.addAccount( accountName );\n    } catch ( Exception e ) {\n      throw new EucalyptusServiceException( \"Failed to create account \" + accountName + \": \" + e.getMessage( ) );\n    }\n  }","id":25951,"modified_method":"public static String createAccount( String accountName ) throws EucalyptusServiceException {\n    try {\n      Account account = Accounts.addAccount( accountName );\n      return account.getAccountNumber( );\n    } catch ( Exception e ) {\n      throw new EucalyptusServiceException( \"Failed to create account \" + accountName + \": \" + e.getMessage( ) );\n    }\n  }","commit_id":"3764314f795ce73a83456c84230b5744bd6c7a80","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void createAccount( Session session, String accountName ) throws EucalyptusServiceException {\n    verifySession( session );\n    EuareWebBackend.createAccount( accountName );\n  }","id":25952,"modified_method":"@Override\n  public String createAccount( Session session, String accountName ) throws EucalyptusServiceException {\n    verifySession( session );\n    return EuareWebBackend.createAccount( accountName );\n  }","commit_id":"3764314f795ce73a83456c84230b5744bd6c7a80","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void createAccount( Session session, String accountName ) throws EucalyptusServiceException {\n    // TODO Auto-generated method stub\n    \n  }","id":25953,"modified_method":"@Override\n  public String createAccount( Session session, String accountName ) throws EucalyptusServiceException {\n    return \"1234\";\n  }","commit_id":"3764314f795ce73a83456c84230b5744bd6c7a80","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Account addAccount(\n\t\t\tString address, String personalName, String protocol,\n\t\t\tString incomingHostName, int incomingPort, boolean incomingSecure,\n\t\t\tString outgoingHostName, int outgoingPort, boolean outgoingSecure,\n\t\t\tString login, String password, boolean savePassword,\n\t\t\tString signature, boolean useSignature, String folderPrefix,\n\t\t\tboolean defaultSender)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidateAccount(\n\t\t\tincomingHostName, incomingPort, incomingSecure, outgoingHostName,\n\t\t\toutgoingPort, outgoingSecure, login, password);\n\n\t\ttry {\n\t\t\tAccountLocalServiceUtil.getAccount(user.getUserId(), address);\n\n\t\t\tthrow new MailException(MailException.ACCOUNT_ALREADY_EXISTS);\n\t\t}\n\t\tcatch (NoSuchAccountException nsae) {\n\t\t\tlong inboxFolderId = 0;\n\t\t\tlong draftFolderId = 0;\n\t\t\tlong sentFolderId = 0;\n\t\t\tlong trashFolderId = 0;\n\n\t\t\tAccount account = AccountLocalServiceUtil.addAccount(\n\t\t\t\tuser.getUserId(), address, personalName, protocol,\n\t\t\t\tincomingHostName, incomingPort, incomingSecure,\n\t\t\t\toutgoingHostName, outgoingPort, outgoingSecure, login,\n\t\t\t\tpassword, savePassword, signature, useSignature, folderPrefix,\n\t\t\t\tinboxFolderId, draftFolderId, sentFolderId, trashFolderId,\n\t\t\t\tdefaultSender);\n\n\t\t\tsetAccount(account);\n\n\t\t\tsynchronize();\n\n\t\t\treturn account;\n\t\t}\n\t}","id":25954,"modified_method":"public Account addAccount(\n\t\t\tString address, String personalName, String protocol,\n\t\t\tString incomingHostName, int incomingPort, boolean incomingSecure,\n\t\t\tString outgoingHostName, int outgoingPort, boolean outgoingSecure,\n\t\t\tString login, String password, boolean savePassword,\n\t\t\tString signature, boolean useSignature, String folderPrefix,\n\t\t\tboolean defaultSender)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidateAccount(\n\t\t\tincomingHostName, incomingPort, incomingSecure, outgoingHostName,\n\t\t\toutgoingPort, outgoingSecure, login, password);\n\n\t\ttry {\n\t\t\tAccountLocalServiceUtil.getAccount(user.getUserId(), address);\n\n\t\t\tthrow new MailException(MailException.ACCOUNT_ALREADY_EXISTS);\n\t\t}\n\t\tcatch (NoSuchAccountException nsae) {\n\t\t\tlong inboxFolderId = 0;\n\t\t\tlong draftFolderId = 0;\n\t\t\tlong sentFolderId = 0;\n\t\t\tlong trashFolderId = 0;\n\n\t\t\treturn AccountLocalServiceUtil.addAccount(\n\t\t\t\tuser.getUserId(), address, personalName, protocol,\n\t\t\t\tincomingHostName, incomingPort, incomingSecure,\n\t\t\t\toutgoingHostName, outgoingPort, outgoingSecure, login,\n\t\t\t\tpassword, savePassword, signature, useSignature, folderPrefix,\n\t\t\t\tinboxFolderId, draftFolderId, sentFolderId, trashFolderId,\n\t\t\t\tdefaultSender);\n\t\t}\n\t}","commit_id":"9708f340d38372fbd666d3088738a64a8124fa57","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public JSONObject addAccount(\n\t\t\tString address, String personalName, String protocol,\n\t\t\tString incomingHostName, int incomingPort, boolean incomingSecure,\n\t\t\tString outgoingHostName, int outgoingPort, boolean outgoingSecure,\n\t\t\tString login, String unencryptedPassword, boolean savePassword,\n\t\t\tString signature, boolean useSignature, String folderPrefix,\n\t\t\tboolean defaultSender)\n\t\tthrows PortalException, SystemException {\n\n\t\ttry {\n\t\t\tMailbox mailbox = MailboxFactoryUtil.getMailbox(\n\t\t\t\t_user.getUserId(), protocol);\n\n\t\t\tmailbox.addAccount(\n\t\t\t\taddress, personalName, protocol, incomingHostName, incomingPort,\n\t\t\t\tincomingSecure, outgoingHostName, outgoingPort, outgoingSecure,\n\t\t\t\tlogin, unencryptedPassword, savePassword, signature,\n\t\t\t\tuseSignature, folderPrefix, defaultSender);\n\n\t\t\treturn createJSONResult(\"success\", \"account-has-been-created\");\n\t\t}\n\t\tcatch (MailException me) {\n\t\t\tif (me.getType() == MailException.ACCOUNT_ALREADY_EXISTS) {\n\t\t\t\treturn createJSONResult(\n\t\t\t\t\t\"failure\",\n\t\t\t\t\t\"an-account-with-the-same-address-already-exists\");\n\t\t\t}\n\n\t\t\t_log.error(me, me);\n\n\t\t\treturn createJSONResult(\"failure\", \"unable-to-add-account\");\n\t\t}\n\t}","id":25955,"modified_method":"public JSONObject addAccount(\n\t\t\tString address, String personalName, String protocol,\n\t\t\tString incomingHostName, int incomingPort, boolean incomingSecure,\n\t\t\tString outgoingHostName, int outgoingPort, boolean outgoingSecure,\n\t\t\tString login, String unencryptedPassword, boolean savePassword,\n\t\t\tString signature, boolean useSignature, String folderPrefix,\n\t\t\tboolean defaultSender)\n\t\tthrows PortalException, SystemException {\n\n\t\ttry {\n\t\t\tMailbox mailbox = MailboxFactoryUtil.getMailbox(\n\t\t\t\t_user.getUserId(), protocol);\n\n\t\t\tAccount account = mailbox.addAccount(\n\t\t\t\taddress, personalName, protocol, incomingHostName, incomingPort,\n\t\t\t\tincomingSecure, outgoingHostName, outgoingPort, outgoingSecure,\n\t\t\t\tlogin, unencryptedPassword, savePassword, signature,\n\t\t\t\tuseSignature, folderPrefix, defaultSender);\n\n\t\t\tmailbox = MailboxFactoryUtil.getMailbox(\n\t\t\t\t_user.getUserId(), account.getAccountId());\n\n\t\t\tmailbox.synchronize();\n\n\t\t\treturn createJSONResult(\"success\", \"account-has-been-created\");\n\t\t}\n\t\tcatch (MailException me) {\n\t\t\tif (me.getType() == MailException.ACCOUNT_ALREADY_EXISTS) {\n\t\t\t\treturn createJSONResult(\n\t\t\t\t\t\"failure\",\n\t\t\t\t\t\"an-account-with-the-same-address-already-exists\");\n\t\t\t}\n\n\t\t\t_log.error(me, me);\n\n\t\t\treturn createJSONResult(\"failure\", \"unable-to-add-account\");\n\t\t}\n\t}","commit_id":"9708f340d38372fbd666d3088738a64a8124fa57","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public Account addAccount(\n\t\t\tString address, String protocol, String incomingHostName,\n\t\t\tint incomingPort, boolean incomingSecure, String outgoingHostName,\n\t\t\tint outgoingPort, boolean outgoingSecure, String folderPrefix,\n\t\t\tString password, boolean savePassword, String login,\n\t\t\tString personalName, String signature, boolean useSignature)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidateAccount(\n\t\t\tincomingHostName, incomingPort, incomingSecure, outgoingHostName,\n\t\t\toutgoingPort, outgoingSecure, login, password);\n\n\t\ttry {\n\t\t\tAccountLocalServiceUtil.getAccount(user.getUserId(), address);\n\t\t}\n\t\tcatch (NoSuchAccountException nsae) {\n\t\t\tlong inboxFolderId = 0;\n\t\t\tlong draftFolderId = 0;\n\t\t\tlong sentFolderId = 0;\n\t\t\tlong trashFolderId = 0;\n\n\t\t\treturn AccountLocalServiceUtil.addAccount(\n\t\t\t\tuser.getUserId(), address, personalName, protocol,\n\t\t\t\tincomingHostName, incomingPort, incomingSecure,\n\t\t\t\toutgoingHostName, outgoingPort, outgoingSecure, login, password,\n\t\t\t\tsavePassword, signature, useSignature, folderPrefix,\n\t\t\t\tinboxFolderId, draftFolderId, sentFolderId, trashFolderId,\n\t\t\t\ttrue);\n\t\t}\n\n\t\tthrow new MailException(\"Address already exists\");\n\t}","id":25956,"modified_method":"public Account addAccount(\n\t\t\tString address, String personalName, String protocol,\n\t\t\tString incomingHostName, int incomingPort, boolean incomingSecure,\n\t\t\tString outgoingHostName, int outgoingPort, boolean outgoingSecure,\n\t\t\tString login, String password, boolean savePassword,\n\t\t\tString signature, boolean useSignature, String folderPrefix,\n\t\t\tboolean defaultSender)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidateAccount(\n\t\t\tincomingHostName, incomingPort, incomingSecure, outgoingHostName,\n\t\t\toutgoingPort, outgoingSecure, login, password);\n\n\t\ttry {\n\t\t\tAccountLocalServiceUtil.getAccount(user.getUserId(), address);\n\n\t\t\tthrow new MailException(\"Address already exists\");\n\t\t}\n\t\tcatch (NoSuchAccountException nsae) {\n\t\t\tlong inboxFolderId = 0;\n\t\t\tlong draftFolderId = 0;\n\t\t\tlong sentFolderId = 0;\n\t\t\tlong trashFolderId = 0;\n\n\t\t\tAccount account = AccountLocalServiceUtil.addAccount(\n\t\t\t\tuser.getUserId(), address, personalName, protocol,\n\t\t\t\tincomingHostName, incomingPort, incomingSecure,\n\t\t\t\toutgoingHostName, outgoingPort, outgoingSecure, login,\n\t\t\t\tpassword, savePassword, signature, useSignature, folderPrefix,\n\t\t\t\tinboxFolderId, draftFolderId, sentFolderId, trashFolderId,\n\t\t\t\tdefaultSender);\n\n\t\t\tsetAccount(account);\n\n\t\t\tsynchronize();\n\t\t\n\t\t\treturn account;\n\t\t}\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void updateFolder(long folderId, String displayName) {\n\t}","id":25957,"modified_method":"public void renameFolder(long folderId, String displayName)\n\t\tthrows PortalException, SystemException {\n\n\t\tFolder folder = FolderLocalServiceUtil.getFolder(folderId);\n\n\t\tIMAPUtil imapUtil = getIMAPUtil();\n\n\t\tString[] folderData = imapUtil.renameFolder(\n\t\t\tfolder.getFolderId(), displayName);\n\n\t\tFolderLocalServiceUtil.updateFolder(\n\t\t\tfolderId, folderData[0], folderData[1],\n\t\t\tfolder.getRemoteMessageCount());\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public InternetAddress[] parseAddresses(String addresses) {\n\t\treturn null;\n\t}","id":25958,"modified_method":"public InternetAddress[] parseAddresses(String addresses)\n\t\tthrows PortalException, SystemException {\n\n\t\tInternetAddress[] internetAddresses = new InternetAddress[0];\n\n\t\ttry {\n\t\t\tinternetAddresses = InternetAddress.parse(addresses, true);\n\n\t\t\tfor (int i = 0; i < internetAddresses.length; i++) {\n\t\t\t\tInternetAddress internetAddress = internetAddresses[i];\n\n\t\t\t\tif (!Validator.isEmailAddress(internetAddress.getAddress())) {\n\t\t\t\t\tthrow new MailException(\n\t\t\t\t\t\tMailException.MESSAGE_INVALID_ADDRESS,\n\t\t\t\t\t\tinternetAddress.getPersonal().concat(\"<\").concat(\n\t\t\t\t\t\t\tinternetAddress.getAddress()).concat(\">\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (AddressException ae) {\n\t\t\tthrow new MailException(\n\t\t\t\tMailException.MESSAGE_INVALID_ADDRESS, ae, addresses);\n\t\t}\n\n\t\treturn internetAddresses;\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void sendMessage(long accountId, long messageId) {\n\t}","id":25959,"modified_method":"public void sendMessage(long accountId, long messageId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<Attachment> attachments =\n\t\t\tAttachmentLocalServiceUtil.getAttachments(messageId);\n\n\t\tList<MailFile> mailFiles = new ArrayList<MailFile>();\n\n\t\tfor (Attachment attachment : attachments) {\n\t\t\tFile file = AttachmentLocalServiceUtil.getFile(\n\t\t\t\tattachment.getAttachmentId());\n\n\t\t\tMailFile mailFile = new MailFile(\n\t\t\t\tfile, attachment.getFileName(), attachment.getSize());\n\n\t\t\tmailFiles.add(mailFile);\n\t\t}\n\n\t\tIMAPUtil imapUtil = getIMAPUtil();\n\n\t\tMessage message = MessageLocalServiceUtil.getMessage(messageId);\n\n\t\tAddress[] to = parseAddresses(message.getTo());\n\t\tAddress[] cc = parseAddresses(message.getCc());\n\t\tAddress[] bcc = parseAddresses(message.getBcc());\n\n\t\tAccount account = AccountLocalServiceUtil.getAccount(accountId);\n\n\t\timapUtil.sendMessage(\n\t\t\taccount.getPersonalName(), account.getAddress(), to, cc, bcc,\n\t\t\tmessage.getSubject(), message.getBody(), mailFiles);\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void deleteAttachment(long attachmentId) {\n\t}","id":25960,"modified_method":"public void deleteAttachment(long attachmentId)\n\t\tthrows PortalException, SystemException {\n\n\t\tAttachmentLocalServiceUtil.deleteAttachment(attachmentId);\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public Message getMessage(\n\t\tlong folderId, String keywords, int messageNumber, String orderByField,\n\t\tString orderByType) {\n\n\t\treturn null;\n\t}","id":25961,"modified_method":"public Message getMessage(\n\t\t\tlong folderId, String keywords, int messageNumber,\n\t\t\tString orderByField, String orderByType)\n\t\tthrows PortalException, SystemException {\n\n\t\tMessagesDisplay messagesDisplay = getMessagesDisplay(\n\t\t\tfolderId, keywords, messageNumber, 1, orderByField, orderByType);\n\n\t\treturn messagesDisplay.getMessages().get(0);\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void validateAccount(\n\t\tString incomingHostName, int incomingPort, boolean incomingSecure,\n\t\tString outgoingHostName, int outgoingPort, boolean outgoingSecure,\n\t\tString login, String password) {\n\t}","id":25962,"modified_method":"public void validateAccount(\n\t\t\tString incomingHostName, int incomingPort, boolean incomingSecure,\n\t\t\tString outgoingHostName, int outgoingPort, boolean outgoingSecure,\n\t\t\tString login, String password)\n\t\tthrows PortalException {\n\n\t\tIMAPConnection imapConnection = new IMAPConnection(\n\t\t\tincomingHostName, incomingPort, incomingSecure, outgoingHostName,\n\t\t\toutgoingPort, outgoingSecure, login, password);\n\n\t\timapConnection.testConnection();\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void updateFlags(\n\t\tlong folderId, long[] messageIds, int flag, boolean value) {\n\t}","id":25963,"modified_method":"public void updateFlags(\n\t\t\tlong folderId, long[] messageIds, int flag, boolean value)\n\t\tthrows PortalException, SystemException {\n\n\t\tFolder folder = FolderLocalServiceUtil.getFolder(folderId);\n\n\t\tAccount account = AccountLocalServiceUtil.getAccount(\n\t\t\tfolder.getAccountId());\n\n\t\tIMAPUtil imapUtil = getIMAPUtil();\n\n\t\tif (account.getDraftFolderId() == folder.getFolderId()) {\n\t\t\timapUtil.updateFlags(\n\t\t\t\tfolder.getFolderId(), messageIds, flag, value, false);\n\t\t}\n\t\telse {\n\t\t\timapUtil.updateFlags(\n\t\t\t\tfolder.getFolderId(), messageIds, flag, value, true);\n\t\t}\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void synchronizeMessage(long messageId) {\n\t}","id":25964,"modified_method":"public void synchronizeMessage(long messageId)\n\t\tthrows PortalException, SystemException {\n\n\t\tMessage message = MessageLocalServiceUtil.getMessage(messageId);\n\n\t\tIMAPUtil imapUtil = getIMAPUtil();\n\n\t\tlong remoteMessageId = message.getRemoteMessageId();\n\n\t\tif (remoteMessageId != 0) {\n\t\t\ttry {\n\t\t\t\timapUtil.storeMessages(\n\t\t\t\t\tmessage.getFolderId(),\n\t\t\t\t\tnew long[] { message.getRemoteMessageId() });\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tthrow new MailException(ioe);\n\t\t\t}\n\t\t}\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void synchronize() {\n\t}","id":25965,"modified_method":"public void synchronize() throws PortalException, SystemException {\n\t\tIMAPUtil imapUtil = getIMAPUtil();\n\n\t\t_log.debug(\"Synchronizing account, updating folders\");\n\n\t\tList<javax.mail.Folder> imapFolders = imapUtil.getFolders();\n\n\t\tlong draftFolderId = account.getDraftFolderId();\n\t\tlong inboxFolderId = account.getInboxFolderId();\n\t\tlong sentFolderId = account.getSentFolderId();\n\t\tlong trashFolderId = account.getTrashFolderId();\n\t\t\n\t\tfor (javax.mail.Folder imapFolder : imapFolders) {\n\t\t\tFolder folder;\n\n\t\t\ttry {\n\t\t\t\tfolder = FolderLocalServiceUtil.getFolder(\n\t\t\t\t\taccount.getAccountId(), imapFolder.getFullName());\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException fe) {\n\t\t\t\tfolder = FolderLocalServiceUtil.addFolder(\n\t\t\t\t\tuser.getUserId(), account.getAccountId(),\n\t\t\t\t\timapFolder.getFullName(), imapFolder.getName(), 0);\n\t\t\t}\n\n\t\t\t// Check for special account folders\n\n\t\t\tString folderName = imapFolder.getName().toLowerCase();\n\n\t\t\tif ((inboxFolderId == 0) && (folderName.indexOf(\"inbox\") != -1)) {\n\t\t\t\tinboxFolderId = folder.getFolderId();\n\t\t\t}\n\t\t\telse if ((draftFolderId == 0) &&\n\t\t\t\t\t(folderName.indexOf(\"draft\") != -1)) {\n\n\t\t\t\tdraftFolderId = folder.getFolderId();\n\t\t\t}\n\t\t\telse if ((sentFolderId == 0) &&\n\t\t\t\t\t(folderName.indexOf(\"sent\") != -1)) {\n\n\t\t\t\tsentFolderId = folder.getFolderId();\n\t\t\t}\n\t\t\telse if ((trashFolderId == 0) &&\n\t\t\t\t\t(folderName.indexOf(\"trash\") != -1)) {\n\n\t\t\t\ttrashFolderId = folder.getFolderId();\n\t\t\t}\n\t\t}\n\n\t\tAccountLocalServiceUtil.updateAccountFolders(\n\t\t\taccount.getAccountId(), inboxFolderId, draftFolderId, sentFolderId,\n\t\t\ttrashFolderId);\n\n\t\t_log.debug(\"Synchronizing account, downloading new messages\");\n\n\t\tList<Folder> folders = FolderLocalServiceUtil.getFolders(\n\t\t\taccount.getAccountId());\n\n\t\tfor (Folder folder : folders) {\n\t\t\tsynchronizeFolder(folder.getFolderId());\n\t\t}\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void synchronizePage(\n\t\tlong folderId, int pageNumber, int messagesPerPage) {\n\t}","id":25966,"modified_method":"public void synchronizePage(\n\t\t\tlong folderId, int pageNumber, int messagesPerPage)\n\t\tthrows PortalException, SystemException {\n\n\t\tIMAPUtil imapUtil = getIMAPUtil();\n\n\t\tlong[] remoteMessageIds = imapUtil.getMessageUIDs(\n\t\t\tfolderId, pageNumber, messagesPerPage);\n\n\t\tList<Long> missingRemoteMessageIds = new ArrayList<Long>();\n\n\t\tfor (long remoteMessageId : remoteMessageIds) {\n\t\t\ttry {\n\t\t\t\tMessageLocalServiceUtil.getMessage(\n\t\t\t\t\tfolderId, remoteMessageId);\n\t\t\t}\n\t\t\tcatch (NoSuchMessageException nsme) {\n\t\t\t\t_log.debug(\"remoteMessageId not cached \" + remoteMessageId);\n\n\t\t\t\tmissingRemoteMessageIds.add(new Long(remoteMessageId));\n\t\t\t}\n\t\t}\n\n\t\tif (!missingRemoteMessageIds.isEmpty()) {\n\t\t\t// add to download queue\n\t\t\t//\timapUtil.storeEnvelopes(folderId, remoteMessageIds);\n\t\t}\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void deleteMessages(long folderId, long[] messageIds) {\n\t}","id":25967,"modified_method":"public void deleteMessages(long folderId, long[] messageIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tIMAPUtil imapUtil = getIMAPUtil();\n\n\t\tFolder folder = FolderLocalServiceUtil.getFolder(folderId);\n\n\t\tif ((account.getDraftFolderId() != folderId) &&\n\t\t\t\t(account.getTrashFolderId() != folderId)) {\n\n\t\t\tFolder trashFolder = FolderLocalServiceUtil.getFolder(\n\t\t\t\taccount.getTrashFolderId());\n\n\t\t\timapUtil.moveMessages(\n\t\t\t\tfolder.getFolderId(), trashFolder.getFolderId(),\n\t\t\t\tmessageIds, true);\n\t\t}\n\t\telse {\n\t\t\timapUtil.deleteMessages(folderId, messageIds);\n\t\t}\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public Folder addFolder(String displayName) {\n\t\treturn null;\n\t}","id":25968,"modified_method":"public Folder addFolder(String displayName)\n\t\tthrows PortalException, SystemException {\n\n\t\tIMAPUtil imapUtil = getIMAPUtil();\n\n\t\tString[] folderData = imapUtil.addFolder(displayName);\n\n\t\treturn FolderLocalServiceUtil.addFolder(\n\t\t\tuser.getUserId(), account.getAccountId(), folderData[0],\n\t\t\tfolderData[1], 0);\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void synchronizeFolder(long folderId) {\n\t}","id":25969,"modified_method":"public void synchronizeFolder(long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\t_log.debug(\"downloading new messages for folder \" + folderId);\n\n\t\tIMAPUtil imapUtil = getIMAPUtil();\n\n\t\timapUtil.storeEnvelopes(folderId);\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public InputStream getAttachment(long attachmentId) {\n\t\treturn null;\n\t}","id":25970,"modified_method":"public InputStream getAttachment(long attachmentId)\n\t\tthrows IOException, PortalException, SystemException {\n\n\t\tAttachment attachment = AttachmentLocalServiceUtil.getAttachment(\n\t\t\tattachmentId);\n\n\t\tMessage message = MessageLocalServiceUtil.getMessage(\n\t\t\tattachment.getMessageId());\n\n\t\tif (account.getDraftFolderId() == attachment.getFolderId()) {\n\t\t\treturn AttachmentLocalServiceUtil.getInputStream(\n\t\t\t\tattachmentId);\n\t\t}\n\t\telse {\n\t\t\tIMAPUtil imapUtil = getIMAPUtil();\n\n\t\t\tFolder folder = FolderLocalServiceUtil.getFolder(\n\t\t\t\tattachment.getFolderId());\n\n\t\t\treturn imapUtil.getAttachment(\n\t\t\t\tfolder.getFolderId(), message.getRemoteMessageId(),\n\t\t\t\tattachment.getContentPath());\n\t\t}\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public MessagesDisplay getMessagesDisplay(\n\t\tlong folderId, String keywords, int pageNumber, int messagesPerPage,\n\t\tString orderByField, String orderByType) {\n\n\t\treturn null;\n\t}","id":25971,"modified_method":"public MessagesDisplay getMessagesDisplay(\n\t\t\tlong folderId, String keywords, int pageNumber, int messagesPerPage,\n\t\t\tString orderByField, String orderByType)\n\t\tthrows PortalException, SystemException {\n\n\t\tFolder folder = FolderLocalServiceUtil.getFolder(folderId);\n\n\t\tif (orderByField.equals(MailConstants.ORDER_BY_ADDRESS)) {\n\t\t\tif (account.getSentFolderId() == folderId) {\n\t\t\t\torderByField = \"to\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\torderByField = \"sender\";\n\t\t\t}\n\t\t}\n\t\telse if (!orderByField.equals(MailConstants.ORDER_BY_SENT_DATE) &&\n\t\t\t\t!orderByField.equals(MailConstants.ORDER_BY_SIZE) &&\n\t\t\t\t!orderByField.equals(MailConstants.ORDER_BY_SUBJECT)) {\n\n\t\t\t_log.error(\"unknown orderbyfield \" + orderByField);\n\n\t\t\torderByField = MailConstants.ORDER_BY_SENT_DATE;\n\t\t}\n\n\t\tkeywords = keywords.trim();\n\n\t\tList<Message> messages = new ArrayList<Message>();\n\n\t\tint messageCount = MessageLocalServiceUtil.populateMessages(\n\t\t\tmessages, folderId, keywords, pageNumber, messagesPerPage,\n\t\t\torderByField, orderByType);\n\n\t\tif (Validator.isNotNull(keywords)) {\n\t\t\treturn new MessagesDisplay(\n\t\t\t\tmessages, pageNumber, messagesPerPage, messageCount);\n\t\t}\n\t\telse {\n\t\t\treturn new MessagesDisplay(\n\t\t\t\tmessages, pageNumber, messagesPerPage,\n\t\t\t\tfolder.getRemoteMessageCount());\n\t\t}\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void deleteFolder(long folderId) {\n\t}","id":25972,"modified_method":"public void deleteFolder(long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif ((account.getDraftFolderId() == folderId)\n\t\t\t\t|| (account.getInboxFolderId() == folderId)\n\t\t\t\t|| (account.getSentFolderId() == folderId)\n\t\t\t\t|| (account.getTrashFolderId() == folderId)) {\n\n\t\t\tthrow new MailException(MailException.FOLDER_REQUIRED);\n\t\t}\n\n\t\tIMAPUtil imapUtil = getIMAPUtil();\n\n\t\tFolder folder = FolderLocalServiceUtil.getFolder(folderId);\n\n\t\timapUtil.deleteFolder(folder.getFolderId());\n\n\t\tFolderLocalServiceUtil.deleteFolder(folderId);\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void moveMessages(long folderId, long[] messageIds) {\n\t}","id":25973,"modified_method":"public void moveMessages(long folderId, long[] messageIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tIMAPUtil imapUtil = getIMAPUtil();\n\n\t\tfor (long messageId : messageIds) {\n\t\t\tMessage message = MessageLocalServiceUtil.getMessage(messageId);\n\n\t\t\tAccount account = AccountLocalServiceUtil.getAccount(\n\t\t\t\tmessage.getAccountId());\n\n\t\t\tlong sourceFolderId = message.getFolderId();\n\n\t\t\tif ((account.getDraftFolderId() == sourceFolderId)\n\t\t\t\t\t|| (account.getSentFolderId() == sourceFolderId)) {\n\n\t\t\t\tthrow new MailException(\n\t\t\t\t\tMailException.FOLDER_INVALID_DESTINATION);\n\t\t\t}\n\n\t\t\timapUtil.moveMessages(\n\t\t\t\tsourceFolderId, folderId, new long[] { messageId }, true);\n\t\t}\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public Message saveDraft(\n\t\tlong accountId, long messageId, String to, String cc, String bcc,\n\t\tString subject, String body, List<MailFile> mailFiles) {\n\n\t\treturn null;\n\t}","id":25974,"modified_method":"public Message saveDraft(\n\t\t\tlong accountId, long messageId, String to, String cc, String bcc,\n\t\t\tString subject, String body, List<MailFile> mailFiles)\n\t\tthrows PortalException, SystemException {\n\n\t\tAccount account = AccountLocalServiceUtil.getAccount(accountId);\n\n\t\tString sender = user.getFullName().concat(\" <\").concat(\n\t\t\taccount.getAddress()).concat(\">\");\n\n\t\tString flags = MailConstants.FLAG_DRAFT + StringPool.COMMA;\n\t\tlong remoteMessageId = 0;\n\t\tDate sentDate = null;\n\n\t\tInternetAddress[] parsedTo = parseAddresses(to);\n\t\tInternetAddress[] parsedCc = parseAddresses(cc);\n\t\tInternetAddress[] parsedBcc = parseAddresses(bcc);\n\n\t\tif (parsedTo.length + parsedCc.length + parsedBcc.length == 0) {\n\t\t\tthrow new MailException(MailException.MESSAGE_HAS_NO_RECIPIENTS);\n\t\t}\n\n\t\tif (messageId != 0) {\n\t\t\treturn MessageLocalServiceUtil.updateMessage(\n\t\t\t\tmessageId, account.getDraftFolderId(), sender,\n\t\t\t\tInternetAddressUtil.toString(parsedTo),\n\t\t\t\tInternetAddressUtil.toString(parsedCc),\n\t\t\t\tInternetAddressUtil.toString(parsedBcc), sentDate, subject,\n\t\t\t\tbody, flags, remoteMessageId);\n\t\t}\n\t\telse {\n\t\t\treturn MessageLocalServiceUtil.addMessage(\n\t\t\t\tuser.getUserId(), account.getDraftFolderId(), sender, to, cc,\n\t\t\t\tbcc, sentDate, subject, body, flags, remoteMessageId);\n\t\t}\n\t}","commit_id":"a5e738d95dbb78045a139b0ba4672fec56ac2733","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@NotNull\n  @Override\n  public List<String> retrieveAvailableVersions(@NotNull String groupId,\n                                                @NotNull String artifactId,\n                                                @NotNull List<MavenRemoteRepository> remoteRepositories)\n    throws RemoteException {\n    try {\n      Artifact artifact =\n        new DefaultArtifact(groupId, artifactId, \"\", Artifact.SCOPE_COMPILE, \"pom\", null, new DefaultArtifactHandler(\"pom\"));\n      List<ArtifactVersion> versions = getComponent(ArtifactMetadataSource.class)\n        .retrieveAvailableVersions(\n          artifact,\n          getLocalRepository(),\n          convertRepositories(remoteRepositories));\n      return Lists.newArrayList(Iterables.transform(versions, new Function<ArtifactVersion, String>() {\n        @Override\n        public String apply(ArtifactVersion version) {\n          return version.toString();\n        }\n      }));\n    }\n    catch (Exception e) {\n      Maven3ServerGlobals.getLogger().info(e);\n    }\n    return Collections.emptyList();\n  }","id":25975,"modified_method":"@NotNull\n  @Override\n  public List<String> retrieveAvailableVersions(@NotNull String groupId,\n                                                @NotNull String artifactId,\n                                                @NotNull List<MavenRemoteRepository> remoteRepositories)\n    throws RemoteException {\n    try {\n      Artifact artifact =\n        new DefaultArtifact(groupId, artifactId, \"\", Artifact.SCOPE_COMPILE, \"pom\", null, new DefaultArtifactHandler(\"pom\"));\n      List<ArtifactVersion> versions = getComponent(ArtifactMetadataSource.class)\n        .retrieveAvailableVersions(\n          artifact,\n          getLocalRepository(),\n          convertRepositories(remoteRepositories));\n      return ContainerUtil.map(versions, new Function<ArtifactVersion, String>() {\n        @Override\n        public String fun(ArtifactVersion version) {\n          return version.toString();\n        }\n      });\n    }\n    catch (Exception e) {\n      Maven3ServerGlobals.getLogger().info(e);\n    }\n    return Collections.emptyList();\n  }","commit_id":"fe8aa5a6e5a8e6e16561304cb3f7cd0ede66d6e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Bucket getBucket(@Nullable Resource reference) {\n    if (reference == null) {\n      return null;\n    }\n    if (StringUtils.isNotBlank(reference.getKey())) {\n      return buckets.get(reference);\n    }\n    String relativePathFromSourceDir = null;\n    boolean isTest = false;\n    boolean isDir = false;\n    if (reference instanceof File) {\n      File referenceFile = (File) reference;\n      isTest = Qualifiers.UNIT_TEST_FILE.equals(referenceFile.getQualifier());\n      relativePathFromSourceDir = referenceFile.relativePathFromSourceDir();\n    } else if (reference instanceof Directory) {\n      isDir = true;\n      Directory referenceDir = (Directory) reference;\n      relativePathFromSourceDir = referenceDir.relativePathFromSourceDir();\n      if (Directory.ROOT.equals(relativePathFromSourceDir)) {\n        relativePathFromSourceDir = \"\";\n      }\n    }\n    return null;\n  }","id":25976,"modified_method":"private Bucket getBucket(@Nullable Resource reference) {\n    if (reference == null) {\n      return null;\n    }\n    if (StringUtils.isNotBlank(reference.getKey())) {\n      return buckets.get(reference);\n    }\n    return null;\n  }","commit_id":"6da2fd6aea26d9d29c3d3f39419e000009be9c14","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public DefaultIndex(BatchComponentCache componentCache, DefaultProjectTree projectTree, MeasureCache measureCache, PathResolver pathResolver) {\n    this.componentCache = componentCache;\n    this.projectTree = projectTree;\n    this.measureCache = measureCache;\n    this.pathResolver = pathResolver;\n  }","id":25977,"modified_method":"public DefaultIndex(BatchComponentCache componentCache, DefaultProjectTree projectTree, MeasureCache measureCache) {\n    this.componentCache = componentCache;\n    this.projectTree = projectTree;\n    this.measureCache = measureCache;\n  }","commit_id":"6da2fd6aea26d9d29c3d3f39419e000009be9c14","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void createIndex() throws IOException {\n    ruleFinder = mock(RuleFinder.class);\n\n    DefaultProjectTree projectTree = mock(DefaultProjectTree.class);\n    BatchComponentCache resourceCache = new BatchComponentCache();\n    index = new DefaultIndex(resourceCache, projectTree, mock(MeasureCache.class), new PathResolver());\n\n    baseDir = temp.newFolder();\n    project = new Project(\"project\");\n    when(projectTree.getProjectDefinition(project)).thenReturn(ProjectDefinition.create().setBaseDir(baseDir));\n    moduleA = new Project(\"moduleA\").setParent(project);\n    when(projectTree.getProjectDefinition(moduleA)).thenReturn(ProjectDefinition.create().setBaseDir(new java.io.File(baseDir, \"moduleA\")));\n    moduleB = new Project(\"moduleB\").setParent(project);\n    when(projectTree.getProjectDefinition(moduleB)).thenReturn(ProjectDefinition.create().setBaseDir(new java.io.File(baseDir, \"moduleB\")));\n    moduleB1 = new Project(\"moduleB1\").setParent(moduleB);\n    when(projectTree.getProjectDefinition(moduleB1)).thenReturn(ProjectDefinition.create().setBaseDir(new java.io.File(baseDir, \"moduleB/moduleB1\")));\n\n    RulesProfile rulesProfile = RulesProfile.create();\n    rule = Rule.create(\"repoKey\", \"ruleKey\", \"Rule\");\n    rule.setId(1);\n    rulesProfile.activateRule(rule, null);\n    index.setCurrentProject(project, mock(DefaultSensorStorage.class));\n    index.doStart(project);\n  }","id":25978,"modified_method":"@Before\n  public void createIndex() throws IOException {\n    ruleFinder = mock(RuleFinder.class);\n\n    DefaultProjectTree projectTree = mock(DefaultProjectTree.class);\n    BatchComponentCache resourceCache = new BatchComponentCache();\n    index = new DefaultIndex(resourceCache, projectTree, mock(MeasureCache.class));\n\n    baseDir = temp.newFolder();\n    project = new Project(\"project\");\n    when(projectTree.getProjectDefinition(project)).thenReturn(ProjectDefinition.create().setBaseDir(baseDir));\n    moduleA = new Project(\"moduleA\").setParent(project);\n    when(projectTree.getProjectDefinition(moduleA)).thenReturn(ProjectDefinition.create().setBaseDir(new java.io.File(baseDir, \"moduleA\")));\n    moduleB = new Project(\"moduleB\").setParent(project);\n    when(projectTree.getProjectDefinition(moduleB)).thenReturn(ProjectDefinition.create().setBaseDir(new java.io.File(baseDir, \"moduleB\")));\n    moduleB1 = new Project(\"moduleB1\").setParent(moduleB);\n    when(projectTree.getProjectDefinition(moduleB1)).thenReturn(ProjectDefinition.create().setBaseDir(new java.io.File(baseDir, \"moduleB/moduleB1\")));\n\n    RulesProfile rulesProfile = RulesProfile.create();\n    rule = Rule.create(\"repoKey\", \"ruleKey\", \"Rule\");\n    rule.setId(1);\n    rulesProfile.activateRule(rule, null);\n    index.setCurrentProject(project, mock(DefaultSensorStorage.class));\n    index.doStart(project);\n  }","commit_id":"6da2fd6aea26d9d29c3d3f39419e000009be9c14","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private Collection<Rule> byInternalKey(RuleQuery query) {\n    return Collections2.transform(rules.findByInternalKey(query.getRepositoryKey(), query.getConfigKey()), ruleTransformer);\n  }","id":25979,"modified_method":"private Collection<Rule> byInternalKey(RuleQuery query) {\n    return rules.findByInternalKey(query.getRepositoryKey(), query.getConfigKey()).stream()\n      .map(RuleFinderCompatibility::toRule)\n      .collect(toList());\n  }","commit_id":"6da2fd6aea26d9d29c3d3f39419e000009be9c14","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private Collection<Rule> byRepository(RuleQuery query) {\n    return Collections2.transform(rules.findByRepository(query.getRepositoryKey()), ruleTransformer);\n  }","id":25980,"modified_method":"private Collection<Rule> byRepository(RuleQuery query) {\n    return rules.findByRepository(query.getRepositoryKey()).stream()\n      .map(RuleFinderCompatibility::toRule)\n      .collect(toList());\n  }","commit_id":"6da2fd6aea26d9d29c3d3f39419e000009be9c14","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private Map<String,String> serverParams( String serverType, int serverId, String initialHosts )\n    {\n        Map<String,String> params = stringMap();\n        params.put( \"dbms.mode\", serverType );\n        params.put( ClusterSettings.cluster_name.name(), CLUSTER_NAME );\n        params.put( ClusterSettings.server_id.name(), String.valueOf( serverId ) );\n        params.put( CoreEdgeClusterSettings.initial_core_cluster_members.name(), initialHosts );\n        return params;\n    }","id":25981,"modified_method":"private Map<String,String> serverParams( String serverType, int serverId, String initialHosts )\n    {\n        Map<String,String> params = stringMap();\n        params.put( \"dbms.mode\", serverType );\n        params.put( CoreEdgeClusterSettings.cluster_name.name(), CLUSTER_NAME );\n        params.put( CoreEdgeClusterSettings.server_id.name(), String.valueOf( serverId ) );\n        params.put( CoreEdgeClusterSettings.initial_core_cluster_members.name(), initialHosts );\n        return params;\n    }","commit_id":"e968bdf6246d8129f1295645f3744f2851cbcbf3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public EdgeGraphDatabase getEdgeServerById( int serverId )\n    {\n        for ( EdgeGraphDatabase edgeServer : edgeServers )\n        {\n            if ( serverIdFor( edgeServer ).toIntegerIndex() == serverId )\n            {\n                return edgeServer;\n            }\n        }\n        return null;\n    }","id":25982,"modified_method":"public EdgeGraphDatabase getEdgeServerById( int serverId )\n    {\n        for ( EdgeGraphDatabase edgeServer : edgeServers )\n        {\n            if ( serverIdFor( edgeServer ) == serverId )\n            {\n                return edgeServer;\n            }\n        }\n        return null;\n    }","commit_id":"e968bdf6246d8129f1295645f3744f2851cbcbf3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public CoreGraphDatabase getCoreServerById( int serverId )\n    {\n        for ( CoreGraphDatabase coreServer : coreServers )\n        {\n            if ( serverIdFor( coreServer ).toIntegerIndex() == serverId )\n            {\n                return coreServer;\n            }\n        }\n        return null;\n    }","id":25983,"modified_method":"public CoreGraphDatabase getCoreServerById( int serverId )\n    {\n        for ( CoreGraphDatabase coreServer : coreServers )\n        {\n            if ( serverIdFor( coreServer ) == serverId )\n            {\n                return coreServer;\n            }\n        }\n        return null;\n    }","commit_id":"e968bdf6246d8129f1295645f3744f2851cbcbf3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void removeEdgeServerWithServerId( int serverId )\n    {\n        EdgeGraphDatabase serverToRemove = null;\n        for ( EdgeGraphDatabase edgeServer : edgeServers )\n        {\n            if ( serverIdFor( edgeServer ).toIntegerIndex() == serverId )\n            {\n                edgeServer.shutdown();\n                serverToRemove = edgeServer;\n            }\n        }\n\n        if ( serverToRemove == null )\n        {\n            throw new RuntimeException( \"Could not remove edge server with server id \" + serverId );\n        }\n        else\n        {\n            edgeServers.remove( serverToRemove );\n        }\n    }","id":25984,"modified_method":"public void removeEdgeServerWithServerId( int serverId )\n    {\n        EdgeGraphDatabase serverToRemove = null;\n        for ( EdgeGraphDatabase edgeServer : edgeServers )\n        {\n            if ( serverIdFor( edgeServer ) == serverId )\n            {\n                edgeServer.shutdown();\n                serverToRemove = edgeServer;\n            }\n        }\n\n        if ( serverToRemove == null )\n        {\n            throw new RuntimeException( \"Could not remove edge server with server id \" + serverId );\n        }\n        else\n        {\n            edgeServers.remove( serverToRemove );\n        }\n    }","commit_id":"e968bdf6246d8129f1295645f3744f2851cbcbf3","url":"https://github.com/neo4j/neo4j"},{"original_method":"private InstanceId serverIdFor( GraphDatabaseFacade graphDatabaseFacade )\n    {\n        return graphDatabaseFacade.getDependencyResolver().resolveDependency( Config.class )\n                .get( ClusterSettings.server_id );\n    }","id":25985,"modified_method":"private int serverIdFor( GraphDatabaseFacade graphDatabaseFacade )\n    {\n        return graphDatabaseFacade.getDependencyResolver().resolveDependency( Config.class )\n                .get( CoreEdgeClusterSettings.server_id );\n    }","commit_id":"e968bdf6246d8129f1295645f3744f2851cbcbf3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public HazelcastInstance connectToHazelcast()\n    {\n        ClientConfig clientConfig = new ClientConfig();\n\n        clientConfig.getGroupConfig().setName( config.get( ClusterSettings.cluster_name ) );\n\n        for ( AdvertisedSocketAddress address : config.get( CoreEdgeClusterSettings.initial_core_cluster_members ) )\n        {\n            clientConfig.getNetworkConfig().addAddress( address.toString() );\n        }\n        return HazelcastClient.newHazelcastClient( clientConfig );\n    }","id":25986,"modified_method":"@Override\n    public HazelcastInstance connectToHazelcast()\n    {\n        ClientConfig clientConfig = new ClientConfig();\n\n        clientConfig.getGroupConfig().setName( config.get( CoreEdgeClusterSettings.cluster_name ) );\n\n        for ( AdvertisedSocketAddress address : config.get( CoreEdgeClusterSettings.initial_core_cluster_members ) )\n        {\n            clientConfig.getNetworkConfig().addAddress( address.toString() );\n        }\n        return HazelcastClient.newHazelcastClient( clientConfig );\n    }","commit_id":"e968bdf6246d8129f1295645f3744f2851cbcbf3","url":"https://github.com/neo4j/neo4j"},{"original_method":"private HazelcastInstance createHazelcastInstance()\n    {\n        System.setProperty( GroupProperties.PROP_WAIT_SECONDS_BEFORE_JOIN, \"1\" );\n\n        JoinConfig joinConfig = new JoinConfig();\n        joinConfig.getMulticastConfig().setEnabled( false );\n        TcpIpConfig tcpIpConfig = joinConfig.getTcpIpConfig();\n        tcpIpConfig.setEnabled( true );\n\n        for ( AdvertisedSocketAddress address : config.get( CoreEdgeClusterSettings.initial_core_cluster_members ) )\n        {\n            tcpIpConfig.addMember( address.toString() );\n        }\n\n        NetworkConfig networkConfig = new NetworkConfig();\n        ListenSocketAddress address = config.get( CoreEdgeClusterSettings.cluster_listen_address );\n        networkConfig.setPort( address.socketAddress().getPort() );\n        networkConfig.setJoin( joinConfig );\n        String instanceName = String.valueOf( config.get( ClusterSettings.server_id ).toIntegerIndex() );\n\n        com.hazelcast.config.Config c = new com.hazelcast.config.Config( instanceName );\n        c.setProperty( GroupProperties.PROP_INITIAL_MIN_CLUSTER_SIZE,\n                String.valueOf( minimumClusterSizeThatCanTolerateOneFaultForExpectedClusterSize() ) );\n        c.setProperty( GroupProperties.PROP_LOGGING_TYPE, \"none\" );\n\n        c.setNetworkConfig( networkConfig );\n        c.getGroupConfig().setName( config.get( ClusterSettings.cluster_name ) );\n\n        MemberAttributeConfig memberAttributeConfig = new MemberAttributeConfig();\n        memberAttributeConfig.setIntAttribute( SERVER_ID, config.get( ClusterSettings.server_id ).toIntegerIndex() );\n\n        memberAttributeConfig.setStringAttribute( CLUSTER_SERVER, address.toString() );\n\n        AdvertisedSocketAddress transactionSource = config.get( CoreEdgeClusterSettings.transaction_advertised_address );\n        memberAttributeConfig.setStringAttribute( TRANSACTION_SERVER, transactionSource.toString() );\n\n        AdvertisedSocketAddress raftAddress = config.get( CoreEdgeClusterSettings.raft_advertised_address );\n        memberAttributeConfig.setStringAttribute( RAFT_SERVER, raftAddress.toString() );\n\n        HostnamePort boltAddress = EnterpriseEdgeEditionModule.extractBoltAddress( config );\n        memberAttributeConfig.setStringAttribute( BOLT_SERVER, boltAddress.toString() );\n\n        c.setMemberAttributeConfig( memberAttributeConfig );\n\n        return Hazelcast.newHazelcastInstance( c );\n    }","id":25987,"modified_method":"private HazelcastInstance createHazelcastInstance()\n    {\n        System.setProperty( GroupProperties.PROP_WAIT_SECONDS_BEFORE_JOIN, \"1\" );\n\n        JoinConfig joinConfig = new JoinConfig();\n        joinConfig.getMulticastConfig().setEnabled( false );\n        TcpIpConfig tcpIpConfig = joinConfig.getTcpIpConfig();\n        tcpIpConfig.setEnabled( true );\n\n        for ( AdvertisedSocketAddress address : config.get( CoreEdgeClusterSettings.initial_core_cluster_members ) )\n        {\n            tcpIpConfig.addMember( address.toString() );\n        }\n\n        NetworkConfig networkConfig = new NetworkConfig();\n        ListenSocketAddress address = config.get( CoreEdgeClusterSettings.cluster_listen_address );\n        networkConfig.setPort( address.socketAddress().getPort() );\n        networkConfig.setJoin( joinConfig );\n        int serverId = config.get( CoreEdgeClusterSettings.server_id );\n\n        com.hazelcast.config.Config c = new com.hazelcast.config.Config( String.valueOf( serverId ) );\n        c.setProperty( GroupProperties.PROP_INITIAL_MIN_CLUSTER_SIZE,\n                String.valueOf( minimumClusterSizeThatCanTolerateOneFaultForExpectedClusterSize() ) );\n        c.setProperty( GroupProperties.PROP_LOGGING_TYPE, \"none\" );\n\n        c.setNetworkConfig( networkConfig );\n        c.getGroupConfig().setName( config.get( CoreEdgeClusterSettings.cluster_name ) );\n\n        MemberAttributeConfig memberAttributeConfig = new MemberAttributeConfig();\n        memberAttributeConfig.setIntAttribute( CoreEdgeClusterSettings.server_id.name(), serverId );\n\n        memberAttributeConfig.setStringAttribute( CLUSTER_SERVER, address.toString() );\n\n        AdvertisedSocketAddress transactionSource = config.get( CoreEdgeClusterSettings.transaction_advertised_address );\n        memberAttributeConfig.setStringAttribute( TRANSACTION_SERVER, transactionSource.toString() );\n\n        AdvertisedSocketAddress raftAddress = config.get( CoreEdgeClusterSettings.raft_advertised_address );\n        memberAttributeConfig.setStringAttribute( RAFT_SERVER, raftAddress.toString() );\n\n        HostnamePort boltAddress = EnterpriseEdgeEditionModule.extractBoltAddress( config );\n        memberAttributeConfig.setStringAttribute( BOLT_SERVER, boltAddress.toString() );\n\n        c.setMemberAttributeConfig( memberAttributeConfig );\n\n        return Hazelcast.newHazelcastInstance( c );\n    }","commit_id":"e968bdf6246d8129f1295645f3744f2851cbcbf3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public CoreTopologyService coreDiscoveryService( Config config )\n    {\n        return new TestOnlyCoreTopologyService( config, this );\n    }","id":25988,"modified_method":"@Override\n    public CoreTopologyService coreDiscoveryService( Config config, LogProvider logProvider )\n    {\n        return new TestOnlyCoreTopologyService( config, this );\n    }","commit_id":"e968bdf6246d8129f1295645f3744f2851cbcbf3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    ClientRequestSelector(boolean isInsertScheduler, boolean isSSKScheduler, boolean isRTScheduler, ClientRequestScheduler sched) {\n\t\tthis.sched = sched;\n\t\tthis.isInsertScheduler = isInsertScheduler;\n\t\tthis.isSSKScheduler = isSSKScheduler;\n\t\tthis.isRTScheduler = isRTScheduler;\n\t\tif(!isInsertScheduler) {\n\t\t\tkeysFetching = new HashSet<Key>();\n\t\t\ttransientRequestsWaitingForKeysFetching = new HashMap<Key, WeakReference<BaseSendableGet>[]>();\n\t\t\trunningInserts = null;\n\t\t\trecentSuccesses = new ArrayDeque<BaseSendableGet>();\n\t\t} else {\n\t\t\tkeysFetching = null;\n\t\t\trunningInserts = new HashSet<SendableRequestItemKey>();\n\t\t\trecentSuccesses = null;\n\t\t}\n\t\tpriorities = new SectoredRandomGrabArray[RequestStarter.NUMBER_OF_PRIORITY_CLASSES];\n\t}","id":25989,"modified_method":"ClientRequestSelector(boolean isInsertScheduler, boolean isSSKScheduler, boolean isRTScheduler, ClientRequestScheduler sched) {\n\t\tthis.sched = sched;\n\t\tthis.isInsertScheduler = isInsertScheduler;\n\t\tthis.isSSKScheduler = isSSKScheduler;\n\t\tthis.isRTScheduler = isRTScheduler;\n\t\tif(!isInsertScheduler) {\n\t\t\tkeysFetching = new HashSet<Key>();\n\t\t\ttransientRequestsWaitingForKeysFetching = new HashMap<Key, WeakReference<BaseSendableGet>[]>();\n\t\t\trunningInserts = null;\n\t\t\trecentSuccesses = new ArrayDeque<BaseSendableGet>();\n\t\t} else {\n\t\t\tkeysFetching = null;\n\t\t\trunningInserts = new HashSet<SendableRequestItemKey>();\n\t\t\trecentSuccesses = null;\n\t\t}\n\t\tpriorities = new RequestClientRGANode[RequestStarter.NUMBER_OF_PRIORITY_CLASSES];\n\t}","commit_id":"d41f801ceb1dce249eee8c2fe521d66ab9200cdc","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized long countQueuedRequests(ClientContext context) {\n        long total = 0;\n        for(int i=0;i<priorities.length;i++) {\n            SectoredRandomGrabArray<RequestClient,SectoredRandomGrabArraySimple<RequestClient,ClientRequester>>\n                prio = priorities[i];\n            if(prio == null || prio.isEmpty())\n                System.out.println(\"Priority \"+i+\" : empty\");\n            else {\n                System.out.println(\"Priority \"+i+\" : \"+prio.size());\n                    System.out.println(\"Clients: \"+prio.size()+\" for \"+prio);\n                    for(int k=0;k<prio.size();k++) {\n                        RequestClient client = prio.getClient(k);\n                        System.out.println(\"Client \"+k+\" : \"+client);\n                        SectoredRandomGrabArrayWithObject<RequestClient,ClientRequester,RandomGrabArrayWithClient<ClientRequester>> \n                            requestGrabber = prio.getGrabber(client);\n                        System.out.println(\"SRGA for client: \"+requestGrabber);\n                        for(int l=0;l<requestGrabber.size();l++) {\n                            ClientRequester cr = requestGrabber.getClient(l);\n                            System.out.println(\"Request \"+l+\" : \"+cr);\n                            RandomGrabArray rga = (RandomGrabArray) requestGrabber.getGrabber(cr);\n                            System.out.println(\"Queued SendableRequests: \"+rga.size()+\" on \"+rga);\n                            long sendable = 0;\n                            long all = 0;\n                            for(int m=0;m<rga.size();m++) {\n                                SendableRequest req = (SendableRequest) rga.get(m);\n                                if(req == null) continue;\n                                sendable += req.countSendableKeys(context);\n                                all += req.countAllKeys(context);\n                            }\n                            System.out.println(\"Sendable keys: \"+sendable+\" all keys \"+all+\" diff \"+(all-sendable));\n                            total += all;\n                        }\n                    }\n            }\n        }\n        return total;\n    }","id":25990,"modified_method":"public synchronized long countQueuedRequests(ClientContext context) {\n        long total = 0;\n        for(int i=0;i<priorities.length;i++) {\n            RequestClientRGANode prio = priorities[i];\n            if(prio == null || prio.isEmpty())\n                System.out.println(\"Priority \"+i+\" : empty\");\n            else {\n                System.out.println(\"Priority \"+i+\" : \"+prio.size());\n                    System.out.println(\"Clients: \"+prio.size()+\" for \"+prio);\n                    for(int k=0;k<prio.size();k++) {\n                        RequestClient client = prio.getClient(k);\n                        System.out.println(\"Client \"+k+\" : \"+client);\n                        ClientRequestRGANode requestGrabber = prio.getGrabber(client);\n                        System.out.println(\"SRGA for client: \"+requestGrabber);\n                        for(int l=0;l<requestGrabber.size();l++) {\n                            ClientRequester cr = requestGrabber.getClient(l);\n                            System.out.println(\"Request \"+l+\" : \"+cr);\n                            RandomGrabArray rga = requestGrabber.getGrabber(cr);\n                            System.out.println(\"Queued SendableRequests: \"+rga.size()+\" on \"+rga);\n                            long sendable = 0;\n                            long all = 0;\n                            for(int m=0;m<rga.size();m++) {\n                                SendableRequest req = (SendableRequest) rga.get(m);\n                                if(req == null) continue;\n                                sendable += req.countSendableKeys(context);\n                                all += req.countAllKeys(context);\n                            }\n                            System.out.println(\"Sendable keys: \"+sendable+\" all keys \"+all+\" diff \"+(all-sendable));\n                            total += all;\n                        }\n                    }\n            }\n        }\n        return total;\n    }","commit_id":"d41f801ceb1dce249eee8c2fe521d66ab9200cdc","url":"https://github.com/freenet/fred"},{"original_method":"public void reregisterAll(ClientRequester request, RequestScheduler lock, ClientContext context, short oldPrio) {\n        RequestClient client = request.getClient();\n        short newPrio = request.getPriorityClass();\n        if(newPrio == oldPrio) {\n            Logger.error(this, \"Changing priority from \"+oldPrio+\" to \"+newPrio+\" for \"+request);\n            return;\n        }\n        synchronized(this) {\n            // First by priority\n            SectoredRandomGrabArray<RequestClient,SectoredRandomGrabArraySimple<RequestClient,ClientRequester>>\n                clientGrabber = priorities[oldPrio];\n            if(clientGrabber == null) {\n                // Normal as most of the schedulers aren't relevant to any given insert/request.\n                if(logMINOR) Logger.minor(this, \"Changing priority but request not running \"+request, new Exception(\"debug\"));\n                return;\n            }\n            // Then by RequestClient\n            SectoredRandomGrabArrayWithObject<RequestClient,ClientRequester,RandomGrabArrayWithClient<ClientRequester>> requestGrabber = clientGrabber.getGrabber(client);\n            if(requestGrabber == null) {\n                if(logMINOR) Logger.minor(this, \"Changing priority but request not running \"+request, new Exception(\"debug\"));\n                return;\n            }\n            RandomGrabArrayWithClient<ClientRequester> rga = (RandomGrabArrayWithClient<ClientRequester>) requestGrabber.getGrabber(request);\n            if(rga == null) {\n                if(logMINOR) Logger.minor(this, \"Changing priority but request not running \"+request, new Exception(\"debug\"));\n                return;\n            }\n            requestGrabber.maybeRemove(rga, context);\n            requestGrabber = makeSRGAForClient(newPrio, client, context);\n            if(requestGrabber.getGrabber(request) != null) {\n                Logger.error(this, \"RGA already exists for \"+request+\" : \"+requestGrabber.getGrabber(request)+\n                        \" but want to insert \"+rga, new Exception(\"error\"));\n                requestGrabber.maybeRemove(rga, context);\n            }\n            requestGrabber.addGrabber(request, rga, context);\n        }\n    }","id":25991,"modified_method":"public void reregisterAll(ClientRequester request, RequestScheduler lock, ClientContext context, short oldPrio) {\n        RequestClient client = request.getClient();\n        short newPrio = request.getPriorityClass();\n        if(newPrio == oldPrio) {\n            Logger.error(this, \"Changing priority from \"+oldPrio+\" to \"+newPrio+\" for \"+request);\n            return;\n        }\n        synchronized(this) {\n            // First by priority\n            RequestClientRGANode clientGrabber = priorities[oldPrio];\n            if(clientGrabber == null) {\n                // Normal as most of the schedulers aren't relevant to any given insert/request.\n                if(logMINOR) Logger.minor(this, \"Changing priority but request not running \"+request, new Exception(\"debug\"));\n                return;\n            }\n            // Then by RequestClient\n            ClientRequestRGANode requestGrabber = clientGrabber.getGrabber(client);\n            if(requestGrabber == null) {\n                if(logMINOR) Logger.minor(this, \"Changing priority but request not running \"+request, new Exception(\"debug\"));\n                return;\n            }\n            RandomGrabArrayWithClient<ClientRequester> rga = requestGrabber.getGrabber(request);\n            if(rga == null) {\n                if(logMINOR) Logger.minor(this, \"Changing priority but request not running \"+request, new Exception(\"debug\"));\n                return;\n            }\n            requestGrabber.maybeRemove(rga, context);\n            requestGrabber = makeSRGAForClient(newPrio, client, context);\n            if(requestGrabber.getGrabber(request) != null) {\n                Logger.error(this, \"RGA already exists for \"+request+\" : \"+requestGrabber.getGrabber(request)+\n                        \" but want to insert \"+rga, new Exception(\"error\"));\n                requestGrabber.maybeRemove(rga, context);\n            }\n            requestGrabber.addGrabber(request, rga, context);\n        }\n    }","commit_id":"d41f801ceb1dce249eee8c2fe521d66ab9200cdc","url":"https://github.com/freenet/fred"},{"original_method":"/** Choose a request to run. Does not check whether the SendableRequest is actually runnable at \n\t * the moment. The cooldown mechanism on the RGAs and SRGAs should ensure that it is usable \n\t * most of the time.\n\t * @return Either a chosen request or the time at which we should try again if all priorities \n\t * are waiting for requests to finish / cooldown periods to expire. */\n\tSelectorReturn chooseRequestInner(int fuzz, RandomSource random, OfferedKeysList offeredKeys, RequestStarter starter, boolean realTime, ClientContext context, long now) {\n\t\t// Priorities start at 0\n\t\tif(logMINOR) Logger.minor(this, \"removeFirst()\");\n\t\tboolean tryOfferedKeys = offeredKeys != null && random.nextBoolean();\n\t\tif(tryOfferedKeys) {\n\t\t\tif(offeredKeys.getWakeupTime(context, now) == 0)\n\t\t\t\treturn new SelectorReturn(offeredKeys);\n\t\t}\n\t\tlong l = choosePriority(fuzz, random, context, now);\n\t\tif(l > Integer.MAX_VALUE) {\n\t\t\tif(logMINOR) Logger.minor(this, \"No priority available for the next \"+TimeUtil.formatTime(l - now));\n\t\t\treturn null;\n\t\t}\n\t\tint choosenPriorityClass = (int)l;\n\t\tif(choosenPriorityClass == -1) {\n\t\t\tif(!tryOfferedKeys) {\n\t\t\t\tif(offeredKeys != null && offeredKeys.getWakeupTime(context, now) == 0)\n\t\t\t\t\treturn new SelectorReturn(offeredKeys);\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Nothing to do\");\n\t\t\treturn null;\n\t\t}\n\t\tlong wakeupTime = Long.MAX_VALUE;\nouter:\tfor(;choosenPriorityClass <= RequestStarter.MINIMUM_FETCHABLE_PRIORITY_CLASS;choosenPriorityClass++) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Using priority \"+choosenPriorityClass);\n\t\t\tSectoredRandomGrabArray<RequestClient,SectoredRandomGrabArraySimple<RequestClient,ClientRequester>> \n\t\t\t    chosenTracker = priorities[choosenPriorityClass];\n\t\t\tif(chosenTracker == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No requests to run: chosen priority empty\");\n\t\t\t\tcontinue; // Try next priority\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t    long cooldownTime = chosenTracker.getWakeupTime(context, now);\n\t\t\t    if(cooldownTime > 0) {\n\t\t\t        if(cooldownTime < wakeupTime) wakeupTime = cooldownTime;\n\t\t\t        Logger.normal(this, \"Priority \"+choosenPriorityClass+\" is in cooldown for another \"+(cooldownTime - now)+\" \"+TimeUtil.formatTime(cooldownTime - now));\n\t\t\t        continue outer;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Got priority tracker \"+chosenTracker);\n\t\t\t\tRemoveRandomReturn val;\n\t\t\t\tsynchronized(this) {\n\t\t\t\t    // We must hold the overall lock, just as in addToGrabArrays.\n\t\t\t\t    // This is important for keeping the cooldown tracker consistent amongst other \n\t\t\t\t    // things: We can get a race condition between thread A reading the tree, \n\t\t\t\t    // finding nothing and setCachedWakeup(), and thread B waking up a request, \n\t\t\t\t    // resulting in the request not being accessible.\n\t\t\t\t    val = chosenTracker.removeRandom(starter, context, now);\n\t\t\t\t}\n\t\t\t\tSendableRequest req;\n\t\t\t\tif(val == null) {\n\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned null - nothing to schedule, should remove priority\");\n\t\t\t\t\tcontinue outer;\n\t\t\t\t} else if(val.item == null) {\n\t\t\t\t\tif(val.wakeupTime == -1)\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned cooldown time of -1 - nothing to schedule, should remove priority\");\n\t\t\t\t\telse {\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned cooldown time of \"+(val.wakeupTime - now)+\" = \"+TimeUtil.formatTime(val.wakeupTime - now));\n\t\t\t\t\t\tif(val.wakeupTime > 0 && val.wakeupTime < wakeupTime)\n\t\t\t\t\t\t\twakeupTime = val.wakeupTime;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue outer;\n\t\t\t\t} else {\n\t\t\t\t\treq = (SendableRequest) val.item;\n\t\t\t\t}\n\t\t\t\tif(req.getPriorityClass() != choosenPriorityClass) {\n\t\t\t\t\t// Reinsert it : shouldn't happen if we are calling reregisterAll,\n\t\t\t\t\t// maybe we should ask people to report that error if seen\n\t\t\t\t\tLogger.normal(this, \"In wrong priority class: \"+req+\" (req.prio=\"+req.getPriorityClass()+\" but chosen=\"+choosenPriorityClass+ ')');\n\t\t\t\t\t// Remove it.\n\t\t\t\t\tSectoredRandomGrabArrayWithObject<RequestClient,ClientRequester,RandomGrabArrayWithClient<ClientRequester>> clientGrabber = \n\t\t\t\t\t    chosenTracker.getGrabber(req.getClient());\n\t\t\t\t\tif(clientGrabber != null) {\n\t\t\t\t\t\tRandomGrabArray baseRGA = (RandomGrabArray) clientGrabber.getGrabber(req.getClientRequest());\n\t\t\t\t\t\tif(baseRGA != null) {\n\t\t\t\t\t\t\t// Must synchronize to avoid nasty race conditions with cooldown.\n\t\t\t\t\t\t\tsynchronized(this) {\n\t\t\t\t\t\t\t\tbaseRGA.remove(req, context);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Okay, it's been removed already. Cool.\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.error(this, \"Could not find client grabber for client \"+req.getClient()+\" from \"+chosenTracker);\n\t\t\t\t\t}\n\t\t\t\t\tinnerRegister(req, context, null);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check recentSuccesses\n\t\t\t\t/** Choose a recently succeeded request.\n\t\t\t\t * 50% chance of using a recently succeeded request, if there is one.\n\t\t\t\t * We keep a list of recently succeeded BaseSendableGet's, because transient \n\t\t\t\t * requests are chosen individually. */\n\t\t\t\tif(!isInsertScheduler) {\n\t\t\t\t\tBaseSendableGet altReq = null;\n\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\tif(!recentSuccesses.isEmpty()) {\n\t\t\t\t\t\t\tif(random.nextBoolean()) {\n\t\t\t\t\t\t\t\taltReq = recentSuccesses.poll();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(altReq != null && (altReq.isCancelled())) {\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring cancelled recently succeeded item \"+altReq);\n\t\t\t\t\t\taltReq = null;\n\t\t\t\t\t}\n\t\t\t\t\tif(altReq != null && (l = altReq.getWakeupTime(context, now)) != 0) {\n\t\t\t\t\t\tif(logMINOR) {\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring recently succeeded item, cooldown time = \"+l+((l > 0) ? \" (\"+TimeUtil.formatTime(l - now)+\")\" : \"\"));\n\t\t\t\t\t\t\taltReq = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (altReq != null && altReq != req) {\n\t\t\t\t\t\tint prio = altReq.getPriorityClass();\n\t\t\t\t\t\tif(prio <= choosenPriorityClass) {\n\t\t\t\t\t\t\t// Use the recent one instead\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Recently succeeded (transient) req \"+altReq+\" (prio=\"+altReq.getPriorityClass()+\") is better than \"+req+\" (prio=\"+req.getPriorityClass()+\"), using that\");\n\t\t\t\t\t\t\t// Don't need to reregister, because removeRandom doesn't actually remove!\n\t\t\t\t\t\t\treq = altReq;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Don't use the recent one\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Chosen req \"+req+\" is better, reregistering recently succeeded \"+altReq);\n\t\t\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\t\t\trecentSuccesses.add(altReq);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Now we have chosen a request.\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" (prio \"+\n\t\t\t\t\t\treq.getPriorityClass()+\", client \"+req.getClient()+\", client-req \"+req.getClientRequest()+ ')');\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" of \"+req.getClientRequest());\n\t\t\t\tassert(req.realTimeFlag() == realTime);\n\t\t\t\treturn new SelectorReturn(req);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"No requests to run\");\n\t\treturn null;\n\t}","id":25992,"modified_method":"/** Choose a request to run. Does not check whether the SendableRequest is actually runnable at \n\t * the moment. The cooldown mechanism on the RGAs and SRGAs should ensure that it is usable \n\t * most of the time.\n\t * @return Either a chosen request or the time at which we should try again if all priorities \n\t * are waiting for requests to finish / cooldown periods to expire. */\n\tSelectorReturn chooseRequestInner(int fuzz, RandomSource random, OfferedKeysList offeredKeys, RequestStarter starter, boolean realTime, ClientContext context, long now) {\n\t\t// Priorities start at 0\n\t\tif(logMINOR) Logger.minor(this, \"removeFirst()\");\n\t\tboolean tryOfferedKeys = offeredKeys != null && random.nextBoolean();\n\t\tif(tryOfferedKeys) {\n\t\t\tif(offeredKeys.getWakeupTime(context, now) == 0)\n\t\t\t\treturn new SelectorReturn(offeredKeys);\n\t\t}\n\t\tlong l = choosePriority(fuzz, random, context, now);\n\t\tif(l > Integer.MAX_VALUE) {\n\t\t\tif(logMINOR) Logger.minor(this, \"No priority available for the next \"+TimeUtil.formatTime(l - now));\n\t\t\treturn null;\n\t\t}\n\t\tint choosenPriorityClass = (int)l;\n\t\tif(choosenPriorityClass == -1) {\n\t\t\tif(!tryOfferedKeys) {\n\t\t\t\tif(offeredKeys != null && offeredKeys.getWakeupTime(context, now) == 0)\n\t\t\t\t\treturn new SelectorReturn(offeredKeys);\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Nothing to do\");\n\t\t\treturn null;\n\t\t}\n\t\tlong wakeupTime = Long.MAX_VALUE;\nouter:\tfor(;choosenPriorityClass <= RequestStarter.MINIMUM_FETCHABLE_PRIORITY_CLASS;choosenPriorityClass++) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Using priority \"+choosenPriorityClass);\n\t\t\tRequestClientRGANode chosenTracker = priorities[choosenPriorityClass];\n\t\t\tif(chosenTracker == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No requests to run: chosen priority empty\");\n\t\t\t\tcontinue; // Try next priority\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t    long cooldownTime = chosenTracker.getWakeupTime(context, now);\n\t\t\t    if(cooldownTime > 0) {\n\t\t\t        if(cooldownTime < wakeupTime) wakeupTime = cooldownTime;\n\t\t\t        Logger.normal(this, \"Priority \"+choosenPriorityClass+\" is in cooldown for another \"+(cooldownTime - now)+\" \"+TimeUtil.formatTime(cooldownTime - now));\n\t\t\t        continue outer;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Got priority tracker \"+chosenTracker);\n\t\t\t\tRemoveRandomReturn val;\n\t\t\t\tsynchronized(this) {\n\t\t\t\t    // We must hold the overall lock, just as in addToGrabArrays.\n\t\t\t\t    // This is important for keeping the cooldown tracker consistent amongst other \n\t\t\t\t    // things: We can get a race condition between thread A reading the tree, \n\t\t\t\t    // finding nothing and setCachedWakeup(), and thread B waking up a request, \n\t\t\t\t    // resulting in the request not being accessible.\n\t\t\t\t    val = chosenTracker.removeRandom(starter, context, now);\n\t\t\t\t}\n\t\t\t\tSendableRequest req;\n\t\t\t\tif(val == null) {\n\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned null - nothing to schedule, should remove priority\");\n\t\t\t\t\tcontinue outer;\n\t\t\t\t} else if(val.item == null) {\n\t\t\t\t\tif(val.wakeupTime == -1)\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned cooldown time of -1 - nothing to schedule, should remove priority\");\n\t\t\t\t\telse {\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned cooldown time of \"+(val.wakeupTime - now)+\" = \"+TimeUtil.formatTime(val.wakeupTime - now));\n\t\t\t\t\t\tif(val.wakeupTime > 0 && val.wakeupTime < wakeupTime)\n\t\t\t\t\t\t\twakeupTime = val.wakeupTime;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue outer;\n\t\t\t\t} else {\n\t\t\t\t\treq = (SendableRequest) val.item;\n\t\t\t\t}\n\t\t\t\tif(req.getPriorityClass() != choosenPriorityClass) {\n\t\t\t\t\t// Reinsert it : shouldn't happen if we are calling reregisterAll,\n\t\t\t\t\t// maybe we should ask people to report that error if seen\n\t\t\t\t\tLogger.normal(this, \"In wrong priority class: \"+req+\" (req.prio=\"+req.getPriorityClass()+\" but chosen=\"+choosenPriorityClass+ ')');\n\t\t\t\t\t// Remove it.\n\t\t\t\t\tClientRequestRGANode clientGrabber = chosenTracker.getGrabber(req.getClient());\n\t\t\t\t\tif(clientGrabber != null) {\n\t\t\t\t\t\tRandomGrabArray baseRGA = clientGrabber.getGrabber(req.getClientRequest());\n\t\t\t\t\t\tif(baseRGA != null) {\n\t\t\t\t\t\t\t// Must synchronize to avoid nasty race conditions with cooldown.\n\t\t\t\t\t\t\tsynchronized(this) {\n\t\t\t\t\t\t\t\tbaseRGA.remove(req, context);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Okay, it's been removed already. Cool.\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.error(this, \"Could not find client grabber for client \"+req.getClient()+\" from \"+chosenTracker);\n\t\t\t\t\t}\n\t\t\t\t\tinnerRegister(req, context, null);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check recentSuccesses\n\t\t\t\t/** Choose a recently succeeded request.\n\t\t\t\t * 50% chance of using a recently succeeded request, if there is one.\n\t\t\t\t * We keep a list of recently succeeded BaseSendableGet's, because transient \n\t\t\t\t * requests are chosen individually. */\n\t\t\t\tif(!isInsertScheduler) {\n\t\t\t\t\tBaseSendableGet altReq = null;\n\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\tif(!recentSuccesses.isEmpty()) {\n\t\t\t\t\t\t\tif(random.nextBoolean()) {\n\t\t\t\t\t\t\t\taltReq = recentSuccesses.poll();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(altReq != null && (altReq.isCancelled())) {\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring cancelled recently succeeded item \"+altReq);\n\t\t\t\t\t\taltReq = null;\n\t\t\t\t\t}\n\t\t\t\t\tif(altReq != null && (l = altReq.getWakeupTime(context, now)) != 0) {\n\t\t\t\t\t\tif(logMINOR) {\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring recently succeeded item, cooldown time = \"+l+((l > 0) ? \" (\"+TimeUtil.formatTime(l - now)+\")\" : \"\"));\n\t\t\t\t\t\t\taltReq = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (altReq != null && altReq != req) {\n\t\t\t\t\t\tint prio = altReq.getPriorityClass();\n\t\t\t\t\t\tif(prio <= choosenPriorityClass) {\n\t\t\t\t\t\t\t// Use the recent one instead\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Recently succeeded (transient) req \"+altReq+\" (prio=\"+altReq.getPriorityClass()+\") is better than \"+req+\" (prio=\"+req.getPriorityClass()+\"), using that\");\n\t\t\t\t\t\t\t// Don't need to reregister, because removeRandom doesn't actually remove!\n\t\t\t\t\t\t\treq = altReq;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Don't use the recent one\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Chosen req \"+req+\" is better, reregistering recently succeeded \"+altReq);\n\t\t\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\t\t\trecentSuccesses.add(altReq);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Now we have chosen a request.\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" (prio \"+\n\t\t\t\t\t\treq.getPriorityClass()+\", client \"+req.getClient()+\", client-req \"+req.getClientRequest()+ ')');\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" of \"+req.getClientRequest());\n\t\t\t\tassert(req.realTimeFlag() == realTime);\n\t\t\t\treturn new SelectorReturn(req);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"No requests to run\");\n\t\treturn null;\n\t}","commit_id":"d41f801ceb1dce249eee8c2fe521d66ab9200cdc","url":"https://github.com/freenet/fred"},{"original_method":"/** Add a request (or insert) to the request selection tree.\n     * @param priorityClass The priority of the request.\n     * @param client Label object indicating which larger group of requests this request belongs to\n     * (e.g. the global queue, or an FCP client), and whether it is persistent.\n     * @param cr The high-level request that this single block request is part of. E.g. a fetch for \n     * a single key may download many blocks in a splitfile; an insert for a large freesite is \n     * considered a single @see ClientRequester.\n     * @param req A single SendableRequest object which is one or more low-level requests. E.g. it \n     * can be an insert of a single block, or it can be a request or insert for a single segment \n     * within a splitfile. \n     * @param container The database handle, if the request is persistent, in which case this will\n     * be a ClientRequestSchedulerCore. If so, this method must be called on the database thread.\n     * @param context The client context object, which contains links to all the important objects\n     * that are not persisted in the database, e.g. executors, temporary filename generator, etc.\n     */\n    void addToGrabArray(short priorityClass, RequestClient client, ClientRequester cr, SendableRequest req, ClientContext context) {\n        if((priorityClass > RequestStarter.PAUSED_PRIORITY_CLASS) || (priorityClass < RequestStarter.MAXIMUM_PRIORITY_CLASS))\n            throw new IllegalStateException(\"Invalid priority: \"+priorityClass+\" - range is \"+RequestStarter.MAXIMUM_PRIORITY_CLASS+\" (most important) to \"+RequestStarter.PAUSED_PRIORITY_CLASS+\" (least important)\");\n        // Client\n        synchronized(this) {\n            SectoredRandomGrabArraySimple<RequestClient,ClientRequester> requestGrabber = makeSRGAForClient(priorityClass, client, context);\n            requestGrabber.add(cr, req, context);\n        }\n        sched.wakeStarter();\n    }","id":25993,"modified_method":"/** Add a request (or insert) to the request selection tree.\n     * @param priorityClass The priority of the request.\n     * @param client Label object indicating which larger group of requests this request belongs to\n     * (e.g. the global queue, or an FCP client), and whether it is persistent.\n     * @param cr The high-level request that this single block request is part of. E.g. a fetch for \n     * a single key may download many blocks in a splitfile; an insert for a large freesite is \n     * considered a single @see ClientRequester.\n     * @param req A single SendableRequest object which is one or more low-level requests. E.g. it \n     * can be an insert of a single block, or it can be a request or insert for a single segment \n     * within a splitfile. \n     * @param container The database handle, if the request is persistent, in which case this will\n     * be a ClientRequestSchedulerCore. If so, this method must be called on the database thread.\n     * @param context The client context object, which contains links to all the important objects\n     * that are not persisted in the database, e.g. executors, temporary filename generator, etc.\n     */\n    void addToGrabArray(short priorityClass, RequestClient client, ClientRequester cr, SendableRequest req, ClientContext context) {\n        if((priorityClass > RequestStarter.PAUSED_PRIORITY_CLASS) || (priorityClass < RequestStarter.MAXIMUM_PRIORITY_CLASS))\n            throw new IllegalStateException(\"Invalid priority: \"+priorityClass+\" - range is \"+RequestStarter.MAXIMUM_PRIORITY_CLASS+\" (most important) to \"+RequestStarter.PAUSED_PRIORITY_CLASS+\" (least important)\");\n        // Client\n        synchronized(this) {\n            ClientRequestRGANode requestGrabber = makeSRGAForClient(priorityClass, client, context);\n            requestGrabber.add(cr, req, context);\n        }\n        sched.wakeStarter();\n    }","commit_id":"d41f801ceb1dce249eee8c2fe521d66ab9200cdc","url":"https://github.com/freenet/fred"},{"original_method":"private SectoredRandomGrabArraySimple<RequestClient,ClientRequester> makeSRGAForClient(short priorityClass,\n            RequestClient client, ClientContext context) {\n        SectoredRandomGrabArray<RequestClient,SectoredRandomGrabArraySimple<RequestClient,ClientRequester>>\n            clientGrabber = priorities[priorityClass];\n        if(clientGrabber == null) {\n            clientGrabber = new SectoredRandomGrabArray<RequestClient,SectoredRandomGrabArraySimple<RequestClient,ClientRequester>>(null, this);\n            priorities[priorityClass] = clientGrabber;\n            if(logMINOR) Logger.minor(this, \"Registering client tracker for priority \"+priorityClass+\" : \"+clientGrabber);\n        }\n        // Request\n        SectoredRandomGrabArraySimple<RequestClient,ClientRequester> requestGrabber = clientGrabber.getGrabber(client);\n        if(requestGrabber == null) {\n            requestGrabber = new SectoredRandomGrabArraySimple<RequestClient,ClientRequester>(client, clientGrabber, this);\n            if(logMINOR)\n                Logger.minor(this, \"Creating new grabber: \"+requestGrabber+\" for \"+client+\" from \"+clientGrabber+\" : prio=\"+priorityClass);\n            clientGrabber.addGrabber(client, requestGrabber, context);\n            clientGrabber.clearWakeupTime(context);\n        }\n        return requestGrabber;\n    }","id":25994,"modified_method":"private ClientRequestRGANode makeSRGAForClient(short priorityClass,\n            RequestClient client, ClientContext context) {\n        RequestClientRGANode clientGrabber = priorities[priorityClass];\n        if(clientGrabber == null) {\n            clientGrabber = new RequestClientRGANode(null, this);\n            priorities[priorityClass] = clientGrabber;\n            if(logMINOR) Logger.minor(this, \"Registering client tracker for priority \"+priorityClass+\" : \"+clientGrabber);\n        }\n        // Request\n        ClientRequestRGANode requestGrabber = clientGrabber.getGrabber(client);\n        if(requestGrabber == null) {\n            requestGrabber = new ClientRequestRGANode(client, clientGrabber, this);\n            if(logMINOR)\n                Logger.minor(this, \"Creating new grabber: \"+requestGrabber+\" for \"+client+\" from \"+clientGrabber+\" : prio=\"+priorityClass);\n            clientGrabber.addGrabber(client, requestGrabber, context);\n            clientGrabber.clearWakeupTime(context);\n        }\n        return requestGrabber;\n    }","commit_id":"d41f801ceb1dce249eee8c2fe521d66ab9200cdc","url":"https://github.com/freenet/fred"},{"original_method":"/** Choose a priority to start requests from.\n\t * @return The priority chosen or the time at which a priority will have requests to send.\n\t * LOCKING: Synchronized because we may create new priorities. Both the cooldown queue and the \n\t * RGA hierarchy, rooted at the priorities, use ClientRequestSelector lock. */\n\tprivate synchronized long choosePriority(int fuzz, RandomSource random, ClientContext context, long now){\n\t    SectoredRandomGrabArray<RequestClient,SectoredRandomGrabArraySimple<RequestClient,ClientRequester>> result = null;\n\t\t\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\t\n\t\tshort iteration = 0, priority;\n\t\t// we loop to ensure we try every possibilities ( n + 1)\n\t\t//\n\t\t// PRIO will do 0,1,2,3,4,5,6,0\n\t\t// TWEAKED will do rand%6,0,1,2,3,4,5,6\n\t\twhile(iteration++ < RequestStarter.NUMBER_OF_PRIORITY_CLASSES + 1){\n\t\t\tpriority = fuzz<0 ? tweakedPrioritySelector[random.nextInt(tweakedPrioritySelector.length)] : prioritySelector[Math.abs(fuzz % prioritySelector.length)];\n\t\t\tresult = priorities[priority];\n\t\t\tif(result != null) {\n\t\t\t    long cooldownTime = result.getWakeupTime(context, now);\n\t\t\t    if(cooldownTime > 0) {\n\t\t\t        if(cooldownTime < wakeupTime) wakeupTime = cooldownTime;\n\t\t\t        if(logMINOR) {\n\t\t\t            if(cooldownTime == Long.MAX_VALUE)\n\t\t\t                Logger.minor(this, \"Priority \"+priority+\" is waiting until a request finishes or is empty\");\n\t\t\t            else\n\t\t\t                Logger.minor(this, \"Priority \"+priority+\" is in cooldown for another \"+(cooldownTime - now)+\" \"+TimeUtil.formatTime(cooldownTime - now));\n\t\t\t        }\n\t\t\t        result = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(priority > RequestStarter.MINIMUM_FETCHABLE_PRIORITY_CLASS) {\n\t\t\t\tfuzz++;\n\t\t\t\tcontinue; // Don't return because first round may be higher with soft scheduling\n\t\t\t}\n\t\t\tif(((result != null) && (!result.isEmpty()))) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"using priority : \"+priority);\n\t\t\t\treturn priority;\n\t\t\t}\n\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Priority \"+priority+\" is null (fuzz = \"+fuzz+ ')');\n\t\t\tfuzz++;\n\t\t}\n\t\t\n\t\t//FIXME: implement NONE\n\t\treturn wakeupTime;\n\t}","id":25995,"modified_method":"/** Choose a priority to start requests from.\n\t * @return The priority chosen or the time at which a priority will have requests to send.\n\t * LOCKING: Synchronized because we may create new priorities. Both the cooldown queue and the \n\t * RGA hierarchy, rooted at the priorities, use ClientRequestSelector lock. */\n\tprivate synchronized long choosePriority(int fuzz, RandomSource random, ClientContext context, long now){\n\t    RequestClientRGANode result = null;\n\t\t\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\t\n\t\tshort iteration = 0, priority;\n\t\t// we loop to ensure we try every possibilities ( n + 1)\n\t\t//\n\t\t// PRIO will do 0,1,2,3,4,5,6,0\n\t\t// TWEAKED will do rand%6,0,1,2,3,4,5,6\n\t\twhile(iteration++ < RequestStarter.NUMBER_OF_PRIORITY_CLASSES + 1){\n\t\t\tpriority = fuzz<0 ? tweakedPrioritySelector[random.nextInt(tweakedPrioritySelector.length)] : prioritySelector[Math.abs(fuzz % prioritySelector.length)];\n\t\t\tresult = priorities[priority];\n\t\t\tif(result != null) {\n\t\t\t    long cooldownTime = result.getWakeupTime(context, now);\n\t\t\t    if(cooldownTime > 0) {\n\t\t\t        if(cooldownTime < wakeupTime) wakeupTime = cooldownTime;\n\t\t\t        if(logMINOR) {\n\t\t\t            if(cooldownTime == Long.MAX_VALUE)\n\t\t\t                Logger.minor(this, \"Priority \"+priority+\" is waiting until a request finishes or is empty\");\n\t\t\t            else\n\t\t\t                Logger.minor(this, \"Priority \"+priority+\" is in cooldown for another \"+(cooldownTime - now)+\" \"+TimeUtil.formatTime(cooldownTime - now));\n\t\t\t        }\n\t\t\t        result = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(priority > RequestStarter.MINIMUM_FETCHABLE_PRIORITY_CLASS) {\n\t\t\t\tfuzz++;\n\t\t\t\tcontinue; // Don't return because first round may be higher with soft scheduling\n\t\t\t}\n\t\t\tif(((result != null) && (!result.isEmpty()))) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"using priority : \"+priority);\n\t\t\t\treturn priority;\n\t\t\t}\n\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Priority \"+priority+\" is null (fuzz = \"+fuzz+ ')');\n\t\t\tfuzz++;\n\t\t}\n\t\t\n\t\t//FIXME: implement NONE\n\t\treturn wakeupTime;\n\t}","commit_id":"d41f801ceb1dce249eee8c2fe521d66ab9200cdc","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized long countQueuedRequests(ClientContext context) {\n        long total = 0;\n        for(int i=0;i<priorities.length;i++) {\n            SectoredRandomGrabArray<RequestClient> prio = priorities[i];\n            if(prio == null || prio.isEmpty())\n                System.out.println(\"Priority \"+i+\" : empty\");\n            else {\n                System.out.println(\"Priority \"+i+\" : \"+prio.size());\n                    System.out.println(\"Clients: \"+prio.size()+\" for \"+prio);\n                    for(int k=0;k<prio.size();k++) {\n                        RequestClient client = prio.getClient(k);\n                        System.out.println(\"Client \"+k+\" : \"+client);\n                        SectoredRandomGrabArrayWithObject<RequestClient,ClientRequester> requestGrabber = (SectoredRandomGrabArrayWithObject<RequestClient,ClientRequester>) prio.getGrabber(client);\n                        System.out.println(\"SRGA for client: \"+requestGrabber);\n                        for(int l=0;l<requestGrabber.size();l++) {\n                            ClientRequester cr = requestGrabber.getClient(l);\n                            System.out.println(\"Request \"+l+\" : \"+cr);\n                            RandomGrabArray rga = (RandomGrabArray) requestGrabber.getGrabber(cr);\n                            System.out.println(\"Queued SendableRequests: \"+rga.size()+\" on \"+rga);\n                            long sendable = 0;\n                            long all = 0;\n                            for(int m=0;m<rga.size();m++) {\n                                SendableRequest req = (SendableRequest) rga.get(m);\n                                if(req == null) continue;\n                                sendable += req.countSendableKeys(context);\n                                all += req.countAllKeys(context);\n                            }\n                            System.out.println(\"Sendable keys: \"+sendable+\" all keys \"+all+\" diff \"+(all-sendable));\n                            total += all;\n                        }\n                    }\n            }\n        }\n        return total;\n    }","id":25996,"modified_method":"public synchronized long countQueuedRequests(ClientContext context) {\n        long total = 0;\n        for(int i=0;i<priorities.length;i++) {\n            SectoredRandomGrabArray<RequestClient,SectoredRandomGrabArraySimple<RequestClient,ClientRequester>>\n                prio = priorities[i];\n            if(prio == null || prio.isEmpty())\n                System.out.println(\"Priority \"+i+\" : empty\");\n            else {\n                System.out.println(\"Priority \"+i+\" : \"+prio.size());\n                    System.out.println(\"Clients: \"+prio.size()+\" for \"+prio);\n                    for(int k=0;k<prio.size();k++) {\n                        RequestClient client = prio.getClient(k);\n                        System.out.println(\"Client \"+k+\" : \"+client);\n                        SectoredRandomGrabArrayWithObject<RequestClient,ClientRequester,RandomGrabArrayWithClient<ClientRequester>> \n                            requestGrabber = prio.getGrabber(client);\n                        System.out.println(\"SRGA for client: \"+requestGrabber);\n                        for(int l=0;l<requestGrabber.size();l++) {\n                            ClientRequester cr = requestGrabber.getClient(l);\n                            System.out.println(\"Request \"+l+\" : \"+cr);\n                            RandomGrabArray rga = (RandomGrabArray) requestGrabber.getGrabber(cr);\n                            System.out.println(\"Queued SendableRequests: \"+rga.size()+\" on \"+rga);\n                            long sendable = 0;\n                            long all = 0;\n                            for(int m=0;m<rga.size();m++) {\n                                SendableRequest req = (SendableRequest) rga.get(m);\n                                if(req == null) continue;\n                                sendable += req.countSendableKeys(context);\n                                all += req.countAllKeys(context);\n                            }\n                            System.out.println(\"Sendable keys: \"+sendable+\" all keys \"+all+\" diff \"+(all-sendable));\n                            total += all;\n                        }\n                    }\n            }\n        }\n        return total;\n    }","commit_id":"77419465714e500f0c35ad6f352bbba3c609d449","url":"https://github.com/freenet/fred"},{"original_method":"/** Add a request (or insert) to the request selection tree.\n     * @param priorityClass The priority of the request.\n     * @param client Label object indicating which larger group of requests this request belongs to\n     * (e.g. the global queue, or an FCP client), and whether it is persistent.\n     * @param cr The high-level request that this single block request is part of. E.g. a fetch for \n     * a single key may download many blocks in a splitfile; an insert for a large freesite is \n     * considered a single @see ClientRequester.\n     * @param req A single SendableRequest object which is one or more low-level requests. E.g. it \n     * can be an insert of a single block, or it can be a request or insert for a single segment \n     * within a splitfile. \n     * @param container The database handle, if the request is persistent, in which case this will\n     * be a ClientRequestSchedulerCore. If so, this method must be called on the database thread.\n     * @param context The client context object, which contains links to all the important objects\n     * that are not persisted in the database, e.g. executors, temporary filename generator, etc.\n     */\n    void addToGrabArray(short priorityClass, RequestClient client, ClientRequester cr, SendableRequest req, ClientContext context) {\n        if((priorityClass > RequestStarter.PAUSED_PRIORITY_CLASS) || (priorityClass < RequestStarter.MAXIMUM_PRIORITY_CLASS))\n            throw new IllegalStateException(\"Invalid priority: \"+priorityClass+\" - range is \"+RequestStarter.MAXIMUM_PRIORITY_CLASS+\" (most important) to \"+RequestStarter.PAUSED_PRIORITY_CLASS+\" (least important)\");\n        // Client\n        synchronized(this) {\n            SectoredRandomGrabArrayWithObject<RequestClient,ClientRequester> requestGrabber = makeSRGAForClient(priorityClass, client, context);\n            requestGrabber.add(cr, req, context);\n        }\n        sched.wakeStarter();\n    }","id":25997,"modified_method":"/** Add a request (or insert) to the request selection tree.\n     * @param priorityClass The priority of the request.\n     * @param client Label object indicating which larger group of requests this request belongs to\n     * (e.g. the global queue, or an FCP client), and whether it is persistent.\n     * @param cr The high-level request that this single block request is part of. E.g. a fetch for \n     * a single key may download many blocks in a splitfile; an insert for a large freesite is \n     * considered a single @see ClientRequester.\n     * @param req A single SendableRequest object which is one or more low-level requests. E.g. it \n     * can be an insert of a single block, or it can be a request or insert for a single segment \n     * within a splitfile. \n     * @param container The database handle, if the request is persistent, in which case this will\n     * be a ClientRequestSchedulerCore. If so, this method must be called on the database thread.\n     * @param context The client context object, which contains links to all the important objects\n     * that are not persisted in the database, e.g. executors, temporary filename generator, etc.\n     */\n    void addToGrabArray(short priorityClass, RequestClient client, ClientRequester cr, SendableRequest req, ClientContext context) {\n        if((priorityClass > RequestStarter.PAUSED_PRIORITY_CLASS) || (priorityClass < RequestStarter.MAXIMUM_PRIORITY_CLASS))\n            throw new IllegalStateException(\"Invalid priority: \"+priorityClass+\" - range is \"+RequestStarter.MAXIMUM_PRIORITY_CLASS+\" (most important) to \"+RequestStarter.PAUSED_PRIORITY_CLASS+\" (least important)\");\n        // Client\n        synchronized(this) {\n            SectoredRandomGrabArraySimple<RequestClient,ClientRequester> requestGrabber = makeSRGAForClient(priorityClass, client, context);\n            requestGrabber.add(cr, req, context);\n        }\n        sched.wakeStarter();\n    }","commit_id":"77419465714e500f0c35ad6f352bbba3c609d449","url":"https://github.com/freenet/fred"},{"original_method":"public void reregisterAll(ClientRequester request, RequestScheduler lock, ClientContext context, short oldPrio) {\n        RequestClient client = request.getClient();\n        short newPrio = request.getPriorityClass();\n        if(newPrio == oldPrio) {\n            Logger.error(this, \"Changing priority from \"+oldPrio+\" to \"+newPrio+\" for \"+request);\n            return;\n        }\n        synchronized(this) {\n            // First by priority\n            SectoredRandomGrabArray<RequestClient> clientGrabber = priorities[oldPrio];\n            if(clientGrabber == null) {\n                // Normal as most of the schedulers aren't relevant to any given insert/request.\n                if(logMINOR) Logger.minor(this, \"Changing priority but request not running \"+request, new Exception(\"debug\"));\n                return;\n            }\n            // Then by RequestClient\n            SectoredRandomGrabArrayWithObject<RequestClient,ClientRequester> requestGrabber = (SectoredRandomGrabArrayWithObject<RequestClient,ClientRequester>) clientGrabber.getGrabber(client);\n            if(requestGrabber == null) {\n                if(logMINOR) Logger.minor(this, \"Changing priority but request not running \"+request, new Exception(\"debug\"));\n                return;\n            }\n            RandomGrabArrayWithClient<ClientRequester> rga = (RandomGrabArrayWithClient<ClientRequester>) requestGrabber.getGrabber(request);\n            if(rga == null) {\n                if(logMINOR) Logger.minor(this, \"Changing priority but request not running \"+request, new Exception(\"debug\"));\n                return;\n            }\n            requestGrabber.maybeRemove(rga, context);\n            requestGrabber = makeSRGAForClient(newPrio, client, context);\n            if(requestGrabber.getGrabber(request) != null) {\n                Logger.error(this, \"RGA already exists for \"+request+\" : \"+requestGrabber.getGrabber(request)+\n                        \" but want to insert \"+rga, new Exception(\"error\"));\n                requestGrabber.maybeRemove(rga, context);\n            }\n            requestGrabber.addGrabber(request, rga, context);\n        }\n    }","id":25998,"modified_method":"public void reregisterAll(ClientRequester request, RequestScheduler lock, ClientContext context, short oldPrio) {\n        RequestClient client = request.getClient();\n        short newPrio = request.getPriorityClass();\n        if(newPrio == oldPrio) {\n            Logger.error(this, \"Changing priority from \"+oldPrio+\" to \"+newPrio+\" for \"+request);\n            return;\n        }\n        synchronized(this) {\n            // First by priority\n            SectoredRandomGrabArray<RequestClient,SectoredRandomGrabArraySimple<RequestClient,ClientRequester>>\n                clientGrabber = priorities[oldPrio];\n            if(clientGrabber == null) {\n                // Normal as most of the schedulers aren't relevant to any given insert/request.\n                if(logMINOR) Logger.minor(this, \"Changing priority but request not running \"+request, new Exception(\"debug\"));\n                return;\n            }\n            // Then by RequestClient\n            SectoredRandomGrabArrayWithObject<RequestClient,ClientRequester,RandomGrabArrayWithClient<ClientRequester>> requestGrabber = clientGrabber.getGrabber(client);\n            if(requestGrabber == null) {\n                if(logMINOR) Logger.minor(this, \"Changing priority but request not running \"+request, new Exception(\"debug\"));\n                return;\n            }\n            RandomGrabArrayWithClient<ClientRequester> rga = (RandomGrabArrayWithClient<ClientRequester>) requestGrabber.getGrabber(request);\n            if(rga == null) {\n                if(logMINOR) Logger.minor(this, \"Changing priority but request not running \"+request, new Exception(\"debug\"));\n                return;\n            }\n            requestGrabber.maybeRemove(rga, context);\n            requestGrabber = makeSRGAForClient(newPrio, client, context);\n            if(requestGrabber.getGrabber(request) != null) {\n                Logger.error(this, \"RGA already exists for \"+request+\" : \"+requestGrabber.getGrabber(request)+\n                        \" but want to insert \"+rga, new Exception(\"error\"));\n                requestGrabber.maybeRemove(rga, context);\n            }\n            requestGrabber.addGrabber(request, rga, context);\n        }\n    }","commit_id":"77419465714e500f0c35ad6f352bbba3c609d449","url":"https://github.com/freenet/fred"},{"original_method":"/** Choose a priority to start requests from.\n\t * @return The priority chosen or the time at which a priority will have requests to send.\n\t * LOCKING: Synchronized because we may create new priorities. Both the cooldown queue and the \n\t * RGA hierarchy, rooted at the priorities, use ClientRequestSelector lock. */\n\tprivate synchronized long choosePriority(int fuzz, RandomSource random, ClientContext context, long now){\n\t\tSectoredRandomGrabArray<RequestClient> result = null;\n\t\t\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\t\n\t\tshort iteration = 0, priority;\n\t\t// we loop to ensure we try every possibilities ( n + 1)\n\t\t//\n\t\t// PRIO will do 0,1,2,3,4,5,6,0\n\t\t// TWEAKED will do rand%6,0,1,2,3,4,5,6\n\t\twhile(iteration++ < RequestStarter.NUMBER_OF_PRIORITY_CLASSES + 1){\n\t\t\tpriority = fuzz<0 ? tweakedPrioritySelector[random.nextInt(tweakedPrioritySelector.length)] : prioritySelector[Math.abs(fuzz % prioritySelector.length)];\n\t\t\tresult = priorities[priority];\n\t\t\tif(result != null) {\n\t\t\t    long cooldownTime = result.getWakeupTime(context, now);\n\t\t\t    if(cooldownTime > 0) {\n\t\t\t        if(cooldownTime < wakeupTime) wakeupTime = cooldownTime;\n\t\t\t        if(logMINOR) {\n\t\t\t            if(cooldownTime == Long.MAX_VALUE)\n\t\t\t                Logger.minor(this, \"Priority \"+priority+\" is waiting until a request finishes or is empty\");\n\t\t\t            else\n\t\t\t                Logger.minor(this, \"Priority \"+priority+\" is in cooldown for another \"+(cooldownTime - now)+\" \"+TimeUtil.formatTime(cooldownTime - now));\n\t\t\t        }\n\t\t\t        result = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(priority > RequestStarter.MINIMUM_FETCHABLE_PRIORITY_CLASS) {\n\t\t\t\tfuzz++;\n\t\t\t\tcontinue; // Don't return because first round may be higher with soft scheduling\n\t\t\t}\n\t\t\tif(((result != null) && (!result.isEmpty()))) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"using priority : \"+priority);\n\t\t\t\treturn priority;\n\t\t\t}\n\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Priority \"+priority+\" is null (fuzz = \"+fuzz+ ')');\n\t\t\tfuzz++;\n\t\t}\n\t\t\n\t\t//FIXME: implement NONE\n\t\treturn wakeupTime;\n\t}","id":25999,"modified_method":"/** Choose a priority to start requests from.\n\t * @return The priority chosen or the time at which a priority will have requests to send.\n\t * LOCKING: Synchronized because we may create new priorities. Both the cooldown queue and the \n\t * RGA hierarchy, rooted at the priorities, use ClientRequestSelector lock. */\n\tprivate synchronized long choosePriority(int fuzz, RandomSource random, ClientContext context, long now){\n\t    SectoredRandomGrabArray<RequestClient,SectoredRandomGrabArraySimple<RequestClient,ClientRequester>> result = null;\n\t\t\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\t\n\t\tshort iteration = 0, priority;\n\t\t// we loop to ensure we try every possibilities ( n + 1)\n\t\t//\n\t\t// PRIO will do 0,1,2,3,4,5,6,0\n\t\t// TWEAKED will do rand%6,0,1,2,3,4,5,6\n\t\twhile(iteration++ < RequestStarter.NUMBER_OF_PRIORITY_CLASSES + 1){\n\t\t\tpriority = fuzz<0 ? tweakedPrioritySelector[random.nextInt(tweakedPrioritySelector.length)] : prioritySelector[Math.abs(fuzz % prioritySelector.length)];\n\t\t\tresult = priorities[priority];\n\t\t\tif(result != null) {\n\t\t\t    long cooldownTime = result.getWakeupTime(context, now);\n\t\t\t    if(cooldownTime > 0) {\n\t\t\t        if(cooldownTime < wakeupTime) wakeupTime = cooldownTime;\n\t\t\t        if(logMINOR) {\n\t\t\t            if(cooldownTime == Long.MAX_VALUE)\n\t\t\t                Logger.minor(this, \"Priority \"+priority+\" is waiting until a request finishes or is empty\");\n\t\t\t            else\n\t\t\t                Logger.minor(this, \"Priority \"+priority+\" is in cooldown for another \"+(cooldownTime - now)+\" \"+TimeUtil.formatTime(cooldownTime - now));\n\t\t\t        }\n\t\t\t        result = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(priority > RequestStarter.MINIMUM_FETCHABLE_PRIORITY_CLASS) {\n\t\t\t\tfuzz++;\n\t\t\t\tcontinue; // Don't return because first round may be higher with soft scheduling\n\t\t\t}\n\t\t\tif(((result != null) && (!result.isEmpty()))) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"using priority : \"+priority);\n\t\t\t\treturn priority;\n\t\t\t}\n\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Priority \"+priority+\" is null (fuzz = \"+fuzz+ ')');\n\t\t\tfuzz++;\n\t\t}\n\t\t\n\t\t//FIXME: implement NONE\n\t\treturn wakeupTime;\n\t}","commit_id":"77419465714e500f0c35ad6f352bbba3c609d449","url":"https://github.com/freenet/fred"}]