[{"original_method":"@Override\n\tpublic boolean instanceShouldLog(LogLevel priority, Class<?> c) {\n\t\tDetailedThreshold[] thresholds;\n\t\tLogLevel thresh;\n\t\tsynchronized(this) {\n\t\t\tthresholds = detailedThresholds;\n\t\t\tthresh = threshold;\n\t\t}\n\t\tif ((c != null) && (thresholds.length > 0)) {\n\t\t\tString cname = c.getName();\n\t\t\t\tfor(DetailedThreshold dt : thresholds) {\n\t\t\t\t\tif(cname.startsWith(dt.section))\n\t\t\t\t\t\tthresh = dt.dThreshold;\n\t\t\t\t}\n\t\t}\n\t\treturn priority.ordinal() <= thresh.ordinal();\n\t}","id":102000,"modified_method":"@Override\n\tpublic boolean instanceShouldLog(LogLevel priority, Class<?> c) {\n\t\tDetailedThreshold[] thresholds;\n\t\tLogLevel thresh;\n\t\tsynchronized(this) {\n\t\t\tthresholds = detailedThresholds;\n\t\t\tthresh = threshold;\n\t\t}\n\t\tif ((c != null) && (thresholds.length > 0)) {\n\t\t\tString cname = c.getName();\n\t\t\t\tfor(DetailedThreshold dt : thresholds) {\n\t\t\t\t\tif(cname.startsWith(dt.section))\n\t\t\t\t\t\tthresh = dt.dThreshold;\n\t\t\t\t}\n\t\t}\n\t\treturn priority.matchesThreshold(thresh);\n\t}","commit_id":"d2b13f6928a73a43c66244426949bd04e31bff8f","url":"https://github.com/freenet/fred"},{"original_method":"public boolean acceptPriority(LogLevel prio) {\n\t\treturn prio.ordinal() <= threshold.ordinal();\n\t}","id":102001,"modified_method":"public boolean acceptPriority(LogLevel prio) {\n\t\treturn prio.matchesThreshold(threshold);\n\t}","commit_id":"d2b13f6928a73a43c66244426949bd04e31bff8f","url":"https://github.com/freenet/fred"},{"original_method":"public String getDescription() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"Completed \");\n\t\tif((minSuccessfulBlocks == 0) && (succeedBlocks == 0))\n\t\t\tminSuccessfulBlocks = 1;\n\t\tif(minSuccessfulBlocks == 0) {\n\t\t\tif(Logger.globalGetThreshold().ordinal() < LogLevel.MINOR.ordinal())\n\t\t\t\tLogger.error(this, \"minSuccessfulBlocks=0, succeedBlocks=\"+succeedBlocks+\", totalBlocks=\"+totalBlocks+\n\t\t\t\t\t\t\", failedBlocks=\"+failedBlocks+\", fatallyFailedBlocks=\"+fatallyFailedBlocks+\", finalizedTotal=\"+finalizedTotal);\n\t\t\telse\n\t\t\t\tLogger.error(this, \"minSuccessfulBlocks=0, succeedBlocks=\"+succeedBlocks+\", totalBlocks=\"+totalBlocks+\n\t\t\t\t\t\t\", failedBlocks=\"+failedBlocks+\", fatallyFailedBlocks=\"+fatallyFailedBlocks+\", finalizedTotal=\"+finalizedTotal, new Exception(\"debug\"));\n\t\t} else {\n\t\t\tsb.append((100*(succeedBlocks)/minSuccessfulBlocks));\n\t\t\tsb.append('%');\n\t\t}\n\t\tsb.append(' ');\n\t\tsb.append(succeedBlocks);\n\t\tsb.append('/');\n\t\tsb.append(minSuccessfulBlocks);\n\t\tsb.append(\" (failed \");\n\t\tsb.append(failedBlocks);\n\t\tsb.append(\", fatally \");\n\t\tsb.append(fatallyFailedBlocks);\n\t\tsb.append(\", total \");\n\t\tsb.append(totalBlocks);\n\t\tsb.append(\") \");\n\t\tsb.append(finalizedTotal ? \" (finalized total)\" : \"\");\n\t\treturn sb.toString();\n\t}","id":102002,"modified_method":"public String getDescription() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"Completed \");\n\t\tif((minSuccessfulBlocks == 0) && (succeedBlocks == 0))\n\t\t\tminSuccessfulBlocks = 1;\n\t\tif(minSuccessfulBlocks == 0) {\n\t\t\tif(LogLevel.MINOR.matchesThreshold(Logger.globalGetThreshold()))\n\t\t\t\tLogger.error(this, \"minSuccessfulBlocks=0, succeedBlocks=\"+succeedBlocks+\", totalBlocks=\"+totalBlocks+\n\t\t\t\t\t\t\", failedBlocks=\"+failedBlocks+\", fatallyFailedBlocks=\"+fatallyFailedBlocks+\", finalizedTotal=\"+finalizedTotal, new Exception(\"debug\"));\n\t\t\telse\n\t\t\t\tLogger.error(this, \"minSuccessfulBlocks=0, succeedBlocks=\"+succeedBlocks+\", totalBlocks=\"+totalBlocks+\n\t\t\t\t\t\t\", failedBlocks=\"+failedBlocks+\", fatallyFailedBlocks=\"+fatallyFailedBlocks+\", finalizedTotal=\"+finalizedTotal);\n\t\t} else {\n\t\t\tsb.append((100*(succeedBlocks)/minSuccessfulBlocks));\n\t\t\tsb.append('%');\n\t\t}\n\t\tsb.append(' ');\n\t\tsb.append(succeedBlocks);\n\t\tsb.append('/');\n\t\tsb.append(minSuccessfulBlocks);\n\t\tsb.append(\" (failed \");\n\t\tsb.append(failedBlocks);\n\t\tsb.append(\", fatally \");\n\t\tsb.append(fatallyFailedBlocks);\n\t\tsb.append(\", total \");\n\t\tsb.append(totalBlocks);\n\t\tsb.append(\") \");\n\t\tsb.append(finalizedTotal ? \" (finalized total)\" : \"\");\n\t\treturn sb.toString();\n\t}","commit_id":"d2b13f6928a73a43c66244426949bd04e31bff8f","url":"https://github.com/freenet/fred"},{"original_method":"public ClassNameDependencyUpgrader(\n\t\tString oldValue, String newValue,\n\t\tList<ClassNameDependency> dependencies) {\n\n\t\t_oldValue = oldValue;\n\t\t_newValue = newValue;\n\n\t\tif (dependencies == null) {\n\t\t\t_classNameDependencies = new ArrayList<>();\n\t\t}\n\t\telse {\n\t\t\t_classNameDependencies = dependencies;\n\t\t}\n\t}","id":102003,"modified_method":"public ClassNameDependencyUpgrader(\n\t\tString oldValue, String newValue,\n\t\tList<ClassNameDependency> classNameDependencies) {\n\n\t\t_oldValue = oldValue;\n\t\t_newValue = newValue;\n\n\t\tif (classNameDependencies == null) {\n\t\t\t_classNameDependencies = new ArrayList<>();\n\t\t}\n\t\telse {\n\t\t\t_classNameDependencies = classNameDependencies;\n\t\t}\n\t}","commit_id":"bde16ce56640d7b6c8c11092b62a7fa0d13e4ef6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void upgrade() {\n\t\tTable table = new Table(\"ClassName_\");\n\n\t\ttable.updateColumnValue(\"value\", _oldValue, _newValue);\n\n\t\tfor (ClassNameDependency dependency : _classNameDependencies) {\n\t\t\tdependency.update(_oldValue, _newValue);\n\t\t}\n\t}","id":102004,"modified_method":"public void upgrade() {\n\t\tTable table = new Table(\"ClassName_\");\n\n\t\ttable.updateColumnValue(\"value\", _oldValue, _newValue);\n\n\t\tfor (ClassNameDependency classNameDependency : _classNameDependencies) {\n\t\t\tclassNameDependency.update(_oldValue, _newValue);\n\t\t}\n\t}","commit_id":"bde16ce56640d7b6c8c11092b62a7fa0d13e4ef6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doUpgrade() throws Exception {\n\t\tList<ClassNameDependency> classNameDependencies = buildDependencies();\n\n\t\tClassNameDependencyUpgrader classNameDependencyUpgrader =\n\t\t\tnew ClassNameDependencyUpgrader(\n\t\t\t\t\"com.liferay.portlet.bookmarks.model.BookmarksEntry\",\n\t\t\t\tBookmarksEntry.class.getName(), classNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\n\t\tclassNameDependencyUpgrader =\n\t\t\tnew ClassNameDependencyUpgrader(\n\t\t\t\t\"com.liferay.portlet.bookmarks.model.BookmarksFolder\",\n\t\t\t\tBookmarksFolder.class.getName(), classNameDependencies );\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\n\t\tclassNameDependencyUpgrader =\n\t\t\tnew ClassNameDependencyUpgrader(\n\t\t\t\t\"com.liferay.portlet.bookmarks\", \"com.liferay.bookmarks\",\n\t\t\t\tclassNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\t}","id":102005,"modified_method":"@Override\n\tprotected void doUpgrade() throws Exception {\n\t\tList<ClassNameDependency> classNameDependencies =\n\t\t\tCollections.singletonList(new ResourceBlockClassNameDependency());\n\n\t\tClassNameDependencyUpgrader classNameDependencyUpgrader =\n\t\t\tnew ClassNameDependencyUpgrader(\n\t\t\t\t\"com.liferay.portlet.bookmarks\", \"com.liferay.bookmarks\",\n\t\t\t\tclassNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\n\t\tclassNameDependencyUpgrader = new ClassNameDependencyUpgrader(\n\t\t\t\"com.liferay.portlet.bookmarks.model.BookmarksEntry\",\n\t\t\tBookmarksEntry.class.getName(), classNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\n\t\tclassNameDependencyUpgrader = new ClassNameDependencyUpgrader(\n\t\t\t\"com.liferay.portlet.bookmarks.model.BookmarksFolder\",\n\t\t\tBookmarksFolder.class.getName(), classNameDependencies );\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\t}","commit_id":"bde16ce56640d7b6c8c11092b62a7fa0d13e4ef6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doUpgrade() throws Exception {\n\t\tList<ClassNameDependency> classNameDependencies = buildDependencies();\n\n\t\tClassNameDependencyUpgrader classNameDependencyUpgrader =\n\t\t\tnew ClassNameDependencyUpgrader(\n\t\t\t\t\"com.liferay.portlet.wiki.model.WikiNode\",\n\t\t\t\tWikiNode.class.getName(), classNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\n\t\tclassNameDependencyUpgrader =\n\t\t\tnew ClassNameDependencyUpgrader(\n\t\t\t\t\"com.liferay.portlet.wiki.model.WikiPage\",\n\t\t\t\tWikiPage.class.getName(), classNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\n\t\tclassNameDependencyUpgrader =\n\t\t\tnew ClassNameDependencyUpgrader(\n\t\t\t\t\"com.liferay.portlet.wiki\", \"com.liferay.wiki\",\n\t\t\t\tclassNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\t}","id":102006,"modified_method":"@Override\n\tprotected void doUpgrade() throws Exception {\n\t\tList<ClassNameDependency> classNameDependencies =\n\t\t\tCollections.singletonList(\n\t\t\t\tnew ResourcePermissionClassNameDependency());\n\n\t\tClassNameDependencyUpgrader classNameDependencyUpgrader =\n\t\t\tnew ClassNameDependencyUpgrader(\n\t\t\t\t\"com.liferay.portlet.wiki\", \"com.liferay.wiki\",\n\t\t\t\tclassNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\n\t\tclassNameDependencyUpgrader = new ClassNameDependencyUpgrader(\n\t\t\t\"com.liferay.portlet.wiki.model.WikiNode\",\n\t\t\tWikiNode.class.getName(), classNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\n\t\tclassNameDependencyUpgrader = new ClassNameDependencyUpgrader(\n\t\t\t\"com.liferay.portlet.wiki.model.WikiPage\",\n\t\t\tWikiPage.class.getName(), classNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\t}","commit_id":"bde16ce56640d7b6c8c11092b62a7fa0d13e4ef6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doUpgrade() throws Exception {\n\t\tList<ClassNameDependency> classNameDependencies = buildDependencies();\n\n\t\tClassNameDependencyUpgrader classNameDependencyUpgrader =\n\t\t\tnew ClassNameDependencyUpgrader(\n\t\t\t\t\"com.liferay.portlet.polls.model.PollsChoice\",\n\t\t\t\tPollsChoice.class.getName(), classNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\n\t\tclassNameDependencyUpgrader =\n\t\t\tnew ClassNameDependencyUpgrader(\n\t\t\t\t\"com.liferay.portlet.polls.model.PollsQuestion\",\n\t\t\t\tPollsQuestion.class.getName(), classNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\n\t\tclassNameDependencyUpgrader =\n\t\t\tnew ClassNameDependencyUpgrader(\n\t\t\t\t\"com.liferay.portlet.polls.model.PollsVote\",\n\t\t\t\tPollsVote.class.getName(), classNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\n\t\tclassNameDependencyUpgrader =\n\t\t\tnew ClassNameDependencyUpgrader(\n\t\t\t\t\"com.liferay.portlet.polls\", \"com.liferay.polls\",\n\t\t\t\tclassNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\t}","id":102007,"modified_method":"@Override\n\tprotected void doUpgrade() throws Exception {\n\t\tList<ClassNameDependency> classNameDependencies =\n\t\t\tCollections.singletonList(\n\t\t\t\tnew ResourcePermissionClassNameDependency());\n\n\t\tClassNameDependencyUpgrader classNameDependencyUpgrader =\n\t\t\tnew ClassNameDependencyUpgrader(\n\t\t\t\t\"com.liferay.portlet.polls\", \"com.liferay.polls\",\n\t\t\t\tclassNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\n\t\tclassNameDependencyUpgrader = new ClassNameDependencyUpgrader(\n\t\t\t\"com.liferay.portlet.polls.model.PollsChoice\",\n\t\t\tPollsChoice.class.getName(), classNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\n\t\tclassNameDependencyUpgrader = new ClassNameDependencyUpgrader(\n\t\t\t\"com.liferay.portlet.polls.model.PollsQuestion\",\n\t\t\tPollsQuestion.class.getName(), classNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\n\t\tclassNameDependencyUpgrader = new ClassNameDependencyUpgrader(\n\t\t\t\"com.liferay.portlet.polls.model.PollsVote\",\n\t\t\tPollsVote.class.getName(), classNameDependencies);\n\n\t\tclassNameDependencyUpgrader.upgrade();\n\t}","commit_id":"bde16ce56640d7b6c8c11092b62a7fa0d13e4ef6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Nullable\n  private AbstractBlockWrapper getParentFor(final int offset, LeafBlockWrapper block) {\n    AbstractBlockWrapper previous = getPreviousIncompleteBlock(block, offset);\n    if (previous != null) {\n      return previous;\n    }\n    else {\n      return getParentFor(offset, (AbstractBlockWrapper)block);\n    }\n  }","id":102008,"modified_method":"@Nullable\n  private AbstractBlockWrapper getParentFor(final int offset, LeafBlockWrapper block) {\n    AbstractBlockWrapper previous = getPreviousIncompleteBlock(block, offset);\n    if (previous != null) {\n      return getLastNestedCompositeBlockForSameRange(previous);\n    }\n    else {\n      return getParentFor(offset, (AbstractBlockWrapper)block);\n    }\n  }","commit_id":"5f65739fa6aa78e4af12decab5f1f4e09806aaac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static AbstractBlockWrapper getLastChildOf(final AbstractBlockWrapper currentResult) {\n    if (!(currentResult instanceof CompositeBlockWrapper)) return null;\n    final List<AbstractBlockWrapper> subBlocks = ((CompositeBlockWrapper)currentResult).getChildren();\n    if (subBlocks.isEmpty()) return null;\n    return subBlocks.get(subBlocks.size() - 1);\n  }","id":102009,"modified_method":"@Nullable\n  private static AbstractBlockWrapper getLastChildOf(final AbstractBlockWrapper currentResult) {\n    AbstractBlockWrapper parentBlockToUse = getLastNestedCompositeBlockForSameRange(currentResult);\n    if (!(parentBlockToUse instanceof CompositeBlockWrapper)) return null;\n    final List<AbstractBlockWrapper> subBlocks = ((CompositeBlockWrapper)parentBlockToUse).getChildren();\n    if (subBlocks.isEmpty()) return null;\n    return subBlocks.get(subBlocks.size() - 1);\n  }","commit_id":"5f65739fa6aa78e4af12decab5f1f4e09806aaac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int getNewChildPosition(final AbstractBlockWrapper parent, final int offset) {\n    if (!(parent instanceof CompositeBlockWrapper)) return 0;\n    final List<AbstractBlockWrapper> subBlocks = ((CompositeBlockWrapper)parent).getChildren();\n    //noinspection ConstantConditions\n    if (subBlocks != null) {\n      for (int i = 0; i < subBlocks.size(); i++) {\n        AbstractBlockWrapper block = subBlocks.get(i);\n        if (block.getStartOffset() >= offset) return i;\n      }\n      return subBlocks.size();\n    }\n    else {\n      return 0;\n    }\n  }","id":102010,"modified_method":"private static int getNewChildPosition(final AbstractBlockWrapper parent, final int offset) {\n    AbstractBlockWrapper parentBlockToUse = getLastNestedCompositeBlockForSameRange(parent);\n    if (!(parentBlockToUse instanceof CompositeBlockWrapper)) return 0;\n    final List<AbstractBlockWrapper> subBlocks = ((CompositeBlockWrapper)parentBlockToUse).getChildren();\n    //noinspection ConstantConditions\n    if (subBlocks != null) {\n      for (int i = 0; i < subBlocks.size(); i++) {\n        AbstractBlockWrapper block = subBlocks.get(i);\n        if (block.getStartOffset() >= offset) return i;\n      }\n      return subBlocks.size();\n    }\n    else {\n      return 0;\n    }\n  }","commit_id":"5f65739fa6aa78e4af12decab5f1f4e09806aaac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public ChildAttributes getChildAttributes(final int newChildIndex) {\n    if (myNode.getElementType() == ElementType.CONDITIONAL_EXPRESSION && mySettings.ALIGN_MULTILINE_TERNARY_OPERATION) {\n      final Alignment usedAlignment = getUsedAlignment(newChildIndex);\n      if (usedAlignment != null) {\n        return new ChildAttributes(null, usedAlignment);        \n      } else {\n        return super.getChildAttributes(newChildIndex);\n      }\n    } else {\n      return super.getChildAttributes(newChildIndex);\n    }\n  }","id":102011,"modified_method":"@Override\n  @NotNull\n  public ChildAttributes getChildAttributes(final int newChildIndex) {\n    if (myNode.getElementType() == ElementType.CONDITIONAL_EXPRESSION && mySettings.ALIGN_MULTILINE_TERNARY_OPERATION) {\n      final Alignment usedAlignment = getUsedAlignment(newChildIndex);\n      if (usedAlignment != null) {\n        return new ChildAttributes(null, usedAlignment);        \n      } else {\n        return super.getChildAttributes(newChildIndex);\n      }\n    }\n    else if (myNode.getElementType() == JavaElementType.SWITCH_LABEL_STATEMENT) {\n      return new ChildAttributes(Indent.getNormalIndent(), null);\n    }\n    else {\n      return super.getChildAttributes(newChildIndex);\n    }\n  }","commit_id":"5f65739fa6aa78e4af12decab5f1f4e09806aaac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String toString() {\n    final ASTNode treeNode = ((AbstractBlock)mySubBlocks.get(0)).getNode();\n    final TextRange textRange = getTextRange();\n    return treeNode.getPsi().getContainingFile().getText().subSequence(textRange.getStartOffset(), textRange.getEndOffset()).toString();\n  }","id":102012,"modified_method":"public String toString() {\n    ASTNode treeNode = null;\n    Block child = mySubBlocks.get(0);\n    while (treeNode == null) {\n      if (child instanceof AbstractBlock) {\n        treeNode = ((AbstractBlock)child).getNode();\n      }\n      else if (child instanceof SyntheticCodeBlock) {\n        child = ((SyntheticCodeBlock)child).mySubBlocks.get(0);\n      }\n      else {\n        break;\n      }\n    }\n    final TextRange textRange = getTextRange();\n    if (treeNode != null) {\n      PsiElement psi = treeNode.getPsi();\n      if (psi != null) {\n        PsiFile file = psi.getContainingFile();\n        if (file != null) {\n          return file.getText().subSequence(textRange.getStartOffset(), textRange.getEndOffset()) + \" \" + textRange;\n        }\n      }\n    }\n    return getClass().getName() + \": \" + textRange;\n  }","commit_id":"5f65739fa6aa78e4af12decab5f1f4e09806aaac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ASTNode getFirstTreeNode() {\n    return AbstractJavaBlock.getTreeNode(mySubBlocks.get(0));\n  }","id":102013,"modified_method":"public ASTNode getFirstTreeNode() {\n    ASTNode result = AbstractJavaBlock.getTreeNode(mySubBlocks.get(0));\n    assert result != null;\n    return result;\n  }","commit_id":"5f65739fa6aa78e4af12decab5f1f4e09806aaac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doInit() {\n      if (myChild1.getPsi().getLanguage() != GROOVY_LANGUAGE ||\n          myChild2.getPsi().getLanguage() != GROOVY_LANGUAGE) {\n        return;\n      }\n\n      if (myChild2 != null && mySettings.KEEP_FIRST_COLUMN_COMMENT && SpacingUtil.COMMENT_BIT_SET.contains(myChild2.getElementType())) {\n        if (myChild1.getElementType() != IMPORT_STATEMENT) {\n          myResult = Spacing.createKeepingFirstColumnSpacing(0, Integer.MAX_VALUE, true, 1);\n        }\n      } else {\n        if (myParent instanceof GroovyPsiElement) {\n          ((GroovyPsiElement) myParent).accept(this);\n          if (myResult == null) {\n            final ASTNode prev = SpacingUtil.getPrevElementType(myChild2);\n            if (prev != null && prev.getElementType() == mSL_COMMENT) {\n              myResult = Spacing.createSpacing(0, 0, 1, mySettings.KEEP_LINE_BREAKS, mySettings.KEEP_BLANK_LINES_IN_CODE);\n            } else if (!CodeEditUtil.canStickChildrenTogether(myChild1, myChild2)) {\n              myResult = Spacing.createSpacing(1, Integer.MIN_VALUE, 0, mySettings.KEEP_LINE_BREAKS, mySettings.KEEP_BLANK_LINES_IN_CODE);\n            } else if (myChild1.getElementType() == mML_COMMENT) {\n              myResult = null;\n            } else if (!SpacingUtil.shouldKeepSpace(myParent)) {\n              // todo [ilyas] rewrite all pacings via this processor\n//              myResult = Spacing.createSpacing(0, 0, 0, true, mySettings.KEEP_BLANK_LINES_IN_CODE);\n            }\n          }\n        }\n      }\n    }","id":102014,"modified_method":"private void doInit() {\n      if (myChild1 == null || myChild2 == null) return;\n      PsiElement psi1 = myChild1.getPsi();\n      PsiElement psi2 = myChild2.getPsi();\n      if (psi1 == null || psi2 == null) return;\n      if (psi1.getLanguage() != GROOVY_LANGUAGE ||\n          psi2.getLanguage() != GROOVY_LANGUAGE) {\n        return;\n      }\n\n      if (myChild2 != null && mySettings.KEEP_FIRST_COLUMN_COMMENT && SpacingUtil.COMMENT_BIT_SET.contains(myChild2.getElementType())) {\n        if (myChild1.getElementType() != IMPORT_STATEMENT) {\n          myResult = Spacing.createKeepingFirstColumnSpacing(0, Integer.MAX_VALUE, true, 1);\n        }\n      } else {\n        if (myParent instanceof GroovyPsiElement) {\n          ((GroovyPsiElement) myParent).accept(this);\n          if (myResult == null) {\n            final ASTNode prev = SpacingUtil.getPrevElementType(myChild2);\n            if (prev != null && prev.getElementType() == mSL_COMMENT) {\n              myResult = Spacing.createSpacing(0, 0, 1, mySettings.KEEP_LINE_BREAKS, mySettings.KEEP_BLANK_LINES_IN_CODE);\n            } else if (!CodeEditUtil.canStickChildrenTogether(myChild1, myChild2)) {\n              myResult = Spacing.createSpacing(1, Integer.MIN_VALUE, 0, mySettings.KEEP_LINE_BREAKS, mySettings.KEEP_BLANK_LINES_IN_CODE);\n            } else if (myChild1.getElementType() == mML_COMMENT) {\n              myResult = null;\n            } else if (!SpacingUtil.shouldKeepSpace(myParent)) {\n              // todo [ilyas] rewrite all pacings via this processor\n//              myResult = Spacing.createSpacing(0, 0, 0, true, mySettings.KEEP_BLANK_LINES_IN_CODE);\n            }\n          }\n        }\n      }\n    }","commit_id":"20437bc539fb4e5055c6c951945cbf84570ec2b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static OnmsAlarm createNewAlarm(OnmsEvent e, Event event) {\n        OnmsAlarm alarm;\n        alarm = new OnmsAlarm();\n        alarm.setAlarmType(event.getAlarmData().getAlarmType());\n        alarm.setClearKey(event.getAlarmData().getClearKey());\n        alarm.setCounter(1);\n        alarm.setDescription(e.getEventDescr());\n        alarm.setDistPoller(e.getDistPoller());\n        alarm.setEventParms(e.getEventParms());\n        alarm.setFirstEventTime(e.getEventTime());\n        alarm.setIfIndex(e.getIfIndex());\n        alarm.setIpAddr(e.getIpAddr());\n        alarm.setLastEventTime(e.getEventTime());\n        alarm.setLastEvent(e);\n        alarm.setLogMsg(e.getEventLogMsg());\n        alarm.setMouseOverText(e.getEventMouseOverText());\n        alarm.setNode(e.getNode());\n        alarm.setOperInstruct(e.getEventOperInstruct());\n        alarm.setReductionKey(event.getAlarmData().getReductionKey());\n        alarm.setServiceType(e.getServiceType());\n        alarm.setSeverity(OnmsSeverity.get(e.getEventSeverity())); //TODO: what to do?\n        alarm.setSuppressedUntil(e.getEventTime()); //TODO: fix UI to not require this be set\n        alarm.setSuppressedTime(e.getEventTime()); //TODO: Fix UI to not require this be set\n        //alarm.setTTicketId(e.getEventTTicket());\n        //alarm.setTTicketState(TroubleTicketState.CANCEL_FAILED);  //FIXME\n        alarm.setUei(e.getEventUei());\n        e.setAlarm(alarm);\n        return alarm;\n    }","id":102015,"modified_method":"private static OnmsAlarm createNewAlarm(OnmsEvent e, Event event) {\n        e.getServiceType().getName(); // To avoid potential LazyInitializationException when dealing with NorthboundAlarm\n        OnmsAlarm alarm;\n        alarm = new OnmsAlarm();\n        alarm.setAlarmType(event.getAlarmData().getAlarmType());\n        alarm.setClearKey(event.getAlarmData().getClearKey());\n        alarm.setCounter(1);\n        alarm.setDescription(e.getEventDescr());\n        alarm.setDistPoller(e.getDistPoller());\n        alarm.setEventParms(e.getEventParms());\n        alarm.setFirstEventTime(e.getEventTime());\n        alarm.setIfIndex(e.getIfIndex());\n        alarm.setIpAddr(e.getIpAddr());\n        alarm.setLastEventTime(e.getEventTime());\n        alarm.setLastEvent(e);\n        alarm.setLogMsg(e.getEventLogMsg());\n        alarm.setMouseOverText(e.getEventMouseOverText());\n        alarm.setNode(e.getNode());\n        alarm.setOperInstruct(e.getEventOperInstruct());\n        alarm.setReductionKey(event.getAlarmData().getReductionKey());\n        alarm.setServiceType(e.getServiceType());\n        alarm.setSeverity(OnmsSeverity.get(e.getEventSeverity())); //TODO: what to do?\n        alarm.setSuppressedUntil(e.getEventTime()); //TODO: fix UI to not require this be set\n        alarm.setSuppressedTime(e.getEventTime()); //TODO: Fix UI to not require this be set\n        //alarm.setTTicketId(e.getEventTTicket());\n        //alarm.setTTicketState(TroubleTicketState.CANCEL_FAILED);  //FIXME\n        alarm.setUei(e.getEventUei());\n        e.setAlarm(alarm);\n        return alarm;\n    }","commit_id":"80bd05b4f441b8ec457cfe1f442f85698fbca494","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsServiceType getService() {\n\t\treturn m_service;\n\t}","id":102016,"modified_method":"public String getService() {\n\t\treturn m_service;\n\t}","commit_id":"80bd05b4f441b8ec457cfe1f442f85698fbca494","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public NorthboundAlarm(OnmsAlarm alarm) {\n        //alarm.getAckId();\n        //alarm.getAckTime();\n        //alarm.getAckUser();\n        \n    \tm_nodeId = alarm.getNodeId();\n        m_ackTime = alarm.getAlarmAckTime();\n        m_ackUser = alarm.getAlarmAckUser();\n        m_alarmType = alarm.getAlarmType() == null ? null : AlarmType.toAlarmType(alarm.getAlarmType());\n        m_appDn = alarm.getApplicationDN();\n        m_clearKey = alarm.getClearKey();\n        m_count = alarm.getCounter();\n        m_desc = alarm.getDescription();\n        m_poller = alarm.getDistPoller();\n        m_eventParms = alarm.getEventParms();\n        //alarm.getFirstAutomationTime();\n        m_firstOccurrence = alarm.getFirstEventTime();\n        m_id = alarm.getId();\n        //alarm.getIfIndex();\n        m_ipAddr = alarm.getIpAddr();\n        //alarm.getLastAutomationTime();\n        //alarm.getLastEvent();\n        m_lastOccurrence = alarm.getLastEventTime();\n        m_logMsg = alarm.getLogMsg();\n        m_objectInstance = alarm.getManagedObjectInstance();\n        m_objectType = alarm.getManagedObjectType();\n        //alarm.getNode();\n        m_operInst = alarm.getOperInstruct();\n        m_ossKey = alarm.getOssPrimaryKey();\n        m_ossState = alarm.getQosAlarmState();\n        m_alarmKey = alarm.getReductionKey();\n        m_service = alarm.getServiceType();\n        m_severity = alarm.getSeverity();\n        //alarm.getSeverityId();\n        //alarm.getSeverityLabel();\n        m_suppressed = alarm.getSuppressedTime();\n        m_suppressedUntil = alarm.getSuppressedUntil();\n        m_suppressedBy = alarm.getSuppressedUser();\n        m_ticketId = alarm.getTTicketId();\n        m_ticketState = alarm.getTTicketState();\n        //alarm.getType();\n        m_uei = alarm.getUei();\n        m_x733Type = alarm.getX733AlarmType();\n        m_x733Cause = alarm.getX733ProbableCause();\n    }","id":102017,"modified_method":"public NorthboundAlarm(OnmsAlarm alarm) {\n        //alarm.getAckId();\n        //alarm.getAckTime();\n        //alarm.getAckUser();\n        \n    \tm_nodeId = alarm.getNodeId();\n        m_ackTime = alarm.getAlarmAckTime();\n        m_ackUser = alarm.getAlarmAckUser();\n        m_alarmType = alarm.getAlarmType() == null ? null : AlarmType.toAlarmType(alarm.getAlarmType());\n        m_appDn = alarm.getApplicationDN();\n        m_clearKey = alarm.getClearKey();\n        m_count = alarm.getCounter();\n        m_desc = alarm.getDescription();\n        m_poller = alarm.getDistPoller();\n        m_eventParms = alarm.getEventParms();\n        //alarm.getFirstAutomationTime();\n        m_firstOccurrence = alarm.getFirstEventTime();\n        m_id = alarm.getId();\n        //alarm.getIfIndex();\n        m_ipAddr = alarm.getIpAddr();\n        //alarm.getLastAutomationTime();\n        //alarm.getLastEvent();\n        m_lastOccurrence = alarm.getLastEventTime();\n        m_logMsg = alarm.getLogMsg();\n        m_objectInstance = alarm.getManagedObjectInstance();\n        m_objectType = alarm.getManagedObjectType();\n        //alarm.getNode();\n        m_operInst = alarm.getOperInstruct();\n        m_ossKey = alarm.getOssPrimaryKey();\n        m_ossState = alarm.getQosAlarmState();\n        m_alarmKey = alarm.getReductionKey();\n        m_service = alarm.getServiceType() == null ? null : alarm.getServiceType().getName();\n        m_severity = alarm.getSeverity();\n        //alarm.getSeverityId();\n        //alarm.getSeverityLabel();\n        m_suppressed = alarm.getSuppressedTime();\n        m_suppressedUntil = alarm.getSuppressedUntil();\n        m_suppressedBy = alarm.getSuppressedUser();\n        m_ticketId = alarm.getTTicketId();\n        m_ticketState = alarm.getTTicketState();\n        //alarm.getType();\n        m_uei = alarm.getUei();\n        m_x733Type = alarm.getX733AlarmType();\n        m_x733Cause = alarm.getX733ProbableCause();\n    }","commit_id":"80bd05b4f441b8ec457cfe1f442f85698fbca494","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Map<String, String> createMapping(Map<Integer, Map<String, String>> alarmMappings, NorthboundAlarm alarm) {\n\t\tMap<String, String> mapping;\n\t\tmapping = new HashMap<String, String>();\n\t\tmapping.put(\"ackUser\", alarm.getAckUser());\n\t\tmapping.put(\"appDn\", alarm.getAppDn());\n\t\tmapping.put(\"logMsg\", alarm.getLogMsg());\n\t\tmapping.put(\"objectInstance\", alarm.getObjectInstance());\n\t\tmapping.put(\"objectType\", alarm.getObjectType());\n\t\tmapping.put(\"ossKey\", alarm.getOssKey());\n\t\tmapping.put(\"ossState\", alarm.getOssState());\n\t\tmapping.put(\"ticketId\", alarm.getTicketId());\n\t\tmapping.put(\"alarmUei\", alarm.getUei());\n\t\tmapping.put(\"ackTime\", nullSafeToString(alarm.getAckTime(), \"\"));\n\t\t\n\t\tAlarmType alarmType = alarm.getAlarmType() == null ? AlarmType.NOTIFICATION : alarm.getAlarmType();\n\t\tmapping.put(\"alarmType\", alarmType.name());\n\t\t\n\t\tString count = alarm.getCount() == null ? \"1\" : alarm.getCount().toString();\n\t\tmapping.put(\"count\", count);\n\t\t\n\t\tmapping.put(\"firstOccurrence\", nullSafeToString(alarm.getFirstOccurrence(), \"\"));\n\t\tmapping.put(\"alarmId\", alarm.getId().toString());\n\t\tmapping.put(\"ipAddr\", nullSafeToString(alarm.getIpAddr(), \"\"));\n\t\tmapping.put(\"lastOccurrence\", nullSafeToString(alarm.getLastOccurrence(), \"\"));\n\t\t\n\t\t\n\t\tif (alarm.getNodeId() != null) {\n\t\t\tmapping.put(\"nodeId\", alarm.getNodeId().toString());\n\t\t\tString nodeLabel = m_nodeDao.getLabelForId(alarm.getNodeId());\n\t\t\tmapping.put(\"nodeLabel\", nodeLabel == null ? \"?\" : nodeLabel);\n\t\t} else {\n\t\t\tmapping.put(\"nodeId\", \"\");\n\t\t\tmapping.put(\"nodeLabel\", \"\");\n\t\t}\n\t\t\n\t\t\n\t\tString poller = alarm.getPoller() == null ? \"localhost\" : alarm.getPoller().getName();\n\t\tmapping.put(\"distPoller\", poller);\n\t\t\n\t\tString service = alarm.getService() == null ? \"\" : alarm.getService().getName();\t\t\t\t\t\n\t\tmapping.put(\"ifService\", service);\n\t\t\n\t\tmapping.put(\"severity\", nullSafeToString(alarm.getSeverity(), \"\"));\n\t\tmapping.put(\"ticketState\", nullSafeToString(alarm.getTicketState(), \"\"));\n\t\t\n\t\tmapping.put(\"x733AlarmType\", alarm.getX733Type());\n\t\t\n\t\ttry {\n\t\t\tmapping.put(\"x733ProbableCause\", nullSafeToString(x733ProbableCause.get(alarm.getX733Cause()), \"\"));\n\t\t} catch (Exception e) {\n\t\t\tLogUtils.infof(this, e, \"Exception caught setting X733 Cause %d: \", alarm.getX733Cause(), e);\n\t\t\tmapping.put(\"x733ProbableCause\", \"\");\n\t\t}\n\t\t\n\t\tbuildParmMappings(alarm, mapping);\n\t\t\n\t\talarmMappings.put(alarm.getId(), mapping);\n\t\treturn mapping;\n\t}","id":102018,"modified_method":"private Map<String, String> createMapping(Map<Integer, Map<String, String>> alarmMappings, NorthboundAlarm alarm) {\n\t\tMap<String, String> mapping;\n\t\tmapping = new HashMap<String, String>();\n\t\tmapping.put(\"ackUser\", alarm.getAckUser());\n\t\tmapping.put(\"appDn\", alarm.getAppDn());\n\t\tmapping.put(\"logMsg\", alarm.getLogMsg());\n\t\tmapping.put(\"objectInstance\", alarm.getObjectInstance());\n\t\tmapping.put(\"objectType\", alarm.getObjectType());\n\t\tmapping.put(\"ossKey\", alarm.getOssKey());\n\t\tmapping.put(\"ossState\", alarm.getOssState());\n\t\tmapping.put(\"ticketId\", alarm.getTicketId());\n\t\tmapping.put(\"alarmUei\", alarm.getUei());\n\t\tmapping.put(\"ackTime\", nullSafeToString(alarm.getAckTime(), \"\"));\n\t\t\n\t\tAlarmType alarmType = alarm.getAlarmType() == null ? AlarmType.NOTIFICATION : alarm.getAlarmType();\n\t\tmapping.put(\"alarmType\", alarmType.name());\n\t\t\n\t\tString count = alarm.getCount() == null ? \"1\" : alarm.getCount().toString();\n\t\tmapping.put(\"count\", count);\n\t\t\n\t\tmapping.put(\"firstOccurrence\", nullSafeToString(alarm.getFirstOccurrence(), \"\"));\n\t\tmapping.put(\"alarmId\", alarm.getId().toString());\n\t\tmapping.put(\"ipAddr\", nullSafeToString(alarm.getIpAddr(), \"\"));\n\t\tmapping.put(\"lastOccurrence\", nullSafeToString(alarm.getLastOccurrence(), \"\"));\n\t\t\n\t\t\n\t\tif (alarm.getNodeId() != null) {\n\t\t\tmapping.put(\"nodeId\", alarm.getNodeId().toString());\n\t\t\tString nodeLabel = m_nodeDao.getLabelForId(alarm.getNodeId());\n\t\t\tmapping.put(\"nodeLabel\", nodeLabel == null ? \"?\" : nodeLabel);\n\t\t} else {\n\t\t\tmapping.put(\"nodeId\", \"\");\n\t\t\tmapping.put(\"nodeLabel\", \"\");\n\t\t}\n\t\t\n\t\t\n\t\tString poller = alarm.getPoller() == null ? \"localhost\" : alarm.getPoller().getName();\n\t\tmapping.put(\"distPoller\", poller);\n\t\t\n\t\tString service = alarm.getService() == null ? \"\" : alarm.getService();\n\t\tmapping.put(\"ifService\", service);\n\t\t\n\t\tmapping.put(\"severity\", nullSafeToString(alarm.getSeverity(), \"\"));\n\t\tmapping.put(\"ticketState\", nullSafeToString(alarm.getTicketState(), \"\"));\n\t\t\n\t\tmapping.put(\"x733AlarmType\", alarm.getX733Type());\n\t\t\n\t\ttry {\n\t\t\tmapping.put(\"x733ProbableCause\", nullSafeToString(x733ProbableCause.get(alarm.getX733Cause()), \"\"));\n\t\t} catch (Exception e) {\n\t\t\tLogUtils.infof(this, e, \"Exception caught setting X733 Cause %d: \", alarm.getX733Cause(), e);\n\t\t\tmapping.put(\"x733ProbableCause\", \"\");\n\t\t}\n\t\t\n\t\tbuildParmMappings(alarm, mapping);\n\t\t\n\t\talarmMappings.put(alarm.getId(), mapping);\n\t\treturn mapping;\n\t}","commit_id":"80bd05b4f441b8ec457cfe1f442f85698fbca494","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private static OnmsAlarm createNewAlarm(OnmsEvent e, Event event) {\n        OnmsAlarm alarm;\n        alarm = new OnmsAlarm();\n        alarm.setAlarmType(event.getAlarmData().getAlarmType());\n        alarm.setClearKey(event.getAlarmData().getClearKey());\n        alarm.setCounter(1);\n        alarm.setDescription(e.getEventDescr());\n        alarm.setDistPoller(e.getDistPoller());\n        alarm.setEventParms(e.getEventParms());\n        alarm.setFirstEventTime(e.getEventTime());\n        alarm.setIfIndex(e.getIfIndex());\n        alarm.setIpAddr(e.getIpAddr());\n        alarm.setLastEventTime(e.getEventTime());\n        alarm.setLastEvent(e);\n        alarm.setLogMsg(e.getEventLogMsg());\n        alarm.setMouseOverText(e.getEventMouseOverText());\n        alarm.setNode(e.getNode());\n        alarm.setOperInstruct(e.getEventOperInstruct());\n        alarm.setReductionKey(event.getAlarmData().getReductionKey());\n        alarm.setServiceType(e.getServiceType());\n        alarm.setSeverity(OnmsSeverity.get(e.getEventSeverity())); //TODO: what to do?\n        alarm.setSuppressedUntil(e.getEventTime()); //TODO: fix UI to not require this be set\n        alarm.setSuppressedTime(e.getEventTime()); //TODO: Fix UI to not require this be set\n        //alarm.setTTicketId(e.getEventTTicket());\n        //alarm.setTTicketState(TroubleTicketState.CANCEL_FAILED);  //FIXME\n        alarm.setUei(e.getEventUei());\n        e.setAlarm(alarm);\n        return alarm;\n    }","id":102019,"modified_method":"private static OnmsAlarm createNewAlarm(OnmsEvent e, Event event) {\n        e.getServiceType().getName(); // To avoid potential LazyInitializationException when dealing with NorthboundAlarm\n        OnmsAlarm alarm;\n        alarm = new OnmsAlarm();\n        alarm.setAlarmType(event.getAlarmData().getAlarmType());\n        alarm.setClearKey(event.getAlarmData().getClearKey());\n        alarm.setCounter(1);\n        alarm.setDescription(e.getEventDescr());\n        alarm.setDistPoller(e.getDistPoller());\n        alarm.setEventParms(e.getEventParms());\n        alarm.setFirstEventTime(e.getEventTime());\n        alarm.setIfIndex(e.getIfIndex());\n        alarm.setIpAddr(e.getIpAddr());\n        alarm.setLastEventTime(e.getEventTime());\n        alarm.setLastEvent(e);\n        alarm.setLogMsg(e.getEventLogMsg());\n        alarm.setMouseOverText(e.getEventMouseOverText());\n        alarm.setNode(e.getNode());\n        alarm.setOperInstruct(e.getEventOperInstruct());\n        alarm.setReductionKey(event.getAlarmData().getReductionKey());\n        alarm.setServiceType(e.getServiceType());\n        alarm.setSeverity(OnmsSeverity.get(e.getEventSeverity())); //TODO: what to do?\n        alarm.setSuppressedUntil(e.getEventTime()); //TODO: fix UI to not require this be set\n        alarm.setSuppressedTime(e.getEventTime()); //TODO: Fix UI to not require this be set\n        //alarm.setTTicketId(e.getEventTTicket());\n        //alarm.setTTicketState(TroubleTicketState.CANCEL_FAILED);  //FIXME\n        alarm.setUei(e.getEventUei());\n        e.setAlarm(alarm);\n        return alarm;\n    }","commit_id":"3ce68dcb00b8d556006ab4f991225093d4ff07ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public NorthboundAlarm(OnmsAlarm alarm) {\n        //alarm.getAckId();\n        //alarm.getAckTime();\n        //alarm.getAckUser();\n        \n    \tm_nodeId = alarm.getNodeId();\n        m_ackTime = alarm.getAlarmAckTime();\n        m_ackUser = alarm.getAlarmAckUser();\n        m_alarmType = alarm.getAlarmType() == null ? null : AlarmType.toAlarmType(alarm.getAlarmType());\n        m_appDn = alarm.getApplicationDN();\n        m_clearKey = alarm.getClearKey();\n        m_count = alarm.getCounter();\n        m_desc = alarm.getDescription();\n        m_poller = alarm.getDistPoller();\n        m_eventParms = alarm.getEventParms();\n        //alarm.getFirstAutomationTime();\n        m_firstOccurrence = alarm.getFirstEventTime();\n        m_id = alarm.getId();\n        //alarm.getIfIndex();\n        m_ipAddr = alarm.getIpAddr();\n        //alarm.getLastAutomationTime();\n        //alarm.getLastEvent();\n        m_lastOccurrence = alarm.getLastEventTime();\n        m_logMsg = alarm.getLogMsg();\n        m_objectInstance = alarm.getManagedObjectInstance();\n        m_objectType = alarm.getManagedObjectType();\n        //alarm.getNode();\n        m_operInst = alarm.getOperInstruct();\n        m_ossKey = alarm.getOssPrimaryKey();\n        m_ossState = alarm.getQosAlarmState();\n        m_alarmKey = alarm.getReductionKey();\n        m_service = alarm.getServiceType();\n        m_severity = alarm.getSeverity();\n        //alarm.getSeverityId();\n        //alarm.getSeverityLabel();\n        m_suppressed = alarm.getSuppressedTime();\n        m_suppressedUntil = alarm.getSuppressedUntil();\n        m_suppressedBy = alarm.getSuppressedUser();\n        m_ticketId = alarm.getTTicketId();\n        m_ticketState = alarm.getTTicketState();\n        //alarm.getType();\n        m_uei = alarm.getUei();\n        m_x733Type = alarm.getX733AlarmType();\n        m_x733Cause = alarm.getX733ProbableCause();\n    }","id":102020,"modified_method":"public NorthboundAlarm(OnmsAlarm alarm) {\n        //alarm.getAckId();\n        //alarm.getAckTime();\n        //alarm.getAckUser();\n        \n    \tm_nodeId = alarm.getNodeId();\n        m_ackTime = alarm.getAlarmAckTime();\n        m_ackUser = alarm.getAlarmAckUser();\n        m_alarmType = alarm.getAlarmType() == null ? null : AlarmType.toAlarmType(alarm.getAlarmType());\n        m_appDn = alarm.getApplicationDN();\n        m_clearKey = alarm.getClearKey();\n        m_count = alarm.getCounter();\n        m_desc = alarm.getDescription();\n        m_poller = alarm.getDistPoller();\n        m_eventParms = alarm.getEventParms();\n        //alarm.getFirstAutomationTime();\n        m_firstOccurrence = alarm.getFirstEventTime();\n        m_id = alarm.getId();\n        //alarm.getIfIndex();\n        m_ipAddr = alarm.getIpAddr();\n        //alarm.getLastAutomationTime();\n        //alarm.getLastEvent();\n        m_lastOccurrence = alarm.getLastEventTime();\n        m_logMsg = alarm.getLogMsg();\n        m_objectInstance = alarm.getManagedObjectInstance();\n        m_objectType = alarm.getManagedObjectType();\n        //alarm.getNode();\n        m_operInst = alarm.getOperInstruct();\n        m_ossKey = alarm.getOssPrimaryKey();\n        m_ossState = alarm.getQosAlarmState();\n        m_alarmKey = alarm.getReductionKey();\n        m_service = alarm.getServiceType() == null ? null : alarm.getServiceType().getName();\n        m_severity = alarm.getSeverity();\n        //alarm.getSeverityId();\n        //alarm.getSeverityLabel();\n        m_suppressed = alarm.getSuppressedTime();\n        m_suppressedUntil = alarm.getSuppressedUntil();\n        m_suppressedBy = alarm.getSuppressedUser();\n        m_ticketId = alarm.getTTicketId();\n        m_ticketState = alarm.getTTicketState();\n        //alarm.getType();\n        m_uei = alarm.getUei();\n        m_x733Type = alarm.getX733AlarmType();\n        m_x733Cause = alarm.getX733ProbableCause();\n    }","commit_id":"3ce68dcb00b8d556006ab4f991225093d4ff07ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsServiceType getService() {\n\t\treturn m_service;\n\t}","id":102021,"modified_method":"public String getService() {\n\t\treturn m_service;\n\t}","commit_id":"3ce68dcb00b8d556006ab4f991225093d4ff07ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Map<String, Object> createMapping(Map<Integer, Map<String, Object>> alarmMappings, NorthboundAlarm alarm) {\n\t\tMap<String, Object> mapping;\n\t\tmapping = new HashMap<String, Object>();\n\t\tmapping.put(\"ackUser\", alarm.getAckUser());\n\t\tmapping.put(\"appDn\", alarm.getAppDn());\n\t\tmapping.put(\"logMsg\", alarm.getLogMsg());\n\t\tmapping.put(\"objectInstance\", alarm.getObjectInstance());\n\t\tmapping.put(\"objectType\", alarm.getObjectType());\n\t\tmapping.put(\"ossKey\", alarm.getOssKey());\n\t\tmapping.put(\"ossState\", alarm.getOssState());\n\t\tmapping.put(\"ticketId\", alarm.getTicketId());\n\t\tmapping.put(\"alarmUei\", alarm.getUei());\n\t\tmapping.put(\"ackTime\", nullSafeToString(alarm.getAckTime(), \"\"));\n\t\t\n\t\tAlarmType alarmType = alarm.getAlarmType() == null ? AlarmType.NOTIFICATION : alarm.getAlarmType();\n\t\tmapping.put(\"alarmType\", alarmType.name());\n\t\t\n\t\tString count = alarm.getCount() == null ? \"1\" : alarm.getCount().toString();\n\t\tmapping.put(\"count\", count);\n\t\t\n\t\tmapping.put(\"firstOccurrence\", nullSafeToString(alarm.getFirstOccurrence(), \"\"));\n\t\tmapping.put(\"alarmId\", alarm.getId().toString());\n\t\tmapping.put(\"ipAddr\", nullSafeToString(alarm.getIpAddr(), \"\"));\n\t\tmapping.put(\"lastOccurrence\", nullSafeToString(alarm.getLastOccurrence(), \"\"));\n\t\t\n\t\t\n\t\tif (alarm.getNodeId() != null) {\n\t\t\tmapping.put(\"nodeId\", alarm.getNodeId().toString());\n\t\t\tString nodeLabel = m_nodeDao.getLabelForId(alarm.getNodeId());\n\t\t\tmapping.put(\"nodeLabel\", nodeLabel == null ? \"?\" : nodeLabel);\n\t\t} else {\n\t\t\tmapping.put(\"nodeId\", \"\");\n\t\t\tmapping.put(\"nodeLabel\", \"\");\n\t\t}\n\t\t\n\t\t\n\t\tString poller = alarm.getPoller() == null ? \"localhost\" : alarm.getPoller().getName();\n\t\tmapping.put(\"distPoller\", poller);\n\t\t\n\t\tString service = alarm.getService() == null ? \"\" : alarm.getService().getName();\t\t\t\t\t\n\t\tmapping.put(\"ifService\", service);\n\t\t\n\t\tmapping.put(\"severity\", nullSafeToString(alarm.getSeverity(), \"\"));\n\t\tmapping.put(\"ticketState\", nullSafeToString(alarm.getTicketState(), \"\"));\n\t\t\n\t\tmapping.put(\"x733AlarmType\", alarm.getX733Type());\n\t\t\n\t\ttry {\n\t\t\tmapping.put(\"x733ProbableCause\", nullSafeToString(x733ProbableCause.get(alarm.getX733Cause()), \"\"));\n\t\t} catch (Exception e) {\n\t\t\tLOG.info(\"Exception caught setting X733 Cause: {}\", alarm.getX733Cause(), e);\n\t\t\tmapping.put(\"x733ProbableCause\", \"\");\n\t\t}\n\t\t\n\t\tbuildParmMappings(alarm, mapping);\n\t\t\n\t\talarmMappings.put(alarm.getId(), mapping);\n\t\treturn mapping;\n\t}","id":102022,"modified_method":"private Map<String, Object> createMapping(Map<Integer, Map<String, Object>> alarmMappings, NorthboundAlarm alarm) {\n\t\tMap<String, Object> mapping;\n\t\tmapping = new HashMap<String, Object>();\n\t\tmapping.put(\"ackUser\", alarm.getAckUser());\n\t\tmapping.put(\"appDn\", alarm.getAppDn());\n\t\tmapping.put(\"logMsg\", alarm.getLogMsg());\n\t\tmapping.put(\"objectInstance\", alarm.getObjectInstance());\n\t\tmapping.put(\"objectType\", alarm.getObjectType());\n\t\tmapping.put(\"ossKey\", alarm.getOssKey());\n\t\tmapping.put(\"ossState\", alarm.getOssState());\n\t\tmapping.put(\"ticketId\", alarm.getTicketId());\n\t\tmapping.put(\"alarmUei\", alarm.getUei());\n\t\tmapping.put(\"ackTime\", nullSafeToString(alarm.getAckTime(), \"\"));\n\t\t\n\t\tAlarmType alarmType = alarm.getAlarmType() == null ? AlarmType.NOTIFICATION : alarm.getAlarmType();\n\t\tmapping.put(\"alarmType\", alarmType.name());\n\t\t\n\t\tString count = alarm.getCount() == null ? \"1\" : alarm.getCount().toString();\n\t\tmapping.put(\"count\", count);\n\t\t\n\t\tmapping.put(\"firstOccurrence\", nullSafeToString(alarm.getFirstOccurrence(), \"\"));\n\t\tmapping.put(\"alarmId\", alarm.getId().toString());\n\t\tmapping.put(\"ipAddr\", nullSafeToString(alarm.getIpAddr(), \"\"));\n\t\tmapping.put(\"lastOccurrence\", nullSafeToString(alarm.getLastOccurrence(), \"\"));\n\t\t\n\t\t\n\t\tif (alarm.getNodeId() != null) {\n\t\t\tmapping.put(\"nodeId\", alarm.getNodeId().toString());\n\t\t\tString nodeLabel = m_nodeDao.getLabelForId(alarm.getNodeId());\n\t\t\tmapping.put(\"nodeLabel\", nodeLabel == null ? \"?\" : nodeLabel);\n\t\t} else {\n\t\t\tmapping.put(\"nodeId\", \"\");\n\t\t\tmapping.put(\"nodeLabel\", \"\");\n\t\t}\n\t\t\n\t\t\n\t\tString poller = alarm.getPoller() == null ? \"localhost\" : alarm.getPoller().getName();\n\t\tmapping.put(\"distPoller\", poller);\n\t\t\n\t\tString service = alarm.getService() == null ? \"\" : alarm.getService();\n\t\tmapping.put(\"ifService\", service);\n\t\t\n\t\tmapping.put(\"severity\", nullSafeToString(alarm.getSeverity(), \"\"));\n\t\tmapping.put(\"ticketState\", nullSafeToString(alarm.getTicketState(), \"\"));\n\t\t\n\t\tmapping.put(\"x733AlarmType\", alarm.getX733Type());\n\t\t\n\t\ttry {\n\t\t\tmapping.put(\"x733ProbableCause\", nullSafeToString(x733ProbableCause.get(alarm.getX733Cause()), \"\"));\n\t\t} catch (Exception e) {\n\t\t\tLOG.info(\"Exception caught setting X733 Cause: {}\", alarm.getX733Cause(), e);\n\t\t\tmapping.put(\"x733ProbableCause\", \"\");\n\t\t}\n\t\t\n\t\tbuildParmMappings(alarm, mapping);\n\t\t\n\t\talarmMappings.put(alarm.getId(), mapping);\n\t\treturn mapping;\n\t}","commit_id":"3ce68dcb00b8d556006ab4f991225093d4ff07ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private static OnmsAlarm createNewAlarm(OnmsEvent e, Event event) {\n        OnmsAlarm alarm;\n        alarm = new OnmsAlarm();\n        alarm.setAlarmType(event.getAlarmData().getAlarmType());\n        alarm.setClearKey(event.getAlarmData().getClearKey());\n        alarm.setCounter(1);\n        alarm.setDescription(e.getEventDescr());\n        alarm.setDistPoller(e.getDistPoller());\n        alarm.setEventParms(e.getEventParms());\n        alarm.setFirstEventTime(e.getEventTime());\n        alarm.setIfIndex(e.getIfIndex());\n        alarm.setIpAddr(e.getIpAddr());\n        alarm.setLastEventTime(e.getEventTime());\n        alarm.setLastEvent(e);\n        alarm.setLogMsg(e.getEventLogMsg());\n        alarm.setMouseOverText(e.getEventMouseOverText());\n        alarm.setNode(e.getNode());\n        alarm.setOperInstruct(e.getEventOperInstruct());\n        alarm.setReductionKey(event.getAlarmData().getReductionKey());\n        alarm.setServiceType(e.getServiceType());\n        alarm.setSeverity(OnmsSeverity.get(e.getEventSeverity())); //TODO: what to do?\n        alarm.setSuppressedUntil(e.getEventTime()); //TODO: fix UI to not require this be set\n        alarm.setSuppressedTime(e.getEventTime()); //TODO: Fix UI to not require this be set\n        //alarm.setTTicketId(e.getEventTTicket());\n        //alarm.setTTicketState(TroubleTicketState.CANCEL_FAILED);  //FIXME\n        alarm.setUei(e.getEventUei());\n        e.setAlarm(alarm);\n        return alarm;\n    }","id":102023,"modified_method":"private static OnmsAlarm createNewAlarm(OnmsEvent e, Event event) {\n        e.getServiceType().getName(); // To avoid potential LazyInitializationException when dealing with NorthboundAlarm\n        OnmsAlarm alarm;\n        alarm = new OnmsAlarm();\n        alarm.setAlarmType(event.getAlarmData().getAlarmType());\n        alarm.setClearKey(event.getAlarmData().getClearKey());\n        alarm.setCounter(1);\n        alarm.setDescription(e.getEventDescr());\n        alarm.setDistPoller(e.getDistPoller());\n        alarm.setEventParms(e.getEventParms());\n        alarm.setFirstEventTime(e.getEventTime());\n        alarm.setIfIndex(e.getIfIndex());\n        alarm.setIpAddr(e.getIpAddr());\n        alarm.setLastEventTime(e.getEventTime());\n        alarm.setLastEvent(e);\n        alarm.setLogMsg(e.getEventLogMsg());\n        alarm.setMouseOverText(e.getEventMouseOverText());\n        alarm.setNode(e.getNode());\n        alarm.setOperInstruct(e.getEventOperInstruct());\n        alarm.setReductionKey(event.getAlarmData().getReductionKey());\n        alarm.setServiceType(e.getServiceType());\n        alarm.setSeverity(OnmsSeverity.get(e.getEventSeverity())); //TODO: what to do?\n        alarm.setSuppressedUntil(e.getEventTime()); //TODO: fix UI to not require this be set\n        alarm.setSuppressedTime(e.getEventTime()); //TODO: Fix UI to not require this be set\n        //alarm.setTTicketId(e.getEventTTicket());\n        //alarm.setTTicketState(TroubleTicketState.CANCEL_FAILED);  //FIXME\n        alarm.setUei(e.getEventUei());\n        e.setAlarm(alarm);\n        return alarm;\n    }","commit_id":"024e0c146f021023be4aefd043b7a1e232fc882d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsServiceType getService() {\n\t\treturn m_service;\n\t}","id":102024,"modified_method":"public String getService() {\n\t\treturn m_service;\n\t}","commit_id":"024e0c146f021023be4aefd043b7a1e232fc882d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public NorthboundAlarm(OnmsAlarm alarm) {\n        //alarm.getAckId();\n        //alarm.getAckTime();\n        //alarm.getAckUser();\n        \n    \tm_nodeId = alarm.getNodeId();\n        m_ackTime = alarm.getAlarmAckTime();\n        m_ackUser = alarm.getAlarmAckUser();\n        m_alarmType = alarm.getAlarmType() == null ? null : AlarmType.toAlarmType(alarm.getAlarmType());\n        m_appDn = alarm.getApplicationDN();\n        m_clearKey = alarm.getClearKey();\n        m_count = alarm.getCounter();\n        m_desc = alarm.getDescription();\n        m_poller = alarm.getDistPoller();\n        m_eventParms = alarm.getEventParms();\n        //alarm.getFirstAutomationTime();\n        m_firstOccurrence = alarm.getFirstEventTime();\n        m_id = alarm.getId();\n        //alarm.getIfIndex();\n        m_ipAddr = alarm.getIpAddr();\n        //alarm.getLastAutomationTime();\n        //alarm.getLastEvent();\n        m_lastOccurrence = alarm.getLastEventTime();\n        m_logMsg = alarm.getLogMsg();\n        m_objectInstance = alarm.getManagedObjectInstance();\n        m_objectType = alarm.getManagedObjectType();\n        //alarm.getNode();\n        m_operInst = alarm.getOperInstruct();\n        m_ossKey = alarm.getOssPrimaryKey();\n        m_ossState = alarm.getQosAlarmState();\n        m_alarmKey = alarm.getReductionKey();\n        m_service = alarm.getServiceType();\n        m_severity = alarm.getSeverity();\n        //alarm.getSeverityId();\n        //alarm.getSeverityLabel();\n        m_suppressed = alarm.getSuppressedTime();\n        m_suppressedUntil = alarm.getSuppressedUntil();\n        m_suppressedBy = alarm.getSuppressedUser();\n        m_ticketId = alarm.getTTicketId();\n        m_ticketState = alarm.getTTicketState();\n        //alarm.getType();\n        m_uei = alarm.getUei();\n        m_x733Type = alarm.getX733AlarmType();\n        m_x733Cause = alarm.getX733ProbableCause();\n    }","id":102025,"modified_method":"public NorthboundAlarm(OnmsAlarm alarm) {\n        //alarm.getAckId();\n        //alarm.getAckTime();\n        //alarm.getAckUser();\n        \n    \tm_nodeId = alarm.getNodeId();\n        m_ackTime = alarm.getAlarmAckTime();\n        m_ackUser = alarm.getAlarmAckUser();\n        m_alarmType = alarm.getAlarmType() == null ? null : AlarmType.toAlarmType(alarm.getAlarmType());\n        m_appDn = alarm.getApplicationDN();\n        m_clearKey = alarm.getClearKey();\n        m_count = alarm.getCounter();\n        m_desc = alarm.getDescription();\n        m_poller = alarm.getDistPoller();\n        m_eventParms = alarm.getEventParms();\n        //alarm.getFirstAutomationTime();\n        m_firstOccurrence = alarm.getFirstEventTime();\n        m_id = alarm.getId();\n        //alarm.getIfIndex();\n        m_ipAddr = alarm.getIpAddr();\n        //alarm.getLastAutomationTime();\n        //alarm.getLastEvent();\n        m_lastOccurrence = alarm.getLastEventTime();\n        m_logMsg = alarm.getLogMsg();\n        m_objectInstance = alarm.getManagedObjectInstance();\n        m_objectType = alarm.getManagedObjectType();\n        //alarm.getNode();\n        m_operInst = alarm.getOperInstruct();\n        m_ossKey = alarm.getOssPrimaryKey();\n        m_ossState = alarm.getQosAlarmState();\n        m_alarmKey = alarm.getReductionKey();\n        m_service = alarm.getServiceType() == null ? null : alarm.getServiceType().getName();\n        m_severity = alarm.getSeverity();\n        //alarm.getSeverityId();\n        //alarm.getSeverityLabel();\n        m_suppressed = alarm.getSuppressedTime();\n        m_suppressedUntil = alarm.getSuppressedUntil();\n        m_suppressedBy = alarm.getSuppressedUser();\n        m_ticketId = alarm.getTTicketId();\n        m_ticketState = alarm.getTTicketState();\n        //alarm.getType();\n        m_uei = alarm.getUei();\n        m_x733Type = alarm.getX733AlarmType();\n        m_x733Cause = alarm.getX733ProbableCause();\n    }","commit_id":"024e0c146f021023be4aefd043b7a1e232fc882d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Map<String, String> createMapping(Map<Integer, Map<String, String>> alarmMappings, NorthboundAlarm alarm) {\n\t\tMap<String, String> mapping;\n\t\tmapping = new HashMap<String, String>();\n\t\tmapping.put(\"ackUser\", alarm.getAckUser());\n\t\tmapping.put(\"appDn\", alarm.getAppDn());\n\t\tmapping.put(\"logMsg\", alarm.getLogMsg());\n\t\tmapping.put(\"objectInstance\", alarm.getObjectInstance());\n\t\tmapping.put(\"objectType\", alarm.getObjectType());\n\t\tmapping.put(\"ossKey\", alarm.getOssKey());\n\t\tmapping.put(\"ossState\", alarm.getOssState());\n\t\tmapping.put(\"ticketId\", alarm.getTicketId());\n\t\tmapping.put(\"alarmUei\", alarm.getUei());\n\t\tmapping.put(\"ackTime\", nullSafeToString(alarm.getAckTime(), \"\"));\n\t\t\n\t\tAlarmType alarmType = alarm.getAlarmType() == null ? AlarmType.NOTIFICATION : alarm.getAlarmType();\n\t\tmapping.put(\"alarmType\", alarmType.name());\n\t\t\n\t\tString count = alarm.getCount() == null ? \"1\" : alarm.getCount().toString();\n\t\tmapping.put(\"count\", count);\n\t\t\n\t\tmapping.put(\"firstOccurrence\", nullSafeToString(alarm.getFirstOccurrence(), \"\"));\n\t\tmapping.put(\"alarmId\", alarm.getId().toString());\n\t\tmapping.put(\"ipAddr\", nullSafeToString(alarm.getIpAddr(), \"\"));\n\t\tmapping.put(\"lastOccurrence\", nullSafeToString(alarm.getLastOccurrence(), \"\"));\n\t\t\n\t\t\n\t\tif (alarm.getNodeId() != null) {\n\t\t\tmapping.put(\"nodeId\", alarm.getNodeId().toString());\n\t\t\tString nodeLabel = m_nodeDao.getLabelForId(alarm.getNodeId());\n\t\t\tmapping.put(\"nodeLabel\", nodeLabel == null ? \"?\" : nodeLabel);\n\t\t} else {\n\t\t\tmapping.put(\"nodeId\", \"\");\n\t\t\tmapping.put(\"nodeLabel\", \"\");\n\t\t}\n\t\t\n\t\t\n\t\tString poller = alarm.getPoller() == null ? \"localhost\" : alarm.getPoller().getName();\n\t\tmapping.put(\"distPoller\", poller);\n\t\t\n\t\tString service = alarm.getService() == null ? \"\" : alarm.getService().getName();\t\t\t\t\t\n\t\tmapping.put(\"ifService\", service);\n\t\t\n\t\tmapping.put(\"severity\", nullSafeToString(alarm.getSeverity(), \"\"));\n\t\tmapping.put(\"ticketState\", nullSafeToString(alarm.getTicketState(), \"\"));\n\t\t\n\t\tmapping.put(\"x733AlarmType\", alarm.getX733Type());\n\t\t\n\t\ttry {\n\t\t\tmapping.put(\"x733ProbableCause\", nullSafeToString(x733ProbableCause.get(alarm.getX733Cause()), \"\"));\n\t\t} catch (Exception e) {\n\t\t\tLogUtils.infof(this, e, \"Exception caught setting X733 Cause %d: \", alarm.getX733Cause(), e);\n\t\t\tmapping.put(\"x733ProbableCause\", \"\");\n\t\t}\n\t\t\n\t\tbuildParmMappings(alarm, mapping);\n\t\t\n\t\talarmMappings.put(alarm.getId(), mapping);\n\t\treturn mapping;\n\t}","id":102026,"modified_method":"private Map<String, String> createMapping(Map<Integer, Map<String, String>> alarmMappings, NorthboundAlarm alarm) {\n\t\tMap<String, String> mapping;\n\t\tmapping = new HashMap<String, String>();\n\t\tmapping.put(\"ackUser\", alarm.getAckUser());\n\t\tmapping.put(\"appDn\", alarm.getAppDn());\n\t\tmapping.put(\"logMsg\", alarm.getLogMsg());\n\t\tmapping.put(\"objectInstance\", alarm.getObjectInstance());\n\t\tmapping.put(\"objectType\", alarm.getObjectType());\n\t\tmapping.put(\"ossKey\", alarm.getOssKey());\n\t\tmapping.put(\"ossState\", alarm.getOssState());\n\t\tmapping.put(\"ticketId\", alarm.getTicketId());\n\t\tmapping.put(\"alarmUei\", alarm.getUei());\n\t\tmapping.put(\"ackTime\", nullSafeToString(alarm.getAckTime(), \"\"));\n\t\t\n\t\tAlarmType alarmType = alarm.getAlarmType() == null ? AlarmType.NOTIFICATION : alarm.getAlarmType();\n\t\tmapping.put(\"alarmType\", alarmType.name());\n\t\t\n\t\tString count = alarm.getCount() == null ? \"1\" : alarm.getCount().toString();\n\t\tmapping.put(\"count\", count);\n\t\t\n\t\tmapping.put(\"firstOccurrence\", nullSafeToString(alarm.getFirstOccurrence(), \"\"));\n\t\tmapping.put(\"alarmId\", alarm.getId().toString());\n\t\tmapping.put(\"ipAddr\", nullSafeToString(alarm.getIpAddr(), \"\"));\n\t\tmapping.put(\"lastOccurrence\", nullSafeToString(alarm.getLastOccurrence(), \"\"));\n\t\t\n\t\t\n\t\tif (alarm.getNodeId() != null) {\n\t\t\tmapping.put(\"nodeId\", alarm.getNodeId().toString());\n\t\t\tString nodeLabel = m_nodeDao.getLabelForId(alarm.getNodeId());\n\t\t\tmapping.put(\"nodeLabel\", nodeLabel == null ? \"?\" : nodeLabel);\n\t\t} else {\n\t\t\tmapping.put(\"nodeId\", \"\");\n\t\t\tmapping.put(\"nodeLabel\", \"\");\n\t\t}\n\t\t\n\t\t\n\t\tString poller = alarm.getPoller() == null ? \"localhost\" : alarm.getPoller().getName();\n\t\tmapping.put(\"distPoller\", poller);\n\t\t\n\t\tString service = alarm.getService() == null ? \"\" : alarm.getService();\n\t\tmapping.put(\"ifService\", service);\n\t\t\n\t\tmapping.put(\"severity\", nullSafeToString(alarm.getSeverity(), \"\"));\n\t\tmapping.put(\"ticketState\", nullSafeToString(alarm.getTicketState(), \"\"));\n\t\t\n\t\tmapping.put(\"x733AlarmType\", alarm.getX733Type());\n\t\t\n\t\ttry {\n\t\t\tmapping.put(\"x733ProbableCause\", nullSafeToString(x733ProbableCause.get(alarm.getX733Cause()), \"\"));\n\t\t} catch (Exception e) {\n\t\t\tLogUtils.infof(this, e, \"Exception caught setting X733 Cause %d: \", alarm.getX733Cause(), e);\n\t\t\tmapping.put(\"x733ProbableCause\", \"\");\n\t\t}\n\t\t\n\t\tbuildParmMappings(alarm, mapping);\n\t\t\n\t\talarmMappings.put(alarm.getId(), mapping);\n\t\treturn mapping;\n\t}","commit_id":"024e0c146f021023be4aefd043b7a1e232fc882d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public final void testTokenize() {\n    \n    testSplit(new String[] { \"This is a sentence. \" });\n    \n    // NOTE: sentences here need to end with a space character so they\n    // have correct whitespace when appended:\n    testSplit(new String[] { \"Dies ist ein Satz.\" });\n    testSplit(new String[] { \"Dies ist ein Satz. \", \"Noch einer.\" });\n    testSplit(new String[] { \"Ein Satz! \", \"Noch einer.\" });\n    testSplit(new String[] { \"Ein Satz... \", \"Noch einer.\" });\n    testSplit(new String[] { \"Unter http://www.test.de gibt es eine Website.\" });\n    testSplit(new String[] { \"To się wydarzyło 3.10.2000 i mam na to dowody.\" });\n\n    testSplit(new String[] { \"To było 13.12 - nikt nie zapomni tego przemówienia.\" });    \n    testSplit(new String[] { \"Heute ist der 13.12.2004.\" });\n    testSplit(new String[] { \"To jest np. ten debil spod jedynki.\" });\n    testSplit(new String[] { \"To jest 1. wydanie.\" });\n    testSplit(new String[] { \"Dziś jest 13. rocznica powstania wąchockiego.\" });    \n \n    testSplit(new String[] { \"Das in Punkt 3.9.1 genannte Verhalten.\" });\n\n    testSplit(new String[] { \"To jest tzw. premier.\" });\n    testSplit(new String[] { \"Jarek kupił sobie kurteczkę, tj. strój Marka.\" });\n\n    testSplit(new String[] { \"Das ist,, also ob es bla.\" });\n    testSplit(new String[] { \"Das ist es.. \", \"So geht es weiter.\" });\n\n    testSplit(new String[] { \"Das hier ist ein(!) Satz.\" });\n    testSplit(new String[] { \"Das hier ist ein(!!) Satz.\" });\n    testSplit(new String[] { \"Das hier ist ein(?) Satz.\" });\n    testSplit(new String[] { \"Das hier ist ein(???) Satz.\" });\n    testSplit(new String[] { \"Das hier ist ein(???) Satz.\" });\n\n    testSplit(new String[] { \"\u201ePrezydent jest niemądry\u201d. \", \"Tak wyszło.\" });\n    testSplit(new String[] { \"\u201ePrezydent jest niemądry\u201d, powiedział premier\" });\n\n    // TODO: derzeit unterscheiden wir nicht, ob nach dem Doppelpunkt ein\n    // ganzer Satz kommt oder nicht:\n    testSplit(new String[] { \"Das war es: gar nichts.\" });\n    testSplit(new String[] { \"Das war es: Dies ist ein neuer Satz.\" });\n\n    // incomplete sentences, need to work for on-thy-fly checking of texts:\n    testSplit(new String[] { \"Here's a\" });\n    testSplit(new String[] { \"Here's a sentence. \",\n        \"And here's one that's not comp\" });\n\n    // Tests taken from LanguageTool's SentenceSplitterTest.py:\n    testSplit(new String[] { \"This is a sentence. \" });\n    testSplit(new String[] { \"This is a sentence. \", \"And this is another one.\" });\n    testSplit(new String[] { \"This is a sentence.\", \"Isn't it?\", \"Yes, it is.\" });\n\n    testSplit(new String[] { \"Don't split strings like U. S. A. either.\" });\n    testSplit(new String[] { \"Don't split strings like U.S.A. either.\" });\n    testSplit(new String[] { \"Don't split... \", \"Well you know. \",\n        \"Here comes more text.\" });\n    testSplit(new String[] { \"Don't split... well you know. \",\n        \"Here comes more text.\" });\n    testSplit(new String[] { \"The \\\".\\\" should not be a delimiter in quotes.\" });\n    testSplit(new String[] { \"\\\"Here he comes!\\\" she said.\" });\n    testSplit(new String[] { \"\\\"Here he comes!\\\", she said.\" });\n    testSplit(new String[] { \"\\\"Here he comes.\\\" \",\n        \"But this is another sentence.\" });\n    testSplit(new String[] { \"\\\"Here he comes!\\\". \", \"That's what he said.\" });\n    testSplit(new String[] { \"The sentence ends here. \", \"(Another sentence.)\" });\n    // known to fail:\n    // testSplit(new String[]{\"He won't. \", \"Really.\"});\n    testSplit(new String[] { \"He won't go. \", \"Really.\" });\n    testSplit(new String[] { \"He won't say no.\", \"Not really.\" });\n    testSplit(new String[] { \"He won't say No.\", \"Not really.\" });\n    testSplit(new String[] { \"This is it: a test.\" });\n    // one/two returns = paragraph = new sentence:\n    TestTools\n        .testSplit(new String[] { \"He won't\\n\\n\", \"Really.\" }, stokenizer2);\n    TestTools.testSplit(new String[] { \"He won't\\n\", \"Really.\" }, stokenizer);\n    TestTools\n        .testSplit(new String[] { \"He won't\\n\\n\", \"Really.\" }, stokenizer2);\n    TestTools.testSplit(new String[] { \"He won't\\nReally.\" }, stokenizer2);\n    // Missing space after sentence end:\n    testSplit(new String[] { \"James is from the Ireland!\",\n        \"He lives in Spain now.\" });\n\n    // from user bug reports:\n    testSplit(new String[] { \"Temperatura wody w systemie wynosi 30°C.\",\n        \"W skład obiegu otwartego wchodzi zbiornik i armatura.\" });\n    testSplit(new String[] { \"Zabudowano kolumny o długości 45 m. \",\n        \"Woda z ujęcia jest dostarczana do zakładu.\" });\n\n    // From the abbreviation list:\n    testSplit(new String[] { \"Ks. Jankowski jest prof. teologii.\" });\n    testSplit(new String[] { \"To wydarzyło się w 1939 r.\",\n        \"To był burzliwy rok.\" });\n    testSplit(new String[] { \"Prezydent jest popierany przez 20 proc. społeczeństwa.\" });\n    testSplit(new String[] {\n        \"Moje wystąpienie ma na celu zmobilizowanie zarządu partii do działań, które umożliwią uzyskanie 40 proc.\",\n        \"Nie widzę dziś na scenie politycznej formacji, która lepiej by łączyła różne poglądy\" });\n    testSplit(new String[] { \"To jest zmienna A.\", \"Zaś to jest zmienna B.\" });\n    // SKROTY_BEZ_KROPKI in ENDABREVLIST\n    testSplit(new String[] { \"Mam już 20 mln.\", \"To powinno mi wystarczyć\" });\n    testSplit(new String[] { \"Mam już 20 mln. buraków.\" });\n    // ellipsis\n    testSplit(new String[] { \"Rytmem tej wiecznie przemijającej światowej egzystencji [\u2026] rytmem mesjańskiej natury jest szczęście.\" });\n    // sic!\n    testSplit(new String[] { \"W gazecie napisali, że pasy (sic!) pogryzły człowieka.\" });\n    // Numbers with dots.\n    testSplit(new String[] { \"Mam w magazynie dwie skrzynie LMD20. \", \"Jestem żołnierzem i wiem, jak można ich użyć\"});\n  }","id":102027,"modified_method":"public final void testTokenize() {\n    \n    testSplit(new String[] { \"This is a sentence. \" });\n    \n    // NOTE: sentences here need to end with a space character so they\n    // have correct whitespace when appended:\n    testSplit(new String[] { \"Dies ist ein Satz.\" });\n    testSplit(new String[] { \"Dies ist ein Satz. \", \"Noch einer.\" });\n    testSplit(new String[] { \"Ein Satz! \", \"Noch einer.\" });\n    testSplit(new String[] { \"Ein Satz... \", \"Noch einer.\" });\n    testSplit(new String[] { \"Unter http://www.test.de gibt es eine Website.\" });\n    testSplit(new String[] { \"To się wydarzyło 3.10.2000 i mam na to dowody.\" });\n\n    testSplit(new String[] { \"To było 13.12 - nikt nie zapomni tego przemówienia.\" });    \n    testSplit(new String[] { \"Heute ist der 13.12.2004.\" });\n    testSplit(new String[] { \"To jest np. ten debil spod jedynki.\" });\n    testSplit(new String[] { \"To jest 1. wydanie.\" });\n    testSplit(new String[] { \"Dziś jest 13. rocznica powstania wąchockiego.\" });    \n \n    testSplit(new String[] { \"Das in Punkt 3.9.1 genannte Verhalten.\" });\n\n    testSplit(new String[] { \"To jest tzw. premier.\" });\n    testSplit(new String[] { \"Jarek kupił sobie kurteczkę, tj. strój Marka.\" });\n\n    testSplit(new String[] { \"Das ist,, also ob es bla.\" });\n    testSplit(new String[] { \"Das ist es.. \", \"So geht es weiter.\" });\n\n    testSplit(new String[] { \"Das hier ist ein(!) Satz.\" });\n    testSplit(new String[] { \"Das hier ist ein(!!) Satz.\" });\n    testSplit(new String[] { \"Das hier ist ein(?) Satz.\" });\n    testSplit(new String[] { \"Das hier ist ein(???) Satz.\" });\n    testSplit(new String[] { \"Das hier ist ein(???) Satz.\" });\n\n    testSplit(new String[] { \"\u201ePrezydent jest niemądry\u201d. \", \"Tak wyszło.\" });\n    testSplit(new String[] { \"\u201ePrezydent jest niemądry\u201d, powiedział premier\" });\n\n    // TODO: derzeit unterscheiden wir nicht, ob nach dem Doppelpunkt ein\n    // ganzer Satz kommt oder nicht:\n    testSplit(new String[] { \"Das war es: gar nichts.\" });\n    testSplit(new String[] { \"Das war es: Dies ist ein neuer Satz.\" });\n\n    // incomplete sentences, need to work for on-thy-fly checking of texts:\n    testSplit(new String[] { \"Here's a\" });\n    testSplit(new String[] { \"Here's a sentence. \",\n        \"And here's one that's not comp\" });\n\n    // Tests taken from LanguageTool's SentenceSplitterTest.py:\n    testSplit(new String[] { \"This is a sentence. \" });\n    testSplit(new String[] { \"This is a sentence. \", \"And this is another one.\" });\n    testSplit(new String[] { \"This is a sentence.\", \"Isn't it?\", \"Yes, it is.\" });\n\n    testSplit(new String[] { \"Don't split strings like U. S. A. either.\" });\n    testSplit(new String[] { \"Don't split strings like U.S.A. either.\" });\n    testSplit(new String[] { \"Don't split... \", \"Well you know. \",\n        \"Here comes more text.\" });\n    testSplit(new String[] { \"Don't split... well you know. \",\n        \"Here comes more text.\" });\n    testSplit(new String[] { \"The \\\".\\\" should not be a delimiter in quotes.\" });\n    testSplit(new String[] { \"\\\"Here he comes!\\\" she said.\" });\n    testSplit(new String[] { \"\\\"Here he comes!\\\", she said.\" });\n    testSplit(new String[] { \"\\\"Here he comes.\\\" \",\n        \"But this is another sentence.\" });\n    testSplit(new String[] { \"\\\"Here he comes!\\\". \", \"That's what he said.\" });\n    testSplit(new String[] { \"The sentence ends here. \", \"(Another sentence.)\" });\n    // known to fail:\n    // testSplit(new String[]{\"He won't. \", \"Really.\"});\n    testSplit(new String[] { \"He won't go. \", \"Really.\" });\n    testSplit(new String[] { \"He won't say no.\", \"Not really.\" });\n    testSplit(new String[] { \"This is it: a test.\" });\n    // one/two returns = paragraph = new sentence:\n    TestTools\n        .testSplit(new String[] { \"He won't\\n\\n\", \"Really.\" }, stokenizer2);\n    TestTools.testSplit(new String[] { \"He won't\\n\", \"Really.\" }, stokenizer);\n    TestTools\n        .testSplit(new String[] { \"He won't\\n\\n\", \"Really.\" }, stokenizer2);\n    TestTools.testSplit(new String[] { \"He won't\\nReally.\" }, stokenizer2);\n    // Missing space after sentence end:\n    testSplit(new String[] { \"James is from the Ireland!\",\n        \"He lives in Spain now.\" });\n\n    // from user bug reports:\n    testSplit(new String[] { \"Temperatura wody w systemie wynosi 30°C.\",\n        \"W skład obiegu otwartego wchodzi zbiornik i armatura.\" });\n    testSplit(new String[] { \"Zabudowano kolumny o długości 45 m. \",\n        \"Woda z ujęcia jest dostarczana do zakładu.\" });\n    \n    // two-letter initials:\n    testSplit(new String[] { \"Najlepszym polskim reżyserem był St. Różewicz. \", \"Chodzi o brata wielkiego poety.\" });\n    \n    // From the abbreviation list:\n    testSplit(new String[] { \"Ks. Jankowski jest prof. teologii.\" });\n    testSplit(new String[] { \"To wydarzyło się w 1939 r.\",\n        \"To był burzliwy rok.\" });\n    testSplit(new String[] { \"Prezydent jest popierany przez 20 proc. społeczeństwa.\" });\n    testSplit(new String[] {\n        \"Moje wystąpienie ma na celu zmobilizowanie zarządu partii do działań, które umożliwią uzyskanie 40 proc.\",\n        \"Nie widzę dziś na scenie politycznej formacji, która lepiej by łączyła różne poglądy\" });\n    testSplit(new String[] { \"To jest zmienna A.\", \"Zaś to jest zmienna B.\" });\n    // SKROTY_BEZ_KROPKI in ENDABREVLIST\n    testSplit(new String[] { \"Mam już 20 mln.\", \"To powinno mi wystarczyć\" });\n    testSplit(new String[] { \"Mam już 20 mln. buraków.\" });\n    // ellipsis\n    testSplit(new String[] { \"Rytmem tej wiecznie przemijającej światowej egzystencji [\u2026] rytmem mesjańskiej natury jest szczęście.\" });\n    // sic!\n    testSplit(new String[] { \"W gazecie napisali, że pasy (sic!) pogryzły człowieka.\" });\n    // Numbers with dots.\n    testSplit(new String[] { \"Mam w magazynie dwie skrzynie LMD20. \", \"Jestem żołnierzem i wiem, jak można ich użyć\"});\n  }","commit_id":"9c94c90494bfbf4571d3a2760ebe3ed37bc53f6c","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public final void testTokenize() {\n\n\t\t// Initials\n\t\ttestSplit(new String[] { \"A l'atenció d'A. Comes.\" });\n\t\ttestSplit(new String[] { \"A l'atenció d'À. Comes.\" });\n\n\t\t// Ellipsis\n\t\ttestSplit(new String[] { \"Desenganyeu-vos\u2026 \",\n\t\t\t\t\"L\u2019únic problema seriós de l'home en aquest món és el de subsistir.\" });\n\t\ttestSplit(new String[] { \"és clar\u2026 traduir és una feina endimoniada\" });\n\t\ttestSplit(new String[] { \"«El cordó del frare\u2026» surt d'una manera desguitarrada\" });\n\t\ttestSplit(new String[] { \"convidar el seu heroi \u2013del ram que sigui\u2013\u2026 a prendre cafè.\" });\t\n\t\t\n\t\t// Abbreviations\n\t\ttestSplit(new String[] { \"Viu al núm. 24 del carrer de l'Hort.\" });\n\t\ttestSplit(new String[] { \"El Dr. Joan no vindrà.\" });\n\t\ttestSplit(new String[] { \"Distingit Sr. Joan,\" });\n\t\ttestSplit(new String[] { \"Molt Hble. Sr. President\" });\n\n\t\t// A problem solved\n\t\ttestSplit(new String[] { \"El pou d'Avall. \", \"És bonic.\" }); \n\t\ttestSplit(new String[] { \"El pou d\u2019Avall. \", \"És bonic.\" });\n\t\ttestSplit(new String[] { \"Ell viu a l'u. \", \"Jo al dos.\" });\n\t\t\n\t\t//Unsolved problem\n\t\t//testSplit(new String[] { \"\u2013La vols més fina, l'euga? \", \"Mira-te-la, fill meu, l'euga.\" });\n\t\t\n\t}","id":102028,"modified_method":"public final void testTokenize() {\n\n\t\t// Simple sentences\n\t\ttestSplit(new String[] { \"Això és una frase. \", \"Això és una altra frase.\" });\n\t\ttestSplit(new String[] { \"Aquesta és l'egua. \", \"Aquell és el cavall.\" });\n\t\ttestSplit(new String[] { \"Aquesta és l'egua? \", \"Aquell és el cavall.\" });\n\t\ttestSplit(new String[] { \"Vols col·laborar? \", \"Sí, i tant.\" });\n\t\ttestSplit(new String[] { \"Com vas d'il·lusió? \", \"Bé, bé.\" });\n\t\ttestSplit(new String[] { \"Com vas d\u2019il·lusió? \", \"Bé, bé.\" });\n\t\ttestSplit(new String[] { \"És d\u2019abans-d\u2019ahir? \", \"Bé, bé.\" });\n\t\ttestSplit(new String[] { \"És d\u2019abans-d\u2019ahir! \", \"Bé, bé.\" });\n\t\ttestSplit(new String[] { \"Què vols dir? \", \"Ja ho tinc!\" });\n\t\ttestSplit(new String[] { \"Ja ho tinc! \", \"Què vols dir?\" });\n\t\ttestSplit(new String[] { \"Us explicaré com va anar: \", \"»La Maria va engegar el cotxe\" });\n\t\t\n\t\t// Initials\n\t\ttestSplit(new String[] { \"A l'atenció d'A. Comes.\" });\n\t\ttestSplit(new String[] { \"A l'atenció d'À. Comes.\" });\n\n\t\t// Ellipsis\n\t\ttestSplit(new String[] { \"Desenganyeu-vos\u2026 \",\n\t\t\t\t\"L\u2019únic problema seriós de l'home en aquest món és el de subsistir.\" });\n\t\ttestSplit(new String[] { \"és clar\u2026 traduir és una feina endimoniada\" });\n\t\ttestSplit(new String[] { \"«El cordó del frare\u2026» surt d'una manera desguitarrada\" });\n\t\ttestSplit(new String[] { \"convidar el seu heroi \u2013del ram que sigui\u2013\u2026 a prendre cafè.\" });\t\n\t\t\n\t\t// Abbreviations\n\t\ttestSplit(new String[] { \"Viu al núm. 24 del carrer de l'Hort.\" });\n\t\ttestSplit(new String[] { \"El Dr. Joan no vindrà.\" });\n\t\ttestSplit(new String[] { \"Distingit Sr. Joan,\" });\n\t\ttestSplit(new String[] { \"Molt Hble. Sr. President\" });\t\t\n\t\t\n\t\t// Exception to abbreviations\n\t\ttestSplit(new String[] { \"Ell és el número u. \", \"Jo el dos.\" });\n\t\t\n\t\t\n\t}","commit_id":"cbd7d9220850f27f60d56f2d52ea4717e53a58e7","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public void start() {\n    initLogging();\n\n    IndexProperties.ES_TYPE type = settings.hasKey(IndexProperties.TYPE) ?\n      IndexProperties.ES_TYPE.valueOf(settings.getString(IndexProperties.TYPE)) :\n      IndexProperties.ES_TYPE.DATA;\n\n    ImmutableSettings.Builder esSettings = ImmutableSettings.settingsBuilder();\n\n    switch (type) {\n      case MEMORY:\n        initMemoryES(esSettings);\n        break;\n      case TRANSPORT:\n        initTransportES(esSettings);\n        break;\n      case DATA:\n      default:\n        initDataES(esSettings);\n        break;\n    }\n\n    initAnalysis(esSettings);\n    initDirs(esSettings);\n    initRestConsole(esSettings);\n    initNetwork(esSettings);\n\n    node = NodeBuilder.nodeBuilder()\n      .settings(esSettings)\n      .node();\n    node.start();\n\n\n    if (\n      node.client().admin().cluster().prepareHealth()\n        .setWaitForYellowStatus()\n        .get(TimeValue.timeValueMillis(3000))\n        .getStatus() == ClusterHealthStatus.RED) {\n      throw new IllegalStateException(\n        String.format(\"Elasticsearch index is corrupt, please delete directory '%s/%s' and relaunch the SonarQube server.\", fileSystem.getHomeDir().getAbsolutePath(), DATA_DIR));\n    }\n\n    addIndexTemplates();\n\n    LOG.info(\"Elasticsearch started\");\n\n  }","id":102029,"modified_method":"@Override\n  public void start() {\n    initLogging();\n\n    IndexProperties.ES_TYPE type = settings.hasKey(IndexProperties.TYPE) ?\n      IndexProperties.ES_TYPE.valueOf(settings.getString(IndexProperties.TYPE)) :\n      IndexProperties.ES_TYPE.DATA;\n\n    ImmutableSettings.Builder esSettings = ImmutableSettings.settingsBuilder();\n\n    switch (type) {\n      case MEMORY:\n        initMemoryES(esSettings);\n        break;\n      case TRANSPORT:\n        initTransportES(esSettings);\n        break;\n      case DATA:\n      default:\n        initDataES(esSettings);\n        break;\n    }\n\n    initAnalysis(esSettings);\n    initDirs(esSettings);\n    initRestConsole(esSettings);\n    initNetwork(esSettings);\n\n    node = NodeBuilder.nodeBuilder()\n      .settings(esSettings)\n      .node();\n    node.start();\n\n\n    if (\n      node.client().admin().cluster().prepareHealth()\n        .setWaitForYellowStatus()\n        .get()\n        .getStatus() == ClusterHealthStatus.RED) {\n      throw new IllegalStateException(\n        String.format(\"Elasticsearch index is corrupt, please delete directory '%s/%s' and relaunch the SonarQube server.\", fileSystem.getHomeDir().getAbsolutePath(), DATA_DIR));\n    }\n\n    addIndexTemplates();\n\n    LOG.info(\"Elasticsearch started\");\n\n  }","commit_id":"6712c2176821aced7a0478106d2ccc1114979ca5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void initAnalysis(ImmutableSettings.Builder esSettings) {\n    esSettings\n      .put(\"index.mapper.dynamic\", false)\n\n      .put(\"index.analysis.analyzer.sortable.type\", \"custom\")\n      .put(\"index.analysis.analyzer.sortable.tokenizer\", \"keyword\")\n      .putArray(\"index.analysis.analyzer.sortable.filter\", \"trim\", \"lowercase\", \"truncate\")\n\n      .put(\"index.analysis.analyzer.string_gram.type\", \"custom\")\n      .put(\"index.analysis.analyzer.string_gram.tokenizer\", \"whitespace\")\n      .putArray(\"index.analysis.analyzer.string_gram.filter\", \"lowercase\", \"code_gram\")\n\n      .put(\"index.analysis.filter.code_gram.type\", \"edgeNGram\")\n      .put(\"index.analysis.filter.code_gram.min_gram\", 2)\n      .put(\"index.analysis.filter.code_gram.max_gram\", 15)\n      .putArray(\"index.analysis.filter.code_gram.token_chars\", \"letter\", \"digit\", \"punctuation\", \"symbol\")\n\n      .put(\"index.analysis.analyzer.path_analyzer.type\", \"custom\")\n      .put(\"index.analysis.analyzer.path_analyzer.tokenizer\", \"path_hierarchy\");\n\n  }","id":102030,"modified_method":"private void initAnalysis(ImmutableSettings.Builder esSettings) {\n    esSettings\n      .put(\"index.mapper.dynamic\", false)\n\n        // Sortable text analyzer\n      .put(\"index.analysis.analyzer.sortable.type\", \"custom\")\n      .put(\"index.analysis.analyzer.sortable.tokenizer\", \"keyword\")\n      .putArray(\"index.analysis.analyzer.sortable.filter\", \"trim\", \"lowercase\", \"truncate\")\n\n        // Edge NGram index-analyzer\n      .put(\"index.analysis.analyzer.index_grams.type\", \"custom\")\n      .put(\"index.analysis.analyzer.index_grams.tokenizer\", \"whitespace\")\n      .putArray(\"index.analysis.analyzer.index_grams.filter\", \"trim\", \"lowercase\", \"gram_filter\")\n\n        // Edge NGram search-analyzer\n      .put(\"index.analysis.analyzer.search_grams.type\", \"custom\")\n      .put(\"index.analysis.analyzer.search_grams.tokenizer\", \"whitespace\")\n      .putArray(\"index.analysis.analyzer.search_grams.filter\", \"trim\", \"lowercase\")\n\n        // Word index-analyzer\n      .put(\"index.analysis.analyzer.index_words.type\", \"custom\")\n      .put(\"index.analysis.analyzer.index_words.tokenizer\", \"standard\")\n      .putArray(\"index.analysis.analyzer.index_words.filter\",\n        \"standard\", \"word_filter\", \"lowercase\", \"stop\", \"asciifolding\", \"porter_stem\")\n\n        // Word search-analyzer\n      .put(\"index.analysis.analyzer.search_words.type\", \"custom\")\n      .put(\"index.analysis.analyzer.search_words.tokenizer\", \"standard\")\n      .putArray(\"index.analysis.analyzer.search_words.filter\",\n        \"standard\", \"lowercase\", \"stop\", \"asciifolding\", \"porter_stem\")\n\n\n        // Edge NGram filter\n      .put(\"index.analysis.filter.gram_filter.type\", \"edgeNGram\")\n      .put(\"index.analysis.filter.gram_filter.min_gram\", 2)\n      .put(\"index.analysis.filter.gram_filter.max_gram\", 15)\n      .putArray(\"index.analysis.filter.gram_filter.token_chars\", \"letter\", \"digit\", \"punctuation\", \"symbol\")\n\n        // Word filter\n      .put(\"index.analysis.filter.word_filter.type\", \"word_delimiter\")\n      .put(\"index.analysis.filter.word_filter.generate_word_parts\", true)\n      .put(\"index.analysis.filter.word_filter.catenate_words\", true)\n      .put(\"index.analysis.filter.word_filter.catenate_numbers\", true)\n      .put(\"index.analysis.filter.word_filter.catenate_all\", true)\n      .put(\"index.analysis.filter.word_filter.split_on_case_change\", true)\n      .put(\"index.analysis.filter.word_filter.preserve_original\", true)\n      .put(\"index.analysis.filter.word_filter.split_on_numerics\", true)\n      .put(\"index.analysis.filter.word_filter.stem_english_possessive\", true)\n\n        // Path Analyzer\n      .put(\"index.analysis.analyzer.path_analyzer.type\", \"custom\")\n      .put(\"index.analysis.analyzer.path_analyzer.tokenizer\", \"path_hierarchy\");\n\n  }","commit_id":"6712c2176821aced7a0478106d2ccc1114979ca5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void check_analyzer() throws Exception {\n    ESNode node = new ESNode(fs, new Settings());\n    node.start();\n\n    node.client().admin().indices().prepareCreate(\"polop\")\n      .addMapping(\"type1\", \"{\\\"type1\\\": {\\\"properties\\\": {\\\"value\\\": {\\\"type\\\": \\\"string\\\"}}}}\")\n      .execute().actionGet();\n    node.client().admin().cluster().prepareHealth(\"polop\").setWaitForYellowStatus().get(TimeValue.timeValueMillis(1000));\n\n    // default \"sortable\" analyzer is defined for all indices\n    assertThat(node.client().admin().indices()\n      .prepareAnalyze(\"polop\", \"This Is A Wonderful Text\").setAnalyzer(\"sortable\").get()\n      .getTokens().get(0).getTerm()).isEqualTo(\"this is a \");\n\n    // default \"string_gram\" analyzer is defined for all indices\n    AnalyzeResponse response = node.client().admin().indices()\n      .prepareAnalyze(\"polop\", \"he.llo w@rl#d\").setAnalyzer(\"string_gram\").get();\n    assertThat(response.getTokens()).hasSize(10);\n    assertThat(response.getTokens().get(0).getTerm()).isEqualTo(\"he\");\n    assertThat(response.getTokens().get(7).getTerm()).isEqualTo(\"w@rl\");\n\n    // default \"path_analyzer\" analyzer is defined for all indices\n    response = node.client().admin().indices()\n      .prepareAnalyze(\"polop\", \"/temp/65236/test path/MyFile.java\").setAnalyzer(\"path_analyzer\").get();\n    // default \"path_analyzer\" analyzer is defined for all indices\n    assertThat(response.getTokens()).hasSize(4);\n    assertThat(response.getTokens().get(0).getTerm()).isEqualTo(\"/temp\");\n    assertThat(response.getTokens().get(1).getTerm()).isEqualTo(\"/temp/65236\");\n    assertThat(response.getTokens().get(2).getTerm()).isEqualTo(\"/temp/65236/test path\");\n    assertThat(response.getTokens().get(3).getTerm()).isEqualTo(\"/temp/65236/test path/MyFile.java\");\n  }","id":102031,"modified_method":"@Test\n  public void check_path_analyzer() throws Exception {\n    ESNode node = new ESNode(fs, new Settings());\n    node.start();\n\n    node.client().admin().indices().prepareCreate(\"polop\")\n      .addMapping(\"type1\", \"{\\\"type1\\\": {\\\"properties\\\": {\\\"value\\\": {\\\"type\\\": \\\"string\\\"}}}}\")\n      .execute().actionGet();\n    node.client().admin().cluster().prepareHealth(\"polop\").setWaitForYellowStatus().get(TimeValue.timeValueMillis(1000));\n\n    // default \"path_analyzer\" analyzer is defined for all indices\n    AnalyzeResponse response = node.client().admin().indices()\n      .prepareAnalyze(\"polop\", \"/temp/65236/test path/MyFile.java\").setAnalyzer(\"path_analyzer\").get();\n    // default \"path_analyzer\" analyzer is defined for all indices\n    assertThat(response.getTokens()).hasSize(4);\n    assertThat(response.getTokens().get(0).getTerm()).isEqualTo(\"/temp\");\n    assertThat(response.getTokens().get(1).getTerm()).isEqualTo(\"/temp/65236\");\n    assertThat(response.getTokens().get(2).getTerm()).isEqualTo(\"/temp/65236/test path\");\n    assertThat(response.getTokens().get(3).getTerm()).isEqualTo(\"/temp/65236/test path/MyFile.java\");\n\n    node.stop();\n  }","commit_id":"6712c2176821aced7a0478106d2ccc1114979ca5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void initDataES() {\n    initLogging();\n    ImmutableSettings.Builder esSettings = ImmutableSettings.settingsBuilder()\n      .put(\"node.name\", \"sonarqube-\" + System.currentTimeMillis())\n      .put(\"node.data\", true)\n      .put(\"node.local\", true)\n      .put(\"cluster.name\", \"sonarqube\")\n      .put(\"index.number_of_shards\", \"1\")\n      .put(\"index.number_of_replicas\", \"0\")\n      .put(\"index.mapper.dynamic\", false)\n\n      .put(\"index.analysis.analyzer.sortable.type\", \"custom\")\n      .put(\"index.analysis.analyzer.sortable.tokenizer\", \"keyword\")\n      .putArray(\"index.analysis.analyzer.sortable.filter\", \"trim\",\"lowercase\",\"truncate\")\n\n      .put(\"index.analysis.analyzer.string_gram.type\", \"custom\")\n      .put(\"index.analysis.analyzer.string_gram.tokenizer\", \"whitespace\")\n      .putArray(\"index.analysis.analyzer.string_gram.filter\", \"lowercase\", \"code_gram\")\n\n      .put(\"index.analysis.filter.code_gram.type\", \"edgeNGram\")\n      .put(\"index.analysis.filter.code_gram.min_gram\", 2)\n      .put(\"index.analysis.filter.code_gram.max_gram\", 15)\n      .putArray(\"index.analysis.filter.code_gram.token_chars\", \"letter\", \"digit\", \"punctuation\", \"symbol\");\n\n    initDirs(esSettings);\n    initRestConsole(esSettings);\n    initNetwork(esSettings);\n\n    node = NodeBuilder.nodeBuilder()\n      .settings(esSettings)\n      .node();\n    node.start();\n\n    addIndexTemplates();\n\n    if (\n      node.client().admin().cluster().prepareHealth()\n        .setWaitForYellowStatus()\n        .setTimeout(healthTimeout)\n        .execute().actionGet()\n        .getStatus() == ClusterHealthStatus.RED) {\n      throw new IllegalStateException(\n        String.format(\"Elasticsearch index is corrupt, please delete directory '%s/%s' and relaunch the SonarQube server.\", fileSystem.getHomeDir().getAbsolutePath(), DATA_DIR));\n    }\n\n    LOG.info(\"Elasticsearch started\");\n  }","id":102032,"modified_method":"private void initDataES() {\n    initLogging();\n    ImmutableSettings.Builder esSettings = ImmutableSettings.settingsBuilder()\n      .put(\"node.name\", \"sonarqube-\" + System.currentTimeMillis())\n      .put(\"node.data\", true)\n      .put(\"node.local\", true)\n      .put(\"cluster.name\", \"sonarqube\")\n      .put(\"index.number_of_shards\", \"1\")\n      .put(\"index.number_of_replicas\", \"0\")\n      .put(\"index.mapper.dynamic\", false)\n\n      .put(\"index.analysis.analyzer.sortable.type\", \"custom\")\n      .put(\"index.analysis.analyzer.sortable.tokenizer\", \"keyword\")\n      .putArray(\"index.analysis.analyzer.sortable.filter\", \"trim\",\"lowercase\",\"truncate\")\n\n      .put(\"index.analysis.analyzer.string_gram.type\", \"custom\")\n      .put(\"index.analysis.analyzer.string_gram.tokenizer\", \"whitespace\")\n      .putArray(\"index.analysis.analyzer.string_gram.filter\", \"lowercase\", \"code_gram\")\n\n      .put(\"index.analysis.filter.code_gram.type\", \"edgeNGram\")\n      .put(\"index.analysis.filter.code_gram.min_gram\", 2)\n      .put(\"index.analysis.filter.code_gram.max_gram\", 15)\n      .putArray(\"index.analysis.filter.code_gram.token_chars\", \"letter\", \"digit\", \"punctuation\", \"symbol\")\n\n      .put(\"index.analysis.analyzer.path_analyzer.type\", \"custom\")\n      .put(\"index.analysis.analyzer.path_analyzer.tokenizer\", \"path_hierarchy\");\n\n    initDirs(esSettings);\n    initRestConsole(esSettings);\n    initNetwork(esSettings);\n\n    node = NodeBuilder.nodeBuilder()\n      .settings(esSettings)\n      .node();\n    node.start();\n\n    addIndexTemplates();\n\n    if (\n      node.client().admin().cluster().prepareHealth()\n        .setWaitForYellowStatus()\n        .setTimeout(healthTimeout)\n        .execute().actionGet()\n        .getStatus() == ClusterHealthStatus.RED) {\n      throw new IllegalStateException(\n        String.format(\"Elasticsearch index is corrupt, please delete directory '%s/%s' and relaunch the SonarQube server.\", fileSystem.getHomeDir().getAbsolutePath(), DATA_DIR));\n    }\n\n    LOG.info(\"Elasticsearch started\");\n  }","commit_id":"7cd127a2413489413d3a5a41402332eacda4b7c3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void check_analyzer() throws Exception {\n    ESNode node = new ESNode(fs, new Settings());\n    node.start();\n\n    node.client().admin().indices().prepareCreate(\"polop\")\n      .addMapping(\"type1\", \"{\\\"type1\\\": {\\\"properties\\\": {\\\"value\\\": {\\\"type\\\": \\\"string\\\"}}}}\")\n      .execute().actionGet();\n    node.client().admin().cluster().prepareHealth(\"polop\").setWaitForYellowStatus().get(TimeValue.timeValueMillis(1000));\n\n    // default \"sortable\" analyzer is defined for all indices\n    assertThat(node.client().admin().indices()\n      .prepareAnalyze(\"polop\", \"This Is A Wonderful Text\").setAnalyzer(\"sortable\").get()\n      .getTokens().get(0).getTerm()).isEqualTo(\"this is a \");\n\n    // default \"sortable\" analyzer is defined for all indices\n    AnalyzeResponse response = node.client().admin().indices()\n      .prepareAnalyze(\"polop\", \"he.llo w@rl#d\").setAnalyzer(\"string_gram\").get();\n\n    assertThat(response.getTokens()).hasSize(10);\n    assertThat(response.getTokens().get(0).getTerm()).isEqualTo(\"he\");\n    assertThat(response.getTokens().get(7).getTerm()).isEqualTo(\"w@rl\");\n  }","id":102033,"modified_method":"@Test\n  public void check_analyzer() throws Exception {\n    ESNode node = new ESNode(fs, new Settings());\n    node.start();\n\n    node.client().admin().indices().prepareCreate(\"polop\")\n      .addMapping(\"type1\", \"{\\\"type1\\\": {\\\"properties\\\": {\\\"value\\\": {\\\"type\\\": \\\"string\\\"}}}}\")\n      .execute().actionGet();\n    node.client().admin().cluster().prepareHealth(\"polop\").setWaitForYellowStatus().get(TimeValue.timeValueMillis(1000));\n\n    // default \"sortable\" analyzer is defined for all indices\n    assertThat(node.client().admin().indices()\n      .prepareAnalyze(\"polop\", \"This Is A Wonderful Text\").setAnalyzer(\"sortable\").get()\n      .getTokens().get(0).getTerm()).isEqualTo(\"this is a \");\n\n    // default \"string_gram\" analyzer is defined for all indices\n    AnalyzeResponse response = node.client().admin().indices()\n      .prepareAnalyze(\"polop\", \"he.llo w@rl#d\").setAnalyzer(\"string_gram\").get();\n    assertThat(response.getTokens()).hasSize(10);\n    assertThat(response.getTokens().get(0).getTerm()).isEqualTo(\"he\");\n    assertThat(response.getTokens().get(7).getTerm()).isEqualTo(\"w@rl\");\n\n    // default \"path_analyzer\" analyzer is defined for all indices\n    response = node.client().admin().indices()\n      .prepareAnalyze(\"polop\", \"/temp/65236/test path/MyFile.java\").setAnalyzer(\"path_analyzer\").get();\n    // default \"path_analyzer\" analyzer is defined for all indices\n    assertThat(response.getTokens()).hasSize(4);\n    assertThat(response.getTokens().get(0).getTerm()).isEqualTo(\"/temp\");\n    assertThat(response.getTokens().get(1).getTerm()).isEqualTo(\"/temp/65236\");\n    assertThat(response.getTokens().get(2).getTerm()).isEqualTo(\"/temp/65236/test path\");\n    assertThat(response.getTokens().get(3).getTerm()).isEqualTo(\"/temp/65236/test path/MyFile.java\");\n  }","commit_id":"7cd127a2413489413d3a5a41402332eacda4b7c3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"static ImmutableSettings.Builder defaults() {\n    return ImmutableSettings.builder()\n      .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n      .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n      .put(\"index.refresh_interval\", \"30s\")\n      .put(\"index.mapper.dynamic\", false)\n\n      // Sortable text analyzer\n      .put(\"index.analysis.analyzer.sortable.type\", \"custom\")\n      .put(\"index.analysis.analyzer.sortable.tokenizer\", \"keyword\")\n      .putArray(\"index.analysis.analyzer.sortable.filter\", \"trim\", \"lowercase\")\n\n      // Edge NGram index-analyzer\n      .put(\"index.analysis.analyzer.index_grams.type\", \"custom\")\n      .put(\"index.analysis.analyzer.index_grams.tokenizer\", \"whitespace\")\n      .putArray(\"index.analysis.analyzer.index_grams.filter\", \"trim\", \"lowercase\", \"gram_filter\")\n\n      // Edge NGram search-analyzer\n      .put(\"index.analysis.analyzer.search_grams.type\", \"custom\")\n      .put(\"index.analysis.analyzer.search_grams.tokenizer\", \"whitespace\")\n      .putArray(\"index.analysis.analyzer.search_grams.filter\", \"trim\", \"lowercase\")\n\n      // Word index-analyzer\n      .put(\"index.analysis.analyzer.index_words.type\", \"custom\")\n      .put(\"index.analysis.analyzer.index_words.tokenizer\", \"standard\")\n      .putArray(\"index.analysis.analyzer.index_words.filter\",\n        \"standard\", \"word_filter\", \"lowercase\", \"stop\", \"asciifolding\", \"porter_stem\")\n\n      // Word search-analyzer\n      .put(\"index.analysis.analyzer.search_words.type\", \"custom\")\n      .put(\"index.analysis.analyzer.search_words.tokenizer\", \"standard\")\n      .putArray(\"index.analysis.analyzer.search_words.filter\",\n        \"standard\", \"lowercase\", \"stop\", \"asciifolding\", \"porter_stem\")\n\n      // Edge NGram filter\n      .put(\"index.analysis.filter.gram_filter.type\", \"edgeNGram\")\n      .put(\"index.analysis.filter.gram_filter.min_gram\", 2)\n      .put(\"index.analysis.filter.gram_filter.max_gram\", 15)\n      .putArray(\"index.analysis.filter.gram_filter.token_chars\", \"letter\", \"digit\", \"punctuation\", \"symbol\")\n\n      // Word filter\n      .put(\"index.analysis.filter.word_filter.type\", \"word_delimiter\")\n      .put(\"index.analysis.filter.word_filter.generate_word_parts\", true)\n      .put(\"index.analysis.filter.word_filter.catenate_words\", true)\n      .put(\"index.analysis.filter.word_filter.catenate_numbers\", true)\n      .put(\"index.analysis.filter.word_filter.catenate_all\", true)\n      .put(\"index.analysis.filter.word_filter.split_on_case_change\", true)\n      .put(\"index.analysis.filter.word_filter.preserve_original\", true)\n      .put(\"index.analysis.filter.word_filter.split_on_numerics\", true)\n      .put(\"index.analysis.filter.word_filter.stem_english_possessive\", true)\n\n      // Path Analyzer\n      .put(\"index.analysis.analyzer.path_analyzer.type\", \"custom\")\n      .put(\"index.analysis.analyzer.path_analyzer.tokenizer\", \"path_hierarchy\")\n\n      // UUID Module analyzer\n      .put(\"index.analysis.tokenizer.dot_tokenizer.type\", \"pattern\")\n      .put(\"index.analysis.tokenizer.dot_tokenizer.pattern\", \"\\\\.\")\n      .put(\"index.analysis.analyzer.uuid_analyzer.type\", \"custom\")\n      .putArray(\"index.analysis.analyzer.uuid_analyzer.filter\", \"trim\")\n      .put(\"index.analysis.analyzer.uuid_analyzer.tokenizer\", \"dot_tokenizer\");\n\n  }","id":102034,"modified_method":"static ImmutableSettings.Builder defaults() {\n    return ImmutableSettings.builder()\n      .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n      .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n      .put(\"index.refresh_interval\", \"30s\")\n      .put(\"index.mapper.dynamic\", false)\n\n      // Sortable text analyzer\n      .put(\"index.analysis.analyzer.sortable.type\", \"custom\")\n      .put(\"index.analysis.analyzer.sortable.tokenizer\", \"keyword\")\n      .putArray(\"index.analysis.analyzer.sortable.filter\", \"trim\", \"lowercase\")\n\n      // Edge NGram index-analyzer\n      .put(\"index.analysis.analyzer.index_grams.type\", \"custom\")\n      .put(\"index.analysis.analyzer.index_grams.tokenizer\", \"whitespace\")\n      .putArray(\"index.analysis.analyzer.index_grams.filter\", \"trim\", \"lowercase\", \"gram_filter\")\n\n      // Edge NGram search-analyzer\n      .put(\"index.analysis.analyzer.search_grams.type\", \"custom\")\n      .put(\"index.analysis.analyzer.search_grams.tokenizer\", \"whitespace\")\n      .putArray(\"index.analysis.analyzer.search_grams.filter\", \"trim\", \"lowercase\")\n\n      // Word index-analyzer\n      .put(\"index.analysis.analyzer.index_words.type\", \"custom\")\n      .put(\"index.analysis.analyzer.index_words.tokenizer\", \"standard\")\n      .putArray(\"index.analysis.analyzer.index_words.filter\",\n        \"standard\", \"word_filter\", \"lowercase\", \"stop\", \"asciifolding\", \"porter_stem\")\n\n      // Word search-analyzer\n      .put(\"index.analysis.analyzer.search_words.type\", \"custom\")\n      .put(\"index.analysis.analyzer.search_words.tokenizer\", \"standard\")\n      .putArray(\"index.analysis.analyzer.search_words.filter\",\n        \"standard\", \"lowercase\", \"stop\", \"asciifolding\", \"porter_stem\")\n\n      // English HTML analyzer\n      .put(\"index.analysis.analyzer.html_analyzer.type\", \"custom\")\n      .put(\"index.analysis.analyzer.html_analyzer.tokenizer\", \"standard\")\n      .putArray(\"index.analysis.analyzer.html_analyzer.filter\",\n        \"standard\", \"lowercase\", \"stop\", \"asciifolding\", \"porter_stem\")\n      .putArray(\"index.analysis.analyzer.html_analyzer.char_filter\", \"html_strip\")\n\n      // Edge NGram filter\n      .put(\"index.analysis.filter.gram_filter.type\", \"edgeNGram\")\n      .put(\"index.analysis.filter.gram_filter.min_gram\", 2)\n      .put(\"index.analysis.filter.gram_filter.max_gram\", 15)\n      .putArray(\"index.analysis.filter.gram_filter.token_chars\", \"letter\", \"digit\", \"punctuation\", \"symbol\")\n\n      // Word filter\n      .put(\"index.analysis.filter.word_filter.type\", \"word_delimiter\")\n      .put(\"index.analysis.filter.word_filter.generate_word_parts\", true)\n      .put(\"index.analysis.filter.word_filter.catenate_words\", true)\n      .put(\"index.analysis.filter.word_filter.catenate_numbers\", true)\n      .put(\"index.analysis.filter.word_filter.catenate_all\", true)\n      .put(\"index.analysis.filter.word_filter.split_on_case_change\", true)\n      .put(\"index.analysis.filter.word_filter.preserve_original\", true)\n      .put(\"index.analysis.filter.word_filter.split_on_numerics\", true)\n      .put(\"index.analysis.filter.word_filter.stem_english_possessive\", true)\n\n      // Path Analyzer\n      .put(\"index.analysis.analyzer.path_analyzer.type\", \"custom\")\n      .put(\"index.analysis.analyzer.path_analyzer.tokenizer\", \"path_hierarchy\")\n\n      // UUID Module analyzer\n      .put(\"index.analysis.tokenizer.dot_tokenizer.type\", \"pattern\")\n      .put(\"index.analysis.tokenizer.dot_tokenizer.pattern\", \"\\\\.\")\n      .put(\"index.analysis.analyzer.uuid_analyzer.type\", \"custom\")\n      .putArray(\"index.analysis.analyzer.uuid_analyzer.filter\", \"trim\")\n      .put(\"index.analysis.analyzer.uuid_analyzer.tokenizer\", \"dot_tokenizer\");\n\n  }","commit_id":"23ee784e6d44f8462c8d160c7a113a64424bfb67","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected Client nativeClient() {\n    return nativeClient;\n  }","id":102035,"modified_method":"public Client nativeClient() {\n    return nativeClient;\n  }","commit_id":"23ee784e6d44f8462c8d160c7a113a64424bfb67","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static QueryBuilder buildQuery(RuleQuery query) {\n\n    // No contextual query case\n    String queryText = query.getQueryText();\n    if (StringUtils.isEmpty(queryText)) {\n      return QueryBuilders.matchAllQuery();\n    }\n\n    // Build RuleBased contextual query\n    BoolQueryBuilder qb = QueryBuilders.boolQuery();\n    String queryString = query.getQueryText();\n\n    // Human readable type of querying\n    qb.should(simpleQueryStringQuery(query.getQueryText())\n      .field(FIELD_RULE_NAME + \".\" + SEARCH_WORDS_SUFFIX, 20f)\n      .field(FIELD_RULE_HTML_DESCRIPTION + \".\" + SEARCH_WORDS_SUFFIX, 3f)\n      .defaultOperator(SimpleQueryStringBuilder.Operator.AND)\n      ).boost(20f);\n\n    // Match and partial Match queries\n    // Search by key uses the \"sortable\" sub-field as it requires to be case-insensitive (lower-case filtering)\n    qb.should(matchQuery(FIELD_RULE_KEY + \".\" + SORT_SUFFIX, queryString).operator(MatchQueryBuilder.Operator.AND).boost(30f));\n    qb.should(matchQuery(FIELD_RULE_RULE_KEY + \".\" + SORT_SUFFIX, queryString).operator(MatchQueryBuilder.Operator.AND).boost(15f));\n    qb.should(termQuery(FIELD_RULE_LANGUAGE, queryString, 3f));\n    qb.should(termQuery(FIELD_RULE_ALL_TAGS, queryString, 10f));\n    qb.should(termAnyQuery(FIELD_RULE_ALL_TAGS, queryString, 1f));\n\n    return qb;\n  }","id":102036,"modified_method":"private static QueryBuilder buildQuery(RuleQuery query) {\n\n    // No contextual query case\n    String queryText = query.getQueryText();\n    if (StringUtils.isEmpty(queryText)) {\n      return QueryBuilders.matchAllQuery();\n    }\n\n    // Build RuleBased contextual query\n    BoolQueryBuilder qb = QueryBuilders.boolQuery();\n    String queryString = query.getQueryText();\n\n    // Human readable type of querying\n    qb.should(simpleQueryStringQuery(query.getQueryText())\n      .field(FIELD_RULE_NAME + \".\" + SEARCH_WORDS_SUFFIX, 20f)\n      .field(FIELD_RULE_HTML_DESCRIPTION, 3f)\n      .defaultOperator(SimpleQueryStringBuilder.Operator.AND)\n      ).boost(20f);\n\n    // Match and partial Match queries\n    // Search by key uses the \"sortable\" sub-field as it requires to be case-insensitive (lower-case filtering)\n    qb.should(matchQuery(FIELD_RULE_KEY + \".\" + SORT_SUFFIX, queryString).operator(MatchQueryBuilder.Operator.AND).boost(30f));\n    qb.should(matchQuery(FIELD_RULE_RULE_KEY + \".\" + SORT_SUFFIX, queryString).operator(MatchQueryBuilder.Operator.AND).boost(15f));\n    qb.should(termQuery(FIELD_RULE_LANGUAGE, queryString, 3f));\n    qb.should(termQuery(FIELD_RULE_ALL_TAGS, queryString, 10f));\n    qb.should(termAnyQuery(FIELD_RULE_ALL_TAGS, queryString, 1f));\n\n    return qb;\n  }","commit_id":"23ee784e6d44f8462c8d160c7a113a64424bfb67","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.refreshHandledByIndexer();\n    index.configureShards(settings);\n\n    // Rule type\n    NewIndex.NewIndexType ruleMapping = index.createType(TYPE_RULE);\n    ruleMapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_RULE_KEY));\n    ruleMapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", true, \"path\", RuleIndexDefinition.FIELD_RULE_REPOSITORY));\n    ruleMapping.setEnableSource(false);\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_KEY).enableSorting().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_RULE_KEY).enableSorting().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_REPOSITORY).docValues().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_INTERNAL_KEY).disableSearch().docValues().build();\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_NAME).enableSorting().enableWordSearch().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_HTML_DESCRIPTION).enableWordSearch().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_SEVERITY).docValues().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_STATUS).docValues().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_LANGUAGE).build();\n\n    ruleMapping.createBooleanField(FIELD_RULE_IS_TEMPLATE);\n    ruleMapping.stringFieldBuilder(FIELD_RULE_TEMPLATE_KEY).docValues().build();\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_ALL_TAGS).enableGramSearch().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_TYPE).build();\n\n    ruleMapping.createLongField(FIELD_RULE_CREATED_AT);\n    ruleMapping.createLongField(FIELD_RULE_UPDATED_AT);\n\n    // Active rule type\n    NewIndex.NewIndexType activeRuleMapping = index.createType(RuleIndexDefinition.TYPE_ACTIVE_RULE);\n    activeRuleMapping.setEnableSource(false);\n    activeRuleMapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", RuleIndexDefinition.FIELD_ACTIVE_RULE_KEY));\n    activeRuleMapping.setAttribute(\"_parent\", ImmutableMap.of(\"type\", RuleIndexDefinition.TYPE_RULE));\n    activeRuleMapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", true, \"path\", RuleIndexDefinition.FIELD_ACTIVE_RULE_REPOSITORY));\n\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_KEY).enableSorting().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_RULE_KEY).disableSearch().docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_REPOSITORY).disableSearch().docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_PROFILE_KEY).docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_INHERITANCE).docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_SEVERITY).docValues().build();\n\n    activeRuleMapping.createLongField(RuleIndexDefinition.FIELD_ACTIVE_RULE_CREATED_AT);\n    activeRuleMapping.createLongField(RuleIndexDefinition.FIELD_ACTIVE_RULE_UPDATED_AT);\n  }","id":102037,"modified_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.refreshHandledByIndexer();\n    index.configureShards(settings);\n\n    // Rule type\n    NewIndex.NewIndexType ruleMapping = index.createType(TYPE_RULE);\n    ruleMapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_RULE_KEY));\n    ruleMapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", true, \"path\", RuleIndexDefinition.FIELD_RULE_REPOSITORY));\n    ruleMapping.setEnableSource(false);\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_KEY).enableSorting().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_RULE_KEY).enableSorting().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_REPOSITORY).docValues().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_INTERNAL_KEY).disableSearch().docValues().build();\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_NAME).enableSorting().enableWordSearch().build();\n    ruleMapping.setProperty(FIELD_RULE_HTML_DESCRIPTION, ImmutableSortedMap.of(\n      \"type\", \"string\",\n      \"index\", \"analyzed\",\n      \"doc_values\", \"false\",\n      \"index_analyzer\", \"html_analyzer\",\n      \"search_analyzer\", \"html_analyzer\"\n      ));\n    ruleMapping.stringFieldBuilder(FIELD_RULE_SEVERITY).docValues().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_STATUS).docValues().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_LANGUAGE).build();\n\n    ruleMapping.createBooleanField(FIELD_RULE_IS_TEMPLATE);\n    ruleMapping.stringFieldBuilder(FIELD_RULE_TEMPLATE_KEY).docValues().build();\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_ALL_TAGS).enableGramSearch().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_TYPE).build();\n\n    ruleMapping.createLongField(FIELD_RULE_CREATED_AT);\n    ruleMapping.createLongField(FIELD_RULE_UPDATED_AT);\n\n    // Active rule type\n    NewIndex.NewIndexType activeRuleMapping = index.createType(RuleIndexDefinition.TYPE_ACTIVE_RULE);\n    activeRuleMapping.setEnableSource(false);\n    activeRuleMapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", RuleIndexDefinition.FIELD_ACTIVE_RULE_KEY));\n    activeRuleMapping.setAttribute(\"_parent\", ImmutableMap.of(\"type\", RuleIndexDefinition.TYPE_RULE));\n    activeRuleMapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", true, \"path\", RuleIndexDefinition.FIELD_ACTIVE_RULE_REPOSITORY));\n\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_KEY).enableSorting().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_RULE_KEY).disableSearch().docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_REPOSITORY).disableSearch().docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_PROFILE_KEY).docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_INHERITANCE).docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_SEVERITY).docValues().build();\n\n    activeRuleMapping.createLongField(RuleIndexDefinition.FIELD_ACTIVE_RULE_CREATED_AT);\n    activeRuleMapping.createLongField(RuleIndexDefinition.FIELD_ACTIVE_RULE_UPDATED_AT);\n  }","commit_id":"23ee784e6d44f8462c8d160c7a113a64424bfb67","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public AbstractGccCompatibleToolChain(String name, OperatingSystem operatingSystem, FileResolver fileResolver, ExecActionFactory execActionFactory, ToolSearchPath toolSearchPath) {\n        super(name, operatingSystem, fileResolver);\n        this.execActionFactory = execActionFactory;\n        this.toolSearchPath = toolSearchPath;\n\n        addPlatformConfiguration(new ToolChainDefaultArchitecture());\n        addPlatformConfiguration(new Intel32Architecture());\n        addPlatformConfiguration(new Intel64Architecture());\n        configInsertLocation = 0;\n    }","id":102038,"modified_method":"public AbstractGccCompatibleToolChain(String name, OperatingSystem operatingSystem, FileResolver fileResolver, ExecActionFactory execActionFactory, ToolSearchPath toolSearchPath) {\n        super(name, operatingSystem, fileResolver);\n        this.execActionFactory = execActionFactory;\n        this.toolSearchPath = toolSearchPath;\n\n        target(new ToolChainDefaultArchitecture());\n        target(new Intel32Architecture());\n        target(new Intel64Architecture());\n        configInsertLocation = 0;\n    }","commit_id":"7ee6c4c7784c8541ac74f7fe147a634e11f48f69","url":"https://github.com/gradle/gradle"},{"original_method":"protected TargetPlatformConfiguration getPlatformConfiguration(Platform targetPlatform) {\n        for (TargetPlatformConfiguration platformConfig : platformConfigs) {\n            if (platformConfig.supportsPlatform(targetPlatform)) {\n                return platformConfig;\n            }\n        }\n        return null;\n    }","id":102039,"modified_method":"protected ApplyablePlatformConfiguration getPlatformConfiguration(Platform targetPlatform) {\n        for (ApplyablePlatformConfiguration platformConfig : platformConfigs) {\n            if (platformConfig.supportsPlatform(targetPlatform)) {\n                return platformConfig;\n            }\n        }\n        return null;\n    }","commit_id":"7ee6c4c7784c8541ac74f7fe147a634e11f48f69","url":"https://github.com/gradle/gradle"},{"original_method":"public void addPlatformConfiguration(TargetPlatformConfiguration platformConfig) {\n        platformConfigs.add(configInsertLocation, platformConfig);\n        configInsertLocation++;\n    }","id":102040,"modified_method":"@Deprecated\n    public void addPlatformConfiguration(TargetPlatformConfiguration platformConfig) {\n        target(new ApplyableTargetPlatformConfigurationAdapter(platformConfig));\n    }","commit_id":"7ee6c4c7784c8541ac74f7fe147a634e11f48f69","url":"https://github.com/gradle/gradle"},{"original_method":"public PlatformToolChain target(Platform targetPlatform) {\n        TargetPlatformConfiguration platformConfiguration = getPlatformConfiguration(targetPlatform);\n        ToolChainAvailability result = new ToolChainAvailability();\n        if (platformConfiguration == null) {\n            result.unavailable(String.format(\"Don't know how to build for platform '%s'.\", targetPlatform.getName()));\n            return new UnavailablePlatformToolChain(result);\n        }\n        initTools(result);\n        if (!result.isAvailable()) {\n            return new UnavailablePlatformToolChain(result);\n        }\n\n        // Target the tools for the platform\n        ToolRegistry platformTools = new PlatformToolRegistry(toolRegistry, platformConfiguration);\n        return new GccPlatformToolChain(toolSearchPath, platformTools, execActionFactory, canUseCommandFile());\n    }","id":102041,"modified_method":"public PlatformToolChain select(Platform targetPlatform) {\n        ApplyablePlatformConfiguration applyablePlatformConfiguration = getPlatformConfiguration(targetPlatform);\n        ToolChainAvailability result = new ToolChainAvailability();\n        if (applyablePlatformConfiguration == null) {\n            result.unavailable(String.format(\"Don't know how to build for platform '%s'.\", targetPlatform.getName()));\n            return new UnavailablePlatformToolChain(result);\n        }\n        initTools(result);\n        if (!result.isAvailable()) {\n            return new UnavailablePlatformToolChain(result);\n        }\n\n        // Target the tools for the platform\n        ToolRegistry platformTools = new PlatformToolRegistry(toolRegistry, applyablePlatformConfiguration);\n        return new GccPlatformToolChain(toolSearchPath, platformTools, execActionFactory, canUseCommandFile());\n    }","commit_id":"7ee6c4c7784c8541ac74f7fe147a634e11f48f69","url":"https://github.com/gradle/gradle"},{"original_method":"public ToolChain getForPlatform(Platform targetPlatform) {\n        for (ToolChainInternal toolChain : searchOrder) {\n            if (toolChain.target(targetPlatform).isAvailable()) {\n                return toolChain;\n            }\n        }\n\n        // No tool chains can build for this platform. Assemble a description of why\n        Map<String, PlatformToolChain> candidates = new LinkedHashMap<String, PlatformToolChain>();\n        for (ToolChainInternal toolChain : searchOrder) {\n            candidates.put(toolChain.getDisplayName(), toolChain.target(targetPlatform));\n        }\n\n        return new UnavailableToolChain(new UnavailableToolChainDescription(targetPlatform, candidates));\n    }","id":102042,"modified_method":"public ToolChain getForPlatform(Platform targetPlatform) {\n        for (ToolChainInternal toolChain : searchOrder) {\n            if (toolChain.select(targetPlatform).isAvailable()) {\n                return toolChain;\n            }\n        }\n\n        // No tool chains can build for this platform. Assemble a description of why\n        Map<String, PlatformToolChain> candidates = new LinkedHashMap<String, PlatformToolChain>();\n        for (ToolChainInternal toolChain : searchOrder) {\n            candidates.put(toolChain.getDisplayName(), toolChain.select(targetPlatform));\n        }\n\n        return new UnavailableToolChain(new UnavailableToolChainDescription(targetPlatform, candidates));\n    }","commit_id":"7ee6c4c7784c8541ac74f7fe147a634e11f48f69","url":"https://github.com/gradle/gradle"},{"original_method":"public PlatformToolChain target(Platform targetPlatform) {\n            return new UnavailablePlatformToolChain(failure);\n        }","id":102043,"modified_method":"public PlatformToolChain select(Platform targetPlatform) {\n            return new UnavailablePlatformToolChain(failure);\n        }","commit_id":"7ee6c4c7784c8541ac74f7fe147a634e11f48f69","url":"https://github.com/gradle/gradle"},{"original_method":"public PlatformToolRegistry(ToolRegistry defaultTools, TargetPlatformConfiguration configuration) {\n        // TODO:DAZ Replace TargetPlatformConfiguration with an action that applies to the entire registry.\n        // This will involve exposing the tools by their 'name' in a container, and applying the action to that container.\n        register(defaultTools.getTool(ToolType.CPP_COMPILER), configuration.getCppCompilerArgs());\n        register(defaultTools.getTool(ToolType.C_COMPILER), configuration.getCCompilerArgs());\n        register(defaultTools.getTool(ToolType.OBJECTIVECPP_COMPILER), configuration.getObjectiveCppCompilerArgs());\n        register(defaultTools.getTool(ToolType.OBJECTIVEC_COMPILER), configuration.getObjectiveCCompilerArgs());\n        register(defaultTools.getTool(ToolType.ASSEMBLER), configuration.getAssemblerArgs());\n        register(defaultTools.getTool(ToolType.LINKER), configuration.getLinkerArgs());\n        register(defaultTools.getTool(ToolType.STATIC_LIB_ARCHIVER), configuration.getStaticLibraryArchiverArgs());\n    }","id":102044,"modified_method":"public PlatformToolRegistry(ToolRegistry defaultTools, ApplyablePlatformConfiguration applyablePlatformConfiguration) {\n        // TODO:DAZ Replace TargetPlatformConfiguration with an action that applies to the entire registry.\n        DefaultConfigurableToolChain configurableToolChain = new DefaultConfigurableToolChain(\n                defaultTools.getTool(ToolType.C_COMPILER),\n                defaultTools.getTool(ToolType.CPP_COMPILER),\n                defaultTools.getTool(ToolType.ASSEMBLER),\n                defaultTools.getTool(ToolType.OBJECTIVEC_COMPILER),\n                defaultTools.getTool(ToolType.OBJECTIVECPP_COMPILER),\n                defaultTools.getTool(ToolType.LINKER),\n                defaultTools.getTool(ToolType.STATIC_LIB_ARCHIVER));\n\n        applyablePlatformConfiguration.apply(configurableToolChain);\n\n        register(configurableToolChain.getCCompiler());\n        register(configurableToolChain.getCppCompiler());\n        register(configurableToolChain.getAssembler());\n        register(configurableToolChain.getObjcCompiler());\n        register(configurableToolChain.getObjcppCompiler());\n        register(configurableToolChain.getLinker());\n        register(configurableToolChain.getStaticLibArchiver());\n    }","commit_id":"7ee6c4c7784c8541ac74f7fe147a634e11f48f69","url":"https://github.com/gradle/gradle"},{"original_method":"private GccTool register(GccToolInternal baseTool, List<String> platformArgs) {\n        return gccTools.put(baseTool.getToolType(), new PlatformGccTool(baseTool, platformArgs));\n    }","id":102045,"modified_method":"private GccTool register(GccToolInternal tool) {\n        return gccTools.put(tool.getToolType(), tool);\n    }","commit_id":"7ee6c4c7784c8541ac74f7fe147a634e11f48f69","url":"https://github.com/gradle/gradle"},{"original_method":"public PlatformToolChain target(Platform targetPlatform) {\n        ToolChainAvailability result = new ToolChainAvailability();\n        result.mustBeAvailable(getAvailability());\n        if (visualCpp != null && !visualCpp.isSupportedPlatform(targetPlatform)) {\n            result.unavailable(String.format(\"Don't know how to build for platform '%s'.\", targetPlatform.getName()));\n        }\n        if (!result.isAvailable()) {\n            return new UnavailablePlatformToolChain(result);\n        }\n        return new VisualCppPlatformToolChain(visualCpp, windowsSdk, targetPlatform);\n    }","id":102046,"modified_method":"public PlatformToolChain select(Platform targetPlatform) {\n        ToolChainAvailability result = new ToolChainAvailability();\n        result.mustBeAvailable(getAvailability());\n        if (visualCpp != null && !visualCpp.isSupportedPlatform(targetPlatform)) {\n            result.unavailable(String.format(\"Don't know how to build for platform '%s'.\", targetPlatform.getName()));\n        }\n        if (!result.isAvailable()) {\n            return new UnavailablePlatformToolChain(result);\n        }\n        return new VisualCppPlatformToolChain(visualCpp, windowsSdk, targetPlatform);\n    }","commit_id":"7ee6c4c7784c8541ac74f7fe147a634e11f48f69","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {\n        messageReceived = true;\n\n        Object body = messageEvent.getMessage();\n        LOG.debug(\"Message received: {}\", body);\n\n        // if textline enabled then covert to a String which must be used for textline\n        if (producer.getConfiguration().isTextline()) {\n            try {\n                body = producer.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body);\n            } catch (NoTypeConversionAvailableException e) {\n                exchange.setException(e);\n                callback.done(false);\n            }\n        }\n\n\n        // set the result on either IN or OUT on the original exchange depending on its pattern\n        if (ExchangeHelper.isOutCapable(exchange)) {\n            NettyPayloadHelper.setOut(exchange, body);\n        } else {\n            NettyPayloadHelper.setIn(exchange, body);\n        }\n\n        try {\n            // should channel be closed after complete?\n            Boolean close;\n            if (ExchangeHelper.isOutCapable(exchange)) {\n                close = exchange.getOut().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);\n            } else {\n                close = exchange.getIn().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);\n            }\n\n            // should we disconnect, the header can override the configuration\n            boolean disconnect = producer.getConfiguration().isDisconnect();\n            if (close != null) {\n                disconnect = close;\n            }\n            if (disconnect) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Closing channel when complete at address: {}\", producer.getConfiguration().getAddress());\n                }\n                NettyHelper.close(ctx.getChannel());\n            }\n        } finally {\n            // signal callback\n            callback.done(false);\n        }\n    }","id":102047,"modified_method":"@Override\n    public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {\n        messageReceived = true;\n\n        Exchange exchange = getExchange(ctx);\n        AsyncCallback callback = getAsyncCallback(ctx);\n\n        Object body = messageEvent.getMessage();\n        LOG.debug(\"Message received: {}\", body);\n\n        // if textline enabled then covert to a String which must be used for textline\n        if (producer.getConfiguration().isTextline()) {\n            try {\n                body = producer.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body);\n            } catch (NoTypeConversionAvailableException e) {\n                exchange.setException(e);\n                callback.done(false);\n            }\n        }\n\n\n        // set the result on either IN or OUT on the original exchange depending on its pattern\n        if (ExchangeHelper.isOutCapable(exchange)) {\n            NettyPayloadHelper.setOut(exchange, body);\n        } else {\n            NettyPayloadHelper.setIn(exchange, body);\n        }\n\n        try {\n            // should channel be closed after complete?\n            Boolean close;\n            if (ExchangeHelper.isOutCapable(exchange)) {\n                close = exchange.getOut().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);\n            } else {\n                close = exchange.getIn().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);\n            }\n\n            // should we disconnect, the header can override the configuration\n            boolean disconnect = producer.getConfiguration().isDisconnect();\n            if (close != null) {\n                disconnect = close;\n            }\n            if (disconnect) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Closing channel when complete at address: {}\", producer.getConfiguration().getAddress());\n                }\n                NettyHelper.close(ctx.getChannel());\n            }\n        } finally {\n            // signal callback\n            callback.done(false);\n        }\n    }","commit_id":"91fae1d8df18822d3b98f3d3e7311895ac508375","url":"https://github.com/apache/camel"},{"original_method":"public ClientChannelHandler(NettyProducer producer, Exchange exchange, AsyncCallback callback) {\n        this.producer = producer;\n        this.exchange = exchange;\n        this.callback = callback;\n    }","id":102048,"modified_method":"public ClientChannelHandler(NettyProducer producer) {\n        this.producer = producer;\n    }","commit_id":"91fae1d8df18822d3b98f3d3e7311895ac508375","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent exceptionEvent) throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Exception caught at Channel: \" + ctx.getChannel(), exceptionEvent.getCause());\n\n        }\n        if (exceptionHandled) {\n            // ignore subsequent exceptions being thrown\n            return;\n        }\n\n        exceptionHandled = true;\n        Throwable cause = exceptionEvent.getCause();\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Closing channel as an exception was thrown from Netty\", cause);\n        }\n        // set the cause on the exchange\n        exchange.setException(cause);\n\n        // close channel in case an exception was thrown\n        NettyHelper.close(exceptionEvent.getChannel());\n\n        // signal callback\n        callback.done(false);\n    }","id":102049,"modified_method":"@Override\n    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent exceptionEvent) throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Exception caught at Channel: \" + ctx.getChannel(), exceptionEvent.getCause());\n\n        }\n        if (exceptionHandled) {\n            // ignore subsequent exceptions being thrown\n            return;\n        }\n\n        exceptionHandled = true;\n        Throwable cause = exceptionEvent.getCause();\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Closing channel as an exception was thrown from Netty\", cause);\n        }\n\n        Exchange exchange = getExchange(ctx);\n        AsyncCallback callback = getAsyncCallback(ctx);\n\n        // the state may not be set\n        if (exchange != null && callback != null) {\n            // set the cause on the exchange\n            exchange.setException(cause);\n\n            // close channel in case an exception was thrown\n            NettyHelper.close(exceptionEvent.getChannel());\n\n            // signal callback\n            callback.done(false);\n        }\n    }","commit_id":"91fae1d8df18822d3b98f3d3e7311895ac508375","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n        LOG.trace(\"Channel closed: {}\", ctx.getChannel());\n\n        if (producer.getConfiguration().isSync() && !messageReceived && !exceptionHandled) {\n            // session was closed but no message received. This could be because the remote server had an internal error\n            // and could not return a response. We should count down to stop waiting for a response\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Channel closed but no message received from address: {}\", producer.getConfiguration().getAddress());\n            }\n            exchange.setException(new CamelExchangeException(\"No response received from remote server: \" + producer.getConfiguration().getAddress(), exchange));\n            // signal callback\n            callback.done(false);\n        }\n    }","id":102050,"modified_method":"@Override\n    public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n        LOG.trace(\"Channel closed: {}\", ctx.getChannel());\n\n        Exchange exchange = getExchange(ctx);\n        AsyncCallback callback = getAsyncCallback(ctx);\n\n        // remove state\n        producer.removeState(ctx.getChannel());\n\n        if (producer.getConfiguration().isSync() && !messageReceived && !exceptionHandled) {\n            // session was closed but no message received. This could be because the remote server had an internal error\n            // and could not return a response. We should count down to stop waiting for a response\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Channel closed but no message received from address: {}\", producer.getConfiguration().getAddress());\n            }\n            exchange.setException(new CamelExchangeException(\"No response received from remote server: \" + producer.getConfiguration().getAddress(), exchange));\n            // signal callback\n            callback.done(false);\n        }\n    }","commit_id":"91fae1d8df18822d3b98f3d3e7311895ac508375","url":"https://github.com/apache/camel"},{"original_method":"public ClientPipelineFactory(NettyProducer producer, Exchange exchange, AsyncCallback callback) {\n        this.producer = producer;\n        this.exchange = exchange;\n        this.callback = callback;\n    }","id":102051,"modified_method":"public ClientPipelineFactory(NettyProducer producer) {\n        this.producer = producer;\n    }","commit_id":"91fae1d8df18822d3b98f3d3e7311895ac508375","url":"https://github.com/apache/camel"},{"original_method":"public ChannelPipeline getPipeline() throws Exception {\n        // create a new pipeline\n        ChannelPipeline channelPipeline = Channels.pipeline();\n\n        SslHandler sslHandler = configureClientSSLOnDemand();\n        if (sslHandler != null) {\n            LOG.debug(\"Client SSL handler configured and added to the ChannelPipeline\");\n            channelPipeline.addLast(\"ssl\", sslHandler);\n        }\n\n        List<ChannelUpstreamHandler> decoders = producer.getConfiguration().getDecoders();\n        for (int x = 0; x < decoders.size(); x++) {\n            channelPipeline.addLast(\"decoder-\" + x, decoders.get(x));\n        }\n\n        List<ChannelDownstreamHandler> encoders = producer.getConfiguration().getEncoders();\n        for (int x = 0; x < encoders.size(); x++) {\n            channelPipeline.addLast(\"encoder-\" + x, encoders.get(x));\n        }\n\n        // our handler must be added last\n        channelPipeline.addLast(\"handler\", new ClientChannelHandler(producer, exchange, callback));\n\n        return channelPipeline;\n    }","id":102052,"modified_method":"public ChannelPipeline getPipeline() throws Exception {\n        // create a new pipeline\n        ChannelPipeline channelPipeline = Channels.pipeline();\n\n        SslHandler sslHandler = configureClientSSLOnDemand();\n        if (sslHandler != null) {\n            LOG.debug(\"Client SSL handler configured and added to the ChannelPipeline\");\n            channelPipeline.addLast(\"ssl\", sslHandler);\n        }\n\n        List<ChannelUpstreamHandler> decoders = producer.getConfiguration().getDecoders();\n        for (int x = 0; x < decoders.size(); x++) {\n            channelPipeline.addLast(\"decoder-\" + x, decoders.get(x));\n        }\n\n        List<ChannelDownstreamHandler> encoders = producer.getConfiguration().getEncoders();\n        for (int x = 0; x < encoders.size(); x++) {\n            channelPipeline.addLast(\"encoder-\" + x, encoders.get(x));\n        }\n\n        // our handler must be added last\n        channelPipeline.addLast(\"handler\", new ClientChannelHandler(producer));\n\n        return channelPipeline;\n    }","commit_id":"91fae1d8df18822d3b98f3d3e7311895ac508375","url":"https://github.com/apache/camel"},{"original_method":"public DefaultClientPipelineFactory(NettyProducer producer, Exchange exchange, AsyncCallback callback) {\n        super(producer, exchange, callback);\n    }","id":102053,"modified_method":"public DefaultClientPipelineFactory(NettyProducer producer) {\n        super(producer);\n    }","commit_id":"91fae1d8df18822d3b98f3d3e7311895ac508375","url":"https://github.com/apache/camel"},{"original_method":"public ChannelPipeline getPipeline() throws Exception {\n            invoked = true;\n            \n            ChannelPipeline channelPipeline = Channels.pipeline();\n\n            channelPipeline.addLast(\"decoder-DELIM\", new DelimiterBasedFrameDecoder(maxLineSize, true, Delimiters.lineDelimiter()));\n            channelPipeline.addLast(\"decoder-SD\", new StringDecoder(CharsetUtil.UTF_8));\n            channelPipeline.addLast(\"encoder-SD\", new StringEncoder(CharsetUtil.UTF_8));            \n            channelPipeline.addLast(\"handler\", new ClientChannelHandler(producer, exchange, callback));\n\n            return channelPipeline;\n\n        }","id":102054,"modified_method":"public ChannelPipeline getPipeline() throws Exception {\n            invoked = true;\n            \n            ChannelPipeline channelPipeline = Channels.pipeline();\n\n            channelPipeline.addLast(\"decoder-DELIM\", new DelimiterBasedFrameDecoder(maxLineSize, true, Delimiters.lineDelimiter()));\n            channelPipeline.addLast(\"decoder-SD\", new StringDecoder(CharsetUtil.UTF_8));\n            channelPipeline.addLast(\"encoder-SD\", new StringEncoder(CharsetUtil.UTF_8));            \n            channelPipeline.addLast(\"handler\", new ClientChannelHandler(producer));\n\n            return channelPipeline;\n        }","commit_id":"91fae1d8df18822d3b98f3d3e7311895ac508375","url":"https://github.com/apache/camel"},{"original_method":"public ChannelPipeline getPipeline() throws Exception {\n            invoked = true;\n            \n            ChannelPipeline channelPipeline = Channels.pipeline();\n\n            channelPipeline.addLast(\"decoder-DELIM\", new DelimiterBasedFrameDecoder(maxLineSize, true, Delimiters.lineDelimiter()));\n            channelPipeline.addLast(\"decoder-SD\", new StringDecoder(CharsetUtil.UTF_8));\n            channelPipeline.addLast(\"encoder-SD\", new StringEncoder(CharsetUtil.UTF_8));            \n            channelPipeline.addLast(\"handler\", new ClientChannelHandler(producer, exchange, callback));\n\n            return channelPipeline;\n        }","id":102055,"modified_method":"public ChannelPipeline getPipeline() throws Exception {\n            invoked = true;\n            \n            ChannelPipeline channelPipeline = Channels.pipeline();\n\n            channelPipeline.addLast(\"decoder-DELIM\", new DelimiterBasedFrameDecoder(maxLineSize, true, Delimiters.lineDelimiter()));\n            channelPipeline.addLast(\"decoder-SD\", new StringDecoder(CharsetUtil.UTF_8));\n            channelPipeline.addLast(\"encoder-SD\", new StringEncoder(CharsetUtil.UTF_8));            \n            channelPipeline.addLast(\"handler\", new ClientChannelHandler(producer));\n\n            return channelPipeline;\n        }","commit_id":"91fae1d8df18822d3b98f3d3e7311895ac508375","url":"https://github.com/apache/camel"},{"original_method":"private void openAndCloseConnection() throws Exception {\n        ChannelFuture future = openConnection(new DefaultExchange(context), new AsyncCallback() {\n            public void done(boolean doneSync) {\n                // noop\n            }\n        });\n        Channel channel = openChannel(future);\n        NettyHelper.close(channel);\n    }","id":102056,"modified_method":"private void openAndCloseConnection() throws Exception {\n        ChannelFuture future = openConnection();\n        Channel channel = openChannel(future);\n        NettyHelper.close(channel);\n        ALL_CHANNELS.remove(channel);\n    }","commit_id":"91fae1d8df18822d3b98f3d3e7311895ac508375","url":"https://github.com/apache/camel"},{"original_method":"public boolean process(final Exchange exchange, final AsyncCallback callback) {\n        if (!isRunAllowed()) {\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException());\n            }\n            callback.done(true);\n            return true;\n        }\n\n        Object body = NettyPayloadHelper.getIn(getEndpoint(), exchange);\n        if (body == null) {\n            noReplyLogger.log(\"No payload to send for exchange: \" + exchange);\n            callback.done(true);\n            return true;\n        }\n\n        // if textline enabled then covert to a String which must be used for textline\n        if (getConfiguration().isTextline()) {\n            try {\n                body = NettyHelper.getTextlineBody(body, exchange, getConfiguration().getDelimiter(), getConfiguration().isAutoAppendDelimiter());\n            } catch (NoTypeConversionAvailableException e) {\n                exchange.setException(e);\n                callback.done(true);\n                return true;\n            }\n        }\n\n        // set the exchange encoding property\n        if (getConfiguration().getCharsetName() != null) {\n            exchange.setProperty(Exchange.CHARSET_NAME, IOHelper.normalizeCharset(getConfiguration().getCharsetName()));\n        }\n\n        ChannelFuture channelFuture;\n        final Channel channel;\n        try {\n            channelFuture = openConnection(exchange, callback);\n            channel = openChannel(channelFuture);\n        } catch (Exception e) {\n            exchange.setException(e);\n            callback.done(true);\n            return true;\n        }\n\n        // log what we are writing\n        LOG.debug(\"Writing body: {}\", body);\n        // write the body asynchronously\n        ChannelFuture future = channel.write(body);\n\n        // add listener which handles the operation\n        future.addListener(new ChannelFutureListener() {\n            public void operationComplete(ChannelFuture channelFuture) throws Exception {\n                LOG.debug(\"Operation complete {}\", channelFuture);\n                if (!channelFuture.isSuccess()) {\n                    // no success the set the caused exception and signal callback and break\n                    exchange.setException(channelFuture.getCause());\n                    callback.done(false);\n                    return;\n                }\n\n                // if we do not expect any reply then signal callback to continue routing\n                if (!configuration.isSync()) {\n                    try {\n                        // should channel be closed after complete?\n                        Boolean close;\n                        if (ExchangeHelper.isOutCapable(exchange)) {\n                            close = exchange.getOut().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);\n                        } else {\n                            close = exchange.getIn().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);\n                        }\n\n                        // should we disconnect, the header can override the configuration\n                        boolean disconnect = getConfiguration().isDisconnect();\n                        if (close != null) {\n                            disconnect = close;\n                        }\n                        if (disconnect) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Closing channel when complete at address: {}\", getEndpoint().getConfiguration().getAddress());\n                            }\n                            NettyHelper.close(channel);\n                        }\n                    } finally {\n                        // signal callback to continue routing\n                        callback.done(false);\n                    }\n                }\n            }\n        });\n\n        // continue routing asynchronously\n        return false;\n    }","id":102057,"modified_method":"public boolean process(final Exchange exchange, final AsyncCallback callback) {\n        if (!isRunAllowed()) {\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException());\n            }\n            callback.done(true);\n            return true;\n        }\n\n        Object body = NettyPayloadHelper.getIn(getEndpoint(), exchange);\n        if (body == null) {\n            noReplyLogger.log(\"No payload to send for exchange: \" + exchange);\n            callback.done(true);\n            return true;\n        }\n\n        // if textline enabled then covert to a String which must be used for textline\n        if (getConfiguration().isTextline()) {\n            try {\n                body = NettyHelper.getTextlineBody(body, exchange, getConfiguration().getDelimiter(), getConfiguration().isAutoAppendDelimiter());\n            } catch (NoTypeConversionAvailableException e) {\n                exchange.setException(e);\n                callback.done(true);\n                return true;\n            }\n        }\n\n        // set the exchange encoding property\n        if (getConfiguration().getCharsetName() != null) {\n            exchange.setProperty(Exchange.CHARSET_NAME, IOHelper.normalizeCharset(getConfiguration().getCharsetName()));\n        }\n\n        try {\n            // allow to reuse channel, on this producer, to avoid creating a new connection\n            // for each message being sent\n            if (channelFuture == null || channel == null || !channel.isOpen()) {\n                channelFuture = openConnection();\n                channel = openChannel(channelFuture);\n            }\n            // setup state now we have the channel we can do this because\n            // this producer is not thread safe, but pooled using ServicePoolAware\n            state.set(channel, new NettyCamelState(callback, exchange));\n        } catch (Exception e) {\n            exchange.setException(e);\n            callback.done(true);\n            return true;\n        }\n\n        // log what we are writing\n        LOG.debug(\"Writing body: {}\", body);\n        // write the body asynchronously\n        ChannelFuture future = channel.write(body);\n\n        // add listener which handles the operation\n        future.addListener(new ChannelFutureListener() {\n            public void operationComplete(ChannelFuture channelFuture) throws Exception {\n                LOG.debug(\"Operation complete {}\", channelFuture);\n                if (!channelFuture.isSuccess()) {\n                    // no success the set the caused exception and signal callback and break\n                    exchange.setException(channelFuture.getCause());\n                    callback.done(false);\n                    return;\n                }\n\n                // if we do not expect any reply then signal callback to continue routing\n                if (!configuration.isSync()) {\n                    try {\n                        // should channel be closed after complete?\n                        Boolean close;\n                        if (ExchangeHelper.isOutCapable(exchange)) {\n                            close = exchange.getOut().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);\n                        } else {\n                            close = exchange.getIn().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);\n                        }\n\n                        // should we disconnect, the header can override the configuration\n                        boolean disconnect = getConfiguration().isDisconnect();\n                        if (close != null) {\n                            disconnect = close;\n                        }\n                        if (disconnect) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Closing channel when complete at address: {}\", getEndpoint().getConfiguration().getAddress());\n                            }\n                            NettyHelper.close(channel);\n                        }\n                    } finally {\n                        // signal callback to continue routing\n                        callback.done(false);\n                    }\n                }\n            }\n        });\n\n        // continue routing asynchronously\n        return false;\n    }","commit_id":"91fae1d8df18822d3b98f3d3e7311895ac508375","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Exception caught at Channel: \" + ctx.channel(), cause);\n        }\n\n        if (exceptionHandled) {\n            // ignore subsequent exceptions being thrown\n            return;\n        }\n\n        exceptionHandled = true;\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Closing channel as an exception was thrown from Netty\", cause);\n        }\n\n        Exchange exchange = getExchange(ctx);\n        AsyncCallback callback = getAsyncCallback(ctx);\n\n        // the state may not be set\n        if (exchange != null && callback != null) {\n            // set the cause on the exchange\n            exchange.setException(cause);\n\n            // close channel in case an exception was thrown\n            NettyHelper.close(ctx.channel());\n\n            // signal callback\n            callback.done(false);\n        }\n    }","id":102058,"modified_method":"@Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Exception caught at Channel: \" + ctx.channel(), cause);\n        }\n\n        if (exceptionHandled) {\n            // ignore subsequent exceptions being thrown\n            return;\n        }\n\n        exceptionHandled = true;\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Closing channel as an exception was thrown from Netty\", cause);\n        }\n\n        Exchange exchange = getExchange(ctx);\n        AsyncCallback callback = getAsyncCallback(ctx);\n\n        // the state may not be set\n        if (exchange != null && callback != null) {\n            Throwable initialCause = exchange.getException();\n            if (initialCause != null && initialCause.getCause() == null) {\n                initialCause.initCause(cause);\n            } else {\n                // set the cause on the exchange\n                exchange.setException(cause);\n            }\n\n            // close channel in case an exception was thrown\n            NettyHelper.close(ctx.channel());\n\n            // signal callback\n            callback.done(false);\n        }\n    }","commit_id":"6473653e65dc73a0bf88804211689898cc2614e2","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent exceptionEvent) throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Exception caught at Channel: \" + ctx.getChannel(), exceptionEvent.getCause());\n        }\n         \n        if (exceptionHandled) {\n            // ignore subsequent exceptions being thrown\n            return;\n        }\n\n        exceptionHandled = true;\n        Throwable cause = exceptionEvent.getCause();\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Closing channel as an exception was thrown from Netty\", cause);\n        }\n\n        Exchange exchange = getExchange(ctx);\n        AsyncCallback callback = getAsyncCallback(ctx);\n\n        // the state may not be set\n        if (exchange != null && callback != null) {\n            // set the cause on the exchange\n            exchange.setException(cause);\n\n            // close channel in case an exception was thrown\n            NettyHelper.close(exceptionEvent.getChannel());\n\n            // signal callback\n            callback.done(false);\n        }\n    }","id":102059,"modified_method":"@Override\n    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent exceptionEvent) throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Exception caught at Channel: \" + ctx.getChannel(), exceptionEvent.getCause());\n        }\n         \n        if (exceptionHandled) {\n            // ignore subsequent exceptions being thrown\n            return;\n        }\n\n        exceptionHandled = true;\n        Throwable cause = exceptionEvent.getCause();\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Closing channel as an exception was thrown from Netty\", cause);\n        }\n\n        Exchange exchange = getExchange(ctx);\n        AsyncCallback callback = getAsyncCallback(ctx);\n\n        // the state may not be set\n        if (exchange != null && callback != null) {\n            Throwable initialCause = exchange.getException();\n            if (initialCause != null && initialCause.getCause() == null) {\n                initialCause.initCause(cause);\n            } else {\n                // set the cause on the exchange\n                exchange.setException(cause);\n            }\n\n            // close channel in case an exception was thrown\n            NettyHelper.close(exceptionEvent.getChannel());\n\n            // signal callback\n            callback.done(false);\n        }\n    }","commit_id":"10f3ff6616599fa849a95cd75bc6d9b7dd331153","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testValueMissingLin() throws Exception {\n\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", \n                jsonBuilder().startObject().startObject(\"type1\").startObject(\"properties\")\n                    .startObject(\"test\").field(\"type\", \"string\").endObject()\n                    .startObject(\"num1\").field(\"type\", \"date\").endObject()\n                    .startObject(\"num2\").field(\"type\", \"double\").endObject()\n                    .endObject().endObject().endObject()));\n        ensureYellow();\n        client().index(\n                indexRequest(\"test\")\n                        .type(\"type1\")\n                        .id(\"1\")\n                        .source(jsonBuilder().startObject().field(\"test\", \"value\").field(\"num1\", \"2013-05-27\").field(\"num2\", \"1.0\")\n                                .endObject())).actionGet();\n        client().index(\n                indexRequest(\"test\").type(\"type1\").id(\"2\")\n                        .source(jsonBuilder().startObject().field(\"test\", \"value\").field(\"num2\", \"1.0\").endObject())).actionGet();\n        client().index(\n                indexRequest(\"test\")\n                        .type(\"type1\")\n                        .id(\"3\")\n                        .source(jsonBuilder().startObject().field(\"test\", \"value\").field(\"num1\", \"2013-05-30\").field(\"num2\", \"1.0\")\n                                .endObject())).actionGet();\n        client().index(\n                indexRequest(\"test\").type(\"type1\").id(\"4\")\n                        .source(jsonBuilder().startObject().field(\"test\", \"value\").field(\"num1\", \"2013-05-30\").endObject())).actionGet();\n\n        refresh();\n\n        ActionFuture<SearchResponse> response = client().search(\n                searchRequest().searchType(SearchType.QUERY_THEN_FETCH).source(\n                        searchSource().explain(false).query(\n                                functionScoreQuery(termQuery(\"test\", \"value\"))\n                                        .add(new MatchAllFilterBuilder(), linearDecayFunction(\"num1\", \"2013-05-28\", \"+3d\"))\n                                        .add(new MatchAllFilterBuilder(), linearDecayFunction(\"num2\", \"0.0\", \"1\")).scoreMode(\"multiply\"))));\n\n        SearchResponse sr = response.actionGet();\n        ElasticsearchAssertions.assertNoFailures(sr);\n        SearchHits sh = sr.getHits();\n        assertThat(sh.hits().length, equalTo(4));\n        double[] scores = new double[4];\n        for (int i = 0; i < sh.hits().length; i++) {\n            scores[Integer.parseInt(sh.getAt(i).getId()) - 1] = sh.getAt(i).getScore();\n        }\n        assertThat(scores[0], lessThan(scores[1]));\n        assertThat(scores[2], lessThan(scores[3]));\n\n    }","id":102060,"modified_method":"@Test\n    public void testValueMissingLin() throws Exception {\n\n        assertAcked(prepareCreate(\"test\").addMapping(\"type1\", \n                jsonBuilder().startObject().startObject(\"type1\").startObject(\"properties\")\n                    .startObject(\"test\").field(\"type\", \"string\").endObject()\n                    .startObject(\"num1\").field(\"type\", \"date\").endObject()\n                    .startObject(\"num2\").field(\"type\", \"double\").endObject()\n                    .endObject().endObject().endObject()));\n        ensureYellow();\n        client().index(\n                indexRequest(\"test\")\n                        .type(\"type1\")\n                        .id(\"1\")\n                        .source(jsonBuilder().startObject().field(\"test\", \"value\").field(\"num1\", \"2013-05-27\").field(\"num2\", \"1.0\")\n                                .endObject())).actionGet();\n        client().index(\n                indexRequest(\"test\").type(\"type1\").id(\"2\")\n                        .source(jsonBuilder().startObject().field(\"test\", \"value\").field(\"num2\", \"1.0\").endObject())).actionGet();\n        client().index(\n                indexRequest(\"test\")\n                        .type(\"type1\")\n                        .id(\"3\")\n                        .source(jsonBuilder().startObject().field(\"test\", \"value\").field(\"num1\", \"2013-05-30\").field(\"num2\", \"1.0\")\n                                .endObject())).actionGet();\n        client().index(\n                indexRequest(\"test\").type(\"type1\").id(\"4\")\n                        .source(jsonBuilder().startObject().field(\"test\", \"value\").field(\"num1\", \"2013-05-30\").endObject())).actionGet();\n\n        refresh();\n\n        ActionFuture<SearchResponse> response = client().search(\n                searchRequest().searchType(SearchType.QUERY_THEN_FETCH).source(\n                        searchSource().explain(false).query(\n                                functionScoreQuery(termQuery(\"test\", \"value\"))\n                                        .add(linearDecayFunction(\"num1\", \"2013-05-28\", \"+3d\"))\n                                        .add(linearDecayFunction(\"num2\", \"0.0\", \"1\")).scoreMode(\"multiply\"))));\n\n        SearchResponse sr = response.actionGet();\n        ElasticsearchAssertions.assertNoFailures(sr);\n        SearchHits sh = sr.getHits();\n        assertThat(sh.hits().length, equalTo(4));\n        double[] scores = new double[4];\n        for (int i = 0; i < sh.hits().length; i++) {\n            scores[Integer.parseInt(sh.getAt(i).getId()) - 1] = sh.getAt(i).getScore();\n        }\n        assertThat(scores[0], lessThan(scores[1]));\n        assertThat(scores[2], lessThan(scores[3]));\n\n    }","commit_id":"3162eb4dcf2cb612db7d87cc83db8f33651570df","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(FunctionScoreQueryParser.NAME);\n        if (queryBuilder != null) {\n            builder.field(\"query\");\n            queryBuilder.toXContent(builder, params);\n        } else if (filterBuilder != null) {\n            builder.field(\"filter\");\n            filterBuilder.toXContent(builder, params);\n        } else {\n            throw new ElasticSearchException(FunctionScoreQueryParser.NAME\n                    + \" builder requires that either a filter or a query is defined!\");\n        }\n        // If there is only one function without a filter, we later want to\n        // create a FunctionScoreQuery.\n        // For this, we only build the scoreFunction.Tthis will be translated to\n        // FunctionScoreQuery in the parser.\n        if (filters.size() == 1 && filters.get(0) == null) {\n            scoreFunctions.get(0).toXContent(builder, params);\n        } else { // in all other cases we build the format needed for a\n                 // FiltersFunctionScoreQuery\n            builder.startArray(\"functions\");\n            for (int i = 0; i < filters.size(); i++) {\n                builder.startObject();\n                builder.field(\"filter\");\n                filters.get(i).toXContent(builder, params);\n                scoreFunctions.get(i).toXContent(builder, params);\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        if (scoreMode != null) {\n            builder.field(\"score_mode\", scoreMode);\n        }\n        if (boostMode != null) {\n            builder.field(\"boost_mode\", boostMode);\n        }\n        if (maxBoost != null) {\n            builder.field(\"max_boost\", maxBoost);\n        }\n        if (boost != null) {\n            builder.field(\"boost\", boost);\n        }\n\n        builder.endObject();\n    }","id":102061,"modified_method":"@Override\n    protected void doXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(FunctionScoreQueryParser.NAME);\n        if (queryBuilder != null) {\n            builder.field(\"query\");\n            queryBuilder.toXContent(builder, params);\n        } else if (filterBuilder != null) {\n            builder.field(\"filter\");\n            filterBuilder.toXContent(builder, params);\n        } else {\n            throw new ElasticSearchException(FunctionScoreQueryParser.NAME\n                    + \" builder requires that either a filter or a query is defined!\");\n        }\n        // If there is only one function without a filter, we later want to\n        // create a FunctionScoreQuery.\n        // For this, we only build the scoreFunction.Tthis will be translated to\n        // FunctionScoreQuery in the parser.\n        if (filters.size() == 1 && filters.get(0) == null) {\n            scoreFunctions.get(0).toXContent(builder, params);\n        } else { // in all other cases we build the format needed for a\n                 // FiltersFunctionScoreQuery\n            builder.startArray(\"functions\");\n            for (int i = 0; i < filters.size(); i++) {\n                builder.startObject();\n                builder.field(\"filter\");\n                if (filters.get(i) == null) {\n                    FilterBuilders.matchAllFilter().toXContent(builder, params);\n                } else {\n                    filters.get(i).toXContent(builder, params);\n                }\n                scoreFunctions.get(i).toXContent(builder, params);\n                builder.endObject();\n            }\n            builder.endArray();\n        }\n        if (scoreMode != null) {\n            builder.field(\"score_mode\", scoreMode);\n        }\n        if (boostMode != null) {\n            builder.field(\"boost_mode\", boostMode);\n        }\n        if (maxBoost != null) {\n            builder.field(\"max_boost\", maxBoost);\n        }\n        if (boost != null) {\n            builder.field(\"boost\", boost);\n        }\n\n        builder.endObject();\n    }","commit_id":"3162eb4dcf2cb612db7d87cc83db8f33651570df","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static String readTokenOrQuotedString(StringReader input)\n            throws IOException {\n        int c = input.read();\n        input.skip(-1);\n\n        if (c == '\"') {\n            return readQuotedString(input);\n        } else {\n            return readToken(input);\n        }\n    }","id":102062,"modified_method":"private static String readTokenOrQuotedString(StringReader input,\n            boolean returnQuoted) throws IOException {\n        int c = input.read();\n        input.skip(-1);\n\n        if (c == '\"') {\n            return readQuotedString(input, returnQuoted);\n        } else {\n            return readToken(input);\n        }\n    }","commit_id":"a5c134bbfe2e7d480082d9bd70069d39cc74fce2","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @return the quoted string if one was found, null if data other than a\n     *         quoted string was found or null if the end of data was reached\n     *         before the quoted string was terminated\n     */\n    private static String readQuotedString(StringReader input)\n            throws IOException {\n\n        int c = input.read();\n        if (c != '\"') {\n            return null;\n        }\n\n        StringBuilder result = new StringBuilder();\n\n        c = input.read();\n        while (c != '\"') {\n            if (c == -1) {\n                return null;\n            } else if (c == '\\\\') {\n                c = input.read();\n                result.append(c);\n            } else {\n                result.append((char) c);\n            }\n            c = input.read();\n        }\n\n        return result.toString();\n    }","id":102063,"modified_method":"/**\n     * @return the quoted string if one was found, null if data other than a\n     *         quoted string was found or null if the end of data was reached\n     *         before the quoted string was terminated\n     */\n    private static String readQuotedString(StringReader input,\n            boolean returnQuoted) throws IOException {\n\n        int c = input.read();\n        if (c != '\"') {\n            return null;\n        }\n\n        StringBuilder result = new StringBuilder();\n        if (returnQuoted) {\n            result.append('\\\"');\n        }\n        c = input.read();\n        while (c != '\"') {\n            if (c == -1) {\n                return null;\n            } else if (c == '\\\\') {\n                c = input.read();\n                if (returnQuoted) {\n                    result.append('\\\\');\n                }\n                result.append(c);\n            } else {\n                result.append((char) c);\n            }\n            c = input.read();\n        }\n        if (returnQuoted) {\n            result.append('\\\"');\n        }\n\n        return result.toString();\n    }","commit_id":"a5c134bbfe2e7d480082d9bd70069d39cc74fce2","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Parses an HTTP Authorization header for DIGEST authentication as per RFC\n     * 2617 section 3.2.2.\n     *\n     * @param input The header value to parse\n     *\n     * @return  A map of directives and values as {@link String}s or\n     *          <code>null<\/code> if a parsing error occurs. Although the\n     *          values returned are {@link String}s they will have been\n     *          validated to ensure that they conform to RFC 2617.\n     *\n     * @throws IllegalArgumentException If the header does not conform to RFC\n     *                                  2617\n     * @throws IOException If an error occurs while reading the input\n     */\n    public static Map<String,String> parseAuthorizationDigest (\n            StringReader input) throws IllegalArgumentException, IOException {\n\n        Map<String,String> result = new HashMap<>();\n\n        if (!skipConstant(input, \"Digest\", false)) {\n            return null;\n        }\n        skipLws(input);\n        // All field names are valid tokens\n        String field = readToken(input);\n        if (field == null) {\n            return null;\n        }\n        while (!field.equals(\"\")) {\n            skipLws(input);\n            if (!skipConstant(input, \"=\", false)) {\n                return null;\n            }\n            skipLws(input);\n            String value = null;\n            Integer type = fieldTypes.get(field.toLowerCase(Locale.US));\n            if (type == null) {\n                // auth-param = token \"=\" ( token | quoted-string )\n                type = FIELD_TYPE_TOKEN_OR_QUOTED_STRING;\n            }\n            switch (type.intValue()) {\n                case 0:\n                    // FIELD_TYPE_TOKEN\n                    value = readToken(input);\n                    break;\n                case 1:\n                    // FIELD_TYPE_QUOTED_STRING\n                    value = readQuotedString(input);\n                    break;\n                case 2:\n                    // FIELD_TYPE_TOKEN_OR_QUOTED_STRING\n                    value = readTokenOrQuotedString(input);\n                    break;\n                case 3:\n                    // FIELD_TYPE_LHEX\n                    value = readLhex(input);\n                    break;\n                case 4:\n                    // FIELD_TYPE_QUOTED_LHEX\n                    value = readQuotedLhex(input);\n                    break;\n                default:\n                    // Error\n                    throw new IllegalArgumentException(\n                            \"TODO i18n: Unsupported type\");\n            }\n\n            if (value == null) {\n                return null;\n            }\n            result.put(field, value);\n\n            skipLws(input);\n            if (!skipConstant(input, \",\", true)) {\n                return null;\n            }\n            skipLws(input);\n            field = readToken(input);\n            if (field == null) {\n                return null;\n            }\n        }\n\n        return result;\n    }","id":102064,"modified_method":"/**\n     * Parses an HTTP Authorization header for DIGEST authentication as per RFC\n     * 2617 section 3.2.2.\n     *\n     * @param input The header value to parse\n     *\n     * @return  A map of directives and values as {@link String}s or\n     *          <code>null<\/code> if a parsing error occurs. Although the\n     *          values returned are {@link String}s they will have been\n     *          validated to ensure that they conform to RFC 2617.\n     *\n     * @throws IllegalArgumentException If the header does not conform to RFC\n     *                                  2617\n     * @throws IOException If an error occurs while reading the input\n     */\n    public static Map<String,String> parseAuthorizationDigest (\n            StringReader input) throws IllegalArgumentException, IOException {\n\n        Map<String,String> result = new HashMap<>();\n\n        if (skipConstant(input, \"Digest\") != SkipConstantResult.FOUND) {\n            return null;\n        }\n        skipLws(input);\n        // All field names are valid tokens\n        String field = readToken(input);\n        if (field == null) {\n            return null;\n        }\n        while (!field.equals(\"\")) {\n            skipLws(input);\n            if (skipConstant(input, \"=\") != SkipConstantResult.FOUND) {\n                return null;\n            }\n            skipLws(input);\n            String value = null;\n            Integer type = fieldTypes.get(field.toLowerCase(Locale.US));\n            if (type == null) {\n                // auth-param = token \"=\" ( token | quoted-string )\n                type = FIELD_TYPE_TOKEN_OR_QUOTED_STRING;\n            }\n            switch (type.intValue()) {\n                case 0:\n                    // FIELD_TYPE_TOKEN\n                    value = readToken(input);\n                    break;\n                case 1:\n                    // FIELD_TYPE_QUOTED_STRING\n                    value = readQuotedString(input, false);\n                    break;\n                case 2:\n                    // FIELD_TYPE_TOKEN_OR_QUOTED_STRING\n                    value = readTokenOrQuotedString(input, false);\n                    break;\n                case 3:\n                    // FIELD_TYPE_LHEX\n                    value = readLhex(input);\n                    break;\n                case 4:\n                    // FIELD_TYPE_QUOTED_LHEX\n                    value = readQuotedLhex(input);\n                    break;\n                default:\n                    // Error\n                    throw new IllegalArgumentException(\n                            \"TODO i18n: Unsupported type\");\n            }\n\n            if (value == null) {\n                return null;\n            }\n            result.put(field, value);\n\n            skipLws(input);\n            if (skipConstant(input, \",\") == SkipConstantResult.NOT_FOUND) {\n                return null;\n            }\n            skipLws(input);\n            field = readToken(input);\n            if (field == null) {\n                return null;\n            }\n        }\n\n        return result;\n    }","commit_id":"a5c134bbfe2e7d480082d9bd70069d39cc74fce2","url":"https://github.com/apache/tomcat"},{"original_method":"private static String readQuotedLhex(StringReader input)\n            throws IOException {\n\n        skipConstant(input, \"\\\"\", false);\n        String result = readLhex(input);\n        skipConstant(input, \"\\\"\", false);\n\n        return result;\n    }","id":102065,"modified_method":"private static String readQuotedLhex(StringReader input)\n            throws IOException {\n\n        if (skipConstant(input, \"\\\"\") != SkipConstantResult.FOUND) {\n            return null;\n        }\n        String result = readLhex(input);\n        if (skipConstant(input, \"\\\"\") == SkipConstantResult.NOT_FOUND) {\n            return null;\n        }\n\n        return result;\n    }","commit_id":"a5c134bbfe2e7d480082d9bd70069d39cc74fce2","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @return  <code>true<\/code> if the constant is found or if no data is\n     *          present and EOF is allowed otherwise returns <code>false<\/code>\n     */\n    private static boolean skipConstant(StringReader input, String constant,\n            boolean eofOk) throws IOException {\n        int len = constant.length();\n\n        for (int i = 0; i < len; i++) {\n            int c = input.read();\n            if (i == 0 && c == -1 && eofOk) {\n                return true;\n            }\n            if (c != constant.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }","id":102066,"modified_method":"private static SkipConstantResult skipConstant(StringReader input,\n            String constant) throws IOException {\n        int len = constant.length();\n\n        for (int i = 0; i < len; i++) {\n            int c = input.read();\n            if (i == 0 && c == -1) {\n                return SkipConstantResult.EOF;\n            }\n            if (c != constant.charAt(i)) {\n                input.skip(-(i + 1));\n                return SkipConstantResult.NOT_FOUND;\n            }\n        }\n        return SkipConstantResult.FOUND;\n    }","commit_id":"a5c134bbfe2e7d480082d9bd70069d39cc74fce2","url":"https://github.com/apache/tomcat"},{"original_method":"@Override protected void finish() {\n            if (errors.length() > 0)\n                JOptionPane.showMessageDialog(Main.parent, tr(\"There were problems with the following plugins:\\n\\n {0}\",errors));\n            else\n                JOptionPane.showMessageDialog(Main.parent, trn(\"{0} Plugin successfully downloaded. Please restart JOSM.\", \"{0} Plugins successfully downloaded. Please restart JOSM.\", count, count));\n        }","id":102067,"modified_method":"@Override protected void finish() {\n            if (errors.length() > 0) {\n                OptionPaneUtil.showMessageDialog(\n                        Main.parent,\n                        tr(\"There were problems with the following plugins:\\n\\n {0}\",errors),\n                        tr(\"Error\"),\n                        JOptionPane.ERROR_MESSAGE\n                );\n            } else {\n                OptionPaneUtil.showMessageDialog(\n                        Main.parent,\n                        trn(\"{0} Plugin successfully downloaded. Please restart JOSM.\", \"{0} Plugins successfully downloaded. Please restart JOSM.\", count, count),\n                        tr(\"Information\"),\n                        JOptionPane.INFORMATION_MESSAGE\n                );\n            }\n        }","commit_id":"88b3df4cc858c13303ed8e07904b2f331f937a6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static Boolean checkException(Throwable e)\n    {\n        PluginProxy plugin = null;\n\n        // Check for an explicit problem when calling a plugin function\n        if (e instanceof PluginException)\n            plugin = ((PluginException)e).plugin;\n\n        if (plugin == null)\n        {\n            String name = null;\n            /**\n            * Analyze the stack of the argument and find a name of a plugin, if\n            * some known problem pattern has been found.\n            *\n            * Note: This heuristic is not meant as discrimination against specific\n            * plugins, but only to stop the flood of similar bug reports about plugins.\n            * Of course, plugin writers are free to install their own version of\n            * an exception handler with their email address listed to receive\n            * bug reports ;-).\n            */\n            for (StackTraceElement element : e.getStackTrace()) {\n                String c = element.getClassName();\n\n                if (c.contains(\"wmsplugin.\") || c.contains(\".WMSLayer\"))\n                    name = \"wmsplugin\";\n                if (c.contains(\"livegps.\"))\n                    name = \"livegps\";\n                if (c.startsWith(\"UtilsPlugin.\"))\n                    name = \"UtilsPlugin\";\n\n                if (c.startsWith(\"org.openstreetmap.josm.plugins.\")) {\n                    String p = c.substring(\"org.openstreetmap.josm.plugins.\".length());\n                    if (p.indexOf('.') != -1 && p.matches(\"[a-z].*\")) {\n                        name = p.substring(0,p.indexOf('.'));\n                    }\n                }\n                if(name != null)\n                  break;\n            }\n            for (PluginProxy p : pluginList)\n            {\n                if (p.info.name.equals(name))\n                {\n                    plugin = p;\n                    break;\n                }\n            }\n        }\n\n        if (plugin != null) {\n            int answer = new ExtendedDialog(Main.parent,\n                tr(\"Disable plugin\"),\n                tr(\"An unexpected exception occurred that may have come from the ''{0}'' plugin.\", plugin.info.name)\n                    + \"\\n\"\n                    + (plugin.info.author != null\n                        ? tr(\"According to the information within the plugin, the author is {0}.\", plugin.info.author)\n                        : \"\")\n                    + \"\\n\"\n                    + tr(\"Try updating to the newest version of this plugin before reporting a bug.\")\n                    + \"\\n\"\n                    + tr(\"Should the plugin be disabled?\"),\n                new String[] {tr(\"Disable plugin\"), tr(\"Cancel\")},\n                new String[] {\"dialogs/delete.png\", \"cancel.png\"}).getValue();\n            if (answer == 1) {\n                List<String> plugins = new ArrayList<String>(Main.pref.getCollection(\"plugins\", Collections.<String>emptyList()));\n                if (plugins.contains(plugin.info.name)) {\n                    while (plugins.remove(plugin.info.name)) {}\n                    Main.pref.putCollection(\"plugins\", plugins);\n                    JOptionPane.showMessageDialog(Main.parent,\n                    tr(\"The plugin has been removed from the configuration. Please restart JOSM to unload the plugin.\"));\n                } else {\n                    JOptionPane.showMessageDialog(Main.parent,\n                    tr(\"The plugin could not be removed. Probably it was already disabled\"));\n                }\n                return true;\n            }\n        }\n        return false;\n    }","id":102068,"modified_method":"public static Boolean checkException(Throwable e)\n    {\n        PluginProxy plugin = null;\n\n        // Check for an explicit problem when calling a plugin function\n        if (e instanceof PluginException) {\n            plugin = ((PluginException)e).plugin;\n        }\n\n        if (plugin == null)\n        {\n            String name = null;\n            /**\n             * Analyze the stack of the argument and find a name of a plugin, if\n             * some known problem pattern has been found.\n             *\n             * Note: This heuristic is not meant as discrimination against specific\n             * plugins, but only to stop the flood of similar bug reports about plugins.\n             * Of course, plugin writers are free to install their own version of\n             * an exception handler with their email address listed to receive\n             * bug reports ;-).\n             */\n            for (StackTraceElement element : e.getStackTrace()) {\n                String c = element.getClassName();\n\n                if (c.contains(\"wmsplugin.\") || c.contains(\".WMSLayer\")) {\n                    name = \"wmsplugin\";\n                }\n                if (c.contains(\"livegps.\")) {\n                    name = \"livegps\";\n                }\n                if (c.startsWith(\"UtilsPlugin.\")) {\n                    name = \"UtilsPlugin\";\n                }\n\n                if (c.startsWith(\"org.openstreetmap.josm.plugins.\")) {\n                    String p = c.substring(\"org.openstreetmap.josm.plugins.\".length());\n                    if (p.indexOf('.') != -1 && p.matches(\"[a-z].*\")) {\n                        name = p.substring(0,p.indexOf('.'));\n                    }\n                }\n                if(name != null) {\n                    break;\n                }\n            }\n            for (PluginProxy p : pluginList)\n            {\n                if (p.info.name.equals(name))\n                {\n                    plugin = p;\n                    break;\n                }\n            }\n        }\n\n        if (plugin != null) {\n            int answer = new ExtendedDialog(Main.parent,\n                    tr(\"Disable plugin\"),\n                    tr(\"An unexpected exception occurred that may have come from the ''{0}'' plugin.\", plugin.info.name)\n                    + \"\\n\"\n                    + (plugin.info.author != null\n                            ? tr(\"According to the information within the plugin, the author is {0}.\", plugin.info.author)\n                                    : \"\")\n                                    + \"\\n\"\n                                    + tr(\"Try updating to the newest version of this plugin before reporting a bug.\")\n                                    + \"\\n\"\n                                    + tr(\"Should the plugin be disabled?\"),\n                                    new String[] {tr(\"Disable plugin\"), tr(\"Cancel\")},\n                                    new String[] {\"dialogs/delete.png\", \"cancel.png\"}).getValue();\n            if (answer == 1) {\n                List<String> plugins = new ArrayList<String>(Main.pref.getCollection(\"plugins\", Collections.<String>emptyList()));\n                if (plugins.contains(plugin.info.name)) {\n                    while (plugins.remove(plugin.info.name)) {}\n                    Main.pref.putCollection(\"plugins\", plugins);\n                    OptionPaneUtil.showMessageDialog(Main.parent,\n                            tr(\"The plugin has been removed from the configuration. Please restart JOSM to unload the plugin.\"),\n                            tr(\"Information\"),\n                            JOptionPane.INFORMATION_MESSAGE);\n                } else {\n                    OptionPaneUtil.showMessageDialog(\n                            Main.parent,\n                            tr(\"The plugin could not be removed. Probably it was already disabled\"),\n                            tr(\"Error\"),\n                            JOptionPane.ERROR_MESSAGE\n                    );\n                }\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"88b3df4cc858c13303ed8e07904b2f331f937a6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Load all plugins specified in preferences. If the parameter is\n     * <code>true<\/code>, all early plugins are loaded (before constructor).\n     */\n    public static void loadPlugins(boolean early) {\n        List<String> plugins = new LinkedList<String>();\n        Collection<String> cp = Main.pref.getCollection(\"plugins\", null);\n        if (cp != null)\n            plugins.addAll(cp);\n        if (System.getProperty(\"josm.plugins\") != null)\n            plugins.addAll(Arrays.asList(System.getProperty(\"josm.plugins\").split(\",\")));\n\n        String [] oldplugins = new String[] {\"mappaint\", \"unglueplugin\",\n        \"lang-de\", \"lang-en_GB\", \"lang-fr\", \"lang-it\", \"lang-pl\", \"lang-ro\",\n        \"lang-ru\", \"ewmsplugin\", \"ywms\", \"tways-0.2\", \"geotagged\", \"landsat\",\n        \"namefinder\", \"waypoints\", \"slippy_map_chooser\", \"tcx-support\"};\n        for (String p : oldplugins) {\n            if (plugins.contains(p)) {\n                plugins.remove(p);\n                Main.pref.removeFromCollection(\"plugins\", p);\n                JOptionPane.showMessageDialog(Main.parent, tr(\"Warning - loading of {0} plugin was requested. This plugin is no longer required.\", p));\n            }\n        }\n\n        if (plugins.isEmpty())\n            return;\n\n        SortedMap<Integer, Collection<PluginInformation>> p = new TreeMap<Integer, Collection<PluginInformation>>();\n        for (String pluginName : plugins) {\n            PluginInformation info = PluginInformation.findPlugin(pluginName);\n            if (info != null) {\n                if (info.early != early)\n                    continue;\n                if (info.mainversion > AboutAction.getVersionNumber()) {\n                    JOptionPane.showMessageDialog(Main.parent, tr(\"Plugin {0} requires JOSM update to version {1}.\", pluginName,\n                    info.mainversion));\n                    continue;\n                }\n                if(info.requires != null)\n                {\n                    String warn = null;\n                    for(String n : info.requires.split(\";\"))\n                    {\n                        if(!plugins.contains(n))\n                        { warn = n; break; }\n                    }\n                    if(warn != null)\n                    {\n                        JOptionPane.showMessageDialog(Main.parent,\n                        tr(\"Plugin {0} is required by plugin {1} but was not found.\",\n                        warn, pluginName));\n                        continue;\n                    }\n                }\n                if (!p.containsKey(info.stage))\n                    p.put(info.stage, new LinkedList<PluginInformation>());\n                p.get(info.stage).add(info);\n            } else if(early) {\n                JOptionPane.showMessageDialog(Main.parent, tr(\"Plugin not found: {0}.\", pluginName));\n            }\n        }\n\n        if (!early) {\n            long tim = System.currentTimeMillis();\n            long last = Main.pref.getLong(\"pluginmanager.lastupdate\", 0);\n            Integer maxTime = Main.pref.getInteger(\"pluginmanager.warntime\", 30);\n            long d = (tim - last)/(24*60*60*1000l);\n            if ((last <= 0) || (maxTime <= 0)) {\n                Main.pref.put(\"pluginmanager.lastupdate\",Long.toString(tim));\n            } else if (d > maxTime) {\n                JOptionPane.showMessageDialog(Main.parent,\n                   \"<html>\" +\n                   tr(\"Last plugin update more than {0} days ago.\", d) +\n                   \"<br><em>\" +\n                   tr(\"(You can change the number of days after which this warning appears<br>by setting the config option 'pluginmanager.warntime'.)\") +\n                   \"<\/html>\");\n            }\n        }\n\n        // iterate all plugins and collect all libraries of all plugins:\n        List<URL> allPluginLibraries = new ArrayList<URL>();\n        for (Collection<PluginInformation> c : p.values())\n            for (PluginInformation info : c)\n                allPluginLibraries.addAll(info.libraries);\n        // create a classloader for all plugins:\n        URL[] jarUrls = new URL[allPluginLibraries.size()];\n        jarUrls = allPluginLibraries.toArray(jarUrls);\n        URLClassLoader pluginClassLoader = new URLClassLoader(jarUrls, Main.class.getClassLoader());\n        ImageProvider.sources.add(0, pluginClassLoader);\n\n        for (Collection<PluginInformation> c : p.values()) {\n            for (PluginInformation info : c) {\n                try {\n                    Class<?> klass = info.loadClass(pluginClassLoader);\n                    if (klass != null) {\n                        System.out.println(\"loading \"+info.name);\n                        pluginList.add(info.load(klass));\n                    }\n                } catch (Throwable e) {\n                    e.printStackTrace();\n\n                    int result = new ExtendedDialog(Main.parent,\n                        tr(\"Disable plugin\"),\n                        tr(\"Could not load plugin {0}. Delete from preferences?\", info.name),\n                        new String[] {tr(\"Disable plugin\"), tr(\"Keep plugin\")},\n                        new String[] {\"dialogs/delete.png\", \"cancel.png\"}).getValue();\n\n                    if(result == 1)\n                    {\n                        plugins.remove(info.name);\n                        Main.pref.removeFromCollection(\"plugins\", info.name);\n                    }\n                }\n            }\n        }\n    }","id":102069,"modified_method":"/**\n     * Load all plugins specified in preferences. If the parameter is\n     * <code>true<\/code>, all early plugins are loaded (before constructor).\n     */\n    public static void loadPlugins(boolean early) {\n        List<String> plugins = new LinkedList<String>();\n        Collection<String> cp = Main.pref.getCollection(\"plugins\", null);\n        if (cp != null) {\n            plugins.addAll(cp);\n        }\n        if (System.getProperty(\"josm.plugins\") != null) {\n            plugins.addAll(Arrays.asList(System.getProperty(\"josm.plugins\").split(\",\")));\n        }\n\n        String [] oldplugins = new String[] {\"mappaint\", \"unglueplugin\",\n                \"lang-de\", \"lang-en_GB\", \"lang-fr\", \"lang-it\", \"lang-pl\", \"lang-ro\",\n                \"lang-ru\", \"ewmsplugin\", \"ywms\", \"tways-0.2\", \"geotagged\", \"landsat\",\n                \"namefinder\", \"waypoints\", \"slippy_map_chooser\", \"tcx-support\"};\n        for (String p : oldplugins) {\n            if (plugins.contains(p)) {\n                plugins.remove(p);\n                Main.pref.removeFromCollection(\"plugins\", p);\n                OptionPaneUtil.showMessageDialog(\n                        Main.parent,\n                        tr(\"Loading of {0} plugin was requested. This plugin is no longer required.\", p),\n                        tr(\"Warning\"),\n                        JOptionPane.WARNING_MESSAGE\n                );\n            }\n        }\n\n        if (plugins.isEmpty())\n            return;\n\n        SortedMap<Integer, Collection<PluginInformation>> p = new TreeMap<Integer, Collection<PluginInformation>>();\n        for (String pluginName : plugins) {\n            PluginInformation info = PluginInformation.findPlugin(pluginName);\n            if (info != null) {\n                if (info.early != early) {\n                    continue;\n                }\n                if (info.mainversion > AboutAction.getVersionNumber()) {\n                    OptionPaneUtil.showMessageDialog(\n                            Main.parent,\n                            tr(\"Plugin {0} requires JOSM update to version {1}.\", pluginName,\n                                    info.mainversion),\n                                    tr(\"Warning\"),\n                                    JOptionPane.WARNING_MESSAGE\n                    );\n                    continue;\n                }\n                if(info.requires != null)\n                {\n                    String warn = null;\n                    for(String n : info.requires.split(\";\"))\n                    {\n                        if(!plugins.contains(n))\n                        { warn = n; break; }\n                    }\n                    if(warn != null)\n                    {\n                        OptionPaneUtil.showMessageDialog(Main.parent,\n                                tr(\"Plugin {0} is required by plugin {1} but was not found.\",\n                                        warn, pluginName),\n                                        tr(\"Error\"),\n                                        JOptionPane.ERROR_MESSAGE\n                        );\n                        continue;\n                    }\n                }\n                if (!p.containsKey(info.stage)) {\n                    p.put(info.stage, new LinkedList<PluginInformation>());\n                }\n                p.get(info.stage).add(info);\n            } else if(early) {\n                OptionPaneUtil.showMessageDialog(\n                        Main.parent,\n                        tr(\"Plugin not found: {0}.\", pluginName),\n                        tr(\"Error\"),\n                        JOptionPane.ERROR_MESSAGE\n                );\n            }\n        }\n\n        if (!early) {\n            long tim = System.currentTimeMillis();\n            long last = Main.pref.getLong(\"pluginmanager.lastupdate\", 0);\n            Integer maxTime = Main.pref.getInteger(\"pluginmanager.warntime\", 30);\n            long d = (tim - last)/(24*60*60*1000l);\n            if ((last <= 0) || (maxTime <= 0)) {\n                Main.pref.put(\"pluginmanager.lastupdate\",Long.toString(tim));\n            } else if (d > maxTime) {\n                OptionPaneUtil.showMessageDialog(Main.parent,\n                        \"<html>\" +\n                        tr(\"Last plugin update more than {0} days ago.\", d) +\n                        \"<br><em>\" +\n                        tr(\"(You can change the number of days after which this warning appears<br>by setting the config option 'pluginmanager.warntime'.)\") +\n                        \"<\/html>\",\n                        tr(\"Warning\"),\n                        JOptionPane.WARNING_MESSAGE\n                );\n            }\n        }\n\n        // iterate all plugins and collect all libraries of all plugins:\n        List<URL> allPluginLibraries = new ArrayList<URL>();\n        for (Collection<PluginInformation> c : p.values()) {\n            for (PluginInformation info : c) {\n                allPluginLibraries.addAll(info.libraries);\n            }\n        }\n        // create a classloader for all plugins:\n        URL[] jarUrls = new URL[allPluginLibraries.size()];\n        jarUrls = allPluginLibraries.toArray(jarUrls);\n        URLClassLoader pluginClassLoader = new URLClassLoader(jarUrls, Main.class.getClassLoader());\n        ImageProvider.sources.add(0, pluginClassLoader);\n\n        for (Collection<PluginInformation> c : p.values()) {\n            for (PluginInformation info : c) {\n                try {\n                    Class<?> klass = info.loadClass(pluginClassLoader);\n                    if (klass != null) {\n                        System.out.println(\"loading \"+info.name);\n                        pluginList.add(info.load(klass));\n                    }\n                } catch (Throwable e) {\n                    e.printStackTrace();\n\n                    int result = new ExtendedDialog(Main.parent,\n                            tr(\"Disable plugin\"),\n                            tr(\"Could not load plugin {0}. Delete from preferences?\", info.name),\n                            new String[] {tr(\"Disable plugin\"), tr(\"Keep plugin\")},\n                            new String[] {\"dialogs/delete.png\", \"cancel.png\"}).getValue();\n\n                    if(result == 1)\n                    {\n                        plugins.remove(info.name);\n                        Main.pref.removeFromCollection(\"plugins\", info.name);\n                    }\n                }\n            }\n        }\n    }","commit_id":"88b3df4cc858c13303ed8e07904b2f331f937a6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static void earlyCleanup()\n    {\n        if (!PluginDownloader.moveUpdatedPlugins()) {\n            JOptionPane.showMessageDialog(null,\n                    tr(\"Activating the updated plugins failed. Check if JOSM has the permission to overwrite the existing ones.\"),\n                    tr(\"Plugins\"), JOptionPane.ERROR_MESSAGE);\n        }\n    }","id":102070,"modified_method":"public static void earlyCleanup()\n    {\n        if (!PluginDownloader.moveUpdatedPlugins()) {\n            OptionPaneUtil.showMessageDialog(\n                    Main.parent,\n                    tr(\"Activating the updated plugins failed. Check if JOSM has the permission to overwrite the existing ones.\"),\n                    tr(\"Plugins\"), JOptionPane.ERROR_MESSAGE);\n        }\n    }","commit_id":"88b3df4cc858c13303ed8e07904b2f331f937a6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static JPanel getInfoPanel()\n    {\n        JPanel pluginTab = new JPanel(new GridBagLayout());\n        for (final PluginProxy p : pluginList) {\n            String name = p.info.name + (p.info.version != null && !p.info.version.equals(\"\") ? \" Version: \"+p.info.version : \"\");\n            pluginTab.add(new JLabel(name), GBC.std());\n            pluginTab.add(Box.createHorizontalGlue(), GBC.std().fill(GBC.HORIZONTAL));\n            pluginTab.add(new JButton(new AbstractAction(tr(\"Information\")){\n                public void actionPerformed(ActionEvent event) {\n                    StringBuilder b = new StringBuilder();\n                    for (Entry<String,String> e : p.info.attr.entrySet()) {\n                        b.append(e.getKey());\n                        b.append(\": \");\n                        b.append(e.getValue());\n                        b.append(\"\\n\");\n                    }\n                    JTextArea a = new JTextArea(10,40);\n                    a.setEditable(false);\n                    a.setText(b.toString());\n                    JOptionPane.showMessageDialog(Main.parent, new JScrollPane(a));\n                }\n            }), GBC.eol());\n\n            JTextArea description = new JTextArea((p.info.description==null? tr(\"no description available\"):p.info.description));\n            description.setEditable(false);\n            description.setFont(new JLabel().getFont().deriveFont(Font.ITALIC));\n            description.setLineWrap(true);\n            description.setWrapStyleWord(true);\n            description.setBorder(BorderFactory.createEmptyBorder(0,20,0,0));\n            description.setBackground(UIManager.getColor(\"Panel.background\"));\n\n            pluginTab.add(description, GBC.eop().fill(GBC.HORIZONTAL));\n        }\n        return pluginTab;\n    }","id":102071,"modified_method":"public static JPanel getInfoPanel()\n    {\n        JPanel pluginTab = new JPanel(new GridBagLayout());\n        for (final PluginProxy p : pluginList) {\n            String name = p.info.name + (p.info.version != null && !p.info.version.equals(\"\") ? \" Version: \"+p.info.version : \"\");\n            pluginTab.add(new JLabel(name), GBC.std());\n            pluginTab.add(Box.createHorizontalGlue(), GBC.std().fill(GBC.HORIZONTAL));\n            pluginTab.add(new JButton(new AbstractAction(tr(\"Information\")){\n                public void actionPerformed(ActionEvent event) {\n                    StringBuilder b = new StringBuilder();\n                    for (Entry<String,String> e : p.info.attr.entrySet()) {\n                        b.append(e.getKey());\n                        b.append(\": \");\n                        b.append(e.getValue());\n                        b.append(\"\\n\");\n                    }\n                    JTextArea a = new JTextArea(10,40);\n                    a.setEditable(false);\n                    a.setText(b.toString());\n                    OptionPaneUtil.showMessageDialog(\n                            Main.parent,\n                            new JScrollPane(a),\n                            tr(\"Plugin information\"),\n                            JOptionPane.INFORMATION_MESSAGE\n                    );\n                }\n            }), GBC.eol());\n\n            JTextArea description = new JTextArea((p.info.description==null? tr(\"no description available\"):p.info.description));\n            description.setEditable(false);\n            description.setFont(new JLabel().getFont().deriveFont(Font.ITALIC));\n            description.setLineWrap(true);\n            description.setWrapStyleWord(true);\n            description.setBorder(BorderFactory.createEmptyBorder(0,20,0,0));\n            description.setBackground(UIManager.getColor(\"Panel.background\"));\n\n            pluginTab.add(description, GBC.eop().fill(GBC.HORIZONTAL));\n        }\n        return pluginTab;\n    }","commit_id":"88b3df4cc858c13303ed8e07904b2f331f937a6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void update(JPanel pluginPanel) {\n        // refresh description\n        int num = PluginDownloader.downloadDescription();\n        Boolean done = false;\n        drawPanel(pluginPanel);\n\n        Set<PluginInformation> toUpdate = new HashSet<PluginInformation>();\n        StringBuilder toUpdateStr = new StringBuilder();\n        for (String pluginName : Main.pref.getCollection(\"plugins\", Collections.<String>emptySet())) {\n            PluginInformation local = localPlugins.get(pluginName);\n            PluginInformation description = availablePlugins.get(pluginName);\n\n            if (description == null) {\n                System.out.println(tr(\"Plug-in named {0} is not available. Update skipped.\", pluginName));\n                continue;\n            }\n\n            if (local == null || (description.version != null && !description.version.equals(local.version))) {\n                toUpdate.add(description);\n                toUpdateStr.append(pluginName+\"\\n\");\n            }\n        }\n        if (toUpdate.isEmpty()) {\n            JOptionPane.showMessageDialog(Main.parent, tr(\"All installed plugins are up to date.\"));\n            done = true;\n        } else {\n            int answer = new ExtendedDialog(Main.parent,\n                        tr(\"Update\"),\n                        tr(\"Update the following plugins:\\n\\n{0}\", toUpdateStr.toString()),\n                        new String[] {tr(\"Update Plugins\"), tr(\"Cancel\")},\n                        new String[] {\"dialogs/refresh.png\", \"cancel.png\"}).getValue();\n            if (answer == 1) {\n                PluginDownloader.update(toUpdate);\n                done = true;\n            }\n        }\n        if (done && num >= 1)\n            Main.pref.put(\"pluginmanager.lastupdate\", Long.toString(System.currentTimeMillis()));\n        drawPanel(pluginPanel);\n    }","id":102072,"modified_method":"public void update(JPanel pluginPanel) {\n        // refresh description\n        int num = PluginDownloader.downloadDescription();\n        Boolean done = false;\n        drawPanel(pluginPanel);\n\n        Set<PluginInformation> toUpdate = new HashSet<PluginInformation>();\n        StringBuilder toUpdateStr = new StringBuilder();\n        for (String pluginName : Main.pref.getCollection(\"plugins\", Collections.<String>emptySet())) {\n            PluginInformation local = localPlugins.get(pluginName);\n            PluginInformation description = availablePlugins.get(pluginName);\n\n            if (description == null) {\n                System.out.println(tr(\"Plug-in named {0} is not available. Update skipped.\", pluginName));\n                continue;\n            }\n\n            if (local == null || (description.version != null && !description.version.equals(local.version))) {\n                toUpdate.add(description);\n                toUpdateStr.append(pluginName+\"\\n\");\n            }\n        }\n        if (toUpdate.isEmpty()) {\n            OptionPaneUtil.showMessageDialog(\n                    Main.parent,\n                    tr(\"All installed plugins are up to date.\"),\n                    tr(\"Information\"),\n                    JOptionPane.INFORMATION_MESSAGE\n            );\n            done = true;\n        } else {\n            int answer = new ExtendedDialog(Main.parent,\n                    tr(\"Update\"),\n                    tr(\"Update the following plugins:\\n\\n{0}\", toUpdateStr.toString()),\n                    new String[] {tr(\"Update Plugins\"), tr(\"Cancel\")},\n                    new String[] {\"dialogs/refresh.png\", \"cancel.png\"}).getValue();\n            if (answer == 1) {\n                PluginDownloader.update(toUpdate);\n                done = true;\n            }\n        }\n        if (done && num >= 1) {\n            Main.pref.put(\"pluginmanager.lastupdate\", Long.toString(System.currentTimeMillis()));\n        }\n        drawPanel(pluginPanel);\n    }","commit_id":"88b3df4cc858c13303ed8e07904b2f331f937a6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void updateDescription(JPanel pluginPanel) {\n        int count = PluginDownloader.downloadDescription();\n        if (count > 0)\n            JOptionPane.showMessageDialog(Main.parent,\n                trn(\"Downloaded plugin information from {0} site\",\n                    \"Downloaded plugin information from {0} sites\", count, count));\n        else\n            JOptionPane.showMessageDialog(Main.parent, tr(\"No plugin information found.\"));\n        drawPanel(pluginPanel);\n    }","id":102073,"modified_method":"public void updateDescription(JPanel pluginPanel) {\n        int count = PluginDownloader.downloadDescription();\n        if (count > 0) {\n            OptionPaneUtil.showMessageDialog(Main.parent,\n                    trn(\"Downloaded plugin information from {0} site\",\n                            \"Downloaded plugin information from {0} sites\", count, count),\n                            tr(\"Information\"),\n                            JOptionPane.INFORMATION_MESSAGE\n            );\n        } else {\n            OptionPaneUtil.showMessageDialog(\n                    Main.parent,\n                    tr(\"No plugin information found.\"),\n                    tr(\"Error\"),\n                    JOptionPane.ERROR_MESSAGE\n            );\n        }\n        drawPanel(pluginPanel);\n    }","commit_id":"88b3df4cc858c13303ed8e07904b2f331f937a6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void loadPlugins() {\n        availablePlugins = new TreeMap<String, PluginInformation>(new Comparator<String>(){\n            public int compare(String o1, String o2) {\n                return o1.compareToIgnoreCase(o2);\n            }\n        });\n        localPlugins = new TreeMap<String, PluginInformation>(new Comparator<String>(){\n            public int compare(String o1, String o2) {\n                return o1.compareToIgnoreCase(o2);\n            }\n        });\n        for (String location : PluginInformation.getPluginLocations()) {\n            File[] pluginFiles = new File(location).listFiles();\n            if (pluginFiles != null) {\n                Arrays.sort(pluginFiles);\n                for (File f : pluginFiles) {\n                    if (!f.isFile())\n                        continue;\n                    String fname = f.getName();\n                    if (fname.endsWith(\".jar\")) {\n                        try {\n                            PluginInformation info = new PluginInformation(f,fname.substring(0,fname.length()-4));\n                            if (!availablePlugins.containsKey(info.name))\n                                availablePlugins.put(info.name, info);\n                            if (!localPlugins.containsKey(info.name))\n                                localPlugins.put(info.name, info);\n                        } catch (PluginException x) {\n                        }\n                    } else if (fname.endsWith(\".jar.new\")) {\n                        try {\n                            PluginInformation info = new PluginInformation(f,fname.substring(0,fname.length()-8));\n                            availablePlugins.put(info.name, info);\n                            localPlugins.put(info.name, info);\n                        } catch (PluginException x) {\n                        }\n                    } else if (fname.matches(\"^[0-9]+-site.*\\\\.txt$\")) {\n                        int err = 0;\n                        try {\n                            BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(f), \"utf-8\"));\n                            String name = null;\n                            String url = null;\n                            String manifest = null;\n                            for (String line = r.readLine(); line != null; line = r.readLine())\n                            {\n                                if(line.startsWith(\"\\t\"))\n                                {\n                                    line = line.substring(1);\n                                    if(line.length() > 70)\n                                    {\n                                        manifest += line.substring(0,70)+\"\\n\";\n                                        line = \" \" + line.substring(70);\n                                    }\n                                    manifest += line+\"\\n\";\n                                }\n                                else\n                                {\n                                    if(name != null)\n                                    {\n                                        try\n                                        {\n                                            PluginInformation info = new PluginInformation(\n                                            new ByteArrayInputStream(manifest.getBytes(\"utf-8\")),\n                                            name.substring(0,name.length()-4), url);\n                                            if(!availablePlugins.containsKey(info.name))\n                                                availablePlugins.put(info.name, info);\n                                        }\n                                        catch (Exception e)\n                                        {\n                                            e.printStackTrace();\n                                            ++err;\n                                        }\n                                    }\n                                    String x[] = line.split(\";\");\n                                    name = x[0];\n                                    url = x[1];\n                                    manifest = null;\n                                }\n                            }\n                            if(name != null)\n                            {\n                                PluginInformation info = new PluginInformation(\n                                new ByteArrayInputStream(manifest.getBytes(\"utf-8\")),\n                                name.substring(0,name.length()-4), url);\n                                if(!availablePlugins.containsKey(info.name))\n                                    availablePlugins.put(info.name, info);\n                            }\n                            r.close();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                            ++err;\n                        }\n                        if(err > 0)\n                        {\n                          JOptionPane.showMessageDialog(Main.parent, tr(\"Error reading plugin information file: {0}\", f.getName()));\n                        }\n                    }\n                }\n            }\n        }\n        for (PluginProxy proxy : PluginHandler.pluginList)\n        {\n            if (!availablePlugins.containsKey(proxy.info.name))\n                availablePlugins.put(proxy.info.name, proxy.info);\n            if (!localPlugins.containsKey(proxy.info.name))\n                localPlugins.put(proxy.info.name, proxy.info);\n        }\n    }","id":102074,"modified_method":"private void loadPlugins() {\n        availablePlugins = new TreeMap<String, PluginInformation>(new Comparator<String>(){\n            public int compare(String o1, String o2) {\n                return o1.compareToIgnoreCase(o2);\n            }\n        });\n        localPlugins = new TreeMap<String, PluginInformation>(new Comparator<String>(){\n            public int compare(String o1, String o2) {\n                return o1.compareToIgnoreCase(o2);\n            }\n        });\n        for (String location : PluginInformation.getPluginLocations()) {\n            File[] pluginFiles = new File(location).listFiles();\n            if (pluginFiles != null) {\n                Arrays.sort(pluginFiles);\n                for (File f : pluginFiles) {\n                    if (!f.isFile()) {\n                        continue;\n                    }\n                    String fname = f.getName();\n                    if (fname.endsWith(\".jar\")) {\n                        try {\n                            PluginInformation info = new PluginInformation(f,fname.substring(0,fname.length()-4));\n                            if (!availablePlugins.containsKey(info.name)) {\n                                availablePlugins.put(info.name, info);\n                            }\n                            if (!localPlugins.containsKey(info.name)) {\n                                localPlugins.put(info.name, info);\n                            }\n                        } catch (PluginException x) {\n                        }\n                    } else if (fname.endsWith(\".jar.new\")) {\n                        try {\n                            PluginInformation info = new PluginInformation(f,fname.substring(0,fname.length()-8));\n                            availablePlugins.put(info.name, info);\n                            localPlugins.put(info.name, info);\n                        } catch (PluginException x) {\n                        }\n                    } else if (fname.matches(\"^[0-9]+-site.*\\\\.txt$\")) {\n                        int err = 0;\n                        try {\n                            BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(f), \"utf-8\"));\n                            String name = null;\n                            String url = null;\n                            String manifest = null;\n                            for (String line = r.readLine(); line != null; line = r.readLine())\n                            {\n                                if(line.startsWith(\"\\t\"))\n                                {\n                                    line = line.substring(1);\n                                    if(line.length() > 70)\n                                    {\n                                        manifest += line.substring(0,70)+\"\\n\";\n                                        line = \" \" + line.substring(70);\n                                    }\n                                    manifest += line+\"\\n\";\n                                }\n                                else\n                                {\n                                    if(name != null)\n                                    {\n                                        try\n                                        {\n                                            PluginInformation info = new PluginInformation(\n                                                    new ByteArrayInputStream(manifest.getBytes(\"utf-8\")),\n                                                    name.substring(0,name.length()-4), url);\n                                            if(!availablePlugins.containsKey(info.name)) {\n                                                availablePlugins.put(info.name, info);\n                                            }\n                                        }\n                                        catch (Exception e)\n                                        {\n                                            e.printStackTrace();\n                                            ++err;\n                                        }\n                                    }\n                                    String x[] = line.split(\";\");\n                                    name = x[0];\n                                    url = x[1];\n                                    manifest = null;\n                                }\n                            }\n                            if(name != null)\n                            {\n                                PluginInformation info = new PluginInformation(\n                                        new ByteArrayInputStream(manifest.getBytes(\"utf-8\")),\n                                        name.substring(0,name.length()-4), url);\n                                if(!availablePlugins.containsKey(info.name)) {\n                                    availablePlugins.put(info.name, info);\n                                }\n                            }\n                            r.close();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                            ++err;\n                        }\n                        if(err > 0)\n                        {\n                            OptionPaneUtil.showMessageDialog(\n                                    Main.parent,\n                                    tr(\"Error reading plugin information file: {0}\", f.getName()),\n                                    tr(\"Error\"),\n                                    JOptionPane.ERROR_MESSAGE\n                            );\n                        }\n                    }\n                }\n            }\n        }\n        for (PluginProxy proxy : PluginHandler.pluginList)\n        {\n            if (!availablePlugins.containsKey(proxy.info.name)) {\n                availablePlugins.put(proxy.info.name, proxy.info);\n            }\n            if (!localPlugins.containsKey(proxy.info.name)) {\n                localPlugins.put(proxy.info.name, proxy.info);\n            }\n        }\n    }","commit_id":"88b3df4cc858c13303ed8e07904b2f331f937a6c","url":"https://github.com/openstreetmap/josm"},{"original_method":"public ProxySettingsPanel() {\n    ButtonGroup buttonGroup = new ButtonGroup();\n    buttonGroup.add(myHTTP);\n    buttonGroup.add(mySocks4);\n    buttonGroup.add(mySocks5);\n    disableAll(false);\n\n    myUseProxy.addItemListener(new ItemListener() {\n      public void itemStateChanged(ItemEvent e) {\n        if (myUseProxy.isSelected()) {\n          enableAll(false);\n        }\n        else {\n          disableAll(false);\n        }\n      }\n    });\n\n  }","id":102075,"modified_method":"public ProxySettingsPanel() {\n    ButtonGroup buttonGroup = new ButtonGroup();\n    buttonGroup.add(myHTTP);\n    buttonGroup.add(mySocks4);\n    buttonGroup.add(mySocks5);\n    disableAll(false);\n\n    myUseProxy.addItemListener(new ItemListener() {\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        if (myUseProxy.isSelected()) {\n          enableAll(false);\n        }\n        else {\n          disableAll(false);\n        }\n      }\n    });\n\n  }","commit_id":"8634cb04c56f767e2b3ecd71ad6b41476474a0cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateFrom(ProxySettings proxy_settings) {\n    myUseProxy.setSelected(proxy_settings.USE_PROXY);\n    myProxyHost.setText(proxy_settings.PROXY_HOST);\n    myProxyPort.setText(getStringPortValue(proxy_settings.PROXY_PORT));\n\n    if (proxy_settings.getType() == ProxySettings.HTTP) {\n      myHTTP.setSelected(true);\n    }\n    else if (proxy_settings.getType() == ProxySettings.SOCKS4) {\n      mySocks4.setSelected(true);\n    }\n    else {\n      mySocks5.setSelected(true);\n    }\n\n    myLogin.setText(proxy_settings.getLogin());\n    myPassword.setText(proxy_settings.getPassword());\n    if (proxy_settings.USE_PROXY){\n      enableAll(true);\n    } else {\n      disableAll(false);\n    }\n  }","id":102076,"modified_method":"public void updateFrom(ProxySettings proxy_settings) {\n    myUseProxy.setSelected(proxy_settings.USE_PROXY);\n    myProxyHost.setText(proxy_settings.PROXY_HOST);\n    myProxyPort.setText(String.valueOf(proxy_settings.PROXY_PORT));\n\n    if (proxy_settings.getType() == ProxySettings.HTTP) {\n      myHTTP.setSelected(true);\n    }\n    else if (proxy_settings.getType() == ProxySettings.SOCKS4) {\n      mySocks4.setSelected(true);\n    }\n    else {\n      mySocks5.setSelected(true);\n    }\n\n    myLogin.setText(proxy_settings.getLogin());\n    myPassword.setText(proxy_settings.getPassword());\n    if (proxy_settings.USE_PROXY){\n      enableAll(true);\n    } else {\n      disableAll(false);\n    }\n  }","commit_id":"8634cb04c56f767e2b3ecd71ad6b41476474a0cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int getIntPortValue(String text, JComponent component) {\n    try {\n      return Integer.parseInt(text);\n    }\n    catch (NumberFormatException e) {\n      throw new InputException(com.intellij.CvsBundle.message(\"exception.text.invalid.port.value\", text), component);\n    }\n  }","id":102077,"modified_method":"private static int getIntPortValue(String text, JComponent component) {\n    try {\n      final int result = Integer.parseInt(text);\n      if (result < 0) {\n        throw new InputException(CvsBundle.message(\"error.message.invalid.port.value\", text), component);\n      }\n      return result;\n    }\n    catch (NumberFormatException e) {\n      throw new InputException(CvsBundle.message(\"error.message.invalid.port.value\", text), component);\n    }\n  }","commit_id":"8634cb04c56f767e2b3ecd71ad6b41476474a0cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private final static char expandCharRef(String buf) throws XPathException {\n\t\ttry {\n\t\t\tif (buf.length() > 1 && buf.charAt(0) == 'x') {\n\t\t\t\t// Hex\n\t\t\t\treturn (char) Integer.parseInt(buf.substring(1), 16);\n\t\t\t} else\n\t\t\t\treturn (char) Integer.parseInt(buf);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new XPathException(\"Unknown character reference: \" + buf);\n\t\t}\n\t}","id":102078,"modified_method":"private final static char expandCharRef(String buf) throws XPathException {\n\t\ttry {\n                   int charNumber;\n\t\t\tif (buf.length() > 1 && buf.charAt(0) == 'x') {\n\t\t\t\t// Hex\n\t\t\t\tcharNumber = Integer.parseInt(buf.substring(1), 16);\n\t\t\t} else {\n\t\t\t\tcharNumber = Integer.parseInt(buf);\n                        }\n                   if (charNumber==0) {\n                      throw new XPathException(\"XQST0090 : Character number zero (0) is not allowed.\");\n                   }\n                   return (char)charNumber;\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new XPathException(\"Unknown character reference: \" + buf);\n\t\t}\n\t}","commit_id":"7aaa92eb7e9f3b1c9c466d7792f098288a8b50ad","url":"https://github.com/eXist-db/exist"},{"original_method":"public final static String expand(CharSequence seq) throws XPathException {\n\t\tStringBuffer buf = new StringBuffer(seq.length());\n\t\tStringBuffer entityRef = null;\n\t\tchar ch;\n\t\tfor (int i = 0; i < seq.length(); i++) {\n\t\t\tch = seq.charAt(i);\n\t\t\tswitch (ch) {\n\t\t\t\tcase '&' :\n\t\t\t\t\tif (entityRef == null)\n\t\t\t\t\t\tentityRef = new StringBuffer();\n\t\t\t\t\telse\n\t\t\t\t\t\tentityRef.setLength(0);\n\t\t\t\t\tboolean found = false;\n\t\t\t\t\tfor (int j = i + 1; j < seq.length(); j++) {\n\t\t\t\t\t\tch = seq.charAt(j);\n\t\t\t\t\t\tif (ch != ';')\n\t\t\t\t\t\t\tentityRef.append(ch);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tbuf.append(expandEntity(entityRef.toString()));\n\t\t\t\t\t//TODO : does it make sens to outup such a standalone \"&\" ?\n\t\t\t\t\t//<elem>&<\/elem>\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuf.append('&');\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault :\n\t\t\t\t\tbuf.append(ch);\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}","id":102079,"modified_method":"public final static String expand(CharSequence seq) throws XPathException {\n\t\tStringBuffer buf = new StringBuffer(seq.length());\n\t\tStringBuffer entityRef = null;\n\t\tchar ch;\n\t\tfor (int i = 0; i < seq.length(); i++) {\n\t\t\tch = seq.charAt(i);\n\t\t\tswitch (ch) {\n\t\t\t\tcase '&' :\n\t\t\t\t\tif (entityRef == null)\n\t\t\t\t\t\tentityRef = new StringBuffer();\n\t\t\t\t\telse\n\t\t\t\t\t\tentityRef.setLength(0);\n                                        if ((i+1)==seq.length()) {\n                                           throw new XPathException(\"XPST0003 : Ampersands (&) must be escaped.\");\n                                        }\n                                        if ((i+2)==seq.length()) {\n                                           throw new XPathException(\"XPST0003 : Ampersands (&) must be escaped (missing ;).\");\n                                        }\n                                        ch = seq.charAt(i+1);\n                                        if (ch!='#') {\n                                           if (!Character.isLetter(ch)) {\n                                              throw new XPathException(\"XPST0003 : Ampersands (&) must be escaped (following character was not a name start character).\");\n                                           }\n                                           entityRef.append(ch);\n                                           boolean found = false;\n                                           for (int j = i + 2; j < seq.length(); j++) {\n                                                   ch = seq.charAt(j);\n                                                   if (ch != ';' && (ch=='.' || ch=='_' || ch=='-' || Character.isLetterOrDigit(ch))) {\n                                                           entityRef.append(ch);\n                                                   } else if (ch==';') {\n                                                           found = true;\n                                                           i = j;\n                                                           break;\n                                                   } else {\n                                                      break;\n                                                   }\n                                           }\n                                           if (found) {\n                                                   buf.append(expandEntity(entityRef.toString()));\n                                           } else {\n                                              throw new XPathException(\"XPST0003 : Invalid character in entity name (\"+ch+\") or missing ;\");\n                                           }\n                                        } else {\n                                           entityRef.append(ch);\n                                           ch = seq.charAt(i+2);\n                                           boolean found = false;\n                                           if (ch=='x') {\n                                              entityRef.append(ch);\n                                              // hex number\n                                              for (int j = i + 3; j < seq.length(); j++) {\n                                                      ch = seq.charAt(j);\n                                                      if (ch != ';' && (ch=='0' || ch=='1' || ch=='2' || ch=='3' || ch=='4' || ch=='5' || ch=='6' || ch=='7' || ch=='8' || ch=='9' ||\n                                                                        ch=='a' || ch=='b' || ch=='c' || ch=='d' || ch=='e' || ch=='f' ||\n                                                                        ch=='A' || ch=='B' || ch=='C' || ch=='D' || ch=='E' || ch=='F')) {\n                                                              entityRef.append(ch);\n                                                      } else if (ch==';') {\n                                                              found = true;\n                                                              i = j;\n                                                              break;\n                                                      } else {\n                                                         break;\n                                                      }\n                                              }\n                                           } else {\n                                              // decimal number\n                                              for (int j = i + 2; j < seq.length(); j++) {\n                                                      ch = seq.charAt(j);\n                                                      if (ch != ';' && (ch=='0' || ch=='1' || ch=='2' || ch=='3' || ch=='4' || ch=='5' || ch=='6' || ch=='7' || ch=='8' || ch=='9')) {\n                                                              entityRef.append(ch);\n                                                      } else if (ch==';') {\n                                                              found = true;\n                                                              i = j;\n                                                              break;\n                                                      } else {\n                                                         break;\n                                                      }\n                                              }\n                                           }\n                                           if (found) {\n                                                   buf.append(expandEntity(entityRef.toString()));\n                                           } else {\n                                              throw new XPathException(\"XPST0003 : Invalid character in character reference (\"+ch+\") or missing ;\");\n                                           }\n                                           \n                                        }\n\t\t\t\t\tbreak;\n                                case '\\r':\n                                   // drop carriage returns\n                                   if ((i+1)!=seq.length()) {\n                                      ch = seq.charAt(i+1);\n                                      if (ch!='\\n') {\n                                         buf.append('\\n');\n                                      }\n                                   }\n                                   break;\n\t\t\t\tdefault :\n\t\t\t\t\tbuf.append(ch);\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}","commit_id":"7aaa92eb7e9f3b1c9c466d7792f098288a8b50ad","url":"https://github.com/eXist-db/exist"},{"original_method":"private void performRuntime(final OperationContext context, final HornetQServerResource resource,\n                                  final ServiceVerificationHandler verificationHandler,\n                                  final List<ServiceController<?>> newControllers) throws OperationFailedException {\n        // Add a RUNTIME step to actually install the HQ Service. This will execute after the runtime step\n        // added by any child resources whose ADD handler executes after this one in the model stage.\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                final ServiceTarget serviceTarget = context.getServiceTarget();\n\n                final String serverName = PathAddress.pathAddress(operation.require(OP_ADDR)).getLastElement().getValue();\n\n                // Transform the configuration based on the recursive model\n                final ModelNode model = Resource.Tools.readModel(resource);\n                final Configuration configuration = transformConfig(context, serverName, model);\n\n                // Create path services\n                String bindingsPath = getPath(DEFAULT_BINDINGS_DIR, PATH.resolveModelAttribute(context, model.get(ModelDescriptionConstants.PATH, BINDINGS_DIRECTORY)));\n                String bindingsRelativeToPath = RELATIVE_TO.resolveModelAttribute(context, model.get(ModelDescriptionConstants.PATH, BINDINGS_DIRECTORY)).asString();\n                String journalPath = getPath(DEFAULT_JOURNAL_DIR, PATH.resolveModelAttribute(context, model.get(ModelDescriptionConstants.PATH, JOURNAL_DIRECTORY)));\n                String journalRelativeToPath = RELATIVE_TO.resolveModelAttribute(context, model.get(ModelDescriptionConstants.PATH, JOURNAL_DIRECTORY)).asString();\n                String largeMessagePath = getPath(DEFAULT_LARGE_MESSAGE_DIR, PATH.resolveModelAttribute(context, model.get(ModelDescriptionConstants.PATH, LARGE_MESSAGES_DIRECTORY)));\n                String largeMessageRelativeToPath = RELATIVE_TO.resolveModelAttribute(context, model.get(ModelDescriptionConstants.PATH, LARGE_MESSAGES_DIRECTORY)).asString();\n                String pagingPath = getPath(DEFAULT_PAGING_DIR, PATH.resolveModelAttribute(context, model.get(ModelDescriptionConstants.PATH, PAGING_DIRECTORY)));\n                String pagingRelativeToPath = RELATIVE_TO.resolveModelAttribute(context, model.get(ModelDescriptionConstants.PATH, PAGING_DIRECTORY)).asString();\n\n                // Create the HornetQ Service\n                final HornetQService hqService = new HornetQService(\n                        new PathConfig(bindingsPath, bindingsRelativeToPath, journalPath, journalRelativeToPath, largeMessagePath, largeMessageRelativeToPath, pagingPath, pagingRelativeToPath));\n\n                hqService.setConfiguration(configuration);\n\n                // Add the HornetQ Service\n                ServiceName hqServiceName = MessagingServices.getHornetQServiceName(serverName);\n                final ServiceBuilder<HornetQServer> serviceBuilder = serviceTarget.addService(hqServiceName, hqService)\n                        .addDependency(DependencyType.OPTIONAL, ServiceName.JBOSS.append(\"mbean\", \"server\"), MBeanServer.class, hqService.getMBeanServer());\n\n                serviceBuilder.addDependency(PathManagerService.SERVICE_NAME, PathManager.class, hqService.getPathManagerInjector());\n\n                // Add security\n                String domain = SECURITY_DOMAIN.resolveModelAttribute(context, model).asString();\n                serviceBuilder.addDependency(DependencyType.REQUIRED,\n                        SecurityDomainService.SERVICE_NAME.append(domain),\n                        SecurityDomainContext.class,\n                        hqService.getSecurityDomainContextInjector());\n\n                // Process acceptors and connectors\n                final Set<String> socketBindings = new HashSet<String>();\n                TransportConfigOperationHandlers.processAcceptors(context, configuration, model, socketBindings);\n\n                for (final String socketBinding : socketBindings) {\n                    final ServiceName socketName = SocketBinding.JBOSS_BINDING_NAME.append(socketBinding);\n                    serviceBuilder.addDependency(socketName, SocketBinding.class, hqService.getSocketBindingInjector(socketBinding));\n                }\n\n                final Set<String> outboundSocketBindings = new HashSet<String>();\n                TransportConfigOperationHandlers.processConnectors(context, configuration, model, outboundSocketBindings);\n                for (final String outboundSocketBinding : outboundSocketBindings) {\n                    final ServiceName outboundSocketName = OutboundSocketBinding.OUTBOUND_SOCKET_BINDING_BASE_SERVICE_NAME.append(outboundSocketBinding);\n                    // Optional dependency so it won't fail if the user used a ref to socket-binding instead of\n                    // outgoing-socket-binding\n                    serviceBuilder.addDependency(DependencyType.OPTIONAL, outboundSocketName, OutboundSocketBinding.class,\n                            hqService.getOutboundSocketBindingInjector(outboundSocketBinding));\n                    if (!socketBindings.contains(outboundSocketBinding)) {\n                        // Add a dependency on the regular socket binding as well so users don't have to use\n                        // outgoing-socket-binding to configure a ref to the local server socket\n                        final ServiceName socketName = SocketBinding.JBOSS_BINDING_NAME.append(outboundSocketBinding);\n                        serviceBuilder.addDependency(DependencyType.OPTIONAL, socketName, SocketBinding.class,\n                                hqService.getSocketBindingInjector(outboundSocketBinding));\n                    }\n                }\n\n                final List<BroadcastGroupConfiguration> broadcastGroupConfigurations = configuration.getBroadcastGroupConfigurations();\n                final Map<String, DiscoveryGroupConfiguration> discoveryGroupConfigurations = configuration.getDiscoveryGroupConfigurations();\n\n                if(broadcastGroupConfigurations != null) {\n                    for(final BroadcastGroupConfiguration config : broadcastGroupConfigurations) {\n                        final String name = config.getName();\n                        final ServiceName groupBinding = GroupBindingService.getBroadcastBaseServiceName(hqServiceName).append(name);\n                        serviceBuilder.addDependency(groupBinding, SocketBinding.class, hqService.getGroupBindingInjector(\"broadcast\" + name));\n                    }\n                }\n                if(discoveryGroupConfigurations != null) {\n                    for(final DiscoveryGroupConfiguration config : discoveryGroupConfigurations.values()) {\n                        final String name = config.getName();\n                        final ServiceName groupBinding = GroupBindingService.getDiscoveryBaseServiceName(hqServiceName).append(name);\n                        serviceBuilder.addDependency(groupBinding, SocketBinding.class, hqService.getGroupBindingInjector(\"discovery\" + name));\n                    }\n                }\n\n                serviceBuilder.addListener(verificationHandler);\n\n                // Install the HornetQ Service\n                ServiceController<HornetQServer> hqServerServiceController = serviceBuilder.install();\n                // Provide our custom Resource impl a ref to the HornetQServer so it can create child runtime resources\n                resource.setHornetQServerServiceController(hqServerServiceController);\n\n                newControllers.add(hqServerServiceController);\n                newControllers.add(JMSService.addService(serviceTarget, hqServiceName, verificationHandler));\n\n                context.completeStep();\n            }\n        }, OperationContext.Stage.RUNTIME);\n    }","id":102080,"modified_method":"private void performRuntime(final OperationContext context, final HornetQServerResource resource,\n                                  final ServiceVerificationHandler verificationHandler,\n                                  final List<ServiceController<?>> newControllers) throws OperationFailedException {\n        // Add a RUNTIME step to actually install the HQ Service. This will execute after the runtime step\n        // added by any child resources whose ADD handler executes after this one in the model stage.\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                final ServiceTarget serviceTarget = context.getServiceTarget();\n\n                final String serverName = PathAddress.pathAddress(operation.require(OP_ADDR)).getLastElement().getValue();\n\n                // Transform the configuration based on the recursive model\n                final ModelNode model = Resource.Tools.readModel(resource);\n                final Configuration configuration = transformConfig(context, serverName, model);\n\n                // Create path services\n                String bindingsPath = PATHS.get(BINDINGS_DIRECTORY).resolveModelAttribute(context, model.get(PATH, BINDINGS_DIRECTORY)).asString();\n                String bindingsRelativeToPath = RELATIVE_TO.resolveModelAttribute(context, model.get(PATH, BINDINGS_DIRECTORY)).asString();\n                String journalPath = PATHS.get(JOURNAL_DIRECTORY).resolveModelAttribute(context, model.get(PATH, JOURNAL_DIRECTORY)).asString();\n                String journalRelativeToPath = RELATIVE_TO.resolveModelAttribute(context, model.get(PATH, JOURNAL_DIRECTORY)).asString();\n                String largeMessagePath = PATHS.get(LARGE_MESSAGES_DIRECTORY).resolveModelAttribute(context, model.get(PATH, LARGE_MESSAGES_DIRECTORY)).asString();\n                String largeMessageRelativeToPath = RELATIVE_TO.resolveModelAttribute(context, model.get(PATH, LARGE_MESSAGES_DIRECTORY)).asString();\n                String pagingPath = PATHS.get(PAGING_DIRECTORY).resolveModelAttribute(context, model.get(PATH, PAGING_DIRECTORY)).asString();\n                String pagingRelativeToPath = RELATIVE_TO.resolveModelAttribute(context, model.get(PATH, PAGING_DIRECTORY)).asString();\n\n                // Create the HornetQ Service\n                final HornetQService hqService = new HornetQService(\n                        new PathConfig(bindingsPath, bindingsRelativeToPath, journalPath, journalRelativeToPath, largeMessagePath, largeMessageRelativeToPath, pagingPath, pagingRelativeToPath));\n\n                hqService.setConfiguration(configuration);\n\n                // Add the HornetQ Service\n                ServiceName hqServiceName = MessagingServices.getHornetQServiceName(serverName);\n                final ServiceBuilder<HornetQServer> serviceBuilder = serviceTarget.addService(hqServiceName, hqService)\n                        .addDependency(DependencyType.OPTIONAL, ServiceName.JBOSS.append(\"mbean\", \"server\"), MBeanServer.class, hqService.getMBeanServer());\n\n                serviceBuilder.addDependency(PathManagerService.SERVICE_NAME, PathManager.class, hqService.getPathManagerInjector());\n\n                // Add security\n                String domain = SECURITY_DOMAIN.resolveModelAttribute(context, model).asString();\n                serviceBuilder.addDependency(DependencyType.REQUIRED,\n                        SecurityDomainService.SERVICE_NAME.append(domain),\n                        SecurityDomainContext.class,\n                        hqService.getSecurityDomainContextInjector());\n\n                // Process acceptors and connectors\n                final Set<String> socketBindings = new HashSet<String>();\n                TransportConfigOperationHandlers.processAcceptors(context, configuration, model, socketBindings);\n\n                for (final String socketBinding : socketBindings) {\n                    final ServiceName socketName = SocketBinding.JBOSS_BINDING_NAME.append(socketBinding);\n                    serviceBuilder.addDependency(socketName, SocketBinding.class, hqService.getSocketBindingInjector(socketBinding));\n                }\n\n                final Set<String> outboundSocketBindings = new HashSet<String>();\n                TransportConfigOperationHandlers.processConnectors(context, configuration, model, outboundSocketBindings);\n                for (final String outboundSocketBinding : outboundSocketBindings) {\n                    final ServiceName outboundSocketName = OutboundSocketBinding.OUTBOUND_SOCKET_BINDING_BASE_SERVICE_NAME.append(outboundSocketBinding);\n                    // Optional dependency so it won't fail if the user used a ref to socket-binding instead of\n                    // outgoing-socket-binding\n                    serviceBuilder.addDependency(DependencyType.OPTIONAL, outboundSocketName, OutboundSocketBinding.class,\n                            hqService.getOutboundSocketBindingInjector(outboundSocketBinding));\n                    if (!socketBindings.contains(outboundSocketBinding)) {\n                        // Add a dependency on the regular socket binding as well so users don't have to use\n                        // outgoing-socket-binding to configure a ref to the local server socket\n                        final ServiceName socketName = SocketBinding.JBOSS_BINDING_NAME.append(outboundSocketBinding);\n                        serviceBuilder.addDependency(DependencyType.OPTIONAL, socketName, SocketBinding.class,\n                                hqService.getSocketBindingInjector(outboundSocketBinding));\n                    }\n                }\n\n                final List<BroadcastGroupConfiguration> broadcastGroupConfigurations = configuration.getBroadcastGroupConfigurations();\n                final Map<String, DiscoveryGroupConfiguration> discoveryGroupConfigurations = configuration.getDiscoveryGroupConfigurations();\n\n                if(broadcastGroupConfigurations != null) {\n                    for(final BroadcastGroupConfiguration config : broadcastGroupConfigurations) {\n                        final String name = config.getName();\n                        final ServiceName groupBinding = GroupBindingService.getBroadcastBaseServiceName(hqServiceName).append(name);\n                        serviceBuilder.addDependency(groupBinding, SocketBinding.class, hqService.getGroupBindingInjector(\"broadcast\" + name));\n                    }\n                }\n                if(discoveryGroupConfigurations != null) {\n                    for(final DiscoveryGroupConfiguration config : discoveryGroupConfigurations.values()) {\n                        final String name = config.getName();\n                        final ServiceName groupBinding = GroupBindingService.getDiscoveryBaseServiceName(hqServiceName).append(name);\n                        serviceBuilder.addDependency(groupBinding, SocketBinding.class, hqService.getGroupBindingInjector(\"discovery\" + name));\n                    }\n                }\n\n                serviceBuilder.addListener(verificationHandler);\n\n                // Install the HornetQ Service\n                ServiceController<HornetQServer> hqServerServiceController = serviceBuilder.install();\n                // Provide our custom Resource impl a ref to the HornetQServer so it can create child runtime resources\n                resource.setHornetQServerServiceController(hqServerServiceController);\n\n                newControllers.add(hqServerServiceController);\n                newControllers.add(JMSService.addService(serviceTarget, hqServiceName, verificationHandler));\n\n                context.completeStep();\n            }\n        }, OperationContext.Stage.RUNTIME);\n    }","commit_id":"8cd95138cfa007f749a41daf524d9313ba89c9ac","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc */\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n\n        // We use a custom Resource impl so we can expose runtime HQ components (e.g. AddressControl) as child resources\n        final HornetQServerResource resource = new HornetQServerResource();\n        context.addResource(PathAddress.EMPTY_ADDRESS, resource);\n        final ModelNode model = resource.getModel();\n\n        for (final AttributeDefinition attributeDefinition : CommonAttributes.SIMPLE_ROOT_RESOURCE_ATTRIBUTES) {\n            attributeDefinition.validateAndSet(operation, model);\n        }\n\n        if (context.isNormalServer()) {\n            // add an operation to create all the messaging paths resources that have not been already been created\n            // prior to adding the HornetQ server\n            context.addStep(new OperationStepHandler() {\n                @Override\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final ModelNode model = Resource.Tools.readModel(resource);\n                    for (String path : MessagingPathHandlers.PATHS) {\n                        if (!model.get(ModelDescriptionConstants.PATH).hasDefined(path)) {\n                            PathAddress pathAddress = PathAddress.pathAddress(PathElement.pathElement(ModelDescriptionConstants.PATH, path));\n                            context.createResource(pathAddress);\n                        }\n                    }\n                    context.completeStep();\n                }\n            }, OperationContext.Stage.MODEL);\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final List<ServiceController<?>> controllers = new ArrayList<ServiceController<?>>();\n                    final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                    performRuntime(context, resource, verificationHandler, controllers);\n\n                    context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n\n                    if (context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        for(ServiceController<?> controller : controllers) {\n                            context.removeService(controller.getName());\n                        }\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        context.completeStep();\n    }","id":102081,"modified_method":"/** {@inheritDoc */\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n\n        // We use a custom Resource impl so we can expose runtime HQ components (e.g. AddressControl) as child resources\n        final HornetQServerResource resource = new HornetQServerResource();\n        context.addResource(PathAddress.EMPTY_ADDRESS, resource);\n        final ModelNode model = resource.getModel();\n\n        for (final AttributeDefinition attributeDefinition : CommonAttributes.SIMPLE_ROOT_RESOURCE_ATTRIBUTES) {\n            attributeDefinition.validateAndSet(operation, model);\n        }\n\n        if (context.isNormalServer()) {\n            // add an operation to create all the messaging paths resources that have not been already been created\n            // prior to adding the HornetQ server\n            context.addStep(new OperationStepHandler() {\n                @Override\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final ModelNode model = Resource.Tools.readModel(resource);\n                    for (String path : MessagingPathHandlers.PATHS.keySet()) {\n                        if (!model.get(ModelDescriptionConstants.PATH).hasDefined(path)) {\n                            PathAddress pathAddress = PathAddress.pathAddress(PathElement.pathElement(ModelDescriptionConstants.PATH, path));\n                            context.createResource(pathAddress);\n                        }\n                    }\n                    context.completeStep();\n                }\n            }, OperationContext.Stage.MODEL);\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final List<ServiceController<?>> controllers = new ArrayList<ServiceController<?>>();\n                    final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                    performRuntime(context, resource, verificationHandler, controllers);\n\n                    context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n\n                    if (context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        for(ServiceController<?> controller : controllers) {\n                            context.removeService(controller.getName());\n                        }\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        context.completeStep();\n    }","commit_id":"8cd95138cfa007f749a41daf524d9313ba89c9ac","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void removeHornetQServer(String serverName, OperationContext context, Resource resource) {\n\n        final ServiceName hqServiceName = MessagingServices.getHornetQServiceName(serverName);\n\n        for(final Resource.ResourceEntry jmsQueue : resource.getChildren(CommonAttributes.JMS_QUEUE)) {\n            context.removeService(JMSServices.getJmsQueueBaseServiceName(hqServiceName).append(jmsQueue.getName()));\n        }\n        for(final Resource.ResourceEntry jmsTopic : resource.getChildren(CommonAttributes.JMS_TOPIC)) {\n            context.removeService(JMSServices.getJmsTopicBaseServiceName(hqServiceName).append(jmsTopic.getName()));\n        }\n        for(final Resource.ResourceEntry cf : resource.getChildren(CommonAttributes.CONNECTION_FACTORY)) {\n            context.removeService(JMSServices.getConnectionFactoryBaseServiceName(hqServiceName).append(cf.getName()));\n        }\n        for(final Resource.ResourceEntry pcf : resource.getChildren(CommonAttributes.POOLED_CONNECTION_FACTORY)) {\n            context.removeService(JMSServices.getPooledConnectionFactoryBaseServiceName(hqServiceName).append(pcf.getName()));\n        }\n        for(final Resource.ResourceEntry queue : resource.getChildren(CommonAttributes.QUEUE)) {\n            context.removeService(MessagingServices.getQueueBaseServiceName(hqServiceName).append(queue.getName()));\n        }\n\n        context.removeService(JMSServices.getJmsManagerBaseServiceName(hqServiceName));\n        context.removeService(MessagingServices.getHornetQServiceName(serverName));\n        for(final Resource.ResourceEntry broadcastGroup : resource.getChildren(CommonAttributes.BROADCAST_GROUP)) {\n            context.removeService(GroupBindingService.getBroadcastBaseServiceName(hqServiceName).append(broadcastGroup.getName()));\n        }\n        for(final Resource.ResourceEntry divertGroup : resource.getChildren(CommonAttributes.DISCOVERY_GROUP)) {\n            context.removeService(GroupBindingService.getDiscoveryBaseServiceName(hqServiceName).append(divertGroup.getName()));\n        }\n        context.removeService(hqServiceName.append(HornetQServerAdd.PATH_BASE).append(HornetQServerAdd.DEFAULT_BINDINGS_DIR));\n        context.removeService(hqServiceName.append(HornetQServerAdd.PATH_BASE).append(HornetQServerAdd.DEFAULT_JOURNAL_DIR));\n        context.removeService(hqServiceName.append(HornetQServerAdd.PATH_BASE).append(HornetQServerAdd.DEFAULT_LARGE_MESSAGE_DIR));\n        context.removeService(hqServiceName.append(HornetQServerAdd.PATH_BASE).append(HornetQServerAdd.DEFAULT_PAGING_DIR));\n    }","id":102082,"modified_method":"static void removeHornetQServer(String serverName, OperationContext context, Resource resource) {\n\n        final ServiceName hqServiceName = MessagingServices.getHornetQServiceName(serverName);\n\n        for(final Resource.ResourceEntry jmsQueue : resource.getChildren(CommonAttributes.JMS_QUEUE)) {\n            context.removeService(JMSServices.getJmsQueueBaseServiceName(hqServiceName).append(jmsQueue.getName()));\n        }\n        for(final Resource.ResourceEntry jmsTopic : resource.getChildren(CommonAttributes.JMS_TOPIC)) {\n            context.removeService(JMSServices.getJmsTopicBaseServiceName(hqServiceName).append(jmsTopic.getName()));\n        }\n        for(final Resource.ResourceEntry cf : resource.getChildren(CommonAttributes.CONNECTION_FACTORY)) {\n            context.removeService(JMSServices.getConnectionFactoryBaseServiceName(hqServiceName).append(cf.getName()));\n        }\n        for(final Resource.ResourceEntry pcf : resource.getChildren(CommonAttributes.POOLED_CONNECTION_FACTORY)) {\n            context.removeService(JMSServices.getPooledConnectionFactoryBaseServiceName(hqServiceName).append(pcf.getName()));\n        }\n        for(final Resource.ResourceEntry queue : resource.getChildren(CommonAttributes.QUEUE)) {\n            context.removeService(MessagingServices.getQueueBaseServiceName(hqServiceName).append(queue.getName()));\n        }\n\n        context.removeService(JMSServices.getJmsManagerBaseServiceName(hqServiceName));\n        context.removeService(MessagingServices.getHornetQServiceName(serverName));\n        for(final Resource.ResourceEntry broadcastGroup : resource.getChildren(CommonAttributes.BROADCAST_GROUP)) {\n            context.removeService(GroupBindingService.getBroadcastBaseServiceName(hqServiceName).append(broadcastGroup.getName()));\n        }\n        for(final Resource.ResourceEntry divertGroup : resource.getChildren(CommonAttributes.DISCOVERY_GROUP)) {\n            context.removeService(GroupBindingService.getDiscoveryBaseServiceName(hqServiceName).append(divertGroup.getName()));\n        }\n        for (ResourceEntry path : resource.getChildren(PATH)) {\n            context.removeService(hqServiceName.append(HornetQServerAdd.PATH_BASE).append(path.getName()));\n        }\n    }","commit_id":"8cd95138cfa007f749a41daf524d9313ba89c9ac","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     * <p/>\n     * The resource description has a small tweak from the standard\n     */\n    @Override\n    public DescriptionProvider getDescriptionProvider(ImmutableManagementResourceRegistration resourceRegistration) {\n        return new DefaultResourceDescriptionProvider(resourceRegistration, getResourceDescriptionResolver()) {\n            @Override\n            public ModelNode getModelDescription(Locale locale) {\n                ModelNode result = super.getModelDescription(locale);\n                String path = CommonAttributes.PATH.getName();\n                result.get(CHILDREN, path, MIN_OCCURS).set(4);\n                result.get(CHILDREN, path, MAX_OCCURS).set(4);\n                return result;\n            }\n        };\n    }","id":102083,"modified_method":"/**\n     * {@inheritDoc}\n     * <p/>\n     * The resource description has a small tweak from the standard\n     */\n    @Override\n    public DescriptionProvider getDescriptionProvider(ImmutableManagementResourceRegistration resourceRegistration) {\n        return new DefaultResourceDescriptionProvider(resourceRegistration, getResourceDescriptionResolver()) {\n            @Override\n            public ModelNode getModelDescription(Locale locale) {\n                ModelNode result = super.getModelDescription(locale);\n                result.get(CHILDREN, PATH, MIN_OCCURS).set(4);\n                result.get(CHILDREN, PATH, MAX_OCCURS).set(4);\n                return result;\n            }\n        };\n    }","commit_id":"8cd95138cfa007f749a41daf524d9313ba89c9ac","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ModelNode getPathResource(Locale locale, String pathType) {\n        final ResourceBundle bundle = getResourceBundle(locale);\n\n        final ModelNode root = new ModelNode();\n        root.get(DESCRIPTION).set(bundle.getString(pathType + \".path\"));\n        for (AttributeDefinition attr : MessagingPathHandlers.ATTRIBUTES) {\n            attr.addResourceAttributeDescription(bundle, \"path\", root);\n        }\n\n        root.get(OPERATIONS); // placeholder\n\n        root.get(CHILDREN).setEmptyObject();\n\n        return root;\n    }","id":102084,"modified_method":"public static ModelNode getPathResource(Locale locale, final String path) {\n        final ResourceBundle bundle = getResourceBundle(locale);\n\n        final ModelNode root = new ModelNode();\n        root.get(DESCRIPTION).set(bundle.getString(path + \".path\"));\n        for (AttributeDefinition attr : MessagingPathHandlers.getAttributes(path)) {\n            attr.addResourceAttributeDescription(bundle, \"path\", root);\n        }\n\n        root.get(OPERATIONS); // placeholder\n\n        root.get(CHILDREN).setEmptyObject();\n\n        return root;\n    }","commit_id":"8cd95138cfa007f749a41daf524d9313ba89c9ac","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ModelNode getPathAdd(Locale locale) {\n        final ResourceBundle bundle = getResourceBundle(locale);\n\n        final ModelNode node = new ModelNode();\n        node.get(OPERATION_NAME).set(ADD);\n        node.get(DESCRIPTION).set(bundle.getString(\"path.add\"));\n\n        for (AttributeDefinition attr : MessagingPathHandlers.ATTRIBUTES) {\n            attr.addOperationParameterDescription(bundle, \"path\", node);\n        }\n\n        return node;\n    }","id":102085,"modified_method":"public static ModelNode getPathAdd(Locale locale, final String path) {\n        final ResourceBundle bundle = getResourceBundle(locale);\n\n        final ModelNode node = new ModelNode();\n        node.get(OPERATION_NAME).set(ADD);\n        node.get(DESCRIPTION).set(bundle.getString(\"path.add\"));\n\n        for (AttributeDefinition attr : MessagingPathHandlers.getAttributes(path)) {\n            attr.addOperationParameterDescription(bundle, \"path\", node);\n        }\n\n        return node;\n    }","commit_id":"8cd95138cfa007f749a41daf524d9313ba89c9ac","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME,\n                MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION,\n                MANAGEMENT_API_MICRO_VERSION);\n        subsystem.registerXMLElementWriter(MessagingXMLWriter.INSTANCE);\n\n        boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();\n\n        // Root resource\n        final ManagementResourceRegistration rootRegistration = subsystem.registerSubsystemModel(MessagingSubsystemRootResourceDefinition.INSTANCE);\n        rootRegistration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);\n\n        // HQ servers\n        final ManagementResourceRegistration serverRegistration = rootRegistration.registerSubModel(new HornetQServerResourceDefinition(registerRuntimeOnly));\n\n        // Runtime addresses\n        if (registerRuntimeOnly) {\n            final ManagementResourceRegistration coreAddress = serverRegistration.registerSubModel(new CoreAddressDefinition());\n            coreAddress.setRuntimeOnly(true);\n        }\n\n        // Address settings\n        serverRegistration.registerSubModel(new AddressSettingDefinition(registerRuntimeOnly));\n\n        // Broadcast groups\n        serverRegistration.registerSubModel(new BroadcastGroupDefinition(registerRuntimeOnly));\n        // getConnectorPairs, -- no, this is just the same as attribute connector-refs\n\n        // Discovery groups\n        serverRegistration.registerSubModel(new DiscoveryGroupDefinition(registerRuntimeOnly));\n\n        // Diverts\n        serverRegistration.registerSubModel(new DivertDefinition(registerRuntimeOnly));\n\n        // Core queues\n        serverRegistration.registerSubModel(new QueueDefinition(registerRuntimeOnly));\n        // getExpiryAddress, setExpiryAddress, getDeadLetterAddress, setDeadLetterAddress  -- no -- just toggle the 'queue-address', make this a mutable attr of address-setting\n\n        // Acceptors\n        serverRegistration.registerSubModel(GenericTransportDefinition.createAcceptorDefinition(registerRuntimeOnly));\n        serverRegistration.registerSubModel(RemoteTransportDefinition.createAcceptorDefinition(registerRuntimeOnly));\n        serverRegistration.registerSubModel(InVMTransportDefinition.createAcceptorDefinition(registerRuntimeOnly));\n\n        // Connectors\n        serverRegistration.registerSubModel(GenericTransportDefinition.createConnectorDefinition(registerRuntimeOnly));\n        serverRegistration.registerSubModel(RemoteTransportDefinition.createConnectorDefinition(registerRuntimeOnly));\n        serverRegistration.registerSubModel(InVMTransportDefinition.createConnectorDefinition(registerRuntimeOnly));\n\n        // Bridges\n        serverRegistration.registerSubModel(new BridgeDefinition(registerRuntimeOnly));\n\n        // Cluster connections\n        serverRegistration.registerSubModel(new ClusterConnectionDefinition(registerRuntimeOnly));\n\n        // Grouping Handler\n        serverRegistration.registerSubModel(new GroupingHandlerDefinition(registerRuntimeOnly));\n\n        // Connector services\n        serverRegistration.registerSubModel(new ConnectorServiceDefinition(registerRuntimeOnly));\n\n        // Messaging paths\n        //todo, shouldn't we leverage Path service from AS? see: package org.jboss.as.controller.services.path\n        for (final String path : MessagingPathHandlers.PATHS) {\n            ManagementResourceRegistration bindings = serverRegistration.registerSubModel(PathElement.pathElement(PATH, path),\n                    new MessagingSubsystemProviders.PathProvider(path));\n            MessagingPathHandlers.register(bindings);\n        }\n\n        // Connection factories\n        serverRegistration.registerSubModel(new ConnectionFactoryDefinition(registerRuntimeOnly));\n        // getJNDIBindings (no -- same as \"entries\")\n\n        // Resource Adapter Pooled connection factories\n        serverRegistration.registerSubModel(new PooledConnectionFactoryDefinition(registerRuntimeOnly));\n        // TODO how do ConnectionFactoryControl things relate?\n\n        // JMS Queues\n        serverRegistration.registerSubModel(new JMSQueueDefinition(registerRuntimeOnly));\n        // setExpiryAddress, setDeadLetterAddress  -- no -- just toggle the 'queue-address', make this a mutable attr of address-setting\n        // getJNDIBindings (no -- same as \"entries\")\n\n        // JMS Topics\n        serverRegistration.registerSubModel(new JMSTopicDefinition(registerRuntimeOnly));\n        // getJNDIBindings (no -- same as \"entries\")\n\n        serverRegistration.registerSubModel(new SecuritySettingDefinition(registerRuntimeOnly));\n\n        if (registerRuntimeOnly) {\n\n            ResourceDefinition deploymentsDef = new SimpleResourceDefinition(SUBSYSTEM_PATH, getResourceDescriptionResolver(\"deployed\"));\n            final ManagementResourceRegistration deploymentsRegistration = subsystem.registerDeploymentModel(deploymentsDef);\n            final ManagementResourceRegistration serverModel = deploymentsRegistration.registerSubModel(new HornetQServerResourceDefinition(true));\n\n            serverModel.registerSubModel(JMSQueueDefinition.newDeployedJMSQueueDefinition());\n            serverModel.registerSubModel(JMSTopicDefinition.newDeployedJMSTopicDefinition());\n        }\n\n        // JMS Bridges\n        rootRegistration.registerSubModel(new JMSBridgeDefinition());\n\n        registerTransformers_1_1_0(subsystem);\n    }","id":102086,"modified_method":"public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME,\n                MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION,\n                MANAGEMENT_API_MICRO_VERSION);\n        subsystem.registerXMLElementWriter(MessagingXMLWriter.INSTANCE);\n\n        boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();\n\n        // Root resource\n        final ManagementResourceRegistration rootRegistration = subsystem.registerSubsystemModel(MessagingSubsystemRootResourceDefinition.INSTANCE);\n        rootRegistration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);\n\n        // HQ servers\n        final ManagementResourceRegistration serverRegistration = rootRegistration.registerSubModel(new HornetQServerResourceDefinition(registerRuntimeOnly));\n\n        // Runtime addresses\n        if (registerRuntimeOnly) {\n            final ManagementResourceRegistration coreAddress = serverRegistration.registerSubModel(new CoreAddressDefinition());\n            coreAddress.setRuntimeOnly(true);\n        }\n\n        // Address settings\n        serverRegistration.registerSubModel(new AddressSettingDefinition(registerRuntimeOnly));\n\n        // Broadcast groups\n        serverRegistration.registerSubModel(new BroadcastGroupDefinition(registerRuntimeOnly));\n        // getConnectorPairs, -- no, this is just the same as attribute connector-refs\n\n        // Discovery groups\n        serverRegistration.registerSubModel(new DiscoveryGroupDefinition(registerRuntimeOnly));\n\n        // Diverts\n        serverRegistration.registerSubModel(new DivertDefinition(registerRuntimeOnly));\n\n        // Core queues\n        serverRegistration.registerSubModel(new QueueDefinition(registerRuntimeOnly));\n        // getExpiryAddress, setExpiryAddress, getDeadLetterAddress, setDeadLetterAddress  -- no -- just toggle the 'queue-address', make this a mutable attr of address-setting\n\n        // Acceptors\n        serverRegistration.registerSubModel(GenericTransportDefinition.createAcceptorDefinition(registerRuntimeOnly));\n        serverRegistration.registerSubModel(RemoteTransportDefinition.createAcceptorDefinition(registerRuntimeOnly));\n        serverRegistration.registerSubModel(InVMTransportDefinition.createAcceptorDefinition(registerRuntimeOnly));\n\n        // Connectors\n        serverRegistration.registerSubModel(GenericTransportDefinition.createConnectorDefinition(registerRuntimeOnly));\n        serverRegistration.registerSubModel(RemoteTransportDefinition.createConnectorDefinition(registerRuntimeOnly));\n        serverRegistration.registerSubModel(InVMTransportDefinition.createConnectorDefinition(registerRuntimeOnly));\n\n        // Bridges\n        serverRegistration.registerSubModel(new BridgeDefinition(registerRuntimeOnly));\n\n        // Cluster connections\n        serverRegistration.registerSubModel(new ClusterConnectionDefinition(registerRuntimeOnly));\n\n        // Grouping Handler\n        serverRegistration.registerSubModel(new GroupingHandlerDefinition(registerRuntimeOnly));\n\n        // Connector services\n        serverRegistration.registerSubModel(new ConnectorServiceDefinition(registerRuntimeOnly));\n\n        // Messaging paths\n        //todo, shouldn't we leverage Path service from AS? see: package org.jboss.as.controller.services.path\n        for (final String path : MessagingPathHandlers.PATHS.keySet()) {\n            ManagementResourceRegistration bindings = serverRegistration.registerSubModel(PathElement.pathElement(PATH, path),\n                    new MessagingSubsystemProviders.PathProvider(path));\n            MessagingPathHandlers.register(bindings, path);\n        }\n\n        // Connection factories\n        serverRegistration.registerSubModel(new ConnectionFactoryDefinition(registerRuntimeOnly));\n        // getJNDIBindings (no -- same as \"entries\")\n\n        // Resource Adapter Pooled connection factories\n        serverRegistration.registerSubModel(new PooledConnectionFactoryDefinition(registerRuntimeOnly));\n        // TODO how do ConnectionFactoryControl things relate?\n\n        // JMS Queues\n        serverRegistration.registerSubModel(new JMSQueueDefinition(registerRuntimeOnly));\n        // setExpiryAddress, setDeadLetterAddress  -- no -- just toggle the 'queue-address', make this a mutable attr of address-setting\n        // getJNDIBindings (no -- same as \"entries\")\n\n        // JMS Topics\n        serverRegistration.registerSubModel(new JMSTopicDefinition(registerRuntimeOnly));\n        // getJNDIBindings (no -- same as \"entries\")\n\n        serverRegistration.registerSubModel(new SecuritySettingDefinition(registerRuntimeOnly));\n\n        if (registerRuntimeOnly) {\n\n            ResourceDefinition deploymentsDef = new SimpleResourceDefinition(SUBSYSTEM_PATH, getResourceDescriptionResolver(\"deployed\"));\n            final ManagementResourceRegistration deploymentsRegistration = subsystem.registerDeploymentModel(deploymentsDef);\n            final ManagementResourceRegistration serverModel = deploymentsRegistration.registerSubModel(new HornetQServerResourceDefinition(true));\n\n            serverModel.registerSubModel(JMSQueueDefinition.newDeployedJMSQueueDefinition());\n            serverModel.registerSubModel(JMSTopicDefinition.newDeployedJMSTopicDefinition());\n        }\n\n        // JMS Bridges\n        rootRegistration.registerSubModel(new JMSBridgeDefinition());\n\n        registerTransformers_1_1_0(subsystem);\n    }","commit_id":"8cd95138cfa007f749a41daf524d9313ba89c9ac","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void registerTransformers_1_1_0(final SubsystemRegistration subsystem) {\n        final ModelVersion version_1_1_0 = ModelVersion.create(1, 1, 0);\n        final TransformersSubRegistration transformers = subsystem.registerModelTransformers(version_1_1_0, new AbstractSubsystemTransformer(SUBSYSTEM_NAME) {\n\n            @Override\n            public ModelNode transformModel(final TransformationContext context, final ModelNode model) {\n                ModelNode oldModel = model.clone();\n                if (oldModel.hasDefined(HORNETQ_SERVER)) {\n                    for (Property server : oldModel.get(HORNETQ_SERVER).asPropertyList()) {\n                        if (server.getValue().hasDefined(POOLED_CONNECTION_FACTORY)) {\n                            for (Property pooledConnectionFactory : server.getValue().get(POOLED_CONNECTION_FACTORY).asPropertyList()) {\n                                oldModel.get(HORNETQ_SERVER, server.getName(), POOLED_CONNECTION_FACTORY, pooledConnectionFactory.getName()).remove(Pooled.INITIAL_CONNECT_ATTEMPTS.getName());\n                                oldModel.get(HORNETQ_SERVER, server.getName(), POOLED_CONNECTION_FACTORY, pooledConnectionFactory.getName()).remove(Pooled.INITIAL_MESSAGE_PACKET_SIZE.getName());\n                                oldModel.get(HORNETQ_SERVER, server.getName(), POOLED_CONNECTION_FACTORY, pooledConnectionFactory.getName()).remove(Pooled.USE_AUTO_RECOVERY.getName());\n                                oldModel.get(HORNETQ_SERVER, server.getName(), POOLED_CONNECTION_FACTORY, pooledConnectionFactory.getName()).remove(Common.COMPRESS_LARGE_MESSAGES.getName());\n                            }\n                        }\n                        if (server.getValue().hasDefined(CONNECTION_FACTORY)) {\n                            for (Property connectionFactory : server.getValue().get(CONNECTION_FACTORY).asPropertyList()) {\n                                if (!connectionFactory.getValue().hasDefined(HA.getName())) {\n                                    oldModel.get(HORNETQ_SERVER, server.getName(), CONNECTION_FACTORY, connectionFactory.getName()).get(HA.getName()).set(HA.getDefaultValue());\n                                }\n                                if (connectionFactory.getValue().hasDefined(FACTORY_TYPE.getName()) && (connectionFactory.getValue().get(FACTORY_TYPE.getName()).equals(FACTORY_TYPE.getDefaultValue()))) {\n                                    oldModel.get(HORNETQ_SERVER, server.getName(), CONNECTION_FACTORY, connectionFactory.getName()).get(FACTORY_TYPE.getName()).set(new ModelNode());\n                                }\n                            }\n                        }\n                    }\n                }\n                return oldModel;\n            }\n        });\n\n        TransformersSubRegistration server = transformers.registerSubResource(PathElement.pathElement(CommonAttributes.HORNETQ_SERVER));\n        server.registerOperationTransformer(ADD, new OperationTransformer() {\n            @Override\n            public TransformedOperation transformOperation(TransformationContext context, PathAddress address, ModelNode operation)\n                    throws OperationFailedException {\n                if (!operation.hasDefined(ID_CACHE_SIZE.getName())) {\n                    operation.get(ID_CACHE_SIZE.getName()).set(ID_CACHE_SIZE.getDefaultValue());\n                }\n                return new TransformedOperation(operation, ORIGINAL_RESULT);\n            }\n        });\n\n        RejectExpressionValuesTransformer rejectTransportParamExpressionTransformer = new RejectExpressionValuesTransformer(VALUE);\n        final String[] transports = { CommonAttributes.ACCEPTOR, CommonAttributes.REMOTE_ACCEPTOR, CommonAttributes.IN_VM_ACCEPTOR,\n                CommonAttributes.CONNECTOR, CommonAttributes.REMOTE_CONNECTOR, CommonAttributes.IN_VM_CONNECTOR };\n        for (String transport : transports) {\n            TransformersSubRegistration remoteConnector = server.registerSubResource(PathElement.pathElement(transport));\n            TransformersSubRegistration transportParam = remoteConnector.registerSubResource(PathElement.pathElement(PARAM));\n            transportParam.registerOperationTransformer(ADD, rejectTransportParamExpressionTransformer);\n            transportParam.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, rejectTransportParamExpressionTransformer.getWriteAttributeTransformer());\n        }\n\n        RejectExpressionValuesTransformer rejectExpressionTransformer = new RejectExpressionValuesTransformer(PATH);\n        for (final String path : MessagingPathHandlers.PATHS) {\n            TransformersSubRegistration pathRegistration = server.registerSubResource(PathElement.pathElement(PATH, path), rejectExpressionTransformer, rejectExpressionTransformer);\n            pathRegistration.registerOperationTransformer(ADD, rejectExpressionTransformer);\n            pathRegistration.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, rejectExpressionTransformer.getWriteAttributeTransformer());\n        }\n        TransformersSubRegistration pooledConnectionFactory = server.registerSubResource(PooledConnectionFactoryDefinition.PATH);\n        pooledConnectionFactory.registerOperationTransformer(ADD, new OperationTransformer() {\n            @Override\n            public TransformedOperation transformOperation(final TransformationContext context, final PathAddress address, final ModelNode operation)\n                    throws OperationFailedException {\n                final ModelNode transformedOperation = operation.clone();\n                transformedOperation.remove(Pooled.INITIAL_CONNECT_ATTEMPTS.getName());\n                transformedOperation.remove(Pooled.INITIAL_MESSAGE_PACKET_SIZE.getName());\n                transformedOperation.remove(Pooled.USE_AUTO_RECOVERY.getName());\n                transformedOperation.remove(Common.COMPRESS_LARGE_MESSAGES.getName());\n                if (!transformedOperation.hasDefined(RECONNECT_ATTEMPTS.getName())) {\n                    transformedOperation.get(RECONNECT_ATTEMPTS.getName()).set(RECONNECT_ATTEMPTS.getDefaultValue());\n                }\n\n                return new TransformedOperation(transformedOperation, ORIGINAL_RESULT);\n            }\n        });\n        pooledConnectionFactory.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new OperationTransformer() {\n            @Override\n            public TransformedOperation transformOperation(final TransformationContext context, final PathAddress address, final ModelNode operation)\n                    throws OperationFailedException {\n\n                OperationResultTransformer resultTransformer = ORIGINAL_RESULT;\n                final List<String> found = new ArrayList<String>();\n\n                String[] unsupportedAttributes = {\n                        Pooled.INITIAL_CONNECT_ATTEMPTS.getName(),\n                        Pooled.INITIAL_MESSAGE_PACKET_SIZE.getName(),\n                        Pooled.USE_AUTO_RECOVERY.getName(),\n                        Common.COMPRESS_LARGE_MESSAGES.getName()};\n                for (String attrName : unsupportedAttributes) {\n                    if (operation.require(NAME).asString().equals(attrName)) {\n                        if (found.size() == 0) {\n                            // Transform the result into a failure if the op wasn't ignored\n                            resultTransformer = new OperationResultTransformer() {\n                                @Override\n                                public ModelNode transformResult(ModelNode result) {\n                                    ModelNode transformed = result;\n                                    if (!IGNORED.equals(result.get(OUTCOME).asString())) {\n                                        transformed = new ModelNode();\n                                        transformed.get(OUTCOME).set(FAILED);\n                                        transformed.get(FAILURE_DESCRIPTION).set(MessagingMessages.MESSAGES.unsupportedAttributeInVersion(found.toString(), version_1_1_0));\n                                    }\n                                    return transformed;\n                                }\n                            };\n                        }\n                        found.add(attrName);\n                    }\n                }\n\n                return new TransformedOperation(operation, resultTransformer);\n            }\n        });\n    }","id":102087,"modified_method":"private static void registerTransformers_1_1_0(final SubsystemRegistration subsystem) {\n        final ModelVersion version_1_1_0 = ModelVersion.create(1, 1, 0);\n        final TransformersSubRegistration transformers = subsystem.registerModelTransformers(version_1_1_0, new AbstractSubsystemTransformer(SUBSYSTEM_NAME) {\n\n            @Override\n            public ModelNode transformModel(final TransformationContext context, final ModelNode model) {\n                ModelNode oldModel = model.clone();\n                if (oldModel.hasDefined(HORNETQ_SERVER)) {\n                    for (Property server : oldModel.get(HORNETQ_SERVER).asPropertyList()) {\n                        if (server.getValue().hasDefined(POOLED_CONNECTION_FACTORY)) {\n                            for (Property pooledConnectionFactory : server.getValue().get(POOLED_CONNECTION_FACTORY).asPropertyList()) {\n                                oldModel.get(HORNETQ_SERVER, server.getName(), POOLED_CONNECTION_FACTORY, pooledConnectionFactory.getName()).remove(Pooled.INITIAL_CONNECT_ATTEMPTS.getName());\n                                oldModel.get(HORNETQ_SERVER, server.getName(), POOLED_CONNECTION_FACTORY, pooledConnectionFactory.getName()).remove(Pooled.INITIAL_MESSAGE_PACKET_SIZE.getName());\n                                oldModel.get(HORNETQ_SERVER, server.getName(), POOLED_CONNECTION_FACTORY, pooledConnectionFactory.getName()).remove(Pooled.USE_AUTO_RECOVERY.getName());\n                                oldModel.get(HORNETQ_SERVER, server.getName(), POOLED_CONNECTION_FACTORY, pooledConnectionFactory.getName()).remove(Common.COMPRESS_LARGE_MESSAGES.getName());\n                            }\n                        }\n                        if (server.getValue().hasDefined(CONNECTION_FACTORY)) {\n                            for (Property connectionFactory : server.getValue().get(CONNECTION_FACTORY).asPropertyList()) {\n                                if (!connectionFactory.getValue().hasDefined(HA.getName())) {\n                                    oldModel.get(HORNETQ_SERVER, server.getName(), CONNECTION_FACTORY, connectionFactory.getName()).get(HA.getName()).set(HA.getDefaultValue());\n                                }\n                                if (connectionFactory.getValue().hasDefined(FACTORY_TYPE.getName()) && (connectionFactory.getValue().get(FACTORY_TYPE.getName()).equals(FACTORY_TYPE.getDefaultValue()))) {\n                                    oldModel.get(HORNETQ_SERVER, server.getName(), CONNECTION_FACTORY, connectionFactory.getName()).get(FACTORY_TYPE.getName()).set(new ModelNode());\n                                }\n                            }\n                        }\n                    }\n                }\n                return oldModel;\n            }\n        });\n\n        TransformersSubRegistration server = transformers.registerSubResource(PathElement.pathElement(CommonAttributes.HORNETQ_SERVER));\n        server.registerOperationTransformer(ADD, new OperationTransformer() {\n            @Override\n            public TransformedOperation transformOperation(TransformationContext context, PathAddress address, ModelNode operation)\n                    throws OperationFailedException {\n                if (!operation.hasDefined(ID_CACHE_SIZE.getName())) {\n                    operation.get(ID_CACHE_SIZE.getName()).set(ID_CACHE_SIZE.getDefaultValue());\n                }\n                return new TransformedOperation(operation, ORIGINAL_RESULT);\n            }\n        });\n\n        RejectExpressionValuesTransformer rejectTransportParamExpressionTransformer = new RejectExpressionValuesTransformer(VALUE);\n        final String[] transports = { CommonAttributes.ACCEPTOR, CommonAttributes.REMOTE_ACCEPTOR, CommonAttributes.IN_VM_ACCEPTOR,\n                CommonAttributes.CONNECTOR, CommonAttributes.REMOTE_CONNECTOR, CommonAttributes.IN_VM_CONNECTOR };\n        for (String transport : transports) {\n            TransformersSubRegistration remoteConnector = server.registerSubResource(PathElement.pathElement(transport));\n            TransformersSubRegistration transportParam = remoteConnector.registerSubResource(PathElement.pathElement(PARAM));\n            transportParam.registerOperationTransformer(ADD, rejectTransportParamExpressionTransformer);\n            transportParam.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, rejectTransportParamExpressionTransformer.getWriteAttributeTransformer());\n        }\n\n        RejectExpressionValuesTransformer rejectExpressionTransformer = new RejectExpressionValuesTransformer(PATH);\n        for (final String path : MessagingPathHandlers.PATHS.keySet()) {\n            TransformersSubRegistration pathRegistration = server.registerSubResource(PathElement.pathElement(PATH, path), rejectExpressionTransformer, rejectExpressionTransformer);\n            pathRegistration.registerOperationTransformer(ADD, rejectExpressionTransformer);\n            pathRegistration.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, rejectExpressionTransformer.getWriteAttributeTransformer());\n        }\n        TransformersSubRegistration pooledConnectionFactory = server.registerSubResource(PooledConnectionFactoryDefinition.PATH);\n        pooledConnectionFactory.registerOperationTransformer(ADD, new OperationTransformer() {\n            @Override\n            public TransformedOperation transformOperation(final TransformationContext context, final PathAddress address, final ModelNode operation)\n                    throws OperationFailedException {\n                final ModelNode transformedOperation = operation.clone();\n                transformedOperation.remove(Pooled.INITIAL_CONNECT_ATTEMPTS.getName());\n                transformedOperation.remove(Pooled.INITIAL_MESSAGE_PACKET_SIZE.getName());\n                transformedOperation.remove(Pooled.USE_AUTO_RECOVERY.getName());\n                transformedOperation.remove(Common.COMPRESS_LARGE_MESSAGES.getName());\n                if (!transformedOperation.hasDefined(RECONNECT_ATTEMPTS.getName())) {\n                    transformedOperation.get(RECONNECT_ATTEMPTS.getName()).set(RECONNECT_ATTEMPTS.getDefaultValue());\n                }\n\n                return new TransformedOperation(transformedOperation, ORIGINAL_RESULT);\n            }\n        });\n        pooledConnectionFactory.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new OperationTransformer() {\n            @Override\n            public TransformedOperation transformOperation(final TransformationContext context, final PathAddress address, final ModelNode operation)\n                    throws OperationFailedException {\n\n                OperationResultTransformer resultTransformer = ORIGINAL_RESULT;\n                final List<String> found = new ArrayList<String>();\n\n                String[] unsupportedAttributes = {\n                        Pooled.INITIAL_CONNECT_ATTEMPTS.getName(),\n                        Pooled.INITIAL_MESSAGE_PACKET_SIZE.getName(),\n                        Pooled.USE_AUTO_RECOVERY.getName(),\n                        Common.COMPRESS_LARGE_MESSAGES.getName()};\n                for (String attrName : unsupportedAttributes) {\n                    if (operation.require(NAME).asString().equals(attrName)) {\n                        if (found.size() == 0) {\n                            // Transform the result into a failure if the op wasn't ignored\n                            resultTransformer = new OperationResultTransformer() {\n                                @Override\n                                public ModelNode transformResult(ModelNode result) {\n                                    ModelNode transformed = result;\n                                    if (!IGNORED.equals(result.get(OUTCOME).asString())) {\n                                        transformed = new ModelNode();\n                                        transformed.get(OUTCOME).set(FAILED);\n                                        transformed.get(FAILURE_DESCRIPTION).set(MessagingMessages.MESSAGES.unsupportedAttributeInVersion(found.toString(), version_1_1_0));\n                                    }\n                                    return transformed;\n                                }\n                            };\n                        }\n                        found.add(attrName);\n                    }\n                }\n\n                return new TransformedOperation(operation, resultTransformer);\n            }\n        });\n    }","commit_id":"8cd95138cfa007f749a41daf524d9313ba89c9ac","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void register(final ManagementResourceRegistration registration) {\n        registration.registerOperationHandler(ADD, PATH_ADD, MessagingSubsystemProviders.PATH_ADD);\n        registration.registerOperationHandler(REMOVE, PATH_REMOVE, MessagingSubsystemProviders.PATH_REMOVE);\n        for(final AttributeDefinition def : ATTRIBUTES) {\n            registration.registerReadWriteAttribute(def, null, PATH_ATTR);\n        }\n    }","id":102088,"modified_method":"static void register(final ManagementResourceRegistration registration, final String path) {\n        registration.registerOperationHandler(ADD, PATH_ADD, new MessagingSubsystemProviders.PathAddProvider(path));\n        registration.registerOperationHandler(REMOVE, PATH_REMOVE, MessagingSubsystemProviders.PATH_REMOVE);\n\n        AttributeDefinition[] attributes = getAttributes(path);\n        OperationStepHandler attributeHandler = new ReloadRequiredWriteAttributeHandler(attributes);\n        for (AttributeDefinition attribute : attributes) {\n            registration.registerReadWriteAttribute(attribute, null, attributeHandler);\n        }\n    }","commit_id":"8cd95138cfa007f749a41daf524d9313ba89c9ac","url":"https://github.com/wildfly/wildfly"},{"original_method":"public PathProvider(String pathType) {\n            this.pathType = pathType;\n        }","id":102089,"modified_method":"public PathProvider(String path) {\n            this.path = path;\n        }","commit_id":"8cd95138cfa007f749a41daf524d9313ba89c9ac","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public ModelNode getModelDescription(Locale locale) {\n            return MessagingDescriptions.getPathResource(locale, pathType);\n        }","id":102090,"modified_method":"@Override\n        public ModelNode getModelDescription(Locale locale) {\n            return MessagingDescriptions.getPathResource(locale, path);\n        }","commit_id":"8cd95138cfa007f749a41daf524d9313ba89c9ac","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeDirectory(final XMLExtendedStreamWriter writer, final Element element, final ModelNode node) throws XMLStreamException {\n        final String localName = element.getLocalName();\n        if(node.hasDefined(localName)) {\n            final String path = node.get(localName).has(PATH.getName()) ? node.get(localName, PATH.getName()).asString() : null;\n            final String relativeTo = node.get(localName).hasDefined(RELATIVE_TO.getName()) ? node.get(localName, RELATIVE_TO.getName()).asString() : null;\n            if(path != null || relativeTo != null) {\n                writer.writeEmptyElement(localName);\n                if(path != null) writer.writeAttribute(PATH.getName(), path);\n                RELATIVE_TO.marshallAsAttribute(node.get(localName), writer);\n            }\n        }\n    }","id":102091,"modified_method":"private static void writeDirectory(final XMLExtendedStreamWriter writer, final Element element, final ModelNode node) throws XMLStreamException {\n        final String localName = element.getLocalName();\n        if(node.hasDefined(localName)) {\n            final ModelNode localNode = node.get(localName);\n            if (RELATIVE_TO.isMarshallable(localNode) ||  PATHS.get(localName).isMarshallable(localNode)) {\n                writer.writeEmptyElement(localName);\n                PATHS.get(localName).marshallAsAttribute(node.get(localName), writer);\n                RELATIVE_TO.marshallAsAttribute(node.get(localName), writer);\n            }\n        }\n    }","commit_id":"8cd95138cfa007f749a41daf524d9313ba89c9ac","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected ModelNode createConnectionFactory(XMLExtendedStreamReader reader, ModelNode connectionFactory, boolean pooled) throws XMLStreamException\n    {\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            if (!seen.add(element)) {\n                throw ParseUtils.duplicateNamedElement(reader, element.getLocalName());\n            }\n            switch(element) {\n                // =========================================================\n                // elements common to regular & pooled connection factories\n                case DISCOVERY_GROUP_REF: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.DISCOVERY_GROUP_REF, Element.CONNECTORS);\n                    final String groupRef = readStringAttributeElement(reader, DISCOVERY_GROUP_NAME.getXmlName());\n                    DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef, connectionFactory, reader);\n                    break;\n                } case CONNECTORS: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.CONNECTORS, Element.DISCOVERY_GROUP_REF);\n                    connectionFactory.get(CONNECTOR).set(processJmsConnectors(reader));\n                    break;\n                } case ENTRIES: {\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        if(local != Element.ENTRY ) {\n                            throw ParseUtils.unexpectedElement(reader);\n                        }\n                        final String entry = readStringAttributeElement(reader, CommonAttributes.NAME);\n                        JndiEntriesAttribute.CONNECTION_FACTORY.parseAndAddParameterElement(entry, connectionFactory, reader);\n                    }\n                    break;\n                }\n                case HA:\n                case CLIENT_FAILURE_CHECK_PERIOD:\n                case CALL_TIMEOUT:\n                case CONSUMER_WINDOW_SIZE:\n                case CONSUMER_MAX_RATE:\n                case CONFIRMATION_WINDOW_SIZE:\n                case PRODUCER_WINDOW_SIZE:\n                case PRODUCER_MAX_RATE:\n                case CACHE_LARGE_MESSAGE_CLIENT:\n                case CLIENT_ID:\n                case DUPS_OK_BATCH_SIZE:\n                case TRANSACTION_BATH_SIZE:\n                case BLOCK_ON_ACK:\n                case BLOCK_ON_NON_DURABLE_SEND:\n                case BLOCK_ON_DURABLE_SEND:\n                case AUTO_GROUP:\n                case PRE_ACK:\n                case FAILOVER_ON_INITIAL_CONNECTION:\n                case FAILOVER_ON_SERVER_SHUTDOWN:\n                case LOAD_BALANCING_CLASS_NAME:\n                case USE_GLOBAL_POOLS:\n                case GROUP_ID:\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                case CONNECTION_TTL:\n                case MAX_RETRY_INTERVAL:\n                case MIN_LARGE_MESSAGE_SIZE:\n                case RECONNECT_ATTEMPTS:\n                case RETRY_INTERVAL:\n                case RETRY_INTERVAL_MULTIPLIER:\n                case SCHEDULED_THREAD_POOL_MAX_SIZE:\n                case THREAD_POOL_MAX_SIZE:\n                    // Use the \"connection\" variant\n                    handleElementText(reader, element, \"connection\", connectionFactory);\n                    break;\n                // end of common elements\n                // =========================================================\n\n                // =========================================================\n                // elements specific to regular (non-pooled) connection factories\n                case CONNECTION_FACTORY_TYPE:\n                    if(pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                // end of regular CF elements\n                // =========================================================\n\n                // =========================================================\n                // elements specific to pooled connection factories\n                case INBOUND_CONFIG: {\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        switch (local) {\n                            case USE_JNDI:\n                            case JNDI_PARAMS:\n                            case USE_LOCAL_TX:\n                            case SETUP_ATTEMPTS:\n                            case SETUP_INTERVAL:\n                                handleElementText(reader, local, connectionFactory);\n                                break;\n                            default:\n                                throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                } case TRANSACTION: {\n                    if(!pooled) {\n                        throw ParseUtils.unexpectedElement(reader);\n                    }\n                    final String txType = reader.getAttributeValue(0);\n                    if( txType != null) {\n                        connectionFactory.get(TRANSACTION).set(txType);\n                    }\n                    ParseUtils.requireNoContent(reader);\n                    break;\n                }\n                case USER:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    Pooled.USER.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                case PASSWORD:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    Pooled.PASSWORD.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                case MAX_POOL_SIZE:\n                case MIN_POOL_SIZE:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                // end of pooled CF elements\n                // =========================================================\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        checkOnlyOneOfElements(reader, seen, Element.CONNECTORS, Element.DISCOVERY_GROUP_REF);\n\n        return connectionFactory;\n    }","id":102092,"modified_method":"protected ModelNode createConnectionFactory(XMLExtendedStreamReader reader, ModelNode connectionFactory, boolean pooled) throws XMLStreamException\n    {\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            if (!seen.add(element)) {\n                throw ParseUtils.duplicateNamedElement(reader, element.getLocalName());\n            }\n            switch(element) {\n                // =========================================================\n                // elements common to regular & pooled connection factories\n                case DISCOVERY_GROUP_REF: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.DISCOVERY_GROUP_REF, Element.CONNECTORS);\n                    final String groupRef = readStringAttributeElement(reader, DISCOVERY_GROUP_NAME.getXmlName());\n                    DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef, connectionFactory, reader);\n                    break;\n                } case CONNECTORS: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.CONNECTORS, Element.DISCOVERY_GROUP_REF);\n                    connectionFactory.get(CONNECTOR).set(processJmsConnectors(reader));\n                    break;\n                } case ENTRIES: {\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        if(local != Element.ENTRY ) {\n                            throw ParseUtils.unexpectedElement(reader);\n                        }\n                        final String entry = readStringAttributeElement(reader, CommonAttributes.NAME);\n                        JndiEntriesAttribute.CONNECTION_FACTORY.parseAndAddParameterElement(entry, connectionFactory, reader);\n                    }\n                    break;\n                }\n                case HA:\n                case CLIENT_FAILURE_CHECK_PERIOD:\n                case CALL_TIMEOUT:\n                case CONSUMER_WINDOW_SIZE:\n                case CONSUMER_MAX_RATE:\n                case CONFIRMATION_WINDOW_SIZE:\n                case PRODUCER_WINDOW_SIZE:\n                case PRODUCER_MAX_RATE:\n                case CACHE_LARGE_MESSAGE_CLIENT:\n                case CLIENT_ID:\n                case DUPS_OK_BATCH_SIZE:\n                case TRANSACTION_BATH_SIZE:\n                case BLOCK_ON_ACK:\n                case BLOCK_ON_NON_DURABLE_SEND:\n                case BLOCK_ON_DURABLE_SEND:\n                case AUTO_GROUP:\n                case PRE_ACK:\n                case FAILOVER_ON_INITIAL_CONNECTION:\n                case FAILOVER_ON_SERVER_SHUTDOWN:\n                case LOAD_BALANCING_CLASS_NAME:\n                case USE_GLOBAL_POOLS:\n                case GROUP_ID:\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                case CONNECTION_TTL:\n                case MAX_RETRY_INTERVAL:\n                case MIN_LARGE_MESSAGE_SIZE:\n                case RECONNECT_ATTEMPTS:\n                case RETRY_INTERVAL:\n                case RETRY_INTERVAL_MULTIPLIER:\n                case SCHEDULED_THREAD_POOL_MAX_SIZE:\n                case THREAD_POOL_MAX_SIZE:\n                    // Use the \"connection\" variant\n                    handleElementText(reader, element, \"connection\", connectionFactory);\n                    break;\n                // end of common elements\n                // =========================================================\n\n                // =========================================================\n                // elements specific to regular (non-pooled) connection factories\n                case CONNECTION_FACTORY_TYPE:\n                    if(pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                // end of regular CF elements\n                // =========================================================\n\n                // =========================================================\n                // elements specific to pooled connection factories\n                case INBOUND_CONFIG: {\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        switch (local) {\n                            case USE_JNDI:\n                            case JNDI_PARAMS:\n                            case USE_LOCAL_TX:\n                            case SETUP_ATTEMPTS:\n                            case SETUP_INTERVAL:\n                                handleElementText(reader, local, connectionFactory);\n                                break;\n                            default:\n                                throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                } case TRANSACTION: {\n                    if(!pooled) {\n                        throw ParseUtils.unexpectedElement(reader);\n                    }\n                    final String txType = reader.getAttributeValue(0);\n                    if( txType != null) {\n                        connectionFactory.get(Pooled.TRANSACTION.getName()).set(txType);\n                    }\n                    ParseUtils.requireNoContent(reader);\n                    break;\n                }\n                case USER:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    Pooled.USER.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                case PASSWORD:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    Pooled.PASSWORD.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                case MAX_POOL_SIZE:\n                case MIN_POOL_SIZE:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                // end of pooled CF elements\n                // =========================================================\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        checkOnlyOneOfElements(reader, seen, Element.CONNECTORS, Element.DISCOVERY_GROUP_REF);\n\n        return connectionFactory;\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected ModelNode createConnectionFactory(XMLExtendedStreamReader reader, ModelNode connectionFactory, boolean pooled) throws XMLStreamException\n    {\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            if (!seen.add(element)) {\n                throw ParseUtils.duplicateNamedElement(reader, element.getLocalName());\n            }\n            switch(element) {\n                // =========================================================\n                // elements common to regular & pooled connection factories\n                case DISCOVERY_GROUP_REF: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.DISCOVERY_GROUP_REF, Element.CONNECTORS);\n                    final String groupRef = readStringAttributeElement(reader, DISCOVERY_GROUP_NAME.getXmlName());\n                    DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef, connectionFactory, reader);\n                    break;\n                } case CONNECTORS: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.CONNECTORS, Element.DISCOVERY_GROUP_REF);\n                    connectionFactory.get(CONNECTOR).set(processJmsConnectors(reader));\n                    break;\n                } case ENTRIES: {\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        if(local != Element.ENTRY ) {\n                            throw ParseUtils.unexpectedElement(reader);\n                        }\n                        final String entry = readStringAttributeElement(reader, CommonAttributes.NAME);\n                        JndiEntriesAttribute.CONNECTION_FACTORY.parseAndAddParameterElement(entry, connectionFactory, reader);\n                    }\n                    break;\n                }\n                case HA:\n                case CLIENT_FAILURE_CHECK_PERIOD:\n                case CALL_TIMEOUT:\n                case COMPRESS_LARGE_MESSAGES:\n                case CONSUMER_WINDOW_SIZE:\n                case CONSUMER_MAX_RATE:\n                case CONFIRMATION_WINDOW_SIZE:\n                case PRODUCER_WINDOW_SIZE:\n                case PRODUCER_MAX_RATE:\n                case CACHE_LARGE_MESSAGE_CLIENT:\n                case CLIENT_ID:\n                case DUPS_OK_BATCH_SIZE:\n                case TRANSACTION_BATH_SIZE:\n                case BLOCK_ON_ACK:\n                case BLOCK_ON_NON_DURABLE_SEND:\n                case BLOCK_ON_DURABLE_SEND:\n                case AUTO_GROUP:\n                case PRE_ACK:\n                case FAILOVER_ON_INITIAL_CONNECTION:\n                case FAILOVER_ON_SERVER_SHUTDOWN:\n                case LOAD_BALANCING_CLASS_NAME:\n                case USE_GLOBAL_POOLS:\n                case GROUP_ID:\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                case CONNECTION_TTL:\n                case MAX_RETRY_INTERVAL:\n                case MIN_LARGE_MESSAGE_SIZE:\n                case RECONNECT_ATTEMPTS:\n                case RETRY_INTERVAL:\n                case RETRY_INTERVAL_MULTIPLIER:\n                case SCHEDULED_THREAD_POOL_MAX_SIZE:\n                case THREAD_POOL_MAX_SIZE:\n                    // Use the \"connection\" variant\n                    handleElementText(reader, element, \"connection\", connectionFactory);\n                    break;\n                // end of common elements\n                // =========================================================\n\n                // =========================================================\n                // elements specific to regular (non-pooled) connection factories\n                case CONNECTION_FACTORY_TYPE:\n                    if(pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                // end of regular CF elements\n                // =========================================================\n\n                // =========================================================\n                // elements specific to pooled connection factories\n                case INBOUND_CONFIG: {\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        switch (local) {\n                            case USE_JNDI:\n                            case JNDI_PARAMS:\n                            case USE_LOCAL_TX:\n                            case SETUP_ATTEMPTS:\n                            case SETUP_INTERVAL:\n                                handleElementText(reader, local, connectionFactory);\n                                break;\n                            default:\n                                throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                } case TRANSACTION: {\n                    if(!pooled) {\n                        throw ParseUtils.unexpectedElement(reader);\n                    }\n                    final String txType = reader.getAttributeValue(0);\n                    if( txType != null) {\n                        connectionFactory.get(TRANSACTION).set(txType);\n                    }\n                    ParseUtils.requireNoContent(reader);\n                    break;\n                }\n                case USER:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    Pooled.USER.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                case PASSWORD:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    Pooled.PASSWORD.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                case MAX_POOL_SIZE:\n                case MIN_POOL_SIZE:\n                case USE_AUTO_RECOVERY:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                // end of pooled CF elements\n                // =========================================================\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        checkOnlyOneOfElements(reader, seen, Element.CONNECTORS, Element.DISCOVERY_GROUP_REF);\n\n        return connectionFactory;\n    }","id":102093,"modified_method":"protected ModelNode createConnectionFactory(XMLExtendedStreamReader reader, ModelNode connectionFactory, boolean pooled) throws XMLStreamException\n    {\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            if (!seen.add(element)) {\n                throw ParseUtils.duplicateNamedElement(reader, element.getLocalName());\n            }\n            switch(element) {\n                // =========================================================\n                // elements common to regular & pooled connection factories\n                case DISCOVERY_GROUP_REF: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.DISCOVERY_GROUP_REF, Element.CONNECTORS);\n                    final String groupRef = readStringAttributeElement(reader, DISCOVERY_GROUP_NAME.getXmlName());\n                    DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef, connectionFactory, reader);\n                    break;\n                } case CONNECTORS: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.CONNECTORS, Element.DISCOVERY_GROUP_REF);\n                    connectionFactory.get(CONNECTOR).set(processJmsConnectors(reader));\n                    break;\n                } case ENTRIES: {\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        if(local != Element.ENTRY ) {\n                            throw ParseUtils.unexpectedElement(reader);\n                        }\n                        final String entry = readStringAttributeElement(reader, CommonAttributes.NAME);\n                        JndiEntriesAttribute.CONNECTION_FACTORY.parseAndAddParameterElement(entry, connectionFactory, reader);\n                    }\n                    break;\n                }\n                case HA:\n                case CLIENT_FAILURE_CHECK_PERIOD:\n                case CALL_TIMEOUT:\n                case COMPRESS_LARGE_MESSAGES:\n                case CONSUMER_WINDOW_SIZE:\n                case CONSUMER_MAX_RATE:\n                case CONFIRMATION_WINDOW_SIZE:\n                case PRODUCER_WINDOW_SIZE:\n                case PRODUCER_MAX_RATE:\n                case CACHE_LARGE_MESSAGE_CLIENT:\n                case CLIENT_ID:\n                case DUPS_OK_BATCH_SIZE:\n                case TRANSACTION_BATH_SIZE:\n                case BLOCK_ON_ACK:\n                case BLOCK_ON_NON_DURABLE_SEND:\n                case BLOCK_ON_DURABLE_SEND:\n                case AUTO_GROUP:\n                case PRE_ACK:\n                case FAILOVER_ON_INITIAL_CONNECTION:\n                case FAILOVER_ON_SERVER_SHUTDOWN:\n                case LOAD_BALANCING_CLASS_NAME:\n                case USE_GLOBAL_POOLS:\n                case GROUP_ID:\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                case CONNECTION_TTL:\n                case MAX_RETRY_INTERVAL:\n                case MIN_LARGE_MESSAGE_SIZE:\n                case RECONNECT_ATTEMPTS:\n                case RETRY_INTERVAL:\n                case RETRY_INTERVAL_MULTIPLIER:\n                case SCHEDULED_THREAD_POOL_MAX_SIZE:\n                case THREAD_POOL_MAX_SIZE:\n                    // Use the \"connection\" variant\n                    handleElementText(reader, element, \"connection\", connectionFactory);\n                    break;\n                // end of common elements\n                // =========================================================\n\n                // =========================================================\n                // elements specific to regular (non-pooled) connection factories\n                case CONNECTION_FACTORY_TYPE:\n                    if(pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                // end of regular CF elements\n                // =========================================================\n\n                // =========================================================\n                // elements specific to pooled connection factories\n                case INBOUND_CONFIG: {\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        switch (local) {\n                            case USE_JNDI:\n                            case JNDI_PARAMS:\n                            case USE_LOCAL_TX:\n                            case SETUP_ATTEMPTS:\n                            case SETUP_INTERVAL:\n                                handleElementText(reader, local, connectionFactory);\n                                break;\n                            default:\n                                throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                } case TRANSACTION: {\n                    if(!pooled) {\n                        throw ParseUtils.unexpectedElement(reader);\n                    }\n                    final String txType = reader.getAttributeValue(0);\n                    if( txType != null) {\n                        connectionFactory.get(Pooled.TRANSACTION.getName()).set(txType);\n                    }\n                    ParseUtils.requireNoContent(reader);\n                    break;\n                }\n                case USER:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    Pooled.USER.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                case PASSWORD:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    Pooled.PASSWORD.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                case MAX_POOL_SIZE:\n                case MIN_POOL_SIZE:\n                case USE_AUTO_RECOVERY:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                // end of pooled CF elements\n                // =========================================================\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        checkOnlyOneOfElements(reader, seen, Element.CONNECTORS, Element.DISCOVERY_GROUP_REF);\n\n        return connectionFactory;\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected ModelNode createConnectionFactory(XMLExtendedStreamReader reader, ModelNode connectionFactory, boolean pooled) throws XMLStreamException\n    {\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            if (!seen.add(element)) {\n                throw ParseUtils.duplicateNamedElement(reader, element.getLocalName());\n            }\n            switch(element) {\n                // =========================================================\n                // elements common to regular & pooled connection factories\n                case DISCOVERY_GROUP_REF: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.DISCOVERY_GROUP_REF, Element.CONNECTORS);\n                    final String groupRef = readStringAttributeElement(reader, DISCOVERY_GROUP_NAME.getXmlName());\n                    DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef, connectionFactory, reader);\n                    break;\n                } case CONNECTORS: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.CONNECTORS, Element.DISCOVERY_GROUP_REF);\n                    connectionFactory.get(CONNECTOR).set(processJmsConnectors(reader));\n                    break;\n                } case ENTRIES: {\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        if(local != Element.ENTRY ) {\n                            throw ParseUtils.unexpectedElement(reader);\n                        }\n                        final String entry = readStringAttributeElement(reader, CommonAttributes.NAME);\n                        JndiEntriesAttribute.CONNECTION_FACTORY.parseAndAddParameterElement(entry, connectionFactory, reader);\n                    }\n                    break;\n                }\n                case HA:\n                case CLIENT_FAILURE_CHECK_PERIOD:\n                case CALL_TIMEOUT:\n                case CONSUMER_WINDOW_SIZE:\n                case CONSUMER_MAX_RATE:\n                case CONFIRMATION_WINDOW_SIZE:\n                case PRODUCER_WINDOW_SIZE:\n                case PRODUCER_MAX_RATE:\n                case CACHE_LARGE_MESSAGE_CLIENT:\n                case CLIENT_ID:\n                case DUPS_OK_BATCH_SIZE:\n                case TRANSACTION_BATH_SIZE:\n                case BLOCK_ON_ACK:\n                case BLOCK_ON_NON_DURABLE_SEND:\n                case BLOCK_ON_DURABLE_SEND:\n                case AUTO_GROUP:\n                case PRE_ACK:\n                case FAILOVER_ON_INITIAL_CONNECTION:\n                case FAILOVER_ON_SERVER_SHUTDOWN:\n                case LOAD_BALANCING_CLASS_NAME:\n                case USE_GLOBAL_POOLS:\n                case GROUP_ID:\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                case CONNECTION_TTL:\n                case MAX_RETRY_INTERVAL:\n                case MIN_LARGE_MESSAGE_SIZE:\n                case RECONNECT_ATTEMPTS:\n                case RETRY_INTERVAL:\n                case RETRY_INTERVAL_MULTIPLIER:\n                case SCHEDULED_THREAD_POOL_MAX_SIZE:\n                case THREAD_POOL_MAX_SIZE:\n                    // Use the \"connection\" variant\n                    handleElementText(reader, element, \"connection\", connectionFactory);\n                    break;\n                case DISCOVERY_INITIAL_WAIT_TIMEOUT:\n                    MessagingLogger.ROOT_LOGGER.deprecatedXMLElement(element.toString());\n                    skipElementText(reader);\n                    break;\n                // end of common elements\n                // =========================================================\n\n                // =========================================================\n                // elements specific to regular (non-pooled) connection factories\n                case CONNECTION_FACTORY_TYPE:\n                    if(pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                // end of regular CF elements\n                // =========================================================\n\n                // =========================================================\n                // elements specific to pooled connection factories\n                case INBOUND_CONFIG: {\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        switch (local) {\n                            case USE_JNDI:\n                            case JNDI_PARAMS:\n                            case USE_LOCAL_TX:\n                            case SETUP_ATTEMPTS:\n                            case SETUP_INTERVAL:\n                                handleElementText(reader, local, connectionFactory);\n                                break;\n                            default:\n                                throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                } case TRANSACTION: {\n                    if(!pooled) {\n                        throw ParseUtils.unexpectedElement(reader);\n                    }\n                    final String txType = reader.getAttributeValue(0);\n                    if( txType != null) {\n                        connectionFactory.get(TRANSACTION).set(txType);\n                    }\n                    ParseUtils.requireNoContent(reader);\n                    break;\n                }\n                case USER:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    Pooled.USER.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                case PASSWORD:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    Pooled.PASSWORD.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                // end of pooled CF elements\n                // =========================================================\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        checkOnlyOneOfElements(reader, seen, Element.CONNECTORS, Element.DISCOVERY_GROUP_REF);\n\n        return connectionFactory;\n    }","id":102094,"modified_method":"protected ModelNode createConnectionFactory(XMLExtendedStreamReader reader, ModelNode connectionFactory, boolean pooled) throws XMLStreamException\n    {\n        Set<Element> seen = EnumSet.noneOf(Element.class);\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            if (!seen.add(element)) {\n                throw ParseUtils.duplicateNamedElement(reader, element.getLocalName());\n            }\n            switch(element) {\n                // =========================================================\n                // elements common to regular & pooled connection factories\n                case DISCOVERY_GROUP_REF: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.DISCOVERY_GROUP_REF, Element.CONNECTORS);\n                    final String groupRef = readStringAttributeElement(reader, DISCOVERY_GROUP_NAME.getXmlName());\n                    DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef, connectionFactory, reader);\n                    break;\n                } case CONNECTORS: {\n                    checkOtherElementIsNotAlreadyDefined(reader, seen, Element.CONNECTORS, Element.DISCOVERY_GROUP_REF);\n                    connectionFactory.get(CONNECTOR).set(processJmsConnectors(reader));\n                    break;\n                } case ENTRIES: {\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        if(local != Element.ENTRY ) {\n                            throw ParseUtils.unexpectedElement(reader);\n                        }\n                        final String entry = readStringAttributeElement(reader, CommonAttributes.NAME);\n                        JndiEntriesAttribute.CONNECTION_FACTORY.parseAndAddParameterElement(entry, connectionFactory, reader);\n                    }\n                    break;\n                }\n                case HA:\n                case CLIENT_FAILURE_CHECK_PERIOD:\n                case CALL_TIMEOUT:\n                case CONSUMER_WINDOW_SIZE:\n                case CONSUMER_MAX_RATE:\n                case CONFIRMATION_WINDOW_SIZE:\n                case PRODUCER_WINDOW_SIZE:\n                case PRODUCER_MAX_RATE:\n                case CACHE_LARGE_MESSAGE_CLIENT:\n                case CLIENT_ID:\n                case DUPS_OK_BATCH_SIZE:\n                case TRANSACTION_BATH_SIZE:\n                case BLOCK_ON_ACK:\n                case BLOCK_ON_NON_DURABLE_SEND:\n                case BLOCK_ON_DURABLE_SEND:\n                case AUTO_GROUP:\n                case PRE_ACK:\n                case FAILOVER_ON_INITIAL_CONNECTION:\n                case FAILOVER_ON_SERVER_SHUTDOWN:\n                case LOAD_BALANCING_CLASS_NAME:\n                case USE_GLOBAL_POOLS:\n                case GROUP_ID:\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                case CONNECTION_TTL:\n                case MAX_RETRY_INTERVAL:\n                case MIN_LARGE_MESSAGE_SIZE:\n                case RECONNECT_ATTEMPTS:\n                case RETRY_INTERVAL:\n                case RETRY_INTERVAL_MULTIPLIER:\n                case SCHEDULED_THREAD_POOL_MAX_SIZE:\n                case THREAD_POOL_MAX_SIZE:\n                    // Use the \"connection\" variant\n                    handleElementText(reader, element, \"connection\", connectionFactory);\n                    break;\n                case DISCOVERY_INITIAL_WAIT_TIMEOUT:\n                    MessagingLogger.ROOT_LOGGER.deprecatedXMLElement(element.toString());\n                    skipElementText(reader);\n                    break;\n                // end of common elements\n                // =========================================================\n\n                // =========================================================\n                // elements specific to regular (non-pooled) connection factories\n                case CONNECTION_FACTORY_TYPE:\n                    if(pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                // end of regular CF elements\n                // =========================================================\n\n                // =========================================================\n                // elements specific to pooled connection factories\n                case INBOUND_CONFIG: {\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        switch (local) {\n                            case USE_JNDI:\n                            case JNDI_PARAMS:\n                            case USE_LOCAL_TX:\n                            case SETUP_ATTEMPTS:\n                            case SETUP_INTERVAL:\n                                handleElementText(reader, local, connectionFactory);\n                                break;\n                            default:\n                                throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                } case TRANSACTION: {\n                    if(!pooled) {\n                        throw ParseUtils.unexpectedElement(reader);\n                    }\n                    final String txType = reader.getAttributeValue(0);\n                    if( txType != null) {\n                        connectionFactory.get(Pooled.TRANSACTION.getName()).set(txType);\n                    }\n                    ParseUtils.requireNoContent(reader);\n                    break;\n                }\n                case USER:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    Pooled.USER.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                case PASSWORD:\n                    if(!pooled) {\n                        throw unexpectedElement(reader);\n                    }\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    Pooled.PASSWORD.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                // end of pooled CF elements\n                // =========================================================\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n\n        checkOnlyOneOfElements(reader, seen, Element.CONNECTORS, Element.DISCOVERY_GROUP_REF);\n\n        return connectionFactory;\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeGroupingHandler(XMLExtendedStreamWriter writer, ModelNode node) throws XMLStreamException {\n\n        boolean wroteHandler = false;\n        for (Property handler : node.asPropertyList()) {\n            if (wroteHandler) {\n                throw MESSAGES.multipleChildrenFound(GROUPING_HANDLER);\n            } else {\n                wroteHandler = true;\n            }\n            writer.writeStartElement(Element.GROUPING_HANDLER.getLocalName());\n            writer.writeAttribute(Attribute.NAME.getLocalName(), handler.getName());\n            final ModelNode resourceModel = handler.getValue();\n            for (AttributeDefinition attr : GroupingHandlerDefinition.ATTRIBUTES) {\n                attr.marshallAsElement(resourceModel, writer);\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","id":102095,"modified_method":"private static void writeGroupingHandler(XMLExtendedStreamWriter writer, ModelNode node) throws XMLStreamException {\n        if (!node.isDefined()) {\n            return;\n        }\n        boolean wroteHandler = false;\n        for (Property handler : node.asPropertyList()) {\n            if (wroteHandler) {\n                throw MESSAGES.multipleChildrenFound(GROUPING_HANDLER);\n            } else {\n                wroteHandler = true;\n            }\n            writer.writeStartElement(Element.GROUPING_HANDLER.getLocalName());\n            writer.writeAttribute(Attribute.NAME.getLocalName(), handler.getName());\n            final ModelNode resourceModel = handler.getValue();\n            for (AttributeDefinition attr : GroupingHandlerDefinition.ATTRIBUTES) {\n                attr.marshallAsElement(resourceModel, writer);\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeDirectory(final XMLExtendedStreamWriter writer, final Element element, final ModelNode node) throws XMLStreamException {\n        final String localName = element.getLocalName();\n        if(node.has(localName)) {\n            final String path = node.get(localName).has(PATH.getName()) ? node.get(localName, PATH.getName()).asString() : null;\n            final String relativeTo = node.get(localName).hasDefined(RELATIVE_TO.getName()) ? node.get(localName, RELATIVE_TO.getName()).asString() : null;\n            if(path != null || relativeTo != null) {\n                writer.writeEmptyElement(localName);\n                if(path != null) writer.writeAttribute(PATH.getName(), path);\n                if(relativeTo != null) writer.writeAttribute(RELATIVE_TO.getName(), relativeTo);\n            }\n        }\n    }","id":102096,"modified_method":"private static void writeDirectory(final XMLExtendedStreamWriter writer, final Element element, final ModelNode node) throws XMLStreamException {\n        final String localName = element.getLocalName();\n        if(node.hasDefined(localName)) {\n            final String path = node.get(localName).has(PATH.getName()) ? node.get(localName, PATH.getName()).asString() : null;\n            final String relativeTo = node.get(localName).hasDefined(RELATIVE_TO.getName()) ? node.get(localName, RELATIVE_TO.getName()).asString() : null;\n            if(path != null || relativeTo != null) {\n                writer.writeEmptyElement(localName);\n                if(path != null) writer.writeAttribute(PATH.getName(), path);\n                if(relativeTo != null) writer.writeAttribute(RELATIVE_TO.getName(), relativeTo);\n            }\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeConnectionFactories(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            for (Property prop : properties) {\n                final String name = prop.getName();\n                final ModelNode factory = prop.getValue();\n                if (factory.isDefined()) {\n                    writer.writeStartElement(Element.CONNECTION_FACTORY.getLocalName());\n                    writer.writeAttribute(Attribute.NAME.getLocalName(), name);\n\n                    writeRegularConnectionFactoryAttributes(writer, name, factory);\n                    writeCommonConnectionFactoryAttributes(writer, name, factory);\n                }\n            }\n        }\n    }","id":102097,"modified_method":"private static void writeConnectionFactories(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        if (!node.isDefined() || node.keys().size() == 0) {\n            return;\n        }\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            for (Property prop : properties) {\n                final String name = prop.getName();\n                final ModelNode factory = prop.getValue();\n                if (factory.isDefined()) {\n                    writer.writeStartElement(Element.CONNECTION_FACTORY.getLocalName());\n                    writer.writeAttribute(Attribute.NAME.getLocalName(), name);\n\n                    writeRegularConnectionFactoryAttributes(writer, name, factory);\n                    writeCommonConnectionFactoryAttributes(writer, name, factory);\n                }\n            }\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeClusterConnections(XMLExtendedStreamWriter writer, ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.CLUSTER_CONNECTIONS.getLocalName());\n            for(final Property property : node.asPropertyList()) {\n                writer.writeStartElement(Element.CLUSTER_CONNECTION.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                final ModelNode cluster = property.getValue();\n                for (AttributeDefinition attribute : ClusterConnectionDefinition.ATTRIBUTES) {\n                    if (attribute == ClusterConnectionDefinition.ALLOW_DIRECT_CONNECTIONS_ONLY) {\n                        // we nest it in static-connectors\n                        continue;\n                    }\n                    if (attribute == ConnectorRefsAttribute.CLUSTER_CONNECTION_CONNECTORS) {\n                        if (ConnectorRefsAttribute.CLUSTER_CONNECTION_CONNECTORS.isMarshallable(cluster)) {\n                            writer.writeStartElement(Element.STATIC_CONNECTORS.getLocalName());\n                            ClusterConnectionDefinition.ALLOW_DIRECT_CONNECTIONS_ONLY.marshallAsAttribute(cluster, writer);\n                            ConnectorRefsAttribute.CLUSTER_CONNECTION_CONNECTORS.marshallAsElement(cluster, writer);\n                            writer.writeEndElement();\n                        } else if (ClusterConnectionDefinition.ALLOW_DIRECT_CONNECTIONS_ONLY.isMarshallable(cluster)) {\n                            writer.writeEmptyElement(Element.STATIC_CONNECTORS.getLocalName());\n                            ClusterConnectionDefinition.ALLOW_DIRECT_CONNECTIONS_ONLY.marshallAsAttribute(cluster, writer);\n                        }\n                    }\n                    else if (attribute == CommonAttributes.DISCOVERY_GROUP_NAME) {\n                        if (CommonAttributes.DISCOVERY_GROUP_NAME.isMarshallable(cluster)) {\n                            writer.writeStartElement(Element.DISCOVERY_GROUP_REF.getLocalName());\n                            CommonAttributes.DISCOVERY_GROUP_NAME.marshallAsAttribute(cluster, writer);\n                            writer.writeEndElement();\n                        }\n                    } else {\n                        attribute.marshallAsElement(property.getValue(), writer);\n                    }\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","id":102098,"modified_method":"private static void writeClusterConnections(XMLExtendedStreamWriter writer, ModelNode node) throws XMLStreamException {\n        if (!node.isDefined()) {\n            return;\n        }\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.CLUSTER_CONNECTIONS.getLocalName());\n            for(final Property property : node.asPropertyList()) {\n                writer.writeStartElement(Element.CLUSTER_CONNECTION.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                final ModelNode cluster = property.getValue();\n                for (AttributeDefinition attribute : ClusterConnectionDefinition.ATTRIBUTES) {\n                    if (attribute == ClusterConnectionDefinition.ALLOW_DIRECT_CONNECTIONS_ONLY) {\n                        // we nest it in static-connectors\n                        continue;\n                    }\n                    if (attribute == ConnectorRefsAttribute.CLUSTER_CONNECTION_CONNECTORS) {\n                        if (ConnectorRefsAttribute.CLUSTER_CONNECTION_CONNECTORS.isMarshallable(cluster)) {\n                            writer.writeStartElement(Element.STATIC_CONNECTORS.getLocalName());\n                            ClusterConnectionDefinition.ALLOW_DIRECT_CONNECTIONS_ONLY.marshallAsAttribute(cluster, writer);\n                            ConnectorRefsAttribute.CLUSTER_CONNECTION_CONNECTORS.marshallAsElement(cluster, writer);\n                            writer.writeEndElement();\n                        } else if (ClusterConnectionDefinition.ALLOW_DIRECT_CONNECTIONS_ONLY.isMarshallable(cluster)) {\n                            writer.writeEmptyElement(Element.STATIC_CONNECTORS.getLocalName());\n                            ClusterConnectionDefinition.ALLOW_DIRECT_CONNECTIONS_ONLY.marshallAsAttribute(cluster, writer);\n                        }\n                    }\n                    else if (attribute == CommonAttributes.DISCOVERY_GROUP_NAME) {\n                        if (CommonAttributes.DISCOVERY_GROUP_NAME.isMarshallable(cluster)) {\n                            writer.writeStartElement(Element.DISCOVERY_GROUP_REF.getLocalName());\n                            CommonAttributes.DISCOVERY_GROUP_NAME.marshallAsAttribute(cluster, writer);\n                            writer.writeEndElement();\n                        }\n                    } else {\n                        attribute.marshallAsElement(property.getValue(), writer);\n                    }\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeQueues(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.CORE_QUEUES.getLocalName());\n            for (Property queueProp : properties) {\n                writer.writeStartElement(Element.QUEUE.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), queueProp.getName());\n                final ModelNode queue = queueProp.getValue();\n                QueueDefinition.ADDRESS.marshallAsElement(queue, writer);\n                writeFilter(writer, queue);\n                DURABLE.marshallAsElement(queue, writer);\n\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","id":102099,"modified_method":"private static void writeQueues(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        if (!node.isDefined()) {\n            return;\n        }\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.CORE_QUEUES.getLocalName());\n            for (Property queueProp : properties) {\n                writer.writeStartElement(Element.QUEUE.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), queueProp.getName());\n                final ModelNode queue = queueProp.getValue();\n                QueueDefinition.ADDRESS.marshallAsElement(queue, writer);\n                writeFilter(writer, queue);\n                DURABLE.marshallAsElement(queue, writer);\n\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeSecuritySettings(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.SECURITY_SETTINGS.getLocalName());\n\n            for (Property matchRoles : properties) {\n                writer.writeStartElement(Element.SECURITY_SETTING.getLocalName());\n                writer.writeAttribute(Attribute.MATCH.getLocalName(), matchRoles.getName());\n\n                if (matchRoles.getValue().hasDefined(ROLE)) {\n\n                    ArrayList<String> send = new ArrayList<String>();\n                    ArrayList<String> consume = new ArrayList<String>();\n                    ArrayList<String> createDurableQueue = new ArrayList<String>();\n                    ArrayList<String> deleteDurableQueue = new ArrayList<String>();\n                    ArrayList<String> createNonDurableQueue = new ArrayList<String>();\n                    ArrayList<String> deleteNonDurableQueue = new ArrayList<String>();\n                    ArrayList<String> manageRoles = new ArrayList<String>();\n\n                    for (Property rolePerms : matchRoles.getValue().get(ROLE).asPropertyList()) {\n                        final String role = rolePerms.getName();\n                        final ModelNode perms = rolePerms.getValue();\n                        if (perms.get(SecurityRoleDefinition.SEND.getName()).asBoolean(false)) {\n                            send.add(role);\n                        }\n                        if (perms.get(SecurityRoleDefinition.CONSUME.getName()).asBoolean(false)) {\n                            consume.add(role);\n                        }\n                        if (perms.get(SecurityRoleDefinition.CREATE_DURABLE_QUEUE.getName()).asBoolean(false)) {\n                            createDurableQueue.add(role);\n                        }\n                        if (perms.get(SecurityRoleDefinition.DELETE_DURABLE_QUEUE.getName()).asBoolean(false)) {\n                            deleteDurableQueue.add(role);\n                        }\n                        if (perms.get(SecurityRoleDefinition.CREATE_NON_DURABLE_QUEUE.getName()).asBoolean(false)) {\n                            createNonDurableQueue.add(role);\n                        }\n                        if (perms.get(SecurityRoleDefinition.DELETE_NON_DURABLE_QUEUE.getName()).asBoolean(false)) {\n                            deleteNonDurableQueue.add(role);\n                        }\n                        if (perms.get(SecurityRoleDefinition.MANAGE.getName()).asBoolean(false)) {\n                            manageRoles.add(role);\n                        }\n                    }\n\n                    writePermission(writer, SecurityRoleDefinition.SEND.getXmlName(), send);\n                    writePermission(writer, SecurityRoleDefinition.CONSUME.getXmlName(), consume);\n                    writePermission(writer, SecurityRoleDefinition.CREATE_DURABLE_QUEUE.getXmlName(), createDurableQueue);\n                    writePermission(writer, SecurityRoleDefinition.DELETE_DURABLE_QUEUE.getXmlName(), deleteDurableQueue);\n                    writePermission(writer, SecurityRoleDefinition.CREATE_NON_DURABLE_QUEUE.getXmlName(), createNonDurableQueue);\n                    writePermission(writer, SecurityRoleDefinition.DELETE_NON_DURABLE_QUEUE.getXmlName(), deleteNonDurableQueue);\n                    writePermission(writer, SecurityRoleDefinition.MANAGE.getXmlName(), manageRoles);\n                }\n\n                writer.writeEndElement();\n            }\n\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","id":102100,"modified_method":"private static void writeSecuritySettings(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        if (!node.isDefined()) {\n            return;\n        }\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.SECURITY_SETTINGS.getLocalName());\n\n            for (Property matchRoles : properties) {\n                writer.writeStartElement(Element.SECURITY_SETTING.getLocalName());\n                writer.writeAttribute(Attribute.MATCH.getLocalName(), matchRoles.getName());\n\n                if (matchRoles.getValue().hasDefined(ROLE)) {\n\n                    ArrayList<String> send = new ArrayList<String>();\n                    ArrayList<String> consume = new ArrayList<String>();\n                    ArrayList<String> createDurableQueue = new ArrayList<String>();\n                    ArrayList<String> deleteDurableQueue = new ArrayList<String>();\n                    ArrayList<String> createNonDurableQueue = new ArrayList<String>();\n                    ArrayList<String> deleteNonDurableQueue = new ArrayList<String>();\n                    ArrayList<String> manageRoles = new ArrayList<String>();\n\n                    for (Property rolePerms : matchRoles.getValue().get(ROLE).asPropertyList()) {\n                        final String role = rolePerms.getName();\n                        final ModelNode perms = rolePerms.getValue();\n                        if (perms.get(SecurityRoleDefinition.SEND.getName()).asBoolean(false)) {\n                            send.add(role);\n                        }\n                        if (perms.get(SecurityRoleDefinition.CONSUME.getName()).asBoolean(false)) {\n                            consume.add(role);\n                        }\n                        if (perms.get(SecurityRoleDefinition.CREATE_DURABLE_QUEUE.getName()).asBoolean(false)) {\n                            createDurableQueue.add(role);\n                        }\n                        if (perms.get(SecurityRoleDefinition.DELETE_DURABLE_QUEUE.getName()).asBoolean(false)) {\n                            deleteDurableQueue.add(role);\n                        }\n                        if (perms.get(SecurityRoleDefinition.CREATE_NON_DURABLE_QUEUE.getName()).asBoolean(false)) {\n                            createNonDurableQueue.add(role);\n                        }\n                        if (perms.get(SecurityRoleDefinition.DELETE_NON_DURABLE_QUEUE.getName()).asBoolean(false)) {\n                            deleteNonDurableQueue.add(role);\n                        }\n                        if (perms.get(SecurityRoleDefinition.MANAGE.getName()).asBoolean(false)) {\n                            manageRoles.add(role);\n                        }\n                    }\n\n                    writePermission(writer, SecurityRoleDefinition.SEND.getXmlName(), send);\n                    writePermission(writer, SecurityRoleDefinition.CONSUME.getXmlName(), consume);\n                    writePermission(writer, SecurityRoleDefinition.CREATE_DURABLE_QUEUE.getXmlName(), createDurableQueue);\n                    writePermission(writer, SecurityRoleDefinition.DELETE_DURABLE_QUEUE.getXmlName(), deleteDurableQueue);\n                    writePermission(writer, SecurityRoleDefinition.CREATE_NON_DURABLE_QUEUE.getXmlName(), createNonDurableQueue);\n                    writePermission(writer, SecurityRoleDefinition.DELETE_NON_DURABLE_QUEUE.getXmlName(), deleteNonDurableQueue);\n                    writePermission(writer, SecurityRoleDefinition.MANAGE.getXmlName(), manageRoles);\n                }\n\n                writer.writeEndElement();\n            }\n\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writePooledConnectionFactories(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            for (Property prop : properties) {\n                final String name = prop.getName();\n                final ModelNode factory = prop.getValue();\n                if (factory.isDefined()) {\n                    writer.writeStartElement(Element.POOLED_CONNECTION_FACTORY.getLocalName());\n\n                    writer.writeAttribute(Attribute.NAME.getLocalName(), name);\n\n                    writePooledConnectionFactoryAttributes(writer, name, factory);\n                    writeCommonConnectionFactoryAttributes(writer, name, factory);\n                }\n            }\n        }\n    }","id":102101,"modified_method":"private static void writePooledConnectionFactories(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        if (!node.isDefined() || node.keys().size() == 0) {\n            return;\n        }\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            for (Property prop : properties) {\n                final String name = prop.getName();\n                final ModelNode factory = prop.getValue();\n                if (factory.isDefined()) {\n                    writer.writeStartElement(Element.POOLED_CONNECTION_FACTORY.getLocalName());\n\n                    writer.writeAttribute(Attribute.NAME.getLocalName(), name);\n\n                    writePooledConnectionFactoryAttributes(writer, name, factory);\n                    writeCommonConnectionFactoryAttributes(writer, name, factory);\n                }\n            }\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeTopics(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            for (Property prop : properties) {\n                final String name = prop.getName();\n                final ModelNode topic = prop.getValue();\n                if (topic.isDefined()) {\n                    writer.writeStartElement(Element.JMS_TOPIC.getLocalName());\n                    writer.writeAttribute(Attribute.NAME.getLocalName(), name);\n                    JndiEntriesAttribute.DESTINATION.marshallAsElement(topic, writer);\n                    writer.writeEndElement();\n                }\n            }\n        }\n    }","id":102102,"modified_method":"private static void writeTopics(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        if (!node.isDefined() || node.keys().size() == 0) {\n            return;\n        }\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            for (Property prop : properties) {\n                final String name = prop.getName();\n                final ModelNode topic = prop.getValue();\n                if (topic.isDefined()) {\n                    writer.writeStartElement(Element.JMS_TOPIC.getLocalName());\n                    writer.writeAttribute(Attribute.NAME.getLocalName(), name);\n                    JndiEntriesAttribute.DESTINATION.marshallAsElement(topic, writer);\n                    writer.writeEndElement();\n                }\n            }\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeAcceptorAndConnectorContent(final XMLExtendedStreamWriter writer, final Property property) throws XMLStreamException {\n        writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n        final ModelNode value = property.getValue();\n\n        if (value.hasDefined(RemoteTransportDefinition.SOCKET_BINDING.getName())) {\n            writeAttribute(writer, Attribute.SOCKET_BINDING, value.get(RemoteTransportDefinition.SOCKET_BINDING.getName()));\n        }\n        if (value.hasDefined(InVMTransportDefinition.SERVER_ID.getName())) {\n            writeAttribute(writer, Attribute.SERVER_ID, value.get(InVMTransportDefinition.SERVER_ID.getName()));\n        }\n\n        CommonAttributes.FACTORY_CLASS.marshallAsElement(value, writer);\n\n        if (value.hasDefined(PARAM)) {\n            for(final Property parameter : value.get(PARAM).asPropertyList()) {\n                writer.writeStartElement(Element.PARAM.getLocalName());\n                writer.writeAttribute(Attribute.KEY.getLocalName(), parameter.getName());\n                writeAttribute(writer, Attribute.VALUE, parameter.getValue().get(VALUE.getName()));\n                writer.writeEndElement();\n            }\n        }\n    }","id":102103,"modified_method":"private static void writeAcceptorAndConnectorContent(final XMLExtendedStreamWriter writer, final Property property) throws XMLStreamException {\n        writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n        final ModelNode value = property.getValue();\n\n        RemoteTransportDefinition.SOCKET_BINDING.marshallAsAttribute(value, writer);\n        InVMTransportDefinition.SERVER_ID.marshallAsAttribute(value, writer);\n        CommonAttributes.FACTORY_CLASS.marshallAsElement(value, writer);\n\n        if (value.hasDefined(PARAM)) {\n            for(final Property parameter : value.get(PARAM).asPropertyList()) {\n                writer.writeStartElement(Element.PARAM.getLocalName());\n                writer.writeAttribute(Attribute.KEY.getLocalName(), parameter.getName());\n                writer.writeAttribute(Attribute.VALUE.getLocalName(), parameter.getValue().get(VALUE.getName()).asString());\n                writer.writeEndElement();\n            }\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeDiverts(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.DIVERTS.getLocalName());\n            for(final Property property : properties) {\n                writer.writeStartElement(Element.DIVERT.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                for (AttributeDefinition attribute : DivertDefinition.ATTRIBUTES) {\n                    if (CommonAttributes.FILTER == attribute) {\n                        writeFilter(writer, property.getValue());\n                    } else {\n                        attribute.marshallAsElement(property.getValue(), writer);\n                    }\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","id":102104,"modified_method":"private static void writeDiverts(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        if (!node.isDefined()) {\n            return;\n        }\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.DIVERTS.getLocalName());\n            for(final Property property : properties) {\n                writer.writeStartElement(Element.DIVERT.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                for (AttributeDefinition attribute : DivertDefinition.ATTRIBUTES) {\n                    if (CommonAttributes.FILTER == attribute) {\n                        writeFilter(writer, property.getValue());\n                    } else {\n                        attribute.marshallAsElement(property.getValue(), writer);\n                    }\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeBridges(XMLExtendedStreamWriter writer, ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.BRIDGES.getLocalName());\n            for(final Property property : node.asPropertyList()) {\n                writer.writeStartElement(Element.BRIDGE.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                final ModelNode bridge = property.getValue();\n                for (AttributeDefinition attribute : BridgeDefinition.ATTRIBUTES) {\n                    if (CommonAttributes.FILTER == attribute) {\n                        writeFilter(writer, property.getValue());\n                    } else if (attribute == CommonAttributes.DISCOVERY_GROUP_NAME) {\n                        if (CommonAttributes.DISCOVERY_GROUP_NAME.isMarshallable(bridge)) {\n                            writer.writeStartElement(Element.DISCOVERY_GROUP_REF.getLocalName());\n                            CommonAttributes.DISCOVERY_GROUP_NAME.marshallAsAttribute(bridge, writer);\n                            writer.writeEndElement();\n                        }\n                    } else {\n                        attribute.marshallAsElement(property.getValue(), writer);\n                    }\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","id":102105,"modified_method":"private static void writeBridges(XMLExtendedStreamWriter writer, ModelNode node) throws XMLStreamException {\n        if (!node.isDefined()) {\n            return;\n        }\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.BRIDGES.getLocalName());\n            for(final Property property : node.asPropertyList()) {\n                writer.writeStartElement(Element.BRIDGE.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                final ModelNode bridge = property.getValue();\n                for (AttributeDefinition attribute : BridgeDefinition.ATTRIBUTES) {\n                    if (CommonAttributes.FILTER == attribute) {\n                        writeFilter(writer, property.getValue());\n                    } else if (attribute == CommonAttributes.DISCOVERY_GROUP_NAME) {\n                        if (CommonAttributes.DISCOVERY_GROUP_NAME.isMarshallable(bridge)) {\n                            writer.writeStartElement(Element.DISCOVERY_GROUP_REF.getLocalName());\n                            CommonAttributes.DISCOVERY_GROUP_NAME.marshallAsAttribute(bridge, writer);\n                            writer.writeEndElement();\n                        }\n                    } else {\n                        attribute.marshallAsElement(property.getValue(), writer);\n                    }\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeAddressSettings(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.ADDRESS_SETTINGS.getLocalName());\n            for (Property matchSetting : properties) {\n                writer.writeStartElement(Element.ADDRESS_SETTING.getLocalName());\n                writer.writeAttribute(Attribute.MATCH.getLocalName(), matchSetting.getName());\n                final ModelNode setting = matchSetting.getValue();\n                CommonAttributes.DEAD_LETTER_ADDRESS.marshallAsElement(setting, writer);\n                CommonAttributes.EXPIRY_ADDRESS.marshallAsElement(setting, writer);\n                AddressSettingDefinition.REDELIVERY_DELAY.marshallAsElement(setting, writer);\n                AddressSettingDefinition.MAX_DELIVERY_ATTEMPTS.marshallAsElement(setting, writer);\n                AddressSettingDefinition.MAX_SIZE_BYTES.marshallAsElement(setting, writer);\n                AddressSettingDefinition.PAGE_SIZE_BYTES.marshallAsElement(setting, writer);\n                AddressSettingDefinition.PAGE_MAX_CACHE_SIZE.marshallAsElement(setting, writer);\n                AddressSettingDefinition.ADDRESS_FULL_MESSAGE_POLICY.marshallAsElement(setting, writer);\n                AddressSettingDefinition.MESSAGE_COUNTER_HISTORY_DAY_LIMIT.marshallAsElement(setting, writer);\n                AddressSettingDefinition.LAST_VALUE_QUEUE.marshallAsElement(setting, writer);\n                AddressSettingDefinition.REDISTRIBUTION_DELAY.marshallAsElement(setting, writer);\n                AddressSettingDefinition.SEND_TO_DLA_ON_NO_ROUTE.marshallAsElement(setting, writer);\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","id":102106,"modified_method":"private static void writeAddressSettings(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        if (!node.isDefined()) {\n            return;\n        }\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.ADDRESS_SETTINGS.getLocalName());\n            for (Property matchSetting : properties) {\n                writer.writeStartElement(Element.ADDRESS_SETTING.getLocalName());\n                writer.writeAttribute(Attribute.MATCH.getLocalName(), matchSetting.getName());\n                final ModelNode setting = matchSetting.getValue();\n                CommonAttributes.DEAD_LETTER_ADDRESS.marshallAsElement(setting, writer);\n                CommonAttributes.EXPIRY_ADDRESS.marshallAsElement(setting, writer);\n                AddressSettingDefinition.REDELIVERY_DELAY.marshallAsElement(setting, writer);\n                AddressSettingDefinition.MAX_DELIVERY_ATTEMPTS.marshallAsElement(setting, writer);\n                AddressSettingDefinition.MAX_SIZE_BYTES.marshallAsElement(setting, writer);\n                AddressSettingDefinition.PAGE_SIZE_BYTES.marshallAsElement(setting, writer);\n                AddressSettingDefinition.PAGE_MAX_CACHE_SIZE.marshallAsElement(setting, writer);\n                AddressSettingDefinition.ADDRESS_FULL_MESSAGE_POLICY.marshallAsElement(setting, writer);\n                AddressSettingDefinition.MESSAGE_COUNTER_HISTORY_DAY_LIMIT.marshallAsElement(setting, writer);\n                AddressSettingDefinition.LAST_VALUE_QUEUE.marshallAsElement(setting, writer);\n                AddressSettingDefinition.REDISTRIBUTION_DELAY.marshallAsElement(setting, writer);\n                AddressSettingDefinition.SEND_TO_DLA_ON_NO_ROUTE.marshallAsElement(setting, writer);\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeConnectorServices(XMLExtendedStreamWriter writer, ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.CONNECTOR_SERVICES.getLocalName());\n            for(final Property property : node.asPropertyList()) {\n                writer.writeStartElement(Element.CONNECTOR_SERVICE.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                final ModelNode service = property.getValue();\n                for (AttributeDefinition attribute : ConnectorServiceDefinition.ATTRIBUTES) {\n                    attribute.marshallAsElement(property.getValue(), writer);\n                }\n                if (service.hasDefined(CommonAttributes.PARAM)) {\n                    for (Property param : service.get(CommonAttributes.PARAM).asPropertyList()) {\n                        writer.writeEmptyElement(Element.PARAM.getLocalName());\n                        writer.writeAttribute(Attribute.KEY.getLocalName(), param.getName());\n                        writer.writeAttribute(Attribute.VALUE.getLocalName(), param.getValue().get(CommonAttributes.VALUE.getName()).asString());\n                    }\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","id":102107,"modified_method":"private static void writeConnectorServices(XMLExtendedStreamWriter writer, ModelNode node) throws XMLStreamException {\n        if (!node.isDefined()) {\n            return;\n        }\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.CONNECTOR_SERVICES.getLocalName());\n            for(final Property property : node.asPropertyList()) {\n                writer.writeStartElement(Element.CONNECTOR_SERVICE.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                final ModelNode service = property.getValue();\n                for (AttributeDefinition attribute : ConnectorServiceDefinition.ATTRIBUTES) {\n                    attribute.marshallAsElement(property.getValue(), writer);\n                }\n                if (service.hasDefined(CommonAttributes.PARAM)) {\n                    for (Property param : service.get(CommonAttributes.PARAM).asPropertyList()) {\n                        writer.writeEmptyElement(Element.PARAM.getLocalName());\n                        writer.writeAttribute(Attribute.KEY.getLocalName(), param.getName());\n                        writer.writeAttribute(Attribute.VALUE.getLocalName(), param.getValue().get(CommonAttributes.VALUE.getName()).asString());\n                    }\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeDiscoveryGroups(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.DISCOVERY_GROUPS.getLocalName());\n            for(final Property property : properties) {\n                writer.writeStartElement(Element.DISCOVERY_GROUP.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                for (AttributeDefinition attribute : DiscoveryGroupDefinition.ATTRIBUTES) {\n                    attribute.marshallAsElement(property.getValue(), writer);\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","id":102108,"modified_method":"private static void writeDiscoveryGroups(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        if (!node.isDefined()) {\n            return;\n        }\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.DISCOVERY_GROUPS.getLocalName());\n            for(final Property property : properties) {\n                writer.writeStartElement(Element.DISCOVERY_GROUP.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                for (AttributeDefinition attribute : DiscoveryGroupDefinition.ATTRIBUTES) {\n                    attribute.marshallAsElement(property.getValue(), writer);\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeJmsQueues(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            for (Property prop : properties) {\n                final String name = prop.getName();\n                final ModelNode queue = prop.getValue();\n                if (queue.isDefined()) {\n                    writer.writeStartElement(Element.JMS_QUEUE.getLocalName());\n                    writer.writeAttribute(Attribute.NAME.getLocalName(), name);\n                    JndiEntriesAttribute.DESTINATION.marshallAsElement(queue, writer);\n                    DURABLE.marshallAsElement(queue, writer);\n                    SELECTOR.marshallAsElement(queue, writer);\n                    writer.writeEndElement();\n                }\n            }\n        }\n    }","id":102109,"modified_method":"private static void writeJmsQueues(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        if (!node.isDefined() || node.keys().size() == 0) {\n            return;\n        }\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            for (Property prop : properties) {\n                final String name = prop.getName();\n                final ModelNode queue = prop.getValue();\n                if (queue.isDefined()) {\n                    writer.writeStartElement(Element.JMS_QUEUE.getLocalName());\n                    writer.writeAttribute(Attribute.NAME.getLocalName(), name);\n                    JndiEntriesAttribute.DESTINATION.marshallAsElement(queue, writer);\n                    DURABLE.marshallAsElement(queue, writer);\n                    SELECTOR.marshallAsElement(queue, writer);\n                    writer.writeEndElement();\n                }\n            }\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeHornetQServer(final XMLExtendedStreamWriter writer, final String serverName, final ModelNode node) throws XMLStreamException {\n\n        writer.writeStartElement(Element.HORNETQ_SERVER.getLocalName());\n\n        if (!DEFAULT.equals(serverName)) {\n            writer.writeAttribute(Attribute.NAME.getLocalName(), serverName);\n        }\n\n        for (AttributeDefinition simpleAttribute : CommonAttributes.SIMPLE_ROOT_RESOURCE_ATTRIBUTES) {\n            simpleAttribute.marshallAsElement(node, writer);\n        }\n\n        final ModelNode paths = node.get(ModelDescriptionConstants.PATH);\n        if (paths.hasDefined(CommonAttributes.PAGING_DIRECTORY)) {\n            writeDirectory(writer, Element.PAGING_DIRECTORY, node.get(ModelDescriptionConstants.PATH));\n        }\n        if (paths.hasDefined(BINDINGS_DIRECTORY)) {\n            writeDirectory(writer, Element.BINDINGS_DIRECTORY, node.get(ModelDescriptionConstants.PATH));\n        }\n        if (paths.hasDefined(CommonAttributes.JOURNAL_DIRECTORY)) {\n            writeDirectory(writer, Element.JOURNAL_DIRECTORY, node.get(ModelDescriptionConstants.PATH));\n        }\n        if (paths.hasDefined(CommonAttributes.LARGE_MESSAGES_DIRECTORY)) {\n            writeDirectory(writer, Element.LARGE_MESSAGES_DIRECTORY, node.get(ModelDescriptionConstants.PATH));\n        }\n        // New line after the simpler elements\n        writeNewLine(writer);\n\n        writeConnectors(writer, node);\n\n        writeAcceptors(writer, node);\n\n        if (node.hasDefined(BROADCAST_GROUP)) {\n            writeBroadcastGroups(writer, node.get(BROADCAST_GROUP));\n        }\n        if (node.hasDefined(DISCOVERY_GROUP)) {\n            writeDiscoveryGroups(writer, node.get(DISCOVERY_GROUP));\n        }\n        if (node.hasDefined(DIVERT)) {\n            writeDiverts(writer, node.get(DIVERT));\n        }\n        if (node.hasDefined(CommonAttributes.QUEUE)) {\n            writeQueues(writer, node.get(CommonAttributes.QUEUE));\n        }\n        if (node.hasDefined(CommonAttributes.BRIDGE)) {\n            writeBridges(writer, node.get(CommonAttributes.BRIDGE));\n        }\n        if (node.hasDefined(CommonAttributes.CLUSTER_CONNECTION)) {\n            writeClusterConnections(writer, node.get(CommonAttributes.CLUSTER_CONNECTION));\n        }\n\n        if (node.hasDefined(CommonAttributes.GROUPING_HANDLER)) {\n            writeGroupingHandler(writer, node.get(GROUPING_HANDLER));\n        }\n\n        if (node.hasDefined(CommonAttributes.SECURITY_SETTING)) {\n            writeSecuritySettings(writer, node.get(CommonAttributes.SECURITY_SETTING));\n        }\n\n        if (node.hasDefined(ADDRESS_SETTING)) {\n            writeAddressSettings(writer, node.get(ADDRESS_SETTING));\n        }\n\n        if (node.hasDefined(CommonAttributes.CONNECTOR_SERVICE)) {\n            writeConnectorServices(writer, node.get(CommonAttributes.CONNECTOR_SERVICE));\n        }\n\n        if (node.hasDefined(CONNECTION_FACTORY) || node.hasDefined(POOLED_CONNECTION_FACTORY)) {\n            ModelNode cf = node.get(CONNECTION_FACTORY);\n            ModelNode pcf = node.get(POOLED_CONNECTION_FACTORY);\n            boolean hasCf = cf.isDefined() && cf.keys().size() > 0;\n            boolean hasPcf = pcf.isDefined() && pcf.keys().size() > 0;\n            if (hasCf || hasPcf) {\n                writer.writeStartElement(JMS_CONNECTION_FACTORIES);\n                if (hasCf) {\n                    writeConnectionFactories(writer, cf);\n                }\n                if (hasPcf) {\n                    writePooledConnectionFactories(writer, pcf);\n                }\n                writer.writeEndElement();\n                writeNewLine(writer);\n            }\n        }\n\n        if (node.has(JMS_QUEUE) || node.has(JMS_TOPIC)) {\n            ModelNode queue = node.get(JMS_QUEUE);\n            ModelNode topic = node.get(JMS_TOPIC);\n            boolean hasQueue = queue.isDefined() && queue.keys().size() > 0;\n            boolean hasTopic = topic.isDefined() && topic.keys().size() > 0;\n            if (hasQueue || hasTopic) {\n                writer.writeStartElement(JMS_DESTINATIONS);\n                if (hasQueue) {\n                    writeJmsQueues(writer, node.get(JMS_QUEUE));\n                }\n                if (hasTopic) {\n                    writeTopics(writer, node.get(JMS_TOPIC));\n                }\n                writer.writeEndElement();\n            }\n        }\n\n        writer.writeEndElement();\n    }","id":102110,"modified_method":"private static void writeHornetQServer(final XMLExtendedStreamWriter writer, final String serverName, final ModelNode node) throws XMLStreamException {\n\n        writer.writeStartElement(Element.HORNETQ_SERVER.getLocalName());\n\n        if (!DEFAULT.equals(serverName)) {\n            writer.writeAttribute(Attribute.NAME.getLocalName(), serverName);\n        }\n\n        for (AttributeDefinition simpleAttribute : CommonAttributes.SIMPLE_ROOT_RESOURCE_ATTRIBUTES) {\n            simpleAttribute.marshallAsElement(node, writer);\n        }\n\n        final ModelNode paths = node.get(ModelDescriptionConstants.PATH);\n        writeDirectory(writer, Element.PAGING_DIRECTORY, paths);\n        writeDirectory(writer, Element.BINDINGS_DIRECTORY, paths);\n        writeDirectory(writer, Element.JOURNAL_DIRECTORY, paths);\n        writeDirectory(writer, Element.LARGE_MESSAGES_DIRECTORY, paths);\n\n        // New line after the simpler elements\n        writeNewLine(writer);\n\n        writeConnectors(writer, node);\n        writeAcceptors(writer, node);\n        writeBroadcastGroups(writer, node.get(BROADCAST_GROUP));\n        writeDiscoveryGroups(writer, node.get(DISCOVERY_GROUP));\n        writeDiverts(writer, node.get(DIVERT));\n        writeQueues(writer, node.get(CommonAttributes.QUEUE));\n        writeBridges(writer, node.get(CommonAttributes.BRIDGE));\n        writeClusterConnections(writer, node.get(CommonAttributes.CLUSTER_CONNECTION));\n        writeGroupingHandler(writer, node.get(GROUPING_HANDLER));\n        writeSecuritySettings(writer, node.get(CommonAttributes.SECURITY_SETTING));\n        writeAddressSettings(writer, node.get(ADDRESS_SETTING));\n        writeConnectorServices(writer, node.get(CommonAttributes.CONNECTOR_SERVICE));\n\n        if (node.hasDefined(CONNECTION_FACTORY) || node.hasDefined(POOLED_CONNECTION_FACTORY)) {\n            ModelNode cf = node.get(CONNECTION_FACTORY);\n            ModelNode pcf = node.get(POOLED_CONNECTION_FACTORY);\n            boolean hasCf = cf.isDefined() && cf.keys().size() > 0;\n            boolean hasPcf = pcf.isDefined() && pcf.keys().size() > 0;\n            if (hasCf || hasPcf) {\n                writer.writeStartElement(JMS_CONNECTION_FACTORIES);\n                writeConnectionFactories(writer, cf);\n                writePooledConnectionFactories(writer, pcf);\n                writer.writeEndElement();\n                writeNewLine(writer);\n            }\n        }\n\n        if (node.hasDefined(JMS_QUEUE) || node.hasDefined(JMS_TOPIC)) {\n            ModelNode queue = node.get(JMS_QUEUE);\n            ModelNode topic = node.get(JMS_TOPIC);\n            boolean hasQueue = queue.isDefined() && queue.keys().size() > 0;\n            boolean hasTopic = topic.isDefined() && topic.keys().size() > 0;\n            if (hasQueue || hasTopic) {\n                writer.writeStartElement(JMS_DESTINATIONS);\n                writeJmsQueues(writer, node.get(JMS_QUEUE));\n                writeTopics(writer, node.get(JMS_TOPIC));\n                writer.writeEndElement();\n            }\n        }\n\n        writer.writeEndElement();\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writePooledConnectionFactoryAttributes(XMLExtendedStreamWriter writer, String name, ModelNode factory)\n            throws XMLStreamException {\n\n        Pooled.USER.marshallAsElement(factory, writer);\n        Pooled.PASSWORD.marshallAsElement(factory, writer);\n\n        if(factory.hasDefined(INBOUND_CONFIG)) {\n            final ModelNode inboundConfigs = factory.get(INBOUND_CONFIG);\n            if (inboundConfigs.getType() == ModelType.LIST) {\n                writer.writeStartElement(Element.INBOUND_CONFIG.getLocalName());\n                for (ModelNode config : inboundConfigs.asList()) {\n                    if (config.isDefined()) {\n                        Pooled.USE_JNDI.marshallAsElement(config, writer);\n                        Pooled.JNDI_PARAMS.marshallAsElement(config, writer);\n                        Pooled.USE_LOCAL_TX.marshallAsElement(config, writer);\n                        Pooled.SETUP_ATTEMPTS.marshallAsElement(config, writer);\n                        Pooled.SETUP_INTERVAL.marshallAsElement(config, writer);\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n\n        if(factory.hasDefined(TRANSACTION)) {\n            writer.writeStartElement(Element.TRANSACTION.getLocalName());\n            writeTransactionTypeAttribute(writer, Element.MODE, factory.get(TRANSACTION));\n            writer.writeEndElement();\n        }\n\n        Pooled.MIN_POOL_SIZE.marshallAsElement(factory, writer);\n        Pooled.MAX_POOL_SIZE.marshallAsElement(factory, writer);\n        Pooled.USE_AUTO_RECOVERY.marshallAsElement(factory, writer);\n    }","id":102111,"modified_method":"private static void writePooledConnectionFactoryAttributes(XMLExtendedStreamWriter writer, String name, ModelNode factory)\n            throws XMLStreamException {\n\n        Pooled.USER.marshallAsElement(factory, writer);\n        Pooled.PASSWORD.marshallAsElement(factory, writer);\n\n        if(factory.hasDefined(INBOUND_CONFIG)) {\n            final ModelNode inboundConfigs = factory.get(INBOUND_CONFIG);\n            if (inboundConfigs.getType() == ModelType.LIST) {\n                writer.writeStartElement(Element.INBOUND_CONFIG.getLocalName());\n                for (ModelNode config : inboundConfigs.asList()) {\n                    if (config.isDefined()) {\n                        Pooled.USE_JNDI.marshallAsElement(config, writer);\n                        Pooled.JNDI_PARAMS.marshallAsElement(config, writer);\n                        Pooled.USE_LOCAL_TX.marshallAsElement(config, writer);\n                        Pooled.SETUP_ATTEMPTS.marshallAsElement(config, writer);\n                        Pooled.SETUP_INTERVAL.marshallAsElement(config, writer);\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n\n        Pooled.TRANSACTION.marshallAsElement(factory, writer);\n        Pooled.MIN_POOL_SIZE.marshallAsElement(factory, writer);\n        Pooled.MAX_POOL_SIZE.marshallAsElement(factory, writer);\n        Pooled.USE_AUTO_RECOVERY.marshallAsElement(factory, writer);\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void writeBroadcastGroups(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.BROADCAST_GROUPS.getLocalName());\n            for(final Property property : properties) {\n                writer.writeStartElement(Element.BROADCAST_GROUP.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                for (AttributeDefinition attribute : BroadcastGroupDefinition.ATTRIBUTES) {\n                    attribute.marshallAsElement(property.getValue(), writer);\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","id":102112,"modified_method":"private static void writeBroadcastGroups(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        if (!node.isDefined()) {\n            return;\n        }\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            writer.writeStartElement(Element.BROADCAST_GROUPS.getLocalName());\n            for(final Property property : properties) {\n                writer.writeStartElement(Element.BROADCAST_GROUP.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                for (AttributeDefinition attribute : BroadcastGroupDefinition.ATTRIBUTES) {\n                    attribute.marshallAsElement(property.getValue(), writer);\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        ModelNode opAddr = operation.require(OP_ADDR);\n        final PathAddress address = PathAddress.pathAddress(opAddr);\n        final String name = address.getLastElement().getValue();\n\n        final ModelNode resolvedModel = model.clone();\n        for(final AttributeDefinition attribute : getDefinitions(PooledConnectionFactoryDefinition.ATTRIBUTES)) {\n            resolvedModel.get(attribute.getName()).set(attribute.resolveModelAttribute(context, resolvedModel ));\n        }\n\n        // We validated that jndiName part of the model in populateModel\n        // TODO we only use a single jndi name here but the xsd indicates support for many\n        final String jndiName = resolvedModel.get(JndiEntriesAttribute.CONNECTION_FACTORY.getName()).asList().get(0).asString();\n\n        final int minPoolSize = resolvedModel.get(ConnectionFactoryAttributes.Pooled.MIN_POOL_SIZE.getName()).asInt();\n        final int maxPoolSize = resolvedModel.get(ConnectionFactoryAttributes.Pooled.MAX_POOL_SIZE.getName()).asInt();\n\n        final String txSupport;\n        if(resolvedModel.hasDefined(TRANSACTION)) {\n            String txType = resolvedModel.get(TRANSACTION).asString();\n            if(LOCAL.equals(txType)) {\n                txSupport = LOCAL_TX;\n            } else if (NONE.equals(txType)) {\n                 txSupport = NO_TX;\n            } else {\n                txSupport = XA_TX;\n            }\n        } else {\n            txSupport = XA_TX;\n        }\n\n        ServiceTarget serviceTarget = context.getServiceTarget();\n\n        List<String> connectors = getConnectors(resolvedModel);\n\n        String discoveryGroupName = getDiscoveryGroup(resolvedModel);\n\n        List<PooledConnectionFactoryConfigProperties> adapterParams = getAdapterParams(resolvedModel, context);\n\n        final ServiceName hqServiceName = MessagingServices.getHornetQServiceName(address);\n        ServiceName hornetQResourceAdapterService = JMSServices.getPooledConnectionFactoryBaseServiceName(hqServiceName).append(name);\n        PooledConnectionFactoryService resourceAdapterService = new PooledConnectionFactoryService(name, connectors, discoveryGroupName, adapterParams, jndiName, txSupport, minPoolSize, maxPoolSize);\n        ServiceBuilder serviceBuilder = serviceTarget\n                .addService(hornetQResourceAdapterService, resourceAdapterService)\n                .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, resourceAdapterService.getTransactionManager())\n                .addDependency(hqServiceName, HornetQServer.class, resourceAdapterService.getHornetQService())\n                .addDependency(JMSServices.getJmsManagerBaseServiceName(hqServiceName))\n                .addListener(verificationHandler);\n\n        newControllers.add(serviceBuilder.setInitialMode(Mode.ACTIVE).install());\n    }","id":102113,"modified_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        ModelNode opAddr = operation.require(OP_ADDR);\n        final PathAddress address = PathAddress.pathAddress(opAddr);\n        final String name = address.getLastElement().getValue();\n\n        final ModelNode resolvedModel = model.clone();\n        for(final AttributeDefinition attribute : getDefinitions(PooledConnectionFactoryDefinition.ATTRIBUTES)) {\n            resolvedModel.get(attribute.getName()).set(attribute.resolveModelAttribute(context, resolvedModel ));\n        }\n\n        // We validated that jndiName part of the model in populateModel\n        // TODO we only use a single jndi name here but the xsd indicates support for many\n        final String jndiName = resolvedModel.get(JndiEntriesAttribute.CONNECTION_FACTORY.getName()).asList().get(0).asString();\n\n        final int minPoolSize = resolvedModel.get(ConnectionFactoryAttributes.Pooled.MIN_POOL_SIZE.getName()).asInt();\n        final int maxPoolSize = resolvedModel.get(ConnectionFactoryAttributes.Pooled.MAX_POOL_SIZE.getName()).asInt();\n\n        final String txSupport;\n        if(resolvedModel.hasDefined(ConnectionFactoryAttributes.Pooled.TRANSACTION.getName())) {\n            String txType = resolvedModel.get(ConnectionFactoryAttributes.Pooled.TRANSACTION.getName()).asString();\n            if(LOCAL.equals(txType)) {\n                txSupport = LOCAL_TX;\n            } else if (NONE.equals(txType)) {\n                 txSupport = NO_TX;\n            } else {\n                txSupport = XA_TX;\n            }\n        } else {\n            txSupport = XA_TX;\n        }\n\n        ServiceTarget serviceTarget = context.getServiceTarget();\n\n        List<String> connectors = getConnectors(resolvedModel);\n\n        String discoveryGroupName = getDiscoveryGroup(resolvedModel);\n\n        List<PooledConnectionFactoryConfigProperties> adapterParams = getAdapterParams(resolvedModel, context);\n\n        final ServiceName hqServiceName = MessagingServices.getHornetQServiceName(address);\n        ServiceName hornetQResourceAdapterService = JMSServices.getPooledConnectionFactoryBaseServiceName(hqServiceName).append(name);\n        PooledConnectionFactoryService resourceAdapterService = new PooledConnectionFactoryService(name, connectors, discoveryGroupName, adapterParams, jndiName, txSupport, minPoolSize, maxPoolSize);\n        ServiceBuilder serviceBuilder = serviceTarget\n                .addService(hornetQResourceAdapterService, resourceAdapterService)\n                .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, resourceAdapterService.getTransactionManager())\n                .addDependency(hqServiceName, HornetQServer.class, resourceAdapterService.getHornetQService())\n                .addDependency(JMSServices.getJmsManagerBaseServiceName(hqServiceName))\n                .addListener(verificationHandler);\n\n        newControllers.add(serviceBuilder.setInitialMode(Mode.ACTIVE).install());\n    }","commit_id":"e5de2fe47dbfc79f038d269c30191fb9b34ff09d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testUnsafeDriver(RuleBase ruleBase) {\n\t\tStatefulSession session = ruleBase.newStatefulSession();\n\t\t\n\t\tDriver driver = new Driver();\n\t\tdriver.setPriorClaims(new Integer(4));\n\t\tPolicy policy = new Policy();\n\t\tpolicy.setType(\"COMPREHENSIVE\");\n\t\tpolicy.setApproved(false);\n\t\t\n\t\t\n        Future futureAssertDrv = session.asyncInsert( driver );\n        Future futureAssertPol = session.asyncInsert( policy );\n        Future futureFireAllRules = session.asyncFireAllRules();\n\n        System.out.println(\"Policy approved: \" + policy.isApproved());\n\t}","id":102114,"modified_method":"private void testUnsafeDriver(RuleBase ruleBase) {\n\t\tStatefulSession session = ruleBase.newStatefulSession();\n\t\t\n\t\tDriver driver = new Driver();\n\t\tdriver.setPriorClaims(new Integer(1));\n\t\tPolicy policy = new Policy();\n\t\tpolicy.setType(\"COMPREHENSIVE\");\n\t\tpolicy.setApproved(false);\n\t\t\n\t\tsession.insert(driver);\n\t\tsession.insert(policy);\n\t\tsession.fireAllRules();\n\t}","commit_id":"453121a7f170360ccb8fb55b4c91f5f568779e59","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void testSafeMature(RuleBase ruleBase) {\n\t\tStatefulSession session = ruleBase.newStatefulSession();\n\t\t\n\t\tDriver driver = new Driver();\n\t\tdriver.setPriorClaims(new Integer(0));\n\t\tdriver.setAge(new Integer(45));\n\t\t\n\t\tPolicy policy = new Policy();\n\t\tpolicy.setType(\"COMPREHENSIVE\");\n\t\tpolicy.setApproved(false);\n\t\t\n        Future futureAssertDrv = session.asyncInsert( driver );\n        Future futureAssertPol = session.asyncInsert( policy );\n        Future futureFireAllRules = session.asyncFireAllRules();\n\t}","id":102115,"modified_method":"private void testSafeMature(RuleBase ruleBase) {\n\t\tStatefulSession session = ruleBase.newStatefulSession();\n\t\t\n\t\tDriver driver = new Driver();\n\t\tdriver.setPriorClaims(new Integer(0));\n\t\tdriver.setAge(new Integer(45));\n\t\t\n\t\tPolicy policy = new Policy();\n\t\tpolicy.setType(\"COMPREHENSIVE\");\n\t\tpolicy.setApproved(false);\n\t\t\n\t\tsession.insert(driver);\n\t\tsession.insert(policy);\n\t\tsession.fireAllRules();\n\t}","commit_id":"453121a7f170360ccb8fb55b4c91f5f568779e59","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void testUnsafeAreaAndPriors(RuleBase ruleBase) {\n\t\tStatefulSession session = ruleBase.newStatefulSession();\n\t\t\n\t\tDriver driver = new Driver();\n\t\tdriver.setPriorClaims(new Integer(2));\n\t\tdriver.setAge(new Integer(55));\n\t\tdriver.setLocationRiskProfile(\"LOW\");\n\t\t\n\t\tPolicy policy = new Policy();\n\t\tpolicy.setType(\"COMPREHENSIVE\");\n\t\tpolicy.setApproved(false);\n\t\t\n        Future futureAssertDrv = session.asyncInsert( driver );\n        Future futureAssertPol = session.asyncInsert( policy );\n        Future futureFireAllRules = session.asyncFireAllRules();\n\t}","id":102116,"modified_method":"private void testUnsafeAreaAndPriors(RuleBase ruleBase) {\n\t\tStatefulSession session = ruleBase.newStatefulSession();\n\t\t\n\t\tDriver driver = new Driver();\n\t\tdriver.setPriorClaims(new Integer(20));\n\t\tdriver.setAge(new Integer(55));\n\t\tdriver.setLocationRiskProfile(\"LOW\");\n\t\t\n\t\tPolicy policy = new Policy();\n\t\tpolicy.setType(\"COMPREHENSIVE\");\n\t\tpolicy.setApproved(false);\n\t\t\n\t\tsession.insert(driver);\n\t\tsession.insert(policy);\n\t\tsession.fireAllRules();\n\t}","commit_id":"453121a7f170360ccb8fb55b4c91f5f568779e59","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected NodeSet getChildren(XQueryContext context, NodeSet contextSet) {\n\t\tif (test.isWildcardTest()) {\n\t\t\t// test is one out of *, text(), node()\n\t\t\tVirtualNodeSet vset = new VirtualNodeSet(axis, test, contextSet);\n\t\t\tvset.setInPredicate(inPredicate);\n\t\t\treturn vset;\n\t\t} else if(preloadNodeSets()) {\n\t\t\tDocumentSet docs = getDocumentSet(contextSet);\n\t\t\tif (currentSet == null || currentDocs == null || !(docs == currentDocs || docs.equals(currentDocs))) {\n                currentDocs = docs;\n                currentSet =\n                    (NodeSet) context.getBroker().getElementIndex().findElementsByTagName(\n                        ElementValue.ELEMENT, currentDocs, test.getName(), null);\n                registerUpdateListener();\n            }\n            return currentSet.selectParentChild(contextSet, NodeSet.DESCENDANT, inPredicate);\n\t\t} else {\n\t\t    DocumentSet docs = getDocumentSet(contextSet);\n\t\t    NodeSelector selector = new ChildSelector(contextSet, inPredicate);\n\t\t    return context.getBroker().getElementIndex().findElementsByTagName(\n\t\t    \t\tElementValue.ELEMENT, docs, test.getName(), selector\n\t\t    );\n\t\t}\n\t}","id":102117,"modified_method":"protected NodeSet getChildren(XQueryContext context, NodeSet contextSet) {\n\t\tif (test.isWildcardTest()) {\n\t\t\t// test is one out of *, text(), node()\n\t\t\tVirtualNodeSet vset = new VirtualNodeSet(axis, test, contextSet);\n\t\t\tvset.setInPredicate(inPredicate);\n\t\t\treturn vset;\n\t\t} else if (preloadNodeSets()) {            \n\t\t\tDocumentSet docs = getDocumentSet(contextSet);\n\t\t\t//TODO : understand why this one is different from the other ones\n\t\t\tif (currentSet == null || currentDocs == null || !(docs == currentDocs || docs.equals(currentDocs))) {\n                ElementIndex index = context.getBroker().getElementIndex();                \n                currentSet = index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n            }\n            return currentSet.selectParentChild(contextSet, NodeSet.DESCENDANT, inPredicate);\n\t\t} else {\n            ElementIndex index = context.getBroker().getElementIndex();\n\t\t    DocumentSet docs = getDocumentSet(contextSet);\n\t\t    NodeSelector selector = new ChildSelector(contextSet, inPredicate);\n\t\t    return index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), selector);\n\t\t}\n\t}","commit_id":"0be43802f233be1d4879dd881fdb77eefa4d35c9","url":"https://github.com/eXist-db/exist"},{"original_method":"protected NodeSet getPreceding(XQueryContext context, NodeSet contextSet)\n    throws XPathException {\n        NodeSet result = NodeSet.EMPTY_SET;\n        if(!test.isWildcardTest()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            if (currentSet == null || currentDocs == null || !(docs.equals(currentDocs))) {\n                currentDocs = docs;\n                currentSet =\n                    (NodeSet) context.getBroker().getElementIndex().findElementsByTagName(\n                        ElementValue.ELEMENT, currentDocs, test.getName(), null);\n                registerUpdateListener();\n            }\n            result = currentSet.selectPreceding(contextSet);\n        }\n        return result;\n    }","id":102118,"modified_method":"protected NodeSet getPreceding(XQueryContext context, NodeSet contextSet) throws XPathException {        \n        if(!test.isWildcardTest()) {            \n            DocumentSet docs = getDocumentSet(contextSet);\n            if (currentSet == null || currentDocs == null || !(docs.equals(currentDocs))) {\n                ElementIndex index = context.getBroker().getElementIndex();                \n                currentSet = index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n            }\n            return currentSet.selectPreceding(contextSet);\n        }\n        //TODO : throw an exception here ! Don't let this pass through\n        return NodeSet.EMPTY_SET;\n    }","commit_id":"0be43802f233be1d4879dd881fdb77eefa4d35c9","url":"https://github.com/eXist-db/exist"},{"original_method":"protected NodeSet getSiblings(\n\t\tXQueryContext context,\n\t\tNodeSet contextSet) {\n\t\tNodeSet result;\n\t\tif (!test.isWildcardTest()) {\n\t\t    DocumentSet docs = getDocumentSet(contextSet);\n\t\t\tif (currentSet == null || currentDocs == null || !(docs.equals(currentDocs))) {\n\t\t\t\tcurrentDocs = docs;\n\t\t\t\tcurrentSet =\n\t\t\t\t\t(NodeSet) context.getBroker().getElementIndex().findElementsByTagName(\n\t\t\t\t\t\tElementValue.ELEMENT, currentDocs, test.getName(), null);\n\t\t\t\tregisterUpdateListener();\n\t\t\t} \n            switch (axis) {\n                case Constants.PRECEDING_SIBLING_AXIS :             \n                    return currentSet.selectSiblings(contextSet, NodeSet.PRECEDING);                    \n                case Constants.FOLLOWING_SIBLING_AXIS :\n                    return currentSet.selectSiblings(contextSet, NodeSet.FOLLOWING);                   \n                default :\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");                   \n            }\t\t\t\n\t\t} else {\n\t\t\tresult = new ArraySet(contextSet.getLength());\n\t\t\tNodeProxy p, sib;\n\t\t\tNodeImpl n;\n\t\t\tfor (Iterator i = contextSet.iterator(); i.hasNext();) {\n\t\t\t\tp = (NodeProxy) i.next();\n\t\t\t\tn = (NodeImpl) p.getNode();\n\t\t\t\twhile ((n = getNextSibling(n)) != null) {\n\t\t\t\t\tif (test.matches(n)) {\n\t\t\t\t\t\tsib = new NodeProxy((DocumentImpl) n.getOwnerDocument(), n.getGID(),\n\t\t\t\t\t\t\t\tn.getInternalAddress());\n                        if (inPredicate)\n                            sib.addContextNode(p);\n                        else\n                            sib.copyContext(p);\n                        result.add(sib);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":102119,"modified_method":"protected NodeSet getSiblings(XQueryContext context, NodeSet contextSet) {\t\t\n\t\tif (!test.isWildcardTest()) {            \n\t\t    DocumentSet docs = getDocumentSet(contextSet);\n\t\t\tif (currentSet == null || currentDocs == null || !(docs.equals(currentDocs))) {\n                ElementIndex index = context.getBroker().getElementIndex();\t\t\t\t\n\t\t\t\tcurrentSet = index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n\t\t\t} \n            switch (axis) {\n                case Constants.PRECEDING_SIBLING_AXIS :             \n                    return currentSet.selectSiblings(contextSet, NodeSet.PRECEDING);                    \n                case Constants.FOLLOWING_SIBLING_AXIS :\n                    return currentSet.selectSiblings(contextSet, NodeSet.FOLLOWING);                   \n                default :\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");                   \n            }\t\t\t\n\t\t} else {\n\t\t\tNodeSet result = new ArraySet(contextSet.getLength());\n\t\t\tNodeProxy p, sib;\n\t\t\tNodeImpl n;\n\t\t\tfor (Iterator i = contextSet.iterator(); i.hasNext();) {\n\t\t\t\tp = (NodeProxy) i.next();\n\t\t\t\tn = (NodeImpl) p.getNode();\n\t\t\t\twhile ((n = getNextSibling(n)) != null) {\n\t\t\t\t\tif (test.matches(n)) {\n\t\t\t\t\t\tsib = new NodeProxy((DocumentImpl) n.getOwnerDocument(), n.getGID(),\n\t\t\t\t\t\t\t\tn.getInternalAddress());\n                        if (inPredicate)\n                            sib.addContextNode(p);\n                        else\n                            sib.copyContext(p);\n                        result.add(sib);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            return result;\n\t\t}\t\t\n\t}","commit_id":"0be43802f233be1d4879dd881fdb77eefa4d35c9","url":"https://github.com/eXist-db/exist"},{"original_method":"protected NodeSet getAttributes(XQueryContext context, NodeSet contextSet) {\t\t\n\t\tif (test.isWildcardTest()) {\n            NodeSet result = new VirtualNodeSet(axis, test, contextSet);\n\t\t\t((VirtualNodeSet) result).setInPredicate(inPredicate);\n            return result;\n\t\t// if there's just a single known node in the context, it is faster\n\t    // do directly search for the attribute in the parent node.\n        } else if(axis == Constants.ATTRIBUTE_AXIS && contextSet.getLength() == 1\n                && !(contextSet instanceof VirtualNodeSet)) {\n            NodeProxy proxy = contextSet.get(0);\n            if (proxy.getInternalAddress() != NodeProxy.UNKNOWN_NODE_ADDRESS)                \n                return contextSet.directSelectAttribute(test.getName(), inPredicate);\n        }       \n        if(preloadNodeSets()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            if (currentSet == null || currentDocs == null || !(docs.equals(currentDocs))) {\n                currentDocs = docs;\n                currentSet =\n                    (NodeSet) context.getBroker().getElementIndex().findElementsByTagName(\n                        ElementValue.ATTRIBUTE,\n                        currentDocs,\n                        test.getName(), null);\n                registerUpdateListener();\n            }\n            switch (axis) {\n                case Constants.ATTRIBUTE_AXIS :\n                    return currentSet.selectParentChild(contextSet, NodeSet.DESCENDANT, inPredicate);                              \n                case Constants.DESCENDANT_ATTRIBUTE_AXIS :             \n                    return currentSet.selectAncestorDescendant(contextSet, NodeSet.DESCENDANT, false, inPredicate);                    \n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");                   \n            }       \n\t\t} else {\n\t\t\tNodeSelector selector;\n            DocumentSet docs = getDocumentSet(contextSet);\n            switch (axis) {\n                case Constants.ATTRIBUTE_AXIS :\n                    selector = new ChildSelector(contextSet, inPredicate);  \n                    //TODO : find when this condition must return true !\n                    //It should for :\n                    //let $a := (<c id=\"1\"><d id=\"2\">d<\/d><e>e<\/e><\/c>)/descendant-or-self::node()\n                    //for $b in $a/attribute::id\n                    //return <b>{$b}<\/b>\n                    if (false) \n                        ((ChildSelector)selector).setMysteriousCondition();\n                    break;\n                case Constants.DESCENDANT_ATTRIBUTE_AXIS : \n                    selector = new DescendantSelector(contextSet, inPredicate); \n                    break;\n               default:\n                   throw new IllegalArgumentException(\"Unsupported axis specified\");                   \n\t\t\t}    \t\t\t\n            return context.getBroker().getElementIndex().getAttributesByName(docs, test.getName(), selector);                          \n\t\t}    \n\t}","id":102120,"modified_method":"protected NodeSet getAttributes(XQueryContext context, NodeSet contextSet) {\t\t\n\t\tif (test.isWildcardTest()) {\n            NodeSet result = new VirtualNodeSet(axis, test, contextSet);\n\t\t\t((VirtualNodeSet) result).setInPredicate(inPredicate);\n            return result;\n\t\t// if there's just a single known node in the context, it is faster\n\t    // do directly search for the attribute in the parent node.\n        } else if(axis == Constants.ATTRIBUTE_AXIS && contextSet.getLength() == 1\n                && !(contextSet instanceof VirtualNodeSet)) {\n            NodeProxy proxy = contextSet.get(0);\n            if (proxy.getInternalAddress() != NodeProxy.UNKNOWN_NODE_ADDRESS)                \n                return contextSet.directSelectAttribute(test.getName(), inPredicate);\n        }       \n        if (preloadNodeSets()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            if (currentSet == null || currentDocs == null || !(docs.equals(currentDocs))) { \n                ElementIndex index = context.getBroker().getElementIndex();                          \n                //TODO : why a null selector here ? Whe have one below !\n                currentSet = index.findElementsByTagName(ElementValue.ATTRIBUTE, docs, test.getName(), null);  \n                currentDocs = docs;      \n                registerUpdateListener();\n            }\n            switch (axis) {\n                case Constants.ATTRIBUTE_AXIS :\n                    return currentSet.selectParentChild(contextSet, NodeSet.DESCENDANT, inPredicate);                              \n                case Constants.DESCENDANT_ATTRIBUTE_AXIS :             \n                    return currentSet.selectAncestorDescendant(contextSet, NodeSet.DESCENDANT, false, inPredicate);                    \n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");                   \n            }       \n\t\t} else {\n\t\t\tNodeSelector selector;            \n            DocumentSet docs = getDocumentSet(contextSet);\n            //TODO : why a selector here ? We havn't one above !\n            switch (axis) {\n                case Constants.ATTRIBUTE_AXIS :\n                    selector = new ChildSelector(contextSet, inPredicate);  \n                    //TODO : find when this condition must return true !\n                    //It should for :\n                    //let $a := (<c id=\"1\"><d id=\"2\">d<\/d><e>e<\/e><\/c>)/descendant-or-self::node()\n                    //for $b in $a/attribute::id\n                    //return <b>{$b}<\/b>\n                    //Note that it also works with selector = null\n                    if (false) \n                        ((ChildSelector)selector).setMysteriousCondition();\n                    break;\n                case Constants.DESCENDANT_ATTRIBUTE_AXIS : \n                    selector = new DescendantSelector(contextSet, inPredicate); \n                    break;\n               default:\n                   throw new IllegalArgumentException(\"Unsupported axis specified\");                   \n\t\t\t}    \t\t\t\n            ElementIndex index = context.getBroker().getElementIndex();\n            return index.getAttributesByName(docs, test.getName(), selector);\n            \n\t\t}    \n\t}","commit_id":"0be43802f233be1d4879dd881fdb77eefa4d35c9","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * @param context\n\t * @param contextSet\n\t * @return\n\t */\n\tprotected Sequence getSelf(XQueryContext context, NodeSet contextSet) {\n\t\tif(test.isWildcardTest()) {\n            if (nodeTestType == null)\n                nodeTestType = Integer.valueOf(test.getType());   \n\t\t\tif(nodeTestType.intValue() == Type.NODE) {\n\t\t\t\tif (inPredicate) {\n\t\t\t\t\tif (contextSet instanceof VirtualNodeSet) {\n\t\t\t\t\t\t((VirtualNodeSet) contextSet).setInPredicate(true);\n\t\t\t\t\t\t((VirtualNodeSet) contextSet).setSelfIsContext();\n                    } else if(Type.subTypeOf(contextSet.getItemType(), Type.NODE)) {\n\t\t\t\t\t\tNodeProxy p;\n\t\t\t\t\t\tfor (Iterator i = contextSet.iterator(); i.hasNext();) {\n\t\t\t\t\t\t\tp = (NodeProxy) i.next();\n\t\t\t\t\t\t\tif (test.matches(p))\n\t\t\t\t\t\t\t\tp.addContextNode(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn contextSet;\n\t\t\t} else {\n//                NodeSet result = new ExtArrayNodeSet();\n//                NodeProxy p;\n//                for (Iterator i = contextSet.iterator(); i.hasNext(); ) {\n//                    p = (NodeProxy) i.next();\n//                    if (test.matches(p)) {\n//                        result.add(p);\n//                        p.addContextNode(p);\n//                    }\n//                }\n//                return result;\n\t\t\t\tVirtualNodeSet vset = new VirtualNodeSet(axis, test, contextSet);\n\t\t\t\tvset.setInPredicate(inPredicate);\n\t\t\t\treturn vset;\n\t\t\t}\n\t\t} else {\n\t\t\tDocumentSet docs = getDocumentSet(contextSet);\n\t\t    NodeSelector selector = new SelfSelector(contextSet, inPredicate);\n\t\t    return context.getBroker().getElementIndex().findElementsByTagName(\n\t\t    \t\tElementValue.ELEMENT, docs, test.getName(), selector);\n\t\t}\n\t}","id":102121,"modified_method":"/**\n\t * @param context\n\t * @param contextSet\n\t * @return\n\t */\n\tprotected Sequence getSelf(XQueryContext context, NodeSet contextSet) {\n\t\tif(test.isWildcardTest()) {\n            if (nodeTestType == null)\n                nodeTestType = Integer.valueOf(test.getType());   \n\t\t\tif(nodeTestType.intValue() == Type.NODE) {\n\t\t\t\tif (inPredicate) {\n\t\t\t\t\tif (contextSet instanceof VirtualNodeSet) {\n\t\t\t\t\t\t((VirtualNodeSet) contextSet).setInPredicate(true);\n\t\t\t\t\t\t((VirtualNodeSet) contextSet).setSelfIsContext();\n                    } else if(Type.subTypeOf(contextSet.getItemType(), Type.NODE)) {\n\t\t\t\t\t\tNodeProxy p;\n\t\t\t\t\t\tfor (Iterator i = contextSet.iterator(); i.hasNext();) {\n\t\t\t\t\t\t\tp = (NodeProxy) i.next();\n\t\t\t\t\t\t\tif (test.matches(p))\n\t\t\t\t\t\t\t\tp.addContextNode(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn contextSet;\n\t\t\t} else {\n//                NodeSet result = new ExtArrayNodeSet();\n//                NodeProxy p;\n//                for (Iterator i = contextSet.iterator(); i.hasNext(); ) {\n//                    p = (NodeProxy) i.next();\n//                    if (test.matches(p)) {\n//                        result.add(p);\n//                        p.addContextNode(p);\n//                    }\n//                }\n//                return result;\n\t\t\t\tVirtualNodeSet vset = new VirtualNodeSet(axis, test, contextSet);\n\t\t\t\tvset.setInPredicate(inPredicate);\n\t\t\t\treturn vset;\n\t\t\t}\n\t\t} else {            \n\t\t\tDocumentSet docs = getDocumentSet(contextSet);\n\t\t    NodeSelector selector = new SelfSelector(contextSet, inPredicate);\n            ElementIndex index = context.getBroker().getElementIndex();\n\t\t    return index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), selector);\n\t\t}\n\t}","commit_id":"0be43802f233be1d4879dd881fdb77eefa4d35c9","url":"https://github.com/eXist-db/exist"},{"original_method":"protected NodeSet getDescendants(XQueryContext context,\tNodeSet contextSet) {\n\t\tif (test.isWildcardTest()) {\n\t\t\t// test is one out of *, text(), node()\n\t\t\tVirtualNodeSet vset = new VirtualNodeSet(axis, test, contextSet);\n\t\t\tvset.setInPredicate(inPredicate);\n\t\t\treturn vset;\n\t\t} else if(preloadNodeSets()){            \n\t\t    DocumentSet docs = getDocumentSet(contextSet);\n\t\t\tif (currentSet == null || currentDocs == null || !(docs == currentDocs || docs.equals(currentDocs))) {\n                currentDocs = docs;\n                currentSet =\n                    (NodeSet) context.getBroker().getElementIndex().findElementsByTagName(\n                        ElementValue.ELEMENT, currentDocs, test.getName(), null);\n                registerUpdateListener();\n            }            \n            switch (axis) {\n                case Constants.DESCENDANT_SELF_AXIS :                 \n                    return currentSet.selectAncestorDescendant(contextSet, NodeSet.DESCENDANT, \n                            true, inPredicate);\n                case Constants.DESCENDANT_AXIS :                \n                    return currentSet.selectAncestorDescendant(contextSet, NodeSet.DESCENDANT, \n                            false, inPredicate);\n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");\n            }            \n\t\t} else {\n            NodeSelector selector;\n\t\t\tDocumentSet docs = contextSet.getDocumentSet();            \n            switch (axis) {\n                case Constants.DESCENDANT_SELF_AXIS : \n                    selector = new DescendantOrSelfSelector(contextSet, inPredicate);\n                    break;\n                case Constants.DESCENDANT_AXIS :\n                    selector = new DescendantSelector(contextSet, inPredicate);\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");                          \n            }\n\t\t\treturn context.getBroker().getElementIndex().findElementsByTagName(\n\t\t\t\t\tElementValue.ELEMENT, docs, test.getName(), selector);\n\t\t}\n\t}","id":102122,"modified_method":"protected NodeSet getDescendants(XQueryContext context,\tNodeSet contextSet) {\n\t\tif (test.isWildcardTest()) {\n\t\t\t// test is one out of *, text(), node()\n\t\t\tVirtualNodeSet vset = new VirtualNodeSet(axis, test, contextSet);\n\t\t\tvset.setInPredicate(inPredicate);\n\t\t\treturn vset;\n\t\t} else if (preloadNodeSets()) {             \n\t\t    DocumentSet docs = getDocumentSet(contextSet);\n            //TODO : understand why this one is different from the other ones\n\t\t\tif (currentSet == null || currentDocs == null || !(docs == currentDocs || docs.equals(currentDocs))) {\n                ElementIndex index = context.getBroker().getElementIndex();                \n                currentSet = index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n            }            \n            switch (axis) {\n                case Constants.DESCENDANT_SELF_AXIS :                 \n                    return currentSet.selectAncestorDescendant(contextSet, NodeSet.DESCENDANT, true, inPredicate);\n                case Constants.DESCENDANT_AXIS :                \n                    return currentSet.selectAncestorDescendant(contextSet, NodeSet.DESCENDANT, false, inPredicate);\n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");\n            }            \n\t\t} else {            \n            NodeSelector selector;\n\t\t\tDocumentSet docs = contextSet.getDocumentSet();            \n            switch (axis) {\n                case Constants.DESCENDANT_SELF_AXIS : \n                    selector = new DescendantOrSelfSelector(contextSet, inPredicate);\n                    break;\n                case Constants.DESCENDANT_AXIS :\n                    selector = new DescendantSelector(contextSet, inPredicate);\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");                          \n            }\n            ElementIndex index = context.getBroker().getElementIndex();\n\t\t\treturn index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), selector);\n\t\t}\n\t}","commit_id":"0be43802f233be1d4879dd881fdb77eefa4d35c9","url":"https://github.com/eXist-db/exist"},{"original_method":"protected NodeSet getAncestors(XQueryContext context, NodeSet contextSet) {\t\t\n\t\tif (test.isWildcardTest()) {\n            NodeSet result = new ExtArrayNodeSet();\n            NodeProxy p, ancestor;\n            for (Iterator i = contextSet.iterator(); i.hasNext();) {\n                p = (NodeProxy) i.next();\n                if (axis == Constants.ANCESTOR_SELF_AXIS && test.matches(p)) {\n                    ancestor = new NodeProxy(p.getDocument(), p.gid, p.getInternalAddress());\n                    if (inPredicate)\n                        ancestor.addContextNode(p);\n                    else\n                        ancestor.copyContext(p);\n                    result.add(ancestor);\n                }\n                ancestor = new NodeProxy(p.getDocument(), p.gid);\n                while ((ancestor.gid = XMLUtil.getParentId(p.getDocument(), ancestor.gid)) > 0) {\n                    ancestor.nodeType = Node.ELEMENT_NODE;\n                    if (test.matches(ancestor)) {\n                        if (inPredicate)\n                            ancestor.addContextNode(p);\n                        else\n                            ancestor.copyContext(p);\n                        result.add(ancestor);\n                        ancestor = new NodeProxy(p.getDocument(), ancestor.gid);\n                    }\n                }\n            }\n            return result;\n        } else if(preloadNodeSets()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            if (currentSet == null || currentDocs == null || !(docs.equals(currentDocs))) {\n                currentDocs = docs;\n                currentSet =\n                    context.getBroker().getElementIndex().findElementsByTagName(\n                            ElementValue.ELEMENT, currentDocs, test.getName(), null);\n                registerUpdateListener();\n            }           \n            switch (axis) {\n                case Constants.ANCESTOR_SELF_AXIS :\n                    return currentSet.selectAncestors(contextSet, true, inPredicate);                   \n                case Constants.ANCESTOR_AXIS :             \n                    return currentSet.selectAncestors(contextSet, false, inPredicate);                    \n                default :\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");                   \n            }        \n\t\t} else {\n            NodeSelector selector;\n            DocumentSet docs = getDocumentSet(contextSet);\n            switch (axis) {\n                case Constants.ANCESTOR_SELF_AXIS :\n                    selector = new AncestorSelector(contextSet, inPredicate, true); \n                    break;\n                case Constants.ANCESTOR_AXIS :             \n                    selector = new AncestorSelector(contextSet, inPredicate, false);\n                    break;\n                default :\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");                   \n            }\n            return context.getBroker().getElementIndex().findElementsByTagName(\n                    ElementValue.ELEMENT, docs, test.getName(), selector);\n\t\t}\t\t\n\t}","id":102123,"modified_method":"protected NodeSet getAncestors(XQueryContext context, NodeSet contextSet) {\t\t\n\t\tif (test.isWildcardTest()) {\n            NodeSet result = new ExtArrayNodeSet();\n            NodeProxy p, ancestor;\n            for (Iterator i = contextSet.iterator(); i.hasNext();) {\n                p = (NodeProxy) i.next();\n                if (axis == Constants.ANCESTOR_SELF_AXIS && test.matches(p)) {\n                    ancestor = new NodeProxy(p.getDocument(), p.gid, p.getInternalAddress());\n                    if (inPredicate)\n                        ancestor.addContextNode(p);\n                    else\n                        ancestor.copyContext(p);\n                    result.add(ancestor);\n                }\n                ancestor = new NodeProxy(p.getDocument(), p.gid);\n                while ((ancestor.gid = XMLUtil.getParentId(p.getDocument(), ancestor.gid)) > 0) {\n                    ancestor.nodeType = Node.ELEMENT_NODE;\n                    if (test.matches(ancestor)) {\n                        if (inPredicate)\n                            ancestor.addContextNode(p);\n                        else\n                            ancestor.copyContext(p);\n                        result.add(ancestor);\n                        ancestor = new NodeProxy(p.getDocument(), ancestor.gid);\n                    }\n                }\n            }\n            return result;\n        } else if (preloadNodeSets()) {            \n            DocumentSet docs = getDocumentSet(contextSet);\n            if (currentSet == null || currentDocs == null || !(docs.equals(currentDocs))) {\n                ElementIndex index = context.getBroker().getElementIndex();                \n                currentSet = index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n            }           \n            switch (axis) {\n                case Constants.ANCESTOR_SELF_AXIS :\n                    return currentSet.selectAncestors(contextSet, true, inPredicate);                   \n                case Constants.ANCESTOR_AXIS :             \n                    return currentSet.selectAncestors(contextSet, false, inPredicate);                    \n                default :\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");                   \n            }        \n\t\t} else {\n            NodeSelector selector;            \n            DocumentSet docs = getDocumentSet(contextSet);\n            switch (axis) {\n                case Constants.ANCESTOR_SELF_AXIS :\n                    selector = new AncestorSelector(contextSet, inPredicate, true); \n                    break;\n                case Constants.ANCESTOR_AXIS :             \n                    selector = new AncestorSelector(contextSet, inPredicate, false);\n                    break;\n                default :\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");                   \n            }\n            ElementIndex index = context.getBroker().getElementIndex();\n            return index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), selector);\n\t\t}\t\t\n\t}","commit_id":"0be43802f233be1d4879dd881fdb77eefa4d35c9","url":"https://github.com/eXist-db/exist"},{"original_method":"protected NodeSet getParents(XQueryContext context, NodeSet contextSet) {        \n\t\tif(test.isWildcardTest()) {\n\t\t\treturn contextSet.getParents(inPredicate);\n\t\t} else {\n\t\t    DocumentSet docs = getDocumentSet(contextSet);\n\t\t    NodeSelector selector = new ParentSelector(contextSet, inPredicate);\n\t\t    return context.getBroker().getElementIndex().findElementsByTagName(\n\t\t    \t\tElementValue.ELEMENT, docs, test.getName(), selector);\t\t\t\n\t\t}\n\t}","id":102124,"modified_method":"protected NodeSet getParents(XQueryContext context, NodeSet contextSet) {        \n\t\tif(test.isWildcardTest()) {\n\t\t\treturn contextSet.getParents(inPredicate);\n\t\t} else {            \n\t\t    DocumentSet docs = getDocumentSet(contextSet);\n\t\t    NodeSelector selector = new ParentSelector(contextSet, inPredicate);\n            ElementIndex index = context.getBroker().getElementIndex();\n\t\t    return index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), selector);\t\t\t\n\t\t}\n\t}","commit_id":"0be43802f233be1d4879dd881fdb77eefa4d35c9","url":"https://github.com/eXist-db/exist"},{"original_method":"protected NodeSet getFollowing(XQueryContext context, NodeSet contextSet)\n\tthrows XPathException {\n\t\tNodeSet result = NodeSet.EMPTY_SET;\n\t\tif(!test.isWildcardTest()) {\n\t\t    DocumentSet docs = getDocumentSet(contextSet);\n\t\t\tif (currentSet == null || currentDocs == null || !(docs.equals(currentDocs))) {\n\t\t\t\tcurrentDocs = docs;\n\t\t\t\tcurrentSet =\n\t\t\t\t\t(NodeSet) context.getBroker().getElementIndex().findElementsByTagName(\n\t\t\t\t\t\tElementValue.ELEMENT, currentDocs, test.getName(), null);\n\t\t\t\tregisterUpdateListener();\n\t\t\t}\n\t\t\tresult = currentSet.selectFollowing(contextSet);\n\t\t}\n\t\treturn result;\n\t}","id":102125,"modified_method":"protected NodeSet getFollowing(XQueryContext context, NodeSet contextSet) throws XPathException {\t\t\n\t\tif(!test.isWildcardTest()) {            \n\t\t    DocumentSet docs = getDocumentSet(contextSet);\n\t\t\tif (currentSet == null || currentDocs == null || !(docs.equals(currentDocs))) {\n                ElementIndex index = context.getBroker().getElementIndex();\t\t\t\t\n\t\t\t\tcurrentSet = index.findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), null);\n                currentDocs = docs;\n                registerUpdateListener();\n\t\t\t}\n\t\t\treturn currentSet.selectFollowing(contextSet);\n\t\t}\n        //TODO : throw an exception here ! Don't let this pass through\n\t\treturn NodeSet.EMPTY_SET;\n\t}","commit_id":"0be43802f233be1d4879dd881fdb77eefa4d35c9","url":"https://github.com/eXist-db/exist"},{"original_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Alarms\");\n        feed.setDescription(\"OpenNMS Alarms\");\n        feed.setLink(getUrlBase() + \"alarm/list\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            Alarm[] alarms;\n\n            ArrayList<Filter> filters = new ArrayList<Filter>();\n            if (this.getRequest().getParameter(\"node\") != null) {\n                Integer nodeId = Integer.parseInt(this.getRequest().getParameter(\"node\"));\n                filters.add(new NodeFilter(nodeId));\n            }\n            if (this.getRequest().getParameter(\"severity\") != null) {\n                String sev = this.getRequest().getParameter(\"severity\");\n                List<Integer> severities = AlarmUtil.getSeverityList();\n                for (Integer severity : severities) {\n                    if (EventUtil.getSeverityLabel(severity).toLowerCase().equals(sev)) {\n                        filters.add(new SeverityFilter(severity));\n                    }\n                }\n\n            }\n            \n            alarms = AlarmFactory.getAlarms(SortStyle.FIRSTEVENTTIME, AcknowledgeType.BOTH, filters.toArray(new Filter[] {}), this.getMaxEntries(), -1);\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (Alarm alarm : alarms) {\n                entry = new SyndEntryImpl();\n                if (alarm.getAcknowledgeTime() != null) {\n                    entry.setTitle(sanitizeTitle(alarm.getLogMessage()) + \" (acknowledged by \" + alarm.getAcknowledgeUser() + \")\");\n                } else {\n                    entry.setTitle(sanitizeTitle(alarm.getLogMessage()));\n                }\n                entry.setLink(getUrlBase() + \"alarm/detail.jsp?id=\" + alarm.getId());\n                entry.setPublishedDate(alarm.getFirstEventTime());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get event(s)\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","id":102126,"modified_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Alarms\");\n        feed.setDescription(\"OpenNMS Alarms\");\n        feed.setLink(getUrlBase() + \"alarm/list\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            Alarm[] alarms;\n\n            ArrayList<Filter> filters = new ArrayList<Filter>();\n            if (this.getRequest().getParameter(\"node\") != null) {\n                Integer nodeId = Integer.parseInt(this.getRequest().getParameter(\"node\"));\n                filters.add(new NodeFilter(nodeId));\n            }\n            if (this.getRequest().getParameter(\"severity\") != null) {\n                String sev = this.getRequest().getParameter(\"severity\");\n                List<Integer> severities = AlarmUtil.getSeverityList();\n                for (Integer severity : severities) {\n                    if (EventUtil.getSeverityLabel(severity).toLowerCase().equals(sev)) {\n                        filters.add(new SeverityFilter(severity));\n                    }\n                }\n\n            }\n            \n            alarms = AlarmFactory.getAlarms(SortStyle.FIRSTEVENTTIME, AcknowledgeType.BOTH, filters.toArray(new Filter[] {}), this.getMaxEntries(), -1);\n\n            SyndEntry entry;\n            \n            for (Alarm alarm : alarms) {\n                entry = new SyndEntryImpl();\n                entry.setPublishedDate(alarm.getFirstEventTime());\n                if (alarm.getAcknowledgeTime() != null) {\n                    entry.setTitle(sanitizeTitle(alarm.getLogMessage()) + \" (acknowledged by \" + alarm.getAcknowledgeUser() + \")\");\n                    entry.setUpdatedDate(alarm.getAcknowledgeTime());\n                } else {\n                    entry.setTitle(sanitizeTitle(alarm.getLogMessage()));\n                    entry.setUpdatedDate(alarm.getFirstEventTime());\n                }\n                entry.setLink(getUrlBase() + \"alarm/detail.jsp?id=\" + alarm.getId());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get event(s)\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","commit_id":"01fb4c301f12cf4966f74f9d99630e6736684046","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Events\");\n        feed.setDescription(\"OpenNMS Events\");\n        feed.setLink(getUrlBase() + \"event/list\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            Event[] events;\n\n            ArrayList<Filter> filters = new ArrayList<Filter>();\n            if (this.getRequest().getParameter(\"node\") != null) {\n                Integer nodeId = Integer.parseInt(this.getRequest().getParameter(\"node\"));\n                filters.add(new NodeFilter(nodeId));\n            }\n            if (this.getRequest().getParameter(\"severity\") != null) {\n                String sev = this.getRequest().getParameter(\"severity\");\n                List<Integer> severities = EventUtil.getSeverityList();\n                for (Integer severity : severities) {\n                    if (EventUtil.getSeverityLabel(severity).toLowerCase().equals(sev)) {\n                        filters.add(new SeverityFilter(severity));\n                    }\n                }\n\n            }\n            \n            events = EventFactory.getEvents(SortStyle.TIME, AcknowledgeType.BOTH, filters.toArray(new Filter[] {}), this.getMaxEntries(), -1);\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (Event event : events) {\n                entry = new SyndEntryImpl();\n                if (event.getAcknowledgeTime() != null) {\n                    entry.setTitle(sanitizeTitle(event.getLogMessage()) + \" (acknowledged by \" + event.getAcknowledgeUser() + \")\");\n                } else {\n                    entry.setTitle(sanitizeTitle(event.getLogMessage()));\n                }\n                entry.setLink(getUrlBase() + \"event/detail.jsp?id=\" + event.getId());\n                entry.setPublishedDate(event.getTime());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get event(s)\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","id":102127,"modified_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Events\");\n        feed.setDescription(\"OpenNMS Events\");\n        feed.setLink(getUrlBase() + \"event/list\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            Event[] events;\n\n            ArrayList<Filter> filters = new ArrayList<Filter>();\n            if (this.getRequest().getParameter(\"node\") != null) {\n                Integer nodeId = Integer.parseInt(this.getRequest().getParameter(\"node\"));\n                filters.add(new NodeFilter(nodeId));\n            }\n            if (this.getRequest().getParameter(\"severity\") != null) {\n                String sev = this.getRequest().getParameter(\"severity\");\n                List<Integer> severities = EventUtil.getSeverityList();\n                for (Integer severity : severities) {\n                    if (EventUtil.getSeverityLabel(severity).toLowerCase().equals(sev)) {\n                        filters.add(new SeverityFilter(severity));\n                    }\n                }\n\n            }\n            \n            events = EventFactory.getEvents(SortStyle.TIME, AcknowledgeType.BOTH, filters.toArray(new Filter[] {}), this.getMaxEntries(), -1);\n\n            SyndEntry entry;\n            \n            for (Event event : events) {\n                entry = new SyndEntryImpl();\n                entry.setPublishedDate(event.getTime());\n                if (event.getAcknowledgeTime() != null) {\n                    entry.setTitle(sanitizeTitle(event.getLogMessage()) + \" (acknowledged by \" + event.getAcknowledgeUser() + \")\");\n                    entry.setUpdatedDate(event.getAcknowledgeTime());\n                } else {\n                    entry.setTitle(sanitizeTitle(event.getLogMessage()));\n                    entry.setUpdatedDate(event.getTime());\n                }\n                entry.setLink(getUrlBase() + \"event/detail.jsp?id=\" + event.getId());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get event(s)\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","commit_id":"01fb4c301f12cf4966f74f9d99630e6736684046","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Notifications\");\n        feed.setDescription(\"Notifications\");\n        feed.setLink(getUrlBase() + \"notification/browse\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            NotificationModel model = new NotificationModel();\n            Notification[] notifications = model.allNotifications();\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (Notification notification : notifications) {\n                if (count++ == this.getMaxEntries()) {\n                    break;\n                }\n                entry = new SyndEntryImpl();\n                if (notification.getTimeReplied() == null) {\n                    entry.setTitle(sanitizeTitle(notification.getTextMessage()));\n                } else {\n                    entry.setTitle(sanitizeTitle(notification.getTextMessage()) + \" (acknowledged)\");\n                }\n                entry.setLink(getUrlBase() + \"notification/detail.jsp?notice=\" + notification.getId());\n                entry.setPublishedDate(notification.getTimeSent());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get outstanding notifications\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","id":102128,"modified_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Notifications\");\n        feed.setDescription(\"Notifications\");\n        feed.setLink(getUrlBase() + \"notification/browse\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            NotificationModel model = new NotificationModel();\n            Notification[] notifications = model.allNotifications();\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (Notification notification : notifications) {\n                if (count++ == this.getMaxEntries()) {\n                    break;\n                }\n                entry = new SyndEntryImpl();\n                entry.setPublishedDate(notification.getTimeSent());\n                if (notification.getTimeReplied() == null) {\n                    entry.setTitle(sanitizeTitle(notification.getTextMessage()));\n                    entry.setUpdatedDate(notification.getTimeSent());\n                } else {\n                    entry.setTitle(sanitizeTitle(notification.getTextMessage()) + \" (acknowledged)\");\n                    entry.setUpdatedDate(notification.getTimeReplied());\n                }\n                entry.setLink(getUrlBase() + \"notification/detail.jsp?notice=\" + notification.getId());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get outstanding notifications\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","commit_id":"01fb4c301f12cf4966f74f9d99630e6736684046","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Nodes with Outages\");\n        feed.setDescription(\"OpenNMS Nodes with Outages\");\n        feed.setLink(getUrlBase() + \"outage/current.jsp\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            OutageModel model = new OutageModel();    \n            Date date = new Date();\n            date.setTime(date.getTime() - (1000 * 60 * 60 * 24));\n            OutageSummary[] summaries = model.getAllOutageSummaries(date);\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (OutageSummary summary : summaries) {\n                if (count++ == this.getMaxEntries()) {\n                    break;\n                }\n                String link = getUrlBase() + \"element/node.jsp?node=\" + summary.getNodeId();\n//                link += \"&timeDown=\" + summary.getTimeDown().getTime();\n\n                entry = new SyndEntryImpl();\n                if (summary.getTimeUp() == null) {\n                    entry.setTitle(\"outage: \" + sanitizeTitle(summary.getNodeLabel()));\n                    entry.setPublishedDate(summary.getTimeDown());\n                } else {\n                    entry.setTitle(\"outage: \" + sanitizeTitle(summary.getNodeLabel()) + \" (resolved)\");\n                    entry.setPublishedDate(summary.getTimeUp());\n//                    link += \"&timeUp=\" + summary.getTimeUp().getTime();\n                }\n                entry.setLink(link);\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get current outages\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","id":102129,"modified_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Nodes with Outages\");\n        feed.setDescription(\"OpenNMS Nodes with Outages\");\n        feed.setLink(getUrlBase() + \"outage/current.jsp\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            OutageModel model = new OutageModel();    \n            Date date = new Date();\n            date.setTime(date.getTime() - (1000 * 60 * 60 * 24));\n            OutageSummary[] summaries = model.getAllOutageSummaries(date);\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (OutageSummary summary : summaries) {\n                if (count++ == this.getMaxEntries()) {\n                    break;\n                }\n                String link = getUrlBase() + \"element/node.jsp?node=\" + summary.getNodeId();\n\n                entry = new SyndEntryImpl();\n                entry.setPublishedDate(summary.getTimeDown());\n                \n                if (summary.getTimeUp() == null) {\n                    entry.setTitle(\"outage: \" + sanitizeTitle(summary.getNodeLabel()));\n                    entry.setUpdatedDate(summary.getTimeDown());\n                } else {\n                    entry.setTitle(\"outage: \" + sanitizeTitle(summary.getNodeLabel()) + \" (resolved)\");\n                    entry.setUpdatedDate(summary.getTimeUp());\n                }\n                entry.setLink(link);\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get current outages\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","commit_id":"01fb4c301f12cf4966f74f9d99630e6736684046","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Alarms\");\n        feed.setDescription(\"OpenNMS Alarms\");\n        feed.setLink(getUrlBase() + \"alarm/list\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            Alarm[] alarms;\n\n            ArrayList<Filter> filters = new ArrayList<Filter>();\n            if (this.getRequest().getParameter(\"node\") != null) {\n                Integer nodeId = Integer.parseInt(this.getRequest().getParameter(\"node\"));\n                filters.add(new NodeFilter(nodeId));\n            }\n            if (this.getRequest().getParameter(\"severity\") != null) {\n                String sev = this.getRequest().getParameter(\"severity\");\n                List<Integer> severities = AlarmUtil.getSeverityList();\n                for (Integer severity : severities) {\n                    if (EventUtil.getSeverityLabel(severity).toLowerCase().equals(sev)) {\n                        filters.add(new SeverityFilter(severity));\n                    }\n                }\n\n            }\n            \n            alarms = AlarmFactory.getAlarms(SortStyle.FIRSTEVENTTIME, AcknowledgeType.BOTH, filters.toArray(new Filter[] {}), this.getMaxEntries(), -1);\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (Alarm alarm : alarms) {\n                entry = new SyndEntryImpl();\n                if (alarm.getAcknowledgeTime() != null) {\n                    entry.setTitle(sanitizeTitle(alarm.getLogMessage()) + \" (acknowledged by \" + alarm.getAcknowledgeUser() + \")\");\n                } else {\n                    entry.setTitle(sanitizeTitle(alarm.getLogMessage()));\n                }\n                entry.setLink(getUrlBase() + \"alarm/detail.jsp?id=\" + alarm.getId());\n                entry.setPublishedDate(alarm.getFirstEventTime());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get event(s)\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","id":102130,"modified_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Alarms\");\n        feed.setDescription(\"OpenNMS Alarms\");\n        feed.setLink(getUrlBase() + \"alarm/list\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            Alarm[] alarms;\n\n            ArrayList<Filter> filters = new ArrayList<Filter>();\n            if (this.getRequest().getParameter(\"node\") != null) {\n                Integer nodeId = Integer.parseInt(this.getRequest().getParameter(\"node\"));\n                filters.add(new NodeFilter(nodeId));\n            }\n            if (this.getRequest().getParameter(\"severity\") != null) {\n                String sev = this.getRequest().getParameter(\"severity\");\n                List<Integer> severities = AlarmUtil.getSeverityList();\n                for (Integer severity : severities) {\n                    if (EventUtil.getSeverityLabel(severity).toLowerCase().equals(sev)) {\n                        filters.add(new SeverityFilter(severity));\n                    }\n                }\n\n            }\n            \n            alarms = AlarmFactory.getAlarms(SortStyle.FIRSTEVENTTIME, AcknowledgeType.BOTH, filters.toArray(new Filter[] {}), this.getMaxEntries(), -1);\n\n            SyndEntry entry;\n            \n            for (Alarm alarm : alarms) {\n                entry = new SyndEntryImpl();\n                entry.setPublishedDate(alarm.getFirstEventTime());\n                if (alarm.getAcknowledgeTime() != null) {\n                    entry.setTitle(sanitizeTitle(alarm.getLogMessage()) + \" (acknowledged by \" + alarm.getAcknowledgeUser() + \")\");\n                    entry.setUpdatedDate(alarm.getAcknowledgeTime());\n                } else {\n                    entry.setTitle(sanitizeTitle(alarm.getLogMessage()));\n                    entry.setUpdatedDate(alarm.getFirstEventTime());\n                }\n                entry.setLink(getUrlBase() + \"alarm/detail.jsp?id=\" + alarm.getId());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get event(s)\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","commit_id":"2095f463e4e4bf1ca498cb1bd69d626a0f91ba38","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Events\");\n        feed.setDescription(\"OpenNMS Events\");\n        feed.setLink(getUrlBase() + \"event/list\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            Event[] events;\n\n            ArrayList<Filter> filters = new ArrayList<Filter>();\n            if (this.getRequest().getParameter(\"node\") != null) {\n                Integer nodeId = Integer.parseInt(this.getRequest().getParameter(\"node\"));\n                filters.add(new NodeFilter(nodeId));\n            }\n            if (this.getRequest().getParameter(\"severity\") != null) {\n                String sev = this.getRequest().getParameter(\"severity\");\n                List<Integer> severities = EventUtil.getSeverityList();\n                for (Integer severity : severities) {\n                    if (EventUtil.getSeverityLabel(severity).toLowerCase().equals(sev)) {\n                        filters.add(new SeverityFilter(severity));\n                    }\n                }\n\n            }\n            \n            events = EventFactory.getEvents(SortStyle.TIME, AcknowledgeType.BOTH, filters.toArray(new Filter[] {}), this.getMaxEntries(), -1);\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (Event event : events) {\n                entry = new SyndEntryImpl();\n                if (event.getAcknowledgeTime() != null) {\n                    entry.setTitle(sanitizeTitle(event.getLogMessage()) + \" (acknowledged by \" + event.getAcknowledgeUser() + \")\");\n                } else {\n                    entry.setTitle(sanitizeTitle(event.getLogMessage()));\n                }\n                entry.setLink(getUrlBase() + \"event/detail.jsp?id=\" + event.getId());\n                entry.setPublishedDate(event.getTime());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get event(s)\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","id":102131,"modified_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Events\");\n        feed.setDescription(\"OpenNMS Events\");\n        feed.setLink(getUrlBase() + \"event/list\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            Event[] events;\n\n            ArrayList<Filter> filters = new ArrayList<Filter>();\n            if (this.getRequest().getParameter(\"node\") != null) {\n                Integer nodeId = Integer.parseInt(this.getRequest().getParameter(\"node\"));\n                filters.add(new NodeFilter(nodeId));\n            }\n            if (this.getRequest().getParameter(\"severity\") != null) {\n                String sev = this.getRequest().getParameter(\"severity\");\n                List<Integer> severities = EventUtil.getSeverityList();\n                for (Integer severity : severities) {\n                    if (EventUtil.getSeverityLabel(severity).toLowerCase().equals(sev)) {\n                        filters.add(new SeverityFilter(severity));\n                    }\n                }\n\n            }\n            \n            events = EventFactory.getEvents(SortStyle.TIME, AcknowledgeType.BOTH, filters.toArray(new Filter[] {}), this.getMaxEntries(), -1);\n\n            SyndEntry entry;\n            \n            for (Event event : events) {\n                entry = new SyndEntryImpl();\n                entry.setPublishedDate(event.getTime());\n                if (event.getAcknowledgeTime() != null) {\n                    entry.setTitle(sanitizeTitle(event.getLogMessage()) + \" (acknowledged by \" + event.getAcknowledgeUser() + \")\");\n                    entry.setUpdatedDate(event.getAcknowledgeTime());\n                } else {\n                    entry.setTitle(sanitizeTitle(event.getLogMessage()));\n                    entry.setUpdatedDate(event.getTime());\n                }\n                entry.setLink(getUrlBase() + \"event/detail.jsp?id=\" + event.getId());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get event(s)\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","commit_id":"2095f463e4e4bf1ca498cb1bd69d626a0f91ba38","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Notifications\");\n        feed.setDescription(\"Notifications\");\n        feed.setLink(getUrlBase() + \"notification/browse\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            NotificationModel model = new NotificationModel();\n            Notification[] notifications = model.allNotifications();\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (Notification notification : notifications) {\n                if (count++ == this.getMaxEntries()) {\n                    break;\n                }\n                entry = new SyndEntryImpl();\n                if (notification.getTimeReplied() == null) {\n                    entry.setTitle(sanitizeTitle(notification.getTextMessage()));\n                } else {\n                    entry.setTitle(sanitizeTitle(notification.getTextMessage()) + \" (acknowledged)\");\n                }\n                entry.setLink(getUrlBase() + \"notification/detail.jsp?notice=\" + notification.getId());\n                entry.setPublishedDate(notification.getTimeSent());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get outstanding notifications\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","id":102132,"modified_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Notifications\");\n        feed.setDescription(\"Notifications\");\n        feed.setLink(getUrlBase() + \"notification/browse\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            NotificationModel model = new NotificationModel();\n            Notification[] notifications = model.allNotifications();\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (Notification notification : notifications) {\n                if (count++ == this.getMaxEntries()) {\n                    break;\n                }\n                entry = new SyndEntryImpl();\n                entry.setPublishedDate(notification.getTimeSent());\n                if (notification.getTimeReplied() == null) {\n                    entry.setTitle(sanitizeTitle(notification.getTextMessage()));\n                    entry.setUpdatedDate(notification.getTimeSent());\n                } else {\n                    entry.setTitle(sanitizeTitle(notification.getTextMessage()) + \" (acknowledged)\");\n                    entry.setUpdatedDate(notification.getTimeReplied());\n                }\n                entry.setLink(getUrlBase() + \"notification/detail.jsp?notice=\" + notification.getId());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get outstanding notifications\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","commit_id":"2095f463e4e4bf1ca498cb1bd69d626a0f91ba38","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Nodes with Outages\");\n        feed.setDescription(\"OpenNMS Nodes with Outages\");\n        feed.setLink(getUrlBase() + \"outage/current.jsp\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            OutageModel model = new OutageModel();    \n            Date date = new Date();\n            date.setTime(date.getTime() - (1000 * 60 * 60 * 24));\n            OutageSummary[] summaries = model.getAllOutageSummaries(date);\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (OutageSummary summary : summaries) {\n                if (count++ == this.getMaxEntries()) {\n                    break;\n                }\n                String link = getUrlBase() + \"element/node.jsp?node=\" + summary.getNodeId();\n//                link += \"&timeDown=\" + summary.getTimeDown().getTime();\n\n                entry = new SyndEntryImpl();\n                if (summary.getTimeUp() == null) {\n                    entry.setTitle(\"outage: \" + sanitizeTitle(summary.getNodeLabel()));\n                    entry.setPublishedDate(summary.getTimeDown());\n                } else {\n                    entry.setTitle(\"outage: \" + sanitizeTitle(summary.getNodeLabel()) + \" (resolved)\");\n                    entry.setPublishedDate(summary.getTimeUp());\n//                    link += \"&timeUp=\" + summary.getTimeUp().getTime();\n                }\n                entry.setLink(link);\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get current outages\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","id":102133,"modified_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Nodes with Outages\");\n        feed.setDescription(\"OpenNMS Nodes with Outages\");\n        feed.setLink(getUrlBase() + \"outage/current.jsp\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            OutageModel model = new OutageModel();    \n            Date date = new Date();\n            date.setTime(date.getTime() - (1000 * 60 * 60 * 24));\n            OutageSummary[] summaries = model.getAllOutageSummaries(date);\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (OutageSummary summary : summaries) {\n                if (count++ == this.getMaxEntries()) {\n                    break;\n                }\n                String link = getUrlBase() + \"element/node.jsp?node=\" + summary.getNodeId();\n\n                entry = new SyndEntryImpl();\n                entry.setPublishedDate(summary.getTimeDown());\n                \n                if (summary.getTimeUp() == null) {\n                    entry.setTitle(\"outage: \" + sanitizeTitle(summary.getNodeLabel()));\n                    entry.setUpdatedDate(summary.getTimeDown());\n                } else {\n                    entry.setTitle(\"outage: \" + sanitizeTitle(summary.getNodeLabel()) + \" (resolved)\");\n                    entry.setUpdatedDate(summary.getTimeUp());\n                }\n                entry.setLink(link);\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get current outages\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","commit_id":"2095f463e4e4bf1ca498cb1bd69d626a0f91ba38","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Alarms\");\n        feed.setDescription(\"OpenNMS Alarms\");\n        feed.setLink(getUrlBase() + \"alarm/list\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            Alarm[] alarms;\n\n            ArrayList<Filter> filters = new ArrayList<Filter>();\n            if (this.getRequest().getParameter(\"node\") != null) {\n                Integer nodeId = Integer.parseInt(this.getRequest().getParameter(\"node\"));\n                filters.add(new NodeFilter(nodeId));\n            }\n            if (this.getRequest().getParameter(\"severity\") != null) {\n                String sev = this.getRequest().getParameter(\"severity\");\n                List<Integer> severities = AlarmUtil.getSeverityList();\n                for (Integer severity : severities) {\n                    if (EventUtil.getSeverityLabel(severity).toLowerCase().equals(sev)) {\n                        filters.add(new SeverityFilter(severity));\n                    }\n                }\n\n            }\n            \n            alarms = AlarmFactory.getAlarms(SortStyle.FIRSTEVENTTIME, AcknowledgeType.BOTH, filters.toArray(new Filter[] {}), this.getMaxEntries(), -1);\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (Alarm alarm : alarms) {\n                entry = new SyndEntryImpl();\n                if (alarm.getAcknowledgeTime() != null) {\n                    entry.setTitle(sanitizeTitle(alarm.getLogMessage()) + \" (acknowledged by \" + alarm.getAcknowledgeUser() + \")\");\n                } else {\n                    entry.setTitle(sanitizeTitle(alarm.getLogMessage()));\n                }\n                entry.setLink(getUrlBase() + \"alarm/detail.jsp?id=\" + alarm.getId());\n                entry.setPublishedDate(alarm.getFirstEventTime());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get event(s)\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","id":102134,"modified_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Alarms\");\n        feed.setDescription(\"OpenNMS Alarms\");\n        feed.setLink(getUrlBase() + \"alarm/list\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            Alarm[] alarms;\n\n            ArrayList<Filter> filters = new ArrayList<Filter>();\n            if (this.getRequest().getParameter(\"node\") != null) {\n                Integer nodeId = Integer.parseInt(this.getRequest().getParameter(\"node\"));\n                filters.add(new NodeFilter(nodeId));\n            }\n            if (this.getRequest().getParameter(\"severity\") != null) {\n                String sev = this.getRequest().getParameter(\"severity\");\n                List<Integer> severities = AlarmUtil.getSeverityList();\n                for (Integer severity : severities) {\n                    if (EventUtil.getSeverityLabel(severity).toLowerCase().equals(sev)) {\n                        filters.add(new SeverityFilter(severity));\n                    }\n                }\n\n            }\n            \n            alarms = AlarmFactory.getAlarms(SortStyle.FIRSTEVENTTIME, AcknowledgeType.BOTH, filters.toArray(new Filter[] {}), this.getMaxEntries(), -1);\n\n            SyndEntry entry;\n            \n            for (Alarm alarm : alarms) {\n                entry = new SyndEntryImpl();\n                entry.setPublishedDate(alarm.getFirstEventTime());\n                if (alarm.getAcknowledgeTime() != null) {\n                    entry.setTitle(sanitizeTitle(alarm.getLogMessage()) + \" (acknowledged by \" + alarm.getAcknowledgeUser() + \")\");\n                    entry.setUpdatedDate(alarm.getAcknowledgeTime());\n                } else {\n                    entry.setTitle(sanitizeTitle(alarm.getLogMessage()));\n                    entry.setUpdatedDate(alarm.getFirstEventTime());\n                }\n                entry.setLink(getUrlBase() + \"alarm/detail.jsp?id=\" + alarm.getId());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get event(s)\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","commit_id":"c56fb8962e67c411cc364a409b55f3a41eeb8958","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Events\");\n        feed.setDescription(\"OpenNMS Events\");\n        feed.setLink(getUrlBase() + \"event/list\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            Event[] events;\n\n            ArrayList<Filter> filters = new ArrayList<Filter>();\n            if (this.getRequest().getParameter(\"node\") != null) {\n                Integer nodeId = Integer.parseInt(this.getRequest().getParameter(\"node\"));\n                filters.add(new NodeFilter(nodeId));\n            }\n            if (this.getRequest().getParameter(\"severity\") != null) {\n                String sev = this.getRequest().getParameter(\"severity\");\n                List<Integer> severities = EventUtil.getSeverityList();\n                for (Integer severity : severities) {\n                    if (EventUtil.getSeverityLabel(severity).toLowerCase().equals(sev)) {\n                        filters.add(new SeverityFilter(severity));\n                    }\n                }\n\n            }\n            \n            events = EventFactory.getEvents(SortStyle.TIME, AcknowledgeType.BOTH, filters.toArray(new Filter[] {}), this.getMaxEntries(), -1);\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (Event event : events) {\n                entry = new SyndEntryImpl();\n                if (event.getAcknowledgeTime() != null) {\n                    entry.setTitle(sanitizeTitle(event.getLogMessage()) + \" (acknowledged by \" + event.getAcknowledgeUser() + \")\");\n                } else {\n                    entry.setTitle(sanitizeTitle(event.getLogMessage()));\n                }\n                entry.setLink(getUrlBase() + \"event/detail.jsp?id=\" + event.getId());\n                entry.setPublishedDate(event.getTime());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get event(s)\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","id":102135,"modified_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Events\");\n        feed.setDescription(\"OpenNMS Events\");\n        feed.setLink(getUrlBase() + \"event/list\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            Event[] events;\n\n            ArrayList<Filter> filters = new ArrayList<Filter>();\n            if (this.getRequest().getParameter(\"node\") != null) {\n                Integer nodeId = Integer.parseInt(this.getRequest().getParameter(\"node\"));\n                filters.add(new NodeFilter(nodeId));\n            }\n            if (this.getRequest().getParameter(\"severity\") != null) {\n                String sev = this.getRequest().getParameter(\"severity\");\n                List<Integer> severities = EventUtil.getSeverityList();\n                for (Integer severity : severities) {\n                    if (EventUtil.getSeverityLabel(severity).toLowerCase().equals(sev)) {\n                        filters.add(new SeverityFilter(severity));\n                    }\n                }\n\n            }\n            \n            events = EventFactory.getEvents(SortStyle.TIME, AcknowledgeType.BOTH, filters.toArray(new Filter[] {}), this.getMaxEntries(), -1);\n\n            SyndEntry entry;\n            \n            for (Event event : events) {\n                entry = new SyndEntryImpl();\n                entry.setPublishedDate(event.getTime());\n                if (event.getAcknowledgeTime() != null) {\n                    entry.setTitle(sanitizeTitle(event.getLogMessage()) + \" (acknowledged by \" + event.getAcknowledgeUser() + \")\");\n                    entry.setUpdatedDate(event.getAcknowledgeTime());\n                } else {\n                    entry.setTitle(sanitizeTitle(event.getLogMessage()));\n                    entry.setUpdatedDate(event.getTime());\n                }\n                entry.setLink(getUrlBase() + \"event/detail.jsp?id=\" + event.getId());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get event(s)\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","commit_id":"c56fb8962e67c411cc364a409b55f3a41eeb8958","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Notifications\");\n        feed.setDescription(\"Notifications\");\n        feed.setLink(getUrlBase() + \"notification/browse\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            NotificationModel model = new NotificationModel();\n            Notification[] notifications = model.allNotifications();\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (Notification notification : notifications) {\n                if (count++ == this.getMaxEntries()) {\n                    break;\n                }\n                entry = new SyndEntryImpl();\n                if (notification.getTimeReplied() == null) {\n                    entry.setTitle(sanitizeTitle(notification.getTextMessage()));\n                } else {\n                    entry.setTitle(sanitizeTitle(notification.getTextMessage()) + \" (acknowledged)\");\n                }\n                entry.setLink(getUrlBase() + \"notification/detail.jsp?notice=\" + notification.getId());\n                entry.setPublishedDate(notification.getTimeSent());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get outstanding notifications\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","id":102136,"modified_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Notifications\");\n        feed.setDescription(\"Notifications\");\n        feed.setLink(getUrlBase() + \"notification/browse\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            NotificationModel model = new NotificationModel();\n            Notification[] notifications = model.allNotifications();\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (Notification notification : notifications) {\n                if (count++ == this.getMaxEntries()) {\n                    break;\n                }\n                entry = new SyndEntryImpl();\n                entry.setPublishedDate(notification.getTimeSent());\n                if (notification.getTimeReplied() == null) {\n                    entry.setTitle(sanitizeTitle(notification.getTextMessage()));\n                    entry.setUpdatedDate(notification.getTimeSent());\n                } else {\n                    entry.setTitle(sanitizeTitle(notification.getTextMessage()) + \" (acknowledged)\");\n                    entry.setUpdatedDate(notification.getTimeReplied());\n                }\n                entry.setLink(getUrlBase() + \"notification/detail.jsp?notice=\" + notification.getId());\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get outstanding notifications\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","commit_id":"c56fb8962e67c411cc364a409b55f3a41eeb8958","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Nodes with Outages\");\n        feed.setDescription(\"OpenNMS Nodes with Outages\");\n        feed.setLink(getUrlBase() + \"outage/current.jsp\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            OutageModel model = new OutageModel();    \n            Date date = new Date();\n            date.setTime(date.getTime() - (1000 * 60 * 60 * 24));\n            OutageSummary[] summaries = model.getAllOutageSummaries(date);\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (OutageSummary summary : summaries) {\n                if (count++ == this.getMaxEntries()) {\n                    break;\n                }\n                String link = getUrlBase() + \"element/node.jsp?node=\" + summary.getNodeId();\n//                link += \"&timeDown=\" + summary.getTimeDown().getTime();\n\n                entry = new SyndEntryImpl();\n                if (summary.getTimeUp() == null) {\n                    entry.setTitle(\"outage: \" + sanitizeTitle(summary.getNodeLabel()));\n                    entry.setPublishedDate(summary.getTimeDown());\n                } else {\n                    entry.setTitle(\"outage: \" + sanitizeTitle(summary.getNodeLabel()) + \" (resolved)\");\n                    entry.setPublishedDate(summary.getTimeUp());\n//                    link += \"&timeUp=\" + summary.getTimeUp().getTime();\n                }\n                entry.setLink(link);\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get current outages\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","id":102137,"modified_method":"public SyndFeed getFeed() {\n        SyndFeed feed = new SyndFeedImpl();\n\n        feed.setTitle(\"Nodes with Outages\");\n        feed.setDescription(\"OpenNMS Nodes with Outages\");\n        feed.setLink(getUrlBase() + \"outage/current.jsp\");\n\n        ArrayList<SyndEntry> entries = new ArrayList<SyndEntry>();\n\n        try {\n            OutageModel model = new OutageModel();    \n            Date date = new Date();\n            date.setTime(date.getTime() - (1000 * 60 * 60 * 24));\n            OutageSummary[] summaries = model.getAllOutageSummaries(date);\n\n            SyndEntry entry;\n            \n            int count = 0;\n            for (OutageSummary summary : summaries) {\n                if (count++ == this.getMaxEntries()) {\n                    break;\n                }\n                String link = getUrlBase() + \"element/node.jsp?node=\" + summary.getNodeId();\n\n                entry = new SyndEntryImpl();\n                entry.setPublishedDate(summary.getTimeDown());\n                \n                if (summary.getTimeUp() == null) {\n                    entry.setTitle(\"outage: \" + sanitizeTitle(summary.getNodeLabel()));\n                    entry.setUpdatedDate(summary.getTimeDown());\n                } else {\n                    entry.setTitle(\"outage: \" + sanitizeTitle(summary.getNodeLabel()) + \" (resolved)\");\n                    entry.setUpdatedDate(summary.getTimeUp());\n                }\n                entry.setLink(link);\n                \n                entries.add(entry);\n            }\n        } catch (SQLException e) {\n            log().warn(\"unable to get current outages\", e);\n        }\n        \n        feed.setEntries(entries);\n        return feed;\n    }","commit_id":"c56fb8962e67c411cc364a409b55f3a41eeb8958","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public AbstractDynamicControllerMethod(String methodName,HttpServletRequest request, HttpServletResponse response) {\n        super(methodName);\n        this.request = request;\n        if(response instanceof GrailsHttpServletResponse)\n            this.response = (GrailsHttpServletResponse)response;\n        else {\n            this.response = new GrailsHttpServletResponse(response);\n        }\n    }","id":102138,"modified_method":"public AbstractDynamicControllerMethod(String methodName,HttpServletRequest request, HttpServletResponse response) {\n        super(methodName);\n        this.request = request;\n        this.response = response;\n    }","commit_id":"1299b0bafb8bfafe430617873f320fd415192362","url":"https://github.com/grails/grails-core"},{"original_method":"public Object invoke(Object target, Object[] arguments) {\n\t\tif(arguments.length == 0)\n\t\t\tthrow new MissingMethodException(METHOD_SIGNATURE,target.getClass(),arguments);\n\t\t\t\t\n\t\tObject actionRef;\n\t\tMap params = null;\n\t\tMap model = null;\n\t\tGroovyObject controller = (GroovyObject)target;\n\t\t\n\t\tif(arguments[0] instanceof Map) {\n\t\t\tMap argMap = (Map)arguments[0];\n\t\t\tactionRef = argMap.get(ARGUMENT_ACTION);\n\t\t\tif(argMap.get(ARGUMENT_PARAMS) instanceof Map)\n\t\t\t\tparams = (Map)argMap.get(ARGUMENT_PARAMS);\n\t\t\tif(argMap.get(ARGUMENT_MODEL) instanceof Map)\n\t\t\t\tmodel = (Map)argMap.get(ARGUMENT_MODEL);\n\t\t\telse\n\t\t\t\tthrow new MissingMethodException(METHOD_SIGNATURE,target.getClass(),arguments);\n\t\t}\n\t\telse {\n\t\t\tactionRef = arguments[0];\n\t\t\tif(!(arguments[1] instanceof Map))\n\t\t\t\tthrow new MissingMethodException(METHOD_SIGNATURE,target.getClass(),arguments);\n\t\t\t\n\t\t\tmodel = (Map)arguments[1];\n\t\t\tif(arguments.length > 2) {\n\t\t\t\tif(arguments[2] instanceof Map) {\n\t\t\t\t\tparams = (Map)arguments[2];\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\t\t\n\n\t\tif(actionRef instanceof String) {\n\t\t\tString uri = (String)actionRef;\n\t\t\tif(params != null ) {\n\t\t\t\thelper.setChainModel(model);\n\t\t\t\treturn helper.handleURI(uri,this.request,this.response, params);\n\t\t\t}\n\t\t\telse {\n\t\t\t\thelper.setChainModel(model);\n\t\t\t\treturn helper.handleURI(uri,this.request,this.response);\n\t\t\t}\n\t\t}\n\t\telse if(actionRef instanceof Closure) {\n\t\t\tClosure c = (Closure)actionRef;\n\t\t\tPropertyDescriptor prop = GrailsClassUtils.getPropertyDescriptorForValue(target,c);\n\t\t\tString closureName = null;\n\t\t\tif(prop != null) {\n\t\t\t\tclosureName = prop.getName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGrailsScaffolder scaffolder = helper.getScaffolderForController(target.getClass().getName());\n\t\t\t\tif(scaffolder != null) {\n\t\t\t\t\t\tclosureName = scaffolder.getActionName(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tGrailsControllerClass controllerClass = helper.getControllerClassByName( target.getClass().getName() );\n\t\t\tString viewName  = controllerClass.getViewByName(closureName);\n\n\t\t\thelper.setChainModel(model);\t\t\t\n\t\t\tObject returnValue = helper.handleAction(controller,c,request,response,params);\n\n\t\t\treturn helper.handleActionResponse(controller,returnValue,closureName,viewName);\n\t\t}\n\n\t\tthrow new MissingMethodException(METHOD_SIGNATURE,target.getClass(),arguments);\t\t\t\n\t}","id":102139,"modified_method":"public Object invoke(Object target, Object[] arguments) {\n        if(arguments.length == 0)\n            throw new MissingMethodException(METHOD_SIGNATURE,target.getClass(),arguments);\n\n        Object actionRef;\n        String controllerName;\n        Object id;\n        Map params;\n        Map model;\n        Errors errors;\n        GroovyObject controller = (GroovyObject)target;\n\n        if(arguments[0] instanceof Map) {\n            Map argMap = (Map)arguments[0];\n            actionRef = argMap.get(ARGUMENT_ACTION);\n            controllerName = (String)argMap.get(ARGUMENT_CONTROLLER);\n            id =  argMap.get(ARGUMENT_ID);\n            params = (Map)argMap.get(ARGUMENT_PARAMS);\n            model = (Map)argMap.get(ARGUMENT_MODEL);\n            errors = (Errors)argMap.get(ARGUMENT_ERRORS);\n        }\n        else {\n            throw new MissingMethodException(METHOD_SIGNATURE,target.getClass(),arguments);\n        }\n        // place the chain model in flash scope\n        GrailsApplicationAttributes attrs = helper.getGrailsAttributes();\n        FlashScope fs = attrs.getFlashScope(request);\n        if(fs.containsKey(PROPERTY_CHAIN_MODEL)) {\n            Map chainModel = (Map)fs.get(PROPERTY_CHAIN_MODEL);\n            if(chainModel != null) {\n                chainModel.putAll(model);\n                model = chainModel;\n            }\n        }\n\n        fs.put(PROPERTY_CHAIN_MODEL, model);\n\n        // if there are errors add it to the list of errors\n        Errors controllerErrors = (Errors)controller.getProperty( ControllerDynamicMethods.ERRORS_PROPERTY );\n        if(controllerErrors != null) {\n            controllerErrors.addAllErrors(errors);\n        }\n        else {\n            controller.setProperty( ControllerDynamicMethods.ERRORS_PROPERTY, errors);\n        }\n\n        String actionName = null;\n        if(actionRef instanceof String) {\n           actionName = (String)actionRef;\n        }\n        else if(actionRef instanceof Closure) {\n            Closure c = (Closure)actionRef;\n            PropertyDescriptor prop = GrailsClassUtils.getPropertyDescriptorForValue(target,c);\n            if(prop != null) {\n                actionName = prop.getName();\n            }\n            else {\n                GrailsScaffolder scaffolder = helper.getScaffolderForController(target.getClass().getName());\n                if(scaffolder != null) {\n                        actionName = scaffolder.getActionName(c);\n                }\n            }\n        }\n\n        if(actionName != null) {\n            StringBuffer actualUri = new StringBuffer(attrs.getApplicationUri(request));\n            if(controllerName != null) {\n                actualUri.append('/')\n                         .append(controllerName);\n            }\n            else {\n                actualUri.append(attrs.getControllerUri(request));\n            }\n            actualUri.append('/')\n                     .append(actionName);\n            if(id != null) {\n                actualUri.append('/')\n                         .append(id);\n            }\n            if(params != null) {\n                actualUri.append('?');\n                for (Iterator i = params.keySet().iterator(); i.hasNext();) {\n                    Object name = i.next();\n                    actualUri.append(name)\n                             .append('=')\n                             .append(params.get(name));\n                    if(i.hasNext())\n                        actualUri.append('&');\n                }\n            }\n            if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Dynamic method [chain] redirecting request to [\"+actualUri+\"]\");\n            }\n\n            try {\n                response.sendRedirect(response.encodeRedirectURL(actualUri.toString()));\n            } catch (IOException e) {\n                throw new ControllerExecutionException(\"Error redirecting request for url [\"+actualUri+\"]: \" + e.getMessage(),e);\n            }\n\n        }\n        else {\n            throw new ControllerExecutionException(\"Action not found in redirect for name [\"+actionName+\"]\");\n        }\n\n        return null;\n    }","commit_id":"1299b0bafb8bfafe430617873f320fd415192362","url":"https://github.com/grails/grails-core"},{"original_method":"public ControllerDynamicMethods( GroovyObject controller,GrailsControllerHelper helper,HttpServletRequest request, HttpServletResponse response) throws IntrospectionException {\n        super(controller);\n\n        this.controllerClass = helper.getControllerClassByName(controller.getClass().getName());\n\n        // add dynamic properties\n        addDynamicProperty(new GetParamsDynamicProperty(request,response));\n        addDynamicProperty(new GetSessionDynamicProperty(request,response));\n        addDynamicProperty(new GenericDynamicProperty(REQUEST_PROPERTY, HttpServletRequest.class,new GrailsHttpServletRequest( request,controller),true) );\n        addDynamicProperty(new GenericDynamicProperty(RESPONSE_PROPERTY, HttpServletResponse.class,response,true) );\n        addDynamicProperty(new GenericDynamicProperty(SERVLET_CONTEXT, ServletContext.class,helper.getServletContext(),true) );\n        addDynamicProperty(new GenericDynamicProperty(ERRORS_PROPERTY, Errors.class, null, false));\n        addDynamicProperty(new GenericDynamicProperty(MODEL_AND_VIEW_PROPERTY, ModelAndView.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(GRAILS_ATTRIBUTES, GrailsApplicationAttributes.class,helper.getGrailsAttributes(),true));\n        addDynamicProperty(new GenericDynamicProperty(ACTION_URI_PROPERTY,String.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(CONTROLLER_URI_PROPERTY,String.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(RENDER_VIEW_PROPERTY,Boolean.class, Boolean.TRUE,false));\n\n        // add dynamic methods\n        addDynamicMethodInvocation( new RedirectDynamicMethod(helper,request,response) );\n        addDynamicMethodInvocation( new ChainDynamicMethod(helper, request, response ) );\n        addDynamicMethodInvocation( new RenderDynamicMethod(helper,request,response));\n        addDynamicMethodInvocation( new BindDynamicMethod(request,response));\n\n        // the hasErrors() dynamic method that checks of there are any errors in the controller\n        addDynamicMethodInvocation( new AbstractDynamicMethodInvocation(HAS_ERRORS_METHOD) {\n            public Object invoke(Object target, Object[] arguments) {\n                GroovyObject controller = (GroovyObject)target;\n                Errors errors = (Errors)controller.getProperty(ERRORS_PROPERTY);\n                return Boolean.valueOf(errors.hasErrors());\n            }\n        });\n\n        this.scaffolding = this.controllerClass.isScaffolding();\n\n        // if the controller is scaffolding get the scaffolder, then loop through all the\n        // support actions by the scaffolder and register dynamic properties for those that don't exist\n        if(this.scaffolding) {\n            this.scaffolder = helper.getScaffolderForController(controllerClass.getFullName());\n            if(this.scaffolder == null) {\n                throw new IllegalStateException(\"Scaffolder is null when controller scaffold property is set to 'true'\");\n            }\n            String[] scaffoldActions = this.scaffolder.getSupportedActionNames();\n            for (int i = 0; i < scaffoldActions.length; i++) {\n                try {\n                    controller.getProperty(scaffoldActions[i]);\n                }\n                catch(MissingPropertyException mpe) {\n                    addDynamicProperty(new GenericDynamicProperty(\tscaffoldActions[i],\n                                                                    Closure.class,\n                                                                    scaffolder.getAction(controller,scaffoldActions[i]),\n                                                                    true));\n                }\n            }\n        }\n    }","id":102140,"modified_method":"public ControllerDynamicMethods( GroovyObject controller,GrailsControllerHelper helper,HttpServletRequest request, HttpServletResponse response) throws IntrospectionException {\n        super(controller);\n\n        this.controllerClass = helper.getControllerClassByName(controller.getClass().getName());\n\n        // add dynamic properties\n        addDynamicProperty(new GetParamsDynamicProperty(request,response));\n        addDynamicProperty(new GetSessionDynamicProperty(request,response));\n        addDynamicProperty(new GenericDynamicProperty(REQUEST_PROPERTY, HttpServletRequest.class,new GrailsHttpServletRequest( request,controller),true) );\n        addDynamicProperty(new GenericDynamicProperty(RESPONSE_PROPERTY, HttpServletResponse.class,response,true) );\n        addDynamicProperty(new GenericDynamicProperty(SERVLET_CONTEXT, ServletContext.class,helper.getServletContext(),true) );\n        addDynamicProperty(new GenericDynamicProperty(FLASH_SCOPE_PROPERTY, FlashScope.class,helper.getGrailsAttributes().getFlashScope(request),false) );\n        addDynamicProperty(new GenericDynamicProperty(ERRORS_PROPERTY, Errors.class, null, false));\n        addDynamicProperty(new GenericDynamicProperty(MODEL_AND_VIEW_PROPERTY, ModelAndView.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(GRAILS_ATTRIBUTES, GrailsApplicationAttributes.class,helper.getGrailsAttributes(),true));\n        addDynamicProperty(new GenericDynamicProperty(ACTION_URI_PROPERTY,String.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(CONTROLLER_URI_PROPERTY,String.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(RENDER_VIEW_PROPERTY,Boolean.class, Boolean.TRUE,false));\n\n        // add dynamic methods\n        addDynamicMethodInvocation( new RedirectDynamicMethod(helper,request,response) );\n        addDynamicMethodInvocation( new ChainDynamicMethod(helper, request, response ) );\n        addDynamicMethodInvocation( new RenderDynamicMethod(helper,request,response));\n        addDynamicMethodInvocation( new BindDynamicMethod(request,response));\n\n        // the hasErrors() dynamic method that checks of there are any errors in the controller\n        addDynamicMethodInvocation( new AbstractDynamicMethodInvocation(HAS_ERRORS_METHOD) {\n            public Object invoke(Object target, Object[] arguments) {\n                GroovyObject controller = (GroovyObject)target;\n                Errors errors = (Errors)controller.getProperty(ERRORS_PROPERTY);\n                return Boolean.valueOf(errors.hasErrors());\n            }\n        });\n\n        this.scaffolding = this.controllerClass.isScaffolding();\n\n        // if the controller is scaffolding get the scaffolder, then loop through all the\n        // support actions by the scaffolder and register dynamic properties for those that don't exist\n        if(this.scaffolding) {\n            this.scaffolder = helper.getScaffolderForController(controllerClass.getFullName());\n            if(this.scaffolder == null) {\n                throw new IllegalStateException(\"Scaffolder is null when controller scaffold property is set to 'true'\");\n            }\n            String[] scaffoldActions = this.scaffolder.getSupportedActionNames();\n            for (int i = 0; i < scaffoldActions.length; i++) {\n                try {\n                    controller.getProperty(scaffoldActions[i]);\n                }\n                catch(MissingPropertyException mpe) {\n                    addDynamicProperty(new GenericDynamicProperty(\tscaffoldActions[i],\n                                                                    Closure.class,\n                                                                    scaffolder.getAction(controller,scaffoldActions[i]),\n                                                                    true));\n                }\n            }\n        }\n    }","commit_id":"1299b0bafb8bfafe430617873f320fd415192362","url":"https://github.com/grails/grails-core"},{"original_method":"public void testParamsDynamicProperty() throws Exception {\n\t\t\n\t\tGroovyClassLoader gcl = new GroovyClassLoader();\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\t\n\t\trequest.addParameter(\"testParam\", \"testValue\");\n\t\t\n\t\tClass groovyClass = gcl.parseClass( \"class TestController {\\n\" +\n\t\t\t\t\t\t\"def testMethod() {\\n\" +\n\t\t\t\t\t\t\"}\\n\" +\n\t\t\t\t\t\t\"}\" );\n\t\t\n\n\t\tGrailsApplication application = new DefaultGrailsApplication(new Class[] { groovyClass },gcl);\t\t\n\t\tGroovyObject go = configureDynamicGO(groovyClass,application, request,response);\t\t\n\t\ttry {\n\t\t\tObject params = go.getProperty( \"params\" );\t\t\t\n\t\t\tassertNotNull(params);\n\t\t\tassertTrue(params instanceof Map);\n\t\t\t\n\t\t\tMap paramsMap = (Map)params;\n\t\t\tassertTrue(paramsMap.containsKey(\"testParam\"));\n\t\t\tassertEquals(\"testValue\",paramsMap.get(\"testParam\"));\n\t\t}\n\t\tcatch(MissingMethodException mme) {\n\t\t\tfail(\"Missing method exception should not have been thrown!\");\n\t\t}\t\n\t\tcatch(MissingPropertyException mpex) {\n\t\t\tfail(\"Missing property exception should not have been thrown!\");\n\t\t}\n\t}","id":102141,"modified_method":"public void testParamsDynamicProperty() throws Exception {\n\n         GroovyClassLoader gcl = new GroovyClassLoader();\n         MockHttpServletRequest request = new MockHttpServletRequest();\n         MockHttpServletResponse response = new MockHttpServletResponse();\n\n         request.addParameter(\"testParam\", \"testValue\");\n\n         Class groovyClass = gcl.parseClass( \"class TestController {\\n\" +\n                         \"@Property list = {\\n\" +\n                         \"}\\n\" +\n                         \"}\" );\n\n\n         GrailsApplication application = new DefaultGrailsApplication(new Class[] { groovyClass },gcl);\n         registerBeanDefinition(groovyClass,application, request,response);\n         GrailsControllerHelper helper1 = new SimpleGrailsControllerHelper(application,context,new MockServletContext());\n         try {\n             helper1.handleURI(\"/test/list\",request,response);\n             GroovyObject go = (GroovyObject)request.getAttribute(GrailsApplicationAttributes.CONTROLLER);\n             Object params = go.getProperty( \"params\" );\n\n             assertNotNull(params);\n             assertTrue(params instanceof Map);\n\n             Map paramsMap = (Map)params;\n             assertTrue(paramsMap.containsKey(\"testParam\"));\n             assertEquals(\"testValue\",paramsMap.get(\"testParam\"));\n         }\n         catch(MissingMethodException mme) {\n             fail(\"Missing method exception should not have been thrown!\");\n         }\n         catch(MissingPropertyException mpex) {\n             fail(\"Missing property exception should not have been thrown!\");\n         }\n     }","commit_id":"1299b0bafb8bfafe430617873f320fd415192362","url":"https://github.com/grails/grails-core"},{"original_method":"private GroovyObject configureDynamicGO(Class groovyClass,GrailsApplication application, HttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\t\tProxyMetaClass pmc = PropertyAccessProxyMetaClass.getInstance(groovyClass);\n\t\t// proof of concept to try out proxy meta class\n\t\tif(context == null)\n\t\t\tthis.context = new GenericApplicationContext();\n\t\t\n\t\tBeanDefinition bd = new RootBeanDefinition(groovyClass,false);\n\t\tcontext.registerBeanDefinition( groovyClass.getName(), bd );\n\t\t\t\t\n\n\n        GrailsControllerHelper helper = new SimpleGrailsControllerHelper(application,context,new MockServletContext());\n\t\tGroovyObject go = (GroovyObject)groovyClass.newInstance();\n\t\tpmc.setInterceptor( new ControllerDynamicMethods(go,helper,request,response) );\n\t\t\n\t\t\n\t\tgo.setMetaClass( pmc );\n\t\treturn go;\n\t}","id":102142,"modified_method":"private void registerBeanDefinition(Class groovyClass,GrailsApplication application, HttpServletRequest request, HttpServletResponse response)\n        throws Exception {\n        ProxyMetaClass pmc = PropertyAccessProxyMetaClass.getInstance(groovyClass);\n        // proof of concept to try out proxy meta class\n        if(context == null)\n            this.context = new GenericApplicationContext();\n\n        BeanDefinition bd = new RootBeanDefinition(groovyClass,false);\n        context.registerBeanDefinition( groovyClass.getName(), bd );\n    }","commit_id":"1299b0bafb8bfafe430617873f320fd415192362","url":"https://github.com/grails/grails-core"},{"original_method":"public void testRedirectDynamicMethod() throws Exception {\n\n\t\tGroovyClassLoader gcl = new GroovyClassLoader();\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\t\n\t\trequest.addParameter(\"testParam\", \"testValue\");\n\t\t\n\t\tClass groovyClass = gcl.parseClass( \"class TestController {\\n\" +\n\t\t\t\t\t\t\"@Property next = {\\n\" +\n\t\t\t\t\t\t\t\"return ['success':this.params['testParam2']]\" +\n\t\t\t\t\t\t\"}\\n\" +\n\t\t\t\t\t\t\"@Property list = {\\n\" +\n\t\t\t\t\t\t\t\"return redirect(action:this.next,params:['testParam2':'testValue2'])\\n\" +\n\t\t\t\t\t\t\"}\\n\" +\n\t\t\t\t\t\t\"}\" );\n\t\tClass secondController = gcl.parseClass( \"class SecondController {\\n\" +\n\t\t\t\t\"@Property list = {\\n\" +\n\t\t\t\t\t\"return redirect(action:'test/list',params:['testParam2':'testValue2'])\\n\" +\n\t\t\t\t\"}\\n\" +\n\t\t\t\t\"}\" );\t\t\n\t\t\n\t\tGrailsApplication application = new DefaultGrailsApplication(new Class[] { groovyClass,secondController },gcl);\t\t\n\t\tGroovyObject go = configureDynamicGO(groovyClass, application,request,response);\n\t\tGroovyObject go2 = configureDynamicGO(secondController, application,request,response);\n\t\t\n\t\t// first test redirection within the same controller\t\t\n\t\ttry {\n\t\t\tClosure closure = (Closure)go.getProperty(\"list\");\n\t\t\tObject returnValue = closure.call();\n\t\t\tassertNotNull(returnValue);\n\t\t\tassertTrue(returnValue instanceof ModelAndView);\n\t\t\tMap model = ((ModelAndView)returnValue).getModel();\n\t\t\t\n\t\t\tassertEquals(\"testValue2\", model.get(\"success\"));\n\t\t}\n\t\tcatch(MissingMethodException mme) {\n\t\t\tfail(\"Missing method exception should not have been thrown!\");\n\t\t}\t\n\t\tcatch(MissingPropertyException mpex) {\n\t\t\tfail(\"Missing property exception should not have been thrown!\");\n\t\t}\n\t\t// now redirection to another controller\n\t\ttry {\n\t\t\tClosure closure = (Closure)go2.getProperty(\"list\");\n\t\t\tObject returnValue = closure.call();\n\t\t\tassertNotNull(returnValue);\n\t\t\tassertTrue(returnValue instanceof ModelAndView);\n\t\t\tMap model = ((ModelAndView)returnValue).getModel();\n\t\t\t\n\t\t\tassertEquals(\"testValue2\", model.get(\"success\"));\n\t\t}\n\t\tcatch(MissingMethodException mme) {\n\t\t\tfail(\"Missing method exception should not have been thrown!\");\n\t\t}\t\n\t\tcatch(MissingPropertyException mpex) {\n\t\t\tfail(\"Missing property exception should not have been thrown!\");\n\t\t}\t\t\n\t}","id":102143,"modified_method":"public void testRedirectDynamicMethod() throws Exception {\n\n        GroovyClassLoader gcl = new GroovyClassLoader();\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        MockHttpServletResponse response = new MockHttpServletResponse();\n\n\n        request.addParameter(\"testParam\", \"testValue\");\n\n        Class groovyClass = gcl.parseClass( \"class TestController {\\n\" +\n                        \"@Property next = {\\n\" +\n                            \"return ['success':this.params['testParam2']]\" +\n                        \"}\\n\" +\n                        \"@Property list = {\\n\" +\n                            \"redirect(action:next,params:['testParam2':'testValue2'])\\n\" +\n                        \"}\\n\" +\n                        \"}\" );\n        Class secondController = gcl.parseClass( \"class SecondController {\\n\" +\n                \"@Property list = {\\n\" +\n                    \"return redirect(action:'test/list',params:['testParam2':'testValue2'])\\n\" +\n                \"}\\n\" +\n                \"}\" );\n\n        GrailsApplication application = new DefaultGrailsApplication(new Class[] { groovyClass,secondController },gcl);\n        registerBeanDefinition(groovyClass, application,request,response);\n        registerBeanDefinition(secondController, application,request,response);\n\n        GrailsControllerHelper helper1 = new SimpleGrailsControllerHelper(application,context,new MockServletContext());\n        GrailsControllerHelper helper2 = new SimpleGrailsControllerHelper(application,context,new MockServletContext());\n\n        // first test redirection within the same controller\n        try {\n            helper1.handleURI(\"/test/list\",request,response);\n        }\n        catch(MissingMethodException mme) {\n            fail(\"Missing method exception should not have been thrown!\");\n        }\n        catch(MissingPropertyException mpex) {\n            fail(\"Missing property exception should not have been thrown!\");\n        }\n        // now redirection to another controller\n        try {\n            request = new MockHttpServletRequest();\n            response = new MockHttpServletResponse();\n            helper2.handleURI(\"/second/list\",request,response);\n        }\n        catch(MissingMethodException mme) {\n            fail(\"Missing method exception should not have been thrown!\");\n        }\n        catch(MissingPropertyException mpex) {\n            fail(\"Missing property exception should not have been thrown!\");\n        }\n    }","commit_id":"1299b0bafb8bfafe430617873f320fd415192362","url":"https://github.com/grails/grails-core"},{"original_method":"public String getControllerUri(ServletRequest request) {\n        GroovyObject controller = getController(request);\n\n        return (String)controller.getProperty(ControllerDynamicMethods.CONTROLLER_URI_PROPERTY);\n    }","id":102144,"modified_method":"public String getControllerUri(ServletRequest request) {\n        GroovyObject controller = getController(request);\n        if(controller != null)\n            return (String)controller.getProperty(ControllerDynamicMethods.CONTROLLER_URI_PROPERTY);\n        else\n            return null;\n    }","commit_id":"1299b0bafb8bfafe430617873f320fd415192362","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n         * Prepare Bindings before instantiating page.\n         * @param request\n         * @param response\n         * @param out\n         * @return the Bindings\n         * @throws IOException\n         */\n        protected Binding getBinding(HttpServletRequest request, HttpServletResponse response, Writer out)\n                throws IOException {\n            // Set up the script context\n            Binding binding = new Binding();\n            GroovyObject controller = (GroovyObject)request.getAttribute(GrailsApplicationAttributes.CONTROLLER);\n            binding.setVariable(GroovyPage.REQUEST, controller.getProperty(ControllerDynamicMethods.REQUEST_PROPERTY));\n            binding.setVariable(GroovyPage.RESPONSE, controller.getProperty(ControllerDynamicMethods.RESPONSE_PROPERTY));\n            binding.setVariable(GroovyPage.SERVLET_CONTEXT, context);\n            ApplicationContext appContext = (ApplicationContext)context.getAttribute(GrailsApplicationAttributes.APPLICATION_CONTEXT);\n            binding.setVariable(GroovyPage.APPLICATION_CONTEXT, appContext);\n            binding.setVariable(GrailsApplication.APPLICATION_ID, appContext.getBean(GrailsApplication.APPLICATION_ID));\n            binding.setVariable(GrailsApplicationAttributes.CONTROLLER, controller);\n            binding.setVariable(GrailsApplicationAttributes.TAG_LIB, request.getAttribute(GrailsApplicationAttributes.TAG_LIB));\n            binding.setVariable(GroovyPage.SESSION, controller.getProperty(GetSessionDynamicProperty.PROPERTY_NAME));\n            binding.setVariable(GroovyPage.PARAMS, controller.getProperty(GetParamsDynamicProperty.PROPERTY_NAME));\n            binding.setVariable(GroovyPage.OUT, out);\n            binding.setVariable(\"grailsTagRegistry\", GrailsTagRegistry.getInstance());\n\n            // Go through request attributes and add them to the binding as the model\n            for (Enumeration attributeEnum =  request.getAttributeNames(); attributeEnum.hasMoreElements();) {\n                String key = (String) attributeEnum.nextElement();\n                try {\n                    binding.getVariable(key);\n                }\n                catch(MissingPropertyException mpe) {\n                    binding.setVariable( key, request.getAttribute(key) );\n                }\n            }\n            for (Iterator i = additionalBinding.keySet().iterator(); i.hasNext();) {\n                String key =  (String)i.next();\n                binding.setVariable(key, additionalBinding.get(key));\n            }\n            return binding;\n        }","id":102145,"modified_method":"/**\n         * Prepare Bindings before instantiating page.\n         * @param request\n         * @param response\n         * @param out\n         * @return the Bindings\n         * @throws IOException\n         */\n        protected Binding getBinding(HttpServletRequest request, HttpServletResponse response, Writer out)\n                throws IOException {\n            // Set up the script context\n            Binding binding = new Binding();\n            GroovyObject controller = (GroovyObject)request.getAttribute(GrailsApplicationAttributes.CONTROLLER);\n            binding.setVariable(GroovyPage.REQUEST, controller.getProperty(ControllerDynamicMethods.REQUEST_PROPERTY));\n            binding.setVariable(GroovyPage.RESPONSE, controller.getProperty(ControllerDynamicMethods.RESPONSE_PROPERTY));\n            binding.setVariable(GroovyPage.FLASH, controller.getProperty(ControllerDynamicMethods.FLASH_SCOPE_PROPERTY));\n            binding.setVariable(GroovyPage.SERVLET_CONTEXT, context);\n            ApplicationContext appContext = (ApplicationContext)context.getAttribute(GrailsApplicationAttributes.APPLICATION_CONTEXT);\n            binding.setVariable(GroovyPage.APPLICATION_CONTEXT, appContext);\n            binding.setVariable(GrailsApplication.APPLICATION_ID, appContext.getBean(GrailsApplication.APPLICATION_ID));\n            binding.setVariable(GrailsApplicationAttributes.CONTROLLER, controller);\n            binding.setVariable(GrailsApplicationAttributes.TAG_LIB, request.getAttribute(GrailsApplicationAttributes.TAG_LIB));\n            binding.setVariable(GroovyPage.SESSION, controller.getProperty(GetSessionDynamicProperty.PROPERTY_NAME));\n            binding.setVariable(GroovyPage.PARAMS, controller.getProperty(GetParamsDynamicProperty.PROPERTY_NAME));\n            binding.setVariable(GroovyPage.OUT, out);\n\n\n            // Go through request attributes and add them to the binding as the model\n            for (Enumeration attributeEnum =  request.getAttributeNames(); attributeEnum.hasMoreElements();) {\n                String key = (String) attributeEnum.nextElement();\n                try {\n                    binding.getVariable(key);\n                }\n                catch(MissingPropertyException mpe) {\n                    binding.setVariable( key, request.getAttribute(key) );\n                }\n            }\n            for (Iterator i = additionalBinding.keySet().iterator(); i.hasNext();) {\n                String key =  (String)i.next();\n                binding.setVariable(key, additionalBinding.get(key));\n            }\n            return binding;\n        }","commit_id":"1299b0bafb8bfafe430617873f320fd415192362","url":"https://github.com/grails/grails-core"},{"original_method":"public Object invoke(Object target, Object[] arguments) {\n\t\tif(arguments.length == 0)\n\t\t\tthrow new MissingMethodException(METHOD_SIGNATURE,target.getClass(),arguments);\n\t\t\t\t\n\t\tObject actionRef;\n\t\tMap params = null;\n\t\tErrors errors = null;\n\t\tGroovyObject controller = (GroovyObject)target;\n\t\t\n\t\tif(arguments[0] instanceof Map) {\n\t\t\tMap argMap = (Map)arguments[0];\n\t\t\tactionRef = argMap.get(ARGUMENT_ACTION);\n\t\t\tparams = (Map)argMap.get(ARGUMENT_PARAMS);\n\t\t\terrors = (Errors)argMap.get(ARGUMENT_ERRORS);\n\t\t}\n\t\telse {\n\t\t\tactionRef = arguments[0];\n\t\t\tif(arguments.length > 1) {\n\t\t\t\tif(arguments[1] instanceof Map) {\n\t\t\t\t\tparams = (Map)arguments[1];\n\t\t\t\t}\n\t\t\t\telse if(arguments[1] instanceof Errors) {\n\t\t\t\t\terrors = (Errors)arguments[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(arguments.length > 2) {\n\t\t\t\tif(arguments[2] instanceof Map) {\n\t\t\t\t\tparams = (Map)arguments[2];\n\t\t\t\t}\n\t\t\t\telse if(arguments[2] instanceof Errors) {\n\t\t\t\t\terrors = (Errors)arguments[2];\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\t\n\t\t// if there are errors add it to the list of errors\n\t\tErrors controllerErrors = (Errors)controller.getProperty( ControllerDynamicMethods.ERRORS_PROPERTY );\n        if(controllerErrors != null) {\n            controllerErrors.addAllErrors(errors);\n        }\n        else {\n            controller.setProperty( ControllerDynamicMethods.ERRORS_PROPERTY, errors);\n        }\n\n\t\t\n        if(actionRef instanceof String) {\n\t\t\tString uri = (String)actionRef;\n\t\t\tif(params != null ) {\n\t\t\t\treturn helper.handleURI(uri,this.request,this.response, params);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn helper.handleURI(uri,this.request,this.response);\n\t\t\t}\n\t\t}\n\t\telse if(actionRef instanceof Closure) {\n\t\t\tClosure c = (Closure)actionRef;\n\t\t\tPropertyDescriptor prop = GrailsClassUtils.getPropertyDescriptorForValue(target,c);\n\t\t\tString closureName = null;\n\t\t\tif(prop != null) {\n\t\t\t\tclosureName = prop.getName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGrailsScaffolder scaffolder = helper.getScaffolderForController(target.getClass().getName());\n\t\t\t\tif(scaffolder != null) {\n\t\t\t\t\t\tclosureName = scaffolder.getActionName(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tGrailsControllerClass controllerClass = helper.getControllerClassByName( target.getClass().getName() );\n\t\t\tString viewName  = controllerClass.getViewByName(closureName);\n\t\t\t\n\t\t\tObject returnValue = helper.handleAction(controller,c,request,response,params);\n\t\t\treturn helper.handleActionResponse(controller,returnValue,closureName,viewName);\n\t\t}\n\n\t\tthrow new MissingMethodException(METHOD_SIGNATURE,target.getClass(),arguments);\t\t\t\n\t}","id":102146,"modified_method":"public Object invoke(Object target, Object[] arguments) {\n        if(arguments.length == 0)\n            throw new MissingMethodException(METHOD_SIGNATURE,target.getClass(),arguments);\n\n        Object actionRef = null;\n        String controllerName = null;\n        Object id = null;\n        Object uri = null;\n        Map params;\n        Errors errors;\n        GroovyObject controller = (GroovyObject)target;\n\n        if(arguments[0] instanceof Map) {\n            Map argMap = (Map)arguments[0];\n            if(argMap.containsKey(ARGUMENT_URI)) {\n                 uri = argMap.get(ARGUMENT_URI);\n            }\n            else {\n                actionRef = argMap.get(ARGUMENT_ACTION);\n                controllerName = (String)argMap.get(ARGUMENT_CONTROLLER);\n                id =  argMap.get(ARGUMENT_ID);\n            }\n            params = (Map)argMap.get(ARGUMENT_PARAMS);\n            errors = (Errors)argMap.get(ARGUMENT_ERRORS);\n        }\n        else {\n            throw new MissingMethodException(METHOD_SIGNATURE,target.getClass(),arguments);\n        }\n        // if there are errors add it to the list of errors\n        Errors controllerErrors = (Errors)controller.getProperty( ControllerDynamicMethods.ERRORS_PROPERTY );\n        if(controllerErrors != null) {\n            controllerErrors.addAllErrors(errors);\n        }\n        else {\n            controller.setProperty( ControllerDynamicMethods.ERRORS_PROPERTY, errors);\n        }\n\n        String actionName = null;\n        if(actionRef instanceof String) {\n           actionName = (String)actionRef;\n        }\n        else if(actionRef instanceof Closure) {\n            Closure c = (Closure)actionRef;\n            PropertyDescriptor prop = GrailsClassUtils.getPropertyDescriptorForValue(target,c);\n            if(prop != null) {\n                actionName = prop.getName();\n            }\n            else {\n                GrailsScaffolder scaffolder = helper.getScaffolderForController(target.getClass().getName());\n                if(scaffolder != null) {\n                        actionName = scaffolder.getActionName(c);\n                }\n            }\n        }\n        String actualUri = null;\n\n        GrailsApplicationAttributes attrs = helper.getGrailsAttributes();\n\n        if(uri != null) {\n            actualUri = uri.toString();\n        }\n        else {\n            if(actionName != null) {\n                StringBuffer actualUriBuf = new StringBuffer(attrs.getApplicationUri(request));\n                if(controllerName != null) {\n                    actualUriBuf.append('/')\n                             .append(controllerName);\n                }\n                else {\n                    actualUriBuf.append(attrs.getControllerUri(request));\n                }\n                actualUriBuf.append('/')\n                         .append(actionName);\n                if(id != null) {\n                    actualUriBuf.append('/')\n                             .append(id);\n                }\n                if(params != null) {\n                    actualUriBuf.append('?');\n                    for (Iterator i = params.keySet().iterator(); i.hasNext();) {\n                        Object name = i.next();\n                        actualUriBuf.append(name)\n                                 .append('=')\n                                 .append(params.get(name));\n                        if(i.hasNext())\n                            actualUriBuf.append('&');\n                    }\n                }\n            }\n            else {\n                throw new ControllerExecutionException(\"Action not found in redirect for name [\"+actionName+\"]\");\n            }\n        }\n\n\n        if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Dynamic method [redirect] forwarding request to [\"+actualUri +\"]\");\n        }\n\n        try {\n            response.sendRedirect(response.encodeRedirectURL(actualUri));\n        } catch (IOException e) {\n            throw new ControllerExecutionException(\"Error redirecting request for url [\"+actualUri +\"]: \" + e.getMessage(),e);\n        }\n        return null;\n    }","commit_id":"1299b0bafb8bfafe430617873f320fd415192362","url":"https://github.com/grails/grails-core"},{"original_method":"public RenderDynamicMethod(GrailsControllerHelper helper, HttpServletRequest request, HttpServletResponse response) {\n        super(METHOD_SIGNATURE, request, response);\n        this.helper = helper;\n    }","id":102147,"modified_method":"public RenderDynamicMethod(GrailsControllerHelper helper, HttpServletRequest request, HttpServletResponse response) {\n        super(METHOD_SIGNATURE, request, response);\n        this.helper = helper;\n        this.response = new GrailsHttpServletResponse(response);\n    }","commit_id":"1299b0bafb8bfafe430617873f320fd415192362","url":"https://github.com/grails/grails-core"},{"original_method":"public ModelAndView handleURI(String uri, HttpServletRequest request, HttpServletResponse response, Map params) {\n        if(uri == null)\n            throw new IllegalArgumentException(\"Controller URI [\" + uri + \"] cannot be null!\");\n\n        // step 1: process the uri\n        if (uri.indexOf(\"?\") > -1) {\n            uri = uri.substring(0, uri.indexOf(\"?\"));\n        }\n        if(uri.indexOf('\\\\') > -1) {\n            uri = uri.replaceAll(\"\\\\\\\\\", \"/\");\n        }\n        if(!uri.startsWith(\"/\"))\n            uri = '/' + uri;\n        if(uri.endsWith(\"/\"))\n            uri = uri.substring(0,uri.length() - 1);\n\n        String id = null;\n        Map extraParams = Collections.EMPTY_MAP;\n        Matcher m = uriPattern.matcher(uri);\n        if(m.find()) {\n            uri = '/' + m.group(1) + '/' + m.group(2);\n            id = m.group(3);\n            String extraParamsString = m.group(4);\n            if(extraParamsString != null && extraParamsString.indexOf('/') > - 1) {\n                String[] tokens = extraParamsString.split(\"/\");\n                extraParams = new HashMap();\n                for (int i = 0; i < tokens.length; i++) {\n                    String token = tokens[i];\n                    if(i == 0 || ((i % 2) == 0)) {\n                        if((i + 1) < tokens.length) {\n                            extraParams.put(token, tokens[i + 1]);\n                        }\n                    }\n                    else {\n                        continue;\n                    }\n                }\n\n            }\n        }\n\n        // Step 2: lookup the controller in the application.\n        GrailsControllerClass controllerClass = getControllerClassByURI(uri);\n\n        // parse the uri in its individual tokens\n        String controllerName = WordUtils.uncapitalize(controllerClass.getName());;\n\n\n\n        GrailsTagLibClass tagLibClass = this.application.getTagLibClassForController(controllerClass.getFullName());\n\n        if (controllerClass == null) {\n            throw new UnknownControllerException(\"No controller found for URI [\" + uri + \"]!\");\n        }\n\n\n        // Step 3: load controller from application context.\n        GroovyObject controller = getControllerInstance(controllerClass);\n\n        // create the tag lib for the controller if there is one\n        GroovyObject tagLib = null;\n        if(tagLibClass != null) {\n            tagLib = (GroovyObject)this.applicationContext.getBean(tagLibClass.getFullName());\n        }\n        request.setAttribute( GrailsApplicationAttributes.TAG_LIB, tagLib);\n        request.setAttribute( GrailsApplicationAttributes.CONTROLLER, controller );\n\n        // Step 3a: Configure a proxy interceptor for controller dynamic methods for this request\n        if(this.interceptor == null) {\n            try {\n                interceptor = new ControllerDynamicMethods(controller,this,request,response);\n            }\n            catch(IntrospectionException ie) {\n                throw new ControllerExecutionException(\"Error creating dynamic controller methods for controller [\"+controller.getClass()+\"]: \" + ie.getMessage(), ie);\n            }\n        }\n        if(this.tagLibInterceptor == null && tagLib != null) {\n            try {\n                tagLibInterceptor =  new TagLibDynamicMethods(tagLib,controller,request,response);\n            }\n            catch(IntrospectionException ie) {\n                throw new ControllerExecutionException(\"Error creating dynamic controller methods for controller [\"+controller.getClass()+\"]: \" + ie.getMessage(), ie);\n            }                                      \n        }\n        // Step 3b: if scaffolding retrieve scaffolder\n        if(controllerClass.isScaffolding())  {\n            this.scaffolder = (GrailsScaffolder)applicationContext.getBean( controllerClass.getFullName() + SCAFFOLDER );\n            if(this.scaffolder == null)\n                throw new IllegalStateException(\"Scaffolding set to true for controller [\"+controllerClass.getFullName()+\"] but no scaffolder available!\");\n        }\n\n        // Step 4: get closure property name for URI.\n        String actionPropertyName = controllerClass.getClosurePropertyName(uri);\n        if (actionPropertyName == null) {\n            // Step 4a: Check if scaffolding\n            if( controllerClass.isScaffolding() && !scaffolder.supportsAction(actionPropertyName))\n                throw new NoClosurePropertyForURIException(\"Could not find closure property for URI [\" + uri + \"] for controller [\" + controllerClass.getFullName() + \"]!\");\n        }\n\n        // Step 4a: Set dynamic properties on controller\n        if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Processing request for controller [\"+controllerName+\"], action [\"+actionPropertyName+\"], and id [\"+id+\"]\");\n        }\n        if(LOG.isTraceEnabled()) {\n            LOG.trace(\"Extra params from uri [\"+extraParams+\"] \");\n        }\n        controller.setProperty(ControllerDynamicMethods.CONTROLLER_URI_PROPERTY, '/' + controllerName);\n        controller.setProperty(ControllerDynamicMethods.ACTION_URI_PROPERTY, '/' + controllerName + '/' + actionPropertyName);\n        Map controllerParams = (Map)controller.getProperty(GetParamsDynamicProperty.PROPERTY_NAME);\n        if(!StringUtils.isBlank(id)) {\n            controllerParams.put(GrailsApplicationAttributes.ID_PARAM, id);\n        }\n        if(!extraParams.isEmpty()) {\n            for (Iterator i = extraParams.keySet().iterator(); i.hasNext();) {\n                String name = (String) i.next();\n                controllerParams.put(name,extraParams.get(name));\n            }\n        }\n\n        // Step 5: get the view name for this URI.\n        String viewName = controllerClass.getViewByURI(uri);\n\n        // Step 6: get closure from closure property\n        Closure action = (Closure)controller.getProperty(actionPropertyName);\n\n        if(action == null)\n            throw new IllegalStateException(\"Scaffolder supports action [\"+actionPropertyName+\"] for controller [\"+controllerClass.getFullName()+\"] but getAction returned null!\");\n\n        // Step 7: process the action\n        Object returnValue = handleAction( controller,action,request,response,params );\n\n\n        // Step 8: determine return value type and handle accordingly\n        return handleActionResponse(controller,returnValue,actionPropertyName,viewName);\n    }","id":102148,"modified_method":"public ModelAndView handleURI(String uri, HttpServletRequest request, HttpServletResponse response, Map params) {\n        if(uri == null)\n            throw new IllegalArgumentException(\"Controller URI [\" + uri + \"] cannot be null!\");\n\n        // step 1: process the uri\n        if (uri.indexOf(\"?\") > -1) {\n            uri = uri.substring(0, uri.indexOf(\"?\"));\n        }\n        if(uri.indexOf('\\\\') > -1) {\n            uri = uri.replaceAll(\"\\\\\\\\\", \"/\");\n        }\n        if(!uri.startsWith(\"/\"))\n            uri = '/' + uri;\n        if(uri.endsWith(\"/\"))\n            uri = uri.substring(0,uri.length() - 1);\n\n        String id = null;\n        Map extraParams = Collections.EMPTY_MAP;\n        Matcher m = uriPattern.matcher(uri);\n        if(m.find()) {\n            uri = '/' + m.group(1) + '/' + m.group(2);\n            id = m.group(3);\n            String extraParamsString = m.group(4);\n            if(extraParamsString != null && extraParamsString.indexOf('/') > - 1) {\n                String[] tokens = extraParamsString.split(\"/\");\n                extraParams = new HashMap();\n                for (int i = 0; i < tokens.length; i++) {\n                    String token = tokens[i];\n                    if(i == 0 || ((i % 2) == 0)) {\n                        if((i + 1) < tokens.length) {\n                            extraParams.put(token, tokens[i + 1]);\n                        }\n                    }\n                }\n\n            }\n        }\n\n        // Step 2: lookup the controller in the application.\n        GrailsControllerClass controllerClass = getControllerClassByURI(uri);\n\n        // parse the uri in its individual tokens\n        String controllerName = WordUtils.uncapitalize(controllerClass.getName());;\n\n\n\n        GrailsTagLibClass tagLibClass = this.application.getTagLibClassForController(controllerClass.getFullName());\n\n        if (controllerClass == null) {\n            throw new UnknownControllerException(\"No controller found for URI [\" + uri + \"]!\");\n        }\n\n\n        // Step 3: load controller from application context.\n        GroovyObject controller = getControllerInstance(controllerClass);\n\n        // create the tag lib for the controller if there is one\n        GroovyObject tagLib = null;\n        if(tagLibClass != null) {\n            tagLib = (GroovyObject)this.applicationContext.getBean(tagLibClass.getFullName());\n        }\n        request.setAttribute( GrailsApplicationAttributes.TAG_LIB, tagLib);\n        request.setAttribute( GrailsApplicationAttributes.CONTROLLER, controller );\n\n        // Step 3a: Configure a proxy interceptor for controller dynamic methods for this request\n        if(this.interceptor == null) {\n            try {\n                interceptor = new ControllerDynamicMethods(controller,this,request,response);\n            }\n            catch(IntrospectionException ie) {\n                throw new ControllerExecutionException(\"Error creating dynamic controller methods for controller [\"+controller.getClass()+\"]: \" + ie.getMessage(), ie);\n            }\n        }\n        if(this.tagLibInterceptor == null && tagLib != null) {\n            try {\n                tagLibInterceptor =  new TagLibDynamicMethods(tagLib,controller,request,response);\n            }\n            catch(IntrospectionException ie) {\n                throw new ControllerExecutionException(\"Error creating dynamic controller methods for controller [\"+controller.getClass()+\"]: \" + ie.getMessage(), ie);\n            }                                      \n        }\n        // Step 3b: if scaffolding retrieve scaffolder\n        if(controllerClass.isScaffolding())  {\n            this.scaffolder = (GrailsScaffolder)applicationContext.getBean( controllerClass.getFullName() + SCAFFOLDER );\n            if(this.scaffolder == null)\n                throw new IllegalStateException(\"Scaffolding set to true for controller [\"+controllerClass.getFullName()+\"] but no scaffolder available!\");\n        }\n\n        // Step 4: get closure property name for URI.\n        String actionPropertyName = controllerClass.getClosurePropertyName(uri);\n        if (actionPropertyName == null) {\n            // Step 4a: Check if scaffolding\n            if( controllerClass.isScaffolding() && !scaffolder.supportsAction(actionPropertyName))\n                throw new NoClosurePropertyForURIException(\"Could not find closure property for URI [\" + uri + \"] for controller [\" + controllerClass.getFullName() + \"]!\");\n        }\n\n        // Step 4a: Set dynamic properties on controller\n        if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Processing request for controller [\"+controllerName+\"], action [\"+actionPropertyName+\"], and id [\"+id+\"]\");\n        }\n        if(LOG.isTraceEnabled()) {\n            LOG.trace(\"Extra params from uri [\"+extraParams+\"] \");\n        }\n        controller.setProperty(ControllerDynamicMethods.CONTROLLER_URI_PROPERTY, '/' + controllerName);\n        controller.setProperty(ControllerDynamicMethods.ACTION_URI_PROPERTY, '/' + controllerName + '/' + actionPropertyName);\n\n        // populate additional params from url\n        Map controllerParams = (Map)controller.getProperty(GetParamsDynamicProperty.PROPERTY_NAME);\n        if(!StringUtils.isBlank(id)) {\n            controllerParams.put(GrailsApplicationAttributes.ID_PARAM, id);\n        }\n        if(!extraParams.isEmpty()) {\n            for (Iterator i = extraParams.keySet().iterator(); i.hasNext();) {\n                String name = (String) i.next();\n                controllerParams.put(name,extraParams.get(name));\n            }\n        }\n\n        // set the flash scope instance to its next state and set on controller\n        FlashScope fs = this.grailsAttributes.getFlashScope(request);\n        fs.next();\n\n        controller.setProperty(ControllerDynamicMethods.FLASH_SCOPE_PROPERTY,fs);\n\n        // Step 5: get the view name for this URI.\n        String viewName = controllerClass.getViewByURI(uri);\n\n        // Step 6: get closure from closure property\n        Closure action = (Closure)controller.getProperty(actionPropertyName);\n\n        if(action == null)\n            throw new IllegalStateException(\"Scaffolder supports action [\"+actionPropertyName+\"] for controller [\"+controllerClass.getFullName()+\"] but getAction returned null!\");\n\n\n        // Step 7: process the action\n        Object returnValue = handleAction( controller,action,request,response,params );\n\n\n        // Step 8: determine return value type and handle accordingly\n        return handleActionResponse(controller,returnValue,actionPropertyName,viewName);\n    }","commit_id":"1299b0bafb8bfafe430617873f320fd415192362","url":"https://github.com/grails/grails-core"},{"original_method":"public ModelAndView handleActionResponse( GroovyObject controller,Object returnValue,String closurePropertyName, String viewName) {\n        boolean viewNameBlank = (viewName == null || viewName.length() == 0);\n        // reset the metaclass\n        ModelAndView explicityModelAndView = (ModelAndView)controller.getProperty(ControllerDynamicMethods.MODEL_AND_VIEW_PROPERTY);\n        Boolean renderView = (Boolean)controller.getProperty(ControllerDynamicMethods.RENDER_VIEW_PROPERTY);\n        if(renderView == null) renderView = Boolean.TRUE;\n\n        if(!renderView.booleanValue()) {\n            return null;\n        }\n        else if(explicityModelAndView != null) {\n            return explicityModelAndView;\n        }\n        else if (returnValue == null) {\n            if (viewNameBlank) {\n                return null;\n            } else {\n                return new ModelAndView(viewName, new BeanMap(controller));\n            }\n        } else if (returnValue instanceof Map) {\n            // remove any Proxy wrappers and set the adaptee as the value\n            removeProxiesFromModelObjects((Map)returnValue);\n            if (viewNameBlank) {\n                throw new NoViewNameDefinedException(\"Map instance returned by and no view name specified for closure on property [\" + closurePropertyName + \"] in controller [\" + controller.getClass() + \"]!\");\n            } else {\n                Map returnMap = (Map)returnValue;\n                if(!this.chainModel.isEmpty()) {\n                    this.chainModel.putAll( returnMap );\n                    return new ModelAndView(viewName, this.chainModel);\n                }\n                else {\n                    return new ModelAndView(viewName, returnMap);\n                }\n            }\n        } else if (returnValue instanceof ModelAndView) {\n            ModelAndView modelAndView = (ModelAndView)returnValue;\n\n            // remove any Proxy wrappers and set the adaptee as the value\n            Map modelMap = modelAndView.getModel();\n            removeProxiesFromModelObjects(modelMap);\n\n            if(!this.chainModel.isEmpty()) {\n                this.chainModel.putAll(modelMap);\n                modelAndView.addAllObjects(this.chainModel);\n            }\n\n            if (modelAndView.getView() == null && modelAndView.getViewName() == null) {\n                if (viewNameBlank) {\n                    throw new NoViewNameDefinedException(\"ModelAndView instance returned by and no view name defined by nor for closure on property [\" + closurePropertyName + \"] in controller [\" + controller.getClass() + \"]!\");\n                } else {\n                    modelAndView.setViewName(viewName);\n                }\n            }\n            return modelAndView;\n        }\n        else {\n            Map modelMap = new BeanMap(controller);\n            ModelAndView modelAndView = new ModelAndView(viewName, modelMap);\n            if(!this.chainModel.isEmpty()) {\n                this.chainModel.putAll(modelMap);\n                modelAndView.addAllObjects(this.chainModel);\n            }\n            return modelAndView;\n        }\n    }","id":102149,"modified_method":"public ModelAndView handleActionResponse( GroovyObject controller,Object returnValue,String closurePropertyName, String viewName) {\n        boolean viewNameBlank = (viewName == null || viewName.length() == 0);\n        // reset the metaclass\n        ModelAndView explicityModelAndView = (ModelAndView)controller.getProperty(ControllerDynamicMethods.MODEL_AND_VIEW_PROPERTY);\n        Boolean renderView = (Boolean)controller.getProperty(ControllerDynamicMethods.RENDER_VIEW_PROPERTY);\n        FlashScope fs = this.grailsAttributes.getFlashScope((HttpServletRequest)controller.getProperty(ControllerDynamicMethods.REQUEST_PROPERTY));\n        this.chainModel = (Map)fs.get(ChainDynamicMethod.PROPERTY_CHAIN_MODEL);\n\n        if(renderView == null) renderView = Boolean.TRUE;\n\n        if(!renderView.booleanValue()) {\n            return null;\n        }\n        else if(explicityModelAndView != null) {\n            return explicityModelAndView;\n        }\n        else if (returnValue == null) {\n            if (viewNameBlank) {\n                return null;\n            } else {\n                return new ModelAndView(viewName, new BeanMap(controller));\n            }\n        } else if (returnValue instanceof Map) {\n            // remove any Proxy wrappers and set the adaptee as the value\n            Map model = (Map)returnValue;\n            removeProxiesFromModelObjects(model);\n            if (viewNameBlank) {\n                throw new NoViewNameDefinedException(\"Map instance returned by and no view name specified for closure on property [\" + closurePropertyName + \"] in controller [\" + controller.getClass() + \"]!\");\n            } else {\n\n                if(!this.chainModel.isEmpty()) {\n                    model.putAll(this.chainModel);\n                    return new ModelAndView(viewName, model);\n                }\n                else {\n                    return new ModelAndView(viewName, model);\n                }\n            }\n        } else if (returnValue instanceof ModelAndView) {\n            ModelAndView modelAndView = (ModelAndView)returnValue;\n\n            // remove any Proxy wrappers and set the adaptee as the value\n            Map modelMap = modelAndView.getModel();\n            removeProxiesFromModelObjects(modelMap);\n\n            if(!this.chainModel.isEmpty()) {\n                modelAndView.addAllObjects(this.chainModel);\n            }\n\n            if (modelAndView.getView() == null && modelAndView.getViewName() == null) {\n                if (viewNameBlank) {\n                    throw new NoViewNameDefinedException(\"ModelAndView instance returned by and no view name defined by nor for closure on property [\" + closurePropertyName + \"] in controller [\" + controller.getClass() + \"]!\");\n                } else {\n                    modelAndView.setViewName(viewName);\n                }\n            }\n            return modelAndView;\n        }\n        else {\n            Map modelMap = new BeanMap(controller);\n            ModelAndView modelAndView = new ModelAndView(viewName, modelMap);\n            if(!this.chainModel.isEmpty()) {\n                modelMap.putAll(chainModel);\n                modelAndView.addAllObjects(modelMap);\n            }\n            return modelAndView;\n        }\n    }","commit_id":"1299b0bafb8bfafe430617873f320fd415192362","url":"https://github.com/grails/grails-core"},{"original_method":"public TagLibDynamicMethods(GroovyObject taglib, GroovyObject controller, HttpServletRequest request, HttpServletResponse response) throws IntrospectionException {\n        super(taglib);\n\n        ProxyMetaClass controllerMetaClass = (ProxyMetaClass)controller.getMetaClass();\n        ControllerDynamicMethods controllerDynamicMethods = (ControllerDynamicMethods)controllerMetaClass.getInterceptor();\n\n\n        addDynamicProperty(new GenericDynamicProperty(OUT_PROPERTY, Writer.class,false));\n\n        // add dynamic properties (shared with controller)\n        addDynamicProperty(controllerDynamicMethods.getDynamicProperty(GetParamsDynamicProperty.PROPERTY_NAME));\n        addDynamicProperty(controllerDynamicMethods.getDynamicProperty(GetSessionDynamicProperty.PROPERTY_NAME));\n        addDynamicProperty(controllerDynamicMethods.getDynamicProperty(ControllerDynamicMethods.REQUEST_PROPERTY));\n        addDynamicProperty(controllerDynamicMethods.getDynamicProperty(ControllerDynamicMethods.RESPONSE_PROPERTY) );\n        addDynamicProperty(controllerDynamicMethods.getDynamicProperty(ControllerDynamicMethods.SERVLET_CONTEXT) );\n        addDynamicProperty(controllerDynamicMethods.getDynamicProperty(ControllerDynamicMethods.GRAILS_ATTRIBUTES) );\n\n        addDynamicMethodInvocation(new AbstractDynamicMethodInvocation(THROW_TAG_ERROR_METHOD) {\n            public Object invoke(Object target, Object[] arguments) {\n                if(arguments.length == 0)\n                    throw new MissingMethodException(THROW_TAG_ERROR_METHOD,target.getClass(),arguments);\n                throw new GrailsTagException(arguments[0].toString());\n            }\n        });\n    }","id":102150,"modified_method":"public TagLibDynamicMethods(GroovyObject taglib, GroovyObject controller, HttpServletRequest request, HttpServletResponse response) throws IntrospectionException {\n        super(taglib);\n\n        ProxyMetaClass controllerMetaClass = (ProxyMetaClass)controller.getMetaClass();\n        ControllerDynamicMethods controllerDynamicMethods = (ControllerDynamicMethods)controllerMetaClass.getInterceptor();\n\n\n        addDynamicProperty(new GenericDynamicProperty(OUT_PROPERTY, Writer.class,false));\n\n        // add dynamic properties (shared with controller)\n        addDynamicProperty(controllerDynamicMethods.getDynamicProperty(GetParamsDynamicProperty.PROPERTY_NAME));\n        addDynamicProperty(controllerDynamicMethods.getDynamicProperty(GetSessionDynamicProperty.PROPERTY_NAME));\n        addDynamicProperty(controllerDynamicMethods.getDynamicProperty(ControllerDynamicMethods.REQUEST_PROPERTY));\n        addDynamicProperty(controllerDynamicMethods.getDynamicProperty(ControllerDynamicMethods.RESPONSE_PROPERTY) );\n        addDynamicProperty(controllerDynamicMethods.getDynamicProperty(ControllerDynamicMethods.SERVLET_CONTEXT) );\n        addDynamicProperty(controllerDynamicMethods.getDynamicProperty(ControllerDynamicMethods.GRAILS_ATTRIBUTES) );\n        addDynamicProperty(controllerDynamicMethods.getDynamicProperty(ControllerDynamicMethods.FLASH_SCOPE_PROPERTY) );\n\n        addDynamicMethodInvocation(new AbstractDynamicMethodInvocation(THROW_TAG_ERROR_METHOD) {\n            public Object invoke(Object target, Object[] arguments) {\n                if(arguments.length == 0)\n                    throw new MissingMethodException(THROW_TAG_ERROR_METHOD,target.getClass(),arguments);\n                throw new GrailsTagException(arguments[0].toString());\n            }\n        });\n    }","commit_id":"1299b0bafb8bfafe430617873f320fd415192362","url":"https://github.com/grails/grails-core"},{"original_method":"public void readDescriptor(@Language(\"JSON\") @NotNull String descriptor, @Nullable ProjectSetProcessor.Context context) {\n\n    ProjectSetProcessor[] extensions = ProjectSetProcessor.EXTENSION_POINT_NAME.getExtensions();\n    Map<String, ProjectSetProcessor> processors = new HashMap<String, ProjectSetProcessor>();\n    for (ProjectSetProcessor extension : extensions) {\n      processors.put(extension.getId(), extension);\n    }\n\n    JsonElement parse;\n    try {\n      parse = new JsonParser().parse(descriptor);\n    }\n    catch (JsonSyntaxException e) {\n      LOG.error(e);\n      return;\n    }\n    Iterator<Map.Entry<String, JsonElement>> iterator = parse.getAsJsonObject().entrySet().iterator();\n    if (context == null) {\n      context = new ProjectSetProcessor.Context();\n    }\n    context.directoryName = \"\";\n    runProcessor(processors, context, iterator);\n  }","id":102151,"modified_method":"public void readDescriptor(@NotNull JsonObject descriptor, @Nullable ProjectSetProcessor.Context context) {\n    Map<String, ProjectSetProcessor> processors = new HashMap<String, ProjectSetProcessor>();\n    for (ProjectSetProcessor extension : ProjectSetProcessor.EXTENSION_POINT_NAME.getExtensions()) {\n      processors.put(extension.getId(), extension);\n    }\n\n    if (context == null) {\n      context = new ProjectSetProcessor.Context();\n    }\n    context.directoryName = \"\";\n    runProcessor(processors, context, descriptor.entrySet().iterator());\n  }","commit_id":"e99bd4dd1773cde85d5847bdca3a35105e9740d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean process(@NotNull QueryStringDecoder urlDecoder, @NotNull FullHttpRequest request, @NotNull ChannelHandlerContext context)\n    throws IOException {\n\n    @Language(\"JSON\") final String desc = request.content().toString(Charset.defaultCharset());\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        new ProjectSetReader().readDescriptor(desc, null);\n      }\n    });\n    Responses.sendStatus(HttpResponseStatus.OK, context.channel(), request);\n    return true;\n  }","id":102152,"modified_method":"@Nullable\n  @Override\n  public String execute(@NotNull QueryStringDecoder urlDecoder, @NotNull FullHttpRequest request, @NotNull ChannelHandlerContext context) throws IOException {\n    final JsonObject descriptor = new JsonParser().parse(createJsonReader(request)).getAsJsonObject();\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        new ProjectSetReader().readDescriptor(descriptor, null);\n      }\n    });\n    sendOk(request, context);\n    return null;\n  }","commit_id":"e99bd4dd1773cde85d5847bdca3a35105e9740d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testVcsCheckoutProcessor() throws IOException {\n\n    final List<Pair<String, String>> pairs = new ArrayList<Pair<String, String>>();\n    PlatformTestUtil.registerExtension(VcsCheckoutProcessor.EXTENSION_POINT_NAME, new VcsCheckoutProcessor() {\n      @NotNull\n      @Override\n      public String getId() {\n        return \"schema\";\n      }\n\n      @Override\n      public boolean checkout(@NotNull Map<String, String> parameters,\n                              @NotNull VirtualFile parentDirectory, @NotNull String directoryName) {\n        pairs.add(Pair.create(parameters.get(\"url\"), directoryName));\n        return true;\n      }\n    }, myTestRootDisposable);\n\n    @Language(\"JSON\") String descriptor = FileUtil.loadFile(new File(getTestDataPath() + \"vcs.json\"));\n    ProjectSetProcessor.Context context = new ProjectSetProcessor.Context();\n    context.directoryName = \"newDir\";\n    context.directory = getSourceRoot();\n    new ProjectSetReader().readDescriptor(descriptor, context);\n    Collections.sort(pairs, new Comparator<Pair<String, String>>() {\n      @Override\n      public int compare(@NotNull Pair<String, String> o1, @NotNull Pair<String, String> o2) {\n        return o2.first.compareTo(o1.first);\n      }\n    });\n    assertEquals(Pair.create(\"schema://foo.bar/path\", \"test\"), pairs.get(1));\n    assertEquals(Pair.create(\"schema://foo.bar1/path1\", \"test/custom\"), pairs.get(0));\n  }","id":102153,"modified_method":"public void testVcsCheckoutProcessor() throws IOException {\n\n    final List<Pair<String, String>> pairs = new ArrayList<Pair<String, String>>();\n    PlatformTestUtil.registerExtension(VcsCheckoutProcessor.EXTENSION_POINT_NAME, new VcsCheckoutProcessor() {\n      @NotNull\n      @Override\n      public String getId() {\n        return \"schema\";\n      }\n\n      @Override\n      public boolean checkout(@NotNull Map<String, String> parameters,\n                              @NotNull VirtualFile parentDirectory, @NotNull String directoryName) {\n        pairs.add(Pair.create(parameters.get(\"url\"), directoryName));\n        return true;\n      }\n    }, myTestRootDisposable);\n\n    ProjectSetProcessor.Context context = new ProjectSetProcessor.Context();\n    context.directoryName = \"newDir\";\n    context.directory = getSourceRoot();\n    readDescriptor(new File(getTestDataPath() + \"vcs.json\"), context);\n    Collections.sort(pairs, new Comparator<Pair<String, String>>() {\n      @Override\n      public int compare(@NotNull Pair<String, String> o1, @NotNull Pair<String, String> o2) {\n        return o2.first.compareTo(o1.first);\n      }\n    });\n    assertEquals(Pair.create(\"schema://foo.bar/path\", \"test\"), pairs.get(1));\n    assertEquals(Pair.create(\"schema://foo.bar1/path1\", \"test/custom\"), pairs.get(0));\n  }","commit_id":"e99bd4dd1773cde85d5847bdca3a35105e9740d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testProjectSetReader() throws IOException {\n    ProjectSetReader reader = new ProjectSetReader();\n\n    final Ref<List<Pair<String, String>>> ref = Ref.create();\n    PlatformTestUtil.registerExtension(ProjectSetProcessor.EXTENSION_POINT_NAME, new ProjectSetProcessor() {\n      @Override\n      public String getId() {\n        return \"test\";\n      }\n\n      @Override\n      public void processEntries(@NotNull List<Pair<String, String>> entries, @NotNull Context context, @NotNull Runnable runNext) {\n        ref.set(entries);\n      }\n    }, myTestRootDisposable);\n\n    @Language(\"JSON\") String descriptor = FileUtil.loadFile(new File(getTestDataPath() + \"descriptor.json\"));\n    ProjectSetProcessor.Context context = new ProjectSetProcessor.Context();\n    context.directory = getSourceRoot();\n    reader.readDescriptor(descriptor, context);\n\n    List<Pair<String, String>> entries = ref.get();\n    assertEquals(2, entries.size());\n    assertEquals(\"git://foo.bar\", entries.get(0).getSecond());\n    assertEquals(\"{\\\"foo\\\":\\\"bar\\\"}\", entries.get(1).getSecond());\n  }","id":102154,"modified_method":"public void testProjectSetReader() throws IOException {\n    final Ref<List<Pair<String, String>>> ref = Ref.create();\n    PlatformTestUtil.registerExtension(ProjectSetProcessor.EXTENSION_POINT_NAME, new ProjectSetProcessor() {\n      @Override\n      public String getId() {\n        return \"test\";\n      }\n\n      @Override\n      public void processEntries(@NotNull List<Pair<String, String>> entries, @NotNull Context context, @NotNull Runnable runNext) {\n        ref.set(entries);\n      }\n    }, myTestRootDisposable);\n\n    ProjectSetProcessor.Context context = new ProjectSetProcessor.Context();\n    context.directory = getSourceRoot();\n    readDescriptor(new File(getTestDataPath() + \"descriptor.json\"), context);\n\n    List<Pair<String, String>> entries = ref.get();\n    assertEquals(2, entries.size());\n    assertEquals(\"git://foo.bar\", entries.get(0).getSecond());\n    assertEquals(\"{\\\"foo\\\":\\\"bar\\\"}\", entries.get(1).getSecond());\n  }","commit_id":"e99bd4dd1773cde85d5847bdca3a35105e9740d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testOpenProject() throws IOException {\n    @Language(\"JSON\") String descriptor = FileUtil.loadFile(new File(getTestDataPath() + \"project.json\"));\n    ProjectSetProcessor.Context context = new ProjectSetProcessor.Context();\n    context.directory = VfsUtil.findFileByIoFile(new File(getTestDataPath()), true);\n    new ProjectSetReader().readDescriptor(descriptor, context);\n    Project[] projects = ProjectManager.getInstance().getOpenProjects();\n    Project project = ContainerUtil.find(projects, new Condition<Project>() {\n      @Override\n      public boolean value(Project project) {\n        return \"untitled\".equals(project.getName());\n      }\n    });\n    assertNotNull(project);\n    ((ProjectManagerEx)ProjectManager.getInstance()).closeAndDispose(project);\n  }","id":102155,"modified_method":"public void testOpenProject() throws IOException {\n    ProjectSetProcessor.Context context = new ProjectSetProcessor.Context();\n    context.directory = VfsUtil.findFileByIoFile(new File(getTestDataPath()), true);\n    readDescriptor(new File(getTestDataPath() + \"project.json\"), context);\n    Project[] projects = ProjectManager.getInstance().getOpenProjects();\n    Project project = ContainerUtil.find(projects, new Condition<Project>() {\n      @Override\n      public boolean value(Project project) {\n        return \"untitled\".equals(project.getName());\n      }\n    });\n    assertNotNull(project);\n    ((ProjectManagerEx)ProjectManager.getInstance()).closeAndDispose(project);\n  }","commit_id":"e99bd4dd1773cde85d5847bdca3a35105e9740d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public final boolean isSupported(@NotNull FullHttpRequest request) {\n    if (!isMethodSupported(request.method())) {\n      return false;\n    }\n\n    String prefix = \"rest\";\n    String uri = request.uri();\n    String serviceName = getServiceName();\n    int minLength = 1 + prefix.length() + 1 + serviceName.length();\n    if (uri.length() >= minLength &&\n        uri.charAt(0) == '/' &&\n        uri.regionMatches(true, 1, prefix, 0, prefix.length()) &&\n        uri.regionMatches(true, 2 + prefix.length(), serviceName, 0, serviceName.length())) {\n      if (uri.length() == minLength) {\n        return true;\n      }\n      else {\n        char c = uri.charAt(minLength);\n        return c == '/' || c == '?';\n      }\n    }\n    return false;\n  }","id":102156,"modified_method":"@Override\n  public final boolean isSupported(@NotNull FullHttpRequest request) {\n    if (!isMethodSupported(request.method())) {\n      return false;\n    }\n\n    String uri = request.uri();\n\n    if (isPrefixlessAllowed() && checkPrefix(uri, getServiceName())) {\n      return true;\n    }\n\n    String prefix = \"rest\";\n    String serviceName = getServiceName();\n    int minLength = 1 + prefix.length() + 1 + serviceName.length();\n    if (uri.length() >= minLength &&\n        uri.charAt(0) == '/' &&\n        uri.regionMatches(true, 1, prefix, 0, prefix.length()) &&\n        uri.regionMatches(true, 2 + prefix.length(), serviceName, 0, serviceName.length())) {\n      if (uri.length() == minLength) {\n        return true;\n      }\n      else {\n        char c = uri.charAt(minLength);\n        return c == '/' || c == '?';\n      }\n    }\n    return false;\n  }","commit_id":"e99bd4dd1773cde85d5847bdca3a35105e9740d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        registry = new MetricRegistry();\n\n        MBeanServer server = getCamelContext().getManagementStrategy().getManagementAgent().getMBeanServer();\n        if (server != null) {\n            String domain = \"org.apache.camel.metrics.\" + getCamelContext().getManagementName();\n            reporter = JmxReporter.forRegistry(registry).registerWith(server).inDomain(domain).build();\n            reporter.start();\n        }\n    }","id":102157,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        if (registry == null) {\n            registry = new MetricRegistry();\n        }\n\n        if (useJmx) {\n            ManagementAgent agent = getCamelContext().getManagementStrategy().getManagementAgent();\n            if (agent != null) {\n                MBeanServer server = agent.getMBeanServer();\n                if (server != null) {\n                    String domain = jmxDomain + \".\" + getCamelContext().getManagementName();\n                    reporter = JmxReporter.forRegistry(registry).registerWith(server).inDomain(domain).build();\n                    reporter.start();\n                }\n            } else {\n                throw new IllegalStateException(\"CamelContext has not enabled JMX\");\n            }\n        }\n    }","commit_id":"2ff43ad42f4819184d374b2b6708aa40187fd000","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void onInit(Route route) {\n        super.onInit(route);\n\n        this.route = route;\n        try {\n            registry = route.getRouteContext().getCamelContext().hasService(MetricsRegistryService.class);\n            if (registry == null) {\n                registry = new MetricsRegistryService();\n                route.getRouteContext().getCamelContext().addService(registry);\n            }\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n\n        // create statistics holder\n        Counter total = registry.getRegistry().counter(createName(\"total\"));\n        Counter inflight = registry.getRegistry().counter(createName(\"inflight\"));\n        Meter requests = registry.getRegistry().meter(createName(\"requests\"));\n        Timer responses = registry.getRegistry().timer(createName(\"responses\"));\n        statistics = new MetricsStatistics(total, inflight, requests, responses);\n    }","id":102158,"modified_method":"@Override\n    public void onInit(Route route) {\n        super.onInit(route);\n\n        this.route = route;\n        try {\n            registryService = route.getRouteContext().getCamelContext().hasService(MetricsRegistryService.class);\n            if (registryService == null) {\n                registryService = new MetricsRegistryService();\n                registryService.setRegistry(getRegistry());\n                registryService.setUseJmx(isUseJmx());\n                registryService.setJmxDomain(getJmxDomain());\n                route.getRouteContext().getCamelContext().addService(registryService);\n            }\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n\n        // create statistics holder\n        Counter total = registryService.getRegistry().counter(createName(\"total\"));\n        Counter inflight = registryService.getRegistry().counter(createName(\"inflight\"));\n        Meter requests = registryService.getRegistry().meter(createName(\"requests\"));\n        Timer responses = registryService.getRegistry().timer(createName(\"responses\"));\n        statistics = new MetricsStatistics(total, inflight, requests, responses);\n    }","commit_id":"2ff43ad42f4819184d374b2b6708aa40187fd000","url":"https://github.com/apache/camel"},{"original_method":"private String createName(String type) {\n        return route.getRouteContext().getCamelContext().getManagementName() + \"-\" + route.getId() + \"-\" + type;\n    }","id":102159,"modified_method":"private String createName(String type) {\n        CamelContext context = route.getRouteContext().getCamelContext();\n        String name = context.getManagementName() != null ? context.getManagementName() : context.getName();\n        return name + \"-\" + route.getId() + \"-\" + type;\n    }","commit_id":"2ff43ad42f4819184d374b2b6708aa40187fd000","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public RoutePolicy createRoutePolicy(CamelContext camelContext, String routeId, RouteDefinition routeDefinition) {\n        return new MetricsRoutePolicy();\n    }","id":102160,"modified_method":"@Override\n    public RoutePolicy createRoutePolicy(CamelContext camelContext, String routeId, RouteDefinition routeDefinition) {\n        MetricsRoutePolicy answer = new MetricsRoutePolicy();\n        answer.setRegistry(getRegistry());\n        answer.setUseJmx(isUseJmx());\n        answer.setJmxDomain(getJmxDomain());\n        return answer;\n    }","commit_id":"2ff43ad42f4819184d374b2b6708aa40187fd000","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                context.addRoutePolicyFactory(new MetricsRoutePolicyFactory());\n\n                from(\"seda:foo\").routeId(\"foo\")\n                    .delayer(100)\n                    .to(\"mock:result\");\n\n                from(\"seda:bar\").routeId(\"bar\")\n                    .delayer(250)\n                    .to(\"mock:result\");\n            }\n        };\n    }","id":102161,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"seda:foo\").routeId(\"foo\")\n                    .to(\"mock:result\");\n\n                from(\"seda:bar\").routeId(\"bar\")\n                    .to(\"mock:result\");\n            }\n        };\n    }","commit_id":"2ff43ad42f4819184d374b2b6708aa40187fd000","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testMetricsRoutePolicy() throws Exception {\n        getMockEndpoint(\"mock:result\").expectedMessageCount(10);\n\n        for (int i = 0; i < 50; i++) {\n            if (i % 2 == 0) {\n                template.sendBody(\"seda:foo\", \"Hello \" + i);\n            } else {\n                template.sendBody(\"seda:bar\", \"Hello \" + i);\n            }\n        }\n\n        assertMockEndpointsSatisfied();\n\n        // TODO: assert the jmx mbeans\n    }","id":102162,"modified_method":"@Test\n    public void testMetricsRoutePolicy() throws Exception {\n        getMockEndpoint(\"mock:result\").expectedMessageCount(10);\n\n        for (int i = 0; i < 50; i++) {\n            if (i % 2 == 0) {\n                template.sendBody(\"seda:foo\", \"Hello \" + i);\n            } else {\n                template.sendBody(\"seda:bar\", \"Hello \" + i);\n            }\n        }\n\n        assertMockEndpointsSatisfied();\n\n        // there should be 2x4 names\n        assertEquals(8, registry.getNames().size());\n    }","commit_id":"2ff43ad42f4819184d374b2b6708aa40187fd000","url":"https://github.com/apache/camel"},{"original_method":"public Object doExecute() throws Exception {\n        CamelContext camelContext = camelController.getCamelContext(name);\n\n        if (camelContext == null) {\n            System.err.println(\"Camel context \" + name + \" not found.\");\n            return null;\n        }\n\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Context \" + name + \"\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tName: \" + camelContext.getName()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tVersion: \" + camelContext.getVersion()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStatus: \" + camelContext.getStatus()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tUptime: \" + camelContext.getUptime()));\n\n        // the statistics are in the mbenas\n        ObjectName contextMBean = null;\n        MBeanServer mBeanServer = camelContext.getManagementStrategy().getManagementAgent().getMBeanServer();\n        Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(DefaultManagementAgent.DEFAULT_DOMAIN + \":type=context,name=\\\"\" + name + \"\\\",*\"), null);\n        Iterator<ObjectName> iterator = set.iterator();\n        if (iterator.hasNext()) {\n            contextMBean = iterator.next();\n        }\n\n        if (mBeanServer.isRegistered(contextMBean)) {\n            Long exchangesTotal = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesTotal\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Total: \" + exchangesTotal));\n            Long exchangesCompleted = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesCompleted\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Completed: \" + exchangesCompleted));\n            Long exchangesFailed = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesFailed\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Failed: \" + exchangesFailed));\n            Long minProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MinProcessingTime\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\tMin Processing Time: \" + minProcessingTime + \"ms\"));\n            Long maxProcessingTime = (Long) mBeanServer.getAttribute(contextMBean,  \"MaxProcessingTime\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\tMax Processing Time: \" + maxProcessingTime + \"ms\"));\n            Long meanProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MeanProcessingTime\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\tMean Processing Time: \" + meanProcessingTime + \"ms\"));\n            Long totalProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"TotalProcessingTime\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\tTotal Processing Time: \" + totalProcessingTime + \"ms\"));\n            Long lastProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"LastProcessingTime\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Processing Time: \" + lastProcessingTime + \"ms\"));\n\n            String load01 = (String) mBeanServer.getAttribute(contextMBean, \"Load01\");\n            String load05 = (String) mBeanServer.getAttribute(contextMBean, \"Load05\");\n            String load15 = (String) mBeanServer.getAttribute(contextMBean, \"Load15\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\tLoad Avg: \" + load01 + \", \" + load05 + \", \" + load15));\n\n            // Test for null to see if a any exchanges have been processed first to avoid NPE\n            Object firstExchangeTimestampObj = mBeanServer.getAttribute(contextMBean, \"FirstExchangeCompletedTimestamp\");\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            if (firstExchangeTimestampObj == null) {\n                // Print an empty value for scripting\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date:\"));\n            } else {\n                Date firstExchangeTimestamp = (Date) firstExchangeTimestampObj;\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date: \" + format.format(firstExchangeTimestamp)));\n            }\n\n            // Again, check for null to avoid NPE\n            Object lastExchangeCompletedTimestampObj = mBeanServer.getAttribute(contextMBean, \"LastExchangeCompletedTimestamp\");\n            if (lastExchangeCompletedTimestampObj == null) {\n                // Print an empty value for scripting\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date:\"));\n            } else {\n                Date lastExchangeCompletedTimestamp = (Date) lastExchangeCompletedTimestampObj;\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date: \" + format.format(lastExchangeCompletedTimestamp)));\n            }\n\n            long activeRoutes = 0;\n            long inactiveRoutes = 0;\n            List<Route> routeList = camelContext.getRoutes();\n            for (Route route : routeList) {\n                if (camelContext.getRouteStatus(route.getId()).isStarted()) {\n                    activeRoutes++;\n                } else {\n                    inactiveRoutes++;\n                }\n            }\n\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of running routes: \" + activeRoutes));\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of not running routes: \" + inactiveRoutes));\n\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mAdvanced\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tAuto Startup: \" + camelContext.isAutoStartup()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStarting Routes: \" + camelContext.isStartingRoutes()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tSuspended: \" + camelContext.isSuspended()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tTracing: \" + camelContext.isTracing()));\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProperties\\u001B[0m\"));\n        for (String property : camelContext.getProperties().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + property + \" = \" + camelContext.getProperty(property)));\n        }\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mComponents\\u001B[0m\"));\n        for (String component : camelContext.getComponentNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + component));\n        }\n\n        if (mode != null && mode.equals(\"--verbose\")) {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mEndpoints\\u001B[0m\"));\n            for (Endpoint endpoint : camelContext.getEndpoints()) {\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + endpoint.getEndpointUri()));\n            }\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mRoutes\\u001B[0m\"));\n        for (Route route : camelContext.getRoutes()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + route.getId()));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mUsed Languages\\u001B[0m\"));\n        for (String language : camelContext.getLanguageNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + language));\n        }\n        \n        return null;\n    }","id":102163,"modified_method":"public Object doExecute() throws Exception {\n        CamelContext camelContext = camelController.getCamelContext(name);\n\n        if (camelContext == null) {\n            System.err.println(\"Camel context \" + name + \" not found.\");\n            return null;\n        }\n\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Context \" + name + \"\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tName: \" + camelContext.getName()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tVersion: \" + camelContext.getVersion()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStatus: \" + camelContext.getStatus()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tUptime: \" + camelContext.getUptime()));\n\n        // the statistics are in the mbeans\n        ObjectName contextMBean = null;\n        ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n        if (agent != null) {\n            MBeanServer mBeanServer = agent.getMBeanServer();\n\n            Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(DefaultManagementAgent.DEFAULT_DOMAIN + \":type=context,name=\\\"\" + name + \"\\\",*\"), null);\n            Iterator<ObjectName> iterator = set.iterator();\n            if (iterator.hasNext()) {\n                contextMBean = iterator.next();\n            }\n\n            if (mBeanServer.isRegistered(contextMBean)) {\n                Long exchangesTotal = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesTotal\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Total: \" + exchangesTotal));\n                Long exchangesCompleted = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesCompleted\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Completed: \" + exchangesCompleted));\n                Long exchangesFailed = (Long) mBeanServer.getAttribute(contextMBean, \"ExchangesFailed\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Failed: \" + exchangesFailed));\n                Long minProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MinProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMin Processing Time: \" + minProcessingTime + \"ms\"));\n                Long maxProcessingTime = (Long) mBeanServer.getAttribute(contextMBean,  \"MaxProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMax Processing Time: \" + maxProcessingTime + \"ms\"));\n                Long meanProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"MeanProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMean Processing Time: \" + meanProcessingTime + \"ms\"));\n                Long totalProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"TotalProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tTotal Processing Time: \" + totalProcessingTime + \"ms\"));\n                Long lastProcessingTime = (Long) mBeanServer.getAttribute(contextMBean, \"LastProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Processing Time: \" + lastProcessingTime + \"ms\"));\n\n                String load01 = (String) mBeanServer.getAttribute(contextMBean, \"Load01\");\n                String load05 = (String) mBeanServer.getAttribute(contextMBean, \"Load05\");\n                String load15 = (String) mBeanServer.getAttribute(contextMBean, \"Load15\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLoad Avg: \" + load01 + \", \" + load05 + \", \" + load15));\n\n                // Test for null to see if a any exchanges have been processed first to avoid NPE\n                Object firstExchangeTimestampObj = mBeanServer.getAttribute(contextMBean, \"FirstExchangeCompletedTimestamp\");\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                if (firstExchangeTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date:\"));\n                } else {\n                    Date firstExchangeTimestamp = (Date) firstExchangeTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date: \" + format.format(firstExchangeTimestamp)));\n                }\n\n                // Again, check for null to avoid NPE\n                Object lastExchangeCompletedTimestampObj = mBeanServer.getAttribute(contextMBean, \"LastExchangeCompletedTimestamp\");\n                if (lastExchangeCompletedTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date:\"));\n                } else {\n                    Date lastExchangeCompletedTimestamp = (Date) lastExchangeCompletedTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date: \" + format.format(lastExchangeCompletedTimestamp)));\n                }\n\n                long activeRoutes = 0;\n                long inactiveRoutes = 0;\n                List<Route> routeList = camelContext.getRoutes();\n                for (Route route : routeList) {\n                    if (camelContext.getRouteStatus(route.getId()).isStarted()) {\n                        activeRoutes++;\n                    } else {\n                        inactiveRoutes++;\n                    }\n                }\n\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of running routes: \" + activeRoutes));\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tNumber of not running routes: \" + inactiveRoutes));\n\n            }\n\n        } else {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[31mJMX Agent of Camel is not reachable. Maybe it has been disabled on the camel Context\"));\n            System.out.println(StringEscapeUtils.unescapeJava(\"In consequence, the statistics are not available.\\u001B[0m\"));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mAdvanced\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tAuto Startup: \" + camelContext.isAutoStartup()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tStarting Routes: \" + camelContext.isStartingRoutes()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tSuspended: \" + camelContext.isSuspended()));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tTracing: \" + camelContext.isTracing()));\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProperties\\u001B[0m\"));\n        for (String property : camelContext.getProperties().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + property + \" = \" + camelContext.getProperty(property)));\n        }\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mComponents\\u001B[0m\"));\n        for (String component : camelContext.getComponentNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + component));\n        }\n\n        if (mode != null && mode.equals(\"--verbose\")) {\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mEndpoints\\u001B[0m\"));\n            for (Endpoint endpoint : camelContext.getEndpoints()) {\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + endpoint.getEndpointUri()));\n            }\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mRoutes\\u001B[0m\"));\n        for (Route route : camelContext.getRoutes()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + route.getId()));\n        }\n\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mUsed Languages\\u001B[0m\"));\n        for (String language : camelContext.getLanguageNames()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\" + language));\n        }\n        \n        return null;\n    }","commit_id":"4dafcd9cc097d2f8bc5e54192165cdbb05ee6249","url":"https://github.com/apache/camel"},{"original_method":"public Object doExecute() throws Exception {\n        Route camelRoute = camelController.getRoute(route, context);\n\n        if (camelRoute == null) {\n            System.err.println(\"Camel route \" + route + \" not found.\");\n            return null;\n        }\n\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Route \" + camelRoute.getId() + \"\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tCamel Context: \" + camelRoute.getRouteContext().getCamelContext().getName()));\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProperties\\u001B[0m\"));\n        for (String property : camelRoute.getProperties().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\\t\" + property + \" = \" + camelRoute.getProperties().get(property)));\n        }\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mStatistics\\u001B[0m\"));\n        CamelContext camelContext = camelRoute.getRouteContext().getCamelContext();\n        if (camelContext != null) {\n            MBeanServer mBeanServer = camelContext.getManagementStrategy().getManagementAgent().getMBeanServer();\n            Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(DefaultManagementAgent.DEFAULT_DOMAIN + \":type=routes,name=\\\"\" + route + \"\\\",*\"), null);\n            Iterator<ObjectName> iterator = set.iterator();\n            if (iterator.hasNext()) {\n                ObjectName routeMBean = iterator.next();\n                Long exchangesTotal = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesTotal\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Total: \" + exchangesTotal));\n                Long exchangesCompleted = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesCompleted\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Completed: \" + exchangesCompleted));\n                Long exchangesFailed = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesFailed\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Failed: \" + exchangesFailed));\n                Long minProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MinProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMin Processing Time: \" + minProcessingTime + \"ms\"));\n                Long maxProcessingTime = (Long) mBeanServer.getAttribute(routeMBean,  \"MaxProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMax Processing Time: \" + maxProcessingTime + \"ms\"));\n                Long meanProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MeanProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tMean Processing Time: \" + meanProcessingTime + \"ms\"));\n                Long totalProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"TotalProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tTotal Processing Time: \" + totalProcessingTime + \"ms\"));\n                Long lastProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"LastProcessingTime\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Processing Time: \" + lastProcessingTime + \"ms\"));\n                String load01 = (String) mBeanServer.getAttribute(routeMBean, \"Load01\");\n                String load05 = (String) mBeanServer.getAttribute(routeMBean, \"Load05\");\n                String load15 = (String) mBeanServer.getAttribute(routeMBean, \"Load15\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\tLoad Avg: \" + load01 + \", \" + load05 + \", \" + load15));\n                \n                // Test for null to see if a any exchanges have been processed first to avoid NPE\n                Object firstExchangeTimestampObj = mBeanServer.getAttribute(routeMBean, \"FirstExchangeCompletedTimestamp\");\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                if (firstExchangeTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date:\"));\n                } else {\n                    Date firstExchangeTimestamp = (Date) firstExchangeTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date: \" + format.format(firstExchangeTimestamp)));\n                }\n\n                // Again, check for null to avoid NPE\n                Object lastExchangeCompletedTimestampObj = mBeanServer.getAttribute(routeMBean, \"LastExchangeCompletedTimestamp\");\n                if (lastExchangeCompletedTimestampObj == null) {\n                    // Print an empty value for scripting\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date:\"));\n                } else {\n                    Date lastExchangeCompletedTimestamp = (Date) lastExchangeCompletedTimestampObj;\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date: \" + format.format(lastExchangeCompletedTimestamp)));\n                }\n            }\n        }\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mDefinition\\u001B[0m\"));\n        RouteDefinition definition = camelController.getRouteDefinition(route, camelRoute.getRouteContext().getCamelContext().getName());\n        System.out.println(StringEscapeUtils.unescapeJava(ModelHelper.dumpModelAsXml(definition)));\n        return null;\n    }","id":102164,"modified_method":"public Object doExecute() throws Exception {\n        Route camelRoute = camelController.getRoute(route, context);\n\n        if (camelRoute == null) {\n            System.err.println(\"Camel route \" + route + \" not found.\");\n            return null;\n        }\n\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1m\\u001B[33mCamel Route \" + camelRoute.getId() + \"\\u001B[0m\"));\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\tCamel Context: \" + camelRoute.getRouteContext().getCamelContext().getName()));\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mProperties\\u001B[0m\"));\n        for (String property : camelRoute.getProperties().keySet()) {\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\t\\t\" + property + \" = \" + camelRoute.getProperties().get(property)));\n        }\n        System.out.println(\"\");\n        System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mStatistics\\u001B[0m\"));\n        CamelContext camelContext = camelRoute.getRouteContext().getCamelContext();\n        if (camelContext != null) {\n            ManagementAgent agent = camelContext.getManagementStrategy().getManagementAgent();\n            if (agent != null) {\n                MBeanServer mBeanServer = agent.getMBeanServer();\n                Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(DefaultManagementAgent.DEFAULT_DOMAIN + \":type=routes,name=\\\"\" + route + \"\\\",*\"), null);\n                Iterator<ObjectName> iterator = set.iterator();\n                if (iterator.hasNext()) {\n                    ObjectName routeMBean = iterator.next();\n                    Long exchangesTotal = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesTotal\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Total: \" + exchangesTotal));\n                    Long exchangesCompleted = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesCompleted\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Completed: \" + exchangesCompleted));\n                    Long exchangesFailed = (Long) mBeanServer.getAttribute(routeMBean, \"ExchangesFailed\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tExchanges Failed: \" + exchangesFailed));\n                    Long minProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MinProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tMin Processing Time: \" + minProcessingTime + \"ms\"));\n                    Long maxProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MaxProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tMax Processing Time: \" + maxProcessingTime + \"ms\"));\n                    Long meanProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"MeanProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tMean Processing Time: \" + meanProcessingTime + \"ms\"));\n                    Long totalProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"TotalProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tTotal Processing Time: \" + totalProcessingTime + \"ms\"));\n                    Long lastProcessingTime = (Long) mBeanServer.getAttribute(routeMBean, \"LastProcessingTime\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Processing Time: \" + lastProcessingTime + \"ms\"));\n                    String load01 = (String) mBeanServer.getAttribute(routeMBean, \"Load01\");\n                    String load05 = (String) mBeanServer.getAttribute(routeMBean, \"Load05\");\n                    String load15 = (String) mBeanServer.getAttribute(routeMBean, \"Load15\");\n                    System.out.println(StringEscapeUtils.unescapeJava(\"\\tLoad Avg: \" + load01 + \", \" + load05 + \", \" + load15));\n\n                    // Test for null to see if a any exchanges have been processed first to avoid NPE\n                    Object firstExchangeTimestampObj = mBeanServer.getAttribute(routeMBean, \"FirstExchangeCompletedTimestamp\");\n                    SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                    if (firstExchangeTimestampObj == null) {\n                        // Print an empty value for scripting\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date:\"));\n                    } else {\n                        Date firstExchangeTimestamp = (Date) firstExchangeTimestampObj;\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tFirst Exchange Date: \" + format.format(firstExchangeTimestamp)));\n                    }\n\n                    // Again, check for null to avoid NPE\n                    Object lastExchangeCompletedTimestampObj = mBeanServer.getAttribute(routeMBean, \"LastExchangeCompletedTimestamp\");\n                    if (lastExchangeCompletedTimestampObj == null) {\n                        // Print an empty value for scripting\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date:\"));\n                    } else {\n                        Date lastExchangeCompletedTimestamp = (Date) lastExchangeCompletedTimestampObj;\n                        System.out.println(StringEscapeUtils.unescapeJava(\"\\tLast Exchange Completed Date: \" + format.format(lastExchangeCompletedTimestamp)));\n                    }\n                }\n            } else {\n                System.out.println(\"\");\n                System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[31mJMX Agent of Camel is not reachable. Maybe it has been disabled on the camel Context\"));\n                System.out.println(StringEscapeUtils.unescapeJava(\"In consequence, the statistics are not available.\\u001B[0m\"));\n            }\n\n            System.out.println(\"\");\n            System.out.println(StringEscapeUtils.unescapeJava(\"\\u001B[1mDefinition\\u001B[0m\"));\n            RouteDefinition definition = camelController.getRouteDefinition(route, camelRoute.getRouteContext().getCamelContext().getName());\n            System.out.println(StringEscapeUtils.unescapeJava(ModelHelper.dumpModelAsXml(definition)));\n        }\n        return null;\n    }","commit_id":"4dafcd9cc097d2f8bc5e54192165cdbb05ee6249","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void processIntention(@NotNull PsiElement element)\n            throws IncorrectOperationException {\n        final PsiElement parent = element.getParent();\n        if (!(parent instanceof PsiClass)) {\n            return;\n        }\n        PsiClass aClass = (PsiClass) parent;\n        final PsiReferenceList extendsList = aClass.getExtendsList();\n        if (extendsList == null) {\n            return;\n        }\n        final Project project = element.getProject();\n        final JavaCodeStyleManager codeStyleManager =\n                JavaCodeStyleManager.getInstance(project);\n        final PsiMethod[] methods = aClass.getMethods();\n        for (PsiMethod method : methods) {\n            final String name = method.getName();\n            if (method.hasModifierProperty(PsiModifier.STATIC)) {\n                continue;\n            }\n            final PsiType returnType = method.getReturnType();\n            if (!PsiType.VOID.equals(returnType)) {\n                continue;\n            }\n            final PsiModifierList modifierList = method.getModifierList();\n            if (name.startsWith(\"test\")) {\n                final PsiAnnotation annotation =\n                        modifierList.addAnnotation(\"org.junit.Test\");\n                codeStyleManager.shortenClassReferences(annotation);\n                method.accept(new MethodCallModifier());\n            } else if (name.equals(\"setUp\")) {\n                final PsiAnnotation annotation =\n                        modifierList.addAnnotation(\"org.junit.Before\");\n                codeStyleManager.shortenClassReferences(annotation);\n            } else if (name.equals(\"tearDown\")) {\n                final PsiAnnotation annotation =\n                        modifierList.addAnnotation(\"org.junit.After\");\n                codeStyleManager.shortenClassReferences(annotation);\n            }\n        }\n        final PsiJavaCodeReferenceElement[] referenceElements =\n                extendsList.getReferenceElements();\n        for (PsiJavaCodeReferenceElement referenceElement : referenceElements) {\n            referenceElement.delete();\n        }\n    }","id":102165,"modified_method":"@Override\n    protected void processIntention(@NotNull PsiElement element)\n            throws IncorrectOperationException {\n        final PsiElement parent = element.getParent();\n        if (!(parent instanceof PsiClass)) {\n            return;\n        }\n        final PsiClass aClass = (PsiClass) parent;\n        final PsiReferenceList extendsList = aClass.getExtendsList();\n        if (extendsList == null) {\n            return;\n        }\n        final PsiMethod[] methods = aClass.getMethods();\n        for (PsiMethod method : methods) {\n            final String name = method.getName();\n            if (method.hasModifierProperty(PsiModifier.STATIC)) {\n                continue;\n            }\n            final PsiType returnType = method.getReturnType();\n            if (!PsiType.VOID.equals(returnType)) {\n                continue;\n            }\n            final PsiModifierList modifierList = method.getModifierList();\n            if (name.startsWith(\"test\")) {\n                addAnnotationIfNotPresent(modifierList, \"org.junit.Test\");\n                method.accept(new MethodCallModifier());\n            } else if (name.equals(\"setUp\")) {\n                transformSetUpOrTearDownMethod(method);\n                addAnnotationIfNotPresent(modifierList, \"org.junit.Before\");\n            } else if (name.equals(\"tearDown\")) {\n                transformSetUpOrTearDownMethod(method);\n                addAnnotationIfNotPresent(modifierList, \"org.junit.After\");\n            }\n        }\n        final PsiJavaCodeReferenceElement[] referenceElements =\n                extendsList.getReferenceElements();\n        for (PsiJavaCodeReferenceElement referenceElement : referenceElements) {\n            referenceElement.delete();\n        }\n    }","commit_id":"5c456c2e38b2add2e2a5a6d089bfe3f042cafa51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\tif (!applicationFile.exists()) {\r\n\t\t\tthrow new CLIStatusException(\"application_not_found\", applicationFile.getAbsolutePath());\r\n\t\t}\r\n\r\n\t\tlogger.info(\"Validating file \" + applicationFile.getName());\r\n\t\tfinal Application application = ServiceReader.getApplicationFromFile(applicationFile).getApplication();\r\n\r\n\t\tnormalizeApplicationName(application);\r\n\r\n\t\tif (adminFacade.getApplicationsList().contains(applicationName)) {\r\n\t\t\tthrow new CLIStatusException(\"application_already_deployed\", application.getName());\r\n\t\t}\r\n\r\n\t\tFile zipFile;\r\n\t\tif (applicationFile.isFile()) {\n\t\t\tif (applicationFile.getName().endsWith(\".zip\") || applicationFile.getName().endsWith(\".jar\")) {\n\t\t\t\tzipFile = applicationFile;\n\t\t\t} else {\n\t\t\t\tthrow new CLIStatusException(\"application_file_format_mismatch\", applicationFile.getPath());\n\t\t\t}\r\n\t\t} else {//pack an application folder\r\n\t\t\tzipFile = Packager.packApplication(application, applicationFile);\t\t\t\r\n\t\t}\r\n\r\n\t\t// toString of string list (i.e. [service1, service2])\r\n\t\tlogger.info(\"Uploading application \" + applicationName);\r\n\t\tMap<String, String> result = adminFacade.installApplication(zipFile, applicationName, timeoutInMinutes);\n\t\tString serviceOrder = result.get(CloudifyConstants.SERVICE_ORDER);\n\r\n\t\t// If temp file was created, Delete it.\r\n\t\tif (!applicationFile.isFile()) {\r\n\t\t\tzipFile.delete();\r\n\t\t}\r\n\r\n\t\tif (serviceOrder.charAt(0) != '[' && serviceOrder.charAt(serviceOrder.length() - 1) != ']') {\r\n\t\t\tthrow new IllegalStateException(\"Cannot parse service order response: \" + serviceOrder);\r\n\t\t}\n\t\t\n\t\tprintApplicationInfo(application);\n\t\tif (result.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)){\n\t\t\tString pollingID = result.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tthis.adminFacade.waitForLifecycleEvents(pollingID, timeoutInMinutes, TIMEOUT_ERROR_MESSAGE);\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" +\n\t\t\t\"Check logs for more details.\");\n\t\t}\r\n\r\n\t\tsession.put(Constants.ACTIVE_APP, applicationName);\r\n\t\tGigaShellMain.getInstance().setCurrentApplicationName(applicationName);\r\n\r\n\t\treturn this.getFormattedMessage(\"application_installed_succesfully\", Color.GREEN, applicationName);\r\n\t}","id":102166,"modified_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\tif (!applicationFile.exists()) {\r\n\t\t\tthrow new CLIStatusException(\"application_not_found\", applicationFile.getAbsolutePath());\r\n\t\t}\r\n\r\n\t\tlogger.info(\"Validating file \" + applicationFile.getName());\r\n\t\tfinal Application application = ServiceReader.getApplicationFromFile(applicationFile).getApplication();\r\n\r\n\t\tnormalizeApplicationName(application);\r\n\r\n\t\tif (adminFacade.getApplicationsList().contains(applicationName)) {\r\n\t\t\tthrow new CLIStatusException(\"application_already_deployed\", application.getName());\r\n\t\t}\r\n\r\n\t\tFile zipFile;\r\n\t\tif (applicationFile.isFile()) {\n\t\t\tif (applicationFile.getName().endsWith(\".zip\") || applicationFile.getName().endsWith(\".jar\")) {\n\t\t\t\tzipFile = applicationFile;\n\t\t\t} else {\n\t\t\t\tthrow new CLIStatusException(\"application_file_format_mismatch\", applicationFile.getPath());\n\t\t\t}\r\n\t\t} else {//pack an application folder\r\n\t\t\tzipFile = Packager.packApplication(application, applicationFile);\t\t\t\r\n\t\t}\r\n\r\n\t\t// toString of string list (i.e. [service1, service2])\r\n\t\tlogger.info(\"Uploading application \" + applicationName);\r\n\t\tMap<String, String> result = adminFacade.installApplication(zipFile, applicationName, timeoutInMinutes);\n\t\tString serviceOrder = result.get(CloudifyConstants.SERVICE_ORDER);\n\r\n\t\t// If temp file was created, Delete it.\r\n\t\tif (!applicationFile.isFile()) {\r\n\t\t\tzipFile.delete();\r\n\t\t}\r\n\r\n\t\tif (serviceOrder.charAt(0) != '[' && serviceOrder.charAt(serviceOrder.length() - 1) != ']') {\r\n\t\t\tthrow new IllegalStateException(\"Cannot parse service order response: \" + serviceOrder);\r\n\t\t}\n\t\t\n\t\tprintApplicationInfo(application);\n\t\tif (result.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString pollingID = result.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tRestLifecycleEventsLatch lifecycleEventsPollingLatch = \n\t\t\t\t\tthis.adminFacade.getLifecycleEventsPollingLatch(pollingID);\n\t\t\tboolean isDone = lifecycleEventsPollingLatch.waitForLifecycleEvents(timeoutInMinutes, TimeUnit.MINUTES);\n\t\t\twhile (!isDone) {\n\t\t\t\tboolean continueInstallation = promptWouldYouLikeToContinueQuestion();\n\t\t\t\tif (!continueInstallation) {\n\t\t\t\t\t//uninstallApplication();\n\t\t\t\t} else { \n\t\t\t\t\tisDone = lifecycleEventsPollingLatch.continueWaitForLifecycleEvents(timeoutInMinutes, TimeUnit.MINUTES);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\r\n\r\n\t\tsession.put(Constants.ACTIVE_APP, applicationName);\r\n\t\tGigaShellMain.getInstance().setCurrentApplicationName(applicationName);\r\n\r\n\t\treturn this.getFormattedMessage(\"application_installed_succesfully\", Color.GREEN, applicationName);\r\n\t}","commit_id":"f8d1f7ed99e6d147164d446258afb9852c6aa01e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\tif (!recipe.exists()) {\r\n\t\t\tthrow new CLIStatusException(\"service_file_doesnt_exist\", recipe.getPath());\r\n\t\t}\r\n\r\n\t\tFile packedFile;\r\n\r\n\t\t// TODO: this logics should not be done twice. should be done directly in the rest server.\r\n\t\t// also figure out how to treat war/jar files that have no .groovy file. create default?\r\n\t\tService service = null;\r\n\t\ttry {\r\n\t\t\tif (recipe.getName().endsWith(\".jar\") || recipe.getName().endsWith(\".war\")) {\r\n\t\t\t\t// legacy XAP Processing Unit\r\n\t\t\t\tpackedFile = recipe;\r\n\t\t\t} else if (recipe.isDirectory()) {\r\n\t\t\t\t// Assume that a folder will contain a DSL file?\n\t\t\t\t\n\t\t\t\tif (serviceFileName != null) {\n\t\t\t\t\tFile fullPathToRecipe = new File(recipe.getAbsolutePath() + \"/\" + serviceFileName);\n\t\t\t\t\tif (!fullPathToRecipe.exists()) {\n\t\t\t\t\t\tthrow new CLIStatusException(\"service_file_doesnt_exist\", fullPathToRecipe.getPath());\n\t\t\t\t\t}\n\t\t\t\t\tpackedFile = Packager.pack(fullPathToRecipe);\n\t\t\t\t\tservice = ServiceReader.readService(fullPathToRecipe);\n\t\t\t\t} else {\r\n\t\t\t\t\tpackedFile = Packager.pack(recipe);\n\t\t\t\t\tservice = ServiceReader.readService(recipe);\r\n\t\t\t\t}\r\n\t\t\t\tpackedFile.deleteOnExit();\r\n\t\t\t} else {\r\n\t\t\t\t// serviceFile is a zip file\r\n\t\t\t\tpackedFile = recipe;\r\n\t\t\t\tservice = ServiceReader.readServiceFromZip(packedFile, CloudifyConstants.DEFAULT_APPLICATION_NAME);\r\n\t\t\t}\r\n\t\t} catch (final IOException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t} catch (final PackagingException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t}\r\n\t\tfinal String currentApplicationName = getCurrentApplicationName();\r\n\r\n\t\t// TODO: All packaging logic should be moved to the REST server\r\n\t\tProperties props = null;\r\n\t\tif (service != null) {\r\n\t\t\tprops = createServiceContextProperties(service);\n\t\t\tif (serviceFileName != null) {\n\t\t\t\tprops.setProperty(CloudifyConstants.CONTEXT_PROPERTY_SERVICE_FILE_NAME, serviceFileName);\n\t\t\t}\r\n\t\t\tif (serviceName == null || serviceName.isEmpty()) {\r\n\t\t\t\tserviceName = service.getName();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (serviceName == null || serviceName.isEmpty()) {\r\n\t\t\tserviceName = recipe.getName();\r\n\t\t\tfinal int endIndex = serviceName.lastIndexOf('.');\r\n\t\t\tif (endIndex > 0) {\r\n\t\t\t\tserviceName = serviceName.substring(0, endIndex);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (zone == null || zone.isEmpty()) {\r\n\t\t\tzone = serviceName;\r\n\t\t}\r\n\r\n\t\tString templateName;\r\n\t\t// service is null when a simple deploying war for example\r\n\t\tif (service == null || service.getCompute() == null) {\n\t\t\ttemplateName = \"\";\n\t\t} else {\r\n\t\t\ttemplateName = service.getCompute().getTemplate();\r\n\t\t\tif (templateName == null) {\r\n\t\t\t\ttemplateName = \"\";\r\n\t\t\t}\r\n\t\t}\n\t\t\r\n\t\tString lifecycleEventContainerPollingID = adminFacade.installElastic(packedFile,\n\t\t\t\tcurrentApplicationName, serviceName, zone, props, templateName, timeoutInMinutes);\n\n\t\tif (lifecycleEventContainerPollingID != null) {\n\t\t\tthis.adminFacade.waitForLifecycleEvents(lifecycleEventContainerPollingID,\n\t\t\t\t\ttimeoutInMinutes, TIMEOUT_ERROR_MESSAGE);\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\r\n\t\t// if a zip file was created, delete it at the end of use.\r\n\t\tif (recipe.isDirectory()) {\r\n\t\t\tFileUtils.deleteQuietly(packedFile.getParentFile());\r\n\t\t}\r\n\r\n\t\treturn getFormattedMessage(\"service_install_ended\", Color.GREEN, serviceName);\r\n\t}","id":102167,"modified_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\tif (!recipe.exists()) {\r\n\t\t\tthrow new CLIStatusException(\"service_file_doesnt_exist\", recipe.getPath());\r\n\t\t}\r\n\r\n\t\tFile packedFile;\r\n\r\n\t\t// TODO: this logics should not be done twice. should be done directly in the rest server.\r\n\t\t// also figure out how to treat war/jar files that have no .groovy file. create default?\r\n\t\tService service = null;\r\n\t\ttry {\r\n\t\t\tif (recipe.getName().endsWith(\".jar\") || recipe.getName().endsWith(\".war\")) {\r\n\t\t\t\t// legacy XAP Processing Unit\r\n\t\t\t\tpackedFile = recipe;\r\n\t\t\t} else if (recipe.isDirectory()) {\r\n\t\t\t\t// Assume that a folder will contain a DSL file?\n\t\t\t\t\n\t\t\t\tif (serviceFileName != null) {\n\t\t\t\t\tFile fullPathToRecipe = new File(recipe.getAbsolutePath() + \"/\" + serviceFileName);\n\t\t\t\t\tif (!fullPathToRecipe.exists()) {\n\t\t\t\t\t\tthrow new CLIStatusException(\"service_file_doesnt_exist\", fullPathToRecipe.getPath());\n\t\t\t\t\t}\n\t\t\t\t\tpackedFile = Packager.pack(fullPathToRecipe);\n\t\t\t\t\tservice = ServiceReader.readService(fullPathToRecipe);\n\t\t\t\t} else {\r\n\t\t\t\t\tpackedFile = Packager.pack(recipe);\n\t\t\t\t\tservice = ServiceReader.readService(recipe);\r\n\t\t\t\t}\r\n\t\t\t\tpackedFile.deleteOnExit();\r\n\t\t\t} else {\r\n\t\t\t\t// serviceFile is a zip file\r\n\t\t\t\tpackedFile = recipe;\r\n\t\t\t\tservice = ServiceReader.readServiceFromZip(packedFile, CloudifyConstants.DEFAULT_APPLICATION_NAME);\r\n\t\t\t}\r\n\t\t} catch (final IOException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t} catch (final PackagingException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t}\r\n\t\tfinal String currentApplicationName = getCurrentApplicationName();\r\n\r\n\t\t// TODO: All packaging logic should be moved to the REST server\r\n\t\tProperties props = null;\r\n\t\tif (service != null) {\r\n\t\t\tprops = createServiceContextProperties(service);\n\t\t\tif (serviceFileName != null) {\n\t\t\t\tprops.setProperty(CloudifyConstants.CONTEXT_PROPERTY_SERVICE_FILE_NAME, serviceFileName);\n\t\t\t}\r\n\t\t\tif (serviceName == null || serviceName.isEmpty()) {\r\n\t\t\t\tserviceName = service.getName();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (serviceName == null || serviceName.isEmpty()) {\r\n\t\t\tserviceName = recipe.getName();\r\n\t\t\tfinal int endIndex = serviceName.lastIndexOf('.');\r\n\t\t\tif (endIndex > 0) {\r\n\t\t\t\tserviceName = serviceName.substring(0, endIndex);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (zone == null || zone.isEmpty()) {\r\n\t\t\tzone = serviceName;\r\n\t\t}\r\n\r\n\t\tString templateName;\r\n\t\t// service is null when a simple deploying war for example\r\n\t\tif (service == null || service.getCompute() == null) {\n\t\t\ttemplateName = \"\";\n\t\t} else {\r\n\t\t\ttemplateName = service.getCompute().getTemplate();\r\n\t\t\tif (templateName == null) {\r\n\t\t\t\ttemplateName = \"\";\r\n\t\t\t}\r\n\t\t}\n\t\t\r\n\t\tString lifecycleEventContainerPollingID = adminFacade.installElastic(packedFile,\n\t\t\t\tcurrentApplicationName, serviceName, zone, props, templateName, timeoutInMinutes);\n\n\t\tif (lifecycleEventContainerPollingID != null) {\n\t\t\tRestLifecycleEventsLatch lifecycleEventsPollingLatch = this.adminFacade.\n\t\t\t\t\tgetLifecycleEventsPollingLatch(lifecycleEventContainerPollingID);\n\t\t\tboolean isDone = lifecycleEventsPollingLatch.waitForLifecycleEvents(timeoutInMinutes, TimeUnit.MINUTES);\n\t\t\twhile (!isDone) {\n\t\t\t\tboolean continueInstallation = promptWouldYouLikeToContinueQuestion();\n\t\t\t\tif (!continueInstallation) {\n\t\t\t\t\t//uninstallService();\n\t\t\t\t\tisDone = true;\n\t\t\t\t} else {\n\t\t\t\t\tisDone = lifecycleEventsPollingLatch.continueWaitForLifecycleEvents(timeoutInMinutes, TimeUnit.MINUTES);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\r\n\t\t// if a zip file was created, delete it at the end of use.\r\n\t\tif (recipe.isDirectory()) {\r\n\t\t\tFileUtils.deleteQuietly(packedFile.getParentFile());\r\n\t\t}\r\n\r\n\t\treturn getFormattedMessage(\"service_install_ended\", Color.GREEN, serviceName);\r\n\t}","commit_id":"f8d1f7ed99e6d147164d446258afb9852c6aa01e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void uninstallApplications(final long timeout, final TimeUnit timeunit) throws InterruptedException,\n\t\t\tTimeoutException, CLIException {\n\n\t\tList<String> applicationsList = null;\n\t\tboolean applicationsExist = false;\n\t\ttry {\n\t\t\tif (!adminFacade.isConnected()) {\n\t\t\t\tthrow new CLIException(\"Failed to fetch applications list. \"\n\t\t\t\t\t\t+ \"Client is not connected to the rest server.\");\n\t\t\t}\n\n\t\t\tapplicationsList = adminFacade.getApplicationsList();\n\t\t\t// If there existed other applications besides the management.\n\t\t\tapplicationsExist = applicationsList.size() > 1;\n\t\t} catch (final CLIException e) {\n\t\t\tif (!force) {\n\t\t\t\tthrow new CLIStatusException(e, \"failed_to_access_rest_before_teardown\");\n\t\t\t}\n\t\t\tfinal String errorMessage = \"Failed to fetch the currently deployed applications list.\"\n\t\t\t\t\t+ \" Continuing teardown-localcloud.\";\n\t\t\tif (verbose) {\n\t\t\t\tlogger.log(Level.FINE, errorMessage, e);\n\t\t\t\tpublishEvent(errorMessage + System.getProperty(\"line.separator\") + e.toString());\n\t\t\t} else {\n\t\t\t\tlogger.log(Level.FINE, errorMessage);\n\t\t\t\tpublishEvent(errorMessage);\n\t\t\t}\n\t\t\t// Suppress exception. continue with teardown.\n\t\t\treturn;\n\t\t}\n\n\t\tif (applicationsExist && !force) {\n\t\t\tthrow new CLIStatusException(\"apps_deployed_before_teardown_localcloud\", applicationsList.toString());\n\t\t}\n\t\tString uninstallMessage = ShellUtils.getMessageBundle().getString(\"uninstalling_applications_before_teardown\");\n\t\tpublishEvent(uninstallMessage);\n\t\tfor (final String appName : applicationsList) {\n\t\t\ttry {\n\t\t\t\tif (!appName.equals(MANAGEMENT_APPLICATION)) {\n\t\t\t\t\tlogger.fine(\"Uninstalling application \" + appName);\n\t\t\t\t\tMap<String, String> uninstallApplicationResponse = adminFacade.uninstallApplication(appName\n\t\t\t\t\t\t\t, (int) timeout);\n\t\t\t\t\tif (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\t\t\t\tString pollingID = uninstallApplicationResponse\n\t\t\t\t\t\t.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\t\t\t\t((RestAdminFacade) this.adminFacade)\n\t\t\t\t\t\t.waitForLifecycleEvents(pollingID, (int) timeout, TIMEOUT_ERROR_MESSAGE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpublishEvent(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t\t\t\t+ \"Check logs for more details.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (final CLIException e) {\n\t\t\t\tfinal String errorMessage = \"Application \" + appName + \" faild to uninstall.\"\n\t\t\t\t\t\t+ \" Continuing teardown-localcloud.\";\n\t\t\t\tif (!force) {\n\t\t\t\t\tthrow new CLIStatusException(e, \"failed_to_uninstall_app_before_teardown\", appName);\n\t\t\t\t}\n\t\t\t\tif (verbose) {\n\t\t\t\t\tlogger.log(Level.FINE, errorMessage, e);\n\t\t\t\t\tpublishEvent(errorMessage);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.log(Level.FINE, errorMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (applicationsExist) {\n\t\t\twaitForUninstallApplications(timeout, timeunit);\n\t\t\tpublishEvent(ShellUtils.getMessageBundle().getString(\"all_apps_removed_before_teardown\"));\n\t\t\tlogger.fine(ShellUtils.getMessageBundle().getString(\"all_apps_removed_before_teardown\"));\n\t\t}\n\t}","id":102168,"modified_method":"private void uninstallApplications(final long timeout, final TimeUnit timeunit) throws InterruptedException,\n\t\t\tTimeoutException, CLIException {\n\n\t\tList<String> applicationsList = null;\n\t\tboolean applicationsExist = false;\n\t\ttry {\n\t\t\tif (!adminFacade.isConnected()) {\n\t\t\t\tthrow new CLIException(\"Failed to fetch applications list. \"\n\t\t\t\t\t\t+ \"Client is not connected to the rest server.\");\n\t\t\t}\n\n\t\t\tapplicationsList = adminFacade.getApplicationsList();\n\t\t\t// If there existed other applications besides the management.\n\t\t\tapplicationsExist = applicationsList.size() > 1;\n\t\t} catch (final CLIException e) {\n\t\t\tif (!force) {\n\t\t\t\tthrow new CLIStatusException(e, \"failed_to_access_rest_before_teardown\");\n\t\t\t}\n\t\t\tfinal String errorMessage = \"Failed to fetch the currently deployed applications list.\"\n\t\t\t\t\t+ \" Continuing teardown-localcloud.\";\n\t\t\tif (verbose) {\n\t\t\t\tlogger.log(Level.FINE, errorMessage, e);\n\t\t\t\tpublishEvent(errorMessage + System.getProperty(\"line.separator\") + e.toString());\n\t\t\t} else {\n\t\t\t\tlogger.log(Level.FINE, errorMessage);\n\t\t\t\tpublishEvent(errorMessage);\n\t\t\t}\n\t\t\t// Suppress exception. continue with teardown.\n\t\t\treturn;\n\t\t}\n\n\t\tif (applicationsExist && !force) {\n\t\t\tthrow new CLIStatusException(\"apps_deployed_before_teardown_localcloud\", applicationsList.toString());\n\t\t}\n\t\tString uninstallMessage = ShellUtils.getMessageBundle().getString(\"uninstalling_applications_before_teardown\");\n\t\tpublishEvent(uninstallMessage);\n\t\tfor (final String appName : applicationsList) {\n\t\t\ttry {\n\t\t\t\tif (!appName.equals(MANAGEMENT_APPLICATION)) {\n\t\t\t\t\tlogger.fine(\"Uninstalling application \" + appName);\n\t\t\t\t\tMap<String, String> uninstallApplicationResponse = adminFacade.uninstallApplication(appName\n\t\t\t\t\t\t\t, (int) timeout);\n\t\t\t\t\tif (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\t\t\t\tString pollingID = uninstallApplicationResponse\n\t\t\t\t\t\t.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\t\t\t\t((RestAdminFacade) this.adminFacade)\n\t\t\t\t\t\t.waitForLifecycleEvents(pollingID, (int) timeout);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpublishEvent(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t\t\t\t+ \"Check logs for more details.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (final CLIException e) {\n\t\t\t\tfinal String errorMessage = \"Application \" + appName + \" faild to uninstall.\"\n\t\t\t\t\t\t+ \" Continuing teardown-localcloud.\";\n\t\t\t\tif (!force) {\n\t\t\t\t\tthrow new CLIStatusException(e, \"failed_to_uninstall_app_before_teardown\", appName);\n\t\t\t\t}\n\t\t\t\tif (verbose) {\n\t\t\t\t\tlogger.log(Level.FINE, errorMessage, e);\n\t\t\t\t\tpublishEvent(errorMessage);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.log(Level.FINE, errorMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (applicationsExist) {\n\t\t\twaitForUninstallApplications(timeout, timeunit);\n\t\t\tpublishEvent(ShellUtils.getMessageBundle().getString(\"all_apps_removed_before_teardown\"));\n\t\t\tlogger.fine(ShellUtils.getMessageBundle().getString(\"all_apps_removed_before_teardown\"));\n\t\t}\n\t}","commit_id":"f8d1f7ed99e6d147164d446258afb9852c6aa01e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void waitForLifecycleEvents(final String pollingID, int timeout, String timeoutMessage) \n\t\t\tthrows CLIException, InterruptedException, TimeoutException {\n\t\t\n\t\tRestLifecycleEventsLatch restLifecycleEventsLatch = new RestLifecycleEventsLatch();\n\t\trestLifecycleEventsLatch.setTimeoutMessage(timeoutMessage);\n\t\trestLifecycleEventsLatch.waitForLifecycleEvents(pollingID, client, timeout);\n\t}","id":102169,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic boolean waitForLifecycleEvents(final String pollingID, final int timeout) \n\t\t\tthrows CLIException, InterruptedException, TimeoutException {\n\t\tRestLifecycleEventsLatch restLifecycleEventsLatch = new RestLifecycleEventsLatch();\n\t\trestLifecycleEventsLatch.setPollingId(pollingID);\n\t\trestLifecycleEventsLatch.setRestClient(client);\n\t\treturn restLifecycleEventsLatch.waitForLifecycleEvents(timeout, TimeUnit.MINUTES);\n\t}","commit_id":"f8d1f7ed99e6d147164d446258afb9852c6aa01e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Waits for lifecycle events. This method will poll the rest for installation lifecycle events \r\n\t * and print the new events to the CLI console.\r\n\t * \r\n\t * @param serviceLifecycleEventContainerID The polling ID.\r\n\t * @param client The rest client.\r\n\t * @param timeoutInMinutes Timeout for task. \r\n\t * @throws InterruptedException\r\n\t * @throws TimeoutException\r\n\t * @throws CLIException\r\n\t */\r\n\tpublic void waitForLifecycleEvents(final String serviceLifecycleEventContainerID,\r\n\t\t\tfinal GSRestClient client, final int timeoutInMinutes) \r\n\t\t\tthrows InterruptedException, TimeoutException, CLIException {\r\n\t\tcreateConditionLatch(timeoutInMinutes, TimeUnit.MINUTES).waitFor(new Predicate() {\r\n\r\n\t\t\tprivate int cursor = 0;\r\n\t\t\tprivate boolean isDone = false;\r\n\t\t\tprivate boolean timedOutOnServer = false;\r\n\t\t\tprivate boolean exceptionOnServer = false;\r\n\t\t\tprivate String url;\r\n\t\t\tprivate Map<String, Object> lifecycleEventLogs = null;\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean isDone() throws CLIException, InterruptedException {\r\n\t\t\t\turl = \"/service/lifecycleEventContainerID/\" + serviceLifecycleEventContainerID\r\n\t\t\t\t+ \"/cursor/\" + cursor;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlifecycleEventLogs = (Map<String, Object>) client.get(url);\r\n\t\t\t\t} catch (final ErrorStatusException e) {\r\n\t\t\t\t\tthrow new CLIStatusException(e, e.getReasonCode(), e.getArgs());\r\n\t\t\t\t} \r\n\r\n\t\t\t\tList<String> events = (List<String>) lifecycleEventLogs.get(CloudifyConstants.LIFECYCLE_LOGS);\r\n\t\t\t\tcursor = (Integer) lifecycleEventLogs.get(CloudifyConstants.CURSOR_POS);\r\n\t\t\t\tisDone = (Boolean) lifecycleEventLogs.get(CloudifyConstants.IS_TASK_DONE);\r\n\t\t\t\ttimedOutOnServer = (Boolean) lifecycleEventLogs.get(CloudifyConstants.POLLING_TIMEOUT_EXCEPTION);\r\n\t\t\t\texceptionOnServer = (Boolean) lifecycleEventLogs.get(CloudifyConstants.POLLING_EXCEPTION);\r\n\t\t\t\t\r\n\r\n\t\t\t\tif (events == null) {\r\n\t\t\t\t\tdisplayer.printNoChange();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdisplayer.printEvents(events);\r\n\t\t\t \t}\r\n\t\t\t\t\r\n\t\t\t\tif (isDone) {\r\n\t\t\t\t\tif (timedOutOnServer) { \r\n\t\t\t\t           return false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (exceptionOnServer) {\r\n\t\t\t\t\t\t\tthrow new CLIException(\"Event polling failed on remote server.\" \r\n\t\t\t\t\t\t\t\t\t+ \"For more information regarding the installation, please refer to full logs\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdisplayer.eraseCurrentLine();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn isDone;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t});\r\n\t}","id":102170,"modified_method":"/**\r\n\t * Waits for lifecycle events. This method will poll the rest for installation lifecycle events \r\n\t * and print the new events to the CLI console.\r\n\t * \r\n\t * @param timeout\r\n\t * @param timeUnit\r\n\t * @return\r\n\t * @throws InterruptedException\r\n\t * @throws TimeoutException\r\n\t * @throws CLIException\r\n\t */\r\n\tpublic boolean waitForLifecycleEvents(final int timeout, TimeUnit timeUnit) \r\n\t\t\tthrows InterruptedException, TimeoutException, CLIException {\r\n\r\n\t\tthis.endTime = System.currentTimeMillis() + timeUnit.toMillis(timeout);\r\n\t\t\r\n\t\twhile (System.currentTimeMillis() < this.endTime) {\r\n\t\t\turl = \"/service/lifecycleEventContainerID/\" + pollingID\r\n\t\t\t\t\t+ \"/cursor/\" + cursor;\r\n\t\t\ttry {\r\n\t\t\t\tlifecycleEventLogs = (Map<String, Object>) client.get(url);\r\n\t\t\t} catch (final ErrorStatusException e) {\r\n\t\t\t\tthrow new CLIStatusException(e, e.getReasonCode(), e.getArgs());\r\n\t\t\t}\r\n\r\n\t\t\tList<String> events = (List<String>) lifecycleEventLogs.get(CloudifyConstants.LIFECYCLE_LOGS);\r\n\t\t\tthis.cursor = (Integer) lifecycleEventLogs.get(CloudifyConstants.CURSOR_POS);\r\n\t\t\tthis.isDone = (Boolean) lifecycleEventLogs.get(CloudifyConstants.IS_TASK_DONE);\r\n\t\t\tthis.exceptionOnServer = (Boolean) lifecycleEventLogs.get(CloudifyConstants.POLLING_EXCEPTION);\r\n\t\t\tthis.remoteTaskLeaseExpiration = Long.valueOf((String) lifecycleEventLogs.\r\n\t\t\t\t\tget(CloudifyConstants.SERVER_POLLING_TASK_EXPIRATION_MILLI)) + System.currentTimeMillis();\r\n\r\n\t\t\tif (events == null) {\r\n\t\t\t\tdisplayer.printNoChange();\r\n\t\t\t} else {\r\n\t\t\t\tdisplayer.printEvents(events);\r\n\t\t\t}\r\n\r\n\t\t\tif (isDone) {\r\n\t\t\t\tif (exceptionOnServer) {\r\n\t\t\t\t\tthrow new CLIException(\"Event polling task failed on remote server.\" \r\n\t\t\t\t\t\t\t+ \"For more information regarding the installation, please refer to full logs\");\r\n\t\t\t\t}\r\n\t\t\t\tdisplayer.eraseCurrentLine();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tThread.sleep(pollingInterval);\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"f8d1f7ed99e6d147164d446258afb9852c6aa01e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Sets the polling interval.\r\n\t * \r\n\t * @param pollingIntervalInMillis Polling interval in milliseconds.\r\n\t */\r\n\tpublic void setPollingInterval(final long pollingIntervalInMillis) {\r\n\r\n\t\tif (!(pollingIntervalInMillis < MIN_POLLING_INTERVAL)) {\r\n\t\t\tthis.pollingInterval = pollingIntervalInMillis;\r\n\t\t} else {\r\n\t\t\tlogger.log(Level.INFO, \r\n\t\t\t\t\t\"Polling interveal was set to the minimum polling\" +\r\n\t\t\t\t\t\t\t\" interval allowed: \" + MIN_POLLING_INTERVAL + \"seconds\");\r\n\t\t}\r\n\t}","id":102171,"modified_method":"/**\r\n\t * Sets the polling interval.\r\n\t * \r\n\t * @param pollingIntervalInMillis Polling interval in milliseconds.\r\n\t */\r\n\tpublic void setPollingInterval(final long pollingInterval, TimeUnit timeUnit) {\r\n\t\tlong pollingIntervalInMillis = timeUnit.toMillis(pollingInterval);\r\n\t\tif (!(pollingIntervalInMillis < MIN_POLLING_INTERVAL)) {\r\n\t\t\tthis.pollingInterval = pollingIntervalInMillis;\r\n\t\t} else {\r\n\t\t\tlogger.log(Level.INFO, \r\n\t\t\t\t\t\"Polling interveal was set to the minimum polling\" +\r\n\t\t\t\t\t\t\t\" interval allowed: \" + MIN_POLLING_INTERVAL + \"seconds\");\r\n\t\t}\r\n\t}","commit_id":"f8d1f7ed99e6d147164d446258afb9852c6aa01e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tprotected Object doExecute() throws Exception {\n\t\tString applicationName = this.getCurrentApplicationName();\n\t\tif (applicationName == null) {\n\t\t\tapplicationName = CloudifyConstants.DEFAULT_APPLICATION_NAME;\n\t\t}\n\n\t\tfinal int initialNumberOfInstances = adminFacade.getInstanceList(applicationName, serviceName).size();\n\t\tif (initialNumberOfInstances == count) {\n\t\t\treturn getFormattedMessage(\"num_instanes_already_met\", count);\n\t\t}\n\n\t\tMap<String, String> response = adminFacade.setInstances(applicationName, serviceName, count, timeout);\n\n\t\tif (response.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString pollingID = response.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tthis.adminFacade.waitForLifecycleEvents(pollingID, timeout, TIMEOUT_ERROR_MESSAGE);\n\t\t} else {\n\t\t\tlogger.info(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\t\t\n\t\treturn getFormattedMessage(\"set_instances_completed_successfully\", serviceName, count);\n\t}","id":102172,"modified_method":"@Override\n\tprotected Object doExecute() throws Exception {\n\t\tString applicationName = this.getCurrentApplicationName();\n\t\tif (applicationName == null) {\n\t\t\tapplicationName = CloudifyConstants.DEFAULT_APPLICATION_NAME;\n\t\t}\n\n\t\tfinal int initialNumberOfInstances = adminFacade.getInstanceList(applicationName, serviceName).size();\n\t\tif (initialNumberOfInstances == count) {\n\t\t\treturn getFormattedMessage(\"num_instanes_already_met\", count);\n\t\t}\n\n\t\tMap<String, String> response = adminFacade.setInstances(applicationName, serviceName, count, timeout);\n\n\t\tif (response.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString pollingID = response.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tboolean waitForLifecycleEvents = this.adminFacade.waitForLifecycleEvents(pollingID, timeout);\n\t\t\tif (!waitForLifecycleEvents) {\n\t\t\t\tthrow new TimeoutException(TIMEOUT_ERROR_MESSAGE);\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.info(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\t\t\n\t\treturn getFormattedMessage(\"set_instances_completed_successfully\", serviceName, count);\n\t}","commit_id":"f8d1f7ed99e6d147164d446258afb9852c6aa01e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\r\n\t\tif (!askUninstallConfirmationQuestion()) {\r\n\t\t\treturn getFormattedMessage(\"uninstall_aborted\");\r\n\t\t}\r\n\r\n\t\t// we need to look at all containers since the application already undeployed and we cannot get only\r\n\t\t// the application containers\r\n\t\tfinal Set<String> containerIdsOfApplication = ((RestAdminFacade) adminFacade)\r\n\t\t.getGridServiceContainerUidsForApplication(applicationName);\r\n\t\tif (verbose) {\r\n\t\t\tlogger.info(\"Containers running PUs of application \" + applicationName + \":\" + containerIdsOfApplication);\r\n\t\t}\r\n\r\n\t\tMap<String, String> uninstallApplicationResponse = this.adminFacade\n\t\t.uninstallApplication(this.applicationName, timeoutInMinutes);\n\n\t\tif (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString pollingID = uninstallApplicationResponse.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tthis.adminFacade.waitForLifecycleEvents(pollingID, timeoutInMinutes, TIMEOUT_ERROR_MESSAGE);\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\r\n\t\tsession.put(Constants.ACTIVE_APP, \"default\");\r\n\t\tGigaShellMain.getInstance().setCurrentApplicationName(\"default\");\r\n\t\treturn getFormattedMessage(\"application_uninstalled_succesfully\", this.applicationName);\r\n\t}","id":102173,"modified_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\r\n\t\tif (!askUninstallConfirmationQuestion()) {\r\n\t\t\treturn getFormattedMessage(\"uninstall_aborted\");\r\n\t\t}\r\n\r\n\t\t// we need to look at all containers since the application already undeployed and we cannot get only\r\n\t\t// the application containers\r\n\t\tfinal Set<String> containerIdsOfApplication = ((RestAdminFacade) adminFacade)\r\n\t\t.getGridServiceContainerUidsForApplication(applicationName);\r\n\t\tif (verbose) {\r\n\t\t\tlogger.info(\"Containers running PUs of application \" + applicationName + \":\" + containerIdsOfApplication);\r\n\t\t}\r\n\r\n\t\tMap<String, String> uninstallApplicationResponse = this.adminFacade\n\t\t.uninstallApplication(this.applicationName, timeoutInMinutes);\n\n\t\tif (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString pollingID = uninstallApplicationResponse.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tboolean waitForLifecycleEvents = this.adminFacade.waitForLifecycleEvents(pollingID, timeoutInMinutes);\n\t\t\tif (!waitForLifecycleEvents) {\n\t\t\t\tthrow new TimeoutException(TIMEOUT_ERROR_MESSAGE);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\r\n\t\tsession.put(Constants.ACTIVE_APP, \"default\");\r\n\t\tGigaShellMain.getInstance().setCurrentApplicationName(\"default\");\r\n\t\treturn getFormattedMessage(\"application_uninstalled_succesfully\", this.applicationName);\r\n\t}","commit_id":"f8d1f7ed99e6d147164d446258afb9852c6aa01e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Asks the user for confirmation to uninstall the application.\r\n\t * \r\n\t * @return true if the user confirmed, false otherwise\r\n\t * @throws IOException\r\n\t *             Reporting a failure to get the user's confirmation\r\n\t */\r\n\tprivate boolean askUninstallConfirmationQuestion() throws IOException {\r\n\r\n\t\t// we skip question if the shell is running a script.\r\n\t\tif ((Boolean) session.get(Constants.INTERACTIVE_MODE)) {\r\n\t\t\tfinal String confirmationQuestion = getFormattedMessage(\"application_uninstall_confirmation\",\r\n\t\t\t\t\tapplicationName);\r\n\t\t\tSystem.out.print(confirmationQuestion);\r\n\t\t\tSystem.out.flush();\r\n\t\t\tfinal PropertiesReader pr = new PropertiesReader(new InputStreamReader(System.in));\r\n\t\t\tfinal String readLine = pr.readProperty();\r\n\t\t\tSystem.out.println();\r\n\t\t\tSystem.out.flush();\r\n\t\t\treturn \"y\".equalsIgnoreCase(readLine);\r\n\t\t}\r\n\t\t// Shell is running in nonInteractive mode. we skip the question.\r\n\t\treturn true;\r\n\t}","id":102174,"modified_method":"/**\r\n\t * Asks the user for confirmation to uninstall the application.\r\n\t * \r\n\t * @return true if the user confirmed, false otherwise\r\n\t * @throws IOException\r\n\t *             Reporting a failure to get the user's confirmation\r\n\t */\r\n\tprivate boolean askUninstallConfirmationQuestion() throws IOException {\r\n\r\n\t\t// we skip question if the shell is running a script.\r\n\t\tif ((Boolean) session.get(Constants.INTERACTIVE_MODE)) {\r\n\t\t\tfinal String confirmationQuestion = getFormattedMessage(\"application_uninstall_confirmation\",\r\n\t\t\t\t\tapplicationName);\r\n\t\t\tSystem.out.print(confirmationQuestion);\r\n\t\t\tSystem.out.flush();\r\n\t\t\tfinal PropertiesReader pr = new PropertiesReader(new InputStreamReader(System.in));\n\t\t\tString readLine = \"\";\n\t\t\twhile (!readLine.equalsIgnoreCase(\"y\") && !readLine.equalsIgnoreCase(\"n\")) {\n\t\t\t\treadLine = pr.readProperty();\n\t\t\t}\r\n\t\t\tSystem.out.println();\r\n\t\t\tSystem.out.flush();\r\n\t\t\treturn \"y\".equalsIgnoreCase(readLine);\r\n\t\t}\r\n\t\t// Shell is running in nonInteractive mode. we skip the question.\r\n\t\treturn true;\r\n\t}","commit_id":"f8d1f7ed99e6d147164d446258afb9852c6aa01e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * Asks the user for confirmation to uninstall the service.\n\t * \n\t * @return true if the user confirmed, false otherwise\n\t * @throws IOException\n\t *             Reporting a failure to get the user's confirmation\n\t */\n\t// returns true if the answer to the question was 'Yes'.\n\tprivate boolean askUninstallConfirmationQuestion() throws IOException {\n\n\t\t// we skip question if the shell is running a script.\n\t\tif ((Boolean) session.get(Constants.INTERACTIVE_MODE)) {\n\t\t\tfinal String confirmationQuestion = getFormattedMessage(\"service_uninstall_confirmation\", serviceName);\n\t\t\tSystem.out.print(confirmationQuestion);\n\t\t\tSystem.out.flush();\n\t\t\tfinal PropertiesReader pr = new PropertiesReader(new InputStreamReader(System.in));\n\t\t\tfinal String answer = pr.readProperty();\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.flush();\n\t\t\treturn \"y\".equalsIgnoreCase(answer);\n\n\t\t}\n\t\t// Shell is running in nonInteractive mode. we skip the question.\n\t\treturn true;\n\t}","id":102175,"modified_method":"/**\n\t * Asks the user for confirmation to uninstall the service.\n\t * \n\t * @return true if the user confirmed, false otherwise\n\t * @throws IOException\n\t *             Reporting a failure to get the user's confirmation\n\t */\n\t// returns true if the answer to the question was 'Yes'.\n\tprivate boolean askUninstallConfirmationQuestion() throws IOException {\n\n\t\t// we skip question if the shell is running a script.\n\t\tif ((Boolean) session.get(Constants.INTERACTIVE_MODE)) {\n\t\t\tfinal String confirmationQuestion = getFormattedMessage(\"service_uninstall_confirmation\", serviceName);\n\t\t\tSystem.out.print(confirmationQuestion);\n\t\t\tSystem.out.flush();\n\t\t\tfinal PropertiesReader pr = new PropertiesReader(new InputStreamReader(System.in));\n\t\t\tString answer = \"\";\n\t\t\twhile (!answer.equalsIgnoreCase(\"y\") && !answer.equalsIgnoreCase(\"n\")) {\n\t\t\t\tanswer = pr.readProperty();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.flush();\n\t\t\treturn \"y\".equalsIgnoreCase(answer);\n\n\t\t}\n\t\t// Shell is running in nonInteractive mode. we skip the question.\n\t\treturn true;\n\t}","commit_id":"f8d1f7ed99e6d147164d446258afb9852c6aa01e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected Object doExecute() throws Exception {\n\n\t\tif (!askUninstallConfirmationQuestion()) {\n\t\t\treturn getFormattedMessage(\"uninstall_aborted\");\n\t\t}\n\n\t\tfinal Set<String> containerIdsOfService = ((RestAdminFacade) adminFacade)\n\t\t.getGridServiceContainerUidsForService(getCurrentApplicationName(), serviceName);\n\t\tif (verbose) {\n\t\t\tlogger.info(\"Found containers: \" + containerIdsOfService);\n\t\t}\n\n\t\tMap<String, String> undeployServiceResponse = adminFacade.undeploy(getCurrentApplicationName(), serviceName, timeoutInMinutes);\n\t\tif (undeployServiceResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)){\n\t\t\tString pollingID = undeployServiceResponse.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tthis.adminFacade.waitForLifecycleEvents(pollingID, timeoutInMinutes, TIMEOUT_ERROR_MESSAGE);\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" +\n\t\t\t\"Check logs for more details.\");\n\t\t}\n\t\treturn getFormattedMessage(\"undeployed_successfully\", serviceName);\n\t}","id":102176,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected Object doExecute() throws Exception {\n\n\t\tif (!askUninstallConfirmationQuestion()) {\n\t\t\treturn getFormattedMessage(\"uninstall_aborted\");\n\t\t}\n\n\t\tfinal Set<String> containerIdsOfService = ((RestAdminFacade) adminFacade)\n\t\t.getGridServiceContainerUidsForService(getCurrentApplicationName(), serviceName);\n\t\tif (verbose) {\n\t\t\tlogger.info(\"Found containers: \" + containerIdsOfService);\n\t\t}\n\n\t\tMap<String, String> undeployServiceResponse = adminFacade.undeploy(getCurrentApplicationName(), serviceName, timeoutInMinutes);\n\t\tif (undeployServiceResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)){\n\t\t\tString pollingID = undeployServiceResponse.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tboolean waitForLifecycleEvents = this.adminFacade.waitForLifecycleEvents(pollingID, timeoutInMinutes);\n\t\t\tif (!waitForLifecycleEvents) {\n\t\t\t\tthrow new TimeoutException(TIMEOUT_ERROR_MESSAGE);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" +\n\t\t\t\t\t\"Check logs for more details.\");\n\t\t}\n\t\treturn getFormattedMessage(\"undeployed_successfully\", serviceName);\n\t}","commit_id":"f8d1f7ed99e6d147164d446258afb9852c6aa01e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tprotected Object doExecute() throws Exception {\n\t\tString applicationName = this.getCurrentApplicationName();\n\t\tif (applicationName == null) {\n\t\t\tapplicationName = CloudifyConstants.DEFAULT_APPLICATION_NAME;\n\t\t}\n\n\t\tfinal int initialNumberOfInstances = adminFacade.getInstanceList(applicationName, serviceName).size();\n\t\tif (initialNumberOfInstances == count) {\n\t\t\treturn getFormattedMessage(\"num_instanes_already_met\", count);\n\t\t}\n\n\t\tMap<String, String> response = adminFacade.setInstances(applicationName, serviceName, count, timeout);\n\n\t\tString pollingID = response.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\tthis.adminFacade.waitForLifecycleEvents(pollingID, timeout, TIMEOUT_ERROR_MESSAGE);\n\t\t\n\t\treturn getFormattedMessage(\"set_instances_completed_successfully\", Color.GREEN, serviceName, count);\n\t}","id":102177,"modified_method":"@Override\n\tprotected Object doExecute() throws Exception {\n\t\tString applicationName = this.getCurrentApplicationName();\n\t\tif (applicationName == null) {\n\t\t\tapplicationName = CloudifyConstants.DEFAULT_APPLICATION_NAME;\n\t\t}\n\n\t\tfinal int initialNumberOfInstances = adminFacade.getInstanceList(applicationName, serviceName).size();\n\t\tif (initialNumberOfInstances == count) {\n\t\t\treturn getFormattedMessage(\"num_instanes_already_met\", count);\n\t\t}\n\n\t\tMap<String, String> response = adminFacade.setInstances(applicationName, serviceName, count, timeout);\n\n\t\tString pollingID = response.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\tRestLifecycleEventsLatch lifecycleEventsPollingLatch = \n\t\t\t\tthis.adminFacade.getLifecycleEventsPollingLatch(pollingID, TIMEOUT_ERROR_MESSAGE);\n\t\tboolean isDone = false;\n\t\tboolean continuous = false;\n\t\twhile (!isDone) {\n\t\t\ttry {\n\t\t\t\tif (!continuous) {\n\t\t\t\t\tlifecycleEventsPollingLatch.waitForLifecycleEvents(timeout, TimeUnit.MINUTES);\n\t\t\t\t} else {\n\t\t\t\t\tlifecycleEventsPollingLatch.continueWaitForLifecycleEvents(timeout, TimeUnit.MINUTES);\n\t\t\t\t}\n\t\t\t\tisDone = true;\n\t\t\t} catch (TimeoutException e) {\n\t\t\t\tif (!(Boolean) session.get(Constants.INTERACTIVE_MODE)) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tboolean continueInstallation = promptWouldYouLikeToContinueQuestion();\n\t\t\t\tif (!continueInstallation) {\n\t\t\t\t\tthrow new CLIStatusException(e, \"application_installation_timed_out_on_client\", \n\t\t\t\t\t\t\tapplicationName);\n\t\t\t\t} else {\n\t\t\t\t\tcontinuous = continueInstallation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn getFormattedMessage(\"set_instances_completed_successfully\", Color.GREEN, serviceName, count);\n\t}","commit_id":"f8ad93f84d05de7c89c7085c00520cb5fed9c30c","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public EntryListenerConfigReadOnly(EntryListenerConfig config) {\n        this.setImplementation(config.getImplementation());\n        this.setIncludeValue(config.isIncludeValue());\n        this.setLocal(config.isLocal());\n        this.setClassName(config.getClassName());\n    }","id":102178,"modified_method":"public EntryListenerConfigReadOnly(EntryListenerConfig config) {\n        super.setImplementation(config.getImplementation());\n        super.setIncludeValue(config.isIncludeValue());\n        super.setLocal(config.isLocal());\n        super.setClassName(config.getClassName());\n    }","commit_id":"84246f49703f3116868e9487a5ac00a24737f7d3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public MapStoreConfig getMapStoreConfig() {\n        return super.getMapStoreConfig().getAsReadOnly();\n    }","id":102179,"modified_method":"public MapStoreConfig getMapStoreConfig() {\n        final MapStoreConfig mapStoreConfig = super.getMapStoreConfig();\n        if (mapStoreConfig == null) {\n            return null;\n        }\n        return mapStoreConfig.getAsReadOnly();\n    }","commit_id":"84246f49703f3116868e9487a5ac00a24737f7d3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public PartitioningStrategyConfig getPartitioningStrategyConfig() {\n        return super.getPartitioningStrategyConfig().getAsReadOnly();\n    }","id":102180,"modified_method":"public PartitioningStrategyConfig getPartitioningStrategyConfig() {\n        final PartitioningStrategyConfig partitioningStrategyConfig = super.getPartitioningStrategyConfig();\n        if (partitioningStrategyConfig == null){\n            return null;\n        }\n        return partitioningStrategyConfig.getAsReadOnly();\n    }","commit_id":"84246f49703f3116868e9487a5ac00a24737f7d3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public MaxSizeConfig getMaxSizeConfig() {\n        return super.getMaxSizeConfig().getAsReadOnly();\n    }","id":102181,"modified_method":"public MaxSizeConfig getMaxSizeConfig() {\n        final MaxSizeConfig maxSizeConfig = super.getMaxSizeConfig();\n        if (maxSizeConfig == null){\n            return null;\n        }\n        return maxSizeConfig.getAsReadOnly();\n    }","commit_id":"84246f49703f3116868e9487a5ac00a24737f7d3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public WanReplicationRef getWanReplicationRef() {\n        return super.getWanReplicationRef().getAsReadOnly();\n    }","id":102182,"modified_method":"public WanReplicationRef getWanReplicationRef() {\n        final WanReplicationRef wanReplicationRef = super.getWanReplicationRef();\n        if (wanReplicationRef == null){\n            return null;\n        }\n        return wanReplicationRef.getAsReadOnly();\n    }","commit_id":"84246f49703f3116868e9487a5ac00a24737f7d3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public NearCacheConfig getNearCacheConfig() {\n        return super.getNearCacheConfig().getAsReadOnly();\n    }","id":102183,"modified_method":"public NearCacheConfig getNearCacheConfig() {\n        final NearCacheConfig nearCacheConfig = super.getNearCacheConfig();\n        if (nearCacheConfig == null) {\n            return null;\n        }\n        return nearCacheConfig.getAsReadOnly();\n    }","commit_id":"84246f49703f3116868e9487a5ac00a24737f7d3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public MapIndexConfigReadOnly(MapIndexConfig config) {\n        this.setAttribute(config.getAttribute());\n        this.setOrdered(config.isOrdered());\n    }","id":102184,"modified_method":"public MapIndexConfigReadOnly(MapIndexConfig config) {\n        super.setAttribute(config.getAttribute());\n        super.setOrdered(config.isOrdered());\n    }","commit_id":"84246f49703f3116868e9487a5ac00a24737f7d3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public MapStoreConfigReadOnly(MapStoreConfig config) {\n        this.setClassName(config.getClassName());\n        this.setImplementation(config.getImplementation());\n        this.setProperties(config.getProperties());\n        this.setEnabled(config.isEnabled());\n        this.setFactoryClassName(config.getFactoryClassName());\n        this.setFactoryImplementation(config.getFactoryImplementation());\n        this.setWriteDelaySeconds(config.getWriteDelaySeconds());\n    }","id":102185,"modified_method":"public MapStoreConfigReadOnly(MapStoreConfig config) {\n        super.setClassName(config.getClassName());\n        super.setImplementation(config.getImplementation());\n        super.setProperties(config.getProperties());\n        super.setEnabled(config.isEnabled());\n        super.setFactoryClassName(config.getFactoryClassName());\n        super.setFactoryImplementation(config.getFactoryImplementation());\n        super.setWriteDelaySeconds(config.getWriteDelaySeconds());\n    }","commit_id":"84246f49703f3116868e9487a5ac00a24737f7d3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public MaxSizeConfigReadOnly(MaxSizeConfig config) {\n        this.setSize(config.getSize());\n        this.setMaxSizePolicy(config.getMaxSizePolicy());\n    }","id":102186,"modified_method":"public MaxSizeConfigReadOnly(MaxSizeConfig config) {\n        super(config);\n    }","commit_id":"84246f49703f3116868e9487a5ac00a24737f7d3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public NearCacheConfigReadOnly(NearCacheConfig config) {\n        this.setName(config.getName());\n        this.setEvictionPolicy(config.getEvictionPolicy());\n        this.setInMemoryFormat(config.getInMemoryFormat());\n        this.setInvalidateOnChange(config.isInvalidateOnChange());\n        this.setMaxIdleSeconds(config.getMaxIdleSeconds());\n        this.setMaxSize(config.getMaxSize());\n        this.setTimeToLiveSeconds(config.getTimeToLiveSeconds());\n    }","id":102187,"modified_method":"public NearCacheConfigReadOnly(NearCacheConfig config) {\n        super.setName(config.getName());\n        super.setEvictionPolicy(config.getEvictionPolicy());\n        super.setInMemoryFormat(config.getInMemoryFormat());\n        super.setInvalidateOnChange(config.isInvalidateOnChange());\n        super.setMaxIdleSeconds(config.getMaxIdleSeconds());\n        super.setMaxSize(config.getMaxSize());\n        super.setTimeToLiveSeconds(config.getTimeToLiveSeconds());\n    }","commit_id":"84246f49703f3116868e9487a5ac00a24737f7d3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public PartitioningStrategyConfigReadOnly(PartitioningStrategyConfig config) {\n        this.setPartitioningStrategyClass(config.getPartitioningStrategyClass());\n        this.setPartitionStrategy(config.getPartitioningStrategy());\n    }","id":102188,"modified_method":"public PartitioningStrategyConfigReadOnly(PartitioningStrategyConfig config) {\n        super.setPartitioningStrategyClass(config.getPartitioningStrategyClass());\n        super.setPartitionStrategy(config.getPartitioningStrategy());\n    }","commit_id":"84246f49703f3116868e9487a5ac00a24737f7d3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean equals(final Object o) {\n        final AbstractCacheConfig that = (CacheConfig) o;\n        if (isManagementEnabled != that.isManagementEnabled) {\n            return false;\n        }\n        if (isReadThrough != that.isReadThrough) {\n            return false;\n        }\n        if (isStatisticsEnabled != that.isStatisticsEnabled) {\n            return false;\n        }\n        if (isStoreByValue != that.isStoreByValue) {\n            return false;\n        }\n        if (isWriteThrough != that.isWriteThrough) {\n            return false;\n        }\n        if (cacheLoaderFactory != null ? !cacheLoaderFactory.equals(that.cacheLoaderFactory) : that.cacheLoaderFactory != null) {\n            return false;\n        }\n        if (cacheWriterFactory != null ? !cacheWriterFactory.equals(that.cacheWriterFactory) : that.cacheWriterFactory != null) {\n            return false;\n        }\n        if (expiryPolicyFactory != null\n                ? !expiryPolicyFactory.equals(that.expiryPolicyFactory) : that.expiryPolicyFactory != null) {\n            return false;\n        }\n        if (!keyType.equals(that.keyType)) {\n            return false;\n        }\n        if (!listenerConfigurations.equals(that.listenerConfigurations)) {\n            return false;\n        }\n        if (!valueType.equals(that.valueType)) {\n            return false;\n        }\n\n        return true;\n    }","id":102189,"modified_method":"@Override\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        AbstractCacheConfig that = (AbstractCacheConfig) o;\n\n        if (isManagementEnabled != that.isManagementEnabled) {\n            return false;\n        }\n        if (isReadThrough != that.isReadThrough) {\n            return false;\n        }\n        if (isStatisticsEnabled != that.isStatisticsEnabled) {\n            return false;\n        }\n        if (isStoreByValue != that.isStoreByValue) {\n            return false;\n        }\n        if (isWriteThrough != that.isWriteThrough) {\n            return false;\n        }\n        if (cacheLoaderFactory != null ? !cacheLoaderFactory.equals(that.cacheLoaderFactory) : that.cacheLoaderFactory != null) {\n            return false;\n        }\n        if (cacheWriterFactory != null ? !cacheWriterFactory.equals(that.cacheWriterFactory) : that.cacheWriterFactory != null) {\n            return false;\n        }\n        if (expiryPolicyFactory != null\n                ? !expiryPolicyFactory.equals(that.expiryPolicyFactory) : that.expiryPolicyFactory != null) {\n            return false;\n        }\n        if (!keyType.equals(that.keyType)) {\n            return false;\n        }\n        if (!listenerConfigurations.equals(that.listenerConfigurations)) {\n            return false;\n        }\n        if (!valueType.equals(that.valueType)) {\n            return false;\n        }\n\n        return true;\n    }","commit_id":"a19d531672542fa6b2644c890cf26ce03ea9f1bd","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Add a configuration for a {@link javax.cache.event.CacheEntryListener}.\n     *\n     * @param cacheEntryListenerConfiguration the {@link CacheEntryListenerConfiguration}\n     * @return the {@link CacheConfig}\n     * @throws IllegalArgumentException is the same CacheEntryListenerConfiguration\n     *                                  is used more than once\n     */\n    public CompleteConfiguration<K, V> addCacheEntryListenerConfiguration(\n            CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration) {\n\n        if (cacheEntryListenerConfiguration == null) {\n            throw new NullPointerException(\"CacheEntryListenerConfiguration can't be null\");\n        }\n        synchronized (listenerConfigurationsMutex) {\n            for (CacheEntryListenerConfiguration<? super K, ? super V> c : listenerConfigurations) {\n                if (c.equals(cacheEntryListenerConfiguration)) {\n                    throw new IllegalArgumentException(\"A CacheEntryListenerConfiguration can \"\n                            + \"be registered only once\");\n                }\n            }\n            this.listenerConfigurations.add(cacheEntryListenerConfiguration);\n            return this;\n        }\n    }","id":102190,"modified_method":"/**\n     * Add a configuration for a {@link javax.cache.event.CacheEntryListener}.\n     *\n     * @param cacheEntryListenerConfiguration the {@link CacheEntryListenerConfiguration}\n     * @return the {@link CacheConfig}\n     * @throws IllegalArgumentException is the same CacheEntryListenerConfiguration\n     *                                  is used more than once\n     */\n    public CompleteConfiguration<K, V> addCacheEntryListenerConfiguration(\n            CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration) {\n\n        if (cacheEntryListenerConfiguration == null) {\n            throw new NullPointerException(\"CacheEntryListenerConfiguration can't be null\");\n        }\n        if (!listenerConfigurations.add(cacheEntryListenerConfiguration)) {\n            throw new IllegalArgumentException(\"A CacheEntryListenerConfiguration can \"\n                    + \"be registered only once\");\n        }\n        return this;\n    }","commit_id":"a19d531672542fa6b2644c890cf26ce03ea9f1bd","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Remove a configuration for a {@link javax.cache.event.CacheEntryListener}.\n     *\n     * @param cacheEntryListenerConfiguration the {@link CacheEntryListenerConfiguration} to remove\n     * @return the {@link CacheConfig}\n     */\n    public CompleteConfiguration<K, V> removeCacheEntryListenerConfiguration(\n            CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration) {\n        if (cacheEntryListenerConfiguration == null) {\n            throw new NullPointerException(\"CacheEntryListenerConfiguration can't be null\");\n        }\n        synchronized (listenerConfigurationsMutex) {\n            listenerConfigurations.remove(cacheEntryListenerConfiguration);\n            return this;\n        }\n    }","id":102191,"modified_method":"/**\n     * Remove a configuration for a {@link javax.cache.event.CacheEntryListener}.\n     *\n     * @param cacheEntryListenerConfiguration the {@link CacheEntryListenerConfiguration} to remove\n     * @return the {@link CacheConfig}\n     */\n    public CompleteConfiguration<K, V> removeCacheEntryListenerConfiguration(\n            CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration) {\n        if (cacheEntryListenerConfiguration == null) {\n            throw new NullPointerException(\"CacheEntryListenerConfiguration can't be null\");\n        }\n        listenerConfigurations.remove(cacheEntryListenerConfiguration);\n        return this;\n    }","commit_id":"a19d531672542fa6b2644c890cf26ce03ea9f1bd","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public NearCacheConfig getNearCacheConfig() {\n        return super.getNearCacheConfig().getAsReadOnly();\n    }","id":102192,"modified_method":"@Override\n    public NearCacheConfig getNearCacheConfig() {\n        final NearCacheConfig nearCacheConfig = super.getNearCacheConfig();\n        if (nearCacheConfig == null) {\n            return null;\n        }\n        return nearCacheConfig.getAsReadOnly();\n    }","commit_id":"a19d531672542fa6b2644c890cf26ce03ea9f1bd","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Remove a configuration for a {@link javax.cache.event.CacheEntryListener}.\n     *\n     * @param cacheEntryListenerConfiguration the {@link CacheEntryListenerConfiguration} to remove\n     * @return the {@link CacheConfig}\n     */\n    public CompleteConfiguration<K, V> removeCacheEntryListenerConfiguration(\n            CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration) {\n        if (cacheEntryListenerConfiguration == null) {\n            throw new NullPointerException(\"CacheEntryListenerConfiguration can't be null\");\n        }\n        synchronized (listenerConfigurationsMutex) {\n            listenerConfigurations.remove(cacheEntryListenerConfiguration);\n            return this;\n        }\n    }","id":102193,"modified_method":"/**\n     * Remove a configuration for a {@link javax.cache.event.CacheEntryListener}.\n     *\n     * @param cacheEntryListenerConfiguration the {@link CacheEntryListenerConfiguration} to remove\n     * @return the {@link CacheConfig}\n     */\n    public CompleteConfiguration<K, V> removeCacheEntryListenerConfiguration(\n            CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration) {\n        if (cacheEntryListenerConfiguration == null) {\n            throw new NullPointerException(\"CacheEntryListenerConfiguration can't be null\");\n        }\n        listenerConfigurations.remove(cacheEntryListenerConfiguration);\n        return this;\n    }","commit_id":"46f8754b40ab24a2dec7c0adf5189461ce0a2965","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean equals(final Object o) {\n        final AbstractCacheConfig that = (CacheConfig) o;\n        if (isManagementEnabled != that.isManagementEnabled) {\n            return false;\n        }\n        if (isReadThrough != that.isReadThrough) {\n            return false;\n        }\n        if (isStatisticsEnabled != that.isStatisticsEnabled) {\n            return false;\n        }\n        if (isStoreByValue != that.isStoreByValue) {\n            return false;\n        }\n        if (isWriteThrough != that.isWriteThrough) {\n            return false;\n        }\n        if (cacheLoaderFactory != null ? !cacheLoaderFactory.equals(that.cacheLoaderFactory) : that.cacheLoaderFactory != null) {\n            return false;\n        }\n        if (cacheWriterFactory != null ? !cacheWriterFactory.equals(that.cacheWriterFactory) : that.cacheWriterFactory != null) {\n            return false;\n        }\n        if (expiryPolicyFactory != null\n                ? !expiryPolicyFactory.equals(that.expiryPolicyFactory) : that.expiryPolicyFactory != null) {\n            return false;\n        }\n        if (!keyType.equals(that.keyType)) {\n            return false;\n        }\n        if (!listenerConfigurations.equals(that.listenerConfigurations)) {\n            return false;\n        }\n        if (!valueType.equals(that.valueType)) {\n            return false;\n        }\n\n        return true;\n    }","id":102194,"modified_method":"@Override\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        AbstractCacheConfig that = (AbstractCacheConfig) o;\n\n        if (isManagementEnabled != that.isManagementEnabled) {\n            return false;\n        }\n        if (isReadThrough != that.isReadThrough) {\n            return false;\n        }\n        if (isStatisticsEnabled != that.isStatisticsEnabled) {\n            return false;\n        }\n        if (isStoreByValue != that.isStoreByValue) {\n            return false;\n        }\n        if (isWriteThrough != that.isWriteThrough) {\n            return false;\n        }\n        if (cacheLoaderFactory != null ? !cacheLoaderFactory.equals(that.cacheLoaderFactory) : that.cacheLoaderFactory != null) {\n            return false;\n        }\n        if (cacheWriterFactory != null ? !cacheWriterFactory.equals(that.cacheWriterFactory) : that.cacheWriterFactory != null) {\n            return false;\n        }\n        if (expiryPolicyFactory != null\n                ? !expiryPolicyFactory.equals(that.expiryPolicyFactory) : that.expiryPolicyFactory != null) {\n            return false;\n        }\n        if (!keyType.equals(that.keyType)) {\n            return false;\n        }\n        if (!listenerConfigurations.equals(that.listenerConfigurations)) {\n            return false;\n        }\n        if (!valueType.equals(that.valueType)) {\n            return false;\n        }\n\n        return true;\n    }","commit_id":"46f8754b40ab24a2dec7c0adf5189461ce0a2965","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Add a configuration for a {@link javax.cache.event.CacheEntryListener}.\n     *\n     * @param cacheEntryListenerConfiguration the {@link CacheEntryListenerConfiguration}\n     * @return the {@link CacheConfig}\n     * @throws IllegalArgumentException is the same CacheEntryListenerConfiguration\n     *                                  is used more than once\n     */\n    public CompleteConfiguration<K, V> addCacheEntryListenerConfiguration(\n            CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration) {\n\n        if (cacheEntryListenerConfiguration == null) {\n            throw new NullPointerException(\"CacheEntryListenerConfiguration can't be null\");\n        }\n        synchronized (listenerConfigurationsMutex) {\n            for (CacheEntryListenerConfiguration<? super K, ? super V> c : listenerConfigurations) {\n                if (c.equals(cacheEntryListenerConfiguration)) {\n                    throw new IllegalArgumentException(\"A CacheEntryListenerConfiguration can \"\n                            + \"be registered only once\");\n                }\n            }\n            this.listenerConfigurations.add(cacheEntryListenerConfiguration);\n            return this;\n        }\n    }","id":102195,"modified_method":"/**\n     * Add a configuration for a {@link javax.cache.event.CacheEntryListener}.\n     *\n     * @param cacheEntryListenerConfiguration the {@link CacheEntryListenerConfiguration}\n     * @return the {@link CacheConfig}\n     * @throws IllegalArgumentException is the same CacheEntryListenerConfiguration\n     *                                  is used more than once\n     */\n    public CompleteConfiguration<K, V> addCacheEntryListenerConfiguration(\n            CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration) {\n\n        if (cacheEntryListenerConfiguration == null) {\n            throw new NullPointerException(\"CacheEntryListenerConfiguration can't be null\");\n        }\n        if (!listenerConfigurations.add(cacheEntryListenerConfiguration)) {\n            throw new IllegalArgumentException(\"A CacheEntryListenerConfiguration can \"\n                    + \"be registered only once\");\n        }\n        return this;\n    }","commit_id":"46f8754b40ab24a2dec7c0adf5189461ce0a2965","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public NearCacheConfig getNearCacheConfig() {\n        return super.getNearCacheConfig().getAsReadOnly();\n    }","id":102196,"modified_method":"@Override\n    public NearCacheConfig getNearCacheConfig() {\n        final NearCacheConfig nearCacheConfig = super.getNearCacheConfig();\n        if (nearCacheConfig == null) {\n            return null;\n        }\n        return nearCacheConfig.getAsReadOnly();\n    }","commit_id":"46f8754b40ab24a2dec7c0adf5189461ce0a2965","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n\t * Handle a prev-message (view) request.\n\t */\n\tpublic void doView_prev(RunData runData, Context context)\n\t{\n\t\t// access the portlet element id to find our state\n\t\tString peid = ((JetspeedRunData) runData).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) runData).getPortletSessionState(peid);\n\n\t\t// set the flag to go to the prev message on the next view\n\t\tstate.setAttribute(STATE_GO_PREV, \"\");\n\n\t\t// set the page number\n\t\tint page = ((Integer) state.getAttribute(STATE_CURRENT_PAGE)).intValue();\n\t\tstate.setAttribute(STATE_CURRENT_PAGE, new Integer(page - 1));\n\n\t}","id":102197,"modified_method":"/**\n\t * Handle a prev-message (view) request.\n\t */\n\tpublic void doView_prev(RunData runData, Context context)\n\t{\n\t\t// access the portlet element id to find our state\n\t\tString peid = ((JetspeedRunData) runData).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) runData).getPortletSessionState(peid);\n\n\t\t// set the flag to go to the prev message on the next view\n\t\tstate.setAttribute(STATE_GO_PREV, \"\");\n\n\t\t// set the page number\n\t\tint page = state.getAttribute(STATE_CURRENT_PAGE) != null ?\n\t\t\t\t((Integer) state.getAttribute(STATE_CURRENT_PAGE)).intValue() : 2;\n\t\tstate.setAttribute(STATE_CURRENT_PAGE, new Integer(page - 1));\n\n\t}","commit_id":"53af645f8df9752608df0d98038a6be228a3ee2a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Handle a next-page (list) request.\n\t */\n\tpublic void doList_next(RunData runData, Context context)\n\t{\n\t\t// access the portlet element id to find our state\n\t\tString peid = ((JetspeedRunData) runData).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) runData).getPortletSessionState(peid);\n\n\t\t// set the flag to go to the next page on the next list\n\t\tstate.setAttribute(STATE_GO_NEXT_PAGE, \"\");\n\n\t\t// %%% ?? doList(runData, context);\n\n\t\t// set the page number\n\t\tint page = ((Integer) state.getAttribute(STATE_CURRENT_PAGE)).intValue();\n\t\tstate.setAttribute(STATE_CURRENT_PAGE, new Integer(page + 1));\n\n\t}","id":102198,"modified_method":"/**\n\t * Handle a next-page (list) request.\n\t */\n\tpublic void doList_next(RunData runData, Context context)\n\t{\n\t\t// access the portlet element id to find our state\n\t\tString peid = ((JetspeedRunData) runData).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) runData).getPortletSessionState(peid);\n\n\t\t// set the flag to go to the next page on the next list\n\t\tstate.setAttribute(STATE_GO_NEXT_PAGE, \"\");\n\n\t\t// %%% ?? doList(runData, context);\n\n\t\t// set the page number\n\t\tint page = state.getAttribute(STATE_CURRENT_PAGE) != null ?\n\t\t\t\t((Integer) state.getAttribute(STATE_CURRENT_PAGE)).intValue() : 1;\n\t\tstate.setAttribute(STATE_CURRENT_PAGE, new Integer(page + 1));\n\n\t}","commit_id":"53af645f8df9752608df0d98038a6be228a3ee2a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Return the total page number\n\t */\n\tprotected int totalPageNumber(SessionState state)\n\t{\n\t\treturn ((Integer) state.getAttribute(STATE_TOTAL_PAGENUMBER)).intValue();\n\n\t}","id":102199,"modified_method":"/**\n\t * Return the total page number\n\t */\n\tprotected int totalPageNumber(SessionState state)\n\t{\n\t\treturn state.getAttribute(STATE_TOTAL_PAGENUMBER) != null ?\n\t\t\t\t((Integer) state.getAttribute(STATE_TOTAL_PAGENUMBER)).intValue() : 1;\n\n\t}","commit_id":"53af645f8df9752608df0d98038a6be228a3ee2a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Prepare the current page of messages to display.\n\t * \n\t * @return List of MailArchiveMessage to display on this page.\n\t */\n\tprotected List prepPage(SessionState state)\n\t{\n\t\t// access the page size\n\t\tint pageSize = state.getAttribute(STATE_PAGESIZE) != null ?\n\t\t\t\t((Integer) state.getAttribute(STATE_PAGESIZE)).intValue() : DEFAULT_PAGE_SIZE;\n\t\t\n\t\t// cleanup prior prep\n\t\tstate.removeAttribute(STATE_NUM_MESSAGES);\n\n\t\t// are we going next or prev, first or last page?\n\t\tboolean goNextPage = state.getAttribute(STATE_GO_NEXT_PAGE) != null;\n\t\tboolean goPrevPage = state.getAttribute(STATE_GO_PREV_PAGE) != null;\n\t\tboolean goFirstPage = state.getAttribute(STATE_GO_FIRST_PAGE) != null;\n\t\tboolean goLastPage = state.getAttribute(STATE_GO_LAST_PAGE) != null;\n\t\tstate.removeAttribute(STATE_GO_NEXT_PAGE);\n\t\tstate.removeAttribute(STATE_GO_PREV_PAGE);\n\t\tstate.removeAttribute(STATE_GO_FIRST_PAGE);\n\t\tstate.removeAttribute(STATE_GO_LAST_PAGE);\n\n\t\t// are we going next or prev message?\n\t\tboolean goNext = state.getAttribute(STATE_GO_NEXT) != null;\n\t\tboolean goPrev = state.getAttribute(STATE_GO_PREV) != null;\n\t\tstate.removeAttribute(STATE_GO_NEXT);\n\t\tstate.removeAttribute(STATE_GO_PREV);\n\n\t\tboolean goViewPage = state.getAttribute(STATE_GOTO_PAGE) != null;\n\n\t\t// if we have no prev page and do have a top message, then we will stay \"pined\" to the top\n\t\tboolean pinToTop = ((state.getAttribute(STATE_TOP_PAGE_MESSAGE) != null)\n\t\t\t\t&& (state.getAttribute(STATE_PREV_PAGE_EXISTS) == null) && !goNextPage && !goPrevPage && !goNext && !goPrev\n\t\t\t\t&& !goFirstPage && !goLastPage && !goViewPage);\n\n\t\t// how many messages, total\n\t\tint numMessages = sizeResources(state);\n\n\t\tif (numMessages == 0)\n\t\t{\n\t\t\treturn new Vector();\n\t\t}\n\n\t\t// set the total page number\n\t\tint totalPageNumber = 1;\n\t\tif ((numMessages % pageSize) > 0)\n\t\t{\n\t\t\ttotalPageNumber = numMessages / pageSize + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttotalPageNumber = numMessages / pageSize;\n\t\t}\n\t\tstate.setAttribute(STATE_TOTAL_PAGENUMBER, new Integer(totalPageNumber));\n\n\t\t// save the number of messges\n\t\tstate.setAttribute(STATE_NUM_MESSAGES, new Integer(numMessages));\n\n\t\t// find the position of the message that is the top first on the page\n\t\tint posStart = 0;\n\t\tInteger topPageMessage = (Integer) state.getAttribute(STATE_TOP_PAGE_MESSAGE);\n\t\tif (topPageMessage != null)\n\t\t{\n\t\t\tposStart = topPageMessage.intValue();\n\t\t}\n\n\t\t// if going to a certain page\n\t\tif (state.getAttribute(STATE_GOTO_PAGE) != null)\n\t\t{\n\t\t\tint gotoPage = ((Integer) state.getAttribute(STATE_GOTO_PAGE)).intValue();\n\t\t\tint currentPage = ((Integer) state.getAttribute(STATE_CURRENT_PAGE)).intValue();\n\t\t\tposStart += pageSize * (gotoPage - currentPage);\n\t\t}\n\n\t\t// if going to the next page, adjust\n\t\telse if (goNextPage)\n\t\t{\n\t\t\tposStart += pageSize;\n\t\t}\n\n\t\t// if going to the prev page, adjust\n\t\telse if (goPrevPage)\n\t\t{\n\t\t\tposStart -= pageSize;\n\t\t\tif (posStart < 0) posStart = 0;\n\t\t}\n\n\t\t// if going to the first page, adjust\n\t\telse if (goFirstPage)\n\t\t{\n\t\t\tposStart = 0;\n\t\t}\n\n\t\t// if going to the last page, adjust\n\t\telse if (goLastPage)\n\t\t{\n\t\t\tposStart = numMessages - pageSize;\n\t\t\tif (posStart < 0) posStart = 0;\n\t\t}\n\n\t\t// pinning\n\t\tif (pinToTop)\n\t\t{\n\t\t\tposStart = 0;\n\t\t}\n\n\t\t// compute the end to a page size, adjusted for the number of messages available\n\t\tint posEnd = posStart + (pageSize - 1);\n\t\tif (posEnd >= numMessages) posEnd = numMessages - 1;\n\t\tint numMessagesOnThisPage = (posEnd - posStart) + 1;\n\n\t\t// select the messages on this page\n\t\tList messagePage = readResourcesPage(state, posStart + 1, posEnd + 1);\n\n\t\t// save which message is at the top of the page\n\t\tstate.setAttribute(STATE_TOP_PAGE_MESSAGE, new Integer(posStart));\n\n\t\t// which message starts the next page (if any)\n\t\tint next = posStart + pageSize;\n\t\tif (next < numMessages)\n\t\t{\n\t\t\tstate.setAttribute(STATE_NEXT_PAGE_EXISTS, \"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstate.removeAttribute(STATE_NEXT_PAGE_EXISTS);\n\t\t}\n\n\t\t// which message ends the prior page (if any)\n\t\tint prev = posStart - 1;\n\t\tif (prev >= 0)\n\t\t{\n\t\t\tstate.setAttribute(STATE_PREV_PAGE_EXISTS, \"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstate.removeAttribute(STATE_PREV_PAGE_EXISTS);\n\t\t}\n\n\t\tstate.removeAttribute(STATE_FIRST_PAGE_EXISTS);\n\t\tstate.removeAttribute(STATE_LAST_PAGE_EXISTS);\n\t\tif (totalPageNumber != 1)\n\t\t{\n\t\t\tif (posStart > 0)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_FIRST_PAGE_EXISTS, \"\");\n\t\t\t}\n\t\t\tif (posStart + pageSize < numMessages)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_LAST_PAGE_EXISTS, \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (state.getAttribute(STATE_VIEW_ID) != null)\n\t\t{\n\t\t\tint viewPos = ((Integer) state.getAttribute(STATE_VIEW_ID)).intValue();\n\n\t\t\t// are we moving to the next message\n\t\t\tif (goNext)\n\t\t\t{\n\t\t\t\t// advance\n\t\t\t\tviewPos++;\n\t\t\t\tif (viewPos >= numMessages) viewPos = numMessages - 1;\n\t\t\t}\n\n\t\t\t// are we moving to the prev message\n\t\t\tif (goPrev)\n\t\t\t{\n\t\t\t\t// retreat\n\t\t\t\tviewPos--;\n\t\t\t\tif (viewPos < 0) viewPos = 0;\n\t\t\t}\n\n\t\t\t// update the view message\n\t\t\tstate.setAttribute(STATE_VIEW_ID, new Integer(viewPos));\n\n\t\t\t// if the view message is no longer on the current page, adjust the page\n\t\t\t// Note: next time through this will get processed\n\t\t\tif (viewPos < posStart)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_GO_PREV_PAGE, \"\");\n\t\t\t}\n\t\t\telse if (viewPos > posEnd)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_GO_NEXT_PAGE, \"\");\n\t\t\t}\n\n\t\t\tif (viewPos > 0)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_PREV_EXISTS, \"\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.removeAttribute(STATE_PREV_EXISTS);\n\t\t\t}\n\n\t\t\tif (viewPos < numMessages - 1)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_NEXT_EXISTS, \"\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.removeAttribute(STATE_NEXT_EXISTS);\n\t\t\t}\n\t\t}\n\n\t\tif (state.getAttribute(STATE_GOTO_PAGE) != null)\n\t\t{\n\t\t\tstate.setAttribute(STATE_CURRENT_PAGE, state.getAttribute(STATE_GOTO_PAGE));\n\t\t\tstate.removeAttribute(STATE_GOTO_PAGE);\n\t\t}\n\n\t\treturn messagePage;\n\n\t}","id":102200,"modified_method":"/**\n\t * Prepare the current page of messages to display.\n\t * \n\t * @return List of MailArchiveMessage to display on this page.\n\t */\n\tprotected List prepPage(SessionState state)\n\t{\n\t\t// access the page size\n\t\tint pageSize = state.getAttribute(STATE_PAGESIZE) != null ?\n\t\t\t\t((Integer) state.getAttribute(STATE_PAGESIZE)).intValue() : DEFAULT_PAGE_SIZE;\n\t\t\n\t\t// cleanup prior prep\n\t\tstate.removeAttribute(STATE_NUM_MESSAGES);\n\n\t\t// are we going next or prev, first or last page?\n\t\tboolean goNextPage = state.getAttribute(STATE_GO_NEXT_PAGE) != null;\n\t\tboolean goPrevPage = state.getAttribute(STATE_GO_PREV_PAGE) != null;\n\t\tboolean goFirstPage = state.getAttribute(STATE_GO_FIRST_PAGE) != null;\n\t\tboolean goLastPage = state.getAttribute(STATE_GO_LAST_PAGE) != null;\n\t\tstate.removeAttribute(STATE_GO_NEXT_PAGE);\n\t\tstate.removeAttribute(STATE_GO_PREV_PAGE);\n\t\tstate.removeAttribute(STATE_GO_FIRST_PAGE);\n\t\tstate.removeAttribute(STATE_GO_LAST_PAGE);\n\n\t\t// are we going next or prev message?\n\t\tboolean goNext = state.getAttribute(STATE_GO_NEXT) != null;\n\t\tboolean goPrev = state.getAttribute(STATE_GO_PREV) != null;\n\t\tstate.removeAttribute(STATE_GO_NEXT);\n\t\tstate.removeAttribute(STATE_GO_PREV);\n\n\t\tboolean goViewPage = state.getAttribute(STATE_GOTO_PAGE) != null;\n\n\t\t// if we have no prev page and do have a top message, then we will stay \"pined\" to the top\n\t\tboolean pinToTop = ((state.getAttribute(STATE_TOP_PAGE_MESSAGE) != null)\n\t\t\t\t&& (state.getAttribute(STATE_PREV_PAGE_EXISTS) == null) && !goNextPage && !goPrevPage && !goNext && !goPrev\n\t\t\t\t&& !goFirstPage && !goLastPage && !goViewPage);\n\n\t\t// how many messages, total\n\t\tint numMessages = sizeResources(state);\n\n\t\tif (numMessages == 0)\n\t\t{\n\t\t\treturn new Vector();\n\t\t}\n\n\t\t// set the total page number\n\t\tint totalPageNumber = 1;\n\t\tif ((numMessages % pageSize) > 0)\n\t\t{\n\t\t\ttotalPageNumber = numMessages / pageSize + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttotalPageNumber = numMessages / pageSize;\n\t\t}\n\t\tstate.setAttribute(STATE_TOTAL_PAGENUMBER, new Integer(totalPageNumber));\n\n\t\t// save the number of messges\n\t\tstate.setAttribute(STATE_NUM_MESSAGES, new Integer(numMessages));\n\n\t\t// find the position of the message that is the top first on the page\n\t\tint posStart = 0;\n\t\tInteger topPageMessage = (Integer) state.getAttribute(STATE_TOP_PAGE_MESSAGE);\n\t\tif (topPageMessage != null)\n\t\t{\n\t\t\tposStart = topPageMessage.intValue();\n\t\t}\n\n\t\t// if going to a certain page\n\t\tif (state.getAttribute(STATE_GOTO_PAGE) != null)\n\t\t{\n\t\t\tint gotoPage = ((Integer) state.getAttribute(STATE_GOTO_PAGE)).intValue();\n\t\t\tint currentPage = state.getAttribute(STATE_CURRENT_PAGE) != null ?\n\t\t\t\t\t((Integer) state.getAttribute(STATE_CURRENT_PAGE)).intValue() : 0;\n\t\t\tposStart += pageSize * (gotoPage - currentPage);\n\t\t}\n\n\t\t// if going to the next page, adjust\n\t\telse if (goNextPage)\n\t\t{\n\t\t\tposStart += pageSize;\n\t\t}\n\n\t\t// if going to the prev page, adjust\n\t\telse if (goPrevPage)\n\t\t{\n\t\t\tposStart -= pageSize;\n\t\t\tif (posStart < 0) posStart = 0;\n\t\t}\n\n\t\t// if going to the first page, adjust\n\t\telse if (goFirstPage)\n\t\t{\n\t\t\tposStart = 0;\n\t\t}\n\n\t\t// if going to the last page, adjust\n\t\telse if (goLastPage)\n\t\t{\n\t\t\tposStart = numMessages - pageSize;\n\t\t\tif (posStart < 0) posStart = 0;\n\t\t}\n\n\t\t// pinning\n\t\tif (pinToTop)\n\t\t{\n\t\t\tposStart = 0;\n\t\t}\n\n\t\t// compute the end to a page size, adjusted for the number of messages available\n\t\tint posEnd = posStart + (pageSize - 1);\n\t\tif (posEnd >= numMessages) posEnd = numMessages - 1;\n\n\t\t// select the messages on this page\n\t\tList messagePage = readResourcesPage(state, posStart + 1, posEnd + 1);\n\n\t\t// save which message is at the top of the page\n\t\tstate.setAttribute(STATE_TOP_PAGE_MESSAGE, new Integer(posStart));\n\n\t\t// which message starts the next page (if any)\n\t\tint next = posStart + pageSize;\n\t\tif (next < numMessages)\n\t\t{\n\t\t\tstate.setAttribute(STATE_NEXT_PAGE_EXISTS, \"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstate.removeAttribute(STATE_NEXT_PAGE_EXISTS);\n\t\t}\n\n\t\t// which message ends the prior page (if any)\n\t\tint prev = posStart - 1;\n\t\tif (prev >= 0)\n\t\t{\n\t\t\tstate.setAttribute(STATE_PREV_PAGE_EXISTS, \"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstate.removeAttribute(STATE_PREV_PAGE_EXISTS);\n\t\t}\n\n\t\tstate.removeAttribute(STATE_FIRST_PAGE_EXISTS);\n\t\tstate.removeAttribute(STATE_LAST_PAGE_EXISTS);\n\t\tif (totalPageNumber != 1)\n\t\t{\n\t\t\tif (posStart > 0)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_FIRST_PAGE_EXISTS, \"\");\n\t\t\t}\n\t\t\tif (posStart + pageSize < numMessages)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_LAST_PAGE_EXISTS, \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (state.getAttribute(STATE_VIEW_ID) != null)\n\t\t{\n\t\t\tint viewPos = ((Integer) state.getAttribute(STATE_VIEW_ID)).intValue();\n\n\t\t\t// are we moving to the next message\n\t\t\tif (goNext)\n\t\t\t{\n\t\t\t\t// advance\n\t\t\t\tviewPos++;\n\t\t\t\tif (viewPos >= numMessages) viewPos = numMessages - 1;\n\t\t\t}\n\n\t\t\t// are we moving to the prev message\n\t\t\tif (goPrev)\n\t\t\t{\n\t\t\t\t// retreat\n\t\t\t\tviewPos--;\n\t\t\t\tif (viewPos < 0) viewPos = 0;\n\t\t\t}\n\n\t\t\t// update the view message\n\t\t\tstate.setAttribute(STATE_VIEW_ID, new Integer(viewPos));\n\n\t\t\t// if the view message is no longer on the current page, adjust the page\n\t\t\t// Note: next time through this will get processed\n\t\t\tif (viewPos < posStart)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_GO_PREV_PAGE, \"\");\n\t\t\t}\n\t\t\telse if (viewPos > posEnd)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_GO_NEXT_PAGE, \"\");\n\t\t\t}\n\n\t\t\tif (viewPos > 0)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_PREV_EXISTS, \"\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.removeAttribute(STATE_PREV_EXISTS);\n\t\t\t}\n\n\t\t\tif (viewPos < numMessages - 1)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_NEXT_EXISTS, \"\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.removeAttribute(STATE_NEXT_EXISTS);\n\t\t\t}\n\t\t}\n\n\t\tif (state.getAttribute(STATE_GOTO_PAGE) != null)\n\t\t{\n\t\t\tstate.setAttribute(STATE_CURRENT_PAGE, state.getAttribute(STATE_GOTO_PAGE));\n\t\t\tstate.removeAttribute(STATE_GOTO_PAGE);\n\t\t}\n\n\t\treturn messagePage;\n\n\t}","commit_id":"53af645f8df9752608df0d98038a6be228a3ee2a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Handle a next-message (view) request.\n\t */\n\tpublic void doView_next(RunData runData, Context context)\n\t{\n\t\t// access the portlet element id to find our state\n\t\tString peid = ((JetspeedRunData) runData).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) runData).getPortletSessionState(peid);\n\n\t\t// set the flag to go to the next message on the next view\n\t\tstate.setAttribute(STATE_GO_NEXT, \"\");\n\n\t\t// set the page number\n\t\tint page = ((Integer) state.getAttribute(STATE_CURRENT_PAGE)).intValue();\n\t\tstate.setAttribute(STATE_CURRENT_PAGE, new Integer(page + 1));\n\n\t}","id":102201,"modified_method":"/**\n\t * Handle a next-message (view) request.\n\t */\n\tpublic void doView_next(RunData runData, Context context)\n\t{\n\t\t// access the portlet element id to find our state\n\t\tString peid = ((JetspeedRunData) runData).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) runData).getPortletSessionState(peid);\n\n\t\t// set the flag to go to the next message on the next view\n\t\tstate.setAttribute(STATE_GO_NEXT, \"\");\n\n\t\t// set the page number\n\t\tint page = state.getAttribute(STATE_CURRENT_PAGE) != null ?\n\t\t\t\t((Integer) state.getAttribute(STATE_CURRENT_PAGE)).intValue() : 1;\n\t\tstate.setAttribute(STATE_CURRENT_PAGE, new Integer(page + 1));\n\n\t}","commit_id":"53af645f8df9752608df0d98038a6be228a3ee2a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Handle a prev-page (list) request.\n\t */\n\tpublic void doList_prev(RunData runData, Context context)\n\t{\n\t\t// access the portlet element id to find our state\n\t\tString peid = ((JetspeedRunData) runData).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) runData).getPortletSessionState(peid);\n\n\t\t// set the flag to go to the prev page on the next list\n\t\tstate.setAttribute(STATE_GO_PREV_PAGE, \"\");\n\n\t\t// set the page number\n\t\tint page = ((Integer) state.getAttribute(STATE_CURRENT_PAGE)).intValue();\t// FIXME\n\t\tstate.setAttribute(STATE_CURRENT_PAGE, new Integer(page - 1));\n\n\t}","id":102202,"modified_method":"/**\n\t * Handle a prev-page (list) request.\n\t */\n\tpublic void doList_prev(RunData runData, Context context)\n\t{\n\t\t// access the portlet element id to find our state\n\t\tString peid = ((JetspeedRunData) runData).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) runData).getPortletSessionState(peid);\n\n\t\t// set the flag to go to the prev page on the next list\n\t\tstate.setAttribute(STATE_GO_PREV_PAGE, \"\");\n\n\t\t// set the page number\n\t\tint page = state.getAttribute(STATE_CURRENT_PAGE) != null ?\n\t\t\t\t((Integer) state.getAttribute(STATE_CURRENT_PAGE)).intValue() : 2;\n\t\tstate.setAttribute(STATE_CURRENT_PAGE, new Integer(page - 1));\n\n\t}","commit_id":"b32d1c7dc4923571efa021ee80a1d4ba8dde96e6","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Read the role save as form and make the new role in the realm in edit.\n\t * \n\t * @return true if the form is accepted, false if there's a validation error (an alertMessage will be set)\n\t */\n\tprivate boolean readRoleSaveAsForm(RunData data, SessionState state)\n\t{\n\t\t// get the realm\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\n\t\t// we will copy this role\n\t\tRole role = (Role) state.getAttribute(\"role\");\n\n\t\t// read the form\n\t\tString id = StringUtil.trimToNull(data.getParameters().getString(\"id\"));\n\n\t\tif (id == null)\n\t\t{\n\t\t\taddAlert(state, rb.getString(\"realm.please\"));\n\t\t\treturn false;\n\t\t}\n\n\t\t// create the role\n\t\ttry\n\t\t{\n\t\t\trealm.addRole(id, role);\n\t\t}\n\t\tcatch (RoleAlreadyDefinedException e)\n\t\t{\n\t\t\taddAlert(state, rb.getString(\"realm.arole\") + id + rb.getString(\"realm.defined\"));\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\n\t}","id":102203,"modified_method":"/**\n\t * Read the role save as form and make the new role in the realm in edit.\n\t * \n\t * @return true if the form is accepted, false if there's a validation error (an alertMessage will be set)\n\t */\n\tprivate boolean readRoleSaveAsForm(RunData data, SessionState state)\n\t{\n\t\t// get the realm\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\n\t\t// we will copy this role\n\t\tRole role = (Role) state.getAttribute(\"role\");\n\n\t\t// read the form\n\t\tString id = StringUtil.trimToNull(data.getParameters().getString(\"id\"));\n\n\t\tif (id == null)\n\t\t{\n\t\t\taddAlert(state, rb.getString(\"realm.please\"));\n\t\t\treturn false;\n\t\t}\n\n\t\tif (realm != null)\n\t\t{\n\t\t\t// create the role\n\t\t\ttry\n\t\t\t{\n\t\t\t\trealm.addRole(id, role);\n\t\t\t}\n\t\t\tcatch (RoleAlreadyDefinedException e)\n\t\t\t{\n\t\t\t\taddAlert(state, rb.getString(\"realm.arole\") + id + rb.getString(\"realm.defined\"));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\n\t}","commit_id":"9c2b67aa4dfaf6273eef47bdc9c6d5b28cc4ddaf","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Edit an existing page.\n\t */\n\tpublic void doEdit_role(RunData data, Context context)\n\t{\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(((JetspeedRunData) data).getJs_peid());\n\n\t\t// read the form - if rejected, leave things as they are\n\t\tif (!readRealmForm(data, state)) return;\n\n\t\tstate.setAttribute(\"mode\", \"editRole\");\n\n\t\tString id = data.getParameters().getString(\"target\");\n\n\t\t// get the role\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\tRole role = realm.getRole(id);\n\t\tstate.setAttribute(\"role\", role);\n\n\t}","id":102204,"modified_method":"/**\n\t * Edit an existing page.\n\t */\n\tpublic void doEdit_role(RunData data, Context context)\n\t{\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(((JetspeedRunData) data).getJs_peid());\n\n\t\t// read the form - if rejected, leave things as they are\n\t\tif (!readRealmForm(data, state)) return;\n\n\t\tstate.setAttribute(\"mode\", \"editRole\");\n\n\t\tString id = data.getParameters().getString(\"target\");\n\n\t\t// get the role\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\tif (realm != null)\n\t\t{\n\t\t\tRole role = realm.getRole(id);\n\t\t\tstate.setAttribute(\"role\", role);\n\t\t}\n\n\t}","commit_id":"9c2b67aa4dfaf6273eef47bdc9c6d5b28cc4ddaf","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Build the context for the main list mode.\n\t */\n\tprivate String buildListContext(SessionState state, Context context)\n\t{\n\t\t// prepare the paging of realms\n\t\tList realms = prepPage(state);\n\n\t\t// put the service in the context (used for allow update calls on each realm)\n\t\tcontext.put(\"service\", AuthzGroupService.getInstance());\n\n\t\t// put all realms into the context\n\t\tcontext.put(\"realms\", realms);\n\n\t\tint pageSize = Integer.valueOf(state.getAttribute(STATE_PAGESIZE).toString()).intValue();\n\t\tint currentPageNubmer = Integer.valueOf(state.getAttribute(STATE_CURRENT_PAGE).toString()).intValue();\n\t\tint startNumber = pageSize * (currentPageNubmer - 1) + 1;\n\t\tint endNumber = pageSize * currentPageNubmer;\n\n\t\tint totalNumber = 0;\n\t\ttry\n\t\t{\n\t\t\ttotalNumber = Integer.valueOf(state.getAttribute(STATE_NUM_MESSAGES).toString()).intValue();\n\t\t}\n\t\tcatch (java.lang.NullPointerException ignore) {}\n\t\tcatch (java.lang.NumberFormatException ignore) {}\n\n\t\tif (totalNumber < endNumber) endNumber = totalNumber;\n\n\t\tcontext.put(\"startNumber\", Integer.valueOf(startNumber));\n\t\tcontext.put(\"endNumber\", Integer.valueOf(endNumber));\n\t\tcontext.put(\"totalNumber\", Integer.valueOf(totalNumber));\n\t\tpagingInfoToContext(state, context);\n\n\t\t// build the menu\n\t\tMenu bar = new MenuImpl();\n\t\tif (AuthzGroupService.allowAdd(\"\"))\n\t\t{\n\t\t\tbar.add(new MenuEntry(rb.getString(\"realm.new\"), \"doNew\"));\n\t\t}\n\n\t\t// add the paging commands\n\t\t//addListPagingMenus(bar, state);\n\n\t\t// add the search commands\n\t\taddSearchMenus(bar, state);\n\n\t\t// add the refresh commands\n\t\taddRefreshMenus(bar, state);\n\n\t\tif (bar.size() > 0)\n\t\t{\n\t\t\tcontext.put(Menu.CONTEXT_MENU, bar);\n\t\t}\n\n\t\t// inform the observing courier that we just updated the page...\n\t\t// if there are pending requests to do so they can be cleared\n\t\tjustDelivered(state);\n\n\t\treturn \"_list\";\n\n\t}","id":102205,"modified_method":"/**\n\t * Build the context for the main list mode.\n\t */\n\tprivate String buildListContext(SessionState state, Context context)\n\t{\n\t\t// prepare the paging of realms\n\t\tList realms = prepPage(state);\n\n\t\t// put the service in the context (used for allow update calls on each realm)\n\t\tcontext.put(\"service\", AuthzGroupService.getInstance());\n\n\t\t// put all realms into the context\n\t\tcontext.put(\"realms\", realms);\n\n\t\t// defaults to page size of 20\n\t\tint pageSize = state.getAttribute(STATE_PAGESIZE) != null ? Integer.valueOf(state.getAttribute(STATE_PAGESIZE).toString()).intValue() : 20;\n\t\t\n\t\t// defaults to page 1\n\t\tint currentPageNubmer = state.getAttribute(STATE_CURRENT_PAGE) != null ? Integer.valueOf(state.getAttribute(STATE_CURRENT_PAGE).toString()).intValue() : 1;\n\t\t\n\t\tint startNumber = pageSize * (currentPageNubmer - 1) + 1;\n\t\tint endNumber = pageSize * currentPageNubmer;\n\n\t\tint totalNumber = 0;\n\t\ttry\n\t\t{\n\t\t\ttotalNumber = Integer.valueOf(state.getAttribute(STATE_NUM_MESSAGES).toString()).intValue();\n\t\t}\n\t\tcatch (java.lang.NullPointerException ignore) {}\n\t\tcatch (java.lang.NumberFormatException ignore) {}\n\n\t\tif (totalNumber < endNumber) endNumber = totalNumber;\n\n\t\tcontext.put(\"startNumber\", Integer.valueOf(startNumber));\n\t\tcontext.put(\"endNumber\", Integer.valueOf(endNumber));\n\t\tcontext.put(\"totalNumber\", Integer.valueOf(totalNumber));\n\t\tpagingInfoToContext(state, context);\n\n\t\t// build the menu\n\t\tMenu bar = new MenuImpl();\n\t\tif (AuthzGroupService.allowAdd(\"\"))\n\t\t{\n\t\t\tbar.add(new MenuEntry(rb.getString(\"realm.new\"), \"doNew\"));\n\t\t}\n\n\t\t// add the paging commands\n\t\t//addListPagingMenus(bar, state);\n\n\t\t// add the search commands\n\t\taddSearchMenus(bar, state);\n\n\t\t// add the refresh commands\n\t\taddRefreshMenus(bar, state);\n\n\t\tif (bar.size() > 0)\n\t\t{\n\t\t\tcontext.put(Menu.CONTEXT_MENU, bar);\n\t\t}\n\n\t\t// inform the observing courier that we just updated the page...\n\t\t// if there are pending requests to do so they can be cleared\n\t\tjustDelivered(state);\n\n\t\treturn \"_list\";\n\n\t}","commit_id":"9c2b67aa4dfaf6273eef47bdc9c6d5b28cc4ddaf","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Read the user form and update the realm in state.\n\t * \n\t * @return true if the form is accepted, false if there's a validation error (an alertMessage will be set)\n\t */\n\tprivate boolean readRoleForm(RunData data, SessionState state)\n\t{\n\t\t// get the realm\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\n\t\t// get the locks\n\t\tString[] locks = data.getParameters().getStrings(\"locks\");\n\n\t\t// we are setting for either a new role or this role\n\t\tRole role = (Role) state.getAttribute(\"role\");\n\t\tif (role == null)\n\t\t{\n\t\t\t// read the form\n\t\t\tString id = StringUtil.trimToNull(data.getParameters().getString(\"id\"));\n\n\t\t\t// if the field is missing, and there are no locks, just be done with no change\n\t\t\tif ((id == null) && (locks == null)) return true;\n\n\t\t\tif (id == null)\n\t\t\t{\n\t\t\t\taddAlert(state, rb.getString(\"realm.please\"));\n\t\t\t\treturn false;\n\t\t\t\t// TODO: would be nice to read the locks, and restore them when the form returns -ggolden\n\t\t\t}\n\n\t\t\t// create the role\n\t\t\ttry\n\t\t\t{\n\t\t\t\trole = realm.addRole(id);\n\t\t\t}\n\t\t\tcatch (RoleAlreadyDefinedException e)\n\t\t\t{\n\t\t\t\taddAlert(state, rb.getString(\"realm.arole\") + id + rb.getString(\"realm.defined\"));\n\t\t\t\treturn false;\n\t\t\t\t// TODO: would be nice to read the locks, and restore them when the form returns -ggolden\n\t\t\t}\n\t\t}\n\n\t\t// clear out the role\n\t\trole.disallowAll();\n\n\t\t// description\n\t\trole.setDescription(StringUtil.trimToNull(data.getParameters().getString(\"description\")));\n\n\t\t// providerOnly\n\t\tString providerOnlyString = (StringUtil.trimToNull(data.getParameters().getString(\"providerOnly\")));\n\t\trole.setProviderOnly(\"true\".equals(providerOnlyString));\t\t\n\n\t\t// for each lock set, give it to the role\n\t\tif (locks != null)\n\t\t{\n\t\t\tfor (int i = 0; i < locks.length; i++)\n\t\t\t{\n\t\t\t\trole.allowFunction(locks[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\n\t}","id":102206,"modified_method":"/**\n\t * Read the user form and update the realm in state.\n\t * \n\t * @return true if the form is accepted, false if there's a validation error (an alertMessage will be set)\n\t */\n\tprivate boolean readRoleForm(RunData data, SessionState state)\n\t{\n\t\t// get the realm\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\n\t\t// get the locks\n\t\tString[] locks = data.getParameters().getStrings(\"locks\");\n\n\t\t// we are setting for either a new role or this role\n\t\tRole role = (Role) state.getAttribute(\"role\");\n\t\tif (realm != null && role == null)\n\t\t{\n\t\t\t// read the form\n\t\t\tString id = StringUtil.trimToNull(data.getParameters().getString(\"id\"));\n\n\t\t\t// if the field is missing, and there are no locks, just be done with no change\n\t\t\tif ((id == null) && (locks == null)) return true;\n\n\t\t\tif (id == null)\n\t\t\t{\n\t\t\t\taddAlert(state, rb.getString(\"realm.please\"));\n\t\t\t\treturn false;\n\t\t\t\t// TODO: would be nice to read the locks, and restore them when the form returns -ggolden\n\t\t\t}\n\n\t\t\t// create the role\n\t\t\ttry\n\t\t\t{\n\t\t\t\trole = realm.addRole(id);\n\t\t\t}\n\t\t\tcatch (RoleAlreadyDefinedException e)\n\t\t\t{\n\t\t\t\taddAlert(state, rb.getString(\"realm.arole\") + id + rb.getString(\"realm.defined\"));\n\t\t\t\treturn false;\n\t\t\t\t// TODO: would be nice to read the locks, and restore them when the form returns -ggolden\n\t\t\t}\n\t\t}\n\n\t\t// clear out the role\n\t\trole.disallowAll();\n\n\t\t// description\n\t\trole.setDescription(StringUtil.trimToNull(data.getParameters().getString(\"description\")));\n\n\t\t// providerOnly\n\t\tString providerOnlyString = (StringUtil.trimToNull(data.getParameters().getString(\"providerOnly\")));\n\t\trole.setProviderOnly(\"true\".equals(providerOnlyString));\t\t\n\n\t\t// for each lock set, give it to the role\n\t\tif (locks != null)\n\t\t{\n\t\t\tfor (int i = 0; i < locks.length; i++)\n\t\t\t{\n\t\t\t\trole.allowFunction(locks[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\n\t}","commit_id":"9c2b67aa4dfaf6273eef47bdc9c6d5b28cc4ddaf","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Build the context for the edit role mode.\n\t */\n\tprivate String buildEditRoleContext(SessionState state, Context context)\n\t{\n\t\t// name the html form for user edit fields\n\t\tcontext.put(\"form-name\", \"role-form\");\n\n\t\t// get the realm\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\tcontext.put(\"realm\", realm);\n\n\t\t// get the role\n\t\tRole role = (Role) state.getAttribute(\"role\");\n\t\tcontext.put(\"role\", role);\n\n\t\t// get all functions\n\t\tList allFunctions = FunctionManager.getRegisteredFunctions();\n\t\tCollections.sort(allFunctions);\n\t\tcontext.put(\"allLocks\", allFunctions);\n\n\t\t// get all roles\n\t\tList allRoles = new Vector();\n\t\tallRoles.addAll(realm.getRoles());\n\t\tCollections.sort(allRoles);\n\t\tcontext.put(\"allRoles\", allRoles);\n\n\t\t// build the menu\n\t\tMenu bar = new MenuImpl();\n\t\tbar.add(new MenuEntry(rb.getString(\"realm.removerol\"), null, true, MenuItem.CHECKED_NA, \"doRemove_role\"));\n\t\tbar.add(new MenuEntry(rb.getString(\"realm.copyrol\"), null, true, MenuItem.CHECKED_NA, \"doSaveas_role\", \"role-form\"));\n\t\tcontext.put(Menu.CONTEXT_MENU, bar);\n\n\t\treturn \"_edit_role\";\n\n\t}","id":102207,"modified_method":"/**\n\t * Build the context for the edit role mode.\n\t */\n\tprivate String buildEditRoleContext(SessionState state, Context context)\n\t{\n\t\t// name the html form for user edit fields\n\t\tcontext.put(\"form-name\", \"role-form\");\n\n\t\t// get the realm\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\tcontext.put(\"realm\", realm);\n\n\t\t// get the role\n\t\tRole role = (Role) state.getAttribute(\"role\");\n\t\tcontext.put(\"role\", role);\n\n\t\t// get all functions\n\t\tList allFunctions = FunctionManager.getRegisteredFunctions();\n\t\tCollections.sort(allFunctions);\n\t\tcontext.put(\"allLocks\", allFunctions);\n\n\t\t// get all roles\n\t\tList allRoles = new Vector();\n\t\tif (realm != null)\n\t\t\tallRoles.addAll(realm.getRoles());\n\t\tCollections.sort(allRoles);\n\t\tcontext.put(\"allRoles\", allRoles);\n\n\t\t// build the menu\n\t\tMenu bar = new MenuImpl();\n\t\tbar.add(new MenuEntry(rb.getString(\"realm.removerol\"), null, true, MenuItem.CHECKED_NA, \"doRemove_role\"));\n\t\tbar.add(new MenuEntry(rb.getString(\"realm.copyrol\"), null, true, MenuItem.CHECKED_NA, \"doSaveas_role\", \"role-form\"));\n\t\tcontext.put(Menu.CONTEXT_MENU, bar);\n\n\t\treturn \"_edit_role\";\n\n\t}","commit_id":"9c2b67aa4dfaf6273eef47bdc9c6d5b28cc4ddaf","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Read the user form and update the realm in state.\n\t * \n\t * @return true if the form is accepted, false if there's a validation error (an alertMessage will be set)\n\t */\n\tprivate boolean readUserForm(RunData data, SessionState state)\n\t{\n\t\t// get the role\n\t\tString roles = StringUtil.trimToNull(data.getParameters().getString(\"roles\"));\n\t\t\n\t\t//get status\n\t\tBoolean status=true;\n\t\tString checkForStatus=data.getParameters().get(\"status\");\n\t\tif (!(checkForStatus==null)){\n\t\tstatus=data.getParameters().getBoolean(\"status\");\n\t\t}\n\n\t\t// we are setting for either a new user or this user\n\t\tUser user = (User) state.getAttribute(\"user\");\n\t\tif (user == null)\n\t\t{\n\t\t\t// read the form\n\t\t\tString eid = StringUtil.trimToNull(data.getParameters().getString(\"eid\"));\n\n\t\t\t// if the field is missing, and there are no roles, just be done with no change\n\t\t\tif ((eid == null) && (roles == null)) return true;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tuser = UserDirectoryService.getUserByEid(eid);\n\t\t\t}\n\t\t\tcatch (UserNotDefinedException e)\n\t\t\t{\n\t\t\t\taddAlert(state, rb.getString(\"realm.user\"));\n\t\t\t\treturn false;\n\t\t\t\t// TODO: would be nice to read the roles, and restore them when the form returns -ggolden\n\t\t\t}\n\t\t}\n\n\t\t// get the realm\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\n\t\t// if the user is set to have the same role the user already has, do nothing\n\t\tMember grant = realm.getMember(user.getId());\n\n\t\t// if no change, change nothing\n\t\tif (roles == null && (grant == null && (checkForStatus == null) ) ) {\n\t\t    // removing this since it would cause a null pointer exception if the code got here so we think the code does not ever get here -AZ\n\t\t    //) || (grant.isProvided())))) return true;\n\t\t    return true;\n\t\t}\n\t\tif ((roles != null) && (grant != null) && (grant.getRole().getId().equals(roles) && (grant.isActive()==status)) && !grant.isProvided()) return true;\n\n\t\t// clear out this user's settings\n\t\trealm.removeMember(user.getId());\n\n\t\t// if there's a role, give it\n\t\tif (roles != null)\n\t\t{\n\t\t\t// TODO: active, provided\n\t\t\trealm.addMember(user.getId(), roles, status, false);\n\t\t}\n\n\t\treturn true;\n\n\t}","id":102208,"modified_method":"/**\n\t * Read the user form and update the realm in state.\n\t * \n\t * @return true if the form is accepted, false if there's a validation error (an alertMessage will be set)\n\t */\n\tprivate boolean readUserForm(RunData data, SessionState state)\n\t{\n\t\t// get the role\n\t\tString roles = StringUtil.trimToNull(data.getParameters().getString(\"roles\"));\n\t\t\n\t\t//get status\n\t\tBoolean status=true;\n\t\tString checkForStatus=data.getParameters().get(\"status\");\n\t\tif (!(checkForStatus==null)){\n\t\tstatus=data.getParameters().getBoolean(\"status\");\n\t\t}\n\n\t\t// we are setting for either a new user or this user\n\t\tUser user = (User) state.getAttribute(\"user\");\n\t\tif (user == null)\n\t\t{\n\t\t\t// read the form\n\t\t\tString eid = StringUtil.trimToNull(data.getParameters().getString(\"eid\"));\n\n\t\t\t// if the field is missing, and there are no roles, just be done with no change\n\t\t\tif ((eid == null) && (roles == null)) return true;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tuser = UserDirectoryService.getUserByEid(eid);\n\t\t\t}\n\t\t\tcatch (UserNotDefinedException e)\n\t\t\t{\n\t\t\t\taddAlert(state, rb.getString(\"realm.user\"));\n\t\t\t\treturn false;\n\t\t\t\t// TODO: would be nice to read the roles, and restore them when the form returns -ggolden\n\t\t\t}\n\t\t}\n\n\t\t// get the realm\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\tif (realm != null)\n\t\t{\n\t\t\t// if the user is set to have the same role the user already has, do nothing\n\t\t\tMember grant = realm.getMember(user.getId());\n\t\n\t\t\t// if no change, change nothing\n\t\t\tif (roles == null && (grant == null && (checkForStatus == null) ) ) {\n\t\t\t    // removing this since it would cause a null pointer exception if the code got here so we think the code does not ever get here -AZ\n\t\t\t    //) || (grant.isProvided())))) return true;\n\t\t\t    return true;\n\t\t\t}\n\t\t\tif ((roles != null) && (grant != null) && (grant.getRole().getId().equals(roles) && (grant.isActive()==status)) && !grant.isProvided()) return true;\n\t\n\t\t\t// clear out this user's settings\n\t\t\trealm.removeMember(user.getId());\n\t\n\t\t\t// if there's a role, give it\n\t\t\tif (roles != null)\n\t\t\t{\n\t\t\t\t// TODO: active, provided\n\t\t\t\trealm.addMember(user.getId(), roles, status, false);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\n\t}","commit_id":"9c2b67aa4dfaf6273eef47bdc9c6d5b28cc4ddaf","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Build the context for the new role mode.\n\t */\n\tprivate String buildNewRoleContext(SessionState state, Context context)\n\t{\n\t\t// name the html form for user edit fields\n\t\tcontext.put(\"form-name\", \"role-form\");\n\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\tcontext.put(\"realm\", realm);\n\n\t\t// get all functions\n\t\tList allFunctions = FunctionManager.getRegisteredFunctions();\n\t\tCollections.sort(allFunctions);\n\t\tcontext.put(\"allLocks\", allFunctions);\n\n\t\t// get all roles\n\t\tList allRoles = new Vector();\n\t\tallRoles.addAll(realm.getRoles());\n\t\tCollections.sort(allRoles);\n\t\tcontext.put(\"allRoles\", allRoles);\n\n\t\treturn \"_edit_role\";\n\n\t}","id":102209,"modified_method":"/**\n\t * Build the context for the new role mode.\n\t */\n\tprivate String buildNewRoleContext(SessionState state, Context context)\n\t{\n\t\t// name the html form for user edit fields\n\t\tcontext.put(\"form-name\", \"role-form\");\n\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\tcontext.put(\"realm\", realm);\n\n\t\t// get all functions\n\t\tList allFunctions = FunctionManager.getRegisteredFunctions();\n\t\tCollections.sort(allFunctions);\n\t\tcontext.put(\"allLocks\", allFunctions);\n\n\t\t// get all roles\n\t\tList allRoles = new Vector();\n\t\tif (realm != null)\n\t\t\tallRoles.addAll(realm.getRoles());\n\t\tCollections.sort(allRoles);\n\t\tcontext.put(\"allRoles\", allRoles);\n\n\t\treturn \"_edit_role\";\n\n\t}","commit_id":"9c2b67aa4dfaf6273eef47bdc9c6d5b28cc4ddaf","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Build the context for the edit user grant mode.\n\t */\n\tprivate String buildEditUserContext(SessionState state, Context context)\n\t{\n\t\t// name the html form for user edit fields\n\t\tcontext.put(\"form-name\", \"user-form\");\n\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\tUser user = (User) state.getAttribute(\"user\");\n\n\t\tcontext.put(\"realm\", realm);\n\t\tcontext.put(\"user\", user);\n\n\t\t// get this user's role - only if not provided\n\t\tMember grant = realm.getMember(user.getId());\n\t\tcontext.put(\"grant\", grant);\n\t\tif ((grant != null) && (!grant.isProvided()) && (grant.getRole() != null))\n\t\t{\n\t\t\tcontext.put(\"roles\", grant.getRole());\n\t\t}\n\n\t\t// get all roles\n\t\tList allRoles = new Vector();\n\t\tallRoles.addAll(realm.getRoles());\n\t\tCollections.sort(allRoles);\n\t\tcontext.put(\"allRoles\", allRoles);\n\n\t\t// build the menu\n\t\tMenu bar = new MenuImpl();\n\t\tbar.add(new MenuEntry(rb.getString(\"realm.removeall\"), null, true, MenuItem.CHECKED_NA, \"doRemove_user\"));\n\t\tcontext.put(Menu.CONTEXT_MENU, bar);\n\n\t\treturn \"_edit_user\";\n\n\t}","id":102210,"modified_method":"/**\n\t * Build the context for the edit user grant mode.\n\t */\n\tprivate String buildEditUserContext(SessionState state, Context context)\n\t{\n\t\t// name the html form for user edit fields\n\t\tcontext.put(\"form-name\", \"user-form\");\n\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\tUser user = (User) state.getAttribute(\"user\");\n\n\t\tcontext.put(\"realm\", realm);\n\t\tcontext.put(\"user\", user);\n\n\t\t// get this user's role - only if not provided\n\t\tif (realm != null)\n\t\t{\n\t\t\tMember grant = realm.getMember(user.getId());\n\t\t\tcontext.put(\"grant\", grant);\n\t\t\tif ((grant != null) && (!grant.isProvided()) && (grant.getRole() != null))\n\t\t\t{\n\t\t\t\tcontext.put(\"roles\", grant.getRole());\n\t\t\t}\n\t\t}\n\n\t\t// get all roles\n\t\tList allRoles = new Vector();\n\t\tif (realm != null)\n\t\t\tallRoles.addAll(realm.getRoles());\n\t\tCollections.sort(allRoles);\n\t\tcontext.put(\"allRoles\", allRoles);\n\n\t\t// build the menu\n\t\tMenu bar = new MenuImpl();\n\t\tbar.add(new MenuEntry(rb.getString(\"realm.removeall\"), null, true, MenuItem.CHECKED_NA, \"doRemove_user\"));\n\t\tcontext.put(Menu.CONTEXT_MENU, bar);\n\n\t\treturn \"_edit_user\";\n\n\t}","commit_id":"9c2b67aa4dfaf6273eef47bdc9c6d5b28cc4ddaf","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * doRemove_confirmed called when \"eventSubmit_doRemove_confirmed\" is in the request parameters to remove the realm\n\t */\n\tpublic void doRemove_confirmed(RunData data, Context context)\n\t{\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(((JetspeedRunData) data).getJs_peid());\n\n\t\t// get the realm\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\n\t\t// remove the realm\n\t\ttry\n\t\t{\n\t\t\tAuthzGroupService.removeAuthzGroup(realm);\n\t\t}\n\t\tcatch (AuthzPermissionException e)\n\t\t{\n\t\t\taddAlert(state, rb.getString(\"realm.notpermis2\") + \" \" + realm.getId());\n\t\t}\n\n\t\t// cleanup\n\t\tcleanState(state);\n\n\t\t// go to main mode\n\t\tstate.removeAttribute(\"mode\");\n\n\t\t// make sure auto-updates are enabled\n\t\tenableObserver(state);\n\n\t}","id":102211,"modified_method":"/**\n\t * doRemove_confirmed called when \"eventSubmit_doRemove_confirmed\" is in the request parameters to remove the realm\n\t */\n\tpublic void doRemove_confirmed(RunData data, Context context)\n\t{\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(((JetspeedRunData) data).getJs_peid());\n\n\t\t// get the realm\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\tif (realm != null)\n\t\t{\n\t\t\t// remove the realm\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAuthzGroupService.removeAuthzGroup(realm);\n\t\t\t}\n\t\t\tcatch (AuthzPermissionException e)\n\t\t\t{\n\t\t\t\taddAlert(state, rb.getString(\"realm.notpermis2\") + \" \" + realm.getId());\n\t\t\t}\n\t\n\t\t\t// cleanup\n\t\t\tcleanState(state);\n\t\n\t\t\t// go to main mode\n\t\t\tstate.removeAttribute(\"mode\");\n\t\n\t\t\t// make sure auto-updates are enabled\n\t\t\tenableObserver(state);\n\t\t}\n\n\t}","commit_id":"9c2b67aa4dfaf6273eef47bdc9c6d5b28cc4ddaf","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Build the context for the new user grant mode.\n\t */\n\tprivate String buildNewUserContext(SessionState state, Context context)\n\t{\n\t\t// name the html form for user edit fields\n\t\tcontext.put(\"form-name\", \"user-form\");\n\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\n\t\tcontext.put(\"realm\", realm);\n\n\t\t// get all roles\n\t\tList allRoles = new Vector();\n\t\tallRoles.addAll(realm.getRoles());\n\t\tCollections.sort(allRoles);\n\t\tcontext.put(\"allRoles\", allRoles);\n\n\t\treturn \"_edit_user\";\n\n\t}","id":102212,"modified_method":"/**\n\t * Build the context for the new user grant mode.\n\t */\n\tprivate String buildNewUserContext(SessionState state, Context context)\n\t{\n\t\t// name the html form for user edit fields\n\t\tcontext.put(\"form-name\", \"user-form\");\n\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\n\t\tcontext.put(\"realm\", realm);\n\n\t\t// get all roles\n\t\tList allRoles = new Vector();\n\t\tif (realm != null)\n\t\t\tallRoles.addAll(realm.getRoles());\n\t\tCollections.sort(allRoles);\n\t\tcontext.put(\"allRoles\", allRoles);\n\n\t\treturn \"_edit_user\";\n\n\t}","commit_id":"9c2b67aa4dfaf6273eef47bdc9c6d5b28cc4ddaf","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Handle a request to remove all grants to the user.\n\t */\n\tpublic void doRemove_user(RunData data, Context context)\n\t{\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(((JetspeedRunData) data).getJs_peid());\n\n\t\t// the user we are editing\n\t\tUser user = (User) state.getAttribute(\"user\");\n\n\t\t// get the realm\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\n\t\t// clear out this user's settings\n\t\trealm.removeMember(user.getId());\n\n\t\t// done with the user\n\t\tstate.removeAttribute(\"user\");\n\n\t\t// return to edit mode\n\t\tstate.setAttribute(\"mode\", \"edit\");\n\n\t}","id":102213,"modified_method":"/**\n\t * Handle a request to remove all grants to the user.\n\t */\n\tpublic void doRemove_user(RunData data, Context context)\n\t{\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(((JetspeedRunData) data).getJs_peid());\n\n\t\t// the user we are editing\n\t\tUser user = (User) state.getAttribute(\"user\");\n\n\t\t// get the realm\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\t\n\t\tif (realm != null && user != null)\n\t\t{\n\t\t\t// clear out this user's settings\n\t\t\trealm.removeMember(user.getId());\n\t\n\t\t\t// done with the user\n\t\t\tstate.removeAttribute(\"user\");\n\t\n\t\t\t// return to edit mode\n\t\t\tstate.setAttribute(\"mode\", \"edit\");\n\t\t}\n\n\t}","commit_id":"9c2b67aa4dfaf6273eef47bdc9c6d5b28cc4ddaf","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Handle a request to remove the role being edited.\n\t */\n\tpublic void doRemove_role(RunData data, Context context)\n\t{\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(((JetspeedRunData) data).getJs_peid());\n\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\tRole role = (Role) state.getAttribute(\"role\");\n\n\t\t// remove the role (no confirm)\n\t\trealm.removeRole(role.getId());\n\n\t\t// done with the role\n\t\tstate.removeAttribute(\"role\");\n\n\t\t// return to edit mode\n\t\tstate.setAttribute(\"mode\", \"edit\");\n\n\t}","id":102214,"modified_method":"/**\n\t * Handle a request to remove the role being edited.\n\t */\n\tpublic void doRemove_role(RunData data, Context context)\n\t{\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(((JetspeedRunData) data).getJs_peid());\n\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\tRole role = (Role) state.getAttribute(\"role\");\n\t\tif (realm != null && role != null)\n\t\t{\n\t\t\t// remove the role (no confirm)\n\t\t\trealm.removeRole(role.getId());\n\t\n\t\t\t// done with the role\n\t\t\tstate.removeAttribute(\"role\");\n\t\n\t\t\t// return to edit mode\n\t\t\tstate.setAttribute(\"mode\", \"edit\");\n\t\t}\n\n\t}","commit_id":"9c2b67aa4dfaf6273eef47bdc9c6d5b28cc4ddaf","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Build the context for the edit realm mode.\n\t */\n\tprivate String buildEditContext(SessionState state, Context context)\n\t{\n\t\t// get the realm to edit\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\tcontext.put(\"realm\", realm);\n\n\t\t// get the roles defined in the realm\n\t\tList roles = new Vector();\n\t\troles.addAll(realm.getRoles());\n\t\tCollections.sort(roles);\n\t\tcontext.put(\"roles\", roles);\n\n\t\t// get a list of the users who have individual grants in the realm\n\t\tList grants = new Vector();\n\t\tgrants.addAll(realm.getMembers());\n\t\tCollections.sort(grants);\n\t\tcontext.put(\"grants\", grants);\n\n\t\t// name the html form for user edit fields\n\t\tcontext.put(\"form-name\", \"realm-form\");\n\n\t\t// build the menu\n\t\t// we need the form fields for the remove...\n\t\tMenu bar = new MenuImpl();\n\t\tif (AuthzGroupService.allowRemove(realm.getId()))\n\t\t{\n\t\t\tbar.add(new MenuEntry(rb.getString(\"realm.remove\"), null, true, MenuItem.CHECKED_NA, \"doRemove\", \"realm-form\"));\n\t\t}\n\n\t\tbar.add(new MenuEntry(rb.getString(\"realm.add\"), null, true, MenuItem.CHECKED_NA, \"doNew_role\", \"realm-form\"));\n\t\tbar.add(new MenuEntry(rb.getString(\"realm.grant\"), null, true, MenuItem.CHECKED_NA, \"doNew_user\", \"realm-form\"));\n\n\t\tbar.add(new MenuEntry(rb.getString(\"realm.save\"), null, true, MenuItem.CHECKED_NA, \"doSaveas_request\", \"realm-form\"));\n\n\t\tcontext.put(Menu.CONTEXT_MENU, bar);\n\n\t\treturn \"_edit\";\n\n\t}","id":102215,"modified_method":"/**\n\t * Build the context for the edit realm mode.\n\t */\n\tprivate String buildEditContext(SessionState state, Context context)\n\t{\n\t\t// get the realm to edit\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\t\tcontext.put(\"realm\", realm);\n\n\t\t// get the roles defined in the realm\n\t\tList roles = new Vector();\n\t\troles.addAll(realm.getRoles());\n\t\tCollections.sort(roles);\n\t\tcontext.put(\"roles\", roles);\n\n\t\t// get a list of the users who have individual grants in the realm\n\t\tList grants = new Vector();\n\t\tgrants.addAll(realm.getMembers());\n\t\tCollections.sort(grants);\n\t\tcontext.put(\"grants\", grants);\n\n\t\t// name the html form for user edit fields\n\t\tcontext.put(\"form-name\", \"realm-form\");\n\n\t\t// build the menu\n\t\t// we need the form fields for the remove...\n\t\tMenu bar = new MenuImpl();\n\t\tif (realm != null && AuthzGroupService.allowRemove(realm.getId()))\n\t\t{\n\t\t\tbar.add(new MenuEntry(rb.getString(\"realm.remove\"), null, true, MenuItem.CHECKED_NA, \"doRemove\", \"realm-form\"));\n\t\t}\n\n\t\tbar.add(new MenuEntry(rb.getString(\"realm.add\"), null, true, MenuItem.CHECKED_NA, \"doNew_role\", \"realm-form\"));\n\t\tbar.add(new MenuEntry(rb.getString(\"realm.grant\"), null, true, MenuItem.CHECKED_NA, \"doNew_user\", \"realm-form\"));\n\n\t\tbar.add(new MenuEntry(rb.getString(\"realm.save\"), null, true, MenuItem.CHECKED_NA, \"doSaveas_request\", \"realm-form\"));\n\n\t\tcontext.put(Menu.CONTEXT_MENU, bar);\n\n\t\treturn \"_edit\";\n\n\t}","commit_id":"9c2b67aa4dfaf6273eef47bdc9c6d5b28cc4ddaf","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Prepare the current page of messages to display.\n\t * \n\t * @return List of MailArchiveMessage to display on this page.\n\t */\n\tprotected List prepPage(SessionState state)\n\t{\n\t\t// access the page size\n\t\tint pageSize = ((Integer) state.getAttribute(STATE_PAGESIZE)).intValue();\n\n\t\t// cleanup prior prep\n\t\tstate.removeAttribute(STATE_NUM_MESSAGES);\n\n\t\t// are we going next or prev, first or last page?\n\t\tboolean goNextPage = state.getAttribute(STATE_GO_NEXT_PAGE) != null;\n\t\tboolean goPrevPage = state.getAttribute(STATE_GO_PREV_PAGE) != null;\n\t\tboolean goFirstPage = state.getAttribute(STATE_GO_FIRST_PAGE) != null;\n\t\tboolean goLastPage = state.getAttribute(STATE_GO_LAST_PAGE) != null;\n\t\tstate.removeAttribute(STATE_GO_NEXT_PAGE);\n\t\tstate.removeAttribute(STATE_GO_PREV_PAGE);\n\t\tstate.removeAttribute(STATE_GO_FIRST_PAGE);\n\t\tstate.removeAttribute(STATE_GO_LAST_PAGE);\n\n\t\t// are we going next or prev message?\n\t\tboolean goNext = state.getAttribute(STATE_GO_NEXT) != null;\n\t\tboolean goPrev = state.getAttribute(STATE_GO_PREV) != null;\n\t\tstate.removeAttribute(STATE_GO_NEXT);\n\t\tstate.removeAttribute(STATE_GO_PREV);\n\n\t\tboolean goViewPage = state.getAttribute(STATE_GOTO_PAGE) != null;\n\n\t\t// if we have no prev page and do have a top message, then we will stay \"pined\" to the top\n\t\tboolean pinToTop = ((state.getAttribute(STATE_TOP_PAGE_MESSAGE) != null)\n\t\t\t\t&& (state.getAttribute(STATE_PREV_PAGE_EXISTS) == null) && !goNextPage && !goPrevPage && !goNext && !goPrev\n\t\t\t\t&& !goFirstPage && !goLastPage && !goViewPage);\n\n\t\t// how many messages, total\n\t\tint numMessages = sizeResources(state);\n\n\t\tif (numMessages == 0)\n\t\t{\n\t\t\treturn new Vector();\n\t\t}\n\n\t\t// set the total page number\n\t\tint totalPageNumber = 1;\n\t\tif ((numMessages % pageSize) > 0)\n\t\t{\n\t\t\ttotalPageNumber = numMessages / pageSize + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttotalPageNumber = numMessages / pageSize;\n\t\t}\n\t\tstate.setAttribute(STATE_TOTAL_PAGENUMBER, new Integer(totalPageNumber));\n\n\t\t// save the number of messges\n\t\tstate.setAttribute(STATE_NUM_MESSAGES, new Integer(numMessages));\n\n\t\t// find the position of the message that is the top first on the page\n\t\tint posStart = 0;\n\t\tInteger topPageMessage = (Integer) state.getAttribute(STATE_TOP_PAGE_MESSAGE);\n\t\tif (topPageMessage != null)\n\t\t{\n\t\t\tposStart = topPageMessage.intValue();\n\t\t}\n\n\t\t// if going to a certain page\n\t\tif (state.getAttribute(STATE_GOTO_PAGE) != null)\n\t\t{\n\t\t\tint gotoPage = ((Integer) state.getAttribute(STATE_GOTO_PAGE)).intValue();\n\t\t\tint currentPage = ((Integer) state.getAttribute(STATE_CURRENT_PAGE)).intValue();\n\t\t\tposStart += pageSize * (gotoPage - currentPage);\n\t\t}\n\n\t\t// if going to the next page, adjust\n\t\telse if (goNextPage)\n\t\t{\n\t\t\tposStart += pageSize;\n\t\t}\n\n\t\t// if going to the prev page, adjust\n\t\telse if (goPrevPage)\n\t\t{\n\t\t\tposStart -= pageSize;\n\t\t\tif (posStart < 0) posStart = 0;\n\t\t}\n\n\t\t// if going to the first page, adjust\n\t\telse if (goFirstPage)\n\t\t{\n\t\t\tposStart = 0;\n\t\t}\n\n\t\t// if going to the last page, adjust\n\t\telse if (goLastPage)\n\t\t{\n\t\t\tposStart = numMessages - pageSize;\n\t\t\tif (posStart < 0) posStart = 0;\n\t\t}\n\n\t\t// pinning\n\t\tif (pinToTop)\n\t\t{\n\t\t\tposStart = 0;\n\t\t}\n\n\t\t// compute the end to a page size, adjusted for the number of messages available\n\t\tint posEnd = posStart + (pageSize - 1);\n\t\tif (posEnd >= numMessages) posEnd = numMessages - 1;\n\t\tint numMessagesOnThisPage = (posEnd - posStart) + 1;\n\n\t\t// select the messages on this page\n\t\tList messagePage = readResourcesPage(state, posStart + 1, posEnd + 1);\n\n\t\t// save which message is at the top of the page\n\t\tstate.setAttribute(STATE_TOP_PAGE_MESSAGE, new Integer(posStart));\n\n\t\t// which message starts the next page (if any)\n\t\tint next = posStart + pageSize;\n\t\tif (next < numMessages)\n\t\t{\n\t\t\tstate.setAttribute(STATE_NEXT_PAGE_EXISTS, \"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstate.removeAttribute(STATE_NEXT_PAGE_EXISTS);\n\t\t}\n\n\t\t// which message ends the prior page (if any)\n\t\tint prev = posStart - 1;\n\t\tif (prev >= 0)\n\t\t{\n\t\t\tstate.setAttribute(STATE_PREV_PAGE_EXISTS, \"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstate.removeAttribute(STATE_PREV_PAGE_EXISTS);\n\t\t}\n\n\t\tstate.removeAttribute(STATE_FIRST_PAGE_EXISTS);\n\t\tstate.removeAttribute(STATE_LAST_PAGE_EXISTS);\n\t\tif (totalPageNumber != 1)\n\t\t{\n\t\t\tif (posStart > 0)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_FIRST_PAGE_EXISTS, \"\");\n\t\t\t}\n\t\t\tif (posStart + pageSize < numMessages)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_LAST_PAGE_EXISTS, \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (state.getAttribute(STATE_VIEW_ID) != null)\n\t\t{\n\t\t\tint viewPos = ((Integer) state.getAttribute(STATE_VIEW_ID)).intValue();\n\n\t\t\t// are we moving to the next message\n\t\t\tif (goNext)\n\t\t\t{\n\t\t\t\t// advance\n\t\t\t\tviewPos++;\n\t\t\t\tif (viewPos >= numMessages) viewPos = numMessages - 1;\n\t\t\t}\n\n\t\t\t// are we moving to the prev message\n\t\t\tif (goPrev)\n\t\t\t{\n\t\t\t\t// retreat\n\t\t\t\tviewPos--;\n\t\t\t\tif (viewPos < 0) viewPos = 0;\n\t\t\t}\n\n\t\t\t// update the view message\n\t\t\tstate.setAttribute(STATE_VIEW_ID, new Integer(viewPos));\n\n\t\t\t// if the view message is no longer on the current page, adjust the page\n\t\t\t// Note: next time through this will get processed\n\t\t\tif (viewPos < posStart)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_GO_PREV_PAGE, \"\");\n\t\t\t}\n\t\t\telse if (viewPos > posEnd)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_GO_NEXT_PAGE, \"\");\n\t\t\t}\n\n\t\t\tif (viewPos > 0)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_PREV_EXISTS, \"\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.removeAttribute(STATE_PREV_EXISTS);\n\t\t\t}\n\n\t\t\tif (viewPos < numMessages - 1)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_NEXT_EXISTS, \"\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.removeAttribute(STATE_NEXT_EXISTS);\n\t\t\t}\n\t\t}\n\n\t\tif (state.getAttribute(STATE_GOTO_PAGE) != null)\n\t\t{\n\t\t\tstate.setAttribute(STATE_CURRENT_PAGE, state.getAttribute(STATE_GOTO_PAGE));\n\t\t\tstate.removeAttribute(STATE_GOTO_PAGE);\n\t\t}\n\n\t\treturn messagePage;\n\n\t}","id":102216,"modified_method":"/**\n\t * Prepare the current page of messages to display.\n\t * \n\t * @return List of MailArchiveMessage to display on this page.\n\t */\n\tprotected List prepPage(SessionState state)\n\t{\n\t\t// access the page size\n\t\tint pageSize = state.getAttribute(STATE_PAGESIZE) != null ?\n\t\t\t\t((Integer) state.getAttribute(STATE_PAGESIZE)).intValue() : DEFAULT_PAGE_SIZE;\n\t\t\n\t\t// cleanup prior prep\n\t\tstate.removeAttribute(STATE_NUM_MESSAGES);\n\n\t\t// are we going next or prev, first or last page?\n\t\tboolean goNextPage = state.getAttribute(STATE_GO_NEXT_PAGE) != null;\n\t\tboolean goPrevPage = state.getAttribute(STATE_GO_PREV_PAGE) != null;\n\t\tboolean goFirstPage = state.getAttribute(STATE_GO_FIRST_PAGE) != null;\n\t\tboolean goLastPage = state.getAttribute(STATE_GO_LAST_PAGE) != null;\n\t\tstate.removeAttribute(STATE_GO_NEXT_PAGE);\n\t\tstate.removeAttribute(STATE_GO_PREV_PAGE);\n\t\tstate.removeAttribute(STATE_GO_FIRST_PAGE);\n\t\tstate.removeAttribute(STATE_GO_LAST_PAGE);\n\n\t\t// are we going next or prev message?\n\t\tboolean goNext = state.getAttribute(STATE_GO_NEXT) != null;\n\t\tboolean goPrev = state.getAttribute(STATE_GO_PREV) != null;\n\t\tstate.removeAttribute(STATE_GO_NEXT);\n\t\tstate.removeAttribute(STATE_GO_PREV);\n\n\t\tboolean goViewPage = state.getAttribute(STATE_GOTO_PAGE) != null;\n\n\t\t// if we have no prev page and do have a top message, then we will stay \"pined\" to the top\n\t\tboolean pinToTop = ((state.getAttribute(STATE_TOP_PAGE_MESSAGE) != null)\n\t\t\t\t&& (state.getAttribute(STATE_PREV_PAGE_EXISTS) == null) && !goNextPage && !goPrevPage && !goNext && !goPrev\n\t\t\t\t&& !goFirstPage && !goLastPage && !goViewPage);\n\n\t\t// how many messages, total\n\t\tint numMessages = sizeResources(state);\n\n\t\tif (numMessages == 0)\n\t\t{\n\t\t\treturn new Vector();\n\t\t}\n\n\t\t// set the total page number\n\t\tint totalPageNumber = 1;\n\t\tif ((numMessages % pageSize) > 0)\n\t\t{\n\t\t\ttotalPageNumber = numMessages / pageSize + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttotalPageNumber = numMessages / pageSize;\n\t\t}\n\t\tstate.setAttribute(STATE_TOTAL_PAGENUMBER, new Integer(totalPageNumber));\n\n\t\t// save the number of messges\n\t\tstate.setAttribute(STATE_NUM_MESSAGES, new Integer(numMessages));\n\n\t\t// find the position of the message that is the top first on the page\n\t\tint posStart = 0;\n\t\tInteger topPageMessage = (Integer) state.getAttribute(STATE_TOP_PAGE_MESSAGE);\n\t\tif (topPageMessage != null)\n\t\t{\n\t\t\tposStart = topPageMessage.intValue();\n\t\t}\n\n\t\t// if going to a certain page\n\t\tif (state.getAttribute(STATE_GOTO_PAGE) != null)\n\t\t{\n\t\t\tint gotoPage = ((Integer) state.getAttribute(STATE_GOTO_PAGE)).intValue();\n\t\t\tint currentPage = ((Integer) state.getAttribute(STATE_CURRENT_PAGE)).intValue();\n\t\t\tposStart += pageSize * (gotoPage - currentPage);\n\t\t}\n\n\t\t// if going to the next page, adjust\n\t\telse if (goNextPage)\n\t\t{\n\t\t\tposStart += pageSize;\n\t\t}\n\n\t\t// if going to the prev page, adjust\n\t\telse if (goPrevPage)\n\t\t{\n\t\t\tposStart -= pageSize;\n\t\t\tif (posStart < 0) posStart = 0;\n\t\t}\n\n\t\t// if going to the first page, adjust\n\t\telse if (goFirstPage)\n\t\t{\n\t\t\tposStart = 0;\n\t\t}\n\n\t\t// if going to the last page, adjust\n\t\telse if (goLastPage)\n\t\t{\n\t\t\tposStart = numMessages - pageSize;\n\t\t\tif (posStart < 0) posStart = 0;\n\t\t}\n\n\t\t// pinning\n\t\tif (pinToTop)\n\t\t{\n\t\t\tposStart = 0;\n\t\t}\n\n\t\t// compute the end to a page size, adjusted for the number of messages available\n\t\tint posEnd = posStart + (pageSize - 1);\n\t\tif (posEnd >= numMessages) posEnd = numMessages - 1;\n\t\tint numMessagesOnThisPage = (posEnd - posStart) + 1;\n\n\t\t// select the messages on this page\n\t\tList messagePage = readResourcesPage(state, posStart + 1, posEnd + 1);\n\n\t\t// save which message is at the top of the page\n\t\tstate.setAttribute(STATE_TOP_PAGE_MESSAGE, new Integer(posStart));\n\n\t\t// which message starts the next page (if any)\n\t\tint next = posStart + pageSize;\n\t\tif (next < numMessages)\n\t\t{\n\t\t\tstate.setAttribute(STATE_NEXT_PAGE_EXISTS, \"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstate.removeAttribute(STATE_NEXT_PAGE_EXISTS);\n\t\t}\n\n\t\t// which message ends the prior page (if any)\n\t\tint prev = posStart - 1;\n\t\tif (prev >= 0)\n\t\t{\n\t\t\tstate.setAttribute(STATE_PREV_PAGE_EXISTS, \"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstate.removeAttribute(STATE_PREV_PAGE_EXISTS);\n\t\t}\n\n\t\tstate.removeAttribute(STATE_FIRST_PAGE_EXISTS);\n\t\tstate.removeAttribute(STATE_LAST_PAGE_EXISTS);\n\t\tif (totalPageNumber != 1)\n\t\t{\n\t\t\tif (posStart > 0)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_FIRST_PAGE_EXISTS, \"\");\n\t\t\t}\n\t\t\tif (posStart + pageSize < numMessages)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_LAST_PAGE_EXISTS, \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (state.getAttribute(STATE_VIEW_ID) != null)\n\t\t{\n\t\t\tint viewPos = ((Integer) state.getAttribute(STATE_VIEW_ID)).intValue();\n\n\t\t\t// are we moving to the next message\n\t\t\tif (goNext)\n\t\t\t{\n\t\t\t\t// advance\n\t\t\t\tviewPos++;\n\t\t\t\tif (viewPos >= numMessages) viewPos = numMessages - 1;\n\t\t\t}\n\n\t\t\t// are we moving to the prev message\n\t\t\tif (goPrev)\n\t\t\t{\n\t\t\t\t// retreat\n\t\t\t\tviewPos--;\n\t\t\t\tif (viewPos < 0) viewPos = 0;\n\t\t\t}\n\n\t\t\t// update the view message\n\t\t\tstate.setAttribute(STATE_VIEW_ID, new Integer(viewPos));\n\n\t\t\t// if the view message is no longer on the current page, adjust the page\n\t\t\t// Note: next time through this will get processed\n\t\t\tif (viewPos < posStart)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_GO_PREV_PAGE, \"\");\n\t\t\t}\n\t\t\telse if (viewPos > posEnd)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_GO_NEXT_PAGE, \"\");\n\t\t\t}\n\n\t\t\tif (viewPos > 0)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_PREV_EXISTS, \"\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.removeAttribute(STATE_PREV_EXISTS);\n\t\t\t}\n\n\t\t\tif (viewPos < numMessages - 1)\n\t\t\t{\n\t\t\t\tstate.setAttribute(STATE_NEXT_EXISTS, \"\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.removeAttribute(STATE_NEXT_EXISTS);\n\t\t\t}\n\t\t}\n\n\t\tif (state.getAttribute(STATE_GOTO_PAGE) != null)\n\t\t{\n\t\t\tstate.setAttribute(STATE_CURRENT_PAGE, state.getAttribute(STATE_GOTO_PAGE));\n\t\t\tstate.removeAttribute(STATE_GOTO_PAGE);\n\t\t}\n\n\t\treturn messagePage;\n\n\t}","commit_id":"9eb566165c55b79210ff2630cd4a39ef0d512375","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * build the context for the Main panel\n\t * \n\t * @return (optional) template name for this panel\n\t */\n\tpublic String buildMainPanelContext(VelocityPortlet portlet, Context context, RunData rundata, SessionState state)\n\t{\n\n\t\tcontext.put(\"tlang\", rb);\n\n\t\tcontext.put(\"contentTypeImageService\", ContentTypeImageService.getInstance());\n\n\t\t// if the synoptic options have just been imported, we need to update\n\t\t// the state\n\t\tif (state.getAttribute(STATE_UPDATE) != null)\n\t\t{\n\t\t\tupdateState(state, portlet);\n\t\t\tstate.removeAttribute(STATE_UPDATE);\n\t\t}\n\n\t\t// // TODO: TIMING\n\t\t// if (CurrentService.getInThread(\"DEBUG\") == null)\n\t\t// CurrentService.setInThread(\"DEBUG\", new StringBuilder());\n\t\t// long startTime = System.currentTimeMillis();\n\n\t\t// different title of Option link for different tools.\n\t\tTool tool = ToolManager.getCurrentTool();\n\t\tcontext.put(\"toolId\", tool.getId());\n\n\t\t// handle options mode\n\t\tif (MODE_OPTIONS.equals(state.getAttribute(STATE_MODE)))\n\t\t{\n\t\t\treturn buildOptionsPanelContext(portlet, context, rundata, state);\n\t\t}\n\n\t\t// build the menu\n\t\tMenu bar = new MenuImpl(portlet, rundata, (String) state.getAttribute(STATE_ACTION));\n\n\t\t// add options if allowed\n\t\tif (!(Boolean)state.getAttribute(STATE_HIDE_OPTIONS))\n\t\t{\n\t\taddOptionsMenu(bar, (JetspeedRunData) rundata);\n\t\t}\n\t\t\n\t\t\n\t\tif (!bar.getItems().isEmpty())\n\t\t{\n\t\t\tcontext.put(Menu.CONTEXT_MENU, bar);\n\t\t}\n\n\t\tcontext.put(Menu.CONTEXT_ACTION, state.getAttribute(STATE_ACTION));\n\n\t\t// set the message length (leave as an Integer)\n\t\tcontext.put(\"length\", state.getAttribute(STATE_LENGTH));\n\n\t\t// set useSubject - true to display the message subject (else use the body)\n\t\tcontext.put(\"showSubject\", state.getAttribute(STATE_SHOW_SUBJECT));\n\n\t\t// set showBody - true to display the message body\n\t\t// message subject is always displayed for recent discussion tool - handled by vm\n\t\tcontext.put(\"showBody\", state.getAttribute(STATE_SHOW_BODY));\n\n\t\t// whether to show newlines in the message body, or not\n\t\tif (state.getAttribute(STATE_SHOW_NEWLINES) == null)\n\t\t{\n\t\t\tinitStateShowNewlines(state, portlet.getPortletConfig());\n\t\t}\n\t\tcontext.put(\"show_newlines\", ((Boolean) state.getAttribute(STATE_SHOW_NEWLINES)).toString());\n\n\t\ttry\n\t\t{\n\t\t\tMessageService service = (MessageService) state.getAttribute(STATE_SERVICE);\n\t\t\tString channelRef = (String) state.getAttribute(STATE_CHANNEL_REF);\n\t\t\tTime afterDate = (Time) state.getAttribute(STATE_AFTER_DATE);\n\t\t\tint items = ((Integer) state.getAttribute(STATE_ITEMS)).intValue();\n\n\t\t\tString serviceName = (String) state.getAttribute(STATE_SERVICE_NAME);\n\n\t\t\tList messages = retrieveMessages(service, serviceName, channelRef,afterDate, items);\n\t\t\tcontext.put(\"messages\", messages);\n\t\t}\n\t\tcatch (PermissionException e)\n\t\t{\n\t\t\taddAlert(state, rb.getString(\"youdonot\"));\n\t\t}\n\n\t\t// inform the observing courier that we just updated the page...\n\t\t// if there are pending requests to do so they can be cleared\n\t\tjustDelivered(state);\n\n\t\tString rv = (String) getContext(rundata).get(\"template\") + \"-List\";\n\n\t\t// // TODO: TIMING\n\t\t// long endTime = System.currentTimeMillis();\n\t\t// if (endTime-startTime > /*5*/000)\n\t\t// {\n\t\t// StringBuilder buf = (StringBuilder) CurrentService.getInThread(\"DEBUG\");\n\t\t// if (buf != null)\n\t\t// {\n\t\t// buf.insert(0,\"synopticMessageAction: \"\n\t\t// + state.getAttribute(STATE_CHANNEL_REF)\n\t\t// + \" time: \" + (endTime - startTime));\n\t\t// }\n\t\t// }\n\n\t\treturn rv;\n\n\t}","id":102217,"modified_method":"/**\n\t * build the context for the Main panel\n\t * \n\t * @return (optional) template name for this panel\n\t */\n\tpublic String buildMainPanelContext(VelocityPortlet portlet, Context context, RunData rundata, SessionState state)\n\t{\n\n\t\tcontext.put(\"tlang\", rb);\n\n\t\tcontext.put(\"contentTypeImageService\", ContentTypeImageService.getInstance());\n\n\t\t// if the synoptic options have just been imported, we need to update\n\t\t// the state\n\t\tif (state.getAttribute(STATE_UPDATE) != null)\n\t\t{\n\t\t\tupdateState(state, portlet);\n\t\t\tstate.removeAttribute(STATE_UPDATE);\n\t\t}\n\n\t\t// // TODO: TIMING\n\t\t// if (CurrentService.getInThread(\"DEBUG\") == null)\n\t\t// CurrentService.setInThread(\"DEBUG\", new StringBuilder());\n\t\t// long startTime = System.currentTimeMillis();\n\n\t\t// different title of Option link for different tools.\n\t\tTool tool = ToolManager.getCurrentTool();\n\t\tcontext.put(\"toolId\", tool.getId());\n\n\t\t// handle options mode\n\t\tif (MODE_OPTIONS.equals(state.getAttribute(STATE_MODE)))\n\t\t{\n\t\t\treturn buildOptionsPanelContext(portlet, context, rundata, state);\n\t\t}\n\n\t\t// build the menu\n\t\tMenu bar = new MenuImpl(portlet, rundata, (String) state.getAttribute(STATE_ACTION));\n\n\t\t// add options if allowed\n\t\tif (!(Boolean)state.getAttribute(STATE_HIDE_OPTIONS))\n\t\t{\n\t\taddOptionsMenu(bar, (JetspeedRunData) rundata);\n\t\t}\n\t\t\n\t\t\n\t\tif (!bar.getItems().isEmpty())\n\t\t{\n\t\t\tcontext.put(Menu.CONTEXT_MENU, bar);\n\t\t}\n\n\t\tcontext.put(Menu.CONTEXT_ACTION, state.getAttribute(STATE_ACTION));\n\n\t\t// set the message length (leave as an Integer)\n\t\tcontext.put(\"length\", state.getAttribute(STATE_LENGTH));\n\n\t\t// set useSubject - true to display the message subject (else use the body)\n\t\tcontext.put(\"showSubject\", state.getAttribute(STATE_SHOW_SUBJECT));\n\n\t\t// set showBody - true to display the message body\n\t\t// message subject is always displayed for recent discussion tool - handled by vm\n\t\tcontext.put(\"showBody\", state.getAttribute(STATE_SHOW_BODY));\n\n\t\t// whether to show newlines in the message body, or not\n\t\tif (state.getAttribute(STATE_SHOW_NEWLINES) == null)\n\t\t{\n\t\t\tinitStateShowNewlines(state, portlet.getPortletConfig());\n\t\t}\n\t\tcontext.put(\"show_newlines\", ((Boolean) state.getAttribute(STATE_SHOW_NEWLINES)).toString());\n\n\t\ttry\n\t\t{\n\t\t\tMessageService service = (MessageService) state.getAttribute(STATE_SERVICE);\n\t\t\tString channelRef = (String) state.getAttribute(STATE_CHANNEL_REF);\n\t\t\tTime afterDate = (Time) state.getAttribute(STATE_AFTER_DATE);\n\t\t\tint items = 3;\n\t\t\t// read the items parameter\n\t\t\tif (state.getAttribute(STATE_ITEMS) != null)\n\t\t\t{\n\t\t\t\titems = ((Integer) state.getAttribute(STATE_ITEMS)).intValue();\n\t\t\t}\n\n\t\t\tString serviceName = (String) state.getAttribute(STATE_SERVICE_NAME);\n\n\t\t\tList messages = retrieveMessages(service, serviceName, channelRef,afterDate, items);\n\t\t\tcontext.put(\"messages\", messages);\n\t\t}\n\t\tcatch (PermissionException e)\n\t\t{\n\t\t\taddAlert(state, rb.getString(\"youdonot\"));\n\t\t}\n\n\t\t// inform the observing courier that we just updated the page...\n\t\t// if there are pending requests to do so they can be cleared\n\t\tjustDelivered(state);\n\n\t\tString rv = (String) getContext(rundata).get(\"template\") + \"-List\";\n\n\t\t// // TODO: TIMING\n\t\t// long endTime = System.currentTimeMillis();\n\t\t// if (endTime-startTime > /*5*/000)\n\t\t// {\n\t\t// StringBuilder buf = (StringBuilder) CurrentService.getInThread(\"DEBUG\");\n\t\t// if (buf != null)\n\t\t// {\n\t\t// buf.insert(0,\"synopticMessageAction: \"\n\t\t// + state.getAttribute(STATE_CHANNEL_REF)\n\t\t// + \" time: \" + (endTime - startTime));\n\t\t// }\n\t\t// }\n\n\t\treturn rv;\n\n\t}","commit_id":"0e52c79e01ee027e59fd39eb5900b61fa8a1c7c6","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void saveRep(Repository rep, ObjectId id_job) throws KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"file_name\", filename);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"work_directory\", workDirectory);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"arg_from_previous\", argFromPrevious);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"exec_per_row\", execPerRow);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"set_logfile\", setLogfile);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"set_append_logfile\", setAppendLogfile);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"add_date\", addDate);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"add_time\", addTime);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"logfile\", logfile);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"logext\", logext);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"loglevel\", logFileLevel.getCode());\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"insertScript\", insertScript);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"script\", script);\r\n\t\t\t\r\n\t\t\t// save the arguments...\r\n\t\t\tif (arguments != null)\r\n\t\t\t{\r\n\t\t\t\tfor (int i = 0; i < arguments.length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), i, \"argument\", arguments[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (KettleDatabaseException dbe)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Unable to save job entry of type 'shell' to the repository\", dbe);\r\n\t\t}\r\n\t}","id":102218,"modified_method":"public void saveRep(Repository rep, ObjectId id_job) throws KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"file_name\", filename);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"work_directory\", workDirectory);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"arg_from_previous\", argFromPrevious);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"exec_per_row\", execPerRow);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"set_logfile\", setLogfile);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"set_append_logfile\", setAppendLogfile);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"add_date\", addDate);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"add_time\", addTime);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"logfile\", logfile);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"logext\", logext);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"loglevel\", logFileLevel == null ? LogLevel.NOTHING.getCode() : logFileLevel.getCode());\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"insertScript\", insertScript);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"script\", script);\r\n\t\t\t\r\n\t\t\t// save the arguments...\r\n\t\t\tif (arguments != null)\r\n\t\t\t{\r\n\t\t\t\tfor (int i = 0; i < arguments.length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), i, \"argument\", arguments[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (KettleDatabaseException dbe)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Unable to save job entry of type 'shell' to the repository\", dbe);\r\n\t\t}\r\n\t}","commit_id":"f8f2cbc461049dde262ef50b321a8de257d19877","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\n\t{\n        StringBuffer retval = new StringBuffer(200);\n\n\t\tretval.append(super.getXML());\n\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"filename\",          filename));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"jobname\",           jobname));\n\t\tif (directory!=null)\n\t\t{\n\t\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"directory\",         directory));\n\t\t}\n\t\telse\n\t\t\tif (directoryPath!=null)\n\t\t\t{\n\t\t\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"directory\",         directoryPath)); // don't loose this info (backup/recovery)\n\t\t\t}\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"arg_from_previous\", argFromPrevious));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"params_from_previous\", paramsFromPrevious));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"exec_per_row\",      execPerRow));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"set_logfile\",       setLogfile));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"logfile\",           logfile));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"logext\",            logext));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_date\",          addDate));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_time\",          addTime));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"loglevel\",          logFileLevel.getCode()));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"slave_server_name\", remoteSlaveServerName));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"wait_until_finished\",     waitingToFinish));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"follow_abort_remote\",     followingAbortRemotely));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"create_parent_folder\",     createParentFolder));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"pass_export\",     passingExport));\r\n\t\t\n\t\tif (arguments!=null)  {\n\t\t\tfor (int i=0;i<arguments.length;i++)\n\t\t\t{\r\n\t\t\t\t// This is a very very bad way of making an XML file, don't use it (or copy it). Sven Boden\n\t\t\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"argument\"+i, arguments[i]));\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (parameters!=null)  {\r\n\t\t\tretval.append(\"      \").append(XMLHandler.openTag(\"parameters\"));\r\n\t\t\t\r\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"pass_all_parameters\", passingAllParameters));\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<parameters.length;i++)\r\n\t\t\t{\r\n\t\t\t\t// This is a better way of making the XML file than the arguments.\r\n\t\t\t\tretval.append(\"            \").append(XMLHandler.openTag(\"parameter\"));\r\n\t\t\t\t\r\n\t\t\t\tretval.append(\"            \").append(XMLHandler.addTagValue(\"name\", parameters[i]));\r\n\t\t\t\tretval.append(\"            \").append(XMLHandler.addTagValue(\"stream_name\", parameterFieldNames[i]));\r\n\t\t\t\tretval.append(\"            \").append(XMLHandler.addTagValue(\"value\", parameterValues[i]));\r\n\t\t\t\t\r\n\t\t\t\tretval.append(\"            \").append(XMLHandler.closeTag(\"parameter\"));\r\n\t\t\t}\r\n\t\t\tretval.append(\"      \").append(XMLHandler.closeTag(\"parameters\"));\r\n\t\t}\t\t\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"set_append_logfile\",     setAppendLogfile));\r\n\t\t\r\n\t\t\n\t\treturn retval.toString();\n\t}","id":102219,"modified_method":"public String getXML()\n\t{\n        StringBuffer retval = new StringBuffer(200);\n\n\t\tretval.append(super.getXML());\n\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"filename\",          filename));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"jobname\",           jobname));\n\t\tif (directory!=null)\n\t\t{\n\t\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"directory\",         directory));\n\t\t}\n\t\telse\n\t\t\tif (directoryPath!=null)\n\t\t\t{\n\t\t\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"directory\",         directoryPath)); // don't loose this info (backup/recovery)\n\t\t\t}\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"arg_from_previous\", argFromPrevious));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"params_from_previous\", paramsFromPrevious));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"exec_per_row\",      execPerRow));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"set_logfile\",       setLogfile));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"logfile\",           logfile));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"logext\",            logext));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_date\",          addDate));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_time\",          addTime));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"loglevel\",          logFileLevel != null ? logFileLevel.getCode() : DEFAULT_LOG_LEVEL.getCode()));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"slave_server_name\", remoteSlaveServerName));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"wait_until_finished\",     waitingToFinish));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"follow_abort_remote\",     followingAbortRemotely));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"create_parent_folder\",     createParentFolder));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"pass_export\",     passingExport));\r\n\t\t\n\t\tif (arguments!=null)  {\n\t\t\tfor (int i=0;i<arguments.length;i++)\n\t\t\t{\r\n\t\t\t\t// This is a very very bad way of making an XML file, don't use it (or copy it). Sven Boden\n\t\t\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"argument\"+i, arguments[i]));\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (parameters!=null)  {\r\n\t\t\tretval.append(\"      \").append(XMLHandler.openTag(\"parameters\"));\r\n\t\t\t\r\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"pass_all_parameters\", passingAllParameters));\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<parameters.length;i++)\r\n\t\t\t{\r\n\t\t\t\t// This is a better way of making the XML file than the arguments.\r\n\t\t\t\tretval.append(\"            \").append(XMLHandler.openTag(\"parameter\"));\r\n\t\t\t\t\r\n\t\t\t\tretval.append(\"            \").append(XMLHandler.addTagValue(\"name\", parameters[i]));\r\n\t\t\t\tretval.append(\"            \").append(XMLHandler.addTagValue(\"stream_name\", parameterFieldNames[i]));\r\n\t\t\t\tretval.append(\"            \").append(XMLHandler.addTagValue(\"value\", parameterValues[i]));\r\n\t\t\t\t\r\n\t\t\t\tretval.append(\"            \").append(XMLHandler.closeTag(\"parameter\"));\r\n\t\t\t}\r\n\t\t\tretval.append(\"      \").append(XMLHandler.closeTag(\"parameters\"));\r\n\t\t}\t\t\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"set_append_logfile\",     setAppendLogfile));\r\n\t\t\r\n\t\t\n\t\treturn retval.toString();\n\t}","commit_id":"05005df6696dcc5d9dfd87f5c02789164b6440bd","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, ObjectId id_job) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tRepositoryDirectory importLocation = RepositoryImportLocation.getRepositoryImportLocation();\r\n\t\t\t\r\n\t\t\tif (importLocation!=null && !importLocation.isRoot()) {\r\n\t\t\t\tdirectory = importLocation.getPath() + directoryPath;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (directory == null) {\r\n\t\t\t\tif (importLocation!=null) {\r\n\t\t\t\t\tdirectory = importLocation.getPath();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdirectory = new RepositoryDirectory().getPath(); // just pick the root directory\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Removed id_job as we do not know what it is if we are using variables in the path\n\t\t\t//\tlong id_job_attr = rep.getJobID(jobname, directory.getID());\n\t\t\t// rep.saveJobEntryAttribute(id_job, getID(), \"id_job\", id_job_attr);\r\n\t\t\t\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"name\", getJobName());\n      \t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"dir_path\", getDirectory()!=null?getDirectory():\"\");\n      \t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"file_name\", filename);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"arg_from_previous\", argFromPrevious);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"params_from_previous\", paramsFromPrevious);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"exec_per_row\", execPerRow);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"set_logfile\", setLogfile);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"add_date\", addDate);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"add_time\", addTime);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"logfile\", logfile);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"logext\", logext);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"set_append_logfile\", setAppendLogfile);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"loglevel\", logFileLevel.getCode());\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"slave_server_name\", remoteSlaveServerName);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"pass_export\", passingExport);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"wait_until_finished\", waitingToFinish);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"follow_abort_remote\", followingAbortRemotely);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"create_parent_folder\", createParentFolder);\r\n\n\t\t\t// save the arguments...\n\t\t\tif (arguments!=null)\n\t\t\t{\n\t\t\t\tfor (int i=0;i<arguments.length;i++)\n\t\t\t\t{\n\t\t\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), i, \"argument\", arguments[i]);\n\t\t\t\t}\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// save the parameters...\r\n\t\t\tif (parameters!=null)\r\n\t\t\t{\r\n\t\t\t\tfor (int i=0;i<parameters.length;i++)\r\n\t\t\t\t{\r\n\t\t\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), i, \"parameter_name\", parameters[i]);\r\n\t\t\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), i, \"parameter_stream_name\", Const.NVL(parameterFieldNames[i], \"\"));\r\n\t\t\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), i, \"parameter_value\", Const.NVL(parameterValues[i], \"\"));\r\n\t\t\t\t}\r\n\t\t\t}\t\t\r\n\t\t\t\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"pass_all_parameters\", passingAllParameters);\n\t\t}\n\t\tcatch(KettleDatabaseException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to save job entry of type job to the repository with id_job=\"+id_job, dbe);\n\t\t}\n\t}","id":102220,"modified_method":"public void saveRep(Repository rep, ObjectId id_job) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tRepositoryDirectory importLocation = RepositoryImportLocation.getRepositoryImportLocation();\r\n\t\t\t\r\n\t\t\tif (importLocation!=null && !importLocation.isRoot()) {\r\n\t\t\t\tdirectory = importLocation.getPath() + directoryPath;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (directory == null) {\r\n\t\t\t\tif (importLocation!=null) {\r\n\t\t\t\t\tdirectory = importLocation.getPath();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdirectory = new RepositoryDirectory().getPath(); // just pick the root directory\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Removed id_job as we do not know what it is if we are using variables in the path\n\t\t\t//\tlong id_job_attr = rep.getJobID(jobname, directory.getID());\n\t\t\t// rep.saveJobEntryAttribute(id_job, getID(), \"id_job\", id_job_attr);\r\n\t\t\t\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"name\", getJobName());\n      \t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"dir_path\", getDirectory()!=null?getDirectory():\"\");\n      \t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"file_name\", filename);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"arg_from_previous\", argFromPrevious);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"params_from_previous\", paramsFromPrevious);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"exec_per_row\", execPerRow);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"set_logfile\", setLogfile);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"add_date\", addDate);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"add_time\", addTime);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"logfile\", logfile);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"logext\", logext);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"set_append_logfile\", setAppendLogfile);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"loglevel\", logFileLevel != null ? logFileLevel.getCode() : JobEntryJob.DEFAULT_LOG_LEVEL.getCode());\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"slave_server_name\", remoteSlaveServerName);\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"pass_export\", passingExport);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"wait_until_finished\", waitingToFinish);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"follow_abort_remote\", followingAbortRemotely);\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"create_parent_folder\", createParentFolder);\r\n\n\t\t\t// save the arguments...\n\t\t\tif (arguments!=null)\n\t\t\t{\n\t\t\t\tfor (int i=0;i<arguments.length;i++)\n\t\t\t\t{\n\t\t\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), i, \"argument\", arguments[i]);\n\t\t\t\t}\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// save the parameters...\r\n\t\t\tif (parameters!=null)\r\n\t\t\t{\r\n\t\t\t\tfor (int i=0;i<parameters.length;i++)\r\n\t\t\t\t{\r\n\t\t\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), i, \"parameter_name\", parameters[i]);\r\n\t\t\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), i, \"parameter_stream_name\", Const.NVL(parameterFieldNames[i], \"\"));\r\n\t\t\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), i, \"parameter_value\", Const.NVL(parameterValues[i], \"\"));\r\n\t\t\t\t}\r\n\t\t\t}\t\t\r\n\t\t\t\r\n\t\t\trep.saveJobEntryAttribute(id_job, getObjectId(), \"pass_all_parameters\", passingAllParameters);\n\t\t}\n\t\tcatch(KettleDatabaseException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to save job entry of type job to the repository with id_job=\"+id_job, dbe);\n\t\t}\n\t}","commit_id":"05005df6696dcc5d9dfd87f5c02789164b6440bd","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"protected void pickFileVFS() {\r\n\t\t\r\n\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\r\n\t\tdialog.setFilterExtensions(Const.STRING_TRANS_FILTER_EXT);\r\n\t\tdialog.setFilterNames(Const.getJobFilterNames());\r\n\t\tString prevName = jobMeta.environmentSubstitute(wFilename.getText());\r\n\t\tString parentFolder = null;\r\n\t\ttry {\r\n\t\t\tparentFolder = KettleVFS.getFilename( KettleVFS.getFileObject(jobMeta.environmentSubstitute(jobMeta.getFilename())).getParent() );\r\n\t\t} catch(Exception e) {\r\n\t\t\t// not that important\r\n\t\t}\r\n\t\tif (!Const.isEmpty(prevName)) {\r\n\t\t\ttry {\r\n\t\t\t\tif (KettleVFS.fileExists(prevName)) {\r\n\t\t\t\t\tdialog.setFilterPath(KettleVFS.getFilename( KettleVFS.getFileObject(prevName).getParent() ));\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif (!prevName.endsWith(\".kjb\")) {\r\n\t\t\t\t\t\tprevName = \"${\"+Const.INTERNAL_VARIABLE_JOB_FILENAME_DIRECTORY+\"}/\"+Const.trim(wFilename.getText())+\".kjb\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (KettleVFS.fileExists(prevName)) {\r\n\t\t\t\t\t\twFilename.setText(prevName);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// File specified doesn't exist.  Ask if we should create the file...\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.YES | SWT.NO | SWT.ICON_QUESTION);\r\n\t\t\t\t\t\tmb.setMessage(BaseMessages.getString(PKG, \"JobJob.Dialog.CreateJobQuestion.Message\"));\r\n\t\t\t\t\t\tmb.setText(BaseMessages.getString(PKG, \"JobJob.Dialog.CreateJobQuestion.Title\")); // Sorry!\r\n\t\t\t\t\t\tint answer = mb.open();\r\n\t\t\t\t\t\tif (answer == SWT.YES) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tSpoon spoon = Spoon.getInstance();\r\n\t\t\t\t\t\t\tspoon.newJobFile();\r\n\t\t\t\t\t\t\tJobMeta newJobMeta = spoon.getActiveJob();\r\n\t\t\t\t\t\t\tnewJobMeta.initializeVariablesFrom(jobEntry);\r\n\t\t\t\t\t\t\tnewJobMeta.setFilename(jobMeta.environmentSubstitute(prevName));\r\n\t\t\t\t\t\t\twFilename.setText(prevName);\r\n\t\t\t\t\t\t\tspoon.saveFile();\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch(Exception e) {\r\n\t\t\t\tdialog.setFilterPath(parentFolder);\r\n\t\t\t}\r\n\t\t} else if (!Const.isEmpty(parentFolder)) {\r\n\t\t\tdialog.setFilterPath(parentFolder);\r\n\t\t}\r\n\t\t\r\n\t\tString fname = dialog.open();\r\n\t\tif (fname != null) {\r\n\t\t\tFile file = new File(fname);\r\n\t\t\tString name = file.getName();\r\n\t\t\tString parentFolderSelection = file.getParentFile().toString();\r\n\t\t\t\r\n\t\t\tif (!Const.isEmpty(parentFolder) && parentFolder.equals(parentFolderSelection)) {\r\n\t\t\t\twFilename.setText(\"${\"+Const.INTERNAL_VARIABLE_JOB_FILENAME_DIRECTORY+\"}/\"+name);\r\n\t\t\t} else {\r\n\t\t\t\twFilename.setText(fname);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t}","id":102221,"modified_method":"protected void pickFileVFS() {\r\n\t\t\r\n\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\r\n\t\tdialog.setFilterExtensions(Const.STRING_JOB_FILTER_EXT);\r\n\t\tdialog.setFilterNames(Const.getJobFilterNames());\r\n\t\tString prevName = jobMeta.environmentSubstitute(wFilename.getText());\r\n\t\tString parentFolder = null;\r\n\t\ttry {\r\n\t\t\tparentFolder = KettleVFS.getFilename( KettleVFS.getFileObject(jobMeta.environmentSubstitute(jobMeta.getFilename())).getParent() );\r\n\t\t} catch(Exception e) {\r\n\t\t\t// not that important\r\n\t\t}\r\n\t\tif (!Const.isEmpty(prevName)) {\r\n\t\t\ttry {\r\n\t\t\t\tif (KettleVFS.fileExists(prevName)) {\r\n\t\t\t\t\tdialog.setFilterPath(KettleVFS.getFilename( KettleVFS.getFileObject(prevName).getParent() ));\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif (!prevName.endsWith(\".kjb\")) {\r\n\t\t\t\t\t\tprevName = \"${\"+Const.INTERNAL_VARIABLE_JOB_FILENAME_DIRECTORY+\"}/\"+Const.trim(wFilename.getText())+\".kjb\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (KettleVFS.fileExists(prevName)) {\r\n\t\t\t\t\t\twFilename.setText(prevName);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// File specified doesn't exist.  Ask if we should create the file...\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.YES | SWT.NO | SWT.ICON_QUESTION);\r\n\t\t\t\t\t\tmb.setMessage(BaseMessages.getString(PKG, \"JobJob.Dialog.CreateJobQuestion.Message\"));\r\n\t\t\t\t\t\tmb.setText(BaseMessages.getString(PKG, \"JobJob.Dialog.CreateJobQuestion.Title\")); // Sorry!\r\n\t\t\t\t\t\tint answer = mb.open();\r\n\t\t\t\t\t\tif (answer == SWT.YES) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tSpoon spoon = Spoon.getInstance();\r\n\t\t\t\t\t\t\tspoon.newJobFile();\r\n\t\t\t\t\t\t\tJobMeta newJobMeta = spoon.getActiveJob();\r\n\t\t\t\t\t\t\tnewJobMeta.initializeVariablesFrom(jobEntry);\r\n\t\t\t\t\t\t\tnewJobMeta.setFilename(jobMeta.environmentSubstitute(prevName));\r\n\t\t\t\t\t\t\twFilename.setText(prevName);\r\n\t\t\t\t\t\t\tspoon.saveFile();\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch(Exception e) {\r\n\t\t\t\tdialog.setFilterPath(parentFolder);\r\n\t\t\t}\r\n\t\t} else if (!Const.isEmpty(parentFolder)) {\r\n\t\t\tdialog.setFilterPath(parentFolder);\r\n\t\t}\r\n\t\t\r\n\t\tString fname = dialog.open();\r\n\t\tif (fname != null) {\r\n\t\t\tFile file = new File(fname);\r\n\t\t\tString name = file.getName();\r\n\t\t\tString parentFolderSelection = file.getParentFile().toString();\r\n\t\t\t\r\n\t\t\tif (!Const.isEmpty(parentFolder) && parentFolder.equals(parentFolderSelection)) {\r\n\t\t\t\twFilename.setText(\"${\"+Const.INTERNAL_VARIABLE_JOB_FILENAME_DIRECTORY+\"}/\"+name);\r\n\t\t\t} else {\r\n\t\t\t\twFilename.setText(fname);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t}","commit_id":"05005df6696dcc5d9dfd87f5c02789164b6440bd","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void getData()\n\t{\n    wName.setText(Const.NVL(jobEntry.getName(), \"\"));\r\n    \r\n    if (!Const.isEmpty(jobEntry.getFilename())) {\r\n      // Run a job by filename\r\n      //\r\n      wFilename.setText(jobEntry.getFilename());\r\n      radioFilename.setSelection(true);\r\n      radioByName.setSelection(false);\r\n      radioByReference.setSelection(false);\r\n    } else {\r\n      // Run a job by name in the repository\r\n      //\r\n  \t\tif (jobEntry.getDirectory() != null) {\n  \t\t\twDirectory.setText(jobEntry.getDirectory());\r\n  \t\t}\n  \t\twJobname.setText(Const.NVL(jobEntry.getJobName(), \"\"));\r\n      radioFilename.setSelection(false);\r\n      radioByName.setSelection(true);\r\n      radioByReference.setSelection(false);\r\n    }\n\t\t\r\n\t\t// Arguments\n\t\tif (jobEntry.arguments != null)\n\t\t{\n\t\t\tfor (int i = 0; i < jobEntry.arguments.length; i++)\n\t\t\t{\n\t\t\t\tTableItem ti = wFields.table.getItem(i);\n\t\t\t\tif (jobEntry.arguments[i] != null)\n\t\t\t\t\tti.setText(1, jobEntry.arguments[i]);\n\t\t\t}\n\t\t\twFields.setRowNums();\n\t\t\twFields.optWidth(true);\n\t\t}\r\n\r\n\t\t// Parameters\r\n\t\tif (jobEntry.parameters != null)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < jobEntry.parameters.length; i++)\r\n\t\t\t{\r\n\t\t\t\tTableItem ti = wParameters.table.getItem(i);\r\n\t\t\t\tif (! Const.isEmpty(jobEntry.parameters[i]) )  {\r\n\t\t\t\t\tti.setText(1, Const.NVL(jobEntry.parameters[i], \"\"));\r\n\t\t\t\t\tti.setText(2, Const.NVL(jobEntry.parameterFieldNames[i], \"\"));\r\n\t\t\t\t\tti.setText(3, Const.NVL(jobEntry.parameterValues[i], \"\"));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twParameters.setRowNums();\r\n\t\t\twParameters.optWidth(true);\r\n\t\t}\t\r\n\t\t\r\n\t\twPassParams.setSelection(jobEntry.isPassingAllParameters());\r\n\t\t\n\t\twPrevious.setSelection(jobEntry.argFromPrevious);\r\n\t\twPrevToParams.setSelection(jobEntry.paramsFromPrevious);\n\t\twSetLogfile.setSelection(jobEntry.setLogfile);\n\t\tif (jobEntry.logfile != null)\n\t\t\twLogfile.setText(jobEntry.logfile);\n\t\tif (jobEntry.logext != null)\n\t\t\twLogext.setText(jobEntry.logext);\n\t\twAddDate.setSelection(jobEntry.addDate);\n\t\twAddTime.setSelection(jobEntry.addTime);\n\t\t\n\t\tif (jobEntry.getRemoteSlaveServerName()!=null)\n\t\t{\n\t\t\twSlaveServer.setText(jobEntry.getRemoteSlaveServerName());\n\t\t}\r\n\t\twPassExport.setSelection(jobEntry.isPassingExport());\n\n\t\twLoglevel.select(jobEntry.logFileLevel.getLevel());\r\n\t\twAppendLogfile.setSelection(jobEntry.setAppendLogfile);\r\n\t    wCreateParentFolder.setSelection(jobEntry.createParentFolder);\r\n\t\twWaitingToFinish.setSelection(jobEntry.isWaitingToFinish());\n\t\twFollowingAbortRemotely.setSelection(jobEntry.isFollowingAbortRemotely());\r\n\t}","id":102222,"modified_method":"public void getData()\n\t{\n    wName.setText(Const.NVL(jobEntry.getName(), \"\"));\r\n    \r\n    if (!Const.isEmpty(jobEntry.getFilename())) {\r\n      // Run a job by filename\r\n      //\r\n      wFilename.setText(jobEntry.getFilename());\r\n      radioFilename.setSelection(true);\r\n      radioByName.setSelection(false);\r\n      radioByReference.setSelection(false);\r\n    } else {\r\n      // Run a job by name in the repository\r\n      //\r\n  \t\tif (jobEntry.getDirectory() != null) {\n  \t\t\twDirectory.setText(jobEntry.getDirectory());\r\n  \t\t}\n  \t\twJobname.setText(Const.NVL(jobEntry.getJobName(), \"\"));\r\n      radioFilename.setSelection(false);\r\n      radioByName.setSelection(true);\r\n      radioByReference.setSelection(false);\r\n    }\n\t\t\r\n\t\t// Arguments\n\t\tif (jobEntry.arguments != null)\n\t\t{\n\t\t\tfor (int i = 0; i < jobEntry.arguments.length; i++)\n\t\t\t{\n\t\t\t\tTableItem ti = wFields.table.getItem(i);\n\t\t\t\tif (jobEntry.arguments[i] != null)\n\t\t\t\t\tti.setText(1, jobEntry.arguments[i]);\n\t\t\t}\n\t\t\twFields.setRowNums();\n\t\t\twFields.optWidth(true);\n\t\t}\r\n\r\n\t\t// Parameters\r\n\t\tif (jobEntry.parameters != null)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < jobEntry.parameters.length; i++)\r\n\t\t\t{\r\n\t\t\t\tTableItem ti = wParameters.table.getItem(i);\r\n\t\t\t\tif (! Const.isEmpty(jobEntry.parameters[i]) )  {\r\n\t\t\t\t\tti.setText(1, Const.NVL(jobEntry.parameters[i], \"\"));\r\n\t\t\t\t\tti.setText(2, Const.NVL(jobEntry.parameterFieldNames[i], \"\"));\r\n\t\t\t\t\tti.setText(3, Const.NVL(jobEntry.parameterValues[i], \"\"));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twParameters.setRowNums();\r\n\t\t\twParameters.optWidth(true);\r\n\t\t}\t\r\n\t\t\r\n\t\twPassParams.setSelection(jobEntry.isPassingAllParameters());\r\n\t\t\n\t\twPrevious.setSelection(jobEntry.argFromPrevious);\r\n\t\twPrevToParams.setSelection(jobEntry.paramsFromPrevious);\n\t\twSetLogfile.setSelection(jobEntry.setLogfile);\n\t\tif (jobEntry.logfile != null)\n\t\t\twLogfile.setText(jobEntry.logfile);\n\t\tif (jobEntry.logext != null)\n\t\t\twLogext.setText(jobEntry.logext);\n\t\twAddDate.setSelection(jobEntry.addDate);\n\t\twAddTime.setSelection(jobEntry.addTime);\n\t\t\n\t\tif (jobEntry.getRemoteSlaveServerName()!=null)\n\t\t{\n\t\t\twSlaveServer.setText(jobEntry.getRemoteSlaveServerName());\n\t\t}\r\n\t\twPassExport.setSelection(jobEntry.isPassingExport());\n\r\n\t\tif(jobEntry.logFileLevel != null) {\n\t\t  wLoglevel.select(jobEntry.logFileLevel.getLevel());\r\n\t\t} else {\r\n\t\t  // Set the default log level\r\n\t\t  wLoglevel.select(JobEntryJob.DEFAULT_LOG_LEVEL.getLevel());\r\n\t\t}\r\n\t\twAppendLogfile.setSelection(jobEntry.setAppendLogfile);\r\n\t    wCreateParentFolder.setSelection(jobEntry.createParentFolder);\r\n\t\twWaitingToFinish.setSelection(jobEntry.isWaitingToFinish());\n\t\twFollowingAbortRemotely.setSelection(jobEntry.isFollowingAbortRemotely());\r\n\t}","commit_id":"05005df6696dcc5d9dfd87f5c02789164b6440bd","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n\tpublic void postProcessPortletPreferences(\n\t\t\tlong companyId, PortletRequest portletRequest,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromAddress\",\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tAssetPublisherUtil.getEmailFromAddress(\n\t\t\t\t\tportletPreferences, companyId)));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromName\",\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tAssetPublisherUtil.getEmailFromName(\n\t\t\t\t\tportletPreferences, companyId)));\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getSiteDefault());\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailAssetEntryAddedBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(\n\t\t\t\tPropsValues.ASSET_PUBLISHER_EMAIL_ASSET_ENTRY_ADDED_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailAssetEntryAddedSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(\n\t\t\t\tPropsValues.ASSET_PUBLISHER_EMAIL_ASSET_ENTRY_ADDED_SUBJECT));\n\t}","id":102223,"modified_method":"@Override\n\tpublic void postProcessPortletPreferences(\n\t\t\tlong companyId, PortletRequest portletRequest,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromAddress\",\n\t\t\tAssetPublisherUtil.getEmailFromAddress(\n\t\t\t\tportletPreferences, companyId));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromName\",\n\t\t\tAssetPublisherUtil.getEmailFromName(portletPreferences, companyId));\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getSiteDefault());\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailAssetEntryAddedBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(\n\t\t\t\tPropsValues.ASSET_PUBLISHER_EMAIL_ASSET_ENTRY_ADDED_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailAssetEntryAddedSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(\n\t\t\t\tPropsValues.ASSET_PUBLISHER_EMAIL_ASSET_ENTRY_ADDED_SUBJECT));\n\t}","commit_id":"f08af4a7447add5906ae26743023f8887bb9a5e5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void postProcessPortletPreferences(\n\t\t\tlong companyId, PortletRequest portletRequest,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromAddress\",\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tLoginUtil.getEmailFromName(portletPreferences, companyId)));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromName\",\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tLoginUtil.getEmailFromName(portletPreferences, companyId)));\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getSiteDefault());\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailPasswordResetBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.ADMIN_EMAIL_PASSWORD_RESET_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailPasswordResetSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.ADMIN_EMAIL_PASSWORD_RESET_SUBJECT));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailPasswordSentBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.ADMIN_EMAIL_PASSWORD_SENT_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailPasswordSentSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.ADMIN_EMAIL_PASSWORD_SENT_SUBJECT));\n\t}","id":102224,"modified_method":"@Override\n\tpublic void postProcessPortletPreferences(\n\t\t\tlong companyId, PortletRequest portletRequest,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromAddress\",\n\t\t\tLoginUtil.getEmailFromName(portletPreferences, companyId));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromName\",\n\t\t\tLoginUtil.getEmailFromName(portletPreferences, companyId));\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getSiteDefault());\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailPasswordResetBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.ADMIN_EMAIL_PASSWORD_RESET_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailPasswordResetSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.ADMIN_EMAIL_PASSWORD_RESET_SUBJECT));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailPasswordSentBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.ADMIN_EMAIL_PASSWORD_SENT_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailPasswordSentSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.ADMIN_EMAIL_PASSWORD_SENT_SUBJECT));\n\t}","commit_id":"f08af4a7447add5906ae26743023f8887bb9a5e5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void postProcessPortletPreferences(\n\t\t\tlong companyId, PortletRequest portletRequest,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromAddress\",\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tBlogsUtil.getEmailFromAddress(portletPreferences, companyId)));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromName\",\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tBlogsUtil.getEmailFromName(portletPreferences, companyId)));\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getSiteDefault());\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryAddedBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BLOGS_EMAIL_ENTRY_ADDED_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryAddedSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BLOGS_EMAIL_ENTRY_ADDED_SUBJECT));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryUpdatedBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BLOGS_EMAIL_ENTRY_UPDATED_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryUpdatedSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BLOGS_EMAIL_ENTRY_UPDATED_SUBJECT));\n\t}","id":102225,"modified_method":"@Override\n\tpublic void postProcessPortletPreferences(\n\t\t\tlong companyId, PortletRequest portletRequest,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromAddress\",\n\t\t\tBlogsUtil.getEmailFromAddress(portletPreferences, companyId));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromName\",\n\t\t\tBlogsUtil.getEmailFromName(portletPreferences, companyId));\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getSiteDefault());\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryAddedBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BLOGS_EMAIL_ENTRY_ADDED_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryAddedSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BLOGS_EMAIL_ENTRY_ADDED_SUBJECT));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryUpdatedBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BLOGS_EMAIL_ENTRY_UPDATED_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryUpdatedSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BLOGS_EMAIL_ENTRY_UPDATED_SUBJECT));\n\t}","commit_id":"f08af4a7447add5906ae26743023f8887bb9a5e5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void postProcessPortletPreferences(\n\t\t\tlong companyId, PortletRequest portletRequest,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromAddress\",\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tBookmarksUtil.getEmailFromAddress(\n\t\t\t\t\tportletPreferences, companyId)));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromName\",\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tBookmarksUtil.getEmailFromName(portletPreferences, companyId)));\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getSiteDefault());\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryAddedBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BOOKMARKS_EMAIL_ENTRY_ADDED_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryAddedSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BOOKMARKS_EMAIL_ENTRY_ADDED_SUBJECT));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryUpdatedBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BOOKMARKS_EMAIL_ENTRY_UPDATED_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryUpdatedSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BOOKMARKS_EMAIL_ENTRY_UPDATED_SUBJECT));\n\t}","id":102226,"modified_method":"@Override\n\tpublic void postProcessPortletPreferences(\n\t\t\tlong companyId, PortletRequest portletRequest,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromAddress\",\n\t\t\tBookmarksUtil.getEmailFromAddress(portletPreferences, companyId));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromName\",\n\t\t\tBookmarksUtil.getEmailFromName(portletPreferences, companyId));\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getSiteDefault());\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryAddedBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BOOKMARKS_EMAIL_ENTRY_ADDED_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryAddedSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BOOKMARKS_EMAIL_ENTRY_ADDED_SUBJECT));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryUpdatedBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BOOKMARKS_EMAIL_ENTRY_UPDATED_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailEntryUpdatedSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.BOOKMARKS_EMAIL_ENTRY_UPDATED_SUBJECT));\n\t}","commit_id":"f08af4a7447add5906ae26743023f8887bb9a5e5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void postProcessPortletPreferences(\n\t\t\tlong companyId, PortletRequest portletRequest,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromAddress\",\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tDLUtil.getEmailFromAddress(portletPreferences, companyId)));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromName\",\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tDLUtil.getEmailFromName(portletPreferences, companyId)));\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getSiteDefault());\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailFileEntryAddedBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.DL_EMAIL_FILE_ENTRY_ADDED_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailFileEntryAddedSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.DL_EMAIL_FILE_ENTRY_ADDED_SUBJECT));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailFileEntryUpdatedBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.DL_EMAIL_FILE_ENTRY_UPDATED_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailFileEntryUpdatedSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.DL_EMAIL_FILE_ENTRY_UPDATED_SUBJECT));\n\t}","id":102227,"modified_method":"@Override\n\tpublic void postProcessPortletPreferences(\n\t\t\tlong companyId, PortletRequest portletRequest,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromAddress\",\n\t\t\tDLUtil.getEmailFromAddress(portletPreferences, companyId));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences, \"emailFromName\",\n\t\t\tDLUtil.getEmailFromName(portletPreferences, companyId));\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(\n\t\t\tLocaleUtil.getSiteDefault());\n\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailFileEntryAddedBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.DL_EMAIL_FILE_ENTRY_ADDED_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailFileEntryAddedSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.DL_EMAIL_FILE_ENTRY_ADDED_SUBJECT));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailFileEntryUpdatedBody_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.DL_EMAIL_FILE_ENTRY_UPDATED_BODY));\n\t\tremoveDefaultValue(\n\t\t\tportletRequest, portletPreferences,\n\t\t\t\"emailFileEntryUpdatedSubject_\" + defaultLanguageId,\n\t\t\tContentUtil.get(PropsValues.DL_EMAIL_FILE_ENTRY_UPDATED_SUBJECT));\n\t}","commit_id":"f08af4a7447add5906ae26743023f8887bb9a5e5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void visitNewExpression(PsiNewExpression expression) {\n    startElement(expression);\n\n    PsiExpression[] params = expression.getArgumentList().getExpressions();\n    for (PsiExpression param : params) {\n      param.accept(this);\n    }\n\n    pushUnknown();\n    addInstruction(new MethodCallInstruction(expression, myFactory));\n\n    if (myCatchStack.size() > 0) {\n      addMethodThrows(expression.resolveConstructor());\n    }\n\n    finishElement(expression);\n  }","id":102228,"modified_method":"public void visitNewExpression(PsiNewExpression expression) {\n    startElement(expression);\n\n    final PsiExpressionList args = expression.getArgumentList();\n    if (args != null) {\n      PsiExpression[] params = args.getExpressions();\n      for (PsiExpression param : params) {\n        param.accept(this);\n      }\n    }\n\n    pushUnknown();\n    addInstruction(new MethodCallInstruction(expression, myFactory));\n\n    if (myCatchStack.size() > 0) {\n      addMethodThrows(expression.resolveConstructor());\n    }\n\n    finishElement(expression);\n  }","commit_id":"c8e56b1c72d36484ef170db449ad12b7fe35908d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MethodCallInstruction(PsiCallExpression call, DfaValueFactory factory) {\n    myCall = call;\n    myFactory = factory;\n    final PsiMethod callee = call.resolveMethod();\n    final PsiExpression[] args = myCall.getArgumentList().getExpressions();\n    myArgsCount = args.length;\n\n    if (callee != null) {\n      final PsiModifierList modifierList = callee.getModifierList();\n      myIsNullable = modifierList.findAnnotation(DataFlowRunner.NULLABLE) != null;\n      myIsNotNull = modifierList.findAnnotation(DataFlowRunner.NOT_NULL) != null;\n      final PsiParameter[] params = callee.getParameterList().getParameters();\n      myParametersNotNull = new boolean[params.length];\n      for (int i = 0; i < params.length; i++) {\n        PsiParameter param = params[i];\n        final PsiModifierList modList = param.getModifierList();\n        myParametersNotNull[i] = modList != null && modList.findAnnotation(DataFlowRunner.NOT_NULL) != null;\n      }\n    }\n    else {\n      myParametersNotNull = new boolean[0];\n    }\n    myType = myCall.getType();\n\n    if (call instanceof PsiNewExpression) {\n      myIsNullable = false;\n      myIsNotNull = true;\n    }\n  }","id":102229,"modified_method":"public MethodCallInstruction(PsiCallExpression call, DfaValueFactory factory) {\n    myCall = call;\n    myFactory = factory;\n    final PsiMethod callee = call.resolveMethod();\n    final PsiExpressionList argList = myCall.getArgumentList();\n    final PsiExpression[] args = argList != null ? argList.getExpressions() : null;\n    myArgsCount = args.length;\n\n    if (callee != null) {\n      final PsiModifierList modifierList = callee.getModifierList();\n      myIsNullable = modifierList.findAnnotation(DataFlowRunner.NULLABLE) != null;\n      myIsNotNull = modifierList.findAnnotation(DataFlowRunner.NOT_NULL) != null;\n      final PsiParameter[] params = callee.getParameterList().getParameters();\n      myParametersNotNull = new boolean[params.length];\n      for (int i = 0; i < params.length; i++) {\n        PsiParameter param = params[i];\n        final PsiModifierList modList = param.getModifierList();\n        myParametersNotNull[i] = modList != null && modList.findAnnotation(DataFlowRunner.NOT_NULL) != null;\n      }\n    }\n    else {\n      myParametersNotNull = new boolean[0];\n    }\n    myType = myCall.getType();\n\n    if (call instanceof PsiNewExpression) {\n      myIsNullable = false;\n      myIsNotNull = true;\n    }\n  }","commit_id":"c8e56b1c72d36484ef170db449ad12b7fe35908d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  protected UsageInfo[] findUsages() {\n    final List<SmartPsiElementPointer> toInvert = new ArrayList<SmartPsiElementPointer>();\n\n    addRefsToInvert(toInvert, myElement);\n\n    if (myElement instanceof PsiMethod) {\n      final Collection<PsiMethod> overriders = OverridingMethodsSearch.search((PsiMethod)myElement).findAll();\n      for (PsiMethod overrider : overriders) {\n        myRenameProcessor.addElement(overrider, myNewName);\n      }\n\n      Collection<PsiMethod> allMethods = new HashSet<PsiMethod>(overriders);\n      allMethods.add((PsiMethod)myElement);\n\n      for (PsiMethod method : allMethods) {\n        method.accept(new PsiRecursiveElementVisitor() {\n          public void visitReturnStatement(PsiReturnStatement statement) {\n            final PsiExpression returnValue = statement.getReturnValue();\n            if (returnValue != null && PsiType.BOOLEAN.equals(returnValue.getType())) {\n              toInvert.add(mySmartPointerManager.createSmartPsiElementPointer(returnValue));\n            }\n          }\n        });\n      }\n    } else if (myElement instanceof PsiParameter && ((PsiParameter)myElement).getDeclarationScope() instanceof PsiMethod) {\n      final PsiMethod method = (PsiMethod)((PsiParameter)myElement).getDeclarationScope();\n      int index = method.getParameterList().getParameterIndex((PsiParameter)myElement);\n      LOG.assertTrue(index >= 0);\n      final Query<PsiReference> methodQuery = MethodReferencesSearch.search(method);\n      final Collection<PsiReference> methodRefs = methodQuery.findAll();\n      for (PsiReference ref : methodRefs) {\n        if (ref.getElement().getParent() instanceof PsiCallExpression) {\n          final PsiCallExpression call = (PsiCallExpression)ref.getElement().getParent();\n          final PsiReferenceExpression methodExpression = call instanceof PsiMethodCallExpression ?\n                                                          ((PsiMethodCallExpression)call).getMethodExpression() :\n                                                          null;\n          final PsiExpression[] args = call.getArgumentList().getExpressions();\n          if (index < args.length) {\n            if (methodExpression == null || methodExpression.getQualifier() == null || !\"super\".equals(methodExpression.getQualifierExpression().getText())) {\n              toInvert.add(mySmartPointerManager.createSmartPsiElementPointer(args[index]));\n            }\n          }\n        }\n      }\n      final Collection<PsiMethod> overriders = OverridingMethodsSearch.search(method).findAll();\n      for (PsiMethod overrider : overriders) {\n        final PsiParameter overriderParameter = overrider.getParameterList().getParameters()[index];\n        myRenameProcessor.addElement(overriderParameter, myNewName);\n        addRefsToInvert(toInvert, overriderParameter);\n      }\n    }\n\n    final UsageInfo[] renameUsages = myRenameProcessor.findUsages();\n\n    final SmartPsiElementPointer[] usagesToInvert = toInvert.toArray(new SmartPsiElementPointer[toInvert.size()]);\n\n    //merge rename and invert usages\n    Map<PsiElement, UsageInfo> expressionsToUsages = new HashMap<PsiElement, UsageInfo>();\n    List<UsageInfo> result = new ArrayList<UsageInfo>();\n    for (UsageInfo renameUsage : renameUsages) {\n      expressionsToUsages.put(renameUsage.getElement(), renameUsage);\n      result.add(renameUsage);\n    }\n\n    for (SmartPsiElementPointer pointer : usagesToInvert) {\n      final PsiExpression expression = (PsiExpression)pointer.getElement();\n      if (!expressionsToUsages.containsKey(expression)) {\n        final UsageInfo usageInfo = new UsageInfo(expression);\n        expressionsToUsages.put(expression, usageInfo);\n        result.add(usageInfo); //fake UsageInfo\n        myToInvert.put(usageInfo, pointer);\n      } else {\n        myToInvert.put(expressionsToUsages.get(expression), pointer);\n      }\n    }\n\n    return result.toArray(new UsageInfo[result.size()]);\n  }","id":102230,"modified_method":"@NotNull\n  protected UsageInfo[] findUsages() {\n    final List<SmartPsiElementPointer> toInvert = new ArrayList<SmartPsiElementPointer>();\n\n    addRefsToInvert(toInvert, myElement);\n\n    if (myElement instanceof PsiMethod) {\n      final Collection<PsiMethod> overriders = OverridingMethodsSearch.search((PsiMethod)myElement).findAll();\n      for (PsiMethod overrider : overriders) {\n        myRenameProcessor.addElement(overrider, myNewName);\n      }\n\n      Collection<PsiMethod> allMethods = new HashSet<PsiMethod>(overriders);\n      allMethods.add((PsiMethod)myElement);\n\n      for (PsiMethod method : allMethods) {\n        method.accept(new PsiRecursiveElementVisitor() {\n          public void visitReturnStatement(PsiReturnStatement statement) {\n            final PsiExpression returnValue = statement.getReturnValue();\n            if (returnValue != null && PsiType.BOOLEAN.equals(returnValue.getType())) {\n              toInvert.add(mySmartPointerManager.createSmartPsiElementPointer(returnValue));\n            }\n          }\n        });\n      }\n    } else if (myElement instanceof PsiParameter && ((PsiParameter)myElement).getDeclarationScope() instanceof PsiMethod) {\n      final PsiMethod method = (PsiMethod)((PsiParameter)myElement).getDeclarationScope();\n      int index = method.getParameterList().getParameterIndex((PsiParameter)myElement);\n      LOG.assertTrue(index >= 0);\n      final Query<PsiReference> methodQuery = MethodReferencesSearch.search(method);\n      final Collection<PsiReference> methodRefs = methodQuery.findAll();\n      for (PsiReference ref : methodRefs) {\n        if (ref.getElement().getParent() instanceof PsiCall) {\n          final PsiCall call = (PsiCall)ref.getElement().getParent();\n          final PsiReferenceExpression methodExpression = call instanceof PsiMethodCallExpression ?\n                                                          ((PsiMethodCallExpression)call).getMethodExpression() :\n                                                          null;\n          final PsiExpressionList argumentList = call.getArgumentList();\n          if (argumentList != null) {\n            final PsiExpression[] args = argumentList.getExpressions();\n            if (index < args.length) {\n              if (methodExpression == null || methodExpression.getQualifier() == null || !\"super\".equals(methodExpression.getQualifierExpression().getText())) {\n                toInvert.add(mySmartPointerManager.createSmartPsiElementPointer(args[index]));\n              }\n            }\n          }\n        }\n      }\n      final Collection<PsiMethod> overriders = OverridingMethodsSearch.search(method).findAll();\n      for (PsiMethod overrider : overriders) {\n        final PsiParameter overriderParameter = overrider.getParameterList().getParameters()[index];\n        myRenameProcessor.addElement(overriderParameter, myNewName);\n        addRefsToInvert(toInvert, overriderParameter);\n      }\n    }\n\n    final UsageInfo[] renameUsages = myRenameProcessor.findUsages();\n\n    final SmartPsiElementPointer[] usagesToInvert = toInvert.toArray(new SmartPsiElementPointer[toInvert.size()]);\n\n    //merge rename and invert usages\n    Map<PsiElement, UsageInfo> expressionsToUsages = new HashMap<PsiElement, UsageInfo>();\n    List<UsageInfo> result = new ArrayList<UsageInfo>();\n    for (UsageInfo renameUsage : renameUsages) {\n      expressionsToUsages.put(renameUsage.getElement(), renameUsage);\n      result.add(renameUsage);\n    }\n\n    for (SmartPsiElementPointer pointer : usagesToInvert) {\n      final PsiExpression expression = (PsiExpression)pointer.getElement();\n      if (!expressionsToUsages.containsKey(expression)) {\n        final UsageInfo usageInfo = new UsageInfo(expression);\n        expressionsToUsages.put(expression, usageInfo);\n        result.add(usageInfo); //fake UsageInfo\n        myToInvert.put(usageInfo, pointer);\n      } else {\n        myToInvert.put(expressionsToUsages.get(expression), pointer);\n      }\n    }\n\n    return result.toArray(new UsageInfo[result.size()]);\n  }","commit_id":"ab7f470821c7d5d8897f292cd28c434b1d4395cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addUsage(final ReductionSystem system, final PsiElement element) {\n\n    if (element instanceof PsiVariable) {\n      final PsiExpression initializer = ((PsiVariable)element).getInitializer();\n\n      if (initializer != null) {\n        final PsiExpression core = PsiUtil.deparenthesizeExpression(initializer);\n\n        if (core instanceof PsiArrayInitializerExpression) {\n          final PsiExpression[] inits = ((PsiArrayInitializerExpression)core).getInitializers();\n          final PsiType type = getType(element);\n\n          for (PsiExpression init : inits) {\n            system.addSubtypeConstraint(evaluateType(init, system).createArrayType(), type);\n          }\n        }\n        else if (core instanceof PsiNewExpression) {\n          final PsiArrayInitializerExpression init = ((PsiNewExpression)core).getArrayInitializer();\n\n          if (init != null) {\n            final PsiExpression[] inits = init.getInitializers();\n            final PsiType type = getType(element);\n\n            for (PsiExpression init1 : inits) {\n              system.addSubtypeConstraint(evaluateType(init1, system).createArrayType(), type);\n            }\n          }\n\n          system.addSubtypeConstraint(evaluateType(core, system), getType(element));\n        }\n        else {\n          system.addSubtypeConstraint(evaluateType(core, system), getType(element));\n        }\n      }\n\n      if (element instanceof PsiParameter) {\n        final PsiElement declarationScope = ((PsiParameter)element).getDeclarationScope();\n        if (declarationScope instanceof PsiMethod) {\n          final PsiMethod method = ((PsiMethod)declarationScope);\n          final PsiSearchHelper helper = myManager.getSearchHelper();\n          SearchScope scope = getScope(helper, method);\n\n          final PsiReference[] refs = helper.findReferences(method, scope, true);\n\n          for (PsiReference ref : refs) {\n            final PsiElement elt = ref.getElement();\n\n            if (elt != null) {\n              final PsiCallExpression call = PsiTreeUtil.getParentOfType(elt, PsiCallExpression.class);\n\n              if (call != null) {\n                final PsiExpression arg = call.getArgumentList().getExpressions()[method.getParameterList().getParameterIndex(\n                  (PsiParameter)element)];\n\n                system.addSubtypeConstraint(evaluateType(arg, system), myTypes.get(element));\n              }\n            }\n          }\n        }\n      }\n      return;\n    }\n    else if (element instanceof PsiMethod) {\n      final PsiType reType = getType(element);\n\n      element.accept(new PsiRecursiveElementVisitor() {\n                       public void visitReturnStatement(final PsiReturnStatement statement) {\n                         super.visitReturnStatement(statement);\n\n                         final PsiExpression retExpr = statement.getReturnValue();\n\n                         if (retExpr != null) {\n                           system.addSubtypeConstraint(evaluateType(retExpr, system), reType);\n                         }\n                       }\n                     }\n      );\n\n      return;\n    }\n\n    final PsiElement root = PsiTreeUtil.getParentOfType(element, PsiStatement.class, PsiField.class);\n\n    if (root != null) {\n      final PsiAnchor anchor = new PsiAnchor(root);\n\n      if (!myVisitedConstructions.contains(anchor)) {\n        root.accept(new PsiRecursiveElementVisitor() {\n                      public void visitAssignmentExpression(final PsiAssignmentExpression expression) {\n                        super.visitAssignmentExpression(expression);\n\n                        system.addSubtypeConstraint(evaluateType(expression.getRExpression(), system), evaluateType(expression.getLExpression(),\n                                                                                                                        system));\n                      }\n\n                      public void visitConditionalExpression(final PsiConditionalExpression expression) {\n                        super.visitConditionalExpression(expression);\n\n                        system.addSubtypeConstraint(evaluateType(expression.getThenExpression(), system),\n                                                    evaluateType(expression.getElseExpression(), system));\n                        system.addSubtypeConstraint(evaluateType(expression.getElseExpression(), system),\n                                                    evaluateType(expression.getThenExpression(), system));\n                      }\n\n                      public void visitCallExpression(final PsiCallExpression expression) {\n                        super.visitCallExpression(expression);\n                        evaluateType(expression, system);\n                      }\n\n                      public void visitReturnStatement(final PsiReturnStatement statement) {\n                        super.visitReturnStatement(statement);\n\n                        final PsiMethod method = PsiTreeUtil.getParentOfType(statement, PsiMethod.class);\n\n                        if (method != null) {\n                          system.addSubtypeConstraint(evaluateType(statement.getReturnValue(), system), getType(method));\n                        }\n                      }\n\n                      public void visitTypeCastExpression(final PsiTypeCastExpression expression) {\n                        super.visitTypeCastExpression(expression);\n\n                        final PsiType operandType = evaluateType(expression.getOperand(), system);\n                        final PsiType castType = evaluateType(expression, system);\n                        if (operandType == null || castType == null) return;\n\n                        if (Util.bindsTypeVariables(operandType)) {\n                          system.addCast(expression, operandType);\n                        }\n\n                        if (operandType.getDeepComponentType() instanceof PsiTypeVariable || castType.getDeepComponentType() instanceof PsiTypeVariable) {\n                          system.addSubtypeConstraint(operandType, castType);\n                        }\n                        else {\n                          final PsiClassType.ClassResolveResult operandResult = Util.resolveType(operandType);\n                          final PsiClassType.ClassResolveResult castResult = Util.resolveType(castType);\n\n                          final PsiClass operandClass = operandResult.getElement();\n                          final PsiClass castClass = castResult.getElement();\n\n                          if (operandClass != null && castClass != null) {\n                            if (InheritanceUtil.isCorrectDescendant(operandClass, castClass, true)) {\n                              system.addSubtypeConstraint(operandType, castType);\n                            }\n                          }\n                        }\n                      }\n\n                      public void visitVariable(final PsiVariable variable) {\n                        super.visitVariable(variable);\n\n                        final PsiExpression init = variable.getInitializer();\n\n                        if (init != null) {\n                          system.addSubtypeConstraint(evaluateType(init, system), getType(variable));\n                        }\n                      }\n\n                      public void visitNewExpression(final PsiNewExpression expression) {\n                        super.visitNewExpression(expression);\n\n                        final PsiArrayInitializerExpression init = expression.getArrayInitializer();\n\n                        if (init != null) {\n                          final PsiExpression[] inits = init.getInitializers();\n                          final PsiType type = getType(expression);\n\n                          for (PsiExpression init1 : inits) {\n                            system.addSubtypeConstraint(evaluateType(init1, system).createArrayType(), type);\n                          }\n                        }\n                      }\n\n                      public void visitReferenceExpression(final PsiReferenceExpression expression) {\n                        final PsiExpression qualifierExpression = expression.getQualifierExpression();\n\n                        if (qualifierExpression != null) {\n                          qualifierExpression.accept(this);\n                        }\n                      }\n                    });\n\n        myVisitedConstructions.add(anchor);\n      }\n    }\n  }","id":102231,"modified_method":"private void addUsage(final ReductionSystem system, final PsiElement element) {\n\n    if (element instanceof PsiVariable) {\n      final PsiExpression initializer = ((PsiVariable)element).getInitializer();\n\n      if (initializer != null) {\n        final PsiExpression core = PsiUtil.deparenthesizeExpression(initializer);\n\n        if (core instanceof PsiArrayInitializerExpression) {\n          final PsiExpression[] inits = ((PsiArrayInitializerExpression)core).getInitializers();\n          final PsiType type = getType(element);\n\n          for (PsiExpression init : inits) {\n            system.addSubtypeConstraint(evaluateType(init, system).createArrayType(), type);\n          }\n        }\n        else if (core instanceof PsiNewExpression) {\n          final PsiArrayInitializerExpression init = ((PsiNewExpression)core).getArrayInitializer();\n\n          if (init != null) {\n            final PsiExpression[] inits = init.getInitializers();\n            final PsiType type = getType(element);\n\n            for (PsiExpression init1 : inits) {\n              system.addSubtypeConstraint(evaluateType(init1, system).createArrayType(), type);\n            }\n          }\n\n          system.addSubtypeConstraint(evaluateType(core, system), getType(element));\n        }\n        else {\n          system.addSubtypeConstraint(evaluateType(core, system), getType(element));\n        }\n      }\n\n      if (element instanceof PsiParameter) {\n        PsiParameter parameter = (PsiParameter)element;\n        final PsiElement declarationScope = parameter.getDeclarationScope();\n        if (declarationScope instanceof PsiMethod) {\n          final PsiMethod method = ((PsiMethod)declarationScope);\n          final PsiSearchHelper helper = myManager.getSearchHelper();\n          SearchScope scope = getScope(helper, method);\n\n          final PsiReference[] refs = helper.findReferences(method, scope, true);\n\n          for (PsiReference ref : refs) {\n            final PsiElement elt = ref.getElement();\n\n            if (elt != null) {\n              final PsiCallExpression call = PsiTreeUtil.getParentOfType(elt, PsiCallExpression.class);\n\n              if (call != null) {\n                PsiExpressionList argList = call.getArgumentList();\n                if (argList != null) {\n                  PsiExpression[] args = argList.getExpressions();\n                  int index = method.getParameterList().getParameterIndex(parameter);\n                  if (index < args.length) {\n                    system.addSubtypeConstraint(evaluateType(args[index], system), myTypes.get(element));\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      return;\n    }\n    else if (element instanceof PsiMethod) {\n      final PsiType reType = getType(element);\n\n      element.accept(new PsiRecursiveElementVisitor() {\n                       public void visitReturnStatement(final PsiReturnStatement statement) {\n                         super.visitReturnStatement(statement);\n\n                         final PsiExpression retExpr = statement.getReturnValue();\n\n                         if (retExpr != null) {\n                           system.addSubtypeConstraint(evaluateType(retExpr, system), reType);\n                         }\n                       }\n                     }\n      );\n\n      return;\n    }\n\n    final PsiElement root = PsiTreeUtil.getParentOfType(element, PsiStatement.class, PsiField.class);\n\n    if (root != null) {\n      final PsiAnchor anchor = new PsiAnchor(root);\n\n      if (!myVisitedConstructions.contains(anchor)) {\n        root.accept(new PsiRecursiveElementVisitor() {\n                      public void visitAssignmentExpression(final PsiAssignmentExpression expression) {\n                        super.visitAssignmentExpression(expression);\n\n                        system.addSubtypeConstraint(evaluateType(expression.getRExpression(), system), evaluateType(expression.getLExpression(),\n                                                                                                                        system));\n                      }\n\n                      public void visitConditionalExpression(final PsiConditionalExpression expression) {\n                        super.visitConditionalExpression(expression);\n\n                        system.addSubtypeConstraint(evaluateType(expression.getThenExpression(), system),\n                                                    evaluateType(expression.getElseExpression(), system));\n                        system.addSubtypeConstraint(evaluateType(expression.getElseExpression(), system),\n                                                    evaluateType(expression.getThenExpression(), system));\n                      }\n\n                      public void visitCallExpression(final PsiCallExpression expression) {\n                        super.visitCallExpression(expression);\n                        evaluateType(expression, system);\n                      }\n\n                      public void visitReturnStatement(final PsiReturnStatement statement) {\n                        super.visitReturnStatement(statement);\n\n                        final PsiMethod method = PsiTreeUtil.getParentOfType(statement, PsiMethod.class);\n\n                        if (method != null) {\n                          system.addSubtypeConstraint(evaluateType(statement.getReturnValue(), system), getType(method));\n                        }\n                      }\n\n                      public void visitTypeCastExpression(final PsiTypeCastExpression expression) {\n                        super.visitTypeCastExpression(expression);\n\n                        final PsiType operandType = evaluateType(expression.getOperand(), system);\n                        final PsiType castType = evaluateType(expression, system);\n                        if (operandType == null || castType == null) return;\n\n                        if (Util.bindsTypeVariables(operandType)) {\n                          system.addCast(expression, operandType);\n                        }\n\n                        if (operandType.getDeepComponentType() instanceof PsiTypeVariable || castType.getDeepComponentType() instanceof PsiTypeVariable) {\n                          system.addSubtypeConstraint(operandType, castType);\n                        }\n                        else {\n                          final PsiClassType.ClassResolveResult operandResult = Util.resolveType(operandType);\n                          final PsiClassType.ClassResolveResult castResult = Util.resolveType(castType);\n\n                          final PsiClass operandClass = operandResult.getElement();\n                          final PsiClass castClass = castResult.getElement();\n\n                          if (operandClass != null && castClass != null) {\n                            if (InheritanceUtil.isCorrectDescendant(operandClass, castClass, true)) {\n                              system.addSubtypeConstraint(operandType, castType);\n                            }\n                          }\n                        }\n                      }\n\n                      public void visitVariable(final PsiVariable variable) {\n                        super.visitVariable(variable);\n\n                        final PsiExpression init = variable.getInitializer();\n\n                        if (init != null) {\n                          system.addSubtypeConstraint(evaluateType(init, system), getType(variable));\n                        }\n                      }\n\n                      public void visitNewExpression(final PsiNewExpression expression) {\n                        super.visitNewExpression(expression);\n\n                        final PsiArrayInitializerExpression init = expression.getArrayInitializer();\n\n                        if (init != null) {\n                          final PsiExpression[] inits = init.getInitializers();\n                          final PsiType type = getType(expression);\n\n                          for (PsiExpression init1 : inits) {\n                            system.addSubtypeConstraint(evaluateType(init1, system).createArrayType(), type);\n                          }\n                        }\n                      }\n\n                      public void visitReferenceExpression(final PsiReferenceExpression expression) {\n                        final PsiExpression qualifierExpression = expression.getQualifierExpression();\n\n                        if (qualifierExpression != null) {\n                          qualifierExpression.accept(this);\n                        }\n                      }\n                    });\n\n        myVisitedConstructions.add(anchor);\n      }\n    }\n  }","commit_id":"abf6b2776e380521d7ce5d003450cef7d1450957","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SystemBuilder(final Project project, final Settings settings) {\n    myProject = project;\n    myManager = PsiManager.getInstance(myProject);\n    mySettings = settings;\n    myMethodCache = new HashMap<PsiElement, Boolean>();\n    myParameters = new HashMap<PsiParameter, PsiParameter>();\n    myMethods = new HashMap<PsiMethod, PsiMethod>();\n    mySuper = new HashMap<PsiMethod, PsiMethod>();\n    myTypes = new HashMap<PsiElement, PsiType>();\n    myVisitedConstructions = new HashSet<PsiAnchor>();\n    myTypeVariableFactory = new PsiTypeVariableFactory();\n  }","id":102232,"modified_method":"public SystemBuilder(final Project project, final Settings settings) {\n    myProject = project;\n    myManager = PsiManager.getInstance(myProject);\n    mySettings = settings;\n    myMethodCache = new HashMap<PsiElement, Boolean>();\n    myParameters = new HashMap<PsiParameter, PsiParameter>();\n    myMethods = new HashMap<PsiMethod, PsiMethod>();\n    myTypes = new HashMap<PsiElement, PsiType>();\n    myVisitedConstructions = new HashSet<PsiAnchor>();\n    myTypeVariableFactory = new PsiTypeVariableFactory();\n  }","commit_id":"abf6b2776e380521d7ce5d003450cef7d1450957","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean verifyMethod(final PsiElement element, final HashSet<PsiElement> victims, final PsiSearchHelper helper) {\n    PsiMethod method;\n    PsiParameter parameter = null;\n    int index = 0;\n\n    if (element instanceof PsiMethod) {\n      method = (PsiMethod)element;\n    }\n    else if (element instanceof PsiParameter) {\n      parameter = (PsiParameter)element;\n      method = (PsiMethod)parameter.getDeclarationScope();\n      index = method.getParameterList().getParameterIndex(parameter);\n    }\n    else {\n      LOG.error(\"Parameter or method expected, but found \" + (element == null ? \"null\" : element.getClass().getName()));\n      return false;\n    }\n\n    final PsiMethod superMethod = method.findDeepestSuperMethod();\n    PsiMethod keyMethod;\n    PsiParameter keyParameter = null;\n\n    if (superMethod != null) {\n      Boolean good = myMethodCache.get(superMethod);\n\n      if (good != null && !good.booleanValue()) {\n        return false;\n      }\n\n      final PsiElement e =\n        parameter == null ? superMethod : superMethod.getParameterList().getParameters()[index];\n\n      if (!victims.contains(e)) {\n        myMethodCache.put(superMethod, Boolean.FALSE);\n        return false;\n      }\n\n      keyMethod = superMethod;\n\n      myMethods.put(method, keyMethod);\n\n      if (parameter != null) {\n        keyParameter = (PsiParameter)e;\n      }\n    }\n    else {\n      Boolean good = myMethodCache.get(method);\n\n      if (good != null && good.booleanValue()) {\n        if (myMethods.get(method) == null) {\n          myMethods.put(method, method);\n        }\n\n        if (parameter != null && myParameters.get(parameter) == null) {\n          myParameters.put(parameter, parameter);\n        }\n\n        return true;\n      }\n\n      keyMethod = method;\n      keyParameter = parameter;\n    }\n\n    final PsiMethod[] overriders = helper.findOverridingMethods(keyMethod, keyMethod.getUseScope(), true);\n\n    for (final PsiMethod overrider : overriders) {\n      final PsiElement e = parameter != null ? overrider.getParameterList().getParameters()[index] : overrider;\n\n      if (!victims.contains(e)) {\n        myMethodCache.put(keyMethod, Boolean.FALSE);\n        return false;\n      }\n    }\n\n    for (final PsiMethod overrider : overriders) {\n      final PsiElement e = parameter != null ? overrider.getParameterList().getParameters()[index] : overrider;\n\n      mySuper.put(overrider, keyMethod);\n      myMethods.put(overrider, keyMethod);\n\n      if (parameter != null) {\n        myParameters.put((PsiParameter)e, keyParameter);\n      }\n    }\n\n    myMethods.put(method, keyMethod);\n\n    if (parameter != null) {\n      myParameters.put(parameter, keyParameter);\n    }\n\n    myMethodCache.put(keyMethod, Boolean.TRUE);\n\n    return true;\n  }","id":102233,"modified_method":"private boolean verifyMethod(final PsiElement element, final HashSet<PsiElement> victims, final PsiSearchHelper helper) {\n    PsiMethod method;\n    PsiParameter parameter = null;\n    int index = 0;\n\n    if (element instanceof PsiMethod) {\n      method = (PsiMethod)element;\n    }\n    else if (element instanceof PsiParameter) {\n      parameter = (PsiParameter)element;\n      method = (PsiMethod)parameter.getDeclarationScope();\n      index = method.getParameterList().getParameterIndex(parameter);\n    }\n    else {\n      LOG.error(\"Parameter or method expected, but found \" + (element == null ? \"null\" : element.getClass().getName()));\n      return false;\n    }\n\n    final PsiMethod superMethod = method.findDeepestSuperMethod();\n    PsiMethod keyMethod;\n    PsiParameter keyParameter = null;\n\n    if (superMethod != null) {\n      Boolean good = myMethodCache.get(superMethod);\n\n      if (good != null && !good.booleanValue()) {\n        return false;\n      }\n\n      final PsiElement e =\n        parameter == null ? superMethod : superMethod.getParameterList().getParameters()[index];\n\n      if (!victims.contains(e)) {\n        myMethodCache.put(superMethod, Boolean.FALSE);\n        return false;\n      }\n\n      keyMethod = superMethod;\n\n      myMethods.put(method, keyMethod);\n\n      if (parameter != null) {\n        keyParameter = (PsiParameter)e;\n      }\n    }\n    else {\n      Boolean good = myMethodCache.get(method);\n\n      if (good != null && good.booleanValue()) {\n        if (myMethods.get(method) == null) {\n          myMethods.put(method, method);\n        }\n\n        if (parameter != null && myParameters.get(parameter) == null) {\n          myParameters.put(parameter, parameter);\n        }\n\n        return true;\n      }\n\n      keyMethod = method;\n      keyParameter = parameter;\n    }\n\n    final PsiMethod[] overriders = helper.findOverridingMethods(keyMethod, keyMethod.getUseScope(), true);\n\n    for (final PsiMethod overrider : overriders) {\n      final PsiElement e = parameter != null ? overrider.getParameterList().getParameters()[index] : overrider;\n\n      if (!victims.contains(e)) {\n        myMethodCache.put(keyMethod, Boolean.FALSE);\n        return false;\n      }\n    }\n\n    for (final PsiMethod overrider : overriders) {\n      final PsiElement e = parameter != null ? overrider.getParameterList().getParameters()[index] : overrider;\n\n      myMethods.put(overrider, keyMethod);\n\n      if (parameter != null) {\n        myParameters.put((PsiParameter)e, keyParameter);\n      }\n    }\n\n    myMethods.put(method, keyMethod);\n\n    if (parameter != null) {\n      myParameters.put(parameter, keyParameter);\n    }\n\n    myMethodCache.put(keyMethod, Boolean.TRUE);\n\n    return true;\n  }","commit_id":"abf6b2776e380521d7ce5d003450cef7d1450957","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  @Nullable\n  public static JComponent getPreviewComponent(@NotNull final PsiElement element) {\n    final PsiNewExpression psiNewExpression = PsiTreeUtil.getParentOfType(element, PsiNewExpression.class);\n    if (psiNewExpression != null) {\n      final PsiJavaCodeReferenceElement referenceElement = PsiTreeUtil.getChildOfType(psiNewExpression, PsiJavaCodeReferenceElement.class);\n      if (referenceElement != null) {\n        final PsiReference reference = referenceElement.getReference();\n        if (reference != null) {\n          final PsiElement psiElement = reference.resolve();\n          if (psiElement instanceof PsiClass && \"java.awt.Color\".equals(((PsiClass)psiElement).getQualifiedName())) {\n            final PsiExpression[] expressions = psiNewExpression.getArgumentList().getExpressions();\n            int[] values = new int[expressions.length];\n            float[] values2 = new float[expressions.length];\n            int i = 0;\n            int j = 0;\n            for (final PsiExpression each : expressions) {\n              if (each instanceof PsiLiteralExpression) {\n                final Object o = ((PsiLiteralExpression)each).getValue();\n                if (o instanceof Integer) {\n                  values[i] = ((Integer)o).intValue();\n                  i++;\n                } else if (o instanceof Float) {\n                  values2[j] = ((Float)o).floatValue();\n                  j++;\n                }\n              }\n            }\n\n            Color c = null;\n            if (i == expressions.length) {\n              switch (values.length) {\n                case 1:\n                  c = new Color(values[0]);\n                  break;\n                case 3:\n                  c = new Color(values[0], values[1], values[2]);\n                  break;\n                case 4:\n                  c = new Color(values[0], values[1], values[2], values[3]);\n                  break;\n                default:\n                  break;\n              }\n            } else if (j == expressions.length) {\n              switch (values2.length) {\n                case 3:\n                  c = new Color(values2[0], values2[1], values2[2]);\n                  break;\n                case 4:\n                  c = new Color(values2[0], values2[1], values2[2], values2[3]);\n                  break;\n                default:\n                  break;\n              }\n            }\n\n            if (c != null) {\n              return new ColorPreviewComponent(null, c);\n            }\n          }\n        }\n      }\n    }\n\n    if (StandardPatterns.psiElement(PsiIdentifier.class).withParent(StandardPatterns.psiElement(PsiReferenceExpression.class))\n      .accepts(element)) {\n      final PsiReference reference = element.getParent().getReference();\n      if (reference != null) {\n        final PsiElement psiElement = reference.resolve();\n        if (psiElement instanceof PsiField) {\n          if (\"java.awt.Color\".equals(((PsiField)psiElement).getContainingClass().getQualifiedName())) {\n            final String colorName = ((PsiField)psiElement).getName().toLowerCase().replace(\"_\", \"\");\n            final String hex = ColorSampleLookupValue.getHexCodeForColorName(colorName);\n            return new ColorPreviewComponent(null, Color.decode(\"0x\" + hex.substring(1)));\n          }\n        }\n      }\n    }\n\n\n    if (element.getParent() instanceof XmlAttributeValue) {\n      final PsiElement parentParent = element.getParent().getParent();\n      if (parentParent instanceof XmlAttribute) {\n        XmlAttribute attribute = (XmlAttribute)parentParent;\n        String attrName = attribute.getName();\n        if (\"alink\".equals(attrName) || \"link\".equals(attrName) | \"text\".equals(attrName) || \"vlink\".equals(attrName) ||\n            \"bgcolor\".equals(attrName) || \"color\".equals(attrName)) {\n          String s = element.getText();\n          if (s.length() > 0) {\n            final String hexColor = (s.charAt(0) == '#') ? s : ColorSampleLookupValue.getHexCodeForColorName(s.toLowerCase());\n            if (hexColor != null) {\n              try {\n                return new ColorPreviewComponent(null, Color.decode(\"0x\" + hexColor.substring(1)));\n              }\n              catch (NumberFormatException e) {\n                return null;\n              }\n            }\n          }\n        }\n      }\n    }\n    else {\n      final Color color = CssUtil.getColor(element);\n      if (color != null) {\n        try {\n          return new ColorPreviewComponent(null, color);\n        }\n        catch (NumberFormatException e) {\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }","id":102234,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  @Nullable\n  public static JComponent getPreviewComponent(@NotNull final PsiElement element) {\n    final PsiNewExpression psiNewExpression = PsiTreeUtil.getParentOfType(element, PsiNewExpression.class);\n    if (psiNewExpression != null) {\n      final PsiJavaCodeReferenceElement referenceElement = PsiTreeUtil.getChildOfType(psiNewExpression, PsiJavaCodeReferenceElement.class);\n      if (referenceElement != null) {\n        final PsiReference reference = referenceElement.getReference();\n        if (reference != null) {\n          final PsiElement psiElement = reference.resolve();\n          if (psiElement instanceof PsiClass && \"java.awt.Color\".equals(((PsiClass)psiElement).getQualifiedName())) {\n            final PsiExpressionList argumentList = psiNewExpression.getArgumentList();\n            if (argumentList != null) {\n              final PsiExpression[] expressions = argumentList.getExpressions();\n              int[] values = new int[expressions.length];\n              float[] values2 = new float[expressions.length];\n              int i = 0;\n              int j = 0;\n              for (final PsiExpression each : expressions) {\n                if (each instanceof PsiLiteralExpression) {\n                  final Object o = ((PsiLiteralExpression)each).getValue();\n                  if (o instanceof Integer) {\n                    values[i] = ((Integer)o).intValue();\n                    i++;\n                  }\n                  else if (o instanceof Float) {\n                    values2[j] = ((Float)o).floatValue();\n                    j++;\n                  }\n                }\n              }\n\n\n              Color c = null;\n              if (i == expressions.length) {\n                switch (values.length) {\n                  case 1:\n                    c = new Color(values[0]);\n                    break;\n                  case 3:\n                    c = new Color(values[0], values[1], values[2]);\n                    break;\n                  case 4:\n                    c = new Color(values[0], values[1], values[2], values[3]);\n                    break;\n                  default:\n                    break;\n                }\n              }\n              else if (j == expressions.length) {\n                switch (values2.length) {\n                  case 3:\n                    c = new Color(values2[0], values2[1], values2[2]);\n                    break;\n                  case 4:\n                    c = new Color(values2[0], values2[1], values2[2], values2[3]);\n                    break;\n                  default:\n                    break;\n                }\n              }\n\n              if (c != null) {\n                return new ColorPreviewComponent(null, c);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (StandardPatterns.psiElement(PsiIdentifier.class).withParent(StandardPatterns.psiElement(PsiReferenceExpression.class))\n      .accepts(element)) {\n      final PsiReference reference = element.getParent().getReference();\n      if (reference != null) {\n        final PsiElement psiElement = reference.resolve();\n        if (psiElement instanceof PsiField) {\n          if (\"java.awt.Color\".equals(((PsiField)psiElement).getContainingClass().getQualifiedName())) {\n            final String colorName = ((PsiField)psiElement).getName().toLowerCase().replace(\"_\", \"\");\n            final String hex = ColorSampleLookupValue.getHexCodeForColorName(colorName);\n            return new ColorPreviewComponent(null, Color.decode(\"0x\" + hex.substring(1)));\n          }\n        }\n      }\n    }\n\n\n    if (element.getParent() instanceof XmlAttributeValue) {\n      final PsiElement parentParent = element.getParent().getParent();\n      if (parentParent instanceof XmlAttribute) {\n        XmlAttribute attribute = (XmlAttribute)parentParent;\n        String attrName = attribute.getName();\n        if (\"alink\".equals(attrName) ||\n            \"link\".equals(attrName) | \"text\".equals(attrName) ||\n            \"vlink\".equals(attrName) ||\n            \"bgcolor\".equals(attrName) ||\n            \"color\".equals(attrName)) {\n          String s = element.getText();\n          if (s.length() > 0) {\n            final String hexColor = (s.charAt(0) == '#') ? s : ColorSampleLookupValue.getHexCodeForColorName(s.toLowerCase());\n            if (hexColor != null) {\n              try {\n                return new ColorPreviewComponent(null, Color.decode(\"0x\" + hexColor.substring(1)));\n              }\n              catch (NumberFormatException e) {\n                return null;\n              }\n            }\n          }\n        }\n      }\n    }\n    else {\n      final Color color = CssUtil.getColor(element);\n      if (color != null) {\n        try {\n          return new ColorPreviewComponent(null, color);\n        }\n        catch (NumberFormatException e) {\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"eadb24249628df472d53d1d8b0d9658cccc4887e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo checkUncheckedCall(JavaResolveResult resolveResult, PsiCall call) {\n    if (PsiUtil.getLanguageLevel(call).compareTo(LanguageLevel.JDK_1_5) < 0) return null;\n    final HighlightDisplayKey key = HighlightDisplayKey.find(UncheckedWarningLocalInspection.SHORT_NAME);\n    if (!InspectionProjectProfileManager.getInstance(call.getProject()).getInspectionProfile(call).isToolEnabled(key)) return null;\n\n    final PsiMethod method = (PsiMethod)resolveResult.getElement();\n    final PsiSubstitutor substitutor = resolveResult.getSubstitutor();\n    final PsiParameter[] parameters = method.getParameterList().getParameters();\n    for (final PsiParameter parameter : parameters) {\n      final PsiType parameterType = parameter.getType();\n      if (parameterType.accept(new PsiTypeVisitor<Boolean>() {\n        public Boolean visitPrimitiveType(PsiPrimitiveType primitiveType) {\n          return Boolean.FALSE;\n        }\n\n        public Boolean visitArrayType(PsiArrayType arrayType) {\n          return arrayType.getComponentType().accept(this);\n        }\n\n        public Boolean visitClassType(PsiClassType classType) {\n          PsiClass psiClass = classType.resolve();\n          if (psiClass instanceof PsiTypeParameter) {\n            return substitutor.substitute((PsiTypeParameter)psiClass) == null ? Boolean.TRUE : Boolean.FALSE;\n          }\n          PsiType[] parameters = classType.getParameters();\n          for (PsiType parameter : parameters) {\n            if (parameter.accept(this).booleanValue()) return Boolean.TRUE;\n\n          }\n          return Boolean.FALSE;\n        }\n\n        public Boolean visitWildcardType(PsiWildcardType wildcardType) {\n          PsiType bound = wildcardType.getBound();\n          if (bound != null) return bound.accept(this);\n          return Boolean.FALSE;\n        }\n\n        public Boolean visitEllipsisType(PsiEllipsisType ellipsisType) {\n          return ellipsisType.getComponentType().accept(this);\n        }\n      }).booleanValue()) {\n        final PsiElementFactory elementFactory = method.getManager().getElementFactory();\n        PsiType type = elementFactory.createType(method.getContainingClass(), substitutor);\n        String description = JavaErrorMessages.message(\"generics.unchecked.call.to.member.of.raw.type\",\n                                                       HighlightUtil.formatMethod(method),\n                                                       HighlightUtil.formatType(type));\n        PsiElement element = call instanceof PsiMethodCallExpression\n                             ? ((PsiMethodCallExpression)call).getMethodExpression()\n                             : call;\n        if (InspectionManagerEx.inspectionResultSuppressed(call, UncheckedWarningLocalInspection.ID)) return null;\n        HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.UNCHECKED_WARNING, element, description);\n        List<IntentionAction> options = IntentionManager.getInstance(call.getProject()).getStandardIntentionOptions(key,call);\n        String displayName = UncheckedWarningLocalInspection.DISPLAY_NAME;\n        QuickFixAction.registerQuickFixAction(highlightInfo, new GenerifyFileFix(element.getContainingFile()), options, displayName);\n        return highlightInfo;\n      }\n    }\n    return null;\n  }","id":102235,"modified_method":"public static HighlightInfo checkUncheckedCall(JavaResolveResult resolveResult, PsiCall call) {\n    if (PsiUtil.getLanguageLevel(call).compareTo(LanguageLevel.JDK_1_5) < 0) return null;\n    final HighlightDisplayKey key = HighlightDisplayKey.find(UncheckedWarningLocalInspection.SHORT_NAME);\n    if (!InspectionProjectProfileManager.getInstance(call.getProject()).getInspectionProfile(call).isToolEnabled(key)) return null;\n\n    final PsiMethod method = (PsiMethod)resolveResult.getElement();\n    if (method == null) return null;\n    final PsiSubstitutor substitutor = resolveResult.getSubstitutor();\n    final PsiParameter[] parameters = method.getParameterList().getParameters();\n    for (final PsiParameter parameter : parameters) {\n      final PsiType parameterType = parameter.getType();\n      if (parameterType.accept(new PsiTypeVisitor<Boolean>() {\n        public Boolean visitPrimitiveType(PsiPrimitiveType primitiveType) {\n          return Boolean.FALSE;\n        }\n\n        public Boolean visitArrayType(PsiArrayType arrayType) {\n          return arrayType.getComponentType().accept(this);\n        }\n\n        public Boolean visitClassType(PsiClassType classType) {\n          PsiClass psiClass = classType.resolve();\n          if (psiClass instanceof PsiTypeParameter) {\n            return substitutor.substitute((PsiTypeParameter)psiClass) == null ? Boolean.TRUE : Boolean.FALSE;\n          }\n          PsiType[] parameters = classType.getParameters();\n          for (PsiType parameter : parameters) {\n            if (parameter.accept(this).booleanValue()) return Boolean.TRUE;\n\n          }\n          return Boolean.FALSE;\n        }\n\n        public Boolean visitWildcardType(PsiWildcardType wildcardType) {\n          PsiType bound = wildcardType.getBound();\n          if (bound != null) return bound.accept(this);\n          return Boolean.FALSE;\n        }\n\n        public Boolean visitEllipsisType(PsiEllipsisType ellipsisType) {\n          return ellipsisType.getComponentType().accept(this);\n        }\n      }).booleanValue()) {\n        final PsiElementFactory elementFactory = method.getManager().getElementFactory();\n        PsiType type = elementFactory.createType(method.getContainingClass(), substitutor);\n        String description = JavaErrorMessages.message(\"generics.unchecked.call.to.member.of.raw.type\",\n                                                       HighlightUtil.formatMethod(method),\n                                                       HighlightUtil.formatType(type));\n        PsiElement element = call instanceof PsiMethodCallExpression\n                             ? ((PsiMethodCallExpression)call).getMethodExpression()\n                             : call;\n        if (InspectionManagerEx.inspectionResultSuppressed(call, UncheckedWarningLocalInspection.ID)) return null;\n        HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.UNCHECKED_WARNING, element, description);\n        List<IntentionAction> options = IntentionManager.getInstance(call.getProject()).getStandardIntentionOptions(key,call);\n        String displayName = UncheckedWarningLocalInspection.DISPLAY_NAME;\n        QuickFixAction.registerQuickFixAction(highlightInfo, new GenerifyFileFix(element.getContainingFile()), options, displayName);\n        return highlightInfo;\n      }\n    }\n    return null;\n  }","commit_id":"5dc7665a6da5628c565b13b5c044ac4e8d555b50","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo checkReferenceTypeParametersList(final PsiTypeParameterListOwner typeParameterListOwner,\n                                                               final PsiJavaCodeReferenceElement referenceElement,\n                                                               final PsiSubstitutor substitutor, boolean registerIntentions) {\n    if (PsiUtil.getLanguageLevel(referenceElement).compareTo(LanguageLevel.JDK_1_5) < 0) {\n      final PsiReferenceParameterList parameterList = referenceElement.getParameterList();\n      if (parameterList != null && parameterList.getTypeParameterElements().length > 0) {\n        return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,\n                                                 parameterList,\n                                                 GENERICS_ARE_NOT_SUPPORTED);\n      }\n    }\n\n    final PsiTypeParameter[] typeParameters = typeParameterListOwner.getTypeParameters();\n    final int targetParametersNum = typeParameters.length;\n    final PsiReferenceParameterList referenceParameterList = referenceElement.getParameterList();\n    final int refParametersNum = referenceParameterList == null ? 0 : referenceParameterList.getTypeParameterElements().length;\n    if (targetParametersNum != refParametersNum && refParametersNum != 0) {\n      final String description;\n      if (targetParametersNum == 0) {\n        description = JavaErrorMessages.message(\n          \"generics.type.or.method.does.not.have.type.parameters\",\n          typeParameterListOwnerCategoryDescription(typeParameterListOwner),\n          typeParameterListOwnerDescription(typeParameterListOwner)\n        );\n      }\n      else {\n        description = JavaErrorMessages.message(\n          \"generics.wrong.number.of.type.arguments\",\n          new Integer(refParametersNum),\n          new Integer(targetParametersNum)\n        );\n      }\n\n      final HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,\n                                                                            referenceParameterList,\n                                                                            description);\n      if (registerIntentions) {\n        PsiElement parent = referenceElement.getParent();\n        if (parent instanceof PsiTypeElement) {\n          PsiElement variable = parent.getParent();\n          if (variable instanceof PsiVariable) {\n            VariableParameterizedTypeFix.registerIntentions(highlightInfo, (PsiVariable)variable, referenceElement);\n          }\n        }\n      }\n      return highlightInfo;\n    }\n\n    // bounds check\n    if (targetParametersNum > 0 && refParametersNum != 0) {\n      final PsiTypeElement[] referenceElements = referenceParameterList.getTypeParameterElements();\n      for (int i = 0; i < typeParameters.length; i++) {\n        PsiTypeParameter classParameter = typeParameters[i];\n        final PsiTypeElement typeElement = referenceElements[i];\n        final PsiType type = typeElement.getType();\n        if (!(type instanceof PsiClassType)) continue;\n        final PsiClass referenceClass = ((PsiClassType)type).resolve();\n        if (referenceClass == null) continue;\n        final PsiClassType[] bounds = classParameter.getSuperTypes();\n        for (PsiClassType type1 : bounds) {\n          PsiType bound = substitutor.substitute(type1);\n          if (!bound.equalsToText(\"java.lang.Object\") && !TypeConversionUtil.isAssignable(bound, type)) {\n            PsiClass boundClass = bound instanceof PsiClassType ? ((PsiClassType)bound).resolve() : null;\n\n            @NonNls final String messageKey = boundClass == null || referenceClass.isInterface() == boundClass.isInterface()\n                                              ? \"generics.type.parameter.is.not.within.its.bound.extend\"\n                                              : \"generics.type.parameter.is.not.within.its.bound.implement\";\n\n            String description = JavaErrorMessages.message(messageKey,\n                                                           HighlightUtil.formatClass(referenceClass),\n                                                           HighlightUtil.formatType(bound));\n\n            final HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,\n                                                                                  typeElement,\n                                                                                  description);\n            if (bound instanceof PsiClassType) {\n              QuickFixAction.registerQuickFixAction(highlightInfo, QUICK_FIX_FACTORY.createExtendsListFix(referenceClass, (PsiClassType)bound, true), null, null);\n            }\n            return highlightInfo;\n          }\n        }\n      }\n    }\n\n    return null;\n  }","id":102236,"modified_method":"public static HighlightInfo checkReferenceTypeParametersList(final PsiTypeParameterListOwner typeParameterListOwner,\n                                                               final PsiJavaCodeReferenceElement referenceElement,\n                                                               final PsiSubstitutor substitutor, boolean registerIntentions) {\n    if (PsiUtil.getLanguageLevel(referenceElement).compareTo(LanguageLevel.JDK_1_5) < 0) {\n      final PsiReferenceParameterList parameterList = referenceElement.getParameterList();\n      if (parameterList != null && parameterList.getTypeParameterElements().length > 0) {\n        return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,\n                                                 parameterList,\n                                                 GENERICS_ARE_NOT_SUPPORTED);\n      }\n    }\n\n    final PsiTypeParameter[] typeParameters = typeParameterListOwner.getTypeParameters();\n    final int targetParametersNum = typeParameters.length;\n    final PsiReferenceParameterList referenceParameterList = referenceElement.getParameterList();\n    final int refParametersNum = referenceParameterList == null ? 0 : referenceParameterList.getTypeParameterElements().length;\n    if (targetParametersNum != refParametersNum && refParametersNum != 0) {\n      final String description;\n      if (targetParametersNum == 0) {\n        description = JavaErrorMessages.message(\n          \"generics.type.or.method.does.not.have.type.parameters\",\n          typeParameterListOwnerCategoryDescription(typeParameterListOwner),\n          typeParameterListOwnerDescription(typeParameterListOwner)\n        );\n      }\n      else {\n        description = JavaErrorMessages.message(\n          \"generics.wrong.number.of.type.arguments\", refParametersNum, targetParametersNum\n        );\n      }\n\n      final HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,\n                                                                            referenceParameterList,\n                                                                            description);\n      if (registerIntentions) {\n        PsiElement parent = referenceElement.getParent();\n        if (parent instanceof PsiTypeElement) {\n          PsiElement variable = parent.getParent();\n          if (variable instanceof PsiVariable) {\n            VariableParameterizedTypeFix.registerIntentions(highlightInfo, (PsiVariable)variable, referenceElement);\n          }\n        }\n      }\n      return highlightInfo;\n    }\n\n    // bounds check\n    if (targetParametersNum > 0 && refParametersNum != 0) {\n      final PsiTypeElement[] referenceElements = referenceParameterList.getTypeParameterElements();\n      for (int i = 0; i < typeParameters.length; i++) {\n        PsiTypeParameter classParameter = typeParameters[i];\n        final PsiTypeElement typeElement = referenceElements[i];\n        final PsiType type = typeElement.getType();\n        if (!(type instanceof PsiClassType)) continue;\n        final PsiClass referenceClass = ((PsiClassType)type).resolve();\n        if (referenceClass == null) continue;\n        final PsiClassType[] bounds = classParameter.getSuperTypes();\n        for (PsiClassType type1 : bounds) {\n          PsiType bound = substitutor.substitute(type1);\n          if (!bound.equalsToText(\"java.lang.Object\") && !TypeConversionUtil.isAssignable(bound, type)) {\n            PsiClass boundClass = bound instanceof PsiClassType ? ((PsiClassType)bound).resolve() : null;\n\n            @NonNls final String messageKey = boundClass == null || referenceClass.isInterface() == boundClass.isInterface()\n                                              ? \"generics.type.parameter.is.not.within.its.bound.extend\"\n                                              : \"generics.type.parameter.is.not.within.its.bound.implement\";\n\n            String description = JavaErrorMessages.message(messageKey,\n                                                           HighlightUtil.formatClass(referenceClass),\n                                                           HighlightUtil.formatType(bound));\n\n            final HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,\n                                                                                  typeElement,\n                                                                                  description);\n            if (bound instanceof PsiClassType) {\n              QuickFixAction.registerQuickFixAction(highlightInfo, QUICK_FIX_FACTORY.createExtendsListFix(referenceClass, (PsiClassType)bound, true), null, null);\n            }\n            return highlightInfo;\n          }\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"5dc7665a6da5628c565b13b5c044ac4e8d555b50","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo checkUncheckedOverriding (PsiMethod overrider, final List<MethodSignatureBackedByPsiMethod> superMethodSignatures) {\n    if (PsiUtil.getLanguageLevel(overrider).compareTo(LanguageLevel.JDK_1_5) < 0) return null;\n    final HighlightDisplayKey key = HighlightDisplayKey.find(UncheckedWarningLocalInspection.SHORT_NAME);\n    if (!InspectionProjectProfileManager.getInstance(overrider.getProject()).getInspectionProfile(overrider).isToolEnabled(key)) return null;\n    if (InspectionManagerEx.inspectionResultSuppressed(overrider, UncheckedWarningLocalInspection.ID)) return null;\n    final MethodSignature signature = overrider.getSignature(PsiSubstitutor.EMPTY);\n    for (MethodSignatureBackedByPsiMethod superSignature : superMethodSignatures) {\n      PsiMethod baseMethod = superSignature.getMethod();\n      PsiSubstitutor substitutor = MethodSignatureUtil.getSuperMethodSignatureSubstitutor(signature, superSignature);\n      if (substitutor == null) substitutor = superSignature.getSubstitutor();\n      if (PsiUtil.isRawSubstitutor(baseMethod, superSignature.getSubstitutor())) continue;\n      final PsiType baseReturnType = substitutor.substitute(baseMethod.getReturnType());\n      final PsiType overriderReturnType = overrider.getReturnType();\n      if (baseReturnType == null || overriderReturnType == null) return null;\n      if (isRawToGeneric(baseReturnType, overriderReturnType)) {\n        final String message = JavaErrorMessages.message(\"unchecked.overriding.incompatible.return.type\",\n                                                         HighlightUtil.formatType(overriderReturnType),\n                                                         HighlightUtil.formatType(baseReturnType));\n\n        final HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.UNCHECKED_WARNING,\n                                                                              overrider.getReturnTypeElement(), message);\n        List<IntentionAction> options = IntentionManager.getInstance(overrider.getProject()).getStandardIntentionOptions(key,overrider.getReturnTypeElement());\n        String displayName = UncheckedWarningLocalInspection.DISPLAY_NAME;\n        QuickFixAction.registerQuickFixAction(highlightInfo,\n                                              new EmptyIntentionAction(JavaErrorMessages.message(\"unchecked.overriding\"), options),\n                                              options,\n                                              displayName);\n\n        return highlightInfo;\n      }\n    }\n    return null;\n  }","id":102237,"modified_method":"public static HighlightInfo checkUncheckedOverriding (PsiMethod overrider, final List<MethodSignatureBackedByPsiMethod> superMethodSignatures) {\n    if (PsiUtil.getLanguageLevel(overrider).compareTo(LanguageLevel.JDK_1_5) < 0) return null;\n    final HighlightDisplayKey key = HighlightDisplayKey.find(UncheckedWarningLocalInspection.SHORT_NAME);\n    if (!InspectionProjectProfileManager.getInstance(overrider.getProject()).getInspectionProfile(overrider).isToolEnabled(key)) return null;\n    if (InspectionManagerEx.inspectionResultSuppressed(overrider, UncheckedWarningLocalInspection.ID)) return null;\n    final MethodSignature signature = overrider.getSignature(PsiSubstitutor.EMPTY);\n    for (MethodSignatureBackedByPsiMethod superSignature : superMethodSignatures) {\n      PsiMethod baseMethod = superSignature.getMethod();\n      PsiSubstitutor substitutor = MethodSignatureUtil.getSuperMethodSignatureSubstitutor(signature, superSignature);\n      if (substitutor == null) substitutor = superSignature.getSubstitutor();\n      if (PsiUtil.isRawSubstitutor(baseMethod, superSignature.getSubstitutor())) continue;\n      final PsiType baseReturnType = substitutor.substitute(baseMethod.getReturnType());\n      final PsiType overriderReturnType = overrider.getReturnType();\n      if (baseReturnType == null || overriderReturnType == null) return null;\n      if (isRawToGeneric(baseReturnType, overriderReturnType)) {\n        final String message = JavaErrorMessages.message(\"unchecked.overriding.incompatible.return.type\",\n                                                         HighlightUtil.formatType(overriderReturnType),\n                                                         HighlightUtil.formatType(baseReturnType));\n\n        final PsiTypeElement returnTypeElement = overrider.getReturnTypeElement();\n        LOG.assertTrue(returnTypeElement != null);\n        final HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.UNCHECKED_WARNING, returnTypeElement, message);\n        List<IntentionAction> options = IntentionManager.getInstance(overrider.getProject()).getStandardIntentionOptions(key,returnTypeElement);\n        String displayName = UncheckedWarningLocalInspection.DISPLAY_NAME;\n        QuickFixAction.registerQuickFixAction(highlightInfo,\n                                              new EmptyIntentionAction(JavaErrorMessages.message(\"unchecked.overriding\"), options),\n                                              options,\n                                              displayName);\n\n        return highlightInfo;\n      }\n    }\n    return null;\n  }","commit_id":"5dc7665a6da5628c565b13b5c044ac4e8d555b50","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo checkTypeParameterExtendsList(PsiReferenceList referenceList, JavaResolveResult resolveResult, PsiElement context) {\n    PsiClass aClass = (PsiClass)referenceList.getParent();\n    final PsiJavaCodeReferenceElement[] referenceElements = referenceList.getReferenceElements();\n    HighlightInfo errorResult = null;\n    PsiClass extendFrom = (PsiClass)resolveResult.getElement();\n    if (!extendFrom.isInterface() && referenceElements.length != 0 && context != referenceElements[0]) {\n      final String description = HighlightClassUtil.INTERFACE_EXPECTED;\n      errorResult = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, context, description);\n      PsiClassType type = aClass.getManager().getElementFactory().createType(extendFrom, resolveResult.getSubstitutor());\n      QuickFixAction.registerQuickFixAction(errorResult, new MoveBoundClassToFrontFix(aClass, type), null, null);\n    }\n    return errorResult;\n  }","id":102238,"modified_method":"public static HighlightInfo checkTypeParameterExtendsList(PsiReferenceList referenceList, JavaResolveResult resolveResult, PsiElement context) {\n    PsiClass aClass = (PsiClass)referenceList.getParent();\n    final PsiJavaCodeReferenceElement[] referenceElements = referenceList.getReferenceElements();\n    HighlightInfo errorResult = null;\n    PsiClass extendFrom = (PsiClass)resolveResult.getElement();\n    if (extendFrom == null) return null;\n    if (!extendFrom.isInterface() && referenceElements.length != 0 && context != referenceElements[0]) {\n      final String description = HighlightClassUtil.INTERFACE_EXPECTED;\n      errorResult = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, context, description);\n      PsiClassType type = aClass.getManager().getElementFactory().createType(extendFrom, resolveResult.getSubstitutor());\n      QuickFixAction.registerQuickFixAction(errorResult, new MoveBoundClassToFrontFix(aClass, type), null, null);\n    }\n    return errorResult;\n  }","commit_id":"5dc7665a6da5628c565b13b5c044ac4e8d555b50","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo checkGenericCallWithRawArguments(JavaResolveResult resolveResult, PsiCallExpression callExpression) {\n    final PsiMethod method = (PsiMethod)resolveResult.getElement();\n    final PsiSubstitutor substitutor = resolveResult.getSubstitutor();\n    final PsiExpression[] expressions = callExpression.getArgumentList().getExpressions();\n    final PsiParameter[] parameters = method.getParameterList().getParameters();\n    for (int i = 0; i < expressions.length; i++) {\n      PsiParameter parameter = parameters[Math.min(i, parameters.length - 1)];\n      final PsiExpression expression = expressions[i];\n      final PsiType parameterType = substitutor.substitute(parameter.getType());\n      final PsiType expressionType = substitutor.substitute(expression.getType());\n      final HighlightInfo highlightInfo = checkRawToGenericAssignment(parameterType, expressionType, expression);\n      if (highlightInfo != null) return highlightInfo;\n    }\n    return null;\n  }","id":102239,"modified_method":"public static HighlightInfo checkGenericCallWithRawArguments(JavaResolveResult resolveResult, PsiCallExpression callExpression) {\n    final PsiMethod method = (PsiMethod)resolveResult.getElement();\n    if (method == null) return null;\n    final PsiSubstitutor substitutor = resolveResult.getSubstitutor();\n    final PsiExpressionList argumentList = callExpression.getArgumentList();\n    if (argumentList == null) return null;\n    final PsiExpression[] expressions = argumentList.getExpressions();\n    final PsiParameter[] parameters = method.getParameterList().getParameters();\n    for (int i = 0; i < expressions.length; i++) {\n      PsiParameter parameter = parameters[Math.min(i, parameters.length - 1)];\n      final PsiExpression expression = expressions[i];\n      final PsiType parameterType = substitutor.substitute(parameter.getType());\n      final PsiType expressionType = substitutor.substitute(expression.getType());\n      final HighlightInfo highlightInfo = checkRawToGenericAssignment(parameterType, expressionType, expression);\n      if (highlightInfo != null) return highlightInfo;\n    }\n    return null;\n  }","commit_id":"5dc7665a6da5628c565b13b5c044ac4e8d555b50","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public <T1, T2> T2 getPort(String serviceName, String portName, Class<T1> serviceClass,\n                               Class<T2> portTypeClass) throws Exception {\n        String namespace = \"http://cxf.apache.org/jms_simple\";\n        QName qServiceName = new QName(namespace, serviceName);\n        QName qPortName = new QName(namespace, portName);\n        URL wsdl = getClass().getResource(\"/wsdl/jms_spec_testsuite.wsdl\");\n        Definition def = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdl.toString());\n        assertNotNull(def);\n        BusFactory.setThreadDefaultBus(getBus());\n        BusFactory.setDefaultBus(getBus());\n        Class<? extends Service> svcls = serviceClass.asSubclass(Service.class);\n\n        Constructor<? extends Service> serviceConstructor = svcls.getConstructor(URL.class,\n                                                                                 QName.class);\n        Service service = serviceConstructor.newInstance(new Object[] {\n            wsdl, qServiceName\n        });\n        return service.getPort(qPortName, portTypeClass);\n    }","id":102240,"modified_method":"public <T1, T2> T2 getPort(String serviceName, String portName, Class<T1> serviceClass,\n                               Class<T2> portTypeClass) throws Exception {\n        String namespace = \"http://cxf.apache.org/jms_simple\";\n        QName qServiceName = new QName(namespace, serviceName);\n        QName qPortName = new QName(namespace, portName);\n        URL wsdl = getClass().getResource(\"/wsdl/jms_spec_testsuite.wsdl\");\n        String wsdlString = wsdl.toString();\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdlString);\n        BusFactory.setThreadDefaultBus(getBus());\n        BusFactory.setDefaultBus(getBus());\n        Class<? extends Service> svcls = serviceClass.asSubclass(Service.class);\n\n        Constructor<? extends Service> serviceConstructor = svcls.getConstructor(URL.class,\n                                                                                 QName.class);\n        Service service = serviceConstructor.newInstance(new Object[] {\n            wsdl, qServiceName\n        });\n        return service.getPort(qPortName, portTypeClass);\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"public static Definition updateWsdlExtensors(Bus bus, String wsdlLocation) {\n        try {\n            if (bus == null) {\n                bus = BusFactory.getThreadDefaultBus();\n            }\n            Definition def = bus.getExtension(WSDLManager.class)\n                .getDefinition(wsdlLocation);\n            Map map = def.getAllServices();\n            for (Object o : map.values()) {\n                Service service = (Service)o;\n                Map ports = service.getPorts();\n                for (Object p : ports.values()) {\n                    Port port = (Port)p;\n                    List<?> l = port.getExtensibilityElements();\n                    for (Object e : l) {\n                        if (e instanceof SOAPAddress) {\n                            String add = ((SOAPAddress)e).getLocationURI();\n                            int idx = add.indexOf(\"jndiURL=\");\n                            if (idx != -1) {\n                                int idx2 = add.indexOf(\"&\", idx);\n                                add = add.substring(0, idx)\n                                    + \"jndiURL=tcp://localhost:\" + PORT\n                                    + (idx2 == -1 ? \"\" : add.substring(idx2));\n                                ((SOAPAddress)e).setLocationURI(add);\n                            }\n                        } else {\n                            try {\n                                Field f = e.getClass().getDeclaredField(\"jmsNamingProperty\");\n                                f.setAccessible(true);\n                                List<?> props = (List)f.get(e);\n                                for (Object prop : props) {\n                                    f = prop.getClass().getDeclaredField(\"name\");\n                                    f.setAccessible(true);\n                                    if (\"java.naming.provider.url\".equals(f.get(prop))) {\n                                        f = prop.getClass().getDeclaredField(\"value\");\n                                        f.setAccessible(true);\n                                        f.set(prop, \"tcp://localhost:\" + PORT);\n                                    }\n                                }\n                            } catch (Exception ex) {\n                                //ignore\n                            }\n                        }\n                    }                    \n                }\n            }\n            return def;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }","id":102241,"modified_method":"public static void updateWsdlExtensors(Bus bus, String wsdlLocation) {\n        try {\n            if (bus == null) {\n                bus = BusFactory.getThreadDefaultBus();\n            }\n            Definition def = bus.getExtension(WSDLManager.class)\n                .getDefinition(wsdlLocation);\n            Map map = def.getAllServices();\n            for (Object o : map.values()) {\n                Service service = (Service)o;\n                Map ports = service.getPorts();\n                for (Object p : ports.values()) {\n                    Port port = (Port)p;\n                    List<?> l = port.getExtensibilityElements();\n                    for (Object e : l) {\n                        if (e instanceof SOAPAddress) {\n                            String add = ((SOAPAddress)e).getLocationURI();\n                            int idx = add.indexOf(\"jndiURL=\");\n                            if (idx != -1) {\n                                int idx2 = add.indexOf(\"&\", idx);\n                                add = add.substring(0, idx)\n                                    + \"jndiURL=tcp://localhost:\" + PORT\n                                    + (idx2 == -1 ? \"\" : add.substring(idx2));\n                                ((SOAPAddress)e).setLocationURI(add);\n                            }\n                        } else {\n                            try {\n                                Field f = e.getClass().getDeclaredField(\"jmsNamingProperty\");\n                                f.setAccessible(true);\n                                List<?> props = (List)f.get(e);\n                                for (Object prop : props) {\n                                    f = prop.getClass().getDeclaredField(\"name\");\n                                    f.setAccessible(true);\n                                    if (\"java.naming.provider.url\".equals(f.get(prop))) {\n                                        f = prop.getClass().getDeclaredField(\"value\");\n                                        f.setAccessible(true);\n                                        f.set(prop, \"tcp://localhost:\" + PORT);\n                                    }\n                                }\n                            } catch (Exception ex) {\n                                //ignore\n                            }\n                        }\n                    }                    \n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testHttpWrappedContinuatuions() throws Exception {\n        SpringBusFactory bf = new SpringBusFactory();\n        Bus bus = bf.createBus(CONFIG_FILE);\n        BusFactory.setDefaultBus(bus);\n        \n        QName serviceName = new QName(\"http://cxf.apache.org/systest/jaxws\", \"HelloContinuationService\");\n        \n        URL wsdlURL = getClass().getResource(\"/org/apache/cxf/systest/jms/continuations/test2.wsdl\");\n        Definition def = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdlURL.toString());\n        assertNotNull(def);\n        HelloContinuationService service = new HelloContinuationService(wsdlURL, serviceName);\n        assertNotNull(service);\n        final HelloContinuation helloPort = service.getHelloContinuationPort();\n        \n        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 5, 0, TimeUnit.SECONDS,\n                                                             new ArrayBlockingQueue<Runnable>(10));\n        CountDownLatch startSignal = new CountDownLatch(1);\n        CountDownLatch helloDoneSignal = new CountDownLatch(5);\n        \n        executor.execute(new HelloWorker(helloPort, \"Fred\", \"\", startSignal, helloDoneSignal));\n        startSignal.countDown();\n        \n        Thread.sleep(10000);\n                \n        executor.execute(new HelloWorker(helloPort, \"Barry\", \"Jameson\", startSignal, helloDoneSignal));\n        executor.execute(new HelloWorker(helloPort, \"Harry\", \"\", startSignal, helloDoneSignal));\n        executor.execute(new HelloWorker(helloPort, \"Rob\", \"Davidson\", startSignal, helloDoneSignal));\n        executor.execute(new HelloWorker(helloPort, \"James\", \"ServiceMix\", startSignal, helloDoneSignal));\n        \n                \n        helloDoneSignal.await(60, TimeUnit.SECONDS);\n        executor.shutdownNow();\n        System.out.println(\"Completed : \" + (5 - helloDoneSignal.getCount()));\n        assertEquals(\"Not all invocations have completed\", 0, helloDoneSignal.getCount());\n    }","id":102242,"modified_method":"@Test\n    public void testHttpWrappedContinuatuions() throws Exception {\n        SpringBusFactory bf = new SpringBusFactory();\n        Bus bus = bf.createBus(CONFIG_FILE);\n        BusFactory.setDefaultBus(bus);\n        \n        QName serviceName = new QName(\"http://cxf.apache.org/systest/jaxws\", \"HelloContinuationService\");\n        \n        URL wsdlURL = getClass().getResource(\"/org/apache/cxf/systest/jms/continuations/test2.wsdl\");\n        String wsdlString = wsdlURL.toString().intern();\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdlString);\n        HelloContinuationService service = new HelloContinuationService(wsdlURL, serviceName);\n        assertNotNull(service);\n        final HelloContinuation helloPort = service.getHelloContinuationPort();\n        \n        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 5, 0, TimeUnit.SECONDS,\n                                                             new ArrayBlockingQueue<Runnable>(10));\n        CountDownLatch startSignal = new CountDownLatch(1);\n        CountDownLatch helloDoneSignal = new CountDownLatch(5);\n        \n        executor.execute(new HelloWorker(helloPort, \"Fred\", \"\", startSignal, helloDoneSignal));\n        startSignal.countDown();\n        \n        Thread.sleep(10000);\n                \n        executor.execute(new HelloWorker(helloPort, \"Barry\", \"Jameson\", startSignal, helloDoneSignal));\n        executor.execute(new HelloWorker(helloPort, \"Harry\", \"\", startSignal, helloDoneSignal));\n        executor.execute(new HelloWorker(helloPort, \"Rob\", \"Davidson\", startSignal, helloDoneSignal));\n        executor.execute(new HelloWorker(helloPort, \"James\", \"ServiceMix\", startSignal, helloDoneSignal));\n        \n                \n        helloDoneSignal.await(60, TimeUnit.SECONDS);\n        executor.shutdownNow();\n        System.out.println(\"Completed : \" + (5 - helloDoneSignal.getCount()));\n        assertEquals(\"Not all invocations have completed\", 0, helloDoneSignal.getCount());\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"public URL getWSDLURL(String s) throws Exception {\n        URL u = getClass().getResource(s);\n        definition = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), u.toString());\n        assertNotNull(definition);\n        return u;\n    }","id":102243,"modified_method":"public URL getWSDLURL(String s) throws Exception {\n        URL u = getClass().getResource(s);\n        wsdlString = u.toString().intern();\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdlString);\n        System.gc();\n        System.gc();\n        return u;\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testQueueDecoupledOneWaysConnection() throws Exception {\n        QName serviceName = getServiceName(new QName(\"http://cxf.apache.org/hello_world_jms\", \n                                                     \"HelloWorldQueueDecoupledOneWaysService\"));\n        QName portName = getPortName(new QName(\"http://cxf.apache.org/hello_world_jms\", \n                                               \"HelloWorldQueueDecoupledOneWaysPort\"));\n        URL wsdl = getWSDLURL(\"/wsdl/jms_test.wsdl\");\n        assertNotNull(wsdl);\n        Definition def1 = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdl.toString());\n        Definition def2 = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), \"testutils/jms_test.wsdl\");\n        assertNotNull(def1);\n        assertNotNull(def2);\n        \n\n        HelloWorldQueueDecoupledOneWaysService service = \n            new HelloWorldQueueDecoupledOneWaysService(wsdl, serviceName);\n        assertNotNull(service);\n        Endpoint requestEndpoint = null;\n        Endpoint replyEndpoint = null;\n        try {\n            HelloWorldOneWayPort greeter = service.getPort(portName, HelloWorldOneWayPort.class);\n            GreeterImplQueueDecoupledOneWays requestServant = new GreeterImplQueueDecoupledOneWays();\n            requestEndpoint = Endpoint.publish(\"\", requestServant);\n            GreeterImplQueueDecoupledOneWaysDeferredReply replyServant = \n                new GreeterImplQueueDecoupledOneWaysDeferredReply();\n            replyEndpoint = Endpoint.publish(\"\", replyServant);\n            \n            BindingProvider  bp = (BindingProvider)greeter;\n            Map<String, Object> requestContext = bp.getRequestContext();\n            JMSMessageHeadersType requestHeader = new JMSMessageHeadersType();\n            requestHeader.setJMSReplyTo(\"dynamicQueues/test.jmstransport.oneway.with.set.replyto.reply\");\n            requestContext.put(JMSConstants.JMS_CLIENT_REQUEST_HEADERS, requestHeader);\n            String expectedRequest = \"JMS:Queue:Request\"; \n            greeter.greetMeOneWay(expectedRequest);\n            String request = requestServant.ackRequestReceived(5000);\n            if (request == null) {\n                if (requestServant.getException() != null) {\n                    fail(requestServant.getException().getMessage());\n                } else {\n                    fail(\"The oneway call didn't reach its intended endpoint\");\n                }\n            }\n            assertEquals(expectedRequest, request);\n            requestServant.proceedWithReply();\n            String expectedReply = requestServant.ackReplySent(5000);\n            if (expectedReply == null) {\n                if (requestServant.getException() != null) {\n                    fail(requestServant.getException().getMessage());\n                } else {\n                    fail(\"The decoupled one-way reply was not sent\");\n                }\n            }\n            String reply = replyServant.ackRequest(5000);\n            if (reply == null) {\n                if (replyServant.getException() != null) {\n                    fail(replyServant.getException().getMessage());\n                } else {\n                    fail(\"The decoupled one-way reply didn't reach its intended endpoint\");\n                }\n            }\n            assertEquals(expectedReply, reply);\n        } catch (Exception ex) {\n            throw ex;\n        } finally {\n            if (requestEndpoint != null) {\n                requestEndpoint.stop();\n            }\n            if (replyEndpoint != null) {\n                replyEndpoint.stop();\n            }\n        }\n    }","id":102244,"modified_method":"@Test\n    public void testQueueDecoupledOneWaysConnection() throws Exception {\n        QName serviceName = getServiceName(new QName(\"http://cxf.apache.org/hello_world_jms\", \n                                                     \"HelloWorldQueueDecoupledOneWaysService\"));\n        QName portName = getPortName(new QName(\"http://cxf.apache.org/hello_world_jms\", \n                                               \"HelloWorldQueueDecoupledOneWaysPort\"));\n        URL wsdl = getWSDLURL(\"/wsdl/jms_test.wsdl\");\n        assertNotNull(wsdl);\n        String wsdlString2 = wsdl.toString();\n        String wsdlString3 = \"testutils/jms_test.wsdl\";\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdlString2);\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdlString3);\n        \n\n        HelloWorldQueueDecoupledOneWaysService service = \n            new HelloWorldQueueDecoupledOneWaysService(wsdl, serviceName);\n        assertNotNull(service);\n        Endpoint requestEndpoint = null;\n        Endpoint replyEndpoint = null;\n        try {\n            HelloWorldOneWayPort greeter = service.getPort(portName, HelloWorldOneWayPort.class);\n            GreeterImplQueueDecoupledOneWays requestServant = new GreeterImplQueueDecoupledOneWays();\n            requestEndpoint = Endpoint.publish(\"\", requestServant);\n            GreeterImplQueueDecoupledOneWaysDeferredReply replyServant = \n                new GreeterImplQueueDecoupledOneWaysDeferredReply();\n            replyEndpoint = Endpoint.publish(\"\", replyServant);\n            \n            BindingProvider  bp = (BindingProvider)greeter;\n            Map<String, Object> requestContext = bp.getRequestContext();\n            JMSMessageHeadersType requestHeader = new JMSMessageHeadersType();\n            requestHeader.setJMSReplyTo(\"dynamicQueues/test.jmstransport.oneway.with.set.replyto.reply\");\n            requestContext.put(JMSConstants.JMS_CLIENT_REQUEST_HEADERS, requestHeader);\n            String expectedRequest = \"JMS:Queue:Request\"; \n            greeter.greetMeOneWay(expectedRequest);\n            String request = requestServant.ackRequestReceived(5000);\n            if (request == null) {\n                if (requestServant.getException() != null) {\n                    fail(requestServant.getException().getMessage());\n                } else {\n                    fail(\"The oneway call didn't reach its intended endpoint\");\n                }\n            }\n            assertEquals(expectedRequest, request);\n            requestServant.proceedWithReply();\n            String expectedReply = requestServant.ackReplySent(5000);\n            if (expectedReply == null) {\n                if (requestServant.getException() != null) {\n                    fail(requestServant.getException().getMessage());\n                } else {\n                    fail(\"The decoupled one-way reply was not sent\");\n                }\n            }\n            String reply = replyServant.ackRequest(5000);\n            if (reply == null) {\n                if (replyServant.getException() != null) {\n                    fail(replyServant.getException().getMessage());\n                } else {\n                    fail(\"The decoupled one-way reply didn't reach its intended endpoint\");\n                }\n            }\n            assertEquals(expectedReply, reply);\n        } catch (Exception ex) {\n            throw ex;\n        } finally {\n            if (requestEndpoint != null) {\n                requestEndpoint.stop();\n            }\n            if (replyEndpoint != null) {\n                replyEndpoint.stop();\n            }\n        }\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"@Test \n    public void testConnectionsWithinSpring() throws Exception {\n        BusFactory.setDefaultBus(null);\n        BusFactory.setThreadDefaultBus(null);\n        \n        ClassPathXmlApplicationContext ctx = \n            new ClassPathXmlApplicationContext(\n                new String[] {\"/org/apache/cxf/systest/jms/JMSClients.xml\"});\n        Definition def = EmbeddedJMSBrokerLauncher.updateWsdlExtensors((Bus)ctx.getBean(\"cxf\"),\n                                                          \"classpath:wsdl/jms_test.wsdl\");\n        assertNotNull(def);\n        HelloWorldPortType greeter = (HelloWorldPortType)ctx.getBean(\"jmsRPCClient\");\n        assertNotNull(greeter);\n        \n        String response1 = new String(\"Hello Milestone-\");\n        String response2 = new String(\"Bonjour\");\n        try {\n            \n            for (int idx = 0; idx < 5; idx++) {\n                String greeting = greeter.greetMe(\"Milestone-\" + idx);\n                assertNotNull(\"no response received from service\", greeting);\n                String exResponse = response1 + idx;\n                assertEquals(exResponse, greeting);\n\n                String reply = greeter.sayHi();\n                assertNotNull(\"no response received from service\", reply);\n                assertEquals(response2, reply);\n                \n                try {\n                    greeter.testRpcLitFault(\"BadRecordLitFault\");\n                    fail(\"Should have thrown BadRecoedLitFault\");\n                } catch (BadRecordLitFault ex) {\n                    assertNotNull(ex.getFaultInfo());\n                }\n                \n                try {\n                    greeter.testRpcLitFault(\"NoSuchCodeLitFault\");\n                    fail(\"Should have thrown NoSuchCodeLitFault exception\");\n                } catch (NoSuchCodeLitFault nslf) {\n                    assertNotNull(nslf.getFaultInfo());\n                    assertNotNull(nslf.getFaultInfo().getCode());\n                } \n            }\n        } catch (UndeclaredThrowableException ex) {\n            throw (Exception)ex.getCause();\n        }\n        \n        HelloWorldOneWayPort greeter1 = (HelloWorldOneWayPort)ctx.getBean(\"jmsQueueOneWayServiceClient\");\n        assertNotNull(greeter1);\n        try {\n            greeter1.greetMeOneWay(\"hello\");\n        } catch (Exception ex) {\n            fail(\"There should not throw the exception\" + ex);\n        }\n        ctx.close();\n        BusFactory.setDefaultBus(getBus());\n        BusFactory.setThreadDefaultBus(getBus());\n    }","id":102245,"modified_method":"@Test \n    public void testConnectionsWithinSpring() throws Exception {\n        BusFactory.setDefaultBus(null);\n        BusFactory.setThreadDefaultBus(null);\n        \n        ClassPathXmlApplicationContext ctx = \n            new ClassPathXmlApplicationContext(\n                new String[] {\"/org/apache/cxf/systest/jms/JMSClients.xml\"});\n        String wsdlString2 = \"classpath:wsdl/jms_test.wsdl\";\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors((Bus)ctx.getBean(\"cxf\"),\n                                                          wsdlString2);\n        HelloWorldPortType greeter = (HelloWorldPortType)ctx.getBean(\"jmsRPCClient\");\n        assertNotNull(greeter);\n        \n        String response1 = new String(\"Hello Milestone-\");\n        String response2 = new String(\"Bonjour\");\n        try {\n            \n            for (int idx = 0; idx < 5; idx++) {\n                String greeting = greeter.greetMe(\"Milestone-\" + idx);\n                assertNotNull(\"no response received from service\", greeting);\n                String exResponse = response1 + idx;\n                assertEquals(exResponse, greeting);\n\n                String reply = greeter.sayHi();\n                assertNotNull(\"no response received from service\", reply);\n                assertEquals(response2, reply);\n                \n                try {\n                    greeter.testRpcLitFault(\"BadRecordLitFault\");\n                    fail(\"Should have thrown BadRecoedLitFault\");\n                } catch (BadRecordLitFault ex) {\n                    assertNotNull(ex.getFaultInfo());\n                }\n                \n                try {\n                    greeter.testRpcLitFault(\"NoSuchCodeLitFault\");\n                    fail(\"Should have thrown NoSuchCodeLitFault exception\");\n                } catch (NoSuchCodeLitFault nslf) {\n                    assertNotNull(nslf.getFaultInfo());\n                    assertNotNull(nslf.getFaultInfo().getCode());\n                } \n            }\n        } catch (UndeclaredThrowableException ex) {\n            throw (Exception)ex.getCause();\n        }\n        \n        HelloWorldOneWayPort greeter1 = (HelloWorldOneWayPort)ctx.getBean(\"jmsQueueOneWayServiceClient\");\n        assertNotNull(greeter1);\n        try {\n            greeter1.greetMeOneWay(\"hello\");\n        } catch (Exception ex) {\n            fail(\"There should not throw the exception\" + ex);\n        }\n        ctx.close();\n        BusFactory.setDefaultBus(getBus());\n        BusFactory.setThreadDefaultBus(getBus());\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testQueueOneWaySpecCompliantConnection() throws Exception {\n        QName serviceName = getServiceName(new QName(\"http://cxf.apache.org/hello_world_jms\", \n                                                     \"HelloWorldQueueDecoupledOneWaysService\"));\n        QName portName = getPortName(new QName(\"http://cxf.apache.org/hello_world_jms\", \n                                               \"HelloWorldQueueDecoupledOneWaysPort\"));\n        URL wsdl = getWSDLURL(\"/wsdl/jms_test.wsdl\");\n        assertNotNull(wsdl);\n        Definition def = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), \"testutils/jms_test.wsdl\");\n        assertNotNull(def);\n\n        HelloWorldQueueDecoupledOneWaysService service = \n            new HelloWorldQueueDecoupledOneWaysService(wsdl, serviceName);\n        assertNotNull(service);\n        Endpoint requestEndpoint = null;\n        try {\n            HelloWorldOneWayPort greeter = service.getPort(portName, HelloWorldOneWayPort.class);\n            GreeterImplQueueDecoupledOneWays requestServant = new GreeterImplQueueDecoupledOneWays(true);\n            requestEndpoint = Endpoint.publish(\"\", requestServant);\n            \n            Client client = ClientProxy.getClient(greeter);\n            ((JMSConduit)client.getConduit()).getJmsConfig().setEnforceSpec(true);\n            BindingProvider  bp = (BindingProvider)greeter;\n            Map<String, Object> requestContext = bp.getRequestContext();\n            JMSMessageHeadersType requestHeader = new JMSMessageHeadersType();\n            requestHeader.setJMSReplyTo(\"dynamicQueues/test.jmstransport.oneway.with.set.replyto.reply\");\n            requestContext.put(JMSConstants.JMS_CLIENT_REQUEST_HEADERS, requestHeader);\n            String expectedRequest = \"JMS:Queue:Request\"; \n            greeter.greetMeOneWay(expectedRequest);\n            String request = requestServant.ackRequestReceived(5000);\n            if (request == null) {\n                if (requestServant.getException() != null) {\n                    fail(requestServant.getException().getMessage());\n                } else {\n                    fail(\"The oneway call didn't reach its intended endpoint\");\n                }\n            }\n            assertEquals(expectedRequest, request);\n            requestServant.proceedWithReply();\n            boolean ack = requestServant.ackNoReplySent(5000);\n            if (!ack) {\n                if (requestServant.getException() != null) {\n                    fail(requestServant.getException().getMessage());\n                } else {\n                    fail(\"The decoupled one-way reply was sent\");\n                }\n            }\n        } catch (Exception ex) {\n            throw ex;\n        } finally {\n            if (requestEndpoint != null) {\n                requestEndpoint.stop();\n            }\n        }\n\n    }","id":102246,"modified_method":"@Test\n    public void testQueueOneWaySpecCompliantConnection() throws Exception {\n        QName serviceName = getServiceName(new QName(\"http://cxf.apache.org/hello_world_jms\", \n                                                     \"HelloWorldQueueDecoupledOneWaysService\"));\n        QName portName = getPortName(new QName(\"http://cxf.apache.org/hello_world_jms\", \n                                               \"HelloWorldQueueDecoupledOneWaysPort\"));\n        URL wsdl = getWSDLURL(\"/wsdl/jms_test.wsdl\");\n        assertNotNull(wsdl);\n        String wsdlString2 = \"testutils/jms_test.wsdl\";\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdlString2);\n\n        HelloWorldQueueDecoupledOneWaysService service = \n            new HelloWorldQueueDecoupledOneWaysService(wsdl, serviceName);\n        assertNotNull(service);\n        Endpoint requestEndpoint = null;\n        try {\n            HelloWorldOneWayPort greeter = service.getPort(portName, HelloWorldOneWayPort.class);\n            GreeterImplQueueDecoupledOneWays requestServant = new GreeterImplQueueDecoupledOneWays(true);\n            requestEndpoint = Endpoint.publish(\"\", requestServant);\n            \n            Client client = ClientProxy.getClient(greeter);\n            ((JMSConduit)client.getConduit()).getJmsConfig().setEnforceSpec(true);\n            BindingProvider  bp = (BindingProvider)greeter;\n            Map<String, Object> requestContext = bp.getRequestContext();\n            JMSMessageHeadersType requestHeader = new JMSMessageHeadersType();\n            requestHeader.setJMSReplyTo(\"dynamicQueues/test.jmstransport.oneway.with.set.replyto.reply\");\n            requestContext.put(JMSConstants.JMS_CLIENT_REQUEST_HEADERS, requestHeader);\n            String expectedRequest = \"JMS:Queue:Request\"; \n            greeter.greetMeOneWay(expectedRequest);\n            String request = requestServant.ackRequestReceived(5000);\n            if (request == null) {\n                if (requestServant.getException() != null) {\n                    fail(requestServant.getException().getMessage());\n                } else {\n                    fail(\"The oneway call didn't reach its intended endpoint\");\n                }\n            }\n            assertEquals(expectedRequest, request);\n            requestServant.proceedWithReply();\n            boolean ack = requestServant.ackNoReplySent(5000);\n            if (!ack) {\n                if (requestServant.getException() != null) {\n                    fail(requestServant.getException().getMessage());\n                } else {\n                    fail(\"The decoupled one-way reply was sent\");\n                }\n            }\n        } catch (Exception ex) {\n            throw ex;\n        } finally {\n            if (requestEndpoint != null) {\n                requestEndpoint.stop();\n            }\n        }\n\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testContinuationWithTimeout() throws Exception {\n        QName serviceName = getServiceName(new QName(\"http://cxf.apache.org/hello_world_jms\", \n                                 \"HelloWorldService\"));\n        QName portName = getPortName(new QName(\"http://cxf.apache.org/hello_world_jms\", \"HelloWorldPort\"));\n        URL wsdl = getWSDLURL(\"/org/apache/cxf/systest/jms/continuations/jms_test.wsdl\");\n        assertNotNull(wsdl);\n        \n        Definition def = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdl.toString());\n        assertNotNull(def);\n\n        HelloWorldService service = new HelloWorldService(wsdl, serviceName);\n        assertNotNull(service);\n\n        HelloWorldPortType greeter = service.getPort(portName, HelloWorldPortType.class);\n        assertEquals(\"Hi Fred Ruby\", greeter.greetMe(\"Fred\"));\n    }","id":102247,"modified_method":"@Test\n    public void testContinuationWithTimeout() throws Exception {\n        QName serviceName = getServiceName(new QName(\"http://cxf.apache.org/hello_world_jms\", \n                                 \"HelloWorldService\"));\n        QName portName = getPortName(new QName(\"http://cxf.apache.org/hello_world_jms\", \"HelloWorldPort\"));\n        URL wsdl = getWSDLURL(\"/org/apache/cxf/systest/jms/continuations/jms_test.wsdl\");\n        assertNotNull(wsdl);\n        String wsdlString = wsdl.toString();\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdlString);\n\n        HelloWorldService service = new HelloWorldService(wsdl, serviceName);\n        assertNotNull(service);\n\n        HelloWorldPortType greeter = service.getPort(portName, HelloWorldPortType.class);\n        assertEquals(\"Hi Fred Ruby\", greeter.greetMe(\"Fred\"));\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testDocBasicConnection() throws Exception {\n        QName serviceName = getServiceName(new QName(\"http://apache.org/hello_world_doc_lit\", \n                                 \"SOAPService2\"));\n        QName portName = getPortName(new QName(\"http://apache.org/hello_world_doc_lit\", \"SoapPort2\"));\n        URL wsdl = getWSDLURL(\"/wsdl/hello_world_doc_lit.wsdl\");\n        assertNotNull(wsdl);\n        Definition def = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdl.toString());\n        assertNotNull(def);\n        SOAPService2 service = new SOAPService2(wsdl, serviceName);\n        assertNotNull(service);\n\n        Greeter greeter = service.getPort(portName, Greeter.class);\n        doService(greeter, true);\n    }","id":102248,"modified_method":"@Test\n    public void testDocBasicConnection() throws Exception {\n        QName serviceName = getServiceName(new QName(\"http://apache.org/hello_world_doc_lit\", \n                                 \"SOAPService2\"));\n        QName portName = getPortName(new QName(\"http://apache.org/hello_world_doc_lit\", \"SoapPort2\"));\n        URL wsdl = getWSDLURL(\"/wsdl/hello_world_doc_lit.wsdl\");\n        assertNotNull(wsdl);\n        String wsdlString = wsdl.toString();\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdlString);\n        SOAPService2 service = new SOAPService2(wsdl, serviceName);\n        assertNotNull(service);\n\n        Greeter greeter = service.getPort(portName, Greeter.class);\n        doService(greeter, true);\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"protected void run() {\n            Object implementor = new HTTPGreeterImpl();\n            String address = \"http://localhost:\" + PORT + \"/SOAPDocLitService/SoapPort\";\n            Endpoint.publish(address, implementor);\n            def = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(),\n                                                                \"testutils/hello_world_doc_lit.wsdl\");\n            implementor = new JMSGreeterImpl();\n            Endpoint.publish(null, implementor);\n        }","id":102249,"modified_method":"protected void run() {\n            Object implementor = new HTTPGreeterImpl();\n            String address = \"http://localhost:\" + PORT + \"/SOAPDocLitService/SoapPort\";\n            Endpoint.publish(address, implementor);\n            EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(),\n                                                          \"testutils/hello_world_doc_lit.wsdl\");\n            implementor = new JMSGreeterImpl();\n            Endpoint.publish(null, implementor);\n        }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testMultiTransportInOneService() throws Exception {\n        \n        QName portName1 = new QName(\"http://apache.org/hello_world_doc_lit\", \"HttpPort\");\n        QName portName2 = new QName(\"http://apache.org/hello_world_doc_lit\", \"JMSPort\");\n        URL wsdl = getClass().getResource(\"/wsdl/hello_world_doc_lit.wsdl\");\n        assertNotNull(wsdl);\n        Definition def = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdl.toString());\n        assertNotNull(def);\n\n        MultiTransportService service = new MultiTransportService(wsdl, serviceName);\n        assertNotNull(service);\n\n        String response1 = new String(\"Hello Milestone-\");\n        String response2 = new String(\"Bonjour\");\n        try {\n            Greeter greeter = service.getPort(portName1, Greeter.class);\n            updateAddressPort(greeter, PORT);\n            for (int idx = 0; idx < 5; idx++) {\n                String greeting = greeter.greetMe(\"Milestone-\" + idx);\n                assertNotNull(\"no response received from service\", greeting);\n                String exResponse = response1 + idx;\n                assertEquals(exResponse, greeting);\n\n                String reply = greeter.sayHi();\n                assertNotNull(\"no response received from service\", reply);\n                assertEquals(response2, reply);\n                \n                try {\n                    greeter.pingMe();\n                    fail(\"Should have thrown FaultException\");\n                } catch (PingMeFault ex) {\n                    assertNotNull(ex.getFaultInfo());\n                }                \n              \n            }\n            \n            greeter = service.getPort(portName2, Greeter.class);\n            for (int idx = 0; idx < 5; idx++) {\n                String greeting = greeter.greetMe(\"Milestone-\" + idx);\n                assertNotNull(\"no response received from service\", greeting);\n                String exResponse = response1 + idx;\n                assertEquals(exResponse, greeting);\n\n                String reply = greeter.sayHi();\n                assertNotNull(\"no response received from service\", reply);\n                assertEquals(response2, reply);\n                \n                try {\n                    greeter.pingMe();\n                    fail(\"Should have thrown FaultException\");\n                } catch (PingMeFault ex) {\n                    assertNotNull(ex.getFaultInfo());\n                }                \n              \n            }\n\n            \n        } catch (UndeclaredThrowableException ex) {\n            throw (Exception)ex.getCause();\n        }\n    }","id":102250,"modified_method":"@Test\n    public void testMultiTransportInOneService() throws Exception {\n        \n        QName portName1 = new QName(\"http://apache.org/hello_world_doc_lit\", \"HttpPort\");\n        QName portName2 = new QName(\"http://apache.org/hello_world_doc_lit\", \"JMSPort\");\n        URL wsdl = getClass().getResource(\"/wsdl/hello_world_doc_lit.wsdl\");\n        assertNotNull(wsdl);\n        String wsdlString = wsdl.toString();\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(getBus(), wsdlString);\n\n        MultiTransportService service = new MultiTransportService(wsdl, serviceName);\n        assertNotNull(service);\n\n        String response1 = new String(\"Hello Milestone-\");\n        String response2 = new String(\"Bonjour\");\n        try {\n            Greeter greeter = service.getPort(portName1, Greeter.class);\n            updateAddressPort(greeter, PORT);\n            for (int idx = 0; idx < 5; idx++) {\n                String greeting = greeter.greetMe(\"Milestone-\" + idx);\n                assertNotNull(\"no response received from service\", greeting);\n                String exResponse = response1 + idx;\n                assertEquals(exResponse, greeting);\n\n                String reply = greeter.sayHi();\n                assertNotNull(\"no response received from service\", reply);\n                assertEquals(response2, reply);\n                \n                try {\n                    greeter.pingMe();\n                    fail(\"Should have thrown FaultException\");\n                } catch (PingMeFault ex) {\n                    assertNotNull(ex.getFaultInfo());\n                }                \n              \n            }\n            \n            greeter = service.getPort(portName2, Greeter.class);\n            for (int idx = 0; idx < 5; idx++) {\n                String greeting = greeter.greetMe(\"Milestone-\" + idx);\n                assertNotNull(\"no response received from service\", greeting);\n                String exResponse = response1 + idx;\n                assertEquals(exResponse, greeting);\n\n                String reply = greeter.sayHi();\n                assertNotNull(\"no response received from service\", reply);\n                assertEquals(response2, reply);\n                \n                try {\n                    greeter.pingMe();\n                    fail(\"Should have thrown FaultException\");\n                } catch (PingMeFault ex) {\n                    assertNotNull(ex.getFaultInfo());\n                }                \n              \n            }\n\n            \n        } catch (UndeclaredThrowableException ex) {\n            throw (Exception)ex.getCause();\n        }\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testWithGetPortExtensionOverJMS() throws Exception {\n        \n        NumberFactoryService service = new NumberFactoryService();\n        NumberFactory factory = service.getNumberFactoryPort();\n        updateAddressPort(factory, PORT);\n        \n\n        // use values >= 30 to create JMS eprs - see NumberFactoryImpl.create\n        \n        // verify it is JMS, 999 for JMS will throw a fault\n        W3CEndpointReference ref = factory.create(\"999\");\n        Definition def = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(BusFactory.getDefaultBus(),\n                                                                       NumberService.WSDL_LOCATION\n                                                                           .toString());\n        assertNotNull(def);\n        NumberService numService = new NumberService();\n\n        assertNotNull(\"reference\", ref);\n        ServiceImpl serviceImpl = ServiceDelegateAccessor.get(numService);    \n        Number num =  (Number)serviceImpl.getPort(ref, Number.class); \n        try {\n            num.isEven().isEven();\n            fail(\"there should be a fault on val 999\");\n        } catch (Exception expected) {\n            assertTrue(\"match on exception message \" + expected.getMessage(),\n                       expected.getMessage().indexOf(\"999\") != -1);\n        }\n        \n        ref = factory.create(\"37\");\n        assertNotNull(\"reference\", ref);\n        num =  (Number)serviceImpl.getPort(ref, Number.class);\n        assertTrue(\"37 is not even\", !num.isEven().isEven());\n    }","id":102251,"modified_method":"@Test\n    public void testWithGetPortExtensionOverJMS() throws Exception {\n        \n        NumberFactoryService service = new NumberFactoryService();\n        NumberFactory factory = service.getNumberFactoryPort();\n        updateAddressPort(factory, PORT);\n        \n\n        // use values >= 30 to create JMS eprs - see NumberFactoryImpl.create\n        \n        // verify it is JMS, 999 for JMS will throw a fault\n        W3CEndpointReference ref = factory.create(\"999\");\n        String s = NumberService.WSDL_LOCATION.toString();\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(BusFactory.getDefaultBus(), s);\n        NumberService numService = new NumberService();\n\n        assertNotNull(\"reference\", ref);\n        ServiceImpl serviceImpl = ServiceDelegateAccessor.get(numService);    \n        Number num =  (Number)serviceImpl.getPort(ref, Number.class); \n        try {\n            num.isEven().isEven();\n            fail(\"there should be a fault on val 999\");\n        } catch (Exception expected) {\n            assertTrue(\"match on exception message \" + expected.getMessage(),\n                       expected.getMessage().indexOf(\"999\") != -1);\n        }\n        \n        ref = factory.create(\"37\");\n        assertNotNull(\"reference\", ref);\n        num =  (Number)serviceImpl.getPort(ref, Number.class);\n        assertTrue(\"37 is not even\", !num.isEven().isEven());\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"protected void run()  {\n        def = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(BusFactory.getDefaultBus(),\n            \"testutils/jms_test.wsdl\");\n\n        Object implementor = new GreeterImplWithContinuationsJMS();        \n        String address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        Endpoint.publish(address, implementor);\n    }","id":102252,"modified_method":"protected void run()  {\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(BusFactory.getDefaultBus(),\n            \"testutils/jms_test.wsdl\");\n\n        Object implementor = new GreeterImplWithContinuationsJMS();        \n        String address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        Endpoint.publish(address, implementor);\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"protected void run()  {\n        Object implementor = new GreeterImplTwoWayJMS();\n        Object impl2 =  new GreeterImplQueueOneWay();\n        Object impl3  = new GreeterImplTopicOneWay();\n        Object impleDoc = new GreeterImplDoc();\n        Object impl4 = new GreeterByteMessageImpl();\n        Object impl5 =  new SoapService6SoapPort6Impl();\n        Object impl6 = new JmsDestPubSubImpl();\n        Object impl7 =  new SoapService7SoapPort7Impl();\n        Object i1 = new GreeterImplTwoWayJMSAppCorrelationIDNoPrefix();\n        Object i2 = new GreeterImplTwoWayJMSAppCorrelationIDStaticPrefixEng();\n        Object i3 = new GreeterImplTwoWayJMSAppCorrelationIDStaticPrefixSales();\n        Object i4 = new GreeterImplTwoWayJMSRuntimeCorrelationIDDynamicPrefix();\n        Object i5 = new GreeterImplTwoWayJMSRuntimeCorrelationIDStaticPrefixEng();\n        Object i6 = new GreeterImplTwoWayJMSRuntimeCorrelationIDStaticPrefixSales();\n        Object i7 = new GreeterImplTwoWayJMSAppCorrelationIDEng();\n        Object i8 = new GreeterImplTwoWayJMSAppCorrelationIDSales();\n        Object mtom = new JMSMTOMImpl();\n        \n        Bus bus = BusFactory.getDefaultBus();\n        def1 = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(bus, \"testutils/hello_world_doc_lit.wsdl\");\n        def2 = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(bus, \"testutils/jms_test.wsdl\");\n        def3 = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(bus, \"testutils/jms_test_mtom.wsdl\");\n        \n        Endpoint.publish(null, impleDoc);\n        String address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        Endpoint.publish(address, implementor);\n        Endpoint.publish(\"http://testaddr.not.required/\", impl2);\n        Endpoint.publish(\"http://testaddr.not.required.topic/\", impl3);\n        Endpoint.publish(\"http://testaddr.not.required.byte/\", impl4);\n        Endpoint.publish(\"http://testaddr.not.required.jms/\", impl5);\n        Endpoint.publish(\"http://ignore\", impl6);\n        Endpoint.publish(\"\", impl7);\n        Endpoint.publish(\"\", i1);\n        Endpoint.publish(\"\", i2);\n        Endpoint.publish(\"\", i3);\n        Endpoint.publish(\"\", i4);\n        Endpoint.publish(\"\", i5);\n        Endpoint.publish(\"\", i6);\n        Endpoint.publish(\"\", i7);\n        Endpoint.publish(\"\", i8);\n        EndpointImpl ep = (EndpointImpl)Endpoint.publish(\"http://cxf.apache.org/transports/jms\", mtom);\n        Binding binding = ep.getBinding();        \n        ((SOAPBinding)binding).setMTOMEnabled(true);  \n        \n        Object spec1 = new GreeterSpecImpl();\n        String address1 = \"jms:jndi:dynamicQueues/test.cxf.jmstransport.queue2\"\n                         + \"?jndiInitialContextFactory\"\n                         + \"=org.apache.activemq.jndi.ActiveMQInitialContextFactory\"\n                         + \"&jndiConnectionFactoryName=ConnectionFactory&jndiURL=tcp://localhost:\"\n                         + EmbeddedJMSBrokerLauncher.PORT;\n        Endpoint.publish(address1, spec1);\n        \n        Object spec2 = new GreeterSpecWithPortError();\n        String address2 = \"jms:jndi:dynamicQueues/test.cxf.jmstransport.queue5\"\n            + \"?jndiInitialContextFactory\"\n            + \"=org.apache.activemq.jndi.ActiveMQInitialContextFactory\"\n            + \"&jndiConnectionFactoryName=ConnectionFactory&jndiURL=tcp://localhost:\"\n            + EmbeddedJMSBrokerLauncher.PORT;\n        Endpoint.publish(address2, spec2);\n        \n        initNoWsdlServer();\n    }","id":102253,"modified_method":"protected void run()  {\n        Object implementor = new GreeterImplTwoWayJMS();\n        Object impl2 =  new GreeterImplQueueOneWay();\n        Object impl3  = new GreeterImplTopicOneWay();\n        Object impleDoc = new GreeterImplDoc();\n        Object impl4 = new GreeterByteMessageImpl();\n        Object impl5 =  new SoapService6SoapPort6Impl();\n        Object impl6 = new JmsDestPubSubImpl();\n        Object impl7 =  new SoapService7SoapPort7Impl();\n        Object i1 = new GreeterImplTwoWayJMSAppCorrelationIDNoPrefix();\n        Object i2 = new GreeterImplTwoWayJMSAppCorrelationIDStaticPrefixEng();\n        Object i3 = new GreeterImplTwoWayJMSAppCorrelationIDStaticPrefixSales();\n        Object i4 = new GreeterImplTwoWayJMSRuntimeCorrelationIDDynamicPrefix();\n        Object i5 = new GreeterImplTwoWayJMSRuntimeCorrelationIDStaticPrefixEng();\n        Object i6 = new GreeterImplTwoWayJMSRuntimeCorrelationIDStaticPrefixSales();\n        Object i7 = new GreeterImplTwoWayJMSAppCorrelationIDEng();\n        Object i8 = new GreeterImplTwoWayJMSAppCorrelationIDSales();\n        Object mtom = new JMSMTOMImpl();\n        \n        Bus bus = BusFactory.getDefaultBus();\n        \n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(bus, \"testutils/hello_world_doc_lit.wsdl\");\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(bus, \"testutils/jms_test.wsdl\");\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(bus, \"testutils/jms_test_mtom.wsdl\");\n        \n        Endpoint.publish(null, impleDoc);\n        String address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        Endpoint.publish(address, implementor);\n        Endpoint.publish(\"http://testaddr.not.required/\", impl2);\n        Endpoint.publish(\"http://testaddr.not.required.topic/\", impl3);\n        Endpoint.publish(\"http://testaddr.not.required.byte/\", impl4);\n        Endpoint.publish(\"http://testaddr.not.required.jms/\", impl5);\n        Endpoint.publish(\"http://ignore\", impl6);\n        Endpoint.publish(\"\", impl7);\n        Endpoint.publish(\"\", i1);\n        Endpoint.publish(\"\", i2);\n        Endpoint.publish(\"\", i3);\n        Endpoint.publish(\"\", i4);\n        Endpoint.publish(\"\", i5);\n        Endpoint.publish(\"\", i6);\n        Endpoint.publish(\"\", i7);\n        Endpoint.publish(\"\", i8);\n        EndpointImpl ep = (EndpointImpl)Endpoint.publish(\"http://cxf.apache.org/transports/jms\", mtom);\n        Binding binding = ep.getBinding();        \n        ((SOAPBinding)binding).setMTOMEnabled(true);  \n        \n        Object spec1 = new GreeterSpecImpl();\n        String address1 = \"jms:jndi:dynamicQueues/test.cxf.jmstransport.queue2\"\n                         + \"?jndiInitialContextFactory\"\n                         + \"=org.apache.activemq.jndi.ActiveMQInitialContextFactory\"\n                         + \"&jndiConnectionFactoryName=ConnectionFactory&jndiURL=tcp://localhost:\"\n                         + EmbeddedJMSBrokerLauncher.PORT;\n        Endpoint.publish(address1, spec1);\n        \n        Object spec2 = new GreeterSpecWithPortError();\n        String address2 = \"jms:jndi:dynamicQueues/test.cxf.jmstransport.queue5\"\n            + \"?jndiInitialContextFactory\"\n            + \"=org.apache.activemq.jndi.ActiveMQInitialContextFactory\"\n            + \"&jndiConnectionFactoryName=ConnectionFactory&jndiURL=tcp://localhost:\"\n            + EmbeddedJMSBrokerLauncher.PORT;\n        Endpoint.publish(address2, spec2);\n        \n        initNoWsdlServer();\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"protected void run()  {\n        def = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(BusFactory.getDefaultBus(),\n                                                      \"org/apache/cxf/systest/jms/continuations/test.wsdl\");\n        Object implementor = new HelloWorldWithContinuationsJMS();        \n        String address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        Endpoint.publish(address, implementor);\n    }","id":102254,"modified_method":"protected void run()  {\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(BusFactory.getDefaultBus(),\n                                                      \"org/apache/cxf/systest/jms/continuations/test.wsdl\");\n        Object implementor = new HelloWorldWithContinuationsJMS();        \n        String address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        Endpoint.publish(address, implementor);\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"protected void run()  {\n        SpringBusFactory bf = new SpringBusFactory();\n        Bus bus = bf.createBus(CONFIG_FILE);\n        BusFactory.setDefaultBus(bus);\n        def = EmbeddedJMSBrokerLauncher.updateWsdlExtensors(bus, \n                                                      \"org/apache/cxf/systest/jms/continuations/test2.wsdl\");\n        Object implementor = new HelloWorldWithContinuationsJMS2();        \n        String address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        Endpoint.publish(address, implementor);\n    }","id":102255,"modified_method":"protected void run()  {\n        SpringBusFactory bf = new SpringBusFactory();\n        Bus bus = bf.createBus(CONFIG_FILE);\n        BusFactory.setDefaultBus(bus);\n        EmbeddedJMSBrokerLauncher.updateWsdlExtensors(bus, \n                                                      \"org/apache/cxf/systest/jms/continuations/test2.wsdl\");\n        Object implementor = new HelloWorldWithContinuationsJMS2();        \n        String address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        Endpoint.publish(address, implementor);\n    }","commit_id":"5ceff1852d8070889a939fd0e1ccebce3ed78676","url":"https://github.com/apache/cxf"},{"original_method":"public JetType visitUnaryExpression(JetUnaryExpression expression, ExpressionTypingContext context, boolean isStatement) {\n        JetExpression baseExpression = expression.getBaseExpression();\n        if (baseExpression == null) return null;\n\n        JetSimpleNameExpression operationSign = expression.getOperationReference();\n\n        // If it's a labeled expression\n        if (JetTokens.LABELS.contains(operationSign.getReferencedNameElementType())) {\n            String referencedName = operationSign.getReferencedName();\n            referencedName = referencedName == null ? \" <?>\" : referencedName;\n            context.labelResolver.enterLabeledElement(new LabelName(referencedName.substring(1)), baseExpression);\n            // TODO : Some processing for the label?\n            JetType type = facade.getType(baseExpression, context, isStatement);\n            context.labelResolver.exitLabeledElement(baseExpression);\n            return DataFlowUtils.checkType(type, expression, context);\n        }\n\n        IElementType operationType = operationSign.getReferencedNameElementType();\n\n        // Type check the base expression\n        JetType type = facade.getType(baseExpression, context.replaceExpectedType(NO_EXPECTED_TYPE));\n        if (type == null) {\n            return null;\n        }\n\n        // Special case for expr!!\n        if (operationType == JetTokens.EXCLEXCL) {\n            JetType result;\n            if (isKnownToBeNotNull(baseExpression, context)) {\n                context.trace.report(UNNECESSARY_NOT_NULL_ASSERTION.on(operationSign, type));\n                result = type;\n            }\n            else {\n                result = TypeUtils.makeNotNullable(type);\n            }\n            return DataFlowUtils.checkType(result, expression, context);\n        }\n\n        // Conventions for unary operations\n        Name name = OperatorConventions.UNARY_OPERATION_NAMES.get(operationType);\n        if (name == null) {\n            context.trace.report(UNSUPPORTED.on(operationSign, \"visitUnaryExpression\"));\n            return null;\n        }\n\n        // a[i]++/-- takes special treatment because it is actually let j = i, arr = a in arr.set(j, a.get(j).inc())\n        if ((operationType == JetTokens.PLUSPLUS || operationType == JetTokens.MINUSMINUS) && baseExpression instanceof JetArrayAccessExpression) {\n            JetExpression stubExpression = ExpressionTypingUtils.createStubExpressionOfNecessaryType(baseExpression.getProject(), type, context.trace);\n            resolveArrayAccessSetMethod((JetArrayAccessExpression) baseExpression,\n                                        stubExpression,\n                                        context.replaceExpectedType(NO_EXPECTED_TYPE).replaceBindingTrace(TemporaryBindingTrace.create(context.trace)),\n                                        context.trace);\n        }\n\n        ExpressionReceiver receiver = new ExpressionReceiver(baseExpression, type);\n\n        // Resolve the operation reference\n        OverloadResolutionResults<FunctionDescriptor> resolutionResults = context.resolveCallWithGivenName(\n                CallMaker.makeCall(receiver, expression),\n                expression.getOperationReference(),\n                name);\n\n        if (!resolutionResults.isSuccess()) {\n            return null;\n        }\n\n        // Computing the return type\n        JetType returnType = resolutionResults.getResultingDescriptor().getReturnType();\n        JetType result;\n        if (operationType == JetTokens.PLUSPLUS || operationType == JetTokens.MINUSMINUS) {\n            if (JetTypeChecker.INSTANCE.isSubtypeOf(returnType, JetStandardClasses.getUnitType())) {\n                result = ErrorUtils.createErrorType(JetStandardClasses.UNIT_ALIAS.getName());\n                context.trace.report(INC_DEC_SHOULD_NOT_RETURN_UNIT.on(operationSign));\n            }\n            else {\n                JetType receiverType = receiver.getType();\n                if (!JetTypeChecker.INSTANCE.isSubtypeOf(returnType, receiverType)) {\n                    context.trace.report(RESULT_TYPE_MISMATCH.on(operationSign, name.getName(), receiverType, returnType));\n                }\n                else {\n                    context.trace.record(BindingContext.VARIABLE_REASSIGNMENT, expression);\n\n                    checkLValue(context.trace, baseExpression);\n                }\n                // TODO : Maybe returnType?\n                result = receiverType;\n            }\n        }\n        else {\n            result = returnType;\n        }\n        return DataFlowUtils.checkType(result, expression, context);\n    }","id":102256,"modified_method":"public JetType visitUnaryExpression(JetUnaryExpression expression, ExpressionTypingContext context, boolean isStatement) {\n        JetExpression baseExpression = expression.getBaseExpression();\n        if (baseExpression == null) return null;\n\n        JetSimpleNameExpression operationSign = expression.getOperationReference();\n\n        // If it's a labeled expression\n        if (JetTokens.LABELS.contains(operationSign.getReferencedNameElementType())) {\n            String referencedName = operationSign.getReferencedName();\n            referencedName = referencedName == null ? \" <?>\" : referencedName;\n            context.labelResolver.enterLabeledElement(new LabelName(referencedName.substring(1)), baseExpression);\n            // TODO : Some processing for the label?\n            JetType type = facade.getType(baseExpression, context, isStatement);\n            context.labelResolver.exitLabeledElement(baseExpression);\n            return DataFlowUtils.checkType(type, expression, context);\n        }\n\n        IElementType operationType = operationSign.getReferencedNameElementType();\n\n        // Type check the base expression\n        JetType type = facade.getType(baseExpression, context.replaceExpectedType(NO_EXPECTED_TYPE));\n        if (type == null) {\n            return null;\n        }\n\n        // Special case for expr!!\n        if (operationType == JetTokens.EXCLEXCL) {\n            if (isKnownToBeNotNull(baseExpression, context)) {\n                context.trace.report(UNNECESSARY_NOT_NULL_ASSERTION.on(operationSign, type));\n            }\n            return DataFlowUtils.checkType(TypeUtils.makeNotNullable(type), expression, context);\n        }\n\n        // Conventions for unary operations\n        Name name = OperatorConventions.UNARY_OPERATION_NAMES.get(operationType);\n        if (name == null) {\n            context.trace.report(UNSUPPORTED.on(operationSign, \"visitUnaryExpression\"));\n            return null;\n        }\n\n        // a[i]++/-- takes special treatment because it is actually let j = i, arr = a in arr.set(j, a.get(j).inc())\n        if ((operationType == JetTokens.PLUSPLUS || operationType == JetTokens.MINUSMINUS) && baseExpression instanceof JetArrayAccessExpression) {\n            JetExpression stubExpression = ExpressionTypingUtils.createStubExpressionOfNecessaryType(baseExpression.getProject(), type, context.trace);\n            resolveArrayAccessSetMethod((JetArrayAccessExpression) baseExpression,\n                                        stubExpression,\n                                        context.replaceExpectedType(NO_EXPECTED_TYPE).replaceBindingTrace(TemporaryBindingTrace.create(context.trace)),\n                                        context.trace);\n        }\n\n        ExpressionReceiver receiver = new ExpressionReceiver(baseExpression, type);\n\n        // Resolve the operation reference\n        OverloadResolutionResults<FunctionDescriptor> resolutionResults = context.resolveCallWithGivenName(\n                CallMaker.makeCall(receiver, expression),\n                expression.getOperationReference(),\n                name);\n\n        if (!resolutionResults.isSuccess()) {\n            return null;\n        }\n\n        // Computing the return type\n        JetType returnType = resolutionResults.getResultingDescriptor().getReturnType();\n        JetType result;\n        if (operationType == JetTokens.PLUSPLUS || operationType == JetTokens.MINUSMINUS) {\n            if (JetTypeChecker.INSTANCE.isSubtypeOf(returnType, JetStandardClasses.getUnitType())) {\n                result = ErrorUtils.createErrorType(JetStandardClasses.UNIT_ALIAS.getName());\n                context.trace.report(INC_DEC_SHOULD_NOT_RETURN_UNIT.on(operationSign));\n            }\n            else {\n                JetType receiverType = receiver.getType();\n                if (!JetTypeChecker.INSTANCE.isSubtypeOf(returnType, receiverType)) {\n                    context.trace.report(RESULT_TYPE_MISMATCH.on(operationSign, name.getName(), receiverType, returnType));\n                }\n                else {\n                    context.trace.record(BindingContext.VARIABLE_REASSIGNMENT, expression);\n\n                    checkLValue(context.trace, baseExpression);\n                }\n                // TODO : Maybe returnType?\n                result = receiverType;\n            }\n        }\n        else {\n            result = returnType;\n        }\n        return DataFlowUtils.checkType(result, expression, context);\n    }","commit_id":"58e4157c4dfb046320de46924827fffb6f736685","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private boolean checkBinaryWithTypeRHS(JetBinaryExpressionWithTypeRHS expression, ExpressionTypingContext context, @NotNull JetType targetType, @NotNull JetType expectedType, TemporaryBindingTrace temporaryTrace) {\n        ExpressionTypingContext newContext = context.replaceExpectedType(expectedType).replaceBindingTrace(temporaryTrace);\n\n        JetType actualType = facade.getType(expression.getLeft(), newContext);\n        if (actualType == null) return false;\n\n        JetSimpleNameExpression operationSign = expression.getOperationSign();\n        IElementType operationType = operationSign.getReferencedNameElementType();\n        if (operationType == JetTokens.COLON) {\n            if (targetType != NO_EXPECTED_TYPE && !JetTypeChecker.INSTANCE.isSubtypeOf(actualType, targetType)) {\n                context.trace.report(TYPE_MISMATCH.on(expression.getLeft(), targetType, actualType));\n                return false;\n            }\n            return true;\n        }\n        else if (operationType == JetTokens.AS_KEYWORD || operationType == JetTokens.AS_SAFE) {\n            checkForCastImpossibility(expression, actualType, targetType, context);\n            return true;\n        }\n        else {\n            context.trace.report(UNSUPPORTED.on(operationSign, \"binary operation with type RHS\"));\n            return false;\n        }\n    }","id":102257,"modified_method":"private boolean checkBinaryWithTypeRHS(JetBinaryExpressionWithTypeRHS expression, ExpressionTypingContext context, @NotNull JetType targetType) {\n\n        JetType actualType = facade.getType(expression.getLeft(), context);\n        if (actualType == null) return false;\n\n        JetSimpleNameExpression operationSign = expression.getOperationSign();\n        IElementType operationType = operationSign.getReferencedNameElementType();\n        if (operationType == JetTokens.COLON) {\n            if (targetType != NO_EXPECTED_TYPE && !JetTypeChecker.INSTANCE.isSubtypeOf(actualType, targetType)) {\n                context.trace.report(TYPE_MISMATCH.on(expression.getLeft(), targetType, actualType));\n                return false;\n            }\n            return true;\n        }\n        else if (operationType == JetTokens.AS_KEYWORD || operationType == JetTokens.AS_SAFE) {\n            checkForCastImpossibility(expression, actualType, targetType, context);\n            return true;\n        }\n        else {\n            context.trace.report(UNSUPPORTED.on(operationSign, \"binary operation with type RHS\"));\n            return false;\n        }\n    }","commit_id":"58e4157c4dfb046320de46924827fffb6f736685","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public JetType visitBinaryWithTypeRHSExpression(JetBinaryExpressionWithTypeRHS expression, ExpressionTypingContext context) {\n        JetTypeReference right = expression.getRight();\n        JetType result = null;\n        if (right != null) {\n            JetType targetType = context.expressionTypingServices.getTypeResolver().resolveType(context.scope, right, context.trace, true);\n\n            if (isTypeFlexible(expression.getLeft())) {\n                TemporaryBindingTrace temporaryTraceWithExpectedType = TemporaryBindingTrace.create(context.trace);\n                boolean success = checkBinaryWithTypeRHS(expression, context, targetType, targetType, temporaryTraceWithExpectedType);\n                if (success) {\n                    temporaryTraceWithExpectedType.commit();\n                }\n                else {\n                    TemporaryBindingTrace temporaryTraceWithoutExpectedType = TemporaryBindingTrace.create(context.trace);\n                    checkBinaryWithTypeRHS(expression, context, targetType, NO_EXPECTED_TYPE, temporaryTraceWithoutExpectedType);\n                    temporaryTraceWithoutExpectedType.commit();\n                }\n            }\n            else {\n                TemporaryBindingTrace temporaryTraceWithoutExpectedType = TemporaryBindingTrace.create(context.trace);\n                checkBinaryWithTypeRHS(expression, context, targetType, NO_EXPECTED_TYPE, temporaryTraceWithoutExpectedType);\n                temporaryTraceWithoutExpectedType.commit();\n            }\n\n            IElementType operationType = expression.getOperationSign().getReferencedNameElementType();\n            result = operationType == JetTokens.AS_SAFE ? TypeUtils.makeNullable(targetType) : targetType;\n        }\n        else {\n            facade.getType(expression.getLeft(), context.replaceExpectedType(NO_EXPECTED_TYPE));\n        }\n        return DataFlowUtils.checkType(result, expression, context);\n    }","id":102258,"modified_method":"@Override\n    public JetType visitBinaryWithTypeRHSExpression(JetBinaryExpressionWithTypeRHS expression, ExpressionTypingContext context) {\n        JetTypeReference right = expression.getRight();\n        JetType result = null;\n        if (right != null) {\n            JetType targetType = context.expressionTypingServices.getTypeResolver().resolveType(context.scope, right, context.trace, true);\n\n            if (isTypeFlexible(expression.getLeft()) || expression.getOperationSign().getReferencedNameElementType() == JetTokens.COLON) {\n                TemporaryBindingTrace temporaryTraceWithExpectedType = TemporaryBindingTrace.create(context.trace);\n                boolean success = checkBinaryWithTypeRHS(expression, context.replaceBindingTrace(temporaryTraceWithExpectedType).replaceExpectedType(targetType), targetType);\n                if (success) {\n                    temporaryTraceWithExpectedType.commit();\n                }\n                else {\n                    checkBinaryWithTypeRHS(expression, context.replaceExpectedType(NO_EXPECTED_TYPE), targetType);\n                }\n            }\n            else {\n                checkBinaryWithTypeRHS(expression, context.replaceExpectedType(NO_EXPECTED_TYPE), targetType);\n            }\n\n            IElementType operationType = expression.getOperationSign().getReferencedNameElementType();\n            result = operationType == JetTokens.AS_SAFE ? TypeUtils.makeNullable(targetType) : targetType;\n        }\n        else {\n            facade.getType(expression.getLeft(), context.replaceExpectedType(NO_EXPECTED_TYPE));\n        }\n        return DataFlowUtils.checkType(result, expression, context);\n    }","commit_id":"58e4157c4dfb046320de46924827fffb6f736685","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n  public Document saveModel(SModel sourceModel) {\n    Element rootElement = new Element(VCSPersistenceSupport.MODEL);\n    rootElement.setAttribute(VCSPersistenceSupport.MODEL_UID, sourceModel.getReference().toString());\n    Element persistenceElement = new Element(VCSPersistenceSupport.PERSISTENCE);\n    persistenceElement.setAttribute(VCSPersistenceSupport.PERSISTENCE_VERSION, getModelPersistenceVersion() + \"\");\n    rootElement.addContent(persistenceElement);\n    if (sourceModel instanceof DefaultSModel) {\n      saveRefactorings(rootElement, (DefaultSModel) sourceModel);\n    }\n    // languages \n    Set<String> writtenAspects = new HashSet<String>();\n    for (SModuleReference languageNamespace : new SModelLegacy(sourceModel).importedLanguages()) {\n      Element languageElem = new Element(VCSPersistenceSupport.LANGUAGE);\n      languageElem.setAttribute(VCSPersistenceSupport.NAMESPACE, languageNamespace.toString());\n      rootElement.addContent(languageElem);\n    }\n    for (SModel.ImportElement aspectElement : sourceModel.getImplicitImportsSupport().getAdditionalModelVersions()) {\n      SModelReference modelReference = aspectElement.getModelReference();\n      if (modelReference == null) {\n        continue;\n      }\n      if (!(writtenAspects.contains(modelReference.toString()))) {\n        writtenAspects.add(modelReference.toString());\n        writeAspect(sourceModel, rootElement, modelReference);\n      }\n    }\n    // languages engaged on generation \n    for (SModuleReference languageNamespace : sourceModel.engagedOnGenerationLanguages()) {\n      Element languageElem = new Element(VCSPersistenceSupport.LANGUAGE_ENGAGED_ON_GENERATION);\n      languageElem.setAttribute(VCSPersistenceSupport.NAMESPACE, languageNamespace.toString());\n      rootElement.addContent(languageElem);\n    }\n    // devkits \n    for (SModuleReference devkitNamespace : sourceModel.importedDevkits()) {\n      Element devkitElem = new Element(VCSPersistenceSupport.DEVKIT);\n      devkitElem.setAttribute(VCSPersistenceSupport.NAMESPACE, devkitNamespace.toString());\n      rootElement.addContent(devkitElem);\n    }\n    // imports \n    Element maxRefID = new Element(VCSPersistenceSupport.MAX_IMPORT_INDEX);\n    rootElement.addContent(maxRefID);\n    int maxImport = 0;\n    for (SModel.ImportElement importElement : sourceModel.importedModels()) {\n      maxImport = Math.max(maxImport, importElement.getReferenceID());\n    }\n    for (SModel.ImportElement importElement : sourceModel.importedModels()) {\n      Element importElem = new Element(VCSPersistenceSupport.IMPORT_ELEMENT);\n      if (importElement.getReferenceID() < 0) {\n        importElement.setReferenceID(++maxImport);\n      }\n      importElem.setAttribute(VCSPersistenceSupport.MODEL_IMPORT_INDEX, \"\" + importElement.getReferenceID());\n      SModelReference modelReference = importElement.getModelReference();\n      importElem.setAttribute(VCSPersistenceSupport.MODEL_UID, modelReference.toString());\n      importElem.setAttribute(VCSPersistenceSupport.VERSION, \"\" + importElement.getUsedVersion());\n      org.jetbrains.mps.openapi.model.SModel importedModelDescriptor = SModelRepository.getInstance().getModelDescriptor(modelReference);\n      rootElement.addContent(importElem);\n    }\n    maxRefID.setAttribute(VCSPersistenceSupport.VALUE, \"\" + maxImport);\n    VisibleModelElements visibleModelElements = new DOMVisibleModelElements(rootElement);\n    for (SNode root : sourceModel.getRootNodes()) {\n      saveNode(rootElement, root, visibleModelElements);\n    }\n    Document document = new Document();\n    document.setRootElement(rootElement);\n    return document;\n  }","id":102259,"modified_method":"@Override\n  public Document saveModel(SModel sourceModel) {\n    Element rootElement = new Element(VCSPersistenceSupport.MODEL);\n    rootElement.setAttribute(VCSPersistenceSupport.MODEL_UID, sourceModel.getReference().toString());\n    Element persistenceElement = new Element(VCSPersistenceSupport.PERSISTENCE);\n    persistenceElement.setAttribute(VCSPersistenceSupport.PERSISTENCE_VERSION, getModelPersistenceVersion() + \"\");\n    rootElement.addContent(persistenceElement);\n    if (sourceModel instanceof DefaultSModel) {\n      saveRefactorings(rootElement, (DefaultSModel) sourceModel);\n    }\n    // languages \n    Set<String> writtenAspects = new HashSet<String>();\n    for (SModuleReference languageNamespace : new SModelLegacy(sourceModel).importedLanguages()) {\n      Element languageElem = new Element(VCSPersistenceSupport.LANGUAGE);\n      languageElem.setAttribute(VCSPersistenceSupport.NAMESPACE, languageNamespace.toString());\n      rootElement.addContent(languageElem);\n    }\n    for (SModel.ImportElement aspectElement : sourceModel.getImplicitImportsSupport().getAdditionalModelVersions()) {\n      SModelReference modelReference = aspectElement.getModelReference();\n      if (modelReference == null) {\n        continue;\n      }\n      if (!(writtenAspects.contains(modelReference.toString()))) {\n        writtenAspects.add(modelReference.toString());\n        writeAspect(sourceModel, rootElement, modelReference);\n      }\n    }\n    // languages engaged on generation \n    for (SModuleReference languageNamespace : sourceModel.engagedOnGenerationLanguages()) {\n      Element languageElem = new Element(VCSPersistenceSupport.LANGUAGE_ENGAGED_ON_GENERATION);\n      languageElem.setAttribute(VCSPersistenceSupport.NAMESPACE, languageNamespace.toString());\n      rootElement.addContent(languageElem);\n    }\n    // devkits \n    for (SModuleReference devkitNamespace : sourceModel.importedDevkits()) {\n      Element devkitElem = new Element(VCSPersistenceSupport.DEVKIT);\n      devkitElem.setAttribute(VCSPersistenceSupport.NAMESPACE, devkitNamespace.toString());\n      rootElement.addContent(devkitElem);\n    }\n    // imports \n    Element maxRefID = new Element(\"maxImportIndex\");\n    rootElement.addContent(maxRefID);\n    int maxImport = 0;\n    for (SModel.ImportElement importElement : sourceModel.importedModels()) {\n      maxImport = Math.max(maxImport, importElement.getReferenceID());\n    }\n    for (SModel.ImportElement importElement : sourceModel.importedModels()) {\n      Element importElem = new Element(VCSPersistenceSupport.IMPORT_ELEMENT);\n      if (importElement.getReferenceID() < 0) {\n        importElement.setReferenceID(++maxImport);\n      }\n      importElem.setAttribute(VCSPersistenceSupport.MODEL_IMPORT_INDEX, \"\" + importElement.getReferenceID());\n      SModelReference modelReference = importElement.getModelReference();\n      importElem.setAttribute(VCSPersistenceSupport.MODEL_UID, modelReference.toString());\n      importElem.setAttribute(VCSPersistenceSupport.VERSION, \"\" + importElement.getUsedVersion());\n      org.jetbrains.mps.openapi.model.SModel importedModelDescriptor = SModelRepository.getInstance().getModelDescriptor(modelReference);\n      rootElement.addContent(importElem);\n    }\n    maxRefID.setAttribute(VCSPersistenceSupport.VALUE, \"\" + maxImport);\n    VisibleModelElements visibleModelElements = new DOMVisibleModelElements(rootElement);\n    for (SNode root : sourceModel.getRootNodes()) {\n      saveNode(rootElement, root, visibleModelElements);\n    }\n    Document document = new Document();\n    document.setRootElement(rootElement);\n    return document;\n  }","commit_id":"7070beddccdaaa3ff0840aa517d03d20b1e770da","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void saveRootStubs(Element parent, SModel model) {\n    Element roots = new Element(VCSPersistenceSupport.ROOT_STUBS);\n    for (SNode root : model.getRootNodes()) {\n      saveNode(roots, root, false);\n    }\n    parent.addContent(roots);\n  }","id":102260,"modified_method":"protected void saveRootStubs(Element parent, SModel model) {\n    Element roots = new Element(\"root_stubs\");\n    for (SNode root : model.getRootNodes()) {\n      saveNode(roots, root, false);\n    }\n    parent.addContent(roots);\n  }","commit_id":"7070beddccdaaa3ff0840aa517d03d20b1e770da","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void saveNodeAttributes(Element element, SNode node) {\n    DocUtil.setNotNullAttribute(element, VCSPersistenceSupport.ROLE, myHelper.genRole(node));\n    DocUtil.setNotNullAttribute(element, VCSPersistenceSupport.ROLE_ID, myHelper.genRoleId(node));\n    element.setAttribute(VCSPersistenceSupport.TYPE, myHelper.genType(node));\n    DocUtil.setNotNullAttribute(element, VCSPersistenceSupport.TYPE_ID, myHelper.genTypeId(node));\n    element.setAttribute(VCSPersistenceSupport.ID, node.getNodeId().toString());\n  }","id":102261,"modified_method":"protected void saveNodeAttributes(Element element, SNode node) {\n    DocUtil.setNotNullAttribute(element, VCSPersistenceSupport.ROLE, myHelper.genRole(node));\n    DocUtil.setNotNullAttribute(element, \"roleId\", myHelper.genRoleId(node));\n    element.setAttribute(VCSPersistenceSupport.TYPE, myHelper.genType(node));\n    DocUtil.setNotNullAttribute(element, \"typeId\", myHelper.genTypeId(node));\n    element.setAttribute(VCSPersistenceSupport.ID, node.getNodeId().toString());\n  }","commit_id":"7070beddccdaaa3ff0840aa517d03d20b1e770da","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void saveNode(Element nodeElement, SNode node, boolean saveChildren) {\n    saveNodeAttributes(nodeElement, node);\n    for (String propertyName : node.getPropertyNames()) {\n      Element propertyElement = new Element(VCSPersistenceSupport.PROPERTY);\n      propertyElement.setAttribute(VCSPersistenceSupport.NAME, myHelper.genName(node, propertyName));\n      DocUtil.setNotNullAttribute(propertyElement, VCSPersistenceSupport.NAME_ID, myHelper.genNameId(node, propertyName));\n      DocUtil.setNotNullAttribute(propertyElement, VCSPersistenceSupport.VALUE, node.getProperty(propertyName));\n      nodeElement.addContent(propertyElement);\n    }\n    for (SReference reference : node.getReferences()) {\n      Element linkElement = new Element(VCSPersistenceSupport.LINK);\n      linkElement.setAttribute(VCSPersistenceSupport.ROLE, myHelper.genRole(reference));\n      DocUtil.setNotNullAttribute(linkElement, VCSPersistenceSupport.ROLE_ID, myHelper.genRoleId(reference));\n      linkElement.setAttribute(VCSPersistenceSupport.TARGET_NODE_ID, myHelper.genTarget(reference));\n      DocUtil.setNotNullAttribute(linkElement, VCSPersistenceSupport.RESOLVE_INFO, myHelper.genResolveInfo(reference));\n      nodeElement.addContent(linkElement);\n    }\n    if (saveChildren) {\n      for (SNode childNode : node.getChildren()) {\n        Element childElement = new Element(VCSPersistenceSupport.NODE);\n        saveNode(childElement, childNode, true);\n        nodeElement.addContent(childElement);\n      }\n    }\n  }","id":102262,"modified_method":"protected void saveNode(Element nodeElement, SNode node, boolean saveChildren) {\n    saveNodeAttributes(nodeElement, node);\n    for (String propertyName : node.getPropertyNames()) {\n      Element propertyElement = new Element(VCSPersistenceSupport.PROPERTY);\n      propertyElement.setAttribute(VCSPersistenceSupport.NAME, myHelper.genName(node, propertyName));\n      DocUtil.setNotNullAttribute(propertyElement, \"nameId\", myHelper.genNameId(node, propertyName));\n      DocUtil.setNotNullAttribute(propertyElement, VCSPersistenceSupport.VALUE, node.getProperty(propertyName));\n      nodeElement.addContent(propertyElement);\n    }\n    for (SReference reference : node.getReferences()) {\n      Element linkElement = new Element(VCSPersistenceSupport.LINK);\n      linkElement.setAttribute(VCSPersistenceSupport.ROLE, myHelper.genRole(reference));\n      DocUtil.setNotNullAttribute(linkElement, \"roleId\", myHelper.genRoleId(reference));\n      linkElement.setAttribute(VCSPersistenceSupport.TARGET_NODE_ID, myHelper.genTarget(reference));\n      DocUtil.setNotNullAttribute(linkElement, VCSPersistenceSupport.RESOLVE_INFO, myHelper.genResolveInfo(reference));\n      nodeElement.addContent(linkElement);\n    }\n    if (saveChildren) {\n      for (SNode childNode : node.getChildren()) {\n        Element childElement = new Element(VCSPersistenceSupport.NODE);\n        saveNode(childElement, childNode, true);\n        nodeElement.addContent(childElement);\n      }\n    }\n  }","commit_id":"7070beddccdaaa3ff0840aa517d03d20b1e770da","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  /*package*/ static IModelPersistence getModelPersistence(int persistenceID) {\n    if (persistenceID < 0 || persistenceID >= myModelPersistenceFactory.length) {\n      return null;\n    }\n    return myModelPersistenceFactory[persistenceID];\n  }","id":102263,"modified_method":"@Nullable\n  public static IModelPersistence getPersistence(int version) {\n    assert version >= 4;\n\n    if (version == 4) {\n      return new ModelPersistence4();\n    }\n    if (version == 5) {\n      return new ModelPersistence5();\n    }\n    if (version == 6) {\n      return new ModelPersistence6();\n    }\n    if (version == 7) {\n      return new ModelPersistence7();\n    }\n\n    return ModelPersistence.getPersistence(version);\n  }","commit_id":"7070beddccdaaa3ff0840aa517d03d20b1e770da","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  private static Map<String, String> loadMetadata(IFile modelFile) {\n    IFile metadataFile = getMetadataFile(modelFile);\n    if (!(metadataFile.exists())) {\n      return null;\n    }\n    return DefaultMetadataPersistence.load(metadataFile);\n  }","id":102264,"modified_method":"@Nullable\n  private static Map<String, String> loadMetadata(IFile modelFile) {\n    String modelPath = modelFile.getPath();\n    String versionPath = modelPath.substring(0, modelPath.length() - MPSExtentions.DOT_MODEL.length()) + \".metadata\";\n    IFile metadataFile = FileSystem.getInstance().getFileByPath(versionPath);\n    if (!(metadataFile.exists())) {\n      return null;\n    }\n    return DefaultMetadataPersistence.load(metadataFile);\n  }","commit_id":"7070beddccdaaa3ff0840aa517d03d20b1e770da","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static ModelLoadResult readModel(@NotNull SModelHeader header, @NotNull InputSource source, ModelLoadingState state) throws IOException, ModelReadException {\n    IModelPersistence mp = getModelPersistence(header.getPersistenceVersion());\n    if (header.getPersistenceVersion() < 0) {\n      throw new ModelReadException(\"Couldn't read model because of unknown persistence version\", null);\n    }\n    if (mp != null) {\n      // first try to use SAX parser \n      XMLSAXHandler<ModelLoadResult> handler = mp.getModelReaderHandler(state, header);\n      if (handler != null) {\n        parseAndHandleExceptions(source, handler, \"model\");\n        final ModelLoadResult result = handler.getResult();\n        // in case persistence version could change during IModelPersistence activities, might need to update header: \n        // header.setPersistenceVersion(mp.getVersion()); \n        return result;\n      }\n      // then try to use DOM reader \n      IModelReader reader = mp.getModelReader();\n      if (reader != null) {\n        Document document = loadModelDocument(source);\n        return new ModelLoadResult((SModel) reader.readModel(document, header), ModelLoadingState.FULLY_LOADED);\n      }\n    }\n    String m = \"Can not find appropriate persistence version for model %s\\n Use newer version of JetBrains MPS to load this model.\";\n    throw new PersistenceVersionNotFoundException(String.format(m, header.getModelReference()));\n  }","id":102265,"modified_method":"private static ModelLoadResult readModel(@NotNull SModelHeader header, @NotNull InputSource source, ModelLoadingState state) throws IOException, ModelReadException {\n    IModelPersistence mp = getPersistence(header.getPersistenceVersion());\n    if (header.getPersistenceVersion() < 0) {\n      throw new ModelReadException(\"Couldn't read model because of unknown persistence version\", null);\n    }\n\n    String m = \"Can not find appropriate persistence version for model \" + header.getModelReference() + \"\\n Use newer version of JetBrains MPS to load this model.\";\n    if (mp == null) {\n      throw new PersistenceVersionNotFoundException(m);\n    }\n\n    // first try to use SAX parser \n    XMLSAXHandler<ModelLoadResult> handler = mp.getModelReaderHandler(state, header);\n    if (handler != null) {\n      parseAndHandleExceptions(source, handler, \"model\");\n      final ModelLoadResult result = handler.getResult();\n      // in case persistence version could change during IModelPersistence activities, might need to update header: \n      // header.setPersistenceVersion(mp.getVersion()); \n      return result;\n    }\n\n    // then try to use DOM reader \n    IModelReader reader = mp.getModelReader();\n    if (reader == null) {\n      throw new PersistenceVersionNotFoundException(m);\n    }\n\n    Document document = loadModelDocument(source);\n    return new ModelLoadResult((SModel) reader.readModel(document, header), ModelLoadingState.FULLY_LOADED);\n  }","commit_id":"7070beddccdaaa3ff0840aa517d03d20b1e770da","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public static List<LineContent> getLineToContentMap(String content) throws ModelReadException {\n    try {\n      SModelHeader header;\n      header = loadDescriptor(new InputSource(new StringReader(content)));\n      IModelPersistence mp = getModelPersistence(header.getPersistenceVersion());\n      if (mp != null) {\n        XMLSAXHandler<List<LineContent>> handler = mp.getLineToContentMapReaderHandler();\n        if (handler != null) {\n          parseAndHandleExceptions(new InputSource(new StringReader(content)), handler, \"line to content map\");\n          return handler.getResult();\n        }\n      }\n    } catch (IOException ex) {\n      throw new ModelReadException(ex.toString(), ex);\n    }\n    return null;\n  }","id":102266,"modified_method":"@Nullable\n  public static List<LineContent> getLineToContentMap(String content) throws ModelReadException {\n    try {\n      SModelHeader header;\n      header = loadDescriptor(new InputSource(new StringReader(content)));\n      IModelPersistence mp = getPersistence(header.getPersistenceVersion());\n      if (mp == null) {\n        return null;\n      }\n\n      XMLSAXHandler<List<LineContent>> handler = mp.getLineToContentMapReaderHandler();\n      if (handler == null) {\n        return null;\n      }\n\n      parseAndHandleExceptions(new InputSource(new StringReader(content)), handler, \"line to content map\");\n      return handler.getResult();\n    } catch (IOException ex) {\n      throw new ModelReadException(ex.toString(), ex);\n    }\n\n  }","commit_id":"7070beddccdaaa3ff0840aa517d03d20b1e770da","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public boolean doesSaveUpgradePersistence(@NotNull SModelHeader header) {\n      final int pv = ModelPersistence.actualPersistenceVersion(header.getPersistenceVersion());\n      return pv != header.getPersistenceVersion();\n    }","id":102267,"modified_method":"@Override\n    public boolean doesSaveUpgradePersistence(@NotNull SModelHeader header) {\n      //not sure !=-1 is really needed, just left to be ensured about compatibility\n      return header.getPersistenceVersion() != ModelPersistence.LAST_VERSION && header.getPersistenceVersion() != -1;\n    }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static ModelLoadResult readModel(SModelHeader header, MultiStreamDataSource dataSource, ModelLoadingState targetState) throws ModelReadException {\n    IModelPersistence mp = ModelPersistence.getModelPersistence(header.getPersistenceVersion());\n    if (mp == null) {\n      throw new ModelReadException(\"Couldn't read model because of unknown persistence version\", null);\n    }\n    // load .model file\n    DefaultSModel result;\n    XMLSAXHandler<ModelLoadResult> headerHandler = mp.getModelReaderHandler(targetState, header);\n    InputStream in = null;\n    try {\n      in = dataSource.openInputStream(FilePerRootDataSource.HEADER_FILE);\n      InputSource source = new InputSource(new InputStreamReader(in, FileUtil.DEFAULT_CHARSET));\n      ModelPersistence.parseAndHandleExceptions(source, headerHandler, \".model\");\n      if (headerHandler.getResult().getContentKind() != ContentKind.MODEL_HEADER) {\n        throw new ModelReadException(\"Couldn't read model: .model file is broken\", null);\n      }\n    } catch (IOException e) {\n      throw new ModelReadException(\"Couldn't read model: \" + e.getMessage(), e, header);\n    } finally {\n      FileUtil.closeFileSafe(in);\n    }\n    result = (DefaultSModel) headerHandler.getResult().getModel();\n    header = result.getSModelHeader();\n\n    // load roots\n    List<String> streams = new ArrayList<String>();\n    for (String s : dataSource.getAvailableStreams())  streams.add(s);\n    Collections.sort(streams);\n    for (String stream : streams) {\n      if (!(stream.endsWith(FilePerRootDataSource.ROOT_EXTENSION))) continue;\n\n      XMLSAXHandler<ModelLoadResult> rootHandler = mp.getModelReaderHandler(targetState, header);\n      in = null;\n      try {\n        in = dataSource.openInputStream(stream);\n        InputSource source = new InputSource(new InputStreamReader(in, FileUtil.DEFAULT_CHARSET));\n        ModelPersistence.parseAndHandleExceptions(source, rootHandler, stream);\n        if (rootHandler.getResult().getContentKind() != ContentKind.MODEL_ROOT) {\n          throw new ModelReadException(\"Couldn't read model: \" + stream + \" root file is broken\", null);\n        }\n        if (rootHandler.getResult().getState() == ModelLoadingState.INTERFACE_LOADED) {\n          headerHandler.getResult().setState(ModelLoadingState.INTERFACE_LOADED);\n        }\n        int count = 0;\n        SModel model = rootHandler.getResult().getModel();\n        model.setUpdateMode(true);\n        for (SNode rootNode : model.getRootNodes()) {\n          if (count != 0) {\n            throw new ModelReadException(\"Couldn't read model: \" + stream + \" root file is broken - contains more than one roots\", null);\n          }\n          count++;\n          // detach it from its spurious model, which is just a container for this single root\n          model.removeRootNode(rootNode);\n          // now that it's detached we can safely add it to our model\n          result.addRootNode(rootNode);\n        }\n      } catch (IOException e) {\n        throw new ModelReadException(\"Couldn't read model: \" + e.getMessage(), e, header);\n      } finally {\n        FileUtil.closeFileSafe(in);\n      }\n    }\n\n    return headerHandler.getResult();\n  }","id":102268,"modified_method":"public static ModelLoadResult readModel(SModelHeader header, MultiStreamDataSource dataSource, ModelLoadingState targetState) throws ModelReadException {\n    IModelPersistence mp = ModelPersistence.getPersistence(header.getPersistenceVersion());\n    if (mp == null) throw new ModelReadException(\"Couldn't read model because of unknown persistence version\", null);\n\n    // load .model file\n    DefaultSModel result;\n    XMLSAXHandler<ModelLoadResult> headerHandler = mp.getModelReaderHandler(targetState, header);\n    InputStream in = null;\n    try {\n      in = dataSource.openInputStream(FilePerRootDataSource.HEADER_FILE);\n      InputSource source = new InputSource(new InputStreamReader(in, FileUtil.DEFAULT_CHARSET));\n      ModelPersistence.parseAndHandleExceptions(source, headerHandler, \".model\");\n      if (headerHandler.getResult().getContentKind() != ContentKind.MODEL_HEADER) {\n        throw new ModelReadException(\"Couldn't read model: .model file is broken\", null);\n      }\n    } catch (IOException e) {\n      throw new ModelReadException(\"Couldn't read model: \" + e.getMessage(), e, header);\n    } finally {\n      FileUtil.closeFileSafe(in);\n    }\n    result = (DefaultSModel) headerHandler.getResult().getModel();\n    header = result.getSModelHeader();\n\n    // load roots\n    List<String> streams = new ArrayList<String>();\n    for (String s : dataSource.getAvailableStreams())  streams.add(s);\n    Collections.sort(streams);\n    for (String stream : streams) {\n      if (!(stream.endsWith(FilePerRootDataSource.ROOT_EXTENSION))) continue;\n\n      XMLSAXHandler<ModelLoadResult> rootHandler = mp.getModelReaderHandler(targetState, header);\n      in = null;\n      try {\n        in = dataSource.openInputStream(stream);\n        InputSource source = new InputSource(new InputStreamReader(in, FileUtil.DEFAULT_CHARSET));\n        ModelPersistence.parseAndHandleExceptions(source, rootHandler, stream);\n        if (rootHandler.getResult().getContentKind() != ContentKind.MODEL_ROOT) {\n          throw new ModelReadException(\"Couldn't read model: \" + stream + \" root file is broken\", null);\n        }\n        if (rootHandler.getResult().getState() == ModelLoadingState.INTERFACE_LOADED) {\n          headerHandler.getResult().setState(ModelLoadingState.INTERFACE_LOADED);\n        }\n        int count = 0;\n        SModel model = rootHandler.getResult().getModel();\n        model.setUpdateMode(true);\n        for (SNode rootNode : model.getRootNodes()) {\n          if (count != 0) {\n            throw new ModelReadException(\"Couldn't read model: \" + stream + \" root file is broken - contains more than one roots\", null);\n          }\n          count++;\n          // detach it from its spurious model, which is just a container for this single root\n          model.removeRootNode(rootNode);\n          // now that it's detached we can safely add it to our model\n          result.addRootNode(rootNode);\n        }\n      } catch (IOException e) {\n        throw new ModelReadException(\"Couldn't read model: \" + e.getMessage(), e, header);\n      } finally {\n        FileUtil.closeFileSafe(in);\n      }\n    }\n\n    return headerHandler.getResult();\n  }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * returns true if the content should be reloaded from storage after save\n   */\n  public static boolean saveModel(SModel modelData, MultiStreamDataSource source, int persistenceVersion) throws IOException {\n    persistenceVersion = actualPersistenceVersion(persistenceVersion);\n\n    // upgrade?\n    SModelHeader modelHeader = null;\n    int oldVersion = persistenceVersion;\n    if (modelData instanceof DefaultSModel) {\n      DefaultSModel dsm = (DefaultSModel) modelData;\n      modelHeader = dsm.getSModelHeader();\n      oldVersion = modelHeader.getPersistenceVersion();\n      if (oldVersion != persistenceVersion) {\n        modelHeader.setPersistenceVersion(persistenceVersion);\n      }\n    }\n\n    // save into JDOM\n    if (persistenceVersion < 9) {\n      modelData.getImplicitImportsSupport().calculateImplicitImports();\n    }\n    Map<String, Document> result = ModelPersistence.getModelPersistence(persistenceVersion).getModelWriter(modelHeader).saveModelAsMultiStream(modelData);\n\n    // write to storage\n    Set<String> toRemove = new HashSet<String>();\n    for (String s : source.getAvailableStreams()) {\n      if (!result.containsKey(s)) toRemove.add(s);\n    }\n    for (Entry<String, Document> entry : result.entrySet()) {\n      JDOMUtil.writeDocument(entry.getValue(), source, entry.getKey());\n    }\n    for (String r : toRemove) {\n      source.delete(r);\n    }\n\n    if (oldVersion != persistenceVersion) {\n      LOG.info(\"persistence upgraded: \" + oldVersion + \"->\" + persistenceVersion + \" \" + modelData.getReference());\n      return true;\n    }\n    return false;\n  }","id":102269,"modified_method":"/**\n   * returns true if the content should be reloaded from storage after save\n   */\n  public static boolean saveModel(SModel modelData, MultiStreamDataSource source, int persistenceVersion) throws IOException {\n    persistenceVersion = actualPersistenceVersion(persistenceVersion);\n\n    // upgrade?\n    SModelHeader modelHeader = null;\n    int oldVersion = persistenceVersion;\n    if (modelData instanceof DefaultSModel) {\n      DefaultSModel dsm = (DefaultSModel) modelData;\n      modelHeader = dsm.getSModelHeader();\n      oldVersion = modelHeader.getPersistenceVersion();\n      if (oldVersion != persistenceVersion) {\n        modelHeader.setPersistenceVersion(persistenceVersion);\n      }\n    }\n\n    // save into JDOM\n    if (persistenceVersion < 9) {\n      modelData.getImplicitImportsSupport().calculateImplicitImports();\n    }\n    Map<String, Document> result = ModelPersistence.getPersistence(persistenceVersion).getModelWriter(modelHeader).saveModelAsMultiStream(modelData);\n\n    // write to storage\n    Set<String> toRemove = new HashSet<String>();\n    for (String s : source.getAvailableStreams()) {\n      if (!result.containsKey(s)) toRemove.add(s);\n    }\n    for (Entry<String, Document> entry : result.entrySet()) {\n      JDOMUtil.writeDocument(entry.getValue(), source, entry.getKey());\n    }\n    for (String r : toRemove) {\n      source.delete(r);\n    }\n\n    if (oldVersion != persistenceVersion) {\n      LOG.info(\"persistence upgraded: \" + oldVersion + \"->\" + persistenceVersion + \" \" + modelData.getReference());\n      return true;\n    }\n    return false;\n  }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static int actualPersistenceVersion(int desiredPersistenceVersion) {\n    IModelPersistence modelPersistence = ModelPersistence.getModelPersistence(Math.max(desiredPersistenceVersion, 8));\n    if (modelPersistence == null) {\n      modelPersistence = ModelPersistence.getCurrentModelPersistence();\n    }\n    return modelPersistence.getVersion();\n  }","id":102270,"modified_method":"public static int actualPersistenceVersion(int desiredPersistenceVersion) {\n    IModelPersistence modelPersistence = ModelPersistence.getPersistence(Math.max(desiredPersistenceVersion, 8));\n    if (modelPersistence == null) {\n      modelPersistence = ModelPersistence.getPersistence(ModelPersistence.LAST_VERSION);\n    }\n    return modelPersistence.getVersion();\n  }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void extractRootHashes(String content, Map<String, String> rootHashes) {\n    XmlFastScanner scanner = new XmlFastScanner(content.toCharArray());\n    int token, nodeStart = -1, nodeEnd = -1;\n    String rootId = null;\n\n    // { mandatory space} id {optional space} = {optional space} \"{value}\"\n    final Matcher nodeIdMatcher = Pattern.compile(\"\\\\sid\\\\s*=\\\\s*\\\"([^\\\"]+)\\\"\").matcher(\"\");\n    final IdEncoder idEncoder = new IdEncoder();\n\n    boolean nodeElementFound = false;\n    while ((token = scanner.next()) != XmlFastScanner.EOI) {\n      if (token != XmlFastScanner.OPEN_TAG && token != XmlFastScanner.SIMPLE_TAG && token != XmlFastScanner.CLOSE_TAG) {\n        continue;\n      }\n      if (scanner.tagDepth() != 1 || !ModelPersistence.NODE.equals(scanner.getName())) {\n        continue;\n      }\n      switch (token) {\n        case XmlFastScanner.SIMPLE_TAG:\n          nodeEnd = scanner.getOffset();\n          // fall-through\n        case XmlFastScanner.OPEN_TAG:\n          nodeStart = scanner.getTokenOffset();\n          if (nodeIdMatcher.reset(scanner.token()).find()) {\n            rootId = nodeIdMatcher.group(1);\n          } else {\n            rootId = null;\n          }\n          if (rootId != null && !nodeElementFound) {\n            rootHashes.put(GeneratableSModel.HEADER, ModelDigestUtil.hashText(scanner.getText(0, nodeStart)));\n            nodeElementFound = true;\n          }\n          break;\n        case XmlFastScanner.CLOSE_TAG:\n          nodeEnd = scanner.getOffset();\n          break;\n      }\n      if (rootId != null && nodeStart != -1 && nodeEnd != -1) {\n        String s = scanner.getText(nodeStart, nodeEnd);\n        SNodeId nodeId = null;\n        try {\n          nodeId = idEncoder.parseNodeId(rootId);\n        } catch (EncodingException e) {\n          throw new IllegalArgumentException(e);\n        }\n        // presentation of node id in persistence is different from what customers use (SNodeId.toString).\n        // However, it's bad idea to have map<string,string> here, and shall get refactored.\n        rootHashes.put(nodeId.toString(), ModelDigestUtil.hashText(s));\n        nodeStart = nodeEnd = -1;\n        rootId = null;\n      }\n    }\n    if (!nodeElementFound) {\n      rootHashes.put(GeneratableSModel.HEADER, ModelDigestUtil.hashText(content));\n    }\n  }","id":102271,"modified_method":"private static void extractRootHashes(String content, Map<String, String> rootHashes) {\n    XmlFastScanner scanner = new XmlFastScanner(content.toCharArray());\n    int token, nodeStart = -1, nodeEnd = -1;\n    String rootId = null;\n\n    // { mandatory space} id {optional space} = {optional space} \"{value}\"\n    final Matcher nodeIdMatcher = Pattern.compile(\"\\\\sid\\\\s*=\\\\s*\\\"([^\\\"]+)\\\"\").matcher(\"\");\n    final IdEncoder idEncoder = new IdEncoder();\n\n    boolean nodeElementFound = false;\n    while ((token = scanner.next()) != XmlFastScanner.EOI) {\n      if (token != XmlFastScanner.OPEN_TAG && token != XmlFastScanner.SIMPLE_TAG && token != XmlFastScanner.CLOSE_TAG) {\n        continue;\n      }\n      if (scanner.tagDepth() != 1 || !\"node\".equals(scanner.getName())) {\n        continue;\n      }\n      switch (token) {\n        case XmlFastScanner.SIMPLE_TAG:\n          nodeEnd = scanner.getOffset();\n          // fall-through\n        case XmlFastScanner.OPEN_TAG:\n          nodeStart = scanner.getTokenOffset();\n          if (nodeIdMatcher.reset(scanner.token()).find()) {\n            rootId = nodeIdMatcher.group(1);\n          } else {\n            rootId = null;\n          }\n          if (rootId != null && !nodeElementFound) {\n            rootHashes.put(GeneratableSModel.HEADER, ModelDigestUtil.hashText(scanner.getText(0, nodeStart)));\n            nodeElementFound = true;\n          }\n          break;\n        case XmlFastScanner.CLOSE_TAG:\n          nodeEnd = scanner.getOffset();\n          break;\n      }\n      if (rootId != null && nodeStart != -1 && nodeEnd != -1) {\n        String s = scanner.getText(nodeStart, nodeEnd);\n        SNodeId nodeId = null;\n        try {\n          nodeId = idEncoder.parseNodeId(rootId);\n        } catch (EncodingException e) {\n          throw new IllegalArgumentException(e);\n        }\n        // presentation of node id in persistence is different from what customers use (SNodeId.toString).\n        // However, it's bad idea to have map<string,string> here, and shall get refactored.\n        rootHashes.put(nodeId.toString(), ModelDigestUtil.hashText(s));\n        nodeStart = nodeEnd = -1;\n        rootId = null;\n      }\n    }\n    if (!nodeElementFound) {\n      rootHashes.put(GeneratableSModel.HEADER, ModelDigestUtil.hashText(content));\n    }\n  }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    @NotNull\n    public Map<IdIndexEntry, Integer> map(FileContent inputData) {\n      final IndexCallback cb = new IndexCallback();\n      try {\n        ModelPersistence.index(inputData.getContent(), new Consumer<String>() {\n          @Override\n          public void consume(String s) {\n            cb.index(s);\n          }\n        }, cb);\n      } catch (IOException ignored) {\n      }\n      return cb.getResult();\n    }","id":102272,"modified_method":"@Override\n    @NotNull\n    public Map<IdIndexEntry, Integer> map(FileContent inputData) {\n      final IndexCallback cb = new IndexCallback();\n      try {\n        ModelPersistence.index(inputData.getContent(), cb);\n      } catch (IOException ignored) {\n      }\n      return cb.getResult();\n    }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static ModelLoadResult readModel(@NotNull SModelHeader header, @NotNull InputSource source, ModelLoadingState state) throws IOException, ModelReadException {\n    IModelPersistence mp = getModelPersistence(header.getPersistenceVersion());\n    if (header.getPersistenceVersion() < 0) {\n      throw new ModelReadException(\"Couldn't read model because of unknown persistence version\", null);\n    }\n    if (mp != null) {\n      // first try to use SAX parser\n      XMLSAXHandler<ModelLoadResult> handler = mp.getModelReaderHandler(state, header);\n      if (handler != null) {\n        parseAndHandleExceptions(source, handler, \"model\");\n        final ModelLoadResult result = handler.getResult();\n        // in case persistence version could change during IModelPersistence activities, might need to update header:\n        // header.setPersistenceVersion(mp.getVersion());\n        return result;\n      }\n      // then try to use DOM reader\n      IModelReader reader = mp.getModelReader();\n      if (reader != null) {\n        Document document = loadModelDocument(source);\n        return new ModelLoadResult((SModel) reader.readModel(document, header), ModelLoadingState.FULLY_LOADED);\n      }\n    }\n    String m = \"Can not find appropriate persistence version for model %s\\n Use newer version of JetBrains MPS to load this model.\";\n    throw new PersistenceVersionNotFoundException(String.format(m, header.getModelReference()));\n  }","id":102273,"modified_method":"private static ModelLoadResult readModel(@NotNull SModelHeader header, @NotNull InputSource source, ModelLoadingState state) throws IOException,\n      ModelReadException {\n    int ver = header.getPersistenceVersion();\n    if (ver < 0) throw new ModelReadException(\"Couldn't read model because of unknown persistence version\", null);\n\n    IModelPersistence mp = getPersistence(ver);\n    if (mp == null) {\n      String m = \"Can not find appropriate persistence version for model %s\\n Use newer version of JetBrains MPS to load this model.\";\n      throw new PersistenceVersionNotFoundException(String.format(m, header.getModelReference()));\n    }\n\n    XMLSAXHandler<ModelLoadResult> handler = mp.getModelReaderHandler(state, header);\n    if (handler == null) {\n      String m = \"Can not find appropriate persistence version for model %s\\n Use newer version of JetBrains MPS to load this model.\";\n      throw new PersistenceVersionNotFoundException(String.format(m, header.getModelReference()));\n    }\n\n    parseAndHandleExceptions(source, handler, \"model\");\n    // in case persistence version could change during IModelPersistence activities, might need to update header:\n    // header.setPersistenceVersion(mp.getVersion());\n    return handler.getResult();\n  }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n      if (MODEL.equals(qName)) {\n        for (int idx = 0; idx < attributes.getLength(); idx++) {\n          String name = attributes.getQName(idx);\n          String value = attributes.getValue(idx);\n          if (MODEL_UID.equals(name) || ModelPersistence9.REF.equals(name)) {\n            final SModelReference mr = value == null ? null : PersistenceFacade.getInstance().createModelReference(value);\n            myResult.setModelReference(mr);\n          } else if (SModelHeader.DO_NOT_GENERATE.equals(name)) {\n            myResult.setDoNotGenerate(Boolean.parseBoolean(value));\n          } else if (\"version\".equals(name)) {\n            //old model version\n          } else {\n            myResult.setOptionalProperty(name, StringUtil.unescapeXml(value));\n          }\n        }\n      } else if (PERSISTENCE.equals(qName)) {\n        String s = attributes.getValue(PERSISTENCE_VERSION);\n        if (s != null) {\n          try {\n            myResult.setPersistenceVersion(Integer.parseInt(s));\n          } catch (NumberFormatException ignored) {\n          }\n        }\n      } else if (\"attribute\".equals(qName)) {\n        myResult.setOptionalProperty(attributes.getValue(ModelPersistence.NAME), attributes.getValue(ModelPersistence.VALUE));\n      } else {\n        throw new BreakParseSAXException();\n      }\n    }","id":102274,"modified_method":"@Override\n    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n      //todo this must be simplified as soon as all models are re-saved in last v9 persistence or later\n      if (MODEL.equals(qName)) {\n        for (int idx = 0; idx < attributes.getLength(); idx++) {\n          String name = attributes.getQName(idx);\n          String value = attributes.getValue(idx);\n          if (MODEL_UID.equals(name) || ModelPersistence9.REF.equals(name)) {\n            final SModelReference mr = value == null ? null : PersistenceFacade.getInstance().createModelReference(value);\n            myResult.setModelReference(mr);\n          } else if (SModelHeader.DO_NOT_GENERATE.equals(name)) {\n            myResult.setDoNotGenerate(Boolean.parseBoolean(value));\n          } else if (\"version\".equals(name)) {\n            //old model version\n          } else {\n            myResult.setOptionalProperty(name, StringUtil.unescapeXml(value));\n          }\n        }\n      } else if (PERSISTENCE.equals(qName)) {\n        String s = attributes.getValue(PERSISTENCE_VERSION);\n        if (s != null) {\n          try {\n            myResult.setPersistenceVersion(Integer.parseInt(s));\n          } catch (NumberFormatException ignored) {\n          }\n        }\n      } else {\n        throw new BreakParseSAXException();\n      }\n    }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Serialize model to xml in conformance with given persistence version.\n   * @throws java.lang.IllegalArgumentException if persistenceVersion is invalid (use {@link #getCurrentPersistenceVersion()} if uncertain\n   */\n  private static Document modelToXml(@NotNull SModel model, int persistenceVersion) {\n    IModelPersistence modelPersistence = getModelPersistence(persistenceVersion);\n    if (modelPersistence == null) {\n      throw new IllegalArgumentException(String.format(\"Unknown persistence version %d\", persistenceVersion));\n    }\n    if (persistenceVersion < 9) {\n      model.getImplicitImportsSupport().calculateImplicitImports();\n    }\n    return modelPersistence.getModelWriter(model instanceof DefaultSModel ? ((DefaultSModel) model).getSModelHeader() : null).saveModel(model);\n  }","id":102275,"modified_method":"/**\n   * Serialize model to xml in conformance with given persistence version.\n   *\n   * @throws java.lang.IllegalArgumentException if persistenceVersion is invalid (use {@link #LAST_VERSION} if uncertain\n   */\n  private static Document modelToXml(@NotNull SModel model, int persistenceVersion) {\n    IModelPersistence modelPersistence = getPersistence(persistenceVersion);\n    if (modelPersistence == null) {\n      throw new IllegalArgumentException(String.format(\"Unknown persistence version %d\", persistenceVersion));\n    }\n    if (persistenceVersion < 9) {\n      model.getImplicitImportsSupport().calculateImplicitImports();\n    }\n    return modelPersistence.getModelWriter(model instanceof DefaultSModel ? ((DefaultSModel) model).getSModelHeader() : null).saveModel(model);\n  }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  static IModelPersistence getModelPersistence(int persistenceID) {\n    if (persistenceID < 0 || persistenceID >= myModelPersistenceFactory.length) {\n      return null;\n    }\n    return myModelPersistenceFactory[persistenceID];\n  }","id":102276,"modified_method":"@Nullable\n  public static IModelPersistence getPersistence(int version) {\n    if (version == 8) return new ModelPersistence8();\n    if (version == 9) return new ModelPersistence9();\n\n    LOG.error(\"Unknown persistence version requested: \" + version, new Throwable());\n    return null;\n  }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Map<String, String> calculateHashes(String content) throws IOException {\n    SModelHeader header = loadDescriptor(new InputSource(new StringReader(content)));\n    IModelPersistence mp = getModelPersistence(header.getPersistenceVersion());\n    Map<String, String> result;\n    if (mp != null) {\n      IHashProvider hashProvider = mp.getHashProvider();\n      result = hashProvider.getRootHashes(content);\n      result.put(GeneratableSModel.FILE, hashProvider.getHash(content));\n    } else {\n      result = new HashMap<String, String>();\n      result.put(GeneratableSModel.FILE, ModelDigestUtil.hashText(content));\n    }\n    return result;\n  }","id":102277,"modified_method":"public static Map<String, String> calculateHashes(String content) throws IOException {\n    SModelHeader header = loadDescriptor(new InputSource(new StringReader(content)));\n    IModelPersistence mp = getPersistence(header.getPersistenceVersion());\n    Map<String, String> result;\n    if (mp != null) {\n      IHashProvider hashProvider = mp.getHashProvider();\n      result = hashProvider.getRootHashes(content);\n      result.put(GeneratableSModel.FILE, hashProvider.getHash(content));\n    } else {\n      result = new HashMap<String, String>();\n      result.put(GeneratableSModel.FILE, ModelDigestUtil.hashText(content));\n    }\n    return result;\n  }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Serialize model into xml, conformant to actual model's persistence version, if any, or current persistence version otherwise.\n   * The method doesn't update persistence version of the model (as it used to do)\n   */\n  @NotNull\n  public static Document saveModel(@NotNull SModel sourceModel) {\n    int persistenceVersion = -1;\n    if (sourceModel instanceof DefaultSModel) {\n      persistenceVersion = ((DefaultSModel) sourceModel).getSModelHeader().getPersistenceVersion();\n    }\n    if (persistenceVersion == -1 || getModelPersistence(persistenceVersion) == null) {\n      persistenceVersion = getCurrentPersistenceVersion();\n    }\n    return modelToXml(sourceModel, persistenceVersion);\n  }","id":102278,"modified_method":"/**\n   * Serialize model into xml, conformant to actual model's persistence version, if any, or current persistence version otherwise.\n   * The method doesn't update persistence version of the model (as it used to do)\n   */\n  @NotNull\n  public static Document saveModel(@NotNull SModel sourceModel) {\n    int persistenceVersion = -1;\n    if (sourceModel instanceof DefaultSModel) {\n      persistenceVersion = ((DefaultSModel) sourceModel).getSModelHeader().getPersistenceVersion();\n    }\n    if (persistenceVersion == -1 || getPersistence(persistenceVersion) == null) {\n      persistenceVersion = ModelPersistence.LAST_VERSION;\n    }\n    return modelToXml(sourceModel, persistenceVersion);\n  }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public static List<LineContent> getLineToContentMap(String content) throws ModelReadException {\n    try {\n      SModelHeader header;\n      header = loadDescriptor(new InputSource(new StringReader(content)));\n      IModelPersistence mp = getModelPersistence(header.getPersistenceVersion());\n\n      if (mp != null) {\n        XMLSAXHandler<List<LineContent>> handler = mp.getLineToContentMapReaderHandler();\n        if (handler != null) {\n          parseAndHandleExceptions(new InputSource(new StringReader(content)), handler, \"line to content map\");\n          return handler.getResult();\n        }\n      }\n    } catch (IOException ex) {\n      throw new ModelReadException(ex.toString(), ex);\n    }\n    return null;\n  }","id":102279,"modified_method":"@Nullable\n  public static List<LineContent> getLineToContentMap(String content) throws ModelReadException {\n    try {\n      SModelHeader header = loadDescriptor(new InputSource(new StringReader(content)));\n      IModelPersistence mp = getPersistence(header.getPersistenceVersion());\n\n      if (mp == null) return null;\n\n      XMLSAXHandler<List<LineContent>> handler = mp.getLineToContentMapReaderHandler();\n      if (handler == null) return null;\n\n      parseAndHandleExceptions(new InputSource(new StringReader(content)), handler, \"line to content map\");\n      return handler.getResult();\n    } catch (IOException ex) {\n      throw new ModelReadException(ex.toString(), ex);\n    }\n  }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void index(byte[] data, Consumer<String> legacyConsumer, Callback newConsumer) throws IOException {\n    SModelHeader header = loadDescriptor(new InputSource(new InputStreamReader(new ByteArrayInputStream(data), FileUtil.DEFAULT_CHARSET)));\n    IModelPersistence mp = getModelPersistence(header.getPersistenceVersion());\n    assert mp != null : \"Using unsupported persistence version: \" + header.getPersistenceVersion();\n    if (mp instanceof XMLPersistence) {\n      final Indexer indexSupport = ((XMLPersistence) mp).getIndexSupport(newConsumer);\n      indexSupport.index(new InputStreamReader(new ByteArrayInputStream(data), FileUtil.DEFAULT_CHARSET));\n    } else {\n      // FIXME throw away indexing of legacy persistence versions ASAP\n      mp.index(new String(data, FileUtil.DEFAULT_CHARSET).toCharArray(), legacyConsumer);\n    }\n  }","id":102280,"modified_method":"public static void index(byte[] data, Callback newConsumer) throws IOException {\n    SModelHeader header = loadDescriptor(new InputSource(new InputStreamReader(new ByteArrayInputStream(data), FileUtil.DEFAULT_CHARSET)));\n    IModelPersistence mp = getPersistence(header.getPersistenceVersion());\n    assert mp instanceof XMLPersistence : \"Using unsupported persistence version: \" + header.getPersistenceVersion();\n\n    Indexer indexSupport = ((XMLPersistence) mp).getIndexSupport(newConsumer);\n    indexSupport.index(new InputStreamReader(new ByteArrayInputStream(data), FileUtil.DEFAULT_CHARSET));\n  }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public static SModelHeader loadDescriptor(StreamDataSource source) throws ModelReadException {\n    final SModelHeader result = new SModelHeader();\n    loadDescriptor(result, source);\n\n    // for old persistences try to load header from metadata\n    if (result.getPersistenceVersion() < 7 && source instanceof FileDataSource) {\n      Map<String, String> metadata = loadMetadata(((FileDataSource) source).getFile());\n      if (metadata != null) {\n        if (metadata.containsKey(SModelHeader.DO_NOT_GENERATE)) {\n          result.setDoNotGenerate(Boolean.parseBoolean(metadata.remove(SModelHeader.DO_NOT_GENERATE)));\n        }\n      }\n    }\n    return result;\n  }","id":102281,"modified_method":"@NotNull\n  public static SModelHeader loadDescriptor(StreamDataSource source) throws ModelReadException {\n    final SModelHeader result = new SModelHeader();\n    loadDescriptor(result, source);\n    return result;\n  }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static DefaultSModel saveModel(@NotNull SModel model, @NotNull StreamDataSource source, int persistenceVersion) throws IOException {\n    LOG.debug(\"Saving model \" + model.getReference() + \" to \" + source.getLocation());\n\n    persistenceVersion = actualPersistenceVersion(persistenceVersion);\n\n    if (source.isReadOnly()) {\n      throw new IOException(\"`\" + source.getLocation() + \"' is read-only\");\n    }\n\n    // upgrade?\n    int oldVersion = persistenceVersion;\n    if (model instanceof DefaultSModel) {\n      DefaultSModel dsm = (DefaultSModel) model;\n      SModelHeader modelHeader = dsm.getSModelHeader();\n      oldVersion = modelHeader.getPersistenceVersion();\n      if (oldVersion != persistenceVersion) {\n        modelHeader.setPersistenceVersion(persistenceVersion);\n      }\n    }\n\n    // save model\n    Document document = modelToXml(model, persistenceVersion);\n    JDOMUtil.writeDocument(document, source);\n\n    if (oldVersion != persistenceVersion) {\n      LOG.info(\"persistence upgraded: \" + oldVersion + \"->\" + persistenceVersion + \" \" + model.getReference());\n      return (DefaultSModel) model;\n    }\n    return null;\n  }","id":102282,"modified_method":"public static DefaultSModel saveModel(@NotNull SModel model, @NotNull StreamDataSource source, int persistenceVersion) throws IOException {\n    LOG.debug(\"Saving model \" + model.getReference() + \" to \" + source.getLocation());\n\n    if (source.isReadOnly()) {\n      throw new IOException(\"`\" + source.getLocation() + \"' is read-only\");\n    }\n\n    // upgrade?\n    int oldVersion = persistenceVersion;\n    if (model instanceof DefaultSModel) {\n      DefaultSModel dsm = (DefaultSModel) model;\n      SModelHeader modelHeader = dsm.getSModelHeader();\n      oldVersion = modelHeader.getPersistenceVersion();\n      if (oldVersion != persistenceVersion) {\n        modelHeader.setPersistenceVersion(persistenceVersion);\n      }\n    }\n\n    // save model\n    Document document = modelToXml(model, persistenceVersion);\n    JDOMUtil.writeDocument(document, source);\n\n    if (oldVersion != persistenceVersion) {\n      LOG.info(\"persistence upgraded: \" + oldVersion + \"->\" + persistenceVersion + \" \" + model.getReference());\n      return (DefaultSModel) model;\n    }\n    return null;\n  }","commit_id":"575ea238437d2bcd7f4296d0fc68a3a90297af11","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * loads sub-bundles at the given Description LOD, continues\n     *\n     * @param requestedDescrLoD\n     * @param expand\n     */\n    @NbBundle.Messages(value = \"EventStripeNode.loggedTask.name=Load sub clusters\")\n    private synchronized void loadSubBundles(DescriptionLoD.RelativeDetail relativeDetail) {\n        chart.setCursor(Cursor.WAIT);\n        chart.getEventStripes().removeAll(Lists.transform(subNodes, EventStripeNode::getEventStripe));\n        subNodes.clear();\n\n        /*\n         * make new ZoomParams to query with\n         *\n         * We need to extend end time because for the query by one second,\n         * because it is treated as an open interval but we want to include\n         * events at exactly the time of the last event in this cluster\n         */\n        final RootFilter subClusterFilter = getSubClusterFilter();\n        final Interval subClusterSpan = new Interval(getStartMillis(), getEndMillis() + 1000);\n        final EventTypeZoomLevel eventTypeZoomLevel = eventsModel.eventTypeZoomProperty().get();\n        final ZoomParams zoomParams = new ZoomParams(subClusterSpan, eventTypeZoomLevel, subClusterFilter, getDescriptionLoD());\n\n        Task<Collection<EventStripe>> loggedTask = new Task<Collection<EventStripe>>() {\n\n            private volatile DescriptionLoD loadedDescriptionLoD = getDescriptionLoD().withRelativeDetail(relativeDetail);\n\n            {\n                updateTitle(Bundle.EventStripeNode_loggedTask_name());\n            }\n\n            @Override\n            protected Collection<EventStripe> call() throws Exception {\n                Collection<EventStripe> bundles;\n                DescriptionLoD next = loadedDescriptionLoD;\n                do {\n                    loadedDescriptionLoD = next;\n                    if (loadedDescriptionLoD == getEventBundle().getDescriptionLoD()) {\n                        return Collections.emptySet();\n                    }\n                    bundles = eventsModel.getEventStripes(zoomParams.withDescrLOD(loadedDescriptionLoD));\n                    next = loadedDescriptionLoD.withRelativeDetail(relativeDetail);\n                } while (bundles.size() == 1 && nonNull(next));\n                // return list of AbstractEventStripeNodes representing sub-bundles\n                return bundles;\n            }\n\n            @Override\n            protected void succeeded() {\n                try {\n                    Collection<EventStripe> bundles = get();\n\n                    if (bundles.isEmpty()) {\n                        subNodePane.getChildren().clear();\n                        getChildren().setAll(subNodePane, infoHBox);\n                        descLOD.set(getEventBundle().getDescriptionLoD());\n                    } else {\n                        chart.getEventStripes().addAll(bundles);\n                        subNodes.addAll(bundles.stream()\n                                .map(EventClusterNode.this::createStripeNode)\n                                .collect(Collectors.toList()));\n                        subNodePane.getChildren().setAll(subNodes);\n                        getChildren().setAll(new VBox(infoHBox, subNodePane));\n                        descLOD.set(loadedDescriptionLoD);\n                    }\n                } catch (InterruptedException | ExecutionException ex) {\n                    LOGGER.log(Level.SEVERE, \"Error loading subnodes\", ex);\n                }\n                chart.requestChartLayout();\n                chart.setCursor(null);\n            }\n        };\n\n        new Thread(loggedTask).start();\n        //start task\n        chart.getController().monitorTask(loggedTask);\n    }","id":102283,"modified_method":"/**\n     * loads sub-bundles at the given Description LOD, continues\n     *\n     * @param requestedDescrLoD\n     * @param expand\n     */\n    @NbBundle.Messages(value = \"EventStripeNode.loggedTask.name=Load sub clusters\")\n    private synchronized void loadSubBundles(DescriptionLoD.RelativeDetail relativeDetail) {\n        chart.setCursor(Cursor.WAIT);\n        chart.getEventStripes().removeAll(Lists.transform(subNodes, EventStripeNode::getEventStripe));\n        subNodes.clear();\n\n        /*\n         * make new ZoomParams to query with\n         *\n         * We need to extend end time because for the query by one second,\n         * because it is treated as an open interval but we want to include\n         * events at exactly the time of the last event in this cluster\n         */\n        final RootFilter subClusterFilter = getSubClusterFilter();\n        final Interval subClusterSpan = new Interval(getStartMillis(), getEndMillis() + 1000);\n        final EventTypeZoomLevel eventTypeZoomLevel = eventsModel.eventTypeZoomProperty().get();\n        final ZoomParams zoomParams = new ZoomParams(subClusterSpan, eventTypeZoomLevel, subClusterFilter, getDescriptionLoD());\n\n        Task<List<EventStripe>> loggedTask = new Task<List<EventStripe>>() {\n\n            private volatile DescriptionLoD loadedDescriptionLoD = getDescriptionLoD().withRelativeDetail(relativeDetail);\n\n            {\n                updateTitle(Bundle.EventStripeNode_loggedTask_name());\n            }\n\n            @Override\n            protected List<EventStripe> call() throws Exception {\n                List<EventStripe> bundles;\n                DescriptionLoD next = loadedDescriptionLoD;\n                do {\n                    loadedDescriptionLoD = next;\n                    if (loadedDescriptionLoD == getEventBundle().getDescriptionLoD()) {\n                        return Collections.emptyList();\n                    }\n                    bundles = eventsModel.getEventStripes(zoomParams.withDescrLOD(loadedDescriptionLoD));\n\n                    next = loadedDescriptionLoD.withRelativeDetail(relativeDetail);\n                } while (bundles.size() == 1 && nonNull(next));\n\n                // return list of EventStripes representing sub-bundles\n                return Lists.transform(bundles, eventStripe -> eventStripe.withParent(getEventCluster()));\n            }\n\n            @Override\n            protected void succeeded() {\n                try {\n                    List<EventStripe> bundles = get();\n\n                    if (bundles.isEmpty()) {\n                        subNodePane.getChildren().clear();\n                        getChildren().setAll(subNodePane, infoHBox);\n                        descLOD.set(getEventBundle().getDescriptionLoD());\n                    } else {\n                        chart.getEventStripes().addAll(bundles);\n                        subNodes.addAll(Lists.transform(bundles, EventClusterNode.this::createStripeNode));\n                        subNodePane.getChildren().setAll(subNodes);\n                        getChildren().setAll(new VBox(infoHBox, subNodePane));\n                        descLOD.set(loadedDescriptionLoD);\n                    }\n                } catch (InterruptedException | ExecutionException ex) {\n                    LOGGER.log(Level.SEVERE, \"Error loading subnodes\", ex);\n                }\n                chart.requestChartLayout();\n                chart.setCursor(null);\n            }\n        };\n\n        new Thread(loggedTask).start();\n        //start task\n        chart.getController().monitorTask(loggedTask);\n    }","commit_id":"2d3c8c86eed1509e2172cfc43d819cd5db60cb4d","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void insert(Deque<EventBundle<?>> path) {\n        EventBundle<?> head = path.removeFirst();\n        EventDescriptionTreeItem treeItem = childMap.get(head.getDescription());\n        if (treeItem == null) {\n            treeItem = new EventDescriptionTreeItem(head);\n            treeItem.setExpanded(true);\n            childMap.put(head.getDescription(), treeItem);\n            getChildren().add(treeItem);\n        }\n\n        if (path.isEmpty() == false) {\n            treeItem.insert(path);\n        }\n    }","id":102284,"modified_method":"@ThreadConfined(type = ThreadConfined.ThreadType.JFX)\n    public void insert(Deque<EventBundle<?>> path) {\n        EventBundle<?> head = path.removeFirst();\n        EventDescriptionTreeItem treeItem = childMap.computeIfAbsent(head.getDescription(), description -> {\n            EventDescriptionTreeItem newTreeItem = new EventDescriptionTreeItem(head);\n            newTreeItem.setExpanded(true);\n            childMap.put(description, newTreeItem);\n            getChildren().add(newTreeItem);\n            return newTreeItem;\n        });\n\n        if (path.isEmpty() == false) {\n            treeItem.insert(path);\n        }\n    }","commit_id":"2d3c8c86eed1509e2172cfc43d819cd5db60cb4d","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void insert(Deque<EventBundle<?>> path) {\n        EventBundle<?> head = path.removeFirst();\n        EventDescriptionTreeItem treeItem = childMap.get(head.getDescription());\n        if (treeItem == null) {\n            treeItem = new EventDescriptionTreeItem(head);\n            treeItem.setExpanded(true);\n            childMap.put(head.getDescription(), treeItem);\n            getChildren().add(treeItem);\n        }\n\n        if (path.isEmpty() == false) {\n            treeItem.insert(path);\n        }\n    }","id":102285,"modified_method":"@ThreadConfined(type = ThreadConfined.ThreadType.JFX)\n    public void insert(Deque<EventBundle<?>> path) {\n        EventBundle<?> head = path.removeFirst();\n        EventDescriptionTreeItem treeItem = childMap.computeIfAbsent(head.getDescription(), description -> {\n            EventDescriptionTreeItem newTreeItem = new EventDescriptionTreeItem(head);\n            newTreeItem.setExpanded(true);\n            childMap.put(head.getDescription(), newTreeItem);\n            getChildren().add(newTreeItem);\n\n            return newTreeItem;\n        });\n\n        if (path.isEmpty() == false) {\n            treeItem.insert(path);\n        }\n    }","commit_id":"2d3c8c86eed1509e2172cfc43d819cd5db60cb4d","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        protected void updateItem(EventBundle<?> item, boolean empty) {\n            super.updateItem(item, empty);\n            if (item == null || empty) {\n                setText(null);\n                setTooltip(null);\n                setGraphic(null);\n                setContextMenu(null);\n                deRegisterListeners(controller.getQuickHideFilters());\n            } else {\n                filterStateChangeListener = (filterState) -> updateHiddenState(item);\n                controller.getQuickHideFilters().addListener((ListChangeListener.Change<? extends DescriptionFilter> listChange) -> {\n                    while (listChange.next()) {\n                        deRegisterListeners(listChange.getRemoved());\n                        registerListeners(listChange.getAddedSubList(), item);\n                    }\n                    updateHiddenState(item);\n                });\n                registerListeners(controller.getQuickHideFilters(), item);\n                String text;\n                if (getTreeItem() instanceof EventTypeTreeItem) {\n                    text = item.getEventType().getDisplayName();\n                } else {\n                    text = item.getDescription() + \" (\" + item.getCount() + \")\"; // NON-NLS\n                    TreeItem<EventBundle<?>> parent = getTreeItem().getParent();\n                    if (parent != null && parent.getValue() != null && (parent instanceof EventDescriptionTreeItem)) {\n                        text = StringUtils.substringAfter(text, parent.getValue().getDescription());\n                    }\n                }\n                setText(text);\n                setTooltip(new Tooltip(text));\n                imageView.setImage(item.getEventType().getFXImage());\n                setGraphic(new StackPane(rect, imageView));\n                updateHiddenState(item);\n                if (getTreeItem() instanceof EventDescriptionTreeItem) {\n                    setOnMouseClicked((MouseEvent event) -> {\n                        if (event.getButton() == MouseButton.SECONDARY) {\n                            if (hidden.get()) {\n                                ActionUtils.createContextMenu(ImmutableList.of(detailViewPane.newUnhideDescriptionAction(item.getDescription(), item.getDescriptionLoD())))\n                                        .show(EventBundleTreeCell.this, event.getScreenX(), event.getScreenY());\n                            } else {\n                                ActionUtils.createContextMenu(ImmutableList.of(detailViewPane.newHideDescriptionAction(item.getDescription(), item.getDescriptionLoD())))\n                                        .show(EventBundleTreeCell.this, event.getScreenX(), event.getScreenY());\n                            }\n                        }\n                    });\n                } else {\n                    setOnMouseClicked(null);\n                }\n            }\n        }","id":102286,"modified_method":"@Override\n        protected void updateItem(EventBundle<?> item, boolean empty) {\n            super.updateItem(item, empty);\n            if (item == null || empty) {\n                setText(null);\n                setTooltip(null);\n                setGraphic(null);\n                setContextMenu(null);\n                deRegisterListeners(controller.getQuickHideFilters());\n            } else {\n                filterStateChangeListener = (filterState) -> updateHiddenState(item);\n                controller.getQuickHideFilters().addListener((ListChangeListener.Change<? extends DescriptionFilter> listChange) -> {\n                    while (listChange.next()) {\n                        deRegisterListeners(listChange.getRemoved());\n                        registerListeners(listChange.getAddedSubList(), item);\n                    }\n                    updateHiddenState(item);\n                });\n                registerListeners(controller.getQuickHideFilters(), item);\n                String text;\n                if (getTreeItem() instanceof EventTypeTreeItem) {\n                    text = item.getEventType().getDisplayName();\n                    setDisable(true);\n                } else {\n                    setDisable(false);\n                    text = item.getDescription() + \" (\" + item.getCount() + \")\"; // NON-NLS\n                    TreeItem<EventBundle<?>> parent = getTreeItem().getParent();\n                    if (parent != null && parent.getValue() != null && (parent instanceof EventDescriptionTreeItem)) {\n                        text = StringUtils.substringAfter(text, parent.getValue().getDescription());\n                    }\n                }\n                setText(text);\n                setTooltip(new Tooltip(text));\n                imageView.setImage(item.getEventType().getFXImage());\n                setGraphic(new StackPane(rect, imageView));\n                updateHiddenState(item);\n                if (getTreeItem() instanceof EventDescriptionTreeItem) {\n                    setOnMouseClicked((MouseEvent event) -> {\n                        if (event.getButton() == MouseButton.SECONDARY) {\n                            if (hidden.get()) {\n                                ActionUtils.createContextMenu(ImmutableList.of(detailViewPane.newUnhideDescriptionAction(item.getDescription(), item.getDescriptionLoD())))\n                                        .show(EventBundleTreeCell.this, event.getScreenX(), event.getScreenY());\n                            } else {\n                                ActionUtils.createContextMenu(ImmutableList.of(detailViewPane.newHideDescriptionAction(item.getDescription(), item.getDescriptionLoD())))\n                                        .show(EventBundleTreeCell.this, event.getScreenX(), event.getScreenY());\n                            }\n                        }\n                    });\n                } else {\n                    setOnMouseClicked(null);\n                }\n            }\n        }","commit_id":"2d3c8c86eed1509e2172cfc43d819cd5db60cb4d","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@FXML\n    @NbBundle.Messages(\"EventsTree.Label.text=Sort By:\")\n    void initialize() {\n        assert sortByBox != null : \"fx:id=\\\"sortByBox\\\" was not injected: check your FXML file 'NavPanel.fxml'.\"; // NON-NLS\n\n        sortByBox.getItems().setAll(Arrays.asList(TreeComparator.Description, TreeComparator.Count));\n        sortByBox.getSelectionModel().select(TreeComparator.Description);\n        sortByBox.getSelectionModel().selectedItemProperty().addListener((Observable o) -> {\n            getRoot().resort(TreeComparator.Type.reversed().thenComparing(sortByBox.getSelectionModel().getSelectedItem()));\n        });\n        eventsTree.setShowRoot(false);\n        eventsTree.setCellFactory((TreeView<EventBundle<?>> p) -> new EventBundleTreeCell());\n        eventsTree.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);\n\n        eventsTreeLabel.setText(Bundle.EventsTree_Label_text());\n    }","id":102287,"modified_method":"@FXML\n    @NbBundle.Messages(\"EventsTree.Label.text=Sort By:\")\n    void initialize() {\n        assert sortByBox != null : \"fx:id=\\\"sortByBox\\\" was not injected: check your FXML file 'NavPanel.fxml'.\"; // NON-NLS\n\n        sortByBox.getItems().setAll(Arrays.asList(TreeComparator.Description, TreeComparator.Count));\n        sortByBox.getSelectionModel().select(TreeComparator.Description);\n        sortByBox.getSelectionModel().selectedItemProperty().addListener((Observable o) -> {\n            getRoot().resort(TreeComparator.Type.reversed().thenComparing(sortByBox.getSelectionModel().getSelectedItem()));\n        });\n        eventsTree.setShowRoot(false);\n\n        eventsTree.setCellFactory(treeView -> new EventBundleTreeCell());\n        eventsTree.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);\n\n        eventsTreeLabel.setText(Bundle.EventsTree_Label_text());\n    }","commit_id":"2d3c8c86eed1509e2172cfc43d819cd5db60cb4d","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public CoarseSessionAttributes(Map<String, Object> attributes, Mutator mutator, MarshallingContext context, CacheProperties properties) {\n        super(attributes);\n        this.attributes = attributes;\n        this.mutations = !properties.isTransactional() ? new ConcurrentHashSet<>() : null;\n        this.mutator = mutator;\n        this.context = context;\n        this.properties = properties;\n    }","id":102288,"modified_method":"public CoarseSessionAttributes(Map<String, Object> attributes, Mutator mutator, MarshallingContext context, CacheProperties properties) {\n        super(attributes);\n        this.attributes = attributes;\n        this.mutations = !properties.isTransactional() ? ConcurrentHashMap.newKeySet() : null;\n        this.mutator = mutator;\n        this.context = context;\n        this.properties = properties;\n    }","commit_id":"cd38b35e74732b8f363aeaa465d8822532dd0336","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void close() {\n        if (this.mutations != null) {\n            this.mutations.entrySet().forEach(entry -> new CacheEntryMutator<>(this.cache, entry).mutate());\n        }\n    }","id":102289,"modified_method":"@Override\n    public void close() {\n        if (!this.properties.isTransactional()) {\n            this.mutations.values().forEach(mutator -> mutator.mutate());\n        }\n        this.mutations.clear();\n    }","commit_id":"cd38b35e74732b8f363aeaa465d8822532dd0336","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Object getAttribute(String name) {\n        SessionAttributeKey key = this.createKey(name);\n        V value = this.cache.get(key);\n        Object attribute = this.read(name, value);\n        if (attribute != null) {\n            // If the object is mutable, we need to indicate that the attribute should be replicated\n            if (MutableDetector.isMutable(attribute)) {\n                if (this.mutations != null) {\n                    this.mutations.put(key, value);\n                } else {\n                    new CacheEntryMutator<>(this.cache, key, value).mutate();\n                }\n            }\n        }\n        return attribute;\n    }","id":102290,"modified_method":"@Override\n    public Object getAttribute(String name) {\n        SessionAttributeKey key = this.createKey(name);\n        V value = this.cache.get(key);\n        Object attribute = this.read(name, value);\n        if (attribute != null) {\n            // If the object is mutable, we need to indicate that the attribute should be replicated\n            if (MutableDetector.isMutable(attribute)) {\n                Mutator mutator = this.mutations.computeIfAbsent(name, k -> new CacheEntryMutator<>(this.cache, key, value));\n                // If cache is not transactional, mutate on close instead.\n                if (this.properties.isTransactional()) {\n                    mutator.mutate();\n                }\n            }\n        }\n        return attribute;\n    }","commit_id":"cd38b35e74732b8f363aeaa465d8822532dd0336","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Object setAttribute(String name, Object attribute) {\n        if (attribute == null) {\n            return this.removeAttribute(name);\n        }\n        if (this.properties.isMarshalling() && !this.marshaller.getContext().isMarshallable(attribute)) {\n            throw new IllegalArgumentException(new NotSerializableException(attribute.getClass().getName()));\n        }\n        SessionAttributeKey key = this.createKey(name);\n        V value = this.marshaller.write(attribute);\n        Object result = this.read(name, this.cache.getAdvancedCache().withFlags(Flag.FORCE_SYNCHRONOUS).put(key, value));\n        if (this.mutations != null) {\n            this.mutations.remove(key);\n        }\n        return result;\n    }","id":102291,"modified_method":"@Override\n    public Object setAttribute(String name, Object attribute) {\n        if (attribute == null) {\n            return this.removeAttribute(name);\n        }\n        if (this.properties.isMarshalling() && !this.marshaller.getContext().isMarshallable(attribute)) {\n            throw new IllegalArgumentException(new NotSerializableException(attribute.getClass().getName()));\n        }\n        SessionAttributeKey key = this.createKey(name);\n        V value = this.marshaller.write(attribute);\n        Object result = this.read(name, this.cache.getAdvancedCache().withFlags(Flag.FORCE_SYNCHRONOUS).put(key, value));\n        this.mutations.remove(name);\n        return result;\n    }","commit_id":"cd38b35e74732b8f363aeaa465d8822532dd0336","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Object removeAttribute(String name) {\n        SessionAttributeKey key = this.createKey(name);\n        Object result = this.read(name, this.cache.getAdvancedCache().withFlags(Flag.FORCE_SYNCHRONOUS).remove(key));\n        if (this.mutations != null) {\n            this.mutations.remove(key);\n        }\n        return result;\n    }","id":102292,"modified_method":"@Override\n    public Object removeAttribute(String name) {\n        SessionAttributeKey key = this.createKey(name);\n        Object result = this.read(name, this.cache.getAdvancedCache().withFlags(Flag.FORCE_SYNCHRONOUS).remove(key));\n        this.mutations.remove(name);\n        return result;\n    }","commit_id":"cd38b35e74732b8f363aeaa465d8822532dd0336","url":"https://github.com/wildfly/wildfly"},{"original_method":"public FineSessionAttributes(String id, Cache<SessionAttributeKey, V> cache, Marshaller<Object, V, MarshallingContext> marshaller, CacheProperties properties) {\n        super(id, cache, marshaller);\n        this.cache = cache;\n        this.mutations = !properties.isTransactional() ? new ConcurrentHashMap<>() : null;\n        this.marshaller = marshaller;\n        this.properties = properties;\n    }","id":102293,"modified_method":"public FineSessionAttributes(String id, Cache<SessionAttributeKey, V> cache, Marshaller<Object, V, MarshallingContext> marshaller, CacheProperties properties) {\n        super(id, cache, marshaller);\n        this.cache = cache;\n        this.marshaller = marshaller;\n        this.properties = properties;\n    }","commit_id":"cd38b35e74732b8f363aeaa465d8822532dd0336","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public DeploymentDescriptor readFrom(Reader reader) {\n        try {\n            Node appNode = createParser().parse(reader);\n            version = (String) appNode.attribute(\"version\");\n            for (final Node child : Cast.<List<Node>>uncheckedCast(appNode.children())) {\n                String childLocalName = localNameOf(child);\n                if (childLocalName.equals(\"application-name\")) {\n\n                    applicationName = child.text();\n\n                } else if (childLocalName.equals(\"initialize-in-order\")) {\n\n                    initializeInOrder = Boolean.valueOf(child.text());\n\n                } else if (childLocalName.equals(\"description\")) {\n\n                    description = child.text();\n\n                } else if (childLocalName.equals(\"display-name\")) {\n\n                    displayName = child.text();\n\n                } else if (childLocalName.equals(\"library-directory\")) {\n\n                    libraryDirectory = child.text();\n\n                } else if (childLocalName.equals(\"module\")) {\n\n                    EarModule module = null;\n                    for (Node moduleNode : Cast.<List<Node>>uncheckedCast(child.children())) {\n                        String moduleNodeLocalName = localNameOf(moduleNode);\n                        if (moduleNodeLocalName.equals(\"web\")) {\n                            String webUri = childNodeNamed(moduleNode, \"web-uri\").text();\n                            String contextRoot = childNodeNamed(moduleNode, \"context-root\").text();\n                            module = new DefaultEarWebModule(webUri, contextRoot);\n                            modules.add(module);\n                            moduleTypeMappings.put(module.getPath(), \"web\");\n                        } else if (moduleNodeLocalName.equals(\"alt-dd\")) {\n                            assert module != null;\n                            module.setAltDeployDescriptor(moduleNode.text());\n                        } else {\n                            module = new DefaultEarModule(moduleNode.text());\n                            modules.add(module);\n                            moduleTypeMappings.put(module.getPath(), moduleNodeLocalName);\n                        }\n                    }\n\n                } else if (childLocalName.equals(\"security-role\")) {\n\n                    String roleName = childNodeNamed(child, \"role-name\").text();\n                    String description = childNodeNamed(child, \"description\").text();\n                    securityRoles.add(new DefaultEarSecurityRole(roleName, description));\n\n                } else {\n                    withXml(new Action<XmlProvider>() {\n                        @Override\n                        public void execute(XmlProvider xmlProvider) {\n                            xmlProvider.asNode().append(child);\n                        }\n                    });\n                }\n            }\n        } catch (IOException ex) {\n            throw new UncheckedIOException(ex);\n        } catch (SAXException ex) {\n            throw new UncheckedException(ex);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        return this;\n    }","id":102294,"modified_method":"@Override\n    public DeploymentDescriptor readFrom(Reader reader) {\n        try {\n            Node appNode = createParser().parse(reader);\n            version = (String) appNode.attribute(\"version\");\n            for (final Node child : Cast.<List<Node>>uncheckedCast(appNode.children())) {\n                String childLocalName = localNameOf(child);\n                if (childLocalName.equals(\"application-name\")) {\n\n                    applicationName = child.text();\n\n                } else if (childLocalName.equals(\"initialize-in-order\")) {\n\n                    initializeInOrder = Boolean.valueOf(child.text());\n\n                } else if (childLocalName.equals(\"description\")) {\n\n                    description = child.text();\n\n                } else if (childLocalName.equals(\"display-name\")) {\n\n                    displayName = child.text();\n\n                } else if (childLocalName.equals(\"library-directory\")) {\n\n                    libraryDirectory = child.text();\n\n                } else if (childLocalName.equals(\"module\")) {\n\n                    EarModule module = null;\n                    for (Node moduleNode : Cast.<List<Node>>uncheckedCast(child.children())) {\n                        String moduleNodeLocalName = localNameOf(moduleNode);\n                        if (moduleNodeLocalName.equals(\"web\")) {\n                            Node webUriNode = childNodeNamed(moduleNode, \"web-uri\");\n                            Node contextRootNode = childNodeNamed(moduleNode, \"context-root\");\n                            String webUri = webUriNode != null ? webUriNode.text() : null;\n                            String contextRoot = contextRootNode != null ? contextRootNode.text() : null;\n                            module = new DefaultEarWebModule(webUri, contextRoot);\n                            modules.add(module);\n                            moduleTypeMappings.put(module.getPath(), \"web\");\n                        } else if (moduleNodeLocalName.equals(\"alt-dd\")) {\n                            assert module != null;\n                            module.setAltDeployDescriptor(moduleNode.text());\n                        } else {\n                            module = new DefaultEarModule(moduleNode.text());\n                            modules.add(module);\n                            moduleTypeMappings.put(module.getPath(), moduleNodeLocalName);\n                        }\n                    }\n\n                } else if (childLocalName.equals(\"security-role\")) {\n\n                    Node roleNameNode = childNodeNamed(child, \"role-name\");\n                    Node descriptionNode = childNodeNamed(child, \"description\");\n                    String roleName = roleNameNode != null ? roleNameNode.text() : null;\n                    String description = descriptionNode != null ? descriptionNode.text() : null;\n                    securityRoles.add(new DefaultEarSecurityRole(roleName, description));\n\n                } else {\n                    withXml(new Action<XmlProvider>() {\n                        @Override\n                        public void execute(XmlProvider xmlProvider) {\n                            xmlProvider.asNode().append(child);\n                        }\n                    });\n                }\n            }\n        } catch (IOException ex) {\n            throw new UncheckedIOException(ex);\n        } catch (SAXException ex) {\n            throw new UncheckedException(ex);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        return this;\n    }","commit_id":"6248813685ef59b7dd1256fab790a3ddb901a324","url":"https://github.com/gradle/gradle"},{"original_method":"/** Sets the locale used to indetify the format of this datebox.\n\t * <p>Default: null (i.e., {@link Locales#getCurrent}, the current locale\n\t * is assumed)\n\t * @since 5.0.7\n\t */\n\tpublic void setLocale(Locale locale) {\n\t\t_locale = locale;\n\t}","id":102295,"modified_method":"/** Sets the locale used to indetify the format of this datebox.\n\t * <p>Default: null (i.e., {@link Locales#getCurrent}, the current locale\n\t * is assumed)\n\t * @since 5.0.7\n\t */\n\tpublic void setLocale(Locale locale) {\n\t\tif (!Objects.equals(_locale, locale)) {\n\t\t\t_locale = locale;\n\t\t\tsmartUpdate(\"format\", getRealFormat());\n\t\t\tsmartUpdate(\"localizedFormat\", getLocalizedFormat());\n\t\t}\n\t}","commit_id":"a0ae3020f81e8cb143c963bda7a4542830c88de4","url":"https://github.com/zkoss/zk"},{"original_method":"protected String coerceToString(Object value) {\n\t\tfinal DateFormat df = getDateFormat(getFormat());\n\t\treturn value != null ? df.format((Date) value) : \"\";\n\t}","id":102296,"modified_method":"protected String coerceToString(Object value) {\n\t\tfinal DateFormat df = getDateFormat(getRealFormat());\n\t\treturn value != null ? df.format((Date) value) : \"\";\n\t}","commit_id":"a0ae3020f81e8cb143c963bda7a4542830c88de4","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * Returns the localized format, which is used when constructing a datebox.\n\t * <p>\n\t * You might override this method to provide your own localized format.\n\t */\n\tprotected String getLocalizedFormat() {\n\t\tString format = getFormat();\n\t\tif (format == null)\n\t\t\tformat = getDefaultFormat();\n\t\treturn new SimpleDateFormat(format,\n\t\t\t_locale != null ? _locale: Locales.getCurrent()).toLocalizedPattern();\n\t}","id":102297,"modified_method":"/**\n\t * Returns the localized format, which is used when constructing a datebox.\n\t * <p>\n\t * You might override this method to provide your own localized format.\n\t */\n\tprotected String getLocalizedFormat() {\n\t\treturn new SimpleDateFormat(getRealFormat(),\n\t\t\t_locale != null ? _locale: Locales.getCurrent()).toLocalizedPattern();\n\t}","commit_id":"a0ae3020f81e8cb143c963bda7a4542830c88de4","url":"https://github.com/zkoss/zk"},{"original_method":"protected Object coerceFromString(String value) throws WrongValueException {\n\t\tif (value == null || value.length() == 0)\n\t\t\treturn null;\n\n\t\tfinal String fmt = getFormat();\n\t\tfinal DateFormat df = getDateFormat(fmt);\n\t\tdf.setLenient(_lenient);\n\t\tfinal Date date;\n\t\ttry {\n\t\t\tdate = df.parse(value);\n\t\t} catch (ParseException ex) {\n\t\t\tthrow showCustomError(new WrongValueException(this,\n\t\t\t\t\tMZul.DATE_REQUIRED, new Object[] { value, fmt }));\n\t\t}\n\t\treturn date;\n\t}","id":102298,"modified_method":"protected Object coerceFromString(String value) throws WrongValueException {\n\t\tif (value == null || value.length() == 0)\n\t\t\treturn null;\n\n\t\tfinal String fmt = getRealFormat();\n\t\tfinal DateFormat df = getDateFormat(fmt);\n\t\tdf.setLenient(_lenient);\n\t\tfinal Date date;\n\t\ttry {\n\t\t\tdate = df.parse(value);\n\t\t} catch (ParseException ex) {\n\t\t\tthrow showCustomError(new WrongValueException(this,\n\t\t\t\t\tMZul.DATE_REQUIRED, new Object[] { value, fmt }));\n\t\t}\n\t\treturn date;\n\t}","commit_id":"a0ae3020f81e8cb143c963bda7a4542830c88de4","url":"https://github.com/zkoss/zk"},{"original_method":"public Datebox() {\n\t\tsetFormat(getDefaultFormat());\n\t\tsetCols(11);\n\t}","id":102299,"modified_method":"public Datebox() {\n\t\tsetFormat(\"\");\n\t\tsetCols(11);\n\t}","commit_id":"a0ae3020f81e8cb143c963bda7a4542830c88de4","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets the date format.\n<p>If null or empty is specified, {@link #getDefaultFormat} is assumed.\nSince 5.0.7, you could specify one of the following reserved words,\nand {@link DateFormats#getDateFormat} or {@link DateFormats#getDateTimeFormat}\nwill be used to retrieve the real format.\n<table border=0 cellspacing=3 cellpadding=0>\n<tr>\n<td>short<\/td>\n<td>{@link DateFormats#getDateFormat} with {@link DateFormat#SHORT}<\/td>\n<\/tr>\n<tr>\n<td>medium<\/td>\n<td>{@link DateFormats#getDateFormat} with {@link DateFormat#MEDIUM}<\/td>\n<\/tr>\n<tr>\n<td>long<\/td>\n<td>{@link DateFormats#getDateFormat} with {@link DateFormat#LONG}<\/td>\n<\/tr>\n<tr>\n<td>full<\/td>\n<td>{@link DateFormats#getDateFormat} with {@link DateFormat#FULL}<\/td>\n<\/tr>\n<\/table>\n\n<p>To specify a date/time format, you could specify two reserved words, separated\nby a plus. For example, \"medium+short\" means \n{@link DateFormats#getDateTimeFormat} with the medium date styling and\nthe short time styling.\n\n<p>In additions, the format could be a cominbation of the following pattern letters:\n<table border=0 cellspacing=3 cellpadding=0>\n\n     <tr bgcolor=\"#ccccff\">\n         <th align=left>Letter\n         <th align=left>Date or Time Component\n         <th align=left>Presentation\n         <th align=left>Examples\n     <tr>\n         <td><code>G<\/code>\n         <td>Era designator\n         <td><a href=\"#text\">Text<\/a>\n         <td><code>AD<\/code>\n\n     <tr bgcolor=\"#eeeeff\">\n         <td><code>y<\/code>\n         <td>Year\n         <td><a href=\"#year\">Year<\/a>\n         <td><code>1996<\/code>; <code>96<\/code>\n     <tr>\n         <td><code>M<\/code>\n\n         <td>Month in year\n         <td><a href=\"#month\">Month<\/a>\n         <td><code>July<\/code>; <code>Jul<\/code>; <code>07<\/code>\n     <tr bgcolor=\"#eeeeff\">\n         <td><code>w<\/code>\n         <td>Week in year (starting at 1)\n         <td><a href=\"#number\">Number<\/a>\n\n         <td><code>27<\/code>\n     <tr>\n         <td><code>W<\/code>\n         <td>Week in month (starting at 1)\n         <td><a href=\"#number\">Number<\/a>\n         <td><code>2<\/code>\n     <tr bgcolor=\"#eeeeff\">\n\n         <td><code>D<\/code>\n         <td>Day in year (starting at 1)\n         <td><a href=\"#number\">Number<\/a>\n         <td><code>189<\/code>\n     <tr>\n         <td><code>d<\/code>\n         <td>Day in month (starting at 1)\n         <td><a href=\"#number\">Number<\/a>\n\n         <td><code>10<\/code>\n     <tr bgcolor=\"#eeeeff\">\n         <td><code>F<\/code>\n         <td>Day of week in month\n         <td><a href=\"#number\">Number<\/a>\n         <td><code>2<\/code>\n     <tr>\n\n         <td><code>E<\/code>\n         <td>Day in week\n         <td><a href=\"#text\">Text<\/a>\n         <td><code>Tuesday<\/code>; <code>Tue<\/code>\n <\/table>\n \t */\n\tpublic void setFormat(String format) throws WrongValueException {\n\t\tif (format == null || format.length() == 0) {\n\t\t\tformat = getDefaultFormat(); //backward compatible\n\t\t} else {\n\t\t\tboolean bCustom = true;\n\t\t\tint ds = format.indexOf('+');\n\t\t\tif (ds > 0) {\n\t\t\t\tint ts = toStyle(format.substring(ds + 1));\n\t\t\t\tif (ts != -111) {\n\t\t\t\t\tds = toStyle(format.substring(0, ds));\n\t\t\t\t\tif (ds != -111) {\n\t\t\t\t\t\tbCustom = false;\n\t\t\t\t\t\tformat = DateFormats.getDateTimeFormat(ds, ts, _locale, DEFAULT_FORMAT + \" \" + Timebox.DEFAULT_FORMAT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tds = toStyle(format);\n\t\t\t\tif (ds != -111) {\n\t\t\t\t\tbCustom = false;\n\t\t\t\t\tformat = DateFormats.getDateFormat(ds, _locale, DEFAULT_FORMAT);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bCustom)\n\t\t\t\tgetDateFormat(format); // make sure the format is correct\n\t\t}\n\t\tsuper.setFormat(format);\n\t\tsmartUpdate(\"localizedFormat\", getLocalizedFormat());\n\t}","id":102300,"modified_method":"/** Sets the date format.\n<p>If null or empty is specified, {@link #getDefaultFormat} is assumed.\nSince 5.0.7, you could specify one of the following reserved words,\nand {@link DateFormats#getDateFormat} or {@link DateFormats#getDateTimeFormat}\nwill be used to retrieve the real format.\n<table border=0 cellspacing=3 cellpadding=0>\n<tr>\n<td>short<\/td>\n<td>{@link DateFormats#getDateFormat} with {@link DateFormat#SHORT}<\/td>\n<\/tr>\n<tr>\n<td>medium<\/td>\n<td>{@link DateFormats#getDateFormat} with {@link DateFormat#MEDIUM}<\/td>\n<\/tr>\n<tr>\n<td>long<\/td>\n<td>{@link DateFormats#getDateFormat} with {@link DateFormat#LONG}<\/td>\n<\/tr>\n<tr>\n<td>full<\/td>\n<td>{@link DateFormats#getDateFormat} with {@link DateFormat#FULL}<\/td>\n<\/tr>\n<\/table>\n\n<p>To specify a date/time format, you could specify two reserved words, separated\nby a plus. For example, \"medium+short\" means \n{@link DateFormats#getDateTimeFormat} with the medium date styling and\nthe short time styling.\n\n<p>In additions, the format could be a cominbation of the following pattern letters:\n<table border=0 cellspacing=3 cellpadding=0>\n\n     <tr bgcolor=\"#ccccff\">\n         <th align=left>Letter\n         <th align=left>Date or Time Component\n         <th align=left>Presentation\n         <th align=left>Examples\n     <tr>\n         <td><code>G<\/code>\n         <td>Era designator\n         <td><a href=\"#text\">Text<\/a>\n         <td><code>AD<\/code>\n\n     <tr bgcolor=\"#eeeeff\">\n         <td><code>y<\/code>\n         <td>Year\n         <td><a href=\"#year\">Year<\/a>\n         <td><code>1996<\/code>; <code>96<\/code>\n     <tr>\n         <td><code>M<\/code>\n\n         <td>Month in year\n         <td><a href=\"#month\">Month<\/a>\n         <td><code>July<\/code>; <code>Jul<\/code>; <code>07<\/code>\n     <tr bgcolor=\"#eeeeff\">\n         <td><code>w<\/code>\n         <td>Week in year (starting at 1)\n         <td><a href=\"#number\">Number<\/a>\n\n         <td><code>27<\/code>\n     <tr>\n         <td><code>W<\/code>\n         <td>Week in month (starting at 1)\n         <td><a href=\"#number\">Number<\/a>\n         <td><code>2<\/code>\n     <tr bgcolor=\"#eeeeff\">\n\n         <td><code>D<\/code>\n         <td>Day in year (starting at 1)\n         <td><a href=\"#number\">Number<\/a>\n         <td><code>189<\/code>\n     <tr>\n         <td><code>d<\/code>\n         <td>Day in month (starting at 1)\n         <td><a href=\"#number\">Number<\/a>\n\n         <td><code>10<\/code>\n     <tr bgcolor=\"#eeeeff\">\n         <td><code>F<\/code>\n         <td>Day of week in month\n         <td><a href=\"#number\">Number<\/a>\n         <td><code>2<\/code>\n     <tr>\n\n         <td><code>E<\/code>\n         <td>Day in week\n         <td><a href=\"#text\">Text<\/a>\n         <td><code>Tuesday<\/code>; <code>Tue<\/code>\n <\/table>\n \t */\n\tpublic void setFormat(String format) throws WrongValueException {\n\t\tif (format == null) {\n\t\t\tformat =  \"\";\n\t\t} else if (format.length() != 0) {\n\t\t\tboolean bCustom;\n\t\t\tint j = format.indexOf('+');\n\t\t\tif (j > 0) {\n\t\t\t\tbCustom = toStyle(format.substring(j + 1)) == -111\n\t\t\t\t\t|| toStyle(format.substring(0, j)) == -111;\n\t\t\t} else {\n\t\t\t\tbCustom = toStyle(format) == -111;\n\t\t\t}\n\t\t\tif (bCustom)\n\t\t\t\tgetDateFormat(format); // make sure the format is correct\n\t\t}\n\t\tsuper.setFormat(format);\n\t\tsmartUpdate(\"localizedFormat\", getLocalizedFormat());\n\t}","commit_id":"a0ae3020f81e8cb143c963bda7a4542830c88de4","url":"https://github.com/zkoss/zk"},{"original_method":"protected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\tthrows java.io.IOException {\n\t\trender(renderer, \"format\", _format);//value might depend on format (though it shall not)\n\t\tsuper.renderProperties(renderer);\n\t}","id":102301,"modified_method":"protected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\tthrows java.io.IOException {\n\t\trender(renderer, \"format\", getRealFormat());//value might depend on format (though it shall not)\n\t\tsuper.renderProperties(renderer);\n\t}","commit_id":"a0ae3020f81e8cb143c963bda7a4542830c88de4","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets the format.\n\t */\n\tpublic void setFormat(String format) throws WrongValueException {\n\t\tif (!Objects.equals(_format, format)) {\n\t\t\tfinal String old = _format;\n\t\t\t_format = format;\n\t\t\tsmartUpdate(\"format\", _format);\n\t\t\tsmartUpdate(\"_value\", marshall(_value));\n\t\t\t\t//Technically, it shall be indepedent of format, but it is\n\t\t\t\t//safer to send again (since some implementation might not good)\n\t\t\t\t//See also bug 2998196.\n\t\t}\n\t}","id":102302,"modified_method":"/** Sets the format.\n\t */\n\tpublic void setFormat(String format) throws WrongValueException {\n\t\tif (!Objects.equals(_format, format)) {\n\t\t\t_format = format;\n\t\t\tsmartUpdate(\"format\", getRealFormat());\n\t\t\tsmartUpdate(\"_value\", marshall(_value));\n\t\t\t\t//Technically, it shall be indepedent of format, but it is\n\t\t\t\t//safer to send again (since some implementation might not good)\n\t\t\t\t//See also bug 2998196.\n\t\t}\n\t}","commit_id":"a0ae3020f81e8cb143c963bda7a4542830c88de4","url":"https://github.com/zkoss/zk"},{"original_method":"protected Object coerceFromString(String value) throws WrongValueException {\n\t\t//null or empty string,\n\t\tif (value == null || value.length() == 0){\n\t\t\treturn null;\n\t\t}\n\t\tfinal String fmt = getFormat();\n\t\tfinal DateFormat df = getDateFormat(fmt);\n\t\tfinal Date date;\n\t\ttry {\n\t\t\tdate = df.parse(value);\n\t\t} catch (ParseException ex) {\n\t\t\tthrow showCustomError(\n\t\t\t\tnew WrongValueException(this, MZul.DATE_REQUIRED,\n\t\t\t\t\tnew Object[] {value, fmt}));\n\t\t}\n\t\treturn date;\n\t}","id":102303,"modified_method":"protected Object coerceFromString(String value) throws WrongValueException {\n\t\t//null or empty string,\n\t\tif (value == null || value.length() == 0){\n\t\t\treturn null;\n\t\t}\n\t\tfinal String fmt = getRealFormat();\n\t\tfinal DateFormat df = getDateFormat(fmt);\n\t\tfinal Date date;\n\t\ttry {\n\t\t\tdate = df.parse(value);\n\t\t} catch (ParseException ex) {\n\t\t\tthrow showCustomError(\n\t\t\t\tnew WrongValueException(this, MZul.DATE_REQUIRED,\n\t\t\t\t\tnew Object[] {value, fmt}));\n\t\t}\n\t\treturn date;\n\t}","commit_id":"a0ae3020f81e8cb143c963bda7a4542830c88de4","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets the date format.\n<p>If null or empty is specified, {@link #getDefaultFormat} is assumed.\nSince 5.0.7, you could specify one of the following reserved words,\nand {@link DateFormats#getTimeFormat}\nwill be used to retrieve the real format.\n<table border=0 cellspacing=3 cellpadding=0>\n<tr>\n<td>short<\/td>\n<td>{@link DateFormats#getTimeFormat} with {@link DateFormat#SHORT}<\/td>\n<\/tr>\n<tr>\n<td>medium<\/td>\n<td>{@link DateFormats#getTimeFormat} with {@link DateFormat#MEDIUM}<\/td>\n<\/tr>\n<tr>\n<td>long<\/td>\n<td>{@link DateFormats#getTimeFormat} with {@link DateFormat#LONG}<\/td>\n<\/tr>\n<tr>\n<td>full<\/td>\n<td>{@link DateFormats#getTimeFormat} with {@link DateFormat#FULL}<\/td>\n<\/tr>\n<\/table>\n\n<p>In additions, the format could be a combination of the following pattern letters:\n<table border=0 cellspacing=3 cellpadding=0>\n\n     <tr bgcolor=\"#ccccff\">\n         <th align=left>Letter\n         <th align=left>Date or Time Component\n         <th align=left>Presentation\n         <th align=left>Examples\n     <tr>\n *     <tr bgcolor=\"#eeeeff\">\n *         <td><code>a<\/code>\n *         <td>Am/pm marker\n *         <td><a href=\"#text\">Text<\/a>\n *         <td><code>PM<\/code>\n *     <tr>\n *         <td><code>H<\/code>\n *         <td>Hour in day (0-23)\n *         <td><a href=\"#number\">Number<\/a>\n *         <td><code>0<\/code>\n *     <tr bgcolor=\"#eeeeff\">\n *         <td><code>k<\/code>\n *         <td>Hour in day (1-24)\n *         <td><a href=\"#number\">Number<\/a>\n *         <td><code>24<\/code>\n *     <tr>\n *         <td><code>K<\/code>\n *         <td>Hour in am/pm (0-11)\n *         <td><a href=\"#number\">Number<\/a>\n *         <td><code>0<\/code>\n *     <tr bgcolor=\"#eeeeff\">\n *         <td><code>h<\/code>\n *         <td>Hour in am/pm (1-12)\n *         <td><a href=\"#number\">Number<\/a>\n *         <td><code>12<\/code>\n *     <tr>\n *         <td><code>m<\/code>\n *         <td>Minute in hour\n *         <td><a href=\"#number\">Number<\/a>\n *         <td><code>30<\/code>\n *     <tr bgcolor=\"#eeeeff\">\n *         <td><code>s<\/code>\n *         <td>Second in minute\n *         <td><a href=\"#number\">Number<\/a>\n *         <td><code>55<\/code>\n <\/table>\n \t@since 5.0.0\n \t */\n\tpublic void setFormat(String format) throws WrongValueException {\n\t\tif (format == null || format.length() == 0) {\n\t\t\tformat = getDefaultFormat();\n\t\t} else {\n\t\t\tint ts = Datebox.toStyle(format);\n\t\t\tif (ts != -111)\n\t\t\t\tformat = DateFormats.getTimeFormat(ts, _locale, DEFAULT_FORMAT);\n\t\t}\n\t\tsuper.setFormat(format);\n\t}","id":102304,"modified_method":"/** Sets the date format.\n<p>If null or empty is specified, {@link #getDefaultFormat} is assumed.\nSince 5.0.7, you could specify one of the following reserved words,\nand {@link DateFormats#getTimeFormat}\nwill be used to retrieve the real format.\n<table border=0 cellspacing=3 cellpadding=0>\n<tr>\n<td>short<\/td>\n<td>{@link DateFormats#getTimeFormat} with {@link DateFormat#SHORT}<\/td>\n<\/tr>\n<tr>\n<td>medium<\/td>\n<td>{@link DateFormats#getTimeFormat} with {@link DateFormat#MEDIUM}<\/td>\n<\/tr>\n<tr>\n<td>long<\/td>\n<td>{@link DateFormats#getTimeFormat} with {@link DateFormat#LONG}<\/td>\n<\/tr>\n<tr>\n<td>full<\/td>\n<td>{@link DateFormats#getTimeFormat} with {@link DateFormat#FULL}<\/td>\n<\/tr>\n<\/table>\n\n<p>In additions, the format could be a combination of the following pattern letters:\n<table border=0 cellspacing=3 cellpadding=0>\n\n     <tr bgcolor=\"#ccccff\">\n         <th align=left>Letter\n         <th align=left>Date or Time Component\n         <th align=left>Presentation\n         <th align=left>Examples\n     <tr>\n *     <tr bgcolor=\"#eeeeff\">\n *         <td><code>a<\/code>\n *         <td>Am/pm marker\n *         <td><a href=\"#text\">Text<\/a>\n *         <td><code>PM<\/code>\n *     <tr>\n *         <td><code>H<\/code>\n *         <td>Hour in day (0-23)\n *         <td><a href=\"#number\">Number<\/a>\n *         <td><code>0<\/code>\n *     <tr bgcolor=\"#eeeeff\">\n *         <td><code>k<\/code>\n *         <td>Hour in day (1-24)\n *         <td><a href=\"#number\">Number<\/a>\n *         <td><code>24<\/code>\n *     <tr>\n *         <td><code>K<\/code>\n *         <td>Hour in am/pm (0-11)\n *         <td><a href=\"#number\">Number<\/a>\n *         <td><code>0<\/code>\n *     <tr bgcolor=\"#eeeeff\">\n *         <td><code>h<\/code>\n *         <td>Hour in am/pm (1-12)\n *         <td><a href=\"#number\">Number<\/a>\n *         <td><code>12<\/code>\n *     <tr>\n *         <td><code>m<\/code>\n *         <td>Minute in hour\n *         <td><a href=\"#number\">Number<\/a>\n *         <td><code>30<\/code>\n *     <tr bgcolor=\"#eeeeff\">\n *         <td><code>s<\/code>\n *         <td>Second in minute\n *         <td><a href=\"#number\">Number<\/a>\n *         <td><code>55<\/code>\n <\/table>\n \t@since 5.0.0\n \t */\n\tpublic void setFormat(String format) throws WrongValueException {\n\t\tsuper.setFormat(format != null ? format: \"\");\n\t}","commit_id":"a0ae3020f81e8cb143c963bda7a4542830c88de4","url":"https://github.com/zkoss/zk"},{"original_method":"public Timebox() {\n\t\tsetCols(5);\n\t\tsetFormat(getDefaultFormat());\n\t}","id":102305,"modified_method":"public Timebox() {\n\t\tsetCols(5);\n\t\tsetFormat(\"\");\n\t}","commit_id":"a0ae3020f81e8cb143c963bda7a4542830c88de4","url":"https://github.com/zkoss/zk"},{"original_method":"protected String coerceToString(Object value) {\n\t\tfinal DateFormat df = getDateFormat(getFormat());\n\t\treturn value != null ? df.format((Date) value) : \"\";\n\t}","id":102306,"modified_method":"protected String coerceToString(Object value) {\n\t\tfinal DateFormat df = getDateFormat(getRealFormat());\n\t\treturn value != null ? df.format((Date) value) : \"\";\n\t}","commit_id":"a0ae3020f81e8cb143c963bda7a4542830c88de4","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets the locale used to indetify the format of this timebox.\n\t * <p>Default: null (i.e., {@link Locales#getCurrent}, the current locale\n\t * is assumed)\n\t * @since 5.0.7\n\t */\n\tpublic void setLocale(Locale locale) {\n\t\t_locale = locale;\n\t}","id":102307,"modified_method":"/** Sets the locale used to indetify the format of this timebox.\n\t * <p>Default: null (i.e., {@link Locales#getCurrent}, the current locale\n\t * is assumed)\n\t * @since 5.0.7\n\t */\n\tpublic void setLocale(Locale locale) {\n\t\tif (!Objects.equals(_locale, locale)) {\n\t\t\t_locale = locale;\n\t\t\tsmartUpdate(\"format\", getRealFormat());\n\t\t}\n\t}","commit_id":"a0ae3020f81e8cb143c963bda7a4542830c88de4","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void executeDMLUpdates() throws AmbariException, SQLException {\n    // remove NAGIOS to make way for the new embedded alert framework\n    removeNagiosService();\n    updateHiveDatabaseType();\n  }","id":102308,"modified_method":"/**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void executeDMLUpdates() throws AmbariException, SQLException {\n    // remove NAGIOS to make way for the new embedded alert framework\n    removeNagiosService();\n    addNewConfigurationsFromXml();\n    updateHiveDatabaseType();\n  }","commit_id":"6a70baa2a0ef444444f933584a8cf3a8c1a79074","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Tests that each DML method is invoked.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void testExecuteDMLUpdates() throws Exception {\n    Method removeNagiosService = UpgradeCatalog200.class.getDeclaredMethod(\"removeNagiosService\");\n    Method updateHiveDatabaseType = UpgradeCatalog200.class.getDeclaredMethod(\"updateHiveDatabaseType\");\n\n    UpgradeCatalog200 upgradeCatalog = createMockBuilder(\n        UpgradeCatalog200.class).addMockedMethod(removeNagiosService).addMockedMethod(updateHiveDatabaseType).createMock();\n\n    upgradeCatalog.removeNagiosService();\n    expectLastCall().once();\n    upgradeCatalog.updateHiveDatabaseType();\n    expectLastCall().once();\n\n\n    replay(upgradeCatalog);\n\n    upgradeCatalog.executeDMLUpdates();\n\n    verify(upgradeCatalog);\n  }","id":102309,"modified_method":"/**\n   * Tests that each DML method is invoked.\n   *\n   * @throws Exception\n   */\n  @Test\n  public void testExecuteDMLUpdates() throws Exception {\n    Method removeNagiosService = UpgradeCatalog200.class.getDeclaredMethod(\"removeNagiosService\");\n    Method updateHiveDatabaseType = UpgradeCatalog200.class.getDeclaredMethod(\"updateHiveDatabaseType\");\n    Method addNewConfigurationsFromXml = AbstractUpgradeCatalog.class.getDeclaredMethod\n        (\"addNewConfigurationsFromXml\");\n\n    UpgradeCatalog200 upgradeCatalog = createMockBuilder(\n        UpgradeCatalog200.class).addMockedMethod(removeNagiosService).addMockedMethod(updateHiveDatabaseType).addMockedMethod(addNewConfigurationsFromXml).createMock();\n\n    upgradeCatalog.removeNagiosService();\n    expectLastCall().once();\n    upgradeCatalog.addNewConfigurationsFromXml();\n    expectLastCall();\n    upgradeCatalog.updateHiveDatabaseType();\n    expectLastCall().once();\n\n\n    replay(upgradeCatalog);\n\n    upgradeCatalog.executeDMLUpdates();\n\n    verify(upgradeCatalog);\n  }","commit_id":"6a70baa2a0ef444444f933584a8cf3a8c1a79074","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  protected void executeDMLUpdates() throws AmbariException, SQLException {\n    addMissingConfigs();\n    updateAMSConfigs();\n    updateAlertDefinitions();\n  }","id":102310,"modified_method":"@Override\n  protected void executeDMLUpdates() throws AmbariException, SQLException {\n    addNewConfigurationsFromXml();\n    updateAlertDefinitions();\n    updateStormConfigs();\n    updateAMSConfigs();\n    updateHbaseEnvConfig();\n  }","commit_id":"f32e65b08ba5dbc3bca95d6ca1f295e24b9706a7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExecuteDMLUpdates() throws Exception {\n    Method addMissingConfigs = UpgradeCatalog213.class.getDeclaredMethod(\"addMissingConfigs\");\n    Method updateAMSConfigs = UpgradeCatalog213.class.getDeclaredMethod(\"updateAMSConfigs\");\n    Method updateAlertDefinitions = UpgradeCatalog213.class.getDeclaredMethod(\"updateAlertDefinitions\");\n\n    UpgradeCatalog213 upgradeCatalog213 = createMockBuilder(UpgradeCatalog213.class)\n        .addMockedMethod(addMissingConfigs)\n        .addMockedMethod(updateAMSConfigs)\n        .addMockedMethod(updateAlertDefinitions)\n        .createMock();\n\n    upgradeCatalog213.addMissingConfigs();\n    expectLastCall().once();\n    upgradeCatalog213.updateAMSConfigs();\n    expectLastCall().once();\n    upgradeCatalog213.updateAlertDefinitions();\n    expectLastCall().once();\n\n    replay(upgradeCatalog213);\n\n    upgradeCatalog213.executeDMLUpdates();\n\n    verify(upgradeCatalog213);\n  }","id":102311,"modified_method":"@Test\n  public void testExecuteDMLUpdates() throws Exception {\n    Method updateAMSConfigs = UpgradeCatalog213.class.getDeclaredMethod(\"updateAMSConfigs\");\n    Method updateStormConfigs = UpgradeCatalog213.class.getDeclaredMethod(\"updateStormConfigs\");\n    Method addNewConfigurationsFromXml = AbstractUpgradeCatalog.class.getDeclaredMethod(\"addNewConfigurationsFromXml\");\n    Method updateHbaseEnvConfig = UpgradeCatalog213.class.getDeclaredMethod(\"updateHbaseEnvConfig\");\n    Method updateAlertDefinitions = UpgradeCatalog213.class.getDeclaredMethod(\"updateAlertDefinitions\");\n\n    UpgradeCatalog213 upgradeCatalog213 = createMockBuilder(UpgradeCatalog213.class)\n        .addMockedMethod(updateAMSConfigs)\n        .addMockedMethod(updateStormConfigs)\n        .addMockedMethod(addNewConfigurationsFromXml)\n        .addMockedMethod(updateHbaseEnvConfig)\n        .addMockedMethod(updateAlertDefinitions)\n        .createMock();\n\n    upgradeCatalog213.updateHbaseEnvConfig();\n    expectLastCall().once();\n    upgradeCatalog213.addNewConfigurationsFromXml();\n    expectLastCall().once();\n    upgradeCatalog213.updateStormConfigs();\n    expectLastCall().once();\n    upgradeCatalog213.updateAMSConfigs();\n    expectLastCall().once();\n    upgradeCatalog213.updateAlertDefinitions();\n    expectLastCall().once();\n\n    replay(upgradeCatalog213);\n\n    upgradeCatalog213.executeDMLUpdates();\n\n    verify(upgradeCatalog213);\n  }","commit_id":"f32e65b08ba5dbc3bca95d6ca1f295e24b9706a7","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Create a new cluster scoped configuration with the new properties added\n   * to the existing set of properties.\n   * @param configType Configuration type. (hdfs-site, etc.)\n   * @param properties Map of key value pairs to add / update.\n   */\n  protected void updateConfigurationProperties(String configType,\n        Map<String, String> properties, boolean updateIfExists, boolean createNewConfigType) throws\n    AmbariException {\n    AmbariManagementController controller = injector.getInstance(AmbariManagementController.class);\n    String newTag = \"version\" + System.currentTimeMillis();\n\n    Clusters clusters = controller.getClusters();\n    if (clusters == null) {\n      return;\n    }\n    Map<String, Cluster> clusterMap = clusters.getClusters();\n\n    if (clusterMap != null && !clusterMap.isEmpty()) {\n      for (Cluster cluster : clusterMap.values()) {\n        if (properties != null) {\n          Map<String, Config> all = cluster.getConfigsByType(configType);\n          if (all == null || !all.containsKey(newTag) || properties.size() > 0) {\n            Map<String, String> oldConfigProperties;\n            Config oldConfig = cluster.getDesiredConfigByType(configType);\n            \n            if (oldConfig == null && !createNewConfigType) {\n              LOG.info(\"Config \" + configType + \" not found. Assuming service not installed. \" +\n                  \"Skipping configuration properties update\");\n              return;\n            } else if (oldConfig == null) {\n              oldConfigProperties = new HashMap<String, String>();\n              newTag = \"version1\";\n            } else {\n              oldConfigProperties = oldConfig.getProperties();\n            }\n\n            Map<String, String> mergedProperties =\n              mergeProperties(oldConfigProperties, properties, updateIfExists);\n\n            if (!Maps.difference(oldConfigProperties, mergedProperties).areEqual()) {\n              LOG.info(\"Applying configuration with tag '{}' to \" +\n                \"cluster '{}'\", newTag, cluster.getClusterName());\n\n              ConfigurationRequest cr = new ConfigurationRequest();\n              cr.setClusterName(cluster.getClusterName());\n              cr.setVersionTag(newTag);\n              cr.setType(configType);\n              cr.setProperties(mergedProperties);\n              controller.createConfiguration(cr);\n\n              Config baseConfig = cluster.getConfig(cr.getType(), cr.getVersionTag());\n              if (baseConfig != null) {\n                String authName = \"ambari-upgrade\";\n\n                if (cluster.addDesiredConfig(authName, Collections.singleton(baseConfig)) != null) {\n                  String oldConfigString = (oldConfig != null) ? \" from='\" + oldConfig.getTag() + \"'\" : \"\";\n                  LOG.info(\"cluster '\" + cluster.getClusterName() + \"' \"\n                    + \"changed by: '\" + authName + \"'; \"\n                    + \"type='\" + baseConfig.getType() + \"' \"\n                    + \"tag='\" + baseConfig.getTag() + \"'\"\n                    + oldConfigString);\n                }\n              }\n            } else {\n              LOG.info(\"No changes detected to config \" + configType + \". Skipping configuration properties update\");\n            }\n          }\n        }\n      }\n    }\n  }","id":102312,"modified_method":"/**\n   * Create a new cluster scoped configuration with the new properties added\n   * to the existing set of properties.\n   * @param configType Configuration type. (hdfs-site, etc.)\n   * @param properties Map of key value pairs to add / update.\n   */\n  protected void updateConfigurationProperties(String configType,\n        Map<String, String> properties, boolean updateIfExists, boolean createNewConfigType) throws\n    AmbariException {\n    AmbariManagementController controller = injector.getInstance(AmbariManagementController.class);\n\n    Clusters clusters = controller.getClusters();\n    if (clusters == null) {\n      return;\n    }\n    Map<String, Cluster> clusterMap = clusters.getClusters();\n\n    if (clusterMap != null && !clusterMap.isEmpty()) {\n      for (Cluster cluster : clusterMap.values()) {\n        updateConfigurationPropertiesForCluster(cluster, configType,\n            properties, updateIfExists, createNewConfigType);\n      }\n    }\n  }","commit_id":"d99a275f552813593ff378270a8d411f34a25937","url":"https://github.com/apache/ambari"},{"original_method":"public String getPropertyValueFromStackDefenitions(Cluster cluster, String configType, String propertyName) throws AmbariException {\n    StackId stackId = cluster.getCurrentStackVersion();\n    StackInfo stack = ambariMetaInfo.getStackInfo(stackId.getStackName(),\n        stackId.getStackVersion());\n    \n    for(ServiceInfo serviceInfo:stack.getServices()) {     \n      Set<PropertyInfo> stackProperties = ambariMetaInfo.getProperties(stack.getName(), stack.getVersion(), serviceInfo.getName());\n      \n      for (PropertyInfo stackProperty : stackProperties) {\n        String stackPropertyConfigType = fileNameToConfigType(stackProperty.getFilename());\n        \n        if(stackProperty.getName().equals(propertyName) && stackPropertyConfigType.equals(configType)) {\n          return stackProperty.getValue();\n        }\n      }\n      \n    }\n    \n    return null;\n  }","id":102313,"modified_method":"public String getPropertyValueFromStackDefenitions(Cluster cluster, String configType, String propertyName) throws AmbariException {\n    StackId stackId = cluster.getCurrentStackVersion();\n    StackInfo stack = ambariMetaInfo.getStackInfo(stackId.getStackName(),\n        stackId.getStackVersion());\n    \n    for(ServiceInfo serviceInfo:stack.getServices()) {     \n      Set<PropertyInfo> stackProperties = ambariMetaInfo.getProperties(stack.getName(), stack.getVersion(), serviceInfo.getName());\n      Set<PropertyInfo> stackLevelProperties = ambariMetaInfo.getStackProperties(stack.getName(), stack.getVersion());\n      stackProperties.addAll(stackLevelProperties);\n      \n      for (PropertyInfo stackProperty : stackProperties) {\n        String stackPropertyConfigType = fileNameToConfigType(stackProperty.getFilename());\n        \n        if(stackProperty.getName().equals(propertyName) && stackPropertyConfigType.equals(configType)) {\n          return stackProperty.getValue();\n        }\n      }\n      \n    }\n    \n    return null;\n  }","commit_id":"d99a275f552813593ff378270a8d411f34a25937","url":"https://github.com/apache/ambari"},{"original_method":"protected void addMissingConfigs() throws AmbariException {\n    updateConfigurationProperties(\"hbase-site\", Collections.singletonMap(\"hbase.regionserver.info.port\", \"60030\"), false, false);\n    updateConfigurationProperties(\"hbase-site\", Collections.singletonMap(\"hbase.master.info.port\", \"60010\"), false, false);\n    updateConfigurationProperties(\"hive-site\", Collections.singletonMap(\"hive.heapsize\", \"1024\"), false, false);\n    updateConfigurationProperties(\"pig-properties\", Collections.singletonMap(\"pig-content\", \"\\n# Licensed to the Apache \" +\n            \"Software Foundation (ASF) under one\\n# or more contributor license agreements.  See the NOTICE file\\n# \" +\n            \"distributed with this work for additional information\\n# regarding copyright ownership.  The ASF \" +\n            \"licenses this file\\n# to you under the Apache License, Version 2.0 (the\\n# \\\"License\\\"); you may \" +\n            \"not use this file except in compliance\\n# with the License.  You may obtain a copy of the License \" +\n            \"at\\n#\\n#http://www.apache.org/licenses/LICENSE-2.0\\n#\\n# Unless required by applicable law or agreed to \" +\n            \"in writing,\\n# software distributed under the License is distributed on an\\n# \\\"AS IS\\\" BASIS, WITHOUT \" +\n            \"WARRANTIES OR CONDITIONS OF ANY\\n# KIND, either express or implied.  See the License for the\\n# \" +\n            \"specific language governing permissions and limitations\\n# under the License.\\n\\n# Pig default \" +\n            \"configuration file. All values can be overwritten by pig.properties and command line arguments.\\n# \" +\n            \"see bin/pig -help\\n\\n# brief logging (no timestamps)\\nbrief=false\\n\\n# debug level, INFO is default\" +\n            \"\\ndebug=INFO\\n\\n# verbose print all log messages to screen (default to print only INFO and above to \" +\n            \"screen)\\nverbose=false\\n\\n# exectype local|mapreduce, mapreduce is default\\nexectype=mapreduce\\n\\n# \" +\n            \"Enable insertion of information about script into hadoop job conf \\npig.script.info.enabled=true\\n\\n# \" +\n            \"Do not spill temp files smaller than this size (bytes)\\npig.spill.size.threshold=5000000\\n\\n# \" +\n            \"EXPERIMENT: Activate garbage collection when spilling a file bigger than this size (bytes)\\n# \" +\n            \"This should help reduce the number of files being spilled.\\npig.spill.gc.activation.size=40000000\\n\\n# \" +\n            \"the following two parameters are to help estimate the reducer number\\npig.exec.reducers.bytes.per.\" +\n            \"reducer=1000000000\\npig.exec.reducers.max=999\\n\\n# Temporary location to store the intermediate \" +\n            \"data.\\npig.temp.dir=/tmp/\\n\\n# Threshold for merging FRJoin fragment files\\npig.files.concatenation.\" +\n            \"threshold=100\\npig.optimistic.files.concatenation=false;\\n\\npig.disable.counter=false\\n\\n\" +\n            \"hcat.bin=/usr/bin/hcat\"), true, true);\n  }","id":102314,"modified_method":"protected void addMissingConfigs() throws AmbariException {\n    updateConfigurationProperties(\"hbase-site\", Collections.singletonMap(\"hbase.regionserver.info.port\", \"60030\"), false, false);\n    updateConfigurationProperties(\"hbase-site\", Collections.singletonMap(\"hbase.master.info.port\", \"60010\"), false, false);\n    updateConfigurationProperties(\"hive-site\", Collections.singletonMap(\"hive.heapsize\", \"1024\"), false, false);\n    updateConfigurationProperties(\"pig-properties\", Collections.singletonMap(\"pig-content\", \"\\n# Licensed to the Apache \" +\n            \"Software Foundation (ASF) under one\\n# or more contributor license agreements.  See the NOTICE file\\n# \" +\n            \"distributed with this work for additional information\\n# regarding copyright ownership.  The ASF \" +\n            \"licenses this file\\n# to you under the Apache License, Version 2.0 (the\\n# \\\"License\\\"); you may \" +\n            \"not use this file except in compliance\\n# with the License.  You may obtain a copy of the License \" +\n            \"at\\n#\\n#http://www.apache.org/licenses/LICENSE-2.0\\n#\\n# Unless required by applicable law or agreed to \" +\n            \"in writing,\\n# software distributed under the License is distributed on an\\n# \\\"AS IS\\\" BASIS, WITHOUT \" +\n            \"WARRANTIES OR CONDITIONS OF ANY\\n# KIND, either express or implied.  See the License for the\\n# \" +\n            \"specific language governing permissions and limitations\\n# under the License.\\n\\n# Pig default \" +\n            \"configuration file. All values can be overwritten by pig.properties and command line arguments.\\n# \" +\n            \"see bin/pig -help\\n\\n# brief logging (no timestamps)\\nbrief=false\\n\\n# debug level, INFO is default\" +\n            \"\\ndebug=INFO\\n\\n# verbose print all log messages to screen (default to print only INFO and above to \" +\n            \"screen)\\nverbose=false\\n\\n# exectype local|mapreduce, mapreduce is default\\nexectype=mapreduce\\n\\n# \" +\n            \"Enable insertion of information about script into hadoop job conf \\npig.script.info.enabled=true\\n\\n# \" +\n            \"Do not spill temp files smaller than this size (bytes)\\npig.spill.size.threshold=5000000\\n\\n# \" +\n            \"EXPERIMENT: Activate garbage collection when spilling a file bigger than this size (bytes)\\n# \" +\n            \"This should help reduce the number of files being spilled.\\npig.spill.gc.activation.size=40000000\\n\\n# \" +\n            \"the following two parameters are to help estimate the reducer number\\npig.exec.reducers.bytes.per.\" +\n            \"reducer=1000000000\\npig.exec.reducers.max=999\\n\\n# Temporary location to store the intermediate \" +\n            \"data.\\npig.temp.dir=/tmp/\\n\\n# Threshold for merging FRJoin fragment files\\npig.files.concatenation.\" +\n            \"threshold=100\\npig.optimistic.files.concatenation=false;\\n\\npig.disable.counter=false\\n\\n\" +\n            \"hcat.bin=/usr/bin/hcat\"), true, false);\n  }","commit_id":"d99a275f552813593ff378270a8d411f34a25937","url":"https://github.com/apache/ambari"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  @Test\n  public void testExecuteDMLUpdates() throws Exception {\n    Configuration configuration = createNiceMock(Configuration.class);\n    DBAccessor dbAccessor = createNiceMock(DBAccessor.class);\n    Injector injector = createStrictMock(Injector.class);\n    Provider provider = createStrictMock(Provider.class);\n    EntityManager em = createStrictMock(EntityManager.class);\n    EntityTransaction et = createMock(EntityTransaction.class);\n    TypedQuery query = createMock(TypedQuery.class);\n\n    Method m = AbstractUpgradeCatalog.class.getDeclaredMethod\n        (\"updateConfigurationProperties\", String.class, Map.class, boolean.class, boolean.class);\n\n    UpgradeCatalog161 upgradeCatalog = createMockBuilder(UpgradeCatalog161.class)\n      .addMockedMethod(m).createMock();\n\n    expect(configuration.getDatabaseUrl()).andReturn(Configuration.JDBC_IN_MEMORY_URL).anyTimes();\n    expect(injector.getProvider(EntityManager.class)).andReturn(provider).anyTimes();\n    expect(provider.get()).andReturn(em).anyTimes();\n    expect(em.getTransaction()).andReturn(et);\n    expect(et.isActive()).andReturn(true);\n    expect(em.createQuery(\"UPDATE ClusterEntity SET provisioningState = \" +\n      \":provisioningState\", ClusterEntity.class)).andReturn(query);\n    expect(query.setParameter(\"provisioningState\", State.INSTALLED)).andReturn(null);\n    expect(query.executeUpdate()).andReturn(0);\n    \n    upgradeCatalog.updateConfigurationProperties(\"hbase-site\",\n        Collections.singletonMap(\"hbase.regionserver.info.port\", \"60030\"), false, false);\n    expectLastCall();\n\n    upgradeCatalog.updateConfigurationProperties(\"hbase-site\",\n        Collections.singletonMap(\"hbase.master.info.port\", \"60010\"), false, false);\n    expectLastCall();\n    \n    upgradeCatalog.updateConfigurationProperties(\"hive-site\",\n        Collections.singletonMap(\"hive.heapsize\", \"1024\"), false, false);\n    expectLastCall();\n\n    upgradeCatalog.updateConfigurationProperties(\"pig-properties\", Collections.singletonMap(\"pig-content\", \"\\n# Licensed to the Apache \" +\n            \"Software Foundation (ASF) under one\\n# or more contributor license agreements.  See the NOTICE file\\n# \" +\n            \"distributed with this work for additional information\\n# regarding copyright ownership.  The ASF \" +\n            \"licenses this file\\n# to you under the Apache License, Version 2.0 (the\\n# \\\"License\\\"); you may \" +\n            \"not use this file except in compliance\\n# with the License.  You may obtain a copy of the License \" +\n            \"at\\n#\\n#http://www.apache.org/licenses/LICENSE-2.0\\n#\\n# Unless required by applicable law or agreed to \" +\n            \"in writing,\\n# software distributed under the License is distributed on an\\n# \\\"AS IS\\\" BASIS, WITHOUT \" +\n            \"WARRANTIES OR CONDITIONS OF ANY\\n# KIND, either express or implied.  See the License for the\\n# \" +\n            \"specific language governing permissions and limitations\\n# under the License.\\n\\n# Pig default \" +\n            \"configuration file. All values can be overwritten by pig.properties and command line arguments.\\n# \" +\n            \"see bin/pig -help\\n\\n# brief logging (no timestamps)\\nbrief=false\\n\\n# debug level, INFO is default\" +\n            \"\\ndebug=INFO\\n\\n# verbose print all log messages to screen (default to print only INFO and above to \" +\n            \"screen)\\nverbose=false\\n\\n# exectype local|mapreduce, mapreduce is default\\nexectype=mapreduce\\n\\n# \" +\n            \"Enable insertion of information about script into hadoop job conf \\npig.script.info.enabled=true\\n\\n# \" +\n            \"Do not spill temp files smaller than this size (bytes)\\npig.spill.size.threshold=5000000\\n\\n# \" +\n            \"EXPERIMENT: Activate garbage collection when spilling a file bigger than this size (bytes)\\n# \" +\n            \"This should help reduce the number of files being spilled.\\npig.spill.gc.activation.size=40000000\\n\\n# \" +\n            \"the following two parameters are to help estimate the reducer number\\npig.exec.reducers.bytes.per.\" +\n            \"reducer=1000000000\\npig.exec.reducers.max=999\\n\\n# Temporary location to store the intermediate \" +\n            \"data.\\npig.temp.dir=/tmp/\\n\\n# Threshold for merging FRJoin fragment files\\npig.files.concatenation.\" +\n            \"threshold=100\\npig.optimistic.files.concatenation=false;\\n\\npig.disable.counter=false\\n\\n\" +\n            \"hcat.bin=/usr/bin/hcat\"), true, true);\n    expectLastCall();\n\n    replay(upgradeCatalog, dbAccessor, configuration, injector, provider, em,\n      et, query);\n\n    Class<?> c = AbstractUpgradeCatalog.class;\n    Field f = c.getDeclaredField(\"configuration\");\n    f.setAccessible(true);\n    f.set(upgradeCatalog, configuration);\n    f = c.getDeclaredField(\"dbAccessor\");\n    f.setAccessible(true);\n    f.set(upgradeCatalog, dbAccessor);\n    f = c.getDeclaredField(\"injector\");\n    f.setAccessible(true);\n    f.set(upgradeCatalog, injector);\n\n    upgradeCatalog.executeDMLUpdates();\n\n    verify(upgradeCatalog, dbAccessor, configuration, injector, provider, em,\n      et, query);\n  }","id":102315,"modified_method":"@SuppressWarnings(\"unchecked\")\n  @Test\n  public void testExecuteDMLUpdates() throws Exception {\n    Configuration configuration = createNiceMock(Configuration.class);\n    DBAccessor dbAccessor = createNiceMock(DBAccessor.class);\n    Injector injector = createStrictMock(Injector.class);\n    Provider provider = createStrictMock(Provider.class);\n    EntityManager em = createStrictMock(EntityManager.class);\n    EntityTransaction et = createMock(EntityTransaction.class);\n    TypedQuery query = createMock(TypedQuery.class);\n\n    Method m = AbstractUpgradeCatalog.class.getDeclaredMethod\n        (\"updateConfigurationProperties\", String.class, Map.class, boolean.class, boolean.class);\n\n    UpgradeCatalog161 upgradeCatalog = createMockBuilder(UpgradeCatalog161.class)\n      .addMockedMethod(m).createMock();\n\n    expect(configuration.getDatabaseUrl()).andReturn(Configuration.JDBC_IN_MEMORY_URL).anyTimes();\n    expect(injector.getProvider(EntityManager.class)).andReturn(provider).anyTimes();\n    expect(provider.get()).andReturn(em).anyTimes();\n    expect(em.getTransaction()).andReturn(et);\n    expect(et.isActive()).andReturn(true);\n    expect(em.createQuery(\"UPDATE ClusterEntity SET provisioningState = \" +\n      \":provisioningState\", ClusterEntity.class)).andReturn(query);\n    expect(query.setParameter(\"provisioningState\", State.INSTALLED)).andReturn(null);\n    expect(query.executeUpdate()).andReturn(0);\n    \n    upgradeCatalog.updateConfigurationProperties(\"hbase-site\",\n        Collections.singletonMap(\"hbase.regionserver.info.port\", \"60030\"), false, false);\n    expectLastCall();\n\n    upgradeCatalog.updateConfigurationProperties(\"hbase-site\",\n        Collections.singletonMap(\"hbase.master.info.port\", \"60010\"), false, false);\n    expectLastCall();\n    \n    upgradeCatalog.updateConfigurationProperties(\"hive-site\",\n        Collections.singletonMap(\"hive.heapsize\", \"1024\"), false, false);\n    expectLastCall();\n\n    upgradeCatalog.updateConfigurationProperties(\"pig-properties\", Collections.singletonMap(\"pig-content\", \"\\n# Licensed to the Apache \" +\n            \"Software Foundation (ASF) under one\\n# or more contributor license agreements.  See the NOTICE file\\n# \" +\n            \"distributed with this work for additional information\\n# regarding copyright ownership.  The ASF \" +\n            \"licenses this file\\n# to you under the Apache License, Version 2.0 (the\\n# \\\"License\\\"); you may \" +\n            \"not use this file except in compliance\\n# with the License.  You may obtain a copy of the License \" +\n            \"at\\n#\\n#http://www.apache.org/licenses/LICENSE-2.0\\n#\\n# Unless required by applicable law or agreed to \" +\n            \"in writing,\\n# software distributed under the License is distributed on an\\n# \\\"AS IS\\\" BASIS, WITHOUT \" +\n            \"WARRANTIES OR CONDITIONS OF ANY\\n# KIND, either express or implied.  See the License for the\\n# \" +\n            \"specific language governing permissions and limitations\\n# under the License.\\n\\n# Pig default \" +\n            \"configuration file. All values can be overwritten by pig.properties and command line arguments.\\n# \" +\n            \"see bin/pig -help\\n\\n# brief logging (no timestamps)\\nbrief=false\\n\\n# debug level, INFO is default\" +\n            \"\\ndebug=INFO\\n\\n# verbose print all log messages to screen (default to print only INFO and above to \" +\n            \"screen)\\nverbose=false\\n\\n# exectype local|mapreduce, mapreduce is default\\nexectype=mapreduce\\n\\n# \" +\n            \"Enable insertion of information about script into hadoop job conf \\npig.script.info.enabled=true\\n\\n# \" +\n            \"Do not spill temp files smaller than this size (bytes)\\npig.spill.size.threshold=5000000\\n\\n# \" +\n            \"EXPERIMENT: Activate garbage collection when spilling a file bigger than this size (bytes)\\n# \" +\n            \"This should help reduce the number of files being spilled.\\npig.spill.gc.activation.size=40000000\\n\\n# \" +\n            \"the following two parameters are to help estimate the reducer number\\npig.exec.reducers.bytes.per.\" +\n            \"reducer=1000000000\\npig.exec.reducers.max=999\\n\\n# Temporary location to store the intermediate \" +\n            \"data.\\npig.temp.dir=/tmp/\\n\\n# Threshold for merging FRJoin fragment files\\npig.files.concatenation.\" +\n            \"threshold=100\\npig.optimistic.files.concatenation=false;\\n\\npig.disable.counter=false\\n\\n\" +\n            \"hcat.bin=/usr/bin/hcat\"), true, false);\n    expectLastCall();\n\n    replay(upgradeCatalog, dbAccessor, configuration, injector, provider, em,\n      et, query);\n\n    Class<?> c = AbstractUpgradeCatalog.class;\n    Field f = c.getDeclaredField(\"configuration\");\n    f.setAccessible(true);\n    f.set(upgradeCatalog, configuration);\n    f = c.getDeclaredField(\"dbAccessor\");\n    f.setAccessible(true);\n    f.set(upgradeCatalog, dbAccessor);\n    f = c.getDeclaredField(\"injector\");\n    f.setAccessible(true);\n    f.set(upgradeCatalog, injector);\n\n    upgradeCatalog.executeDMLUpdates();\n\n    verify(upgradeCatalog, dbAccessor, configuration, injector, provider, em,\n      et, query);\n  }","commit_id":"d99a275f552813593ff378270a8d411f34a25937","url":"https://github.com/apache/ambari"},{"original_method":"protected void addMissingConfigs() throws AmbariException {\n    updateConfigurationProperties(\"hbase-env\",\n        Collections.singletonMap(\"hbase_regionserver_xmn_max\", \"512\"), false,\n        false);\n\n    updateConfigurationProperties(\"hbase-env\",\n        Collections.singletonMap(\"hbase_regionserver_xmn_ratio\", \"0.2\"), false,\n        false);\n\n    updateConfigurationProperties(\"yarn-env\",\n        Collections.singletonMap(\"min_user_id\", \"1000\"), false,\n        false);\n\n    updateConfigurationProperties(\"sqoop-env\", Collections.singletonMap(\"sqoop_user\", \"sqoop\"), false, false);\n\n    updateConfigurationProperties(\"hadoop-env\",\n            Collections.singletonMap(\"hadoop_root_logger\", \"INFO,RFA\"), false,\n            false);\n\n    updateConfigurationProperties(\"oozie-env\", Collections.singletonMap(\"oozie_admin_port\", \"11001\"), false, false);\n  }","id":102316,"modified_method":"protected void addMissingConfigs() throws AmbariException {\n    addNewConfigurationsFromXml();\n  }","commit_id":"d99a275f552813593ff378270a8d411f34a25937","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  protected void executeDMLUpdates() throws AmbariException, SQLException {\n\n    executeInTransaction(new Runnable() {\n      @Override\n      public void run() {\n        try {\n          moveHcatalogIntoHiveService();\n          moveWebHcatIntoHiveService();\n        } catch (Exception e) {\n          LOG.warn(\"Integrating HCatalog and WebHCat services into Hive threw \" +\n              \"exception. \", e);\n        }\n      }\n    });\n\n    // Update historic records with the log paths, but only enough so as to not prolong the upgrade process\n    executeInTransaction(new Runnable() {\n      @Override\n      public void run() {\n        try {\n          HostRoleCommandDAO hostRoleCommandDAO = injector.getInstance(HostRoleCommandDAO.class);\n          EntityManager em = getEntityManagerProvider().get();\n          CriteriaBuilder cb = em.getCriteriaBuilder();\n          CriteriaQuery<HostRoleCommandEntity> cq1 = cb.createQuery(HostRoleCommandEntity.class);\n          CriteriaQuery<HostRoleCommandEntity> cq2 = cb.createQuery(HostRoleCommandEntity.class);\n          Root<HostRoleCommandEntity> hrc1 = cq1.from(HostRoleCommandEntity.class);\n          Root<HostRoleCommandEntity> hrc2 = cq1.from(HostRoleCommandEntity.class);\n\n          // Rather than using Java reflection, which is more susceptible to breaking, use the classname_.field canonical model\n          // that is safer because it exposes the persistent attributes statically.\n          Expression<Long> taskID1 = hrc1.get(HostRoleCommandEntity_.taskId);\n          Expression<Long> taskID2 = hrc2.get(HostRoleCommandEntity_.taskId);\n          Expression<String> outputLog = hrc1.get(HostRoleCommandEntity_.outputLog);\n          Expression<String> errorLog = hrc2.get(HostRoleCommandEntity_.errorLog);\n\n          Predicate p1 = cb.isNull(outputLog);\n          Predicate p2 = cb.equal(outputLog, \"\");\n          Predicate p1_or_2 = cb.or(p1, p2);\n\n          Predicate p3 = cb.isNull(errorLog);\n          Predicate p4 = cb.equal(errorLog, \"\");\n          Predicate p3_or_4 = cb.or(p3, p4);\n\n          if (daoUtils == null) {\n            daoUtils = new DaoUtils();\n          }\n\n          // Update output_log\n          cq1.select(hrc1).where(p1_or_2).orderBy(cb.desc(taskID1));\n          TypedQuery<HostRoleCommandEntity> q1 = em.createQuery(cq1);\n          q1.setMaxResults(1000);\n          List<HostRoleCommandEntity> r1 = daoUtils.selectList(q1);\n          for (HostRoleCommandEntity entity : r1) {\n            entity.setOutputLog(\"/var/lib/ambari-agent/data/output-\" + entity.getTaskId() + \".txt\");\n            hostRoleCommandDAO.merge(entity);\n          }\n\n          // Update error_log\n          cq2.select(hrc2).where(p3_or_4).orderBy(cb.desc(taskID2));\n          TypedQuery<HostRoleCommandEntity> q2 = em.createQuery(cq2);\n          q2.setMaxResults(1000);\n          List<HostRoleCommandEntity> r2 = daoUtils.selectList(q2);\n          for (HostRoleCommandEntity entity : r2) {\n            entity.setErrorLog(\"/var/lib/ambari-agent/data/errors-\" + entity.getTaskId() + \".txt\");\n            hostRoleCommandDAO.merge(entity);\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Could not populate historic records with output_log and error_log in host_role_command table. \", e);\n        }\n      }\n    });\n\n    moveGlobalsToEnv();\n    addEnvContentFields();\n    addMissingConfigs();\n    renamePigProperties();\n    upgradePermissionModel();\n    addJobsViewPermissions();\n    moveConfigGroupsGlobalToEnv();\n  }","id":102317,"modified_method":"@Override\n  protected void executeDMLUpdates() throws AmbariException, SQLException {\n\n    executeInTransaction(new Runnable() {\n      @Override\n      public void run() {\n        try {\n          moveHcatalogIntoHiveService();\n          moveWebHcatIntoHiveService();\n        } catch (Exception e) {\n          LOG.warn(\"Integrating HCatalog and WebHCat services into Hive threw \" +\n              \"exception. \", e);\n        }\n      }\n    });\n\n    // Update historic records with the log paths, but only enough so as to not prolong the upgrade process\n    executeInTransaction(new Runnable() {\n      @Override\n      public void run() {\n        try {\n          HostRoleCommandDAO hostRoleCommandDAO = injector.getInstance(HostRoleCommandDAO.class);\n          EntityManager em = getEntityManagerProvider().get();\n          CriteriaBuilder cb = em.getCriteriaBuilder();\n          CriteriaQuery<HostRoleCommandEntity> cq1 = cb.createQuery(HostRoleCommandEntity.class);\n          CriteriaQuery<HostRoleCommandEntity> cq2 = cb.createQuery(HostRoleCommandEntity.class);\n          Root<HostRoleCommandEntity> hrc1 = cq1.from(HostRoleCommandEntity.class);\n          Root<HostRoleCommandEntity> hrc2 = cq1.from(HostRoleCommandEntity.class);\n\n          // Rather than using Java reflection, which is more susceptible to breaking, use the classname_.field canonical model\n          // that is safer because it exposes the persistent attributes statically.\n          Expression<Long> taskID1 = hrc1.get(HostRoleCommandEntity_.taskId);\n          Expression<Long> taskID2 = hrc2.get(HostRoleCommandEntity_.taskId);\n          Expression<String> outputLog = hrc1.get(HostRoleCommandEntity_.outputLog);\n          Expression<String> errorLog = hrc2.get(HostRoleCommandEntity_.errorLog);\n\n          Predicate p1 = cb.isNull(outputLog);\n          Predicate p2 = cb.equal(outputLog, \"\");\n          Predicate p1_or_2 = cb.or(p1, p2);\n\n          Predicate p3 = cb.isNull(errorLog);\n          Predicate p4 = cb.equal(errorLog, \"\");\n          Predicate p3_or_4 = cb.or(p3, p4);\n\n          if (daoUtils == null) {\n            daoUtils = new DaoUtils();\n          }\n\n          // Update output_log\n          cq1.select(hrc1).where(p1_or_2).orderBy(cb.desc(taskID1));\n          TypedQuery<HostRoleCommandEntity> q1 = em.createQuery(cq1);\n          q1.setMaxResults(1000);\n          List<HostRoleCommandEntity> r1 = daoUtils.selectList(q1);\n          for (HostRoleCommandEntity entity : r1) {\n            entity.setOutputLog(\"/var/lib/ambari-agent/data/output-\" + entity.getTaskId() + \".txt\");\n            hostRoleCommandDAO.merge(entity);\n          }\n\n          // Update error_log\n          cq2.select(hrc2).where(p3_or_4).orderBy(cb.desc(taskID2));\n          TypedQuery<HostRoleCommandEntity> q2 = em.createQuery(cq2);\n          q2.setMaxResults(1000);\n          List<HostRoleCommandEntity> r2 = daoUtils.selectList(q2);\n          for (HostRoleCommandEntity entity : r2) {\n            entity.setErrorLog(\"/var/lib/ambari-agent/data/errors-\" + entity.getTaskId() + \".txt\");\n            hostRoleCommandDAO.merge(entity);\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Could not populate historic records with output_log and error_log in host_role_command table. \", e);\n        }\n      }\n    });\n\n    moveGlobalsToEnv();\n    addEnvContentFields();\n    renamePigProperties();\n    upgradePermissionModel();\n    addJobsViewPermissions();\n    moveConfigGroupsGlobalToEnv();\n    addMissingConfigs();\n  }","commit_id":"d99a275f552813593ff378270a8d411f34a25937","url":"https://github.com/apache/ambari"},{"original_method":"protected void addEnvContentFields() throws AmbariException {\n    ConfigHelper configHelper = injector.getInstance(ConfigHelper.class);\n    AmbariManagementController ambariManagementController = injector.getInstance(\n        AmbariManagementController.class);\n\n    Clusters clusters = ambariManagementController.getClusters();\n    if (clusters == null) {\n      return;\n    }\n\n    Map<String, Cluster> clusterMap = clusters.getClusters();\n\n    if (clusterMap != null && !clusterMap.isEmpty()) {\n      for (final Cluster cluster : clusterMap.values()) {\n        Set<String> configTypes = configHelper.findConfigTypesByPropertyName(cluster.getCurrentStackVersion(),\n            CONTENT_FIELD_NAME, cluster.getClusterName());\n\n        for(String configType:configTypes) {\n          if(!configType.endsWith(ENV_CONFIGS_POSTFIX)) {\n            continue;\n          }\n\n          String value = configHelper.getPropertyValueFromStackDefenitions(cluster, configType, CONTENT_FIELD_NAME);\n          updateConfigurationProperties(configType, Collections.singletonMap(CONTENT_FIELD_NAME, value), true, true);\n        }\n      }\n    }\n  }","id":102318,"modified_method":"protected void addEnvContentFields() throws AmbariException {\n    ConfigHelper configHelper = injector.getInstance(ConfigHelper.class);\n    AmbariManagementController ambariManagementController = injector.getInstance(\n        AmbariManagementController.class);\n\n    Clusters clusters = ambariManagementController.getClusters();\n    if (clusters == null) {\n      return;\n    }\n\n    Map<String, Cluster> clusterMap = clusters.getClusters();\n\n    if (clusterMap != null && !clusterMap.isEmpty()) {\n      for (final Cluster cluster : clusterMap.values()) {\n        Set<String> configTypes = configHelper.findConfigTypesByPropertyName(cluster.getCurrentStackVersion(),\n            CONTENT_FIELD_NAME, cluster.getClusterName());\n\n        for(String configType:configTypes) {\n          if(!configType.endsWith(ENV_CONFIGS_POSTFIX)) {\n            continue;\n          }\n\n          updateConfigurationPropertiesWithValuesFromXml(configType, Collections.singleton(CONTENT_FIELD_NAME), false, true);\n        }\n      }\n    }\n  }","commit_id":"d99a275f552813593ff378270a8d411f34a25937","url":"https://github.com/apache/ambari"},{"original_method":"protected void moveGlobalsToEnv() throws AmbariException {\n    ConfigHelper configHelper = injector.getInstance(ConfigHelper.class);\n\n    AmbariManagementController ambariManagementController = injector.getInstance(\n        AmbariManagementController.class);\n    Clusters clusters = ambariManagementController.getClusters();\n    if (clusters == null) {\n      return;\n    }\n    Map<String, Cluster> clusterMap = clusters.getClusters();\n\n    if (clusterMap != null && !clusterMap.isEmpty()) {\n      for (final Cluster cluster : clusterMap.values()) {\n        Config config = cluster.getDesiredConfigByType(Configuration.GLOBAL_CONFIG_TAG);\n        if (config == null) {\n          LOG.info(\"Config \" + Configuration.GLOBAL_CONFIG_TAG + \" not found. Assuming upgrade already done.\");\n          return;\n        }\n\n        Map<String, Map<String, String>> newProperties = new HashMap<String, Map<String, String>>();\n        Map<String, String> globalProperites = config.getProperties();\n        Map<String, String> unmappedGlobalProperties = new HashMap<String, String>();\n\n        for (Map.Entry<String, String> property : globalProperites.entrySet()) {\n          String propertyName = property.getKey();\n          String propertyValue = property.getValue();\n\n          Set<String> newConfigTypes = configHelper.findConfigTypesByPropertyName(cluster.getCurrentStackVersion(),\n                  propertyName, cluster.getClusterName());\n          // if it's custom user service global.xml can be still there.\n          newConfigTypes.remove(Configuration.GLOBAL_CONFIG_TAG);\n\n          String newConfigType = null;\n          if(newConfigTypes.size() > 0) {\n            newConfigType = newConfigTypes.iterator().next();\n          } else {\n            newConfigType = getAdditionalMappingGlobalToEnv().get(propertyName);\n          }\n\n          if(newConfigType==null) {\n            LOG.warn(\"Cannot find where to map \" + propertyName + \" from \" + Configuration.GLOBAL_CONFIG_TAG +\n                \" (value=\"+propertyValue+\")\");\n            unmappedGlobalProperties.put(propertyName, propertyValue);\n            continue;\n          }\n\n          LOG.info(\"Mapping config \" + propertyName + \" from \" + Configuration.GLOBAL_CONFIG_TAG +\n              \" to \" + newConfigType +\n              \" (value=\"+propertyValue+\")\");\n\n          if(!newProperties.containsKey(newConfigType)) {\n            newProperties.put(newConfigType, new HashMap<String, String>());\n          }\n          newProperties.get(newConfigType).put(propertyName, propertyValue);\n        }\n\n        for (Entry<String, Map<String, String>> newProperty : newProperties.entrySet()) {\n          updateConfigurationProperties(newProperty.getKey(), newProperty.getValue(), true, true);\n        }\n\n        // if have some custom properties, for own services etc., leave that as it was\n        if(unmappedGlobalProperties.size() != 0) {\n          LOG.info(\"Not deleting globals because have custom properties\");\n          configHelper.createConfigType(cluster, ambariManagementController, Configuration.GLOBAL_CONFIG_TAG, unmappedGlobalProperties, \"ambari-upgrade\");\n        } else {\n          configHelper.removeConfigsByType(cluster, Configuration.GLOBAL_CONFIG_TAG);\n        }\n      }\n    }\n  }","id":102319,"modified_method":"protected void moveGlobalsToEnv() throws AmbariException {\n    ConfigHelper configHelper = injector.getInstance(ConfigHelper.class);\n\n    AmbariManagementController ambariManagementController = injector.getInstance(\n        AmbariManagementController.class);\n    Clusters clusters = ambariManagementController.getClusters();\n    if (clusters == null) {\n      return;\n    }\n    Map<String, Cluster> clusterMap = clusters.getClusters();\n\n    if (clusterMap != null && !clusterMap.isEmpty()) {\n      for (final Cluster cluster : clusterMap.values()) {\n        Config config = cluster.getDesiredConfigByType(Configuration.GLOBAL_CONFIG_TAG);\n        if (config == null) {\n          LOG.info(\"Config \" + Configuration.GLOBAL_CONFIG_TAG + \" not found. Assuming upgrade already done.\");\n          return;\n        }\n\n        Map<String, Map<String, String>> newProperties = new HashMap<String, Map<String, String>>();\n        Map<String, String> globalProperites = config.getProperties();\n        Map<String, String> unmappedGlobalProperties = new HashMap<String, String>();\n\n        for (Map.Entry<String, String> property : globalProperites.entrySet()) {\n          String propertyName = property.getKey();\n          String propertyValue = property.getValue();\n\n          Set<String> newConfigTypes = configHelper.findConfigTypesByPropertyName(cluster.getCurrentStackVersion(),\n                  propertyName, cluster.getClusterName());\n          // if it's custom user service global.xml can be still there.\n          newConfigTypes.remove(Configuration.GLOBAL_CONFIG_TAG);\n\n          String newConfigType = null;\n          if(newConfigTypes.size() > 0) {\n            newConfigType = newConfigTypes.iterator().next();\n          } else {\n            newConfigType = getAdditionalMappingGlobalToEnv().get(propertyName);\n          }\n\n          if(newConfigType==null) {\n            LOG.warn(\"Cannot find where to map \" + propertyName + \" from \" + Configuration.GLOBAL_CONFIG_TAG +\n                \" (value=\"+propertyValue+\")\");\n            unmappedGlobalProperties.put(propertyName, propertyValue);\n            continue;\n          }\n\n          LOG.info(\"Mapping config \" + propertyName + \" from \" + Configuration.GLOBAL_CONFIG_TAG +\n              \" to \" + newConfigType +\n              \" (value=\"+propertyValue+\")\");\n\n          if(!newProperties.containsKey(newConfigType)) {\n            newProperties.put(newConfigType, new HashMap<String, String>());\n          }\n          newProperties.get(newConfigType).put(propertyName, propertyValue);\n        }\n\n        for (Entry<String, Map<String, String>> newProperty : newProperties.entrySet()) {\n          updateConfigurationProperties(newProperty.getKey(), newProperty.getValue(), false, true);\n        }\n\n        // if have some custom properties, for own services etc., leave that as it was\n        if(unmappedGlobalProperties.size() != 0) {\n          LOG.info(\"Not deleting globals because have custom properties\");\n          configHelper.createConfigType(cluster, ambariManagementController, Configuration.GLOBAL_CONFIG_TAG, unmappedGlobalProperties, \"ambari-upgrade\");\n        } else {\n          configHelper.removeConfigsByType(cluster, Configuration.GLOBAL_CONFIG_TAG);\n        }\n      }\n    }\n  }","commit_id":"d99a275f552813593ff378270a8d411f34a25937","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExecuteDMLUpdates() throws Exception {\n    Configuration configuration = createNiceMock(Configuration.class);\n    DBAccessor dbAccessor = createNiceMock(DBAccessor.class);\n    Injector injector = createNiceMock(Injector.class);\n    ConfigHelper configHelper = createNiceMock(ConfigHelper.class);\n    AmbariManagementController amc = createNiceMock(AmbariManagementController.class);\n    Cluster cluster = createNiceMock(Cluster.class);\n    Clusters clusters = createStrictMock(Clusters.class);\n    Config config = createStrictMock(Config.class);\n    Config pigConfig = createStrictMock(Config.class);\n\n    ClusterConfigEntity clusterConfigEntity = createNiceMock(ClusterConfigEntity.class);\n    ConfigGroupConfigMappingDAO configGroupConfigMappingDAO = createNiceMock(ConfigGroupConfigMappingDAO.class);\n    UserDAO userDAO = createNiceMock(UserDAO.class);\n    PrincipalDAO principalDAO = createNiceMock(PrincipalDAO.class);\n    PrincipalTypeDAO principalTypeDAO = createNiceMock(PrincipalTypeDAO.class);\n    ClusterDAO clusterDAO = createNiceMock(ClusterDAO.class);\n    ResourceTypeDAO resourceTypeDAO = createNiceMock(ResourceTypeDAO.class);\n    ResourceDAO resourceDAO = createNiceMock(ResourceDAO.class);\n    ViewDAO viewDAO = createNiceMock(ViewDAO.class);\n    ViewInstanceDAO viewInstanceDAO = createNiceMock(ViewInstanceDAO.class);\n    PermissionDAO permissionDAO = createNiceMock(PermissionDAO.class);\n    PrivilegeDAO privilegeDAO = createNiceMock(PrivilegeDAO.class);\n    KeyValueDAO keyValueDAO = createNiceMock(KeyValueDAO.class);\n\n    EntityTransaction trans = createNiceMock(EntityTransaction.class);\n    CriteriaBuilder cb = createNiceMock(CriteriaBuilder.class);\n    CriteriaQuery<HostRoleCommandEntity> cq = createNiceMock(CriteriaQuery.class);\n    Root<HostRoleCommandEntity> hrc = createNiceMock(Root.class);\n    Path<Long> taskId = null;\n    Path<String> outputLog = null;\n    Path<String> errorLog = null;\n    Order o = createNiceMock(Order.class);\n    TypedQuery<HostRoleCommandEntity> q = createNiceMock(TypedQuery.class);\n    List<HostRoleCommandEntity> r = new ArrayList<HostRoleCommandEntity>();\n    ResultSet userRolesResultSet = createNiceMock(ResultSet.class);\n\n    Method m = AbstractUpgradeCatalog.class.getDeclaredMethod\n        (\"updateConfigurationProperties\", String.class, Map.class, boolean.class, boolean.class);\n    Method n = AbstractUpgradeCatalog.class.getDeclaredMethod(\"getEntityManagerProvider\");\n\n    UpgradeCatalog170 upgradeCatalog = createMockBuilder(UpgradeCatalog170.class)\n      .addMockedMethod(m).addMockedMethod(n).createMock();\n\n    List<ConfigGroupConfigMappingEntity> configGroupConfigMappingEntities =\n            new ArrayList<ConfigGroupConfigMappingEntity>();\n    ConfigGroupConfigMappingEntity configGroupConfigMappingEntity = new ConfigGroupConfigMappingEntity();\n    configGroupConfigMappingEntity.setConfigType(Configuration.GLOBAL_CONFIG_TAG);\n    configGroupConfigMappingEntity.setClusterConfigEntity(clusterConfigEntity);\n    configGroupConfigMappingEntity.setClusterId(1L);\n    configGroupConfigMappingEntities.add(configGroupConfigMappingEntity);\n\n    Map<String, Cluster> clustersMap = new HashMap<String, Cluster>();\n    clustersMap.put(\"c1\", cluster);\n\n    Map<String, String> globalConfigs = new HashMap<String, String>();\n    globalConfigs.put(\"prop1\", \"val1\");\n    globalConfigs.put(\"smokeuser_keytab\", \"val2\");\n\n    Map<String, String> pigSettings = new HashMap<String, String>();\n    pigSettings.put(\"pig-content\", \"foo\");\n\n    Set<String> envDicts = new HashSet<String>();\n    envDicts.add(\"hadoop-env\");\n    envDicts.add(\"global\");\n\n    Set<String> configTypes = new HashSet<String>();\n    configTypes.add(\"hadoop-env\");\n\n    Map<String, String> contentOfHadoopEnv = new HashMap<String, String>();\n    contentOfHadoopEnv.put(\"content\", \"env file contents\");\n\n    upgradeCatalog.updateConfigurationProperties(\"hadoop-env\",\n        globalConfigs, true, true);\n    expectLastCall();\n\n    upgradeCatalog.updateConfigurationProperties(\"hadoop-env\",\n        contentOfHadoopEnv, true, true);\n    expectLastCall();\n\n    upgradeCatalog.updateConfigurationProperties(\"hbase-env\",\n        Collections.singletonMap(\"hbase_regionserver_xmn_max\", \"512\"), false, false);\n    expectLastCall();\n\n    upgradeCatalog.updateConfigurationProperties(\"hbase-env\",\n        Collections.singletonMap(\"hbase_regionserver_xmn_ratio\", \"0.2\"), false, false);\n    expectLastCall();\n\n    upgradeCatalog.updateConfigurationProperties(\"yarn-env\",\n        Collections.singletonMap(\"min_user_id\", \"1000\"), false, false);\n    expectLastCall();\n\n    upgradeCatalog.updateConfigurationProperties(\"sqoop-env\", Collections.singletonMap(\"sqoop_user\", \"sqoop\"), false, false);\n    expectLastCall();\n\n    upgradeCatalog.updateConfigurationProperties(\"hadoop-env\",\n            Collections.singletonMap(\"hadoop_root_logger\", \"INFO,RFA\"), false, false);\n    expectLastCall();\n\n    upgradeCatalog.updateConfigurationProperties(\"oozie-env\",\n            Collections.singletonMap(\"oozie_admin_port\", \"11001\"), false, false);\n    expectLastCall();\n\n    expect(dbAccessor.executeSelect(\"SELECT role_name, user_id FROM user_roles\")).andReturn(userRolesResultSet).once();\n    expect(entityManager.getTransaction()).andReturn(trans).anyTimes();\n    expect(entityManager.getCriteriaBuilder()).andReturn(cb).anyTimes();\n    expect(entityManager.createQuery(cq)).andReturn(q).anyTimes();\n    expect(userRolesResultSet.next()).andReturn(false).once();\n    expect(trans.isActive()).andReturn(true).anyTimes();\n    expect(upgradeCatalog.getEntityManagerProvider()).andReturn(entityManagerProvider).anyTimes();\n    expect(cb.createQuery(HostRoleCommandEntity.class)).andReturn(cq).anyTimes();\n    expect(cb.desc(taskId)).andReturn(o).anyTimes();\n    expect(cq.from(HostRoleCommandEntity.class)).andReturn(hrc).anyTimes();\n    expect(cq.select(hrc)).andReturn(cq).anyTimes();\n    expect(cq.where(anyObject(Predicate.class))).andReturn(cq).anyTimes();\n    expect(hrc.get(isA(SingularAttribute.class))).andReturn(taskId).times(2);\n    expect(hrc.get(isA(SingularAttribute.class))).andReturn(outputLog).once();\n    expect(hrc.get(isA(SingularAttribute.class))).andReturn(errorLog).once();\n    expect(q.setMaxResults(1000)).andReturn(q).anyTimes();\n    expect(q.getResultList()).andReturn(r).anyTimes();\n    expect(clusterConfigEntity.getData()).andReturn(\"{\\\"dtnode_heapsize\\\":\\\"1028m\\\"}\");\n\n    expect(configuration.getDatabaseUrl()).andReturn(Configuration.JDBC_IN_MEMORY_URL).anyTimes();\n    expect(injector.getInstance(ConfigHelper.class)).andReturn(configHelper).anyTimes();\n    expect(injector.getInstance(AmbariManagementController.class)).andReturn(amc).anyTimes();\n    expect(amc.getClusters()).andReturn(clusters).anyTimes();\n    expect(clusters.getClusters()).andReturn(clustersMap).anyTimes();\n    expect(clusters.getClusterById(1L)).andReturn(clustersMap.values().iterator().next()).anyTimes();\n    expect(cluster.getDesiredConfigByType(\"global\")).andReturn(config).anyTimes();\n    expect(cluster.getClusterId()).andReturn(1L);\n    expect(cluster.getNextConfigVersion(\"hadoop-env\")).andReturn(3L);\n    expect(config.getProperties()).andReturn(globalConfigs).anyTimes();\n    expect(cluster.getCurrentStackVersion()).andReturn(new StackId(\"HDP\", \"2.1\")).anyTimes();\n    expect(cluster.getClusterName()).andReturn(\"c1\").anyTimes();\n    expect(configHelper.findConfigTypesByPropertyName(new StackId(\"HDP\", \"2.1\"), \"prop1\", \"c1\")).andReturn(envDicts).once();\n    expect(configHelper.findConfigTypesByPropertyName(new StackId(\"HDP\", \"2.1\"), \"smokeuser_keytab\", \"c1\")).andReturn(new HashSet<String>()).once();\n    expect(configHelper.findConfigTypesByPropertyName(new StackId(\"HDP\", \"2.1\"), \"content\", \"c1\")).andReturn(envDicts).once();\n    expect(configHelper.findConfigTypesByPropertyName(new StackId(\"HDP\", \"2.1\"), \"dtnode_heapsize\", \"c1\")).andReturn(configTypes).once();\n    expect(configHelper.getPropertyValueFromStackDefenitions(cluster, \"hadoop-env\", \"content\")).andReturn(\"env file contents\").once();\n\n    expect(injector.getInstance(ConfigGroupConfigMappingDAO.class)).andReturn(configGroupConfigMappingDAO).anyTimes();\n    expect(injector.getInstance(UserDAO.class)).andReturn(userDAO).anyTimes();\n    expect(injector.getInstance(PrincipalDAO.class)).andReturn(principalDAO).anyTimes();\n    expect(injector.getInstance(PrincipalTypeDAO.class)).andReturn(principalTypeDAO).anyTimes();\n    expect(injector.getInstance(ClusterDAO.class)).andReturn(clusterDAO).anyTimes();\n    expect(injector.getInstance(ResourceTypeDAO.class)).andReturn(resourceTypeDAO).anyTimes();\n    expect(injector.getInstance(ResourceDAO.class)).andReturn(resourceDAO).anyTimes();\n    expect(injector.getInstance(ViewDAO.class)).andReturn(viewDAO).anyTimes();\n    expect(injector.getInstance(ViewInstanceDAO.class)).andReturn(viewInstanceDAO).anyTimes();\n    expect(injector.getInstance(PermissionDAO.class)).andReturn(permissionDAO).anyTimes();\n    expect(injector.getInstance(PrivilegeDAO.class)).andReturn(privilegeDAO).anyTimes();\n    expect(injector.getInstance(KeyValueDAO.class)).andReturn(keyValueDAO).anyTimes();\n\n    expect(configGroupConfigMappingDAO.findAll()).andReturn(configGroupConfigMappingEntities).once();\n    expect(userDAO.findAll()).andReturn(Collections.<UserEntity> emptyList()).times(2);\n    expect(clusterDAO.findAll()).andReturn(Collections.<ClusterEntity> emptyList()).anyTimes();\n    expect(viewDAO.findAll()).andReturn(Collections.<ViewEntity> emptyList()).anyTimes();\n    expect(viewInstanceDAO.findAll()).andReturn(Collections.<ViewInstanceEntity> emptyList()).anyTimes();\n    expect(permissionDAO.findAmbariAdminPermission()).andReturn(null);\n    expect(permissionDAO.findClusterOperatePermission()).andReturn(null);\n    expect(permissionDAO.findClusterReadPermission()).andReturn(null);\n\n    expect(cluster.getDesiredConfigByType(\"pig-properties\")).andReturn(pigConfig).anyTimes();\n    expect(pigConfig.getProperties()).andReturn(pigSettings).anyTimes();\n\n    ViewEntity jobsView = createNiceMock(ViewEntity.class);\n    KeyValueEntity showJobsKeyValue = createNiceMock(KeyValueEntity.class);\n    UserEntity user = createNiceMock(UserEntity.class);\n\n    expect(userDAO.findAll()).andReturn(Collections.singletonList(user));\n    expect(jobsView.getCommonName()).andReturn(UpgradeCatalog170.JOBS_VIEW_NAME);\n    expect(jobsView.getVersion()).andReturn(\"1.0.0\");\n    expect(viewDAO.findByCommonName(UpgradeCatalog170.JOBS_VIEW_NAME)).andReturn(jobsView).once();\n    expect(showJobsKeyValue.getValue()).andReturn(\"true\");\n    expect(keyValueDAO.findByKey(UpgradeCatalog170.SHOW_JOBS_FOR_NON_ADMIN_KEY)).andReturn(showJobsKeyValue);\n    expect(privilegeDAO.findAllByPrincipal(anyObject(List.class))).andReturn(Collections.<PrivilegeEntity>emptyList());\n    expect(viewDAO.merge(jobsView)).andReturn(jobsView);\n\n    resourceDAO.create(anyObject(ResourceEntity.class));\n    viewInstanceDAO.create(anyObject(ViewInstanceEntity.class));\n    keyValueDAO.remove(showJobsKeyValue);\n    privilegeDAO.create(anyObject(PrivilegeEntity.class));\n\n    replay(entityManager, trans, upgradeCatalog, cb, cq, hrc, q, userRolesResultSet);\n\n    replay(dbAccessor, configuration, injector, cluster, clusters, amc, config, configHelper, pigConfig);\n    replay(userDAO, clusterDAO, viewDAO, viewInstanceDAO, permissionDAO, configGroupConfigMappingDAO);\n    replay(resourceTypeDAO, resourceDAO, keyValueDAO, privilegeDAO, clusterConfigEntity);\n    replay(jobsView, showJobsKeyValue, user);\n\n    Class<?> c = AbstractUpgradeCatalog.class;\n    Field f = c.getDeclaredField(\"configuration\");\n    f.setAccessible(true);\n    f.set(upgradeCatalog, configuration);\n    f = c.getDeclaredField(\"dbAccessor\");\n    f.setAccessible(true);\n    f.set(upgradeCatalog, dbAccessor);\n    f = c.getDeclaredField(\"injector\");\n    f.setAccessible(true);\n    f.set(upgradeCatalog, injector);\n\n    upgradeCatalog.executeDMLUpdates();\n\n    verify(upgradeCatalog, dbAccessor, configuration, injector, cluster, clusters, amc, config, configHelper,\n        jobsView, showJobsKeyValue, privilegeDAO, viewDAO, viewInstanceDAO, resourceDAO, keyValueDAO, userRolesResultSet);\n  }","id":102320,"modified_method":"@Test\n  public void testExecuteDMLUpdates() throws Exception {\n    Configuration configuration = createNiceMock(Configuration.class);\n    DBAccessor dbAccessor = createNiceMock(DBAccessor.class);\n    Injector injector = createNiceMock(Injector.class);\n    ConfigHelper configHelper = createNiceMock(ConfigHelper.class);\n    AmbariManagementController amc = createNiceMock(AmbariManagementController.class);\n    Cluster cluster = createNiceMock(Cluster.class);\n    Clusters clusters = createStrictMock(Clusters.class);\n    Config config = createStrictMock(Config.class);\n    Config pigConfig = createStrictMock(Config.class);\n\n    ClusterConfigEntity clusterConfigEntity = createNiceMock(ClusterConfigEntity.class);\n    ConfigGroupConfigMappingDAO configGroupConfigMappingDAO = createNiceMock(ConfigGroupConfigMappingDAO.class);\n    UserDAO userDAO = createNiceMock(UserDAO.class);\n    PrincipalDAO principalDAO = createNiceMock(PrincipalDAO.class);\n    PrincipalTypeDAO principalTypeDAO = createNiceMock(PrincipalTypeDAO.class);\n    ClusterDAO clusterDAO = createNiceMock(ClusterDAO.class);\n    ResourceTypeDAO resourceTypeDAO = createNiceMock(ResourceTypeDAO.class);\n    ResourceDAO resourceDAO = createNiceMock(ResourceDAO.class);\n    ViewDAO viewDAO = createNiceMock(ViewDAO.class);\n    ViewInstanceDAO viewInstanceDAO = createNiceMock(ViewInstanceDAO.class);\n    PermissionDAO permissionDAO = createNiceMock(PermissionDAO.class);\n    PrivilegeDAO privilegeDAO = createNiceMock(PrivilegeDAO.class);\n    KeyValueDAO keyValueDAO = createNiceMock(KeyValueDAO.class);\n\n    EntityTransaction trans = createNiceMock(EntityTransaction.class);\n    CriteriaBuilder cb = createNiceMock(CriteriaBuilder.class);\n    CriteriaQuery<HostRoleCommandEntity> cq = createNiceMock(CriteriaQuery.class);\n    Root<HostRoleCommandEntity> hrc = createNiceMock(Root.class);\n    Path<Long> taskId = null;\n    Path<String> outputLog = null;\n    Path<String> errorLog = null;\n    Order o = createNiceMock(Order.class);\n    TypedQuery<HostRoleCommandEntity> q = createNiceMock(TypedQuery.class);\n    List<HostRoleCommandEntity> r = new ArrayList<HostRoleCommandEntity>();\n    ResultSet userRolesResultSet = createNiceMock(ResultSet.class);\n\n    Method m = AbstractUpgradeCatalog.class.getDeclaredMethod\n        (\"updateConfigurationProperties\", String.class, Map.class, boolean.class, boolean.class);\n    Method n = AbstractUpgradeCatalog.class.getDeclaredMethod(\"getEntityManagerProvider\");\n    Method l = AbstractUpgradeCatalog.class.getDeclaredMethod\n        (\"addNewConfigurationsFromXml\");\n    \n    UpgradeCatalog170 upgradeCatalog = createMockBuilder(UpgradeCatalog170.class)\n      .addMockedMethod(m).addMockedMethod(n).addMockedMethod(l).createMock();\n\n    List<ConfigGroupConfigMappingEntity> configGroupConfigMappingEntities =\n            new ArrayList<ConfigGroupConfigMappingEntity>();\n    ConfigGroupConfigMappingEntity configGroupConfigMappingEntity = new ConfigGroupConfigMappingEntity();\n    configGroupConfigMappingEntity.setConfigType(Configuration.GLOBAL_CONFIG_TAG);\n    configGroupConfigMappingEntity.setClusterConfigEntity(clusterConfigEntity);\n    configGroupConfigMappingEntity.setClusterId(1L);\n    configGroupConfigMappingEntities.add(configGroupConfigMappingEntity);\n\n    Map<String, Cluster> clustersMap = new HashMap<String, Cluster>();\n    clustersMap.put(\"c1\", cluster);\n\n    Map<String, String> globalConfigs = new HashMap<String, String>();\n    globalConfigs.put(\"prop1\", \"val1\");\n    globalConfigs.put(\"smokeuser_keytab\", \"val2\");\n\n    Map<String, String> pigSettings = new HashMap<String, String>();\n    pigSettings.put(\"pig-content\", \"foo\");\n\n    Set<String> envDicts = new HashSet<String>();\n    envDicts.add(\"hadoop-env\");\n    envDicts.add(\"global\");\n\n    Set<String> configTypes = new HashSet<String>();\n    configTypes.add(\"hadoop-env\");\n\n    Map<String, String> contentOfHadoopEnv = new HashMap<String, String>();\n    contentOfHadoopEnv.put(\"content\", \"env file contents\");\n\n    upgradeCatalog.updateConfigurationProperties(\"hadoop-env\",\n        globalConfigs, false, true);\n    expectLastCall();\n\n    upgradeCatalog.addNewConfigurationsFromXml();\n    expectLastCall();\n\n    expect(dbAccessor.executeSelect(\"SELECT role_name, user_id FROM user_roles\")).andReturn(userRolesResultSet).once();\n    expect(entityManager.getTransaction()).andReturn(trans).anyTimes();\n    expect(entityManager.getCriteriaBuilder()).andReturn(cb).anyTimes();\n    expect(entityManager.createQuery(cq)).andReturn(q).anyTimes();\n    expect(userRolesResultSet.next()).andReturn(false).once();\n    expect(trans.isActive()).andReturn(true).anyTimes();\n    expect(upgradeCatalog.getEntityManagerProvider()).andReturn(entityManagerProvider).anyTimes();\n    expect(cb.createQuery(HostRoleCommandEntity.class)).andReturn(cq).anyTimes();\n    expect(cb.desc(taskId)).andReturn(o).anyTimes();\n    expect(cq.from(HostRoleCommandEntity.class)).andReturn(hrc).anyTimes();\n    expect(cq.select(hrc)).andReturn(cq).anyTimes();\n    expect(cq.where(anyObject(Predicate.class))).andReturn(cq).anyTimes();\n    expect(hrc.get(isA(SingularAttribute.class))).andReturn(taskId).times(2);\n    expect(hrc.get(isA(SingularAttribute.class))).andReturn(outputLog).once();\n    expect(hrc.get(isA(SingularAttribute.class))).andReturn(errorLog).once();\n    expect(q.setMaxResults(1000)).andReturn(q).anyTimes();\n    expect(q.getResultList()).andReturn(r).anyTimes();\n    expect(clusterConfigEntity.getData()).andReturn(\"{\\\"dtnode_heapsize\\\":\\\"1028m\\\"}\");\n\n    expect(configuration.getDatabaseUrl()).andReturn(Configuration.JDBC_IN_MEMORY_URL).anyTimes();\n    expect(injector.getInstance(ConfigHelper.class)).andReturn(configHelper).anyTimes();\n    expect(injector.getInstance(AmbariManagementController.class)).andReturn(amc).anyTimes();\n    expect(amc.getClusters()).andReturn(clusters).anyTimes();\n    expect(clusters.getClusters()).andReturn(clustersMap).anyTimes();\n    expect(clusters.getClusterById(1L)).andReturn(clustersMap.values().iterator().next()).anyTimes();\n    expect(cluster.getDesiredConfigByType(\"global\")).andReturn(config).anyTimes();\n    expect(cluster.getClusterId()).andReturn(1L);\n    expect(cluster.getNextConfigVersion(\"hadoop-env\")).andReturn(3L);\n    expect(config.getProperties()).andReturn(globalConfigs).anyTimes();\n    expect(cluster.getCurrentStackVersion()).andReturn(new StackId(\"HDP\", \"2.1\")).anyTimes();\n    expect(cluster.getClusterName()).andReturn(\"c1\").anyTimes();\n    expect(configHelper.findConfigTypesByPropertyName(new StackId(\"HDP\", \"2.1\"), \"prop1\", \"c1\")).andReturn(envDicts).once();\n    expect(configHelper.findConfigTypesByPropertyName(new StackId(\"HDP\", \"2.1\"), \"smokeuser_keytab\", \"c1\")).andReturn(new HashSet<String>()).once();\n    expect(configHelper.findConfigTypesByPropertyName(new StackId(\"HDP\", \"2.1\"), \"content\", \"c1\")).andReturn(envDicts).once();\n    expect(configHelper.findConfigTypesByPropertyName(new StackId(\"HDP\", \"2.1\"), \"dtnode_heapsize\", \"c1\")).andReturn(configTypes).once();\n\n    expect(injector.getInstance(ConfigGroupConfigMappingDAO.class)).andReturn(configGroupConfigMappingDAO).anyTimes();\n    expect(injector.getInstance(UserDAO.class)).andReturn(userDAO).anyTimes();\n    expect(injector.getInstance(PrincipalDAO.class)).andReturn(principalDAO).anyTimes();\n    expect(injector.getInstance(PrincipalTypeDAO.class)).andReturn(principalTypeDAO).anyTimes();\n    expect(injector.getInstance(ClusterDAO.class)).andReturn(clusterDAO).anyTimes();\n    expect(injector.getInstance(ResourceTypeDAO.class)).andReturn(resourceTypeDAO).anyTimes();\n    expect(injector.getInstance(ResourceDAO.class)).andReturn(resourceDAO).anyTimes();\n    expect(injector.getInstance(ViewDAO.class)).andReturn(viewDAO).anyTimes();\n    expect(injector.getInstance(ViewInstanceDAO.class)).andReturn(viewInstanceDAO).anyTimes();\n    expect(injector.getInstance(PermissionDAO.class)).andReturn(permissionDAO).anyTimes();\n    expect(injector.getInstance(PrivilegeDAO.class)).andReturn(privilegeDAO).anyTimes();\n    expect(injector.getInstance(KeyValueDAO.class)).andReturn(keyValueDAO).anyTimes();\n\n    expect(configGroupConfigMappingDAO.findAll()).andReturn(configGroupConfigMappingEntities).once();\n    expect(userDAO.findAll()).andReturn(Collections.<UserEntity> emptyList()).times(2);\n    expect(clusterDAO.findAll()).andReturn(Collections.<ClusterEntity> emptyList()).anyTimes();\n    expect(viewDAO.findAll()).andReturn(Collections.<ViewEntity> emptyList()).anyTimes();\n    expect(viewInstanceDAO.findAll()).andReturn(Collections.<ViewInstanceEntity> emptyList()).anyTimes();\n    expect(permissionDAO.findAmbariAdminPermission()).andReturn(null);\n    expect(permissionDAO.findClusterOperatePermission()).andReturn(null);\n    expect(permissionDAO.findClusterReadPermission()).andReturn(null);\n\n    expect(cluster.getDesiredConfigByType(\"pig-properties\")).andReturn(pigConfig).anyTimes();\n    expect(pigConfig.getProperties()).andReturn(pigSettings).anyTimes();\n\n    ViewEntity jobsView = createNiceMock(ViewEntity.class);\n    KeyValueEntity showJobsKeyValue = createNiceMock(KeyValueEntity.class);\n    UserEntity user = createNiceMock(UserEntity.class);\n\n    expect(userDAO.findAll()).andReturn(Collections.singletonList(user));\n    expect(jobsView.getCommonName()).andReturn(UpgradeCatalog170.JOBS_VIEW_NAME);\n    expect(jobsView.getVersion()).andReturn(\"1.0.0\");\n    expect(viewDAO.findByCommonName(UpgradeCatalog170.JOBS_VIEW_NAME)).andReturn(jobsView).once();\n    expect(showJobsKeyValue.getValue()).andReturn(\"true\");\n    expect(keyValueDAO.findByKey(UpgradeCatalog170.SHOW_JOBS_FOR_NON_ADMIN_KEY)).andReturn(showJobsKeyValue);\n    expect(privilegeDAO.findAllByPrincipal(anyObject(List.class))).andReturn(Collections.<PrivilegeEntity>emptyList());\n    expect(viewDAO.merge(jobsView)).andReturn(jobsView);\n\n    resourceDAO.create(anyObject(ResourceEntity.class));\n    viewInstanceDAO.create(anyObject(ViewInstanceEntity.class));\n    keyValueDAO.remove(showJobsKeyValue);\n    privilegeDAO.create(anyObject(PrivilegeEntity.class));\n\n    replay(entityManager, trans, upgradeCatalog, cb, cq, hrc, q, userRolesResultSet);\n\n    replay(dbAccessor, configuration, injector, cluster, clusters, amc, config, configHelper, pigConfig);\n    replay(userDAO, clusterDAO, viewDAO, viewInstanceDAO, permissionDAO, configGroupConfigMappingDAO);\n    replay(resourceTypeDAO, resourceDAO, keyValueDAO, privilegeDAO, clusterConfigEntity);\n    replay(jobsView, showJobsKeyValue, user);\n\n    Class<?> c = AbstractUpgradeCatalog.class;\n    Field f = c.getDeclaredField(\"configuration\");\n    f.setAccessible(true);\n    f.set(upgradeCatalog, configuration);\n    f = c.getDeclaredField(\"dbAccessor\");\n    f.setAccessible(true);\n    f.set(upgradeCatalog, dbAccessor);\n    f = c.getDeclaredField(\"injector\");\n    f.setAccessible(true);\n    f.set(upgradeCatalog, injector);\n\n    upgradeCatalog.executeDMLUpdates();\n\n    verify(upgradeCatalog, dbAccessor, configuration, injector, cluster, clusters, amc, config, configHelper,\n        jobsView, showJobsKeyValue, privilegeDAO, viewDAO, viewInstanceDAO, resourceDAO, keyValueDAO, userRolesResultSet);\n  }","commit_id":"d99a275f552813593ff378270a8d411f34a25937","url":"https://github.com/apache/ambari"},{"original_method":"public void init()\n    {\n        registerMetaTransportEndpoints(AxisConnector.AXIS);\n        registerBeanDefinitionParser(\"connector\", new MuleOrphanDefinitionParser(AxisConnector.class, true));\n        registerBeanDefinitionParser(\"bean-type\", new ChildListEntryDefinitionParser(\"beanTypes\"));\n        registerBeanDefinitionParser(\"supported-scheme\", new ChildListEntryDefinitionParser(\"supportedSchemes\"));\n    }","id":102321,"modified_method":"public void init()\n    {\n        registerMetaTransportEndpoints(AxisConnector.AXIS);\n        registerBeanDefinitionParser(\"connector\", new MuleOrphanDefinitionParser(AxisConnector.class, true));\n        registerBeanDefinitionParser(\"bean-type\", new ChildListEntryDefinitionParser(\"beanTypes\"));\n        registerBeanDefinitionParser(\"supported-scheme\", new ChildListEntryDefinitionParser(\"supportedSchemes\"));\n        registerMuleBeanDefinitionParser(\"soap-methods\", new SoapMethodsDefinitionParser(\"properties\")).addCollection(\"properties\");\n    }","commit_id":"06562d2e3b3a507b26831870f6b32c3618e40cf3","url":"https://github.com/mulesoft/mule"},{"original_method":"public ChildMapEntryDefinitionParser(String mapName, String keyName, String valueName)\n    {\n        super(mapName, KeyValuePair.class);\n        addAlias(keyName, KEY);\n        addAlias(valueName, VALUE);\n    }","id":102322,"modified_method":"public ChildMapEntryDefinitionParser(String mapName, String keyName, String valueName)\n    {\n        this(mapName);\n        addAlias(keyName, KEY);\n        addAlias(valueName, VALUE);\n    }","commit_id":"06562d2e3b3a507b26831870f6b32c3618e40cf3","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerStandardTransportEndpoints(HttpConnector.HTTP, URIBuilder.SOCKET_ATTRIBUTES);\n        \n        registerBeanDefinitionParser(\"connector\", new MuleOrphanDefinitionParser(HttpConnector.class, true));\n\n        registerBeanDefinitionParser(\"rest-service-component\", new ComplexComponentDefinitionParser(RestServiceWrapper.class));\n        registerBeanDefinitionParser(\"payloadParameterNames\", new ChildListDefinitionParser(\"payloadParameterNames\"));\n        registerBeanDefinitionParser(\"requiredParams\", new ChildMapEntryDefinitionParser(\"requiredParams\",\"key\",\"value\"));\n        registerBeanDefinitionParser(\"optionalParams\", new ChildMapEntryDefinitionParser(\"optionalParams\",\"key\",\"value\"));\n        \n        registerBeanDefinitionParser(\"http-client-response-to-object\", new MuleOrphanDefinitionParser(HttpClientMethodResponseToObject.class, false));\n        registerBeanDefinitionParser(\"http-response-to-string\", new MuleOrphanDefinitionParser(HttpResponseToString.class, false));\n        registerBeanDefinitionParser(\"object-to-http-client-request\", new MuleOrphanDefinitionParser(ObjectToHttpClientMethodRequest.class, false));\n        registerBeanDefinitionParser(\"message-to-http-response\", new MuleOrphanDefinitionParser(UMOMessageToHttpResponse.class, false));\n    }","id":102323,"modified_method":"public void init()\n    {\n        registerStandardTransportEndpoints(HttpConnector.HTTP, URIBuilder.SOCKET_ATTRIBUTES);\n        \n        registerBeanDefinitionParser(\"connector\", new MuleOrphanDefinitionParser(HttpConnector.class, true));\n\n        registerBeanDefinitionParser(\"rest-service-component\", new ComplexComponentDefinitionParser(RestServiceWrapper.class));\n        registerBeanDefinitionParser(\"payloadParameterName\", new ChildListEntryDefinitionParser(\"payloadParameterNames\", ChildMapEntryDefinitionParser.VALUE));\n        registerBeanDefinitionParser(\"requiredParameter\", new ChildMapEntryDefinitionParser(\"requiredParams\"));\n        registerBeanDefinitionParser(\"optionalParameter\", new ChildMapEntryDefinitionParser(\"optionalParams\"));\n        \n        registerBeanDefinitionParser(\"http-client-response-to-object\", new MuleOrphanDefinitionParser(HttpClientMethodResponseToObject.class, false));\n        registerBeanDefinitionParser(\"http-response-to-string\", new MuleOrphanDefinitionParser(HttpResponseToString.class, false));\n        registerBeanDefinitionParser(\"object-to-http-client-request\", new MuleOrphanDefinitionParser(ObjectToHttpClientMethodRequest.class, false));\n        registerBeanDefinitionParser(\"message-to-http-response\", new MuleOrphanDefinitionParser(UMOMessageToHttpResponse.class, false));\n    }","commit_id":"06562d2e3b3a507b26831870f6b32c3618e40cf3","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"environment-property\", new EnvironmentPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"admin-agent\", new MuleAdminAgentDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-component-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"default-receiver-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        //registerBeanDefinitionParser(\"mule-configuration\", new ManagementContextDefinitionParser());\n        registerBeanDefinitionParser(\"component-threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\", MuleConfiguration.DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-service-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultComponentExceptionStrategy.class));\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n        registerMuleBeanDefinitionParser(\"notifications\", new NamedDefinitionParser(ManagementContext.NOTIFICATION_MANAGER)).addAlias(\"dynamic\", \"notificationDynamic\");\n        registerBeanDefinitionParser(\"notification\", new NotificationDefinitionParser());\n        registerBeanDefinitionParser(\"disable-notification\", new NotificationDisableDefinitionParser());\n        registerMuleBeanDefinitionParser(\"notification-listener\", new ChildDefinitionParser(\"allListenerSubscriptionPair\", ListenerSubscriptionPair.class)).addAlias(\"ref\", \"listener\").addReference(\"listener\");\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\", MuleConfiguration.DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\", MuleConfiguration.DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser(\"dispatcherConnectionStrategy\"));\n        registerBeanDefinitionParser(\"receiver-connection-straqtegy\", new ConnectionStrategyDefinitionParser(\"receiverConnectionStrategy\"));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n        registerBeanDefinitionParser(\"transformers\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"responseTransformers\", new ParentDefinitionParser()).addAlias(\"transformer\", \"responseTransformer\");\n\n        registerBeanDefinitionParser(\"transformer\", new TransformerRefDefinitionParser());\n\n        registerBeanDefinitionParser(\"custom-transformer\", new TransformerDefinitionParser());\n        registerBeanDefinitionParser(\"transformer-no-action\", new TransformerDefinitionParser(NoActionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-message-properties\", new TransformerDefinitionParser(MessagePropertiesTransformer.class));\n\n        registerBeanDefinitionParser(\"transformer-base64-encoder\", new TransformerDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"transformer-base64-decoder\", new TransformerDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"transformer-xml-entity-encoder\", new TransformerDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"transformer-xml-entity-decoder\", new TransformerDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"transformer-gzip-compress\", new TransformerDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"transformer-gzip-uncompress\", new TransformerDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"transformer-encrypt\", new TransformerDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-decrypt\", new TransformerDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-hex-string\", new TransformerDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"transformer-hex-sting-to-byte-array\", new TransformerDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"transformer-byte-array-to-object\", new TransformerDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"transformer-object-to-byte-array\", new TransformerDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"transformer-object-to-string\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-serializable\", new TransformerDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"transformer-serializable-to-byte-array\", new TransformerDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-string\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"transformer-string-to-byte-array\", new TransformerDefinitionParser(ObjectToByteArray.class));\n\n        registerBeanDefinitionParser(\"transformer-append-string\", new TransformerDefinitionParser(StringAppendTransformer.class));\n\n        //Transaction Managers\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new TransactionManagerDefinitionParser());\n        registerBeanDefinitionParser(\"transaction-manager-jndi\", new TransactionManagerDefinitionParser(GenericTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-weblogic\", new TransactionManagerDefinitionParser(WeblogicTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-jboss\", new TransactionManagerDefinitionParser(JBossTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-jrun\", new TransactionManagerDefinitionParser(JRunTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-resin\", new TransactionManagerDefinitionParser(Resin3TransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-websphere\", new TransactionManagerDefinitionParser(WebsphereTransactionManagerLookupFactory.class));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new GenericEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new GenericEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"transaction\", new TransactionConfigDefinitionParser());\n        registerBeanDefinitionParser(\"custom-transaction-factory\", new TransactionFactoryDefinitionParser());\n        registerMuleBeanDefinitionParser(\"transaction-factory\", new ParentDefinitionParser()).addAlias(\"ref\", \"factory\");\n\n        //Container contexts\n        registerBeanDefinitionParser(\"custom-container\", new MuleOrphanDefinitionParser(true));\n        registerBeanDefinitionParser(\"rmi-container\", new MuleOrphanDefinitionParser(RmiContainerContext.class, true));\n        registerBeanDefinitionParser(\"jndi-container\", new MuleOrphanDefinitionParser(JndiContainerContext.class, true));\n        registerBeanDefinitionParser(\"properties-container\", new MuleOrphanDefinitionParser(PropertiesContainerContext.class, true));\n\n        // Models\n        registerBeanDefinitionParser(\"model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n//        registerBeanDefinitionParser(\"model-seda-optimised\", new OrphanDefinitionParser(OptimisedSedaModel.class, true));\n//        registerBeanDefinitionParser(\"model-pipeline\", new OrphanDefinitionParser(PipelineModel.class, true));\n\n        //TODO RM*\n        registerBeanDefinitionParser(\"custom-entrypoint-resolver\", new ChildDefinitionParser(\"entryPointResolverSet\", null));\n        //registerBeanDefinitionParser(\"callable-entrypoint-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"method-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"reflection-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"non-void-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", NonVoidEntryPointResolver.class));\n\n        // Services\n        registerBeanDefinitionParser(\"seda-component\", new ServiceDefinitionParser(SedaComponent.class));\n        registerBeanDefinitionParser(\"service\", new ServiceDefinitionParser(SedaComponent.class));\n\n        // Pojo Components\n        registerBeanDefinitionParser(\"component\", new ComponentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"binding\", new BindingDefinitionParser(\"nestedRouter.routers\", NestedRouter.class)).addCollection(\"nestedRouter.routers\");\n\n        // Other Somponents\n        registerBeanDefinitionParser(\"bridge-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"pass-through-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimplePojoServiceDefinitionParser(LogComponent.class));\n        registerBeanDefinitionParser(\"echo-component\", new SimplePojoServiceDefinitionParser(EchoComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimplePojoServiceDefinitionParser(NullComponent.class));\n        registerBeanDefinitionParser(\"no-args-call-component\", new SimplePojoServiceDefinitionParser(NoArgsCallWrapper.class));\n\n        // Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new ObjectFactoryDefinitionParser(SingletonObjectFactory.class));\n        registerBeanDefinitionParser(\"prototype-object\", new ObjectFactoryDefinitionParser(PrototypeObjectFactory.class));\n        registerBeanDefinitionParser(\"pooled-object\", new ObjectFactoryDefinitionParser(PooledObjectFactory.class));\n        registerBeanDefinitionParser(\"spring-factory-bean\", new SpringFactoryBeanDefinitionParser());\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound-router\", new ChildDefinitionParser(\"inboundRouter\", InboundRouterCollection.class));\n        registerBeanDefinitionParser(\"outbound-router\", new ChildDefinitionParser(\"outboundRouter\", OutboundRouterCollection.class));\n        registerBeanDefinitionParser(\"async-reply-router\", new ChildDefinitionParser(\"responseRouter\", ResponseRouterCollection.class));\n\n        //NoArgsCallWrapper\n        registerMuleBeanDefinitionParser(\"delegateClass\", new AttributeMapDefinitionParser(\"properties\")).addAlias(\"class\", \"delegateClass\").addAlias(\"method\", \"delegateMethod\");\n        registerMuleBeanDefinitionParser(\"delegateInstance\", new AttributeMapDefinitionParser(\"properties\")).addAlias(\"ref\", \"delegateInstance\").addAlias(\"method\", \"delegateMethod\");\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new ForwardingRouterDefinitionParser());\n        registerBeanDefinitionParser(\"inbound-pass-through-router\", new RouterDefinitionParser(\"router\", InboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentReceiver.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentSecureHashReceiver.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new RouterDefinitionParser(\"router\", SelectiveConsumer.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new RouterDefinitionParser(\"router\", WireTap.class));\n        registerBeanDefinitionParser(\"correlation-aggregator-router\", new RouterDefinitionParser(\"router\"));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new RouterDefinitionParser(\"router\", MessageChunkingAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new RouterDefinitionParser(\"router\", CorrelationEventResequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"outbound-pass-through-router\", new RouterDefinitionParser(\"router\", OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(\"router\", FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(\"router\", ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(\"router\", EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(\"router\", ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(\"router\", FilteringListMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(\"router\", MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(\"router\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(\"router\", StaticRecipientList.class));\n        registerBeanDefinitionParser(\"recipients\", new ChildListDefinitionParser(\"recipients\"));\n        registerBeanDefinitionParser(\"template-endpoint-router\", new RouterDefinitionParser(\"router\", TemplateEndpointRouter.class));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(\"router\", null));\n        registerMuleBeanDefinitionParser(\"reply-to\", new ParentDefinitionParser()).addAlias(\"address\", \"replyTo\");\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-async-reply-router\", new RouterDefinitionParser(\"router\", null));\n        registerBeanDefinitionParser(\"single-async-reply-router\", new RouterDefinitionParser(\"router\", SingleResponseRouter.class));\n\n        //Property Extractors\n        registerBeanDefinitionParser(\"function-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", FunctionPropertyExtractor.class));\n        registerBeanDefinitionParser(\"correlation-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", CorrelationPropertiesExtractor.class));\n        registerBeanDefinitionParser(\"custom-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\"));\n        registerBeanDefinitionParser(\"map-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MapPayloadPropertyExtractor.class));\n        registerBeanDefinitionParser(\"message-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MessageHeaderPropertyExtractor.class));\n        //registerBeanDefinitionParser(\"payload-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", PayloadPropertyExtractor.class));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerMuleBeanDefinitionParser(\"filter\", new ParentDefinitionParser()).addAlias(\"ref\", \"filter\");\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser(RegExFilter.class));\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Retry strategies\n        registerBeanDefinitionParser(\"retry-connection-strategy\", new ChildDefinitionParser(\"connectionStrategy\", SimpleRetryConnectionStrategy.class));\n\n        //Utils / Standard Types\n        registerBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\"));\n        registerMuleBeanDefinitionParser(\"add-message-properties\", new ChildMapDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"add-message-property\", new ChildMapEntryDefinitionParser(\"addProperties\", ChildMapEntryDefinitionParser.KEY, ChildMapEntryDefinitionParser.VALUE)).addCollection(\"addProperties\");\n        registerBeanDefinitionParser(\"delete-message-property\", new ChildListEntryDefinitionParser(\"deleteProperties\", ChildMapEntryDefinitionParser.KEY));\n        registerBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\"));\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n\n        //Security\n        registerMuleBeanDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\").addIgnored(\"name\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleBeanDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new ChildDefinitionParser(\"securityFilter\", MuleEncryptionEndpointSecurityFilter.class));\n    }","id":102324,"modified_method":"public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"environment-property\", new EnvironmentPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"admin-agent\", new MuleAdminAgentDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-component-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"default-receiver-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        //registerBeanDefinitionParser(\"mule-configuration\", new ManagementContextDefinitionParser());\n        registerBeanDefinitionParser(\"component-threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\", MuleConfiguration.DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-service-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultComponentExceptionStrategy.class));\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n        registerMuleBeanDefinitionParser(\"notifications\", new NamedDefinitionParser(ManagementContext.NOTIFICATION_MANAGER)).addAlias(\"dynamic\", \"notificationDynamic\");\n        registerBeanDefinitionParser(\"notification\", new NotificationDefinitionParser());\n        registerBeanDefinitionParser(\"disable-notification\", new NotificationDisableDefinitionParser());\n        registerMuleBeanDefinitionParser(\"notification-listener\", new ChildDefinitionParser(\"allListenerSubscriptionPair\", ListenerSubscriptionPair.class)).addAlias(\"ref\", \"listener\").addReference(\"listener\");\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\", MuleConfiguration.DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\", MuleConfiguration.DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser(\"dispatcherConnectionStrategy\"));\n        registerBeanDefinitionParser(\"receiver-connection-straqtegy\", new ConnectionStrategyDefinitionParser(\"receiverConnectionStrategy\"));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n        registerBeanDefinitionParser(\"transformers\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"responseTransformers\", new ParentDefinitionParser()).addAlias(\"transformer\", \"responseTransformer\");\n\n        registerBeanDefinitionParser(\"transformer\", new TransformerRefDefinitionParser());\n\n        registerBeanDefinitionParser(\"custom-transformer\", new TransformerDefinitionParser());\n        registerBeanDefinitionParser(\"transformer-no-action\", new TransformerDefinitionParser(NoActionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-message-properties\", new TransformerDefinitionParser(MessagePropertiesTransformer.class));\n\n        registerBeanDefinitionParser(\"transformer-base64-encoder\", new TransformerDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"transformer-base64-decoder\", new TransformerDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"transformer-xml-entity-encoder\", new TransformerDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"transformer-xml-entity-decoder\", new TransformerDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"transformer-gzip-compress\", new TransformerDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"transformer-gzip-uncompress\", new TransformerDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"transformer-encrypt\", new TransformerDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-decrypt\", new TransformerDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-hex-string\", new TransformerDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"transformer-hex-sting-to-byte-array\", new TransformerDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"transformer-byte-array-to-object\", new TransformerDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"transformer-object-to-byte-array\", new TransformerDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"transformer-object-to-string\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-serializable\", new TransformerDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"transformer-serializable-to-byte-array\", new TransformerDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-string\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"transformer-string-to-byte-array\", new TransformerDefinitionParser(ObjectToByteArray.class));\n\n        registerBeanDefinitionParser(\"transformer-append-string\", new TransformerDefinitionParser(StringAppendTransformer.class));\n\n        //Transaction Managers\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new TransactionManagerDefinitionParser());\n        registerBeanDefinitionParser(\"transaction-manager-jndi\", new TransactionManagerDefinitionParser(GenericTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-weblogic\", new TransactionManagerDefinitionParser(WeblogicTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-jboss\", new TransactionManagerDefinitionParser(JBossTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-jrun\", new TransactionManagerDefinitionParser(JRunTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-resin\", new TransactionManagerDefinitionParser(Resin3TransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-websphere\", new TransactionManagerDefinitionParser(WebsphereTransactionManagerLookupFactory.class));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new GenericEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new GenericEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"transaction\", new TransactionConfigDefinitionParser());\n        registerBeanDefinitionParser(\"custom-transaction-factory\", new TransactionFactoryDefinitionParser());\n        registerMuleBeanDefinitionParser(\"transaction-factory\", new ParentDefinitionParser()).addAlias(\"ref\", \"factory\");\n\n        //Container contexts\n        registerBeanDefinitionParser(\"custom-container\", new MuleOrphanDefinitionParser(true));\n        registerBeanDefinitionParser(\"rmi-container\", new MuleOrphanDefinitionParser(RmiContainerContext.class, true));\n        registerBeanDefinitionParser(\"jndi-container\", new MuleOrphanDefinitionParser(JndiContainerContext.class, true));\n        registerBeanDefinitionParser(\"properties-container\", new MuleOrphanDefinitionParser(PropertiesContainerContext.class, true));\n\n        // Models\n        registerBeanDefinitionParser(\"model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n//        registerBeanDefinitionParser(\"model-seda-optimised\", new OrphanDefinitionParser(OptimisedSedaModel.class, true));\n//        registerBeanDefinitionParser(\"model-pipeline\", new OrphanDefinitionParser(PipelineModel.class, true));\n\n        //TODO RM*\n        registerBeanDefinitionParser(\"custom-entrypoint-resolver\", new ChildDefinitionParser(\"entryPointResolverSet\", null));\n        //registerBeanDefinitionParser(\"callable-entrypoint-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"method-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"reflection-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"non-void-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", NonVoidEntryPointResolver.class));\n\n        // Services\n        registerBeanDefinitionParser(\"seda-component\", new ServiceDefinitionParser(SedaComponent.class));\n        registerBeanDefinitionParser(\"service\", new ServiceDefinitionParser(SedaComponent.class));\n\n        // Pojo Components\n        registerBeanDefinitionParser(\"component\", new ComponentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"binding\", new BindingDefinitionParser(\"nestedRouter.routers\", NestedRouter.class)).addCollection(\"nestedRouter.routers\");\n\n        // Other Somponents\n        registerBeanDefinitionParser(\"bridge-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"pass-through-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimplePojoServiceDefinitionParser(LogComponent.class));\n        registerBeanDefinitionParser(\"echo-component\", new SimplePojoServiceDefinitionParser(EchoComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimplePojoServiceDefinitionParser(NullComponent.class));\n        registerBeanDefinitionParser(\"no-args-call-component\", new SimplePojoServiceDefinitionParser(NoArgsCallWrapper.class));\n\n        // Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new ObjectFactoryDefinitionParser(SingletonObjectFactory.class));\n        registerBeanDefinitionParser(\"prototype-object\", new ObjectFactoryDefinitionParser(PrototypeObjectFactory.class));\n        registerBeanDefinitionParser(\"pooled-object\", new ObjectFactoryDefinitionParser(PooledObjectFactory.class));\n        registerBeanDefinitionParser(\"spring-factory-bean\", new SpringFactoryBeanDefinitionParser());\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound-router\", new ChildDefinitionParser(\"inboundRouter\", InboundRouterCollection.class));\n        registerBeanDefinitionParser(\"outbound-router\", new ChildDefinitionParser(\"outboundRouter\", OutboundRouterCollection.class));\n        registerBeanDefinitionParser(\"async-reply-router\", new ChildDefinitionParser(\"responseRouter\", ResponseRouterCollection.class));\n\n        //NoArgsCallWrapper\n        registerMuleBeanDefinitionParser(\"delegateClass\", new AttributeMapDefinitionParser(\"properties\")).addAlias(\"class\", \"delegateClass\").addAlias(\"method\", \"delegateMethod\");\n        registerMuleBeanDefinitionParser(\"delegateInstance\", new AttributeMapDefinitionParser(\"properties\")).addAlias(\"ref\", \"delegateInstance\").addAlias(\"method\", \"delegateMethod\");\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new ForwardingRouterDefinitionParser());\n        registerBeanDefinitionParser(\"inbound-pass-through-router\", new RouterDefinitionParser(\"router\", InboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentReceiver.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentSecureHashReceiver.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new RouterDefinitionParser(\"router\", SelectiveConsumer.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new RouterDefinitionParser(\"router\", WireTap.class));\n        registerBeanDefinitionParser(\"correlation-aggregator-router\", new RouterDefinitionParser(\"router\"));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new RouterDefinitionParser(\"router\", MessageChunkingAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new RouterDefinitionParser(\"router\", CorrelationEventResequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"outbound-pass-through-router\", new RouterDefinitionParser(\"router\", OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(\"router\", FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(\"router\", ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(\"router\", EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(\"router\", ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(\"router\", FilteringListMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(\"router\", MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(\"router\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(\"router\", StaticRecipientList.class));\n        registerBeanDefinitionParser(\"recipients\", new ChildListDefinitionParser(\"recipients\"));\n        registerBeanDefinitionParser(\"template-endpoint-router\", new RouterDefinitionParser(\"router\", TemplateEndpointRouter.class));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(\"router\", null));\n        registerMuleBeanDefinitionParser(\"reply-to\", new ParentDefinitionParser()).addAlias(\"address\", \"replyTo\");\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-async-reply-router\", new RouterDefinitionParser(\"router\", null));\n        registerBeanDefinitionParser(\"single-async-reply-router\", new RouterDefinitionParser(\"router\", SingleResponseRouter.class));\n\n        //Property Extractors\n        registerBeanDefinitionParser(\"function-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", FunctionPropertyExtractor.class));\n        registerBeanDefinitionParser(\"correlation-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", CorrelationPropertiesExtractor.class));\n        registerBeanDefinitionParser(\"custom-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\"));\n        registerBeanDefinitionParser(\"map-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MapPayloadPropertyExtractor.class));\n        registerBeanDefinitionParser(\"message-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MessageHeaderPropertyExtractor.class));\n        //registerBeanDefinitionParser(\"payload-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", PayloadPropertyExtractor.class));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerMuleBeanDefinitionParser(\"filter\", new ParentDefinitionParser()).addAlias(\"ref\", \"filter\");\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser(RegExFilter.class));\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Retry strategies\n        registerBeanDefinitionParser(\"retry-connection-strategy\", new ChildDefinitionParser(\"connectionStrategy\", SimpleRetryConnectionStrategy.class));\n\n        //Utils / Standard Types\n        registerMuleBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"property\", new ChildMapEntryDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"add-message-properties\", new ChildMapDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"add-message-property\", new ChildMapEntryDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerBeanDefinitionParser(\"delete-message-property\", new ChildListEntryDefinitionParser(\"deleteProperties\", ChildMapEntryDefinitionParser.KEY));\n        registerMuleBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerMuleBeanDefinitionParser(\"jndi-provider-property\", new ChildMapEntryDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n\n        //Security\n        registerMuleBeanDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\").addIgnored(\"name\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleBeanDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new ChildDefinitionParser(\"securityFilter\", MuleEncryptionEndpointSecurityFilter.class));\n    }","commit_id":"06562d2e3b3a507b26831870f6b32c3618e40cf3","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerStandardTransportEndpoints(SmtpConnector.SMTP, URIBuilder.HOST_ATTRIBUTES);\n        registerBeanDefinitionParser(\"connector\", new MuleOrphanDefinitionParser(SmtpConnector.class, true));\n        registerBeanDefinitionParser(\"header\", new ChildMapEntryDefinitionParser(\"customHeaders\", \"key\", \"value\"));\n    }","id":102325,"modified_method":"public void init()\n    {\n        registerStandardTransportEndpoints(SmtpConnector.SMTP, URIBuilder.HOST_ATTRIBUTES).addAlias(\"to\", MailProperties.TO_ADDRESSES_PROPERTY).addAlias(\"from\", MailProperties.FROM_ADDRESS_PROPERTY).addAlias(\"cc\", MailProperties.CC_ADDRESSES_PROPERTY).addAlias(\"bcc\", MailProperties.BCC_ADDRESSES_PROPERTY).addAlias(\"from\", MailProperties.FROM_ADDRESS_PROPERTY).addAlias(\"replyTo\", MailProperties.REPLY_TO_ADDRESSES_PROPERTY);\n        registerBeanDefinitionParser(\"connector\", new MuleOrphanDefinitionParser(SmtpConnector.class, true));\n        registerBeanDefinitionParser(\"header\", new ChildMapEntryDefinitionParser(\"customHeaders\", \"key\", \"value\"));\n    }","commit_id":"06562d2e3b3a507b26831870f6b32c3618e40cf3","url":"https://github.com/mulesoft/mule"},{"original_method":"protected String getConfigResources()\n    {\n        return \"stockquote-soap-config.xml\";\n    }","id":102326,"modified_method":"protected String getConfigResources()\n    {\n        return \"stockquote-soap-config-new.xml\";\n    }","commit_id":"06562d2e3b3a507b26831870f6b32c3618e40cf3","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerStandardTransportEndpoints(SmtpsConnector.SMTPS, URIBuilder.HOST_ATTRIBUTES);\n        registerBeanDefinitionParser(\"connector\", new MuleOrphanDefinitionParser(SmtpsConnector.class, true));\n        registerBeanDefinitionParser(\"header\", new ChildMapEntryDefinitionParser(\"customHeaders\", \"key\", \"value\"));\n        registerBeanDefinitionParser(\"tls-trust-store\", new ParentDefinitionParser());\n        registerBeanDefinitionParser(\"tls-client\", new ParentDefinitionParser());\n    }","id":102327,"modified_method":"public void init()\n    {\n        registerStandardTransportEndpoints(SmtpsConnector.SMTPS, URIBuilder.HOST_ATTRIBUTES)\n                .addAlias(\"to\", MailProperties.TO_ADDRESSES_PROPERTY)\n                .addAlias(\"from\", MailProperties.FROM_ADDRESS_PROPERTY)\n                .addAlias(\"cc\", MailProperties.CC_ADDRESSES_PROPERTY)\n                .addAlias(\"bcc\", MailProperties.BCC_ADDRESSES_PROPERTY)\n                .addAlias(\"from\", MailProperties.FROM_ADDRESS_PROPERTY)\n                .addAlias(\"replyTo\", MailProperties.REPLY_TO_ADDRESSES_PROPERTY);\n        registerBeanDefinitionParser(\"connector\", new MuleOrphanDefinitionParser(SmtpsConnector.class, true));\n        registerBeanDefinitionParser(\"header\", new ChildMapEntryDefinitionParser(\"customHeaders\", \"key\", \"value\"));\n        registerBeanDefinitionParser(\"tls-trust-store\", new ParentDefinitionParser());\n        registerBeanDefinitionParser(\"tls-client\", new ParentDefinitionParser());\n    }","commit_id":"b953c6c50c27751a7034d28de1de3071d868a902","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doSetUp() throws Exception\n    {\n        super.doSetUp();\n\n        // start a simple HTTP server that parses the request sent from Mule\n        new Thread(new SimpleHttpServer()).start();\n    }","id":102328,"modified_method":"protected void doSetUp() throws Exception\n    {\n        super.doSetUp();\n\n        // start a simple HTTP server that parses the request sent from Mule\n        new Thread(new SimpleHttpServer(LISTEN_PORT, simpleServerLatch, latch)).start();\n    }","commit_id":"ddd395599f784916d32fda2f97a1142f5651d95b","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testCookies() throws Exception\n    {\n        // wait for the simple server thread started in doSetUp to come up\n        assertTrue(simpleServerLatch.await(RECEIVE_TIMEOUT, TimeUnit.MILLISECONDS));\n\n        Map<String, String> properties = new HashMap<String, String>();\n        properties.put(\"COOKIE_HEADER\",\"MYCOOKIE\");\n        MuleClient client = new MuleClient();\n        client.send(\"vm://vm-in\", \"foobar\", properties);\n\n        assertTrue(latch.await(RECEIVE_TIMEOUT, TimeUnit.MILLISECONDS));\n        assertTrue(cookieFound);\n\n        assertTrue(cookieHeaders.size() == 2);\n        assertEquals(\"Cookie: $Version=0; customCookie=yes\", cookieHeaders.get(0));\n        assertEquals(\"Cookie: $Version=0; expressionCookie=MYCOOKIE\", cookieHeaders.get(1));\n    }","id":102329,"modified_method":"public SimpleHttpServer(int listenPort, CountDownLatch startupLatch, CountDownLatch testCompleteLatch)\n        {\n            super(listenPort, startupLatch, testCompleteLatch);\n        }","commit_id":"ddd395599f784916d32fda2f97a1142f5651d95b","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerStandardTransportEndpoints(HttpConnector.HTTP, URIBuilder.SOCKET_ATTRIBUTES)\n                .addAlias(\"contentType\", HttpConstants.HEADER_CONTENT_TYPE);\n        \n        registerConnectorDefinitionParser(HttpConnector.class);\n        registerBeanDefinitionParser(\"polling-connector\", new MuleOrphanDefinitionParser(HttpPollingConnector.class, true));\n\n        registerBeanDefinitionParser(\"rest-service-component\", new ComponentDefinitionParser(RestServiceWrapper.class));\n        registerBeanDefinitionParser(\"payloadParameterName\", new ChildListEntryDefinitionParser(\"payloadParameterNames\", ChildMapEntryDefinitionParser.VALUE));\n        registerBeanDefinitionParser(\"requiredParameter\", new ChildMapEntryDefinitionParser(\"requiredParams\"));\n        registerBeanDefinitionParser(\"optionalParameter\", new ChildMapEntryDefinitionParser(\"optionalParams\"));\n        \n        registerBeanDefinitionParser(\"http-response-to-object-transformer\", new TransformerDefinitionParser(HttpClientMethodResponseToObject.class));\n        registerBeanDefinitionParser(\"http-response-to-string-transformer\", new TransformerDefinitionParser(HttpResponseToString.class));\n        registerBeanDefinitionParser(\"object-to-http-request-transformer\", new TransformerDefinitionParser(ObjectToHttpClientMethodRequest.class));\n        registerBeanDefinitionParser(\"message-to-http-response-transformer\", new TransformerDefinitionParser(MuleMessageToHttpResponse.class));\n        registerBeanDefinitionParser(\"error-filter\", new ChildDefinitionParser(\"filter\", ErrorFilterFactoryBean.class));\n        registerBeanDefinitionParser(\"request-wildcard-filter\", new ChildDefinitionParser(\"filter\", HttpRequestWildcardFilter.class));\n    }","id":102330,"modified_method":"public void init()\n    {\n        registerStandardTransportEndpoints(HttpConnector.HTTP, URIBuilder.SOCKET_ATTRIBUTES)\n            .addAlias(\"contentType\", HttpConstants.HEADER_CONTENT_TYPE)\n            .addAlias(\"method\", HttpConnector.HTTP_METHOD_PROPERTY);\n        \n        registerConnectorDefinitionParser(HttpConnector.class);\n        registerBeanDefinitionParser(\"polling-connector\", new MuleOrphanDefinitionParser(HttpPollingConnector.class, true));\n\n        registerBeanDefinitionParser(\"rest-service-component\", new ComponentDefinitionParser(RestServiceWrapper.class));\n        registerBeanDefinitionParser(\"payloadParameterName\", new ChildListEntryDefinitionParser(\"payloadParameterNames\", ChildMapEntryDefinitionParser.VALUE));\n        registerBeanDefinitionParser(\"requiredParameter\", new ChildMapEntryDefinitionParser(\"requiredParams\"));\n        registerBeanDefinitionParser(\"optionalParameter\", new ChildMapEntryDefinitionParser(\"optionalParams\"));\n        \n        registerBeanDefinitionParser(\"http-response-to-object-transformer\", new TransformerDefinitionParser(HttpClientMethodResponseToObject.class));\n        registerBeanDefinitionParser(\"http-response-to-string-transformer\", new TransformerDefinitionParser(HttpResponseToString.class));\n        registerBeanDefinitionParser(\"object-to-http-request-transformer\", new TransformerDefinitionParser(ObjectToHttpClientMethodRequest.class));\n        registerBeanDefinitionParser(\"message-to-http-response-transformer\", new TransformerDefinitionParser(MuleMessageToHttpResponse.class));\n        registerBeanDefinitionParser(\"error-filter\", new ChildDefinitionParser(\"filter\", ErrorFilterFactoryBean.class));\n        registerBeanDefinitionParser(\"request-wildcard-filter\", new ChildDefinitionParser(\"filter\", HttpRequestWildcardFilter.class));\n    }","commit_id":"ddd395599f784916d32fda2f97a1142f5651d95b","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerStandardTransportEndpoints(HttpsConnector.HTTPS, URIBuilder.SOCKET_ATTRIBUTES);\n        registerConnectorDefinitionParser(HttpsConnector.class);\n        registerBeanDefinitionParser(\"polling-connector\", new MuleOrphanDefinitionParser(HttpsPollingConnector.class, true));\n\n        registerBeanDefinitionParser(\"tls-key-store\", new KeyStoreDefinitionParser());\n        registerBeanDefinitionParser(\"tls-client\", new ClientKeyStoreDefinitionParser());\n        registerBeanDefinitionParser(\"tls-server\", new TrustStoreDefinitionParser());\n        registerBeanDefinitionParser(\"tls-protocol-handler\", new ProtocolHandlerDefinitionParser());\n    }","id":102331,"modified_method":"public void init()\n    {\n        registerStandardTransportEndpoints(HttpsConnector.HTTPS, URIBuilder.SOCKET_ATTRIBUTES)\n            .addAlias(\"contentType\", HttpConstants.HEADER_CONTENT_TYPE)\n            .addAlias(\"method\", HttpConnector.HTTP_METHOD_PROPERTY);\n        \n        registerConnectorDefinitionParser(HttpsConnector.class);\n        registerBeanDefinitionParser(\"polling-connector\", new MuleOrphanDefinitionParser(HttpsPollingConnector.class, true));\n\n        registerBeanDefinitionParser(\"tls-key-store\", new KeyStoreDefinitionParser());\n        registerBeanDefinitionParser(\"tls-client\", new ClientKeyStoreDefinitionParser());\n        registerBeanDefinitionParser(\"tls-server\", new TrustStoreDefinitionParser());\n        registerBeanDefinitionParser(\"tls-protocol-handler\", new ProtocolHandlerDefinitionParser());\n    }","commit_id":"ddd395599f784916d32fda2f97a1142f5651d95b","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n\t * Establish whether its a basic type\n\t * \n\t * @param prop The domain class property\n\t * @return True if it is basic\n\t */\n\tpublic static boolean isBasicType(GrailsDomainClassProperty prop) {\n\t\treturn TypeFactory.basic(prop.getType().getName()) != null;\n\t}","id":102332,"modified_method":"/**\n\t * Establish whether its a basic type\n\t * \n\t * @param prop The domain class property\n\t * @return True if it is basic\n\t */\n\tpublic static boolean isBasicType(GrailsDomainClassProperty prop) {\n\t\tif(prop == null)return false;\n\t\tClass propType = prop.getType();\n\t\treturn TypeFactory.basic(propType.getName()) != null || \n\t\t\t\t\t\t\t\t\t\tpropType == URL.class || \n\t\t\t\t\t\t\t\t\t\tpropType == URI.class;\n\t}","commit_id":"d163d137143fea0698800214f2b5050568b48676","url":"https://github.com/grails/grails-core"},{"original_method":"public MetricsRegionSourceImpl(MetricsRegionWrapper regionWrapper,\n                                 MetricsRegionAggregateSourceImpl aggregate) {\n    this.regionWrapper = regionWrapper;\n    agg = aggregate;\n    agg.register(this);\n\n    LOG.debug(\"Creating new MetricsRegionSourceImpl for table \" +\n        regionWrapper.getTableName() +\n        \" \" +\n        regionWrapper.getRegionName());\n\n    registry = agg.getMetricsRegistry();\n\n    regionNamePrefix = \"table.\" + regionWrapper.getTableName() + \".\"\n        + \"region.\" + regionWrapper.getRegionName() + \".\";\n\n    String suffix = \"Count\";\n\n\n    regionPutKey = regionNamePrefix + MetricsRegionServerSource.MUTATE_KEY + suffix;\n    regionPut = registry.getLongCounter(regionPutKey, 0l);\n\n    regionDeleteKey = regionNamePrefix + MetricsRegionServerSource.DELETE_KEY + suffix;\n    regionDelete = registry.getLongCounter(regionDeleteKey, 0l);\n\n    regionIncrementKey = regionNamePrefix + MetricsRegionServerSource.INCREMENT_KEY + suffix;\n    regionIncrement = registry.getLongCounter(regionIncrementKey, 0l);\n\n    regionAppendKey = regionNamePrefix + MetricsRegionServerSource.APPEND_KEY + suffix;\n    regionAppend = registry.getLongCounter(regionAppendKey, 0l);\n\n    regionGetKey = regionNamePrefix + MetricsRegionServerSource.GET_KEY;\n    regionGet = registry.newStat(regionGetKey, \"\", OPS_SAMPLE_NAME, SIZE_VALUE_NAME);\n\n    regionScanNextKey = regionNamePrefix + MetricsRegionServerSource.SCAN_NEXT_KEY;\n    regionScanNext = registry.newStat(regionScanNextKey, \"\", OPS_SAMPLE_NAME, SIZE_VALUE_NAME);\n  }","id":102333,"modified_method":"public MetricsRegionSourceImpl(MetricsRegionWrapper regionWrapper,\n                                 MetricsRegionAggregateSourceImpl aggregate) {\n    this.regionWrapper = regionWrapper;\n    agg = aggregate;\n    agg.register(this);\n\n    LOG.debug(\"Creating new MetricsRegionSourceImpl for table \" +\n        regionWrapper.getTableName() + \" \" + regionWrapper.getRegionName());\n\n    registry = agg.getMetricsRegistry();\n\n    regionNamePrefix = \"namespace_\" + regionWrapper.getNamespace() +\n        \"_table_\" + regionWrapper.getTableName() +\n        \"_region_\" + regionWrapper.getRegionName()  +\n        \"_metric_\";\n\n    String suffix = \"Count\";\n\n\n    regionPutKey = regionNamePrefix + MetricsRegionServerSource.MUTATE_KEY + suffix;\n    regionPut = registry.getLongCounter(regionPutKey, 0l);\n\n    regionDeleteKey = regionNamePrefix + MetricsRegionServerSource.DELETE_KEY + suffix;\n    regionDelete = registry.getLongCounter(regionDeleteKey, 0l);\n\n    regionIncrementKey = regionNamePrefix + MetricsRegionServerSource.INCREMENT_KEY + suffix;\n    regionIncrement = registry.getLongCounter(regionIncrementKey, 0l);\n\n    regionAppendKey = regionNamePrefix + MetricsRegionServerSource.APPEND_KEY + suffix;\n    regionAppend = registry.getLongCounter(regionAppendKey, 0l);\n\n    regionGetKey = regionNamePrefix + MetricsRegionServerSource.GET_KEY;\n    regionGet = registry.newHistogram(regionGetKey);\n\n    regionScanNextKey = regionNamePrefix + MetricsRegionServerSource.SCAN_NEXT_KEY;\n    regionScanNext = registry.newHistogram(regionScanNextKey);\n  }","commit_id":"e0768e081488da5ee6ee2efd2facd14d1565bb21","url":"https://github.com/apache/hbase"},{"original_method":"public MetricsRegionSourceImpl(MetricsRegionWrapper regionWrapper,\n                                 MetricsRegionAggregateSourceImpl aggregate) {\n    this.regionWrapper = regionWrapper;\n    agg = aggregate;\n    agg.register(this);\n\n    LOG.debug(\"Creating new MetricsRegionSourceImpl for table \" +\n        regionWrapper.getTableName() +\n        \" \" +\n        regionWrapper.getRegionName());\n\n    registry = agg.getMetricsRegistry();\n\n    regionNamePrefix = \"table.\" + regionWrapper.getTableName() + \".\"\n        + \"region.\" + regionWrapper.getRegionName() + \".\";\n\n    String suffix = \"Count\";\n\n    regionPutKey = regionNamePrefix + MetricsRegionServerSource.MUTATE_KEY + suffix;\n    regionPut = registry.getLongCounter(regionPutKey, 0l);\n\n    regionDeleteKey = regionNamePrefix + MetricsRegionServerSource.DELETE_KEY + suffix;\n    regionDelete = registry.getLongCounter(regionDeleteKey, 0l);\n\n    regionIncrementKey = regionNamePrefix + MetricsRegionServerSource.INCREMENT_KEY + suffix;\n    regionIncrement = registry.getLongCounter(regionIncrementKey, 0l);\n\n    regionAppendKey = regionNamePrefix + MetricsRegionServerSource.APPEND_KEY + suffix;\n    regionAppend = registry.getLongCounter(regionAppendKey, 0l);\n\n    regionGetKey = regionNamePrefix + MetricsRegionServerSource.GET_KEY;\n    regionGet = registry.newStat(regionGetKey, \"\", OPS_SAMPLE_NAME, SIZE_VALUE_NAME);\n\n    regionScanNextKey = regionNamePrefix + MetricsRegionServerSource.SCAN_NEXT_KEY;\n    regionScanNext = registry.newStat(regionScanNextKey, \"\", OPS_SAMPLE_NAME, SIZE_VALUE_NAME);\n  }","id":102334,"modified_method":"public MetricsRegionSourceImpl(MetricsRegionWrapper regionWrapper,\n                                 MetricsRegionAggregateSourceImpl aggregate) {\n    this.regionWrapper = regionWrapper;\n    agg = aggregate;\n    agg.register(this);\n\n    LOG.debug(\"Creating new MetricsRegionSourceImpl for table \" +\n        regionWrapper.getTableName() + \" \" + regionWrapper.getRegionName());\n\n    registry = agg.getMetricsRegistry();\n\n    regionNamePrefix = \"namespace_\" + regionWrapper.getNamespace() +\n        \"_table_\" + regionWrapper.getTableName() +\n        \"_region_\" + regionWrapper.getRegionName()  +\n        \"_metric_\";\n\n    String suffix = \"Count\";\n\n    regionPutKey = regionNamePrefix + MetricsRegionServerSource.MUTATE_KEY + suffix;\n    regionPut = registry.getLongCounter(regionPutKey, 0l);\n\n    regionDeleteKey = regionNamePrefix + MetricsRegionServerSource.DELETE_KEY + suffix;\n    regionDelete = registry.getLongCounter(regionDeleteKey, 0l);\n\n    regionIncrementKey = regionNamePrefix + MetricsRegionServerSource.INCREMENT_KEY + suffix;\n    regionIncrement = registry.getLongCounter(regionIncrementKey, 0l);\n\n    regionAppendKey = regionNamePrefix + MetricsRegionServerSource.APPEND_KEY + suffix;\n    regionAppend = registry.getLongCounter(regionAppendKey, 0l);\n\n    regionGetKey = regionNamePrefix + MetricsRegionServerSource.GET_KEY;\n    regionGet = registry.newHistogram(regionGetKey);\n\n    regionScanNextKey = regionNamePrefix + MetricsRegionServerSource.SCAN_NEXT_KEY;\n    regionScanNext = registry.newHistogram(regionScanNextKey);\n  }","commit_id":"e0768e081488da5ee6ee2efd2facd14d1565bb21","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public String getTableName() {\n    HTableDescriptor tableDesc = this.region.getTableDesc();\n    if (tableDesc == null) {\n      return \"\";\n    }\n    return tableDesc.getTableName().getNameAsString();\n  }","id":102335,"modified_method":"@Override\n  public String getTableName() {\n    HTableDescriptor tableDesc = this.region.getTableDesc();\n    if (tableDesc == null) {\n      return UNKNOWN;\n    }\n    return tableDesc.getTableName().getQualifierAsString();\n  }","commit_id":"e0768e081488da5ee6ee2efd2facd14d1565bb21","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public String getRegionName() {\n    HRegionInfo regionInfo = this.region.getRegionInfo();\n    if (regionInfo == null) {\n      return \"\";\n    }\n    return regionInfo.getEncodedName();\n  }","id":102336,"modified_method":"@Override\n  public String getRegionName() {\n    HRegionInfo regionInfo = this.region.getRegionInfo();\n    if (regionInfo == null) {\n      return UNKNOWN;\n    }\n    return regionInfo.getEncodedName();\n  }","commit_id":"e0768e081488da5ee6ee2efd2facd14d1565bb21","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public void incMethodTime(String name, long time) {\n    MutableStat s = getMetricsRegistry().newRate(name);\n    s.add(time);\n  }","id":102337,"modified_method":"@Override\n  public void incMethodTime(String name, long time) {\n    MutableHistogram s = getMetricsRegistry().getHistogram(name);\n    s.add(time);\n  }","commit_id":"e0768e081488da5ee6ee2efd2facd14d1565bb21","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public void init() {\n    super.init();\n    batchGetStat = getMetricsRegistry().newStat(BATCH_GET_KEY, \"\", \"Keys\", \"Ops\");\n    batchMutateStat = getMetricsRegistry().newStat(BATCH_MUTATE_KEY, \"\", \"Keys\", \"Ops\");\n    queueTimeStat = getMetricsRegistry().newRate(TIME_IN_QUEUE_KEY);\n\n    thriftCallStat = getMetricsRegistry().newRate(THRIFT_CALL_KEY);\n    thriftSlowCallStat = getMetricsRegistry().newRate(SLOW_THRIFT_CALL_KEY);\n\n    callQueueLenGauge = getMetricsRegistry().getLongGauge(CALL_QUEUE_LEN_KEY, 0);\n\n  }","id":102338,"modified_method":"@Override\n  public void init() {\n    super.init();\n    batchGetStat = getMetricsRegistry().newHistogram(BATCH_GET_KEY);\n    batchMutateStat = getMetricsRegistry().newHistogram(BATCH_MUTATE_KEY);\n    queueTimeStat = getMetricsRegistry().newHistogram(TIME_IN_QUEUE_KEY);\n    thriftCallStat = getMetricsRegistry().newHistogram(THRIFT_CALL_KEY);\n    thriftSlowCallStat = getMetricsRegistry().newHistogram(SLOW_THRIFT_CALL_KEY);\n    callQueueLenGauge = getMetricsRegistry().getLongGauge(CALL_QUEUE_LEN_KEY, 0);\n\n  }","commit_id":"e0768e081488da5ee6ee2efd2facd14d1565bb21","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public void init() {\n    super.init();\n    batchGetStat = getMetricsRegistry().newStat(BATCH_GET_KEY, \"\", \"Keys\", \"Ops\");\n    batchMutateStat = getMetricsRegistry().newStat(BATCH_MUTATE_KEY, \"\", \"Keys\", \"Ops\");\n    queueTimeStat = getMetricsRegistry().newStat(TIME_IN_QUEUE_KEY);\n    thriftCallStat = getMetricsRegistry().newStat(THRIFT_CALL_KEY);\n    thriftSlowCallStat = getMetricsRegistry().newStat(SLOW_THRIFT_CALL_KEY);\n    callQueueLenGauge = getMetricsRegistry().getLongGauge(CALL_QUEUE_LEN_KEY, 0);\n  }","id":102339,"modified_method":"@Override\n  public void init() {\n    super.init();\n    batchGetStat = getMetricsRegistry().newHistogram(BATCH_GET_KEY);\n    batchMutateStat = getMetricsRegistry().newHistogram(BATCH_MUTATE_KEY);\n    queueTimeStat = getMetricsRegistry().newHistogram(TIME_IN_QUEUE_KEY);\n    thriftCallStat = getMetricsRegistry().newHistogram(THRIFT_CALL_KEY);\n    thriftSlowCallStat = getMetricsRegistry().newHistogram(SLOW_THRIFT_CALL_KEY);\n    callQueueLenGauge = getMetricsRegistry().getLongGauge(CALL_QUEUE_LEN_KEY, 0);\n  }","commit_id":"e0768e081488da5ee6ee2efd2facd14d1565bb21","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public void incMethodTime(String name, long time) {\n    MetricMutableStat s = getMetricsRegistry().newStat(name);\n    s.add(time);\n  }","id":102340,"modified_method":"@Override\n  public void incMethodTime(String name, long time) {\n    MetricMutableHistogram s = getMetricsRegistry().getHistogram(name);\n    s.add(time);\n  }","commit_id":"e0768e081488da5ee6ee2efd2facd14d1565bb21","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testRegionWrapperMetrics() {\n    MetricsRegion mr = new MetricsRegion(new MetricsRegionWrapperStub());\n    MetricsRegionAggregateSource agg = mr.getSource().getAggregateSource();\n\n    HELPER.assertGauge(\"table.MetricsRegionWrapperStub.region.DEADBEEF001.storeCount\", 101, agg);\n    HELPER.assertGauge(\"table.MetricsRegionWrapperStub.region.DEADBEEF001.storeFileCount\", 102, agg);\n    HELPER.assertGauge(\"table.MetricsRegionWrapperStub.region.DEADBEEF001.memstoreSize\", 103, agg);\n    mr.close();\n  }","id":102341,"modified_method":"@Test\n  public void testRegionWrapperMetrics() {\n    MetricsRegion mr = new MetricsRegion(new MetricsRegionWrapperStub());\n    MetricsRegionAggregateSource agg = mr.getSource().getAggregateSource();\n\n    HELPER.assertGauge(\"namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001_metric_storeCount\", 101, agg);\n    HELPER.assertGauge(\"namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001_metric_storeFileCount\", 102, agg);\n    HELPER.assertGauge(\"namespace_TestNS_table_MetricsRegionWrapperStub_region_DEADBEEF001_metric_memstoreSize\", 103, agg);\n    mr.close();\n  }","commit_id":"e0768e081488da5ee6ee2efd2facd14d1565bb21","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testScanNext() throws IOException {\n    String tableNameString = \"testScanNext\";\n    byte[] tableName = Bytes.toBytes(tableNameString);\n    byte[] cf = Bytes.toBytes(\"d\");\n    byte[] qualifier = Bytes.toBytes(\"qual\");\n    byte[] val = Bytes.toBytes(\"One\");\n\n\n    TEST_UTIL.createTable(tableName, cf);\n    HTable t = new HTable(conf, tableName);\n    t.setAutoFlush(false, true);\n    for (int insertCount =0; insertCount < 100; insertCount++) {\n      Put p = new Put(Bytes.toBytes(\"\" + insertCount + \"row\"));\n      p.add(cf, qualifier, val);\n      t.put(p);\n    }\n    t.flushCommits();\n\n    Scan s = new Scan();\n    s.setBatch(1);\n    s.setCaching(1);\n    ResultScanner resultScanners = t.getScanner(s);\n\n    for (int nextCount = 0; nextCount < 30; nextCount++) {\n      Result result = resultScanners.next();\n      assertNotNull(result);\n      assertEquals(1, result.size());\n    }\n    for ( HRegionInfo i:t.getRegionLocations().keySet()) {\n      MetricsRegionAggregateSource agg = rs.getRegion(i.getRegionName())\n          .getMetrics()\n          .getSource()\n          .getAggregateSource();\n      String prefix = \"table.\"+tableNameString + \".region.\" + i.getEncodedName();\n      metricsHelper.assertCounter(prefix + \".scanNextNumOps\", 30, agg);\n    }\n  }","id":102342,"modified_method":"@Test\n  public void testScanNext() throws IOException {\n    String tableNameString = \"testScanNext\";\n    byte[] tableName = Bytes.toBytes(tableNameString);\n    byte[] cf = Bytes.toBytes(\"d\");\n    byte[] qualifier = Bytes.toBytes(\"qual\");\n    byte[] val = Bytes.toBytes(\"One\");\n\n\n    TEST_UTIL.createTable(tableName, cf);\n    HTable t = new HTable(conf, tableName);\n    t.setAutoFlush(false, true);\n    for (int insertCount =0; insertCount < 100; insertCount++) {\n      Put p = new Put(Bytes.toBytes(\"\" + insertCount + \"row\"));\n      p.add(cf, qualifier, val);\n      t.put(p);\n    }\n    t.flushCommits();\n\n    Scan s = new Scan();\n    s.setBatch(1);\n    s.setCaching(1);\n    ResultScanner resultScanners = t.getScanner(s);\n\n    for (int nextCount = 0; nextCount < 30; nextCount++) {\n      Result result = resultScanners.next();\n      assertNotNull(result);\n      assertEquals(1, result.size());\n    }\n    for ( HRegionInfo i:t.getRegionLocations().keySet()) {\n      MetricsRegionAggregateSource agg = rs.getRegion(i.getRegionName())\n          .getMetrics()\n          .getSource()\n          .getAggregateSource();\n      String prefix = \"namespace_\"+NamespaceDescriptor.DEFAULT_NAMESPACE_NAME_STR+\n          \"_table_\"+tableNameString +\n          \"_region_\" + i.getEncodedName()+\n          \"_metric\";\n      metricsHelper.assertCounter(prefix + \"_scanNextNumOps\", 30, agg);\n    }\n  }","commit_id":"e0768e081488da5ee6ee2efd2facd14d1565bb21","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testRequestCount() throws Exception {\n    String tableNameString = \"testRequestCount\";\n    byte[] tName = Bytes.toBytes(tableNameString);\n    byte[] cfName = Bytes.toBytes(\"d\");\n    byte[] row = Bytes.toBytes(\"rk\");\n    byte[] qualifier = Bytes.toBytes(\"qual\");\n    byte[] initValue = Bytes.toBytes(\"Value\");\n    byte[] nextValue = Bytes.toBytes(\"NEXT VAL\");\n\n\n    TEST_UTIL.createTable(tName, cfName);\n\n    new HTable(conf, tName).close(); //wait for the table to come up.\n    metricsRegionServer.getRegionServerWrapper().forceRecompute();\n    long requests = metricsHelper.getCounter(\"totalRequestCount\", serverSource);\n    long readRequests = metricsHelper.getCounter(\"readRequestCount\", serverSource);\n    long writeRequests = metricsHelper.getCounter(\"writeRequestCount\", serverSource);\n\n    HTable table = new HTable(conf, tName);\n\n    Put p = new Put(row);\n\n\n    p.add(cfName, qualifier, initValue);\n\n    for (int i=0; i< 30; i++) {\n      table.put(p);\n    }\n\n\n    table.flushCommits();\n\n    Get g = new Get(row);\n    for (int i=0; i< 10; i++) {\n      table.get(g);\n    }\n\n\n    for ( HRegionInfo i:table.getRegionLocations().keySet()) {\n      MetricsRegionAggregateSource agg = rs.getRegion(i.getRegionName())\n          .getMetrics()\n          .getSource()\n          .getAggregateSource();\n      String prefix = \"table.\"+tableNameString + \".region.\" + i.getEncodedName();\n      metricsHelper.assertCounter(prefix + \".getNumOps\", 10, agg);\n      metricsHelper.assertCounter(prefix + \".mutateCount\", 30, agg);\n    }\n\n\n    metricsRegionServer.getRegionServerWrapper().forceRecompute();\n    metricsHelper.assertCounterGt(\"totalRequestCount\", requests + 39, serverSource);\n    metricsHelper.assertCounterGt(\"readRequestCount\", readRequests + 9, serverSource);\n    metricsHelper.assertCounterGt(\"writeRequestCount\", writeRequests + 29, serverSource);\n\n    table.close();\n  }","id":102343,"modified_method":"@Test\n  public void testRequestCount() throws Exception {\n    String tableNameString = \"testRequestCount\";\n    byte[] tName = Bytes.toBytes(tableNameString);\n    byte[] cfName = Bytes.toBytes(\"d\");\n    byte[] row = Bytes.toBytes(\"rk\");\n    byte[] qualifier = Bytes.toBytes(\"qual\");\n    byte[] initValue = Bytes.toBytes(\"Value\");\n    byte[] nextValue = Bytes.toBytes(\"NEXT VAL\");\n\n\n    TEST_UTIL.createTable(tName, cfName);\n\n    new HTable(conf, tName).close(); //wait for the table to come up.\n    metricsRegionServer.getRegionServerWrapper().forceRecompute();\n    long requests = metricsHelper.getCounter(\"totalRequestCount\", serverSource);\n    long readRequests = metricsHelper.getCounter(\"readRequestCount\", serverSource);\n    long writeRequests = metricsHelper.getCounter(\"writeRequestCount\", serverSource);\n\n    HTable table = new HTable(conf, tName);\n\n    Put p = new Put(row);\n\n\n    p.add(cfName, qualifier, initValue);\n\n    for (int i=0; i< 30; i++) {\n      table.put(p);\n    }\n\n\n    table.flushCommits();\n\n    Get g = new Get(row);\n    for (int i=0; i< 10; i++) {\n      table.get(g);\n    }\n\n\n    for ( HRegionInfo i:table.getRegionLocations().keySet()) {\n      MetricsRegionAggregateSource agg = rs.getRegion(i.getRegionName())\n          .getMetrics()\n          .getSource()\n          .getAggregateSource();\n      String prefix = \"namespace_\"+NamespaceDescriptor.DEFAULT_NAMESPACE_NAME_STR+\n          \"_table_\"+tableNameString +\n          \"_region_\" + i.getEncodedName()+\n          \"_metric\";\n      metricsHelper.assertCounter(prefix + \"_getNumOps\", 10, agg);\n      metricsHelper.assertCounter(prefix + \"_mutateCount\", 30, agg);\n    }\n\n\n    metricsRegionServer.getRegionServerWrapper().forceRecompute();\n    metricsHelper.assertCounterGt(\"totalRequestCount\", requests + 39, serverSource);\n    metricsHelper.assertCounterGt(\"readRequestCount\", readRequests + 9, serverSource);\n    metricsHelper.assertCounterGt(\"writeRequestCount\", writeRequests + 29, serverSource);\n\n    table.close();\n  }","commit_id":"e0768e081488da5ee6ee2efd2facd14d1565bb21","url":"https://github.com/apache/hbase"},{"original_method":"/**\n     * Overridden to add the initialization javascript for the auto completer.\n     */\n    public void appendToResponse(WOResponse res, WOContext ctx) {\n        super.appendToResponse(res, ctx);\n\t\tboolean isLocal = hasBinding(\"isLocal\") && ((Boolean) valueForBinding(\"isLocal\")).booleanValue();\n\t\tif (isLocal) {\n\t\t\tStringBuffer str = new StringBuffer();\n\t\t\tstr.append(\"<script type=\\\"text/javascript\\\">\\n// <![CDATA[\\n\");\n\t\t\tstr.append(\"new Autocompleter.Local('\");\n\t\t\tstr.append(fieldName);\n\t\t\tstr.append(\"','\");\n\t\t\tstr.append(divName);\n\t\t\tstr.append(\"',\");\n\t\t\tstr.append(\"new Array(\");\n\t\t\tNSArray list = (NSArray) valueForBinding(\"list\");\n\t\t\tint max = list.count();\n\t\t\tString cnt = \"\";\n\t\t\tboolean hasItem = hasBinding(\"item\");\n\t\t\tfor (int i = 0; i < max; i++) {\n\t\t\t\tObject ds = list.objectAtIndex(i);\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tstr.append(\",\");\n\t\t\t\t}\n\t\t\t\tstr.append(\"\\n\\\"\");\n\t\t\t\tif (hasItem) {\n                    setValueForBinding(ds, \"item\");\n             \t}\n            \tObject displayValue = valueForBinding(\"displayString\", valueForBinding(\"item\", ds));\n\t\t\t\tstr.append(displayValue.toString());\n\t\t\t\t// TODO: We should escape the javascript string delimiter (\") to keep the javascript interpreter happy.\n\t\t\t\t//str.append(displayValue.toString().replaceAll(\"\\\"\", \"\\\\\\\\\\\\\\\\\\\"\")); // doesn't work\n\n\t\t\t\tstr.append(cnt);\n\t\t\t\tstr.append(\"\\\"\");\n\t\t\t}\n\t\t\tstr.append(\"),\");\n\t\t\tAjaxOptions.appendToBuffer(createAjaxOptions(), str, ctx);\n\t\t\tstr.append(\");\\n// ]]>\\n<\/script>\\n\");\n\t\t\tres.appendContentString(String.valueOf(str));\n\t\t} else {\n\t\t\tString actionUrl = AjaxUtils.ajaxComponentActionUrl(ctx);\n      AjaxUtils.appendScriptHeader(res);\n\t\t\tres.appendContentString(\"new Ajax.Autocompleter('\"+fieldName+\"', '\"+divName+\"', '\"+actionUrl+\"', \");\n\t\t\tAjaxOptions.appendToResponse(createAjaxOptions(), res, ctx);\n\t\t\tres.appendContentString(\");\");\n      AjaxUtils.appendScriptFooter(res);\n\t\t}\n    }","id":102344,"modified_method":"/**\n     * Overridden to add the initialization javascript for the auto completer.\n     */\n    public void appendToResponse(WOResponse res, WOContext ctx) {\n        super.appendToResponse(res, ctx);\n\t\tboolean isDisabled = hasBinding(\"disabled\") && ((Boolean) valueForBinding(\"disabled\")).booleanValue();\n\t\tif ( !isDisabled ) {\n\t\t\tboolean isLocal = hasBinding(\"isLocal\") && ((Boolean) valueForBinding(\"isLocal\")).booleanValue();\n\t\t\tif (isLocal) {\n\t\t\t\tStringBuffer str = new StringBuffer();\n\t\t\t\tboolean isLocalSharedList = hasBinding(\"isLocalSharedList\") && ((Boolean) valueForBinding(\"isLocalSharedList\")).booleanValue();\n\t\t\t\tString listJS = null;\n\t\t\t\tif (isLocalSharedList) {\n\t\t\t\t\tString varName = (String) valueForBinding(\"localSharedVarName\");\n\t\t\t\t\tNSMutableDictionary userInfo = AjaxUtils.mutableUserInfo(res);\n\t\t\t\t\tif (userInfo.objectForKey(varName) == null) {\n\t\t\t\t\t\tString ljs = listeJS();\n\t\t\t\t\t\tAjaxUtils.addScriptCodeInHead(res, \"var \" + varName + \" = \" + ljs + \";\");\n\t\t\t\t\t\tuserInfo.setObjectForKey(ljs, varName);\n\t\t\t\t\t}\n\t\t\t\t\tlistJS = varName;\n\t\t\t\t} else {\n\t\t\t\t\tlistJS = listeJS();\n\t\t\t\t}\n\t\t\t\tstr.append(\"<script type=\\\"text/javascript\\\">\\n// <![CDATA[\\n\");\n\t\t\t\tstr.append(\"new Autocompleter.Local('\");\n\t\t\t\tstr.append(fieldName);\n\t\t\t\tstr.append(\"','\");\n\t\t\t\tstr.append(divName);\n\t\t\t\tstr.append(\"',\");\n\t\t\t\tstr.append(listJS);\n\t\t\t\tstr.append(\",\");\n\t\t\t\tAjaxOptions.appendToBuffer(createAjaxOptions(), str, ctx);\n\t\t\t\tstr.append(\");\\n// ]]>\\n<\/script>\\n\");\n\t\t\t\tres.appendContentString(String.valueOf(str));\n\t\t\t} else {\n\t\t\t\tString actionUrl = AjaxUtils.ajaxComponentActionUrl(ctx);\n\t\t\t\tAjaxUtils.appendScriptHeader(res);\n\t\t\t\tres.appendContentString(\"new Ajax.Autocompleter('\"+fieldName+\"', '\"+divName+\"', '\"+actionUrl+\"', \");\n\t\t\t\tAjaxOptions.appendToResponse(createAjaxOptions(), res, ctx);\n\t\t\t\tres.appendContentString(\");\");\n\t\t\t\tAjaxUtils.appendScriptFooter(res);\n\t\t\t}\n\t\t}\n    }","commit_id":"04e57334f334b78d90c11df7ee847bc589482265","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Adds all required resources.\n     */\n    protected void addRequiredWebResources(WOResponse res) {\n        addScriptResourceInHead(res, \"prototype.js\");\n        addScriptResourceInHead(res, \"scriptaculous.js\");\n        addScriptResourceInHead(res, \"wonder.js\");\n    }","id":102345,"modified_method":"/**\n     * Adds all required resources.\n     */\n    protected void addRequiredWebResources(WOResponse res) {\n\t\tboolean isDisabled = hasBinding(\"disabled\") && ((Boolean) valueForBinding(\"disabled\")).booleanValue();\n\t\tif ( !isDisabled ) {\n\t\t\taddScriptResourceInHead(res, \"prototype.js\");\n\t\t\taddScriptResourceInHead(res, \"scriptaculous.js\");\n\t\t\taddScriptResourceInHead(res, \"effects.js\");\n\t\t\taddScriptResourceInHead(res, \"builder.js\");\n\t\t\taddScriptResourceInHead(res, \"dragdrop.js\");\n\t\t\taddScriptResourceInHead(res, \"controls.js\");\n\t\t\taddScriptResourceInHead(res, \"wonder.js\");\n\t\t}\n    }","commit_id":"04e57334f334b78d90c11df7ee847bc589482265","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Function to update the main update container\n\t * \n\t * @return String\n\t */\n\tpublic String refreshContainerFunction() {\n\t\treturn updateContainerID() + \"Update()\";\n\t}","id":102346,"modified_method":"/**\n\t * Function to update the main update container\n\t * \n\t * @return String\n\t */\n\tpublic String refreshContainerFunction() {\n\t\treturn updateContainerID() + \"Update();\";\n\t}","commit_id":"84e22e9e468ab4f7b98b1b3153ff51d98543c2d1","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Getter for the masterObject\n\t * \n\t * @return the masterObject\n\t */\n\tpublic EOEnterpriseObject masterObject() {\n\t\tif (_masterObject == null) {\n\t\t\t_masterObject = (EOEnterpriseObject)valueForBinding(Keys.masterObject);\n\t\t}\n\t\treturn _masterObject;\n\t}","id":102347,"modified_method":"/**\n\t * Getter for the masterObject\n\t * \n\t * @return the masterObject\n\t */\n\tpublic EOEnterpriseObject masterObject() {\n\t\treturn (EOEnterpriseObject)valueForBinding(Keys.masterObject);\n\t}","commit_id":"84e22e9e468ab4f7b98b1b3153ff51d98543c2d1","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Action called when an upload succeeds\n\t * \n\t * @return results of the \n\t */\n\tpublic WOActionResults uploadSucceededAction() {\n\t\t\n\t\tattachmentEC().saveChanges();\n\t\t\n\t\tERAttachment existing = (ERAttachment)localParent().valueForKey(relationshipKey());\n\t\tif (existing != null) {\n\t\t\tworkingEC().deleteObject(existing);\n\t\t}\n\t\t// CHECKME ^^^^ Should I be doing this?\n\t\t\n\t\tERAttachment newLocalAttachment = newAttachment().localInstanceIn(workingEC());\n\t\tlocalParent().addObjectToBothSidesOfRelationshipWithKey(newLocalAttachment, relationshipKey());\n\n\t\tworkingEC().saveChanges();\n\t\t_showUpload = false;\n\t\treturn (WOActionResults)valueForBinding(Keys.uploadSucceededAction);\n\t}","id":102348,"modified_method":"/**\n\t * Action called when an upload succeeds\n\t * \n\t * @return results of the \n\t */\n\tpublic WOActionResults uploadSucceededAction() {\n\t\t\n\t\tattachmentEC().saveChanges();\n\n\t\tEOEnterpriseObject localObj = (EOEnterpriseObject)EOUtilities.localInstanceOfObject(workingEC(), masterObject());\n\t\tif (localObj instanceof ERXGenericRecord) {\n\t\t\t((ERXGenericRecord)localObj).setValidatedWhenNested(false);\n\t\t}\n\t\t\n\t\tERAttachment existing = (ERAttachment)localObj.valueForKey(relationshipKey());\n\t\t\n\t\tif (existing != null) {\n\t\t\tworkingEC().deleteObject(existing.localInstanceIn(workingEC()));\n\t\t}\n\t\t\n\t\tEOEnterpriseObject localAttachment = (EOEnterpriseObject)EOUtilities.localInstanceOfObject(workingEC(), newAttachment());\n\t\t\n\t\tlocalObj.addObjectToBothSidesOfRelationshipWithKey(localAttachment, relationshipKey());\n\t\t\n\t\tworkingEC().saveChanges();\n\t\t\n\t\t_showUpload = false;\n\t\treturn (WOActionResults)valueForBinding(Keys.uploadSucceededAction);\n\t}","commit_id":"84e22e9e468ab4f7b98b1b3153ff51d98543c2d1","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Getter for the relationhipKey\n\t * \n\t * @return the relationshipKey\n\t */\n\tpublic String relationshipKey() {\n\t\tif (_relationshipKey == null) {\n\t\t\t_relationshipKey = stringValueForBinding(Keys.relationshipKey);\n\t\t}\n\t\treturn _relationshipKey;\n\t}","id":102349,"modified_method":"/**\n\t * Getter for the relationhipKey\n\t * \n\t * @return the relationshipKey\n\t */\n\tpublic String relationshipKey() {\n\t\treturn stringValueForBinding(Keys.relationshipKey);\n\t}","commit_id":"84e22e9e468ab4f7b98b1b3153ff51d98543c2d1","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String headerString() {\n    \tif (_headerString == null) {\n\t\t\t_headerString = stringValueForBinding(Keys.displayNameForPageConfiguration);;\n\t\t}\n\t\treturn _headerString;\n    }","id":102350,"modified_method":"public String headerString() {\n\t\t\treturn stringValueForBinding(Keys.displayNameForPageConfiguration);\n    }","commit_id":"11e23be68a75ea59dd0de677540a4bc1428ad57e","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n\tpublic JvmTypeReference getTypeForIdentifiable(JvmIdentifiableElement identifiableElement, boolean rawType) {\n\t\treturn getResolvedTypes(identifiableElement).getActualType(identifiableElement).toTypeReference();\n\t}","id":102351,"modified_method":"@Override\n\tpublic JvmTypeReference getTypeForIdentifiable(JvmIdentifiableElement identifiableElement, boolean rawType) {\n\t\treturn getTypeForIdentifiable(identifiableElement);\n\t}","commit_id":"da555d8242ebbb6f6d5e5871729c2f72d5794590","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic JvmTypeReference getTypeForIdentifiable(JvmIdentifiableElement identifiableElement) {\n\t\treturn getResolvedTypes(identifiableElement).getActualType(identifiableElement).toTypeReference();\n\t}","id":102352,"modified_method":"@Override\n\tpublic JvmTypeReference getTypeForIdentifiable(JvmIdentifiableElement identifiableElement) {\n\t\tLightweightTypeReference actualType = getResolvedTypes(identifiableElement).getActualType(identifiableElement);\n\t\tif (actualType == null)\n\t\t\treturn null;\n\t\treturn actualType.toTypeReference();\n\t}","commit_id":"da555d8242ebbb6f6d5e5871729c2f72d5794590","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    public boolean equals(Object obj) {\n        return getActualType().equals(obj);\n    }","id":102353,"modified_method":"@Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        JetType actualType = getActualType();\n        if (actualType == obj) return true;\n\n        if (!(obj instanceof JetType)) return false;\n\n        return TypeUtils.equalTypes(actualType, (JetType) obj);\n    }","commit_id":"9d248d5c4a5901be5a265ec226d16569017ef83f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        JetTypeImpl type = (JetTypeImpl) o;\n\n        return nullable == type.nullable && JetTypeChecker.INSTANCE.equalTypes(this, type);\n    }","id":102354,"modified_method":"@Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof JetType)) return false;\n\n        JetType type = (JetType) o;\n\n        return nullable == type.isNullable() && JetTypeChecker.INSTANCE.equalTypes(this, type);\n    }","commit_id":"9d248d5c4a5901be5a265ec226d16569017ef83f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void assistSessionStarted(ContentAssistEvent event) {\n\t\tgetModeAwareProposalProvider().reset();\n\t\tthis.currentAssistant = (IContentAssistantExtension2) event.assistant;\n\t}","id":102355,"modified_method":"public void assistSessionStarted(ContentAssistEvent event) {\n\t\tModeAware proposalProvider = getModeAwareProposalProvider();\n\t\tif (proposalProvider != null)\n\t\t\tproposalProvider.reset();\n\t\tthis.currentAssistant = (IContentAssistantExtension2) event.assistant;\n\t}","commit_id":"d53476d16433b5f17199c13d095ad87395925e94","url":"https://github.com/eclipse/xtext"},{"original_method":"public void assistSessionRestarted(ContentAssistEvent event) {\n\t\tgetModeAwareProposalProvider().reset();\n\t}","id":102356,"modified_method":"public void assistSessionRestarted(ContentAssistEvent event) {\n\t\tModeAware proposalProvider = getModeAwareProposalProvider();\n\t\tif (proposalProvider != null)\n\t\t\tproposalProvider.reset();\n\t}","commit_id":"d53476d16433b5f17199c13d095ad87395925e94","url":"https://github.com/eclipse/xtext"},{"original_method":"public void assistSessionEnded(ContentAssistEvent event) {\n\t\tgetModeAwareProposalProvider().reset();\n\t\tthis.currentAssistant = null;\n\t}","id":102357,"modified_method":"public void assistSessionEnded(ContentAssistEvent event) {\n\t\tModeAware proposalProvider = getModeAwareProposalProvider();\n\t\tif (proposalProvider != null)\n\t\t\tproposalProvider.reset();\n\t\tthis.currentAssistant = null;\n\t}","commit_id":"d53476d16433b5f17199c13d095ad87395925e94","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, int offset) {\n\t\tModeAware proposalProvider = getModeAwareProposalProvider();\n\t\tint i = 0;\n\t\twhile(i++ < 1000) { // just to prevent endless loop in case #isLastMode has an error\n\t\t\tproposalProvider.nextMode();\n\t\t\tif (currentAssistant != null)\n\t\t\t\tcurrentAssistant.setStatusMessage(getStatusMessage());\n\t\t\tICompletionProposal[] result = super.computeCompletionProposals(viewer, offset);\n\t\t\tif (result != null && result.length > 0)\n\t\t\t\treturn result;\n\t\t\tif (proposalProvider.isLastMode()) {\n\t\t\t\treturn new ICompletionProposal[0];\t\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalStateException(\"#isLastMode did not return true for 1000 times\");\n\t}","id":102358,"modified_method":"@Override\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, int offset) {\n\t\tModeAware proposalProvider = getModeAwareProposalProvider();\n\t\tif (proposalProvider == null)\n\t\t\treturn new ICompletionProposal[0];\n\t\tint i = 0;\n\t\twhile(i++ < 1000) { // just to prevent endless loop in case #isLastMode has an error\n\t\t\tproposalProvider.nextMode();\n\t\t\tif (currentAssistant != null)\n\t\t\t\tcurrentAssistant.setStatusMessage(getStatusMessage());\n\t\t\tICompletionProposal[] result = super.computeCompletionProposals(viewer, offset);\n\t\t\tif (result != null && result.length > 0)\n\t\t\t\treturn result;\n\t\t\tif (proposalProvider.isLastMode()) {\n\t\t\t\treturn new ICompletionProposal[0];\t\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalStateException(\"#isLastMode did not return true for 1000 times\");\n\t}","commit_id":"d53476d16433b5f17199c13d095ad87395925e94","url":"https://github.com/eclipse/xtext"},{"original_method":"public static boolean writeFileKey(\n\t\tfinal Path filePath, final String fileKey) {\n\n\t\tif (getFileKey(filePath) == Long.parseLong(fileKey)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (Files.isDirectory(filePath)) {\n\t\t\tdoWriteFileKey(filePath, fileKey);\n\n\t\t\treturn true;\n\t\t}\n\n\t\tPathCallable pathCallable = new PathCallable(filePath) {\n\n\t\t\t@Override\n\t\t\tpublic Object call() throws Exception {\n\t\t\t\tdoWriteFileKey(filePath, fileKey);\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t};\n\n\t\tFileLockRetryUtil.registerPathCallable(pathCallable);\n\n\t\treturn true;\n\t}","id":102359,"modified_method":"public static void writeFileKey(final Path filePath, final String fileKey) {\n\t\tif (hasFileKey(filePath, Long.parseLong(fileKey))) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (Files.isDirectory(filePath)) {\n\t\t\tdoWriteFileKey(filePath, fileKey);\n\n\t\t\treturn;\n\t\t}\n\n\t\tPathCallable pathCallable = new PathCallable(filePath) {\n\n\t\t\t@Override\n\t\t\tpublic Object call() throws Exception {\n\t\t\t\tdoWriteFileKey(filePath, fileKey);\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t};\n\n\t\tFileLockRetryUtil.registerPathCallable(pathCallable);\n\t}","commit_id":"18c9066902ac9758a70496bdeb55cffa2e99ac35","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void doWriteFileKey(Path filePath, String fileKey) {\n\t\tif (getFileKey(filePath) == Long.parseLong(fileKey)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (OSDetector.isApple()) {\n\t\t\tXattrj xattrj = getXattrj();\n\n\t\t\tif (xattrj == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tFile file = filePath.toFile();\n\n\t\t\tif (!file.canWrite()) {\n\t\t\t\tfile.setWritable(true);\n\t\t\t}\n\n\t\t\txattrj.writeAttribute(file, \"fileKey\", fileKey);\n\t\t}\n\t\telse {\n\t\t\tFile file = filePath.toFile();\n\n\t\t\tif (!file.canWrite()) {\n\t\t\t\tfile.setWritable(true);\n\t\t\t}\n\n\t\t\tUserDefinedFileAttributeView userDefinedFileAttributeView =\n\t\t\t\tFiles.getFileAttributeView(\n\t\t\t\t\tfilePath, UserDefinedFileAttributeView.class);\n\n\t\t\ttry {\n\t\t\t\tuserDefinedFileAttributeView.write(\n\t\t\t\t\t\"fileKey\", _CHARSET.encode(CharBuffer.wrap(fileKey)));\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_logger.error(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}","id":102360,"modified_method":"protected static void doWriteFileKey(Path filePath, String fileKey) {\n\t\tif (hasFileKey(filePath, Long.parseLong(fileKey))) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (OSDetector.isApple()) {\n\t\t\tXattrj xattrj = getXattrj();\n\n\t\t\tif (xattrj == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tFile file = filePath.toFile();\n\n\t\t\tif (!file.canWrite()) {\n\t\t\t\tfile.setWritable(true);\n\t\t\t}\n\n\t\t\txattrj.writeAttribute(file, \"fileKey\", fileKey);\n\t\t}\n\t\telse {\n\t\t\tFile file = filePath.toFile();\n\n\t\t\tif (!file.canWrite()) {\n\t\t\t\tfile.setWritable(true);\n\t\t\t}\n\n\t\t\tUserDefinedFileAttributeView userDefinedFileAttributeView =\n\t\t\t\tFiles.getFileAttributeView(\n\t\t\t\t\tfilePath, UserDefinedFileAttributeView.class);\n\n\t\t\ttry {\n\t\t\t\tuserDefinedFileAttributeView.write(\n\t\t\t\t\t\"fileKey\", _CHARSET.encode(CharBuffer.wrap(fileKey)));\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_logger.error(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"18c9066902ac9758a70496bdeb55cffa2e99ac35","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void moveFile(\n\t\tfinal Path sourceFilePath, final Path targetFilePath) {\n\n\t\ttry {\n\t\t\tcheckFilePath(sourceFilePath);\n\n\t\t\tFiles.move(\n\t\t\t\tsourceFilePath, targetFilePath,\n\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tPathCallable pathCallable = new PathCallable(sourceFilePath) {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\tFileTime fileTime = Files.getLastModifiedTime(\n\t\t\t\t\t\ttargetFilePath);\n\n\t\t\t\t\tif (fileTime.toMillis() <= getStartTime()) {\n\t\t\t\t\t\tFiles.move(\n\t\t\t\t\t\t\tsourceFilePath, targetFilePath,\n\t\t\t\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tFiles.deleteIfExists(sourceFilePath);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tFileLockRetryUtil.registerPathCallable(pathCallable);\n\t\t}\n\t}","id":102361,"modified_method":"public static void moveFile(Path sourceFilePath, Path targetFilePath) {\n\t\ttry {\n\t\t\tmoveFile(sourceFilePath, targetFilePath, true);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\t}","commit_id":"18c9066902ac9758a70496bdeb55cffa2e99ac35","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean isModified(SyncFile syncFile, Path filePath) {\n\t\tif (filePath == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\ttry {\n\t\t\tFileTime fileTime = Files.getLastModifiedTime(filePath);\n\n\t\t\tlong modifiedTime = syncFile.getModifiedTime();\n\n\t\t\tif (OSDetector.isUnix()) {\n\t\t\t\tmodifiedTime = modifiedTime / 1000 * 1000;\n\t\t\t}\n\n\t\t\tif ((fileTime.toMillis() <= modifiedTime) &&\n\t\t\t\t(FileKeyUtil.getFileKey(filePath) ==\n\t\t\t\t\tsyncFile.getSyncFileId())) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(ioe.getMessage(), ioe);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif ((syncFile.getSize() > 0) &&\n\t\t\t\t(syncFile.getSize() != Files.size(filePath))) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(ioe.getMessage(), ioe);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tString checksum = getChecksum(filePath);\n\n\t\t\treturn !checksumsEqual(checksum, syncFile.getChecksum());\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(ioe.getMessage(), ioe);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}","id":102362,"modified_method":"public static boolean isModified(SyncFile syncFile, Path filePath) {\n\t\tif (filePath == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\ttry {\n\t\t\tFileTime fileTime = Files.getLastModifiedTime(filePath);\n\n\t\t\tlong modifiedTime = syncFile.getModifiedTime();\n\n\t\t\tif (OSDetector.isUnix()) {\n\t\t\t\tmodifiedTime = modifiedTime / 1000 * 1000;\n\t\t\t}\n\n\t\t\tif ((fileTime.toMillis() <= modifiedTime) &&\n\t\t\t\tFileKeyUtil.hasFileKey(filePath, syncFile.getSyncFileId())) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(ioe.getMessage(), ioe);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif ((syncFile.getSize() > 0) &&\n\t\t\t\t(syncFile.getSize() != Files.size(filePath))) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(ioe.getMessage(), ioe);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tString checksum = getChecksum(filePath);\n\n\t\t\treturn !checksumsEqual(checksum, syncFile.getChecksum());\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(ioe.getMessage(), ioe);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}","commit_id":"18c9066902ac9758a70496bdeb55cffa2e99ac35","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteFile(final Path filePath) {\n\t\ttry {\n\t\t\tFiles.deleteIfExists(filePath);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tPathCallable pathCallable = new PathCallable(filePath) {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\tFileTime fileTime = Files.getLastModifiedTime(filePath);\n\n\t\t\t\t\tif (fileTime.toMillis() <= getStartTime()) {\n\t\t\t\t\t\tFiles.deleteIfExists(filePath);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tFileLockRetryUtil.registerPathCallable(pathCallable);\n\t\t}\n\t}","id":102363,"modified_method":"public static void deleteFile(Path filePath) {\n\t\ttry {\n\t\t\tdeleteFile(filePath, true);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\t}","commit_id":"18c9066902ac9758a70496bdeb55cffa2e99ac35","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void retryMissingSyncAccountFolder(\n\t\tfinal SyncAccount syncAccount) {\n\n\t\tif (_scheduledFuture != null) {\n\t\t\t_scheduledFuture.cancel(true);\n\t\t}\n\n\t\tRunnable runnable = new Runnable() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tPath filePath = Paths.get(syncAccount.getFilePathName());\n\n\t\t\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\t\t\tsyncAccount.getFilePathName());\n\n\t\t\t\tif (FileKeyUtil.getFileKey(filePath) ==\n\t\t\t\t\t\tsyncFile.getSyncFileId()) {\n\n\t\t\t\t\tsyncAccount.setActive(true);\n\t\t\t\t\tsyncAccount.setUiEvent(SyncAccount.UI_EVENT_NONE);\n\n\t\t\t\t\tSyncAccountService.update(syncAccount);\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t\t_scheduledFuture = _scheduledExecutorService.scheduleAtFixedRate(\n\t\t\trunnable, 0, 5, TimeUnit.SECONDS);\n\t}","id":102364,"modified_method":"protected void retryMissingSyncAccountFolder(\n\t\tfinal SyncAccount syncAccount) {\n\n\t\tif (_scheduledFuture != null) {\n\t\t\t_scheduledFuture.cancel(true);\n\t\t}\n\n\t\tRunnable runnable = new Runnable() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tPath filePath = Paths.get(syncAccount.getFilePathName());\n\n\t\t\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\t\t\tsyncAccount.getFilePathName());\n\n\t\t\t\tif (FileKeyUtil.hasFileKey(\n\t\t\t\t\t\tfilePath, syncFile.getSyncFileId())) {\n\n\t\t\t\t\tsyncAccount.setActive(true);\n\t\t\t\t\tsyncAccount.setUiEvent(SyncAccount.UI_EVENT_NONE);\n\n\t\t\t\t\tSyncAccountService.update(syncAccount);\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t\t_scheduledFuture = _scheduledExecutorService.scheduleAtFixedRate(\n\t\t\trunnable, 0, 5, TimeUnit.SECONDS);\n\t}","commit_id":"18c9066902ac9758a70496bdeb55cffa2e99ac35","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void updateSyncAccountSyncFile(\n\t\t\tPath filePath, long syncAccountId, boolean moveFile)\n\t\tthrows Exception {\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tsyncAccountId);\n\n\t\tif (!moveFile) {\n\t\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\t\tsyncAccount.getFilePathName());\n\n\t\t\tif (syncFile.getSyncFileId() != FileKeyUtil.getFileKey(filePath)) {\n\t\t\t\tthrow new Exception(\n\t\t\t\t\t\"Target folder is not the moved sync data folder\");\n\t\t\t}\n\t\t}\n\n\t\tsyncAccount.setActive(false);\n\n\t\tSyncAccountService.update(syncAccount);\n\n\t\tif (moveFile) {\n\t\t\ttry {\n\t\t\t\tFiles.createDirectories(filePath);\n\n\t\t\t\tFiles.move(\n\t\t\t\t\tPaths.get(syncAccount.getFilePathName()), filePath,\n\t\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tsyncAccount.setActive(true);\n\n\t\t\t\tSyncAccountService.update(syncAccount);\n\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\n\t\tsyncAccount = setFilePathName(syncAccountId, filePath.toString());\n\n\t\tsyncAccount.setActive(true);\n\t\tsyncAccount.setUiEvent(SyncAccount.UI_EVENT_NONE);\n\n\t\tSyncAccountService.update(syncAccount);\n\t}","id":102365,"modified_method":"public static void updateSyncAccountSyncFile(\n\t\t\tPath targetFilePath, long syncAccountId, boolean moveFile)\n\t\tthrows Exception {\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tsyncAccountId);\n\n\t\tif (!moveFile) {\n\t\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\t\tsyncAccount.getFilePathName());\n\n\t\t\tif (!FileKeyUtil.hasFileKey(\n\t\t\t\t\ttargetFilePath, syncFile.getSyncFileId())) {\n\n\t\t\t\tthrow new Exception(\n\t\t\t\t\t\"Target folder is not the moved sync data folder\");\n\t\t\t}\n\t\t}\n\n\t\tsyncAccount.setActive(false);\n\n\t\tSyncAccountService.update(syncAccount);\n\n\t\tboolean resetFileKeys = false;\n\n\t\tif (moveFile) {\n\t\t\tPath sourceFilePath = Paths.get(syncAccount.getFilePathName());\n\n\t\t\ttry {\n\t\t\t\tFileUtil.moveFile(sourceFilePath, targetFilePath, false);\n\t\t\t}\n\t\t\tcatch (Exception e1) {\n\t\t\t\ttry {\n\t\t\t\t\tFileUtils.moveDirectory(\n\t\t\t\t\t\tsourceFilePath.toFile(), targetFilePath.toFile());\n\n\t\t\t\t\tresetFileKeys = true;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e2) {\n\t\t\t\t\tsyncAccount.setActive(true);\n\n\t\t\t\t\tSyncAccountService.update(syncAccount);\n\n\t\t\t\t\tthrow e2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsyncAccount = setFilePathName(syncAccountId, targetFilePath.toString());\n\n\t\tif (resetFileKeys) {\n\t\t\tFileKeyUtil.writeFileKeys(targetFilePath);\n\t\t}\n\n\t\tsyncAccount.setActive(true);\n\t\tsyncAccount.setUiEvent(SyncAccount.UI_EVENT_NONE);\n\n\t\tSyncAccountService.update(syncAccount);\n\t}","commit_id":"18c9066902ac9758a70496bdeb55cffa2e99ac35","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void doScheduleSyncAccountTasks(long syncAccountId)\n\t\tthrows Exception {\n\n\t\tif (!_running) {\n\t\t\treturn;\n\t\t}\n\n\t\tSyncAccount syncAccount = ServerEventUtil.synchronizeSyncAccount(\n\t\t\tsyncAccountId);\n\n\t\tsyncAccount.setState(SyncAccount.STATE_CONNECTED);\n\t\tsyncAccount.setUiEvent(SyncAccount.UI_EVENT_NONE);\n\n\t\tSyncAccountService.update(syncAccount);\n\n\t\tPath filePath = Paths.get(syncAccount.getFilePathName());\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\tsyncAccount.getFilePathName());\n\n\t\tif (FileKeyUtil.getFileKey(filePath) != syncFile.getSyncFileId()) {\n\t\t\tsyncAccount.setActive(false);\n\t\t\tsyncAccount.setUiEvent(\n\t\t\t\tSyncAccount.UI_EVENT_SYNC_ACCOUNT_FOLDER_MISSING);\n\n\t\t\tSyncAccountService.update(syncAccount);\n\n\t\t\treturn;\n\t\t}\n\t\telse if (!syncAccount.isActive()) {\n\t\t\tSyncAccountService.activateSyncAccount(syncAccountId, false);\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncWatchEventService.deleteSyncWatchEvents(syncAccountId);\n\n\t\tPath dataFilePath = FileUtil.getFilePath(\n\t\t\tsyncAccount.getFilePathName(), \".data\");\n\n\t\tif (Files.exists(dataFilePath)) {\n\t\t\tFileUtils.cleanDirectory(dataFilePath.toFile());\n\t\t}\n\n\t\tif (!ConnectionRetryUtil.retryInProgress(syncAccountId)) {\n\t\t\tServerEventUtil.synchronizeSyncSites(syncAccountId);\n\t\t}\n\n\t\tSyncWatchEventProcessor syncWatchEventProcessor =\n\t\t\tnew SyncWatchEventProcessor(syncAccountId);\n\n\t\tScheduledFuture<?> scheduledFuture =\n\t\t\t_localEventsScheduledExecutorService.scheduleAtFixedRate(\n\t\t\t\tsyncWatchEventProcessor, 0, 3, TimeUnit.SECONDS);\n\n\t\tWatchEventListener watchEventListener = new SyncSiteWatchEventListener(\n\t\t\tsyncAccountId);\n\n\t\tWatcher watcher = null;\n\n\t\tif (OSDetector.isApple()) {\n\t\t\twatcher = new BarbaryWatcher(filePath, watchEventListener);\n\t\t}\n\t\telse {\n\t\t\twatcher = new JPathWatcher(filePath, watchEventListener);\n\t\t}\n\n\t\t_executorService.execute(watcher);\n\n\t\tif (!ConnectionRetryUtil.retryInProgress(syncAccountId)) {\n\t\t\tsynchronizeSyncFiles(filePath, syncAccountId);\n\t\t}\n\n\t\tscheduleGetSyncDLObjectUpdateEvent(\n\t\t\tsyncAccount, syncWatchEventProcessor, scheduledFuture, watcher);\n\t}","id":102366,"modified_method":"protected static void doScheduleSyncAccountTasks(long syncAccountId)\n\t\tthrows Exception {\n\n\t\tif (!_running) {\n\t\t\treturn;\n\t\t}\n\n\t\tSyncAccount syncAccount = ServerEventUtil.synchronizeSyncAccount(\n\t\t\tsyncAccountId);\n\n\t\tsyncAccount.setState(SyncAccount.STATE_CONNECTED);\n\t\tsyncAccount.setUiEvent(SyncAccount.UI_EVENT_NONE);\n\n\t\tSyncAccountService.update(syncAccount);\n\n\t\tPath filePath = Paths.get(syncAccount.getFilePathName());\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\tsyncAccount.getFilePathName());\n\n\t\tif (!FileKeyUtil.hasFileKey(filePath, syncFile.getSyncFileId())) {\n\t\t\tsyncAccount.setActive(false);\n\t\t\tsyncAccount.setUiEvent(\n\t\t\t\tSyncAccount.UI_EVENT_SYNC_ACCOUNT_FOLDER_MISSING);\n\n\t\t\tSyncAccountService.update(syncAccount);\n\n\t\t\treturn;\n\t\t}\n\t\telse if (!syncAccount.isActive()) {\n\t\t\tSyncAccountService.activateSyncAccount(syncAccountId, false);\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncWatchEventService.deleteSyncWatchEvents(syncAccountId);\n\n\t\tPath dataFilePath = FileUtil.getFilePath(\n\t\t\tsyncAccount.getFilePathName(), \".data\");\n\n\t\tif (Files.exists(dataFilePath)) {\n\t\t\tFileUtils.cleanDirectory(dataFilePath.toFile());\n\t\t}\n\n\t\tif (!ConnectionRetryUtil.retryInProgress(syncAccountId)) {\n\t\t\tServerEventUtil.synchronizeSyncSites(syncAccountId);\n\t\t}\n\n\t\tSyncWatchEventProcessor syncWatchEventProcessor =\n\t\t\tnew SyncWatchEventProcessor(syncAccountId);\n\n\t\tScheduledFuture<?> scheduledFuture =\n\t\t\t_localEventsScheduledExecutorService.scheduleAtFixedRate(\n\t\t\t\tsyncWatchEventProcessor, 0, 3, TimeUnit.SECONDS);\n\n\t\tWatchEventListener watchEventListener = new SyncSiteWatchEventListener(\n\t\t\tsyncAccountId);\n\n\t\tWatcher watcher = null;\n\n\t\tif (OSDetector.isApple()) {\n\t\t\twatcher = new BarbaryWatcher(filePath, watchEventListener);\n\t\t}\n\t\telse {\n\t\t\twatcher = new JPathWatcher(filePath, watchEventListener);\n\t\t}\n\n\t\t_executorService.execute(watcher);\n\n\t\tif (!ConnectionRetryUtil.retryInProgress(syncAccountId)) {\n\t\t\tsynchronizeSyncFiles(filePath, syncAccountId);\n\t\t}\n\n\t\tscheduleGetSyncDLObjectUpdateEvent(\n\t\t\tsyncAccount, syncWatchEventProcessor, scheduledFuture, watcher);\n\t}","commit_id":"18c9066902ac9758a70496bdeb55cffa2e99ac35","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private SimpleColoredText getClassPresentableName(JSClass clazz) {\n    int style = SimpleTextAttributes.STYLE_BOLD;\n    if (clazz.isDeprecated()) style |= SimpleTextAttributes.STYLE_STRIKEOUT;\n    if (!clazz.isPhysical()) style |= SimpleTextAttributes.STYLE_ITALIC;\n\n    final SimpleColoredText text = new SimpleColoredText();\n    text.append(StringUtil.notNullize(clazz.getName()), new SimpleTextAttributes(style, getFGColor()));\n    return text;\n  }","id":102367,"modified_method":"private SimpleColoredText getClassPresentableName(JSClass clazz) {\n    int style = SimpleTextAttributes.STYLE_BOLD;\n    if (clazz.isDeprecated()) style |= SimpleTextAttributes.STYLE_STRIKEOUT;\n    if (!clazz.isPhysical()) style |= SimpleTextAttributes.STYLE_ITALIC;\n\n    final SimpleColoredText text = new SimpleColoredText();\n    String name = StringUtil.notNullize(clazz.getName());\n    text.append(JSVfsResolver.fixVectorTypeName(name), new SimpleTextAttributes(style, getFGColor()));\n    return text;\n  }","commit_id":"064fde43035b16574f86c186d000673cc9b42bc9","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void showDependenciesFor(final JSClass clazz, final EnumSet<JSDependenciesSettingsOption> options) {\n    DiagramNode<Object> mainNode = findNode(clazz);\n    if (mainNode == null) return;\n\n    JSUmlDependencyProvider provider = new JSUmlDependencyProvider(clazz);\n\n    Collection<Pair<JSClass, FlashDiagramRelationship>> list = provider.computeUsedClasses();\n    for (Pair<JSClass, FlashDiagramRelationship> pair : list) {\n      if (shouldShow(options, clazz, pair.first, pair.second)) {\n        DiagramNode<Object> node = findNode(pair.first);\n        if (node != null) {\n          addDependencyEdge(mainNode, node, pair.second);\n        }\n      }\n    }\n\n    list = provider.computeUsingClasses();\n    for (Pair<JSClass, FlashDiagramRelationship> pair : list) {\n      DiagramNode<Object> node = findNode(pair.first);\n      if (node != null) {\n        addDependencyEdge(node, mainNode, pair.second);\n      }\n    }\n  }","id":102368,"modified_method":"private void showDependenciesFor(final JSClass clazz, final EnumSet<JSDependenciesSettingsOption> options) {\n    DiagramNode<Object> mainNode = findNode(clazz);\n    if (mainNode == null) return;\n\n    JSUmlDependencyProvider provider = new JSUmlDependencyProvider(clazz);\n\n    Collection<Pair<JSClass, FlashDiagramRelationship>> list = provider.computeUsedClasses();\n    for (Pair<JSClass, FlashDiagramRelationship> pair : list) {\n      if (shouldShow(options, clazz, pair.first, pair.second)) {\n        DiagramNode<Object> node = findNode(pair.first);\n        if (node != null) {\n          addDependencyEdge(mainNode, node, pair.second);\n        }\n      }\n    }\n  }","commit_id":"064fde43035b16574f86c186d000673cc9b42bc9","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  private static String getFqn(Object element) {\n    if (element instanceof JSQualifiedNamedElement) {\n      return ((JSQualifiedNamedElement)element).getQualifiedName();\n    }\n    if (element instanceof String) {\n      return (String)element;\n    }\n    return null;\n  }","id":102369,"modified_method":"@Nullable\n  private static String getFqn(Object element) {\n    if (element instanceof JSQualifiedNamedElement) {\n      String qName = ((JSQualifiedNamedElement)element).getQualifiedName();\n      return qName != null ? JSVfsResolver.fixVectorTypeName(qName) : null;\n    }\n    if (element instanceof String) {\n      return (String)element;\n    }\n    return null;\n  }","commit_id":"064fde43035b16574f86c186d000673cc9b42bc9","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public Collection<Pair<JSClass, FlashDiagramRelationship>> computeUsedClasses() {\n    final Collection<Pair<JSClass, FlashDiagramRelationship>> result = new ArrayList<Pair<JSClass, FlashDiagramRelationship>>();\n    final JSElementVisitor visitor = new JSElementVisitor() {\n      JSVariable myVariable;\n      JSNewExpression myNewExpression;\n      boolean myInField;\n      boolean myInParameter;\n\n      @Override\n      public void visitJSReferenceExpression(final JSReferenceExpression node) {\n        if (myVariable == null && myNewExpression == null && !myInParameter && isReturnTypeReference(node)) {\n          return;\n        }\n\n        PsiElement resolved = node.resolve();\n        if (myNewExpression != null && resolved instanceof JSFunction) {\n          if (((JSFunction)resolved).isConstructor()) {\n            resolved = JSResolveUtil.findParent(resolved);\n          }\n        }\n\n        if (resolved instanceof JSClass) {\n          FlashDiagramRelationship relType;\n          if (node.getParent() instanceof JSReferenceExpression) {\n            relType = Factory.dependency(myInField ? myVariable.getName() : null, myVariable != null ? myVariable : node);\n          }\n          else if (myNewExpression != null) {\n            if (node.getParent() instanceof JSGenericSignature) {\n              relType = Factory.dependency(myInField ? myVariable.getName() : null, myVariable != null ? myVariable : node);\n            }\n            else {\n              relType = Factory.create(myNewExpression);\n            }\n          }\n          else if (myInField && node.getParent() instanceof JSGenericSignature) {\n            assert myVariable != null;\n            relType = Factory.oneToMany(myVariable.getName(), myVariable);\n          }\n          else if (myInField) {\n            assert myVariable != null;\n            relType = Factory.oneToOne(myVariable.getName(), myVariable);\n          }\n          else {\n            relType = Factory.dependency(null, myVariable != null ? myVariable : node);\n          }\n          result.add(Pair.create((JSClass)resolved, relType));\n        }\n\n        super.visitJSReferenceExpression(node);\n      }\n\n      @Override\n      public void visitJSVariable(final JSVariable node) {\n        if (node instanceof JSParameter) {\n          myInParameter = true;\n        }\n        else {\n          myVariable = node;\n        }\n        myInField = JSResolveUtil.findParent(node) instanceof JSClass;\n        try {\n          super.visitJSVariable(node);\n        }\n        finally {\n          myVariable = null;\n          myInField = false;\n          myInParameter = false;\n        }\n      }\n\n      @Override\n      public void visitJSNewExpression(final JSNewExpression node) {\n        myNewExpression = node;\n        try {\n          super.visitJSNewExpression(node);\n        }\n        finally {\n          myNewExpression = null;\n        }\n      }\n\n      @Override\n      public void visitElement(final PsiElement element) {\n        super.visitElement(element);\n        element.acceptChildren(this);\n      }\n    };\n\n    if (myClazz instanceof XmlBackedJSClassImpl) {\n      // TODO process attributes\n      ((XmlBackedJSClassImpl)myClazz).processInjectedFiles(new Processor<JSFile>() {\n        @Override\n        public boolean process(final JSFile jsFile) {\n          jsFile.accept(visitor);\n          return true;\n        }\n      });\n\n      myClazz.getParent().acceptChildren(new XmlElementVisitor() { // don't visit parent tag\n        private String myInClassAttributeName; // also to prevent extra references resolve\n\n        @Override\n        public void visitXmlTag(final XmlTag tag) {\n          XmlElementDescriptor descriptor = tag.getDescriptor();\n          if (descriptor != null) {\n            PsiElement declaration = descriptor.getDeclaration();\n            if (declaration instanceof XmlFile && JavaScriptSupportLoader.isFlexMxmFile((PsiFile)declaration)) {\n              declaration = XmlBackedJSClassImpl.getXmlBackedClass((XmlFile)declaration);\n            }\n            if (declaration instanceof JSClass) {\n              XmlAttribute id = tag.getAttribute(\"id\");\n              FlashDiagramRelationship type = id != null && StringUtil.isNotEmpty(id.getValue()) ?\n                                              Factory.oneToOne(id.getValue(), id) : Factory.dependency(null, tag);\n              result.add(Pair.create((JSClass)declaration, type));\n            }\n          }\n          super.visitXmlTag(tag);\n        }\n\n        @Override\n        public void visitXmlAttribute(final XmlAttribute attribute) {\n          XmlAttributeDescriptor descriptor = attribute.getDescriptor();\n          if (descriptor instanceof AnnotationBackedDescriptor) {\n            if (FlexReferenceContributor.isClassReferenceType(((AnnotationBackedDescriptor)descriptor).getType())) {\n              myInClassAttributeName = StringUtil.notNullize(attribute.getName());\n              try {\n                super.visitXmlAttribute(attribute);\n              }\n              finally {\n                myInClassAttributeName = null;\n              }\n            }\n          }\n        }\n\n        @Override\n        public void visitXmlAttributeValue(final XmlAttributeValue value) {\n          if (myInClassAttributeName != null) {\n            processReferenceSet(value.getReferences(), result, Factory.dependency(myInClassAttributeName, value.getParent()));\n          }\n        }\n\n        @Override\n        public void visitXmlText(final XmlText text) {\n          List<Pair<PsiElement, TextRange>> injectedFiles = InjectedLanguageUtil.getInjectedPsiFiles(text);\n          if (injectedFiles != null) {\n            for (Pair<PsiElement, TextRange> pair : injectedFiles) {\n              if (CSS.is(pair.first.getLanguage())) {\n                pair.first.accept(new CssElementVisitor() {\n                  private boolean myInClassReference; // to prevent extra references resolve\n\n                  @Override\n                  public void visitElement(final PsiElement element) {\n                    super.visitElement(element);\n                    element.acceptChildren(this);\n                  }\n\n                  @Override\n                  public void visitCssFunction(final CssFunction _function) {\n                    if (FlexReferenceContributor.CLASS_REFERENCE.equals(_function.getFunctionName())) {\n                      myInClassReference = true;\n                      try {\n                        super.visitCssFunction(_function);\n                      }\n                      finally {\n                        myInClassReference = false;\n                      }\n                    }\n                  }\n\n                  @Override\n                  public void visitCssString(final CssString _string) {\n                    if (myInClassReference) {\n                      CssDeclaration declaration = PsiTreeUtil.getParentOfType(_string, CssDeclaration.class);\n                      if (declaration != null) {\n                        processReferenceSet(_string.getReferences(), result,\n                                            Factory.dependency(declaration.getPropertyName(), declaration));\n                      }\n                    }\n                  }\n                });\n              }\n            }\n          }\n          super.visitXmlText(text);\n        }\n\n        @Override\n        public void visitElement(final PsiElement element) {\n          super.visitElement(element);\n          element.acceptChildren(this);\n        }\n      });\n    }\n\n    myClazz.processDeclarations(new BaseScopeProcessor() {\n      @Override\n      public boolean execute(final PsiElement element, final ResolveState state) {\n        element.accept(visitor);\n        return true;\n      }\n    }, ResolveState.initial(), myClazz, myClazz);\n    return result;\n  }","id":102370,"modified_method":"public Collection<Pair<JSClass, FlashDiagramRelationship>> computeUsedClasses() {\n    final Collection<Pair<JSClass, FlashDiagramRelationship>> result = new ArrayList<Pair<JSClass, FlashDiagramRelationship>>();\n    final JSElementVisitor visitor = new JSElementVisitor() {\n      JSVariable myVariable;\n      JSNewExpression myNewExpression;\n      boolean myInField;\n      boolean myInParameter;\n\n      @Override\n      public void visitJSReferenceExpression(final JSReferenceExpression node) {\n        if (myVariable == null && myNewExpression == null && !myInParameter && isReturnTypeReference(node)) {\n          return;\n        }\n\n        PsiElement resolved = node.resolve();\n        if (myNewExpression != null && resolved instanceof JSFunction) {\n          if (((JSFunction)resolved).isConstructor()) {\n            resolved = JSResolveUtil.findParent(resolved);\n          }\n        }\n\n        if (resolved instanceof JSClass) {\n          FlashDiagramRelationship relType;\n          if (node.getParent() instanceof JSReferenceExpression) {\n            relType = Factory.dependency(myInField ? myVariable.getName() : null, myVariable != null ? myVariable : node);\n          }\n          else if (myNewExpression != null) {\n            if (node.getParent() instanceof JSGenericSignature) {\n              relType = Factory.dependency(myInField ? myVariable.getName() : null, myVariable != null ? myVariable : node);\n            }\n            else {\n              relType = Factory.create(myNewExpression);\n            }\n          }\n          else if (myInField && node.getParent() instanceof JSGenericSignature) {\n            assert myVariable != null;\n            relType = Factory.oneToMany(myVariable.getName(), myVariable);\n          }\n          else if (myInField) {\n            assert myVariable != null;\n            String qName = ((JSClass)resolved).getQualifiedName();\n            if (JSVfsResolver.isVectorType(qName)) {\n              relType = Factory.dependency(myVariable.getName(), myVariable);\n            }\n            else {\n              relType = Factory.oneToOne(myVariable.getName(), myVariable);\n            }\n          }\n          else {\n            relType = Factory.dependency(null, myVariable != null ? myVariable : node);\n          }\n          result.add(Pair.create((JSClass)resolved, relType));\n        }\n\n        super.visitJSReferenceExpression(node);\n      }\n\n      @Override\n      public void visitJSVariable(final JSVariable node) {\n        if (node instanceof JSParameter) {\n          myInParameter = true;\n        }\n        else {\n          myVariable = node;\n        }\n        myInField = JSResolveUtil.findParent(node) instanceof JSClass;\n        try {\n          super.visitJSVariable(node);\n        }\n        finally {\n          myVariable = null;\n          myInField = false;\n          myInParameter = false;\n        }\n      }\n\n      @Override\n      public void visitJSNewExpression(final JSNewExpression node) {\n        myNewExpression = node;\n        try {\n          super.visitJSNewExpression(node);\n        }\n        finally {\n          myNewExpression = null;\n        }\n      }\n\n      @Override\n      public void visitElement(final PsiElement element) {\n        super.visitElement(element);\n        element.acceptChildren(this);\n      }\n    };\n\n    if (myClazz instanceof XmlBackedJSClassImpl) {\n      // TODO process attributes\n      ((XmlBackedJSClassImpl)myClazz).processInjectedFiles(new Processor<JSFile>() {\n        @Override\n        public boolean process(final JSFile jsFile) {\n          jsFile.accept(visitor);\n          return true;\n        }\n      });\n\n      myClazz.getParent().acceptChildren(new XmlElementVisitor() { // don't visit parent tag\n        private String myInClassAttributeName; // also to prevent extra references resolve\n\n        @Override\n        public void visitXmlTag(final XmlTag tag) {\n          XmlElementDescriptor descriptor = tag.getDescriptor();\n          if (descriptor != null) {\n            PsiElement declaration = descriptor.getDeclaration();\n            if (declaration instanceof XmlFile && JavaScriptSupportLoader.isFlexMxmFile((PsiFile)declaration)) {\n              declaration = XmlBackedJSClassImpl.getXmlBackedClass((XmlFile)declaration);\n            }\n            if (declaration instanceof JSClass) {\n              XmlAttribute id = tag.getAttribute(\"id\");\n              FlashDiagramRelationship type = id != null && StringUtil.isNotEmpty(id.getValue()) ?\n                                              Factory.oneToOne(id.getValue(), id) : Factory.dependency(null, tag);\n              result.add(Pair.create((JSClass)declaration, type));\n            }\n          }\n          super.visitXmlTag(tag);\n        }\n\n        @Override\n        public void visitXmlAttribute(final XmlAttribute attribute) {\n          XmlAttributeDescriptor descriptor = attribute.getDescriptor();\n          if (descriptor instanceof AnnotationBackedDescriptor) {\n            if (FlexReferenceContributor.isClassReferenceType(((AnnotationBackedDescriptor)descriptor).getType())) {\n              myInClassAttributeName = StringUtil.notNullize(attribute.getName());\n              try {\n                super.visitXmlAttribute(attribute);\n              }\n              finally {\n                myInClassAttributeName = null;\n              }\n            }\n          }\n        }\n\n        @Override\n        public void visitXmlAttributeValue(final XmlAttributeValue value) {\n          if (myInClassAttributeName != null) {\n            processReferenceSet(value.getReferences(), result, Factory.dependency(myInClassAttributeName, value.getParent()));\n          }\n        }\n\n        @Override\n        public void visitXmlText(final XmlText text) {\n          List<Pair<PsiElement, TextRange>> injectedFiles = InjectedLanguageUtil.getInjectedPsiFiles(text);\n          if (injectedFiles != null) {\n            for (Pair<PsiElement, TextRange> pair : injectedFiles) {\n              if (CSS.is(pair.first.getLanguage())) {\n                pair.first.accept(new CssElementVisitor() {\n                  private boolean myInClassReference; // to prevent extra references resolve\n\n                  @Override\n                  public void visitElement(final PsiElement element) {\n                    super.visitElement(element);\n                    element.acceptChildren(this);\n                  }\n\n                  @Override\n                  public void visitCssFunction(final CssFunction _function) {\n                    if (FlexReferenceContributor.CLASS_REFERENCE.equals(_function.getFunctionName())) {\n                      myInClassReference = true;\n                      try {\n                        super.visitCssFunction(_function);\n                      }\n                      finally {\n                        myInClassReference = false;\n                      }\n                    }\n                  }\n\n                  @Override\n                  public void visitCssString(final CssString _string) {\n                    if (myInClassReference) {\n                      CssDeclaration declaration = PsiTreeUtil.getParentOfType(_string, CssDeclaration.class);\n                      if (declaration != null) {\n                        processReferenceSet(_string.getReferences(), result,\n                                            Factory.dependency(declaration.getPropertyName(), declaration));\n                      }\n                    }\n                  }\n                });\n              }\n            }\n          }\n          super.visitXmlText(text);\n        }\n\n        @Override\n        public void visitElement(final PsiElement element) {\n          super.visitElement(element);\n          element.acceptChildren(this);\n        }\n      });\n    }\n\n    myClazz.processDeclarations(new BaseScopeProcessor() {\n      @Override\n      public boolean execute(final PsiElement element, final ResolveState state) {\n        element.accept(visitor);\n        return true;\n      }\n    }, ResolveState.initial(), myClazz, myClazz);\n    return result;\n  }","commit_id":"064fde43035b16574f86c186d000673cc9b42bc9","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  public static String getQualifiedNameStatic(Object element) {\n    if (element == null) {\n      return null;\n    }\n\n    if (element instanceof PsiElement) {\n      if (((PsiElement)element).getProject().isDisposed()) {\n        return null;\n      }\n      if (element instanceof JSQualifiedNamedElement) {\n        JSQualifiedNamedElement qualifiedNamedElement = (JSQualifiedNamedElement)element;\n        return combineWithModuleName(qualifiedNamedElement, qualifiedNamedElement.getQualifiedName());\n      }\n      else if (element instanceof JSFile) {\n        return getQualifiedNameStatic(JSPsiImplUtils.findQualifiedElement((JSFile)element));\n      }\n      else if (element instanceof XmlFile && JavaScriptSupportLoader.isFlexMxmFile((PsiFile)element)) {\n        //noinspection ConstantConditions\n        return getQualifiedNameStatic(XmlBackedJSClassImpl.getXmlBackedClass((XmlFile)element));\n      }\n      else if (element instanceof PsiDirectory) {\n        PsiDirectory directory = (PsiDirectory)element;\n        return combineWithModuleName(directory,\n                                     JSResolveUtil.getExpectedPackageNameFromFile(directory.getVirtualFile(), directory.getProject()));\n      }\n    }\n    else if (element instanceof String) {\n      return (String)element;\n    }\n    LOG.error(\"can't get qualified name of \" + element);\n    return null;\n  }","id":102371,"modified_method":"@Nullable\n  public static String getQualifiedNameStatic(Object element) {\n    if (element == null) {\n      return null;\n    }\n\n    if (element instanceof PsiElement) {\n      if (((PsiElement)element).getProject().isDisposed()) {\n        return null;\n      }\n      if (element instanceof JSQualifiedNamedElement) {\n        JSQualifiedNamedElement qualifiedNamedElement = (JSQualifiedNamedElement)element;\n        String qName = qualifiedNamedElement.getQualifiedName();\n        if (qName == null) return null;\n        return combineWithModuleName(qualifiedNamedElement, fixVectorTypeName(qName));\n      }\n      else if (element instanceof JSFile) {\n        return getQualifiedNameStatic(JSPsiImplUtils.findQualifiedElement((JSFile)element));\n      }\n      else if (element instanceof XmlFile && JavaScriptSupportLoader.isFlexMxmFile((PsiFile)element)) {\n        //noinspection ConstantConditions\n        return getQualifiedNameStatic(XmlBackedJSClassImpl.getXmlBackedClass((XmlFile)element));\n      }\n      else if (element instanceof PsiDirectory) {\n        PsiDirectory directory = (PsiDirectory)element;\n        return combineWithModuleName(directory,\n                                     JSResolveUtil.getExpectedPackageNameFromFile(directory.getVirtualFile(), directory.getProject()));\n      }\n    }\n    else if (element instanceof String) {\n      return (String)element;\n    }\n    LOG.error(\"can't get qualified name of \" + element);\n    return null;\n  }","commit_id":"064fde43035b16574f86c186d000673cc9b42bc9","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public PsiElement bindToElement(@NotNull PsiElement element) throws IncorrectOperationException {\n    if (isReferenceTo(element)) return this;\n\n    if (element instanceof PsiClass) {\n      final String newName = ((PsiClass) element).getName();\n      final GrReferenceElementImpl newElement = ((GrReferenceElementImpl)handleElementRename(newName));\n      if (newElement.isReferenceTo(element)) return newElement;\n      return newElement.bindWithQualifiedRef(((PsiClass)element).getQualifiedName());\n    } else if (element instanceof PsiMember) {\n      PsiMember member = (PsiMember)element;\n      if (!isPhysical()) {\n        // don't qualify reference: the isReferenceTo() check fails anyway, whether we have a static import for this member or not\n        return this;\n      }\n      final PsiClass psiClass = member.getContainingClass();\n      if (psiClass == null) throw new IncorrectOperationException();\n\n      String qName = psiClass.getQualifiedName() + \".\" + member.getName();\n      return bindWithQualifiedRef(qName);\n    }\n    else if (element instanceof PsiPackage) {\n      final String qName = ((PsiPackage) element).getQualifiedName();\n      return bindWithQualifiedRef(qName);\n    }\n\n    throw new IncorrectOperationException(\"Cannot bind to:\" + element + \" of class \" + element.getClass());\n  }","id":102372,"modified_method":"public PsiElement bindToElement(@NotNull PsiElement element) throws IncorrectOperationException {\n    if (isReferenceTo(element)) return this;\n\n    if (element instanceof PsiClass) {\n      final String newName = ((PsiClass) element).getName();\n      final GrReferenceElementImpl newElement = ((GrReferenceElementImpl)handleElementRename(newName));\n      if (newElement.isReferenceTo(element)) return newElement;\n      final String qualifiedName = ((PsiClass)element).getQualifiedName();\n      if (qualifiedName == null) return newElement;\n      return newElement.bindWithQualifiedRef(qualifiedName);\n    } else if (element instanceof PsiMember) {\n      PsiMember member = (PsiMember)element;\n      if (!isPhysical()) {\n        // don't qualify reference: the isReferenceTo() check fails anyway, whether we have a static import for this member or not\n        return this;\n      }\n      final PsiClass psiClass = member.getContainingClass();\n      if (psiClass == null) throw new IncorrectOperationException();\n\n      String qName = psiClass.getQualifiedName() + \".\" + member.getName();\n      return bindWithQualifiedRef(qName);\n    }\n    else if (element instanceof PsiPackage) {\n      final String qName = ((PsiPackage) element).getQualifiedName();\n      return bindWithQualifiedRef(qName);\n    }\n\n    throw new IncorrectOperationException(\"Cannot bind to:\" + element + \" of class \" + element.getClass());\n  }","commit_id":"7add06e36a08e7d8d58a65ffdd6235982da50af7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String getLocationString(@NotNull final PsiDirectory directory) {\n    PsiPackage aPackage = JavaDirectoryService.getInstance().getPackage(directory);\n    if (ProjectRootsUtil.isSourceRoot(directory) && aPackage != null) {   //package prefix\n      return aPackage.getQualifiedName();\n    }\n    return super.getLocationString(directory);\n  }","id":102373,"modified_method":"@Nullable\n  @Override\n  public String getLocationString(@NotNull PsiDirectory directory, boolean includeUrl, boolean includeRootType) {\n    String result = null;\n    PsiPackage aPackage = JavaDirectoryService.getInstance().getPackage(directory);\n    if (ProjectRootsUtil.isSourceRoot(directory) && aPackage != null) {   //package prefix\n      result = StringUtil.nullize(aPackage.getQualifiedName(), true);\n    }\n    String baseString = super.getLocationString(directory, includeUrl, includeRootType);\n    if (result == null) return baseString;\n    if (baseString == null) return result;\n    return result  + \",\" + FontUtil.spaceAndThinSpace() + baseString;\n  }","commit_id":"0718118c7e6ee7bae647d68674f42abacfdc0665","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getLocationString(@NotNull PsiDirectory psiDirectory) {\n    final VirtualFile directory = psiDirectory.getVirtualFile();\n    \n    if (ProjectRootsUtil.isLibraryRoot(directory, psiDirectory.getProject())) {\n      return \"library home\";\n    }\n    \n    final VirtualFile contentRootForFile = ProjectRootManager.getInstance(myProject).getFileIndex().getContentRootForFile(directory);\n    if (Comparing.equal(contentRootForFile, psiDirectory)) {\n      return directory.getPresentableUrl();\n    }\n    return null;\n  }","id":102374,"modified_method":"@Nullable\n  public String getLocationString(@NotNull PsiDirectory psiDirectory) {\n    return getLocationString(psiDirectory, false, false);\n  }","commit_id":"0718118c7e6ee7bae647d68674f42abacfdc0665","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void updateImpl(PresentationData data) {\n    Project project = getProject();\n    assert project != null : this;\n    PsiDirectory psiDirectory = getValue();\n    assert psiDirectory != null : this;\n    VirtualFile directoryFile = psiDirectory.getVirtualFile();\n    Object parentValue = getParentValue();\n\n    if (ProjectRootsUtil.isModuleContentRoot(directoryFile, project)) {\n      ProjectFileIndex fi = ProjectRootManager.getInstance(project).getFileIndex();\n      Module module = fi.getModuleForFile(directoryFile);\n\n      data.setPresentableText(directoryFile.getName());\n      if (module != null) {\n        if (!(parentValue instanceof Module)) {\n          if (!shouldShowModuleName()) {\n            data.addText(directoryFile.getName() + \" \", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n          }\n          else if (Comparing.equal(module.getName(), directoryFile.getName())) {\n            data.addText(directoryFile.getName(), SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);\n          }\n          else {\n            data.addText(directoryFile.getName() + \" \", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n            data.addText(\"[\" + module.getName() + \"]\", SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);\n          }\n        }\n        else {\n          data.addText(directoryFile.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n\n        if (parentValue instanceof Module || parentValue instanceof Project) {\n          final String location = FileUtil.getLocationRelativeToUserHome(directoryFile.getPresentableUrl());\n          data.addText(FontUtil.spaceAndThinSpace() + location, SimpleTextAttributes.GRAYED_ATTRIBUTES);\n        }\n        else if (shouldShowSourcesRoot()) {\n          SourceFolder sourceRoot = ProjectRootsUtil.getModuleSourceRoot(directoryFile, project);\n          if (sourceRoot != null) {\n            ModuleSourceRootEditHandler<?> handler = ModuleSourceRootEditHandler.getEditHandler(sourceRoot.getRootType());\n            if (handler != null) {\n              String rootTypeName = handler.getRootTypeName();\n              data.addText(FontUtil.spaceAndThinSpace() + rootTypeName.toLowerCase(Locale.getDefault()) + \" root\",  SimpleTextAttributes.GRAYED_ATTRIBUTES);\n            }\n          }\n        }\n\n        setupIcon(data, psiDirectory);\n\n        return;\n      }\n    }\n\n    String name = parentValue instanceof Project\n                  ? psiDirectory.getVirtualFile().getPresentableUrl()\n                  : ProjectViewDirectoryHelper.getInstance(psiDirectory.getProject()).getNodeName(getSettings(), parentValue, psiDirectory);\n    if (name == null) {\n      setValue(null);\n      return;\n    }\n\n    data.setPresentableText(name);\n    data.setLocationString(ProjectViewDirectoryHelper.getInstance(project).getLocationString(psiDirectory));\n\n    setupIcon(data, psiDirectory);\n  }","id":102375,"modified_method":"@Override\n  protected void updateImpl(PresentationData data) {\n    Project project = getProject();\n    assert project != null : this;\n    PsiDirectory psiDirectory = getValue();\n    assert psiDirectory != null : this;\n    VirtualFile directoryFile = psiDirectory.getVirtualFile();\n    Object parentValue = getParentValue();\n\n    if (ProjectRootsUtil.isModuleContentRoot(directoryFile, project)) {\n      ProjectFileIndex fi = ProjectRootManager.getInstance(project).getFileIndex();\n      Module module = fi.getModuleForFile(directoryFile);\n\n      data.setPresentableText(directoryFile.getName());\n      if (module != null) {\n        if (!(parentValue instanceof Module)) {\n          if (!shouldShowModuleName()) {\n            data.addText(directoryFile.getName() + \" \", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n          }\n          else if (Comparing.equal(module.getName(), directoryFile.getName())) {\n            data.addText(directoryFile.getName(), SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);\n          }\n          else {\n            data.addText(directoryFile.getName() + \" \", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n            data.addText(\"[\" + module.getName() + \"]\", SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);\n          }\n        }\n        else {\n          data.addText(directoryFile.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n\n        data.setLocationString(ProjectViewDirectoryHelper.getInstance(project).getLocationString(psiDirectory, true, true));\n        setupIcon(data, psiDirectory);\n\n        return;\n      }\n    }\n\n    String name = parentValue instanceof Project\n                  ? psiDirectory.getVirtualFile().getPresentableUrl()\n                  : ProjectViewDirectoryHelper.getInstance(psiDirectory.getProject()).getNodeName(getSettings(), parentValue, psiDirectory);\n    if (name == null) {\n      setValue(null);\n      return;\n    }\n\n    data.setPresentableText(name);\n    data.setLocationString(ProjectViewDirectoryHelper.getInstance(project).getLocationString(psiDirectory, false, false));\n\n    setupIcon(data, psiDirectory);\n  }","commit_id":"0718118c7e6ee7bae647d68674f42abacfdc0665","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiReferenceExpression createMockReference(final PsiElement place, @NotNull PsiType qualifierType, LookupElement qualifierItem) {\n    PsiElementFactory factory = JavaPsiFacade.getElementFactory(place.getProject());\n    if (qualifierItem.getObject() instanceof PsiClass) {\n      try {\n        return (PsiReferenceExpression)factory\n          .createExpressionFromText(((PsiClass)qualifierItem.getObject()).getQualifiedName() + \".xxx\", place);\n      }\n      catch (IncorrectOperationException e) {\n        LOG.info(e);\n        return null;\n      }\n    }\n\n    return (PsiReferenceExpression) factory.createExpressionFromText(\"xxx.xxx\", JavaCompletionUtil\n      .createContextWithXxxVariable(place, qualifierType));\n  }","id":102376,"modified_method":"@Nullable\n  public static PsiReferenceExpression createMockReference(final PsiElement place, @NotNull PsiType qualifierType, LookupElement qualifierItem) {\n    PsiElementFactory factory = JavaPsiFacade.getElementFactory(place.getProject());\n    if (qualifierItem.getObject() instanceof PsiClass) {\n      final String qname = ((PsiClass)qualifierItem.getObject()).getQualifiedName();\n      if (qname == null) return null;\n      \n      final String text = qname + \".xxx\";\n      try {\n        final PsiExpression expr = factory.createExpressionFromText(text, place);\n        if (expr instanceof PsiReferenceExpression) {\n          return (PsiReferenceExpression)expr;\n        }\n        LOG.error(\"Unexpected type: \" + expr.getType() + \" from text \" + text);\n        return null;\n      }\n      catch (IncorrectOperationException e) {\n        LOG.info(e);\n        return null;\n      }\n    }\n\n    return (PsiReferenceExpression) factory.createExpressionFromText(\"xxx.xxx\", JavaCompletionUtil\n      .createContextWithXxxVariable(place, qualifierType));\n  }","commit_id":"bf0ea2f3b44aa44af3f051f60cd8a098e02dd54c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Checks if FQ element name is one of provided names\n   *\n   * @param element        element to check\n   * @param namesProviders some enum that has one or more names\n   * @return true if element's fqn is one of names, provided by provider\n   */\n  public static boolean isName(@NotNull final PyElement element, @NotNull final FQNamesProvider... namesProviders) {\n    PyElement elementToCheck = element;\n    final PsiReference reference = element.getReference();\n    if (reference != null) {\n      final PsiElement resolvedElement = reference.resolve();\n      if (resolvedElement instanceof PyElement) {\n        elementToCheck = (PyElement)resolvedElement;\n      }\n    }\n    if (elementToCheck instanceof PyQualifiedNameOwner) {\n      final String qualifiedName = ((PyQualifiedNameOwner)elementToCheck).getQualifiedName();\n      return getNames(namesProviders).contains(qualifiedName);\n    }\n    return false;\n  }","id":102377,"modified_method":"/**\n   * Checks if FQ element name is one of provided names\n   *\n   * @param element        element to check\n   * @param namesProviders some enum that has one or more names\n   * @return true if element's fqn is one of names, provided by provider\n   */\n  public static boolean isName(@NotNull final PyElement element, @NotNull final FQNamesProvider... namesProviders) {\n    PyElement elementToCheck = element;\n    final PsiReference reference = element.getReference();\n    if (reference != null) {\n      final PsiElement resolvedElement = reference.resolve();\n      if (resolvedElement instanceof PyElement) {\n        elementToCheck = (PyElement)resolvedElement;\n      }\n    }\n    String qualifiedName = null;\n    if (elementToCheck instanceof PyQualifiedNameOwner) {\n      qualifiedName = ((PyQualifiedNameOwner)elementToCheck).getQualifiedName();\n    }\n    String className = null;\n    if (elementToCheck instanceof PyFunction) {\n      final PyClass aClass = ((PyFunction)elementToCheck).getContainingClass();\n      if (aClass != null) {\n        className = aClass.getQualifiedName();\n      }\n    }\n\n    for (final FQNamesProvider provider : namesProviders) {\n      final List<String> names = Arrays.asList(provider.getNames());\n      if (qualifiedName != null && names.contains(qualifiedName)) {\n        return true;\n      }\n      if (className != null && provider.isClass() && names.contains(className)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"68565aedf8719d640da986447f7d89ab564a5fe1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void init(FilterConfig config) throws ServletException {\n\t\t_ctx = config.getServletContext();\n\n\t\tfinal String ext = config.getInitParameter(\"extension\");\n\t\tif (ext != null && ext.length() > 0)\n\t\t\t_ext = ext;\n\n\t\tfinal String cs = config.getInitParameter(\"charset\");\n\t\tif (cs != null)\n\t\t\t_charset = cs.length() > 0 ? cs: null;\n\t}","id":102378,"modified_method":"public final void init(FilterConfig config) throws ServletException {\n\t\t_ctx = config.getServletContext();\n\n\t\tString param = config.getInitParameter(\"extension\");\n\t\tif (param != null && param.length() > 0)\n\t\t\t_ext = param;\n\n\t\tparam = config.getInitParameter(\"charset\");\n\t\tif (param != null)\n\t\t\t_charset = param.length() > 0 ? param: null;\n\n\t\tparam = config.getInitParameter(\"compress\");\n\t\tif (param != null)\n\t\t\t_compress = \"true\".equals(param);\n\t}","commit_id":"fb81450e8c51f75b7213555ee24293505ee66f7f","url":"https://github.com/zkoss/zk"},{"original_method":"private void process(HttpServletRequest request,\n\tHttpServletResponse response, String content)\n\tthrows ServletException, IOException {\n\t\tif (log.debugable()) log.debug(\"Content to filter:\\n\"+content);\n\n\t\tfinal WebManager webman = WebManager.getWebManager(_ctx);\n\t\tfinal WebApp wapp = webman.getWebApp();\n\t\tfinal WebAppCtrl wappc = (WebAppCtrl)wapp;\n\t\tfinal Session sess = webman.getSession(_ctx, request);\n\t\tfinal Object old = I18Ns.setup(sess, request, response, _charset);\n\t\ttry {\n\t\t\tfinal Desktop desktop = webman.getDesktop(sess, request, null, true);\n\t\t\tfinal RequestInfo ri = new RequestInfoImpl(\n\t\t\t\twapp, sess, desktop, request, null);\n\t\t\tfinal UiFactory uf = wappc.getUiFactory();\n\t\t\tfinal PageDefinition pagedef =\n\t\t\t\tuf.getPageDefinitionDirectly(ri, content, _ext);\n\n\t\t\tfinal Page page = uf.newPage(ri, pagedef, null);\n\t\t\tfinal Execution exec =\n\t\t\t\tnew ExecutionImpl(_ctx, request, response, desktop, page);\n\t\t\tfinal StringWriter out = new StringWriter(4096*2);\n\t\t\twappc.getUiEngine().execNewPage(exec, pagedef, page, out);\n\n\t\t\t//bug 1738368: Jetty refuses wrong content length\n\t\t\t//so we have to calculate it again here\n\t\t\t//(Note: we have to set content length since the servlet\n\t\t\t//being filtering might set content-length, which is,\n\t\t\t//of course, wrong\n\t\t\tString cs = response.getCharacterEncoding();\n\t\t\tif (cs == null || cs.length() == 0)\n\t\t\t\tcs = _charset != null ? _charset: \"UTF-8\";\n\t\t\tfinal byte[] bs = out.toString().getBytes(cs);\n\t\t\tresponse.setContentLength(bs.length);\n\t\t\tresponse.getOutputStream().write(bs);\n\t\t} catch (UiException ex) {\n\t\t\tlog.error(\"Failed to process:\\n\"+content);\n\t\t\tthrow ex;\n\t\t} finally {\n\t\t\tI18Ns.cleanup(request, old);\n\t\t}\n\t}","id":102379,"modified_method":"private void process(HttpServletRequest request,\n\tHttpServletResponse response, String content)\n\tthrows ServletException, IOException {\n\t\tif (log.debugable()) log.debug(\"Content to filter:\\n\"+content);\n\n\t\tfinal WebManager webman = WebManager.getWebManager(_ctx);\n\t\tfinal WebApp wapp = webman.getWebApp();\n\t\tfinal WebAppCtrl wappc = (WebAppCtrl)wapp;\n\t\tfinal Session sess = webman.getSession(_ctx, request);\n\t\tfinal Object old = I18Ns.setup(sess, request, response, _charset);\n\t\ttry {\n\t\t\tfinal Desktop desktop = webman.getDesktop(sess, request, null, true);\n\t\t\tfinal RequestInfo ri = new RequestInfoImpl(\n\t\t\t\twapp, sess, desktop, request, null);\n\t\t\tfinal UiFactory uf = wappc.getUiFactory();\n\t\t\tfinal PageDefinition pagedef =\n\t\t\t\tuf.getPageDefinitionDirectly(ri, content, _ext);\n\n\t\t\tfinal Page page = uf.newPage(ri, pagedef, null);\n\t\t\tfinal Execution exec =\n\t\t\t\tnew ExecutionImpl(_ctx, request, response, desktop, page);\n\t\t\tfinal StringWriter out = new StringWriter(4096*2);\n\t\t\twappc.getUiEngine().execNewPage(exec, pagedef, page, out);\n\n\t\t\t//bug 1738368: Jetty refuses wrong content length\n\t\t\t//so we have to calculate it again here\n\t\t\t//(Note: we have to set content length since the servlet\n\t\t\t//being filtering might set content-length, which is,\n\t\t\t//of course, wrong\n\t\t\tString cs = response.getCharacterEncoding();\n\t\t\tif (cs == null || cs.length() == 0)\n\t\t\t\tcs = _charset != null ? _charset: \"UTF-8\";\n\n\t\t\tbyte[] data = out.toString().getBytes(cs);\n\t\t\tif (_compress && !Servlets.isIncluded(request)\n\t\t\t&& data.length > 200) {\n\t\t\t\tbyte[] bs = Https.gzip(request, response, null, data);\n\t\t\t\tif (bs != null) data = bs; //yes, browser support compress\n\t\t\t}\n\n\t\t\tresponse.setContentLength(data.length);\n\t\t\tresponse.getOutputStream().write(data);\n\t\t} catch (UiException ex) {\n\t\t\tlog.error(\"Failed to process:\\n\"+content);\n\t\t\tthrow ex;\n\t\t} finally {\n\t\t\tI18Ns.cleanup(request, old);\n\t\t}\n\t}","commit_id":"fb81450e8c51f75b7213555ee24293505ee66f7f","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * Process the request.\n\t * @return false if the page is not found.\n\t */\n\tprivate boolean process(Session sess,\n\tHttpServletRequest request, HttpServletResponse response, String path,\n\tboolean bRichlet)\n\tthrows ServletException, IOException {\n\t\tfinal WebApp wapp = sess.getWebApp();\n\t\tfinal WebAppCtrl wappc = (WebAppCtrl)wapp;\n\n\t\tfinal Desktop desktop = _webman.getDesktop(sess, request, path, true);\n\t\tfinal RequestInfo ri = new RequestInfoImpl(\n\t\t\twapp, sess, desktop, request,\n\t\t\tPageDefinitions.getLocator(wapp, path));\n\n\t\tboolean compress = _compress && !Servlets.isIncluded(request);\n\t\tfinal Writer out;\n\t\tfinal UiFactory uf = wappc.getUiFactory();\n\t\tif (uf.isRichlet(ri, bRichlet)) {\n\t\t\tfinal Richlet richlet = uf.getRichlet(ri, path);\n\t\t\tif (richlet == null)\n\t\t\t\treturn false; //not found\n\n\t\t\tfinal Page page = uf.newPage(ri, richlet, path);\n\t\t\tfinal Execution exec = new ExecutionImpl(\n\t\t\t\t_ctx, request, response, desktop, page);\n\t\t\tout = compress ? (Writer)new StringWriter(): response.getWriter();\n\t\t\twappc.getUiEngine().execNewPage(exec, richlet, page, out);\n\t\t\t\t//no need to set device type here, since UiEngine will do it later\n\t\t} else {\n\t\t\tfinal PageDefinition pagedef = uf.getPageDefinition(ri, path);\n\t\t\tif (pagedef == null)\n\t\t\t\treturn false; //not found\n\n\t\t\tfinal Page page = uf.newPage(ri, pagedef, path);\n\t\t\tfinal Execution exec = new ExecutionImpl(\n\t\t\t\t_ctx, request, response, desktop, page);\n\t\t\tout = compress ? (Writer)new StringWriter(): response.getWriter();\n\t\t\twappc.getUiEngine().execNewPage(exec, pagedef, page, out);\n\t\t}\n\n\t\tif (compress) {\n\t\t\tbyte[] bs = ((StringWriter)out).toString().getBytes(\"UTF-8\");\n\t\t\tbyte[] data;\n\t\t\tif (bs.length > 200) {\n\t\t\t\tdata = Https.gzip(request, response, null, bs);\n\t\t\t\tif (data == null) //browser doesn't support compress\n\t\t\t\t\tdata = bs;\n\t\t\t\telse\n\t\t\t\t\tbs = null; //free it\n\t\t\t} else {\n\t\t\t\tdata = bs;\n\t\t\t}\n\n\t\t\tresponse.setContentLength(data.length);\n\t\t\tresponse.getOutputStream().write(data);\n\t\t\tresponse.flushBuffer();\n\t\t}\n\t\treturn true; //success\n\t}","id":102380,"modified_method":"/**\n\t * Process the request.\n\t * @return false if the page is not found.\n\t */\n\tprivate boolean process(Session sess,\n\tHttpServletRequest request, HttpServletResponse response, String path,\n\tboolean bRichlet)\n\tthrows ServletException, IOException {\n\t\tfinal WebApp wapp = sess.getWebApp();\n\t\tfinal WebAppCtrl wappc = (WebAppCtrl)wapp;\n\n\t\tfinal Desktop desktop = _webman.getDesktop(sess, request, path, true);\n\t\tfinal RequestInfo ri = new RequestInfoImpl(\n\t\t\twapp, sess, desktop, request,\n\t\t\tPageDefinitions.getLocator(wapp, path));\n\n\t\tboolean compress = _compress && !Servlets.isIncluded(request);\n\t\tfinal Writer out;\n\t\tfinal UiFactory uf = wappc.getUiFactory();\n\t\tif (uf.isRichlet(ri, bRichlet)) {\n\t\t\tfinal Richlet richlet = uf.getRichlet(ri, path);\n\t\t\tif (richlet == null)\n\t\t\t\treturn false; //not found\n\n\t\t\tfinal Page page = uf.newPage(ri, richlet, path);\n\t\t\tfinal Execution exec = new ExecutionImpl(\n\t\t\t\t_ctx, request, response, desktop, page);\n\t\t\tout = compress ? (Writer)new StringWriter(): response.getWriter();\n\t\t\twappc.getUiEngine().execNewPage(exec, richlet, page, out);\n\t\t\t\t//no need to set device type here, since UiEngine will do it later\n\t\t} else {\n\t\t\tfinal PageDefinition pagedef = uf.getPageDefinition(ri, path);\n\t\t\tif (pagedef == null)\n\t\t\t\treturn false; //not found\n\n\t\t\tfinal Page page = uf.newPage(ri, pagedef, path);\n\t\t\tfinal Execution exec = new ExecutionImpl(\n\t\t\t\t_ctx, request, response, desktop, page);\n\t\t\tout = compress ? (Writer)new StringWriter(): response.getWriter();\n\t\t\twappc.getUiEngine().execNewPage(exec, pagedef, page, out);\n\t\t}\n\n\t\tif (compress) {\n\t\t\tbyte[] data = ((StringWriter)out).toString().getBytes(\"UTF-8\");\n\t\t\tif (data.length > 200) {\n\t\t\t\tbyte[] bs = Https.gzip(request, response, null, data);\n\t\t\t\tif (bs != null) data = bs; //yes, browser support compress\n\t\t\t}\n\n\t\t\tresponse.setContentLength(data.length);\n\t\t\tresponse.getOutputStream().write(data);\n\t\t\tresponse.flushBuffer();\n\t\t}\n\t\treturn true; //success\n\t}","commit_id":"fb81450e8c51f75b7213555ee24293505ee66f7f","url":"https://github.com/zkoss/zk"},{"original_method":"/** Flushes all content in out to the response.\n\t * Don't write the response thereafter.\n\t * @param withrs whether to output <\/rs> first.\n\t */\n\tprivate static final\n\tvoid flushXMLWriter(HttpServletRequest request,\n\tHttpServletResponse response, StringWriter out)\n\tthrows IOException {\n\t\tout.write(\"\\n<\/rs>\");\n\n\t\t//Use OutputStream due to Bug 1528592 (Jetty 6)\n\t\tbyte[] bs = out.toString().getBytes(\"UTF-8\");\n\t\tbyte[] data;\n\t\tif (bs.length > 200) {\n\t\t\tdata = Https.gzip(request, response, null, bs);\n\t\t\tif (data == null) //browser doesn't support compress\n\t\t\t\tdata = bs;\n\t\t\telse\n\t\t\t\tbs = null; //free it\n\t\t} else {\n\t\t\tdata = bs;\n\t\t}\n\n\t\tresponse.setContentType(\"text/xml;charset=UTF-8\");\n\t\tresponse.setContentLength(data.length);\n\t\tresponse.getOutputStream().write(data);\n\t\tresponse.flushBuffer();\n\t}","id":102381,"modified_method":"/** Flushes all content in out to the response.\n\t * Don't write the response thereafter.\n\t * @param withrs whether to output <\/rs> first.\n\t */\n\tprivate static final\n\tvoid flushXMLWriter(HttpServletRequest request,\n\tHttpServletResponse response, StringWriter out)\n\tthrows IOException {\n\t\tout.write(\"\\n<\/rs>\");\n\n\t\t//Use OutputStream due to Bug 1528592 (Jetty 6)\n\t\tbyte[] data = out.toString().getBytes(\"UTF-8\");\n\t\tif (data.length > 200) {\n\t\t\tbyte[] bs = Https.gzip(request, response, null, data);\n\t\t\tif (bs != null) data = bs; //yes, browser support compress\n\t\t}\n\n\t\tresponse.setContentType(\"text/xml;charset=UTF-8\");\n\t\tresponse.setContentLength(data.length);\n\t\tresponse.getOutputStream().write(data);\n\t\tresponse.flushBuffer();\n\t}","commit_id":"fb81450e8c51f75b7213555ee24293505ee66f7f","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * Process the request.\n\t * @return false if the page is not found.\n\t */\n\tprivate void process(Session sess,\n\tHttpServletRequest request, HttpServletResponse response,\n\tPageDefinition pagedef, String path) throws ServletException, IOException {\n\t\tfinal WebApp wapp = sess.getWebApp();\n\t\tfinal WebAppCtrl wappc = (WebAppCtrl)wapp;\n\n\t\tfinal Desktop desktop = getWebManager().getDesktop(sess, request, path, true);\n\t\tfinal RequestInfo ri = new RequestInfoImpl(\n\t\t\twapp, sess, desktop, request, PageDefinitions.getLocator(wapp, path));\n\n\t\tboolean compress = _compress && !Servlets.isIncluded(request);\n\t\tfinal Page page = wappc.getUiFactory().newPage(ri, pagedef, path);\n\t\tfinal Execution exec = new ExecutionImpl(\n\t\t\tgetServletContext(), request, response, desktop, page);\n\t\tfinal Writer out = compress ? (Writer)new StringWriter(): response.getWriter();\n\t\twappc.getUiEngine().execNewPage(exec, pagedef, page, out);\n\n\t\tif (compress) {\n\t\t\tbyte[] bs = ((StringWriter)out).toString().getBytes(\"UTF-8\");\n\t\t\tbyte[] data;\n\t\t\tif (bs.length > 200) {\n\t\t\t\tdata = Https.gzip(request, response, null, bs);\n\t\t\t\tif (data == null) //browser doesn't support compress\n\t\t\t\t\tdata = bs;\n\t\t\t\telse\n\t\t\t\t\tbs = null; //free it\n\t\t\t} else {\n\t\t\t\tdata = bs;\n\t\t\t}\n\n\t\t\tresponse.setContentLength(data.length);\n\t\t\tresponse.getOutputStream().write(data);\n\t\t\tresponse.flushBuffer();\n\t\t}\n\t}","id":102382,"modified_method":"/**\n\t * Process the request.\n\t * @return false if the page is not found.\n\t */\n\tprivate void process(Session sess,\n\tHttpServletRequest request, HttpServletResponse response,\n\tPageDefinition pagedef, String path) throws ServletException, IOException {\n\t\tfinal WebApp wapp = sess.getWebApp();\n\t\tfinal WebAppCtrl wappc = (WebAppCtrl)wapp;\n\n\t\tfinal Desktop desktop = getWebManager().getDesktop(sess, request, path, true);\n\t\tfinal RequestInfo ri = new RequestInfoImpl(\n\t\t\twapp, sess, desktop, request, PageDefinitions.getLocator(wapp, path));\n\n\t\tboolean compress = _compress && !Servlets.isIncluded(request);\n\t\tfinal Page page = wappc.getUiFactory().newPage(ri, pagedef, path);\n\t\tfinal Execution exec = new ExecutionImpl(\n\t\t\tgetServletContext(), request, response, desktop, page);\n\t\tfinal Writer out = compress ? (Writer)new StringWriter(): response.getWriter();\n\t\twappc.getUiEngine().execNewPage(exec, pagedef, page, out);\n\n\t\tif (compress) {\n\t\t\tbyte[] data = ((StringWriter)out).toString().getBytes(\"UTF-8\");\n\t\t\tif (data.length > 200) {\n\t\t\t\tbyte[] bs = Https.gzip(request, response, null, data);\n\t\t\t\tif (bs != null) data = bs; //yes, browser support compress\n\t\t\t}\n\n\t\t\tresponse.setContentLength(data.length);\n\t\t\tresponse.getOutputStream().write(data);\n\t\t\tresponse.flushBuffer();\n\t\t}\n\t}","commit_id":"fb81450e8c51f75b7213555ee24293505ee66f7f","url":"https://github.com/zkoss/zk"},{"original_method":"public SNode findOutputNodeByInputNodeAndMappingName(SNode inputNode, String mappingName) {\n    if (mappingName == null) return null;\n    Map<SNode, Object> currentMapping = myMappingNameAndInputNodeToOutputNodeMap.get(mappingName);\n    if (currentMapping == null) return null;\n    Object o = currentMapping.get(inputNode);\n    if (o instanceof List) {\n      List<SNode> list = (List<SNode>) o;\n      ProblemDescription[] descr = new ProblemDescription[list.size()];\n      for (int i = 0; i < list.size(); i++) {\n        descr[i] = new ProblemDescription(list.get(i), \"output [\" + i + \"] : \" + SNodeUtil.getDebugText(list.get(i)));\n      }\n      myLog.warning(inputNode, \"\" + list.size() + \" output nodes found for mapping label '\" + mappingName + \"' and input \" + SNodeUtil.getDebugText(inputNode), descr);\n      return list.get(0);\n    }\n\n    return (SNode) o;\n  }","id":102383,"modified_method":"public SNode findOutputNodeByInputNodeAndMappingName(SNode inputNode, String mappingName) {\n    if (mappingName == null) return null;\n    Map<SNode, Object> currentMapping = myMappingNameAndInputNodeToOutputNodeMap.get(mappingName);\n    if (currentMapping == null) return null;\n    Object o = currentMapping.get(inputNode);\n    if (o instanceof List) {\n      List<SNode> list = (List<SNode>) o;\n      ProblemDescription[] descr = new ProblemDescription[list.size()];\n      for (int i = 0; i < list.size(); i++) {\n        descr[i] = new ProblemDescription(list.get(i).getReference(), \"output [\" + i + \"] : \" + SNodeUtil.getDebugText(list.get(i)));\n      }\n      String msg = \"%d  output nodes found for mapping label '%s' and input %s\";\n      myLog.warning(inputNode.getReference(), String.format(msg, list.size(), mappingName, SNodeUtil.getDebugText(inputNode)), descr);\n      return list.get(0);\n    }\n\n    return (SNode) o;\n  }","commit_id":"6f17a91f0cbcf2637610f1dc2abf4eced8e8ac89","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected final boolean checkResolvedTarget(AbstractTemplateGenerator generator, SNode outputTargetNode) {\n    Status status = generator.getReferentRoleValidator(myOutputSourceNode, myReferenceRole).validate(outputTargetNode);\n    if (status != null) {\n      generator.getLogger().error(myOutputSourceNode.getReference(), status.getMessage(getClass().getSimpleName()), getErrorDescriptions());\n      return false;\n    }\n\n    SModel referentNodeModel = outputTargetNode.getModel();\n    if (referentNodeModel != myOutputSourceNode.getModel()) {\n      if (SModelStereotype.isGeneratorModel(referentNodeModel)) {\n        // references to template nodes are not acceptable\n        generator.getLogger().error(myOutputSourceNode,\n            \"bad reference, cannot refer to a generator model: \" + SNodeUtil.getDebugText(outputTargetNode) + \" for role '\" + myReferenceRole + \"' in \" +\n                SNodeUtil.getDebugText(myOutputSourceNode),\n            getErrorDescriptions());\n        return false;\n      }\n      if (referentNodeModel .getModule() instanceof TransientModelsModule) {\n        // references to transient nodes are not acceptable\n        generator.getLogger().error(myOutputSourceNode,\n            \"bad reference, cannot refer to a transient model: \" + SNodeUtil.getDebugText(outputTargetNode) + \" for role '\" + myReferenceRole + \"' in \" +\n                SNodeUtil.getDebugText(myOutputSourceNode),\n            getErrorDescriptions());\n        return false;\n      }\n    }\n    return true;\n  }","id":102384,"modified_method":"protected final boolean checkResolvedTarget(AbstractTemplateGenerator generator, SNode outputTargetNode) {\n    Status status = generator.getReferentRoleValidator(myOutputSourceNode, myReferenceRole).validate(outputTargetNode);\n    if (status != null) {\n      generator.getLogger().error(myOutputSourceNode.getReference(), status.getMessage(getClass().getSimpleName()), getErrorDescriptions());\n      return false;\n    }\n\n    SModel referentNodeModel = outputTargetNode.getModel();\n    if (referentNodeModel != myOutputSourceNode.getModel()) {\n      if (SModelStereotype.isGeneratorModel(referentNodeModel)) {\n        // references to template nodes are not acceptable\n        String msg = \"bad reference, cannot refer to a generator model: %s for role '%s' in %s\";\n        generator.getLogger().error(myOutputSourceNode.getReference(), String.format(msg,\n            SNodeUtil.getDebugText(outputTargetNode), myReferenceRole, SNodeUtil.getDebugText(myOutputSourceNode)),\n            getErrorDescriptions());\n        return false;\n      }\n      if (referentNodeModel .getModule() instanceof TransientModelsModule) {\n        // references to transient nodes are not acceptable\n        String msg = \"bad reference, cannot refer to a transient model: %s  for role '%s' in %s\";\n        generator.getLogger().error(myOutputSourceNode.getReference(), String.format(msg,\n            SNodeUtil.getDebugText(outputTargetNode), myReferenceRole, SNodeUtil.getDebugText(myOutputSourceNode)),\n            getErrorDescriptions());\n        return false;\n      }\n    }\n    return true;\n  }","commit_id":"6f17a91f0cbcf2637610f1dc2abf4eced8e8ac89","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void processNull(TemplateExecutionEnvironment environment, SNodeReference templateSwitch, TemplateContext context) {\n    environment.getGenerator().getLogger().info(context.getInput(), \"Hmm, input is null\");\n  }","id":102385,"modified_method":"public void processNull(TemplateExecutionEnvironment environment, SNodeReference templateSwitch, TemplateContext context) {\n    environment.getLogger().info(templateSwitch, \"Hmm, input is null\");\n  }","commit_id":"6f17a91f0cbcf2637610f1dc2abf4eced8e8ac89","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Collection<SNode> apply(@NotNull final TemplateExecutionEnvironment environment, @NotNull final TemplateContext context) throws GenerationException {\n    final SNode tnode1 = environment.createOutputNode(\"jetbrains.mps.transformation.test.outputLang.structure.OutputRoot\");\n    try {\n      environment.getTracer().pushTemplateNode(templateNode_q702qm_a0a0a1a2);\n      environment.nodeCopied(context, tnode1, \"tpl/r:00000000-0000-4000-0000-011c895905f9/1206460153890\");\n      SNodeAccessUtil.setProperty(tnode1, \"name\", \"OutputRoot\");\n      SNodeAccessUtil.setProperty(tnode1, \"text\", \"root in Reduce Inheritors test (expect: A, B, B)\");\n\n      {\n        Collection<SNode> tlist2 = null;\n        try {\n          environment.getTracer().pushMacro(weaveMacroRef_q702qm_a0a0a1a5a1a2);\n          SNode tnode3 = null;\n          try {\n            environment.getTracer().pushMacro(insertMacro_q702qm_a0a0a2a1a5a1a2);\n            final SNode insertInput3 = QueriesGenerated.insertMacro_Query_7612440128092282150(new TemplateQueryContextWithMacro(context, insertMacro_q702qm_a0a0a2a1a5a1a2, environment.getGenerator()));\n            tnode3 = environment.insertNode(insertInput3, insertMacro_q702qm_a0a0a2a1a5a1a2, context);\n            if (tnode3 != null) {\n              environment.registerLabel(context.getInput(), tnode3, \"testLabel1\");\n            }\n          } finally {\n            environment.getTracer().closeMacro(insertMacro_q702qm_a0a0a2a1a5a1a2);\n          }\n          tlist2 = TemplateUtil.singletonList(tnode3);\n          if (tlist2.size() == 1) {\n            SNode outputContextVar3 = tlist2.iterator().next();\n            final Iterable<SNode> weaveList3 = QueriesGenerated.sourceNodesQuery_8417539822878722925(new SourceSubstituteMacroNodesContext(context, weaveMacroRef_q702qm_a0a0a1a5a1a2, environment.getGenerator()));\n            for (SNode itnode3 : weaveList3) {\n              if (itnode3 == null) {\n                continue;\n              }\n              boolean inputChanged3 = context.getInput() != itnode3;\n              try {\n                if (inputChanged3) {\n                  environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(itnode3));\n                }\n                environment.getTracer().pushRuleConsequence(weaveMacroConsequence_q702qm_a0a1a2a2a4a1a5a1a2);\n                TemplateContext weaveContext3 = context.subContext(null, itnode3);\n                new Templateweave__InputRoot().weave(environment, weaveContext3, outputContextVar3);\n\n              } finally {\n                if (inputChanged3) {\n                  environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(itnode3));\n                }\n              }\n            }\n\n          } else if (tlist2.size() > 1) {\n            environment.getGenerator().getLogger().error(context.getInput(), \"cannot apply $WEAVE$ to a list of nodes\");\n          }\n        } finally {\n          environment.getTracer().closeMacro(weaveMacroRef_q702qm_a0a0a1a5a1a2);\n        }\n        for (SNode child4 : TemplateUtil.asNotNull(tlist2)) {\n          tnode1.addChild(\"outputChild\", child4);\n        }\n        // TODO validate child \n      }\n      {\n        Collection<SNode> tlist5 = null;\n        try {\n          environment.getTracer().pushMacro(copySrcListMacro_q702qm_a0a0a1a6a1a2);\n          final Iterable<SNode> copyListInput5 = QueriesGenerated.sourceNodesQuery_1206460249786(new SourceSubstituteMacroNodesContext(context, copySrcListMacro_q702qm_a0a0a1a6a1a2, environment.getGenerator()));\n          tlist5 = environment.copyNodes(copyListInput5, copySrcListMacro_q702qm_a0a0a1a6a1a2, \"tpl/r:00000000-0000-4000-0000-011c895905f9/1206460235939\", null, context);\n        } finally {\n          environment.getTracer().closeMacro(copySrcListMacro_q702qm_a0a0a1a6a1a2);\n        }\n        for (SNode child6 : TemplateUtil.asNotNull(tlist5)) {\n          tnode1.addChild(\"outputChild\", child6);\n        }\n        // TODO validate child \n      }\n      {\n        final SNode tnode7 = environment.createOutputNode(\"jetbrains.mps.transformation.test.outputLang.structure.OutputNode\");\n        try {\n          environment.getTracer().pushTemplateNode(templateNode_q702qm_a0a0a1a7a1a2);\n          environment.nodeCopied(context, tnode7, \"tpl/r:00000000-0000-4000-0000-011c895905f9/8014813979421777297\");\n          SNodeAccessUtil.setProperty(tnode7, \"text\", TemplateUtil.asString(QueriesGenerated.propertyMacro_GetPropertyValue_8014813979421777301(new PropertyMacroContext(context, \"foobar\", propertyMacro_q702qm_c0a0c0c0b0h0b0c, environment.getGenerator()))));\n\n        } finally {\n          environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode7));\n          environment.getTracer().closeTemplateNode(templateNode_q702qm_a0a0a1a7a1a2);\n        }\n        if (tnode7 != null) {\n          tnode1.addChild(\"outputChild\", tnode7);\n        }\n        // TODO validate child \n      }\n    } finally {\n      environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode1));\n      environment.getTracer().closeTemplateNode(templateNode_q702qm_a0a0a1a2);\n    }\n    return TemplateUtil.singletonList(tnode1);\n  }","id":102386,"modified_method":"public Collection<SNode> apply(@NotNull final TemplateExecutionEnvironment environment, @NotNull final TemplateContext context) throws GenerationException {\n    final SNode tnode1 = environment.createOutputNode(\"jetbrains.mps.transformation.test.outputLang.structure.OutputRoot\");\n    try {\n      environment.getTracer().pushTemplateNode(templateNode_q702qm_a0a0a1a2);\n      environment.nodeCopied(context, tnode1, \"tpl/r:00000000-0000-4000-0000-011c895905f9/1206460153890\");\n      SNodeAccessUtil.setProperty(tnode1, \"name\", \"OutputRoot\");\n      SNodeAccessUtil.setProperty(tnode1, \"text\", \"root in Reduce Inheritors test (expect: A, B, B)\");\n\n      {\n        Collection<SNode> tlist2 = null;\n        try {\n          environment.getTracer().pushMacro(weaveMacroRef_q702qm_a0a0a1a5a1a2);\n          SNode tnode3 = null;\n          try {\n            environment.getTracer().pushMacro(insertMacro_q702qm_a0a0a2a1a5a1a2);\n            final SNode insertInput3 = QueriesGenerated.insertMacro_Query_7612440128092282150(new TemplateQueryContextWithMacro(context, insertMacro_q702qm_a0a0a2a1a5a1a2, environment.getGenerator()));\n            tnode3 = environment.insertNode(insertInput3, insertMacro_q702qm_a0a0a2a1a5a1a2, context);\n            if (tnode3 != null) {\n              environment.registerLabel(context.getInput(), tnode3, \"testLabel1\");\n            }\n          } finally {\n            environment.getTracer().closeMacro(insertMacro_q702qm_a0a0a2a1a5a1a2);\n          }\n          tlist2 = TemplateUtil.singletonList(tnode3);\n          if (tlist2.size() == 1) {\n            SNode outputContextVar3 = tlist2.iterator().next();\n            final Iterable<SNode> weaveList3 = QueriesGenerated.sourceNodesQuery_8417539822878722925(new SourceSubstituteMacroNodesContext(context, weaveMacroRef_q702qm_a0a0a1a5a1a2, environment.getGenerator()));\n            for (SNode itnode3 : weaveList3) {\n              if (itnode3 == null) {\n                continue;\n              }\n              boolean inputChanged3 = context.getInput() != itnode3;\n              try {\n                if (inputChanged3) {\n                  environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(itnode3));\n                }\n                environment.getTracer().pushRuleConsequence(weaveMacroConsequence_q702qm_a0a1a2a2a4a1a5a1a2);\n                TemplateContext weaveContext3 = context.subContext(null, itnode3);\n                new Templateweave__InputRoot().weave(environment, weaveContext3, outputContextVar3);\n\n              } finally {\n                if (inputChanged3) {\n                  environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(itnode3));\n                }\n              }\n            }\n\n          } else if (tlist2.size() > 1) {\n            environment.getLogger().error(weaveMacroRef_q702qm_a0a0a1a5a1a2, \"cannot apply $WEAVE$ to a list of nodes\", GeneratorUtil.describeInput(context));\n          }\n        } finally {\n          environment.getTracer().closeMacro(weaveMacroRef_q702qm_a0a0a1a5a1a2);\n        }\n        for (SNode child4 : TemplateUtil.asNotNull(tlist2)) {\n          tnode1.addChild(\"outputChild\", child4);\n        }\n        // TODO validate child \n      }\n      {\n        Collection<SNode> tlist5 = null;\n        try {\n          environment.getTracer().pushMacro(copySrcListMacro_q702qm_a0a0a1a6a1a2);\n          final Iterable<SNode> copyListInput5 = QueriesGenerated.sourceNodesQuery_1206460249786(new SourceSubstituteMacroNodesContext(context, copySrcListMacro_q702qm_a0a0a1a6a1a2, environment.getGenerator()));\n          tlist5 = environment.copyNodes(copyListInput5, copySrcListMacro_q702qm_a0a0a1a6a1a2, \"tpl/r:00000000-0000-4000-0000-011c895905f9/1206460235939\", null, context);\n        } finally {\n          environment.getTracer().closeMacro(copySrcListMacro_q702qm_a0a0a1a6a1a2);\n        }\n        for (SNode child6 : TemplateUtil.asNotNull(tlist5)) {\n          tnode1.addChild(\"outputChild\", child6);\n        }\n        // TODO validate child \n      }\n      {\n        final SNode tnode7 = environment.createOutputNode(\"jetbrains.mps.transformation.test.outputLang.structure.OutputNode\");\n        try {\n          environment.getTracer().pushTemplateNode(templateNode_q702qm_a0a0a1a7a1a2);\n          environment.nodeCopied(context, tnode7, \"tpl/r:00000000-0000-4000-0000-011c895905f9/8014813979421777297\");\n          SNodeAccessUtil.setProperty(tnode7, \"text\", TemplateUtil.asString(QueriesGenerated.propertyMacro_GetPropertyValue_8014813979421777301(new PropertyMacroContext(context, \"foobar\", propertyMacro_q702qm_c0a0c0c0b0h0b0c, environment.getGenerator()))));\n\n        } finally {\n          environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode7));\n          environment.getTracer().closeTemplateNode(templateNode_q702qm_a0a0a1a7a1a2);\n        }\n        if (tnode7 != null) {\n          tnode1.addChild(\"outputChild\", tnode7);\n        }\n        // TODO validate child \n      }\n    } finally {\n      environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode1));\n      environment.getTracer().closeTemplateNode(templateNode_q702qm_a0a0a1a2);\n    }\n    return TemplateUtil.singletonList(tnode1);\n  }","commit_id":"6f17a91f0cbcf2637610f1dc2abf4eced8e8ac89","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void showInformationMessage(SNode node, String message) {\n    myGenerator.getLogger().info(node, message);\n  }","id":102387,"modified_method":"public void showInformationMessage(SNode node, String message) {\n    myGenerator.getLogger().info(node == null ? null : node.getReference(), message);\n  }","commit_id":"6f17a91f0cbcf2637610f1dc2abf4eced8e8ac89","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void showWarningMessage(SNode node, String message) {\n    myGenerator.getLogger().warning(node, message);\n  }","id":102388,"modified_method":"public void showWarningMessage(SNode node, String message) {\n    myGenerator.getLogger().warning(node == null ? null : node.getReference(), message);\n  }","commit_id":"6f17a91f0cbcf2637610f1dc2abf4eced8e8ac89","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void load(OETLPipeline pipeline, final Object input, OCommandContext context) {\n\n    if (input == null)\n      return;\n\n    if (dbAutoCreateProperties) {\n      autoCreateProperties(pipeline, input);\n    }\n\n    if (tx && dbType == DOCUMENT) {\n      final ODatabaseDocument documentDatabase = pipeline.getDocumentDatabase();\n      if (!documentDatabase.getTransaction().isActive()) {\n        documentDatabase.begin();\n        documentDatabase.getTransaction().setUsingLog(txUseLog);\n\n      }\n    }\n\n    if (input instanceof OrientVertex) {\n\n      final OrientVertex v = (OrientVertex) input;\n\n      v.save(clusterName);\n\n    } else if (input instanceof ODocument) {\n\n      final ODocument doc = (ODocument) input;\n\n      doc.setClassName(className);\n\n      doc.save(clusterName);\n\n    }\n\n    progress.incrementAndGet();\n\n    // DO BATCH COMMIT\n    if (batchCommitSize > 0 && batchCounter.get() > batchCommitSize) {\n      if (dbType == DOCUMENT) {\n        final ODatabaseDocument documentDatabase = pipeline.getDocumentDatabase();\n        log(DEBUG, \"committing batch\");\n        documentDatabase.commit();\n        documentDatabase.begin();\n        documentDatabase.getTransaction().setUsingLog(txUseLog);\n      } else {\n        log(DEBUG, \"committing batch\");\n        pipeline.getGraphDatabase().commit();\n      }\n      batchCounter.set(0);\n    } else {\n      batchCounter.incrementAndGet();\n    }\n  }","id":102389,"modified_method":"@Override\n  public void load(OETLPipeline pipeline, final Object input, OCommandContext context) {\n\n    if (input == null)\n      return;\n\n    if (dbAutoCreateProperties) {\n      autoCreateProperties(pipeline, input);\n    }\n\n    if (tx && dbType == DOCUMENT) {\n      final ODatabaseDocument documentDatabase = pipeline.getDocumentDatabase();\n      if (!documentDatabase.getTransaction().isActive()) {\n        documentDatabase.begin();\n        documentDatabase.getTransaction().setUsingLog(txUseLog);\n\n      }\n    }\n\n    if (input instanceof OrientVertex) {\n\n      final OrientVertex v = (OrientVertex) input;\n\n      v.save(clusterName);\n\n    } else if (input instanceof ODocument) {\n\n      final ODocument doc = (ODocument) input;\n\n      if (className != null) {\n        doc.setClassName(className);\n      }\n\n      if (clusterName != null) {\n        doc.save(clusterName);\n      } else {\n        doc.save();\n      }\n    }\n\n    progress.incrementAndGet();\n\n    // DO BATCH COMMIT\n    if (batchCommitSize > 0 && batchCounter.get() > batchCommitSize) {\n      if (dbType == DOCUMENT) {\n        final ODatabaseDocument documentDatabase = pipeline.getDocumentDatabase();\n        log(DEBUG, \"committing batch\");\n        documentDatabase.commit();\n        documentDatabase.begin();\n        documentDatabase.getTransaction().setUsingLog(txUseLog);\n      } else {\n        log(DEBUG, \"committing batch\");\n        pipeline.getGraphDatabase().commit();\n      }\n      batchCounter.set(0);\n    } else {\n      batchCounter.incrementAndGet();\n    }\n  }","commit_id":"9bfed4ef85f1487aca083be7f46f64b270404e90","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Execute the command and return the ODocument object created.\r\n   */\r\n  public Object execute(final Map<Object, Object> iArgs) {\r\n    if (clazz == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    ODatabaseRecord database = getDatabase();\r\n    if (!(database instanceof OGraphDatabase))\r\n      database = new OGraphDatabase((ODatabaseRecordTx) database);\r\n\r\n    final ORecordId[] fromIds = parseTarget(database, from);\r\n    final ORecordId[] toIds = parseTarget(database, to);\r\n\r\n    // CREATE EDGES\r\n    List<ODocument> edges = new ArrayList<ODocument>();\r\n    for (ORecordId from : fromIds) {\r\n      for (ORecordId to : toIds) {\r\n        final ODocument edge = ((OGraphDatabase) database).createEdge(from, to, clazz.getName());\r\n        OSQLHelper.bindParameters(edge, fields, new OCommandParameters(iArgs));\r\n        edge.save(clusterName);\r\n\r\n        edges.add(edge);\r\n      }\r\n    }\r\n\r\n    return edges;\r\n  }","id":102390,"modified_method":"/**\r\n   * Execute the command and return the ODocument object created.\r\n   */\r\n  public Object execute(final Map<Object, Object> iArgs) {\r\n    if (clazz == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    ODatabaseRecord database = getDatabase();\r\n    if (!(database instanceof OGraphDatabase))\r\n      database = new OGraphDatabase((ODatabaseRecordTx) database);\r\n\r\n    final ORecordId[] fromIds = parseTarget(database, from);\r\n    final ORecordId[] toIds = parseTarget(database, to);\r\n\r\n    // CREATE EDGES\r\n    List<ODocument> edges = new ArrayList<ODocument>();\r\n    for (ORecordId from : fromIds) {\r\n      for (ORecordId to : toIds) {\r\n        final ODocument edge = ((OGraphDatabase) database).createEdge(from, to, clazz.getName());\r\n        OSQLHelper.bindParameters(edge, fields, new OCommandParameters(iArgs));\r\n\r\n        if (clusterName != null)\r\n          edge.save(clusterName);\r\n        else\r\n          edge.save();\r\n\r\n        edges.add(edge);\r\n      }\r\n    }\r\n\r\n    return edges;\r\n  }","commit_id":"705ffad7ef11a3c371de1aedb01fc6e3ac87a6d2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Execute the command and return the ODocument object created.\r\n   */\r\n  public Object execute(final Map<Object, Object> iArgs) {\r\n    if (clazz == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    ODatabaseRecord database = getDatabase();\r\n    if (!(database instanceof OGraphDatabase))\r\n      database = new OGraphDatabase((ODatabaseRecordTx) database);\r\n\r\n    final ODocument vertex = ((OGraphDatabase) database).createVertex(clazz.getName());\r\n\r\n    OSQLHelper.bindParameters(vertex, fields, new OCommandParameters(iArgs));\r\n\r\n    vertex.save(clusterName);\r\n\r\n    return vertex;\r\n  }","id":102391,"modified_method":"/**\r\n   * Execute the command and return the ODocument object created.\r\n   */\r\n  public Object execute(final Map<Object, Object> iArgs) {\r\n    if (clazz == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    ODatabaseRecord database = getDatabase();\r\n    if (!(database instanceof OGraphDatabase))\r\n      database = new OGraphDatabase((ODatabaseRecordTx) database);\r\n\r\n    final ODocument vertex = ((OGraphDatabase) database).createVertex(clazz.getName());\r\n\r\n    OSQLHelper.bindParameters(vertex, fields, new OCommandParameters(iArgs));\r\n\r\n    if (clusterName != null)\r\n      vertex.save(clusterName);\r\n    else\r\n      vertex.save();\r\n\r\n    return vertex;\r\n  }","commit_id":"705ffad7ef11a3c371de1aedb01fc6e3ac87a6d2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void fromDocument(final ODocument iDocument) {\r\n    pageSize = (Integer) iDocument.field(\"pageSize\");\r\n    root = iDocument.field(\"root\", OType.LINK);\r\n    if (iDocument.field(\"keySize\") != null)\r\n      keySize = iDocument.<Integer> field(\"keySize\");\r\n\r\n    tree.load();\r\n    \r\n    final Collection<OIdentifiable> tempEntries = iDocument.field(\"tempEntries\");\r\n    if (tempEntries != null && !tempEntries.isEmpty())\r\n      for (OIdentifiable entry : tempEntries)\r\n        tree.put(entry, null);\r\n  }","id":102392,"modified_method":"public void fromDocument(final ODocument iDocument) {\r\n    pageSize = (Integer) iDocument.field(\"pageSize\");\r\n    root = iDocument.field(\"root\", OType.LINK);\r\n    if (iDocument.field(\"keySize\") != null)\r\n      keySize = iDocument.<Integer> field(\"keySize\");\r\n\r\n    tree.load();\r\n\r\n    final Collection<OIdentifiable> tempEntries = iDocument.field(\"tempEntries\");\r\n    if (tempEntries != null && !tempEntries.isEmpty())\r\n      for (OIdentifiable entry : tempEntries)\r\n        if (entry != null)\r\n          tree.put(entry, null);\r\n  }","commit_id":"705ffad7ef11a3c371de1aedb01fc6e3ac87a6d2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Execute the INSERT and return the ODocument object created.\r\n\t */\r\n\tpublic Object execute(final Map<Object, Object> iArgs) {\r\n\t\tif (fieldNames == null)\r\n\t\t\tthrow new OCommandExecutionException(\"Can't execute the command because it hasn't been parsed yet\");\r\n\r\n\t\t// CREATE NEW DOCUMENT\r\n\t\tODocument doc = className != null ? new ODocument(database, className) : new ODocument(database);\r\n\r\n\t\t// BIND VALUES\r\n\t\tObject v;\r\n\t\tfor (int i = 0; i < fieldNames.size(); ++i) {\r\n\t\t\tv = fieldValues[i];\r\n\r\n\t\t\tif (v instanceof OSQLFilterItem)\r\n\t\t\t\tv = ((OSQLFilterItem) v).getValue(doc);\r\n\r\n\t\t\tdoc.field(fieldNames.get(i), v);\r\n\t\t}\r\n\r\n\t\tdoc.save();\r\n\r\n\t\treturn doc;\r\n\t}","id":102393,"modified_method":"/**\r\n\t * Execute the INSERT and return the ODocument object created.\r\n\t */\r\n\tpublic Object execute(final Map<Object, Object> iArgs) {\r\n\t\tif (fieldNames == null)\r\n\t\t\tthrow new OCommandExecutionException(\"Can't execute the command because it hasn't been parsed yet\");\r\n\r\n\t\t// CREATE NEW DOCUMENT\r\n\t\tODocument doc = className != null ? new ODocument(database, className) : new ODocument(database);\r\n\r\n\t\t// BIND VALUES\r\n\t\tObject v;\r\n\t\tfor (int i = 0; i < fieldNames.size(); ++i) {\r\n\t\t\tv = fieldValues[i];\r\n\r\n\t\t\tif (v instanceof OSQLFilterItem)\r\n\t\t\t\tv = ((OSQLFilterItem) v).getValue(doc);\r\n\r\n\t\t\tdoc.field(fieldNames.get(i), v);\r\n\t\t}\r\n\r\n\t\tif (clusterName != null)\r\n\t\t\tdoc.save(clusterName);\r\n\t\telse\r\n\t\t\tdoc.save();\r\n\r\n\t\treturn doc;\r\n\t}","commit_id":"b3d89e2edf9200fb41ac1365897f9b407dc0e8f3","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n\tpublic OCommandExecutorSQLInsert parse(final OCommandRequestText iRequest) {\r\n\t\tiRequest.getDatabase().checkSecurity(ODatabaseSecurityResources.COMMAND, ORole.PERMISSION_CREATE);\r\n\r\n\t\tinit(iRequest.getDatabase(), iRequest.getText());\r\n\r\n\t\tclassName = null;\r\n\t\tfieldNames = null;\r\n\t\tfieldValues = null;\r\n\r\n\t\tStringBuilder word = new StringBuilder();\r\n\r\n\t\tint pos = OSQLHelper.nextWord(text, textUpperCase, 0, word, true);\r\n\t\tif (pos == -1 || !word.toString().equals(OCommandExecutorSQLInsert.KEYWORD_INSERT))\r\n\t\t\tthrow new OCommandSQLParsingException(\"Keyword \" + OCommandExecutorSQLInsert.KEYWORD_INSERT + \" not found\", text, 0);\r\n\r\n\t\tpos = OSQLHelper.nextWord(text, textUpperCase, pos, word, true);\r\n\t\tif (pos == -1 || !word.toString().equals(KEYWORD_INTO))\r\n\t\t\tthrow new OCommandSQLParsingException(\"Keyword \" + KEYWORD_INTO + \" not found\", text, 0);\r\n\r\n\t\tpos = OSQLHelper.nextWord(text, textUpperCase, pos, word, true);\r\n\t\tif (pos == -1)\r\n\t\t\tthrow new OCommandSQLParsingException(\"Invalid class name\", text, pos);\r\n\r\n\t\tString subjectName = word.toString();\r\n\r\n\t\tif (subjectName.startsWith(OCommandExecutorSQLAbstract.CLASS_PREFIX))\r\n\t\t\tsubjectName = subjectName.substring(OCommandExecutorSQLAbstract.CLASS_PREFIX.length());\r\n\r\n\t\t// CLASS\r\n\t\tfinal OClass cls = database.getMetadata().getSchema().getClass(subjectName);\r\n\t\tif (cls == null)\r\n\t\t\tthrow new OCommandSQLParsingException(\"Class \" + subjectName + \" not found in database\", text, pos);\r\n\r\n\t\tclassName = cls.getName();\r\n\r\n\t\tfinal int beginFields = OStringParser.jumpWhiteSpaces(text, pos);\r\n\t\tif (beginFields == -1 || text.charAt(beginFields) != '(')\r\n\t\t\tthrow new OCommandSQLParsingException(\"Set of fields is missed. Example: (name, surname)\", text, pos);\r\n\r\n\t\tfinal int endFields = text.indexOf(')', beginFields + 1);\r\n\t\tif (endFields == -1)\r\n\t\t\tthrow new OCommandSQLParsingException(\"Missed closed brace\", text, beginFields);\r\n\r\n\t\tfieldNames = new ArrayList<String>();\r\n\t\tOStringSerializerHelper.getParameters(text, beginFields, fieldNames);\r\n\t\tif (fieldNames.size() == 0)\r\n\t\t\tthrow new OCommandSQLParsingException(\"Set of fields is empty. Example: (name, surname)\", text, endFields);\r\n\r\n\t\tpos = OSQLHelper.nextWord(text, textUpperCase, endFields + 1, word, true);\r\n\t\tif (pos == -1 || !word.toString().equals(KEYWORD_VALUES))\r\n\t\t\tthrow new OCommandSQLParsingException(\"Missed VALUES keyword\", text, endFields);\r\n\r\n\t\tfinal int beginValues = OStringParser.jumpWhiteSpaces(text, pos + 1);\r\n\t\tif (pos == -1 || text.charAt(beginValues) != '(')\r\n\t\t\tthrow new OCommandSQLParsingException(\"Set of values is missed. Example: ('Bill', 'Stuart', 300)\", text, pos);\r\n\r\n\t\tfinal int endValues = text.indexOf(')', beginValues + 1);\r\n\t\tif (endValues == -1)\r\n\t\t\tthrow new OCommandSQLParsingException(\"Missed closed brace\", text, beginValues);\r\n\r\n\t\tfinal List<String> values = OStringSerializerHelper.smartSplit(text.substring(beginValues + 1, endValues), ',');\r\n\r\n\t\tif (values.size() == 0)\r\n\t\t\tthrow new OCommandSQLParsingException(\"Set of values is empty. Example: ('Bill', 'Stuart', 300)\", text, beginValues);\r\n\r\n\t\tif (values.size() != fieldNames.size())\r\n\t\t\tthrow new OCommandSQLParsingException(\"Fields not match with values\", text, beginValues);\r\n\r\n\t\t// TRANSFORM FIELD VALUES\r\n\t\tfieldValues = new Object[values.size()];\r\n\t\tfor (int i = 0; i < values.size(); ++i)\r\n\t\t\tfieldValues[i] = OSQLHelper.parseValue(database, this, values.get(i));\r\n\r\n\t\treturn this;\r\n\t}","id":102394,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n\tpublic OCommandExecutorSQLInsert parse(final OCommandRequestText iRequest) {\r\n\t\tiRequest.getDatabase().checkSecurity(ODatabaseSecurityResources.COMMAND, ORole.PERMISSION_CREATE);\r\n\r\n\t\tinit(iRequest.getDatabase(), iRequest.getText());\r\n\r\n\t\tclassName = null;\r\n\t\tfieldNames = null;\r\n\t\tfieldValues = null;\r\n\r\n\t\tStringBuilder word = new StringBuilder();\r\n\r\n\t\tint pos = OSQLHelper.nextWord(text, textUpperCase, 0, word, true);\r\n\t\tif (pos == -1 || !word.toString().equals(OCommandExecutorSQLInsert.KEYWORD_INSERT))\r\n\t\t\tthrow new OCommandSQLParsingException(\"Keyword \" + OCommandExecutorSQLInsert.KEYWORD_INSERT + \" not found\", text, 0);\r\n\r\n\t\tpos = OSQLHelper.nextWord(text, textUpperCase, pos, word, true);\r\n\t\tif (pos == -1 || !word.toString().equals(KEYWORD_INTO))\r\n\t\t\tthrow new OCommandSQLParsingException(\"Keyword \" + KEYWORD_INTO + \" not found\", text, 0);\r\n\r\n\t\tpos = OSQLHelper.nextWord(text, textUpperCase, pos, word, true);\r\n\t\tif (pos == -1)\r\n\t\t\tthrow new OCommandSQLParsingException(\"Invalid class name\", text, pos);\r\n\r\n\t\tString subjectName = word.toString();\r\n\r\n\t\tif (subjectName.startsWith(OCommandExecutorSQLAbstract.CLUSTER_PREFIX))\r\n\t\t\t// CLUSTEr\r\n\t\t\tclusterName = subjectName.substring(OCommandExecutorSQLAbstract.CLUSTER_PREFIX.length());\r\n\t\telse {\r\n\t\t\t// CLASS\r\n\t\t\tif (subjectName.startsWith(OCommandExecutorSQLAbstract.CLASS_PREFIX))\r\n\t\t\t\tsubjectName = subjectName.substring(OCommandExecutorSQLAbstract.CLASS_PREFIX.length());\r\n\r\n\t\t\tfinal OClass cls = database.getMetadata().getSchema().getClass(subjectName);\r\n\t\t\tif (cls == null)\r\n\t\t\t\tthrow new OCommandSQLParsingException(\"Class \" + subjectName + \" not found in database\", text, pos);\r\n\r\n\t\t\tclassName = cls.getName();\r\n\t\t}\r\n\r\n\t\tfinal int beginFields = OStringParser.jumpWhiteSpaces(text, pos);\r\n\t\tif (beginFields == -1 || text.charAt(beginFields) != '(')\r\n\t\t\tthrow new OCommandSQLParsingException(\"Set of fields is missed. Example: (name, surname)\", text, pos);\r\n\r\n\t\tfinal int endFields = text.indexOf(')', beginFields + 1);\r\n\t\tif (endFields == -1)\r\n\t\t\tthrow new OCommandSQLParsingException(\"Missed closed brace\", text, beginFields);\r\n\r\n\t\tfieldNames = new ArrayList<String>();\r\n\t\tOStringSerializerHelper.getParameters(text, beginFields, fieldNames);\r\n\t\tif (fieldNames.size() == 0)\r\n\t\t\tthrow new OCommandSQLParsingException(\"Set of fields is empty. Example: (name, surname)\", text, endFields);\r\n\r\n\t\tpos = OSQLHelper.nextWord(text, textUpperCase, endFields + 1, word, true);\r\n\t\tif (pos == -1 || !word.toString().equals(KEYWORD_VALUES))\r\n\t\t\tthrow new OCommandSQLParsingException(\"Missed VALUES keyword\", text, endFields);\r\n\r\n\t\tfinal int beginValues = OStringParser.jumpWhiteSpaces(text, pos + 1);\r\n\t\tif (pos == -1 || text.charAt(beginValues) != '(')\r\n\t\t\tthrow new OCommandSQLParsingException(\"Set of values is missed. Example: ('Bill', 'Stuart', 300)\", text, pos);\r\n\r\n\t\tfinal int endValues = text.indexOf(')', beginValues + 1);\r\n\t\tif (endValues == -1)\r\n\t\t\tthrow new OCommandSQLParsingException(\"Missed closed brace\", text, beginValues);\r\n\r\n\t\tfinal List<String> values = OStringSerializerHelper.smartSplit(text.substring(beginValues + 1, endValues), ',');\r\n\r\n\t\tif (values.size() == 0)\r\n\t\t\tthrow new OCommandSQLParsingException(\"Set of values is empty. Example: ('Bill', 'Stuart', 300)\", text, beginValues);\r\n\r\n\t\tif (values.size() != fieldNames.size())\r\n\t\t\tthrow new OCommandSQLParsingException(\"Fields not match with values\", text, beginValues);\r\n\r\n\t\t// TRANSFORM FIELD VALUES\r\n\t\tfieldValues = new Object[values.size()];\r\n\t\tfor (int i = 0; i < values.size(); ++i)\r\n\t\t\tfieldValues[i] = OSQLHelper.parseValue(database, this, values.get(i));\r\n\r\n\t\treturn this;\r\n\t}","commit_id":"b3d89e2edf9200fb41ac1365897f9b407dc0e8f3","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Convert fields from text to real value. Supports: String, RID, Boolean, Float, Integer and NULL.\r\n\t * \r\n\t * @param iDatabase\r\n\t * @param iValue\r\n\t *          Value to convert.\r\n\t * @return The value converted if recognized, otherwise VALUE_NOT_PARSED\r\n\t */\r\n\tpublic static Object parseValue(final ODatabaseRecord iDatabase, String iValue) {\r\n\t\tif (iValue == null)\r\n\t\t\treturn null;\r\n\r\n\t\tiValue = iValue.trim();\r\n\r\n\t\tObject fieldValue = VALUE_NOT_PARSED;\r\n\r\n\t\tif (iValue.startsWith(\"'\") && iValue.endsWith(\"'\"))\r\n\t\t\t// STRING\r\n\t\t\tfieldValue = stringContent(iValue);\r\n\t\telse if (iValue.charAt(0) == OStringSerializerHelper.COLLECTION_BEGIN\r\n\t\t\t\t&& iValue.charAt(iValue.length() - 1) == OStringSerializerHelper.COLLECTION_END) {\r\n\t\t\t// COLLECTION/ARRAY\r\n\t\t\tfinal List<String> items = OStringSerializerHelper.smartSplit(iValue.substring(1, iValue.length() - 1),\r\n\t\t\t\t\tOStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\tfinal List<Object> coll = new ArrayList<Object>();\r\n\t\t\tfor (String item : items) {\r\n\t\t\t\tcoll.add(parseValue(iDatabase, item));\r\n\t\t\t}\r\n\t\t\tfieldValue = coll;\r\n\r\n\t\t} else if (iValue.indexOf(':') > 0)\r\n\t\t\t// RID\r\n\t\t\tfieldValue = new ORecordId(iValue.trim());\r\n\t\telse {\r\n\r\n\t\t\tfinal String upperCase = iValue.toUpperCase();\r\n\t\t\tif (upperCase.equals(\"NULL\"))\r\n\t\t\t\t// NULL\r\n\t\t\t\tfieldValue = null;\r\n\t\t\telse if (upperCase.equals(\"NOT NULL\"))\r\n\t\t\t\t// NULL\r\n\t\t\t\tfieldValue = NOT_NULL;\r\n\t\t\telse if (upperCase.equals(\"TRUE\"))\r\n\t\t\t\t// BOOLEAN, TRUE\r\n\t\t\t\tfieldValue = Boolean.TRUE;\r\n\t\t\telse if (upperCase.equals(\"FALSE\"))\r\n\t\t\t\t// BOOLEAN, FALSE\r\n\t\t\t\tfieldValue = Boolean.FALSE;\r\n\t\t\telse {\r\n\t\t\t\tfinal Object v = parseStringNumber(iValue);\r\n\t\t\t\tif (v != null)\r\n\t\t\t\t\tfieldValue = v;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn fieldValue;\r\n\t}","id":102395,"modified_method":"/**\r\n\t * Convert fields from text to real value. Supports: String, RID, Boolean, Float, Integer and NULL.\r\n\t * \r\n\t * @param iDatabase\r\n\t * @param iValue\r\n\t *          Value to convert.\r\n\t * @return The value converted if recognized, otherwise VALUE_NOT_PARSED\r\n\t */\r\n\tpublic static Object parseValue(final ODatabaseRecord iDatabase, String iValue) {\r\n\t\tif (iValue == null)\r\n\t\t\treturn null;\r\n\r\n\t\tiValue = iValue.trim();\r\n\r\n\t\tObject fieldValue = VALUE_NOT_PARSED;\r\n\r\n\t\tif (iValue.startsWith(\"'\") && iValue.endsWith(\"'\") || iValue.startsWith(\"\\\"\") && iValue.endsWith(\"\\\"\"))\r\n\t\t\t// STRING\r\n\t\t\tfieldValue = stringContent(iValue);\r\n\t\telse if (iValue.charAt(0) == OStringSerializerHelper.COLLECTION_BEGIN\r\n\t\t\t\t&& iValue.charAt(iValue.length() - 1) == OStringSerializerHelper.COLLECTION_END) {\r\n\t\t\t// COLLECTION/ARRAY\r\n\t\t\tfinal List<String> items = OStringSerializerHelper.smartSplit(iValue.substring(1, iValue.length() - 1),\r\n\t\t\t\t\tOStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\tfinal List<Object> coll = new ArrayList<Object>();\r\n\t\t\tfor (String item : items) {\r\n\t\t\t\tcoll.add(parseValue(iDatabase, item));\r\n\t\t\t}\r\n\t\t\tfieldValue = coll;\r\n\r\n\t\t} else if (iValue.indexOf(':') > 0)\r\n\t\t\t// RID\r\n\t\t\tfieldValue = new ORecordId(iValue.trim());\r\n\t\telse {\r\n\r\n\t\t\tfinal String upperCase = iValue.toUpperCase();\r\n\t\t\tif (upperCase.equals(\"NULL\"))\r\n\t\t\t\t// NULL\r\n\t\t\t\tfieldValue = null;\r\n\t\t\telse if (upperCase.equals(\"NOT NULL\"))\r\n\t\t\t\t// NULL\r\n\t\t\t\tfieldValue = NOT_NULL;\r\n\t\t\telse if (upperCase.equals(\"TRUE\"))\r\n\t\t\t\t// BOOLEAN, TRUE\r\n\t\t\t\tfieldValue = Boolean.TRUE;\r\n\t\t\telse if (upperCase.equals(\"FALSE\"))\r\n\t\t\t\t// BOOLEAN, FALSE\r\n\t\t\t\tfieldValue = Boolean.FALSE;\r\n\t\t\telse {\r\n\t\t\t\tfinal Object v = parseStringNumber(iValue);\r\n\t\t\t\tif (v != null)\r\n\t\t\t\t\tfieldValue = v;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn fieldValue;\r\n\t}","commit_id":"b3d89e2edf9200fb41ac1365897f9b407dc0e8f3","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Execute the command and return the ODocument object created.\r\n   */\r\n  public Object execute(final Map<Object, Object> iArgs) {\r\n    if (clazz == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    final OrientBaseGraph graph = OGraphCommandExecutorSQLFactory.getGraph();\r\n\r\n    final OrientVertex vertex = graph.addVertex(clazz.getName(), clusterName);\r\n\r\n    if (fields != null)\r\n      // EVALUATE FIELDS\r\n      for (Entry<String, Object> f : fields.entrySet()) {\r\n        if (f.getValue() instanceof OSQLFunctionRuntime)\r\n          fields.put(f.getKey(), ((OSQLFunctionRuntime) f.getValue()).getValue(vertex.getRecord(), context));\r\n      }\r\n\r\n    OSQLHelper.bindParameters(vertex.getRecord(), fields, new OCommandParameters(iArgs), context);\r\n\r\n    if (content != null)\r\n      vertex.getRecord().merge(content, true, false);\r\n\r\n    vertex.save();\r\n\r\n    return vertex.getRecord();\r\n  }","id":102396,"modified_method":"/**\r\n   * Execute the command and return the ODocument object created.\r\n   */\r\n  public Object execute(final Map<Object, Object> iArgs) {\r\n    if (clazz == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    final OrientBaseGraph graph = OGraphCommandExecutorSQLFactory.getGraph();\r\n\r\n    final OrientVertex vertex = graph.addTemporaryVertex(clazz.getName());\r\n\r\n    if (fields != null)\r\n      // EVALUATE FIELDS\r\n      for (Entry<String, Object> f : fields.entrySet()) {\r\n        if (f.getValue() instanceof OSQLFunctionRuntime)\r\n          fields.put(f.getKey(), ((OSQLFunctionRuntime) f.getValue()).getValue(vertex.getRecord(), context));\r\n      }\r\n\r\n    OSQLHelper.bindParameters(vertex.getRecord(), fields, new OCommandParameters(iArgs), context);\r\n\r\n    if (content != null)\r\n      vertex.getRecord().merge(content, true, false);\r\n\r\n    if (clusterName != null)\r\n      vertex.save(clusterName);\r\n    else\r\n      vertex.save();\r\n\r\n    return vertex.getRecord();\r\n  }","commit_id":"e39c0d9c01c248025df0d5aba49bd2237590647c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\r\n  public void testCreateEdgeDefaultClass() {\r\n    database.command(new OCommandSQL(\"create class V1 extends V\")).execute();\r\n    database.command(new OCommandSQL(\"create class E1 extends E\")).execute();\r\n    database.getMetadata().getSchema().reload();\r\n\r\n    // VERTEXES\r\n    ODocument v1 = database.command(new OCommandSQL(\"create vertex\")).execute();\r\n    Assert.assertEquals(v1.getClassName(), OGraphDatabase.VERTEX_ALIAS);\r\n\r\n    ODocument v2 = database.command(new OCommandSQL(\"create vertex V1\")).execute();\r\n    Assert.assertEquals(v2.getClassName(), \"V1\");\r\n\r\n    ODocument v3 = database.command(new OCommandSQL(\"create vertex set brand = 'fiat'\")).execute();\r\n    Assert.assertEquals(v3.getClassName(), OGraphDatabase.VERTEX_ALIAS);\r\n    Assert.assertEquals(v3.field(\"brand\"), \"fiat\");\r\n\r\n    ODocument v4 = database.command(new OCommandSQL(\"create vertex V1 set brand = 'fiat',name = 'wow'\")).execute();\r\n    Assert.assertEquals(v4.getClassName(), \"V1\");\r\n    Assert.assertEquals(v4.field(\"brand\"), \"fiat\");\r\n    Assert.assertEquals(v4.field(\"name\"), \"wow\");\r\n\r\n    ODocument v5 = database.command(new OCommandSQL(\"create vertex V1 cluster default\")).execute();\r\n    Assert.assertEquals(v5.getClassName(), \"V1\");\r\n    Assert.assertEquals(v5.getIdentity().getClusterId(), database.getDefaultClusterId());\r\n\r\n    // EDGES\r\n    List<Object> edges = database.command(new OCommandSQL(\"create edge from \" + v1.getIdentity() + \" to \" + v2.getIdentity()))\r\n        .execute();\r\n    Assert.assertFalse(edges.isEmpty());\r\n\r\n    edges = database.command(new OCommandSQL(\"create edge E1 from \" + v1.getIdentity() + \" to \" + v3.getIdentity())).execute();\r\n    Assert.assertFalse(edges.isEmpty());\r\n\r\n    edges = database.command(\r\n        new OCommandSQL(\"create edge from \" + v1.getIdentity() + \" to \" + v4.getIdentity() + \" set weight = 3\")).execute();\r\n    Assert.assertFalse(edges.isEmpty());\r\n    ODocument e3 = ((OIdentifiable) edges.get(0)).getRecord();\r\n    Assert.assertEquals(e3.getClassName(), OGraphDatabase.EDGE_CLASS_NAME);\r\n    Assert.assertEquals(e3.field(\"out\"), v1);\r\n    Assert.assertEquals(e3.field(\"in\"), v4);\r\n    Assert.assertEquals(e3.field(\"weight\"), 3);\r\n\r\n    edges = database.command(\r\n        new OCommandSQL(\"create edge E1 from \" + v2.getIdentity() + \" to \" + v3.getIdentity() + \" set weight = 10\")).execute();\r\n    Assert.assertFalse(edges.isEmpty());\r\n    ODocument e4 = ((OIdentifiable) edges.get(0)).getRecord();\r\n    Assert.assertEquals(e4.getClassName(), \"E1\");\r\n    Assert.assertEquals(e4.field(\"out\"), v2);\r\n    Assert.assertEquals(e4.field(\"in\"), v3);\r\n    Assert.assertEquals(e4.field(\"weight\"), 10);\r\n\r\n    edges = database\r\n        .command(\r\n            new OCommandSQL(\"create edge e1 cluster default from \" + v3.getIdentity() + \" to \" + v5.getIdentity()\r\n                + \" set weight = 17\")).execute();\r\n    Assert.assertFalse(edges.isEmpty());\r\n    ODocument e5 = ((OIdentifiable) edges.get(0)).getRecord();\r\n    Assert.assertEquals(e5.getClassName(), \"E1\");\r\n    Assert.assertEquals(e5.getIdentity().getClusterId(), database.getDefaultClusterId());\r\n  }","id":102397,"modified_method":"@Test\r\n  public void testCreateEdgeDefaultClass() {\r\n    database.command(new OCommandSQL(\"create class V1 extends V\")).execute();\r\n    database.command(new OCommandSQL(\"create class E1 extends E\")).execute();\r\n    database.getMetadata().getSchema().reload();\r\n\r\n    // VERTEXES\r\n    ODocument v1 = database.command(new OCommandSQL(\"create vertex\")).execute();\r\n    Assert.assertEquals(v1.getClassName(), OGraphDatabase.VERTEX_ALIAS);\r\n\r\n    ODocument v2 = database.command(new OCommandSQL(\"create vertex V1\")).execute();\r\n    Assert.assertEquals(v2.getClassName(), \"V1\");\r\n\r\n    ODocument v3 = database.command(new OCommandSQL(\"create vertex set brand = 'fiat'\")).execute();\r\n    Assert.assertEquals(v3.getClassName(), OGraphDatabase.VERTEX_ALIAS);\r\n    Assert.assertEquals(v3.field(\"brand\"), \"fiat\");\r\n\r\n    ODocument v4 = database.command(new OCommandSQL(\"create vertex V1 set brand = 'fiat',name = 'wow'\")).execute();\r\n    Assert.assertEquals(v4.getClassName(), \"V1\");\r\n    Assert.assertEquals(v4.field(\"brand\"), \"fiat\");\r\n    Assert.assertEquals(v4.field(\"name\"), \"wow\");\r\n\r\n    ODocument v5 = database.command(new OCommandSQL(\"create vertex V1 cluster default\")).execute();\r\n    Assert.assertEquals(v5.getClassName(), \"V1\");\r\n    Assert.assertEquals(v5.getIdentity().getClusterId(), database.getDefaultClusterId());\r\n\r\n    // EDGES\r\n    List<Object> edges = database.command(new OCommandSQL(\"create edge from \" + v1.getIdentity() + \" to \" + v2.getIdentity()))\r\n        .execute();\r\n    Assert.assertFalse(edges.isEmpty());\r\n\r\n    edges = database.command(new OCommandSQL(\"create edge E1 from \" + v1.getIdentity() + \" to \" + v3.getIdentity())).execute();\r\n    Assert.assertFalse(edges.isEmpty());\r\n\r\n    edges = database.command(\r\n        new OCommandSQL(\"create edge from \" + v1.getIdentity() + \" to \" + v4.getIdentity() + \" set weight = 3\")).execute();\r\n    Assert.assertFalse(edges.isEmpty());\r\n    ODocument e3 = ((OIdentifiable) edges.get(0)).getRecord();\r\n    Assert.assertEquals(e3.getClassName(), OGraphDatabase.EDGE_ALIAS);\r\n    Assert.assertEquals(e3.field(\"out\"), v1);\r\n    Assert.assertEquals(e3.field(\"in\"), v4);\r\n    Assert.assertEquals(e3.field(\"weight\"), 3);\r\n\r\n    edges = database.command(\r\n        new OCommandSQL(\"create edge E1 from \" + v2.getIdentity() + \" to \" + v3.getIdentity() + \" set weight = 10\")).execute();\r\n    Assert.assertFalse(edges.isEmpty());\r\n    ODocument e4 = ((OIdentifiable) edges.get(0)).getRecord();\r\n    Assert.assertEquals(e4.getClassName(), \"E1\");\r\n    Assert.assertEquals(e4.field(\"out\"), v2);\r\n    Assert.assertEquals(e4.field(\"in\"), v3);\r\n    Assert.assertEquals(e4.field(\"weight\"), 10);\r\n\r\n    edges = database\r\n        .command(\r\n            new OCommandSQL(\"create edge e1 cluster default from \" + v3.getIdentity() + \" to \" + v5.getIdentity()\r\n                + \" set weight = 17\")).execute();\r\n    Assert.assertFalse(edges.isEmpty());\r\n    ODocument e5 = ((OIdentifiable) edges.get(0)).getRecord();\r\n    Assert.assertEquals(e5.getClassName(), \"E1\");\r\n    Assert.assertEquals(e5.getIdentity().getClusterId(), database.getDefaultClusterId());\r\n  }","commit_id":"e39c0d9c01c248025df0d5aba49bd2237590647c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void checkDijkstra() {\r\n    String subquery = \"select $current, $target, Dijkstra($current, $target , 'weight') as path from V let $target = ( select from V where name = \\'C\\' ) where 1 > 0\";\r\n    List<ODocument> result = graph.command(new OSQLSynchQuery<ODocument>(subquery)).execute();\r\n    Assert.assertFalse(result.isEmpty());\r\n\r\n    for (ODocument d : result) {\r\n      System.out.println(\"Shortest path from \" + ((ODocument) d.field(\"$current\")).field(\"name\") + \" and \"\r\n          + ((Collection<ODocument>) d.field(\"$target\")).iterator().next().field(\"name\") + \" is: \" + d.field(\"path\"));\r\n    }\r\n  }","id":102398,"modified_method":"public void checkDijkstra() {\r\n    String subquery = \"select $current, $target, Dijkstra($current, $target , 'weight') as path from V let $target = ( select from V where name = \\'C\\' ) where 1 > 0\";\r\n    Iterable<ODocument> result = graph.command(new OSQLSynchQuery<ODocument>(subquery)).execute();\r\n    Assert.assertTrue(result.iterator().hasNext());\r\n\r\n    for (ODocument d : result) {\r\n      System.out.println(\"Shortest path from \" + ((ODocument) d.field(\"$current\")).field(\"name\") + \" and \"\r\n          + ((Collection<ODocument>) d.field(\"$target\")).iterator().next().field(\"name\") + \" is: \" + d.field(\"path\"));\r\n    }\r\n  }","commit_id":"e39c0d9c01c248025df0d5aba49bd2237590647c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\"))) {\n        final SNode statementList = SNodeOperations.cast(SNodeOperations.getParent(node), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\"));\n        final Wrappers._int index = new Wrappers._int(ListSequence.fromList(SLinkOperations.getChildren(statementList, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).indexOf(node));\n        ListSequence.fromList(SLinkOperations.getChildren(statementList, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).removeElementAt(index.value);\n        ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).visitAll(new IVisitor<SNode>() {\n          public void visit(SNode it) {\n            ListSequence.fromList(SLinkOperations.getChildren(statementList, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).insertElement(index.value, it);\n            index.value += 1;\n          }\n        });\n        SNodeOperations.deleteNode(node);\n\n      } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, \"jetbrains.mps.baseLanguage.structure.IfStatement\")) && SNodeOperations.hasRole(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\"))) {\n        if (!(SNodeOperations.isInstanceOf(SNodeOperations.getParent(SNodeOperations.getParent(node)), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\")))) {\n          SNodeOperations.detachNode(node);\n        } else {\n          while (ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).isNotEmpty()) {\n            SNodeOperations.insertNextSiblingChild(SNodeOperations.getParent(node), ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).last());\n          }\n          SNodeOperations.detachNode(node);\n        }\n      }\n    }","id":102399,"modified_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\"))) {\n        UnwrapStatementsUtil.unwrapStatementListInContainer(node, SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\")));\n      } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, \"jetbrains.mps.baseLanguage.structure.IfStatement\")) && SNodeOperations.hasRole(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\"))) {\n        SNode nodeToSelect = UnwrapStatementsUtil.unwrapElse(SNodeOperations.cast(SNodeOperations.getParent(node), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, \"jetbrains.mps.baseLanguage.structure.IfStatement\")));\n        SelectionUtil.selectCell(editorContext, nodeToSelect, SelectionManager.FIRST_CELL);\n      }\n    }","commit_id":"306fece56325542ad187db133220420dacff422b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\"))) {\n        final SNode statementList = SNodeOperations.cast(SNodeOperations.getParent(node), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\"));\n        final Wrappers._int index = new Wrappers._int(ListSequence.fromList(SLinkOperations.getChildren(statementList, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).indexOf(node));\n        ListSequence.fromList(SLinkOperations.getChildren(statementList, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).removeElementAt(index.value);\n        ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).visitAll(new IVisitor<SNode>() {\n          public void visit(SNode it) {\n            ListSequence.fromList(SLinkOperations.getChildren(statementList, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).insertElement(index.value, it);\n            index.value += 1;\n          }\n        });\n        SNodeOperations.deleteNode(node);\n\n      } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, \"jetbrains.mps.baseLanguage.structure.IfStatement\")) && SNodeOperations.hasRole(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\"))) {\n        if (!(SNodeOperations.isInstanceOf(SNodeOperations.getParent(SNodeOperations.getParent(node)), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\")))) {\n          SNodeOperations.detachNode(node);\n        } else {\n          while (ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).isNotEmpty()) {\n            SNodeOperations.insertNextSiblingChild(SNodeOperations.getParent(node), ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).last());\n          }\n          SNodeOperations.detachNode(node);\n        }\n      }\n    }","id":102400,"modified_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\"))) {\n        UnwrapStatementsUtil.unwrapStatementListInContainer(node, SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\")));\n      } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, \"jetbrains.mps.baseLanguage.structure.IfStatement\")) && SNodeOperations.hasRole(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\"))) {\n        SNode nodeToSelect = UnwrapStatementsUtil.unwrapElse(SNodeOperations.cast(SNodeOperations.getParent(node), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, \"jetbrains.mps.baseLanguage.structure.IfStatement\")));\n        SelectionUtil.selectCell(editorContext, nodeToSelect, SelectionManager.FIRST_CELL);\n      }\n    }","commit_id":"306fece56325542ad187db133220420dacff422b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      if (ListSequence.fromList(SLinkOperations.getChildren(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0x118cecf1287L, \"elsifClauses\"))).isNotEmpty()) {\n        SNodeOperations.deleteNode(ListSequence.fromList(SLinkOperations.getChildren(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0x118cecf1287L, \"elsifClauses\"))).first());\n      } else if ((SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")) != null)) {\n        UnwrapStatementsUtil.unwrapElse(node);\n      } else if (ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xf8cc56b219L, \"ifTrue\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).isNotEmpty()) {\n        UnwrapStatementsUtil.unwrapIf(node);\n      } else {\n        SNodeOperations.deleteNode(node);\n      }\n    }","id":102401,"modified_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      if (ListSequence.fromList(SLinkOperations.getChildren(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0x118cecf1287L, \"elsifClauses\"))).isNotEmpty()) {\n        SNodeOperations.deleteNode(ListSequence.fromList(SLinkOperations.getChildren(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0x118cecf1287L, \"elsifClauses\"))).first());\n      } else if ((SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")) != null)) {\n        SNode nodeToSelect = UnwrapStatementsUtil.unwrapElse(node);\n        SelectionUtil.selectCell(editorContext, nodeToSelect, SelectionManager.FIRST_CELL);\n      } else if (ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xf8cc56b219L, \"ifTrue\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).isNotEmpty()) {\n        UnwrapStatementsUtil.unwrapIf(node);\n      } else {\n        SNodeOperations.deleteNode(node);\n      }\n    }","commit_id":"306fece56325542ad187db133220420dacff422b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      if (ListSequence.fromList(SLinkOperations.getChildren(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0x118cecf1287L, \"elsifClauses\"))).isNotEmpty()) {\n        SNodeOperations.deleteNode(ListSequence.fromList(SLinkOperations.getChildren(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0x118cecf1287L, \"elsifClauses\"))).first());\n      } else if ((SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")) != null)) {\n        UnwrapStatementsUtil.unwrapElse(node);\n      } else if (ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xf8cc56b219L, \"ifTrue\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).isNotEmpty()) {\n        UnwrapStatementsUtil.unwrapIf(node);\n      } else {\n        SNodeOperations.deleteNode(node);\n      }\n    }","id":102402,"modified_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      if (ListSequence.fromList(SLinkOperations.getChildren(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0x118cecf1287L, \"elsifClauses\"))).isNotEmpty()) {\n        SNodeOperations.deleteNode(ListSequence.fromList(SLinkOperations.getChildren(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0x118cecf1287L, \"elsifClauses\"))).first());\n      } else if ((SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")) != null)) {\n        SNode nodeToSelect = UnwrapStatementsUtil.unwrapElse(node);\n        SelectionUtil.selectCell(editorContext, nodeToSelect, SelectionManager.FIRST_CELL);\n      } else if (ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(node, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xf8cc56b219L, \"ifTrue\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).isNotEmpty()) {\n        UnwrapStatementsUtil.unwrapIf(node);\n      } else {\n        SNodeOperations.deleteNode(node);\n      }\n    }","commit_id":"306fece56325542ad187db133220420dacff422b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      UnwrapStatementsUtil.unwrapElse(node);\n    }","id":102403,"modified_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      SNode nodeToSelect = UnwrapStatementsUtil.unwrapElse(node);\n      SelectionUtil.selectCell(editorContext, nodeToSelect, SelectionManager.FIRST_CELL);\n    }","commit_id":"306fece56325542ad187db133220420dacff422b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      UnwrapStatementsUtil.unwrapElse(node);\n    }","id":102404,"modified_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      SNode nodeToSelect = UnwrapStatementsUtil.unwrapElse(node);\n      SelectionUtil.selectCell(editorContext, nodeToSelect, SelectionManager.FIRST_CELL);\n    }","commit_id":"306fece56325542ad187db133220420dacff422b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void unwrapElse(SNode ifStatement) {\n    if (!(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, \"jetbrains.mps.baseLanguage.structure.BlockStatement\")))) {\n      SNode block = SNodeFactoryOperations.createNewNode(SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, \"jetbrains.mps.baseLanguage.structure.BlockStatement\")), null);\n      ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(block, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(SLinkOperations.getTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")));\n      SLinkOperations.setTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\"), block);\n    }\n    assert SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, \"jetbrains.mps.baseLanguage.structure.BlockStatement\"));\n    unwrapStatementListInContainer(ifStatement, SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, \"jetbrains.mps.baseLanguage.structure.BlockStatement\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\")));\n  }","id":102405,"modified_method":"public static SNode unwrapElse(final SNode ifStatement) {\n    if (!(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, \"jetbrains.mps.baseLanguage.structure.BlockStatement\")))) {\n      SNode block = SNodeFactoryOperations.createNewNode(SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, \"jetbrains.mps.baseLanguage.structure.BlockStatement\")), null);\n      ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(block, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(SLinkOperations.getTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")));\n      SLinkOperations.setTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\"), block);\n    }\n    assert SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, \"jetbrains.mps.baseLanguage.structure.BlockStatement\"));\n\n    Iterable<SNode> commentedNodes = CommentUtil.uncommentAll(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, \"jetbrains.mps.baseLanguage.structure.BlockStatement\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\")));\n    List<SNode> statements = SLinkOperations.getChildren(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, \"jetbrains.mps.baseLanguage.structure.BlockStatement\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"));\n    ListSequence.fromList(statements).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        SNodeOperations.insertNextSiblingChild(ifStatement, it);\n      }\n    });\n    SNodeOperations.deleteNode(SLinkOperations.getTarget(ifStatement, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b217L, 0xfc092b6b76L, \"ifFalseStatement\")));\n    CommentUtil.commentOutAll(commentedNodes);\n    return ListSequence.fromList(statements).last();\n  }","commit_id":"306fece56325542ad187db133220420dacff422b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isExcluded(VirtualFile file) {\n    if (myGlobalClassPathIndex.isExcluded(file)) return true;\n\n    Set<FilePath> excludedPaths = myGlobalClassPathIndex.getExcludedClassPath();\n    for (FilePath excludedFile : excludedPaths) {\n      if (VfsUtil.isAncestor(excludedFile.getIOFile(), VFileSystem.toFile(file), false)) {\n        return true;\n      }\n    }\n\n    String filePath = file.getPath();\n    for (String regexp : myExcludedRegexps) {\n      if (filePath.matches(regexp)) {\n        return true;\n      }\n\n    }\n\n    return FileTypeManager.getInstance().isFileIgnored(file.getPath());\n  }","id":102406,"modified_method":"public boolean isExcluded(VirtualFile file) {\n    if (myGlobalClassPathIndex.isExcluded(file)) return true;\n\n    String filePath = file.getPath();\n    for (String regexp : myExcludedRegexps) {\n      if (filePath.matches(regexp)) {\n        return true;\n      }\n    }\n\n    if (FileTypeManager.getInstance().isFileIgnored(file.getPath())) {\n      return true;\n    }\n\n    VirtualFile parent = file.getParent();\n    while (true) {\n      if (parent == null) return false;\n      if (myGlobalClassPathIndex.isExcluded(parent)) return true;      \n      parent = parent.getParent();\n    }\n  }","commit_id":"7123957be135d8ba3eccfd03a1dbb76c3ec100dc","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void line( final String string )\n    {\n        try\n        {\n            fw.append( string + \"\\n\" );\n        }\n        catch ( IOException e )\n        {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }","id":102407,"modified_method":"private void line( FileWriter fw, final String string )\n    {\n        try\n        {\n            fw.append( string + \"\\n\" );\n        }\n        catch ( IOException e )\n        {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }","commit_id":"db8f7378a03a31a61361094c8acfd39d77f2a858","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void document( final DocumentationData data )\n    {\n        try\n        {\n            if ( data.title == null )\n            {\n                return;\n            }\n            File dirs = new File( \"target/rest-api\" );\n            if ( !dirs.exists() )\n            {\n                dirs.mkdirs();\n            }\n            String name = data.title.replace( \" \", \"-\" ).toLowerCase();\n            File out = new File( dirs, name + \".txt\" );\n            out.createNewFile();\n\n            fw = new FileWriter( out, false );\n\n            line( \"[[rest-api-\" + name + \"]]\" );\n            line( \"== \" + data.title + \" ==\" );\n            line( \"\" );\n            line( \"_Example request_\" );\n            line( \"\" );\n            line( \"* *+\" + data.method + \"+*  +\" + data.uri + \"+\" );\n            if ( data.requestHeaders != null )\n            {\n                for ( Entry<String, String> header : data.requestHeaders.entrySet() )\n                {\n                    line( \"* *+\" + header.getKey() + \":+* +\"\n                            + header.getValue() + \"+\" );\n                }\n            }\n            if ( data.payload != null && !data.payload.equals( \"null\" ) )\n            {\n                line( \"[source,javascript]\" );\n                line( \"----\" );\n                line( data.payload );\n                line( \"----\" );\n            }\n            line( \"\" );\n            line( \"_Example response_\" );\n            line( \"\" );\n            line( \"* *+\" + data.status.getStatusCode() + \":+* +\"\n                    + data.status.name() + \"+\" );\n            if ( data.responseHeaders != null )\n            {\n                for ( Entry<String, String> header : data.responseHeaders.entrySet() )\n                {\n                    line( \"* *+\" + header.getKey() + \":+* +\"\n                            + header.getValue() + \"+\" );\n                }\n            }\n            if ( data.entity != null )\n            {\n                line( \"[source,javascript]\" );\n                line( \"----\" );\n                line( data.entity );\n                line( \"----\" );\n                line( \"\" );\n            }\n            fw.flush();\n            fw.close();\n        }\n        catch ( IOException e )\n        {\n            fail();\n            e.printStackTrace();\n        }\n\n    }","id":102408,"modified_method":"protected void document( final DocumentationData data )\n    {\n        FileWriter fw = null;\n        try\n        {\n            if ( data.title == null )\n            {\n                return;\n            }\n            File dirs = new File( \"target/rest-api\" );\n            if ( !dirs.exists() )\n            {\n                dirs.mkdirs();\n            }\n            String name = data.title.replace( \" \", \"-\" ).toLowerCase();\n            File out = new File( dirs, name + \".txt\" );\n            if ( !out.createNewFile() )\n            {\n                throw new RuntimeException( \"File exists: \"\n                        + out.getAbsolutePath() );\n            }\n\n            fw = new FileWriter( out, false );\n\n            line( fw, \"[[rest-api-\" + name + \"]]\" );\n            line( fw, \"== \" + data.title + \" ==\" );\n            line( fw, \"\" );\n            line( fw, \"_Example request_\" );\n            line( fw, \"\" );\n            line( fw, \"* *+\" + data.method + \"+*  +\" + data.uri + \"+\" );\n            if ( data.requestHeaders != null )\n            {\n                for ( Entry<String, String> header : data.requestHeaders.entrySet() )\n                {\n                    line( fw, \"* *+\" + header.getKey() + \":+* +\"\n                            + header.getValue() + \"+\" );\n                }\n            }\n            if ( data.payload != null && !data.payload.equals( \"null\" ) )\n            {\n                line( fw, \"[source,javascript]\" );\n                line( fw, \"----\" );\n                line( fw, data.payload );\n                line( fw, \"----\" );\n            }\n            line( fw, \"\" );\n            line( fw, \"_Example response_\" );\n            line( fw, \"\" );\n            line( fw, \"* *+\" + data.status.getStatusCode() + \":+* +\"\n                    + data.status.name() + \"+\" );\n            if ( data.responseHeaders != null )\n            {\n                for ( Entry<String, String> header : data.responseHeaders.entrySet() )\n                {\n                    line( fw, \"* *+\" + header.getKey() + \":+* +\"\n                            + header.getValue() + \"+\" );\n                }\n            }\n            if ( data.entity != null )\n            {\n                line( fw, \"[source,javascript]\" );\n                line( fw, \"----\" );\n                line( fw, data.entity );\n                line( fw, \"----\" );\n                line( fw, \"\" );\n            }\n        }\n        catch ( IOException e )\n        {\n            fail();\n            e.printStackTrace();\n        }\n        finally\n        {\n            if ( fw != null )\n            {\n                try\n                {\n                    fw.close();\n                }\n                catch ( IOException e )\n                {\n                }\n            }\n        }\n    }","commit_id":"db8f7378a03a31a61361094c8acfd39d77f2a858","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void doGenerateText(SNode node) {\n    boolean oneLine = SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), \"jetbrains.mps.baseLanguage.structure.ParameterDeclaration\") || SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n    if (oneLine) {\n      this.append(\"@\");\n    } else {\n      this.appendWithIndent(\"@\");\n    }\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"annotation\", false), this);\n    this.append(this.getReferentResolveInfoOrName(\"annotation\", node));\n    if (ListSequence.fromList(SLinkOperations.getTargets(node, \"value\", true)).isNotEmpty()) {\n      this.append(\"(\");\n      if (ListSequence.fromList(SLinkOperations.getTargets(node, \"value\", true)).isNotEmpty()) {\n        for (SNode item : SLinkOperations.getTargets(node, \"value\", true)) {\n          TextGenManager.instance().appendNodeText(this.getContext(), this.getBuffer(), item, this.getSNode());\n          if (item != ListSequence.fromList(SLinkOperations.getTargets(node, \"value\", true)).last()) {\n            this.append(\", \");\n          }\n        }\n      }\n      this.append(\")\");\n    }\n    if (oneLine) {\n      this.append(\" \");\n    } else {\n      this.appendNewLine();\n    }\n  }","id":102409,"modified_method":"public void doGenerateText(SNode node) {\n    boolean oneLine = SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), \"jetbrains.mps.baseLanguage.structure.ParameterDeclaration\") || SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n    if (oneLine) {\n      this.append(\"@\");\n    } else {\n      this.appendWithIndent(\"@\");\n    }\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"annotation\", false), this);\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.AnnotationInstance\", \"annotation\"))));\n    if (ListSequence.fromList(SLinkOperations.getTargets(node, \"value\", true)).isNotEmpty()) {\n      this.append(\"(\");\n      if (ListSequence.fromList(SLinkOperations.getTargets(node, \"value\", true)).isNotEmpty()) {\n        for (SNode item : SLinkOperations.getTargets(node, \"value\", true)) {\n          TextGenManager.instance().appendNodeText(this.getContext(), this.getBuffer(), item, this.getSNode());\n          if (item != ListSequence.fromList(SLinkOperations.getTargets(node, \"value\", true)).last()) {\n            this.append(\", \");\n          }\n        }\n      }\n      this.append(\")\");\n    }\n    if (oneLine) {\n      this.append(\" \");\n    } else {\n      this.appendNewLine();\n    }\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"classifier\", false), this);\n    this.append(this.getReferentResolveInfoOrName(\"classifier\", node));\n    if (ListSequence.fromList(SLinkOperations.getTargets(node, \"typeParameter\", true)).isNotEmpty()) {\n      this.append(\"<\");\n      if (ListSequence.fromList(SLinkOperations.getTargets(node, \"typeParameter\", true)).isNotEmpty()) {\n        for (SNode item : SLinkOperations.getTargets(node, \"typeParameter\", true)) {\n          TextGenManager.instance().appendNodeText(this.getContext(), this.getBuffer(), item, this.getSNode());\n          if (item != ListSequence.fromList(SLinkOperations.getTargets(node, \"typeParameter\", true)).last()) {\n            this.append(\", \");\n          }\n        }\n      }\n      this.append(\">\");\n    }\n    if (ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).isNotEmpty()) {\n      this.append(\"(\");\n      if (ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).isNotEmpty()) {\n        for (SNode item : SLinkOperations.getTargets(node, \"parameter\", true)) {\n          TextGenManager.instance().appendNodeText(this.getContext(), this.getBuffer(), item, this.getSNode());\n          if (item != ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).last()) {\n            this.append(\", \");\n          }\n        }\n      }\n      this.append(\")\");\n    } else {\n      this.append(\"(\");\n      if (ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).isNotEmpty()) {\n        for (SNode item : SLinkOperations.getTargets(node, \"actualArgument\", true)) {\n          TextGenManager.instance().appendNodeText(this.getContext(), this.getBuffer(), item, this.getSNode());\n          if (item != ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).last()) {\n            this.append(\", \");\n          }\n        }\n      }\n      this.append(\")\");\n    }\n    if ((SLinkOperations.getTarget(node, \"instanceInitializer\", true) == null) && ListSequence.fromList(SLinkOperations.getTargets(node, \"field\", true)).isEmpty() && ListSequence.fromList(SLinkOperations.getTargets(node, \"method\", true)).isEmpty()) {\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(node, \"classifier\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\") && !(SPropertyOperations.getBoolean(SNodeOperations.cast(SLinkOperations.getTarget(node, \"classifier\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), \"abstractClass\"))) {\n        return;\n      } else {\n        this.append(\" {}\");\n        return;\n      }\n    }\n    this.append(\" {\");\n    this.increaseDepth();\n    BaseClassConceptTextGen.body(node, this);\n    this.decreaseDepth();\n    this.appendWithIndent(\"}\");\n  }","id":102410,"modified_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"classifier\", false), this);\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.AnonymousClass\", \"classifier\"))));\n    if (ListSequence.fromList(SLinkOperations.getTargets(node, \"typeParameter\", true)).isNotEmpty()) {\n      this.append(\"<\");\n      if (ListSequence.fromList(SLinkOperations.getTargets(node, \"typeParameter\", true)).isNotEmpty()) {\n        for (SNode item : SLinkOperations.getTargets(node, \"typeParameter\", true)) {\n          TextGenManager.instance().appendNodeText(this.getContext(), this.getBuffer(), item, this.getSNode());\n          if (item != ListSequence.fromList(SLinkOperations.getTargets(node, \"typeParameter\", true)).last()) {\n            this.append(\", \");\n          }\n        }\n      }\n      this.append(\">\");\n    }\n    if (ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).isNotEmpty()) {\n      this.append(\"(\");\n      if (ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).isNotEmpty()) {\n        for (SNode item : SLinkOperations.getTargets(node, \"parameter\", true)) {\n          TextGenManager.instance().appendNodeText(this.getContext(), this.getBuffer(), item, this.getSNode());\n          if (item != ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).last()) {\n            this.append(\", \");\n          }\n        }\n      }\n      this.append(\")\");\n    } else {\n      this.append(\"(\");\n      if (ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).isNotEmpty()) {\n        for (SNode item : SLinkOperations.getTargets(node, \"actualArgument\", true)) {\n          TextGenManager.instance().appendNodeText(this.getContext(), this.getBuffer(), item, this.getSNode());\n          if (item != ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).last()) {\n            this.append(\", \");\n          }\n        }\n      }\n      this.append(\")\");\n    }\n    if ((SLinkOperations.getTarget(node, \"instanceInitializer\", true) == null) && ListSequence.fromList(SLinkOperations.getTargets(node, \"field\", true)).isEmpty() && ListSequence.fromList(SLinkOperations.getTargets(node, \"method\", true)).isEmpty()) {\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(node, \"classifier\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\") && !(SPropertyOperations.getBoolean(SNodeOperations.cast(SLinkOperations.getTarget(node, \"classifier\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), \"abstractClass\"))) {\n        return;\n      } else {\n        this.append(\" {}\");\n        return;\n      }\n    }\n    this.append(\" {\");\n    this.increaseDepth();\n    BaseClassConceptTextGen.body(node, this);\n    this.decreaseDepth();\n    this.appendWithIndent(\"}\");\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void methodCall(SNode methodCall, final SNodeTextGen textGen) {\n    textGen.append(textGen.getReferentResolveInfoOrName(\"baseMethodDeclaration\", methodCall));\n    BaseLanguageTextGen.arguments(methodCall, textGen);\n  }","id":102411,"modified_method":"public static void methodCall(SNode methodCall, final SNodeTextGen textGen) {\n    textGen.append(textGen.getReferentPresentation(SNodeOperations.getReference(methodCall, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.IMethodCall\", \"baseMethodDeclaration\"))));\n    BaseLanguageTextGen.arguments(methodCall, textGen);\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false), this);\n    this.append(this.getReferentResolveInfoOrName(\"baseMethodDeclaration\", node));\n    BaseLanguageTextGen.typeParameters(SLinkOperations.getTargets(node, \"typeParameter\", true), this);\n    BaseLanguageTextGen.arguments(node, this);\n  }","id":102412,"modified_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false), this);\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.ClassCreator\", \"constructorDeclaration\"))));\n    BaseLanguageTextGen.typeParameters(SLinkOperations.getTargets(node, \"typeParameter\", true), this);\n    BaseLanguageTextGen.arguments(node, this);\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"classifier\", false), this);\n    this.append(this.getReferentResolveInfoOrName(\"classifier\", node));\n    this.append(\".class\");\n  }","id":102413,"modified_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"classifier\", false), this);\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.ClassifierClassExpression\", \"classifier\"))));\n    this.append(\".class\");\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"classifier\", false), this);\n    this.append(this.getReferentResolveInfoOrName(\"classifier\", node));\n    if (ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).isNotEmpty()) {\n      this.append(\"<\");\n      if (ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).isNotEmpty()) {\n        for (SNode item : SLinkOperations.getTargets(node, \"parameter\", true)) {\n          TextGenManager.instance().appendNodeText(this.getContext(), this.getBuffer(), item, this.getSNode());\n          if (item != ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).last()) {\n            this.append(\", \");\n          }\n        }\n      }\n      this.append(\">\");\n    }\n  }","id":102414,"modified_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"classifier\", false), this);\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.ClassifierType\", \"classifier\"))));\n    if (ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).isNotEmpty()) {\n      this.append(\"<\");\n      if (ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).isNotEmpty()) {\n        for (SNode item : SLinkOperations.getTargets(node, \"parameter\", true)) {\n          TextGenManager.instance().appendNodeText(this.getContext(), this.getBuffer(), item, this.getSNode());\n          if (item != ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).last()) {\n            this.append(\", \");\n          }\n        }\n      }\n      this.append(\">\");\n    }\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"enumClass\", false), this);\n    this.append(this.getReferentResolveInfoOrName(\"enumClass\", node));\n    this.append(\".\");\n    this.append(this.getReferentResolveInfoOrName(\"enumConstantDeclaration\", node));\n  }","id":102415,"modified_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"enumClass\", false), this);\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.EnumConstantReference\", \"enumClass\"))));\n    this.append(\".\");\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.EnumConstantReference\", \"enumConstantDeclaration\"))));\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"enumClass\", false), this);\n    this.append(this.getReferentResolveInfoOrName(\"enumClass\", node));\n    this.append(\".\");\n    this.append(\"valueOf(\");\n    TextGenManager.instance().appendNodeText(this.getContext(), this.getBuffer(), SLinkOperations.getTarget(node, \"value\", true), this.getSNode());\n    this.append(\")\");\n  }","id":102416,"modified_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"enumClass\", false), this);\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.EnumValueOfExpression\", \"enumClass\"))));\n    this.append(\".\");\n    this.append(\"valueOf(\");\n    TextGenManager.instance().appendNodeText(this.getContext(), this.getBuffer(), SLinkOperations.getTarget(node, \"value\", true), this.getSNode());\n    this.append(\")\");\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"enumClass\", false), this);\n    this.append(this.getReferentResolveInfoOrName(\"enumClass\", node));\n    this.append(\".values()\");\n  }","id":102417,"modified_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"enumClass\", false), this);\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.EnumValuesExpression\", \"enumClass\"))));\n    this.append(\".values()\");\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    this.append(this.getReferentResolveInfoOrName(\"fieldDeclaration\", node));\n  }","id":102418,"modified_method":"public void doGenerateText(SNode node) {\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.FieldReferenceOperation\", \"fieldDeclaration\"))));\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    this.append(this.getReferentResolveInfoOrName(\"variableDeclaration\", SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.VariableReference\")));\n  }","id":102419,"modified_method":"public void doGenerateText(SNode node) {\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.VariableReference\"), SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.VariableReference\", \"variableDeclaration\"))));\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    this.append(this.getReferentResolveInfoOrName(\"variableDeclaration\", SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.VariableReference\")));\n  }","id":102420,"modified_method":"public void doGenerateText(SNode node) {\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.VariableReference\"), SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.VariableReference\", \"variableDeclaration\"))));\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    this.append(this.getReferentResolveInfoOrName(\"variableDeclaration\", SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.VariableReference\")));\n  }","id":102421,"modified_method":"public void doGenerateText(SNode node) {\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.VariableReference\"), SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.VariableReference\", \"variableDeclaration\"))));\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"classifier\", false), this);\n    this.append(this.getReferentResolveInfoOrName(\"classifier\", node));\n    this.append(\".\");\n    this.append(this.getReferentResolveInfoOrName(\"variableDeclaration\", SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.VariableReference\")));\n  }","id":102422,"modified_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"classifier\", false), this);\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.StaticFieldReference\", \"classifier\"))));\n    this.append(\".\");\n    this.append(this.getReferentResolveInfoOrName(\"variableDeclaration\", SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.VariableReference\")));\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"classConcept\", false), this);\n    this.append(this.getReferentResolveInfoOrName(\"classConcept\", node));\n    this.append(\".\");\n    BaseLanguageTextGen.methodCall(node, this);\n  }","id":102423,"modified_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importPart(SLinkOperations.getTarget(node, \"classConcept\", false), this);\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.StaticMethodCall\", \"classConcept\"))));\n    this.append(\".\");\n    BaseLanguageTextGen.methodCall(node, this);\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    this.append(this.getReferentResolveInfoOrName(\"typeVariableDeclaration\", node));\n  }","id":102424,"modified_method":"public void doGenerateText(SNode node) {\n    this.append(this.getReferentPresentation(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", \"typeVariableDeclaration\"))));\n  }","commit_id":"5e54d57800ac596c941fcb47635241981de4383e","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void performSearch() {\n\n        try {\n            searchCriteria.setSearchOperation(SearchCriteria.FIND_OBJECTS);\n            searchCriteria.setKeywords(keywords.getText());\n            searchCriteria.setMaxReturns(maxReturns.getSelectedItem().toString()); \n            searchCriteria.setResults(0);\n            resultObjectsIterator = dr.getAssetsBySearch(searchCriteria,searchType); \n            VueDragTree tree = new VueDragTree(getAssetResourceIterator(resultObjectsIterator),\"Fedora Search Results\");\n            tree.setRootVisible(false);\n            JScrollPane jsp = new JScrollPane(tree);\n            setSearchResultsPanel(jsp);\n            countError = 0;\n        } catch (Exception ex) {\n            if(countError >5)\n                VueUtil.alert(this, FEDORA_MESG,\"Search Error\");\n            else {\n                searchButton.doClick();\n                countError++;\n            }\n             System.out.println(\"DRViewer.performSearch :\"+ex);\n        }\n    }","id":102425,"modified_method":"private void performSearch() {\n\n        try {\n            searchCriteria.setSearchOperation(SearchCriteria.FIND_OBJECTS);\n            searchCriteria.setKeywords(keywords.getText());\n            searchCriteria.setMaxReturns(maxReturns.getSelectedItem().toString()); \n            searchCriteria.setResults(0);\n            resultObjectsIterator = dr.getAssetsBySearch(searchCriteria,searchType); \n            VueDragTree tree = new VueDragTree(getAssetResourceIterator(resultObjectsIterator),\"Fedora Search Results\");\n            tree.setRootVisible(false);\n            jsp = new JScrollPane(tree);\n            setSearchResultsPanel();\n            countError = 0;\n        }  catch (Exception ex) {\n            if(countError >5) {\n                VueUtil.alert(this, FEDORA_MESG,\"Search Error\");\n                //countError = 0;\n            }else {\n                searchButton.doClick();\n                countError++;\n            }\n             System.out.println(\"DRViewer.performSearch :\"+ex);\n        }\n    }","commit_id":"d2f59afef732588e16dfb8d397ceb3868027ceca","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(ActionEvent e) {\n        if(e.getActionCommand().equals(\"Search\")) {\n          performSearch();\n        }\n         if(e.getActionCommand().equals(\"Advanced Search\")) {\n          performAdvancedSearch();\n        }\n        if(e.getActionCommand().equals(\"more\")) {\n            performMoreSearch();\n        }\n            \n    }","id":102426,"modified_method":"public void actionPerformed(ActionEvent e) {\n        if(e.getActionCommand().equals(\"Search\")) {\n          performSearch();\n        }\n         if(e.getActionCommand().equals(\"Advanced Search\")) {\n          performAdvancedSearch();\n        }\n        if(e.getActionCommand().equals(\"More\")) {\n            performMoreSearch();\n        }\n            \n    }","commit_id":"d2f59afef732588e16dfb8d397ceb3868027ceca","url":"https://github.com/VUE/VUE"},{"original_method":"private void setSearchResultsPanel(JScrollPane jsp) {\n         //noResultsLabel = new JLabel(\"Search Returned no Results\");\n         //noResultsLabel.setFont(VueConstants.MediumFont);\n         //noResultsLabel.setBackground(Color.WHITE);\n         nextButton = new JButton(\"more\");\n         nextButton.addActionListener(this);\n         DRSearchResults.setLayout(new BorderLayout());\n         DRSearchResults.add(jsp,BorderLayout.CENTER,0);\n         /**\n         if(searchCriteria.getResults() == 0) \n            DRSearchResults.add(this.noResultsLabel,BorderLayout.NORTH,0);\n          */\n         if(searchCriteria.getToken() != null)\n            DRSearchResults.add(nextButton,BorderLayout.SOUTH,0);\n         DRSearchResults.validate();\n         tabbedPane.setSelectedComponent(DRSearchResults);\n     }","id":102427,"modified_method":"private void setSearchResultsPanel() {\n         \n         // need to organize this part\n         //noResultsLabel = new JLabel(\"Search Returned no Results\");\n         //noResultsLabel.setFont(VueConstants.MediumFont);\n         //noResultsLabel.setBackground(Color.WHITE);\n         DRSearchResults.remove(jsp);\n         nextButtonPanel.remove(nextButton);\n         DRSearchResults.remove(nextButtonPanel);\n         \n         nextButton = new JButton(\"More\");\n         nextButton.addActionListener(this);\n         nextButtonPanel=new JPanel(new FlowLayout(FlowLayout.RIGHT,2,0));\n         \n         nextButtonPanel.add(nextButton);\n         nextButtonPanel.setBorder(BorderFactory.createEmptyBorder(6,6,6,0));\n         DRSearchResults.setLayout(new BorderLayout());\n         \n         \n         DRSearchResults.add(jsp,BorderLayout.CENTER,0);\n         /**\n         if(searchCriteria.getResults() == 0) \n            DRSearchResults.add(this.noResultsLabel,BorderLayout.NORTH,0);\n          */\n         if(searchCriteria.getToken() != null)\n            DRSearchResults.add(nextButtonPanel,BorderLayout.SOUTH,0);\n         DRSearchResults.validate();\n         tabbedPane.setSelectedComponent(DRSearchResults);\n     }","commit_id":"d2f59afef732588e16dfb8d397ceb3868027ceca","url":"https://github.com/VUE/VUE"},{"original_method":"private void performMoreSearch() {\n        try {\n            searchCriteria.setSearchOperation(SearchCriteria.RESUME_FIND_OBJECTS);\n             searchCriteria.setResults(0);\n            resultObjectsIterator = dr.getAssetsBySearch(searchCriteria,searchType);\n            VueDragTree tree = new VueDragTree(getAssetResourceIterator(resultObjectsIterator),\"Fedora Search Results\");\n            tree.setRootVisible(false);\n            JScrollPane jsp = new JScrollPane(tree);\n            setSearchResultsPanel(jsp);\n        } catch (Exception ex) {\n            VueUtil.alert(this,FEDORA_MESG,\"Search Error\");\n            \n            System.out.println(\"DRViewer.performMoreSearch :\"+ex);\n        }\n        \n    }","id":102428,"modified_method":"private void performMoreSearch() {\n        try {\n            searchCriteria.setSearchOperation(SearchCriteria.RESUME_FIND_OBJECTS);\n             searchCriteria.setResults(0);\n            resultObjectsIterator = dr.getAssetsBySearch(searchCriteria,searchType);\n            VueDragTree tree = new VueDragTree(getAssetResourceIterator(resultObjectsIterator),\"Fedora Search Results\");\n            tree.setRootVisible(false);\n            jsp = new JScrollPane(tree);\n            setSearchResultsPanel();\n            countError = 0;\n        } catch (Exception ex) {\n             if(countError > 5) {\n                VueUtil.alert(this, FEDORA_MESG,\"Search Error\");\n                //countError = 0;\n             }else {\n                nextButton.doClick();\n                countError++;\n            }\n            System.out.println(\"DRViewer.performMoreSearch :\"+ex);\n        } \n        \n    }","commit_id":"d2f59afef732588e16dfb8d397ceb3868027ceca","url":"https://github.com/VUE/VUE"},{"original_method":"private void performAdvancedSearch() {\n        try {\n           \n            searchCriteria.setConditions((fedora.server.types.gen.Condition[])m_model.getConditions().toArray(new Condition[0]));\n            searchCriteria.setMaxReturns(maxReturnsAdvancedSearch.getSelectedItem().toString());\n            searchCriteria.setResults(0);\n            resultObjectsIterator = dr.getAssetsBySearch(searchCriteria,advancedSearchType); \n            VueDragTree tree = new VueDragTree(getAssetResourceIterator(resultObjectsIterator),\"Fedora Search Results\");\n            tree.setRootVisible(false);\n            JScrollPane jsp = new JScrollPane(tree);\n            setSearchResultsPanel(jsp);\n            countError = 0;\n        } catch (Exception ex) {\n            if(countError > 5)\n                VueUtil.alert(this, FEDORA_MESG,\"Search Error\");\n            else {\n                searchButton.doClick();\n                countError++;\n            }ex.printStackTrace();\n                       \n        }\n    }","id":102429,"modified_method":"private void performAdvancedSearch() {\n        try {\n           \n            searchCriteria.setConditions((fedora.server.types.gen.Condition[])m_model.getConditions().toArray(new Condition[0]));\n            searchCriteria.setMaxReturns(maxReturnsAdvancedSearch.getSelectedItem().toString());\n            searchCriteria.setResults(0);\n            resultObjectsIterator = dr.getAssetsBySearch(searchCriteria,advancedSearchType); \n            VueDragTree tree = new VueDragTree(getAssetResourceIterator(resultObjectsIterator),\"Fedora Search Results\");\n            tree.setRootVisible(false);\n            jsp = new JScrollPane(tree);\n            setSearchResultsPanel();\n            countError = 0;\n        } catch (Exception ex) {\n            if(countError > 5){ \n                VueUtil.alert(this, FEDORA_MESG,\"Search Error\");\n                //countError = 0;\n           }else {\n                searchButton.doClick();\n                countError++;\n            }\n            ex.printStackTrace();\n                       \n        }\n    }","commit_id":"d2f59afef732588e16dfb8d397ceb3868027ceca","url":"https://github.com/VUE/VUE"},{"original_method":"private void performMoreSearch() {\n        osid.dr.AssetIterator resultObjectsIterator;\n        try {\n            searchCriteria.setSearchOperation(SearchCriteria.RESUME_FIND_OBJECTS);\n\n            resultObjectsIterator = dr.getAssetsBySearch(searchCriteria,searchType);\n            VueDragTree tree = new VueDragTree(getAssetResourceIterator(resultObjectsIterator),\"Fedora Search Results\");\n            tree.setRootVisible(false);\n            JScrollPane jsp = new JScrollPane(tree);\n            setSearchResultsPanel(jsp);\n        } catch (Exception ex) {\n            VueUtil.alert(this,FEDORA_MESG,\"Search Error\");\n            \n            System.out.println(\"DRViewer.performMoreSearch :\"+ex);\n        }\n        \n    }","id":102430,"modified_method":"private void performMoreSearch() {\n        try {\n            searchCriteria.setSearchOperation(SearchCriteria.RESUME_FIND_OBJECTS);\n             searchCriteria.setResults(0);\n            resultObjectsIterator = dr.getAssetsBySearch(searchCriteria,searchType);\n            VueDragTree tree = new VueDragTree(getAssetResourceIterator(resultObjectsIterator),\"Fedora Search Results\");\n            tree.setRootVisible(false);\n            JScrollPane jsp = new JScrollPane(tree);\n            setSearchResultsPanel(jsp);\n        } catch (Exception ex) {\n            VueUtil.alert(this,FEDORA_MESG,\"Search Error\");\n            \n            System.out.println(\"DRViewer.performMoreSearch :\"+ex);\n        }\n        \n    }","commit_id":"310bddf718c63904ad2f5ba65e3439af5f623976","url":"https://github.com/VUE/VUE"},{"original_method":"private void performAdvancedSearch() {\n        osid.dr.AssetIterator resultObjectsIterator;\n        try {\n           \n            searchCriteria.setConditions((fedora.server.types.gen.Condition[])m_model.getConditions().toArray(new Condition[0]));\n            searchCriteria.setMaxReturns(maxReturns.getSelectedItem().toString());\n            resultObjectsIterator = dr.getAssetsBySearch(searchCriteria,advancedSearchType); \n            VueDragTree tree = new VueDragTree(getAssetResourceIterator(resultObjectsIterator),\"Fedora Search Results\");\n            tree.setRootVisible(false);\n            JScrollPane jsp = new JScrollPane(tree);\n            setSearchResultsPanel(jsp);\n        } catch (Exception ex) {\n            VueUtil.alert(this,FEDORA_MESG,\"Search Error\");\n            ex.printStackTrace();\n                       \n        }\n    }","id":102431,"modified_method":"private void performAdvancedSearch() {\n        try {\n           \n            searchCriteria.setConditions((fedora.server.types.gen.Condition[])m_model.getConditions().toArray(new Condition[0]));\n            searchCriteria.setMaxReturns(maxReturns.getSelectedItem().toString());\n            searchCriteria.setResults(0);\n            resultObjectsIterator = dr.getAssetsBySearch(searchCriteria,advancedSearchType); \n            VueDragTree tree = new VueDragTree(getAssetResourceIterator(resultObjectsIterator),\"Fedora Search Results\");\n            tree.setRootVisible(false);\n            JScrollPane jsp = new JScrollPane(tree);\n            setSearchResultsPanel(jsp);\n            countError = 0;\n        } catch (Exception ex) {\n            if(countError > 5)\n                VueUtil.alert(this, FEDORA_MESG,\"Search Error\");\n            else {\n                searchButton.doClick();\n                countError++;\n            }ex.printStackTrace();\n                       \n        }\n    }","commit_id":"310bddf718c63904ad2f5ba65e3439af5f623976","url":"https://github.com/VUE/VUE"},{"original_method":"private void performSearch() {\n        osid.dr.AssetIterator resultObjectsIterator;\n        try {\n            searchCriteria.setSearchOperation(SearchCriteria.FIND_OBJECTS);\n            searchCriteria.setKeywords(keywords.getText());\n            searchCriteria.setMaxReturns(maxReturns.getSelectedItem().toString()); \n            resultObjectsIterator = dr.getAssetsBySearch(searchCriteria,searchType); \n            VueDragTree tree = new VueDragTree(getAssetResourceIterator(resultObjectsIterator),\"Fedora Search Results\");\n            tree.setRootVisible(false);\n            JScrollPane jsp = new JScrollPane(tree);\n            setSearchResultsPanel(jsp);\n        } catch (Exception ex) {\n            VueUtil.alert(this, FEDORA_MESG,\"Search Error\");\n             System.out.println(\"DRViewer.performSearch :\"+ex);\n        }\n    }","id":102432,"modified_method":"private void performSearch() {\n\n        try {\n            searchCriteria.setSearchOperation(SearchCriteria.FIND_OBJECTS);\n            searchCriteria.setKeywords(keywords.getText());\n            searchCriteria.setMaxReturns(maxReturns.getSelectedItem().toString()); \n            searchCriteria.setResults(0);\n            resultObjectsIterator = dr.getAssetsBySearch(searchCriteria,searchType); \n            VueDragTree tree = new VueDragTree(getAssetResourceIterator(resultObjectsIterator),\"Fedora Search Results\");\n            tree.setRootVisible(false);\n            JScrollPane jsp = new JScrollPane(tree);\n            setSearchResultsPanel(jsp);\n            countError = 0;\n        } catch (Exception ex) {\n            if(countError >5)\n                VueUtil.alert(this, FEDORA_MESG,\"Search Error\");\n            else {\n                searchButton.doClick();\n                countError++;\n            }\n             System.out.println(\"DRViewer.performSearch :\"+ex);\n        }\n    }","commit_id":"310bddf718c63904ad2f5ba65e3439af5f623976","url":"https://github.com/VUE/VUE"},{"original_method":"public static  FedoraObjectIterator advancedSearch(DR dr,SearchCriteria lSearchCriteria)  throws osid.dr.DigitalRepositoryException {\n        Condition cond[] = lSearchCriteria.getConditions();\n        String maxResults = lSearchCriteria.getMaxReturns();\n        \n        Call call;\n        FieldSearchResult searchResults=new FieldSearchResult();   \n        NonNegativeInteger maxRes=new NonNegativeInteger(maxResults);\n        String[] resField=new String[4];\n        resField[0]=\"pid\";\n        resField[1]=\"title\";\n        resField[2]=\"description\";\n        resField[3]=\"cModel\";\n        try { \n            call = getCallAdvancedSearch(dr);\n            FieldSearchQuery query=new FieldSearchQuery();\n            //query.setTerms(term);\n             query.setConditions(cond);\n            java.util.Vector resultObjects = new java.util.Vector();\n            FieldSearchResult methodDefs =    (FieldSearchResult) call.invoke(new Object[] {resField,maxRes,query} );\n            if (methodDefs != null){\n                    ObjectFields[] fields= methodDefs.getResultList(); \n                    for(int i=0;i<fields.length;i++) {\n                        resultObjects.add(new FedoraObject(dr,fields[i].getPid(),fields[i].getTitle()[0],dr.getAssetType(fields[i].getCModel())));\n                    }\n            } else {\n                System.out.println(\"search return no results\");\n            }\n            return new FedoraObjectIterator(resultObjects) ;\n        }catch(Exception ex) {\n            throw new osid.dr.DigitalRepositoryException(\"FedoraSoapFactory.advancedSearch\"+ex.getMessage());\n        }  \n    }","id":102433,"modified_method":"public static  FedoraObjectIterator advancedSearch(DR dr,SearchCriteria lSearchCriteria)  throws osid.dr.DigitalRepositoryException {\n        Condition cond[] = lSearchCriteria.getConditions();\n        String maxResults = lSearchCriteria.getMaxReturns();\n        \n        Call call;\n        FieldSearchResult searchResults=new FieldSearchResult();   \n        NonNegativeInteger maxRes=new NonNegativeInteger(maxResults);\n        String[] resField=new String[4];\n        resField[0]=\"pid\";\n        resField[1]=\"title\";\n        resField[2]=\"description\";\n        resField[3]=\"cModel\";\n        try { \n            call = getCallAdvancedSearch(dr);\n            FieldSearchQuery query=new FieldSearchQuery();\n            //query.setTerms(term);\n             query.setConditions(cond);\n            java.util.Vector resultObjects = new java.util.Vector();\n            FieldSearchResult methodDefs =    (FieldSearchResult) call.invoke(new Object[] {resField,maxRes,query} );\n            if (methodDefs != null){\n                    ObjectFields[] fields= methodDefs.getResultList(); \n                    lSearchCriteria.setResults(fields.length);\n                    for(int i=0;i<fields.length;i++) {\n                        resultObjects.add(new FedoraObject(dr,fields[i].getPid(),fields[i].getTitle()[0],dr.getAssetType(fields[i].getCModel())));\n                    }\n            } else {\n                System.out.println(\"search return no results\");\n            }\n            return new FedoraObjectIterator(resultObjects) ;\n        }catch(Exception ex) {\n            throw new osid.dr.DigitalRepositoryException(\"FedoraSoapFactory.advancedSearch\"+ex.getMessage());\n        }  \n    }","commit_id":"310bddf718c63904ad2f5ba65e3439af5f623976","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n    public static  FieldSearchResult search(DR dr,String term,String maxResults,String[] resField)  throws osid.dr.DigitalRepositoryException {\n        Call call;\n        FieldSearchResult searchResults=new FieldSearchResult();   \n        NonNegativeInteger maxRes=new NonNegativeInteger(maxResults);\n        try { \n            call = getCallSearch(dr);\n            FieldSearchQuery query=new FieldSearchQuery();\n            query.setTerms(term);\n            FieldSearchResult searchResult  =    (FieldSearchResult) call.invoke(new Object[] {resField,maxRes,query} );\n            return searchResult ;\n        }catch(Exception ex) {\n            throw new osid.dr.DigitalRepositoryException(\"FedoraSoapFactory.search\"+ex.getMessage());\n        }  \n    }\n   **/\n    public static  FedoraObjectIterator search(DR dr,SearchCriteria lSearchCriteria)  throws osid.dr.DigitalRepositoryException {\n        String term = lSearchCriteria.getKeywords();\n        String maxResults = lSearchCriteria.getMaxReturns();\n        String searchOperation = lSearchCriteria.getSearchOperation();\n        String token = lSearchCriteria.getToken();\n        \n        Call call;\n        String fedoraApiUrl = dr.getFedoraProperties().getProperty(\"url.fedora.api\");            \n        \n        \n        FieldSearchResult searchResults=new FieldSearchResult();   \n        NonNegativeInteger maxRes=new NonNegativeInteger(maxResults);\n        \n        FieldSearchResult methodDefs = null;\n        \n        String[] resField=new String[4];\n        resField[0]=\"pid\";\n        resField[1]=\"title\";\n        resField[2]=\"description\";\n        resField[3]=\"cModel\";\n        try { \n            call = getCallSearch(dr);\n            call.setOperationName(new QName(fedoraApiUrl,searchOperation));\n            FieldSearchQuery query=new FieldSearchQuery();\n            query.setTerms(term);\n            java.util.Vector resultObjects = new java.util.Vector();\n            if(searchOperation == SearchCriteria.FIND_OBJECTS) {\n                methodDefs =    (FieldSearchResult) call.invoke(new Object[] {resField,maxRes,query} );\n                ListSession listSession = methodDefs.getListSession();\n                if(listSession != null)\n                        lSearchCriteria.setToken(listSession.getToken());\n                   else \n                       lSearchCriteria.setToken(null);\n           \n            }else {\n                if(lSearchCriteria.getToken() != null) {\n                   methodDefs =    (FieldSearchResult) call.invoke(new Object[] {lSearchCriteria.getToken()} ); \n                   ListSession listSession = methodDefs.getListSession();\n                   if(listSession != null)\n                        lSearchCriteria.setToken(listSession.getToken());\n                   else \n                       lSearchCriteria.setToken(null);\n                }\n            }\n                   \n            if (methodDefs != null &&  methodDefs.getResultList().length > 0 ){\n                    ObjectFields[] fields= methodDefs.getResultList(); \n                    for(int i=0;i<fields.length;i++) {\n                            String title = \"No Title\";\n                            if(fields[i].getTitle() != null) \n                                title = fields[i].getTitle()[0];\n                            resultObjects.add(new FedoraObject(dr,fields[i].getPid(),title,dr.getAssetType(fields[i].getCModel())));\n                  \n             \n                    }\n            } else {\n                System.out.println(\"search returned no results\");\n            }\n            \n            \n            return new FedoraObjectIterator(resultObjects) ;\n        }catch(Exception ex) {\n              ex.printStackTrace();\n            throw new osid.dr.DigitalRepositoryException(\"FedoraSoapFactory.search\"+ex.getMessage());\n          \n        }  \n    }","id":102434,"modified_method":"/**\n    public static  FieldSearchResult search(DR dr,String term,String maxResults,String[] resField)  throws osid.dr.DigitalRepositoryException {\n        Call call;\n        FieldSearchResult searchResults=new FieldSearchResult();   \n        NonNegativeInteger maxRes=new NonNegativeInteger(maxResults);\n        try { \n            call = getCallSearch(dr);\n            FieldSearchQuery query=new FieldSearchQuery();\n            query.setTerms(term);\n            FieldSearchResult searchResult  =    (FieldSearchResult) call.invoke(new Object[] {resField,maxRes,query} );\n            return searchResult ;\n        }catch(Exception ex) {\n            throw new osid.dr.DigitalRepositoryException(\"FedoraSoapFactory.search\"+ex.getMessage());\n        }  \n    }\n   **/\n    public static  FedoraObjectIterator search(DR dr,SearchCriteria lSearchCriteria)  throws osid.dr.DigitalRepositoryException {\n        String term = lSearchCriteria.getKeywords();\n        String maxResults = lSearchCriteria.getMaxReturns();\n        String searchOperation = lSearchCriteria.getSearchOperation();\n        String token = lSearchCriteria.getToken();\n        \n        Call call;\n        String fedoraApiUrl = dr.getFedoraProperties().getProperty(\"url.fedora.api\");            \n        \n        \n        FieldSearchResult searchResults=new FieldSearchResult();   \n        NonNegativeInteger maxRes=new NonNegativeInteger(maxResults);\n        \n        FieldSearchResult methodDefs = null;\n        \n        String[] resField=new String[4];\n        resField[0]=\"pid\";\n        resField[1]=\"title\";\n        resField[2]=\"description\";\n        resField[3]=\"cModel\";\n        try { \n            call = getCallSearch(dr);\n            call.setOperationName(new QName(fedoraApiUrl,searchOperation));\n            FieldSearchQuery query=new FieldSearchQuery();\n            query.setTerms(term);\n            java.util.Vector resultObjects = new java.util.Vector();\n            if(searchOperation == SearchCriteria.FIND_OBJECTS) {\n                methodDefs =    (FieldSearchResult) call.invoke(new Object[] {resField,maxRes,query} );\n                ListSession listSession = methodDefs.getListSession();\n                if(listSession != null)\n                        lSearchCriteria.setToken(listSession.getToken());\n                   else \n                       lSearchCriteria.setToken(null);\n           \n            }else {\n                if(lSearchCriteria.getToken() != null) {\n                   methodDefs =    (FieldSearchResult) call.invoke(new Object[] {lSearchCriteria.getToken()} ); \n                   ListSession listSession = methodDefs.getListSession();\n                   if(listSession != null)\n                        lSearchCriteria.setToken(listSession.getToken());\n                   else \n                       lSearchCriteria.setToken(null);\n                }\n            }\n                   \n            if (methodDefs != null &&  methodDefs.getResultList().length > 0 ){\n                    ObjectFields[] fields= methodDefs.getResultList(); \n                    lSearchCriteria.setResults(fields.length);\n                    for(int i=0;i<fields.length;i++) {\n                            String title = \"No Title\";\n                            if(fields[i].getTitle() != null) \n                                title = fields[i].getTitle()[0];\n                            resultObjects.add(new FedoraObject(dr,fields[i].getPid(),title,dr.getAssetType(fields[i].getCModel())));\n                  \n             \n                    }\n            } else {\n                System.out.println(\"search returned no results\");\n            }\n            \n            \n            return new FedoraObjectIterator(resultObjects) ;\n        }catch(Exception ex) {\n              ex.printStackTrace();\n            throw new osid.dr.DigitalRepositoryException(\"FedoraSoapFactory.search\"+ex.getMessage());\n          \n        }  \n    }","commit_id":"310bddf718c63904ad2f5ba65e3439af5f623976","url":"https://github.com/VUE/VUE"},{"original_method":"public Vector getPropertyList() {\n        propertyList = new Vector();\n        Iterator i = mProperties.keySet().iterator();\n        while(i.hasNext()) {\n            Object object = i.next();\n            PropertyEntry entry = new PropertyEntry();\n            entry.setEntryKey(object);\n            entry.setEntryValue(mProperties.get(object));\n            propertyList.add(entry);\n        }\n        return propertyList;\n    }","id":102435,"modified_method":"public Vector getPropertyList() {\n       propertyList = new Vector();\n        Iterator i = mProperties.keySet().iterator();\n        while(i.hasNext()) {\n            Object object = i.next();\n            PropertyEntry entry = new PropertyEntry();\n            entry.setEntryKey(object);\n            entry.setEntryValue(mProperties.get(object));\n            propertyList.add(entry);\n        }\n        System.out.println(\"Property = \"+propertyList.size());       \n        return propertyList;\n    }","commit_id":"310bddf718c63904ad2f5ba65e3439af5f623976","url":"https://github.com/VUE/VUE"},{"original_method":"private void registerFactories() {\n        register(LongOperationFIF.INSTANCE$);\n        register(PrimitiveUnaryOperationFIF.INSTANCE);\n        register(PrimitiveBinaryOperationFIF.INSTANCE);\n        register(StringOperationFIF.INSTANCE);\n        register(ArrayFIF.INSTANCE);\n        register(TopLevelFIF.INSTANCE);\n        register(NumberAndCharConversionFIF.INSTANCE$);\n    }","id":102436,"modified_method":"private void registerFactories() {\n        register(LongOperationFIF.INSTANCE$);\n        register(PrimitiveUnaryOperationFIF.INSTANCE);\n        register(PrimitiveBinaryOperationFIF.INSTANCE);\n        register(StringOperationFIF.INSTANCE);\n        register(ArrayFIF.INSTANCE);\n        register(TopLevelFIF.INSTANCE);\n        register(NumberAndCharConversionFIF.INSTANCE$);\n        register(ProgressionCompanionFIF.INSTANCE);\n    }","commit_id":"af9020a010b79006473f1dd2fafaf50166e49120","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void declareKotlinStandardClasses(@NotNull StandardClasses standardClasses) {\n        for (PrimitiveType type : PrimitiveType.NUMBER_TYPES) {\n            if (type == PrimitiveType.CHAR || type == PrimitiveType.LONG) continue;\n\n            String typeName = type.getTypeName().asString();\n            standardClasses.declare().forFQ(\"kotlin.\" + typeName + \"Range\").kotlinClass(\"NumberRange\")\n                    .methods(\"iterator\", \"contains\").properties(\"start\", \"end\", \"increment\");\n\n            standardClasses.declare().forFQ(\"kotlin.\" + typeName + \"Progression\").kotlinClass(\"NumberProgression\")\n                    .methods(\"iterator\", \"contains\").properties(\"start\", \"end\", \"increment\");\n        }\n\n        standardClasses.declare().forFQ(\"kotlin.LongRange\").kotlinClass(\"LongRange\")\n                .methods(\"iterator\", \"contains\").properties(\"start\", \"end\", \"increment\");\n\n        standardClasses.declare().forFQ(\"kotlin.CharRange\").kotlinClass(\"CharRange\")\n                .methods(\"iterator\", \"contains\").properties(\"start\", \"end\", \"increment\");\n\n\n        standardClasses.declare().forFQ(\"kotlin.LongProgression\").kotlinClass(\"LongProgression\")\n                .methods(\"iterator\", \"contains\").properties(\"start\", \"end\", \"increment\");\n\n        standardClasses.declare().forFQ(\"kotlin.CharProgression\").kotlinClass(\"CharProgression\")\n                .methods(\"iterator\", \"contains\").properties(\"start\", \"end\", \"increment\");\n\n        standardClasses.declare().forFQ(\"kotlin.Enum\").kotlinClass(\"Enum\");\n\n        standardClasses.declare().forFQ(\"kotlin.Comparable\").kotlinClass(\"Comparable\");\n\n        standardClasses.declare().forFQ(\"koltin.Throwable\").kotlinClass(\"Throwable\");\n    }","id":102437,"modified_method":"private static void declareKotlinStandardClasses(@NotNull StandardClasses standardClasses) {\n        for (PrimitiveType type : PrimitiveType.NUMBER_TYPES) {\n            if (type == PrimitiveType.CHAR || type == PrimitiveType.LONG) continue;\n\n            String typeName = type.getTypeName().asString();\n            standardClasses.declare().forFQ(\"kotlin.\" + typeName + \"Range\").kotlinClass(\"NumberRange\");\n            standardClasses.declare().forFQ(\"kotlin.\" + typeName + \"Progression\").kotlinClass(\"NumberProgression\");\n        }\n\n        standardClasses.declare().forFQ(\"kotlin.LongRange\").kotlinClass(\"LongRange\");\n        standardClasses.declare().forFQ(\"kotlin.CharRange\").kotlinClass(\"CharRange\");\n\n        standardClasses.declare().forFQ(\"kotlin.LongProgression\").kotlinClass(\"LongProgression\");\n        standardClasses.declare().forFQ(\"kotlin.CharProgression\").kotlinClass(\"CharProgression\");\n\n        standardClasses.declare().forFQ(\"kotlin.Enum\").kotlinClass(\"Enum\");\n\n        standardClasses.declare().forFQ(\"kotlin.Comparable\").kotlinClass(\"Comparable\");\n\n        standardClasses.declare().forFQ(\"koltin.Throwable\").kotlinClass(\"Throwable\");\n    }","commit_id":"af9020a010b79006473f1dd2fafaf50166e49120","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected boolean hasGuestPermission(\n\t\t\tlong groupId, String name, String primKey, String actionId)\n\t\tthrows Exception {\n\n\t\tList<String> resourceActions = ResourceActionsUtil.getResourceActions(\n\t\t\tname);\n\n\t\tif (!resourceActions.contains(actionId)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (name.indexOf(CharPool.PERIOD) != -1) {\n\n\t\t\t// Check unsupported model actions\n\n\t\t\tList<String> actions =\n\t\t\t\tResourceActionsUtil.getModelResourceGuestUnsupportedActions(\n\t\t\t\t\tname);\n\n\t\t\tif (actions.contains(actionId)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// Check unsupported portlet actions\n\n\t\t\tList<String> actions =\n\t\t\t\tResourceActionsUtil.getPortletResourceGuestUnsupportedActions(\n\t\t\t\t\tname);\n\n\t\t\tif (actions.contains(actionId)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tlong companyId = user.getCompanyId();\n\n\t\tif (groupId > 0) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tcompanyId = group.getCompanyId();\n\t\t}\n\n\t\ttry {\n\t\t\tif (ResourceBlockLocalServiceUtil.isSupported(name)) {\n\t\t\t\tResourceBlockIdsBag resourceBlockIdsBag =\n\t\t\t\t\tgetGuestResourceBlockIdsBag(companyId, groupId, name);\n\n\t\t\t\treturn ResourceBlockLocalServiceUtil.hasPermission(\n\t\t\t\t\tname, GetterUtil.getLong(primKey), actionId,\n\t\t\t\t\tresourceBlockIdsBag);\n\t\t\t}\n\n\t\t\tprimKey = fixLegacyPrimaryKey(companyId, name, primKey);\n\n\t\t\tList<Resource> resources = getResources(\n\t\t\t\tcompanyId, groupId, name, primKey, actionId);\n\n\t\t\treturn ResourceLocalServiceUtil.hasUserPermissions(\n\t\t\t\tdefaultUserId, groupId, resources, actionId,\n\t\t\t\tgetGuestUserRoleIds());\n\t\t}\n\t\tcatch (NoSuchResourcePermissionException nsrpe) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Somebody is trying to circumvent permission framework \" +\n\t\t\t\t\t\"or there is a bug in permission framework caller: \" +\n\t\t\t\t\t\tnsrpe.getMessage(),\n\t\t\t\tnsrpe);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\treturn false;\n\t\t}\n\t}","id":102438,"modified_method":"protected boolean hasGuestPermission(\n\t\t\tlong groupId, String name, String primKey, String actionId)\n\t\tthrows Exception {\n\n\t\tList<String> resourceActions = ResourceActionsUtil.getResourceActions(\n\t\t\tname);\n\n\t\tif (!resourceActions.contains(actionId)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (name.indexOf(CharPool.PERIOD) != -1) {\n\n\t\t\t// Check unsupported model actions\n\n\t\t\tList<String> actions =\n\t\t\t\tResourceActionsUtil.getModelResourceGuestUnsupportedActions(\n\t\t\t\t\tname);\n\n\t\t\tif (actions.contains(actionId)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// Check unsupported portlet actions\n\n\t\t\tList<String> actions =\n\t\t\t\tResourceActionsUtil.getPortletResourceGuestUnsupportedActions(\n\t\t\t\t\tname);\n\n\t\t\tif (actions.contains(actionId)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tlong companyId = user.getCompanyId();\n\n\t\tif (groupId > 0) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tcompanyId = group.getCompanyId();\n\t\t}\n\n\t\ttry {\n\t\t\tif (ResourceBlockLocalServiceUtil.isSupported(name)) {\n\t\t\t\tResourceBlockIdsBag resourceBlockIdsBag =\n\t\t\t\t\tgetGuestResourceBlockIdsBag(companyId, groupId, name);\n\n\t\t\t\treturn ResourceBlockLocalServiceUtil.hasPermission(\n\t\t\t\t\tname, GetterUtil.getLong(primKey), actionId,\n\t\t\t\t\tresourceBlockIdsBag);\n\t\t\t}\n\n\t\t\tprimKey = fixLegacyPrimaryKey(companyId, name, primKey);\n\n\t\t\tList<Resource> resources = getResources(\n\t\t\t\tcompanyId, groupId, name, primKey, actionId);\n\n\t\t\treturn ResourceLocalServiceUtil.hasUserPermissions(\n\t\t\t\tdefaultUserId, groupId, resources, actionId,\n\t\t\t\tgetGuestUserRoleIds());\n\t\t}\n\t\tcatch (NoSuchResourcePermissionException nsrpe) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Someone may be trying to circumvent the permission checker: \" +\n\t\t\t\t\tnsrpe.getMessage(),\n\t\t\t\tnsrpe);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"8033988686f67f4b9ac3e787f42dfc3e641c0dd2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String fixLegacyPrimaryKey(\n\t\tlong companyId, String name, String primKey) {\n\n\t\tif (((primKey.length() == 1) && (primKey.charAt(0) == 48)) ||\n\t\t\t(primKey.equals(String.valueOf(companyId)) &&\n\t\t\t !name.equals(Company.class.getName()))) {\n\n\t\t\tString message =\n\t\t\t\t\"Legacy primary key \" + primKey + \" was used for \" +\n\t\t\t\t\t\"permission checking of \" + name + \" in company \" +\n\t\t\t\t\tcompanyId + \". Please use \" + name + \" as the \" +\n\t\t\t\t\t\"primary key.\";\n\n\t\t\t_log.error(message, new IllegalArgumentException(message));\n\n\t\t\treturn name;\n\t\t}\n\n\t\treturn primKey;\n\t}","id":102439,"modified_method":"protected String fixLegacyPrimaryKey(\n\t\tlong companyId, String name, String primKey) {\n\n\t\tif (((primKey.length() == 1) && (primKey.charAt(0) == 48)) ||\n\t\t\t(primKey.equals(String.valueOf(companyId)) &&\n\t\t\t !name.equals(Company.class.getName()))) {\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\tStringBundler sb = new StringBundler(9);\n\t\t\t\t\n\t\t\t\tsb.append(\"Using \");\n\t\t\t\tsb.append(name);\n\t\t\t\tsb.append(\" as the primary key instead of the legacy primary \");\n\t\t\t\tsb.append(\"key \");\n\t\t\t\tsb.append(primKey);\n\t\t\t\tsb.append(\" that was used for permission checking of \");\n\t\t\t\tsb.append(name);\n\t\t\t\tsb.append(\" in company \");\n\t\t\t\tsb.append(companyId);\n\n\t\t\t\t_log.warn(\n\t\t\t\t\tsb.toString(), new IllegalArgumentException(sb.toString()));\n\t\t\t}\n\n\t\t\treturn name;\n\t\t}\n\n\t\treturn primKey;\n\t}","commit_id":"8033988686f67f4b9ac3e787f42dfc3e641c0dd2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean hasUserPermissionImpl(\n\t\t\tlong groupId, String name, String primKey, long[] roleIds,\n\t\t\tString actionId)\n\t\tthrows Exception {\n\n\t\tStopWatch stopWatch = new StopWatch();\n\n\t\tstopWatch.start();\n\n\t\tif (isOmniadmin()) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (name.equals(Organization.class.getName())) {\n\t\t\tif (isOrganizationAdminImpl(GetterUtil.getLong(primKey))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tlong companyId = user.getCompanyId();\n\n\t\tif (groupId > 0) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tcompanyId = group.getCompanyId();\n\t\t}\n\n\t\tprimKey = fixLegacyPrimaryKey(companyId, name, primKey);\n\n\t\ttry {\n\t\t\tboolean hasPermission = doCheckPermission(\n\t\t\t\tcompanyId, groupId, name, primKey, roleIds, actionId,\n\t\t\t\tstopWatch);\n\n\t\t\tif (hasPermission) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchResourcePermissionException nsrpe) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Somebody is trying to circumvent permission framework \" +\n\t\t\t\t\t\"or there is a bug in permission framework caller: \" +\n\t\t\t\t\t\tnsrpe.getMessage(),\n\t\t\t\tnsrpe);\n\t\t}\n\n\t\tif (isCompanyAdminImpl(companyId)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (isGroupAdminImpl(groupId)) {\n\t\t\tboolean hasLayoutManagerPermission = true;\n\n\t\t\t// Check if the layout manager has permission to do this action for\n\t\t\t// the current portlet\n\n\t\t\tif (Validator.isNotNull(name) && Validator.isNotNull(primKey) &&\n\t\t\t\tprimKey.contains(PortletConstants.LAYOUT_SEPARATOR)) {\n\n\t\t\t\thasLayoutManagerPermission =\n\t\t\t\t\tPortletPermissionUtil.hasLayoutManagerPermission(\n\t\t\t\t\t\tname, actionId);\n\t\t\t}\n\n\t\t\tif (hasLayoutManagerPermission) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":102440,"modified_method":"protected boolean hasUserPermissionImpl(\n\t\t\tlong groupId, String name, String primKey, long[] roleIds,\n\t\t\tString actionId)\n\t\tthrows Exception {\n\n\t\tStopWatch stopWatch = new StopWatch();\n\n\t\tstopWatch.start();\n\n\t\tif (isOmniadmin()) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (name.equals(Organization.class.getName())) {\n\t\t\tif (isOrganizationAdminImpl(GetterUtil.getLong(primKey))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tlong companyId = user.getCompanyId();\n\n\t\tif (groupId > 0) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tcompanyId = group.getCompanyId();\n\t\t}\n\n\t\tprimKey = fixLegacyPrimaryKey(companyId, name, primKey);\n\n\t\ttry {\n\t\t\tboolean hasPermission = doCheckPermission(\n\t\t\t\tcompanyId, groupId, name, primKey, roleIds, actionId,\n\t\t\t\tstopWatch);\n\n\t\t\tif (hasPermission) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchResourcePermissionException nsrpe) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Someone may be trying to circumvent the permission checker: \" +\n\t\t\t\t\tnsrpe.getMessage(),\n\t\t\t\tnsrpe);\n\t\t}\n\n\t\tif (isCompanyAdminImpl(companyId)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (isGroupAdminImpl(groupId)) {\n\t\t\tboolean hasLayoutManagerPermission = true;\n\n\t\t\t// Check if the layout manager has permission to do this action for\n\t\t\t// the current portlet\n\n\t\t\tif (Validator.isNotNull(name) && Validator.isNotNull(primKey) &&\n\t\t\t\tprimKey.contains(PortletConstants.LAYOUT_SEPARATOR)) {\n\n\t\t\t\thasLayoutManagerPermission =\n\t\t\t\t\tPortletPermissionUtil.hasLayoutManagerPermission(\n\t\t\t\t\t\tname, actionId);\n\t\t\t}\n\n\t\t\tif (hasLayoutManagerPermission) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"8033988686f67f4b9ac3e787f42dfc3e641c0dd2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Returns <code>true<\/code> if the roles have permission at the scope to\n\t * perform the action on the resources.\n\t *\n\t * <p>\n\t * Depending on the scope, the value of <code>primKey<\/code> will have\n\t * different meanings. For more information, see {@link\n\t * com.liferay.portal.model.impl.ResourcePermissionImpl}.\n\t * <\/p>\n\t *\n\t * @param  resources the resources\n\t * @param  roleIds the primary keys of the roles\n\t * @param  actionId the action ID\n\t * @return <code>true<\/code> if any one of the roles has permission to\n\t *         perform the action on any one of the resources;\n\t *         <code>false<\/code> otherwise\n\t */\n\t@Override\n\tpublic boolean hasResourcePermission(\n\t\t\tList<Resource> resources, long[] roleIds, String actionId)\n\t\tthrows PortalException {\n\n\t\tif (roleIds.length == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint size = resources.size();\n\n\t\tif (size < 2) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The list of resources must contain at least two values\");\n\t\t}\n\n\t\tResource individualResource = resources.get(0);\n\n\t\tif (individualResource.getScope() !=\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL) {\n\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The first resource must be an individual scope\");\n\t\t}\n\n\t\tResource companyResource = resources.get(size - 1);\n\n\t\tif (companyResource.getScope() != ResourceConstants.SCOPE_COMPANY) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The last resource must be a company scope\");\n\t\t}\n\n\t\t// See LPS-47464\n\n\t\tif (resourcePermissionPersistence.countByC_N_S_P(\n\t\t\t\tindividualResource.getCompanyId(), individualResource.getName(),\n\t\t\t\tindividualResource.getScope(),\n\t\t\t\tindividualResource.getPrimKey()) < 1) {\n\n\t\t\tthrow new NoSuchResourcePermissionException(\n\t\t\t\t\"There is no \" + individualResource.getName() +\n\t\t\t\t\t\" with primary key \" + individualResource.getPrimKey() +\n\t\t\t\t\t\t\" and companyId \" + individualResource.getCompanyId());\n\t\t}\n\n\t\t// Iterate the list of resources in reverse order to test permissions\n\t\t// from company scope to individual scope because it is more likely that\n\t\t// a permission is assigned at a higher scope. Optimizing this method to\n\t\t// one SQL call may actually slow things down since most of the calls\n\t\t// will pull from the cache after the first request.\n\n\t\tfor (int i = size - 1; i >= 0; i--) {\n\t\t\tResource resource = resources.get(i);\n\n\t\t\tif (hasResourcePermission(\n\t\t\t\t\tresource.getCompanyId(), resource.getName(),\n\t\t\t\t\tresource.getScope(), resource.getPrimKey(), roleIds,\n\t\t\t\t\tactionId)) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":102441,"modified_method":"/**\n\t * Returns <code>true<\/code> if the roles have permission at the scope to\n\t * perform the action on the resources.\n\t *\n\t * <p>\n\t * Depending on the scope, the value of <code>primKey<\/code> will have\n\t * different meanings. For more information, see {@link\n\t * com.liferay.portal.model.impl.ResourcePermissionImpl}.\n\t * <\/p>\n\t *\n\t * @param  resources the resources\n\t * @param  roleIds the primary keys of the roles\n\t * @param  actionId the action ID\n\t * @return <code>true<\/code> if any one of the roles has permission to\n\t *         perform the action on any one of the resources;\n\t *         <code>false<\/code> otherwise\n\t */\n\t@Override\n\tpublic boolean hasResourcePermission(\n\t\t\tList<Resource> resources, long[] roleIds, String actionId)\n\t\tthrows PortalException {\n\n\t\tif (roleIds.length == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint size = resources.size();\n\n\t\tif (size < 2) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The list of resources must contain at least two values\");\n\t\t}\n\n\t\tResource individualResource = resources.get(0);\n\n\t\tif (individualResource.getScope() !=\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL) {\n\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The first resource must be an individual scope\");\n\t\t}\n\n\t\tResource companyResource = resources.get(size - 1);\n\n\t\tif (companyResource.getScope() != ResourceConstants.SCOPE_COMPANY) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The last resource must be a company scope\");\n\t\t}\n\n\t\t// See LPS-47464\n\n\t\tif (resourcePermissionPersistence.countByC_N_S_P(\n\t\t\t\tindividualResource.getCompanyId(), individualResource.getName(),\n\t\t\t\tindividualResource.getScope(),\n\t\t\t\tindividualResource.getPrimKey()) < 1) {\n\n\t\t\tStringBundler sb = new StringBundler(9);\n\n\t\t\tsb.append(\"{companyId=\");\n\t\t\tsb.append(individualResource.getCompanyId());\n\t\t\tsb.append(\", name=\");\n\t\t\tsb.append(individualResource.getName());\n\t\t\tsb.append(\", primKey=\");\n\t\t\tsb.append(individualResource.getPrimKey());\n\t\t\tsb.append(\", scope=\");\n\t\t\tsb.append(individualResource.getScope());\n\t\t\tsb.append(\"}\");\n\n\t\t\tthrow new NoSuchResourcePermissionException(sb.toString());\n\t\t}\n\n\t\t// Iterate the list of resources in reverse order to test permissions\n\t\t// from company scope to individual scope because it is more likely that\n\t\t// a permission is assigned at a higher scope. Optimizing this method to\n\t\t// one SQL call may actually slow things down since most of the calls\n\t\t// will pull from the cache after the first request.\n\n\t\tfor (int i = size - 1; i >= 0; i--) {\n\t\t\tResource resource = resources.get(i);\n\n\t\t\tif (hasResourcePermission(\n\t\t\t\t\tresource.getCompanyId(), resource.getName(),\n\t\t\t\t\tresource.getScope(), resource.getPrimKey(), roleIds,\n\t\t\t\t\tactionId)) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"8033988686f67f4b9ac3e787f42dfc3e641c0dd2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean hasGuestPermission(\n\t\t\tlong groupId, String name, String primKey, String actionId)\n\t\tthrows Exception {\n\n\t\tList<String> resourceActions = ResourceActionsUtil.getResourceActions(\n\t\t\tname);\n\n\t\tif (!resourceActions.contains(actionId)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (name.indexOf(CharPool.PERIOD) != -1) {\n\n\t\t\t// Check unsupported model actions\n\n\t\t\tList<String> actions =\n\t\t\t\tResourceActionsUtil.getModelResourceGuestUnsupportedActions(\n\t\t\t\t\tname);\n\n\t\t\tif (actions.contains(actionId)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// Check unsupported portlet actions\n\n\t\t\tList<String> actions =\n\t\t\t\tResourceActionsUtil.getPortletResourceGuestUnsupportedActions(\n\t\t\t\t\tname);\n\n\t\t\tif (actions.contains(actionId)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tlong companyId = user.getCompanyId();\n\n\t\tif (groupId > 0) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tcompanyId = group.getCompanyId();\n\t\t}\n\n\t\ttry {\n\t\t\tif (ResourceBlockLocalServiceUtil.isSupported(name)) {\n\t\t\t\tResourceBlockIdsBag resourceBlockIdsBag =\n\t\t\t\t\tgetGuestResourceBlockIdsBag(companyId, groupId, name);\n\n\t\t\t\treturn ResourceBlockLocalServiceUtil.hasPermission(\n\t\t\t\t\tname, GetterUtil.getLong(primKey), actionId,\n\t\t\t\t\tresourceBlockIdsBag);\n\t\t\t}\n\n\t\t\tprimKey = fixLegacyPrimaryKey(companyId, name, primKey);\n\n\t\t\tList<Resource> resources = getResources(\n\t\t\t\tcompanyId, groupId, name, primKey, actionId);\n\n\t\t\treturn ResourceLocalServiceUtil.hasUserPermissions(\n\t\t\t\tdefaultUserId, groupId, resources, actionId,\n\t\t\t\tgetGuestUserRoleIds());\n\t\t}\n\t\tcatch (NoSuchResourcePermissionException nsrpe) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Somebody is trying to circumvent permission framework \" +\n\t\t\t\t\t\"or there is a bug in permission framework caller: \" +\n\t\t\t\t\t\tnsrpe.getMessage(),\n\t\t\t\tnsrpe);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\treturn false;\n\t\t}\n\t}","id":102442,"modified_method":"protected boolean hasGuestPermission(\n\t\t\tlong groupId, String name, String primKey, String actionId)\n\t\tthrows Exception {\n\n\t\tList<String> resourceActions = ResourceActionsUtil.getResourceActions(\n\t\t\tname);\n\n\t\tif (!resourceActions.contains(actionId)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (name.indexOf(CharPool.PERIOD) != -1) {\n\n\t\t\t// Check unsupported model actions\n\n\t\t\tList<String> actions =\n\t\t\t\tResourceActionsUtil.getModelResourceGuestUnsupportedActions(\n\t\t\t\t\tname);\n\n\t\t\tif (actions.contains(actionId)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// Check unsupported portlet actions\n\n\t\t\tList<String> actions =\n\t\t\t\tResourceActionsUtil.getPortletResourceGuestUnsupportedActions(\n\t\t\t\t\tname);\n\n\t\t\tif (actions.contains(actionId)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tlong companyId = user.getCompanyId();\n\n\t\tif (groupId > 0) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tcompanyId = group.getCompanyId();\n\t\t}\n\n\t\ttry {\n\t\t\tif (ResourceBlockLocalServiceUtil.isSupported(name)) {\n\t\t\t\tResourceBlockIdsBag resourceBlockIdsBag =\n\t\t\t\t\tgetGuestResourceBlockIdsBag(companyId, groupId, name);\n\n\t\t\t\treturn ResourceBlockLocalServiceUtil.hasPermission(\n\t\t\t\t\tname, GetterUtil.getLong(primKey), actionId,\n\t\t\t\t\tresourceBlockIdsBag);\n\t\t\t}\n\n\t\t\tprimKey = fixLegacyPrimaryKey(companyId, name, primKey);\n\n\t\t\tList<Resource> resources = getResources(\n\t\t\t\tcompanyId, groupId, name, primKey, actionId);\n\n\t\t\treturn ResourceLocalServiceUtil.hasUserPermissions(\n\t\t\t\tdefaultUserId, groupId, resources, actionId,\n\t\t\t\tgetGuestUserRoleIds());\n\t\t}\n\t\tcatch (NoSuchResourcePermissionException nsrpe) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Someone may be trying to circumvent the permission checker: \" +\n\t\t\t\t\tnsrpe.getMessage(),\n\t\t\t\tnsrpe);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"037c9ef49de9439127c41b786acdb8b53487cacf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String fixLegacyPrimaryKey(\n\t\tlong companyId, String name, String primKey) {\n\n\t\tif (((primKey.length() == 1) && (primKey.charAt(0) == 48)) ||\n\t\t\t(primKey.equals(String.valueOf(companyId)) &&\n\t\t\t !name.equals(Company.class.getName()))) {\n\n\t\t\tString message =\n\t\t\t\t\"Legacy primary key \" + primKey + \" was used for \" +\n\t\t\t\t\t\"permission checking of \" + name + \" in company \" +\n\t\t\t\t\tcompanyId + \". Please use \" + name + \" as the \" +\n\t\t\t\t\t\"primary key.\";\n\n\t\t\t_log.error(message, new IllegalArgumentException(message));\n\n\t\t\treturn name;\n\t\t}\n\n\t\treturn primKey;\n\t}","id":102443,"modified_method":"protected String fixLegacyPrimaryKey(\n\t\tlong companyId, String name, String primKey) {\n\n\t\tif (((primKey.length() == 1) && (primKey.charAt(0) == 48)) ||\n\t\t\t(primKey.equals(String.valueOf(companyId)) &&\n\t\t\t !name.equals(Company.class.getName()))) {\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\tStringBundler sb = new StringBundler(9);\n\t\t\t\t\n\t\t\t\tsb.append(\"Using \");\n\t\t\t\tsb.append(name);\n\t\t\t\tsb.append(\" as the primary key instead of the legacy primary \");\n\t\t\t\tsb.append(\"key \");\n\t\t\t\tsb.append(primKey);\n\t\t\t\tsb.append(\" that was used for permission checking of \");\n\t\t\t\tsb.append(name);\n\t\t\t\tsb.append(\" in company \");\n\t\t\t\tsb.append(companyId);\n\n\t\t\t\t_log.warn(\n\t\t\t\t\tsb.toString(), new IllegalArgumentException(sb.toString()));\n\t\t\t}\n\n\t\t\treturn name;\n\t\t}\n\n\t\treturn primKey;\n\t}","commit_id":"037c9ef49de9439127c41b786acdb8b53487cacf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean hasUserPermissionImpl(\n\t\t\tlong groupId, String name, String primKey, long[] roleIds,\n\t\t\tString actionId)\n\t\tthrows Exception {\n\n\t\tStopWatch stopWatch = new StopWatch();\n\n\t\tstopWatch.start();\n\n\t\tif (isOmniadmin()) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (name.equals(Organization.class.getName())) {\n\t\t\tif (isOrganizationAdminImpl(GetterUtil.getLong(primKey))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tlong companyId = user.getCompanyId();\n\n\t\tif (groupId > 0) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tcompanyId = group.getCompanyId();\n\t\t}\n\n\t\tprimKey = fixLegacyPrimaryKey(companyId, name, primKey);\n\n\t\ttry {\n\t\t\tboolean hasPermission = doCheckPermission(\n\t\t\t\tcompanyId, groupId, name, primKey, roleIds, actionId,\n\t\t\t\tstopWatch);\n\n\t\t\tif (hasPermission) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchResourcePermissionException nsrpe) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Somebody is trying to circumvent permission framework \" +\n\t\t\t\t\t\"or there is a bug in permission framework caller: \" +\n\t\t\t\t\t\tnsrpe.getMessage(),\n\t\t\t\tnsrpe);\n\t\t}\n\n\t\tif (isCompanyAdminImpl(companyId)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (isGroupAdminImpl(groupId)) {\n\t\t\tboolean hasLayoutManagerPermission = true;\n\n\t\t\t// Check if the layout manager has permission to do this action for\n\t\t\t// the current portlet\n\n\t\t\tif (Validator.isNotNull(name) && Validator.isNotNull(primKey) &&\n\t\t\t\tprimKey.contains(PortletConstants.LAYOUT_SEPARATOR)) {\n\n\t\t\t\thasLayoutManagerPermission =\n\t\t\t\t\tPortletPermissionUtil.hasLayoutManagerPermission(\n\t\t\t\t\t\tname, actionId);\n\t\t\t}\n\n\t\t\tif (hasLayoutManagerPermission) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":102444,"modified_method":"protected boolean hasUserPermissionImpl(\n\t\t\tlong groupId, String name, String primKey, long[] roleIds,\n\t\t\tString actionId)\n\t\tthrows Exception {\n\n\t\tStopWatch stopWatch = new StopWatch();\n\n\t\tstopWatch.start();\n\n\t\tif (isOmniadmin()) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (name.equals(Organization.class.getName())) {\n\t\t\tif (isOrganizationAdminImpl(GetterUtil.getLong(primKey))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tlong companyId = user.getCompanyId();\n\n\t\tif (groupId > 0) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\tcompanyId = group.getCompanyId();\n\t\t}\n\n\t\tprimKey = fixLegacyPrimaryKey(companyId, name, primKey);\n\n\t\ttry {\n\t\t\tboolean hasPermission = doCheckPermission(\n\t\t\t\tcompanyId, groupId, name, primKey, roleIds, actionId,\n\t\t\t\tstopWatch);\n\n\t\t\tif (hasPermission) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchResourcePermissionException nsrpe) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Someone may be trying to circumvent the permission checker: \" +\n\t\t\t\t\tnsrpe.getMessage(),\n\t\t\t\tnsrpe);\n\t\t}\n\n\t\tif (isCompanyAdminImpl(companyId)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (isGroupAdminImpl(groupId)) {\n\t\t\tboolean hasLayoutManagerPermission = true;\n\n\t\t\t// Check if the layout manager has permission to do this action for\n\t\t\t// the current portlet\n\n\t\t\tif (Validator.isNotNull(name) && Validator.isNotNull(primKey) &&\n\t\t\t\tprimKey.contains(PortletConstants.LAYOUT_SEPARATOR)) {\n\n\t\t\t\thasLayoutManagerPermission =\n\t\t\t\t\tPortletPermissionUtil.hasLayoutManagerPermission(\n\t\t\t\t\t\tname, actionId);\n\t\t\t}\n\n\t\t\tif (hasLayoutManagerPermission) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"037c9ef49de9439127c41b786acdb8b53487cacf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Returns <code>true<\/code> if the roles have permission at the scope to\n\t * perform the action on the resources.\n\t *\n\t * <p>\n\t * Depending on the scope, the value of <code>primKey<\/code> will have\n\t * different meanings. For more information, see {@link\n\t * com.liferay.portal.model.impl.ResourcePermissionImpl}.\n\t * <\/p>\n\t *\n\t * @param  resources the resources\n\t * @param  roleIds the primary keys of the roles\n\t * @param  actionId the action ID\n\t * @return <code>true<\/code> if any one of the roles has permission to\n\t *         perform the action on any one of the resources;\n\t *         <code>false<\/code> otherwise\n\t */\n\t@Override\n\tpublic boolean hasResourcePermission(\n\t\t\tList<Resource> resources, long[] roleIds, String actionId)\n\t\tthrows PortalException {\n\n\t\tif (roleIds.length == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint size = resources.size();\n\n\t\tif (size < 2) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The list of resources must contain at least two values\");\n\t\t}\n\n\t\tResource individualResource = resources.get(0);\n\n\t\tif (individualResource.getScope() !=\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL) {\n\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The first resource must be an individual scope\");\n\t\t}\n\n\t\tResource companyResource = resources.get(size - 1);\n\n\t\tif (companyResource.getScope() != ResourceConstants.SCOPE_COMPANY) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The last resource must be a company scope\");\n\t\t}\n\n\t\t// See LPS-47464\n\n\t\tif (resourcePermissionPersistence.countByC_N_S_P(\n\t\t\t\tindividualResource.getCompanyId(), individualResource.getName(),\n\t\t\t\tindividualResource.getScope(),\n\t\t\t\tindividualResource.getPrimKey()) < 1) {\n\n\t\t\tthrow new NoSuchResourcePermissionException(\n\t\t\t\t\"There is no \" + individualResource.getName() +\n\t\t\t\t\t\" with primary key \" + individualResource.getPrimKey() +\n\t\t\t\t\t\t\" and companyId \" + individualResource.getCompanyId());\n\t\t}\n\n\t\t// Iterate the list of resources in reverse order to test permissions\n\t\t// from company scope to individual scope because it is more likely that\n\t\t// a permission is assigned at a higher scope. Optimizing this method to\n\t\t// one SQL call may actually slow things down since most of the calls\n\t\t// will pull from the cache after the first request.\n\n\t\tfor (int i = size - 1; i >= 0; i--) {\n\t\t\tResource resource = resources.get(i);\n\n\t\t\tif (hasResourcePermission(\n\t\t\t\t\tresource.getCompanyId(), resource.getName(),\n\t\t\t\t\tresource.getScope(), resource.getPrimKey(), roleIds,\n\t\t\t\t\tactionId)) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":102445,"modified_method":"/**\n\t * Returns <code>true<\/code> if the roles have permission at the scope to\n\t * perform the action on the resources.\n\t *\n\t * <p>\n\t * Depending on the scope, the value of <code>primKey<\/code> will have\n\t * different meanings. For more information, see {@link\n\t * com.liferay.portal.model.impl.ResourcePermissionImpl}.\n\t * <\/p>\n\t *\n\t * @param  resources the resources\n\t * @param  roleIds the primary keys of the roles\n\t * @param  actionId the action ID\n\t * @return <code>true<\/code> if any one of the roles has permission to\n\t *         perform the action on any one of the resources;\n\t *         <code>false<\/code> otherwise\n\t */\n\t@Override\n\tpublic boolean hasResourcePermission(\n\t\t\tList<Resource> resources, long[] roleIds, String actionId)\n\t\tthrows PortalException {\n\n\t\tif (roleIds.length == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint size = resources.size();\n\n\t\tif (size < 2) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The list of resources must contain at least two values\");\n\t\t}\n\n\t\tResource individualResource = resources.get(0);\n\n\t\tif (individualResource.getScope() !=\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL) {\n\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The first resource must be an individual scope\");\n\t\t}\n\n\t\tResource companyResource = resources.get(size - 1);\n\n\t\tif (companyResource.getScope() != ResourceConstants.SCOPE_COMPANY) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The last resource must be a company scope\");\n\t\t}\n\n\t\t// See LPS-47464\n\n\t\tif (resourcePermissionPersistence.countByC_N_S_P(\n\t\t\t\tindividualResource.getCompanyId(), individualResource.getName(),\n\t\t\t\tindividualResource.getScope(),\n\t\t\t\tindividualResource.getPrimKey()) < 1) {\n\n\t\t\tStringBundler sb = new StringBundler(9);\n\n\t\t\tsb.append(\"{companyId=\");\n\t\t\tsb.append(individualResource.getCompanyId());\n\t\t\tsb.append(\", name=\");\n\t\t\tsb.append(individualResource.getName());\n\t\t\tsb.append(\", primKey=\");\n\t\t\tsb.append(individualResource.getPrimKey());\n\t\t\tsb.append(\", scope=\");\n\t\t\tsb.append(individualResource.getScope());\n\t\t\tsb.append(\"}\");\n\n\t\t\tthrow new NoSuchResourcePermissionException(sb.toString());\n\t\t}\n\n\t\t// Iterate the list of resources in reverse order to test permissions\n\t\t// from company scope to individual scope because it is more likely that\n\t\t// a permission is assigned at a higher scope. Optimizing this method to\n\t\t// one SQL call may actually slow things down since most of the calls\n\t\t// will pull from the cache after the first request.\n\n\t\tfor (int i = size - 1; i >= 0; i--) {\n\t\t\tResource resource = resources.get(i);\n\n\t\t\tif (hasResourcePermission(\n\t\t\t\t\tresource.getCompanyId(), resource.getName(),\n\t\t\t\t\tresource.getScope(), resource.getPrimKey(), roleIds,\n\t\t\t\t\tactionId)) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"037c9ef49de9439127c41b786acdb8b53487cacf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Reference(\n\t\tcardinality = ReferenceCardinality.MULTIPLE,\n\t\tpolicy = ReferencePolicy.DYNAMIC\n\t)\n\tprotected void setConfigurationBeanDeclaration(\n\t\tConfigurationBeanDeclaration configurationBeanDeclaration) {\n\n\t\tClass<?> configurationBeanClass =\n\t\t\tconfigurationBeanDeclaration.getConfigurationBeanClass();\n\n\t\tif (_configurationBeanManagedServices.containsKey(\n\t\t\t\tconfigurationBeanClass)) {\n\n\t\t\t_log.error(\n\t\t\t\t\"ConfigurationBeanDeclaration for configuration bean class \" +\n\t\t\t\t\tconfigurationBeanClass.getName() + \" has been already \" +\n\t\t\t\t\t\"started: only one ConfigurationBeanDeclaration per \" +\n\t\t\t\t\t\"configuration bean is allowed.\");\n\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationBeanManagedService configurationBeanManagedService =\n\t\t\tnew ConfigurationBeanManagedService(\n\t\t\t\t_bundleContext, configurationBeanClass);\n\n\t\t_configurationBeanManagedServices.put(\n\t\t\tconfigurationBeanClass, configurationBeanManagedService);\n\t\t_configurationBeanClasses.put(\n\t\t\tconfigurationBeanManagedService.getConfigurationPid(),\n\t\t\tconfigurationBeanClass);\n\n\t\tconfigurationBeanManagedService.register();\n\t}","id":102446,"modified_method":"@Reference(\n\t\tcardinality = ReferenceCardinality.MULTIPLE,\n\t\tpolicy = ReferencePolicy.DYNAMIC\n\t)\n\tprotected void setConfigurationBeanDeclaration(\n\t\tConfigurationBeanDeclaration configurationBeanDeclaration) {\n\n\t\tClass<?> configurationBeanClass =\n\t\t\tconfigurationBeanDeclaration.getConfigurationBeanClass();\n\n\t\tif (_configurationBeanManagedServices.containsKey(\n\t\t\t\tconfigurationBeanClass)) {\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Configuration bean declaration for configuration bean \" +\n\t\t\t\t\t\tconfigurationBeanClass.getName() + \" already exists\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationBeanManagedService configurationBeanManagedService =\n\t\t\tnew ConfigurationBeanManagedService(\n\t\t\t\t_bundleContext, configurationBeanClass);\n\n\t\t_configurationBeanManagedServices.put(\n\t\t\tconfigurationBeanClass, configurationBeanManagedService);\n\t\t_configurationBeanClasses.put(\n\t\t\tconfigurationBeanManagedService.getConfigurationPid(),\n\t\t\tconfigurationBeanClass);\n\n\t\tconfigurationBeanManagedService.register();\n\t}","commit_id":"7e5b0b15677aaba044161ecd6bb039587d185c0f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static GroovyElementType parse(PsiBuilder builder) {\n\n    PsiBuilder.Marker annMarker = builder.mark();\n\n    if (!ParserUtils.getToken(builder, mAT)) {\n      annMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n\n    if (WRONGWAY.equals(ReferenceElement.parseReferenceElement(builder))) {\n      annMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n    AnnotationArguments.parse(builder);\n\n    annMarker.done(ANNOTATION);\n    return ANNOTATION;\n  }","id":102447,"modified_method":"public static GroovyElementType parse(PsiBuilder builder) {\n\n    PsiBuilder.Marker annMarker = builder.mark();\n\n    if (!ParserUtils.getToken(builder, mAT)) {\n      annMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n\n    if (!ReferenceElement.parseReferenceElement(builder)) {\n      annMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n    AnnotationArguments.parse(builder);\n\n    annMarker.done(ANNOTATION);\n    return ANNOTATION;\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static IElementType parse(PsiBuilder builder, String className) {\n\n    //constructor\n    PsiBuilder.Marker constructorMarker = builder.mark();\n\n    GroovyElementType constructorDef = ConstructorDefinition.parse(builder, className);\n\n    if (WRONGWAY.equals(constructorDef)) {\n      constructorMarker.rollbackTo();\n    } else {\n      constructorMarker.done(constructorDef);\n      return constructorDef;\n    }\n\n    //declaration\n    PsiBuilder.Marker declMarker = builder.mark();\n    GroovyElementType declType = Declaration.parse(builder, true);\n    if (WRONGWAY.equals(declType)) {\n      declMarker.rollbackTo();\n    } else {\n      declMarker.drop();\n      return declType;\n    }\n//    if (DeclarationStart.parse(builder)) {\n//      declMarker.rollbackTo();\n//      return Declaration.parse(builder);\n//    }\n\n    //type definition\n    PsiBuilder.Marker typeDeclStartMarker = builder.mark();\n    if (TypeDeclarationStart.parse(builder)) {\n      typeDeclStartMarker.rollbackTo();\n\n      IElementType typeDef = TypeDefinition.parse(builder);\n      if (WRONGWAY.equals(typeDef)) {\n        builder.error(GroovyBundle.message(\"type.definition.expected\"));\n        return WRONGWAY;\n      }\n      return typeDef;\n    }\n    typeDeclStartMarker.rollbackTo();\n\n    //static compound statement\n    if (ParserUtils.getToken(builder, kSTATIC)) {\n      if (!WRONGWAY.equals(OpenOrClosableBlock.parseOpenBlock(builder))) {\n        return STATIC_COMPOUND_STATEMENT;\n      } else {\n        builder.error(GroovyBundle.message(\"compound.statemenet.expected\"));\n        return WRONGWAY;\n      }\n    }\n\n    if (!WRONGWAY.equals(OpenOrClosableBlock.parseOpenBlock(builder))) {\n      return COMPOUND_STATEMENT;\n    }\n\n    return WRONGWAY;\n  }","id":102448,"modified_method":"public static IElementType parse(PsiBuilder builder, String className) {\n\n    if (ConstructorDefinition.parse(builder, className)) return CONSTRUCTOR_DEFINITION;\n\n    //declaration\n    PsiBuilder.Marker declMarker = builder.mark();\n    GroovyElementType declType = Declaration.parse(builder, true);\n    if (WRONGWAY.equals(declType)) {\n      declMarker.rollbackTo();\n    } else {\n      declMarker.drop();\n      return declType;\n    }\n//    if (DeclarationStart.parse(builder)) {\n//      declMarker.rollbackTo();\n//      return Declaration.parse(builder);\n//    }\n\n    //type definition\n    PsiBuilder.Marker typeDeclStartMarker = builder.mark();\n    if (TypeDeclarationStart.parse(builder)) {\n      typeDeclStartMarker.rollbackTo();\n\n      IElementType typeDef = TypeDefinition.parse(builder);\n      if (WRONGWAY.equals(typeDef)) {\n        builder.error(GroovyBundle.message(\"type.definition.expected\"));\n        return WRONGWAY;\n      }\n      return typeDef;\n    }\n    typeDeclStartMarker.rollbackTo();\n\n    //static compound statement\n    if (ParserUtils.getToken(builder, kSTATIC)) {\n      if (!WRONGWAY.equals(OpenOrClosableBlock.parseOpenBlock(builder))) {\n        return STATIC_COMPOUND_STATEMENT;\n      } else {\n        builder.error(GroovyBundle.message(\"compound.statemenet.expected\"));\n        return WRONGWAY;\n      }\n    }\n\n    if (!WRONGWAY.equals(OpenOrClosableBlock.parseOpenBlock(builder))) {\n      return COMPOUND_STATEMENT;\n    }\n\n    return WRONGWAY;\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static IElementType parseModifiers(PsiBuilder builder) {\n    PsiBuilder.Marker modifiersMarker = builder.mark();\n\n    boolean parsedAnnotation;\n    boolean parsedModifier;\n    boolean parsedDef;\n    do {\n      if (kSTATIC.equals(builder.getTokenType())) {\n        modifiersMarker.rollbackTo();\n        return WRONGWAY;\n      }\n\n      parsedAnnotation = Annotation.parse(builder) != WRONGWAY;\n      parsedModifier = Modifier.parse(builder) != WRONGWAY;\n      parsedDef = ParserUtils.getToken(builder, kDEF);\n      ParserUtils.getToken(builder, mNLS);\n    } while(parsedAnnotation || parsedModifier | parsedDef);\n\n    modifiersMarker.done(MODIFIERS);\n    return MODIFIERS;\n  }","id":102449,"modified_method":"private static boolean parseModifiers(PsiBuilder builder) {\n    PsiBuilder.Marker modifiersMarker = builder.mark();\n\n    boolean parsedAnnotation;\n    boolean parsedModifier;\n    boolean parsedDef;\n    do {\n      if (kSTATIC.equals(builder.getTokenType())) {\n        modifiersMarker.rollbackTo();\n        return false;\n      }\n\n      parsedAnnotation = Annotation.parse(builder) != WRONGWAY;\n      parsedModifier = Modifier.parse(builder) != WRONGWAY;\n      parsedDef = ParserUtils.getToken(builder, kDEF);\n      ParserUtils.getToken(builder, mNLS);\n    } while(parsedAnnotation || parsedModifier | parsedDef);\n\n    modifiersMarker.done(MODIFIERS);\n    return true;\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GroovyElementType parse(PsiBuilder builder, String className) {\n    if (className == null) return WRONGWAY;\n    if (parseModifiers(builder) == WRONGWAY) return WRONGWAY;\n\n    if (builder.getTokenType() != mIDENT || !className.equals(builder.getTokenText())) {\n      builder.error(GroovyBundle.message(\"identifier.expected\"));\n      return WRONGWAY;\n    } else {\n      builder.advanceLexer();\n    }\n\n    if (!ParserUtils.getToken(builder, mLPAREN)) {\n      builder.error(GroovyBundle.message(\"lparen.expected\"));\n    }\n\n    ParameterDeclarationList.parse(builder, mRPAREN);\n\n    ParserUtils.getToken(builder, mNLS);\n    if (!ParserUtils.getToken(builder, mRPAREN)) {\n      /*ThrowClause.parse(builder);\n      ParserUtils.waitNextRCurly(builder);\n\n      builder.error(GroovyBundle.message(\"rparen.expected\"));*/\n      return WRONGWAY;\n    }\n\n    ThrowClause.parse(builder);\n\n    if (builder.getTokenType() == mLCURLY || ParserUtils.lookAhead(builder, mNLS, mLCURLY)) {\n      ParserUtils.getToken(builder, mNLS);\n      GroovyElementType methodBody = ConstructorBody.parse(builder);\n      if (!WRONGWAY.equals(methodBody)) {\n        return CONSTRUCTOR_DEFINITION;\n      }\n    }\n\n    return WRONGWAY;\n  }","id":102450,"modified_method":"public static boolean parse(PsiBuilder builder, String className) {\n    if (className == null) return false;\n    PsiBuilder.Marker constructorMarker = builder.mark();\n    if (!parseModifiers(builder)) {\n      constructorMarker.rollbackTo();\n      return false;\n    }\n\n    if (builder.getTokenType() != mIDENT || !className.equals(builder.getTokenText())) {\n      builder.error(GroovyBundle.message(\"identifier.expected\"));\n      constructorMarker.rollbackTo();\n      return false;\n    } else {\n      builder.advanceLexer();\n    }\n\n    if (!ParserUtils.getToken(builder, mLPAREN)) {\n      builder.error(GroovyBundle.message(\"lparen.expected\"));\n    }\n\n    ParameterDeclarationList.parse(builder, mRPAREN);\n\n    ParserUtils.getToken(builder, mNLS);\n    if (!ParserUtils.getToken(builder, mRPAREN)) {\n      constructorMarker.rollbackTo();\n      return false;\n    }\n\n    ThrowClause.parse(builder);\n\n    if (builder.getTokenType() == mLCURLY || ParserUtils.lookAhead(builder, mNLS, mLCURLY)) {\n      ParserUtils.getToken(builder, mNLS);\n      GroovyElementType methodBody = ConstructorBody.parse(builder);\n      if (!WRONGWAY.equals(methodBody)) {\n        constructorMarker.done(CONSTRUCTOR_DEFINITION);\n        return true;\n      }\n    }\n\n    constructorMarker.rollbackTo();\n    return false;\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static IElementType parse(PsiBuilder builder) {\n    PsiBuilder.Marker sccMarker = builder.mark();\n\n    if (!ParserUtils.getToken(builder, kEXTENDS)) {\n      sccMarker.rollbackTo();\n      return NONE;\n    }\n\n    ParserUtils.getToken(builder, mNLS);\n\n    if (WRONGWAY.equals(ReferenceElement.parseReferenceElement(builder))) {\n      sccMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n    while (ParserUtils.getToken(builder, mCOMMA)) {\n      ParserUtils.getToken(builder, mNLS);\n\n      if (WRONGWAY.equals(ReferenceElement.parseReferenceElement(builder))) {\n        sccMarker.rollbackTo();\n        return WRONGWAY;\n      }\n    }\n\n    sccMarker.done(EXTENDS_CLAUSE);\n    return EXTENDS_CLAUSE;\n  }","id":102451,"modified_method":"public static IElementType parse(PsiBuilder builder) {\n    PsiBuilder.Marker sccMarker = builder.mark();\n\n    if (!ParserUtils.getToken(builder, kEXTENDS)) {\n      sccMarker.rollbackTo();\n      return NONE;\n    }\n\n    ParserUtils.getToken(builder, mNLS);\n\n    if (!ReferenceElement.parseReferenceElement(builder)) {\n      sccMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n    while (ParserUtils.getToken(builder, mCOMMA)) {\n      ParserUtils.getToken(builder, mNLS);\n\n      if (!ReferenceElement.parseReferenceElement(builder)) {\n        sccMarker.rollbackTo();\n        return WRONGWAY;\n      }\n    }\n\n    sccMarker.done(EXTENDS_CLAUSE);\n    return EXTENDS_CLAUSE;\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static IElementType parse(PsiBuilder builder) {\n    PsiBuilder.Marker isMarker = builder.mark();\n\n    if (!ParserUtils.getToken(builder, kIMPLEMENTS)) {\n      isMarker.rollbackTo();\n      return NONE;\n    }\n\n    ParserUtils.getToken(builder, mNLS);\n\n    if (WRONGWAY.equals(ReferenceElement.parseReferenceElement(builder))) {\n      isMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n    while (ParserUtils.getToken(builder, mCOMMA)) {\n      ParserUtils.getToken(builder, mNLS);\n\n      if (WRONGWAY.equals(ReferenceElement.parseReferenceElement(builder))) {\n        isMarker.rollbackTo();\n        return WRONGWAY;\n      }\n    }\n\n    ParserUtils.getToken(builder, mNLS);\n    isMarker.done(IMPLEMENTS_CLAUSE);\n    return IMPLEMENTS_CLAUSE;\n  }","id":102452,"modified_method":"public static IElementType parse(PsiBuilder builder) {\n    PsiBuilder.Marker isMarker = builder.mark();\n\n    if (!ParserUtils.getToken(builder, kIMPLEMENTS)) {\n      isMarker.rollbackTo();\n      return NONE;\n    }\n\n    ParserUtils.getToken(builder, mNLS);\n\n    if (!ReferenceElement.parseReferenceElement(builder)) {\n      isMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n    while (ParserUtils.getToken(builder, mCOMMA)) {\n      ParserUtils.getToken(builder, mNLS);\n\n      if (!ReferenceElement.parseReferenceElement(builder)) {\n        isMarker.rollbackTo();\n        return WRONGWAY;\n      }\n    }\n\n    ParserUtils.getToken(builder, mNLS);\n    isMarker.done(IMPLEMENTS_CLAUSE);\n    return IMPLEMENTS_CLAUSE;\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static IElementType parse(PsiBuilder builder, String interfaceName) {\n    //constructor\n    PsiBuilder.Marker constructorMarker = builder.mark();\n\n    GroovyElementType constructorDef = ConstructorDefinition.parse(builder, interfaceName);\n\n    if (WRONGWAY.equals(constructorDef)) {\n      constructorMarker.rollbackTo();\n    } else {\n      constructorMarker.done(constructorDef);\n      return constructorDef;\n    }\n    \n    //declaration\n    PsiBuilder.Marker declMarker = builder.mark();\n    GroovyElementType declType = Declaration.parse(builder, true);\n    if (WRONGWAY.equals(declType)) {\n      declMarker.rollbackTo();\n    } else {\n      declMarker.drop();\n      return declType;\n    }\n\n    //declaration\n//    PsiBuilder.Marker declMarker = builder.mark();\n//    if (DeclarationStart.parse(builder)) {\n//      declMarker.rollbackTo();\n//      return Declaration.parse(builder);\n//    }\n//    declMarker.rollbackTo();\n\n    //type definition\n    PsiBuilder.Marker typeDeclStartMarker = builder.mark();\n    if (TypeDeclarationStart.parse(builder)) {\n      typeDeclStartMarker.rollbackTo();\n\n      IElementType typeDef = TypeDefinition.parse(builder);\n      if (WRONGWAY.equals(typeDef)) {\n        return WRONGWAY;\n      }\n      return typeDef;\n    }\n    typeDeclStartMarker.rollbackTo();\n\n    //static compound statement\n    if (ParserUtils.getToken(builder, kSTATIC)) {\n      if (!WRONGWAY.equals(OpenOrClosableBlock.parseOpenBlock(builder))) {\n        builder.error(GroovyBundle.message(\"interface.must.has.no.static.compound.statemenet\"));\n        return STATIC_COMPOUND_STATEMENT;\n      } else {\n        builder.error(GroovyBundle.message(\"compound.statemenet.expected\"));\n        return WRONGWAY;\n      }\n    }\n\n    if (!WRONGWAY.equals(OpenOrClosableBlock.parseOpenBlock(builder))) {\n      builder.error(GroovyBundle.message(\"interface.must.has.no.compound.statemenet\"));\n      return COMPOUND_STATEMENT;\n    }\n\n    return WRONGWAY;\n  }","id":102453,"modified_method":"public static IElementType parse(PsiBuilder builder, String interfaceName) {\n    //constructor\n    if (ConstructorDefinition.parse(builder, interfaceName)) return CONSTRUCTOR_DEFINITION;\n\n    //declaration\n    PsiBuilder.Marker declMarker = builder.mark();\n    GroovyElementType declType = Declaration.parse(builder, true);\n    if (WRONGWAY.equals(declType)) {\n      declMarker.rollbackTo();\n    } else {\n      declMarker.drop();\n      return declType;\n    }\n\n    //declaration\n//    PsiBuilder.Marker declMarker = builder.mark();\n//    if (DeclarationStart.parse(builder)) {\n//      declMarker.rollbackTo();\n//      return Declaration.parse(builder);\n//    }\n//    declMarker.rollbackTo();\n\n    //type definition\n    PsiBuilder.Marker typeDeclStartMarker = builder.mark();\n    if (TypeDeclarationStart.parse(builder)) {\n      typeDeclStartMarker.rollbackTo();\n\n      IElementType typeDef = TypeDefinition.parse(builder);\n      if (WRONGWAY.equals(typeDef)) {\n        return WRONGWAY;\n      }\n      return typeDef;\n    }\n    typeDeclStartMarker.rollbackTo();\n\n    //static compound statement\n    if (ParserUtils.getToken(builder, kSTATIC)) {\n      if (!WRONGWAY.equals(OpenOrClosableBlock.parseOpenBlock(builder))) {\n        builder.error(GroovyBundle.message(\"interface.must.has.no.static.compound.statemenet\"));\n        return STATIC_COMPOUND_STATEMENT;\n      } else {\n        builder.error(GroovyBundle.message(\"compound.statemenet.expected\"));\n        return WRONGWAY;\n      }\n    }\n\n    if (!WRONGWAY.equals(OpenOrClosableBlock.parseOpenBlock(builder))) {\n      builder.error(GroovyBundle.message(\"interface.must.has.no.compound.statemenet\"));\n      return COMPOUND_STATEMENT;\n    }\n\n    return WRONGWAY;\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GroovyElementType parseForPackage(PsiBuilder builder) {\n    return parse(builder, false, false, false, true);\n  }","id":102454,"modified_method":"public static boolean parseForPackage(PsiBuilder builder) {\n    return parse(builder, false, false, false, true);\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GroovyElementType parseForImport(PsiBuilder builder) {\n    return parse(builder, false, false, true, false);\n  }","id":102455,"modified_method":"public static boolean parseForImport(PsiBuilder builder) {\n    return parse(builder, false, false, true, false);\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GroovyElementType parseReferenceElement(PsiBuilder builder, boolean isUpperCase) {\n    return parse(builder, isUpperCase, true, false, false);\n  }","id":102456,"modified_method":"public static boolean parseReferenceElement(PsiBuilder builder, boolean isUpperCase) {\n    return parse(builder, isUpperCase, true, false, false);\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static GroovyElementType parse(PsiBuilder builder, boolean checkUpperCase, boolean parseTypeArgs, boolean forImport, boolean forPackage) {\n    PsiBuilder.Marker internalTypeMarker = builder.mark();\n\n//    char firstChar;\n//    if (builder.getTokenText() != null) firstChar = builder.getTokenText().charAt(0);\n//    else return WRONGWAY;\n\n//    if (checkUpperCase && !Character.isUpperCase(firstChar)) {\n//      internalTypeMarker.rollbackTo();\n//      return WRONGWAY;\n//    }\n\n    String lastIdentifier = builder.getTokenText();\n\n    if (!ParserUtils.getToken(builder, mIDENT)) {\n      internalTypeMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n    if (parseTypeArgs) TypeArguments.parse(builder);\n\n    internalTypeMarker.done(REFERENCE_ELEMENT);\n    internalTypeMarker = internalTypeMarker.precede();\n\n    while (mDOT.equals(builder.getTokenType())) {\n\n      if ((ParserUtils.lookAhead(builder, mDOT, mSTAR) ||\n          ParserUtils.lookAhead(builder, mDOT, mNLS, mSTAR)) &&\n          forImport) {\n        internalTypeMarker.drop();\n        return REFERENCE_ELEMENT;\n      }\n\n      ParserUtils.getToken(builder, mDOT);\n\n      if (forImport) {\n        ParserUtils.getToken(builder, mNLS);\n      }\n\n      lastIdentifier = builder.getTokenText();\n\n      if (!ParserUtils.getToken(builder, mIDENT)) {\n        internalTypeMarker.rollbackTo();\n        return WRONGWAY;\n      }\n\n      TypeArguments.parse(builder);\n\n      internalTypeMarker.done(REFERENCE_ELEMENT);\n      internalTypeMarker = internalTypeMarker.precede();\n    }\n\n    char firstChar;\n    if (lastIdentifier != null) firstChar = lastIdentifier.charAt(0);\n    else return WRONGWAY;\n\n    if (checkUpperCase && (!Character.isUpperCase(firstChar) || DUMMY_IDENTIFIER.equals(lastIdentifier))) { //hack to make completion work\n      internalTypeMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n    if (forPackage || forImport) {\n      internalTypeMarker.drop();\n      return REFERENCE_ELEMENT;\n    }\n\n//    internalTypeMarker.done(TYPE_ELEMENT);\n    internalTypeMarker.drop();\n    return REFERENCE_ELEMENT;\n  }","id":102457,"modified_method":"private static boolean parse(PsiBuilder builder, boolean checkUpperCase, boolean parseTypeArgs, boolean forImport, boolean forPackage) {\n    PsiBuilder.Marker internalTypeMarker = builder.mark();\n\n//    char firstChar;\n//    if (builder.getTokenText() != null) firstChar = builder.getTokenText().charAt(0);\n//    else return WRONGWAY;\n\n//    if (checkUpperCase && !Character.isUpperCase(firstChar)) {\n//      internalTypeMarker.rollbackTo();\n//      return WRONGWAY;\n//    }\n\n    String lastIdentifier = builder.getTokenText();\n\n    if (!ParserUtils.getToken(builder, mIDENT)) {\n      internalTypeMarker.rollbackTo();\n      return false;\n    }\n\n    if (parseTypeArgs) TypeArguments.parse(builder);\n\n    internalTypeMarker.done(REFERENCE_ELEMENT);\n    internalTypeMarker = internalTypeMarker.precede();\n\n    while (mDOT.equals(builder.getTokenType())) {\n\n      if ((ParserUtils.lookAhead(builder, mDOT, mSTAR) ||\n          ParserUtils.lookAhead(builder, mDOT, mNLS, mSTAR)) &&\n          forImport) {\n        internalTypeMarker.drop();\n        return true;\n      }\n\n      ParserUtils.getToken(builder, mDOT);\n\n      if (forImport) {\n        ParserUtils.getToken(builder, mNLS);\n      }\n\n      lastIdentifier = builder.getTokenText();\n\n      if (!ParserUtils.getToken(builder, mIDENT)) {\n        internalTypeMarker.rollbackTo();\n        return false;\n      }\n\n      TypeArguments.parse(builder);\n\n      internalTypeMarker.done(REFERENCE_ELEMENT);\n      internalTypeMarker = internalTypeMarker.precede();\n    }\n\n    char firstChar;\n    if (lastIdentifier != null) firstChar = lastIdentifier.charAt(0);\n    else return false;\n\n    if (checkUpperCase && (!Character.isUpperCase(firstChar) || DUMMY_IDENTIFIER.equals(lastIdentifier))) { //hack to make completion work\n      internalTypeMarker.rollbackTo();\n      return false;\n    }\n\n    if (forPackage || forImport) {\n      internalTypeMarker.drop();\n      return true;\n    }\n\n//    internalTypeMarker.done(TYPE_ELEMENT);\n    internalTypeMarker.drop();\n    return true;\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GroovyElementType parseReferenceElement(PsiBuilder builder) {\n    return parse(builder, false, true, false, false);\n  }","id":102458,"modified_method":"public static boolean parseReferenceElement(PsiBuilder builder) {\n    return parse(builder, false, true, false, false);\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void parse(PsiBuilder builder) {\n    PsiBuilder.Marker throwClauseMarker = builder.mark();\n\n    if (!ParserUtils.getToken(builder, kTHROWS)) {\n      throwClauseMarker.done(THROW_CLAUSE);\n      return;\n    }\n\n    ParserUtils.getToken(builder, mNLS);\n\n    if (WRONGWAY.equals(ReferenceElement.parseReferenceElement(builder))) {\n      throwClauseMarker.done(THROW_CLAUSE);\n      builder.error(GroovyBundle.message(\"identifier.expected\"));\n      return;\n    }\n\n    while (ParserUtils.getToken(builder, mCOMMA)) {\n      ParserUtils.getToken(builder, mNLS);\n\n      if (WRONGWAY.equals(ReferenceElement.parseReferenceElement(builder))) {\n        throwClauseMarker.done(THROW_CLAUSE);\n        return;\n      }\n    }\n\n    ParserUtils.getToken(builder, mNLS);\n\n    throwClauseMarker.done(THROW_CLAUSE);\n  }","id":102459,"modified_method":"public static void parse(PsiBuilder builder) {\n    PsiBuilder.Marker throwClauseMarker = builder.mark();\n\n    if (!ParserUtils.getToken(builder, kTHROWS)) {\n      throwClauseMarker.done(THROW_CLAUSE);\n      return;\n    }\n\n    ParserUtils.getToken(builder, mNLS);\n\n    if (!ReferenceElement.parseReferenceElement(builder)) {\n      throwClauseMarker.done(THROW_CLAUSE);\n      builder.error(GroovyBundle.message(\"identifier.expected\"));\n      return;\n    }\n\n    while (ParserUtils.getToken(builder, mCOMMA)) {\n      ParserUtils.getToken(builder, mNLS);\n\n      if (!ReferenceElement.parseReferenceElement(builder)) {\n        throwClauseMarker.done(THROW_CLAUSE);\n        return;\n      }\n    }\n\n    ParserUtils.getToken(builder, mNLS);\n\n    throwClauseMarker.done(THROW_CLAUSE);\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static IElementType parseExtendsBoundList(PsiBuilder builder) {\n    PsiBuilder.Marker marker = builder.mark();\n    ParserUtils.getToken(builder, kEXTENDS);\n    ParserUtils.getToken(builder, mNLS);\n    GroovyElementType reference = ReferenceElement.parseReferenceElement(builder);\n    if (reference == WRONGWAY) {\n      builder.error(GroovyBundle.message(\"identifier.expected\"));\n    } else {\n      while (mBAND == builder.getTokenType() && reference != WRONGWAY) {\n        ParserUtils.getToken(builder, mBAND);\n        ParserUtils.getToken(builder, mNLS);\n        reference = ReferenceElement.parseReferenceElement(builder);\n        if (reference == WRONGWAY) {\n          builder.error(GroovyBundle.message(\"type.argument.expected\"));\n        }\n      }\n    }\n    marker.done(TYPE_PARAMETER_EXTENDS_BOUND_LIST);\n    return TYPE_PARAMETER_EXTENDS_BOUND_LIST;\n  }","id":102460,"modified_method":"private static IElementType parseExtendsBoundList(PsiBuilder builder) {\n    PsiBuilder.Marker marker = builder.mark();\n    ParserUtils.getToken(builder, kEXTENDS);\n    ParserUtils.getToken(builder, mNLS);\n    if (!ReferenceElement.parseReferenceElement(builder)) {\n      builder.error(GroovyBundle.message(\"identifier.expected\"));\n    } else {\n      while (mBAND == builder.getTokenType()) {\n        ParserUtils.getToken(builder, mBAND);\n        ParserUtils.getToken(builder, mNLS);\n        if (!ReferenceElement.parseReferenceElement(builder)) {\n          builder.error(GroovyBundle.message(\"type.argument.expected\"));\n        }\n      }\n    }\n    marker.done(TYPE_PARAMETER_EXTENDS_BOUND_LIST);\n    return TYPE_PARAMETER_EXTENDS_BOUND_LIST;\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Class or interface type\n   *\n   * @param builder\n   */\n\n  private static GroovyElementType parseClassOrInterfaceType(PsiBuilder builder, boolean isUpper) {\n    PsiBuilder.Marker arrMarker = builder.mark();\n    PsiBuilder.Marker typeElementMarker = builder.mark();\n\n    if (WRONGWAY.equals(ReferenceElement.parseReferenceElement(builder, isUpper))) {\n      typeElementMarker.drop();\n      arrMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n    typeElementMarker.done(CLASS_TYPE_ELEMENT);\n\n    if (ParserUtils.lookAhead(builder, mLBRACK, mRBRACK)) {\n      declarationBracketsParse(builder, arrMarker);\n    } else {\n      arrMarker.drop();\n    }\n    return CLASS_TYPE_ELEMENT;\n  }","id":102461,"modified_method":"/**\n   * Class or interface type\n   *\n   * @param builder\n   */\n\n  private static GroovyElementType parseClassOrInterfaceType(PsiBuilder builder, boolean isUpper) {\n    PsiBuilder.Marker arrMarker = builder.mark();\n    PsiBuilder.Marker typeElementMarker = builder.mark();\n\n    if (!ReferenceElement.parseReferenceElement(builder, isUpper)) {\n      typeElementMarker.drop();\n      arrMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n    typeElementMarker.done(CLASS_TYPE_ELEMENT);\n\n    if (ParserUtils.lookAhead(builder, mLBRACK, mRBRACK)) {\n      declarationBracketsParse(builder, arrMarker);\n    } else {\n      arrMarker.drop();\n    }\n    return CLASS_TYPE_ELEMENT;\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GroovyElementType parseClassOrInterfaceType(PsiBuilder builder) {\n    PsiBuilder.Marker typeElementMarker = builder.mark();\n\n    if (WRONGWAY.equals(ReferenceElement.parseReferenceElement(builder, true))) {\n      typeElementMarker.drop();\n      return WRONGWAY;\n    }\n    typeElementMarker.done(CLASS_TYPE_ELEMENT);\n    return CLASS_TYPE_ELEMENT;\n  }","id":102462,"modified_method":"public static GroovyElementType parseClassOrInterfaceType(PsiBuilder builder) {\n    PsiBuilder.Marker typeElementMarker = builder.mark();\n\n    if (!ReferenceElement.parseReferenceElement(builder, true)) {\n      typeElementMarker.drop();\n      return WRONGWAY;\n    }\n    typeElementMarker.done(CLASS_TYPE_ELEMENT);\n    return CLASS_TYPE_ELEMENT;\n  }","commit_id":"bdd8fd19b701065a7689aa43b3b27a4f67d170c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void locateOutsideMouseCursor(Editor editor, JComponent editorComponent, Point p, int width, int height, int heightLimit) {\n    Point mouse = MouseInfo.getPointerInfo().getLocation();\n    SwingUtilities.convertPointFromScreen(mouse, editorComponent);\n    Rectangle tooltipRect = new Rectangle(p, new Dimension(width, height));\n    // should show at least one line apart\n    tooltipRect.setBounds(tooltipRect.x, tooltipRect.y - editor.getLineHeight(), width, height + 2 * editor.getLineHeight());\n    if (tooltipRect.contains(mouse)) {\n      if (mouse.y + height + editor.getLineHeight() > heightLimit && mouse.y - height - editor.getLineHeight() > 0) {\n        p.y = mouse.y - height - editor.getLineHeight();\n      }\n      else {\n        p.y = mouse.y + editor.getLineHeight();\n      }\n    }\n  }","id":102463,"modified_method":"private static void locateOutsideMouseCursor(Editor editor, JComponent editorComponent, Point p, int width, int height, int heightLimit) {\n    PointerInfo pointerInfo = MouseInfo.getPointerInfo();\n    if (pointerInfo == null) return;\n    Point mouse = pointerInfo.getLocation();\n    SwingUtilities.convertPointFromScreen(mouse, editorComponent);\n    Rectangle tooltipRect = new Rectangle(p, new Dimension(width, height));\n    // should show at least one line apart\n    tooltipRect.setBounds(tooltipRect.x, tooltipRect.y - editor.getLineHeight(), width, height + 2 * editor.getLineHeight());\n    if (tooltipRect.contains(mouse)) {\n      if (mouse.y + height + editor.getLineHeight() > heightLimit && mouse.y - height - editor.getLineHeight() > 0) {\n        p.y = mouse.y - height - editor.getLineHeight();\n      }\n      else {\n        p.y = mouse.y + editor.getLineHeight();\n      }\n    }\n  }","commit_id":"91d037fc5b2529d20f4ba73a5f15bb4fca8e71b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void run()\r\n    {\r\n        run = true;\r\n        int timer = 0;\r\n        do\r\n        {\r\n            try\r\n            {\r\n                if (MouseInfo.getPointerInfo() != null)\r\n                {\r\n                    Point currentPosition = MouseInfo.getPointerInfo()\r\n                            .getLocation();\r\n                    if (!isNear(lastPosition, currentPosition))\r\n                    {\r\n                        // position has changed\r\n                        // check, if a minor state has been automatically set\r\n                        // and\r\n                        // reset this state to the former state.\r\n                        ProtocolProviderService[] pps = AutoAwayActivator\r\n                                .getProtocolProviders();\r\n\r\n                        for (ProtocolProviderService protocolProviderService : pps)\r\n                        {\r\n                            if (lastStates.get(protocolProviderService) != null)\r\n                            {\r\n                                PresenceStatus lastState = lastStates\r\n                                        .get(protocolProviderService);\r\n                                OperationSetPresence presence = (OperationSetPresence) protocolProviderService\r\n                                        .getOperationSet(OperationSetPresence.class);\r\n                                try\r\n                                {\r\n                                    presence.publishPresenceStatus(lastState,\r\n                                            \"\");\r\n                                } catch (IllegalArgumentException e)\r\n                                {\r\n                                } catch (IllegalStateException e)\r\n                                {\r\n                                } catch (OperationFailedException e)\r\n                                {\r\n                                }\r\n                                lastStates.remove(protocolProviderService);\r\n                            }\r\n                        }\r\n                        timer = getTimer() * 1000 * 60;\r\n                    } else\r\n                    {\r\n                        // position has not changed!\r\n                        // get all protocols and set them to away\r\n\r\n                        ProtocolProviderService[] pps = AutoAwayActivator\r\n                                .getProtocolProviders();\r\n\r\n                        for (ProtocolProviderService protocolProviderService : pps)\r\n                        {\r\n                            OperationSetPresence presence = (OperationSetPresence) protocolProviderService\r\n                                    .getOperationSet(OperationSetPresence.class);\r\n\r\n                            PresenceStatus status = presence\r\n                                    .getPresenceStatus();\r\n\r\n                            if (status.getStatus() < PresenceStatus.AVAILABLE_THRESHOLD)\r\n                            {\r\n                                // already (manually) set to away or lower\r\n                                continue;\r\n                            }\r\n\r\n                            lastStates.put(protocolProviderService, presence\r\n                                    .getPresenceStatus());\r\n\r\n                            PresenceStatus newStatus = findAwayStatus(presence);\r\n\r\n                            try\r\n                            {\r\n                                if (newStatus != null)\r\n                                {\r\n                                    presence.publishPresenceStatus(newStatus,\r\n                                            newStatus.getStatusName());\r\n                                }\r\n                            } catch (IllegalArgumentException e)\r\n                            {\r\n                            } catch (IllegalStateException e)\r\n                            {\r\n                            } catch (OperationFailedException e)\r\n                            {\r\n                            }\r\n                        }\r\n\r\n                        timer = IDLE_TIMER;\r\n                    }\r\n                    lastPosition = currentPosition;\r\n                }\r\n                Thread.sleep(timer);\r\n            } catch (InterruptedException e)\r\n            {\r\n            }\r\n        } while (run && timer > 0);\r\n    }","id":102464,"modified_method":"public void run()\r\n    {\r\n        run = true;\r\n        int timer = 0;\r\n        do\r\n        {\r\n            try\r\n            {\r\n                if (MouseInfo.getPointerInfo() != null)\r\n                {\r\n                    PointerInfo info = MouseInfo.getPointerInfo();\r\n                    Point currentPosition = null;\r\n\r\n                    if (info != null)\r\n                    {\r\n                        currentPosition = info.getLocation();\r\n                    } else\r\n                    {\r\n                        // mouse cannot be determined\r\n                        currentPosition = new Point(0, 0);\r\n                    }\r\n                    if (!isNear(lastPosition, currentPosition))\r\n                    {\r\n                        // position has changed\r\n                        // check, if a minor state has been automatically set\r\n                        // and\r\n                        // reset this state to the former state.\r\n                        ProtocolProviderService[] pps = AutoAwayActivator\r\n                                .getProtocolProviders();\r\n\r\n                        for (ProtocolProviderService protocolProviderService : pps)\r\n                        {\r\n                            if (lastStates.get(protocolProviderService) != null)\r\n                            {\r\n                                PresenceStatus lastState = lastStates\r\n                                        .get(protocolProviderService);\r\n                                OperationSetPresence presence = (OperationSetPresence) protocolProviderService\r\n                                        .getOperationSet(OperationSetPresence.class);\r\n                                try\r\n                                {\r\n                                    presence.publishPresenceStatus(lastState,\r\n                                            \"\");\r\n                                } catch (IllegalArgumentException e)\r\n                                {\r\n                                } catch (IllegalStateException e)\r\n                                {\r\n                                } catch (OperationFailedException e)\r\n                                {\r\n                                }\r\n                                lastStates.remove(protocolProviderService);\r\n                            }\r\n                        }\r\n                        timer = getTimer() * 1000 * 60;\r\n                    } else\r\n                    {\r\n                        // position has not changed!\r\n                        // get all protocols and set them to away\r\n\r\n                        ProtocolProviderService[] pps = AutoAwayActivator\r\n                                .getProtocolProviders();\r\n\r\n                        for (ProtocolProviderService protocolProviderService : pps)\r\n                        {\r\n                            OperationSetPresence presence = (OperationSetPresence) protocolProviderService\r\n                                    .getOperationSet(OperationSetPresence.class);\r\n\r\n                            PresenceStatus status = presence\r\n                                    .getPresenceStatus();\r\n\r\n                            if (status.getStatus() < PresenceStatus.AVAILABLE_THRESHOLD)\r\n                            {\r\n                                // already (manually) set to away or lower\r\n                                continue;\r\n                            }\r\n\r\n                            lastStates.put(protocolProviderService, presence\r\n                                    .getPresenceStatus());\r\n\r\n                            PresenceStatus newStatus = findAwayStatus(presence);\r\n\r\n                            try\r\n                            {\r\n                                if (newStatus != null)\r\n                                {\r\n                                    presence.publishPresenceStatus(newStatus,\r\n                                            newStatus.getStatusName());\r\n                                }\r\n                            } catch (IllegalArgumentException e)\r\n                            {\r\n                            } catch (IllegalStateException e)\r\n                            {\r\n                            } catch (OperationFailedException e)\r\n                            {\r\n                            }\r\n                        }\r\n\r\n                        timer = IDLE_TIMER;\r\n                    }\r\n                    lastPosition = currentPosition;\r\n                }\r\n                Thread.sleep(timer);\r\n            } catch (InterruptedException e)\r\n            {\r\n            }\r\n        } while (run && timer > 0);\r\n    }","commit_id":"b2aad2c1461b3862e484ee60aa1cf8c23ad16b5e","url":"https://github.com/jitsi/jitsi"},{"original_method":"private Point fixPopupLocation(final Component contents, final int x, final int y) {\n    if (!(contents instanceof JToolTip)) return new Point(x, y);\n\n    final Point mouse = MouseInfo.getPointerInfo().getLocation();\n    int deltaY = mouse.y - y;\n\n    final Dimension size = contents.getPreferredSize();\n    final Rectangle rec = new Rectangle(new Point(x, y), size);\n    ScreenUtil.moveRectangleToFitTheScreen(rec);\n\n    if (rec.y < y) {\n      rec.y += deltaY;\n    }\n\n    return rec.getLocation();\n  }","id":102465,"modified_method":"private Point fixPopupLocation(final Component contents, final int x, final int y) {\n    if (!(contents instanceof JToolTip)) return new Point(x, y);\n\n    final PointerInfo info = MouseInfo.getPointerInfo();\n    int deltaY = 0;\n\n    if (info != null) {\n      final Point mouse = info.getLocation();\n      deltaY = mouse.y - y;\n    }\n\n    final Dimension size = contents.getPreferredSize();\n    final Rectangle rec = new Rectangle(new Point(x, y), size);\n    ScreenUtil.moveRectangleToFitTheScreen(rec);\n\n    if (rec.y < y) {\n      rec.y += deltaY;\n    }\n\n    return rec.getLocation();\n  }","commit_id":"6c3d7537023689e64f68e2261667191f834490bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void execute(ProjectInternal project) {\n        LOGGER.info(String.format(\"Evaluating %s using %s.\", project, project.getBuildScriptSource().getDisplayName()));\n        Clock clock = new Clock();\n        try {\n            ScriptPlugin configurer = configurerFactory.create(project.getBuildScriptSource(), project.getBuildscript(), project.getClassLoaderScope(), project.getBaseClassLoaderScope(), true);\n            configurer.apply(project);\n        } finally {\n            LOGGER.debug(\"Timing: Running the build script took {}\", clock.getTime());\n        }\n    }","id":102466,"modified_method":"public void execute(ProjectInternal project) {\n        LOGGER.info(\"Evaluating {} using {}.\", project, project.getBuildScriptSource().getDisplayName());\n        Clock clock = new Clock();\n        try {\n            ScriptPlugin configurer = configurerFactory.create(project.getBuildScriptSource(), project.getBuildscript(), project.getClassLoaderScope(), project.getBaseClassLoaderScope(), true);\n            configurer.apply(project);\n        } finally {\n            LOGGER.debug(\"Timing: Running the build script took {}\", clock.getTime());\n        }\n    }","commit_id":"335cc091f05d6bdc634c91842b025f789b1cbf80","url":"https://github.com/gradle/gradle"},{"original_method":"@OutputFiles\n    public Set<File> getEnabledFileReportDestinations() {\n        return CollectionUtils.collect(CollectionUtils.filter(getEnabled(), IS_FILE_OUTPUT_TYPE), toFile);\n    }","id":102467,"modified_method":"@OutputFiles\n    public Set<File> getEnabledFileReportDestinations() {\n        return CollectionUtils.collect(CollectionUtils.filter(getEnabled(), IS_FILE_OUTPUT_TYPE), TO_FILE);\n    }","commit_id":"335cc091f05d6bdc634c91842b025f789b1cbf80","url":"https://github.com/gradle/gradle"},{"original_method":"@OutputDirectories\n    public Set<File> getEnabledDirectoryReportDestinations() {\n        return CollectionUtils.collect(CollectionUtils.filter(getEnabled(), IS_DIRECTORY_OUTPUT_TYPE), toFile);\n    }","id":102468,"modified_method":"@OutputDirectories\n    public Set<File> getEnabledDirectoryReportDestinations() {\n        return CollectionUtils.collect(CollectionUtils.filter(getEnabled(), IS_DIRECTORY_OUTPUT_TYPE), TO_FILE);\n    }","commit_id":"335cc091f05d6bdc634c91842b025f789b1cbf80","url":"https://github.com/gradle/gradle"},{"original_method":"@Input\n    public SortedSet<String> getEnabledReportNames() {\n        return CollectionUtils.collect(getEnabled(), new TreeSet<String>(), new Transformer<String, Report>() {\n            public String transform(Report report) {\n                return report.getName();\n            }\n        });        \n    }","id":102469,"modified_method":"@Input\n    public SortedSet<String> getEnabledReportNames() {\n        return CollectionUtils.collect(getEnabled(), new TreeSet<String>(), REPORT_NAME);\n    }","commit_id":"335cc091f05d6bdc634c91842b025f789b1cbf80","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void slaveLost(SchedulerDriver driver, Protos.SlaveID slaveId) {\n      // TODO(jiri): Handle lost Mesos slaves.\n      LOG.info(String.format(\"Executor %s was lost\", slaveId.getValue()));\n    }","id":102470,"modified_method":"@Override\n    public void slaveLost(SchedulerDriver driver, Protos.SlaveID slaveId) {\n      // TODO(jiri): Handle lost Mesos slaves.\n      LOG.info(\"Executor {} was lost\", slaveId.getValue());\n    }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n    public void reregistered(SchedulerDriver driver, Protos.MasterInfo masterInfo) {\n      LOG.info(String.format(\"Registered framework with master %s:%d\",\n          masterInfo.getHostname(), masterInfo.getPort()));\n    }","id":102471,"modified_method":"@Override\n    public void reregistered(SchedulerDriver driver, Protos.MasterInfo masterInfo) {\n      LOG.info(\"Registered framework with master {}:{}\",\n          masterInfo.getHostname(), masterInfo.getPort());\n    }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"private static Protos.Credential createCredential() {\n\n    if (!Configuration.containsKey(Constants.INTEGRATION_MESOS_PRINCIPAL)) {\n      return null;\n    }\n\n    try {\n      Protos.Credential.Builder credentialBuilder = Protos.Credential.newBuilder()\n          .setPrincipal(Configuration.get(Constants.INTEGRATION_MESOS_PRINCIPAL)).setSecret(\n              ByteString.copyFrom(\n                  Configuration.get(Constants.INTEGRATION_MESOS_SECRET).getBytes(\"UTF-8\")));\n\n      return credentialBuilder.build();\n    } catch (UnsupportedEncodingException ex) {\n      LOG.error(String.format(\"Failed to encode secret when creating Credential: %s\",\n          ex.getMessage()));\n    }\n    return null;\n  }","id":102472,"modified_method":"private static Protos.Credential createCredential() {\n\n    if (!Configuration.containsKey(Constants.INTEGRATION_MESOS_PRINCIPAL)) {\n      return null;\n    }\n\n    try {\n      Protos.Credential.Builder credentialBuilder = Protos.Credential.newBuilder()\n          .setPrincipal(Configuration.get(Constants.INTEGRATION_MESOS_PRINCIPAL)).setSecret(\n              ByteString.copyFrom(\n                  Configuration.get(Constants.INTEGRATION_MESOS_SECRET).getBytes(\"UTF-8\")));\n\n      return credentialBuilder.build();\n    } catch (UnsupportedEncodingException ex) {\n      LOG.error(\"Failed to encode secret when creating Credential.\", ex);\n    }\n    return null;\n  }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"private static void usage() {\n    String name = AlluxioFramework.class.getName();\n    LOG.error(\"This is an implementation of a Mesos framework that is responsible for \"\n        + \"starting Alluxio processes. The current implementation starts a single Alluxio master \"\n        + \"and n Alluxio workers (one per Mesos slave).\");\n    LOG.error(\"Usage: \" + name + \" <hostname>\");\n  }","id":102473,"modified_method":"private static void usage() {\n    String name = AlluxioFramework.class.getName();\n    LOG.error(\"This is an implementation of a Mesos framework that is responsible for \"\n        + \"starting Alluxio processes. The current implementation starts a single Alluxio master \"\n        + \"and n Alluxio workers (one per Mesos slave).\");\n    LOG.error(\"Usage: {} <hostname>\", name);\n  }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n    public void statusUpdate(SchedulerDriver driver, Protos.TaskStatus status) {\n      String taskId = status.getTaskId().getValue();\n      Protos.TaskState state = status.getState();\n      LOG.info(String.format(\"Task %s is in state %s\", taskId, state));\n      // TODO(jiri): Handle the case when an Alluxio master and/or worker task fails.\n      // In particular, we should enable support for the fault tolerant mode of Alluxio to account\n      // for Alluxio master process failures and keep track of the running number of Alluxio\n      // masters.\n\n      switch (status.getState()) {\n        case TASK_FAILED: // intend to fall through\n        case TASK_LOST: // intend to fall through\n        case TASK_ERROR:\n          if (status.getTaskId().getValue().equals(String.valueOf(mMasterTaskId))) {\n            mMasterCount--;\n          }\n          break;\n        case TASK_RUNNING:\n          if (status.getTaskId().getValue().equals(String.valueOf(mMasterTaskId))) {\n            mMasterLaunched = true;\n          }\n          break;\n        default:\n          break;\n      }\n    }","id":102474,"modified_method":"@Override\n    public void statusUpdate(SchedulerDriver driver, Protos.TaskStatus status) {\n      String taskId = status.getTaskId().getValue();\n      Protos.TaskState state = status.getState();\n      LOG.info(\"Task {} is in state {}\", taskId, state);\n      // TODO(jiri): Handle the case when an Alluxio master and/or worker task fails.\n      // In particular, we should enable support for the fault tolerant mode of Alluxio to account\n      // for Alluxio master process failures and keep track of the running number of Alluxio\n      // masters.\n\n      switch (status.getState()) {\n        case TASK_FAILED: // intend to fall through\n        case TASK_LOST: // intend to fall through\n        case TASK_ERROR:\n          if (status.getTaskId().getValue().equals(String.valueOf(mMasterTaskId))) {\n            mMasterCount--;\n          }\n          break;\n        case TASK_RUNNING:\n          if (status.getTaskId().getValue().equals(String.valueOf(mMasterTaskId))) {\n            mMasterLaunched = true;\n          }\n          break;\n        default:\n          break;\n      }\n    }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n    public void registered(SchedulerDriver driver, Protos.FrameworkID frameworkId,\n                           Protos.MasterInfo masterInfo) {\n      LOG.info(String.format(\"Registered framework %s with master %s:%d\",\n          frameworkId.getValue(), masterInfo.getHostname(), masterInfo.getPort()));\n    }","id":102475,"modified_method":"@Override\n    public void registered(SchedulerDriver driver, Protos.FrameworkID frameworkId,\n        Protos.MasterInfo masterInfo) {\n      LOG.info(\"Registered framework {} with master {}:{}\",\n          frameworkId.getValue(), masterInfo.getHostname(), masterInfo.getPort());\n    }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n    public void error(SchedulerDriver driver, String message) {\n      LOG.error(String.format(\"Error: %s\", message));\n    }","id":102476,"modified_method":"@Override\n    public void error(SchedulerDriver driver, String message) {\n      LOG.error(\"Error: {}\", message);\n    }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n    public void resourceOffers(SchedulerDriver driver, List<Protos.Offer> offers) {\n      long masterCpu = Configuration.getInt(Constants.INTEGRATION_MASTER_RESOURCE_CPU);\n      long masterMem =\n          Configuration.getBytes(Constants.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB;\n      long workerCpu = Configuration.getInt(Constants.INTEGRATION_WORKER_RESOURCE_CPU);\n      long workerMem =\n          Configuration.getBytes(Constants.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB;\n\n      LOG.info(String.format(\"Master launched %b, master count %d, \"\n          + \"requested master cpu %d and mem %d MB\",\n          mMasterLaunched, mMasterCount, masterCpu, masterMem));\n\n      for (Protos.Offer offer : offers) {\n        Protos.Offer.Operation.Launch.Builder launch = Protos.Offer.Operation.Launch.newBuilder();\n        double offerCpu = 0;\n        double offerMem = 0;\n        for (Protos.Resource resource : offer.getResourcesList()) {\n          if (resource.getName().equals(Constants.MESOS_RESOURCE_CPUS)) {\n            offerCpu += resource.getScalar().getValue();\n          } else if (resource.getName().equals(Constants.MESOS_RESOURCE_MEM)) {\n            offerMem += resource.getScalar().getValue();\n          } else {\n            // Other resources are currently ignored.\n          }\n        }\n\n        LOG.info(String.format(\"Received offer %s with cpus %f and mem %f MB and hasMasterPorts %b\",\n            offer.getId().getValue(), offerCpu, offerMem,\n            OfferUtils.hasAvailableMasterPorts(offer)));\n\n        Protos.ExecutorInfo.Builder executorBuilder = Protos.ExecutorInfo.newBuilder();\n        List<Protos.Resource> resources;\n        if (!mMasterLaunched && offerCpu >= masterCpu && offerMem >= masterMem\n            && mMasterCount < Configuration\n            .getInt(Constants.INTEGRATION_MESOS_ALLUXIO_MASTER_NODE_COUNT) && OfferUtils\n            .hasAvailableMasterPorts(offer)) {\n          LOG.debug(\"Creating Alluxio Master executor\");\n          executorBuilder\n              .setName(\"Alluxio Master Executor\")\n              .setSource(\"master\")\n              .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"master\"))\n              .addAllResources(getExecutorResources())\n              .setCommand(\n                  Protos.CommandInfo\n                      .newBuilder()\n                      .setValue(\n                          \"export JAVA_HOME=\"\n                              + Configuration.get(Constants.INTEGRATION_MESOS_JRE_PATH)\n                              + \" && export PATH=$PATH:$JAVA_HOME/bin && \"\n                              + PathUtils.concatPath(\"alluxio\", \"integration\", \"bin\",\n                              \"alluxio-master-mesos.sh\"))\n                      .addAllUris(getExecutorDependencyURIList())\n                      .setEnvironment(\n                          Protos.Environment\n                              .newBuilder()\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                      .setValue(Configuration.get(Constants.UNDERFS_ADDRESS))\n                                      .build())\n                              .build()));\n          // pre-build resource list here, then use it to build Protos.Task later.\n          resources = getMasterRequiredResources(masterCpu, masterMem);\n          mMasterHostname = offer.getHostname();\n          mTaskName = Configuration.get(Constants.INTEGRATION_MESOS_ALLUXIO_MASTER_NAME);\n          mMasterCount++;\n          mMasterTaskId = mLaunchedTasks;\n\n        } else if (mMasterLaunched && !mWorkers.contains(offer.getHostname())\n            && offerCpu >= workerCpu && offerMem >= workerMem\n            && OfferUtils.hasAvailableWorkerPorts(offer)) {\n          LOG.debug(\"Creating Alluxio Worker executor\");\n          final String memSize = FormatUtils.getSizeFromBytes((long) workerMem * Constants.MB);\n          executorBuilder\n              .setName(\"Alluxio Worker Executor\")\n              .setSource(\"worker\")\n              .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"worker\"))\n              .addAllResources(getExecutorResources())\n              .setCommand(\n                  Protos.CommandInfo\n                      .newBuilder()\n                      .setValue(\n                          \"export JAVA_HOME=\"\n                              + Configuration.get(Constants.INTEGRATION_MESOS_JRE_PATH)\n                              + \" && export PATH=$PATH:$JAVA_HOME/bin && \"\n                              + PathUtils.concatPath(\"alluxio\", \"integration\", \"bin\",\n                              \"alluxio-worker-mesos.sh\"))\n                      .addAllUris(getExecutorDependencyURIList())\n                      .setEnvironment(\n                          Protos.Environment\n                              .newBuilder()\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_MASTER_HOSTNAME\").setValue(mMasterHostname)\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_WORKER_MEMORY_SIZE\").setValue(memSize)\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                      .setValue(Configuration.get(Constants.UNDERFS_ADDRESS))\n                                      .build())\n                              .build()));\n          // pre-build resource list here, then use it to build Protos.Task later.\n          resources = getWorkerRequiredResources(workerCpu, workerMem);\n          mWorkers.add(offer.getHostname());\n          mTaskName = Configuration.get(Constants.INTEGRATION_MESOS_ALLUXIO_WORKER_NAME);\n        } else {\n          // The resource offer cannot be used to start either master or a worker.\n          LOG.info(String.format(\"Declining offer %s\", offer.getId().getValue()));\n          driver.declineOffer(offer.getId());\n          continue;\n        }\n\n        Protos.TaskID taskId =\n            Protos.TaskID.newBuilder().setValue(String.valueOf(mLaunchedTasks)).build();\n\n        LOG.info(String.format(\"Launching task %s using offer %s\",\n            taskId.getValue(), offer.getId().getValue()));\n\n        Protos.TaskInfo task =\n            Protos.TaskInfo\n                .newBuilder()\n                .setName(mTaskName)\n                .setTaskId(taskId)\n                .setSlaveId(offer.getSlaveId())\n                .addAllResources(resources)\n                .setExecutor(executorBuilder).build();\n\n        launch.addTaskInfos(Protos.TaskInfo.newBuilder(task));\n        mLaunchedTasks++;\n\n        // NOTE: We use the new API `acceptOffers` here to launch tasks.\n        // The 'launchTasks' API will be deprecated.\n        List<Protos.OfferID> offerIds = new ArrayList<Protos.OfferID>();\n        offerIds.add(offer.getId());\n        List<Protos.Offer.Operation> operations = new ArrayList<Protos.Offer.Operation>();\n        Protos.Offer.Operation operation =\n            Protos.Offer.Operation.newBuilder().setType(Protos.Offer.Operation.Type.LAUNCH)\n                .setLaunch(launch).build();\n        operations.add(operation);\n        Protos.Filters filters = Protos.Filters.newBuilder().setRefuseSeconds(1).build();\n        driver.acceptOffers(offerIds, operations, filters);\n      }\n    }","id":102477,"modified_method":"@Override\n    public void resourceOffers(SchedulerDriver driver, List<Protos.Offer> offers) {\n      long masterCpu = Configuration.getInt(Constants.INTEGRATION_MASTER_RESOURCE_CPU);\n      long masterMem =\n          Configuration.getBytes(Constants.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB;\n      long workerCpu = Configuration.getInt(Constants.INTEGRATION_WORKER_RESOURCE_CPU);\n      long workerMem =\n          Configuration.getBytes(Constants.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB;\n\n      LOG.info(\"Master launched {}, master count {}, \"\n          + \"requested master cpu {} and mem {} MB\",\n          mMasterLaunched, mMasterCount, masterCpu, masterMem);\n\n      for (Protos.Offer offer : offers) {\n        Protos.Offer.Operation.Launch.Builder launch = Protos.Offer.Operation.Launch.newBuilder();\n        double offerCpu = 0;\n        double offerMem = 0;\n        for (Protos.Resource resource : offer.getResourcesList()) {\n          if (resource.getName().equals(Constants.MESOS_RESOURCE_CPUS)) {\n            offerCpu += resource.getScalar().getValue();\n          } else if (resource.getName().equals(Constants.MESOS_RESOURCE_MEM)) {\n            offerMem += resource.getScalar().getValue();\n          } else {\n            // Other resources are currently ignored.\n          }\n        }\n\n        LOG.info(\"Received offer {} with cpus {} and mem {} MB and hasMasterPorts {}\",\n            offer.getId().getValue(), offerCpu, offerMem,\n            OfferUtils.hasAvailableMasterPorts(offer));\n\n        Protos.ExecutorInfo.Builder executorBuilder = Protos.ExecutorInfo.newBuilder();\n        List<Protos.Resource> resources;\n        if (!mMasterLaunched && offerCpu >= masterCpu && offerMem >= masterMem\n            && mMasterCount < Configuration\n            .getInt(Constants.INTEGRATION_MESOS_ALLUXIO_MASTER_NODE_COUNT) && OfferUtils\n            .hasAvailableMasterPorts(offer)) {\n          LOG.debug(\"Creating Alluxio Master executor\");\n          executorBuilder\n              .setName(\"Alluxio Master Executor\")\n              .setSource(\"master\")\n              .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"master\"))\n              .addAllResources(getExecutorResources())\n              .setCommand(\n                  Protos.CommandInfo\n                      .newBuilder()\n                      .setValue(\n                          \"export JAVA_HOME=\"\n                              + Configuration.get(Constants.INTEGRATION_MESOS_JRE_PATH)\n                              + \" && export PATH=$PATH:$JAVA_HOME/bin && \"\n                              + PathUtils.concatPath(\"alluxio\", \"integration\", \"bin\",\n                              \"alluxio-master-mesos.sh\"))\n                      .addAllUris(getExecutorDependencyURIList())\n                      .setEnvironment(\n                          Protos.Environment\n                              .newBuilder()\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                      .setValue(Configuration.get(Constants.UNDERFS_ADDRESS))\n                                      .build())\n                              .build()));\n          // pre-build resource list here, then use it to build Protos.Task later.\n          resources = getMasterRequiredResources(masterCpu, masterMem);\n          mMasterHostname = offer.getHostname();\n          mTaskName = Configuration.get(Constants.INTEGRATION_MESOS_ALLUXIO_MASTER_NAME);\n          mMasterCount++;\n          mMasterTaskId = mLaunchedTasks;\n\n        } else if (mMasterLaunched && !mWorkers.contains(offer.getHostname())\n            && offerCpu >= workerCpu && offerMem >= workerMem\n            && OfferUtils.hasAvailableWorkerPorts(offer)) {\n          LOG.debug(\"Creating Alluxio Worker executor\");\n          final String memSize = FormatUtils.getSizeFromBytes((long) workerMem * Constants.MB);\n          executorBuilder\n              .setName(\"Alluxio Worker Executor\")\n              .setSource(\"worker\")\n              .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"worker\"))\n              .addAllResources(getExecutorResources())\n              .setCommand(\n                  Protos.CommandInfo\n                      .newBuilder()\n                      .setValue(\n                          \"export JAVA_HOME=\"\n                              + Configuration.get(Constants.INTEGRATION_MESOS_JRE_PATH)\n                              + \" && export PATH=$PATH:$JAVA_HOME/bin && \"\n                              + PathUtils.concatPath(\"alluxio\", \"integration\", \"bin\",\n                              \"alluxio-worker-mesos.sh\"))\n                      .addAllUris(getExecutorDependencyURIList())\n                      .setEnvironment(\n                          Protos.Environment\n                              .newBuilder()\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_MASTER_HOSTNAME\").setValue(mMasterHostname)\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_WORKER_MEMORY_SIZE\").setValue(memSize)\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                      .setValue(Configuration.get(Constants.UNDERFS_ADDRESS))\n                                      .build())\n                              .build()));\n          // pre-build resource list here, then use it to build Protos.Task later.\n          resources = getWorkerRequiredResources(workerCpu, workerMem);\n          mWorkers.add(offer.getHostname());\n          mTaskName = Configuration.get(Constants.INTEGRATION_MESOS_ALLUXIO_WORKER_NAME);\n        } else {\n          // The resource offer cannot be used to start either master or a worker.\n          LOG.info(\"Declining offer {}\", offer.getId().getValue());\n          driver.declineOffer(offer.getId());\n          continue;\n        }\n\n        Protos.TaskID taskId =\n            Protos.TaskID.newBuilder().setValue(String.valueOf(mLaunchedTasks)).build();\n\n        LOG.info(\"Launching task {} using offer {}\", taskId.getValue(), offer.getId().getValue());\n\n        Protos.TaskInfo task =\n            Protos.TaskInfo\n                .newBuilder()\n                .setName(mTaskName)\n                .setTaskId(taskId)\n                .setSlaveId(offer.getSlaveId())\n                .addAllResources(resources)\n                .setExecutor(executorBuilder).build();\n\n        launch.addTaskInfos(Protos.TaskInfo.newBuilder(task));\n        mLaunchedTasks++;\n\n        // NOTE: We use the new API `acceptOffers` here to launch tasks.\n        // The 'launchTasks' API will be deprecated.\n        List<Protos.OfferID> offerIds = new ArrayList<Protos.OfferID>();\n        offerIds.add(offer.getId());\n        List<Protos.Offer.Operation> operations = new ArrayList<Protos.Offer.Operation>();\n        Protos.Offer.Operation operation =\n            Protos.Offer.Operation.newBuilder().setType(Protos.Offer.Operation.Type.LAUNCH)\n                .setLaunch(launch).build();\n        operations.add(operation);\n        Protos.Filters filters = Protos.Filters.newBuilder().setRefuseSeconds(1).build();\n        driver.acceptOffers(offerIds, operations, filters);\n      }\n    }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n    public void frameworkMessage(SchedulerDriver driver, Protos.ExecutorID executorId,\n                                 Protos.SlaveID slaveId, byte[] data) {\n      LOG.info(String.format(\"Executor: %s, slave: %s, data: %s\",\n          executorId.getValue(), slaveId.getValue(), Arrays.toString(data)));\n    }","id":102478,"modified_method":"@Override\n    public void frameworkMessage(SchedulerDriver driver, Protos.ExecutorID executorId,\n        Protos.SlaveID slaveId, byte[] data) {\n      LOG.info(\"Executor: {}, slave: {}, data: {}\",\n          executorId.getValue(), slaveId.getValue(), Arrays.toString(data));\n    }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n    public void offerRescinded(SchedulerDriver driver, Protos.OfferID offerId) {\n      LOG.info(String.format(\"Offered %s rescinded\", offerId.getValue()));\n    }","id":102479,"modified_method":"@Override\n    public void offerRescinded(SchedulerDriver driver, Protos.OfferID offerId) {\n      LOG.info(\"Offered {} rescinded\", offerId.getValue());\n    }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n    public void executorLost(SchedulerDriver driver, Protos.ExecutorID executorId,\n        Protos.SlaveID slaveId, int status) {\n      LOG.info(String.format(\"Executor %s was lost\", executorId.getValue()));\n    }","id":102480,"modified_method":"@Override\n    public void executorLost(SchedulerDriver driver, Protos.ExecutorID executorId,\n        Protos.SlaveID slaveId, int status) {\n      LOG.info(\"Executor {} was lost\", executorId.getValue());\n    }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void launchTask(final ExecutorDriver driver, final Protos.TaskInfo task) {\n    new Thread() {\n      public void run() {\n        try {\n          Protos.TaskStatus status =\n              Protos.TaskStatus.newBuilder().setTaskId(task.getTaskId())\n                  .setState(Protos.TaskState.TASK_RUNNING).build();\n\n          driver.sendStatusUpdate(status);\n\n          LOG.info(String.format(\"Launching task %s\", task.getTaskId().getValue()));\n\n          Thread.currentThread().setContextClassLoader(\n              UnderFileSystemRegistry.class.getClassLoader());\n\n          // TODO(jiri): Consider handling Format.main() failures gracefully.\n          Format.main(new String[] {\"master\"});\n          AlluxioMaster.main(new String[] {});\n\n          status =\n              Protos.TaskStatus.newBuilder().setTaskId(task.getTaskId())\n                  .setState(Protos.TaskState.TASK_FINISHED).build();\n\n          driver.sendStatusUpdate(status);\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    }.start();\n  }","id":102481,"modified_method":"@Override\n  public void launchTask(final ExecutorDriver driver, final Protos.TaskInfo task) {\n    new Thread() {\n      public void run() {\n        try {\n          Protos.TaskStatus status =\n              Protos.TaskStatus.newBuilder().setTaskId(task.getTaskId())\n                  .setState(Protos.TaskState.TASK_RUNNING).build();\n\n          driver.sendStatusUpdate(status);\n\n          LOG.info(\"Launching task {}\", task.getTaskId().getValue());\n\n          Thread.currentThread().setContextClassLoader(\n              UnderFileSystemRegistry.class.getClassLoader());\n\n          // TODO(jiri): Consider handling Format.main() failures gracefully.\n          Format.main(new String[] {\"master\"});\n          AlluxioMaster.main(new String[] {});\n\n          status =\n              Protos.TaskStatus.newBuilder().setTaskId(task.getTaskId())\n                  .setState(Protos.TaskState.TASK_FINISHED).build();\n\n          driver.sendStatusUpdate(status);\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    }.start();\n  }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void registered(ExecutorDriver driver, Protos.ExecutorInfo executorInfo,\n                         Protos.FrameworkInfo frameworkInfo, Protos.SlaveInfo slaveInfo) {\n    LOG.info(String.format(\"Registered executor %s with %s through framework %s\",\n        executorInfo.getName(), slaveInfo.getHostname(), frameworkInfo.getName()));\n  }","id":102482,"modified_method":"@Override\n  public void registered(ExecutorDriver driver, Protos.ExecutorInfo executorInfo,\n      Protos.FrameworkInfo frameworkInfo, Protos.SlaveInfo slaveInfo) {\n    LOG.info(\"Registered executor {} with {} through framework {}\",\n        executorInfo.getName(), slaveInfo.getHostname(), frameworkInfo.getName());\n  }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void reregistered(ExecutorDriver driver, Protos.SlaveInfo slaveInfo) {\n    LOG.info(String.format(\"Re-registered executor with %s\", slaveInfo.getHostname()));\n  }","id":102483,"modified_method":"@Override\n  public void reregistered(ExecutorDriver driver, Protos.SlaveInfo slaveInfo) {\n    LOG.info(\"Re-registered executor with {}\", slaveInfo.getHostname());\n  }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void killTask(ExecutorDriver driver, Protos.TaskID taskId) {\n    LOG.info(String.format(\"Killing task %s\", taskId.getValue()));\n    // TODO(jiri): Implement.\n  }","id":102484,"modified_method":"@Override\n  public void killTask(ExecutorDriver driver, Protos.TaskID taskId) {\n    LOG.info(\"Killing task {}\", taskId.getValue());\n    // TODO(jiri): Implement.\n  }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void error(ExecutorDriver driver, String message) {\n    LOG.error(String.format(\"A fatal error has occurred: %s\", message));\n  }","id":102485,"modified_method":"@Override\n  public void error(ExecutorDriver driver, String message) {\n    LOG.error(\"A fatal error has occurred: {}\", message);\n  }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void launchTask(final ExecutorDriver driver, final Protos.TaskInfo task) {\n    new Thread() {\n      public void run() {\n        try {\n          Protos.TaskStatus status =\n              Protos.TaskStatus.newBuilder().setTaskId(task.getTaskId())\n                  .setState(Protos.TaskState.TASK_RUNNING).build();\n\n          driver.sendStatusUpdate(status);\n\n          LOG.info(String.format(\"Launching task %s\", task.getTaskId().getValue()));\n\n          Thread.currentThread().setContextClassLoader(\n              UnderFileSystemRegistry.class.getClassLoader());\n\n          // TODO(jiri): Consider handling Format.main() failures gracefully.\n          Format.main(new String[] {\"master\"});\n          AlluxioWorker.main(new String[] {});\n\n          status =\n              Protos.TaskStatus.newBuilder().setTaskId(task.getTaskId())\n                  .setState(Protos.TaskState.TASK_FINISHED).build();\n          driver.sendStatusUpdate(status);\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    }.start();\n  }","id":102486,"modified_method":"@Override\n  public void launchTask(final ExecutorDriver driver, final Protos.TaskInfo task) {\n    new Thread() {\n      public void run() {\n        try {\n          Protos.TaskStatus status =\n              Protos.TaskStatus.newBuilder().setTaskId(task.getTaskId())\n                  .setState(Protos.TaskState.TASK_RUNNING).build();\n\n          driver.sendStatusUpdate(status);\n\n          LOG.info(\"Launching task {}\", task.getTaskId().getValue());\n\n          Thread.currentThread().setContextClassLoader(\n              UnderFileSystemRegistry.class.getClassLoader());\n\n          // TODO(jiri): Consider handling Format.main() failures gracefully.\n          Format.main(new String[] {\"master\"});\n          AlluxioWorker.main(new String[] {});\n\n          status =\n              Protos.TaskStatus.newBuilder().setTaskId(task.getTaskId())\n                  .setState(Protos.TaskState.TASK_FINISHED).build();\n          driver.sendStatusUpdate(status);\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    }.start();\n  }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void registered(ExecutorDriver driver, Protos.ExecutorInfo executorInfo,\n                         Protos.FrameworkInfo frameworkInfo, Protos.SlaveInfo slaveInfo) {\n    LOG.info(String.format(\"Registered executor %s with %s through framework %s\",\n        executorInfo.getName(), slaveInfo.getHostname(), frameworkInfo.getName()));\n  }","id":102487,"modified_method":"@Override\n  public void registered(ExecutorDriver driver, Protos.ExecutorInfo executorInfo,\n      Protos.FrameworkInfo frameworkInfo, Protos.SlaveInfo slaveInfo) {\n    LOG.info(\"Registered executor {} with {} through framework {}\",\n        executorInfo.getName(), slaveInfo.getHostname(), frameworkInfo.getName());\n  }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void reregistered(ExecutorDriver driver, Protos.SlaveInfo slaveInfo) {\n    LOG.info(String.format(\"Re-registered executor with %s\", slaveInfo.getHostname()));\n  }","id":102488,"modified_method":"@Override\n  public void reregistered(ExecutorDriver driver, Protos.SlaveInfo slaveInfo) {\n    LOG.info(\"Re-registered executor with {}\", slaveInfo.getHostname());\n  }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void error(ExecutorDriver driver, String message) {\n    LOG.error(String.format(\"A fatal error has occurred: %s\", message));\n  }","id":102489,"modified_method":"@Override\n  public void error(ExecutorDriver driver, String message) {\n    LOG.error(\"A fatal error has occurred: {}\", message);\n  }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void killTask(ExecutorDriver driver, Protos.TaskID taskId) {\n    LOG.info(String.format(\"Killing task %s\", taskId.getValue()));\n    // TODO(jiri): Implement.\n  }","id":102490,"modified_method":"@Override\n  public void killTask(ExecutorDriver driver, Protos.TaskID taskId) {\n    LOG.info(\"Killing task {}\", taskId.getValue());\n    // TODO(jiri): Implement.\n  }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"private static boolean hasAvailablePorts(int port, Protos.Value.Ranges ranges) {\n    for (Protos.Value.Range range : ranges.getRangeList()) {\n      LOG.debug(String.format(\"Port range %s\", range));\n      if (port >= range.getBegin() && port <= range.getEnd()) {\n        return true;\n      }\n    }\n    return false;\n  }","id":102491,"modified_method":"private static boolean hasAvailablePorts(int port, Protos.Value.Ranges ranges) {\n    for (Protos.Value.Range range : ranges.getRangeList()) {\n      LOG.debug(\"Port range {}\", range);\n      if (port >= range.getBegin() && port <= range.getEnd()) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"885e3f404343edd2076b0815666a0ea7c1bc73a0","url":"https://github.com/amplab/tachyon"},{"original_method":"public void displaySearchResults()\n    {\n        if(searchLocationType == SEARCH_ALL_OPEN_MAPS)\n        {\n            Iterator<LWMap> allOpenMaps = VUE.getLeftTabbedPane().getAllMaps();\n            \n            LWMap searchResultMap = new LWMap(\"Search Result #\" + searchResultsMaps++);\n            \n            while(allOpenMaps.hasNext())\n            {\n                Iterator<LWComponent> components = allOpenMaps.next().getAllDescendents(LWComponent.ChildKind.EDITABLE).iterator();   \n                while(components.hasNext())\n                {\n                    LWComponent next = components.next();\n                    if(comps.contains(next))\n                    {\n                        \n                       LWComponent duplicate = next.duplicate();\n                       LWComponent parent = next.getParent();\n                       if(parent !=null && !comps.contains(parent))\n                       {\n                         if(parent instanceof LWNode)\n                         {    \n                           duplicate.setLocation(parent.getLocation());\n                         }\n                         \n                         \n                         if(LWNode.isImageNode(parent))\n                         {\n                           if(!comps.contains(parent))\n                           {\n                               LWComponent dup = parent.duplicate();\n                               if(!(dup instanceof LWSlide) && !dup.hasFlag(LWComponent.Flag.SLIDE_STYLE)\n                                 && (!(dup.hasAncestorOfType(LWSlide.class))) )  \n                                 searchResultMap.add(dup);\n                           }\n                         }   \n                         else\n                         {    \n                           if(!(duplicate instanceof LWSlide) && !duplicate.hasFlag(LWComponent.Flag.SLIDE_STYLE)\n                              && (!(duplicate.hasAncestorOfType(LWSlide.class))) )    \n                             searchResultMap.add(duplicate);\n                         }\n                         \n                         /*if(next.hasFlag(LWComponent.Flag.SLIDE_STYLE))\n                         {\n                            LWSlide slide = (LWSlide)next.getParentOfType(LWSlide.class);\n                            //searchResultMap.add(slide);\n                            searchResultMap.add(slide.getSourceNode());\n                         }*/\n                         \n                       } \n\n                    }\n                }\n            }\n            \n            VUE.displayMap(searchResultMap);\n            \n            return;\n        }\n        \n        if(resultsType == COPY_ACTION)\n        {\n            LWMap searchResultMap = new LWMap(\"Search Result \" + searchResultsMaps++);\n            \n            HashMap<LWComponent,LWComponent> duplicates = new HashMap<LWComponent,LWComponent>();\n            \n            Iterator<LWComponent> components = VUE.getActiveMap().getAllDescendents(LWComponent.ChildKind.EDITABLE).iterator();   \n            while(components.hasNext())\n            {\n                LWComponent next = components.next();\n                if(comps.contains(next))\n                {\n                   LWComponent duplicate = next.duplicate();\n                   \n                   duplicates.put(next,duplicate);\n                   \n                   LWComponent parent = next.getParent();\n                   if(parent !=null && !comps.contains(parent))\n                   {\n                       if(parent instanceof LWNode)\n                       {    \n                         duplicate.setLocation(parent.getLocation());\n                       }\n                       \n                       /*if(next instanceof LWLink)\n                       {\n                         LWLink link = (LWLink)next;\n                         LWComponent head = link.getHead();\n                         if(head != null && comps.contains(head))\n                             ((LWLink)duplicate).setHead(head); // OOPS needs to be\n                                                                // head's duplicate\n                         LWComponent tail = link.getTail();\n                         if(tail != null && comps.contains(tail))\n                             ((LWLink)duplicate).setTail(tail); // double OOPS\n                       }*/\n                       \n                      \n                       \n                       // do we need this code any more? see\n                       // \"raw image\" search bug in jira\n                       // if we do, links may have to be handled\n                       // correctly for these nodes as well\n                       if(LWNode.isImageNode(parent))\n                       {\n                         if(!comps.contains(parent))\n                         {\n                               if(!(parent instanceof LWSlide) && !parent.hasFlag(LWComponent.Flag.SLIDE_STYLE)\n                                 && (!parent.hasAncestorOfType(LWSlide.class)))   \n                                 searchResultMap.add(parent.duplicate());\n                         }\n                       }   \n                       else\n                       {    \n                           if(!(duplicate instanceof LWSlide) && !duplicate.hasFlag(LWComponent.Flag.SLIDE_STYLE)\n                               && (!(duplicate.hasAncestorOfType(LWSlide.class))))  \n                             searchResultMap.add(duplicate);\n                       }\n\n                       \n                   }\n                  \n                }\n            }\n            \n            \n            Iterator<LWComponent> components2 = VUE.getActiveMap().getAllDescendents(LWComponent.ChildKind.EDITABLE).iterator(); \n            while(components2.hasNext())\n            {\n                       LWComponent next = components2.next();\n                \n                       if(next instanceof LWLink && duplicates.get(next) != null)\n                       {\n                         LWLink link = (LWLink)next;\n                         LWComponent head = link.getHead();\n                         if(head != null && comps.contains(head))\n                             ((LWLink)duplicates.get(next)).setHead(duplicates.get(head)); \n                         LWComponent tail = link.getTail();\n                         if(tail != null && comps.contains(tail))\n                             ((LWLink)duplicates.get(next)).setTail(duplicates.get(tail)); \n                       }\n            }\n            \n            VUE.displayMap(searchResultMap);\n            \n            return; \n        }\n        \n        if(DEBUG_LOCAL)\n        {\n          System.out.println(\"SearchAction: comps size after perform search - \" + comps.size());\n        }\n        \n        revertGlobalSearchSelection();\n        globalResultsType = resultsType;\n        \n        ArrayList<LWComponent> images = new ArrayList<LWComponent>();\n        Iterator<LWComponent> compsIterator = comps.iterator();\n        while(compsIterator.hasNext())\n        {\n            LWComponent current = compsIterator.next();\n            if(current instanceof LWNode)\n            {\n                LWNode currentNode = (LWNode)current;\n                if(LWNode.isImageNode(currentNode))\n                {\n                    images.add(currentNode.getImage());\n                }\n            }\n            \n            /*if(current.hasFlag(LWComponent.Flag.SLIDE_STYLE))\n            {\n                            LWSlide slide = (LWSlide)current.getParentOfType(LWSlide.class);\n                            images.add(slide);\n                            //LWNode source  = ((LWNode)slide.getSourceNode());\n                            //images.add(source);\n                            if(LWNode.isImageNode(source))\n                            {\n                                images.add(source.getImage());\n                            }\n                            \n            }*/\n            \n            if(current instanceof LWImage)\n            {\n                LWImage currentImage = (LWImage)current;\n                if(currentImage.isNodeIcon() && currentImage.getParent() != null)\n                {\n                  images.add(currentImage.getParent());\n                }\n            }\n            \n        }\n        \n        comps.addAll(images);\n        \n        if((resultsType == SELECT_ACTION || resultsType == CLUSTER_ACTION || resultsType == LINK_ACTION) && DO_NOT_SELECT_SLIDE_COMPONENTS)\n        {\n                 \n           Iterator<LWComponent> it = comps.iterator();        \n                 \n           List<LWComponent> slideComponents = new ArrayList<LWComponent>();\n           \n           while(it.hasNext())\n           {\n              LWComponent next = it.next();\n              if(next.hasFlag(LWComponent.Flag.SLIDE_STYLE))\n              {\n                  slideComponents.add(next);\n              }\n           }\n           \n           Iterator<LWComponent> slides = slideComponents.iterator();\n           while(slides.hasNext())\n           {\n              LWComponent slide = slides.next();\n              if(!(slide instanceof LWSlide))\n                comps.remove(slide);\n           }\n           \n        }\n        \n        if((resultsType == SELECT_ACTION || resultsType == CLUSTER_ACTION || resultsType == LINK_ACTION) && DO_NOT_SELECT_NESTED_IMAGES)\n        {\n           Iterator<LWComponent> it2 = comps.iterator(); \n           \n           List<LWComponent> toNotBeSelected = new ArrayList<LWComponent>();\n           \n           while(it2.hasNext())\n           {\n              LWComponent next = it2.next();\n              \n              Iterator<LWComponent> nestedComponents = next.getAllDescendents().iterator();\n              while(nestedComponents.hasNext())\n              {\n                  LWComponent nextNested = nestedComponents.next();\n                  if(comps.contains(nextNested))\n                  {\n                      toNotBeSelected.add(nextNested);\n                  }\n              }\n              \n \n              if(next instanceof LWNode && LWNode.isImageNode(next))\n              {\n                  toNotBeSelected.add(((LWNode)next).getImage());\n              }\n\n           }\n           \n           Iterator<LWComponent> dontSelect = toNotBeSelected.iterator();\n           while(dontSelect.hasNext())\n           {\n              LWComponent removeThis = dontSelect.next();\n              if(comps.contains(removeThis))\n              {\n                  comps.remove(removeThis);\n              }\n           }\n           \n        }\n        \n        // also hide or show elements inside of groups when group is also\n        // in the search results set\n        if(resultsType == HIDE_ACTION || resultsType == SHOW_ACTION )\n        {\n            List<LWComponent> groupDescendants = new ArrayList<LWComponent>();\n            \n            Iterator<LWComponent> groupSearch = comps.iterator();\n            \n            while(groupSearch.hasNext())\n            {\n                LWComponent next = groupSearch.next();\n                if(next instanceof LWGroup)\n                {\n                    // todo: don't add duplicates!'\n                    groupDescendants.addAll(next.getAllDescendents(LWComponent.ChildKind.EDITABLE));\n                }\n            }\n            \n            comps.addAll(groupDescendants);\n        }\n        \n        if(resultsType == HIDE_ACTION || resultsType == SELECT_ACTION || resultsType == CLUSTER_ACTION || resultsType == LINK_ACTION)\n        {    \n            \n          Iterator<LWComponent> it3 = comps.iterator();  \n            \n          while(it3.hasNext())\n          {\n             if(resultsType == SELECT_ACTION || resultsType == CLUSTER_ACTION || resultsType == LINK_ACTION)\n             {\n               if(MARQUEE == false)\n               {\n                 it3.next().setSelected(true);\n               }\n               else\n               {\n                 LWComponent comp = it3.next();\n                 LWMap.Layer compLayer = comp.getLayer();\n                 \n                 if(!(compLayer != null && compLayer.isHidden()) && !(comp instanceof LWSlide) && !comp.hasFlag(LWComponent.Flag.SLIDE_STYLE)\n                   && (!(comp.hasAncestorOfType(LWSlide.class))))  \n                   VUE.getSelection().add(comp);\n               }\n             }\n             if(resultsType == HIDE_ACTION)\n             {\n               // VUE-892 -- switch back to setFiltered (needs change in LWImage to work for image nodes, but this\n               // will handle child nodes/images correctly in non image nodes)\n               //it.next().setHidden(LWComponent.HideCause.DEFAULT);\n                 \n                 \n               LWComponent comp = it3.next();\n                 \n               if(!(comp instanceof LWSlide) && !comp.hasFlag(LWComponent.Flag.SLIDE_STYLE)\n                 && (!(comp.hasAncestorOfType(LWSlide.class))) && !(comp instanceof LWGroup) )  \n                   comp.setFiltered(true);\n             }\n          }\n        }\n        \n        globalResults = comps;\n        \n        if(resultsType == SHOW_ACTION)\n        {    \n          \n          Iterator<LWComponent> it4 = comps.iterator();  \n            \n          if(AUTO_SHOW_NESTED_IMAGES)\n          {    \n            // checking all children of nodes in search results to see if they\n            // are images or image nodes\n            // to be done: for select, possibly actually remove selection for any \n            // children of search results\n            // also to be done: image or image node results should also show\n            // parents (but not non image results)\n            List<LWComponent> toBeAdded = new ArrayList<LWComponent>();  \n            \n            while(it4.hasNext())\n            {\n              LWComponent current = it4.next();\n              Iterator<LWComponent> children = current.getAllDescendents().iterator();\n              while(children.hasNext())\n              {\n                  LWComponent next = children.next();\n                  if (( (next instanceof LWImage) || LWNode.isImageNode(next))\n                       && !comps.contains(next) )\n                  {\n                    toBeAdded.add(next);         \n                  }\n              }\n            }\n          \n            Iterator<LWComponent> addThese = toBeAdded.iterator();\n            while(addThese.hasNext())\n            {\n              comps.add(addThese.next());\n            }\n          }\n            \n            \n          //globalHides = // opposite of comps\n\n          // todo: really, we want to do this on VISIBLE, not EDITABLE (e.g., even\n          // filter locked objects), but we would need to change all other duplicate code\n          // references, and then regression test.\n          //Collection<LWComponent> allComps = tufts.vue.VUE.getActiveMap().getAllDescendents(LWComponent.ChildKind.VISIBLE);\n          \n          Collection<LWComponent> allComps = tufts.vue.VUE.getActiveMap().getAllDescendents(LWComponent.ChildKind.EDITABLE);\n          globalHides = new ArrayList();\n          Iterator<LWComponent> allIt = allComps.iterator();\n          while(allIt.hasNext())\n          {\n              LWComponent comp = allIt.next();\n              if(!comps.contains(comp))\n              {\n                  if(DEBUG_LOCAL)\n                  {\n                      System.out.println(\"SearchAction adding \" + comp.getLabel() + \" to globalHides and hiding\");\n                  }\n                  \n                  // VUE-892 -- switch back to setFiltered (needs change in LWImage to work for image nodes, but this\n                  // will handle child nodes/images correctly in non image nodes)\n                  //comp.setHidden(LWComponent.HideCause.DEFAULT);\n                  if(!(comp instanceof LWSlide) && !comp.hasFlag(LWComponent.Flag.SLIDE_STYLE)\n                    && (!(comp.hasAncestorOfType(LWSlide.class))) && !(comp instanceof LWGroup) )  \n                  {\n                      comp.setFiltered(true); // SHOW/HIDE\n                    globalHides.add(comp);\n                  }\n              }\n\n          }\n        }\n        else if(resultsType == HIDE_ACTION)\n        {\n          globalHides = comps; \n        }    \n        \n        if (resultsType == CLUSTER_ACTION) {\n        \tCluster2Layout layout = new Cluster2Layout();\n\n        \tlayout.layout(VUE.getSelection());\n            VUE.getUndoManager().mark(VueResources.getString(\"searchgui.cluster\"));\n        }\n\n        if (resultsType == LINK_ACTION) {\n            // Create a new node, name it based on the search, and link the selected nodes to it.\n            GUI.invokeAfterAWT(new Runnable() { public void run() {\n                LWSelection                      selection = VUE.getSelection();\n\n                if (selection.size() > 0) {\n                    Iterator<VueMetadataElement> criterias = searchTerms.iterator();\n                    String                       operator = (crossTermOperator == OR ? \" or \" : \" and \");\n                    StringBuffer                 newNodeName = new StringBuffer();\n                    LWNode                       newNode = new LWNode(\"New Node\");\n                    boolean                      firstTerm = true;\n\n                    while (criterias.hasNext()) {\n                        VueMetadataElement       criteria = criterias.next();\n                        String                   key = criteria.getKey(),\n                                                 value = criteria.getValue();\n\n                        if (!firstTerm) {\n                            newNodeName.append(operator);\n                        } else {\n                            firstTerm = false;\n                        }\n\n                        newNodeName.append(value);\n\n                        if (!key.equals(\"http://vue.tufts.edu/vue.rdfs#none\")) {\n                        \tnewNode.addDataValue(key, value);\n                        }\n                    }\n\n                    Iterator<LWComponent>        selectionIter = selection.iterator();\n                    List<LWComponent>            newComps = new ArrayList<LWComponent>(),\n                                                 selectedNodes = new ArrayList<LWComponent>();\n\n                    newNode.setLabel(newNodeName.toString());\n                    newComps.add(newNode);\n\n                    while (selectionIter.hasNext()) {\n                        LWComponent              selectedComp = selectionIter.next();\n\n                        if (selectedComp instanceof LWNode) {\n                            LWLink               newLink = new LWLink(selectedComp, newNode);\n\n                            selectedNodes.add(selectedComp);\n                            newComps.add(newLink);\n                        }\n                    }\n\n                    if (selectedNodes.size() > 0) {\n                        LWMap                    activeMap = VUE.getActiveMap();\n                        Rectangle2D              selectionBounds = selection.getBounds();\n                        UndoManager              undoMgr = VUE.getUndoManager();\n\n                        newNode.setCenterAt(selectionBounds.getCenterX(), selectionBounds.getCenterY());\n                        activeMap.addChildren(newComps);\n                        undoMgr.mark(VueResources.getString(\"searchgui.link\"));\n//                      tufts.vue.Actions.MakeCluster.doClusterAction(newNode, selectedNodes);\n//                      undoMgr.mark(VueResources.getString(\"menu.format.layout.makecluster\"));\n//                      VUE.getActiveViewer().scrollRectToVisible(VUE.getSelection().getBounds().getBounds());  // must get bounds again after cluster action\n                        VUE.getActiveViewer().scrollRectToVisible(selectionBounds.getBounds());\n                        selection.add(newComps);\n//                      tufts.vue.Actions.PushOut.act();\n//                      undoMgr.mark(VueResources.local(\"menu.format.arrange.pushout\"));\n                    }\n                }\n            }});\n        }\n\n        // also need to save last results type...\n        globalResultsType = resultsType;\n        \n        //VueToolbarController.getController().selectionChanged(VUE.getSelection());\n        //VUE.getActiveViewer().requestFocus();\n        VUE.getActiveViewer().grabVueApplicationFocus(\"search\",null);\n        VUE.getActiveViewer().repaint();\n\n    }","id":102492,"modified_method":"public void displaySearchResults()\n    {\n        if (DEBUG_LOCAL || DEBUG.SEARCH) Log.debug(\"displaySearchResults: result set at start: \" + Util.tags(comps));\n        \n        if (searchLocationType == SEARCH_ALL_OPEN_MAPS) {\n            displayAllMapsSearchResults();\n            return;\n        }\n\n        if (resultsType == COPY_ACTION) {\n            produceSearchResultCopyMap();\n            return;\n        }\n        \n        revertGlobalSearchSelection();\n        globalResultsType = resultsType;\n        \n        final Collection<LWComponent> images = new HashSet<LWComponent>();\n\n        for (LWComponent c : comps) {\n            if (c instanceof LWNode && LWNode.isImageNode(c))\n                images.add(((LWNode)c).getImage());\n            \n            if (c instanceof LWImage) {\n                LWImage image = (LWImage) c;\n                if (image.isNodeIcon() && image.getParent() != null)\n                    images.add(image.getParent());\n            }\n            \n            /*if(current.hasFlag(LWComponent.Flag.SLIDE_STYLE)) {\n                    LWSlide slide = (LWSlide)current.getParentOfType(LWSlide.class);\n                    images.add(slide);\n                    //LWNode source  = ((LWNode)slide.getSourceNode());\n                    //images.add(source);\n                    if(LWNode.isImageNode(source))\n                         images.add(source.getImage());\n            }*/\n        }\n        \n        comps.addAll(images);\n        \n        if (DEBUG_LOCAL || DEBUG.SEARCH) Log.debug(\"displaySearchResults: results with images: \" + Util.tags(comps));\n        \n        if((resultsType == SELECT_ACTION || resultsType == CLUSTER_ACTION || resultsType == LINK_ACTION) && DO_NOT_SELECT_SLIDE_COMPONENTS)\n        {\n                 \n           Iterator<LWComponent> it = comps.iterator();        \n                 \n           List<LWComponent> slideComponents = new ArrayList<LWComponent>();\n           \n           while(it.hasNext())\n           {\n              LWComponent next = it.next();\n              if(next.hasFlag(LWComponent.Flag.SLIDE_STYLE))\n              {\n                  slideComponents.add(next);\n              }\n           }\n           \n           Iterator<LWComponent> slides = slideComponents.iterator();\n           while(slides.hasNext())\n           {\n              LWComponent slide = slides.next();\n              if(!(slide instanceof LWSlide))\n                comps.remove(slide);\n           }\n           \n        }\n        \n        if((resultsType == SELECT_ACTION || resultsType == CLUSTER_ACTION || resultsType == LINK_ACTION) && DO_NOT_SELECT_NESTED_IMAGES)\n        {\n           Iterator<LWComponent> it2 = comps.iterator(); \n           \n           List<LWComponent> toNotBeSelected = new ArrayList<LWComponent>();\n           \n           while(it2.hasNext())\n           {\n              LWComponent next = it2.next();\n              \n              Iterator<LWComponent> nestedComponents = next.getAllDescendents().iterator();\n              while(nestedComponents.hasNext())\n              {\n                  LWComponent nextNested = nestedComponents.next();\n                  if(comps.contains(nextNested))\n                  {\n                      toNotBeSelected.add(nextNested);\n                  }\n              }\n              \n \n              if(next instanceof LWNode && LWNode.isImageNode(next))\n              {\n                  toNotBeSelected.add(((LWNode)next).getImage());\n              }\n\n           }\n           \n           Iterator<LWComponent> dontSelect = toNotBeSelected.iterator();\n           while(dontSelect.hasNext())\n           {\n              LWComponent removeThis = dontSelect.next();\n              if(comps.contains(removeThis))\n              {\n                  comps.remove(removeThis);\n              }\n           }\n           \n        }\n        \n        // also hide or show elements inside of groups when group is also\n        // in the search results set\n        if(resultsType == HIDE_ACTION || resultsType == SHOW_ACTION ) {\n            List<LWComponent> groupDescendants = new ArrayList<LWComponent>();\n            Iterator<LWComponent> groupSearch = comps.iterator();\n            \n            while(groupSearch.hasNext()) {\n                LWComponent next = groupSearch.next();\n                if(next instanceof LWGroup) {\n                    // todo: don't add duplicates!'\n                    groupDescendants.addAll(next.getAllDescendents(LWComponent.ChildKind.EDITABLE));\n                }\n            }\n            comps.addAll(groupDescendants);\n        }\n        \n        globalResults = comps;\n\n        if (resultsType == SELECT_ACTION || resultsType == CLUSTER_ACTION || resultsType == LINK_ACTION) {\n            final List<LWComponent> toAdd = new ArrayList<LWComponent>(comps.size());\n            for (LWComponent c : comps) {\n                LWMap.Layer layer = c.getLayer();\n                if(!(layer != null && layer.isHidden()) &&\n                   !(c instanceof LWSlide) &&\n                   !c.hasFlag(LWComponent.Flag.SLIDE_STYLE) &&\n                   (!(c.hasAncestorOfType(LWSlide.class))))  \n                    toAdd.add(c);\n            }\n            VUE.getSelection().add(toAdd);\n        } else if (resultsType == HIDE_ACTION) {\n            for (LWComponent c : comps) {\n                // VUE-892 -- switch back to setFiltered (needs change in LWImage to work for image nodes, but this\n                // will handle child nodes/images correctly in non image nodes)\n                //it.next().setHidden(LWComponent.HideCause.DEFAULT);\n                if(!(c instanceof LWSlide) &&\n                   !c.hasFlag(LWComponent.Flag.SLIDE_STYLE) &&\n                   !c.hasAncestorOfType(LWSlide.class) &&\n                   !(c instanceof LWGroup) )  \n                    c.setFiltered(true);\n            }\n        } else if(resultsType == SHOW_ACTION) {    \n          \n            Iterator<LWComponent> it4 = comps.iterator();  \n            \n            if(AUTO_SHOW_NESTED_IMAGES) {    \n                // checking all children of nodes in search results to see if they\n                // are images or image nodes\n                // to be done: for select, possibly actually remove selection for any \n                // children of search results\n                // also to be done: image or image node results should also show\n                // parents (but not non image results)\n                List<LWComponent> toBeAdded = new ArrayList<LWComponent>();  \n            \n                while(it4.hasNext()) {\n                    LWComponent current = it4.next();\n                    Iterator<LWComponent> children = current.getAllDescendents().iterator();\n                    while(children.hasNext())\n                        {\n                            LWComponent next = children.next();\n                            if (( (next instanceof LWImage) || LWNode.isImageNode(next))\n                                && !comps.contains(next) )\n                                {\n                                    toBeAdded.add(next);         \n                                }\n                        }\n                }\n          \n                Iterator<LWComponent> addThese = toBeAdded.iterator();\n                while(addThese.hasNext())\n                    comps.add(addThese.next());\n            }\n            \n            \n            //globalHides = // opposite of comps\n\n            // todo: really, we want to do this on VISIBLE, not EDITABLE (e.g., even\n            // filter locked objects), but we would need to change all other duplicate code\n            // references, and then regression test.\n            //Collection<LWComponent> allComps = tufts.vue.VUE.getActiveMap().getAllDescendents(LWComponent.ChildKind.VISIBLE);\n          \n            Collection<LWComponent> allComps = tufts.vue.VUE.getActiveMap().getAllDescendents(LWComponent.ChildKind.EDITABLE);\n            globalHides = new ArrayList();\n            Iterator<LWComponent> allIt = allComps.iterator();\n            while(allIt.hasNext())\n                {\n                    LWComponent comp = allIt.next();\n                    if(!comps.contains(comp))\n                        {\n                            if(DEBUG_LOCAL)\n                                {\n                                    System.out.println(\"SearchAction adding \" + comp.getLabel() + \" to globalHides and hiding\");\n                                }\n                  \n                            // VUE-892 -- switch back to setFiltered (needs change in LWImage to work for image nodes, but this\n                            // will handle child nodes/images correctly in non image nodes)\n                            //comp.setHidden(LWComponent.HideCause.DEFAULT);\n                            if(!(comp instanceof LWSlide) && !comp.hasFlag(LWComponent.Flag.SLIDE_STYLE)\n                               && (!(comp.hasAncestorOfType(LWSlide.class))) && !(comp instanceof LWGroup) )  \n                                {\n                                    comp.setFiltered(true); // SHOW/HIDE\n                                    globalHides.add(comp);\n                                }\n                        }\n\n                }\n        } else if (resultsType == HIDE_ACTION) {\n\n            globalHides = comps;\n            \n        } else if (resultsType == CLUSTER_ACTION) {\n            \n            Cluster2Layout layout = new Cluster2Layout();\n            layout.layout(VUE.getSelection());\n            VUE.getUndoManager().mark(VueResources.getString(\"searchgui.cluster\"));\n            \n        } else if (resultsType == LINK_ACTION) {\n            \n            // Create a new node, name it based on the search, and link the selected nodes to it.\n            GUI.invokeAfterAWT(new Runnable() { public void run() {\n                LWSelection                      selection = VUE.getSelection();\n\n                if (selection.size() > 0) {\n                    Iterator<VueMetadataElement> criterias = searchTerms.iterator();\n                    String                       operator = (crossTermOperator == OR ? \" or \" : \" and \");\n                    StringBuffer                 newNodeName = new StringBuffer();\n                    LWNode                       newNode = new LWNode(\"New Node\");\n                    boolean                      firstTerm = true;\n\n                    while (criterias.hasNext()) {\n                        VueMetadataElement       criteria = criterias.next();\n                        String                   key = criteria.getKey(),\n                                                 value = criteria.getValue();\n\n                        if (!firstTerm) {\n                            newNodeName.append(operator);\n                        } else {\n                            firstTerm = false;\n                        }\n\n                        newNodeName.append(value);\n\n                        if (!key.equals(\"http://vue.tufts.edu/vue.rdfs#none\")) {\n                        \tnewNode.addDataValue(key, value);\n                        }\n                    }\n\n                    Iterator<LWComponent>        selectionIter = selection.iterator();\n                    List<LWComponent>            newComps = new ArrayList<LWComponent>(),\n                                                 selectedNodes = new ArrayList<LWComponent>();\n\n                    newNode.setLabel(newNodeName.toString());\n                    newComps.add(newNode);\n\n                    while (selectionIter.hasNext()) {\n                        LWComponent              selectedComp = selectionIter.next();\n\n                        if (selectedComp instanceof LWNode) {\n                            LWLink               newLink = new LWLink(selectedComp, newNode);\n\n                            selectedNodes.add(selectedComp);\n                            newComps.add(newLink);\n                        }\n                    }\n\n                    if (selectedNodes.size() > 0) {\n                        LWMap                    activeMap = VUE.getActiveMap();\n                        Rectangle2D              selectionBounds = selection.getBounds();\n                        UndoManager              undoMgr = VUE.getUndoManager();\n\n                        newNode.setCenterAt(selectionBounds.getCenterX(), selectionBounds.getCenterY());\n                        activeMap.addChildren(newComps);\n                        undoMgr.mark(VueResources.getString(\"searchgui.link\"));\n//                      tufts.vue.Actions.MakeCluster.doClusterAction(newNode, selectedNodes);\n//                      undoMgr.mark(VueResources.getString(\"menu.format.layout.makecluster\"));\n//                      VUE.getActiveViewer().scrollRectToVisible(VUE.getSelection().getBounds().getBounds());  // must get bounds again after cluster action\n                        VUE.getActiveViewer().scrollRectToVisible(selectionBounds.getBounds());\n                        selection.add(newComps);\n//                      tufts.vue.Actions.PushOut.act();\n//                      undoMgr.mark(VueResources.local(\"menu.format.arrange.pushout\"));\n                    }\n                }\n            }});\n        }\n\n        // also need to save last results type...\n        globalResultsType = resultsType;\n        \n        //VueToolbarController.getController().selectionChanged(VUE.getSelection());\n        //VUE.getActiveViewer().requestFocus();\n        VUE.getActiveViewer().grabVueApplicationFocus(\"search\",null);\n        VUE.getActiveViewer().repaint();\n\n    }","commit_id":"ffb17799da17dc382dd7e93d5946610040acfec1","url":"https://github.com/VUE/VUE"},{"original_method":"public void setLocationType(int type)\n    {\n        searchLocationType = type;\n    }","id":102493,"modified_method":"public void setLocationType(String type)\n    {\n        searchLocationType = type;\n    }","commit_id":"ffb17799da17dc382dd7e93d5946610040acfec1","url":"https://github.com/VUE/VUE"},{"original_method":"public void runIndex()\n    {\n        Thread t = new Thread() {\n            public void run() {\n             index = new  edu.tufts.vue.rdf.RDFIndex();\n                //index.index(VUE.getActiveMap());\n                \n             if(searchLocationType == SEARCH_ALL_OPEN_MAPS)\n             { \n            \n                    if(DEBUG_LOCAL)\n                    { \n                      System.out.println(\"SearchAction: Searching all open maps...\");\n                    }\n          \n                    Iterator<LWMap> maps = VUE.getLeftTabbedPane().getAllMaps();\n                    while(maps.hasNext())\n                    {   \n                         index.index(maps.next(),metadataOnly,everything,false);\n                    }\n             }    \n             else // default is SEARCH_SELECTED_MAP\n             {\n            \t if(VUE.getActiveMap()!=null){\n                    index.index(VUE.getActiveMap(),metadataOnly,everything,true);\n            \t }\n             }\n                \n            }\n        };\n        t.start(); \n    }","id":102494,"modified_method":"private void runIndex()\n    {\n        if (true) {\n            // This appears undeeded for at least standard searches... are there any searches that require this?\n            // There may be synchronization issues, and most importantly, this.index is RESET TO A NEW\n            // EMPTY INDEX when search results are displayed.\n            return;\n        }\n\n        // Also, there is no control over this thread:\n\n        /*-------------------------------------------------------\n         * Disbaled SMF 2012-06-12 16:20.56 Tuesday SFAir.local\n        \n        new Thread() {\n                public void run() {\n                    if (DEBUG.SEARCH) Log.debug(\"Running index of SearchAction creation...\");\n                    \n                    SearchAction.this.index = new edu.tufts.vue.rdf.RDFIndex();\n                    \n                    // //index.index(VUE.getActiveMap());\n                    \n                    if (searchLocationType == SEARCH_ALL_OPEN_MAPS) { \n                        if (DEBUG_LOCAL || DEBUG.SEARCH) Log.debug(\"Searching all open maps...\");\n                        Iterator<LWMap> maps = VUE.getAllMaps().iterator();\n                        while (maps.hasNext())\n                            index.index(maps.next(),metadataOnly,everything,false);\n                    }    \n                    else { // default is SEARCH_SELECTED_MAP\n                        if(VUE.getActiveMap()!=null){\n                            index.index(VUE.getActiveMap(),metadataOnly,everything,true);\n                        }\n                    }\n                    if (DEBUG.SEARCH) Log.debug(\"SearchAction index completed.\");\n                }\n            }\n        .start();\n\n        -------------------------------------------------------*/\n    }","commit_id":"ffb17799da17dc382dd7e93d5946610040acfec1","url":"https://github.com/VUE/VUE"},{"original_method":"public void performSearch(final int searchLocationType) \n    {\n       //Thread t = new Thread()\n       //{\n       //    public void run()\n       //    {\n             runSearchThread(searchLocationType);               \n       //    }\n       //};\n       //t.start();\n    }","id":102495,"modified_method":"public void performSearch(final String searchLocationType)\n    {\n        runSearchThread(searchLocationType);               \n        \n        // Thread t = new Thread() {\n        //         public void run() { runSearchThread(searchLocationType); }\n        //     };\n        // t.start();\n    }","commit_id":"ffb17799da17dc382dd7e93d5946610040acfec1","url":"https://github.com/VUE/VUE"},{"original_method":"public void runSearchThread(int searchLocationType)\n    {      \t\n        if(searchType == QUERY && crossTermOperator == AND)\n        {        \t\n            createQuery();\n        }\n        else // todo: AND in first query\n        if(searchType == QUERY && crossTermOperator == OR)\n        {      \n            createQueries();\n        }\n       // else // todo: for gathering text into its own list\n             // hmm seems to suggest a superclass for Query?\n        /*if(searchType == QUERY && crossTermOperation == OR)\n        {\n            getSearchStrings();\n        }*/\n        \n        // edu.tufts.vue.rdf.RDFIndex.getDefaultIndex().index(VUE.getActiveMap());\n        \n        \n        long t0 = System.currentTimeMillis();\n        \n        synchronized(index) { \n        if(DEBUG.RDF)System.out.println(\"Time at the beginning: \"+(System.currentTimeMillis()-t0));\n        index.remove(index);\n        \n        if(searchLocationType == SEARCH_ALL_OPEN_MAPS)\n        { \n            \n          if(DEBUG_LOCAL)\n          {\n              System.out.println(\"SearchAction: Searching all open maps...\");\n          }\n          \n          Iterator<LWMap> maps = VUE.getLeftTabbedPane().getAllMaps();\n          while(maps.hasNext())\n          {\n              index.index(maps.next(),metadataOnly,everything,false);\n          }\n        }    \n        else // default is SEARCH_SELECTED_MAP\n        {    \n          index.index(VUE.getActiveMap(),metadataOnly,everything,true);\n        }\n        \n        \n        if(DEBUG_LOCAL)\n        {    \n          System.out.println(\"SearchAction: index - \" + index);\n        }\n        if(DEBUG.RDF)System.out.println(\"Performed Index:\"+(System.currentTimeMillis()-t0));\n        } // end synchronized block\n        finds = new ArrayList<List<URI>>();\n        \n        List<URI> found = null;\n        \n        if(searchType == FIELD)\n        {\n          for(int i=0;i<tags.size();i++) {\n              //found = edu.tufts.vue.rdf.RDFIndex.getDefaultIndex().search(tags.get(i));\n              if(DEBUG.RDF)System.out.println(\"Beginning search \"+i+\" at: \"+(System.currentTimeMillis()-t0));\n              found = index.searchAllResources(tags.get(i));\n              if(DEBUG.RDF)System.out.println(\"Ending search \"+i+\" at: \"+(System.currentTimeMillis()-t0));\n              finds.add(found);\n          }\n        }\n        else if(searchType == QUERY)\n        {\n            //System.out.println(\"query result \" + index.search(query) + \" for query \" + query.createSPARQLQuery());\n            \n            if(actualCriteriaAdded && crossTermOperator == AND)\n            {    \n              finds.add(index.search(query));\n            }\n            else if(actualCriteriaAdded && crossTermOperator == OR)\n            {\n              Iterator<Query> queries = queryList.iterator();\n              while(queries.hasNext())\n              {\n                  finds.add(index.search(queries.next()));\n              }\n            }\n            \n            boolean firstFinds = true;\n            if(textToFind.size() != 0)\n            {\n               Iterator<String> textIterator = textToFind.iterator(); \n               while(textIterator.hasNext())\n               {\n                   String text = textIterator.next();\n                   \n                   if(DEBUG_LOCAL)\n                   {    \n                     System.out.println(\"\\n\\n**********\\n Searching all resources for: \" + text );\n                   }\n                   \n                   found = index.searchAllResources(text);\n                   \n                   \n                   if(crossTermOperator == OR || firstFinds == true)\n                   {\n                      finds.add(found);   \n                      firstFinds = false;\n                   }\n                   else\n                   {\n                      // note: this iterator should usually have only one element in this case\n                      Iterator<List<URI>> findsIterator = finds.iterator();\n                      while(findsIterator.hasNext())\n                      {\n                          List<URI> current = findsIterator.next();\n                          Iterator<URI> alreadyFound = current.iterator();\n                          List<URI> toBeRemoved = new ArrayList<URI>();\n                          while(alreadyFound.hasNext())\n                          {\n                            URI currentURI = alreadyFound.next();\n                            \n                            if(DEBUG_LOCAL)\n                            {\n                               System.out.println(\"SearchAction - already found \" + currentURI + \",\" + text);\n                            }\n                            \n                            if(!found.contains(currentURI))\n                            {\n                                if(DEBUG_LOCAL)\n                                {\n                                    System.out.println(\"SearchAction - scheduling uri to be removed: (text follows) \" + currentURI + \",\" + text);\n                                }\n                                \n                                toBeRemoved.add(currentURI);\n                            }\n                          }\n                          \n                          Iterator<URI> removeThese = toBeRemoved.iterator();\n                          while(removeThese.hasNext())\n                          {\n                            current.remove(removeThese.next());\n                          }\n                      }\n                   }\n                   \n                   firstFinds = false;\n               }\n               \n               /*\n               while(textIterator.hasNext())\n               {\n                 //loadKeywords(textIterator.next());\n                 //for(int i=0;i<tags.size();i++)\n                 //{    \n                   //System.out.println(\"tags.get(i)\" + tags.get(i));\n                   //found = index.searchAllResources(tags.get(i));\n                   found = index.searchAllResources(textIterator.next());\n                   //System.out.println(\"found \" + found);\n                   //finds.add(found);\n                 //}\n               }*/\n            }\n           \n        } \n\n        Iterator<List<URI>> findsIterator = finds.iterator();\n        \n        comps = new ArrayList<LWComponent>();\n        \n        Iterator<LWMap> mapsIterator = VUE.getLeftTabbedPane().getAllMaps();\n        \n        ArrayList<LWMap> maps = new ArrayList<LWMap>();\n        while(mapsIterator.hasNext())\n        {\n            maps.add(mapsIterator.next());\n        }\n        \n        while(findsIterator.hasNext()) {\n            found = findsIterator.next();\n            if(found !=null) {\n                Iterator<URI> foundIterator = found.iterator();\n                while(foundIterator.hasNext()) {\n                    URI uri = foundIterator.next();\n                    if(DEBUG_LOCAL)\n                    {    \n                      System.out.println(\"SearchAction: uri found - \" + uri);\n                    }\n                    LWComponent r = (LWComponent)edu.tufts.vue.rdf.VueIndexedObjectsMap.getObjectForID(uri);\n                    //if(r!=null && (r.getMap() != null) && r.getMap().equals(VUE.getActiveMap())) {\n                    if(r!=null && (r.getMap() != null) && maps.contains(r.getMap())) {\n                        comps.add(r);\n                    }\n                    //else if(r != null && (r.getMap() !=null) && maps.contains(r.getMap()))\n                }\n            }\n        }\n        \n        // System.out.println(\"VUE Object Index: \" + edu.tufts.vue.rdf.VueIndexedObjectsMap.objs);\n        \n        //SwingUtilities.invokeLater(new Thread(){\n        //   public void run()\n        //   {\n               displaySearchResults();\n        //   }\n        //});\n    }","id":102496,"modified_method":"public void runSearchThread(String searchLocationType)\n    {\n        if (DEBUG.SEARCH) Log.debug(\"runSearchThread: locationType=\" + searchLocationType);\n        \n        if(searchType == QUERY && crossTermOperator == AND)\n        {        \t\n            createQuery();\n        }\n        else // todo: AND in first query\n        if(searchType == QUERY && crossTermOperator == OR)\n        {      \n            createQueries();\n        }\n\n        /*-------------------------------------------------------*\n         * SMF: WAS ALREADY COMMENTED OUT:\n         *-------------------------------------------------------*\n           \n        // else // todo: for gathering text into its own list\n             // hmm seems to suggest a superclass for Query?\n        // if(searchType == QUERY && crossTermOperation == OR)\n        // {\n        //     getSearchStrings();\n        // }\n        // edu.tufts.vue.rdf.RDFIndex.getDefaultIndex().index(VUE.getActiveMap());\n        *-------------------------------------------------------*/\n        \n        final long t0 = System.currentTimeMillis();\n        \n        /*-------------------------------------------------------\n         * SMF DISABLED 2012-06-12 16:24.25 Tuesday SFAir.local\n         */\n        if (DEBUG.SEARCH || DEBUG.RDF) Log.debug(\"Indexing with RDFIndex...\");\n        //synchronized(this.index) { // thread currently unused\n        if (true) {\n            this.index.remove(index);\n            if (searchLocationType == SEARCH_ALL_OPEN_MAPS) { \n                    if(DEBUG_LOCAL) System.out.println(\"SearchAction: Searching all open maps...\");\n                    for (LWMap map : VUE.getAllMaps())\n                        index.index(map, metadataOnly, everything, false);\n            } else {// default is SEARCH_SELECTED_MAP\n                index.index(VUE.getActiveMap(), metadataOnly, everything, true);\n            }\n            if (DEBUG.SEARCH) Log.debug(\"Done indexing.\");\n            if(DEBUG_LOCAL) System.out.println(\"SearchAction: index - \" + index);\n            if(DEBUG.RDF)System.out.println(\"Performed Index:\"+(System.currentTimeMillis()-t0));\n        } // end synchronized block\n\n        /*-------------------------------------------------------*/\n        \n        final List<List<URI>> finds = new ArrayList<List<URI>>();\n        //this.finds = new ArrayList<List<URI>>();\n        \n        List<URI> found = null;\n        \n        if(searchType == FIELD)\n        {\n          for(int i=0;i<tags.size();i++) {\n              //found = edu.tufts.vue.rdf.RDFIndex.getDefaultIndex().search(tags.get(i));\n              if(DEBUG.RDF)System.out.println(\"Beginning search \"+i+\" at: \"+(System.currentTimeMillis()-t0));\n              found = index.searchAllResources(tags.get(i));\n              if(DEBUG.RDF)System.out.println(\"Ending search \"+i+\" at: \"+(System.currentTimeMillis()-t0));\n              finds.add(found);\n          }\n        }\n        else if(searchType == QUERY)\n        {\n            //System.out.println(\"query result \" + index.search(query) + \" for query \" + query.createSPARQLQuery());\n            \n            if(actualCriteriaAdded && crossTermOperator == AND)\n            {    \n              finds.add(index.search(query));\n            }\n            else if(actualCriteriaAdded && crossTermOperator == OR)\n            {\n              Iterator<Query> queries = queryList.iterator();\n              while(queries.hasNext())\n              {\n                  finds.add(index.search(queries.next()));\n              }\n            }\n            \n            boolean firstFinds = true;\n            if(textToFind.size() != 0)\n            {\n               Iterator<String> textIterator = textToFind.iterator(); \n               while(textIterator.hasNext())\n               {\n                   String text = textIterator.next();\n                   \n                   if(DEBUG_LOCAL)\n                   {    \n                     System.out.println(\"\\n\\n**********\\n Searching all resources for: \" + text );\n                   }\n                   \n                   found = index.searchAllResources(text);\n                   \n                   \n                   if(crossTermOperator == OR || firstFinds == true)\n                   {\n                      finds.add(found);   \n                      firstFinds = false;\n                   }\n                   else\n                   {\n                      // note: this iterator should usually have only one element in this case\n                      Iterator<List<URI>> findsIterator = finds.iterator();\n                      while(findsIterator.hasNext())\n                      {\n                          List<URI> current = findsIterator.next();\n                          Iterator<URI> alreadyFound = current.iterator();\n                          List<URI> toBeRemoved = new ArrayList<URI>();\n                          while(alreadyFound.hasNext())\n                          {\n                            URI currentURI = alreadyFound.next();\n                            \n                            if(DEBUG_LOCAL)\n                            {\n                               System.out.println(\"SearchAction - already found \" + currentURI + \",\" + text);\n                            }\n                            \n                            if(!found.contains(currentURI))\n                            {\n                                if(DEBUG_LOCAL)\n                                {\n                                    System.out.println(\"SearchAction - scheduling uri to be removed: (text follows) \" + currentURI + \",\" + text);\n                                }\n                                \n                                toBeRemoved.add(currentURI);\n                            }\n                          }\n                          \n                          Iterator<URI> removeThese = toBeRemoved.iterator();\n                          while(removeThese.hasNext())\n                          {\n                            current.remove(removeThese.next());\n                          }\n                      }\n                   }\n                   \n                   firstFinds = false;\n               }\n               \n               /*\n               while(textIterator.hasNext())\n               {\n                 //loadKeywords(textIterator.next());\n                 //for(int i=0;i<tags.size();i++)\n                 //{    \n                   //System.out.println(\"tags.get(i)\" + tags.get(i));\n                   //found = index.searchAllResources(tags.get(i));\n                   found = index.searchAllResources(textIterator.next());\n                   //System.out.println(\"found \" + found);\n                   //finds.add(found);\n                 //}\n               }*/\n            }\n           \n        } \n\n        Iterator<List<URI>> findsIterator = finds.iterator();\n        \n        comps = new ArrayList<LWComponent>();\n        \n        Iterator<LWMap> mapsIterator = VUE.getLeftTabbedPane().getAllMaps();\n        \n        ArrayList<LWMap> maps = new ArrayList<LWMap>();\n        while(mapsIterator.hasNext())\n        {\n            maps.add(mapsIterator.next());\n        }\n        \n        while(findsIterator.hasNext()) {\n            found = findsIterator.next();\n            if(found !=null) {\n                Iterator<URI> foundIterator = found.iterator();\n                while(foundIterator.hasNext()) {\n                    URI uri = foundIterator.next();\n                    if(DEBUG_LOCAL)\n                    {    \n                      System.out.println(\"SearchAction: uri found - \" + uri);\n                    }\n                    LWComponent r = (LWComponent)edu.tufts.vue.rdf.VueIndexedObjectsMap.getObjectForID(uri);\n                    //if(r!=null && (r.getMap() != null) && r.getMap().equals(VUE.getActiveMap())) {\n                    if(r!=null && (r.getMap() != null) && maps.contains(r.getMap())) {\n                        comps.add(r);\n                    }\n                    //else if(r != null && (r.getMap() !=null) && maps.contains(r.getMap()))\n                }\n            }\n        }\n        \n        // System.out.println(\"VUE Object Index: \" + edu.tufts.vue.rdf.VueIndexedObjectsMap.objs);\n        \n        //SwingUtilities.invokeLater(new Thread(){\n        //   public void run()\n        //   {\n               displaySearchResults();\n        //   }\n        //});\n    }","commit_id":"ffb17799da17dc382dd7e93d5946610040acfec1","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(ActionEvent e) {\n        \n       // runIndex();\n        \n        index = new  edu.tufts.vue.rdf.RDFIndex();\n        //edu.tufts.vue.rdf.VueIndexedObjectsMap.clear();\n        \n        VUE.getSelection().clear();\n\n        if(searchType == FIELD)\n        {\n          revertSelections();\n          loadKeywords(searchInput.getText());\n        }\n        performSearch(searchLocationType);\n        \n    }","id":102497,"modified_method":"public void actionPerformed(ActionEvent e)\n    {\n        if (DEBUG.SEARCH || DEBUG.RDF) Log.debug(\"actionPerformed, ae=\" + e);\n        \n        tufts.vue.gui.GUI.activateWaitCursor();\n\n        // // runIndex();\n        // Is this index being used?  SMF 2012-06-12 16:12.59 Tuesday SFAir.local\n        this.index = new edu.tufts.vue.rdf.RDFIndex();\n        // // edu.tufts.vue.rdf.VueIndexedObjectsMap.clear();\n        \n        VUE.getSelection().clear();\n\n        if(searchType == FIELD) {\n            revertSelections();\n            loadKeywords(searchInput.getText());\n        }\n        performSearch(searchLocationType);\n\n        tufts.vue.gui.GUI.clearWaitCursor();\n    }","commit_id":"ffb17799da17dc382dd7e93d5946610040acfec1","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * @return true if success, false if not\n     */\n      \n    public static boolean saveMap(LWMap map, boolean saveAs, boolean export)\n    {\n        Log.info(\"saveMap: \" + map);        \n        \n        GUI.activateWaitCursor();         \n       \n        \n        if (map == null)\n            return false;\n        \n        File file = map.getFile();\n        int response = -1;\n        if (map.getSaveFileModelVersion() == 0) {\n\n        \tfinal Object[] defaultOrderButtons = { VueResources.getString(\"saveaction.saveacopy\"),VueResources.getString(\"saveaction.save\")};\n            Object[] messageObject = {map.getLabel()};\n        \tresponse = VueUtil.option\n            (VUE.getDialogParent(),\n        \t VueResources.getFormatMessage(messageObject, \"dialog.saveaction.message\"),         \n        \t VueResources.getFormatMessage(messageObject, \"dialog.saveaction.title\"),\n             JOptionPane.YES_NO_OPTION,\n             JOptionPane.PLAIN_MESSAGE,\n             defaultOrderButtons,             \n             VueResources.getString(\"saveaction.saveacopy\")\n             );\n        }\n        \n        if (response == 0) {\n            saveAs=true;\n        } if ((saveAs || file == null) && !export) {\n            //file = ActionUtil.selectFile(\"Save Map\", \"vue\");\n            file = ActionUtil.selectFile(\"Save Map\", null);\n        } else if (export) {\n            file = ActionUtil.selectFile(\"Export Map\", \"export\");\n        }\n            \n        if (file == null) {\n            //GUI.clearWaitCursor();\n            try {\n                return false;\n            } finally {\n                GUI.clearWaitCursor();\n            }\n        }\n\n        try {\n        \t         \t\n            Log.info(\"saveMap: target[\" + file + \"]\");\n            \n            final String name = file.getName().toLowerCase();\n\n            if (name.endsWith(\".rli.xml\")) {\n                new IMSResourceList().convert(map,file);\n            }\n            else if (name.endsWith(\".xml\") || name.endsWith(\".vue\")) {\n                ActionUtil.marshallMap(file, map);\n            }\n            else if (name.endsWith(\".jpeg\") || name.endsWith(\".jpg\"))\n                ImageConversion.createActiveMapJpeg(file,VueResources.getDouble(\"imageExportFactor\"));\n            else if (name.endsWith(\".png\"))\n                ImageConversion.createActiveMapPng(file,VueResources.getDouble(\"imageExportFactor\"));\n            else if (name.endsWith(\".svg\"))\n                SVGConversion.createSVG(file);\n            \n            else if (name.endsWith(\".pdf\"))\n            {\n            \tPresentationNotes.createMapAsPDF(file);\n                //new PDFTransform().convert(file);\n            }\n            else if (name.endsWith(\".zip\"))\n            {   Vector resourceVector = new Vector();\n            \tIterator i = map.getAllDescendents(LWComponent.ChildKind.PROPER).iterator();\n            \twhile(i.hasNext()) {\t\n            \t\tLWComponent component = (LWComponent) i.next();\n            \t\tSystem.out.println(\"Component:\"+component+\" has resource:\"+component.hasResource());\n            \t\tif(component.hasResource() && (component.getResource() instanceof URLResource)){\n                    \n            \t\t\tURLResource resource = (URLResource) component.getResource();                    \n                \n            \t\t\t//   \tif(resource.getType() == Resource.URL) {\n            \t\t\ttry {\n                        // File file = new File(new URL(resource.getSpec()).getFile());\n                        if(resource.isLocalFile()) {\n                        \tString spec = resource.getSpec();                        \t                        \n                        \tSystem.out.println(resource.getSpec());\n                            Vector row = new Vector();\n                            row.add(new Boolean(true));\n                            row.add(resource);\n                            row.add(new Long(file.length()));\n                            row.add(\"Ready\");\n                            resourceVector.add(row);\n                        }\n            \t\t\t}catch (Exception ex) {\n            \t\t\t\tSystem.out.println(\"Publisher.setLocalResourceVector: Resource \"+resource.getSpec()+ ex);\n            \t\t\t\tex.printStackTrace();\n            \t\t\t}                    \n            \t\t}                \n            \t}\n            \tFile savedCMap =PublishUtil.createZip(map, resourceVector);\n            \t InputStream istream = new BufferedInputStream(new FileInputStream(savedCMap));\n                OutputStream ostream = new BufferedOutputStream(new FileOutputStream(file));\n                int fileLength = (int)savedCMap.length();\n                byte bytes[] = new  byte[fileLength];\n                try\n                {\n                \twhile (istream.read(bytes,0,fileLength) != -1)\n                \t\tostream.write(bytes,0,fileLength);\n                }\n                catch(Exception e)\n                {\n                \te.printStackTrace();\n                }\n                finally\n                {\n                \tistream.close();\n                \tostream.close();\n                }\n            }\n            //else if (name.endsWith(\".html\"))\n              //  new HTMLConversion().convert(file);\n            \n            //else if (name.endsWith(\".imap\"))\n            else if (name.endsWith(\".html\")) \n            {            \t\n            \tHtmlOutputDialog hod = new HtmlOutputDialog();\n            \thod.setVisible(true);   \n            \tif (hod.getReturnVal() > 0)\n            \t\tnew ImageMap().createImageMap(file, hod.getScale(), hod.getFormat());\n            }\n//             else if (name.endsWith(\".htm\")) {\n//                 writeHTMLOutline(map, file);\n//             }\n            else if(name.endsWith(\".rdf\"))\n            {\n               edu.tufts.vue.rdf.RDFIndex index = new edu.tufts.vue.rdf.RDFIndex();\n               \n               String selectionType = VueResources.getString(\"rdf.export.selection\");\n               \n               if(selectionType.equals(\"ALL\"))\n               {\n                 Iterator<LWMap> maps = VUE.getLeftTabbedPane().getAllMaps();\n                 while(maps.hasNext())\n                 {\n                     index.index(maps.next());\n                 }\n               }\n               else if(selectionType.equals(\"ACTIVE\"))\n               {\n                 index.index(VUE.getActiveMap());  \n               }    \n               else\n               {    \n                 index.index(VUE.getActiveMap());\n               }  \n               FileWriter writer = new FileWriter(file);\n               index.write(writer);\n               writer.close();\n            }\n            else if (name.endsWith(VueUtil.VueArchiveExtension))\n            {\n                Archive.writeArchive(map, file);\n                \n            } else {\n                Log.warn(\"Unknown save type for filename extension: \" + name);\n                return false;\n            }\n\n\t\t\t// don't know this as not all the above stuff is passing\n            // exceptions on to us!\n            Log.debug(\"Save completed for \" + file);\n            if (!VUE.isApplet())\n            {\n            \tVueFrame frame = (VueFrame)VUE.getMainWindow();\n            \tString title = VUE.getName() + \": \" + name;                      \n            \tframe.setTitle(title);\n            }\n            if (name.endsWith(\".vue\"))\n            {\n             RecentlyOpenedFilesManager rofm = RecentlyOpenedFilesManager.getInstance();\n             rofm.updateRecentlyOpenedFiles(file.getAbsolutePath());\n            }\n            return true;\n\n        } catch (Throwable t) {\n            Log.error(\"Exception attempting to save file \" + file + \": \" + t);\n            Throwable e = t;\n            if (t.getCause() != null)\n                e = t.getCause();\n            if (e instanceof java.io.FileNotFoundException) {\n                Log.error(\"Save Failed: \" + e);\n            } else {\n                Log.error(\"Save failed for \\\"\" + file + \"\\\"; \", e);\n                //tufts.Util.printStackTrace(e);\n            }\n            if (e != t)\n                Log.error(\"Exception attempting to save file \" + file + \": \" + e);\n            VueUtil.alert(String.format(Locale.getDefault(),VueResources.getString(\"saveaction.savemap.error\")+ \"\\\"%s\\\";\\n\"+VueResources.getString(\"saveaction.targetfiel\")+\"\\n\\n\"+VueResources.getString(\"saveaction.problem\"),\n                                        map.getLabel(), file, Util.formatLines(e.toString(), 80)),\n                          \"Problem Saving Map\");\n        } finally {\n            GUI.invokeAfterAWT(new Runnable() { public void run() {\n                GUI.clearWaitCursor();\n            }});\n        }\n\n        return false;\n    }","id":102498,"modified_method":"/**\n     * @return true if success, false if not\n     */\n      \n    public static boolean saveMap(LWMap map, boolean saveAs, boolean export)\n    {\n        Log.info(\"saveMap: \" + map);        \n        \n        GUI.activateWaitCursor();         \n       \n        \n        if (map == null)\n            return false;\n        \n        File file = map.getFile();\n        int response = -1;\n        if (map.getSaveFileModelVersion() == 0) {\n\n        \tfinal Object[] defaultOrderButtons = { VueResources.getString(\"saveaction.saveacopy\"),VueResources.getString(\"saveaction.save\")};\n            Object[] messageObject = {map.getLabel()};\n        \tresponse = VueUtil.option\n            (VUE.getDialogParent(),\n        \t VueResources.getFormatMessage(messageObject, \"dialog.saveaction.message\"),         \n        \t VueResources.getFormatMessage(messageObject, \"dialog.saveaction.title\"),\n             JOptionPane.YES_NO_OPTION,\n             JOptionPane.PLAIN_MESSAGE,\n             defaultOrderButtons,             \n             VueResources.getString(\"saveaction.saveacopy\")\n             );\n        }\n        \n        if (response == 0) {\n            saveAs=true;\n        } if ((saveAs || file == null) && !export) {\n            //file = ActionUtil.selectFile(\"Save Map\", \"vue\");\n            file = ActionUtil.selectFile(\"Save Map\", null);\n        } else if (export) {\n            file = ActionUtil.selectFile(\"Export Map\", \"export\");\n        }\n            \n        if (file == null) {\n            //GUI.clearWaitCursor();\n            try {\n                return false;\n            } finally {\n                GUI.clearWaitCursor();\n            }\n        }\n\n        try {\n        \t         \t\n            Log.info(\"saveMap: target[\" + file + \"]\");\n            \n            final String name = file.getName().toLowerCase();\n\n            if (name.endsWith(\".rli.xml\")) {\n                new IMSResourceList().convert(map,file);\n            }\n            else if (name.endsWith(\".xml\") || name.endsWith(\".vue\")) {\n                ActionUtil.marshallMap(file, map);\n            }\n            else if (name.endsWith(\".jpeg\") || name.endsWith(\".jpg\"))\n                ImageConversion.createActiveMapJpeg(file,VueResources.getDouble(\"imageExportFactor\"));\n            else if (name.endsWith(\".png\"))\n                ImageConversion.createActiveMapPng(file,VueResources.getDouble(\"imageExportFactor\"));\n            else if (name.endsWith(\".svg\"))\n                SVGConversion.createSVG(file);\n            \n            else if (name.endsWith(\".pdf\"))\n            {\n            \tPresentationNotes.createMapAsPDF(file);\n                //new PDFTransform().convert(file);\n            }\n            else if (name.endsWith(\".zip\"))\n            {   Vector resourceVector = new Vector();\n            \tIterator i = map.getAllDescendents(LWComponent.ChildKind.PROPER).iterator();\n            \twhile(i.hasNext()) {\t\n            \t\tLWComponent component = (LWComponent) i.next();\n            \t\tSystem.out.println(\"Component:\"+component+\" has resource:\"+component.hasResource());\n            \t\tif(component.hasResource() && (component.getResource() instanceof URLResource)){\n                    \n            \t\t\tURLResource resource = (URLResource) component.getResource();                    \n                \n            \t\t\t//   \tif(resource.getType() == Resource.URL) {\n            \t\t\ttry {\n                        // File file = new File(new URL(resource.getSpec()).getFile());\n                        if(resource.isLocalFile()) {\n                        \tString spec = resource.getSpec();                        \t                        \n                        \tSystem.out.println(resource.getSpec());\n                            Vector row = new Vector();\n                            row.add(new Boolean(true));\n                            row.add(resource);\n                            row.add(new Long(file.length()));\n                            row.add(\"Ready\");\n                            resourceVector.add(row);\n                        }\n            \t\t\t}catch (Exception ex) {\n            \t\t\t\tSystem.out.println(\"Publisher.setLocalResourceVector: Resource \"+resource.getSpec()+ ex);\n            \t\t\t\tex.printStackTrace();\n            \t\t\t}                    \n            \t\t}                \n            \t}\n            \tFile savedCMap =PublishUtil.createZip(map, resourceVector);\n            \t InputStream istream = new BufferedInputStream(new FileInputStream(savedCMap));\n                OutputStream ostream = new BufferedOutputStream(new FileOutputStream(file));\n                int fileLength = (int)savedCMap.length();\n                byte bytes[] = new  byte[fileLength];\n                try\n                {\n                \twhile (istream.read(bytes,0,fileLength) != -1)\n                \t\tostream.write(bytes,0,fileLength);\n                }\n                catch(Exception e)\n                {\n                \te.printStackTrace();\n                }\n                finally\n                {\n                \tistream.close();\n                \tostream.close();\n                }\n            }\n            //else if (name.endsWith(\".html\"))\n              //  new HTMLConversion().convert(file);\n            \n            //else if (name.endsWith(\".imap\"))\n            else if (name.endsWith(\".html\")) \n            {            \t\n            \tHtmlOutputDialog hod = new HtmlOutputDialog();\n            \thod.setVisible(true);   \n            \tif (hod.getReturnVal() > 0)\n            \t\tnew ImageMap().createImageMap(file, hod.getScale(), hod.getFormat());\n            }\n//             else if (name.endsWith(\".htm\")) {\n//                 writeHTMLOutline(map, file);\n//             }\n            else if(name.endsWith(\".rdf\"))\n            {\n               final edu.tufts.vue.rdf.RDFIndex index = new edu.tufts.vue.rdf.RDFIndex();\n               \n               final String selectionType = VueResources.getString(\"rdf.export.selection\");\n               \n               if (selectionType.equals(\"ALL\")) {\n                 for (LWMap map : VUE.getAllMaps())\n                     index.index(map);\n               }\n               else if (selectionType.equals(\"ACTIVE\"))\n                   index.index(VUE.getActiveMap());  \n               else \n                   index.index(VUE.getActiveMap());\n\n               FileWriter writer = new FileWriter(file);\n               index.write(writer);\n               writer.close();\n            }\n            else if (name.endsWith(VueUtil.VueArchiveExtension))\n            {\n                Archive.writeArchive(map, file);\n                \n            } else {\n                Log.warn(\"Unknown save type for filename extension: \" + name);\n                return false;\n            }\n\n\t\t\t// don't know this as not all the above stuff is passing\n            // exceptions on to us!\n            Log.debug(\"Save completed for \" + file);\n            if (!VUE.isApplet())\n            {\n            \tVueFrame frame = (VueFrame)VUE.getMainWindow();\n            \tString title = VUE.getName() + \": \" + name;                      \n            \tframe.setTitle(title);\n            }\n            if (name.endsWith(\".vue\"))\n            {\n             RecentlyOpenedFilesManager rofm = RecentlyOpenedFilesManager.getInstance();\n             rofm.updateRecentlyOpenedFiles(file.getAbsolutePath());\n            }\n            return true;\n\n        } catch (Throwable t) {\n            Log.error(\"Exception attempting to save file \" + file + \": \" + t);\n            Throwable e = t;\n            if (t.getCause() != null)\n                e = t.getCause();\n            if (e instanceof java.io.FileNotFoundException) {\n                Log.error(\"Save Failed: \" + e);\n            } else {\n                Log.error(\"Save failed for \\\"\" + file + \"\\\"; \", e);\n                //tufts.Util.printStackTrace(e);\n            }\n            if (e != t)\n                Log.error(\"Exception attempting to save file \" + file + \": \" + e);\n            VueUtil.alert(String.format(Locale.getDefault(),VueResources.getString(\"saveaction.savemap.error\")+ \"\\\"%s\\\";\\n\"+VueResources.getString(\"saveaction.targetfiel\")+\"\\n\\n\"+VueResources.getString(\"saveaction.problem\"),\n                                        map.getLabel(), file, Util.formatLines(e.toString(), 80)),\n                          \"Problem Saving Map\");\n        } finally {\n            GUI.invokeAfterAWT(new Runnable() { public void run() {\n                GUI.clearWaitCursor();\n            }});\n        }\n\n        return false;\n    }","commit_id":"1cb089b00eceb6822a1922dd6803c05b9dda5a01","url":"https://github.com/VUE/VUE"},{"original_method":"public IGImage updateImage(\n\t\t\tString companyId, String imageId, String folderId,\n\t\t\tString description, File file, String contentType,\n\t\t\tString[] tagsEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\ttry {\n\n\t\t\t// Image\n\n\t\t\tIGImage image = IGImageUtil.findByPrimaryKey(\n\t\t\t\tnew IGImagePK(companyId, imageId));\n\n\t\t\tIGFolder folder = getFolder(image, folderId);\n\t\t\tBufferedImage bufferedImage = ImageIO.read(file);\n\t\t\tbyte[] bytes = FileUtil.getBytes(file);\n\n\t\t\tvalidate(file, bytes);\n\n\t\t\timage.setModifiedDate(new Date());\n\t\t\timage.setFolderId(folder.getFolderId());\n\t\t\timage.setDescription(description);\n\t\t\timage.setHeight(bufferedImage.getHeight());\n\t\t\timage.setWidth(bufferedImage.getWidth());\n\t\t\timage.setSize(bytes.length);\n\n\t\t\tIGImageUtil.update(image);\n\n\t\t\t// Images\n\n\t\t\tsaveImages(\n\t\t\t\timage.getLargeImageId(), bufferedImage, image.getSmallImageId(),\n\t\t\t\tfile, bytes, contentType);\n\n\t\t\t// Tags\n\n\t\t\tTagsAssetLocalServiceUtil.updateAsset(\n\t\t\t\timage.getUserId(), IGImage.class.getName(),\n\t\t\t\timage.getPrimaryKey().toString(), tagsEntries);\n\n\t\t\treturn image;\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new ImageSizeException(ioe);\n\t\t}\n\t}","id":102499,"modified_method":"public IGImage updateImage(\n\t\t\tString companyId, String imageId, String folderId,\n\t\t\tString description, File file, String contentType,\n\t\t\tString[] tagsEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\ttry {\n\n\t\t\t// Image\n\n\t\t\tIGImage image = IGImageUtil.findByPrimaryKey(\n\t\t\t\tnew IGImagePK(companyId, imageId));\n\n\t\t\tIGFolder folder = getFolder(image, folderId);\n\n\t\t\tBufferedImage bufferedImage = null;\n\t\t\tbyte[] bytes = null;\n\n\t\t\tif (file.exists()) {\n\t\t\t\tbufferedImage = ImageIO.read(file);\n\t\t\t\tbytes = FileUtil.getBytes(file);\n\t\t\t}\n\n\t\t\tvalidate(file, bytes);\n\n\t\t\timage.setModifiedDate(new Date());\n\t\t\timage.setFolderId(folder.getFolderId());\n\t\t\timage.setDescription(description);\n\n\t\t\tif (bufferedImage != null) {\n\t\t\t\timage.setHeight(bufferedImage.getHeight());\n\t\t\t\timage.setWidth(bufferedImage.getWidth());\n\t\t\t\timage.setSize(bytes.length);\n\t\t\t}\n\n\t\t\tIGImageUtil.update(image);\n\n\t\t\t// Images\n\n\t\t\tif (bufferedImage != null) {\n\t\t\t\tsaveImages(\n\t\t\t\t\timage.getLargeImageId(), bufferedImage,\n\t\t\t\t\timage.getSmallImageId(), file, bytes, contentType);\n\t\t\t}\n\n\t\t\t// Tags\n\n\t\t\tTagsAssetLocalServiceUtil.updateAsset(\n\t\t\t\timage.getUserId(), IGImage.class.getName(),\n\t\t\t\timage.getPrimaryKey().toString(), tagsEntries);\n\n\t\t\treturn image;\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new ImageSizeException(ioe);\n\t\t}\n\t}","commit_id":"785c6eff0b8fad6e5299a0ac4110dd52649dbef6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void expectNodes( String entity, long... nodes ) throws PropertyValueException\n    {\n        Set<String> expected = new HashSet<String>();\n        for ( long node : nodes )\n        {\n            expected.add( functionalTestHelper.nodeUri( node ) );\n        }\n        Collection<?> items = (Collection<?>) JsonHelper.jsonToSingleValue( entity );\n        for ( Object item : items )\n        {\n            Map<?, ?> map = (Map<?, ?>) item;\n            String uri = (String) map.get( \"self\" );\n            assertTrue( uri + \" not found\", expected.remove( uri ) );\n        }\n        assertTrue( \"Expected not empty:\" + expected, expected.isEmpty() );\n    }","id":102500,"modified_method":"private void expectNodes( String entity, Node... nodes )\n            throws PropertyValueException\n    {\n        Set<String> expected = new HashSet<String>();\n        for ( Node node : nodes )\n        {\n            expected.add( getNodeUri( node ) );\n        }\n        Collection<?> items = (Collection<?>) JsonHelper.jsonToSingleValue( entity );\n        for ( Object item : items )\n        {\n            Map<?, ?> map = (Map<?, ?>) item;\n            String uri = (String) map.get( \"self\" );\n            assertTrue( uri + \" not found\", expected.remove( uri ) );\n        }\n        assertTrue( \"Expected not empty:\" + expected, expected.isEmpty() );\n    }","commit_id":"3a18456637c3b96936f18435f255bb630ec4089d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldGet200WhenNoHitsFromTraversing() throws DatabaseBlockedException\n    {\n        long node = helper.createNode();\n        JaxRsResponse response = traverse(node, \"{}\");\n        assertEquals( Status.OK.getStatusCode(), response.getStatus() );\n        response.close();\n    }","id":102501,"modified_method":"@Test\n    @Graph( \"I know you\" )\n    public void shouldGet200WhenNoHitsFromTraversing()\n            throws DatabaseBlockedException\n    {\n        gen.get().expectedStatus( 200 ).payload( \"{}\" ).post(\n                getTraverseUriNodes( getNode( \"I\" ) ) ).entity();\n    }","commit_id":"3a18456637c3b96936f18435f255bb630ec4089d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldGet400WhenSupplyingInvalidTraverserDescriptionFormat() throws DatabaseBlockedException\n    {\n        long node = helper.createNode();\n        JaxRsResponse response = traverse(node, \"::not JSON{[ at all\");\n        assertEquals( Status.BAD_REQUEST.getStatusCode(), response.getStatus() );\n        response.close();\n    }","id":102502,"modified_method":"@Test\n    @Graph( \"I know you\" )\n    public void shouldGet400WhenSupplyingInvalidTraverserDescriptionFormat()\n            throws DatabaseBlockedException\n    {\n        gen.get().expectedStatus( Status.BAD_REQUEST.getStatusCode() ).payload(\n                \"::not JSON{[ at all\" ).post(\n                getTraverseUriNodes( getNode( \"I\" ) ) ).entity();\n    }","commit_id":"3a18456637c3b96936f18435f255bb630ec4089d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    @Documented\n    public void shouldGetSomeHitsWhenTraversingWithDefaultDescription() throws PropertyValueException\n    {\n        JaxRsResponse response = traverse(startNode, \"\");\n        assertEquals( Status.OK.getStatusCode(), response.getStatus() );\n        String entity = response.getEntity( String.class );\n        expectNodes( entity, mattias, johan );\n        response.close();\n    }","id":102503,"modified_method":"@Test\n    @Graph( \"I know you\" )\n    @Documented\n    public void shouldGetSomeHitsWhenTraversingWithDefaultDescription()\n            throws PropertyValueException\n    {\n        String entity = gen.get().expectedStatus( Status.OK.getStatusCode() ).payload( \"{}\" ).post(\n                getTraverseUriNodes( getNode( \"I\" ) ) ).entity();\n\n        expectNodes( entity, getNode( \"you\" ));\n    }","commit_id":"3a18456637c3b96936f18435f255bb630ec4089d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldGet404WhenTraversingFromNonExistentNode()\n    {\n        JaxRsResponse response = traverse(99999, \"{}\");\n        assertEquals( Status.NOT_FOUND.getStatusCode(), response.getStatus() );\n        response.close();\n    }","id":102504,"modified_method":"@Test\n    public void shouldGet404WhenTraversingFromNonExistentNode()\n    {\n        gen.get().expectedStatus( Status.NOT_FOUND.getStatusCode() ).payload(\n                \"{}\" ).post( getDataUri() + \"node/10000/traverse/node\" ).entity();\n    }","commit_id":"3a18456637c3b96936f18435f255bb630ec4089d","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Traversal using a return filter.\n     * \n     * In this example, the +none+ prune evaluator is used and a return filter\n     * is supplied. The result is to be returned as nodes and the max depth is\n     * set to 3.\n     */\n    @Documented\n    @Test\n    public void shouldGetExpectedHitsWhenTraversingWithDescription() throws PropertyValueException\n    {\n        List<Map<String, Object>> rels = new ArrayList<Map<String, Object>>();\n        rels.add( MapUtil.map( \"type\", \"knows\", \"direction\", \"all\" ) );\n        rels.add( MapUtil.map( \"type\", \"loves\", \"direction\", \"all\" ) );\n        String description = JsonHelper.createJsonFrom( MapUtil.map( \"order\", \"breadth_first\", \"uniqueness\",\n                \"node_global\", \"prune_evaluator\", MapUtil.map( \"language\", \"builtin\", \"name\", \"none\" ),\n                \"return_filter\", MapUtil.map( \"language\", \"javascript\", \"body\",\n                        \"position.endNode().getProperty('name').toLowerCase().contains('t')\" ), \"relationships\", rels,\n                \"max depth\", 3 ) );\n        String entity = gen.get()\n                .expectedStatus( 200 )\n                .payload( description )\n                .post( functionalTestHelper.nodeUri( startNode ) + \"/traverse/node\" )\n                .entity();\n        expectNodes( entity, startNode, mattias, peter, tobias );\n    }","id":102505,"modified_method":"/**\n     * Traversal using a return filter.\n     * \n     * In this example, the +none+ prune evaluator is used and a return filter\n     * is supplied. The result is to be returned as nodes and the max depth is\n     * set to 3.\n     */\n    @Documented\n    @Graph( {\"Root knows Mattias\", \"Root knows Johan\", \"Johan knows Emil\", \"Emil knows Peter\", \"Emil knows Tobias\", \"Tobias loves Sara\"} )\n    @Test\n    public void shouldGetExpectedHitsWhenTraversingWithDescription()\n            throws PropertyValueException\n    {\n        Node start = getNode( \"Root\" );\n        List<Map<String, Object>> rels = new ArrayList<Map<String, Object>>();\n        rels.add( MapUtil.map( \"type\", \"knows\", \"direction\", \"all\" ) );\n        rels.add( MapUtil.map( \"type\", \"loves\", \"direction\", \"all\" ) );\n        String description = JsonHelper.createJsonFrom( MapUtil.map(\n                \"order\",\n                \"breadth_first\",\n                \"uniqueness\",\n                \"node_global\",\n                \"prune_evaluator\",\n                MapUtil.map( \"language\", \"builtin\", \"name\", \"none\" ),\n                \"return_filter\",\n                MapUtil.map( \"language\", \"javascript\", \"body\",\n                        \"position.endNode().getProperty('name').toLowerCase().contains('t')\" ),\n                \"relationships\", rels, \"max depth\", 3 ) );\n        String entity = gen.get().expectedStatus( 200 ).payload( description ).post(\n                getTraverseUriNodes( start ) ).entity();\n        expectNodes( entity, getNodes( \"Root\", \"Mattias\", \"Peter\", \"Tobias\" ) );\n    }","commit_id":"3a18456637c3b96936f18435f255bb630ec4089d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void extractTerms(Set<Term> terms) {\n        childQuery.extractTerms(terms);\n    }","id":102506,"modified_method":"@Override\n    public void extractTerms(Set<Term> terms) {\n        rewrittenChildQuery.extractTerms(terms);\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private ChildrenQuery(ChildrenQuery unProcessedQuery, Query rewrittenChildQuery) {\n        this.searchContext = unProcessedQuery.searchContext;\n        this.parentType = unProcessedQuery.parentType;\n        this.childType = unProcessedQuery.childType;\n        this.parentFilter = unProcessedQuery.parentFilter;\n        this.scoreType = unProcessedQuery.scoreType;\n        this.childQuery = rewrittenChildQuery;\n\n        this.uidToScore = unProcessedQuery.uidToScore;\n        this.uidToCount = unProcessedQuery.uidToCount;\n    }","id":102507,"modified_method":"private ChildrenQuery(ChildrenQuery unProcessedQuery, Query rewrittenChildQuery) {\n        this.searchContext = unProcessedQuery.searchContext;\n        this.parentType = unProcessedQuery.parentType;\n        this.childType = unProcessedQuery.childType;\n        this.parentFilter = unProcessedQuery.parentFilter;\n        this.scoreType = unProcessedQuery.scoreType;\n        this.originalChildQuery = unProcessedQuery.originalChildQuery;\n        this.rewrittenChildQuery = rewrittenChildQuery;\n\n        this.uidToScore = unProcessedQuery.uidToScore;\n        this.uidToCount = unProcessedQuery.uidToCount;\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Weight createWeight(IndexSearcher searcher) throws IOException {\n        if (uidToScore == null) {\n            throw new ElasticSearchIllegalStateException(\"has_child query hasn't executed properly\");\n        }\n\n        return new ParentWeight(childQuery.createWeight(searcher));\n    }","id":102508,"modified_method":"@Override\n    public Weight createWeight(IndexSearcher searcher) throws IOException {\n        if (uidToScore == null) {\n            throw new ElasticSearchIllegalStateException(\"has_child query hasn't executed properly\");\n        }\n\n        return new ParentWeight(rewrittenChildQuery.createWeight(searcher));\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void contextRewrite(SearchContext searchContext) throws Exception {\n        searchContext.idCache().refresh(searchContext.searcher().getTopReaderContext().leaves());\n\n        uidToScore = CacheRecycler.popObjectFloatMap();\n        Collector collector;\n        switch (scoreType) {\n            case AVG:\n                uidToCount = CacheRecycler.popObjectIntMap();\n                collector = new AvgChildUidCollector(scoreType, searchContext, parentType, uidToScore, uidToCount);\n                break;\n            default:\n                collector = new ChildUidCollector(scoreType, searchContext, parentType, uidToScore);\n        }\n        searchContext.searcher().search(childQuery, collector);\n    }","id":102509,"modified_method":"@Override\n    public void contextRewrite(SearchContext searchContext) throws Exception {\n        searchContext.idCache().refresh(searchContext.searcher().getTopReaderContext().leaves());\n\n        uidToScore = CacheRecycler.popObjectFloatMap();\n        Collector collector;\n        switch (scoreType) {\n            case AVG:\n                uidToCount = CacheRecycler.popObjectIntMap();\n                collector = new AvgChildUidCollector(scoreType, searchContext, parentType, uidToScore, uidToCount);\n                break;\n            default:\n                collector = new ChildUidCollector(scoreType, searchContext, parentType, uidToScore);\n        }\n        Query childQuery;\n        if (rewrittenChildQuery == null) {\n            childQuery = rewrittenChildQuery = searchContext.searcher().rewrite(originalChildQuery);\n        } else {\n            childQuery = rewrittenChildQuery;\n        }\n        searchContext.searcher().search(childQuery, collector);\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public String toString(String field) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"ChildrenQuery[\").append(childType).append(\"/\").append(parentType).append(\"](\").append(childQuery\n                .toString(field)).append(')').append(ToStringUtils.boost(getBoost()));\n        return sb.toString();\n    }","id":102510,"modified_method":"@Override\n    public String toString(String field) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"ChildrenQuery[\").append(childType).append(\"/\").append(parentType).append(\"](\").append(originalChildQuery\n                .toString(field)).append(')').append(ToStringUtils.boost(getBoost()));\n        return sb.toString();\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Query rewrite(IndexReader reader) throws IOException {\n        Query rewrittenChildQuery = childQuery.rewrite(reader);\n        if (rewrittenChildQuery == childQuery) {\n            return this;\n        }\n\n        int index = searchContext.rewrites().indexOf(this);\n        ChildrenQuery rewrite = new ChildrenQuery(this, rewrittenChildQuery);\n        searchContext.rewrites().set(index, rewrite);\n        return rewrite;\n    }","id":102511,"modified_method":"@Override\n    public Query rewrite(IndexReader reader) throws IOException {\n        Query rewritten;\n        if (rewrittenChildQuery == null) {\n            rewritten = originalChildQuery.rewrite(reader);\n        } else {\n            rewritten = rewrittenChildQuery;\n        }\n        if (rewritten == rewrittenChildQuery) {\n            return this;\n        }\n\n        // See TopChildrenQuery#rewrite\n        int index = searchContext.rewrites().indexOf(this);\n        ChildrenQuery rewrite = new ChildrenQuery(this, rewritten);\n        searchContext.rewrites().set(index, rewrite);\n        return rewrite;\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ChildrenQuery(SearchContext searchContext, String parentType, String childType, Filter parentFilter, Query childQuery, ScoreType scoreType) {\n        this.searchContext = searchContext;\n        this.parentType = parentType;\n        this.childType = childType;\n        this.parentFilter = parentFilter;\n        this.childQuery = childQuery;\n        this.scoreType = scoreType;\n    }","id":102512,"modified_method":"public ChildrenQuery(SearchContext searchContext, String parentType, String childType, Filter parentFilter, Query childQuery, ScoreType scoreType) {\n        this.searchContext = searchContext;\n        this.parentType = parentType;\n        this.childType = childType;\n        this.parentFilter = parentFilter;\n        this.originalChildQuery = childQuery;\n        this.scoreType = scoreType;\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Query rewrite(IndexReader reader) throws IOException {\n        Query rewrittenChildQuery = parentQuery.rewrite(reader);\n        if (rewrittenChildQuery == parentQuery) {\n            return this;\n        }\n        ParentQuery rewrite = new ParentQuery(this, rewrittenChildQuery);\n        int index = searchContext.rewrites().indexOf(this);\n        searchContext.rewrites().set(index, rewrite);\n        return rewrite;\n    }","id":102513,"modified_method":"@Override\n    public Query rewrite(IndexReader reader) throws IOException {\n        Query rewritten;\n        if (rewrittenParentQuery == null) {\n            rewritten = originalParentQuery.rewrite(reader);\n        } else {\n            rewritten = rewrittenParentQuery;\n        }\n        if (rewritten == rewrittenParentQuery) {\n            return this;\n        }\n\n        // See TopChildrenQuery#rewrite\n        ParentQuery rewrite = new ParentQuery(this, rewritten);\n        int index = searchContext.rewrites().indexOf(this);\n        searchContext.rewrites().set(index, rewrite);\n        return rewrite;\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Weight createWeight(IndexSearcher searcher) throws IOException {\n        if (uidToScore == null) {\n            throw new ElasticSearchIllegalStateException(\"has_parent query hasn't executed properly\");\n        }\n        return new ChildWeight(parentQuery.createWeight(searcher));\n    }","id":102514,"modified_method":"@Override\n    public Weight createWeight(IndexSearcher searcher) throws IOException {\n        if (uidToScore == null) {\n            throw new ElasticSearchIllegalStateException(\"has_parent query hasn't executed properly\");\n        }\n        return new ChildWeight(rewrittenParentQuery.createWeight(searcher));\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ParentQuery(SearchContext searchContext, Query parentQuery, String parentType, List<String> childTypes, Filter childrenFilter) {\n        this.searchContext = searchContext;\n        this.parentQuery = parentQuery;\n        this.parentType = parentType;\n        this.childTypes = childTypes;\n        this.childrenFilter = childrenFilter;\n    }","id":102515,"modified_method":"public ParentQuery(SearchContext searchContext, Query parentQuery, String parentType, List<String> childTypes, Filter childrenFilter) {\n        this.searchContext = searchContext;\n        this.originalParentQuery = parentQuery;\n        this.parentType = parentType;\n        this.childTypes = childTypes;\n        this.childrenFilter = childrenFilter;\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public String toString(String field) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"ParentQuery[\").append(parentType).append(\"/\").append(childTypes)\n                .append(\"](\").append(parentQuery.toString(field)).append(')')\n                .append(ToStringUtils.boost(getBoost()));\n        return sb.toString();\n    }","id":102516,"modified_method":"@Override\n    public String toString(String field) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"ParentQuery[\").append(parentType).append(\"/\").append(childTypes)\n                .append(\"](\").append(originalParentQuery.toString(field)).append(')')\n                .append(ToStringUtils.boost(getBoost()));\n        return sb.toString();\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void extractTerms(Set<Term> terms) {\n        parentQuery.extractTerms(terms);\n    }","id":102517,"modified_method":"@Override\n    public void extractTerms(Set<Term> terms) {\n        rewrittenParentQuery.extractTerms(terms);\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private ParentQuery(ParentQuery unwritten, Query rewrittenParentQuery) {\n        this.searchContext = unwritten.searchContext;\n        this.parentQuery = rewrittenParentQuery;\n        this.parentType = unwritten.parentType;\n        this.childrenFilter = unwritten.childrenFilter;\n        this.childTypes = unwritten.childTypes;\n\n        this.uidToScore = unwritten.uidToScore;\n    }","id":102518,"modified_method":"private ParentQuery(ParentQuery unwritten, Query rewrittenParentQuery) {\n        this.searchContext = unwritten.searchContext;\n        this.originalParentQuery = unwritten.originalParentQuery;\n        this.parentType = unwritten.parentType;\n        this.childrenFilter = unwritten.childrenFilter;\n        this.childTypes = unwritten.childTypes;\n\n        this.rewrittenParentQuery = rewrittenParentQuery;\n        this.uidToScore = unwritten.uidToScore;\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void contextRewrite(SearchContext searchContext) throws Exception {\n        searchContext.idCache().refresh(searchContext.searcher().getTopReaderContext().leaves());\n        uidToScore = CacheRecycler.popObjectFloatMap();\n        ParentUidCollector collector = new ParentUidCollector(uidToScore, searchContext, parentType);\n        searchContext.searcher().search(parentQuery, collector);\n    }","id":102519,"modified_method":"@Override\n    public void contextRewrite(SearchContext searchContext) throws Exception {\n        searchContext.idCache().refresh(searchContext.searcher().getTopReaderContext().leaves());\n        uidToScore = CacheRecycler.popObjectFloatMap();\n        ParentUidCollector collector = new ParentUidCollector(uidToScore, searchContext, parentType);\n        Query parentQuery;\n        if (rewrittenParentQuery == null) {\n            parentQuery = rewrittenParentQuery = searchContext.searcher().rewrite(originalParentQuery);\n        } else {\n            parentQuery = rewrittenParentQuery;\n        }\n        searchContext.searcher().search(parentQuery, collector);\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public String toString(String field) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"score_child[\").append(childType).append(\"/\").append(parentType).append(\"](\").append(childQuery.toString(field)).append(')');\n        sb.append(ToStringUtils.boost(getBoost()));\n        return sb.toString();\n    }","id":102520,"modified_method":"public String toString(String field) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"score_child[\").append(childType).append(\"/\").append(parentType).append(\"](\").append(originalChildQuery.toString(field)).append(')');\n        sb.append(ToStringUtils.boost(getBoost()));\n        return sb.toString();\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Query rewrite(IndexReader reader) throws IOException {\n        Query rewrittenChildQuery = childQuery.rewrite(reader);\n        if (rewrittenChildQuery == childQuery) {\n            return this;\n        }\n        int index = searchContext.rewrites().indexOf(this);\n        TopChildrenQuery rewrite = new TopChildrenQuery(this, rewrittenChildQuery);\n        searchContext.rewrites().set(index, rewrite);\n        return rewrite;\n    }","id":102521,"modified_method":"@Override\n    public Query rewrite(IndexReader reader) throws IOException {\n        Query rewritten;\n        if (rewrittenChildQuery == null) {\n            rewritten = originalChildQuery.rewrite(reader);\n        } else {\n            rewritten = rewrittenChildQuery;\n        }\n        if (rewritten == rewrittenChildQuery) {\n            return this;\n        }\n        // We need to update the rewritten query also in the SearchContext#rewrites b/c we can run into this situation:\n        // 1) During parsing we set SearchContext#rewrites with queries that implement Rewrite.\n        // 2) Then during the dfs phase, the main query (which included this query and its child query) gets rewritten\n        // and updated in SearchContext. So different TopChildrenQuery instances are in SearchContext#rewrites and in the main query.\n        // 3) Then during the query phase first the queries that impl. Rewrite are executed, which will update their own data\n        // parentDocs Map. Then when the main query is executed, 0 results are found, b/c the main query holds a different\n        // TopChildrenQuery instance then in SearchContext#rewrites\n        int index = searchContext.rewrites().indexOf(this);\n        TopChildrenQuery rewrite = new TopChildrenQuery(this, rewritten);\n        searchContext.rewrites().set(index, rewrite);\n        return rewrite;\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private TopChildrenQuery(TopChildrenQuery existing, Query rewrittenChildQuery) {\n        this.searchContext = existing.searchContext;\n        this.childQuery = rewrittenChildQuery;\n        this.parentType = existing.parentType;\n        this.childType = existing.childType;\n        this.scoreType = existing.scoreType;\n        this.factor = existing.factor;\n        this.incrementalFactor = existing.incrementalFactor;\n        this.parentDocs = existing.parentDocs;\n    }","id":102522,"modified_method":"private TopChildrenQuery(TopChildrenQuery existing, Query rewrittenChildQuery) {\n        this.searchContext = existing.searchContext;\n        this.originalChildQuery = existing.originalChildQuery;\n        this.parentType = existing.parentType;\n        this.childType = existing.childType;\n        this.scoreType = existing.scoreType;\n        this.factor = existing.factor;\n        this.incrementalFactor = existing.incrementalFactor;\n        this.parentDocs = existing.parentDocs;\n        this.rewrittenChildQuery = rewrittenChildQuery;\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void extractTerms(Set<Term> terms) {\n        childQuery.extractTerms(terms);\n    }","id":102523,"modified_method":"@Override\n    public void extractTerms(Set<Term> terms) {\n        rewrittenChildQuery.extractTerms(terms);\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void contextRewrite(SearchContext searchContext) throws Exception {\n        this.parentDocs = CacheRecycler.popHashMap();\n        searchContext.idCache().refresh(searchContext.searcher().getTopReaderContext().leaves());\n\n        int parentHitsResolved;\n        int numChildDocs = (searchContext.from() + searchContext.size());\n        if (numChildDocs == 0) {\n            numChildDocs = 1;\n        }\n        numChildDocs *= factor;\n        while (true) {\n            parentDocs.clear();\n            TopDocs topChildDocs = searchContext.searcher().search(childQuery, numChildDocs);\n            parentHitsResolved = resolveParentDocuments(topChildDocs, searchContext);\n\n            // check if we found enough docs, if so, break\n            if (parentHitsResolved >= (searchContext.from() + searchContext.size())) {\n                break;\n            }\n            // if we did not find enough docs, check if it make sense to search further\n            if (topChildDocs.totalHits <= numChildDocs) {\n                break;\n            }\n            // if not, update numDocs, and search again\n            numChildDocs *= incrementalFactor;\n            if (numChildDocs > topChildDocs.totalHits) {\n                numChildDocs = topChildDocs.totalHits;\n            }\n        }\n    }","id":102524,"modified_method":"@Override\n    public void contextRewrite(SearchContext searchContext) throws Exception {\n        this.parentDocs = CacheRecycler.popHashMap();\n        searchContext.idCache().refresh(searchContext.searcher().getTopReaderContext().leaves());\n\n        int parentHitsResolved;\n        int numChildDocs = (searchContext.from() + searchContext.size());\n        if (numChildDocs == 0) {\n            numChildDocs = 1;\n        }\n        numChildDocs *= factor;\n\n        Query childQuery;\n        if (rewrittenChildQuery == null) {\n            childQuery = rewrittenChildQuery = searchContext.searcher().rewrite(originalChildQuery);\n        } else {\n            childQuery = rewrittenChildQuery;\n        }\n        while (true) {\n            parentDocs.clear();\n            TopDocs topChildDocs = searchContext.searcher().search(childQuery, numChildDocs);\n            parentHitsResolved = resolveParentDocuments(topChildDocs, searchContext);\n\n            // check if we found enough docs, if so, break\n            if (parentHitsResolved >= (searchContext.from() + searchContext.size())) {\n                break;\n            }\n            // if we did not find enough docs, check if it make sense to search further\n            if (topChildDocs.totalHits <= numChildDocs) {\n                break;\n            }\n            // if not, update numDocs, and search again\n            numChildDocs *= incrementalFactor;\n            if (numChildDocs > topChildDocs.totalHits) {\n                numChildDocs = topChildDocs.totalHits;\n            }\n        }\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Weight createWeight(IndexSearcher searcher) throws IOException {\n        if (parentDocs == null) {\n            throw new ElasticSearchIllegalStateException(\"top_children query hasn't executed properly\");\n        }\n\n        return new ParentWeight(searcher, childQuery.createWeight(searcher));\n    }","id":102525,"modified_method":"@Override\n    public Weight createWeight(IndexSearcher searcher) throws IOException {\n        if (parentDocs == null) {\n            throw new ElasticSearchIllegalStateException(\"top_children query hasn't executed properly\");\n        }\n\n        return new ParentWeight(searcher, rewrittenChildQuery.createWeight(searcher));\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public TopChildrenQuery(SearchContext searchContext, Query childQuery, String childType, String parentType, ScoreType scoreType, int factor, int incrementalFactor) {\n        this.searchContext = searchContext;\n        this.childQuery = childQuery;\n        this.childType = childType;\n        this.parentType = parentType;\n        this.scoreType = scoreType;\n        this.factor = factor;\n        this.incrementalFactor = incrementalFactor;\n    }","id":102526,"modified_method":"public TopChildrenQuery(SearchContext searchContext, Query childQuery, String childType, String parentType, ScoreType scoreType, int factor, int incrementalFactor) {\n        this.searchContext = searchContext;\n        this.originalChildQuery = childQuery;\n        this.childType = childType;\n        this.parentType = parentType;\n        this.scoreType = scoreType;\n        this.factor = factor;\n        this.incrementalFactor = incrementalFactor;\n    }","commit_id":"19295280d9fff07cbfa05e367681105f6291bed9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void execute(SNode node) {\n    if (SNodeOperations.isInstanceOf(((SNode)this.getField(\"methodCall\")[0]), \"jetbrains.mps.baseLanguage.structure.ClassCreator\") && SNodeOperations.isInstanceOf(((SNode)this.getField(\"classifier\")[0]), \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n      SNode constructorCall = ((SNode)this.getField(\"methodCall\")[0]);\n      SNode classConcept = ((SNode)this.getField(\"classifier\")[0]);\n      List<SNode> list = SLinkOperations.getTargets(classConcept, \"constructor\", true);\n      for(SNode constructorDeclaration : list) {\n        if (SLinkOperations.getCount(constructorDeclaration, \"parameter\") == SLinkOperations.getCount(constructorCall, \"actualArgument\")) {\n          boolean good = true;\n          List<SNode> parameterTypes = ResolveUtil.parameterTypes(SLinkOperations.getTarget(constructorCall, \"baseMethodDeclaration\", false), TypeChecker.getInstance().getTypeOf(constructorCall), ((SNode)this.getField(\"classifier\")[0]));\n          {\n            SNode parameter;\n            SNode argument;\n            Iterator<SNode> parameter_iterator = parameterTypes.iterator();\n            Iterator<SNode> argument_iterator = SLinkOperations.getTargets(constructorCall, \"actualArgument\", true).iterator();\n            while (true) {\n              if (!(parameter_iterator.hasNext())) {\n                break;\n              }\n              if (!(argument_iterator.hasNext())) {\n                break;\n              }\n              parameter = parameter_iterator.next();\n              argument = argument_iterator.next();\n              if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument), SLinkOperations.getTarget(parameter, \"type\", true)))) {\n                good = false;\n                break;\n              }\n            }\n          }\n          if (good) {\n            SLinkOperations.setTarget(constructorCall, \"baseMethodDeclaration\", constructorDeclaration, false);\n            return;\n          }\n        }\n      }\n    } else\n    {\n      SNode instanceType = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(SNodeOperations.getParent(((SNode)this.getField(\"methodCall\")[0])), \"operand\", true));\n      ClassifierAndSuperClassifiersScope scope = new ClassifierAndSuperClassifiersScope((Classifier)((Classifier)SNodeOperations.getAdapter(SLinkOperations.getTarget(instanceType, \"classifier\", false))));\n      List<BaseMethodDeclaration> list = scope.getMethodsByName(SPropertyOperations.getString(SLinkOperations.getTarget(((SNode)this.getField(\"methodCall\")[0]), \"baseMethodDeclaration\", false), \"name\"));\n      for(BaseMethodDeclaration object : list) {\n        INodeAdapter adapter = (INodeAdapter)object;\n        SNode baseMethodDeclaration = ((SNode)adapter.getNode());\n        if (SLinkOperations.getCount(baseMethodDeclaration, \"parameter\") == SLinkOperations.getCount(((SNode)this.getField(\"methodCall\")[0]), \"actualArgument\")) {\n          boolean good = true;\n          List<SNode> parameterTypes = ResolveUtil.parameterTypes(baseMethodDeclaration, instanceType, ((SNode)this.getField(\"classifier\")[0]));\n          {\n            SNode parameterType;\n            SNode argument;\n            Iterator<SNode> parameterType_iterator = parameterTypes.iterator();\n            Iterator<SNode> argument_iterator = SLinkOperations.getTargets(((SNode)this.getField(\"methodCall\")[0]), \"actualArgument\", true).iterator();\n            while (true) {\n              if (!(parameterType_iterator.hasNext())) {\n                break;\n              }\n              if (!(argument_iterator.hasNext())) {\n                break;\n              }\n              parameterType = parameterType_iterator.next();\n              argument = argument_iterator.next();\n              if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument), parameterType))) {\n                good = false;\n                break;\n              }\n            }\n          }\n          if (good) {\n            SLinkOperations.setTarget(((SNode)this.getField(\"methodCall\")[0]), \"baseMethodDeclaration\", baseMethodDeclaration, false);\n            return;\n          }\n        }\n      }\n    }\n  }","id":102527,"modified_method":"public void execute(SNode node) {\n    if (SNodeOperations.isInstanceOf(((SNode)this.getField(\"methodCall\")[0]), \"jetbrains.mps.baseLanguage.structure.ClassCreator\") && SNodeOperations.isInstanceOf(((SNode)this.getField(\"classifier\")[0]), \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n      SNode constructorCall = ((SNode)this.getField(\"methodCall\")[0]);\n      SNode classConcept = ((SNode)this.getField(\"classifier\")[0]);\n      List<SNode> list = SLinkOperations.getTargets(classConcept, \"constructor\", true);\n      for(SNode constructorDeclaration : list) {\n        if (SLinkOperations.getCount(constructorDeclaration, \"parameter\") == SLinkOperations.getCount(constructorCall, \"actualArgument\")) {\n          boolean good = true;\n          List<SNode> parameterTypes = ResolveUtil.parameterTypes(SLinkOperations.getTarget(constructorCall, \"baseMethodDeclaration\", false), TypeChecker.getInstance().getTypeOf(constructorCall), ((SNode)this.getField(\"classifier\")[0]));\n          {\n            SNode parameter;\n            SNode argument;\n            Iterator<SNode> parameter_iterator = parameterTypes.iterator();\n            Iterator<SNode> argument_iterator = SLinkOperations.getTargets(constructorCall, \"actualArgument\", true).iterator();\n            while (true) {\n              if (!(parameter_iterator.hasNext())) {\n                break;\n              }\n              if (!(argument_iterator.hasNext())) {\n                break;\n              }\n              parameter = parameter_iterator.next();\n              argument = argument_iterator.next();\n              if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument), SLinkOperations.getTarget(parameter, \"type\", true)))) {\n                good = false;\n                break;\n              }\n            }\n          }\n          if (good) {\n            SLinkOperations.setTarget(constructorCall, \"baseMethodDeclaration\", constructorDeclaration, false);\n            return;\n          }\n        }\n      }\n    } else\n    {\n      SNode instanceType = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(SNodeOperations.getParent(((SNode)this.getField(\"methodCall\")[0])), \"operand\", true));\n      ClassifierAndSuperClassifiersScope scope = new ClassifierAndSuperClassifiersScope((Classifier)((Classifier)SNodeOperations.getAdapter(SLinkOperations.getTarget(instanceType, \"classifier\", false))));\n      List list = scope.getMethodsByName(SPropertyOperations.getString(SLinkOperations.getTarget(((SNode)this.getField(\"methodCall\")[0]), \"baseMethodDeclaration\", false), \"name\"));\n      for(Object object : list) {\n        INodeAdapter adapter = (INodeAdapter)object;\n        SNode baseMethodDeclaration = ((SNode)adapter.getNode());\n        if (SLinkOperations.getCount(baseMethodDeclaration, \"parameter\") == SLinkOperations.getCount(((SNode)this.getField(\"methodCall\")[0]), \"actualArgument\")) {\n          boolean good = true;\n          List<SNode> parameterTypes = ResolveUtil.parameterTypes(baseMethodDeclaration, instanceType, ((SNode)this.getField(\"classifier\")[0]));\n          {\n            SNode parameterType;\n            SNode argument;\n            Iterator<SNode> parameterType_iterator = parameterTypes.iterator();\n            Iterator<SNode> argument_iterator = SLinkOperations.getTargets(((SNode)this.getField(\"methodCall\")[0]), \"actualArgument\", true).iterator();\n            while (true) {\n              if (!(parameterType_iterator.hasNext())) {\n                break;\n              }\n              if (!(argument_iterator.hasNext())) {\n                break;\n              }\n              parameterType = parameterType_iterator.next();\n              argument = argument_iterator.next();\n              if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument), parameterType))) {\n                good = false;\n                break;\n              }\n            }\n          }\n          if (good) {\n            SLinkOperations.setTarget(((SNode)this.getField(\"methodCall\")[0]), \"baseMethodDeclaration\", baseMethodDeclaration, false);\n            return;\n          }\n        }\n      }\n    }\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean virtual_isSupersetOf_1220438914705(SNode thisNode, SNode t) {\n    if (SNodeOperations.isInstanceOf(t, \"jetbrains.mps.baseLanguage.structure.WildCardType\")) {\n      do {\n        SNode matchedNode_0 = thisNode;\n        {\n          boolean matches_0 = false;\n          _Patterns.Pattern_0 matchingPattern = new _Patterns.Pattern_0();\n          matches_0 = matchingPattern.match(matchedNode_0);\n          if (matches_0) {\n            return true;\n          }\n        }\n        return false;\n      } while(false);\n    }\n    {\n      _Patterns.Pattern_1 pattern_0 = new _Patterns.Pattern_1();\n      SNode coercedNode_0 = TypeChecker.getInstance().getRuntimeSupport().coerce_(t, pattern_0);\n      if (coercedNode_0 != null) {\n        {\n          SNode typeParam;\n          SNode myParam;\n          Iterator<SNode> typeParam_iterator = pattern_0.PatternVar0.iterator();\n          Iterator<SNode> myParam_iterator = SLinkOperations.getTargets(thisNode, \"parameter\", true).iterator();\n          while (true) {\n            if (!(typeParam_iterator.hasNext())) {\n              break;\n            }\n            if (!(myParam_iterator.hasNext())) {\n              break;\n            }\n            typeParam = typeParam_iterator.next();\n            myParam = myParam_iterator.next();\n            if (SNodeOperations.isInstanceOf(myParam, \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(myParam, \"jetbrains.mps.baseLanguage.structure.UpperBoundType\")) {\n              if (!(Type_Behavior.call_isSupersetOf_1220438914705(myParam, typeParam))) {\n                return false;\n              }\n            } else\n            {\n              if (!(MatchingUtil.matchNodes(myParam, typeParam))) {\n                return false;\n              }\n            }\n          }\n        }\n        return true;\n      } else\n      {\n      }\n    }\n    return Type_Behavior.callSuper_isSupersetOf_1220438914705(thisNode, \"jetbrains.mps.baseLanguage.structure.ClassifierType\", t);\n  }","id":102528,"modified_method":"public static boolean virtual_isSupersetOf_1220438914705(SNode thisNode, SNode t) {\n    if (SNodeOperations.isInstanceOf(t, \"jetbrains.mps.baseLanguage.structure.WildCardType\")) {\n      do {\n        SNode matchedNode_0 = thisNode;\n        {\n          boolean matches_0 = false;\n          _Patterns.Pattern_0 matchingPattern = new _Patterns.Pattern_0();\n          matches_0 = matchingPattern.match(matchedNode_0);\n          if (matches_0) {\n            return true;\n          }\n        }\n        return false;\n      } while(false);\n    }\n    {\n      _Patterns.Pattern_1 pattern_0 = new _Patterns.Pattern_1(SLinkOperations.getTarget(thisNode, \"classifier\", false));\n      SNode coercedNode_0 = TypeChecker.getInstance().getRuntimeSupport().coerce_(t, pattern_0);\n      if (coercedNode_0 != null) {\n        {\n          SNode typeParam;\n          SNode myParam;\n          Iterator<SNode> typeParam_iterator = pattern_0.PatternVar0.iterator();\n          Iterator<SNode> myParam_iterator = SLinkOperations.getTargets(thisNode, \"parameter\", true).iterator();\n          while (true) {\n            if (!(typeParam_iterator.hasNext())) {\n              break;\n            }\n            if (!(myParam_iterator.hasNext())) {\n              break;\n            }\n            typeParam = typeParam_iterator.next();\n            myParam = myParam_iterator.next();\n            if (SNodeOperations.isInstanceOf(myParam, \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(myParam, \"jetbrains.mps.baseLanguage.structure.UpperBoundType\")) {\n              if (!(Type_Behavior.call_isSupersetOf_1220438914705(myParam, typeParam))) {\n                return false;\n              }\n            } else\n            {\n              if (!(MatchingUtil.matchNodes(myParam, typeParam))) {\n                return false;\n              }\n            }\n          }\n        }\n        return true;\n      } else\n      {\n      }\n    }\n    return Type_Behavior.callSuper_isSupersetOf_1220438914705(thisNode, \"jetbrains.mps.baseLanguage.structure.ClassifierType\", t);\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void execute_internal(final KeyEvent keyEvent, final EditorContext editorContext, final SNode node, final List<SNode> selectedNodes) {\n      SNode method = SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", true, false);\n      SNode declClassifier = SNodeOperations.getAncestor(method, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n      if ((declClassifier != null)) {\n        ClassifierAndSuperClassifiersScope scope = new ClassifierAndSuperClassifiersScope(((Classifier)SNodeOperations.getAdapter(declClassifier)), IClassifiersSearchScope.INSTANCE_METHOD);\n        List<BaseMethodDeclaration> list = scope.getOverriddenMethods(((InstanceMethodDeclaration)SNodeOperations.getAdapter(method)));\n        if (ListSequence.fromList(list).count() > 0) {\n          SNode overriden = ((SNode)ListSequence.fromList(list).getElement(0).getNode());\n          editorContext.getOperationContext().getComponent(MPSEditorOpener.class).openNode(overriden);\n        }\n      }\n    }","id":102529,"modified_method":"private void execute_internal(final KeyEvent keyEvent, final EditorContext editorContext, final SNode node, final List<SNode> selectedNodes) {\n      SNode method = SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", true, false);\n      SNode declClassifier = SNodeOperations.getAncestor(method, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n      if ((declClassifier != null)) {\n        ClassifierAndSuperClassifiersScope scope = new ClassifierAndSuperClassifiersScope(((Classifier)SNodeOperations.getAdapter(declClassifier)), IClassifiersSearchScope.INSTANCE_METHOD);\n        List<BaseMethodDeclaration> list = scope.getOverriddenMethods(((InstanceMethodDeclaration)SNodeOperations.getAdapter(method)));\n        if (list.size() > 0) {\n          SNode overriden = ((SNode)list.get(0).getNode());\n          editorContext.getOperationContext().getComponent(MPSEditorOpener.class).openNode(overriden);\n        }\n      }\n    }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MigrationToCollections_MigrationScript(IOperationContext operationContext) {\n    super(\"Migration from List to collections\");\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"ListMigration\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"ListMigration\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.ClassifierType\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#java.util(java.util@java_stub)\", \"~List\") || SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#java.util(java.util@java_stub)\", \"~ArrayList\") || SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#java.util(java.util@java_stub)\", \"~LinkedList\");\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.ListType\", null);\n        if (ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).count() > 0) {\n          SLinkOperations.setTarget(result, \"elementType\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).first()), true);\n        } else\n        {\n          SNode type = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ClassifierType\", null);\n          SLinkOperations.setTarget(type, \"classifier\", SNodeOperations.getNode(\"f:java_stub#java.lang(java.lang@java_stub)\", \"~Object\"), false);\n          SLinkOperations.setTarget(result, \"elementType\", type, true);\n        }\n        SNodeOperations.replaceWithAnother(node, result);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"ArrayList\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"ArrayList\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.ClassCreator\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).count() == 0 && SNodeOperations.getParent(SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false)) == SNodeOperations.getNode(\"f:java_stub#java.util(java.util@java_stub)\", \"~ArrayList\");\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.ListCreatorWithInit\", null);\n        SLinkOperations.setTarget(result, \"elementType\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"typeParameter\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, result);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Size \";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Size \";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_15().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.GetSizeOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Get\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Get\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_16().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode access = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.ListElementAccessExpression\", null);\n        SLinkOperations.setTarget(access, \"list\", SLinkOperations.getTarget(SNodeOperations.getParent(node), \"operand\", true), true);\n        SLinkOperations.setTarget(access, \"index\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(SNodeOperations.getParent(node), access);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Clear\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Clear\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_17().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.ClearAllElementsOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Add first\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Add first\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        ArrayList arrayList;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_18().createNode(), \"operation\", true), \"baseMethodDeclaration\", false) || SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_19().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode opration = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddElementOperation\", null);\n        SLinkOperations.setTarget(opration, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, opration);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Add element\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Add element\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_20().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.InsertElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"index\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SLinkOperations.setTarget(operation, \"element\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).last()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"isEmpty\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"isEmpty\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        LinkedList l2;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_21().createNode(), \"operation\", true), \"baseMethodDeclaration\", false) || SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_22().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.IsEmptyOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"set\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"set\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_23().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.SetElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"index\", SNodeOperations.copyNode(ListSequence.fromList(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).toListSequence()).getElement(0)), true);\n        SLinkOperations.setTarget(operation, \"element\", SNodeOperations.copyNode(ListSequence.fromList(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).toListSequence()).getElement(1)), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"removeObject\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"removeObject\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_24().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.RemoveElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"indexOf\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"indexOf\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_25().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.GetIndexOfOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"addAll\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"addAll\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_26().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddAllElementsOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"addFirst\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"addFirst\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        LinkedList l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_27().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddFirstElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"addLast\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"addLast\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        LinkedList l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_28().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddLastElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"removeFirst\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"removeFirst\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        LinkedList l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_29().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.RemoveFirstElementOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n  }","id":102530,"modified_method":"public MigrationToCollections_MigrationScript(IOperationContext operationContext) {\n    super(\"Migration from List to collections\");\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"ListMigration\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"ListMigration\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.ClassifierType\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#java.util(java.util@java_stub)\", \"~List\") || SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#java.util(java.util@java_stub)\", \"~ArrayList\") || SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#java.util(java.util@java_stub)\", \"~LinkedList\");\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.ListType\", null);\n        SLinkOperations.setTarget(result, \"elementType\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, result);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Size \";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Size \";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_15().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.GetSizeOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Get\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Get\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_16().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode access = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.ListElementAccessExpression\", null);\n        SLinkOperations.setTarget(access, \"list\", SLinkOperations.getTarget(SNodeOperations.getParent(node), \"operand\", true), true);\n        SLinkOperations.setTarget(access, \"index\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(SNodeOperations.getParent(node), access);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Clear\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Clear\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_17().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.ClearAllElementsOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Add first\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Add first\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_18().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode opration = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddElementOperation\", null);\n        SLinkOperations.setTarget(opration, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, opration);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Add element\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Add element\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_19().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.InsertElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"index\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SLinkOperations.setTarget(operation, \"element\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).last()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"isEmpty\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"isEmpty\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        LinkedList l2;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_20().createNode(), \"operation\", true), \"baseMethodDeclaration\", false) || SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_21().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.IsEmptyOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"set\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"set\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_22().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.SetElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"index\", SNodeOperations.copyNode(ListSequence.fromList(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).toListSequence()).getElement(0)), true);\n        SLinkOperations.setTarget(operation, \"element\", SNodeOperations.copyNode(ListSequence.fromList(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).toListSequence()).getElement(1)), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"remove\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"remove\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_23().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.RemoveAtElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"index\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"removeObject\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"removeObject\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_24().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.RemoveElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"indexOf\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"indexOf\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_25().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.GetIndexOfOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"addAll\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"addAll\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_26().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddAllElementsOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"addFirst\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"addFirst\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        LinkedList l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_27().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddFirstElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"addLast\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"addLast\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        LinkedList l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_28().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddLastElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"removeFirst\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"removeFirst\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        LinkedList l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_29().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.RemoveFirstElementOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getSubOrSuperTypes(SNode arrayType) {\n    // see JLS 3.0\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(arrayType, \"componentType\", true), \"jetbrains.mps.baseLanguage.structure.PrimitiveType\")) {\n      return CollectionUtil.list(new _Quotations.QuotationClass_82().createNode(), new _Quotations.QuotationClass_83().createNode(), new _Quotations.QuotationClass_84().createNode());\n    }\n    return ListSequence.<SNode>fromArray();\n  }","id":102531,"modified_method":"public List<SNode> getSubOrSuperTypes(SNode arrayType) {\n    // see JLS 3.0\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(arrayType, \"componentType\", true), \"jetbrains.mps.baseLanguage.structure.PrimitiveType\")) {\n      return CollectionUtil.list(new _Quotations.QuotationClass_82().createNode(), new _Quotations.QuotationClass_83().createNode(), new _Quotations.QuotationClass_84().createNode());\n    }\n    return new ArrayList<SNode>();\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> parameterTypes(SNode method, SNode instanceType, SNode classifier) {\n    List<SNode> result = new LinkedList<SNode>();\n    boolean containsVars = false;\n    for(SNode parameter : SLinkOperations.getTargets(method, \"parameter\", true)) {\n      if (ListSequence.fromList(SNodeOperations.getDescendants(parameter, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", true)).isNotEmpty()) {\n        containsVars = true;\n      }\n      ListSequence.fromList(result).addElement(SNodeOperations.copyNode(SLinkOperations.getTarget(parameter, \"type\", true)));\n    }\n    if (!(containsVars)) {\n      return result;\n    }\n    Set<SNode> frontier = new HashSet<SNode>();\n    frontier.add(instanceType);\n    SNode concreteMethodClassifierType = ResolveUtil.getConcreteSuperClassifierType(frontier, classifier);\n    if (concreteMethodClassifierType == null) {\n      return result;\n    }\n    List<SNode> typeParameters = ListSequence.fromList(SLinkOperations.getTargets(concreteMethodClassifierType, \"parameter\", true)).toListSequence();\n    for(SNode paramType : new ArrayList<SNode>(result)) {\n      for(SNode typeVar : SNodeOperations.getDescendants(paramType, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", true)) {\n        SNode replacement = SNodeOperations.copyNode(ListSequence.fromList(typeParameters).getElement(SNodeOperations.getIndexInParent(SLinkOperations.getTarget(typeVar, \"typeVariableDeclaration\", false))));\n        if ((SNodeOperations.getParent(typeVar) == null)) {\n          ListSequence.fromList(result).insertElement(ListSequence.fromList(result).indexOf(typeVar), replacement);\n          ListSequence.fromList(result).removeElement(typeVar);\n        } else\n        {\n          SNodeOperations.replaceWithAnother(typeVar, replacement);\n        }\n      }\n    }\n    return result;\n  }","id":102532,"modified_method":"public static List<SNode> parameterTypes(SNode method, SNode instanceType, SNode classifier) {\n    List<SNode> result = new LinkedList<SNode>();\n    boolean containsVars = false;\n    for(SNode parameter : SLinkOperations.getTargets(method, \"parameter\", true)) {\n      if (ListSequence.fromList(SNodeOperations.getDescendants(parameter, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", true)).isNotEmpty()) {\n        containsVars = true;\n      }\n      result.add(SNodeOperations.copyNode(SLinkOperations.getTarget(parameter, \"type\", true)));\n    }\n    if (!(containsVars)) {\n      return result;\n    }\n    Set<SNode> frontier = new HashSet<SNode>();\n    frontier.add(instanceType);\n    SNode concreteMethodClassifierType = ResolveUtil.getConcreteSuperClassifierType(frontier, classifier);\n    if (concreteMethodClassifierType == null) {\n      return result;\n    }\n    List<SNode> typeParameters = ListSequence.fromList(SLinkOperations.getTargets(concreteMethodClassifierType, \"parameter\", true)).toListSequence();\n    for(SNode paramType : new ArrayList<SNode>(result)) {\n      for(SNode typeVar : SNodeOperations.getDescendants(paramType, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", true)) {\n        SNode replacement = SNodeOperations.copyNode(ListSequence.fromList(typeParameters).getElement(SNodeOperations.getIndexInParent(SLinkOperations.getTarget(typeVar, \"typeVariableDeclaration\", false))));\n        if ((SNodeOperations.getParent(typeVar) == null)) {\n          result.add(result.indexOf(typeVar), replacement);\n          result.remove(typeVar);\n        } else\n        {\n          SNodeOperations.replaceWithAnother(typeVar, replacement);\n        }\n      }\n    }\n    return result;\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"@CheckingMethod()\n  /* package */static void check(final TypeCheckingContext typeCheckingContext, Set<SNode> throwables, SNode mainNode) {\n    for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n      if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, new _Quotations.QuotationClass_29().createNode(typeCheckingContext)) || TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, new _Quotations.QuotationClass_28().createNode(typeCheckingContext))) {\n        throwables.remove(livingThrowable);\n      }\n    }\n    if (throwables.isEmpty()) {\n      return;\n    }\n    List<SNode> statementLists = SNodeOperations.getAncestors(mainNode, \"jetbrains.mps.baseLanguage.structure.StatementList\", false);\n    for(SNode statementList : statementLists) {\n      SNode parent = SNodeOperations.getParent(statementList);\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.TryStatement\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode tryStatement = parent;\n        for(SNode catchClause : SLinkOperations.getTargets(tryStatement, \"catchClause\", true)) {\n          SNode throwableType = SLinkOperations.getTarget(SLinkOperations.getTarget(catchClause, \"throwable\", true), \"type\", true);\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n      }\n      if (throwables.isEmpty()) {\n        return;\n      }\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.TryCatchStatement\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode tryCatchStatement = parent;\n        for(SNode catchClause : SLinkOperations.getTargets(tryCatchStatement, \"catchClause\", true)) {\n          SNode throwableType = SLinkOperations.getTarget(SLinkOperations.getTarget(catchClause, \"throwable\", true), \"type\", true);\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n      }\n      if (throwables.isEmpty()) {\n        return;\n      }\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode baseMethodDeclaration = parent;\n        for(SNode throwableType : SLinkOperations.getTargets(baseMethodDeclaration, \"throwsItem\", true)) {\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n        if (!(throwables.isEmpty())) {\n          String errorString = \"uncaught exceptions:\";\n          for(SNode exc : throwables) {\n            errorString = errorString + \" \" + exc;\n          }\n          {\n            BaseIntentionProvider intentionProvider = null;\n            intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).AddExceptionToMethodSignature_QuickFix\", false);\n            intentionProvider.putArgument(\"throwableType\", throwables.iterator().next());\n            IErrorTarget errorTarget = new NodeErrorTarget();\n            typeCheckingContext.reportTypeError(mainNode, errorString, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1210182111558\", intentionProvider, errorTarget);\n          }\n        }\n        return;\n      }\n    }\n  }","id":102533,"modified_method":"@CheckingMethod()\n  /* package */static void check(final TypeCheckingContext typeCheckingContext, Set<SNode> throwables, SNode mainNode) {\n    for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n      if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, new _Quotations.QuotationClass_29().createNode(typeCheckingContext)) || TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, new _Quotations.QuotationClass_28().createNode(typeCheckingContext))) {\n        throwables.remove(livingThrowable);\n      }\n    }\n    if (throwables.isEmpty()) {\n      return;\n    }\n    List<SNode> statementLists = SNodeOperations.getAncestors(mainNode, \"jetbrains.mps.baseLanguage.structure.StatementList\", false);\n    for(SNode statementList : statementLists) {\n      SNode parent = SNodeOperations.getParent(statementList);\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.TryStatement\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode tryStatement = parent;\n        for(SNode catchClause : SLinkOperations.getTargets(tryStatement, \"catchClause\", true)) {\n          SNode throwableType = SLinkOperations.getTarget(SLinkOperations.getTarget(catchClause, \"throwable\", true), \"type\", true);\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n      }\n      if (throwables.isEmpty()) {\n        return;\n      }\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.TryCatchStatement\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode tryCatchStatement = parent;\n        for(SNode catchClause : SLinkOperations.getTargets(tryCatchStatement, \"catchClause\", true)) {\n          SNode throwableType = SLinkOperations.getTarget(SLinkOperations.getTarget(catchClause, \"throwable\", true), \"type\", true);\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n      }\n      if (throwables.isEmpty()) {\n        return;\n      }\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode baseMethodDeclaration = parent;\n        for(SNode throwableType : SLinkOperations.getTargets(baseMethodDeclaration, \"throwsItem\", true)) {\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n        if (!(throwables.isEmpty())) {\n          String errorString = \"uncaught exceptions:\";\n          for(SNode exc : throwables) {\n            errorString = errorString + \" \" + exc;\n          }\n          {\n            BaseIntentionProvider intentionProvider = null;\n            intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).AddExceptionToMethodSignature_QuickFix\", false);\n            intentionProvider.putArgument(\"throwableType\", throwables.iterator().next());\n            IErrorTarget errorTarget = new NodeErrorTarget();\n            typeCheckingContext.reportTypeError(mainNode, errorString, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1210182111558\", intentionProvider, errorTarget);\n          }\n        }\n        return;\n      }\n    }\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"@InferenceMethod()\n  public static void inference_matchConcreteTypesWithTypeVariables(final TypeCheckingContext typeCheckingContext, SNode genericClassifier, SNode instanceType, Map<SNode, List<SNode>> mmap) {\n    if ((genericClassifier != null) && mmap != null && !(mmap.isEmpty())) {\n      List<SNode> params = ListSequence.<SNode>fromArray();\n      for(SNode tvd : SLinkOperations.getTargets(genericClassifier, \"typeVariableDeclaration\", true)) {\n        List<SNode> nodes = mmap.get(tvd);\n        final SNode p_typevar_1228174472023 = typeCheckingContext.createNewRuntimeTypesVariable();\n        if (nodes != null) {\n          SNode tvar = ListSequence.fromList(nodes).getElement(0);\n          if (TRACE_METHOD_TYPES) {\n            System.out.println(\"-2- \" + BaseConcept_Behavior.call_getPresentation_1213877396640(tvar) + \" :==: \" + BaseConcept_Behavior.call_getPresentation_1213877396640(ListSequence.fromList(nodes).getElement(0)));\n          }\n          {\n            SNode _nodeToCheck_1029348928467 = null;\n            BaseIntentionProvider intentionProvider = null;\n            typeCheckingContext.createEquation(tvar, typeCheckingContext.getEquationManager().getRepresentator(p_typevar_1228174472023), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1228174300650\", intentionProvider);\n          }\n        }\n        ListSequence.fromList(params).addElement(typeCheckingContext.getEquationManager().getRepresentator(p_typevar_1228174472023));\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = null;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createLessThanInequation(instanceType, new _Quotations.QuotationClass_27().createNode(params, genericClassifier, typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1228174029908\", false, 0, intentionProvider);\n      }\n    }\n  }","id":102534,"modified_method":"@InferenceMethod()\n  public static void inference_matchConcreteTypesWithTypeVariables(final TypeCheckingContext typeCheckingContext, SNode genericClassifier, SNode instanceType, Map<SNode, List<SNode>> mmap) {\n    if ((genericClassifier != null) && mmap != null && !(mmap.isEmpty())) {\n      List<SNode> params = new ArrayList<SNode>();\n      for(SNode tvd : SLinkOperations.getTargets(genericClassifier, \"typeVariableDeclaration\", true)) {\n        List<SNode> nodes = mmap.get(tvd);\n        final SNode p_typevar_1228174472023 = typeCheckingContext.createNewRuntimeTypesVariable();\n        if (nodes != null) {\n          SNode tvar = ListSequence.fromList(nodes).getElement(0);\n          if (TRACE_METHOD_TYPES) {\n            System.out.println(\"-2- \" + BaseConcept_Behavior.call_getPresentation_1213877396640(tvar) + \" :==: \" + BaseConcept_Behavior.call_getPresentation_1213877396640(ListSequence.fromList(nodes).getElement(0)));\n          }\n          {\n            SNode _nodeToCheck_1029348928467 = null;\n            BaseIntentionProvider intentionProvider = null;\n            typeCheckingContext.createEquation(tvar, typeCheckingContext.getEquationManager().getRepresentator(p_typevar_1228174472023), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1228174300650\", intentionProvider);\n          }\n        }\n        ListSequence.fromList(params).addElement(typeCheckingContext.getEquationManager().getRepresentator(p_typevar_1228174472023));\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = null;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createLessThanInequation(instanceType, new _Quotations.QuotationClass_27().createNode(params, genericClassifier, typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1228174029908\", false, 0, intentionProvider);\n      }\n    }\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"@InferenceMethod()\n  public static void inference_equateParametersAndReturnType(final TypeCheckingContext typeCheckingContext, final SNode mc, SNode returnType, Map<SNode, List<SNode>> mmap) {\n    List<SNode> parameterDeclarations = SLinkOperations.getTargets(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"parameter\", true);\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(parameterDeclarations).last(), \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n      Iterator<SNode> formalIterator = ((List<SNode>)parameterDeclarations).iterator();\n      Iterator<SNode> actualIterator = SLinkOperations.getTargets(mc, \"actualArgument\", true).iterator();\n      SNode formalParam = null;\n      SNode actualParam = null;\n      while (true) {\n        if (!(actualIterator.hasNext())) {\n          break;\n        }\n        if (!(formalIterator.hasNext())) {\n          break;\n        }\n        formalParam = formalIterator.next();\n        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(formalParam, \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n          break;\n        }\n        actualParam = actualIterator.next();\n        SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, SLinkOperations.getTarget(formalParam, \"type\", true), mmap);\n        {\n          SNode _nodeToCheck_1029348928467 = actualParam;\n          BaseIntentionProvider intentionProvider = null;\n          intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n          intentionProvider.putArgument(\"methodCall\", mc);\n          intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n          typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(actualParam, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947530380\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947530376\", false, 2, intentionProvider);\n        }\n      }\n      do {\n        SNode matchedNode_3 = SLinkOperations.getTarget(formalParam, \"type\", true);\n        {\n          boolean matches_3 = false;\n          {\n            SNode matchingNode_3 = SLinkOperations.getTarget(formalParam, \"type\", true);\n            if (matchingNode_3 != null) {\n              matches_3 = SModelUtil_new.isAssignableConcept(matchingNode_3.getConceptFqName(), \"jetbrains.mps.baseLanguage.structure.VariableArityType\");\n            }\n          }\n          if (matches_3) {\n            {\n              SNode componentType = SLinkOperations.getTarget(matchedNode_3, \"componentType\", true);\n              final SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, componentType, mmap);\n              if (SLinkOperations.getCount(mc, \"actualArgument\") == ListSequence.fromList(parameterDeclarations).count()) {\n                // the actual parameter may appear to be an array instead of vararg\n                final SNode actual = actualIterator.next();\n                {\n                  final SNode actualType = typeCheckingContext.typeOf(actual, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347108709\", true);\n                  typeCheckingContext.whenConcrete(actualType, new Runnable() {\n\n                    public void run() {\n                      if (SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(actualType), \"jetbrains.mps.baseLanguage.structure.ArrayType\")) {\n                        {\n                          SNode _nodeToCheck_1029348928467 = actual;\n                          BaseIntentionProvider intentionProvider = null;\n                          intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                          intentionProvider.putArgument(\"methodCall\", mc);\n                          intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                          typeCheckingContext.createLessThanInequation(SLinkOperations.getTarget(typeCheckingContext.getEquationManager().getRepresentator(actualType), \"componentType\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347279318\", false, 2, intentionProvider);\n                        }\n                      } else\n                      {\n                        SNode _nodeToCheck_1029348928467 = actual;\n                        BaseIntentionProvider intentionProvider = null;\n                        intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                        intentionProvider.putArgument(\"methodCall\", mc);\n                        intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                        typeCheckingContext.createLessThanInequation(typeCheckingContext.getEquationManager().getRepresentator(actualType), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347200873\", false, 2, intentionProvider);\n                      }\n                    }\n\n                  }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347102532\", false, false);\n                }\n              } else\n              {\n                // in this case the actual parameter is definitely a vararg\n                while (actualIterator.hasNext()) {\n                  SNode actual = actualIterator.next();\n                  {\n                    SNode _nodeToCheck_1029348928467 = actual;\n                    BaseIntentionProvider intentionProvider = null;\n                    intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                    intentionProvider.putArgument(\"methodCall\", mc);\n                    intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                    typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(actual, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947702426\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947702422\", false, 2, intentionProvider);\n                  }\n                }\n              }\n            }\n            break;\n          }\n        }\n      } while(false);\n    } else\n    {\n      {\n        SNode arg;\n        SNode param;\n        Iterator<SNode> arg_iterator = SLinkOperations.getTargets(mc, \"actualArgument\", true).iterator();\n        Iterator<SNode> param_iterator = SLinkOperations.getTargets(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"parameter\", true).iterator();\n        while (true) {\n          if (!(arg_iterator.hasNext())) {\n            break;\n          }\n          if (!(param_iterator.hasNext())) {\n            break;\n          }\n          arg = arg_iterator.next();\n          param = param_iterator.next();\n          {\n            SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, SLinkOperations.getTarget(param, \"type\", true), mmap);\n            {\n              SNode _nodeToCheck_1029348928467 = arg;\n              BaseIntentionProvider intentionProvider = null;\n              intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n              intentionProvider.putArgument(\"methodCall\", mc);\n              intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n              typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(arg, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371331\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371327\", false, 2, intentionProvider);\n            }\n          }\n        }\n      }\n    }\n    if (returnType != null) {\n      SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, returnType, mmap);\n      {\n        SNode _nodeToCheck_1029348928467 = null;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.typeOf(mc, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371361\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371359\", intentionProvider);\n      }\n    }\n  }","id":102535,"modified_method":"@InferenceMethod()\n  public static void inference_equateParametersAndReturnType(final TypeCheckingContext typeCheckingContext, final SNode mc, SNode returnType, Map<SNode, List<SNode>> mmap) {\n    List<SNode> parameterDeclarations = SLinkOperations.getTargets(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"parameter\", true);\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(parameterDeclarations).last(), \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n      Iterator<SNode> formalIterator = ((List<SNode>)parameterDeclarations).iterator();\n      Iterator<SNode> actualIterator = SLinkOperations.getTargets(mc, \"actualArgument\", true).iterator();\n      SNode formalParam = null;\n      SNode actualParam = null;\n      while (true) {\n        if (!(actualIterator.hasNext())) {\n          break;\n        }\n        if (!(formalIterator.hasNext())) {\n          break;\n        }\n        formalParam = formalIterator.next();\n        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(formalParam, \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n          break;\n        }\n        actualParam = actualIterator.next();\n        SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, SLinkOperations.getTarget(formalParam, \"type\", true), mmap);\n        {\n          SNode _nodeToCheck_1029348928467 = actualParam;\n          BaseIntentionProvider intentionProvider = null;\n          intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n          intentionProvider.putArgument(\"methodCall\", mc);\n          intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n          typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(actualParam, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947530380\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947530376\", false, 2, intentionProvider);\n        }\n      }\n      do {\n        SNode matchedNode_3 = SLinkOperations.getTarget(formalParam, \"type\", true);\n        {\n          boolean matches_3 = false;\n          {\n            SNode matchingNode_3 = SLinkOperations.getTarget(formalParam, \"type\", true);\n            if (matchingNode_3 != null) {\n              matches_3 = SModelUtil_new.isAssignableConcept(matchingNode_3.getConceptFqName(), \"jetbrains.mps.baseLanguage.structure.VariableArityType\");\n            }\n          }\n          if (matches_3) {\n            {\n              SNode componentType = SLinkOperations.getTarget(matchedNode_3, \"componentType\", true);\n              final SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, componentType, mmap);\n              if (SLinkOperations.getCount(mc, \"actualArgument\") == ListSequence.fromList(parameterDeclarations).count()) {\n                // the actual parameter may appear to be an array instead of vararg\n                final SNode actual = actualIterator.next();\n                {\n                  final SNode actualType = typeCheckingContext.typeOf(actual, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347108709\", true);\n                  typeCheckingContext.whenConcrete(actualType, new Runnable() {\n\n                    public void run() {\n                      if (SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(actualType), \"jetbrains.mps.baseLanguage.structure.ArrayType\")) {\n                        {\n                          SNode _nodeToCheck_1029348928467 = actual;\n                          BaseIntentionProvider intentionProvider = null;\n                          intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                          intentionProvider.putArgument(\"methodCall\", mc);\n                          intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                          typeCheckingContext.createLessThanInequation(SLinkOperations.getTarget(typeCheckingContext.getEquationManager().getRepresentator(actualType), \"componentType\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347279318\", false, 2, intentionProvider);\n                        }\n                      } else\n                      {\n                        SNode _nodeToCheck_1029348928467 = actual;\n                        BaseIntentionProvider intentionProvider = null;\n                        intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                        intentionProvider.putArgument(\"methodCall\", mc);\n                        intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                        typeCheckingContext.createLessThanInequation(typeCheckingContext.getEquationManager().getRepresentator(actualType), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347200873\", false, 2, intentionProvider);\n                      }\n                    }\n\n                  }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347102532\", false, false);\n                }\n              } else\n              {\n                // in this case the actual parameter is definitely a vararg\n                while (actualIterator.hasNext()) {\n                  SNode actual = actualIterator.next();\n                  {\n                    SNode _nodeToCheck_1029348928467 = actual;\n                    BaseIntentionProvider intentionProvider = null;\n                    intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                    intentionProvider.putArgument(\"methodCall\", mc);\n                    intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                    typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(actual, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947702426\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947702422\", false, 2, intentionProvider);\n                  }\n                }\n              }\n            }\n            break;\n          }\n        }\n      } while(false);\n    } else\n    {\n      {\n        SNode arg;\n        SNode param;\n        Iterator<SNode> arg_iterator = SLinkOperations.getTargets(mc, \"actualArgument\", true).iterator();\n        Iterator<SNode> param_iterator = SLinkOperations.getTargets(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"parameter\", true).iterator();\n        while (true) {\n          if (!(arg_iterator.hasNext())) {\n            break;\n          }\n          if (!(param_iterator.hasNext())) {\n            break;\n          }\n          arg = arg_iterator.next();\n          param = param_iterator.next();\n          {\n            SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, SLinkOperations.getTarget(param, \"type\", true), mmap);\n            {\n              SNode _nodeToCheck_1029348928467 = arg;\n              BaseIntentionProvider intentionProvider = null;\n              intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n              intentionProvider.putArgument(\"methodCall\", mc);\n              intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n              typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(arg, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371331\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371327\", false, 2, intentionProvider);\n            }\n          }\n        }\n      }\n    }\n    if (returnType != null) {\n      SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, returnType, mmap);\n      {\n        SNode _nodeToCheck_1029348928467 = null;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.typeOf(mc, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371361\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371359\", intentionProvider);\n      }\n    }\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      ListSequence.fromList(SLinkOperations.getTargets(node, \"auxBounds\", true)).clear();\n      SLinkOperations.setTarget(node, \"bound\", null, true);\n    }","id":102536,"modified_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      SLinkOperations.getTargets(node, \"auxBounds\", true).clear();\n      SLinkOperations.setTarget(node, \"bound\", null, true);\n    }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode antiquotation, final TypeCheckingContext typeCheckingContext) {\n    SNode contentsType = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(antiquotation, \"expression\", true));\n    if (SNodeOperations.isInstanceOf(contentsType, \"jetbrains.mps.lang.smodel.structure.SNodeType\")) {\n      if (SConceptOperations.isSubConceptOf(SLinkOperations.getTarget(contentsType, \"concept\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\")) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ReplaceClassAntiquotationWithClassifierType_QuickFix\");\n          intentionProvider.putArgument(\"antiquotation\", antiquotation);\n          IErrorTarget errorTarget = new NodeErrorTarget();\n          typeCheckingContext.reportWarning(SLinkOperations.getTarget(antiquotation, \"expression\", true), \"Substitution of a classifier here is probably an error\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1228301999219\", intentionProvider, errorTarget);\n        }\n      }\n    }\n  }","id":102537,"modified_method":"public void applyRule(final SNode antiquotation, final TypeCheckingContext typeCheckingContext) {\n    SNode contentsType = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(antiquotation, \"expression\", true));\n    if (SNodeOperations.isInstanceOf(contentsType, \"jetbrains.mps.lang.smodel.structure.SNodeType\")) {\n      if (SConceptOperations.isSubConceptOf(SLinkOperations.getTarget(contentsType, \"concept\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\")) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ReplaceClassAntiquotationWithClassifierType_QuickFix\");\n          intentionProvider.putArgument(\"antiquotation\", antiquotation);\n          IErrorTarget errorTarget = new NodeErrorTarget();\n          typeCheckingContext.reportWarning(SLinkOperations.getTarget(antiquotation, \"expression\", true), \"Substitution of a classifier here is probably an error\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1228301999219\", intentionProvider, errorTarget);\n        }\n      }\n    }\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode iMethodCall, final TypeCheckingContext typeCheckingContext) {\n    SNode baseMethodDeclaration = SLinkOperations.getTarget(iMethodCall, \"baseMethodDeclaration\", false);\n    boolean b = true;\n    List<SNode> parameterDeclarations = SLinkOperations.getTargets(baseMethodDeclaration, \"parameter\", true);\n    List<SNode> actualArguments = SLinkOperations.getTargets(iMethodCall, \"actualArgument\", true);\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(parameterDeclarations).last(), \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n      b = ListSequence.fromList(parameterDeclarations).count() - 1 <= ListSequence.fromList(actualArguments).count();\n    } else\n    {\n      b = ListSequence.fromList(parameterDeclarations).count() == ListSequence.fromList(actualArguments).count();\n    }\n    if (!(b)) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n        intentionProvider.putArgument(\"methodCall\", iMethodCall);\n        intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(baseMethodDeclaration, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(iMethodCall, \"wrong number of parameters\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219948518456\", intentionProvider, errorTarget);\n      }\n    }\n    if (SLinkOperations.getCount(baseMethodDeclaration, \"typeVariableDeclaration\") > 0) {\n      for(SNode actual : actualArguments) {\n        typeCheckingContext.addDependencyForCurrent(actual);\n      }\n    }\n  }","id":102538,"modified_method":"public void applyRule(final SNode iMethodCall, final TypeCheckingContext typeCheckingContext) {\n    SNode baseMethodDeclaration = SLinkOperations.getTarget(iMethodCall, \"baseMethodDeclaration\", false);\n    boolean b = true;\n    List<SNode> parameterDeclarations = SLinkOperations.getTargets(baseMethodDeclaration, \"parameter\", true);\n    List<SNode> actualArguments = SLinkOperations.getTargets(iMethodCall, \"actualArgument\", true);\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(parameterDeclarations).last(), \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n      b = ListSequence.fromList(parameterDeclarations).count() - 1 <= ListSequence.fromList(actualArguments).count();\n    } else\n    {\n      b = ListSequence.fromList(parameterDeclarations).count() == ListSequence.fromList(actualArguments).count();\n    }\n    if (!(b)) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n        intentionProvider.putArgument(\"methodCall\", iMethodCall);\n        intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(baseMethodDeclaration, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(iMethodCall, \"wrong number of parameters\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219948518456\", intentionProvider, errorTarget);\n      }\n    }\n    if (SLinkOperations.getCount(baseMethodDeclaration, \"typeVariableDeclaration\") > 0) {\n      for(SNode actual : actualArguments) {\n        typeCheckingContext.addDependencyForCurrent(actual);\n      }\n    }\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void processInequation(final SNode subtype, final SNode supertype, final EquationInfo equationInfo, final TypeCheckingContext typeCheckingContext) {\n    {\n      final SNode t = subtype;\n      typeCheckingContext.whenConcrete(t, new Runnable() {\n\n        public void run() {\n          {\n            _Patterns.Pattern_9 pattern_0 = new _Patterns.Pattern_9();\n            SNode coercedNode_0 = TypeChecker.getInstance().getRuntimeSupport().coerce_(typeCheckingContext.getEquationManager().getRepresentator(t), pattern_0, typeCheckingContext);\n            if (coercedNode_0 != null) {\n              {\n                SNode typeParam;\n                SNode myParam;\n                Iterator<SNode> typeParam_iterator = SLinkOperations.getTargets(coercedNode_0, \"parameter\", true).iterator();\n                Iterator<SNode> myParam_iterator = SLinkOperations.getTargets(supertype, \"parameter\", true).iterator();\n                while (true) {\n                  if (!(typeParam_iterator.hasNext())) {\n                    break;\n                  }\n                  if (!(myParam_iterator.hasNext())) {\n                    break;\n                  }\n                  typeParam = typeParam_iterator.next();\n                  myParam = myParam_iterator.next();\n                  {\n                    final SNode finalTypeParam = typeParam;\n                    {\n                      SNode _nodeToCheck_1029348928467 = equationInfo.getNodeWithError();\n                      BaseIntentionProvider intentionProvider = null;\n                      typeCheckingContext.createLessThanInequation(finalTypeParam, myParam, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220535076789\", false, 0, intentionProvider);\n                    }\n                    {\n                      final SNode concreteParam = myParam;\n                      typeCheckingContext.whenConcrete(concreteParam, new Runnable() {\n\n                        public void run() {\n                          if (!(SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(concreteParam), \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(concreteParam), \"jetbrains.mps.baseLanguage.structure.UpperBoundType\"))) {\n                            {\n                              SNode _nodeToCheck_1029348928467 = equationInfo.getNodeWithError();\n                              BaseIntentionProvider intentionProvider = null;\n                              typeCheckingContext.createEquation(finalTypeParam, typeCheckingContext.getEquationManager().getRepresentator(concreteParam), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357903\", intentionProvider);\n                            }\n                          }\n                        }\n\n                      }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357880\", false, false);\n                    }\n                  }\n                }\n              }\n            } else\n            {\n              SNode nodeWithError = equationInfo.getNodeWithError();\n              SNode methodCall = null;\n              if (SNodeOperations.isInstanceOf(nodeWithError, \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n                methodCall = nodeWithError;\n              } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(nodeWithError), \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n                methodCall = SNodeOperations.getParent(nodeWithError);\n              }\n              if (methodCall != null) {\n                SNode classifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(methodCall, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                  intentionProvider.putArgument(\"methodCall\", methodCall);\n                  intentionProvider.putArgument(\"classifier\", classifier);\n                  IErrorTarget errorTarget = new NodeErrorTarget();\n                  typeCheckingContext.reportTypeError(nodeWithError, BaseConcept_Behavior.call_getPresentation_1213877396640(subtype) + \" is not a subtype of \" + BaseConcept_Behavior.call_getPresentation_1213877396640(supertype), \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1227259028675\", intentionProvider, errorTarget);\n                }\n              } else\n              {\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  IErrorTarget errorTarget = new NodeErrorTarget();\n                  typeCheckingContext.reportTypeError(nodeWithError, BaseConcept_Behavior.call_getPresentation_1213877396640(subtype) + \" is not a subtype of \" + BaseConcept_Behavior.call_getPresentation_1213877396640(supertype), \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357915\", intentionProvider, errorTarget);\n                }\n              }\n            }\n          }\n        }\n\n      }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357849\", false, true);\n    }\n  }","id":102539,"modified_method":"public void processInequation(final SNode subtype, final SNode supertype, final EquationInfo equationInfo, final TypeCheckingContext typeCheckingContext) {\n    {\n      final SNode t = subtype;\n      typeCheckingContext.whenConcrete(t, new Runnable() {\n\n        public void run() {\n          {\n            _Patterns.Pattern_9 pattern_0 = new _Patterns.Pattern_9(SLinkOperations.getTarget(supertype, \"classifier\", false));\n            SNode coercedNode_0 = TypeChecker.getInstance().getRuntimeSupport().coerce_(typeCheckingContext.getEquationManager().getRepresentator(t), pattern_0, typeCheckingContext);\n            if (coercedNode_0 != null) {\n              {\n                SNode typeParam;\n                SNode myParam;\n                Iterator<SNode> typeParam_iterator = SLinkOperations.getTargets(coercedNode_0, \"parameter\", true).iterator();\n                Iterator<SNode> myParam_iterator = SLinkOperations.getTargets(supertype, \"parameter\", true).iterator();\n                while (true) {\n                  if (!(typeParam_iterator.hasNext())) {\n                    break;\n                  }\n                  if (!(myParam_iterator.hasNext())) {\n                    break;\n                  }\n                  typeParam = typeParam_iterator.next();\n                  myParam = myParam_iterator.next();\n                  {\n                    final SNode finalTypeParam = typeParam;\n                    {\n                      SNode _nodeToCheck_1029348928467 = equationInfo.getNodeWithError();\n                      BaseIntentionProvider intentionProvider = null;\n                      typeCheckingContext.createLessThanInequation(finalTypeParam, myParam, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220535076789\", false, 0, intentionProvider);\n                    }\n                    {\n                      final SNode concreteParam = myParam;\n                      typeCheckingContext.whenConcrete(concreteParam, new Runnable() {\n\n                        public void run() {\n                          if (!(SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(concreteParam), \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(concreteParam), \"jetbrains.mps.baseLanguage.structure.UpperBoundType\"))) {\n                            {\n                              SNode _nodeToCheck_1029348928467 = equationInfo.getNodeWithError();\n                              BaseIntentionProvider intentionProvider = null;\n                              typeCheckingContext.createEquation(finalTypeParam, typeCheckingContext.getEquationManager().getRepresentator(concreteParam), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357903\", intentionProvider);\n                            }\n                          }\n                        }\n\n                      }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357880\", false, false);\n                    }\n                  }\n                }\n              }\n            } else\n            {\n              SNode nodeWithError = equationInfo.getNodeWithError();\n              SNode methodCall = null;\n              if (SNodeOperations.isInstanceOf(nodeWithError, \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n                methodCall = nodeWithError;\n              } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(nodeWithError), \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n                methodCall = SNodeOperations.getParent(nodeWithError);\n              }\n              if (methodCall != null) {\n                SNode classifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(methodCall, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                  intentionProvider.putArgument(\"methodCall\", methodCall);\n                  intentionProvider.putArgument(\"classifier\", classifier);\n                  IErrorTarget errorTarget = new NodeErrorTarget();\n                  typeCheckingContext.reportTypeError(nodeWithError, BaseConcept_Behavior.call_getPresentation_1213877396640(subtype) + \" is not a subtype of \" + BaseConcept_Behavior.call_getPresentation_1213877396640(supertype), \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1227259028675\", intentionProvider, errorTarget);\n                }\n              } else\n              {\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  IErrorTarget errorTarget = new NodeErrorTarget();\n                  typeCheckingContext.reportTypeError(nodeWithError, BaseConcept_Behavior.call_getPresentation_1213877396640(subtype) + \" is not a subtype of \" + BaseConcept_Behavior.call_getPresentation_1213877396640(supertype), \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357915\", intentionProvider, errorTarget);\n                }\n              }\n            }\n          }\n        }\n\n      }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357849\", false, true);\n    }\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean checkInequation(final SNode subtype, final SNode supertype, final EquationInfo equationInfo) {\n    boolean result_14532009 = true;\n    {\n      final SNode t = subtype;\n      {\n        _Patterns.Pattern_9 pattern_1 = new _Patterns.Pattern_9();\n        SNode coercedNode_1 = TypeChecker.getInstance().getRuntimeSupport().coerce_(t, pattern_1);\n        if (coercedNode_1 != null) {\n          {\n            SNode typeParam;\n            SNode myParam;\n            Iterator<SNode> typeParam_iterator = SLinkOperations.getTargets(coercedNode_1, \"parameter\", true).iterator();\n            Iterator<SNode> myParam_iterator = SLinkOperations.getTargets(supertype, \"parameter\", true).iterator();\n            while (true) {\n              if (!(typeParam_iterator.hasNext())) {\n                break;\n              }\n              if (!(myParam_iterator.hasNext())) {\n                break;\n              }\n              typeParam = typeParam_iterator.next();\n              myParam = myParam_iterator.next();\n              {\n                final SNode finalTypeParam = typeParam;\n                result_14532009 = result_14532009 && TypeChecker.getInstance().getSubtypingManager().isSubtype(finalTypeParam, myParam, true);\n                {\n                  final SNode concreteParam = myParam;\n                  if (!(SNodeOperations.isInstanceOf(concreteParam, \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(concreteParam, \"jetbrains.mps.baseLanguage.structure.UpperBoundType\"))) {\n                    result_14532009 = result_14532009 && MatchingUtil.matchNodes(finalTypeParam, concreteParam);\n                  }\n                }\n              }\n            }\n          }\n        } else\n        {\n          SNode nodeWithError = equationInfo.getNodeWithError();\n          SNode methodCall = null;\n          if (SNodeOperations.isInstanceOf(nodeWithError, \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n            methodCall = nodeWithError;\n          } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(nodeWithError), \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n            methodCall = SNodeOperations.getParent(nodeWithError);\n          }\n          if (methodCall != null) {\n            SNode classifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(methodCall, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n            result_14532009 = false;\n          } else\n          {\n            result_14532009 = false;\n          }\n        }\n      }\n    }\n    return result_14532009;\n  }","id":102540,"modified_method":"public boolean checkInequation(final SNode subtype, final SNode supertype, final EquationInfo equationInfo) {\n    boolean result_14532009 = true;\n    {\n      final SNode t = subtype;\n      {\n        _Patterns.Pattern_9 pattern_1 = new _Patterns.Pattern_9(SLinkOperations.getTarget(supertype, \"classifier\", false));\n        SNode coercedNode_1 = TypeChecker.getInstance().getRuntimeSupport().coerce_(t, pattern_1);\n        if (coercedNode_1 != null) {\n          {\n            SNode typeParam;\n            SNode myParam;\n            Iterator<SNode> typeParam_iterator = SLinkOperations.getTargets(coercedNode_1, \"parameter\", true).iterator();\n            Iterator<SNode> myParam_iterator = SLinkOperations.getTargets(supertype, \"parameter\", true).iterator();\n            while (true) {\n              if (!(typeParam_iterator.hasNext())) {\n                break;\n              }\n              if (!(myParam_iterator.hasNext())) {\n                break;\n              }\n              typeParam = typeParam_iterator.next();\n              myParam = myParam_iterator.next();\n              {\n                final SNode finalTypeParam = typeParam;\n                result_14532009 = result_14532009 && TypeChecker.getInstance().getSubtypingManager().isSubtype(finalTypeParam, myParam, true);\n                {\n                  final SNode concreteParam = myParam;\n                  if (!(SNodeOperations.isInstanceOf(concreteParam, \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(concreteParam, \"jetbrains.mps.baseLanguage.structure.UpperBoundType\"))) {\n                    result_14532009 = result_14532009 && MatchingUtil.matchNodes(finalTypeParam, concreteParam);\n                  }\n                }\n              }\n            }\n          }\n        } else\n        {\n          SNode nodeWithError = equationInfo.getNodeWithError();\n          SNode methodCall = null;\n          if (SNodeOperations.isInstanceOf(nodeWithError, \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n            methodCall = nodeWithError;\n          } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(nodeWithError), \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n            methodCall = SNodeOperations.getParent(nodeWithError);\n          }\n          if (methodCall != null) {\n            SNode classifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(methodCall, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n            result_14532009 = false;\n          } else\n          {\n            result_14532009 = false;\n          }\n        }\n      }\n    }\n    return result_14532009;\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getSubOrSuperTypes(SNode clt) {\n    SNode classifier = SLinkOperations.getTarget(clt, \"classifier\", false);\n    List<SNode> result = ListSequence.<SNode>fromArray();\n    List<SNode> supertypes = ListSequence.<SNode>fromArray();\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n      SNode classConcept = classifier;\n      if (!((SLinkOperations.getTarget(classConcept, \"superclass\", true) == null))) {\n        ListSequence.fromList(supertypes).addElement(SLinkOperations.getTarget(classConcept, \"superclass\", true));\n      }\n      ListSequence.fromList(supertypes).addSequence(ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"implementedInterface\", true)));\n    }\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.Interface\")) {\n      SNode interfaceConcept = classifier;\n      ListSequence.fromList(supertypes).addSequence(ListSequence.fromList(SLinkOperations.getTargets(interfaceConcept, \"extendedInterface\", true)));\n    }\n    if (ListSequence.fromList(supertypes).isEmpty()) {\n      ListSequence.fromList(result).addElement(new _Quotations.QuotationClass_4().createNode());\n    }\n    for(SNode supertype : supertypes) {\n      SNode supertypeCopy = SNodeOperations.copyNode(supertype);\n      for(SNode typeParam : new ArrayList<SNode>(SLinkOperations.getTargets(supertypeCopy, \"parameter\", true))) {\n        if (SNodeOperations.isInstanceOf(typeParam, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\")) {\n          SNode tvr = typeParam;\n          int i = ListSequence.fromList(SLinkOperations.getTargets(classifier, \"typeVariableDeclaration\", true)).indexOf(SLinkOperations.getTarget(tvr, \"typeVariableDeclaration\", false));\n          if (i < 0 || i >= SLinkOperations.getCount(clt, \"parameter\")) {\n            ((SNode)supertypeCopy).removeChild(typeParam);\n            continue;\n          }\n          SNode newNode = SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(clt, \"parameter\", true)).getElement(i));\n          supertypeCopy.replaceChild(typeParam, newNode);\n        }\n      }\n      ListSequence.fromList(result).addElement(supertypeCopy);\n    }\n    ListSequence.fromList(supertypes).addElement(clt);\n    for(SNode supertype : supertypes) {\n      SNode erasure = SNodeOperations.copyNode(supertype);\n      if (SLinkOperations.getCount(erasure, \"parameter\") > 0) {\n        for(SNode parameter : SLinkOperations.getTargets(erasure, \"parameter\", true)) {\n          SNodeOperations.deleteNode(parameter);\n        }\n        ListSequence.fromList(result).addElement(erasure);\n      }\n    }\n    return result;\n  }","id":102541,"modified_method":"public List<SNode> getSubOrSuperTypes(SNode clt) {\n    SNode classifier = SLinkOperations.getTarget(clt, \"classifier\", false);\n    List<SNode> result = new ArrayList<SNode>();\n    List<SNode> supertypes = new ArrayList<SNode>();\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n      SNode classConcept = classifier;\n      if (!((SLinkOperations.getTarget(classConcept, \"superclass\", true) == null))) {\n        supertypes.add(SLinkOperations.getTarget(classConcept, \"superclass\", true));\n      }\n      supertypes.addAll(SLinkOperations.getTargets(classConcept, \"implementedInterface\", true));\n    }\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.Interface\")) {\n      SNode interfaceConcept = classifier;\n      supertypes.addAll(SLinkOperations.getTargets(interfaceConcept, \"extendedInterface\", true));\n    }\n    if (supertypes.isEmpty()) {\n      result.add(new _Quotations.QuotationClass_4().createNode());\n    }\n    for(SNode supertype : supertypes) {\n      SNode supertypeCopy = SNodeOperations.copyNode(supertype);\n      for(SNode typeParam : new ArrayList<SNode>(SLinkOperations.getTargets(supertypeCopy, \"parameter\", true))) {\n        if (SNodeOperations.isInstanceOf(typeParam, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\")) {\n          SNode tvr = typeParam;\n          int i = ((List)SLinkOperations.getTargets(classifier, \"typeVariableDeclaration\", true)).indexOf(SLinkOperations.getTarget(tvr, \"typeVariableDeclaration\", false));\n          if (i < 0 || i >= SLinkOperations.getCount(clt, \"parameter\")) {\n            ((SNode)supertypeCopy).removeChild(typeParam);\n            continue;\n          }\n          SNode newNode = SNodeOperations.copyNode(((SNode)((List)SLinkOperations.getTargets(clt, \"parameter\", true)).get(i)));\n          supertypeCopy.replaceChild(typeParam, newNode);\n        }\n      }\n      result.add(supertypeCopy);\n    }\n    supertypes.add(clt);\n    for(SNode supertype : supertypes) {\n      SNode erasure = SNodeOperations.copyNode(supertype);\n      if (SLinkOperations.getCount(erasure, \"parameter\") > 0) {\n        for(SNode parameter : SLinkOperations.getTargets(erasure, \"parameter\", true)) {\n          SNodeOperations.deleteNode(parameter);\n        }\n        result.add(erasure);\n      }\n    }\n    return result;\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode thisExpr, final TypeCheckingContext typeCheckingContext) {\n    SNode classifier;\n    if ((SLinkOperations.getTarget(thisExpr, \"classConcept\", false) != null)) {\n      classifier = SLinkOperations.getTarget(thisExpr, \"classConcept\", false);\n    } else\n    {\n      SNode contextNode = thisExpr;\n      SNode parent = SNodeOperations.getParent(thisExpr);\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\")) {\n        for(SNode param : SLinkOperations.getTargets(parent, \"parameter\", true)) {\n          if (ListSequence.fromList(SNodeOperations.getDescendants(param, null, true)).contains(thisExpr)) {\n            contextNode = parent;\n            break;\n          }\n        }\n      }\n      classifier = SNodeOperations.getAncestor(contextNode, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    }\n    List<SNode> typeVarRefs = new ArrayList<SNode>();\n    for(SNode typeVariableDeclaration : SLinkOperations.getTargets(classifier, \"typeVariableDeclaration\", true)) {\n      ListSequence.fromList(typeVarRefs).addElement(new _Quotations.QuotationClass_14().createNode(typeVariableDeclaration, typeCheckingContext));\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = thisExpr;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(thisExpr, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1215004810739\", true), new _Quotations.QuotationClass_15().createNode(typeVarRefs, typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1215004810737\", intentionProvider);\n    }\n  }","id":102542,"modified_method":"public void applyRule(final SNode thisExpr, final TypeCheckingContext typeCheckingContext) {\n    SNode classifier;\n    if ((SLinkOperations.getTarget(thisExpr, \"classConcept\", false) != null)) {\n      classifier = SLinkOperations.getTarget(thisExpr, \"classConcept\", false);\n    } else\n    {\n      SNode contextNode = thisExpr;\n      SNode parent = SNodeOperations.getParent(thisExpr);\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\")) {\n        for(SNode param : SLinkOperations.getTargets(parent, \"parameter\", true)) {\n          if (ListSequence.fromList(SNodeOperations.getDescendants(param, null, true)).contains(thisExpr)) {\n            contextNode = parent;\n            break;\n          }\n        }\n      }\n      classifier = SNodeOperations.getAncestor(contextNode, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    }\n    List<SNode> typeVarRefs = new ArrayList<SNode>();\n    for(SNode typeVariableDeclaration : SLinkOperations.getTargets(classifier, \"typeVariableDeclaration\", true)) {\n      ListSequence.fromList(typeVarRefs).addElement(new _Quotations.QuotationClass_14().createNode(typeVariableDeclaration, typeCheckingContext));\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = thisExpr;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(thisExpr, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1215004810739\", true), new _Quotations.QuotationClass_15().createNode(typeVarRefs, classifier, typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1215004810737\", intentionProvider);\n    }\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode creator, final TypeCheckingContext typeCheckingContext) {\n    if (SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false) == null) {\n      return;\n    }\n    final SNode methodClassifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    if (!(SLinkOperations.getCount(creator, \"typeParameter\") == 0 || SLinkOperations.getCount(creator, \"typeParameter\") == SLinkOperations.getCount(SNodeOperations.getAncestor(SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false), \"typeVariableDeclaration\"))) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(creator, \"wrong number of type parameters\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1216200944338\", intentionProvider, errorTarget);\n      }\n    }\n    for(SNode parameter : SLinkOperations.getTargets(creator, \"typeParameter\", true)) {\n      if (!(!(TypeChecker.getInstance().getSubtypingManager().isSubtype(parameter, SLinkOperations.getTarget(new _Quotations.QuotationClass_87().createNode(typeCheckingContext), \"descriptor\", false), false)))) {\n        BaseIntentionProvider intentionProvider = null;\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(parameter, \"primitive type not allowed\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606006\", intentionProvider, errorTarget);\n      }\n    }\n    // ---\n    SNode constructedType = new _Quotations.QuotationClass_88().createNode(SLinkOperations.getTargets(creator, \"typeParameter\", true), typeCheckingContext);\n    {\n      SNode _nodeToCheck_1029348928467 = creator;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(creator, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606043\", true), constructedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606039\", intentionProvider);\n    }\n    final SNode instanceType_typevar_1212781606045 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = creator;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(instanceType_typevar_1212781606045), constructedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606046\", intentionProvider);\n    }\n    // --- following piece of cake is identical for any method call ---\n    Map<SNode, List<SNode>> mmap = new HashMap<SNode, List<SNode>>();\n    RulesFunctions_BaseLanguage.inference_equateParametersAndReturnType(typeCheckingContext, creator, null, mmap);\n    RulesFunctions_BaseLanguage.inference_matchConcreteTypesWithTypeVariables(typeCheckingContext, methodClassifier, typeCheckingContext.getEquationManager().getRepresentator(instanceType_typevar_1212781606045), mmap);\n    RulesFunctions_BaseLanguage.inference_equateMatchingTypeVariables(typeCheckingContext, mmap);\n  }","id":102543,"modified_method":"public void applyRule(final SNode creator, final TypeCheckingContext typeCheckingContext) {\n    if (SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false) == null) {\n      return;\n    }\n    final SNode methodClassifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    if (!(SLinkOperations.getCount(creator, \"typeParameter\") == 0 || SLinkOperations.getCount(creator, \"typeParameter\") == SLinkOperations.getCount(SNodeOperations.getAncestor(SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false), \"typeVariableDeclaration\"))) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(creator, \"wrong number of type parameters\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1216200944338\", intentionProvider, errorTarget);\n      }\n    }\n    for(SNode parameter : SLinkOperations.getTargets(creator, \"typeParameter\", true)) {\n      if (!(!(TypeChecker.getInstance().getSubtypingManager().isSubtype(parameter, SLinkOperations.getTarget(new _Quotations.QuotationClass_87().createNode(typeCheckingContext), \"descriptor\", false), false)))) {\n        BaseIntentionProvider intentionProvider = null;\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(parameter, \"primitive type not allowed\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606006\", intentionProvider, errorTarget);\n      }\n    }\n    // ---\n    SNode constructedType = new _Quotations.QuotationClass_88().createNode(SLinkOperations.getTargets(creator, \"typeParameter\", true), methodClassifier, typeCheckingContext);\n    {\n      SNode _nodeToCheck_1029348928467 = creator;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(creator, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606043\", true), constructedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606039\", intentionProvider);\n    }\n    final SNode instanceType_typevar_1212781606045 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = creator;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(instanceType_typevar_1212781606045), constructedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606046\", intentionProvider);\n    }\n    // --- following piece of cake is identical for any method call ---\n    Map<SNode, List<SNode>> mmap = new HashMap<SNode, List<SNode>>();\n    RulesFunctions_BaseLanguage.inference_equateParametersAndReturnType(typeCheckingContext, creator, null, mmap);\n    RulesFunctions_BaseLanguage.inference_matchConcreteTypesWithTypeVariables(typeCheckingContext, methodClassifier, typeCheckingContext.getEquationManager().getRepresentator(instanceType_typevar_1212781606045), mmap);\n    RulesFunctions_BaseLanguage.inference_equateMatchingTypeVariables(typeCheckingContext, mmap);\n  }","commit_id":"1f862661171715e68900b86dc0b6fb82ccbbbc74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getNewModelName() {\n    if (this.myModelName == null && this.mySolutionName != null) {\n      String modelNamePrefix = this.mySolutionName;\n      int count = 0;\n      {\n        Pattern _pattern_0 = _PrecompiledPatterns.REGEXP0;\n        Matcher _matcher_0 = _pattern_0.matcher(modelNamePrefix);\n        if (_matcher_0.find()) {\n          modelNamePrefix = _matcher_0.group(1) + _matcher_0.group(2);\n        }\n      }\n      this.myModelName = modelNamePrefix;\n      while (!(this.isValidModelName(this.myModelName))) {\n        this.myModelName = modelNamePrefix + count;\n        count++ ;\n      }\n    }\n    return this.myModelName;\n  }","id":102544,"modified_method":"public String getNewModelName() {\n    if (this.myModelName == null && this.mySolutionName != null) {\n      String modelNamePrefix = this.mySolutionName;\n      int count = 0;\n      this.myModelName = modelNamePrefix;\n      while (!(this.isValidModelName(this.myModelName))) {\n        this.myModelName = modelNamePrefix + count;\n        count++ ;\n      }\n    }\n    return this.myModelName;\n  }","commit_id":"f00f631c7fe55ca2a913c80869f44cf037ed9144","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setModules(List<NodeData> modules) {\n    ListSequence.fromList(this.myModules).clear();\n    ListSequence.fromList(this.myModules).addSequence(ListSequence.fromList(modules));\n  }","id":102545,"modified_method":"public void setModules(List<NodeData> modules) {\n    this.myModules.clear();\n    this.myModules.addAll(modules);\n  }","commit_id":"f00f631c7fe55ca2a913c80869f44cf037ed9144","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode createBasedirPath(String macro, String path) {\n    SNode basedirPath = SConceptOperations.createNewNode(\"jetbrains.mps.build.packaging.structure.BaseDirPath\", null);\n    SPropertyOperations.set(SLinkOperations.getTarget(basedirPath, \"macro\", true), \"name\", macro);\n    String[] pathComponents = path.split(File.separator);\n    if (pathComponents.length > 0) {\n      List<SNode> pathComponentNodes = new ArrayList();\n      for(String pathComponentName : pathComponents) {\n        if (StringUtils.isEmpty(pathComponentName)) {\n          continue;\n        }\n        ListSequence.fromList(pathComponentNodes).addElement(PackagingLanguageGenerator.createPathComponent(pathComponentName));\n      }\n      SNode compositePathComponent = createCompositePathComponent(pathComponentNodes);\n      SLinkOperations.setTarget(basedirPath, \"compositePathComponent\", compositePathComponent, true);\n    }\n    return basedirPath;\n  }","id":102546,"modified_method":"public static SNode createBasedirPath(String macro, String path) {\n    SNode basedirPath = SConceptOperations.createNewNode(\"jetbrains.mps.build.packaging.structure.BaseDirPath\", null);\n    SPropertyOperations.set(SLinkOperations.getTarget(basedirPath, \"macro\", true), \"name\", macro);\n    String[] pathComponents = path.split(File.separator.replace(\"\\\\\", \"\\\\\\\\\"));\n    if (pathComponents.length > 0) {\n      List<SNode> pathComponentNodes = new ArrayList();\n      for(String pathComponentName : pathComponents) {\n        if (StringUtils.isEmpty(pathComponentName)) {\n          continue;\n        }\n        ListSequence.fromList(pathComponentNodes).addElement(PackagingLanguageGenerator.createPathComponent(pathComponentName));\n      }\n      SNode compositePathComponent = createCompositePathComponent(pathComponentNodes);\n      SLinkOperations.setTarget(basedirPath, \"compositePathComponent\", compositePathComponent, true);\n    }\n    return basedirPath;\n  }","commit_id":"f00f631c7fe55ca2a913c80869f44cf037ed9144","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void process(ApplicationSpecLocation appSpec) throws Exception {\n    List<ProgramSpecification> deletedSpecs = store.getDeletedProgramSpecifications(appSpec.getApplicationId(),\n                                                                                    appSpec.getSpecification());\n\n    List<String> deletedFlows = Lists.newArrayList();\n    for (ProgramSpecification spec : deletedSpecs) {\n      //call the deleted spec\n      Type type = Type.typeOfSpecification(spec);\n      Id.Program programId = Id.Program.from(appSpec.getApplicationId(), spec.getName());\n      programTerminator.stop(Id.Account.from(appSpec.getApplicationId().getAccountId()),\n                                   programId, type);\n\n      // TODO: Unify with AppFabricHttpHandler.removeApplication\n      // drop all queues and stream states of a deleted flow\n      if (Type.FLOW.equals(type)) {\n        FlowSpecification flowSpecification = (FlowSpecification) spec;\n\n        // Collects stream name to all group ids consuming that stream\n        Multimap<String, Long> streamGroups = HashMultimap.create();\n        for (FlowletConnection connection : flowSpecification.getConnections()) {\n          if (connection.getSourceType() == FlowletConnection.Type.STREAM) {\n            long groupId = FlowUtils.generateConsumerGroupId(programId, connection.getTargetName());\n            streamGroups.put(connection.getSourceName(), groupId);\n          }\n        }\n        // Remove all process states and group states for each stream\n        String namespace = String.format(\"%s.%s\", programId.getApplicationId(), programId.getId());\n        for (Map.Entry<String, Collection<Long>> entry : streamGroups.asMap().entrySet()) {\n          streamConsumerFactory.dropAll(QueueName.fromStream(entry.getKey()), namespace, entry.getValue());\n        }\n\n        queueAdmin.dropAllForFlow(programId.getApplicationId(), programId.getId());\n        deletedFlows.add(programId.getId());\n      }\n    }\n    deleteMetrics(appSpec.getApplicationId().getAccountId(), appSpec.getApplicationId().getId(), deletedFlows);\n    emit(appSpec);\n  }","id":102547,"modified_method":"@Override\n  public void process(ApplicationSpecLocation appSpec) throws Exception {\n    List<ProgramSpecification> deletedSpecs = store.getDeletedProgramSpecifications(appSpec.getApplicationId(),\n                                                                                    appSpec.getSpecification());\n\n    List<String> deletedFlows = Lists.newArrayList();\n    for (ProgramSpecification spec : deletedSpecs) {\n      //call the deleted spec\n      Type type = Type.typeOfSpecification(spec);\n      Id.Program programId = Id.Program.from(appSpec.getApplicationId(), spec.getName());\n      programTerminator.stop(Id.Account.from(appSpec.getApplicationId().getAccountId()),\n                                   programId, type);\n\n      // TODO: Unify with AppFabricHttpHandler.removeApplication\n      // drop all queues and stream states of a deleted flow\n      if (Type.FLOW.equals(type)) {\n        FlowSpecification flowSpecification = (FlowSpecification) spec;\n\n        // Collects stream name to all group ids consuming that stream\n        Multimap<String, Long> streamGroups = HashMultimap.create();\n        for (FlowletConnection connection : flowSpecification.getConnections()) {\n          if (connection.getSourceType() == FlowletConnection.Type.STREAM) {\n            long groupId = FlowUtils.generateConsumerGroupId(programId, connection.getTargetName());\n            streamGroups.put(connection.getSourceName(), groupId);\n          }\n        }\n        // Remove all process states and group states for each stream\n        String namespace = String.format(\"%s.%s\", programId.getApplicationId(), programId.getId());\n        for (Map.Entry<String, Collection<Long>> entry : streamGroups.asMap().entrySet()) {\n          streamConsumerFactory.dropAll(QueueName.fromStream(entry.getKey()), namespace, entry.getValue());\n        }\n\n        queueAdmin.dropAllForFlow(programId.getApplicationId(), programId.getId());\n        deletedFlows.add(programId.getId());\n      }\n    }\n    if (!deletedFlows.isEmpty()) {\n      deleteMetrics(appSpec.getApplicationId().getAccountId(), appSpec.getApplicationId().getId(), deletedFlows);\n    }\n\n    emit(appSpec);\n  }","commit_id":"b0105f47cbb58d5706b7cfaeefab1dedb03f9f97","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testFlow() throws Exception {\n    final ApplicationWithPrograms app = AppFabricTestHelper.deployApplicationWithManager(WordCountApp.class,\n                                                                                         TEMP_FOLDER_SUPPLIER);\n    ProgramRunnerFactory runnerFactory = AppFabricTestHelper.getInjector().getInstance(ProgramRunnerFactory.class);\n\n    List<ProgramController> controllers = Lists.newArrayList();\n\n    for (final Program program : app.getPrograms()) {\n      // running mapreduce is out of scope of this tests (there's separate unit-test for that)\n      if (program.getType() == Type.MAPREDUCE) {\n        continue;\n      }\n      ProgramRunner runner = runnerFactory.create(ProgramRunnerFactory.Type.valueOf(program.getType().name()));\n      controllers.add(runner.run(program, new SimpleProgramOptions(program)));\n    }\n\n    TimeUnit.SECONDS.sleep(1);\n\n    TransactionSystemClient txSystemClient = AppFabricTestHelper.getInjector().\n                                             getInstance(TransactionSystemClient.class);\n\n    QueueName queueName = QueueName.fromStream(\"text\");\n    QueueClientFactory queueClientFactory = AppFabricTestHelper.getInjector().getInstance(QueueClientFactory.class);\n    Queue2Producer producer = queueClientFactory.createProducer(queueName);\n\n    // start tx to write in queue in tx\n    Transaction tx = txSystemClient.startShort();\n    ((TransactionAware) producer).startTx(tx);\n\n    StreamEventCodec codec = new StreamEventCodec();\n    for (int i = 0; i < 10; i++) {\n      String msg = \"Testing message \" + i;\n      StreamEvent event = new DefaultStreamEvent(ImmutableMap.<String, String>of(),\n                                                 ByteBuffer.wrap(msg.getBytes(Charsets.UTF_8)));\n      producer.enqueue(new QueueEntry(codec.encodePayload(event)));\n    }\n\n    // commit tx\n    ((TransactionAware) producer).commitTx();\n    txSystemClient.commit(tx);\n\n    TimeUnit.SECONDS.sleep(10);\n\n    // Procedure\n    Gson gson = new Gson();\n    DiscoveryServiceClient discoveryServiceClient = AppFabricTestHelper.getInjector().\n      getInstance(DiscoveryServiceClient.class);\n    Discoverable discoverable = discoveryServiceClient.discover(\n      String.format(\"procedure.%s.%s.%s\",\n                    DefaultId.ACCOUNT.getId(), \"WordCountApp\", \"WordFrequency\")).iterator().next();\n\n    URL url = new URL(String.format(\"http://%s:%d/apps/%s/procedures/%s/methods/%s\",\n                                    discoverable.getSocketAddress().getHostName(),\n                                    discoverable.getSocketAddress().getPort(),\n                                    \"WordCountApp\",\n                                    \"WordFrequency\",\n                                    \"wordfreq\"));\n    HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();\n    urlConn.setDoOutput(true);\n    urlConn.getOutputStream().write(gson.toJson(ImmutableMap.of(\"word\", \"text:Testing\")).getBytes(Charsets.UTF_8));\n    Map<String, Long> responseContent = gson.fromJson(new InputStreamReader(urlConn.getInputStream(), Charsets.UTF_8),\n                                                      new TypeToken<Map<String, Long>>() { }.getType());\n\n    LOG.info(\"Procedure response: \" + responseContent);\n    Assert.assertEquals(ImmutableMap.of(\"text:Testing\", 10L), responseContent);\n\n    for (ProgramController controller : controllers) {\n      controller.stop().get();\n    }\n  }","id":102548,"modified_method":"@Test\n  public void testFlow() throws Exception {\n    final ApplicationWithPrograms app = AppFabricTestHelper.deployApplicationWithManager(WordCountApp.class,\n                                                                                         TEMP_FOLDER_SUPPLIER);\n    ProgramRunnerFactory runnerFactory = AppFabricTestHelper.getInjector().getInstance(ProgramRunnerFactory.class);\n\n    List<ProgramController> controllers = Lists.newArrayList();\n\n    for (final Program program : app.getPrograms()) {\n      // running mapreduce is out of scope of this tests (there's separate unit-test for that)\n      if (program.getType() == Type.MAPREDUCE) {\n        continue;\n      }\n      ProgramRunner runner = runnerFactory.create(ProgramRunnerFactory.Type.valueOf(program.getType().name()));\n      controllers.add(runner.run(program, new SimpleProgramOptions(program)));\n    }\n\n    TimeUnit.SECONDS.sleep(1);\n\n    TransactionSystemClient txSystemClient = AppFabricTestHelper.getInjector().\n                                             getInstance(TransactionSystemClient.class);\n\n    QueueName queueName = QueueName.fromStream(\"text\");\n    QueueClientFactory queueClientFactory = AppFabricTestHelper.getInjector().getInstance(QueueClientFactory.class);\n    Queue2Producer producer = queueClientFactory.createProducer(queueName);\n\n    // start tx to write in queue in tx\n    Transaction tx = txSystemClient.startShort();\n    ((TransactionAware) producer).startTx(tx);\n\n    StreamEventCodec codec = new StreamEventCodec();\n    for (int i = 0; i < 10; i++) {\n      String msg = \"Testing message \" + i;\n      StreamEvent event = new DefaultStreamEvent(ImmutableMap.<String, String>of(),\n                                                 ByteBuffer.wrap(msg.getBytes(Charsets.UTF_8)));\n      producer.enqueue(new QueueEntry(codec.encodePayload(event)));\n    }\n\n    // commit tx\n    ((TransactionAware) producer).commitTx();\n    txSystemClient.commit(tx);\n\n    // Query the procedure for at most 10 seconds for the expected result\n    Gson gson = new Gson();\n    DiscoveryServiceClient discoveryServiceClient = AppFabricTestHelper.getInjector().\n      getInstance(DiscoveryServiceClient.class);\n    ServiceDiscovered procedureDiscovered = discoveryServiceClient.discover(\n      String.format(\"procedure.%s.%s.%s\", DefaultId.ACCOUNT.getId(), \"WordCountApp\", \"WordFrequency\"));\n    EndpointStrategy endpointStrategy = new TimeLimitEndpointStrategy(new RandomEndpointStrategy(procedureDiscovered),\n                                                                      2L, TimeUnit.SECONDS);\n    int trials = 0;\n    while (trials++ < 10) {\n      Discoverable discoverable = endpointStrategy.pick();\n      URL url = new URL(String.format(\"http://%s:%d/apps/%s/procedures/%s/methods/%s\",\n                                      discoverable.getSocketAddress().getHostName(),\n                                      discoverable.getSocketAddress().getPort(),\n                                      \"WordCountApp\",\n                                      \"WordFrequency\",\n                                      \"wordfreq\"));\n      try {\n        HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();\n        urlConn.setDoOutput(true);\n        urlConn.getOutputStream().write(gson.toJson(ImmutableMap.of(\"word\", \"text:Testing\")).getBytes(Charsets.UTF_8));\n        Map<String, Long> responseContent = gson.fromJson(\n          new InputStreamReader(urlConn.getInputStream(), Charsets.UTF_8),\n          new TypeToken<Map<String, Long>>() { }.getType());\n\n        LOG.info(\"Procedure response: \" + responseContent);\n        if (ImmutableMap.of(\"text:Testing\", 10L).equals(responseContent)) {\n          break;\n        }\n\n      } catch (Throwable t) {\n        LOG.info(\"Exception when trying to query procedure.\", t);\n      }\n\n      TimeUnit.SECONDS.sleep(1);\n    }\n\n    Assert.assertTrue(trials < 10);\n\n    for (ProgramController controller : controllers) {\n      controller.stop().get();\n    }\n  }","commit_id":"b0105f47cbb58d5706b7cfaeefab1dedb03f9f97","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Deletes metrics for a given account.\n   *\n   * @param accountId for which the metrics need to be reset.\n   * @throws IOException throw due to issue in reseting metrics for\n   * @throws TException on thrift errors while talking to thrift service\n   * @throws MetadataServiceException on errors from metadata service\n   */\n  private void deleteMetrics(String accountId) throws IOException, TException, MetadataServiceException {\n\n    List<Application> applications = this.mds.getApplications(new Account(accountId));\n    Discoverable discoverable = this.discoveryServiceClient.discover(Constants.SERVICE_METRICS).iterator().next();\n\n    for (Application application : applications){\n      String url = String.format(\"http://%s:%d/metrics/app/%s\",\n                                 discoverable.getSocketAddress().getHostName(),\n                                 discoverable.getSocketAddress().getPort(),\n                                 application.getId());\n      SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()\n        .setUrl(url)\n        .setRequestTimeoutInMs((int) METRICS_SERVER_RESPONSE_TIMEOUT)\n        .build();\n\n      client.delete();\n    }\n\n    String url = String.format(\"http://%s:%d/metrics\",\n                               discoverable.getSocketAddress().getHostName(),\n                               discoverable.getSocketAddress().getPort());\n\n    SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()\n      .setUrl(url)\n      .setRequestTimeoutInMs((int) METRICS_SERVER_RESPONSE_TIMEOUT)\n      .build();\n    client.delete();\n  }","id":102549,"modified_method":"/**\n   * Deletes metrics for a given account.\n   *\n   * @param accountId for which the metrics need to be reset.\n   * @throws IOException throw due to issue in reseting metrics for\n   * @throws TException on thrift errors while talking to thrift service\n   * @throws MetadataServiceException on errors from metadata service\n   */\n  private void deleteMetrics(String accountId) throws IOException, TException, MetadataServiceException {\n\n    List<Application> applications = this.mds.getApplications(new Account(accountId));\n    Iterable<Discoverable> discoverables = this.discoveryServiceClient.discover(Constants.SERVICE_METRICS);\n    Discoverable discoverable = new TimeLimitEndpointStrategy(new RandomEndpointStrategy(discoverables),\n                                                              DISCOVERY_TIMEOUT_SECONDS, TimeUnit.SECONDS).pick();\n\n    if (discoverable == null) {\n      LOG.error(\"Fail to get any metrics endpoint for deleting metrics.\");\n      return;\n    }\n\n    for (Application application : applications){\n      String url = String.format(\"http://%s:%d/metrics/app/%s\",\n                                 discoverable.getSocketAddress().getHostName(),\n                                 discoverable.getSocketAddress().getPort(),\n                                 application.getId());\n      SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()\n        .setUrl(url)\n        .setRequestTimeoutInMs((int) METRICS_SERVER_RESPONSE_TIMEOUT)\n        .build();\n\n      client.delete();\n    }\n\n    String url = String.format(\"http://%s:%d/metrics\",\n                               discoverable.getSocketAddress().getHostName(),\n                               discoverable.getSocketAddress().getPort());\n\n    SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()\n      .setUrl(url)\n      .setRequestTimeoutInMs((int) METRICS_SERVER_RESPONSE_TIMEOUT)\n      .build();\n    client.delete();\n  }","commit_id":"606fbea53499bc53b13988b6bb2d58115a4b9535","url":"https://github.com/caskdata/cdap"},{"original_method":"private void deleteMetrics(String account, String application) throws IOException {\n    Discoverable discoverable = this.discoveryServiceClient.discover(Constants.SERVICE_METRICS).iterator().next();\n    String url = String.format(\"http://%s:%d/metrics/app/%s\",\n                                    discoverable.getSocketAddress().getHostName(),\n                                    discoverable.getSocketAddress().getPort(),\n                                    application);\n    LOG.debug(\"Deleting metrics for application {}\", application);\n    SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()\n      .setUrl(url)\n      .setRequestTimeoutInMs((int) METRICS_SERVER_RESPONSE_TIMEOUT)\n      .build();\n\n    client.delete();\n  }","id":102550,"modified_method":"private void deleteMetrics(String account, String application) throws IOException {\n    Iterable<Discoverable> discoverables = this.discoveryServiceClient.discover(Constants.SERVICE_METRICS);\n    Discoverable discoverable = new TimeLimitEndpointStrategy(new RandomEndpointStrategy(discoverables),\n                                                              DISCOVERY_TIMEOUT_SECONDS, TimeUnit.SECONDS).pick();\n\n    if (discoverable == null) {\n      LOG.error(\"Fail to get any metrics endpoint for deleting metrics.\");\n      return;\n    }\n\n    String url = String.format(\"http://%s:%d/metrics/app/%s\",\n                                    discoverable.getSocketAddress().getHostName(),\n                                    discoverable.getSocketAddress().getPort(),\n                                    application);\n    LOG.debug(\"Deleting metrics for application {}\", application);\n    SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()\n      .setUrl(url)\n      .setRequestTimeoutInMs((int) METRICS_SERVER_RESPONSE_TIMEOUT)\n      .build();\n\n    client.delete();\n  }","commit_id":"606fbea53499bc53b13988b6bb2d58115a4b9535","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testQueuePartition() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestFlowQueueIntegrationApp.class);\n    try {\n      FlowManager flowManager = applicationManager.startFlow(\"QueuePartitionFlow\");\n\n      StreamWriter s1 = applicationManager.getStreamWriter(\"s1\");\n      RuntimeMetrics flowletMetrics1 = RuntimeStats.getFlowletMetrics(\"TestFlowQueueIntegrationApp\",\n                                                                      \"QueuePartitionFlow\",\n                                                                      \"QueuePartitionTestFlowlet\");\n      flowManager.setFlowletInstances(\"QueuePartitionTestFlowlet\",\n                                      TestFlowQueueIntegrationApp.QueuePartitionTestFlowlet.NUM_INSTANCES);\n\n      RuntimeMetrics flowletMetrics2 = RuntimeStats.getFlowletMetrics(\"TestFlowQueueIntegrationApp\",\n                                                                      \"QueuePartitionFlow\", \"QueueBatchTestFlowlet\");\n      flowManager.setFlowletInstances(\"QueueBatchTestFlowlet\",\n                                      TestFlowQueueIntegrationApp.QueueBatchTestFlowlet.NUM_INSTANCES);\n      for (int i = 0; i < TestFlowQueueIntegrationApp.MAX_ITERATIONS; i++) {\n        s1.send(String.valueOf(i));\n      }\n\n      flowletMetrics1.waitForProcessed(TestFlowQueueIntegrationApp.MAX_ITERATIONS * 3,\n                                       FLOWLET_TIMEOUT, TimeUnit.SECONDS);\n      flowletMetrics2.waitForProcessed(TestFlowQueueIntegrationApp.QueueBatchTestFlowlet.NUM_INSTANCES,\n                                       FLOWLET_TIMEOUT, TimeUnit.SECONDS);\n\n      // Wait for Fifo consumers to finish\n      TimeUnit.SECONDS.sleep(1);\n\n      if (flowletMetrics1.getException() > 0) {\n        Assert.fail(\"QueuePartitionTestFlowlet test failed\");\n      }\n      if (flowletMetrics2.getException() > 0) {\n        Assert.fail(\"QueueBatchTestFlowlet test failed\");\n      }\n    } finally {\n      applicationManager.stopAll();\n      clearAppFabric();\n    }\n  }","id":102551,"modified_method":"@Test\n  public void testQueuePartition() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestFlowQueueIntegrationApp.class);\n    try {\n      applicationManager.startFlow(\"QueuePartitionFlow\");\n\n      StreamWriter s1 = applicationManager.getStreamWriter(\"s1\");\n      RuntimeMetrics flowletMetrics1 = RuntimeStats.getFlowletMetrics(\"TestFlowQueueIntegrationApp\",\n                                                                      \"QueuePartitionFlow\",\n                                                                      \"QueuePartitionTestFlowlet\");\n\n      RuntimeMetrics flowletMetrics2 = RuntimeStats.getFlowletMetrics(\"TestFlowQueueIntegrationApp\",\n                                                                      \"QueuePartitionFlow\", \"QueueBatchTestFlowlet\");\n\n      for (int i = 0; i < TestFlowQueueIntegrationApp.MAX_ITERATIONS; i++) {\n        s1.send(String.valueOf(i));\n      }\n\n      flowletMetrics1.waitForProcessed(TestFlowQueueIntegrationApp.MAX_ITERATIONS * 3,\n                                       FLOWLET_TIMEOUT, TimeUnit.SECONDS);\n      flowletMetrics2.waitForProcessed(TestFlowQueueIntegrationApp.QueueBatchTestFlowlet.NUM_INSTANCES,\n                                       FLOWLET_TIMEOUT, TimeUnit.SECONDS);\n\n      // Wait for Fifo consumers to finish\n      TimeUnit.SECONDS.sleep(1);\n\n      if (flowletMetrics1.getException() > 0) {\n        Assert.fail(\"QueuePartitionTestFlowlet test failed\");\n      }\n      if (flowletMetrics2.getException() > 0) {\n        Assert.fail(\"QueueBatchTestFlowlet test failed\");\n      }\n    } finally {\n      applicationManager.stopAll();\n      clearAppFabric();\n    }\n  }","commit_id":"606fbea53499bc53b13988b6bb2d58115a4b9535","url":"https://github.com/caskdata/cdap"},{"original_method":"@ProcessInput(\"entry1\")\n    @HashPartition(HASH_KEY1)\n    public void hashPartition1(Entry1 actual) {\n      String logID = \"HID1:\" + id;\n\n      // Wait for first entry to be populated\n      try {\n        latch.await();\n      } catch (InterruptedException e) {\n        Assert.fail(logID + \": Interrupted latch wait\");\n      }\n\n      if (expectedHash1Iterator == null) {\n        expectedHash1Iterator = expectedHash1Lists[first].iterator();\n      }\n      verify(Entry1.ID, actual.i, expectedHash1Iterator, logID);\n    }","id":102552,"modified_method":"@ProcessInput(\"entry1\")\n    @HashPartition(HASH_KEY1)\n    public void hashPartition1(Entry1 actual) {\n      if (expectedHash1Iterator == null) {\n        if (!EXPECTED_HASH1_LISTS.containsKey(actual.i - Entry1.ID)) {\n          Assert.fail(\"Unexpected sequence \" + actual.i);\n        }\n        expectedHash1Iterator = EXPECTED_HASH1_LISTS.remove(actual.i - Entry1.ID).iterator();\n      }\n      verify(Entry1.ID, actual.i, expectedHash1Iterator);\n    }","commit_id":"606fbea53499bc53b13988b6bb2d58115a4b9535","url":"https://github.com/caskdata/cdap"},{"original_method":"private void verify(int base, int i, Iterator<Integer> iterator, String logID) {\n      logID = logID  + \" : first=\" + first;\n      LOG.warn(logID + \": value=\" + i);\n      if (iterator.hasNext()) {\n        int expected = iterator.next();\n        Assert.assertEquals(logID, expected, i - base);\n      } else {\n        Assert.fail(logID + \": Got more than expected!\");\n      }\n    }","id":102553,"modified_method":"private void verify(int base, int i, Iterator<Integer> iterator) {\n      if (iterator.hasNext()) {\n        int expected = iterator.next();\n        Assert.assertEquals(expected, i - base);\n      } else {\n        Assert.fail(\"Unexpected sequence \" + i);\n      }\n    }","commit_id":"606fbea53499bc53b13988b6bb2d58115a4b9535","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public FlowSpecification configure() {\n      return FlowSpecification.Builder.with()\n        .setName(\"QueuePartitionFlow\")\n        .setDescription(\"Flow for testing queue partitioning\")\n        .withFlowlets().add(new StreamReader())\n                       .add(new QueuePartitionTestFlowlet())\n                       .add(new QueueBatchTestFlowlet())\n        .connect().from(\"StreamReader\").to(\"QueuePartitionTestFlowlet\")\n        .from(\"StreamReader\").to(\"QueueBatchTestFlowlet\")\n        .fromStream(\"s1\").to(\"StreamReader\")\n        .build();\n    }","id":102554,"modified_method":"@Override\n    public FlowSpecification configure() {\n      return FlowSpecification.Builder.with()\n        .setName(\"QueuePartitionFlow\")\n        .setDescription(\"Flow for testing queue partitioning\")\n        .withFlowlets().add(new StreamReader())\n                       .add(new QueuePartitionTestFlowlet(), QueuePartitionTestFlowlet.NUM_INSTANCES)\n                       .add(new QueueBatchTestFlowlet(), QueueBatchTestFlowlet.NUM_INSTANCES)\n        .connect().from(\"StreamReader\").to(\"QueuePartitionTestFlowlet\")\n        .from(\"StreamReader\").to(\"QueueBatchTestFlowlet\")\n        .fromStream(\"s1\").to(\"StreamReader\")\n        .build();\n    }","commit_id":"606fbea53499bc53b13988b6bb2d58115a4b9535","url":"https://github.com/caskdata/cdap"},{"original_method":"@ProcessInput(\"entry2\")\n    @HashPartition(HASH_KEY2)\n    public void hashPartition2(Entry2 actual) {\n      String logID = \"HID2:\" + id;\n\n      // Wait for first entry to be populated\n      try {\n        latch.await();\n      } catch (InterruptedException e) {\n        Assert.fail(logID + \": Interrupted latch wait\");\n      }\n\n      if (expectedHash2Iterator == null) {\n        expectedHash2Iterator = expectedHash2Lists[first].iterator();\n      }\n      verify(Entry2.ID, actual.i, expectedHash2Iterator, logID);\n    }","id":102555,"modified_method":"@ProcessInput(\"entry2\")\n    @HashPartition(HASH_KEY2)\n    public void hashPartition2(Entry2 actual) {\n      if (expectedHash2Iterator == null) {\n        if (!EXPECTED_HASH2_LISTS.containsKey(actual.i - Entry2.ID)) {\n          Assert.fail(\"Unexpected sequence \" + actual.i);\n        }\n        expectedHash2Iterator = EXPECTED_HASH2_LISTS.remove(actual.i - Entry2.ID).iterator();\n      }\n      verify(Entry2.ID, actual.i, expectedHash2Iterator);\n\n    }","commit_id":"606fbea53499bc53b13988b6bb2d58115a4b9535","url":"https://github.com/caskdata/cdap"},{"original_method":"@ProcessInput(\"int\")\n    @RoundRobin\n    public void roundRobin(int actual) {\n      LOG.warn(\"RID:\" + id + \" value=\" + actual);\n      if (expectedRoundRobinIterator == null) {\n        expectedRoundRobinIterator = expectedRoundRobinLists[actual].iterator();\n        first = actual;\n        latch.countDown();\n      }\n      if (expectedRoundRobinIterator.hasNext()) {\n        int expected = expectedRoundRobinIterator.next();\n        Assert.assertEquals(expected, actual);\n      } else {\n        Assert.fail(\"Not enough inputs!\");\n      }\n    }","id":102556,"modified_method":"@ProcessInput(\"int\")\n    @RoundRobin\n    public void roundRobin(int actual) {\n      LOG.warn(\"RID:\" + id + \" value=\" + actual);\n      if (expectedRoundRobinIterator == null) {\n        if (!EXPECTED_ROUND_ROBIN_LISTS.containsKey(actual)) {\n          Assert.fail(\"Unexpected sequence \" + actual);\n        }\n        expectedRoundRobinIterator = EXPECTED_ROUND_ROBIN_LISTS.remove(actual).iterator();\n      }\n      verify(0, actual, expectedRoundRobinIterator);\n    }","commit_id":"606fbea53499bc53b13988b6bb2d58115a4b9535","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testApp() throws InterruptedException, IOException, TimeoutException, OperationException {\n    ApplicationManager applicationManager = deployApplication(WordCountApp2.class);\n\n    try {\n      applicationManager.startFlow(\"WordCountFlow\");\n\n      // Send some inputs to streams\n      StreamWriter streamWriter = applicationManager.getStreamWriter(\"text\");\n      for (int i = 0; i < 100; i++) {\n        streamWriter.send(ImmutableMap.of(\"title\", \"title \" + i), \"testing message \" + i);\n      }\n\n      // Check the flowlet metrics\n      RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"WordCountApp\",\n                                                                     \"WordCountFlow\",\n                                                                     \"CountByField\");\n      flowletMetrics.waitForProcessed(500, 5, TimeUnit.SECONDS);\n      Assert.assertEquals(0L, flowletMetrics.getException());\n\n      // Query the result\n      ProcedureManager procedureManager = applicationManager.startProcedure(\"WordFrequency\");\n      ProcedureClient procedureClient = procedureManager.getClient();\n\n      // Verify the query result\n      Type resultType = new TypeToken<Map<String, Long>>(){}.getType();\n      Gson gson = new Gson();\n      Map<String, Long> result = gson.fromJson(procedureClient.query(\"wordfreq\",\n                                                                     ImmutableMap.of(\"word\", \"text:testing\")),\n                                               resultType);\n\n      Assert.assertEquals(100L, result.get(\"text:testing\").longValue());\n\n      // Verify by looking into dataset\n      MyKeyValueTable mydataset = applicationManager.getDataSet(\"mydataset\");\n      Assert.assertEquals(100L, Longs.fromByteArray(mydataset.read(\"title:title\".getBytes(Charsets.UTF_8))));\n\n      // check the metrics\n      RuntimeMetrics procedureMetrics = RuntimeStats.getProcedureMetrics(\"WordCountApp\", \"WordFrequency\");\n      procedureMetrics.waitForProcessed(1, 1, TimeUnit.SECONDS);\n      Assert.assertEquals(0L, procedureMetrics.getException());\n\n      // Run mapreduce job\n      MapReduceManager mrManager = applicationManager.startMapReduce(\"countTotal\");\n      mrManager.waitForFinish(15L, TimeUnit.SECONDS);\n\n      long totalCount = Long.valueOf(procedureClient.query(\"total\", Collections.<String, String>emptyMap()));\n      // every event has 5 tokens\n      Assert.assertEquals(5 * 100L, totalCount);\n\n    } finally {\n      applicationManager.stopAll();\n      clear();\n    }\n  }","id":102557,"modified_method":"@Test\n  public void testApp() throws InterruptedException, IOException, TimeoutException, OperationException {\n    ApplicationManager applicationManager = deployApplication(WordCountApp2.class);\n\n    try {\n      applicationManager.startFlow(\"WordCountFlow\");\n\n      // Send some inputs to streams\n      StreamWriter streamWriter = applicationManager.getStreamWriter(\"text\");\n      for (int i = 0; i < 100; i++) {\n        streamWriter.send(ImmutableMap.of(\"title\", \"title \" + i), \"testing message \" + i);\n      }\n\n      // Check the flowlet metrics\n      RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"WordCountApp\",\n                                                                     \"WordCountFlow\",\n                                                                     \"CountByField\");\n      flowletMetrics.waitForProcessed(500, 5, TimeUnit.SECONDS);\n      Assert.assertEquals(0L, flowletMetrics.getException());\n\n      // Query the result\n      ProcedureManager procedureManager = applicationManager.startProcedure(\"WordFrequency\");\n      ProcedureClient procedureClient = procedureManager.getClient();\n\n      // Verify the query result\n      Type resultType = new TypeToken<Map<String, Long>>(){}.getType();\n      Gson gson = new Gson();\n      Map<String, Long> result = gson.fromJson(procedureClient.query(\"wordfreq\",\n                                                                     ImmutableMap.of(\"word\", \"text:testing\")),\n                                               resultType);\n\n      Assert.assertEquals(100L, result.get(\"text:testing\").longValue());\n\n      // Verify by looking into dataset\n      MyKeyValueTable mydataset = applicationManager.getDataSet(\"mydataset\");\n      Assert.assertEquals(100L, Longs.fromByteArray(mydataset.read(\"title:title\".getBytes(Charsets.UTF_8))));\n\n      // check the metrics\n      RuntimeMetrics procedureMetrics = RuntimeStats.getProcedureMetrics(\"WordCountApp\", \"WordFrequency\");\n      procedureMetrics.waitForProcessed(1, 1, TimeUnit.SECONDS);\n      Assert.assertEquals(0L, procedureMetrics.getException());\n\n      // Run mapreduce job\n      MapReduceManager mrManager = applicationManager.startMapReduce(\"countTotal\");\n      mrManager.waitForFinish(60L, TimeUnit.SECONDS);\n\n      long totalCount = Long.valueOf(procedureClient.query(\"total\", Collections.<String, String>emptyMap()));\n      // every event has 5 tokens\n      Assert.assertEquals(5 * 100L, totalCount);\n\n    } finally {\n      applicationManager.stopAll();\n      clear();\n    }\n  }","commit_id":"606fbea53499bc53b13988b6bb2d58115a4b9535","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void parse(XContentParser parser, SearchContext context) throws Exception {\n        XContentParser.Token token;\n\n        List<SearchContextFacets.Entry> entries = new ArrayList<SearchContextFacets.Entry>();\n\n        String facetName = null;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                facetName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                FacetExecutor facetExecutor = null;\n                boolean global = false;\n                FacetExecutor.Mode defaultMainMode = null;\n                FacetExecutor.Mode defaultGlobalMode = null;\n                FacetExecutor.Mode mode = null;\n                Filter filter = null;\n                boolean cacheFilter = false;\n                String nestedPath = null;\n\n                String fieldName = null;\n                while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                    if (token == XContentParser.Token.FIELD_NAME) {\n                        fieldName = parser.currentName();\n                    } else if (token == XContentParser.Token.START_OBJECT) {\n                        if (\"facet_filter\".equals(fieldName) || \"facetFilter\".equals(fieldName)) {\n                            filter = context.queryParserService().parseInnerFilter(parser).filter();\n                        } else {\n                            FacetParser facetParser = facetParsers.parser(fieldName);\n                            if (facetParser == null) {\n                                throw new SearchParseException(context, \"No facet type found for [\" + fieldName + \"]\");\n                            }\n                            facetExecutor = facetParser.parse(facetName, parser, context);\n                            defaultMainMode = facetParser.defaultMainMode();\n                            defaultGlobalMode = facetParser.defaultGlobalMode();\n                        }\n                    } else if (token.isValue()) {\n                        if (\"global\".equals(fieldName)) {\n                            global = parser.booleanValue();\n                        } else if (\"mode\".equals(fieldName)) {\n                            String modeAsText = parser.text();\n                            if (\"collector\".equals(modeAsText)) {\n                                mode = FacetExecutor.Mode.COLLECTOR;\n                            } else if (\"post\".equals(modeAsText)) {\n                                mode = FacetExecutor.Mode.POST;\n                            } else {\n                                throw new ElasticSearchIllegalArgumentException(\"failed to parse facet mode [\" + modeAsText + \"]\");\n                            }\n                        } else if (\"scope\".equals(fieldName) || \"_scope\".equals(fieldName)) {\n                            throw new SearchParseException(context, \"the [scope] support in facets have been removed\");\n                        } else if (\"cache_filter\".equals(fieldName) || \"cacheFilter\".equals(fieldName)) {\n                            cacheFilter = parser.booleanValue();\n                        } else if (\"nested\".equals(fieldName)) {\n                            nestedPath = parser.text();\n                        }\n                    }\n                }\n\n                if (filter != null) {\n                    if (cacheFilter) {\n                        filter = context.filterCache().cache(filter);\n                    }\n                }\n\n                if (facetExecutor == null) {\n                    throw new SearchParseException(context, \"no facet type found for facet named [\" + facetName + \"]\");\n                }\n\n                if (nestedPath != null) {\n                    facetExecutor = new NestedFacetExecutor(facetExecutor, context, nestedPath);\n                }\n\n                if (mode == null) {\n                    mode = global ? defaultGlobalMode : defaultMainMode;\n                }\n                entries.add(new SearchContextFacets.Entry(facetName, mode, facetExecutor, global, filter));\n            }\n        }\n\n        context.facets(new SearchContextFacets(entries));\n    }","id":102558,"modified_method":"@Override\n    public void parse(XContentParser parser, SearchContext context) throws Exception {\n        XContentParser.Token token;\n\n        List<SearchContextFacets.Entry> entries = new ArrayList<SearchContextFacets.Entry>();\n\n        String facetName = null;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                facetName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                FacetExecutor facetExecutor = null;\n                boolean global = false;\n                FacetExecutor.Mode defaultMainMode = null;\n                FacetExecutor.Mode defaultGlobalMode = null;\n                FacetExecutor.Mode mode = null;\n                Filter filter = null;\n                boolean cacheFilter = false;\n                String nestedPath = null;\n\n                String fieldName = null;\n                while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                    if (token == XContentParser.Token.FIELD_NAME) {\n                        fieldName = parser.currentName();\n                    } else if (token == XContentParser.Token.START_OBJECT) {\n                        if (\"facet_filter\".equals(fieldName) || \"facetFilter\".equals(fieldName)) {\n                            ParsedFilter parsedFilter = context.queryParserService().parseInnerFilter(parser);\n                            filter = parsedFilter == null ? null : parsedFilter.filter();\n                        } else {\n                            FacetParser facetParser = facetParsers.parser(fieldName);\n                            if (facetParser == null) {\n                                throw new SearchParseException(context, \"No facet type found for [\" + fieldName + \"]\");\n                            }\n                            facetExecutor = facetParser.parse(facetName, parser, context);\n                            defaultMainMode = facetParser.defaultMainMode();\n                            defaultGlobalMode = facetParser.defaultGlobalMode();\n                        }\n                    } else if (token.isValue()) {\n                        if (\"global\".equals(fieldName)) {\n                            global = parser.booleanValue();\n                        } else if (\"mode\".equals(fieldName)) {\n                            String modeAsText = parser.text();\n                            if (\"collector\".equals(modeAsText)) {\n                                mode = FacetExecutor.Mode.COLLECTOR;\n                            } else if (\"post\".equals(modeAsText)) {\n                                mode = FacetExecutor.Mode.POST;\n                            } else {\n                                throw new ElasticSearchIllegalArgumentException(\"failed to parse facet mode [\" + modeAsText + \"]\");\n                            }\n                        } else if (\"scope\".equals(fieldName) || \"_scope\".equals(fieldName)) {\n                            throw new SearchParseException(context, \"the [scope] support in facets have been removed\");\n                        } else if (\"cache_filter\".equals(fieldName) || \"cacheFilter\".equals(fieldName)) {\n                            cacheFilter = parser.booleanValue();\n                        } else if (\"nested\".equals(fieldName)) {\n                            nestedPath = parser.text();\n                        }\n                    }\n                }\n\n                if (filter != null) {\n                    if (cacheFilter) {\n                        filter = context.filterCache().cache(filter);\n                    }\n                }\n\n                if (facetExecutor == null) {\n                    throw new SearchParseException(context, \"no facet type found for facet named [\" + facetName + \"]\");\n                }\n\n                if (nestedPath != null) {\n                    facetExecutor = new NestedFacetExecutor(facetExecutor, context, nestedPath);\n                }\n\n                if (mode == null) {\n                    mode = global ? defaultGlobalMode : defaultMainMode;\n                }\n                entries.add(new SearchContextFacets.Entry(facetName, mode, facetExecutor, global, filter));\n            }\n        }\n\n        context.facets(new SearchContextFacets(entries));\n    }","commit_id":"cf0c360f86eb4ffb3c12999067eef24bf54c883f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public FacetExecutor parse(String facetName, XContentParser parser, SearchContext context) throws IOException {\n        Filter facetFilter = context.queryParserService().parseInnerFilter(parser).filter();\n        return new FilterFacetExecutor(facetFilter);\n    }","id":102559,"modified_method":"@Override\n    public FacetExecutor parse(String facetName, XContentParser parser, SearchContext context) throws IOException {\n        ParsedFilter parsedFilter = context.queryParserService().parseInnerFilter(parser);\n        if (parsedFilter == null) {\n            parsedFilter = ParsedFilter.EMPTY;\n        }\n        return new FilterFacetExecutor(parsedFilter.filter());\n    }","commit_id":"cf0c360f86eb4ffb3c12999067eef24bf54c883f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public SortField parse(XContentParser parser, SearchContext context) throws Exception {\n        String fieldName = null;\n        GeoPoint point = new GeoPoint();\n        DistanceUnit unit = DistanceUnit.KILOMETERS;\n        GeoDistance geoDistance = GeoDistance.ARC;\n        boolean reverse = false;\n        SortMode sortMode = null;\n        String nestedPath = null;\n        Filter nestedFilter = null;\n\n        boolean normalizeLon = true;\n        boolean normalizeLat = true;\n\n        XContentParser.Token token;\n        String currentName = parser.currentName();\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentName = parser.currentName();\n            } else if (token == XContentParser.Token.START_ARRAY) {\n                GeoPoint.parse(parser, point);\n                fieldName = currentName;\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                // the json in the format of -> field : { lat : 30, lon : 12 }\n                if (\"nested_filter\".equals(currentName) || \"nestedFilter\".equals(currentName)) {\n                    nestedFilter = context.queryParserService().parseInnerFilter(parser).filter();\n                } else {\n                    fieldName = currentName;\n                    GeoPoint.parse(parser, point);\n                }\n            } else if (token.isValue()) {\n                if (\"reverse\".equals(currentName)) {\n                    reverse = parser.booleanValue();\n                } else if (\"order\".equals(currentName)) {\n                    reverse = \"desc\".equals(parser.text());\n                } else if (currentName.equals(\"unit\")) {\n                    unit = DistanceUnit.fromString(parser.text());\n                } else if (currentName.equals(\"distance_type\") || currentName.equals(\"distanceType\")) {\n                    geoDistance = GeoDistance.fromString(parser.text());\n                } else if (\"normalize\".equals(currentName)) {\n                    normalizeLat = parser.booleanValue();\n                    normalizeLon = parser.booleanValue();\n                } else if (\"sort_mode\".equals(currentName) || \"sortMode\".equals(currentName) || \"mode\".equals(currentName)) {\n                    sortMode = SortMode.fromString(parser.text());\n                } else if (\"nested_path\".equals(currentName) || \"nestedPath\".equals(currentName)) {\n                    nestedPath = parser.text();\n                } else {\n                    point.resetFromString(parser.text());\n                    fieldName = currentName;\n                }\n            }\n        }\n\n        if (normalizeLat || normalizeLon) {\n            GeoUtils.normalizePoint(point, normalizeLat, normalizeLon);\n        }\n\n        if (sortMode == null) {\n            sortMode = reverse ? SortMode.MAX : SortMode.MIN;\n        }\n\n        if (sortMode == SortMode.SUM) {\n            throw new ElasticSearchIllegalArgumentException(\"sort_mode [sum] isn't supported for sorting by geo distance\");\n        }\n\n        FieldMapper mapper = context.smartNameFieldMapper(fieldName);\n        if (mapper == null) {\n            throw new ElasticSearchIllegalArgumentException(\"failed to find mapper for [\" + fieldName + \"] for geo distance based sort\");\n        }\n        IndexGeoPointFieldData indexFieldData = context.fieldData().getForField(mapper);\n\n        IndexFieldData.XFieldComparatorSource geoDistanceComparatorSource = new GeoDistanceComparatorSource(\n            indexFieldData, point.lat(), point.lon(), unit, geoDistance, sortMode\n        );\n        ObjectMapper objectMapper;\n        if (nestedPath != null) {\n            ObjectMappers objectMappers = context.mapperService().objectMapper(nestedPath);\n            if (objectMappers == null) {\n                throw new ElasticSearchIllegalArgumentException(\"failed to find nested object mapping for explicit nested path [\" + nestedPath + \"]\");\n            }\n            objectMapper = objectMappers.mapper();\n            if (!objectMapper.nested().isNested()) {\n                throw new ElasticSearchIllegalArgumentException(\"mapping for explicit nested path is not mapped as nested: [\" + nestedPath + \"]\");\n            }\n        } else {\n            objectMapper = context.mapperService().resolveClosestNestedObjectMapper(fieldName);\n        }\n        if (objectMapper != null && objectMapper.nested().isNested()) {\n            Filter rootDocumentsFilter = context.filterCache().cache(NonNestedDocsFilter.INSTANCE);\n            Filter innerDocumentsFilter;\n            if (nestedFilter != null) {\n                innerDocumentsFilter = context.filterCache().cache(nestedFilter);\n            } else {\n                innerDocumentsFilter = context.filterCache().cache(objectMapper.nestedTypeFilter());\n            }\n            geoDistanceComparatorSource = new NestedFieldComparatorSource(\n                sortMode, geoDistanceComparatorSource, rootDocumentsFilter, innerDocumentsFilter\n            );\n        }\n\n        return new SortField(fieldName, geoDistanceComparatorSource, reverse);\n    }","id":102560,"modified_method":"@Override\n    public SortField parse(XContentParser parser, SearchContext context) throws Exception {\n        String fieldName = null;\n        GeoPoint point = new GeoPoint();\n        DistanceUnit unit = DistanceUnit.KILOMETERS;\n        GeoDistance geoDistance = GeoDistance.ARC;\n        boolean reverse = false;\n        SortMode sortMode = null;\n        String nestedPath = null;\n        Filter nestedFilter = null;\n\n        boolean normalizeLon = true;\n        boolean normalizeLat = true;\n\n        XContentParser.Token token;\n        String currentName = parser.currentName();\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentName = parser.currentName();\n            } else if (token == XContentParser.Token.START_ARRAY) {\n                GeoPoint.parse(parser, point);\n                fieldName = currentName;\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                // the json in the format of -> field : { lat : 30, lon : 12 }\n                if (\"nested_filter\".equals(currentName) || \"nestedFilter\".equals(currentName)) {\n                    ParsedFilter parsedFilter = context.queryParserService().parseInnerFilter(parser);\n                    nestedFilter = parsedFilter == null ? null : parsedFilter.filter();\n                } else {\n                    fieldName = currentName;\n                    GeoPoint.parse(parser, point);\n                }\n            } else if (token.isValue()) {\n                if (\"reverse\".equals(currentName)) {\n                    reverse = parser.booleanValue();\n                } else if (\"order\".equals(currentName)) {\n                    reverse = \"desc\".equals(parser.text());\n                } else if (currentName.equals(\"unit\")) {\n                    unit = DistanceUnit.fromString(parser.text());\n                } else if (currentName.equals(\"distance_type\") || currentName.equals(\"distanceType\")) {\n                    geoDistance = GeoDistance.fromString(parser.text());\n                } else if (\"normalize\".equals(currentName)) {\n                    normalizeLat = parser.booleanValue();\n                    normalizeLon = parser.booleanValue();\n                } else if (\"sort_mode\".equals(currentName) || \"sortMode\".equals(currentName) || \"mode\".equals(currentName)) {\n                    sortMode = SortMode.fromString(parser.text());\n                } else if (\"nested_path\".equals(currentName) || \"nestedPath\".equals(currentName)) {\n                    nestedPath = parser.text();\n                } else {\n                    point.resetFromString(parser.text());\n                    fieldName = currentName;\n                }\n            }\n        }\n\n        if (normalizeLat || normalizeLon) {\n            GeoUtils.normalizePoint(point, normalizeLat, normalizeLon);\n        }\n\n        if (sortMode == null) {\n            sortMode = reverse ? SortMode.MAX : SortMode.MIN;\n        }\n\n        if (sortMode == SortMode.SUM) {\n            throw new ElasticSearchIllegalArgumentException(\"sort_mode [sum] isn't supported for sorting by geo distance\");\n        }\n\n        FieldMapper mapper = context.smartNameFieldMapper(fieldName);\n        if (mapper == null) {\n            throw new ElasticSearchIllegalArgumentException(\"failed to find mapper for [\" + fieldName + \"] for geo distance based sort\");\n        }\n        IndexGeoPointFieldData indexFieldData = context.fieldData().getForField(mapper);\n\n        IndexFieldData.XFieldComparatorSource geoDistanceComparatorSource = new GeoDistanceComparatorSource(\n            indexFieldData, point.lat(), point.lon(), unit, geoDistance, sortMode\n        );\n        ObjectMapper objectMapper;\n        if (nestedPath != null) {\n            ObjectMappers objectMappers = context.mapperService().objectMapper(nestedPath);\n            if (objectMappers == null) {\n                throw new ElasticSearchIllegalArgumentException(\"failed to find nested object mapping for explicit nested path [\" + nestedPath + \"]\");\n            }\n            objectMapper = objectMappers.mapper();\n            if (!objectMapper.nested().isNested()) {\n                throw new ElasticSearchIllegalArgumentException(\"mapping for explicit nested path is not mapped as nested: [\" + nestedPath + \"]\");\n            }\n        } else {\n            objectMapper = context.mapperService().resolveClosestNestedObjectMapper(fieldName);\n        }\n        if (objectMapper != null && objectMapper.nested().isNested()) {\n            Filter rootDocumentsFilter = context.filterCache().cache(NonNestedDocsFilter.INSTANCE);\n            Filter innerDocumentsFilter;\n            if (nestedFilter != null) {\n                innerDocumentsFilter = context.filterCache().cache(nestedFilter);\n            } else {\n                innerDocumentsFilter = context.filterCache().cache(objectMapper.nestedTypeFilter());\n            }\n            geoDistanceComparatorSource = new NestedFieldComparatorSource(\n                sortMode, geoDistanceComparatorSource, rootDocumentsFilter, innerDocumentsFilter\n            );\n        }\n\n        return new SortField(fieldName, geoDistanceComparatorSource, reverse);\n    }","commit_id":"cf0c360f86eb4ffb3c12999067eef24bf54c883f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private Filter parse(String alias, CompressedString filter) {\n        if (filter == null) {\n            return null;\n        }\n        try {\n            byte[] filterSource = filter.uncompressed();\n            XContentParser parser = XContentFactory.xContent(filterSource).createParser(filterSource);\n            try {\n                return indexQueryParser.parseInnerFilter(parser).filter();\n            } finally {\n                parser.close();\n            }\n        } catch (IOException ex) {\n            throw new AliasFilterParsingException(index, alias, \"Invalid alias filter\", ex);\n        }\n    }","id":102561,"modified_method":"private Filter parse(String alias, CompressedString filter) {\n        if (filter == null) {\n            return null;\n        }\n        try {\n            byte[] filterSource = filter.uncompressed();\n            XContentParser parser = XContentFactory.xContent(filterSource).createParser(filterSource);\n            try {\n                ParsedFilter parsedFilter = indexQueryParser.parseInnerFilter(parser);\n                return parsedFilter == null ? null : parsedFilter.filter();\n            } finally {\n                parser.close();\n            }\n        } catch (IOException ex) {\n            throw new AliasFilterParsingException(index, alias, \"Invalid alias filter\", ex);\n        }\n    }","commit_id":"cf0c360f86eb4ffb3c12999067eef24bf54c883f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ParsedFilter(Filter filter, ImmutableMap<String, Filter> namedFilters) {\n        this.filter = filter;\n        this.namedFilters = namedFilters;\n    }","id":102562,"modified_method":"public ParsedFilter(Filter filter, ImmutableMap<String, Filter> namedFilters) {\n        assert filter != null;\n        assert namedFilters != null;\n        this.filter = filter;\n        this.namedFilters = namedFilters;\n    }","commit_id":"cf0c360f86eb4ffb3c12999067eef24bf54c883f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public SortField parse(XContentParser parser, SearchContext context) throws Exception {\n        String script = null;\n        String scriptLang = null;\n        String type = null;\n        Map<String, Object> params = null;\n        boolean reverse = false;\n        SortMode sortMode = null;\n        String nestedPath = null;\n        Filter nestedFilter = null;\n\n        XContentParser.Token token;\n        String currentName = parser.currentName();\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                if (\"params\".equals(currentName)) {\n                    params = parser.map();\n                } else if (\"nested_filter\".equals(currentName) || \"nestedFilter\".equals(currentName)) {\n                    nestedFilter = context.queryParserService().parseInnerFilter(parser).filter();\n                }\n            } else if (token.isValue()) {\n                if (\"reverse\".equals(currentName)) {\n                    reverse = parser.booleanValue();\n                } else if (\"order\".equals(currentName)) {\n                    reverse = \"desc\".equals(parser.text());\n                } else if (\"script\".equals(currentName)) {\n                    script = parser.text();\n                } else if (\"type\".equals(currentName)) {\n                    type = parser.text();\n                } else if (\"lang\".equals(currentName)) {\n                    scriptLang = parser.text();\n                } else if (\"mode\".equals(currentName)) {\n                    sortMode = SortMode.fromString(parser.text());\n                } else if (\"nested_path\".equals(currentName) || \"nestedPath\".equals(currentName)) {\n                    nestedPath = parser.text();\n                }\n            }\n        }\n\n        if (script == null) {\n            throw new SearchParseException(context, \"_script sorting requires setting the script to sort by\");\n        }\n        if (type == null) {\n            throw new SearchParseException(context, \"_script sorting requires setting the type of the script\");\n        }\n        SearchScript searchScript = context.scriptService().search(context.lookup(), scriptLang, script, params);\n        IndexFieldData.XFieldComparatorSource fieldComparatorSource;\n        if (\"string\".equals(type)) {\n            fieldComparatorSource = StringScriptDataComparator.comparatorSource(searchScript);\n        } else if (\"number\".equals(type)) {\n            fieldComparatorSource = DoubleScriptDataComparator.comparatorSource(searchScript);\n        } else {\n            throw new SearchParseException(context, \"custom script sort type [\" + type + \"] not supported\");\n        }\n\n        if (\"string\".equals(type) && (sortMode == SortMode.SUM || sortMode == SortMode.AVG)) {\n            throw new SearchParseException(context, \"type [string] doesn't support mode [\" + sortMode + \"]\");\n        }\n\n        if (sortMode == null) {\n            sortMode = reverse ? SortMode.MAX : SortMode.MIN;\n        }\n\n        // If nested_path is specified, then wrap the `fieldComparatorSource` in a `NestedFieldComparatorSource`\n        ObjectMapper objectMapper;\n        if (nestedPath != null) {\n            ObjectMappers objectMappers = context.mapperService().objectMapper(nestedPath);\n            if (objectMappers == null) {\n                throw new ElasticSearchIllegalArgumentException(\"failed to find nested object mapping for explicit nested path [\" + nestedPath + \"]\");\n            }\n            objectMapper = objectMappers.mapper();\n            if (!objectMapper.nested().isNested()) {\n                throw new ElasticSearchIllegalArgumentException(\"mapping for explicit nested path is not mapped as nested: [\" + nestedPath + \"]\");\n            }\n\n            Filter rootDocumentsFilter = context.filterCache().cache(NonNestedDocsFilter.INSTANCE);\n            Filter innerDocumentsFilter;\n            if (nestedFilter != null) {\n                innerDocumentsFilter = context.filterCache().cache(nestedFilter);\n            } else {\n                innerDocumentsFilter = context.filterCache().cache(objectMapper.nestedTypeFilter());\n            }\n            fieldComparatorSource = new NestedFieldComparatorSource(sortMode, fieldComparatorSource, rootDocumentsFilter, innerDocumentsFilter);\n        }\n\n        return new SortField(\"_script\", fieldComparatorSource, reverse);\n    }","id":102563,"modified_method":"@Override\n    public SortField parse(XContentParser parser, SearchContext context) throws Exception {\n        String script = null;\n        String scriptLang = null;\n        String type = null;\n        Map<String, Object> params = null;\n        boolean reverse = false;\n        SortMode sortMode = null;\n        String nestedPath = null;\n        Filter nestedFilter = null;\n\n        XContentParser.Token token;\n        String currentName = parser.currentName();\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                if (\"params\".equals(currentName)) {\n                    params = parser.map();\n                } else if (\"nested_filter\".equals(currentName) || \"nestedFilter\".equals(currentName)) {\n                    ParsedFilter parsedFilter = context.queryParserService().parseInnerFilter(parser);\n                    nestedFilter = parsedFilter == null ? null : parsedFilter.filter();\n                }\n            } else if (token.isValue()) {\n                if (\"reverse\".equals(currentName)) {\n                    reverse = parser.booleanValue();\n                } else if (\"order\".equals(currentName)) {\n                    reverse = \"desc\".equals(parser.text());\n                } else if (\"script\".equals(currentName)) {\n                    script = parser.text();\n                } else if (\"type\".equals(currentName)) {\n                    type = parser.text();\n                } else if (\"lang\".equals(currentName)) {\n                    scriptLang = parser.text();\n                } else if (\"mode\".equals(currentName)) {\n                    sortMode = SortMode.fromString(parser.text());\n                } else if (\"nested_path\".equals(currentName) || \"nestedPath\".equals(currentName)) {\n                    nestedPath = parser.text();\n                }\n            }\n        }\n\n        if (script == null) {\n            throw new SearchParseException(context, \"_script sorting requires setting the script to sort by\");\n        }\n        if (type == null) {\n            throw new SearchParseException(context, \"_script sorting requires setting the type of the script\");\n        }\n        SearchScript searchScript = context.scriptService().search(context.lookup(), scriptLang, script, params);\n        IndexFieldData.XFieldComparatorSource fieldComparatorSource;\n        if (\"string\".equals(type)) {\n            fieldComparatorSource = StringScriptDataComparator.comparatorSource(searchScript);\n        } else if (\"number\".equals(type)) {\n            fieldComparatorSource = DoubleScriptDataComparator.comparatorSource(searchScript);\n        } else {\n            throw new SearchParseException(context, \"custom script sort type [\" + type + \"] not supported\");\n        }\n\n        if (\"string\".equals(type) && (sortMode == SortMode.SUM || sortMode == SortMode.AVG)) {\n            throw new SearchParseException(context, \"type [string] doesn't support mode [\" + sortMode + \"]\");\n        }\n\n        if (sortMode == null) {\n            sortMode = reverse ? SortMode.MAX : SortMode.MIN;\n        }\n\n        // If nested_path is specified, then wrap the `fieldComparatorSource` in a `NestedFieldComparatorSource`\n        ObjectMapper objectMapper;\n        if (nestedPath != null) {\n            ObjectMappers objectMappers = context.mapperService().objectMapper(nestedPath);\n            if (objectMappers == null) {\n                throw new ElasticSearchIllegalArgumentException(\"failed to find nested object mapping for explicit nested path [\" + nestedPath + \"]\");\n            }\n            objectMapper = objectMappers.mapper();\n            if (!objectMapper.nested().isNested()) {\n                throw new ElasticSearchIllegalArgumentException(\"mapping for explicit nested path is not mapped as nested: [\" + nestedPath + \"]\");\n            }\n\n            Filter rootDocumentsFilter = context.filterCache().cache(NonNestedDocsFilter.INSTANCE);\n            Filter innerDocumentsFilter;\n            if (nestedFilter != null) {\n                innerDocumentsFilter = context.filterCache().cache(nestedFilter);\n            } else {\n                innerDocumentsFilter = context.filterCache().cache(objectMapper.nestedTypeFilter());\n            }\n            fieldComparatorSource = new NestedFieldComparatorSource(sortMode, fieldComparatorSource, rootDocumentsFilter, innerDocumentsFilter);\n        }\n\n        return new SortField(\"_script\", fieldComparatorSource, reverse);\n    }","commit_id":"cf0c360f86eb4ffb3c12999067eef24bf54c883f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void addCompoundSortField(XContentParser parser, SearchContext context, List<SortField> sortFields) throws Exception {\n        XContentParser.Token token;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                String fieldName = parser.currentName();\n                boolean reverse = false;\n                String missing = null;\n                String innerJsonName = null;\n                boolean ignoreUnmapped = false;\n                SortMode sortMode = null;\n                Filter nestedFilter = null;\n                String nestedPath = null;\n                token = parser.nextToken();\n                if (token == XContentParser.Token.VALUE_STRING) {\n                    String direction = parser.text();\n                    if (direction.equals(\"asc\")) {\n                        reverse = SCORE_FIELD_NAME.equals(fieldName);\n                    } else if (direction.equals(\"desc\")) {\n                        reverse = !SCORE_FIELD_NAME.equals(fieldName);\n                    } else {\n                        throw new ElasticSearchIllegalArgumentException(\"sort direction [\" + fieldName + \"] not supported\");\n                    }\n                    addSortField(context, sortFields, fieldName, reverse, ignoreUnmapped, missing, sortMode, nestedPath, nestedFilter);\n                } else {\n                    if (parsers.containsKey(fieldName)) {\n                        sortFields.add(parsers.get(fieldName).parse(parser, context));\n                    } else {\n                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                            if (token == XContentParser.Token.FIELD_NAME) {\n                                innerJsonName = parser.currentName();\n                            } else if (token.isValue()) {\n                                if (\"reverse\".equals(innerJsonName)) {\n                                    reverse = parser.booleanValue();\n                                } else if (\"order\".equals(innerJsonName)) {\n                                    if (\"asc\".equals(parser.text())) {\n                                        reverse = SCORE_FIELD_NAME.equals(fieldName);\n                                    } else if (\"desc\".equals(parser.text())) {\n                                        reverse = !SCORE_FIELD_NAME.equals(fieldName);\n                                    }\n                                } else if (\"missing\".equals(innerJsonName)) {\n                                    missing = parser.textOrNull();\n                                } else if (\"ignore_unmapped\".equals(innerJsonName) || \"ignoreUnmapped\".equals(innerJsonName)) {\n                                    ignoreUnmapped = parser.booleanValue();\n                                } else if (\"mode\".equals(innerJsonName)) {\n                                    sortMode = SortMode.fromString(parser.text());\n                                } else if (\"nested_path\".equals(innerJsonName) || \"nestedPath\".equals(innerJsonName)) {\n                                    nestedPath = parser.text();\n                                } else {\n                                    throw new ElasticSearchIllegalArgumentException(\"sort option [\" + innerJsonName + \"] not supported\");\n                                }\n                            } else if (token == XContentParser.Token.START_OBJECT) {\n                                if (\"nested_filter\".equals(innerJsonName) || \"nestedFilter\".equals(innerJsonName)) {\n                                    nestedFilter = context.queryParserService().parseInnerFilter(parser).filter();\n                                } else {\n                                    throw new ElasticSearchIllegalArgumentException(\"sort option [\" + innerJsonName + \"] not supported\");\n                                }\n                            }\n                        }\n                        addSortField(context, sortFields, fieldName, reverse, ignoreUnmapped, missing, sortMode, nestedPath, nestedFilter);\n                    }\n                }\n            }\n        }\n    }","id":102564,"modified_method":"private void addCompoundSortField(XContentParser parser, SearchContext context, List<SortField> sortFields) throws Exception {\n        XContentParser.Token token;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                String fieldName = parser.currentName();\n                boolean reverse = false;\n                String missing = null;\n                String innerJsonName = null;\n                boolean ignoreUnmapped = false;\n                SortMode sortMode = null;\n                Filter nestedFilter = null;\n                String nestedPath = null;\n                token = parser.nextToken();\n                if (token == XContentParser.Token.VALUE_STRING) {\n                    String direction = parser.text();\n                    if (direction.equals(\"asc\")) {\n                        reverse = SCORE_FIELD_NAME.equals(fieldName);\n                    } else if (direction.equals(\"desc\")) {\n                        reverse = !SCORE_FIELD_NAME.equals(fieldName);\n                    } else {\n                        throw new ElasticSearchIllegalArgumentException(\"sort direction [\" + fieldName + \"] not supported\");\n                    }\n                    addSortField(context, sortFields, fieldName, reverse, ignoreUnmapped, missing, sortMode, nestedPath, nestedFilter);\n                } else {\n                    if (parsers.containsKey(fieldName)) {\n                        sortFields.add(parsers.get(fieldName).parse(parser, context));\n                    } else {\n                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                            if (token == XContentParser.Token.FIELD_NAME) {\n                                innerJsonName = parser.currentName();\n                            } else if (token.isValue()) {\n                                if (\"reverse\".equals(innerJsonName)) {\n                                    reverse = parser.booleanValue();\n                                } else if (\"order\".equals(innerJsonName)) {\n                                    if (\"asc\".equals(parser.text())) {\n                                        reverse = SCORE_FIELD_NAME.equals(fieldName);\n                                    } else if (\"desc\".equals(parser.text())) {\n                                        reverse = !SCORE_FIELD_NAME.equals(fieldName);\n                                    }\n                                } else if (\"missing\".equals(innerJsonName)) {\n                                    missing = parser.textOrNull();\n                                } else if (\"ignore_unmapped\".equals(innerJsonName) || \"ignoreUnmapped\".equals(innerJsonName)) {\n                                    ignoreUnmapped = parser.booleanValue();\n                                } else if (\"mode\".equals(innerJsonName)) {\n                                    sortMode = SortMode.fromString(parser.text());\n                                } else if (\"nested_path\".equals(innerJsonName) || \"nestedPath\".equals(innerJsonName)) {\n                                    nestedPath = parser.text();\n                                } else {\n                                    throw new ElasticSearchIllegalArgumentException(\"sort option [\" + innerJsonName + \"] not supported\");\n                                }\n                            } else if (token == XContentParser.Token.START_OBJECT) {\n                                if (\"nested_filter\".equals(innerJsonName) || \"nestedFilter\".equals(innerJsonName)) {\n                                    ParsedFilter parsedFilter = context.queryParserService().parseInnerFilter(parser);\n                                    nestedFilter = parsedFilter == null ? null : parsedFilter.filter();\n                                } else {\n                                    throw new ElasticSearchIllegalArgumentException(\"sort option [\" + innerJsonName + \"] not supported\");\n                                }\n                            }\n                        }\n                        addSortField(context, sortFields, fieldName, reverse, ignoreUnmapped, missing, sortMode, nestedPath, nestedFilter);\n                    }\n                }\n            }\n        }\n    }","commit_id":"cf0c360f86eb4ffb3c12999067eef24bf54c883f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public boolean enqueue(DeferredSerialization ds) {\n        throw new UnsupportedOperationException();\n    }","id":102565,"modified_method":"@Override\n    public void enqueue(DeferredSerialization ds) {\n        throw new UnsupportedOperationException();\n    }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public boolean enqueue(ByteBuffer b) {\n        throw new UnsupportedOperationException();\n    }","id":102566,"modified_method":"@Override\n    public void enqueue(ByteBuffer b) {\n        throw new UnsupportedOperationException();\n    }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    synchronized public boolean isEmpty()\n    {\n        return m_queuedBuffers.isEmpty() && m_queuedWrites.isEmpty();\n    }","id":102567,"modified_method":"@Override\n    synchronized public boolean isEmpty()\n    {\n        return m_queuedBuffers.isEmpty() && m_queuedWrites.isEmpty() && m_currentWriteBuffer == null;\n    }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void tearDown() {\n        stream.shutdown();\n        pool.clear();\n    }","id":102568,"modified_method":"@Override\n    public void tearDown() {\n        stream.shutdown();\n\n    }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void setUp() {\n        channel = new MockReadableByteChannel();\n        stream = new NIOReadStream();\n        pool = new DBBPool();\n    }","id":102569,"modified_method":"@Override\n    public void setUp() {\n        channel = new MockReadableByteChannel();\n        stream = new NIOReadStream();\n        pool = new NetworkDBBPool();\n    }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testIncompleteReads() throws IOException {\n        channel.nextRead = new byte[17408];\n        assertEquals(NIOReadStream.BUFFER_SIZE, stream.read(channel, 1500, pool));\n        assertEquals(NIOReadStream.BUFFER_SIZE, stream.dataAvailable());\n        channel.nextRead = new byte[500];\n        assertEquals(500, stream.read(channel, 1500, pool));\n        assertEquals(8692, stream.dataAvailable());\n    }","id":102570,"modified_method":"public void testIncompleteReads() throws IOException {\n        channel.nextRead = new byte[17408];\n        assertEquals(1024 * 32, stream.read(channel, 1500, pool));\n        assertEquals(1024 * 32, stream.dataAvailable());\n        channel.nextRead = new byte[500];\n        assertEquals(500, stream.read(channel, 1500, pool));\n        assertEquals(8692, stream.dataAvailable());\n    }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testClosed() throws IOException {\n        MockChannel channel = new MockChannel(MockChannel.FULL);\n        MockPort port = new MockPort();\n        NIOWriteStream wstream = new NIOWriteStream(port);\n\n        ByteBuffer tmp = ByteBuffer.allocate(5);\n        tmp.put((byte)1);\n        tmp.put((byte)2);\n        tmp.put((byte)3);\n        tmp.put((byte)4);\n        tmp.flip();\n        assertTrue(wstream.enqueue(tmp));\n        assertTrue(port.checkWriteSet());\n        int closed = wstream.drainTo(channel, wstream.swapAndSerializeQueuedWrites(pool));\n        assertEquals(closed, 0);\n\n        channel.m_open = false;\n\n        boolean threwException = false;\n        try {\n            assertEquals( -1, wstream.drainTo( channel, wstream.swapAndSerializeQueuedWrites(pool)));\n        } catch (IOException e) {\n            threwException = true;\n        }\n        assertTrue(threwException);\n        wstream.shutdown();\n\n    }","id":102571,"modified_method":"public void testClosed() throws IOException {\n        MockChannel channel = new MockChannel(MockChannel.FULL);\n        MockPort port = new MockPort();\n        NIOWriteStream wstream = new NIOWriteStream(port);\n\n        ByteBuffer tmp = ByteBuffer.allocate(4);\n        tmp.put((byte)1);\n        tmp.put((byte)2);\n        tmp.put((byte)3);\n        tmp.put((byte)4);\n        tmp.flip();\n        wstream.enqueue(tmp);\n        assertTrue(port.checkWriteSet());\n        wstream.swapAndSerializeQueuedWrites(pool);\n        int closed = wstream.drainTo(channel);\n        assertEquals(closed, 0);\n\n        channel.m_open = false;\n\n        boolean threwException = false;\n        try {\n            wstream.swapAndSerializeQueuedWrites(pool);\n            assertEquals( -1, wstream.drainTo( channel));\n        } catch (IOException e) {\n            threwException = true;\n        }\n        assertTrue(threwException);\n        wstream.shutdown();\n\n    }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testLastWriteDelta() throws Exception {\n        final MockChannel channel = new MockChannel(MockChannel.SINK);\n        MockPort port = new MockPort();\n        NIOWriteStream wstream = new NIOWriteStream(port);\n\n        assertEquals( 0, wstream.calculatePendingWriteDelta(999));\n\n        EstTimeUpdater.update(System.currentTimeMillis());\n\n        /**\n         * Test the basic write and drain\n         */\n        final ByteBuffer b = ByteBuffer.allocate(5);\n        wstream.enqueue(b.duplicate());\n        assertEquals( 5, wstream.calculatePendingWriteDelta(EstTime.currentTimeMillis() + 5));\n        wstream.drainTo( channel, wstream.swapAndSerializeQueuedWrites(pool));\n        assertEquals( 0, wstream.calculatePendingWriteDelta(EstTime.currentTimeMillis() + 5));\n\n        Thread.sleep(20);\n        EstTimeUpdater.update(System.currentTimeMillis());\n\n        wstream.enqueue(b.duplicate());\n        assertEquals( 5, wstream.calculatePendingWriteDelta(EstTime.currentTimeMillis() + 5));\n        wstream.enqueue(b.duplicate());\n        assertEquals( 5, wstream.calculatePendingWriteDelta(EstTime.currentTimeMillis() + 5));\n        channel.m_behavior = MockChannel.PARTIAL;\n        wstream.drainTo( channel, wstream.swapAndSerializeQueuedWrites(pool));\n        assertEquals( 5, wstream.calculatePendingWriteDelta(EstTime.currentTimeMillis() + 5));\n\n        wstream.shutdown();\n    }","id":102572,"modified_method":"public void testLastWriteDelta() throws Exception {\n        final MockChannel channel = new MockChannel(MockChannel.SINK);\n        MockPort port = new MockPort();\n        NIOWriteStream wstream = new NIOWriteStream(port);\n\n        assertEquals( 0, wstream.calculatePendingWriteDelta(999));\n\n        EstTimeUpdater.update(System.currentTimeMillis());\n\n        /**\n         * Test the basic write and drain\n         */\n        final ByteBuffer b = ByteBuffer.allocate(5);\n        wstream.enqueue(b.duplicate());\n        assertEquals( 5, wstream.calculatePendingWriteDelta(EstTime.currentTimeMillis() + 5));\n        wstream.swapAndSerializeQueuedWrites(pool);\n        wstream.drainTo( channel);\n        assertEquals( 0, wstream.calculatePendingWriteDelta(EstTime.currentTimeMillis() + 5));\n\n        Thread.sleep(20);\n        EstTimeUpdater.update(System.currentTimeMillis());\n\n        wstream.enqueue(b.duplicate());\n        assertEquals( 5, wstream.calculatePendingWriteDelta(EstTime.currentTimeMillis() + 5));\n        wstream.enqueue(b.duplicate());\n        assertEquals( 5, wstream.calculatePendingWriteDelta(EstTime.currentTimeMillis() + 5));\n        channel.m_behavior = MockChannel.PARTIAL;\n        wstream.swapAndSerializeQueuedWrites(pool);\n        wstream.drainTo( channel );\n        assertEquals( 5, wstream.calculatePendingWriteDelta(EstTime.currentTimeMillis() + 5));\n\n        wstream.shutdown();\n    }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public MockPort() {\n            super(null, null, 2048, \"\");\n        }","id":102573,"modified_method":"public MockPort() {\n            super(null, null, \"\", pool);\n        }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void setUp() {\n        pool = new DBBPool();\n    }","id":102574,"modified_method":"@Override\n    public void setUp() {\n        pool = new NetworkDBBPool();\n    }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testLargeNonDirectWrite() throws IOException {\n        MockChannel channel = new MockChannel(MockChannel.SINK);\n        MockPort port = new MockPort();\n        NIOWriteStream wstream = new NIOWriteStream(port);\n\n        ByteBuffer tmp = ByteBuffer.allocate(NIOWriteStream.MAX_GATHERING_WRITE * 3);\n        final AtomicInteger discardCount = new AtomicInteger(0);\n        BBContainer bbc = new BBContainer(tmp, 0L) {\n            @Override\n            public void discard() {\n                discardCount.addAndGet(1);\n            }\n        };\n\n        assertTrue(wstream.enqueue(bbc));\n        assertTrue(port.checkWriteSet());\n        int written = wstream.drainTo( channel, wstream.swapAndSerializeQueuedWrites(pool));\n        assertEquals( NIOWriteStream.MAX_GATHERING_WRITE * 3, written);\n        assertFalse(channel.didOversizeWrite);\n        assertTrue(discardCount.get() == 1);\n        wstream.shutdown();\n    }","id":102575,"modified_method":"public void testLargeNonDirectWrite() throws IOException {\n        MockChannel channel = new MockChannel(MockChannel.SINK);\n        MockPort port = new MockPort();\n        NIOWriteStream wstream = new NIOWriteStream(port);\n\n        ByteBuffer tmp = ByteBuffer.allocate(262144 * 3);\n        wstream.enqueue(tmp);\n        assertTrue(port.checkWriteSet());\n        wstream.swapAndSerializeQueuedWrites(pool);\n        int written = wstream.drainTo( channel);\n        assertEquals( 262144 * 3, written);\n        assertFalse(channel.didOversizeWrite);\n        wstream.shutdown();\n    }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testFull() throws IOException {\n        MockChannel channel = new MockChannel(MockChannel.FULL);\n        MockPort port = new MockPort();\n        NIOWriteStream wstream = new NIOWriteStream(port);\n        assertTrue(wstream.isEmpty());\n\n        ByteBuffer tmp = ByteBuffer.allocate(5);\n        tmp.put((byte)1);\n        tmp.put((byte)2);\n        tmp.put((byte)3);\n        tmp.put((byte)4);\n        tmp.flip();\n        assertTrue(wstream.enqueue(tmp));\n        assertTrue(port.checkWriteSet());\n        assertEquals(1, wstream.getOutstandingMessageCount());\n        assertEquals(0, wstream.drainTo(channel, wstream.swapAndSerializeQueuedWrites(pool)));\n        assertFalse(wstream.isEmpty());\n        assertEquals(1, wstream.getOutstandingMessageCount());\n\n        channel.m_behavior = MockChannel.SINK;\n        int wrote = wstream.drainTo(channel, wstream.swapAndSerializeQueuedWrites(pool));\n        assertEquals(4, wrote);\n        assertTrue(wstream.isEmpty());\n        assertEquals(0, wstream.getOutstandingMessageCount());\n        wstream.shutdown();\n    }","id":102576,"modified_method":"public void testFull() throws IOException {\n        MockChannel channel = new MockChannel(MockChannel.FULL);\n        MockPort port = new MockPort();\n        NIOWriteStream wstream = new NIOWriteStream(port);\n        assertTrue(wstream.isEmpty());\n\n        ByteBuffer tmp = ByteBuffer.allocate(4);\n        tmp.put((byte)1);\n        tmp.put((byte)2);\n        tmp.put((byte)3);\n        tmp.put((byte)4);\n        tmp.flip();\n        wstream.enqueue(tmp);\n        assertTrue(port.checkWriteSet());\n        assertEquals(1, wstream.getOutstandingMessageCount());\n        wstream.swapAndSerializeQueuedWrites(pool);\n        wstream.drainTo(channel);\n        assertFalse(wstream.isEmpty());\n\n        channel.m_behavior = MockChannel.SINK;\n        wstream.swapAndSerializeQueuedWrites(pool);\n        int wrote = wstream.drainTo(channel);\n        assertEquals(4, wrote);\n        assertTrue(wstream.isEmpty());\n        assertEquals(0, wstream.getOutstandingMessageCount());\n        wstream.shutdown();\n    }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testPartial() throws IOException {\n        MockChannel channel = new MockChannel(MockChannel.PARTIAL);\n        MockPort port = new MockPort();\n        NIOWriteStream wstream = new NIOWriteStream(port);\n        assertTrue(wstream.isEmpty());\n\n        ByteBuffer tmp = ByteBuffer.allocate(5);\n        tmp.put((byte)1);\n        tmp.put((byte)2);\n        tmp.put((byte)3);\n        tmp.put((byte)4);\n        tmp.flip();\n        assertTrue(wstream.enqueue(tmp));\n        assertTrue(port.checkWriteSet());\n        int wrote = wstream.drainTo(channel, wstream.swapAndSerializeQueuedWrites(pool));\n        assertFalse(wstream.isEmpty());\n        assertEquals(2, wrote);\n\n        channel.wrotePartial = false;\n\n        ByteBuffer tmp2 = ByteBuffer.allocate(4);\n        tmp2.put((byte)5);\n        tmp2.put((byte)6);\n        tmp2.put((byte)7);\n        tmp2.put((byte)8);\n        tmp2.flip();\n        wstream.enqueue(tmp2);\n        org.voltcore.utils.DBBPool.BBContainer containers[] = wstream.swapAndSerializeQueuedWrites(pool);\n        wrote += wstream.drainTo( channel, containers);\n        assertFalse(wstream.isEmpty());\n        // wrote half of half of the first buffer (note +=)\n        assertEquals(3, wrote);\n\n        channel.m_behavior = MockChannel.SINK;\n        wrote += wstream.drainTo( channel, wstream.swapAndSerializeQueuedWrites(pool));\n        assertEquals(8, wrote);\n        assertTrue(wstream.isEmpty());\n        wstream.shutdown();\n    }","id":102577,"modified_method":"public void testPartial() throws IOException {\n        MockChannel channel = new MockChannel(MockChannel.PARTIAL);\n        MockPort port = new MockPort();\n        NIOWriteStream wstream = new NIOWriteStream(port);\n        assertTrue(wstream.isEmpty());\n\n        ByteBuffer tmp = ByteBuffer.allocate(4);\n        tmp.put((byte)1);\n        tmp.put((byte)2);\n        tmp.put((byte)3);\n        tmp.put((byte)4);\n        tmp.flip();\n        wstream.enqueue(tmp);\n        assertTrue(port.checkWriteSet());\n        wstream.swapAndSerializeQueuedWrites(pool);\n        int wrote = wstream.drainTo(channel);\n        assertFalse(wstream.isEmpty());\n        assertEquals(2, wrote);\n\n        channel.wrotePartial = false;\n\n        ByteBuffer tmp2 = ByteBuffer.allocate(4);\n        tmp2.put((byte)5);\n        tmp2.put((byte)6);\n        tmp2.put((byte)7);\n        tmp2.put((byte)8);\n        tmp2.flip();\n        wstream.enqueue(tmp2);\n        wstream.swapAndSerializeQueuedWrites(pool);\n        wrote += wstream.drainTo( channel);\n        assertFalse(wstream.isEmpty());\n        // wrote half of half of the first buffer (note +=)\n        assertEquals(3, wrote);\n\n        channel.m_behavior = MockChannel.SINK;\n        wstream.swapAndSerializeQueuedWrites(pool);\n        wrote += wstream.drainTo( channel);\n        assertEquals(8, wrote);\n        assertTrue(wstream.isEmpty());\n        wstream.shutdown();\n    }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testSink() throws IOException {\n        MockChannel channel = new MockChannel(MockChannel.SINK);\n        MockPort port = new MockPort();\n        NIOWriteStream wstream = new NIOWriteStream(port);\n        assertTrue(wstream.isEmpty());\n\n        ByteBuffer tmp = ByteBuffer.allocate(5);\n        tmp.put((byte) 1);\n        tmp.put((byte) 2);\n        tmp.flip();\n        assertTrue(wstream.enqueue(tmp));\n        assertTrue(port.checkWriteSet());\n        assertEquals(1, wstream.getOutstandingMessageCount());\n        assertEquals(2, wstream.drainTo(channel, wstream.swapAndSerializeQueuedWrites(pool)));\n        assertTrue(wstream.isEmpty());\n        assertEquals(0, wstream.getOutstandingMessageCount());\n        wstream.shutdown();\n        port.toString();\n    }","id":102578,"modified_method":"public void testSink() throws IOException {\n        MockChannel channel = new MockChannel(MockChannel.SINK);\n        MockPort port = new MockPort();\n        NIOWriteStream wstream = new NIOWriteStream(port);\n        assertTrue(wstream.isEmpty());\n\n        ByteBuffer tmp = ByteBuffer.allocate(2);\n        tmp.put((byte) 1);\n        tmp.put((byte) 2);\n        tmp.flip();\n        wstream.enqueue(tmp);\n        assertTrue(port.checkWriteSet());\n        assertEquals(1, wstream.getOutstandingMessageCount());\n        wstream.swapAndSerializeQueuedWrites(pool);\n        assertEquals(2, wstream.drainTo(channel));\n        assertTrue(wstream.isEmpty());\n        assertEquals(0, wstream.getOutstandingMessageCount());\n        wstream.shutdown();\n        port.toString();\n    }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public int write(ByteBuffer src) throws IOException {\n            if (!m_open) throw new IOException();\n\n            if (!src.hasRemaining()) {\n                wroteSizeZero = true;\n            }\n\n            if (!src.isDirect()) {\n                if (src.remaining() > NIOWriteStream.MAX_GATHERING_WRITE) {\n                    didOversizeWrite = true;\n                }\n            }\n            if (m_behavior == SINK) {\n                int remaining = src.remaining();\n                src.position(src.limit());\n                return remaining;\n            }\n            else if (m_behavior == FULL) {\n                return 0;\n            }\n            else if (m_behavior == PARTIAL) {\n                if (wrotePartial) {\n                    return 0;\n                } else {\n                    wrotePartial = true;\n                }\n                ByteBuffer copy = ByteBuffer.allocate(src.remaining());\n                src.get(copy.array(), 0, src.remaining()/2);\n                return src.remaining();\n            }\n            assert(false);\n            return -1;\n        }","id":102579,"modified_method":"@Override\n        public int write(ByteBuffer src) throws IOException {\n            if (!m_open) throw new IOException();\n\n            if (!src.hasRemaining()) {\n                wroteSizeZero = true;\n            }\n\n            if (!src.isDirect()) {\n                if (src.remaining() > 1024 * 256) {\n                    didOversizeWrite = true;\n                }\n            }\n            if (m_behavior == SINK) {\n                int remaining = src.remaining();\n                src.position(src.limit());\n                return remaining;\n            }\n            else if (m_behavior == FULL) {\n                return 0;\n            }\n            else if (m_behavior == PARTIAL) {\n                if (wrotePartial) {\n                    return 0;\n                } else {\n                    wrotePartial = true;\n                }\n                ByteBuffer copy = ByteBuffer.allocate(src.remaining());\n                src.get(copy.array(), 0, src.remaining()/2);\n                return src.remaining();\n            }\n            assert(false);\n            return -1;\n        }","commit_id":"d4076a41d292e7967e00f211bf6926a87a744b35","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Checks the set of URLs for duplicate classes\n     * @throws IllegalStateException if jar hell was found\n     */\n    @SuppressForbidden(reason = \"needs JarFile for speed, just reading entries\")\n    public static void checkJarHell(URL urls[]) throws Exception {\n        ESLogger logger = Loggers.getLogger(JarHell.class);\n        // we don't try to be sneaky and use deprecated/internal/not portable stuff\n        // like sun.boot.class.path, and with jigsaw we don't yet have a way to get\n        // a \"list\" at all. So just exclude any elements underneath the java home\n        String javaHome = System.getProperty(\"java.home\");\n        logger.debug(\"java.home: {}\", javaHome);\n        final Map<String,Path> clazzes = new HashMap<>(32768);\n        Set<Path> seenJars = new HashSet<>();\n        for (final URL url : urls) {\n            final Path path = PathUtils.get(url.toURI());\n            // exclude system resources\n            if (path.startsWith(javaHome)) {\n                logger.debug(\"excluding system resource: {}\", path);\n                continue;\n            }\n            if (path.toString().endsWith(\".jar\")) {\n                if (!seenJars.add(path)) {\n                    logger.debug(\"excluding duplicate classpath element: {}\", path);\n                    continue; // we can't fail because of sheistiness with joda-time\n                }\n                logger.debug(\"examining jar: {}\", path);\n                try (JarFile file = new JarFile(path.toString())) {\n                    Manifest manifest = file.getManifest();\n                    if (manifest != null) {\n                        // inspect Manifest: give a nice error if jar requires a newer java version\n                        String systemVersion = System.getProperty(\"java.specification.version\");\n                        String targetVersion = manifest.getMainAttributes().getValue(\"X-Compile-Target-JDK\");\n                        if (targetVersion != null) {\n                            float current = Float.POSITIVE_INFINITY;\n                            float target = Float.NEGATIVE_INFINITY;\n                            try {\n                                current = Float.parseFloat(systemVersion);\n                                target = Float.parseFloat(targetVersion);\n                            } catch (NumberFormatException e) {\n                                // some spec changed, time for a more complex parser\n                            }\n                            if (current < target) {\n                                throw new IllegalStateException(path + \" requires Java \" + targetVersion\n                                        + \", your system: \" + systemVersion);\n                            }\n                        }\n                    }\n                    // inspect entries\n                    Enumeration<JarEntry> elements = file.entries();\n                    while (elements.hasMoreElements()) {\n                        String entry = elements.nextElement().getName();\n                        if (entry.endsWith(\".class\")) {\n                            // for jar format, the separator is defined as /\n                            entry = entry.replace('/', '.').substring(0, entry.length() - 6);\n                            checkClass(clazzes, entry, path);\n                        }\n                    }\n                }\n            } else {\n                logger.debug(\"examining directory: {}\", path);\n                // case for tests: where we have class files in the classpath\n                final Path root = PathUtils.get(url.toURI());\n                final String sep = root.getFileSystem().getSeparator();\n                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n                    @Override\n                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                        String entry = root.relativize(file).toString();\n                        if (entry.endsWith(\".class\")) {\n                            // normalize with the os separator\n                            entry = entry.replace(sep, \".\").substring(0,  entry.length() - 6);\n                            checkClass(clazzes, entry, path);\n                        }\n                        return super.visitFile(file, attrs);\n                    }\n                });\n            }\n        }\n    }","id":102580,"modified_method":"/**\n     * Checks the set of URLs for duplicate classes\n     * @throws IllegalStateException if jar hell was found\n     */\n    @SuppressForbidden(reason = \"needs JarFile for speed, just reading entries\")\n    public static void checkJarHell(URL urls[]) throws Exception {\n        ESLogger logger = Loggers.getLogger(JarHell.class);\n        // we don't try to be sneaky and use deprecated/internal/not portable stuff\n        // like sun.boot.class.path, and with jigsaw we don't yet have a way to get\n        // a \"list\" at all. So just exclude any elements underneath the java home\n        String javaHome = System.getProperty(\"java.home\");\n        logger.debug(\"java.home: {}\", javaHome);\n        final Map<String,Path> clazzes = new HashMap<>(32768);\n        Set<Path> seenJars = new HashSet<>();\n        for (final URL url : urls) {\n            final Path path = PathUtils.get(url.toURI());\n            // exclude system resources\n            if (path.startsWith(javaHome)) {\n                logger.debug(\"excluding system resource: {}\", path);\n                continue;\n            }\n            if (path.toString().endsWith(\".jar\")) {\n                if (!seenJars.add(path)) {\n                    logger.debug(\"excluding duplicate classpath element: {}\", path);\n                    continue; // we can't fail because of sheistiness with joda-time\n                }\n                logger.debug(\"examining jar: {}\", path);\n                try (JarFile file = new JarFile(path.toString())) {\n                    Manifest manifest = file.getManifest();\n                    if (manifest != null) {\n                        checkManifest(manifest, path);\n                    }\n                    // inspect entries\n                    Enumeration<JarEntry> elements = file.entries();\n                    while (elements.hasMoreElements()) {\n                        String entry = elements.nextElement().getName();\n                        if (entry.endsWith(\".class\")) {\n                            // for jar format, the separator is defined as /\n                            entry = entry.replace('/', '.').substring(0, entry.length() - 6);\n                            checkClass(clazzes, entry, path);\n                        }\n                    }\n                }\n            } else {\n                logger.debug(\"examining directory: {}\", path);\n                // case for tests: where we have class files in the classpath\n                final Path root = PathUtils.get(url.toURI());\n                final String sep = root.getFileSystem().getSeparator();\n                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n                    @Override\n                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                        String entry = root.relativize(file).toString();\n                        if (entry.endsWith(\".class\")) {\n                            // normalize with the os separator\n                            entry = entry.replace(sep, \".\").substring(0,  entry.length() - 6);\n                            checkClass(clazzes, entry, path);\n                        }\n                        return super.visitFile(file, attrs);\n                    }\n                });\n            }\n        }\n    }","commit_id":"5d48f93557bb42a291c649f48fccdf7a429b2dac","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDirsOnClasspath() throws Exception {\n        Path dir1 = createTempDir();\n        Path dir2 = createTempDir();\n        URL[] dirs = {makeFile(dir1, \"DuplicateClass.class\"), makeFile(dir2, \"DuplicateClass.class\")};\n        try {\n            JarHell.checkJarHell(dirs);\n        } catch (IllegalStateException e) {\n            assertTrue(e.getMessage().contains(\"jar hell!\"));\n            assertTrue(e.getMessage().contains(\"DuplicateClass\"));\n            assertTrue(e.getMessage().contains(dir1.toString()));\n            assertTrue(e.getMessage().contains(dir2.toString()));\n        }\n    }","id":102581,"modified_method":"public void testDirsOnClasspath() throws Exception {\n        Path dir1 = createTempDir();\n        Path dir2 = createTempDir();\n        URL[] dirs = {makeFile(dir1, \"DuplicateClass.class\"), makeFile(dir2, \"DuplicateClass.class\")};\n        try {\n            JarHell.checkJarHell(dirs);\n            fail(\"did not get expected exception\");\n        } catch (IllegalStateException e) {\n            assertTrue(e.getMessage().contains(\"jar hell!\"));\n            assertTrue(e.getMessage().contains(\"DuplicateClass\"));\n            assertTrue(e.getMessage().contains(dir1.toString()));\n            assertTrue(e.getMessage().contains(dir2.toString()));\n        }\n    }","commit_id":"5d48f93557bb42a291c649f48fccdf7a429b2dac","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testBadJDKVersionInJar() throws Exception {\n        Path dir = createTempDir();\n        Manifest manifest = new Manifest();\n        manifest.getMainAttributes().put(new Attributes.Name(\"X-Compile-Target-JDK\"), \"bogus\");\n        URL[] jars = {makeJar(dir, \"foo.jar\", manifest, \"Foo.class\")};\n        JarHell.checkJarHell(jars);\n    }","id":102582,"modified_method":"public void testBadJDKVersionInJar() throws Exception {\n        Path dir = createTempDir();\n        Manifest manifest = new Manifest();\n        Attributes attributes = manifest.getMainAttributes();\n        attributes.put(Attributes.Name.MANIFEST_VERSION, \"1.0.0\");\n        attributes.put(new Attributes.Name(\"X-Compile-Target-JDK\"), \"bogus\");\n        URL[] jars = {makeJar(dir, \"foo.jar\", manifest, \"Foo.class\")};\n        JarHell.checkJarHell(jars);\n    }","commit_id":"5d48f93557bb42a291c649f48fccdf7a429b2dac","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDifferentJars() throws Exception {\n        Path dir = createTempDir();\n        URL[] jars = {makeJar(dir, \"foo.jar\", null, \"DuplicateClass.class\"), makeJar(dir, \"bar.jar\", null, \"DuplicateClass.class\")};\n        try {\n            JarHell.checkJarHell(jars);\n        } catch (IllegalStateException e) {\n            assertTrue(e.getMessage().contains(\"jar hell!\"));\n            assertTrue(e.getMessage().contains(\"DuplicateClass\"));\n            assertTrue(e.getMessage().contains(\"foo.jar\"));\n            assertTrue(e.getMessage().contains(\"bar.jar\"));\n        }\n    }","id":102583,"modified_method":"public void testDifferentJars() throws Exception {\n        Path dir = createTempDir();\n        URL[] jars = {makeJar(dir, \"foo.jar\", null, \"DuplicateClass.class\"), makeJar(dir, \"bar.jar\", null, \"DuplicateClass.class\")};\n        try {\n            JarHell.checkJarHell(jars);\n            fail(\"did not get expected exception\");\n        } catch (IllegalStateException e) {\n            assertTrue(e.getMessage().contains(\"jar hell!\"));\n            assertTrue(e.getMessage().contains(\"DuplicateClass\"));\n            assertTrue(e.getMessage().contains(\"foo.jar\"));\n            assertTrue(e.getMessage().contains(\"bar.jar\"));\n        }\n    }","commit_id":"5d48f93557bb42a291c649f48fccdf7a429b2dac","url":"https://github.com/elastic/elasticsearch"},{"original_method":"URL makeFile(Path dir, String name) throws IOException {\n        Path filepath = dir.resolve(name);\n        Files.newOutputStream(filepath, StandardOpenOption.CREATE).close();\n        return filepath.toUri().toURL();\n    }","id":102584,"modified_method":"URL makeFile(Path dir, String name) throws IOException {\n        Path filepath = dir.resolve(name);\n        Files.newOutputStream(filepath, StandardOpenOption.CREATE).close();\n        return dir.toUri().toURL();\n    }","commit_id":"5d48f93557bb42a291c649f48fccdf7a429b2dac","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDirAndJar() throws Exception {\n        Path dir1 = createTempDir();\n        Path dir2 = createTempDir();\n        URL[] dirs = {makeJar(dir1, \"foo.jar\", null, \"DuplicateClass.class\"), makeFile(dir2, \"DuplicateClass.class\")};\n        try {\n            JarHell.checkJarHell(dirs);\n        } catch (IllegalStateException e) {\n            assertTrue(e.getMessage().contains(\"jar hell!\"));\n            assertTrue(e.getMessage().contains(\"DuplicateClass\"));\n            assertTrue(e.getMessage().contains(\"foo.jar\"));\n            assertTrue(e.getMessage().contains(dir2.toString()));\n        }\n    }","id":102585,"modified_method":"public void testDirAndJar() throws Exception {\n        Path dir1 = createTempDir();\n        Path dir2 = createTempDir();\n        URL[] dirs = {makeJar(dir1, \"foo.jar\", null, \"DuplicateClass.class\"), makeFile(dir2, \"DuplicateClass.class\")};\n        try {\n            JarHell.checkJarHell(dirs);\n            fail(\"did not get expected exception\");\n        } catch (IllegalStateException e) {\n            assertTrue(e.getMessage().contains(\"jar hell!\"));\n            assertTrue(e.getMessage().contains(\"DuplicateClass\"));\n            assertTrue(e.getMessage().contains(\"foo.jar\"));\n            assertTrue(e.getMessage().contains(dir2.toString()));\n        }\n    }","commit_id":"5d48f93557bb42a291c649f48fccdf7a429b2dac","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testRequiredJDKVersionIsOK() throws Exception {\n        Path dir = createTempDir();\n        String previousJavaVersion = System.getProperty(\"java.specification.version\");\n        System.setProperty(\"java.specification.version\", \"1.7\");\n\n        Manifest manifest = new Manifest();\n        manifest.getMainAttributes().put(new Attributes.Name(\"X-Compile-Target-JDK\"), \"1.7\");\n        URL[] jars = {makeJar(dir, \"foo.jar\", manifest, \"Foo.class\")};\n        try {\n            JarHell.checkJarHell(jars);\n        } finally {\n            System.setProperty(\"java.specification.version\", previousJavaVersion);\n        }\n    }","id":102586,"modified_method":"public void testRequiredJDKVersionIsOK() throws Exception {\n        Path dir = createTempDir();\n        String previousJavaVersion = System.getProperty(\"java.specification.version\");\n        System.setProperty(\"java.specification.version\", \"1.7\");\n\n        Manifest manifest = new Manifest();\n        Attributes attributes = manifest.getMainAttributes();\n        attributes.put(Attributes.Name.MANIFEST_VERSION, \"1.0.0\");\n        attributes.put(new Attributes.Name(\"X-Compile-Target-JDK\"), \"1.7\");\n        URL[] jars = {makeJar(dir, \"foo.jar\", manifest, \"Foo.class\")};\n        try {\n            JarHell.checkJarHell(jars);\n        } finally {\n            System.setProperty(\"java.specification.version\", previousJavaVersion);\n        }\n    }","commit_id":"5d48f93557bb42a291c649f48fccdf7a429b2dac","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testRequiredJDKVersionTooOld() throws Exception {\n        Path dir = createTempDir();\n        String previousJavaVersion = System.getProperty(\"java.specification.version\");\n        System.setProperty(\"java.specification.version\", \"1.7\");\n\n        Manifest manifest = new Manifest();\n        manifest.getMainAttributes().put(new Attributes.Name(\"X-Compile-Target-JDK\"), \"1.8\");\n        URL[] jars = {makeJar(dir, \"foo.jar\", manifest, \"Foo.class\")};\n        try {\n            JarHell.checkJarHell(jars);\n        } catch (IllegalStateException e) {\n            assertTrue(e.getMessage().contains(\"requires java 1.8\"));\n            assertTrue(e.getMessage().contains(\"your system: 1.7\"));\n        } finally {\n            System.setProperty(\"java.specification.version\", previousJavaVersion);\n        }\n    }","id":102587,"modified_method":"public void testRequiredJDKVersionTooOld() throws Exception {\n        Path dir = createTempDir();\n        String previousJavaVersion = System.getProperty(\"java.specification.version\");\n        System.setProperty(\"java.specification.version\", \"1.7\");\n\n        Manifest manifest = new Manifest();\n        Attributes attributes = manifest.getMainAttributes();\n        attributes.put(Attributes.Name.MANIFEST_VERSION, \"1.0.0\");\n        attributes.put(new Attributes.Name(\"X-Compile-Target-JDK\"), \"1.8\");\n        URL[] jars = {makeJar(dir, \"foo.jar\", manifest, \"Foo.class\")};\n        try {\n            JarHell.checkJarHell(jars);\n            fail(\"did not get expected exception\");\n        } catch (IllegalStateException e) {\n            assertTrue(e.getMessage().contains(\"requires Java 1.8\"));\n            assertTrue(e.getMessage().contains(\"your system: 1.7\"));\n        } finally {\n            System.setProperty(\"java.specification.version\", previousJavaVersion);\n        }\n    }","commit_id":"5d48f93557bb42a291c649f48fccdf7a429b2dac","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testWithinSingleJar() throws Exception {\n        // the java api for zip file does not allow creating duplicate entries (good!) so\n        // this bogus jar had to be constructed with ant\n        URL[] jars = {JarHellTests.class.getResource(\"duplicate-classes.jar\")};\n        try {\n            JarHell.checkJarHell(jars);\n        } catch (IllegalStateException e) {\n            assertTrue(e.getMessage().contains(\"jar hell!\"));\n            assertTrue(e.getMessage().contains(\"DuplicateClass\"));\n            assertTrue(e.getMessage().contains(\"duplicate-classes.jar\"));\n            assertTrue(e.getMessage().contains(\"exists multiple times in jar\"));\n        }\n    }","id":102588,"modified_method":"public void testWithinSingleJar() throws Exception {\n        // the java api for zip file does not allow creating duplicate entries (good!) so\n        // this bogus jar had to be constructed with ant\n        URL[] jars = {JarHellTests.class.getResource(\"duplicate-classes.jar\")};\n        try {\n            JarHell.checkJarHell(jars);\n            fail(\"did not get expected exception\");\n        } catch (IllegalStateException e) {\n            assertTrue(e.getMessage().contains(\"jar hell!\"));\n            assertTrue(e.getMessage().contains(\"DuplicateClass\"));\n            assertTrue(e.getMessage().contains(\"duplicate-classes.jar\"));\n            assertTrue(e.getMessage().contains(\"exists multiple times in jar\"));\n        }\n    }","commit_id":"5d48f93557bb42a291c649f48fccdf7a429b2dac","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testBadJDKVersionProperty() throws Exception {\n        Path dir = createTempDir();\n        String previousJavaVersion = System.getProperty(\"java.specification.version\");\n        System.setProperty(\"java.specification.version\", \"bogus\");\n\n        Manifest manifest = new Manifest();\n        manifest.getMainAttributes().put(new Attributes.Name(\"X-Compile-Target-JDK\"), \"1.7\");\n        URL[] jars = {makeJar(dir, \"foo.jar\", manifest, \"Foo.class\")};\n        try {\n            JarHell.checkJarHell(jars);\n        } finally {\n            System.setProperty(\"java.specification.version\", previousJavaVersion);\n        }\n    }","id":102589,"modified_method":"public void testBadJDKVersionProperty() throws Exception {\n        Path dir = createTempDir();\n        String previousJavaVersion = System.getProperty(\"java.specification.version\");\n        System.setProperty(\"java.specification.version\", \"bogus\");\n\n        Manifest manifest = new Manifest();\n        Attributes attributes = manifest.getMainAttributes();\n        attributes.put(Attributes.Name.MANIFEST_VERSION, \"1.0.0\");\n        attributes.put(new Attributes.Name(\"X-Compile-Target-JDK\"), \"1.7\");\n        URL[] jars = {makeJar(dir, \"foo.jar\", manifest, \"Foo.class\")};\n        try {\n            JarHell.checkJarHell(jars);\n        } finally {\n            System.setProperty(\"java.specification.version\", previousJavaVersion);\n        }\n    }","commit_id":"5d48f93557bb42a291c649f48fccdf7a429b2dac","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private TypeProjection substitutionResult(\n            TypeParameterDescriptor correspondingTypeParameter,\n            Variance effectiveContextVariance,\n            Variance passedProjectionKind,\n            TypeProjection value,\n            int recursionDepth) throws SubstitutionException {\n        assertRecursionDepth(recursionDepth, correspondingTypeParameter, value, substitution);\n\n        Variance projectionKindValue = value.getProjectionKind();\n        JetType typeValue = value.getType();\n        Variance effectiveProjectionKindValue = asymmetricOr(passedProjectionKind, projectionKindValue);\n        JetType effectiveTypeValue;\n        switch (effectiveContextVariance) {\n            case INVARIANT:\n                effectiveProjectionKindValue = projectionKindValue;\n                effectiveTypeValue = typeValue;\n                break;\n            case IN_VARIANCE:\n                if (projectionKindValue == Variance.OUT_VARIANCE) {\n                    throw new SubstitutionException(\"\"); // TODO\n//                    effectiveProjectionKindValue = Variance.INVARIANT;\n//                    effectiveTypeValue = JetStandardClasses.getNothingType();\n                }\n                else {\n                    effectiveTypeValue = typeValue;\n                }\n                break;\n            case OUT_VARIANCE:\n                if (projectionKindValue == Variance.IN_VARIANCE) {\n                    effectiveProjectionKindValue = Variance.INVARIANT;\n                    effectiveTypeValue = correspondingTypeParameter.getUpperBoundsAsType();\n                }\n                else {\n                    effectiveTypeValue = typeValue;\n                }\n                break;\n            default:\n                throw new IllegalStateException(effectiveContextVariance.toString());\n        }\n\n//            if (!allows(effectiveContextVariance, projectionKindValue)) {\n//                throw new SubstitutionException(\"\"); // TODO : error message\n//            }\n//\n        return new TypeProjection(effectiveProjectionKindValue, specializeType(effectiveTypeValue, effectiveContextVariance, recursionDepth + 1));\n    }","id":102590,"modified_method":"private List<TypeProjection> substituteTypeArguments(List<TypeParameterDescriptor> typeParameters, List<TypeProjection> typeArguments, int recursionDepth)\n            throws SubstitutionException {\n        List<TypeProjection> substitutedArguments = Lists.newArrayList();\n        for (int i = 0; i < typeParameters.size(); i++) {\n            TypeParameterDescriptor typeParameter = typeParameters.get(i);\n            TypeProjection typeArgument = typeArguments.get(i);\n\n            TypeProjection substitutedTypeArgument = unsafeSubstitute(typeArgument, recursionDepth + 1);\n\n            switch (conflictType(typeParameter.getVariance(), substitutedTypeArgument.getProjectionKind())) {\n                case OUT_IN_IN_POSITION:\n                    substitutedTypeArgument = new TypeProjection(Variance.IN_VARIANCE, typeParameter.getLowerBoundsAsType());\n                    break;\n                case IN_IN_OUT_POSITION:\n                    substitutedTypeArgument = SubstitutionUtils.makeStarProjection(typeParameter);\n                    break;\n            }\n\n            substitutedArguments.add(substitutedTypeArgument);\n        }\n        return substitutedArguments;\n    }","commit_id":"2c8b3c879c1ebb50b3041969a9fe82727858ef07","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public JetType substitute(@NotNull JetType type, @NotNull Variance howThisTypeIsUsed) {\n        if (isEmpty()) {\n            return type;\n        }\n\n        try {\n            return unsafeSubstitute(type, howThisTypeIsUsed);\n        } catch (SubstitutionException e) {\n            return null;\n        }\n    }","id":102591,"modified_method":"@Nullable\n    public JetType substitute(@NotNull JetType type, @NotNull Variance howThisTypeIsUsed) {\n        if (isEmpty()) {\n            return type;\n        }\n\n        try {\n            return unsafeSubstitute(new TypeProjection(howThisTypeIsUsed, type), 0).getType();\n        } catch (SubstitutionException e) {\n            return null;\n        }\n    }","commit_id":"2c8b3c879c1ebb50b3041969a9fe82727858ef07","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean allows(Variance declarationSiteVariance, Variance callSiteVariance) {\n        switch (declarationSiteVariance) {\n            case INVARIANT: return true;\n            case IN_VARIANCE: return callSiteVariance != Variance.OUT_VARIANCE;\n            case OUT_VARIANCE: return callSiteVariance != Variance.IN_VARIANCE;\n        }\n        throw new IllegalStateException(declarationSiteVariance.toString());\n    }","id":102592,"modified_method":"private static Variance combine(Variance typeParameterVariance, Variance projectionKind) {\n        if (typeParameterVariance == Variance.INVARIANT) return projectionKind;\n        if (projectionKind == Variance.INVARIANT) return typeParameterVariance;\n        return typeParameterVariance.superpose(projectionKind);\n    }","commit_id":"2c8b3c879c1ebb50b3041969a9fe82727858ef07","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public JetType safeSubstitute(@NotNull JetType type, @NotNull Variance howThisTypeIsUsed) {\n        if (isEmpty()) {\n            return type;\n        }\n\n        try {\n            return unsafeSubstitute(type, howThisTypeIsUsed);\n        } catch (SubstitutionException e) {\n            return ErrorUtils.createErrorType(e.getMessage());\n        }\n    }","id":102593,"modified_method":"@NotNull\n    public JetType safeSubstitute(@NotNull JetType type, @NotNull Variance howThisTypeIsUsed) {\n        if (isEmpty()) {\n            return type;\n        }\n\n        try {\n            return unsafeSubstitute(new TypeProjection(howThisTypeIsUsed, type), 0).getType();\n        } catch (SubstitutionException e) {\n            return ErrorUtils.createErrorType(e.getMessage());\n        }\n    }","commit_id":"2c8b3c879c1ebb50b3041969a9fe82727858ef07","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void assertRecursionDepth(int recursionDepth, JetType type, TypeSubstitution substitution) {\n        if (recursionDepth > MAX_RECURSION_DEPTH) {\n            throw new IllegalStateException(\"Recursion too deep. Most likely infinite loop while substituting \" + safeToString(type) + \"; substitution: \" + safeToString(substitution));\n        }\n    }","id":102594,"modified_method":"private static void assertRecursionDepth(int recursionDepth, TypeProjection projection, TypeSubstitution substitution) {\n        if (recursionDepth > MAX_RECURSION_DEPTH) {\n            throw new IllegalStateException(\"Recursion too deep. Most likely infinite loop while substituting \" + safeToString(projection) + \"; substitution: \" + safeToString(substitution));\n        }\n    }","commit_id":"2c8b3c879c1ebb50b3041969a9fe82727858ef07","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private TypeProjection substituteInProjection(\n            @NotNull TypeSubstitution substitutionContext,\n            @NotNull TypeProjection passedProjection,\n            @NotNull TypeParameterDescriptor correspondingTypeParameter,\n            @NotNull Variance contextCallSiteVariance,\n            int recursionDepth) throws SubstitutionException {\n        assertRecursionDepth(recursionDepth, correspondingTypeParameter, passedProjection, substitution);\n\n        JetType typeToSubstituteIn = passedProjection.getType();\n        if (ErrorUtils.isErrorType(typeToSubstituteIn)) return passedProjection;\n\n        Variance passedProjectionKind = passedProjection.getProjectionKind();\n        Variance parameterVariance = correspondingTypeParameter.getVariance();\n\n        Variance effectiveProjectionKind = asymmetricOr(passedProjectionKind, parameterVariance);\n        Variance effectiveContextVariance = contextCallSiteVariance.superpose(effectiveProjectionKind);\n\n        TypeProjection projectionValue = getValueWithCorrectNullability(substitutionContext, typeToSubstituteIn);\n        if (projectionValue != null) {\n            assert typeToSubstituteIn.getConstructor().getDeclarationDescriptor() instanceof TypeParameterDescriptor;\n\n            if (!allows(parameterVariance, passedProjectionKind)) {\n                return SubstitutionUtils.makeStarProjection(correspondingTypeParameter);\n            }\n\n            return substitutionResult(correspondingTypeParameter, effectiveContextVariance, passedProjectionKind, projectionValue, recursionDepth + 1);\n        }\n        return new TypeProjection(\n                passedProjectionKind,\n                specializeType(\n                        typeToSubstituteIn,\n                        effectiveContextVariance, recursionDepth + 1));\n    }","id":102595,"modified_method":"@NotNull\n    private TypeProjection unsafeSubstitute(@NotNull TypeProjection originalProjection, int recursionDepth) throws SubstitutionException {\n        assertRecursionDepth(recursionDepth, originalProjection, substitution);\n        // The type is within the substitution range, i.e. T or T?\n        JetType type = originalProjection.getType();\n        if (JetStandardClasses.isNothing(type) || ErrorUtils.isErrorType(type)) return originalProjection;\n\n        TypeProjection replacement = substitution.get(type.getConstructor());\n\n        if (replacement != null) {\n            // It must be a type parameter: only they can be directly substituted for\n            TypeParameterDescriptor typeParameter = (TypeParameterDescriptor) type.getConstructor().getDeclarationDescriptor();\n\n            switch (conflictType(originalProjection.getProjectionKind(), replacement.getProjectionKind())) {\n                case OUT_IN_IN_POSITION:\n                    throw new SubstitutionException(\"Out-projection in in-position\");\n                case IN_IN_OUT_POSITION:\n                    replacement = SubstitutionUtils.makeStarProjection(typeParameter);\n                    break;\n            }\n            boolean resultingIsNullable = type.isNullable() || replacement.getType().isNullable();\n            JetType substitutedType = TypeUtils.makeNullableAsSpecified(replacement.getType(), resultingIsNullable);\n            Variance resultingProjectionKind = combine(originalProjection.getProjectionKind(), replacement.getProjectionKind());\n\n            return new TypeProjection(resultingProjectionKind, substitutedType);\n        }\n        else {\n            // The type is not within the substitution range, i.e. Foo, Bar<T> etc.\n            List<TypeProjection> substitutedArguments = substituteTypeArguments(\n                    type.getConstructor().getParameters(), type.getArguments(), recursionDepth);\n\n            JetType substitutedType = new JetTypeImpl(type.getAnnotations(),   // Old annotations. This is questionable\n                                               type.getConstructor(),   // The same constructor\n                                               type.isNullable(),       // Same nullability\n                                               substitutedArguments,\n                                               new SubstitutingScope(type.getMemberScope(), this));\n            return new TypeProjection(originalProjection.getProjectionKind(), substitutedType);\n        }\n    }","commit_id":"2c8b3c879c1ebb50b3041969a9fe82727858ef07","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected AbstractModelGenerator(IOperationContext operationContext, IAdaptiveProgressMonitor progressMonitor) {\n    myOperationContext = operationContext;\n    myProgressMonitor = progressMonitor;\n  }","id":102596,"modified_method":"protected AbstractModelGenerator(IOperationContext operationContext,\n                                   IAdaptiveProgressMonitor progressMonitor,\n                                   IMessageHandler handler) {\n    myOperationContext = operationContext;\n    myProgressMonitor = progressMonitor;\n    myHandler = handler;\n  }","commit_id":"70c76d6b603ec7e7727ab112c4800f0d11a58a8a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addMessage(final MessageKind kind, final String text) {\n    myInvocationContext.getProject().getComponentSafe(MessageView.class).add(new Message(kind, text));\n  }","id":102597,"modified_method":"private void addMessage(final MessageKind kind, final String text) {\n    addMessage(new Message(kind, text));\n  }","commit_id":"70c76d6b603ec7e7727ab112c4800f0d11a58a8a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public GenerationSession(IOperationContext invocationContext, boolean saveTransientModels, IAdaptiveProgressMonitor progressMonitor) {\n    myInvocationContext = invocationContext;\n    myDiscardTransients = !saveTransientModels;\n    myProgressMonitor = progressMonitor;\n    mySessionId = \"\" + System.currentTimeMillis();\n  }","id":102598,"modified_method":"public GenerationSession(IOperationContext invocationContext, boolean saveTransientModels, IAdaptiveProgressMonitor progressMonitor, IMessageHandler handler) {\n    myInvocationContext = invocationContext;\n    myDiscardTransients = !saveTransientModels;\n    myProgressMonitor = progressMonitor;\n    myHandler = handler;\n    mySessionId = \"\" + System.currentTimeMillis();\n  }","commit_id":"70c76d6b603ec7e7727ab112c4800f0d11a58a8a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addProgressMessage(final MessageKind kind, final String text) {\n    myProgressMonitor.addText(text);\n    myInvocationContext.getProject().getComponentSafe(MessageView.class).add(new Message(kind, text));\n  }","id":102599,"modified_method":"private void addProgressMessage(final MessageKind kind, final String text) {\n    myProgressMonitor.addText(text);\n    addMessage(new Message(kind, text));\n  }","commit_id":"70c76d6b603ec7e7727ab112c4800f0d11a58a8a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addMessage(final Message message) {\n    myInvocationContext.getProject().getComponentSafe(MessageView.class).add(message);\n  }","id":102600,"modified_method":"private void addMessage(final Message message) {\n    myHandler.handle(message);\n  }","commit_id":"70c76d6b603ec7e7727ab112c4800f0d11a58a8a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public GenerationStatus generateModel(final SModelDescriptor sourceModel,\n                                        final Language targetLanguage,\n                                        final IGenerationScript script) throws Exception {\n    GenerationStatus status;\n\n    status = script.doGenerate(new IGenerationScriptContext() {\n      public GenerationStatus doGenerate(@NotNull SModelDescriptor sourceModel, @NotNull Language targetLanguage, Set<MappingConfiguration> confs) throws Exception {\n        return generateModel_internal(sourceModel, targetLanguage, confs);\n      }\n\n      public SModelDescriptor getSourceModelDescriptor() {\n        return sourceModel;\n      }\n\n\n      public Language getTargetLanguage() {\n        return targetLanguage;\n      }\n\n      public IOperationContext getOperationContext() {\n        return myInvocationContext;\n      }\n    });\n\n    if (status.isError()) {\n      // if ERROR - keep transient models: we need them to navigate to from error messages\n      myDiscardTransients = false;\n    }\n    return status;\n  }","id":102601,"modified_method":"public GenerationStatus generateModel(final SModelDescriptor sourceModel,\n                                        final Language targetLanguage,\n                                        final IGenerationScript script) throws Exception {\n    GenerationStatus status;\n\n    status = script.doGenerate(new IGenerationScriptContext() {\n      public GenerationStatus doGenerate(@NotNull SModelDescriptor sourceModel, @NotNull Language targetLanguage, Set<MappingConfiguration> confs) throws Exception {\n        return generateModel_internal(sourceModel, targetLanguage, confs);\n      }\n\n      public SModelDescriptor getSourceModelDescriptor() {\n        return sourceModel;\n      }\n\n\n      public Language getTargetLanguage() {\n        return targetLanguage;\n      }\n\n      public IOperationContext getOperationContext() {\n        return myInvocationContext;\n      }\n\n      public IMessageHandler getHandler() {\n        return myHandler;\n      }\n    });\n\n    if (status.isError()) {\n      // if ERROR - keep transient models: we need them to navigate to from error messages\n      myDiscardTransients = false;\n    }\n    return status;\n  }","commit_id":"70c76d6b603ec7e7727ab112c4800f0d11a58a8a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private GenerationStatus generateModel_internal(SModelDescriptor sourceModelDescriptor, Language targetLanguage, Set<MappingConfiguration> mappings)\n          throws ClassNotFoundException,\n          NoSuchMethodException,\n          IllegalAccessException,\n          InvocationTargetException,\n          InstantiationException {\n\n    myInvocationCount++;\n    myTransientModelsCount = 0;\n    SModel sourceModel = sourceModelDescriptor.getSModel();\n    addProgressMessage(MessageKind.INFORMATION, \"generating model \\\"\" + sourceModel.getUID() + \"\\\"\");\n    Class<? extends IModelGenerator> defaultGeneratorClass = getDefaultGeneratorClass(targetLanguage);\n    addMessage(MessageKind.INFORMATION, \"    default generator class: \" + defaultGeneratorClass.getName());\n\n    // -- replace context and create generators list\n\n\n    GenerationSessionContext context = new GenerationSessionContext(targetLanguage, sourceModel, myInvocationContext, mappings, myCurrentContext);\n\n    List<Generator> generators = context.getGeneratorModules();\n    if (generators.isEmpty()) {\n      addProgressMessage(MessageKind.WARNING, \"skip model \\\"\" + sourceModel.getUID() + \"\\\" : no generator avalable\");\n      return new GenerationStatus(sourceModel, null, null, false, false);\n    }\n    setGenerationSessionContext(context);\n\n    // -- choose generator class\n    Class<? extends IModelGenerator> currentGeneratorClass = null;\n    for (Generator generator : generators) {\n      Class<? extends IModelGenerator> generatorClass = getGeneratorClass(generator);\n      addMessage(MessageKind.INFORMATION, \"    generator found: \" + generator.getModuleUID() + \" generator class: \" + (generatorClass != null ? generatorClass.getName() : \"<default>\"));\n      if (generatorClass != null) {\n        if (currentGeneratorClass == null) {\n          currentGeneratorClass = generatorClass;\n          continue;\n        }\n        if (currentGeneratorClass.isAssignableFrom(generatorClass)) {\n          currentGeneratorClass = generatorClass;\n        } else if (!generatorClass.isAssignableFrom(currentGeneratorClass)) {\n          addProgressMessage(MessageKind.ERROR, \"couldn't choose generator class\");\n          addMessage(MessageKind.ERROR, \"generator classes \\\"\" + currentGeneratorClass.getName() + \"\\\" and \" + generatorClass.getName() + \" are not compatible\");\n          return new GenerationStatus.ERROR(sourceModel);\n        }\n      }\n    }\n\n    if (currentGeneratorClass == null) {\n      if (defaultGeneratorClass == null) {\n        addProgressMessage(MessageKind.ERROR, \"generator class is not defined\");\n        return new GenerationStatus.ERROR(sourceModel);\n      }\n      currentGeneratorClass = defaultGeneratorClass;\n    }\n    addMessage(MessageKind.INFORMATION, \"    use generator class: \\\"\" + currentGeneratorClass + \"\\\"\");\n    // templates or hand-coded?\n    if (!ITemplateGenerator.class.isAssignableFrom(currentGeneratorClass)) {\n      // hand-coded - not much to do ... just instantiate and invoke\n      IModelGenerator handCodedGenerator = currentGeneratorClass.getConstructor(IOperationContext.class).newInstance(context);\n      SModelDescriptor outputModel = createTransientModel(sourceModel, context.getModule());\n      handCodedGenerator.generate(sourceModel, outputModel.getSModel());\n      return new GenerationStatus(sourceModel, outputModel.getSModel(), null, false, false);\n    }\n\n    // templates generator\n    ITemplateGenerator generator = (ITemplateGenerator) currentGeneratorClass.getConstructor(GenerationSessionContext.class, IAdaptiveProgressMonitor.class).newInstance(context, myProgressMonitor);\n    GenerationStatus status;\n    try {\n      SModel outputModel = generateModel(sourceModel, targetLanguage, generator);\n      boolean wasErrors = generator.getErrorCount() > 0;\n      status = new GenerationStatus(sourceModel, outputModel, context.getTraceMap(), wasErrors, false);\n      addMessage(status.isError() ? MessageKind.WARNING : MessageKind.INFORMATION, \"model \\\"\" + sourceModel.getUID() + \"\\\" has been generated \" + (status.isError() ? \"with errors\" : \"successfully\"));\n      generator.reset();\n    } catch (GenerationCanceledException gce) {\n      throw gce;//rethrow it for not to be caught in the last catch block\n    } catch (GenerationFailedException gfe) {\n      LOG.error(gfe);\n      myProgressMonitor.addText(gfe.toString());\n      GenerationFailueInfo failueInfo = gfe.getFailueInfo();\n      if (failueInfo != null) {\n        for (Message message : failueInfo.createMessages()) {\n          addMessage(message);\n        }\n      }\n      addMessage(MessageKind.ERROR, \"model \\\"\" + sourceModel.getUID() + \"\\\" generation failed : \" + gfe);\n      status = new GenerationStatus.ERROR(sourceModel);\n    } catch (Exception e) {\n      LOG.error(e);\n      myProgressMonitor.addText(e.toString());\n      addMessage(MessageKind.ERROR, \"model \\\"\" + sourceModel.getUID() + \"\\\" generation failed : \" + e);\n      status = new GenerationStatus.ERROR(sourceModel);\n    }\n\n    return status;\n  }","id":102602,"modified_method":"private GenerationStatus generateModel_internal(SModelDescriptor sourceModelDescriptor, Language targetLanguage, Set<MappingConfiguration> mappings)\n          throws ClassNotFoundException,\n          NoSuchMethodException,\n          IllegalAccessException,\n          InvocationTargetException,\n          InstantiationException {\n\n    myInvocationCount++;\n    myTransientModelsCount = 0;\n    SModel sourceModel = sourceModelDescriptor.getSModel();\n    addProgressMessage(MessageKind.INFORMATION, \"generating model \\\"\" + sourceModel.getUID() + \"\\\"\");\n    Class<? extends IModelGenerator> defaultGeneratorClass = getDefaultGeneratorClass(targetLanguage);\n    addMessage(MessageKind.INFORMATION, \"    default generator class: \" + defaultGeneratorClass.getName());\n\n    // -- replace context and create generators list\n\n\n    GenerationSessionContext context = new GenerationSessionContext(targetLanguage, sourceModel, myInvocationContext, mappings, myCurrentContext);\n\n    List<Generator> generators = context.getGeneratorModules();\n    if (generators.isEmpty()) {\n      addProgressMessage(MessageKind.WARNING, \"skip model \\\"\" + sourceModel.getUID() + \"\\\" : no generator avalable\");\n      return new GenerationStatus(sourceModel, null, null, false, false);\n    }\n    setGenerationSessionContext(context);\n\n    // -- choose generator class\n    Class<? extends IModelGenerator> currentGeneratorClass = null;\n    for (Generator generator : generators) {\n      Class<? extends IModelGenerator> generatorClass = getGeneratorClass(generator);\n      addMessage(MessageKind.INFORMATION, \"    generator found: \" + generator.getModuleUID() + \" generator class: \" + (generatorClass != null ? generatorClass.getName() : \"<default>\"));\n      if (generatorClass != null) {\n        if (currentGeneratorClass == null) {\n          currentGeneratorClass = generatorClass;\n          continue;\n        }\n        if (currentGeneratorClass.isAssignableFrom(generatorClass)) {\n          currentGeneratorClass = generatorClass;\n        } else if (!generatorClass.isAssignableFrom(currentGeneratorClass)) {\n          addProgressMessage(MessageKind.ERROR, \"couldn't choose generator class\");\n          addMessage(MessageKind.ERROR, \"generator classes \\\"\" + currentGeneratorClass.getName() + \"\\\" and \" + generatorClass.getName() + \" are not compatible\");\n          return new GenerationStatus.ERROR(sourceModel);\n        }\n      }\n    }\n\n    if (currentGeneratorClass == null) {\n      if (defaultGeneratorClass == null) {\n        addProgressMessage(MessageKind.ERROR, \"generator class is not defined\");\n        return new GenerationStatus.ERROR(sourceModel);\n      }\n      currentGeneratorClass = defaultGeneratorClass;\n    }\n    addMessage(MessageKind.INFORMATION, \"    use generator class: \\\"\" + currentGeneratorClass + \"\\\"\");\n    // templates or hand-coded?\n    if (!ITemplateGenerator.class.isAssignableFrom(currentGeneratorClass)) {\n      // hand-coded - not much to do ... just instantiate and invoke\n      IModelGenerator handCodedGenerator = currentGeneratorClass.getConstructor(IOperationContext.class).newInstance(context);\n      SModelDescriptor outputModel = createTransientModel(sourceModel, context.getModule());\n      handCodedGenerator.generate(sourceModel, outputModel.getSModel());\n      return new GenerationStatus(sourceModel, outputModel.getSModel(), null, false, false);\n    }\n\n    // templates generator\n    ITemplateGenerator generator = null;\n\n\n    try {\n      Constructor c = currentGeneratorClass.getConstructor(GenerationSessionContext.class, IAdaptiveProgressMonitor.class);\n      generator = (ITemplateGenerator) c.newInstance(context, myProgressMonitor);\n    } catch (NoSuchMethodException e) {\n      //ok to skip\n    }\n\n    if (generator == null) {\n      try {\n        Constructor c = currentGeneratorClass.getConstructor(GenerationSessionContext.class, IAdaptiveProgressMonitor.class, IMessageHandler.class);\n        generator = (ITemplateGenerator) c.newInstance(context, myProgressMonitor, myHandler);\n      } catch (NoSuchMethodException e) {\n        //ok to skip\n      }\n    }\n\n    if (generator == null) {\n      myHandler.handle(new Message(MessageKind.ERROR, \"Generator Class Not Found\"));\n      return new GenerationStatus.ERROR(sourceModel);\n    }\n\n    GenerationStatus status;\n    try {\n      SModel outputModel = generateModel(sourceModel, targetLanguage, generator);\n      boolean wasErrors = generator.getErrorCount() > 0;\n      status = new GenerationStatus(sourceModel, outputModel, context.getTraceMap(), wasErrors, false);\n      addMessage(status.isError() ? MessageKind.WARNING : MessageKind.INFORMATION, \"model \\\"\" + sourceModel.getUID() + \"\\\" has been generated \" + (status.isError() ? \"with errors\" : \"successfully\"));\n      generator.reset();\n    } catch (GenerationCanceledException gce) {\n      throw gce;//rethrow it for not to be caught in the last catch block\n    } catch (GenerationFailedException gfe) {\n      LOG.error(gfe);\n      myProgressMonitor.addText(gfe.toString());\n      GenerationFailueInfo failueInfo = gfe.getFailueInfo();\n      if (failueInfo != null) {\n        for (Message message : failueInfo.createMessages()) {\n          addMessage(message);\n        }\n      }\n      addMessage(MessageKind.ERROR, \"model \\\"\" + sourceModel.getUID() + \"\\\" generation failed : \" + gfe);\n      status = new GenerationStatus.ERROR(sourceModel);\n    } catch (Exception e) {\n      LOG.error(e);\n      myProgressMonitor.addText(e.toString());\n      addMessage(MessageKind.ERROR, \"model \\\"\" + sourceModel.getUID() + \"\\\" generation failed : \" + e);\n      status = new GenerationStatus.ERROR(sourceModel);\n    }\n\n    return status;\n  }","commit_id":"70c76d6b603ec7e7727ab112c4800f0d11a58a8a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void generateModels(List<SModel> _sourceModels, Language targetLanguage, IOperationContext invocationContext, IGenerationType generationType, IGenerationScript script, IAdaptiveProgressMonitor progress) {\n    MPSModuleRepository.getInstance().removeTransientModules();\n    showMessageView();\n\n    invocationContext.getProject().saveModels();\n    List<SModelDescriptor> sourceModels = new ArrayList<SModelDescriptor>();\n    for (SModel model : _sourceModels) {\n      sourceModels.add(model.getModelDescriptor());\n    }\n    clearMessages();\n\n\n    addMessage(MessageKind.INFORMATION, generationType.getStartText());\n\n    addMessage(MessageKind.INFORMATION, \"    target language: \\\"\" + targetLanguage.getNamespace() + \"\\\"\");\n    String outputFolder = invocationContext.getModule().getGeneratorOutputPath();\n\n    if (!new File(outputFolder).exists()) {\n      new File(outputFolder).mkdirs();\n\n      try {\n        myProject.getProjectHandler().addSourceRoot(outputFolder);\n      } catch (Exception e) {\n        addMessage(MessageKind.WARNING, \"Can't add output folder to IDEA as sources\");\n      }\n    }\n\n    addMessage(MessageKind.INFORMATION, \"    target root folder: \\\"\" + outputFolder + \"\\\"\");\n\n    boolean ideaPresent = myProject.getProjectHandler() != null;\n    boolean compile = myCompileOnGeneration && ideaPresent && generationType.requiresCompilationInIDEAfterGeneration();\n\n    long totalJob = ModelsProgressUtil.estimateTotalGenerationJobMillis(compile, sourceModels);\n\n    progress.startTaskAnyway(\"generating\", null, totalJob);\n\n    try {\n      boolean reloadClasses = true;\n\n      if (!myCompileOnGeneration || !generationType.requiresCompilationInIDEABeforeGeneration()) {\n        progress.addText(\"compilation in IntelliJ IDEA on generation is turned off or not needed\");\n        reloadClasses = false;\n      } else if (!ideaPresent) {\n        progress.addText(\"IntelliJ IDEA with installed MPS is not present\");\n      } else {\n        // -- compile sources before generation\n        checkMonitorCanceled(progress);\n\n        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n        myProject.getProjectHandler().refreshFS();\n        progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n        checkMonitorCanceled(progress);\n\n        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n        progress.addText(\"compiling output module...\");\n        CompilationResult compilationResult = myProject.getProjectHandler().buildModule(outputFolder);\n        progress.addText(\"\" + compilationResult);\n        if (!compilationResult.isOk()) {\n          reloadClasses = false;\n        }\n\n\n        boolean needCompileSourceLanguageModules = false;\n        if (invocationContext instanceof ModuleContext) {\n          ModuleContext ctx = (ModuleContext) invocationContext;\n          if (ctx.getModule() instanceof Solution) {\n            needCompileSourceLanguageModules = true;\n          }\n        }\n\n        if (myCompileSourceLanguageModules && needCompileSourceLanguageModules) {\n          for (Language l : getPossibleSourceLanguages(_sourceModels, invocationContext.getScope())) {\n            progress.addText(\"compiling \" + l + \"'s  module...\");\n            compilationResult = myProject.getProjectHandler().buildModule(l.getSourceDir().getPath());\n            progress.addText(\"\" + compilationResult);\n\n            if (!compilationResult.isOk()) {\n              reloadClasses = false;\n            }\n          }\n        }\n\n        progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n        checkMonitorCanceled(progress);\n      }\n\n      // re-load classes anyway (to be sure that java_stub are up-to-date)\n      if (reloadClasses) {\n        progress.addText(\"reloading MPS classes...\");\n        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n        ReloadUtils.reloadAll(false);\n        progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n        checkMonitorCanceled(progress);\n      }\n\n\n      GenerationStatus status = null;\n      //++ generation\n      GenerationSession generationSession = new GenerationSession(invocationContext, isSaveTransientModels(), progress);\n      for (SModelDescriptor sourceModelDescriptor : sourceModels) {\n        progress.addText(\"\");\n        String taskName = ModelsProgressUtil.generationModelTaskName(sourceModelDescriptor);\n        progress.startLeafTask(taskName, ModelsProgressUtil.TASK_KIND_GENERATION);\n\n        status = generationSession.generateModel(sourceModelDescriptor, targetLanguage, script);\n        checkMonitorCanceled(progress);\n        if (status.getOutputModel() != null) {\n          generationType.handleOutput(invocationContext, status, progress, outputFolder);\n        }\n        generationSession.discardTransients();\n        progress.finishTask(taskName);\n        if (!status.isOk()) {\n          break;\n        }\n      }\n      //-- generation\n\n      if (isSaveTransientModels()) {\n        File solutionDescriptorFile = generationSession.saveTransientModels();\n\n        addProgressMessage(MessageKind.INFORMATION, \"update output models solution\", progress);\n        Solution outputModels = myProject.findSolution(\"outputModels\");\n        if (outputModels != null) {\n          outputModels.reloadFromDisk();\n        } else {\n          myProject.addProjectSolution(solutionDescriptorFile);\n        }\n      }\n\n      //update generated sources timestamp\n      updateLanguagesGenerationRequiredStatus(invocationContext);\n\n      checkMonitorCanceled(progress);\n      progress.addText(\"\");\n      if (status.isOk()) {\n        if (compile) {\n          // -- compile after generation\n          progress.addText(\"compiling in IntelliJ IDEA...\");\n\n          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n          myProject.getProjectHandler().refreshFS();\n          progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n          checkMonitorCanceled(progress);\n          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n          CompilationResult compilationResult = myProject.getProjectHandler().buildModule(outputFolder);\n          progress.addText(\"\" + compilationResult);\n          progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n          checkMonitorCanceled(progress);\n\n\n          if (compilationResult.isOk()) {\n            progress.addText(\"reloading MPS classes...\");\n            progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n            ReloadUtils.reloadAll(false);\n            progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n            checkMonitorCanceled(progress);\n          }\n        }\n        addProgressMessage(MessageKind.INFORMATION, \"generation completed successfully\", progress);\n        progress.finishSomehow();\n      } else if (status.isError()) {\n        addProgressMessage(MessageKind.WARNING, \"generation finished with errors\", progress);\n        progress.finishSomehow();\n      }\n    } catch (GenerationCanceledException gce) {\n      addProgressMessage(MessageKind.WARNING, \"generation canceled\", progress);\n      progress.finishAnyway();\n      showMessageView();\n    } catch (Throwable t) {\n      LOG.error(t);\n      addProgressMessage(MessageKind.ERROR, t.toString(), progress);\n      progress.finishSomehow();\n    } finally {\n      System.gc();\n    }\n  }","id":102603,"modified_method":"public void generateModels(\n            List<SModel> _sourceModels,\n            Language targetLanguage,\n            IOperationContext invocationContext,\n            IGenerationType generationType,\n            IGenerationScript script,\n            IAdaptiveProgressMonitor progress) {\n\n    generateModels(_sourceModels,\n            targetLanguage,\n            invocationContext,\n            generationType,\n            script,\n            progress,\n            new IMessageHandler() {\n              public void handle(Message msg) {\n                MessageView messageView = myProject.getComponent(MessageView.class);\n                assert messageView != null;\n                messageView.add(msg);\n              }\n            });\n  }","commit_id":"70c76d6b603ec7e7727ab112c4800f0d11a58a8a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private String renderDefaultType(JetType type) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(type.getConstructor());\n        if (!type.getArguments().isEmpty()) {\n            sb.append(\"<\");\n            appendTypeProjections(sb, type.getArguments());\n            sb.append(\">\");\n        }\n        if (type.isNullable()) {\n            sb.append(\"?\");\n        }\n        return sb.toString();\n    }","id":102604,"modified_method":"private String renderDefaultType(JetType type) {\n        StringBuilder sb = new StringBuilder();\n        ClassifierDescriptor cd = type.getConstructor().getDeclarationDescriptor();\n        sb.append(cd == null || cd instanceof TypeParameterDescriptor\n                  ? type.getConstructor() : DescriptorUtils.getFQName(cd));\n        if (!type.getArguments().isEmpty()) {\n            sb.append(\"<\");\n            appendTypeProjections(sb, type.getArguments());\n            sb.append(\">\");\n        }\n        if (type.isNullable()) {\n            sb.append(\"?\");\n        }\n        return sb.toString();\n    }","commit_id":"8f5d469a0cf5e8c04ce58ed3af3c0d72a663afe6","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static String getFQName(DeclarationDescriptor descriptor) {\n        DeclarationDescriptor container = descriptor.getContainingDeclaration();\n        if (container != null && !(container instanceof ModuleDescriptor)) {\n            String baseName = getFQName(container);\n            if (!baseName.isEmpty()) return baseName + \".\" + descriptor.getName();\n        }\n\n        return descriptor.getName();\n    }","id":102605,"modified_method":"public static String getFQName(DeclarationDescriptor descriptor) {\n        DeclarationDescriptor container = descriptor.getContainingDeclaration();\n        if (container != null && !(container instanceof ModuleDescriptor)\n                                 && !(\"<java_root>\".equals(container.getName()))) {\n            // TODO JavaNamespaceDescriptors should be refactored\n            String baseName = getFQName(container);\n            if (!baseName.isEmpty()) return baseName + \".\" + descriptor.getName();\n        }\n\n        return descriptor.getName();\n    }","commit_id":"8f5d469a0cf5e8c04ce58ed3af3c0d72a663afe6","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * @param namespace true for \"namespace\" suffix \n     */\n    public static String getJVMClassName(String fqName, boolean namespace) {\n        if (fqName.length() == 0) {\n            return JvmAbi.PACKAGE_CLASS;\n        }\n\n        String name = fqName.replace('.', '/');\n        if(name.startsWith(\"<java_root>\")) {\n            name = name.substring(\"<java_root>\".length() + 1, name.length());\n        }\n        if (namespace) {\n            name += \"/\" + JvmAbi.PACKAGE_CLASS;\n        }\n        return name;\n    }","id":102606,"modified_method":"/**\n     * @param namespace true for \"namespace\" suffix \n     */\n    public static String getJVMClassName(String fqName, boolean namespace) {\n        if (fqName.length() == 0) {\n            return JvmAbi.PACKAGE_CLASS;\n        }\n\n        String name = fqName.replace('.', '/');\n        if (name.startsWith(JavaDescriptorResolver.JAVA_ROOT)) {\n            name = name.substring(JavaDescriptorResolver.JAVA_ROOT.length() + 1, name.length());\n        }\n        if (namespace) {\n            name += \"/\" + JvmAbi.PACKAGE_CLASS;\n        }\n        return name;\n    }","commit_id":"8f5d469a0cf5e8c04ce58ed3af3c0d72a663afe6","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private boolean isPrimitive(TypedDeclaration declaration, TypedDeclaration refinedDeclaration) {\n        if(declaration.getType() == null){\n            // an error must have already been reported\n            return false;\n        }\n        return (transformer.isCeylonBasicType(declaration.getType()) || transformer.isCeylonArray(declaration.getType()))\n                && !(refinedDeclaration.getTypeDeclaration() instanceof TypeParameter);\n    }","id":102607,"modified_method":"private void setBoxingState(TypedDeclaration declaration, TypedDeclaration refinedDeclaration) {\n        if(declaration.getType() == null){\n            // an error must have already been reported\n            return;\n        }\n        if((transformer.isCeylonBasicType(declaration.getType()) \n            || transformer.isCeylonArray(declaration.getType()))\n           && !(refinedDeclaration.getTypeDeclaration() instanceof TypeParameter)){\n            // set the refined decl if it isn't already set (by the model loader for example)\n            if(refinedDeclaration.getUnboxed())\n                refinedDeclaration.setUnboxed(true);\n            // propagate to decl if needed\n            if(refinedDeclaration != declaration)\n                declaration.setUnboxed(refinedDeclaration.getUnboxed());\n        }\n    }","commit_id":"86b7fe3aa73d48372bddb22086c69ea965bb6d3f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(AttributeSetterDefinition that) {\n        super.visit(that);\n        Setter declarationModel = that.getDeclarationModel();\n        // deal with invalid input\n        if(declarationModel == null)\n            return;\n        TypedDeclaration declaration = declarationModel.getParameter();\n        // deal with invalid input\n        if(declaration == null)\n            return;\n        TypedDeclaration refinedDeclaration = (TypedDeclaration)Util.getTopmostRefinedDeclaration(declaration);\n        // deal with invalid input\n        if(refinedDeclaration == null)\n            return;\n        if(isPrimitive(declaration, refinedDeclaration)) {\n            Util.markUnBoxed(declaration);\n            Util.markUnBoxed(refinedDeclaration);\n        }\n    }","id":102608,"modified_method":"@Override\n    public void visit(AttributeSetterDefinition that) {\n        super.visit(that);\n        Setter declarationModel = that.getDeclarationModel();\n        // deal with invalid input\n        if(declarationModel == null)\n            return;\n        TypedDeclaration declaration = declarationModel.getParameter();\n        // deal with invalid input\n        if(declaration == null)\n            return;\n        TypedDeclaration refinedDeclaration = (TypedDeclaration)Util.getTopmostRefinedDeclaration(declaration);\n        // deal with invalid input\n        if(refinedDeclaration == null)\n            return;\n        setBoxingState(declaration, refinedDeclaration);\n    }","commit_id":"86b7fe3aa73d48372bddb22086c69ea965bb6d3f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(Variable that) {\n        super.visit(that);\n        TypedDeclaration declaration = that.getDeclarationModel();\n        // deal with invalid input\n        if(declaration == null)\n            return;\n        if(isPrimitive(declaration, declaration))\n            Util.markUnBoxed(declaration);\n    }","id":102609,"modified_method":"@Override\n    public void visit(Variable that) {\n        super.visit(that);\n        TypedDeclaration declaration = that.getDeclarationModel();\n        // deal with invalid input\n        if(declaration == null)\n            return;\n        setBoxingState(declaration, declaration);\n    }","commit_id":"86b7fe3aa73d48372bddb22086c69ea965bb6d3f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(ClassDefinition that) {\n        super.visit(that);\n        Class klass = that.getDeclarationModel();\n        // deal with invalid input\n        if(klass == null)\n            return;\n        List<ParameterList> parameterLists = klass.getParameterLists();\n        // deal with invalid input\n        if(parameterLists.isEmpty())\n            return;\n        List<Parameter> parameters = parameterLists.get(0).getParameters();\n        for(Parameter param : parameters){\n            if(isPrimitive(param, param))\n                Util.markUnBoxed(param);\n        }\n    }","id":102610,"modified_method":"@Override\n    public void visit(ClassDefinition that) {\n        super.visit(that);\n        Class klass = that.getDeclarationModel();\n        // deal with invalid input\n        if(klass == null)\n            return;\n        List<ParameterList> parameterLists = klass.getParameterLists();\n        // deal with invalid input\n        if(parameterLists.isEmpty())\n            return;\n        List<Parameter> parameters = parameterLists.get(0).getParameters();\n        for(Parameter param : parameters){\n            setBoxingState(param, param);\n        }\n    }","commit_id":"86b7fe3aa73d48372bddb22086c69ea965bb6d3f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(AnyMethod that) {\n        super.visit(that);\n        // FIXME: we need to set those in the model loader as well\n        Method method = that.getDeclarationModel();\n        // deal with invalid input\n        if(method == null)\n            return;\n        Method refinedMethod = (Method) Util.getTopmostRefinedDeclaration(method);\n        // deal with invalid input\n        if(refinedMethod == null)\n            return;\n        if(isPrimitive(method, refinedMethod)) {\n            Util.markUnBoxed(method);\n            Util.markUnBoxed(refinedMethod);\n        }\n        List<ParameterList> methodParameterLists = method.getParameterLists();\n        List<ParameterList> refinedParameterLists = refinedMethod.getParameterLists();\n        // deal with invalid input\n        if(methodParameterLists.isEmpty()\n                || refinedParameterLists.isEmpty())\n            return;\n        Iterator<Parameter> parameters = methodParameterLists.get(0).getParameters().iterator();\n        for(Parameter refinedParam : refinedParameterLists.get(0).getParameters()){\n            Parameter param = parameters.next();\n            if(isPrimitive(param, refinedParam)) {\n                Util.markUnBoxed(param);\n                Util.markUnBoxed(refinedParam);\n            }\n        }\n    }","id":102611,"modified_method":"@Override\n    public void visit(AnyMethod that) {\n        super.visit(that);\n        // FIXME: we need to set those in the model loader as well\n        Method method = that.getDeclarationModel();\n        // deal with invalid input\n        if(method == null)\n            return;\n        Method refinedMethod = (Method) Util.getTopmostRefinedDeclaration(method);\n        // deal with invalid input\n        if(refinedMethod == null)\n            return;\n        setBoxingState(method, refinedMethod);\n        List<ParameterList> methodParameterLists = method.getParameterLists();\n        List<ParameterList> refinedParameterLists = refinedMethod.getParameterLists();\n        // deal with invalid input\n        if(methodParameterLists.isEmpty()\n                || refinedParameterLists.isEmpty())\n            return;\n        Iterator<Parameter> parameters = methodParameterLists.get(0).getParameters().iterator();\n        for(Parameter refinedParam : refinedParameterLists.get(0).getParameters()){\n            Parameter param = parameters.next();\n            setBoxingState(param, refinedParam);\n        }\n    }","commit_id":"86b7fe3aa73d48372bddb22086c69ea965bb6d3f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(AnyAttribute that) {\n        super.visit(that);\n        TypedDeclaration declaration = that.getDeclarationModel();\n        // deal with invalid input\n        if(declaration == null)\n            return;\n        TypedDeclaration refinedDeclaration = (TypedDeclaration)Util.getTopmostRefinedDeclaration(declaration);\n        // deal with invalid input\n        if(refinedDeclaration == null)\n            return;\n        if(isPrimitive(declaration, refinedDeclaration)) {\n            Util.markUnBoxed(declaration);\n            Util.markUnBoxed(refinedDeclaration);\n        }\n    }","id":102612,"modified_method":"@Override\n    public void visit(AnyAttribute that) {\n        super.visit(that);\n        TypedDeclaration declaration = that.getDeclarationModel();\n        // deal with invalid input\n        if(declaration == null)\n            return;\n        TypedDeclaration refinedDeclaration = (TypedDeclaration)Util.getTopmostRefinedDeclaration(declaration);\n        // deal with invalid input\n        if(refinedDeclaration == null)\n            return;\n        setBoxingState(declaration, refinedDeclaration);\n    }","commit_id":"86b7fe3aa73d48372bddb22086c69ea965bb6d3f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * Get contribution statistic (translations) from project-version within\n     * given date range.\n     *\n     * Throws NoSuchEntityException if: - project/version not found or is\n     * obsolete, - user not found\n     *\n     * Throws InvalidDateParamException if: - dateRangeParam is in wrong format,\n     * - date range is over MAX_STATS_DAYS\n     *\n     * @param projectSlug\n     *            project identifier\n     * @param versionSlug\n     *            version identifier\n     * @param username\n     *            username of contributor\n     * @param dateRangeParam\n     *            from..to (yyyy-mm-dd..yyyy-mm-dd), date range maximum: 365\n     *            days\n     */\n    @Override\n    public ContributionStatistics getContributionStatistics(String projectSlug,\n            String versionSlug, String username, String dateRangeParam, boolean automatedEntry) {\n\n        HProjectIteration version =\n                projectIterationDAO.getBySlug(projectSlug, versionSlug);\n        if (version == null || version.getStatus() == EntityStatus.OBSOLETE ||\n                version.getProject().getStatus() == EntityStatus.OBSOLETE) {\n            throw new NoSuchEntityException(projectSlug + \"/\" + versionSlug);\n        }\n\n        HPerson person = findPersonOrExceptionOnNotFound(username);\n\n        DateRange dateRange = DateRange.from(dateRangeParam);\n\n        LocaleStatistics localeStatistics = new LocaleStatistics();\n\n        List<Object[]> data =\n                textFlowTargetHistoryDAO.getUserContributionStatisticInVersion(\n                        version.getId(), person.getId(),\n                        dateRange.getFromDate().toDate(),\n                        dateRange.getToDate().toDate(),\n                        automatedEntry);\n\n        for (Object[] entry : data) {\n            int count = ((BigDecimal) entry[0]).intValue();\n            ContentState state = ContentState.values()[(int) entry[1]];\n            LocaleId localeId = new LocaleId(entry[2].toString());\n\n            BaseContributionStatistic stats;\n            if (localeStatistics.containsKey(localeId)) {\n                stats = localeStatistics.get(localeId);\n            } else {\n                stats = new BaseContributionStatistic(0, 0, 0, 0);\n            }\n            stats.set(state, count);\n            localeStatistics.put(localeId, stats);\n        }\n\n        ContributionStatistics result = new ContributionStatistics();\n        result.put(username, localeStatistics);\n\n        return result;\n    }","id":102613,"modified_method":"/**\n     * Get contribution statistic (translations) from project-version within\n     * given date range.\n     *\n     * Throws NoSuchEntityException if: - project/version not found or is\n     * obsolete, - user not found\n     *\n     * Throws InvalidDateParamException if: - dateRangeParam is in wrong format,\n     * - date range is over MAX_STATS_DAYS\n     *\n     * @param projectSlug\n     *            project identifier\n     * @param versionSlug\n     *            version identifier\n     * @param username\n     *            username of contributor\n     * @param dateRangeParam\n     *            from..to (yyyy-mm-dd..yyyy-mm-dd), date range maximum: 365\n     *            days\n     */\n    @Override\n    public ContributionStatistics getContributionStatistics(String projectSlug,\n            String versionSlug, String username, String dateRangeParam, boolean automatedEntry) {\n\n        HProjectIteration version =\n                projectIterationDAO.getBySlug(projectSlug, versionSlug);\n        if (version == null || version.getStatus() == EntityStatus.OBSOLETE ||\n                version.getProject().getStatus() == EntityStatus.OBSOLETE) {\n            throw new NoSuchEntityException(projectSlug + \"/\" + versionSlug);\n        }\n\n        HPerson person = findPersonOrExceptionOnNotFound(username);\n\n        DateRange dateRange = DateRange.from(dateRangeParam);\n\n        List<Object[]> translationData =\n                textFlowTargetHistoryDAO.getUserTranslationStatisticInVersion(\n                        version.getId(), person.getId(),\n                        dateRange.getFromDate().toDate(),\n                        dateRange.getToDate().toDate(),\n                        automatedEntry);\n\n        List<Object[]> reviewData =\n            textFlowTargetHistoryDAO.getUserReviewStatisticInVersion(\n                version.getId(), person.getId(),\n                dateRange.getFromDate().toDate(),\n                dateRange.getToDate().toDate(),\n                automatedEntry);\n\n        Map<LocaleId, LocaleStatistics> localeStatsMap = Maps.newHashMap();\n\n        for (Object[] entry : translationData) {\n            int count = ((BigDecimal) entry[0]).intValue();\n            ContentState state = ContentState.values()[(int) entry[1]];\n            LocaleId localeId = new LocaleId(entry[2].toString());\n\n            BaseContributionStatistic translationStats = null;\n            LocaleStatistics localeStatistics = null;\n            if (localeStatsMap.containsKey(localeId)) {\n                localeStatistics = localeStatsMap.get(localeId);\n                translationStats = localeStatistics.getTranslationStats();\n            }\n            if(localeStatistics == null) {\n                localeStatistics = new LocaleStatistics(localeId);\n            }\n            if(translationStats == null) {\n                translationStats = new BaseContributionStatistic(0, 0, 0, 0);\n            }\n            translationStats.set(state, count);\n            localeStatistics.setTranslationStats(translationStats);\n            localeStatsMap.put(localeId, localeStatistics);\n        }\n\n        for (Object[] entry : reviewData) {\n            int count = ((BigDecimal) entry[0]).intValue();\n            ContentState state = ContentState.values()[(int) entry[1]];\n            LocaleId localeId = new LocaleId(entry[2].toString());\n\n            BaseContributionStatistic reviewStats = null;\n            LocaleStatistics localeStatistics = null;\n            if (localeStatsMap.containsKey(localeId)) {\n                localeStatistics = localeStatsMap.get(localeId);\n                reviewStats = localeStatistics.getReviewStats();\n            }\n            if(localeStatistics == null) {\n                localeStatistics = new LocaleStatistics(localeId);\n            }\n            if(reviewStats == null) {\n                reviewStats = new BaseContributionStatistic(0, null, null, 0);\n            }\n            reviewStats.set(state, count);\n            localeStatistics.setReviewStats(reviewStats);\n\n            localeStatsMap.put(localeId, localeStatistics);\n        }\n\n        return new ContributionStatistics(username,\n            new ArrayList(localeStatsMap.values()));\n    }","commit_id":"7b4e1d6ec537a9e034d3e64c7f3035b25d32a7f4","url":"https://github.com/zanata/zanata-server"},{"original_method":"private TranslationStatistics getWordsStats(TransUnitWords wordCount,\n            LocaleId locale, Date lastChanged, String lastModifiedBy) {\n        TranslationStatistics stats =\n                new TranslationStatistics(wordCount, locale.getId());\n        stats.setLastTranslatedBy(lastModifiedBy);\n        stats.setLastTranslatedDate(lastChanged);\n        stats.setLastTranslated(getLastTranslated(lastChanged, lastModifiedBy));\n\n        return stats;\n    }","id":102614,"modified_method":"private TranslationStatistics getWordsStats(TransUnitWords wordCount,\n            LocaleId locale, Date lastChanged, String lastModifiedBy) {\n        TranslationStatistics stats =\n                new TranslationStatistics(wordCount, locale.getId());\n        stats = setLastTranslated(stats, lastChanged, lastModifiedBy);\n        return stats;\n    }","commit_id":"7b4e1d6ec537a9e034d3e64c7f3035b25d32a7f4","url":"https://github.com/zanata/zanata-server"},{"original_method":"public ContainerTranslationStatistics getDocStatistics(Long documentId,\n            LocaleId localeId) {\n        ContainerTranslationStatistics result =\n                documentDAO.getStatistics(documentId, localeId);\n\n        TranslationStatistics wordStatistics =\n                result.getStats(localeId.getId(), StatUnit.WORD);\n        wordStatistics.setRemainingHours(StatisticsUtil\n                .getRemainingHours(wordStatistics));\n\n        TranslationStatistics msgStatistics =\n                result.getStats(localeId.getId(), StatUnit.MESSAGE);\n        msgStatistics.setRemainingHours(StatisticsUtil\n                .getRemainingHours(wordStatistics));\n\n        return result;\n    }","id":102615,"modified_method":"public ContainerTranslationStatistics getDocStatistics(Long documentId,\n            LocaleId localeId) {\n        ContainerTranslationStatistics result =\n                documentDAO.getStatistics(documentId, localeId);\n\n        TranslationStatistics wordStatistics =\n                extractStatistics(result, localeId, StatUnit.WORD);\n\n        TranslationStatistics msgStatistics =\n                extractStatistics(result, localeId, StatUnit.MESSAGE);\n        msgStatistics.setRemainingHours(StatisticsUtil\n                .getRemainingHours(wordStatistics));\n\n        return result;\n    }","commit_id":"7b4e1d6ec537a9e034d3e64c7f3035b25d32a7f4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n        public Object transformTuple(Object[] tuple, String[] aliases) {\n            String savedDate = dateFormater.print(\n                    new DateTime(tuple[0]).toDate().getTime());\n            HProjectIteration iteration =\n                    entityManager.find(HProjectIteration.class,\n                            ((BigInteger) tuple[1]).longValue());\n            String projectSlug = iteration.getProject().getSlug();\n            String projectName = iteration.getProject().getName();\n            String versionSlug = iteration.getSlug();\n\n            HLocale locale =\n                    entityManager.find(HLocale.class,\n                            ((BigInteger) tuple[2]).longValue());\n            String localeDisplayName = locale.retrieveDisplayName();\n            LocaleId localeId = locale.getLocaleId();\n\n            ContentState savedState = ContentState.values()[(int) tuple[3]];\n            long wordCount =\n                    ((BigDecimal) tuple[4]).toBigInteger().longValue();\n\n            return new TranslationMatrix(savedDate, projectSlug, projectName,\n                    versionSlug, localeId, localeDisplayName,\n                    savedState, wordCount);\n        }","id":102616,"modified_method":"@Override\n        public Object transformTuple(Object[] tuple, String[] aliases) {\n            String savedDate = dateFormatter.print(\n                    new DateTime(tuple[0]).toDate().getTime());\n            HProjectIteration iteration =\n                    entityManager.find(HProjectIteration.class,\n                            ((BigInteger) tuple[1]).longValue());\n            String projectSlug = iteration.getProject().getSlug();\n            String projectName = iteration.getProject().getName();\n            String versionSlug = iteration.getSlug();\n\n            HLocale locale =\n                    entityManager.find(HLocale.class,\n                            ((BigInteger) tuple[2]).longValue());\n            String localeDisplayName = locale.retrieveDisplayName();\n            LocaleId localeId = locale.getLocaleId();\n\n            ContentState savedState = ContentState.values()[(int) tuple[3]];\n            long wordCount =\n                    ((BigDecimal) tuple[4]).toBigInteger().longValue();\n\n            return new TranslationMatrix(savedDate, projectSlug, projectName,\n                    versionSlug, localeId, localeDisplayName,\n                    savedState, wordCount);\n        }","commit_id":"7b4e1d6ec537a9e034d3e64c7f3035b25d32a7f4","url":"https://github.com/zanata/zanata-server"},{"original_method":"private TranslationStatistics getMessageStats(TransUnitCount unitCount,\n            LocaleId locale, Date lastChanged, String lastModifiedBy) {\n        TranslationStatistics stats =\n                new TranslationStatistics(unitCount, locale.getId());\n        stats.setLastTranslatedBy(lastModifiedBy);\n        stats.setLastTranslatedDate(lastChanged);\n        stats.setLastTranslated(getLastTranslated(lastChanged, lastModifiedBy));\n\n        return stats;\n    }","id":102617,"modified_method":"private TranslationStatistics getMessageStats(TransUnitCount unitCount,\n            LocaleId locale, Date lastChanged, String lastModifiedBy) {\n        TranslationStatistics stats =\n                new TranslationStatistics(unitCount, locale.getId());\n        stats = setLastTranslated(stats, lastChanged, lastModifiedBy);\n        return stats;\n    }","commit_id":"7b4e1d6ec537a9e034d3e64c7f3035b25d32a7f4","url":"https://github.com/zanata/zanata-server"},{"original_method":"private HTextFlowTarget executeStateChangeTest(HTextFlowTarget target,\n            String newContent, ContentState newState, HPerson translator,\n            ContributionStatistics expectedStats) {\n        target = changeState(target, newContent, newState, translator);\n\n        String todayDate = formatter.format(today);\n\n        ContributionStatistics newStats =\n                statisticsService.getContributionStatistics(\n                        \"sample-project\", \"1.0\", translator.getAccount()\n                                .getUsername(), todayDate + \"..\" + todayDate, false);\n\n        assertNotNull(newStats);\n        assertThat(newStats).isEqualTo(expectedStats);\n        return target;\n    }","id":102618,"modified_method":"private HTextFlowTarget executeStateChangeTest(HTextFlowTarget target,\n            String newContent, ContentState newState, HPerson translator,\n            ContributionStatistics expectedStats) {\n        target = changeState(target, newContent, newState, translator);\n\n        String todayDate = formatter.format(today);\n\n        ContributionStatistics newStats =\n                statisticsService.getContributionStatistics(\n                        \"sample-project\", \"1.0\", translator.getAccount()\n                                .getUsername(), todayDate + \"..\" + todayDate, false);\n\n        assertNotNull(newStats);\n        assertThat(newStats.getUsername())\n                .isEqualTo(expectedStats.getUsername());\n        assertThat(newStats.getContributions())\n                .containsAll(expectedStats.getContributions());\n        return target;\n    }","commit_id":"7b4e1d6ec537a9e034d3e64c7f3035b25d32a7f4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void getContribStatsSingleTarget() {\n        PersonDAO personDAO = seam.autowire(PersonDAO.class);\n\n        // Initial state = needReview\n        HTextFlowTarget target = textFlowTargetDAO.findById(2L);\n\n        int wordCount = target.getTextFlow().getWordCount().intValue();\n\n        String todayDate = formatter.format(today);\n\n        String username = \"demo\";\n        HPerson demoPerson = personDAO.findByUsername(username);\n\n        ContributionStatistics initialStats =\n                statisticsService.getContributionStatistics(\n                        \"sample-project\", \"1.0\", username, todayDate + \"..\"\n                                + todayDate, false);\n\n        BaseContributionStatistic stats =\n                initialStats.get(username).get(target.getLocaleId());\n\n        // Should have no stats for user on today\n        assertNull(stats);\n\n        // needReview -> approved\n        ContributionStatistics expectedStats = new ContributionStatistics();\n        expectedStats.put(username, buildStats(target.getLocaleId(), 0, 0,\n                wordCount, 0));\n        target = executeStateChangeTest(target, \"test1\", ContentState.Approved,\n                demoPerson, expectedStats);\n\n        // approved -> approved\n        target = executeStateChangeTest(target, \"test2\", ContentState.Approved,\n                demoPerson, expectedStats);\n\n        // approved -> approved\n        target = executeStateChangeTest(target, \"test3\", ContentState.Approved,\n                demoPerson, expectedStats);\n\n        // approved -> needReview\n        expectedStats.put(username, buildStats(target.getLocaleId(), wordCount,\n                0, 0, 0));\n        target = executeStateChangeTest(target, \"test4\",\n                ContentState.NeedReview, demoPerson, expectedStats);\n    }","id":102619,"modified_method":"@Test\n    public void getContribStatsSingleTarget() {\n        PersonDAO personDAO = seam.autowire(PersonDAO.class);\n\n        // Initial state = needReview\n        HTextFlowTarget target = textFlowTargetDAO.findById(2L);\n\n        int wordCount = target.getTextFlow().getWordCount().intValue();\n\n        String todayDate = formatter.format(today);\n\n        String username = \"demo\";\n        HPerson demoPerson = personDAO.findByUsername(username);\n\n        ContributionStatistics initialStats =\n                statisticsService.getContributionStatistics(\n                        \"sample-project\", \"1.0\", username, todayDate + \"..\"\n                                + todayDate, false);\n\n        BaseContributionStatistic translationStats = getLocaleTranslationStats(\n                target.getLocaleId(), initialStats.getContributions());\n\n        // Should have no stats for user on today\n        assertNull(translationStats);\n\n        // needReview -> approved\n        ContributionStatistics expectedStats = new ContributionStatistics(\n                username,\n                Lists.newArrayList(buildStats(target.getLocaleId(), 0, 0,\n                        wordCount, 0)));\n        target = executeStateChangeTest(target, \"test1\", ContentState.Approved,\n                demoPerson, expectedStats);\n\n        // approved -> approved\n        target = executeStateChangeTest(target, \"test2\", ContentState.Approved,\n                demoPerson, expectedStats);\n\n        // approved -> approved\n        target = executeStateChangeTest(target, \"test3\", ContentState.Approved,\n                demoPerson, expectedStats);\n\n        // approved -> needReview\n        expectedStats = new ContributionStatistics(\n                username,\n                Lists.newArrayList(buildStats(target.getLocaleId(), wordCount,\n                        0, 0, 0)));\n        target = executeStateChangeTest(target, \"test4\",\n                ContentState.NeedReview, demoPerson, expectedStats);\n    }","commit_id":"7b4e1d6ec537a9e034d3e64c7f3035b25d32a7f4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void getContribStatsSameLocaleMultiTargets() {\n        PersonDAO personDAO = seam.autowire(PersonDAO.class);\n        String username = \"demo\";\n        HPerson demoPerson = personDAO.findByUsername(username);\n\n        // Initial state = new (en-us)\n        HTextFlowTarget target1 = textFlowTargetDAO.findById(5L);\n\n        // Initial state = new (en-us)\n        HTextFlowTarget target2 = textFlowTargetDAO.findById(6L);\n\n        LocaleId localeId = target1.getLocaleId(); // same as target2\n\n        int wordCount1 = target1.getTextFlow().getWordCount().intValue();\n        int wordCount2 = target2.getTextFlow().getWordCount().intValue();\n\n        // new -> approved\n        ContentState newState = ContentState.Approved;\n\n        ContributionStatistics expectedStats = new ContributionStatistics();\n        expectedStats.put(username, buildStats(localeId, 0, 0,\n                wordCount1, 0));\n        target1 = executeStateChangeTest(target1, \"test1\",\n                newState, demoPerson, expectedStats);\n\n        expectedStats.put(username, buildStats(localeId, 0, 0,\n                wordCount1 + wordCount2, 0));\n        target2 = executeStateChangeTest(target2, \"test1\",\n                newState, demoPerson, expectedStats);\n\n        // approved -> needReview\n        newState = ContentState.NeedReview;\n        expectedStats.put(username, buildStats(localeId, wordCount1, 0,\n                wordCount1, 0));\n        target1 = executeStateChangeTest(target1, \"test2\",\n                newState, demoPerson, expectedStats);\n\n        expectedStats.put(username, buildStats(localeId, wordCount1 + wordCount2,\n                0, 0, 0));\n        target2 = executeStateChangeTest(target2, \"test2\",\n                newState, demoPerson, expectedStats);\n    }","id":102620,"modified_method":"@Test\n    public void getContribStatsSameLocaleMultiTargets() {\n        PersonDAO personDAO = seam.autowire(PersonDAO.class);\n        String username = \"demo\";\n        HPerson demoPerson = personDAO.findByUsername(username);\n\n        // Initial state = new (en-us)\n        HTextFlowTarget target1 = textFlowTargetDAO.findById(5L);\n\n        // Initial state = new (en-us)\n        HTextFlowTarget target2 = textFlowTargetDAO.findById(6L);\n\n        LocaleId localeId = target1.getLocaleId(); // same as target2\n\n        int wordCount1 = target1.getTextFlow().getWordCount().intValue();\n        int wordCount2 = target2.getTextFlow().getWordCount().intValue();\n\n        // new -> approved\n        ContentState newState = ContentState.Approved;\n\n        ContributionStatistics expectedStats =\n                new ContributionStatistics(username,\n                        Lists.newArrayList(\n                                buildStats(localeId, 0, 0, wordCount1, 0)));\n        target1 = executeStateChangeTest(target1, \"test1\",\n                newState, demoPerson, expectedStats);\n\n        expectedStats =\n                new ContributionStatistics(username,\n                        Lists.newArrayList(\n                                buildStats(localeId, 0, 0,\n                                        wordCount1 + wordCount2, 0)));\n\n        target2 = executeStateChangeTest(target2, \"test1\",\n                newState, demoPerson, expectedStats);\n\n        // approved -> needReview\n        newState = ContentState.NeedReview;\n\n        expectedStats =\n                new ContributionStatistics(username,\n                        Lists.newArrayList(\n                                buildStats(localeId, wordCount1, 0,\n                                        wordCount1, 0)));\n        target1 = executeStateChangeTest(target1, \"test2\",\n                newState, demoPerson, expectedStats);\n\n        expectedStats =\n                new ContributionStatistics(username,\n                        Lists.newArrayList(\n                                buildStats(localeId, wordCount1 + wordCount2,\n                                        0, 0, 0)));\n        target2 = executeStateChangeTest(target2, \"test2\",\n                newState, demoPerson, expectedStats);\n    }","commit_id":"7b4e1d6ec537a9e034d3e64c7f3035b25d32a7f4","url":"https://github.com/zanata/zanata-server"},{"original_method":"private LocaleStatistics buildStats(LocaleId localeId, int needReview,\n            int translated, int approved, int rejected) {\n        LocaleStatistics localeStatistics = new LocaleStatistics();\n\n        localeStatistics.put(localeId, new BaseContributionStatistic(approved,\n                needReview, translated, rejected));\n\n        return localeStatistics;\n    }","id":102621,"modified_method":"private LocaleStatistics buildStats(LocaleId localeId, int needReview,\n            int translated, int approved, int rejected) {\n        BaseContributionStatistic translationStats =\n                new BaseContributionStatistic(approved,\n                        needReview, translated, rejected);\n        return new LocaleStatistics(localeId, translationStats, null);\n    }","commit_id":"7b4e1d6ec537a9e034d3e64c7f3035b25d32a7f4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void getContributionStatisticsMultiLocale() {\n        PersonDAO personDAO = seam.autowire(PersonDAO.class);\n        String username = \"demo\";\n        HPerson demoPerson = personDAO.findByUsername(username);\n\n        // Initial state = needReview (AS)\n        HTextFlowTarget target1 = textFlowTargetDAO.findById(1L);\n\n        // Initial state = needReview (DE)\n        HTextFlowTarget target2 = textFlowTargetDAO.findById(2L);\n\n        int wordCount1 = target1.getTextFlow().getWordCount().intValue();\n        int wordCount2 = target2.getTextFlow().getWordCount().intValue();\n\n        // needReview -> approved\n        ContentState newState = ContentState.Approved;\n\n        ContributionStatistics expectedStats = new ContributionStatistics();\n        expectedStats.put(username, buildStats(target1.getLocaleId(), 0, 0,\n                wordCount1, 0));\n        target1 = executeStateChangeTest(target1, \"test1\",\n                newState, demoPerson, expectedStats);\n\n        expectedStats.get(username).putAll(buildStats(target2.getLocaleId(), 0,\n                0, wordCount2, 0));\n        target2 = executeStateChangeTest(target2, \"test1\",\n                newState, demoPerson, expectedStats);\n\n        // approved -> needReview\n        newState = ContentState.NeedReview;\n        BaseContributionStatistic localeStat = expectedStats.get(username)\n                .get(target1.getLocaleId());\n        localeStat.set(newState, localeStat.get(newState) + wordCount1);\n        localeStat.set(ContentState.Approved, 0);\n        target1 = executeStateChangeTest(target1, \"test2\",\n                newState, demoPerson, expectedStats);\n\n        localeStat = expectedStats.get(username).get(target2.getLocaleId());\n        localeStat.set(newState, localeStat.get(newState) + wordCount2);\n        localeStat.set(ContentState.Approved, 0);\n        target2 = executeStateChangeTest(target2, \"test2\",\n                newState, demoPerson, expectedStats);\n\n    }","id":102622,"modified_method":"@Test\n    public void getContributionStatisticsMultiLocale() {\n        PersonDAO personDAO = seam.autowire(PersonDAO.class);\n        String username = \"demo\";\n        HPerson demoPerson = personDAO.findByUsername(username);\n\n        // Initial state = needReview (AS)\n        HTextFlowTarget target1 = textFlowTargetDAO.findById(1L);\n\n        // Initial state = needReview (DE)\n        HTextFlowTarget target2 = textFlowTargetDAO.findById(2L);\n\n        int wordCount1 = target1.getTextFlow().getWordCount().intValue();\n        int wordCount2 = target2.getTextFlow().getWordCount().intValue();\n\n        // needReview -> approved\n        ContentState newState = ContentState.Approved;\n\n        ContributionStatistics expectedStats = new ContributionStatistics(\n                username,\n                Lists.newArrayList(buildStats(target1.getLocaleId(), 0, 0,\n                        wordCount1, 0)));\n        target1 = executeStateChangeTest(target1, \"test1\",\n                newState, demoPerson, expectedStats);\n\n        expectedStats.getContributions()\n                .add(buildStats(target2.getLocaleId(), 0,\n                        0, wordCount2, 0));\n        target2 = executeStateChangeTest(target2, \"test1\",\n                newState, demoPerson, expectedStats);\n\n        // approved -> needReview\n        newState = ContentState.NeedReview;\n        BaseContributionStatistic localeStat =\n                getLocaleTranslationStats(target1.getLocaleId(),\n            expectedStats.getContributions());\n        localeStat.set(newState, localeStat.get(newState) + wordCount1);\n        localeStat.set(ContentState.Approved, 0);\n        target1 = executeStateChangeTest(target1, \"test2\",\n                newState, demoPerson, expectedStats);\n        localeStat = getLocaleTranslationStats(target2.getLocaleId(),\n                expectedStats.getContributions());\n        localeStat.set(newState, localeStat.get(newState) + wordCount2);\n        localeStat.set(ContentState.Approved, 0);\n        target2 = executeStateChangeTest(target2, \"test2\",\n                newState, demoPerson, expectedStats);\n\n    }","commit_id":"7b4e1d6ec537a9e034d3e64c7f3035b25d32a7f4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void getContribStatsDiffUser() {\n        PersonDAO personDAO = seam.autowire(PersonDAO.class);\n\n        String username1 = \"demo\";\n        String username2 = \"admin\";\n        HPerson person1 = personDAO.findByUsername(username1);\n        HPerson person2 = personDAO.findByUsername(username2);\n\n        HTextFlowTarget target = textFlowTargetDAO.findById(1L);\n\n        int wordCount = target.getTextFlow().getWordCount().intValue();\n\n        ContentState newState = ContentState.Approved;\n\n        ContributionStatistics expectedStats = new ContributionStatistics();\n        expectedStats.put(username1, buildStats(target.getLocaleId(), 0, 0,\n                wordCount, 0));\n        target = executeStateChangeTest(target, \"test1\",\n                newState, person1, expectedStats);\n\n        ContributionStatistics expectedStats2 = new ContributionStatistics();\n        expectedStats2.put(username2, buildStats(target.getLocaleId(), 0, 0,\n                wordCount, 0));\n        target = executeStateChangeTest(target, \"test2\",\n                newState, person2, expectedStats2);\n\n        //Test person1 statistic has not changed\n        String todayDate = formatter.format(today);\n        ContributionStatistics newStats =\n                statisticsService.getContributionStatistics(\n                        \"sample-project\", \"1.0\", person1.getAccount()\n                                .getUsername(), todayDate + \"..\" + todayDate, false);\n        assertThat(newStats).isEqualTo(expectedStats);\n    }","id":102623,"modified_method":"@Test\n    public void getContribStatsDiffUser() {\n        PersonDAO personDAO = seam.autowire(PersonDAO.class);\n\n        String username1 = \"demo\";\n        String username2 = \"admin\";\n        HPerson person1 = personDAO.findByUsername(username1);\n        HPerson person2 = personDAO.findByUsername(username2);\n\n        HTextFlowTarget target = textFlowTargetDAO.findById(1L);\n\n        int wordCount = target.getTextFlow().getWordCount().intValue();\n\n        ContentState newState = ContentState.Approved;\n\n        ContributionStatistics expectedStats = new ContributionStatistics(\n                username1,\n                Lists.newArrayList(buildStats(target.getLocaleId(), 0, 0,\n                        wordCount, 0)));\n        target = executeStateChangeTest(target, \"test1\",\n                newState, person1, expectedStats);\n\n        ContributionStatistics expectedStats2 = new ContributionStatistics(\n                username2,\n                Lists.newArrayList(buildStats(target.getLocaleId(), 0, 0,\n                        wordCount, 0)));\n        target = executeStateChangeTest(target, \"test2\",\n                newState, person2, expectedStats2);\n\n        //Test person1 statistic has not changed\n        String todayDate = formatter.format(today);\n        ContributionStatistics newStats =\n                statisticsService.getContributionStatistics(\n                        \"sample-project\", \"1.0\", person1.getAccount()\n                                .getUsername(), todayDate + \"..\" + todayDate, false);\n        assertThat(newStats).isEqualTo(expectedStats);\n    }","commit_id":"7b4e1d6ec537a9e034d3e64c7f3035b25d32a7f4","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Query to get total wordCount of a person(translated_by_id) from\n     * HTextFlowTarget union HTextFlowTargetHistory tables\n     * in a project-version, within given date range group by state and locale.\n     *\n     * HTextFlowTargetHistory:\n     * gets latest of all records translated from user in given version,\n     * locale and dateRange and its target is not translated by same person.\n     *\n     * HTextFlowTarget:\n     * gets all records translated from user in given version, locale and\n     * dateRange.\n     *\n     * @param versionId HProjectIteration identifier\n     * @param personId HPerson identifier\n     * @param from start of date range\n     * @param to end of date range\n     *\n     * @return list of Object[wordCount][contentState][localeId]\n     */\n    @NativeQuery\n    public List<Object[]> getUserContributionStatisticInVersion(\n            Long versionId, Long personId, Date fromDate, Date toDate, boolean automatedEntry) {\n\n        StringBuilder queryString = new StringBuilder();\n        queryString\n                .append(\"select sum(wordCount), state, localeId from \")\n                    .append(\"(select wordCount, id, state, localeId from \")\n                        .append(\n                            \"(select h.state, tft.id, h.translated_by_id, tf.wordCount, locale.localeId \")\n                        .append(\"from HTextFlowTargetHistory h \")\n                        .append(\"JOIN HTextFlowTarget tft ON tft.id = h.target_id \")\n                        .append(\"JOIN HLocale locale ON locale.id = tft.locale \")\n                        .append(\"JOIN HTextFlow tf ON tf.id = tft.tf_id \")\n                        .append(\"JOIN HDocument doc ON doc.id = tf.document_Id \")\n                        .append(\"where doc.project_iteration_id =:versionId \")\n                        .append(\"and h.state <> :untranslated \")\n                        .append(\"and h.translated_by_id =:personId \")\n                        .append(\"and h.lastChanged between :fromDate and :toDate \")\n                        .append(\"and h.automatedEntry =:automatedEntry \")\n                        .append(\"and tft.translated_by_id <> h.translated_by_id \")\n                        .append(\"and h.lastChanged = \")\n                            .append(\n                                \"(select max(lastChanged) from HTextFlowTargetHistory where h.target_id = target_id) \")\n                        .append(\"union all \")\n                        .append(\"select tft.state, tft.id, tft.translated_by_id, tf.wordCount, locale.localeId \")\n                        .append(\"from HTextFlowTarget tft \")\n                        .append(\"JOIN HLocale locale ON locale.id = tft.locale \")\n                        .append(\"JOIN HTextFlow tf ON tf.id = tft.tf_id \")\n                        .append(\"JOIN HDocument doc ON doc.id = tf.document_Id \")\n                        .append(\"where doc.project_iteration_id =:versionId \")\n                        .append(\"and tft.state <> :untranslated \")\n                        .append(\"and tft.automatedEntry =:automatedEntry \")\n                        .append(\"and tft.translated_by_id =:personId \")\n                        .append(\"and tft.lastChanged between :fromDate and :toDate \")\n                        .append(\") as target_history_union \")\n                    .append(\"group by state, id, localeId, wordCount) as target_history_group \")\n                .append(\"group by state, localeId\");\n\n\n        Query query = getSession().createSQLQuery(queryString.toString());\n        query.setParameter(\"versionId\", versionId);\n        query.setParameter(\"personId\", personId);\n        query.setInteger(\"untranslated\", ContentState.New.ordinal());\n        query.setBoolean(\"automatedEntry\", automatedEntry);\n        query.setTimestamp(\"fromDate\", fromDate);\n        query.setTimestamp(\"toDate\", toDate);\n        query.setComment(\"textFlowTargetHistoryDAO.getUserContributionStatisticInVersion\");\n        return query.list();\n    }","id":102624,"modified_method":"/**\n     * Query to get total wordCount of a person(translated_by_id) from\n     * HTextFlowTarget union HTextFlowTargetHistory tables\n     * in a project-version, within given date range group by state and locale.\n     *\n     * HTextFlowTargetHistory:\n     * gets latest of all records translated from user in given version,\n     * locale and dateRange and its target is not translated by same person.\n     *\n     * HTextFlowTarget:\n     * gets all records translated from user in given version, locale and\n     * dateRange.\n     *\n     * @param versionId HProjectIteration identifier\n     * @param personId HPerson identifier\n     * @param from start of date range\n     * @param to end of date range\n     *\n     * @return list of Object[wordCount][contentState][localeId]\n     */\n    @NativeQuery\n    public List<Object[]> getUserTranslationStatisticInVersion(\n            Long versionId, Long personId, Date fromDate, Date toDate, boolean automatedEntry) {\n        Query query = buildContributionStatisticQuery(true, versionId,\n            personId, fromDate, toDate, automatedEntry);\n        query.setComment(\"textFlowTargetHistoryDAO.getUserTranslationStatisticInVersion\");\n        return query.list();\n    }","commit_id":"7b4e1d6ec537a9e034d3e64c7f3035b25d32a7f4","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Makes a synchronous call on the UMO\n     *\n     * @param event the event to pass to the UMO\n     * @return the return event from the UMO\n     * @throws UMOException if the call fails\n     */\n    public Object onCall(UMOEvent event) throws UMOException\n    {\n        logger.trace(\"MuleProxy: sync call for Mule UMO \" + descriptor.getName());\n\n        UMOMessage returnMessage = null;\n        try\n        {\n            if (event.getEndpoint().canReceive())\n            {\n                RequestContext.setEvent(event);\n                Object replyTo = event.getMessage().getReplyTo();\n                InterceptorsInvoker invoker = new InterceptorsInvoker(interceptorList, descriptor, event.getMessage());\n\n                //stats\n                long startTime = 0;\n                if (stat.isEnabled())\n                    startTime = System.currentTimeMillis();\n\n                UMOMessage result = invoker.execute();\n                //stats\n                if (stat.isEnabled())\n                    stat.addExecutionTime(System.currentTimeMillis() - startTime);\n\n                //returnMessage = processResponse(result, replyTo, ((AbstractConnector) event.getEndpoint().getConnector()).getReplyToHandler());\n                //this is the request event\n                event = RequestContext.getEvent();\n                if (event.isStopFurtherProcessing())\n                {\n                    logger.debug(\"Event stop further processing has been set, no outbound routing will be performed.\");\n                }\n                if (result != null && !event.isStopFurtherProcessing())\n                {\n                    Map context = RequestContext.clearProperties();\n                    if (context != null)\n                    {\n                        result.addProperties(context);\n                    }\n                    returnMessage = descriptor.getOutboundRouter().route(result, event.getSession(), event.isSynchronous());\n                } else\n                {\n                    returnMessage = result;\n                }\n\n                //process repltyTo if there is one\n                if (result != null && replyTo != null)\n                {\n                    String requestor = (String) result.getProperty(MuleProperties.MULE_REPLY_TO_REQUESTOR_PROPERTY);\n\n                    ReplyToHandler replyToHandler = ((AbstractConnector) event.getEndpoint().getConnector()).getReplyToHandler();\n                    if (replyToHandler != null)\n                    {\n                        if ((requestor != null && !requestor.equals(descriptor.getName())) ||\n                                requestor == null)\n                        {\n                            replyToHandler.processReplyTo(event, result, replyTo);\n                        }\n                    }\n                }\n            } else\n            {\n                returnMessage = event.getSession().sendEvent(event);\n                processReplyTo(returnMessage);\n            }\n\n            //stats\n            if (stat.isEnabled())\n                stat.incSentEventSync();\n        } catch (Exception e)\n        {\n            event.getSession().setValid(false);\n            if(e instanceof UMOException) {\n                handleException(e);\n            } else {\n                handleException(new MessagingException(new Message(Messages.EVENT_PROCIESSING_FAILED_FOR_X, descriptor.getName()), event.getMessage(), e));\n            }\n        } finally\n        {\n            //Finalise the event for this component\n            ((MuleComponent) event.getComponent()).finaliseEvent(event);\n        }\n        return returnMessage;\n    }","id":102625,"modified_method":"/**\n     * Makes a synchronous call on the UMO\n     *\n     * @param event the event to pass to the UMO\n     * @return the return event from the UMO\n     * @throws UMOException if the call fails\n     */\n    public Object onCall(UMOEvent event) throws UMOException\n    {\n        logger.trace(\"MuleProxy: sync call for Mule UMO \" + descriptor.getName());\n\n        UMOMessage returnMessage = null;\n        try\n        {\n            if (event.getEndpoint().canReceive())\n            {\n                RequestContext.setEvent(event);\n                Object replyTo = event.getMessage().getReplyTo();\n                ReplyToHandler replyToHandler = null;\n                if(replyTo!=null) {\n                    replyToHandler = ((AbstractConnector) event.getEndpoint().getConnector()).getReplyToHandler();\n                }\n                InterceptorsInvoker invoker = new InterceptorsInvoker(interceptorList, descriptor, event.getMessage());\n\n                //stats\n                long startTime = 0;\n                if (stat.isEnabled())\n                    startTime = System.currentTimeMillis();\n\n                UMOMessage result = invoker.execute();\n                //stats\n                if (stat.isEnabled())\n                    stat.addExecutionTime(System.currentTimeMillis() - startTime);\n\n                //returnMessage = processResponse(result, replyTo, ((AbstractConnector) event.getEndpoint().getConnector()).getReplyToHandler());\n                //this is the request event\n                event = RequestContext.getEvent();\n                if (event.isStopFurtherProcessing())\n                {\n                    logger.debug(\"Event stop further processing has been set, no outbound routing will be performed.\");\n                }\n                if (result != null && !event.isStopFurtherProcessing())\n                {\n                    Map context = RequestContext.clearProperties();\n                    if (context != null)\n                    {\n                        result.addProperties(context);\n                    }\n                    returnMessage = descriptor.getOutboundRouter().route(result, event.getSession(), event.isSynchronous());\n                } else\n                {\n                    returnMessage = result;\n                }\n\n                //process repltyTo if there is one\n                if (result != null && replyToHandler != null)\n                {\n                    String requestor = (String) result.getProperty(MuleProperties.MULE_REPLY_TO_REQUESTOR_PROPERTY);\n                    if ((requestor != null && !requestor.equals(descriptor.getName())) ||\n                            requestor == null)\n                    {\n                        replyToHandler.processReplyTo(event, result, replyTo);\n                    }\n                }\n            } else\n            {\n                returnMessage = event.getSession().sendEvent(event);\n                processReplyTo(returnMessage);\n            }\n\n            //stats\n            if (stat.isEnabled())\n                stat.incSentEventSync();\n        } catch (Exception e)\n        {\n            event.getSession().setValid(false);\n            if(e instanceof UMOException) {\n                handleException(e);\n            } else {\n                handleException(new MessagingException(new Message(Messages.EVENT_PROCIESSING_FAILED_FOR_X, descriptor.getName()), event.getMessage(), e));\n            }\n        } finally\n        {\n            //Finalise the event for this component\n            ((MuleComponent) event.getComponent()).finaliseEvent(event);\n        }\n        return returnMessage;\n    }","commit_id":"6123f0b2728dd4e3ba7b2baa30d5bbfc256ced0b","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testClientDispatchAndReceiveOnReplyTo() throws Exception\n    {\n        MuleClient client = new MuleClient();\n        MuleManager.getConfiguration().setSynchronous(false);\n\n        Map props = new HashMap();\n        props.put(\"JMSReplyTo\", \"replyTo.queue\");\n\n        long start = System.currentTimeMillis();\n        int i = 0;\n        for( i = 0;i < 100;i++) {\n            System.out.println(\"Sending message \" + i);\n            client.dispatch(getDispatchUrl(), \"Test Client Dispatch message\" + i, props);\n        }\n        long time = System.currentTimeMillis() - start;\n        System.out.println(\"It took \" + time + \"ms to send \" + i + \" messages\");\n\n        start = System.currentTimeMillis();\n        for( i = 0;i < 100;i++) {\n            UMOMessage message = client.receive(\"jms://replyTo.queue\", 3000);\n            System.out.println(\"Count is \" + i);\n            assertNotNull(message);\n            System.out.println(((TextMessage)message.getPayload()).getText());\n            //((TextMessage)message.getPayload()).acknowledge();\n        }\n        time = System.currentTimeMillis() - start;\n        System.out.println(\"It took \" + time + \"ms to receive \" + i + \" messages\");\n\n        //assertEquals(\"Received: Test Client Dispatch message\", ((TextMessage)message.getPayload()).getText());\n    }","id":102626,"modified_method":"public void testClientDispatchAndReceiveOnReplyTo() throws Exception\n    {\n        MuleClient client = new MuleClient();\n        MuleManager.getConfiguration().setSynchronous(false);\n\n        Map props = new HashMap();\n        props.put(\"JMSReplyTo\", \"replyTo.queue\");\n\n        long start = System.currentTimeMillis();\n        int i = 0;\n        for( i = 0;i < 100;i++) {\n            System.out.println(\"Sending message \" + i);\n            client.dispatch(getDispatchUrl(), \"Test Client Dispatch message\" + i, props);\n        }\n        long time = System.currentTimeMillis() - start;\n        System.out.println(\"It took \" + time + \"ms to send \" + i + \" messages\");\n\n        start = System.currentTimeMillis();\n        for( i = 0;i < 100;i++) {\n            UMOMessage message = client.receive(\"jms://replyTo.queue\", 5000);\n            System.out.println(\"Count is \" + i);\n            assertNotNull(message);\n            System.out.println(((TextMessage)message.getPayload()).getText());\n            //((TextMessage)message.getPayload()).acknowledge();\n        }\n        time = System.currentTimeMillis() - start;\n        System.out.println(\"It took \" + time + \"ms to receive \" + i + \" messages\");\n\n        //assertEquals(\"Received: Test Client Dispatch message\", ((TextMessage)message.getPayload()).getText());\n    }","commit_id":"8ec7d2b86cd053c017087fe36feb047af9b7d3c1","url":"https://github.com/mulesoft/mule"},{"original_method":"public void run()\n    {\n        logger.trace(\"MuleProxy: async onEvent for Mule UMO \" + descriptor.getName());\n\n        try\n        {\n            if (event.getEndpoint().canReceive())\n            {\n                //dispatch the next receiver\n                RequestContext.setEvent(event);\n                Object replyTo = event.getMessage().getReplyTo();\n                ReplyToHandler replyToHandler = ((AbstractConnector) event.getEndpoint().getConnector()).getReplyToHandler();\n                InterceptorsInvoker invoker = new InterceptorsInvoker(interceptorList, descriptor, event.getMessage());\n\n                //do stats\n                long startTime = 0;\n                if (stat.isEnabled())\n                {\n                    startTime = System.currentTimeMillis();\n                }\n\n                UMOMessage result = invoker.execute();\n                if (stat.isEnabled())\n                {\n                    stat.addExecutionTime(System.currentTimeMillis() - startTime);\n                }\n               // processResponse(result, replyTo, replyToHandler);\n                event = (MuleEvent) RequestContext.getEvent();\n                if (result != null && !event.isStopFurtherProcessing())\n                {\n                    descriptor.getOutboundRouter().route(result, event.getSession(), event.isSynchronous());\n                }\n\n                //process repltyTo if there is one\n                if (result != null && replyTo != null)\n                {\n                    String requestor = (String) result.getProperty(MuleProperties.MULE_REPLY_TO_REQUESTOR_PROPERTY);\n\n                    if (replyToHandler != null)\n                    {\n                        if ((requestor != null && !requestor.equals(descriptor.getName())) ||\n                                requestor == null)\n                        {\n                            replyToHandler.processReplyTo(event, result, replyTo);\n                        }\n                    }\n                }\n            } else\n            {\n                UMOMessageDispatcher dispatcher = event.getEndpoint().getConnector().getDispatcher(event.getEndpoint().getEndpointURI().getAddress());\n                dispatcher.dispatch(event);\n            }\n\n            //Finalise the event for this component\n            ((MuleComponent) event.getComponent()).finaliseEvent(event);\n\n            if (stat.isEnabled())\n            {\n                stat.incSentEventASync();\n            }\n        } catch (Exception e)\n        {\n            //Finalise the event for this component\n            ((MuleComponent) event.getComponent()).finaliseEvent(event);\n            event.getSession().setValid(false);\n            if(e instanceof UMOException) {\n                handleException(e);\n            } else {\n                handleException(new MessagingException(new Message(Messages.EVENT_PROCIESSING_FAILED_FOR_X, descriptor.getName()), event.getMessage(), e));\n            }\n        } finally\n        {\n            try\n            {\n                proxyPool.returnObject(this);\n            } catch (Exception e2)\n            {\n                logger.error(\"Failed to return proxy: \" + e2.getMessage(), e2);\n            }\n        }\n    }","id":102627,"modified_method":"public void run()\n    {\n        logger.trace(\"MuleProxy: async onEvent for Mule UMO \" + descriptor.getName());\n\n        try\n        {\n            if (event.getEndpoint().canReceive())\n            {\n                //dispatch the next receiver\n                RequestContext.setEvent(event);\n                Object replyTo = event.getMessage().getReplyTo();\n                ReplyToHandler replyToHandler = null;\n                if(replyTo!=null) {\n                    replyToHandler = ((AbstractConnector) event.getEndpoint().getConnector()).getReplyToHandler();\n                }\n                InterceptorsInvoker invoker = new InterceptorsInvoker(interceptorList, descriptor, event.getMessage());\n\n                //do stats\n                long startTime = 0;\n                if (stat.isEnabled())\n                {\n                    startTime = System.currentTimeMillis();\n                }\n\n                UMOMessage result = invoker.execute();\n                if (stat.isEnabled())\n                {\n                    stat.addExecutionTime(System.currentTimeMillis() - startTime);\n                }\n               // processResponse(result, replyTo, replyToHandler);\n                event = (MuleEvent) RequestContext.getEvent();\n                if (result != null && !event.isStopFurtherProcessing())\n                {\n                    descriptor.getOutboundRouter().route(result, event.getSession(), event.isSynchronous());\n                }\n\n                //process repltyTo if there is one\n                if (result != null && replyToHandler != null)\n                {\n                    String requestor = (String) result.getProperty(MuleProperties.MULE_REPLY_TO_REQUESTOR_PROPERTY);\n                    if ((requestor != null && !requestor.equals(descriptor.getName())) ||\n                            requestor == null)\n                    {\n                        replyToHandler.processReplyTo(event, result, replyTo);\n                    }\n                }\n            } else\n            {\n                UMOMessageDispatcher dispatcher = event.getEndpoint().getConnector().getDispatcher(event.getEndpoint().getEndpointURI().getAddress());\n                dispatcher.dispatch(event);\n            }\n\n            //Finalise the event for this component\n            ((MuleComponent) event.getComponent()).finaliseEvent(event);\n\n            if (stat.isEnabled())\n            {\n                stat.incSentEventASync();\n            }\n        } catch (Exception e)\n        {\n            //Finalise the event for this component\n            ((MuleComponent) event.getComponent()).finaliseEvent(event);\n            event.getSession().setValid(false);\n            if(e instanceof UMOException) {\n                handleException(e);\n            } else {\n                handleException(new MessagingException(new Message(Messages.EVENT_PROCIESSING_FAILED_FOR_X, descriptor.getName()), event.getMessage(), e));\n            }\n        } finally\n        {\n            try\n            {\n                proxyPool.returnObject(this);\n            } catch (Exception e2)\n            {\n                logger.error(\"Failed to return proxy: \" + e2.getMessage(), e2);\n            }\n        }\n    }","commit_id":"8ec7d2b86cd053c017087fe36feb047af9b7d3c1","url":"https://github.com/mulesoft/mule"},{"original_method":"public void setUp() throws Exception\n    {\n        System.setProperty(\"org.mule.disable.server.connections\", \"false\");       \n        if(MuleManager.isInstanciated()) MuleManager.getInstance().dispose();\n        MuleXmlConfigurationBuilder builder = new MuleXmlConfigurationBuilder();\n        builder.configure(\"org/mule/test/integration/client/test-client-mule-config-remote-jms.xml\");\n    }","id":102628,"modified_method":"public void setUp() throws Exception\n    {\n        System.setProperty(\"org.mule.disable.server.connections\", \"false\");\n        if(MuleManager.isInstanciated()) MuleManager.getInstance().dispose();\n        MuleXmlConfigurationBuilder builder = new MuleXmlConfigurationBuilder();\n        builder.configure(\"org/mule/test/integration/client/test-client-mule-config-remote-jms.xml\");\n        System.setProperty(\"org.mule.disable.server.connections\", \"true\");\n    }","commit_id":"ae8bf91c66555bb6d0ab75b7d84239c7b44869c8","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Makes a synchronous call on the UMO\n     *\n     * @param event the event to pass to the UMO\n     * @return the return event from the UMO\n     * @throws UMOException if the call fails\n     */\n    public Object onCall(UMOEvent event) throws UMOException\n    {\n        logger.trace(\"MuleProxy: sync call for Mule UMO \" + descriptor.getName());\n\n        UMOMessage returnMessage = null;\n        try\n        {\n            if (event.getEndpoint().canReceive())\n            {\n                RequestContext.setEvent(event);\n                Object replyTo = event.getMessage().getReplyTo();\n                InterceptorsInvoker invoker = new InterceptorsInvoker(interceptorList, descriptor, event.getMessage());\n\n                //stats\n                long startTime = 0;\n                if (stat.isEnabled())\n                    startTime = System.currentTimeMillis();\n\n                UMOMessage result = invoker.execute();\n                //stats\n                if (stat.isEnabled())\n                    stat.addExecutionTime(System.currentTimeMillis() - startTime);\n\n                //returnMessage = processResponse(result, replyTo, ((AbstractConnector) event.getEndpoint().getConnector()).getReplyToHandler());\n                //this is the request event\n                event = RequestContext.getEvent();\n                if (event.isStopFurtherProcessing())\n                {\n                    logger.debug(\"Event stop further processing has been set, no outbound routing will be performed.\");\n                }\n                if (result != null && !event.isStopFurtherProcessing())\n                {\n                    Map context = RequestContext.clearProperties();\n                    if (context != null)\n                    {\n                        result.addProperties(context);\n                    }\n                    returnMessage = descriptor.getOutboundRouter().route(result, event.getSession(), event.isSynchronous());\n                } else\n                {\n                    returnMessage = result;\n                }\n\n                //process repltyTo if there is one\n                if (result != null && replyTo != null)\n                {\n                    String requestor = (String) result.getProperty(MuleProperties.MULE_REPLY_TO_REQUESTOR_PROPERTY);\n\n                    ReplyToHandler replyToHandler = ((AbstractConnector) event.getEndpoint().getConnector()).getReplyToHandler();\n                    if (replyToHandler != null)\n                    {\n                        if ((requestor != null && !requestor.equals(descriptor.getName())) ||\n                                requestor == null)\n                        {\n                            replyToHandler.processReplyTo(event, result, replyTo);\n                        }\n                    }\n                }\n            } else\n            {\n                returnMessage = event.getSession().sendEvent(event);\n                processReplyTo(returnMessage);\n            }\n\n            //stats\n            if (stat.isEnabled())\n                stat.incSentEventSync();\n        } catch (Exception e)\n        {\n            event.getSession().setValid(false);\n            if(e instanceof UMOException) {\n                handleException(e);\n            } else {\n                handleException(new MessagingException(new Message(Messages.EVENT_PROCIESSING_FAILED_FOR_X, descriptor.getName()), event.getMessage(), e));\n            }\n        } finally\n        {\n            //Finalise the event for this component\n            ((MuleComponent) event.getComponent()).finaliseEvent(event);\n        }\n        return returnMessage;\n    }","id":102629,"modified_method":"/**\n     * Makes a synchronous call on the UMO\n     *\n     * @param event the event to pass to the UMO\n     * @return the return event from the UMO\n     * @throws UMOException if the call fails\n     */\n    public Object onCall(UMOEvent event) throws UMOException\n    {\n        logger.trace(\"MuleProxy: sync call for Mule UMO \" + descriptor.getName());\n\n        UMOMessage returnMessage = null;\n        try\n        {\n            if (event.getEndpoint().canReceive())\n            {\n                RequestContext.setEvent(event);\n                Object replyTo = event.getMessage().getReplyTo();\n                ReplyToHandler replyToHandler = null;\n                if(replyTo!=null) {\n                    replyToHandler = ((AbstractConnector) event.getEndpoint().getConnector()).getReplyToHandler();\n                }\n                InterceptorsInvoker invoker = new InterceptorsInvoker(interceptorList, descriptor, event.getMessage());\n\n                //stats\n                long startTime = 0;\n                if (stat.isEnabled())\n                    startTime = System.currentTimeMillis();\n\n                UMOMessage result = invoker.execute();\n                //stats\n                if (stat.isEnabled())\n                    stat.addExecutionTime(System.currentTimeMillis() - startTime);\n\n                //returnMessage = processResponse(result, replyTo, ((AbstractConnector) event.getEndpoint().getConnector()).getReplyToHandler());\n                //this is the request event\n                event = RequestContext.getEvent();\n                if (event.isStopFurtherProcessing())\n                {\n                    logger.debug(\"Event stop further processing has been set, no outbound routing will be performed.\");\n                }\n                if (result != null && !event.isStopFurtherProcessing())\n                {\n                    Map context = RequestContext.clearProperties();\n                    if (context != null)\n                    {\n                        result.addProperties(context);\n                    }\n                    returnMessage = descriptor.getOutboundRouter().route(result, event.getSession(), event.isSynchronous());\n                } else\n                {\n                    returnMessage = result;\n                }\n\n                //process repltyTo if there is one\n                if (result != null && replyToHandler != null)\n                {\n                    String requestor = (String) result.getProperty(MuleProperties.MULE_REPLY_TO_REQUESTOR_PROPERTY);\n                    if ((requestor != null && !requestor.equals(descriptor.getName())) ||\n                            requestor == null)\n                    {\n                        replyToHandler.processReplyTo(event, result, replyTo);\n                    }\n                }\n            } else\n            {\n                returnMessage = event.getSession().sendEvent(event);\n                processReplyTo(returnMessage);\n            }\n\n            //stats\n            if (stat.isEnabled())\n                stat.incSentEventSync();\n        } catch (Exception e)\n        {\n            event.getSession().setValid(false);\n            if(e instanceof UMOException) {\n                handleException(e);\n            } else {\n                handleException(new MessagingException(new Message(Messages.EVENT_PROCIESSING_FAILED_FOR_X, descriptor.getName()), event.getMessage(), e));\n            }\n        } finally\n        {\n            //Finalise the event for this component\n            ((MuleComponent) event.getComponent()).finaliseEvent(event);\n        }\n        return returnMessage;\n    }","commit_id":"ae8bf91c66555bb6d0ab75b7d84239c7b44869c8","url":"https://github.com/mulesoft/mule"},{"original_method":"public URL getConfigFile()\n    {\n        return configFile;\n    }","id":102630,"modified_method":"public String getConfigFile()\n    {\n        return configFile;\n    }","commit_id":"ae8bf91c66555bb6d0ab75b7d84239c7b44869c8","url":"https://github.com/mulesoft/mule"},{"original_method":"public void initialise() throws InitialisationException, RecoverableException\n    {\n        if(configFile==null) return;\n        try\n        {\n            container.setConfiguration(configFile);\n            container.start();\n        } catch (Exception e)\n        {\n            throw new InitialisationException(new Message(Messages.FAILED_TO_CREATE_X_WITH_X, \"Plexus container\", this.configFile), this);\n        }\n    }","id":102631,"modified_method":"public void initialise() throws InitialisationException, RecoverableException\n    {\n        if(configFile==null) return;\n        try\n        {\n            URL url = Utility.getResource(configFile, getClass());\n            if (url == null)\n            {\n                throw new ConfigurationException(new Message(Messages.CANT_LOAD_X_FROM_CLASSPATH_FILE, configFile));\n            }\n            container.setConfiguration(url);\n            container.start();\n        } catch (Exception e)\n        {\n            throw new InitialisationException(new Message(Messages.FAILED_TO_CREATE_X_WITH_X, \"Plexus container\", this.configFile), this);\n        }\n    }","commit_id":"ae8bf91c66555bb6d0ab75b7d84239c7b44869c8","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * @param configFile The configFile to set.\n     */\n    public void setConfigFile(String configFile) throws ConfigurationException\n    {\n        URL url = Utility.getResource(configFile, getClass());\n        if (url == null)\n        {\n            throw new ConfigurationException(new Message(Messages.CANT_LOAD_X_FROM_CLASSPATH_FILE, configFile));\n        }\n        setConfigFile(url);\n    }","id":102632,"modified_method":"/**\n     * @param configFile The configFile to set.\n     */\n    public void setConfigFile(String configFile) throws ConfigurationException\n    {\n        this.configFile = configFile;\n    }","commit_id":"ae8bf91c66555bb6d0ab75b7d84239c7b44869c8","url":"https://github.com/mulesoft/mule"},{"original_method":"public void run()\n    {\n        logger.trace(\"MuleProxy: async onEvent for Mule UMO \" + descriptor.getName());\n\n        try\n        {\n            if (event.getEndpoint().canReceive())\n            {\n                //dispatch the next receiver\n                RequestContext.setEvent(event);\n                Object replyTo = event.getMessage().getReplyTo();\n                ReplyToHandler replyToHandler = ((AbstractConnector) event.getEndpoint().getConnector()).getReplyToHandler();\n                InterceptorsInvoker invoker = new InterceptorsInvoker(interceptorList, descriptor, event.getMessage());\n\n                //do stats\n                long startTime = 0;\n                if (stat.isEnabled())\n                {\n                    startTime = System.currentTimeMillis();\n                }\n\n                UMOMessage result = invoker.execute();\n                if (stat.isEnabled())\n                {\n                    stat.addExecutionTime(System.currentTimeMillis() - startTime);\n                }\n               // processResponse(result, replyTo, replyToHandler);\n                event = (MuleEvent) RequestContext.getEvent();\n                if (result != null && !event.isStopFurtherProcessing())\n                {\n                    descriptor.getOutboundRouter().route(result, event.getSession(), event.isSynchronous());\n                }\n\n                //process repltyTo if there is one\n                if (result != null && replyTo != null)\n                {\n                    String requestor = (String) result.getProperty(MuleProperties.MULE_REPLY_TO_REQUESTOR_PROPERTY);\n\n                    if (replyToHandler != null)\n                    {\n                        if ((requestor != null && !requestor.equals(descriptor.getName())) ||\n                                requestor == null)\n                        {\n                            replyToHandler.processReplyTo(event, result, replyTo);\n                        }\n                    }\n                }\n            } else\n            {\n                UMOMessageDispatcher dispatcher = event.getEndpoint().getConnector().getDispatcher(event.getEndpoint().getEndpointURI().getAddress());\n                dispatcher.dispatch(event);\n            }\n\n            //Finalise the event for this component\n            ((MuleComponent) event.getComponent()).finaliseEvent(event);\n\n            if (stat.isEnabled())\n            {\n                stat.incSentEventASync();\n            }\n        } catch (Exception e)\n        {\n            //Finalise the event for this component\n            ((MuleComponent) event.getComponent()).finaliseEvent(event);\n            event.getSession().setValid(false);\n            if(e instanceof UMOException) {\n                handleException(e);\n            } else {\n                handleException(new MessagingException(new Message(Messages.EVENT_PROCIESSING_FAILED_FOR_X, descriptor.getName()), event.getMessage(), e));\n            }\n        } finally\n        {\n            try\n            {\n                proxyPool.returnObject(this);\n            } catch (Exception e2)\n            {\n                logger.error(\"Failed to return proxy: \" + e2.getMessage(), e2);\n            }\n        }\n    }","id":102633,"modified_method":"public void run()\n    {\n        logger.trace(\"MuleProxy: async onEvent for Mule UMO \" + descriptor.getName());\n\n        try\n        {\n            if (event.getEndpoint().canReceive())\n            {\n                //dispatch the next receiver\n                RequestContext.setEvent(event);\n                Object replyTo = event.getMessage().getReplyTo();\n                ReplyToHandler replyToHandler = null;\n                if(replyTo!=null) {\n                    replyToHandler = ((AbstractConnector) event.getEndpoint().getConnector()).getReplyToHandler();\n                }\n                InterceptorsInvoker invoker = new InterceptorsInvoker(interceptorList, descriptor, event.getMessage());\n\n                //do stats\n                long startTime = 0;\n                if (stat.isEnabled())\n                {\n                    startTime = System.currentTimeMillis();\n                }\n\n                UMOMessage result = invoker.execute();\n                if (stat.isEnabled())\n                {\n                    stat.addExecutionTime(System.currentTimeMillis() - startTime);\n                }\n               // processResponse(result, replyTo, replyToHandler);\n                event = (MuleEvent) RequestContext.getEvent();\n                if (result != null && !event.isStopFurtherProcessing())\n                {\n                    descriptor.getOutboundRouter().route(result, event.getSession(), event.isSynchronous());\n                }\n\n                //process repltyTo if there is one\n                if (result != null && replyToHandler != null)\n                {\n                    String requestor = (String) result.getProperty(MuleProperties.MULE_REPLY_TO_REQUESTOR_PROPERTY);\n                    if ((requestor != null && !requestor.equals(descriptor.getName())) ||\n                            requestor == null)\n                    {\n                        replyToHandler.processReplyTo(event, result, replyTo);\n                    }\n                }\n            } else\n            {\n                UMOMessageDispatcher dispatcher = event.getEndpoint().getConnector().getDispatcher(event.getEndpoint().getEndpointURI().getAddress());\n                dispatcher.dispatch(event);\n            }\n\n            //Finalise the event for this component\n            ((MuleComponent) event.getComponent()).finaliseEvent(event);\n\n            if (stat.isEnabled())\n            {\n                stat.incSentEventASync();\n            }\n        } catch (Exception e)\n        {\n            //Finalise the event for this component\n            ((MuleComponent) event.getComponent()).finaliseEvent(event);\n            event.getSession().setValid(false);\n            if(e instanceof UMOException) {\n                handleException(e);\n            } else {\n                handleException(new MessagingException(new Message(Messages.EVENT_PROCIESSING_FAILED_FOR_X, descriptor.getName()), event.getMessage(), e));\n            }\n        } finally\n        {\n            try\n            {\n                proxyPool.returnObject(this);\n            } catch (Exception e2)\n            {\n                logger.error(\"Failed to return proxy: \" + e2.getMessage(), e2);\n            }\n        }\n    }","commit_id":"9aa541dfe95fc23927e15b7cadd1a3d2f168e8b9","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n   * The utility function used to implement getFiles.\n   * It follows the same algorithm as {@link #getAlluxioURIs}.\n   *\n   * @param inputPath the input file path (could contain wildcards)\n   * @param parent the directory in which we are searching matched files\n   * @return a list of files that matches the input path in the parent directory\n   */\n  private static List<File> getFiles(String inputPath, String parent) {\n    List<File> res = new LinkedList<>();\n    File pFile = new File(parent);\n    if (!pFile.exists() || !pFile.isDirectory()) {\n      return res;\n    }\n    if (pFile.isDirectory() && pFile.canRead()) {\n      for (File file : pFile.listFiles()) {\n        if (match(file.getPath(), inputPath)) { // if it matches\n          res.add(file);\n        } else {\n          if (file.isDirectory()) { // if it is a folder, we do it recursively\n            AlluxioURI dirURI = new AlluxioURI(file.getPath());\n            String prefix = new AlluxioURI(inputPath).getLeadingPath(dirURI.getDepth());\n            if (prefix != null && match(dirURI, new AlluxioURI(prefix))) {\n              res.addAll(getFiles(inputPath, dirURI.getPath()));\n            }\n          }\n        }\n      }\n    }\n    return res;\n  }","id":102634,"modified_method":"/**\n   * The utility function used to implement getFiles.\n   * It follows the same algorithm as {@link #getAlluxioURIs}.\n   *\n   * @param inputPath the input file path (could contain wildcards)\n   * @param parent the directory in which we are searching matched files\n   * @return a list of files that matches the input path in the parent directory\n   */\n  private static List<File> getFiles(String inputPath, String parent) {\n    List<File> res = new LinkedList<>();\n    File pFile = new File(parent);\n    if (!pFile.exists() || !pFile.isDirectory()) {\n      return res;\n    }\n    if (pFile.isDirectory() && pFile.canRead()) {\n      File[] fileList = pFile.listFiles();\n      if (fileList == null) {\n        return res;\n      }\n      for (File file : fileList) {\n        if (match(file.getPath(), inputPath)) { // if it matches\n          res.add(file);\n        } else {\n          if (file.isDirectory()) { // if it is a folder, we do it recursively\n            AlluxioURI dirURI = new AlluxioURI(file.getPath());\n            String prefix = new AlluxioURI(inputPath).getLeadingPath(dirURI.getDepth());\n            if (prefix != null && match(dirURI, new AlluxioURI(prefix))) {\n              res.addAll(getFiles(inputPath, dirURI.getPath()));\n            }\n          }\n        }\n      }\n    }\n    return res;\n  }","commit_id":"0eac22b070254a6aeb33ef5113f192e919c72a7c","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n     * Scan the given directory for content changes.\n     *\n     * @param directory the directory to scan\n     * @param builder the builder to use to add deployment actions as new content is found\n     * @param foundDeployed place to store marker files found in the directory; key is the name\n     *           of the deployment, value is the marker file\n     * @param newlyAdded place to store names of newly added content\n     *\n     * @return the builder the current builder following any changes\n     */\n    private DeploymentPlanBuilder scanDirectory(File directory, DeploymentPlanBuilder builder, Map<String, File> foundDeployed, Set<String> newlyAdded) {\n\n        //TODO externalize config of filter?\n        for (File child : directory.listFiles(filter)) {\n\n            String fileName = child.getName();\n\n            if (fileName.endsWith(DEPLOYED)) {\n                String origName = fileName.substring(0, fileName.length() - DEPLOYED.length());\n                foundDeployed.put(origName, child);\n            }\n            else if (child.isDirectory()) {\n                int idx = fileName.lastIndexOf('.');\n                if (idx > -1 && ARCHIVES.contains(fileName.substring(idx))) {\n                    // FIXME handle exploded deployments\n                    log.warnf(\"%s is an exploded deployment and exploded deployments are not currently handled by %s\", child.getName(), getClass().getSimpleName());\n                }\n                else {\n                    // It's just a dir for organizing content. Recurse\n                    builder = scanDirectory(child, builder, foundDeployed, newlyAdded);\n                }\n            }\n            else {\n                // Found a single non-marker file\n\n                DeploymentPlanBuilder currentBuilder = builder;\n\n                boolean uploaded = false;\n                boolean replace = false;\n                ServerGroupDeploymentElement deployment = injectedServerModel.getValue().getDeployment(fileName);\n                if (deployment != null) {\n                    if (deployment.isStart()) {\n                        replace = true;\n                    }\n                    else {\n                        // A replace(child) will not result in deploying the new\n                        // content, which is not the semantic we want with\n                        // filesystem hot deployment. So clean out the\n                        // existing deployment from the config and do a new\n                        // add+deploy below\n                        builder = builder.remove(fileName);\n                    }\n                }\n\n                try {\n                    if (replace) {\n                        builder = builder.replace(child);\n                    }\n                    else {\n                        builder = builder.add(child).andDeploy();\n                    }\n                    uploaded = true;\n                } catch (IOException e) {\n                    log.errorf(e, \"Failed adding deployment content at %s\", child.getAbsolutePath());\n                } catch (DuplicateDeploymentNameException e) {\n                    // Content with same name must have been added via some\n                    // other means. Warn and replace\n                    log.warnf(\"Deployment content with name %s is already installed \" +\n                            \"but was unknown to this filesystem deployment scanner. \" +\n                            \"Replacing the existing content with new content %s.\", fileName, child.getAbsolutePath());\n                    try {\n                        builder = builder.replace(child);\n                        uploaded = true;\n                    } catch (IOException e1) {\n                        log.errorf(e1, \"Failed replacing %s with content at %s\", fileName, child.getAbsolutePath());\n                    }\n                }\n\n                if (uploaded) {\n                    if (replaceWithDeployedMarker(child)) {\n                        newlyAdded.add(fileName);\n                    }\n                    else {\n                        // Discard the deployment plan work done in this step\n                        builder = currentBuilder;\n                    }\n                }\n            }\n        }\n        return builder;\n    }","id":102635,"modified_method":"/**\n     * Scan the given directory for content changes.\n     *\n     * @param directory the directory to scan\n     * @param builder the builder to use to add deployment actions as new content is found\n     * @param foundDeployed place to store marker files found in the directory; key is the name\n     *           of the deployment, value is the marker file\n     * @param newlyAdded place to store names of newly added content\n     *\n     * @return the builder the current builder following any changes\n     */\n    private DeploymentPlanBuilder scanDirectory(File directory, DeploymentPlanBuilder builder, Map<String, File> foundDeployed, Set<String> newlyAdded) {\n\n        //TODO externalize config of filter?\n        File[] children = directory.listFiles(filter);\n        if (children == null) {\n            return builder;\n        }\n\n        for (File child : children) {\n\n            String fileName = child.getName();\n\n            if (fileName.endsWith(DEPLOYED)) {\n                String origName = fileName.substring(0, fileName.length() - DEPLOYED.length());\n                foundDeployed.put(origName, child);\n            }\n            else if (child.isDirectory()) {\n                int idx = fileName.lastIndexOf('.');\n                if (idx > -1 && ARCHIVES.contains(fileName.substring(idx))) {\n                    // FIXME handle exploded deployments\n                    log.warnf(\"%s is an exploded deployment and exploded deployments are not currently handled by %s\", child.getName(), getClass().getSimpleName());\n                }\n                else {\n                    // It's just a dir for organizing content. Recurse\n                    builder = scanDirectory(child, builder, foundDeployed, newlyAdded);\n                }\n            }\n            else {\n                // Found a single non-marker file\n\n                DeploymentPlanBuilder currentBuilder = builder;\n\n                boolean uploaded = false;\n                boolean replace = false;\n                ServerGroupDeploymentElement deployment = injectedServerModel.getValue().getDeployment(fileName);\n                if (deployment != null) {\n                    if (deployment.isStart()) {\n                        replace = true;\n                    }\n                    else {\n                        // A replace(child) will not result in deploying the new\n                        // content, which is not the semantic we want with\n                        // filesystem hot deployment. So clean out the\n                        // existing deployment from the config and do a new\n                        // add+deploy below\n                        builder = builder.remove(fileName);\n                    }\n                }\n\n                try {\n                    if (replace) {\n                        builder = builder.replace(child);\n                    }\n                    else {\n                        builder = builder.add(child).andDeploy();\n                    }\n                    uploaded = true;\n                } catch (IOException e) {\n                    log.errorf(e, \"Failed adding deployment content at %s\", child.getAbsolutePath());\n                } catch (DuplicateDeploymentNameException e) {\n                    // Content with same name must have been added via some\n                    // other means. Warn and replace\n                    log.warnf(\"Deployment content with name %s is already installed \" +\n                            \"but was unknown to this filesystem deployment scanner. \" +\n                            \"Replacing the existing content with new content %s.\", fileName, child.getAbsolutePath());\n                    try {\n                        builder = builder.replace(child);\n                        uploaded = true;\n                    } catch (IOException e1) {\n                        log.errorf(e1, \"Failed replacing %s with content at %s\", fileName, child.getAbsolutePath());\n                    }\n                }\n\n                if (uploaded) {\n                    if (replaceWithDeployedMarker(child)) {\n                        newlyAdded.add(fileName);\n                    }\n                    else {\n                        // Discard the deployment plan work done in this step\n                        builder = currentBuilder;\n                    }\n                }\n            }\n        }\n        return builder;\n    }","commit_id":"982eb0f6ac8dae5ac8449a7721e4b17afb077860","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n  protected JsonArray serve(String filter, int limit) {\n    File base = null;\n    String filterPrefix = \"\";\n    if( !filter.isEmpty() ) {\n      File file = new File(filter);\n      if( file.isDirectory() ) {\n        base = file;\n      } else {\n        base = file.getParentFile();\n        filterPrefix = file.getName().toLowerCase();\n      }\n    }\n    if( base == null ) base = new File(\".\");\n\n    JsonArray array = new JsonArray();\n    for( File file : base.listFiles() ) {\n      if( file.isHidden() ) continue;\n      if( file.getName().toLowerCase().startsWith(filterPrefix) ) {\n        String s = file.getPath();\n        array.add(new JsonPrimitive(s));\n      }\n      if( array.size() == limit) break;\n    }\n    return array;\n  }","id":102636,"modified_method":"@Override\n  protected JsonArray serve(String filter, int limit) {\n    File base = null;\n    String filterPrefix = \"\";\n    if( !filter.isEmpty() ) {\n      File file = new File(filter);\n      if( file.isDirectory() ) {\n        base = file;\n      } else {\n        base = file.getParentFile();\n        filterPrefix = file.getName().toLowerCase();\n      }\n    }\n    if( base == null ) base = new File(\".\");\n\n    JsonArray array = new JsonArray();\n    File[] files = base.listFiles();\n    if( files == null ) return array;\n    for( File file : files ) {\n      if( file.isHidden() ) continue;\n      if( file.getName().toLowerCase().startsWith(filterPrefix) )\n        array.add(new JsonPrimitive(file.getPath()));\n      if( array.size() == limit) break;\n    }\n    return array;\n  }","commit_id":"cbde377559c912cf28458234e0bcbd3b7b0bc7c4","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n    public void doWith(ProfileRegistry profileRegistry, DataStore dataStore) {\n        String version = options.getVersion();\n        int minimumPort = options.getMinimumPort();\n        int maximumPort = options.getMaximumPort();\n        String zooKeeperServerHost = options.getBindAddress();\n        int zooKeeperServerPort = options.getZooKeeperServerPort();\n        int zooKeeperServerConnectionPort = options.getZooKeeperServerConnectionPort();\n        int mappedPort = mapPortToRange(zooKeeperServerPort, minimumPort, maximumPort);\n        CuratorFramework curator = null;\n\n        try {\n            curator = createCuratorFramework(connectionUrl, options);\n            curator.start();\n            curator.getZookeeperClient().blockUntilConnectedOrTimedOut();\n\n            // Make the import path absolute\n            File importPath = new File(options.getImportPath());\n            if (!importPath.isAbsolute()) {\n                importPath = new File(homeDir, options.getImportPath());\n            }\n\n            // Import data into the DataStore\n            if (options.isAutoImportEnabled()) {\n                profileRegistry.importFromFileSystem(importPath.getAbsolutePath());\n            }\n\n            // set the fabric configuration\n            setData(curator, ZkPath.CONFIG_DEFAULT_VERSION.getPath(), version);\n\n            // configure default profile\n            String defaultProfile = profileRegistry.getProfile(version, \"default\", true);\n\n            setData(curator, ZkPath.CONFIG_ENSEMBLE_URL.getPath(), \"${zk:\" + name + \"/ip}:\" + zooKeeperServerConnectionPort);\n            setData(curator, ZkPath.CONFIG_ENSEMBLE_PASSWORD.getPath(), PasswordEncoder.encode(options.getZookeeperPassword()));\n\n            Properties zkProps = new Properties();\n            zkProps.setProperty(\"zookeeper.url\", \"${zk:\" + ZkPath.CONFIG_ENSEMBLE_URL.getPath() + \"}\");\n            zkProps.setProperty(\"zookeeper.password\", \"${zk:\" + ZkPath.CONFIG_ENSEMBLE_PASSWORD.getPath() + \"}\");\n            profileRegistry.setFileConfiguration(version, defaultProfile, \"io.fabric8.zookeeper.properties\", DataStoreUtils.toBytes(zkProps));\n\n            // configure the ensemble\n            String ensembleProfile = profileRegistry.getProfile(version, \"fabric-ensemble-0000\", true);\n            profileRegistry.setProfileAttribute(version, ensembleProfile, \"abstract\", \"true\");\n            profileRegistry.setProfileAttribute(version, ensembleProfile, \"hidden\", \"true\");\n\n            Properties ensembleProps = new Properties();\n            ensembleProps.put(\"tickTime\", String.valueOf(options.getZooKeeperServerTickTime()));\n            ensembleProps.put(\"initLimit\", String.valueOf(options.getZooKeeperServerInitLimit()));\n            ensembleProps.put(\"syncLimit\", String.valueOf(options.getZooKeeperServerSyncLimit()));\n            ensembleProps.put(\"dataDir\", options.getZooKeeperServerDataDir() + File.separator + \"0000\");\n\n            loadPropertiesFrom(ensembleProps, importPath + \"/fabric/profiles/default.profile/io.fabric8.zookeeper.server.properties\");\n            profileRegistry.setFileConfiguration(version, ensembleProfile, \"io.fabric8.zookeeper.server-0000.properties\", DataStoreUtils.toBytes(ensembleProps));\n\n            // configure this server in the ensemble\n            String ensembleServerProfile = profileRegistry.getProfile(version, \"fabric-ensemble-0000-1\", true);\n            profileRegistry.setProfileAttribute(version, ensembleServerProfile, \"hidden\", \"true\");\n            profileRegistry.setProfileAttribute(version, ensembleServerProfile, \"parents\", ensembleProfile);\n            Properties serverProps = new Properties();\n            serverProps.put(\"clientPort\", String.valueOf(mappedPort));\n            serverProps.put(\"clientPortAddress\", zooKeeperServerHost);\n            profileRegistry.setFileConfiguration(version, ensembleServerProfile, \"io.fabric8.zookeeper.server-0000.properties\",\n                    DataStoreUtils.toBytes(serverProps));\n\n            setData(curator, ZkPath.CONFIG_ENSEMBLES.getPath(), \"0000\");\n            setData(curator, ZkPath.CONFIG_ENSEMBLE.getPath(\"0000\"), name);\n\n            // configure fabric profile\n            String fabricProfile = profileRegistry.getProfile(version, \"fabric\", true);\n            Properties agentProps = DataStoreUtils.toProperties(profileRegistry.getFileConfiguration(version, fabricProfile, \"io.fabric8.agent.properties\"));\n            agentProps.put(\"feature.fabric-commands\", \"fabric-commands\");\n            profileRegistry.setFileConfiguration(version, \"fabric\", \"io.fabric8.agent.properties\", DataStoreUtils.toBytes(agentProps));\n\n            createDefault(curator, ZkPath.CONFIG_CONTAINER.getPath(name), version);\n\n            StringBuilder profilesBuilder = new StringBuilder();\n            Set<String> profiles = options.getProfiles();\n            profilesBuilder.append(\"fabric\").append(\" \").append(\"fabric-ensemble-0000-1\");\n            for (String p : profiles) {\n                profilesBuilder.append(\" \").append(p);\n            }\n            if (!options.isAgentEnabled()) {\n                profilesBuilder.append(\" \").append(\"unmanaged\");\n            }\n\n            createDefault(curator, ZkPath.CONFIG_VERSIONS_CONTAINER.getPath(version, name), profilesBuilder.toString());\n\n            // add auth\n            Map<String, String> configs = new HashMap<String, String>();\n            configs.put(\"encryption.enabled\", \"${zk:/fabric/authentication/encryption.enabled}\");\n            profileRegistry.setConfiguration(version, defaultProfile, \"io.fabric8.jaas\", configs);\n\n            // outside of the profile storage area, so we'll keep these in zk\n            EncryptionSupport encryption = addUsersToZookeeper(curator, options.getUsers());\n            createDefault(curator, \"/fabric/authentication/encryption.enabled\", Boolean.valueOf(encryption != null).toString());\n            createDefault(curator, \"/fabric/authentication/domain\", \"karaf\");\n\n            createDefault(curator, ZkPath.AUTHENTICATION_CRYPT_ALGORITHM.getPath(), \"PBEWithMD5AndDES\");\n            createDefault(curator, ZkPath.AUTHENTICATION_CRYPT_PASSWORD.getPath(), PasswordEncoder.encode(options.getZookeeperPassword()));\n\n            //Ensure ACLs are from the beggining of the fabric tree.\n            aclManager.fixAcl(curator, \"/fabric\", true);\n        } catch (Exception ex) {\n            throw new FabricException(\"Unable to create bootstrap configuration\", ex);\n        } finally {\n            curator.close();\n        }\n    }","id":102637,"modified_method":"@Override\n    public void doWith(ProfileRegistry profileRegistry, DataStore dataStore) {\n        String versionId = options.getVersion();\n        int minimumPort = options.getMinimumPort();\n        int maximumPort = options.getMaximumPort();\n        String zooKeeperServerHost = options.getBindAddress();\n        int zooKeeperServerPort = options.getZooKeeperServerPort();\n        int zooKeeperServerConnectionPort = options.getZooKeeperServerConnectionPort();\n        int mappedPort = mapPortToRange(zooKeeperServerPort, minimumPort, maximumPort);\n        CuratorFramework curator = null;\n\n        try {\n            curator = createCuratorFramework(connectionUrl, options);\n            curator.start();\n            curator.getZookeeperClient().blockUntilConnectedOrTimedOut();\n\n            // Make the import path absolute\n            File importPath = new File(options.getImportPath());\n            if (!importPath.isAbsolute()) {\n                importPath = new File(homeDir, options.getImportPath());\n            }\n\n            // Import data into the DataStore\n            if (options.isAutoImportEnabled()) {\n                profileRegistry.importFromFileSystem(importPath.getAbsolutePath());\n            }\n\n            // set the fabric configuration\n            setData(curator, ZkPath.CONFIG_DEFAULT_VERSION.getPath(), versionId);\n\n            // configure default profile\n            String defaultProfileId = profileRegistry.getProfile(versionId, \"default\", true);\n\n            setData(curator, ZkPath.CONFIG_ENSEMBLE_URL.getPath(), \"${zk:\" + name + \"/ip}:\" + zooKeeperServerConnectionPort);\n            setData(curator, ZkPath.CONFIG_ENSEMBLE_PASSWORD.getPath(), PasswordEncoder.encode(options.getZookeeperPassword()));\n\n            Properties zkProps = new Properties();\n            zkProps.setProperty(\"zookeeper.url\", \"${zk:\" + ZkPath.CONFIG_ENSEMBLE_URL.getPath() + \"}\");\n            zkProps.setProperty(\"zookeeper.password\", \"${zk:\" + ZkPath.CONFIG_ENSEMBLE_PASSWORD.getPath() + \"}\");\n            profileRegistry.setFileConfiguration(versionId, defaultProfileId, \"io.fabric8.zookeeper.properties\", DataStoreUtils.toBytes(zkProps));\n\n            // configure the ensemble\n            String profileId = \"fabric-ensemble-0000\";\n            IllegalStateAssertion.assertFalse(profileRegistry.hasProfile(versionId, profileId), \"Profile already exists: \" + versionId + \"/\" + profileId);\n            String ensembleProfileId = profileRegistry.getProfile(versionId, profileId, true);\n            profileRegistry.setProfileAttribute(versionId, ensembleProfileId, \"abstract\", \"true\");\n            profileRegistry.setProfileAttribute(versionId, ensembleProfileId, \"hidden\", \"true\");\n\n            Properties ensembleProps = new Properties();\n            ensembleProps.put(\"tickTime\", String.valueOf(options.getZooKeeperServerTickTime()));\n            ensembleProps.put(\"initLimit\", String.valueOf(options.getZooKeeperServerInitLimit()));\n            ensembleProps.put(\"syncLimit\", String.valueOf(options.getZooKeeperServerSyncLimit()));\n            ensembleProps.put(\"dataDir\", options.getZooKeeperServerDataDir() + File.separator + \"0000\");\n\n            loadPropertiesFrom(ensembleProps, importPath + \"/fabric/profiles/default.profile/io.fabric8.zookeeper.server.properties\");\n            profileRegistry.setFileConfiguration(versionId, ensembleProfileId, \"io.fabric8.zookeeper.server-0000.properties\", DataStoreUtils.toBytes(ensembleProps));\n\n            // configure this server in the ensemble\n            profileId = \"fabric-ensemble-0000-1\";\n            IllegalStateAssertion.assertFalse(profileRegistry.hasProfile(versionId, profileId), \"Profile already exists: \" + versionId + \"/\" + profileId);\n            String ensembleServerProfileId = profileRegistry.getProfile(versionId, profileId, true);\n            profileRegistry.setProfileAttribute(versionId, ensembleServerProfileId, \"hidden\", \"true\");\n            profileRegistry.setProfileAttribute(versionId, ensembleServerProfileId, \"parents\", ensembleProfileId);\n            Properties serverProps = new Properties();\n            serverProps.put(\"clientPort\", String.valueOf(mappedPort));\n            serverProps.put(\"clientPortAddress\", zooKeeperServerHost);\n            profileRegistry.setFileConfiguration(versionId, ensembleServerProfileId, \"io.fabric8.zookeeper.server-0000.properties\",\n                    DataStoreUtils.toBytes(serverProps));\n\n            setData(curator, ZkPath.CONFIG_ENSEMBLES.getPath(), \"0000\");\n            setData(curator, ZkPath.CONFIG_ENSEMBLE.getPath(\"0000\"), name);\n\n            // configure fabric profile\n            String fabricProfile = profileRegistry.getProfile(versionId, \"fabric\", true);\n            Properties agentProps = DataStoreUtils.toProperties(profileRegistry.getFileConfiguration(versionId, fabricProfile, \"io.fabric8.agent.properties\"));\n            agentProps.put(\"feature.fabric-commands\", \"fabric-commands\");\n            profileRegistry.setFileConfiguration(versionId, \"fabric\", \"io.fabric8.agent.properties\", DataStoreUtils.toBytes(agentProps));\n\n            createDefault(curator, ZkPath.CONFIG_CONTAINER.getPath(name), versionId);\n\n            StringBuilder profilesBuilder = new StringBuilder();\n            Set<String> profiles = options.getProfiles();\n            profilesBuilder.append(\"fabric\").append(\" \").append(\"fabric-ensemble-0000-1\");\n            for (String p : profiles) {\n                profilesBuilder.append(\" \").append(p);\n            }\n            if (!options.isAgentEnabled()) {\n                profilesBuilder.append(\" \").append(\"unmanaged\");\n            }\n\n            createDefault(curator, ZkPath.CONFIG_VERSIONS_CONTAINER.getPath(versionId, name), profilesBuilder.toString());\n\n            // add auth\n            Map<String, String> configs = new HashMap<String, String>();\n            configs.put(\"encryption.enabled\", \"${zk:/fabric/authentication/encryption.enabled}\");\n            profileRegistry.setConfiguration(versionId, defaultProfileId, \"io.fabric8.jaas\", configs);\n\n            // outside of the profile storage area, so we'll keep these in zk\n            EncryptionSupport encryption = addUsersToZookeeper(curator, options.getUsers());\n            createDefault(curator, \"/fabric/authentication/encryption.enabled\", Boolean.valueOf(encryption != null).toString());\n            createDefault(curator, \"/fabric/authentication/domain\", \"karaf\");\n\n            createDefault(curator, ZkPath.AUTHENTICATION_CRYPT_ALGORITHM.getPath(), \"PBEWithMD5AndDES\");\n            createDefault(curator, ZkPath.AUTHENTICATION_CRYPT_PASSWORD.getPath(), PasswordEncoder.encode(options.getZookeeperPassword()));\n\n            //Ensure ACLs are from the beggining of the fabric tree.\n            aclManager.fixAcl(curator, \"/fabric\", true);\n        } catch (Exception ex) {\n            throw new FabricException(\"Unable to create bootstrap configuration\", ex);\n        } finally {\n            curator.close();\n        }\n    }","commit_id":"e904c3fb44db4bee942c4290e76ad4745fd172de","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void createCluster(final List<String> containers, CreateEnsembleOptions options) {\n        assertValid();\n        final List<String> oldContainers = getEnsembleContainers();\n        try {\n            if (containers == null || containers.size() == 2) {\n                throw new EnsembleModificationFailed(\"One or at least 3 containers must be used to create a zookeeper ensemble\", EnsembleModificationFailed.Reason.INVALID_ARGUMENTS);\n            }\n            Configuration config = configAdmin.get().getConfiguration(Constants.ZOOKEEPER_CLIENT_PID, null);\n            String zooKeeperUrl = config != null && config.getProperties() != null ? (String) config.getProperties().get(\"zookeeper.url\") : null;\n            String karafName = runtimeProperties.get().getRuntimeIdentity();\n            if (zooKeeperUrl == null) {\n                if (containers.size() != 1 || !containers.get(0).equals(karafName)) {\n                    throw new EnsembleModificationFailed(\"The first zookeeper cluster must be configured on this container only.\", EnsembleModificationFailed.Reason.INVALID_ARGUMENTS);\n                }\n                bootstrap.get().create(options);\n                return;\n            }\n\n            Container[] allContainers = fabricService.get().getContainers();\n            Set<Container> notAliveOrOk = new HashSet<Container>();\n            for (Container container : allContainers) {\n                if (!container.isAliveAndOK()) {\n                    notAliveOrOk.add(container);\n                }\n            }\n\n            if (!notAliveOrOk.isEmpty()) {\n                throw new EnsembleModificationFailed(\"Can not modify the zookeeper ensemble if all containers are not running. Containers not ready:\" + notAliveOrOk, EnsembleModificationFailed.Reason.CONTAINERS_NOT_ALIVE);\n            }\n\n            String version = dataStore.get().getDefaultVersion();\n\n            for (String container : containers) {\n                Container c = fabricService.get().getContainer(container);\n                if (exists(curator.get(), ZkPath.CONTAINER_ALIVE.getPath(container)) == null) {\n                    throw new EnsembleModificationFailed(\"The container \" + container + \" is not alive\", EnsembleModificationFailed.Reason.CONTAINERS_NOT_ALIVE);\n                }\n            }\n\n            // Find used zookeeper ports\n            Map<String, List<Integer>> usedPorts = new HashMap<String, List<Integer>>();\n            final String oldClusterId = getStringData(curator.get(), ZkPath.CONFIG_ENSEMBLES.getPath());\n            if (oldClusterId != null) {\n                String profile = \"fabric-ensemble-\" + oldClusterId;\n                String pid = \"io.fabric8.zookeeper.server-\" + oldClusterId;\n\n                Map<String, String> p = profileRegistry.get().getConfiguration(version, profile, pid);\n\n                if (p == null) {\n                    throw new EnsembleModificationFailed(\"Failed to find old cluster configuration for ID \" + oldClusterId, EnsembleModificationFailed.Reason.ILLEGAL_STATE);\n                }\n\n                for (Object n : p.keySet()) {\n                    String node = (String) n;\n                    if (node.startsWith(\"server.\")) {\n                        String data = getSubstitutedData(\n                                curator.get(),\n                                profileRegistry.get().getConfigurations(version, \"fabric-ensemble-\" + oldClusterId)\n                                        .get(\"io.fabric8.zookeeper.server-\" + oldClusterId).get(node));\n                        addUsedPorts(usedPorts, data);\n                    }\n                }\n\n                Map<String, String> zkConfig = profileRegistry.get().getConfiguration(version, \"default\", Constants.ZOOKEEPER_CLIENT_PID);\n                if (zkConfig == null) {\n                    throw new FabricException(\"Failed to find old zookeeper configuration in default profile\");\n                }\n                String zkUrl = getSubstitutedData(curator.get(), zkConfig.get(\"zookeeper.url\"));\n                for (String data : zkUrl.split(\",\")) {\n                    addUsedPorts(usedPorts, data);\n                }\n            }\n\n            String newClusterId;\n            if (oldClusterId == null) {\n                newClusterId = \"0000\";\n            } else {\n                newClusterId = new DecimalFormat(\"0000\").format(Integer.parseInt(oldClusterId) + 1);\n            }\n\n            // create new ensemble\n            String ensembleProfile = profileRegistry.get().getProfile(version, \"fabric-ensemble-\" + newClusterId, true);\n            profileRegistry.get().setProfileAttribute(version, ensembleProfile, \"abstract\", \"true\");\n            profileRegistry.get().setProfileAttribute(version, ensembleProfile, \"hidden\", \"true\");\n\n            Properties ensembleProperties = new Properties();\n            ensembleProperties.put(\"tickTime\", String.valueOf(options.getZooKeeperServerTickTime()));\n            ensembleProperties.put(\"initLimit\", String.valueOf(options.getZooKeeperServerInitLimit()));\n            ensembleProperties.put(\"syncLimit\", String.valueOf(options.getZooKeeperServerSyncLimit()));\n            ensembleProperties.put(\"dataDir\", options.getZooKeeperServerDataDir() + File.separator + newClusterId);\n\n            int index = 1;\n            String connectionUrl = \"\";\n            String realConnectionUrl = \"\";\n            String containerList = \"\";\n            for (String container : containers) {\n                String ip = getSubstitutedPath(curator.get(), ZkPath.CONTAINER_IP.getPath(container));\n\n                String minimumPort = String.valueOf(Ports.MIN_PORT_NUMBER);\n                String maximumPort = String.valueOf(Ports.MAX_PORT_NUMBER);\n                String bindAddress = \"0.0.0.0\";\n\n                if (exists(curator.get(), ZkPath.CONTAINER_PORT_MIN.getPath(container)) != null) {\n                    minimumPort = getSubstitutedPath(curator.get(), ZkPath.CONTAINER_PORT_MIN.getPath(container));\n                }\n\n                if (exists(curator.get(), ZkPath.CONTAINER_PORT_MAX.getPath(container)) != null) {\n                    maximumPort = getSubstitutedPath(curator.get(), ZkPath.CONTAINER_PORT_MAX.getPath(container));\n                }\n\n                if (exists(curator.get(), ZkPath.CONTAINER_BINDADDRESS.getPath(container)) != null) {\n                    bindAddress = getSubstitutedPath(curator.get(), ZkPath.CONTAINER_BINDADDRESS.getPath(container));\n                }\n\n                String ensembleMemberConfigName = \"io.fabric8.zookeeper.server-\" + newClusterId + \".properties\";\n                Properties ensembleMemberProperties = new Properties();\n\n                // configure this server in the ensemble\n                String ensembleMemberProfile = profileRegistry.get().getProfile(version, \"fabric-ensemble-\" + newClusterId + \"-\" + Integer.toString(index), true);\n                profileRegistry.get().setProfileAttribute(version, ensembleMemberProfile, \"hidden\", \"true\");\n                profileRegistry.get().setProfileAttribute(version, ensembleMemberProfile, \"parents\", ensembleProfile);\n\n                String port1 = Integer.toString(findPort(usedPorts, ip, mapPortToRange(Ports.DEFAULT_ZOOKEEPER_SERVER_PORT, minimumPort, maximumPort)));\n                if (containers.size() > 1) {\n                    String port2 = Integer.toString(findPort(usedPorts, ip, mapPortToRange(Ports.DEFAULT_ZOOKEEPER_PEER_PORT, minimumPort, maximumPort)));\n                    String port3 = Integer.toString(findPort(usedPorts, ip, mapPortToRange(Ports.DEFAULT_ZOOKEEPER_ELECTION_PORT, minimumPort, maximumPort)));\n                    ensembleProperties.put(\"server.\" + Integer.toString(index), \"${zk:\" + container + \"/ip}:\" + port2 + \":\" + port3);\n                    ensembleMemberProperties.put(\"server.id\", Integer.toString(index));\n                }\n                ensembleMemberProperties.put(\"clientPort\", port1);\n                ensembleMemberProperties.put(\"clientPortAddress\", bindAddress);\n\n                profileRegistry.get().setFileConfiguration(version, ensembleMemberProfile, ensembleMemberConfigName, DataStoreUtils.toBytes(ensembleMemberProperties));\n\n                if (connectionUrl.length() > 0) {\n                    connectionUrl += \",\";\n                    realConnectionUrl += \",\";\n                }\n                connectionUrl += \"${zk:\" + container + \"/ip}:\" + port1;\n                realConnectionUrl += ip + \":\" + port1;\n                if (containerList.length() > 0) {\n                    containerList += \",\";\n                }\n                containerList += container;\n                index++;\n            }\n\n            String ensembleConfigName = \"io.fabric8.zookeeper.server-\" + newClusterId + \".properties\";\n            profileRegistry.get().setFileConfiguration(version, ensembleProfile, ensembleConfigName, DataStoreUtils.toBytes(ensembleProperties));\n\n            index = 1;\n            for (String container : containers) {\n                // add this container to the ensemble\n                List<String> profiles = new LinkedList<String>(dataStore.get().getContainerProfiles(container));\n                profiles.add(\"fabric-ensemble-\" + newClusterId + \"-\" + Integer.toString(index));\n                dataStore.get().setContainerProfiles(container, profiles);\n                index++;\n            }\n\n            if (oldClusterId != null) {\n                Properties properties = DataStoreUtils.toProperties(profileRegistry.get().getConfiguration(version, \"default\", Constants.ZOOKEEPER_CLIENT_PID));\n                properties.put(\"zookeeper.url\", getSubstitutedData(curator.get(), realConnectionUrl));\n                properties.put(\"zookeeper.password\", options.getZookeeperPassword());\n                CuratorFramework dst = CuratorFrameworkFactory.builder().connectString(realConnectionUrl).retryPolicy(new RetryOneTime(500))\n                        .aclProvider(aclProvider.get()).authorization(\"digest\", (\"fabric:\" + options.getZookeeperPassword()).getBytes()).sessionTimeoutMs(30000)\n                        .connectionTimeoutMs((int) options.getMigrationTimeout()).build();\n                dst.start();\n                try {\n                    long t0 = System.currentTimeMillis();\n                    if (!dst.getZookeeperClient().blockUntilConnectedOrTimedOut()) {\n                        throw new EnsembleModificationFailed(\"Timed out connecting to new ensemble.\", EnsembleModificationFailed.Reason.TIMEOUT);\n                    }\n                    copy(curator.get(), dst, \"/fabric\");\n                    setData(dst, ZkPath.CONFIG_ENSEMBLES.getPath(), newClusterId);\n                    setData(dst, ZkPath.CONFIG_ENSEMBLE.getPath(newClusterId), containerList);\n\n                    // Perform cleanup when the new datastore has been registered.\n                    final AtomicReference<DataStore> result = new AtomicReference<DataStore>();\n                    runtimeProperties.get().putRuntimeAttribute(DataStoreTemplate.class, new DataStoreTemplate() {\n                        @Override\n                        public void doWith(ProfileRegistry profileRegistry, DataStore dataStore) {\n                            synchronized (result) {\n                                result.set(dataStore);\n                                result.notifyAll();\n                            }\n                        }\n                    });\n\n                    setData(dst, ZkPath.CONFIG_ENSEMBLE_PASSWORD.getPath(), PasswordEncoder.encode(options.getZookeeperPassword()));\n                    setData(dst, ZkPath.CONFIG_ENSEMBLE_URL.getPath(), connectionUrl);                    \n                    setData(curator.get(), ZkPath.CONFIG_ENSEMBLE_PASSWORD.getPath(), PasswordEncoder.encode(options.getZookeeperPassword()));\n                    setData(curator.get(), ZkPath.CONFIG_ENSEMBLE_URL.getPath(), connectionUrl);\n\n                    // Wait until all containers switched\n\n                    boolean allStarted = false;\n                    while (!allStarted && System.currentTimeMillis() - t0 < options.getMigrationTimeout()) {\n                        allStarted = true;\n                        for (Container container : allContainers) {\n                            allStarted &= exists(dst, ZkPath.CONTAINER_ALIVE.getPath(container.getId())) != null;\n                        }\n                        if (!allStarted) {\n                            Thread.sleep(1000);\n                        }\n                    }\n                    if (!allStarted) {\n                        throw new EnsembleModificationFailed(\"Timeout waiting for containers to join the new ensemble\", EnsembleModificationFailed.Reason.TIMEOUT);\n                    }\n\n                    // Wait until the new datastore has been registered\n                    synchronized (result) {\n                        if (result.get() == null) {\n                            result.wait();\n                        }\n                    }\n                    // Remove old profiles\n                    for (String container : oldContainers) {\n                        cleanUpEnsembleProfiles(result.get(), container, oldClusterId);\n                    }\n\n                } finally {\n                    dst.close();\n                }\n            } else {\n                Map<String, String> zkConfig = profileRegistry.get().getConfiguration(version, \"default\", Constants.ZOOKEEPER_CLIENT_PID);\n                zkConfig.put(\"zookeeper.password\", \"${zk:\" + ZkPath.CONFIG_ENSEMBLE_PASSWORD.getPath() + \"}\");\n                zkConfig.put(\"zookeeper.url\", \"${zk:\" + ZkPath.CONFIG_ENSEMBLE_URL.getPath() + \"}\");\n                profileRegistry.get().setConfiguration(version, \"default\", Constants.ZOOKEEPER_CLIENT_PID, zkConfig);\n            }\n        } catch (Exception e) {\n            throw EnsembleModificationFailed.launderThrowable(e);\n        }\n    }","id":102638,"modified_method":"public void createCluster(final List<String> containers, CreateEnsembleOptions options) {\n        assertValid();\n        final List<String> oldContainers = getEnsembleContainers();\n        try {\n            if (containers == null || containers.size() == 2) {\n                throw new EnsembleModificationFailed(\"One or at least 3 containers must be used to create a zookeeper ensemble\", EnsembleModificationFailed.Reason.INVALID_ARGUMENTS);\n            }\n            Configuration config = configAdmin.get().getConfiguration(Constants.ZOOKEEPER_CLIENT_PID, null);\n            String zooKeeperUrl = config != null && config.getProperties() != null ? (String) config.getProperties().get(\"zookeeper.url\") : null;\n            String karafName = runtimeProperties.get().getRuntimeIdentity();\n            if (zooKeeperUrl == null) {\n                if (containers.size() != 1 || !containers.get(0).equals(karafName)) {\n                    throw new EnsembleModificationFailed(\"The first zookeeper cluster must be configured on this container only.\", EnsembleModificationFailed.Reason.INVALID_ARGUMENTS);\n                }\n                bootstrap.get().create(options);\n                return;\n            }\n\n            Container[] allContainers = fabricService.get().getContainers();\n            Set<Container> notAliveOrOk = new HashSet<Container>();\n            for (Container container : allContainers) {\n                if (!container.isAliveAndOK()) {\n                    notAliveOrOk.add(container);\n                }\n            }\n\n            if (!notAliveOrOk.isEmpty()) {\n                throw new EnsembleModificationFailed(\"Can not modify the zookeeper ensemble if all containers are not running. Containers not ready:\" + notAliveOrOk, EnsembleModificationFailed.Reason.CONTAINERS_NOT_ALIVE);\n            }\n\n            String versionId = dataStore.get().getDefaultVersion();\n\n            for (String container : containers) {\n                Container c = fabricService.get().getContainer(container);\n                if (exists(curator.get(), ZkPath.CONTAINER_ALIVE.getPath(container)) == null) {\n                    throw new EnsembleModificationFailed(\"The container \" + container + \" is not alive\", EnsembleModificationFailed.Reason.CONTAINERS_NOT_ALIVE);\n                }\n            }\n\n            // Find used zookeeper ports\n            Map<String, List<Integer>> usedPorts = new HashMap<String, List<Integer>>();\n            final String oldClusterId = getStringData(curator.get(), ZkPath.CONFIG_ENSEMBLES.getPath());\n            if (oldClusterId != null) {\n                String profile = \"fabric-ensemble-\" + oldClusterId;\n                String pid = \"io.fabric8.zookeeper.server-\" + oldClusterId;\n\n                Map<String, String> p = profileRegistry.get().getConfiguration(versionId, profile, pid);\n\n                if (p == null) {\n                    throw new EnsembleModificationFailed(\"Failed to find old cluster configuration for ID \" + oldClusterId, EnsembleModificationFailed.Reason.ILLEGAL_STATE);\n                }\n\n                for (Object n : p.keySet()) {\n                    String node = (String) n;\n                    if (node.startsWith(\"server.\")) {\n                        String data = getSubstitutedData(\n                                curator.get(),\n                                profileRegistry.get().getConfigurations(versionId, \"fabric-ensemble-\" + oldClusterId)\n                                        .get(\"io.fabric8.zookeeper.server-\" + oldClusterId).get(node));\n                        addUsedPorts(usedPorts, data);\n                    }\n                }\n\n                Map<String, String> zkConfig = profileRegistry.get().getConfiguration(versionId, \"default\", Constants.ZOOKEEPER_CLIENT_PID);\n                if (zkConfig == null) {\n                    throw new FabricException(\"Failed to find old zookeeper configuration in default profile\");\n                }\n                String zkUrl = getSubstitutedData(curator.get(), zkConfig.get(\"zookeeper.url\"));\n                for (String data : zkUrl.split(\",\")) {\n                    addUsedPorts(usedPorts, data);\n                }\n            }\n\n            String newClusterId;\n            if (oldClusterId == null) {\n                newClusterId = \"0000\";\n            } else {\n                newClusterId = new DecimalFormat(\"0000\").format(Integer.parseInt(oldClusterId) + 1);\n            }\n\n            // create new ensemble\n            String profileId = \"fabric-ensemble-\" + newClusterId;\n            IllegalStateAssertion.assertFalse(profileRegistry.get().hasProfile(versionId, profileId), \"Profile already exists: \" + versionId + \"/\" + profileId);\n            String ensembleProfileId = profileRegistry.get().getProfile(versionId, profileId, true);\n            profileRegistry.get().setProfileAttribute(versionId, ensembleProfileId, \"abstract\", \"true\");\n            profileRegistry.get().setProfileAttribute(versionId, ensembleProfileId, \"hidden\", \"true\");\n\n            Properties ensembleProperties = new Properties();\n            ensembleProperties.put(\"tickTime\", String.valueOf(options.getZooKeeperServerTickTime()));\n            ensembleProperties.put(\"initLimit\", String.valueOf(options.getZooKeeperServerInitLimit()));\n            ensembleProperties.put(\"syncLimit\", String.valueOf(options.getZooKeeperServerSyncLimit()));\n            ensembleProperties.put(\"dataDir\", options.getZooKeeperServerDataDir() + File.separator + newClusterId);\n\n            int index = 1;\n            String connectionUrl = \"\";\n            String realConnectionUrl = \"\";\n            String containerList = \"\";\n            for (String container : containers) {\n                String ip = getSubstitutedPath(curator.get(), ZkPath.CONTAINER_IP.getPath(container));\n\n                String minimumPort = String.valueOf(Ports.MIN_PORT_NUMBER);\n                String maximumPort = String.valueOf(Ports.MAX_PORT_NUMBER);\n                String bindAddress = \"0.0.0.0\";\n\n                if (exists(curator.get(), ZkPath.CONTAINER_PORT_MIN.getPath(container)) != null) {\n                    minimumPort = getSubstitutedPath(curator.get(), ZkPath.CONTAINER_PORT_MIN.getPath(container));\n                }\n\n                if (exists(curator.get(), ZkPath.CONTAINER_PORT_MAX.getPath(container)) != null) {\n                    maximumPort = getSubstitutedPath(curator.get(), ZkPath.CONTAINER_PORT_MAX.getPath(container));\n                }\n\n                if (exists(curator.get(), ZkPath.CONTAINER_BINDADDRESS.getPath(container)) != null) {\n                    bindAddress = getSubstitutedPath(curator.get(), ZkPath.CONTAINER_BINDADDRESS.getPath(container));\n                }\n\n                String ensembleMemberConfigName = \"io.fabric8.zookeeper.server-\" + newClusterId + \".properties\";\n                Properties ensembleMemberProperties = new Properties();\n\n                // configure this server in the ensemble\n                profileId = \"fabric-ensemble-\" + newClusterId + \"-\" + index;\n                IllegalStateAssertion.assertFalse(profileRegistry.get().hasProfile(versionId, profileId), \"Profile already exists: \" + versionId + \"/\" + profileId);\n                String ensembleMemberProfileId = profileRegistry.get().getProfile(versionId, profileId, true);\n                profileRegistry.get().setProfileAttribute(versionId, ensembleMemberProfileId, \"hidden\", \"true\");\n                profileRegistry.get().setProfileAttribute(versionId, ensembleMemberProfileId, \"parents\", ensembleProfileId);\n\n                String port1 = Integer.toString(findPort(usedPorts, ip, mapPortToRange(Ports.DEFAULT_ZOOKEEPER_SERVER_PORT, minimumPort, maximumPort)));\n                if (containers.size() > 1) {\n                    String port2 = Integer.toString(findPort(usedPorts, ip, mapPortToRange(Ports.DEFAULT_ZOOKEEPER_PEER_PORT, minimumPort, maximumPort)));\n                    String port3 = Integer.toString(findPort(usedPorts, ip, mapPortToRange(Ports.DEFAULT_ZOOKEEPER_ELECTION_PORT, minimumPort, maximumPort)));\n                    ensembleProperties.put(\"server.\" + Integer.toString(index), \"${zk:\" + container + \"/ip}:\" + port2 + \":\" + port3);\n                    ensembleMemberProperties.put(\"server.id\", Integer.toString(index));\n                }\n                ensembleMemberProperties.put(\"clientPort\", port1);\n                ensembleMemberProperties.put(\"clientPortAddress\", bindAddress);\n\n                profileRegistry.get().setFileConfiguration(versionId, ensembleMemberProfileId, ensembleMemberConfigName, DataStoreUtils.toBytes(ensembleMemberProperties));\n\n                if (connectionUrl.length() > 0) {\n                    connectionUrl += \",\";\n                    realConnectionUrl += \",\";\n                }\n                connectionUrl += \"${zk:\" + container + \"/ip}:\" + port1;\n                realConnectionUrl += ip + \":\" + port1;\n                if (containerList.length() > 0) {\n                    containerList += \",\";\n                }\n                containerList += container;\n                index++;\n            }\n\n            String ensembleConfigName = \"io.fabric8.zookeeper.server-\" + newClusterId + \".properties\";\n            profileRegistry.get().setFileConfiguration(versionId, ensembleProfileId, ensembleConfigName, DataStoreUtils.toBytes(ensembleProperties));\n\n            index = 1;\n            for (String container : containers) {\n                // add this container to the ensemble\n                List<String> profiles = new LinkedList<String>(dataStore.get().getContainerProfiles(container));\n                profiles.add(\"fabric-ensemble-\" + newClusterId + \"-\" + Integer.toString(index));\n                dataStore.get().setContainerProfiles(container, profiles);\n                index++;\n            }\n\n            if (oldClusterId != null) {\n                Properties properties = DataStoreUtils.toProperties(profileRegistry.get().getConfiguration(versionId, \"default\", Constants.ZOOKEEPER_CLIENT_PID));\n                properties.put(\"zookeeper.url\", getSubstitutedData(curator.get(), realConnectionUrl));\n                properties.put(\"zookeeper.password\", options.getZookeeperPassword());\n                CuratorFramework dst = CuratorFrameworkFactory.builder().connectString(realConnectionUrl).retryPolicy(new RetryOneTime(500))\n                        .aclProvider(aclProvider.get()).authorization(\"digest\", (\"fabric:\" + options.getZookeeperPassword()).getBytes()).sessionTimeoutMs(30000)\n                        .connectionTimeoutMs((int) options.getMigrationTimeout()).build();\n                dst.start();\n                try {\n                    long t0 = System.currentTimeMillis();\n                    if (!dst.getZookeeperClient().blockUntilConnectedOrTimedOut()) {\n                        throw new EnsembleModificationFailed(\"Timed out connecting to new ensemble.\", EnsembleModificationFailed.Reason.TIMEOUT);\n                    }\n                    copy(curator.get(), dst, \"/fabric\");\n                    setData(dst, ZkPath.CONFIG_ENSEMBLES.getPath(), newClusterId);\n                    setData(dst, ZkPath.CONFIG_ENSEMBLE.getPath(newClusterId), containerList);\n\n                    // Perform cleanup when the new datastore has been registered.\n                    final AtomicReference<DataStore> result = new AtomicReference<DataStore>();\n                    runtimeProperties.get().putRuntimeAttribute(DataStoreTemplate.class, new DataStoreTemplate() {\n                        @Override\n                        public void doWith(ProfileRegistry profileRegistry, DataStore dataStore) {\n                            synchronized (result) {\n                                result.set(dataStore);\n                                result.notifyAll();\n                            }\n                        }\n                    });\n\n                    setData(dst, ZkPath.CONFIG_ENSEMBLE_PASSWORD.getPath(), PasswordEncoder.encode(options.getZookeeperPassword()));\n                    setData(dst, ZkPath.CONFIG_ENSEMBLE_URL.getPath(), connectionUrl);                    \n                    setData(curator.get(), ZkPath.CONFIG_ENSEMBLE_PASSWORD.getPath(), PasswordEncoder.encode(options.getZookeeperPassword()));\n                    setData(curator.get(), ZkPath.CONFIG_ENSEMBLE_URL.getPath(), connectionUrl);\n\n                    // Wait until all containers switched\n\n                    boolean allStarted = false;\n                    while (!allStarted && System.currentTimeMillis() - t0 < options.getMigrationTimeout()) {\n                        allStarted = true;\n                        for (Container container : allContainers) {\n                            allStarted &= exists(dst, ZkPath.CONTAINER_ALIVE.getPath(container.getId())) != null;\n                        }\n                        if (!allStarted) {\n                            Thread.sleep(1000);\n                        }\n                    }\n                    if (!allStarted) {\n                        throw new EnsembleModificationFailed(\"Timeout waiting for containers to join the new ensemble\", EnsembleModificationFailed.Reason.TIMEOUT);\n                    }\n\n                    // Wait until the new datastore has been registered\n                    synchronized (result) {\n                        if (result.get() == null) {\n                            result.wait();\n                        }\n                    }\n                    // Remove old profiles\n                    for (String container : oldContainers) {\n                        cleanUpEnsembleProfiles(result.get(), container, oldClusterId);\n                    }\n\n                } finally {\n                    dst.close();\n                }\n            } else {\n                Map<String, String> zkConfig = profileRegistry.get().getConfiguration(versionId, \"default\", Constants.ZOOKEEPER_CLIENT_PID);\n                zkConfig.put(\"zookeeper.password\", \"${zk:\" + ZkPath.CONFIG_ENSEMBLE_PASSWORD.getPath() + \"}\");\n                zkConfig.put(\"zookeeper.url\", \"${zk:\" + ZkPath.CONFIG_ENSEMBLE_URL.getPath() + \"}\");\n                profileRegistry.get().setConfiguration(versionId, \"default\", Constants.ZOOKEEPER_CLIENT_PID, zkConfig);\n            }\n        } catch (Exception e) {\n            throw EnsembleModificationFailed.launderThrowable(e);\n        }\n    }","commit_id":"e904c3fb44db4bee942c4290e76ad4745fd172de","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public List<Event> getRecentPersonalMessages()\n    {\n        DocumentReference currentUser = new DocumentReference(\n            this.currentResolver.resolve(this.bridge.getCurrentUser(), EntityType.DOCUMENT));\n        return getRecentPersonalMessages(currentUser, 30, 0);\n    }","id":102639,"modified_method":"@Override\n    public List<Event> getRecentPersonalMessages()\n    {\n        return getRecentPersonalMessages(this.bridge.getCurrentUserReference(), 30, 0);\n    }","commit_id":"54d3d2d924c5442830485ab71c6a3e7f88dbbec6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void postPublicMessage(String message)\n    {\n        Event e = createMessageEvent(message, \"publicMessage\");\n        // FIXME This shouldn't be needed if the current user were already available as a reference.\n        DocumentReference userDoc =\n            new DocumentReference(this.currentResolver.resolve(this.bridge.getCurrentUser(), EntityType.DOCUMENT));\n        e.setRelatedEntity(userDoc);\n        e.setImportance(Importance.MINOR);\n        e.setStream(this.serializer.serialize(userDoc));\n        this.stream.addEvent(e);\n    }","id":102640,"modified_method":"@Override\n    public void postPublicMessage(String message)\n    {\n        Event e = createMessageEvent(message, \"publicMessage\");\n        DocumentReference userDoc = this.bridge.getCurrentUserReference();\n        e.setRelatedEntity(userDoc);\n        e.setImportance(Importance.MINOR);\n        e.setStream(this.serializer.serialize(userDoc));\n        this.stream.addEvent(e);\n    }","commit_id":"54d3d2d924c5442830485ab71c6a3e7f88dbbec6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public List<Event> getRecentPersonalMessages(int limit, int offset)\n    {\n        DocumentReference currentUser = new DocumentReference(\n            this.currentResolver.resolve(this.bridge.getCurrentUser(), EntityType.DOCUMENT));\n        return getRecentPersonalMessages(currentUser, limit, offset);\n    }","id":102641,"modified_method":"@Override\n    public List<Event> getRecentPersonalMessages(int limit, int offset)\n    {\n        return getRecentPersonalMessages(this.bridge.getCurrentUserReference(), limit, offset);\n    }","commit_id":"54d3d2d924c5442830485ab71c6a3e7f88dbbec6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void postPersonalMessage(String message)\n    {\n        Event e = createMessageEvent(message, \"personalMessage\");\n        // FIXME This shouldn't be needed if the current user were already available as a reference.\n        DocumentReference userDoc =\n            new DocumentReference(this.currentResolver.resolve(this.bridge.getCurrentUser(), EntityType.DOCUMENT));\n        e.setRelatedEntity(userDoc);\n        e.setStream(this.serializer.serialize(userDoc));\n        this.stream.addEvent(e);\n    }","id":102642,"modified_method":"@Override\n    public void postPersonalMessage(String message)\n    {\n        Event e = createMessageEvent(message, \"personalMessage\");\n        DocumentReference userDoc = this.bridge.getCurrentUserReference();\n        e.setRelatedEntity(userDoc);\n        e.setStream(this.serializer.serialize(userDoc));\n        this.stream.addEvent(e);\n    }","commit_id":"54d3d2d924c5442830485ab71c6a3e7f88dbbec6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public List<Event> getRecentDirectMessages(int limit, int offset)\n    {\n        List<Event> result = new ArrayList<Event>();\n        try {\n            DocumentReference currentUser = new DocumentReference(\n                this.currentResolver.resolve(this.bridge.getCurrentUser(), EntityType.DOCUMENT));\n            Query q = this.qm.createQuery(\n                \"where event.application = 'MessageStream' and event.type = 'directMessage'\"\n                + \" and event.stream = :targetUser order by event.date desc\",\n                Query.XWQL);\n            q.bindValue(\"targetUser\", this.serializer.serialize(currentUser));\n            q.setLimit(limit > 0 ? limit : 30).setOffset(offset >= 0 ? offset : 0);\n            result = this.stream.searchEvents(q);\n        } catch (QueryException ex) {\n            LOG.warn(\"Failed to search direct messages: {}\", ex.getMessage());\n        }\n        return result;\n    }","id":102643,"modified_method":"@Override\n    public List<Event> getRecentDirectMessages(int limit, int offset)\n    {\n        List<Event> result = new ArrayList<Event>();\n        try {\n            Query q = this.qm.createQuery(\n                \"where event.application = 'MessageStream' and event.type = 'directMessage'\"\n                + \" and event.stream = :targetUser order by event.date desc\",\n                Query.XWQL);\n            q.bindValue(\"targetUser\", this.serializer.serialize(this.bridge.getCurrentUserReference()));\n            q.setLimit(limit > 0 ? limit : 30).setOffset(offset >= 0 ? offset : 0);\n            result = this.stream.searchEvents(q);\n        } catch (QueryException ex) {\n            LOG.warn(\"Failed to search direct messages: {}\", ex.getMessage());\n        }\n        return result;\n    }","commit_id":"54d3d2d924c5442830485ab71c6a3e7f88dbbec6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void deleteMessage(String id)\n    {\n        Query q;\n        try {\n            DocumentReference currentUser = new DocumentReference(\n                this.currentResolver.resolve(this.bridge.getCurrentUser(), EntityType.DOCUMENT));\n            q = this.qm.createQuery(\"where event.id = :id\", Query.XWQL);\n            q.bindValue(\"id\", id);\n            List<Event> events = this.stream.searchEvents(q);\n            if (events == null || events.isEmpty()) {\n                throw new IllegalArgumentException(\"This message does not exist\");\n            } else if (events.get(0).getUser().equals(currentUser)) {\n                this.stream.deleteEvent(events.get(0));\n            } else {\n                throw new IllegalArgumentException(\"You are not authorized to delete this message\");\n            }\n        } catch (QueryException ex) {\n            LOG.warn(\"Failed to delete message: {}\", ex.getMessage());\n        }\n    }","id":102644,"modified_method":"@Override\n    public void deleteMessage(String id)\n    {\n        Query q;\n        try {\n            q = this.qm.createQuery(\"where event.id = :id\", Query.XWQL);\n            q.bindValue(\"id\", id);\n            List<Event> events = this.stream.searchEvents(q);\n            if (events == null || events.isEmpty()) {\n                throw new IllegalArgumentException(\"This message does not exist\");\n            } else if (events.get(0).getUser().equals(this.bridge.getCurrentUserReference())) {\n                this.stream.deleteEvent(events.get(0));\n            } else {\n                throw new IllegalArgumentException(\"You are not authorized to delete this message\");\n            }\n        } catch (QueryException ex) {\n            LOG.warn(\"Failed to delete message: {}\", ex.getMessage());\n        }\n    }","commit_id":"54d3d2d924c5442830485ab71c6a3e7f88dbbec6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void setupForLimitQueries(final int expectedLimit, final int expectedOffset)\n        throws ComponentLookupException, Exception\n    {\n        final Query mockQuery = getMockQuery();\n        final QueryManager mockQueryManager = getComponentManager().getInstance(QueryManager.class);\n        final EventStream mockEventStream = getComponentManager().getInstance(EventStream.class);\n        final DocumentAccessBridge mockBridge = getComponentManager().getInstance(DocumentAccessBridge.class);\n        final EntityReferenceResolver<String> mockResolver =\n            getComponentManager().getInstance(EntityReferenceResolver.TYPE_STRING, \"current\");\n        @SuppressWarnings(\"unchecked\")\n        final EntityReferenceSerializer<String> mockSerializer =\n            getComponentManager().getInstance(EntityReferenceSerializer.TYPE_STRING);\n        getMockery().checking(new Expectations()\n        {\n            {\n                allowing(mockBridge).getCurrentUser();\n                will(returnValue(\"XWiki.JohnDoe\"));\n                allowing(mockResolver).resolve(\"XWiki.JohnDoe\", EntityType.DOCUMENT);\n                will(returnValue(MessageStreamTest.this.currentUser));\n                allowing(mockSerializer).serialize(MessageStreamTest.this.currentUser);\n                will(returnValue(\"wiki:XWiki.JohnDoe\"));\n                exactly(1).of(mockQuery).setLimit(expectedLimit);\n                will(returnValue(mockQuery));\n                exactly(1).of(mockQuery).setOffset(expectedOffset);\n                will(returnValue(mockQuery));\n                allowing(mockQuery).bindValue(with(any(String.class)), with(\"wiki:XWiki.JohnDoe\"));\n                allowing(mockQueryManager).createQuery(with(aNonNull(String.class)), with(aNonNull(String.class)));\n                will(returnValue(mockQuery));\n                exactly(1).of(mockEventStream).searchEvents(with(mockQuery));\n                will(returnValue(null));\n            }\n        });\n    }","id":102645,"modified_method":"private void setupForLimitQueries(final int expectedLimit, final int expectedOffset)\n        throws ComponentLookupException, Exception\n    {\n        final Query mockQuery = getMockQuery();\n        final QueryManager mockQueryManager = getComponentManager().getInstance(QueryManager.class);\n        final EventStream mockEventStream = getComponentManager().getInstance(EventStream.class);\n        final DocumentAccessBridge mockBridge = getComponentManager().getInstance(DocumentAccessBridge.class);\n        final EntityReferenceSerializer<String> mockSerializer =\n            getComponentManager().getInstance(EntityReferenceSerializer.TYPE_STRING);\n        getMockery().checking(new Expectations()\n        {\n            {\n                allowing(mockBridge).getCurrentUserReference();\n                will(returnValue(MessageStreamTest.this.currentUser));\n                allowing(mockSerializer).serialize(MessageStreamTest.this.currentUser);\n                will(returnValue(\"wiki:XWiki.JohnDoe\"));\n                exactly(1).of(mockQuery).setLimit(expectedLimit);\n                will(returnValue(mockQuery));\n                exactly(1).of(mockQuery).setOffset(expectedOffset);\n                will(returnValue(mockQuery));\n                allowing(mockQuery).bindValue(with(any(String.class)), with(\"wiki:XWiki.JohnDoe\"));\n                allowing(mockQueryManager).createQuery(with(aNonNull(String.class)), with(aNonNull(String.class)));\n                will(returnValue(mockQuery));\n                exactly(1).of(mockEventStream).searchEvents(with(mockQuery));\n                will(returnValue(null));\n            }\n        });\n    }","commit_id":"54d3d2d924c5442830485ab71c6a3e7f88dbbec6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private Event setupForGroupMessage() throws ComponentLookupException, Exception\n    {\n        final Event e = setupForNewMessage();\n        @SuppressWarnings(\"unchecked\")\n        final EntityReferenceSerializer<String> mockSerializer =\n            getComponentManager().getInstance(EntityReferenceSerializer.TYPE_STRING);\n        getMockery().checking(new Expectations()\n        {\n            {\n                exactly(1).of(mockSerializer).serialize(MessageStreamTest.this.targetGroup);\n                will(returnValue(\"wiki:XWiki.MyFriends\"));\n            }\n        });\n        return e;\n    }","id":102646,"modified_method":"private Event setupForGroupMessage() throws ComponentLookupException, Exception\n    {\n        final Event e = setupForNewMessage();\n        final EntityReferenceSerializer<String> mockSerializer =\n            getComponentManager().getInstance(EntityReferenceSerializer.TYPE_STRING);\n        getMockery().checking(new Expectations()\n        {\n            {\n                exactly(1).of(mockSerializer).serialize(MessageStreamTest.this.targetGroup);\n                will(returnValue(\"wiki:XWiki.MyFriends\"));\n            }\n        });\n        return e;\n    }","commit_id":"54d3d2d924c5442830485ab71c6a3e7f88dbbec6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testGetRecentPersonalMessagesWhenQueryFails() throws Exception\n    {\n        final Query mockQuery = getMockQuery();\n        final QueryManager mockQueryManager = getComponentManager().getInstance(QueryManager.class);\n        final EventStream mockEventStream = getComponentManager().getInstance(EventStream.class);\n        final DocumentAccessBridge mockBridge = getComponentManager().getInstance(DocumentAccessBridge.class);\n        @SuppressWarnings(\"unchecked\")\n        final EntityReferenceResolver<String> mockResolver =\n            getComponentManager().getInstance(EntityReferenceResolver.TYPE_STRING, \"current\");\n        @SuppressWarnings(\"unchecked\")\n        final EntityReferenceSerializer<String> mockSerializer =\n            getComponentManager().getInstance(EntityReferenceSerializer.TYPE_STRING);\n        getMockery().checking(new Expectations()\n        {\n            {\n                allowing(mockBridge).getCurrentUser();\n                will(returnValue(\"XWiki.JohnDoe\"));\n                allowing(mockResolver).resolve(\"XWiki.JohnDoe\", EntityType.DOCUMENT);\n                will(returnValue(MessageStreamTest.this.currentUser));\n                allowing(mockSerializer).serialize(MessageStreamTest.this.currentUser);\n                will(returnValue(\"wiki:XWiki.JohnDoe\"));\n                exactly(1).of(mockQuery).setLimit(30);\n                will(returnValue(mockQuery));\n                exactly(1).of(mockQuery).setOffset(0);\n                will(returnValue(mockQuery));\n                allowing(mockQuery).bindValue(with(any(String.class)), with(\"wiki:XWiki.JohnDoe\"));\n                allowing(mockQueryManager).createQuery(with(aNonNull(String.class)), with(aNonNull(String.class)));\n                will(returnValue(mockQuery));\n                exactly(1).of(mockEventStream).searchEvents(with(mockQuery));\n                will(throwException(new QueryException(\"\", null, null)));\n            }\n        });\n        List<Event> result = this.stream.getRecentPersonalMessages();\n        Assert.assertNotNull(result);\n        Assert.assertTrue(result.isEmpty());\n    }","id":102647,"modified_method":"@Test\n    public void testGetRecentPersonalMessagesWhenQueryFails() throws Exception\n    {\n        final Query mockQuery = getMockQuery();\n        final QueryManager mockQueryManager = getComponentManager().getInstance(QueryManager.class);\n        final EventStream mockEventStream = getComponentManager().getInstance(EventStream.class);\n        final DocumentAccessBridge mockBridge = getComponentManager().getInstance(DocumentAccessBridge.class);\n        final EntityReferenceSerializer<String> mockSerializer =\n            getComponentManager().getInstance(EntityReferenceSerializer.TYPE_STRING);\n        getMockery().checking(new Expectations()\n        {\n            {\n                allowing(mockBridge).getCurrentUserReference();\n                will(returnValue(MessageStreamTest.this.currentUser));\n                allowing(mockSerializer).serialize(MessageStreamTest.this.currentUser);\n                will(returnValue(\"wiki:XWiki.JohnDoe\"));\n                exactly(1).of(mockQuery).setLimit(30);\n                will(returnValue(mockQuery));\n                exactly(1).of(mockQuery).setOffset(0);\n                will(returnValue(mockQuery));\n                allowing(mockQuery).bindValue(with(any(String.class)), with(\"wiki:XWiki.JohnDoe\"));\n                allowing(mockQueryManager).createQuery(with(aNonNull(String.class)), with(aNonNull(String.class)));\n                will(returnValue(mockQuery));\n                exactly(1).of(mockEventStream).searchEvents(with(mockQuery));\n                will(throwException(new QueryException(\"\", null, null)));\n            }\n        });\n        List<Event> result = this.stream.getRecentPersonalMessages();\n        Assert.assertNotNull(result);\n        Assert.assertTrue(result.isEmpty());\n    }","commit_id":"54d3d2d924c5442830485ab71c6a3e7f88dbbec6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private Event setupForDirectMessage() throws ComponentLookupException, Exception\n    {\n        final Event e = setupForNewMessage();\n        @SuppressWarnings(\"unchecked\")\n        final EntityReferenceSerializer<String> mockSerializer =\n            getComponentManager().getInstance(EntityReferenceSerializer.TYPE_STRING);\n        getMockery().checking(new Expectations()\n        {\n            {\n                exactly(1).of(mockSerializer).serialize(MessageStreamTest.this.targetUser);\n                will(returnValue(\"wiki:XWiki.JaneBuck\"));\n            }\n        });\n        return e;\n    }","id":102648,"modified_method":"private Event setupForDirectMessage() throws ComponentLookupException, Exception\n    {\n        final Event e = setupForNewMessage();\n        final EntityReferenceSerializer<String> mockSerializer =\n            getComponentManager().getInstance(EntityReferenceSerializer.TYPE_STRING);\n        getMockery().checking(new Expectations()\n        {\n            {\n                exactly(1).of(mockSerializer).serialize(MessageStreamTest.this.targetUser);\n                will(returnValue(\"wiki:XWiki.JaneBuck\"));\n            }\n        });\n        return e;\n    }","commit_id":"54d3d2d924c5442830485ab71c6a3e7f88dbbec6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private Event setupForPublicMessage() throws Exception\n    {\n        final Event e = setupForNewMessage();\n        final DocumentAccessBridge mockBridge = getComponentManager().getInstance(DocumentAccessBridge.class);\n        @SuppressWarnings(\"unchecked\")\n        final EntityReferenceResolver<String> mockResolver =\n            getComponentManager().getInstance(EntityReferenceResolver.TYPE_STRING, \"current\");\n        @SuppressWarnings(\"unchecked\")\n        final EntityReferenceSerializer<String> mockSerializer =\n            getComponentManager().getInstance(EntityReferenceSerializer.TYPE_STRING);\n        getMockery().checking(new Expectations()\n        {\n            {\n                exactly(1).of(mockBridge).getCurrentUser();\n                will(returnValue(\"XWiki.JohnDoe\"));\n                atLeast(1).of(mockResolver).resolve(\"XWiki.JohnDoe\", EntityType.DOCUMENT);\n                will(returnValue(MessageStreamTest.this.currentUser));\n                exactly(1).of(mockSerializer).serialize(MessageStreamTest.this.currentUser);\n                will(returnValue(\"wiki:XWiki.JohnDoe\"));\n            }\n        });\n        return e;\n    }","id":102649,"modified_method":"private Event setupForPublicMessage() throws Exception\n    {\n        final Event e = setupForNewMessage();\n        final DocumentAccessBridge mockBridge = getComponentManager().getInstance(DocumentAccessBridge.class);\n        final EntityReferenceSerializer<String> mockSerializer =\n            getComponentManager().getInstance(EntityReferenceSerializer.TYPE_STRING);\n        getMockery().checking(new Expectations()\n        {\n            {\n                exactly(1).of(mockBridge).getCurrentUserReference();\n                will(returnValue(MessageStreamTest.this.currentUser));\n                exactly(1).of(mockSerializer).serialize(MessageStreamTest.this.currentUser);\n                will(returnValue(\"wiki:XWiki.JohnDoe\"));\n            }\n        });\n        return e;\n    }","commit_id":"54d3d2d924c5442830485ab71c6a3e7f88dbbec6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private Event setupForPersonalMessage() throws Exception\n    {\n        final Event e = setupForNewMessage();\n        final DocumentAccessBridge mockBridge = getComponentManager().getInstance(DocumentAccessBridge.class);\n        @SuppressWarnings(\"unchecked\")\n        final EntityReferenceResolver<String> mockResolver =\n            getComponentManager().getInstance(EntityReferenceResolver.TYPE_STRING, \"current\");\n        @SuppressWarnings(\"unchecked\")\n        final EntityReferenceSerializer<String> mockSerializer =\n            getComponentManager().getInstance(EntityReferenceSerializer.TYPE_STRING);\n        getMockery().checking(new Expectations()\n        {\n            {\n                exactly(1).of(mockBridge).getCurrentUser();\n                will(returnValue(\"XWiki.JohnDoe\"));\n                atLeast(1).of(mockResolver).resolve(\"XWiki.JohnDoe\", EntityType.DOCUMENT);\n                will(returnValue(MessageStreamTest.this.currentUser));\n                exactly(1).of(mockSerializer).serialize(MessageStreamTest.this.currentUser);\n                will(returnValue(\"wiki:XWiki.JohnDoe\"));\n            }\n        });\n        return e;\n    }","id":102650,"modified_method":"private Event setupForPersonalMessage() throws Exception\n    {\n        final Event e = setupForNewMessage();\n        final DocumentAccessBridge mockBridge = getComponentManager().getInstance(DocumentAccessBridge.class);\n        final EntityReferenceSerializer<String> mockSerializer =\n            getComponentManager().getInstance(EntityReferenceSerializer.TYPE_STRING);\n        getMockery().checking(new Expectations()\n        {\n            {\n                exactly(1).of(mockBridge).getCurrentUserReference();\n                will(returnValue(MessageStreamTest.this.currentUser));\n                exactly(1).of(mockSerializer).serialize(MessageStreamTest.this.currentUser);\n                will(returnValue(\"wiki:XWiki.JohnDoe\"));\n            }\n        });\n        return e;\n    }","commit_id":"54d3d2d924c5442830485ab71c6a3e7f88dbbec6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Nullable\n  public static PsiElement appendToMethod(PyFunction init, Function<String, PyStatement> callback) {\n    // add this field as the last stmt of the constructor\n    final PyStatementList statementList = init.getStatementList();\n    assert statementList != null;\n    // name of 'self' may be different for fancier styles\n    PyParameter[] params = init.getParameterList().getParameters();\n    String selfName = PyNames.CANONICAL_SELF;\n    if (params.length > 0) {\n      selfName = params[0].getName();\n    }\n    PyStatement newStmt = callback.fun(selfName);\n    if (!FileModificationService.getInstance().preparePsiElementForWrite(statementList)) return null;\n    final PsiElement result = PyUtil.addElementToStatementList(newStmt, statementList, true);\n    PyPsiUtils.removeRedundantPass(statementList);\n    return result;\n  }","id":102651,"modified_method":"@Nullable\n  public static PsiElement appendToMethod(PyFunction init, Function<String, PyStatement> callback) {\n    // add this field as the last stmt of the constructor\n    final PyStatementList statementList = init.getStatementList();\n    // name of 'self' may be different for fancier styles\n    PyParameter[] params = init.getParameterList().getParameters();\n    String selfName = PyNames.CANONICAL_SELF;\n    if (params.length > 0) {\n      selfName = params[0].getName();\n    }\n    PyStatement newStmt = callback.fun(selfName);\n    if (!FileModificationService.getInstance().preparePsiElementForWrite(statementList)) return null;\n    final PsiElement result = PyUtil.addElementToStatementList(newStmt, statementList, true);\n    PyPsiUtils.removeRedundantPass(statementList);\n    return result;\n  }","commit_id":"f5ac410c49043cb38bfb53b55541a92e61981f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void showTemplateBuilder(PsiElement initStatement) {\n    initStatement = CodeInsightUtilCore.forcePsiPostprocessAndRestoreElement(initStatement);\n    if (initStatement instanceof PyAssignmentStatement) {\n      final TemplateBuilder builder = TemplateBuilderFactory.getInstance().createTemplateBuilder(initStatement);\n      final PyExpression assignedValue = ((PyAssignmentStatement)initStatement).getAssignedValue();\n      if (assignedValue != null) {\n        builder.replaceElement(assignedValue, myInitializer);\n        builder.run();\n      }\n    }\n  }","id":102652,"modified_method":"private void showTemplateBuilder(PsiElement initStatement, @NotNull final PsiFile file) {\n    initStatement = CodeInsightUtilCore.forcePsiPostprocessAndRestoreElement(initStatement);\n    if (initStatement instanceof PyAssignmentStatement) {\n      final TemplateBuilder builder = TemplateBuilderFactory.getInstance().createTemplateBuilder(initStatement);\n      final PyExpression assignedValue = ((PyAssignmentStatement)initStatement).getAssignedValue();\n      if (assignedValue != null) {\n        builder.replaceElement(assignedValue, myInitializer);\n        final VirtualFile virtualFile = file.getVirtualFile();\n        if (virtualFile == null) return;\n        final Editor editor = FileEditorManager.getInstance(file.getProject()).openTextEditor(\n                  new OpenFileDescriptor(file.getProject(), virtualFile), true);\n        if (editor == null) return;\n        builder.run(editor, false);\n      }\n    }\n  }","commit_id":"f5ac410c49043cb38bfb53b55541a92e61981f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    // expect the descriptor to point to the unresolved identifier.\n    PyClass cls = myQualifierType.getPyClass();\n    PsiElement initStatement;\n    if (!myQualifierType.isDefinition()) {\n      initStatement = addFieldToInit(project, cls, myIdentifier, new CreateFieldCallback(project, myIdentifier, myInitializer));\n    }\n    else {\n      PyStatement field = PyElementGenerator.getInstance(project)\n        .createFromText(LanguageLevel.getDefault(), PyStatement.class, myIdentifier + \" = \" + myInitializer);\n      initStatement = PyUtil.addElementToStatementList(field, cls.getStatementList(), true);\n    }\n    if (initStatement != null) {\n      showTemplateBuilder(initStatement);\n      return;\n    }\n    // somehow we failed. tell about this\n    PyUtil.showBalloon(project, PyBundle.message(\"QFIX.failed.to.add.field\"), MessageType.ERROR);\n  }","id":102653,"modified_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    // expect the descriptor to point to the unresolved identifier.\n    PyClass cls = myQualifierType.getPyClass();\n    PsiElement initStatement;\n    if (!myQualifierType.isDefinition()) {\n      initStatement = addFieldToInit(project, cls, myIdentifier, new CreateFieldCallback(project, myIdentifier, myInitializer));\n    }\n    else {\n      PyStatement field = PyElementGenerator.getInstance(project)\n        .createFromText(LanguageLevel.getDefault(), PyStatement.class, myIdentifier + \" = \" + myInitializer);\n      initStatement = PyUtil.addElementToStatementList(field, cls.getStatementList(), true);\n    }\n    if (initStatement != null) {\n      showTemplateBuilder(initStatement, cls.getContainingFile());\n      return;\n    }\n    // somehow we failed. tell about this\n    PyUtil.showBalloon(project, PyBundle.message(\"QFIX.failed.to.add.field\"), MessageType.ERROR);\n  }","commit_id":"f5ac410c49043cb38bfb53b55541a92e61981f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiElement addFieldToInit(Project project, PyClass cls, String itemName, Function<String, PyStatement> callback) {\n    if (cls != null && itemName != null) {\n      PyFunction init = cls.findMethodByName(PyNames.INIT, false);\n      if (init != null) {\n        return appendToMethod(init, callback);\n      }\n      else { // no init! boldly copy ancestor's.\n        for (PyClass ancestor : cls.getAncestorClasses()) {\n          init = ancestor.findMethodByName(PyNames.INIT, false);\n          if (init != null) break;\n        }\n        PyFunction newInit = createInitMethod(project, cls, init);\n        if (newInit == null) {\n          return null;\n        }\n\n        appendToMethod(newInit, callback);\n\n        PsiElement addAnchor = null;\n        PyFunction[] meths = cls.getMethods();\n        if (meths.length > 0) addAnchor = meths[0].getPrevSibling();\n        PyStatementList clsContent = cls.getStatementList();\n        newInit = (PyFunction) clsContent.addAfter(newInit, addAnchor);\n\n        PyUtil.showBalloon(project, PyBundle.message(\"QFIX.added.constructor.$0.for.field.$1\", cls.getName(), itemName), MessageType.INFO);\n        final PyStatementList statementList = newInit.getStatementList();\n        assert statementList != null;\n        return statementList.getStatements()[0];\n        //else  // well, that can't be\n      }\n    }\n    return null;\n  }","id":102654,"modified_method":"@Nullable\n  public static PsiElement addFieldToInit(Project project, PyClass cls, String itemName, Function<String, PyStatement> callback) {\n    if (cls != null && itemName != null) {\n      PyFunction init = cls.findMethodByName(PyNames.INIT, false);\n      if (init != null) {\n        return appendToMethod(init, callback);\n      }\n      else { // no init! boldly copy ancestor's.\n        for (PyClass ancestor : cls.getAncestorClasses()) {\n          init = ancestor.findMethodByName(PyNames.INIT, false);\n          if (init != null) break;\n        }\n        PyFunction newInit = createInitMethod(project, cls, init);\n        if (newInit == null) {\n          return null;\n        }\n\n        appendToMethod(newInit, callback);\n\n        PsiElement addAnchor = null;\n        PyFunction[] meths = cls.getMethods();\n        if (meths.length > 0) addAnchor = meths[0].getPrevSibling();\n        PyStatementList clsContent = cls.getStatementList();\n        newInit = (PyFunction) clsContent.addAfter(newInit, addAnchor);\n\n        PyUtil.showBalloon(project, PyBundle.message(\"QFIX.added.constructor.$0.for.field.$1\", cls.getName(), itemName), MessageType.INFO);\n        final PyStatementList statementList = newInit.getStatementList();\n        final PyStatement[] statements = statementList.getStatements();\n        return statements.length != 0 ? statements[0] : null;\n      }\n    }\n    return null;\n  }","commit_id":"f5ac410c49043cb38bfb53b55541a92e61981f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static Editor getEditor(@NotNull final Project project, @NotNull final PsiFile file, int offset) {\n    final VirtualFile virtualFile = file.getVirtualFile();\n    if (virtualFile != null) {\n    return FileEditorManager.getInstance(project).openTextEditor(\n      new OpenFileDescriptor(project, virtualFile, offset), true\n    );\n    }\n    return null;\n  }","id":102655,"modified_method":"@Nullable\n  private static Editor getEditor(@NotNull final Project project, @NotNull final PsiFile file, int offset) {\n    final VirtualFile virtualFile = file.getVirtualFile();\n    return virtualFile != null ? FileEditorManager.getInstance(project).openTextEditor(\n      new OpenFileDescriptor(project, virtualFile, offset), true\n    ) : null;\n  }","commit_id":"f5ac410c49043cb38bfb53b55541a92e61981f8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void insertDocStub(PyFunction function, PyStatementList insertPlace, Project project, Editor editor) {\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    PsiWhiteSpace whitespace = PsiTreeUtil.getPrevSiblingOfType(insertPlace, PsiWhiteSpace.class);\n    String ws = \"\\n\";\n    if (whitespace != null) {\n      String[] spaces = whitespace.getText().split(\"\\n\");\n      if (spaces.length > 1) {\n        ws += spaces[spaces.length - 1];\n      }\n    }\n    String docContent = ws + generateDocumentationContentStub(function, ws, true);\n    PyExpressionStatement string = elementGenerator.createDocstring(\"\\\"\\\"\\\"\" + docContent + \"\\\"\\\"\\\"\");\n    if (insertPlace.getStatements().length != 0) {\n      insertPlace.addBefore(string, insertPlace.getStatements()[0]);\n    }\n    PyStringLiteralExpression docstring = function.getDocStringExpression();\n    if (editor != null && docstring != null) {\n      int offset = docstring.getTextOffset();\n      editor.getCaretModel().moveToOffset(offset);\n      editor.getCaretModel().moveCaretRelatively(0, 1, false, false, false);\n    }\n  }","id":102656,"modified_method":"public static void insertDocStub(PyFunction function, PyStatementList insertPlace, Project project, Editor editor) {\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    PsiWhiteSpace whitespace = PsiTreeUtil.getPrevSiblingOfType(insertPlace, PsiWhiteSpace.class);\n    String ws = \"\\n\";\n    if (whitespace != null) {\n      String[] spaces = whitespace.getText().split(\"\\n\");\n      if (spaces.length > 1) {\n        ws += spaces[spaces.length - 1];\n      }\n    }\n    String docContent = ws + generateDocumentationContentStub(function, ws, true);\n    PyExpressionStatement string = elementGenerator.createDocstring(\"\\\"\\\"\\\"\" + docContent + \"\\\"\\\"\\\"\");\n    if (insertPlace != null) {\n      final PyStatement[] statements = insertPlace.getStatements();\n      if (statements.length != 0) {\n        insertPlace.addBefore(string, statements[0]);\n      }\n    }\n    PyStringLiteralExpression docstring = function.getDocStringExpression();\n    if (editor != null && docstring != null) {\n      int offset = docstring.getTextOffset();\n      editor.getCaretModel().moveToOffset(offset);\n      editor.getCaretModel().moveCaretRelatively(0, 1, false, false, false);\n    }\n  }","commit_id":"8a059733eb9d7140f3320cc80395d77aaf81b4e1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String generateContent(PyFunction function, String offset, String prefix, boolean checkReturn) {\n    //TODO: this code duplicates PyDocstringGenerator in some parts\n\n    final StringBuilder builder = new StringBuilder(offset);\n    final TypeEvalContext context = TypeEvalContext.userInitiated(function.getContainingFile());\n    PySignature signature = PySignatureCacheManager.getInstance(function.getProject()).findSignature(function);\n\n    for (PyParameter p : PyUtil.getParameters(function, context)) {\n      final String parameterName = p.getName();\n      if (p.getText().equals(PyNames.CANONICAL_SELF) || parameterName == null) {\n        continue;\n      }\n      String argType = signature == null ? null : signature.getArgTypeQualifiedName(parameterName);\n\n      if (argType == null) {\n        builder.append(prefix);\n        builder.append(\"param \");\n        builder.append(parameterName);\n        builder.append(\": \");\n        builder.append(offset);\n      }\n      if (PyCodeInsightSettings.getInstance().INSERT_TYPE_DOCSTUB || argType != null) {\n        builder.append(prefix);\n        builder.append(\"type \");\n        builder.append(parameterName);\n        builder.append(\": \");\n        if (signature != null) {\n          builder.append(PySignatureUtil.getShortestImportableName(function, argType));\n        }\n        builder.append(offset);\n      }\n    }\n    builder.append(generateRaiseOrReturn(function, offset, prefix, checkReturn));\n    return builder.toString();\n  }","id":102657,"modified_method":"private static String generateContent(PyFunction function, String offset, String prefix, boolean checkReturn) {\n    //TODO: this code duplicates PyDocstringGenerator in some parts\n\n    final StringBuilder builder = new StringBuilder(offset);\n    final TypeEvalContext context = TypeEvalContext.userInitiated(function.getContainingFile());\n    PySignature signature = PySignatureCacheManager.getInstance(function.getProject()).findSignature(function);\n    final PyDecoratorList decoratorList = function.getDecoratorList();\n    final PyDecorator classMethod = decoratorList == null ? null : decoratorList.findDecorator(PyNames.CLASSMETHOD);\n    for (PyParameter p : PyUtil.getParameters(function, context)) {\n      final String parameterName = p.getName();\n      if (p.getText().equals(PyNames.CANONICAL_SELF) || parameterName == null) {\n        continue;\n      }\n      if (classMethod != null && parameterName.equals(PyNames.CANONICAL_CLS)) continue;\n      String argType = signature == null ? null : signature.getArgTypeQualifiedName(parameterName);\n\n      if (argType == null) {\n        builder.append(prefix);\n        builder.append(\"param \");\n        builder.append(parameterName);\n        builder.append(\": \");\n        builder.append(offset);\n      }\n      if (PyCodeInsightSettings.getInstance().INSERT_TYPE_DOCSTUB || argType != null) {\n        builder.append(prefix);\n        builder.append(\"type \");\n        builder.append(parameterName);\n        builder.append(\": \");\n        if (signature != null && argType != null) {\n          builder.append(PySignatureUtil.getShortestImportableName(function, argType));\n        }\n        builder.append(offset);\n      }\n    }\n    builder.append(generateRaiseOrReturn(function, offset, prefix, checkReturn));\n    return builder.toString();\n  }","commit_id":"8a059733eb9d7140f3320cc80395d77aaf81b4e1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void insertDocStringStub(Editor editor, PsiElement element) {\n    PythonDocumentationProvider provider = new PythonDocumentationProvider();\n    PyFunction fun = PsiTreeUtil.getParentOfType(element, PyFunction.class);\n    if (fun != null) {\n      String docStub = provider.generateDocumentationContentStub(fun, false);\n      docStub += element.getParent().getText().substring(0,3);\n      if (docStub != null && docStub.length() != 0) {\n        editor.getDocument().insertString(editor.getCaretModel().getOffset(), docStub);\n        return;\n      }\n    }\n    PyElement klass = PsiTreeUtil.getParentOfType(element, PyClass.class, PyFile.class);\n    if (klass != null) {\n      editor.getDocument().insertString(editor.getCaretModel().getOffset(),\n                      PythonDocCommentUtil.generateDocForClass(klass, element.getParent().getText().substring(0, 3)));\n    }\n  }","id":102658,"modified_method":"private static void insertDocStringStub(Editor editor, PsiElement element) {\n    PythonDocumentationProvider provider = new PythonDocumentationProvider();\n    PyFunction fun = PsiTreeUtil.getParentOfType(element, PyFunction.class);\n    if (fun != null) {\n      String docStub = provider.generateDocumentationContentStub(fun, false);\n      docStub += element.getParent().getText().substring(0,3);\n      if (docStub.length() != 0) {\n        editor.getDocument().insertString(editor.getCaretModel().getOffset(), docStub);\n        return;\n      }\n    }\n    PyElement klass = PsiTreeUtil.getParentOfType(element, PyClass.class, PyFile.class);\n    if (klass != null && element != null) {\n      editor.getDocument().insertString(editor.getCaretModel().getOffset(),\n                      PythonDocCommentUtil.generateDocForClass(klass, element.getParent().getText().substring(0, 3)));\n    }\n  }","commit_id":"8a059733eb9d7140f3320cc80395d77aaf81b4e1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void init() throws IOException {\n        _selector = Selector.open();\n        \n        SocketChannel sch = SocketChannel.open();\n        sch.configureBlocking(true);\n        s_logger.info(\"Connecting to \" + _host + \":\" + _port);\n\n        if(_bindAddress != null) {\n            s_logger.info(\"Binding outbound interface at \" + _bindAddress);\n            \n            InetSocketAddress addr = new InetSocketAddress(_bindAddress, 0);\n            sch.socket().bind(addr);\n        }\n\n        InetSocketAddress addr = new InetSocketAddress(_host, _port);\n        try {\n        \tsch.connect(addr);\n        } catch (IOException e) {\n        \t_selector.close();\n        \tthrow e;\n        }\n\n        SSLEngine sslEngine = null;\n        try {\n        \t// Begin SSL handshake in BLOCKING mode\n        \tsch.configureBlocking(true);\n\n        \tSSLContext sslContext = Link.initSSLContext(true);\n        \tsslEngine = sslContext.createSSLEngine(_host, _port);\n        \tsslEngine.setUseClientMode(true);\n\n        \tLink.doHandshake(sch, sslEngine, true);\n        \ts_logger.info(\"SSL: Handshake done\");\n        } catch (Exception e) {\n        \t_selector.close();\n        \tthrow new IOException(\"SSL: Fail to init SSL! \" + e);\n        }\n        \n        sch.configureBlocking(false);\n        Link link = new Link(addr, this);\n        link.setSSLEngine(sslEngine);\n        SelectionKey key = sch.register(_selector, SelectionKey.OP_READ);\n        link.setKey(key);\n        key.attach(link);\n        // Notice we've already connected due to the handshake, so let's get the\n        // remaining task done\n        Task task = _factory.create(Task.Type.CONNECT, link, null);\n        _executor.execute(task);\n    }","id":102659,"modified_method":"@Override\n    protected void init() throws IOException {\n        _selector = Selector.open();\n        SocketChannel sch = null;\n        InetSocketAddress addr = null;\n        \n        try {\n            sch = SocketChannel.open();\n            sch.configureBlocking(true);\n            s_logger.info(\"Connecting to \" + _host + \":\" + _port);\n\n            if(_bindAddress != null) {\n                s_logger.info(\"Binding outbound interface at \" + _bindAddress);\n\n                addr = new InetSocketAddress(_bindAddress, 0);\n                sch.socket().bind(addr);\n            }\n\n            addr = new InetSocketAddress(_host, _port);\n            sch.connect(addr);\n        } catch (IOException e) {\n        \t_selector.close();\n        \tthrow e;\n        }\n\n        SSLEngine sslEngine = null;\n        try {\n        \t// Begin SSL handshake in BLOCKING mode\n        \tsch.configureBlocking(true);\n\n        \tSSLContext sslContext = Link.initSSLContext(true);\n        \tsslEngine = sslContext.createSSLEngine(_host, _port);\n        \tsslEngine.setUseClientMode(true);\n\n        \tLink.doHandshake(sch, sslEngine, true);\n        \ts_logger.info(\"SSL: Handshake done\");\n        } catch (Exception e) {\n        \t_selector.close();\n        \tthrow new IOException(\"SSL: Fail to init SSL! \" + e);\n        }\n        \n        Task task = null;\n        try {\n            sch.configureBlocking(false);\n            Link link = new Link(addr, this);\n            link.setSSLEngine(sslEngine);\n            SelectionKey key = sch.register(_selector, SelectionKey.OP_READ);\n            link.setKey(key);\n            key.attach(link);\n            // Notice we've already connected due to the handshake, so let's get the\n            // remaining task done\n            task = _factory.create(Task.Type.CONNECT, link, null);\n        } catch (Exception e) {\n        \t_selector.close();\n        \tthrow new IOException(\"Fail to init NioClient! \" + e);\n        }\n        _executor.execute(task);\n    }","commit_id":"cba8e16b61cdf3c5077e878d412b332161deca4a","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    protected void init() throws IOException {\n        _selector = Selector.open();\n        \n        SocketChannel sch = SocketChannel.open();\n        sch.configureBlocking(true);\n        s_logger.info(\"Connecting to \" + _host + \":\" + _port);\n\n        if(_bindAddress != null) {\n            s_logger.info(\"Binding outbound interface at \" + _bindAddress);\n            \n            InetSocketAddress addr = new InetSocketAddress(_bindAddress, 0);\n            sch.socket().bind(addr);\n        }\n\n        InetSocketAddress addr = new InetSocketAddress(_host, _port);\n        try {\n        \tsch.connect(addr);\n        } catch (IOException e) {\n        \t_selector.close();\n        \tthrow e;\n        }\n\n        SSLEngine sslEngine = null;\n        try {\n        \t// Begin SSL handshake in BLOCKING mode\n        \tsch.configureBlocking(true);\n\n        \tSSLContext sslContext = Link.initSSLContext(true);\n        \tsslEngine = sslContext.createSSLEngine(_host, _port);\n        \tsslEngine.setUseClientMode(true);\n\n        \tLink.doHandshake(sch, sslEngine, true);\n        \ts_logger.info(\"SSL: Handshake done\");\n        } catch (Exception e) {\n        \t_selector.close();\n        \tthrow new IOException(\"SSL: Fail to init SSL! \" + e);\n        }\n        \n        sch.configureBlocking(false);\n        Link link = new Link(addr, this);\n        link.setSSLEngine(sslEngine);\n        SelectionKey key = sch.register(_selector, SelectionKey.OP_READ);\n        link.setKey(key);\n        key.attach(link);\n        // Notice we've already connected due to the handshake, so let's get the\n        // remaining task done\n        Task task = _factory.create(Task.Type.CONNECT, link, null);\n        _executor.execute(task);\n    }","id":102660,"modified_method":"@Override\n    protected void init() throws IOException {\n        _selector = Selector.open();\n        SocketChannel sch = null;\n        InetSocketAddress addr = null;\n        \n        try {\n            sch = SocketChannel.open();\n            sch.configureBlocking(true);\n            s_logger.info(\"Connecting to \" + _host + \":\" + _port);\n\n            if(_bindAddress != null) {\n                s_logger.info(\"Binding outbound interface at \" + _bindAddress);\n\n                addr = new InetSocketAddress(_bindAddress, 0);\n                sch.socket().bind(addr);\n            }\n\n            addr = new InetSocketAddress(_host, _port);\n            sch.connect(addr);\n        } catch (IOException e) {\n        \t_selector.close();\n        \tthrow e;\n        }\n\n        SSLEngine sslEngine = null;\n        try {\n        \t// Begin SSL handshake in BLOCKING mode\n        \tsch.configureBlocking(true);\n\n        \tSSLContext sslContext = Link.initSSLContext(true);\n        \tsslEngine = sslContext.createSSLEngine(_host, _port);\n        \tsslEngine.setUseClientMode(true);\n\n        \tLink.doHandshake(sch, sslEngine, true);\n        \ts_logger.info(\"SSL: Handshake done\");\n        } catch (Exception e) {\n        \t_selector.close();\n        \tthrow new IOException(\"SSL: Fail to init SSL! \" + e);\n        }\n        \n        Task task = null;\n        try {\n            sch.configureBlocking(false);\n            Link link = new Link(addr, this);\n            link.setSSLEngine(sslEngine);\n            SelectionKey key = sch.register(_selector, SelectionKey.OP_READ);\n            link.setKey(key);\n            key.attach(link);\n            // Notice we've already connected due to the handshake, so let's get the\n            // remaining task done\n            task = _factory.create(Task.Type.CONNECT, link, null);\n        } catch (Exception e) {\n        \t_selector.close();\n        \tthrow new IOException(\"Fail to init NioClient! \" + e);\n        }\n        _executor.execute(task);\n    }","commit_id":"ba6dd6cfcd085d3e12bb096cac7f22fcfbdd6253","url":"https://github.com/apache/cloudstack"},{"original_method":"public static SSLContext initSSLContext(boolean isClient) throws Exception {\n        InputStream stream;\n        SSLContext sslContext = null;\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        KeyStore ks = KeyStore.getInstance(\"JKS\");\n        TrustManager[] tms;\n\n        File confFile = PropertiesUtil.findConfigFile(\"db.properties\");\n        if (null != confFile && !isClient) {\n            final Properties dbProps = DbProperties.getDbProperties();\n            char[] passphrase = dbProps.getProperty(\"db.cloud.keyStorePassphrase\").toCharArray();\n            String confPath = confFile.getParent();\n            String keystorePath = confPath + keystoreFile;\n            if (new File(keystorePath).exists()) {\n                stream = new FileInputStream(keystorePath);\n            } else {\n                s_logger.warn(\"SSL: Fail to find the generated keystore. Loading fail-safe one to continue.\");\n                stream = NioConnection.class.getResourceAsStream(\"/cloud.keystore\");\n            }\n            ks.load(stream, passphrase);\n            stream.close();\n            kmf.init(ks, passphrase);\n            tmf.init(ks);\n            tms = tmf.getTrustManagers();\n        } else {\n            ks.load(null, null);\n            kmf.init(ks, null);\n            tms = new TrustManager[1];\n            tms[0] = new TrustAllManager();\n        }\n\n        sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(kmf.getKeyManagers(), tms, null);\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"SSL: SSLcontext has been initialized\");\n        }\n\n        return sslContext;\n    }","id":102661,"modified_method":"public static SSLContext initSSLContext(boolean isClient) throws GeneralSecurityException, IOException {\n        InputStream stream;\n        SSLContext sslContext = null;\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        KeyStore ks = KeyStore.getInstance(\"JKS\");\n        TrustManager[] tms;\n\n        File confFile = PropertiesUtil.findConfigFile(\"db.properties\");\n        if (null != confFile && !isClient) {\n            final Properties dbProps = DbProperties.getDbProperties();\n            char[] passphrase = dbProps.getProperty(\"db.cloud.keyStorePassphrase\").toCharArray();\n            String confPath = confFile.getParent();\n            String keystorePath = confPath + keystoreFile;\n            if (new File(keystorePath).exists()) {\n                stream = new FileInputStream(keystorePath);\n            } else {\n                s_logger.warn(\"SSL: Fail to find the generated keystore. Loading fail-safe one to continue.\");\n                stream = NioConnection.class.getResourceAsStream(\"/cloud.keystore\");\n            }\n            ks.load(stream, passphrase);\n            stream.close();\n            kmf.init(ks, passphrase);\n            tmf.init(ks);\n            tms = tmf.getTrustManagers();\n        } else {\n            ks.load(null, null);\n            kmf.init(ks, null);\n            tms = new TrustManager[1];\n            tms[0] = new TrustAllManager();\n        }\n\n        sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(kmf.getKeyManagers(), tms, null);\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"SSL: SSLcontext has been initialized\");\n        }\n\n        return sslContext;\n    }","commit_id":"de26a7228e1298d0a5d4d2c0bf00c924a99cd505","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    protected void init() throws IOException {\n        _selector = Selector.open();\n        SocketChannel sch = null;\n        InetSocketAddress addr = null;\n\n        try {\n            sch = SocketChannel.open();\n            sch.configureBlocking(true);\n            s_logger.info(\"Connecting to \" + _host + \":\" + _port);\n\n            if (_bindAddress != null) {\n                s_logger.info(\"Binding outbound interface at \" + _bindAddress);\n\n                addr = new InetSocketAddress(_bindAddress, 0);\n                sch.socket().bind(addr);\n            }\n\n            addr = new InetSocketAddress(_host, _port);\n            sch.connect(addr);\n        } catch (IOException e) {\n            _selector.close();\n            throw e;\n        }\n\n        SSLEngine sslEngine = null;\n        try {\n            // Begin SSL handshake in BLOCKING mode\n            sch.configureBlocking(true);\n\n            SSLContext sslContext = Link.initSSLContext(true);\n            sslEngine = sslContext.createSSLEngine(_host, _port);\n            sslEngine.setUseClientMode(true);\n\n            Link.doHandshake(sch, sslEngine, true);\n            s_logger.info(\"SSL: Handshake done\");\n            s_logger.info(\"Connected to \" + _host + \":\" + _port);\n        } catch (Exception e) {\n            _selector.close();\n            throw new IOException(\"SSL: Fail to init SSL! \" + e);\n        }\n\n        Task task = null;\n        try {\n            sch.configureBlocking(false);\n            Link link = new Link(addr, this);\n            link.setSSLEngine(sslEngine);\n            SelectionKey key = sch.register(_selector, SelectionKey.OP_READ);\n            link.setKey(key);\n            key.attach(link);\n            // Notice we've already connected due to the handshake, so let's get the\n            // remaining task done\n            task = _factory.create(Task.Type.CONNECT, link, null);\n        } catch (Exception e) {\n            _selector.close();\n            throw new IOException(\"Fail to init NioClient! \" + e);\n        }\n        _executor.execute(task);\n    }","id":102662,"modified_method":"@Override\n    protected void init() throws IOException {\n        _selector = Selector.open();\n        Task task = null;\n\n        try (SocketChannel sch = SocketChannel.open()) {\n            sch.configureBlocking(true);\n            s_logger.info(\"Connecting to \" + _host + \":\" + _port);\n\n            if (_bindAddress != null) {\n                s_logger.info(\"Binding outbound interface at \" + _bindAddress);\n\n                InetSocketAddress bindAddr = new InetSocketAddress(_bindAddress, 0);\n                sch.socket().bind(bindAddr);\n            }\n\n            InetSocketAddress peerAddr = new InetSocketAddress(_host, _port);\n            sch.connect(peerAddr);\n\n            SSLEngine sslEngine = null;\n            // Begin SSL handshake in BLOCKING mode\n            sch.configureBlocking(true);\n\n            SSLContext sslContext = Link.initSSLContext(true);\n            sslEngine = sslContext.createSSLEngine(_host, _port);\n            sslEngine.setUseClientMode(true);\n\n            Link.doHandshake(sch, sslEngine, true);\n            s_logger.info(\"SSL: Handshake done\");\n            s_logger.info(\"Connected to \" + _host + \":\" + _port);\n\n\n            sch.configureBlocking(false);\n            Link link = new Link(peerAddr, this);\n            link.setSSLEngine(sslEngine);\n            SelectionKey key = sch.register(_selector, SelectionKey.OP_READ);\n            link.setKey(key);\n            key.attach(link);\n            // Notice we've already connected due to the handshake, so let's get the\n            // remaining task done\n            task = _factory.create(Task.Type.CONNECT, link, null);\n        } catch (GeneralSecurityException e) {\n            throw new IOException(\"Failed to initialise security\", e);\n        } finally {\n            _selector.close();\n        }\n        _executor.execute(task);\n    }","commit_id":"de26a7228e1298d0a5d4d2c0bf00c924a99cd505","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    protected void init() throws IOException {\n        _selector = SelectorProvider.provider().openSelector();\n\n        ServerSocketChannel ssc = ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n\n        _localAddr = new InetSocketAddress(_port);\n        ssc.socket().bind(_localAddr);\n\n        ssc.register(_selector, SelectionKey.OP_ACCEPT, null);\n\n        s_logger.info(\"NioConnection started and listening on \" + _localAddr.toString());\n    }","id":102663,"modified_method":"@Override\n    protected void init() throws IOException {\n        _selector = SelectorProvider.provider().openSelector();\n\n        _serverSocket = ServerSocketChannel.open();\n        _serverSocket.configureBlocking(false);\n\n        _localAddr = new InetSocketAddress(_port);\n        _serverSocket.socket().bind(_localAddr);\n\n        _serverSocket.register(_selector, SelectionKey.OP_ACCEPT, null);\n\n        s_logger.info(\"NioConnection started and listening on \" + _localAddr.toString());\n    }","commit_id":"de26a7228e1298d0a5d4d2c0bf00c924a99cd505","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean matches(Exchange exchange) {\n        return exchange.getContext().resolveLanguage(\"simple\").createPredicate(text).matches(exchange);\n    }","id":102664,"modified_method":"public boolean matches(Exchange exchange) {\n        if (predicate == null) {\n            predicate = exchange.getContext().resolveLanguage(\"simple\").createPredicate(text);\n        }\n        return predicate.matches(exchange);\n    }","commit_id":"65decee64fb8ffec9f436ec16683b39f05090fe7","url":"https://github.com/apache/camel"},{"original_method":"public <T> T evaluate(Exchange exchange, Class<T> type) {\n        return createExpression(exchange).evaluate(exchange, type);\n    }","id":102665,"modified_method":"public <T> T evaluate(Exchange exchange, Class<T> type) {\n        if (expression == null) {\n            expression = createExpression(exchange);\n        }\n        return expression.evaluate(exchange, type);\n    }","commit_id":"65decee64fb8ffec9f436ec16683b39f05090fe7","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void cancelRequest(MemberCandidacy request) throws WikiUserManagerException\n    {\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(request.getWikiId());\n\n        // Get the candidacy object\n        DocumentReference candidateClassReference = new DocumentReference(request.getWikiId(), CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        BaseObject object = groupDoc.getXObject(candidateClassReference, request.getId());\n\n        // Remove the candidacy, if any\n        if (object != null) {\n            groupDoc.removeXObject(object);\n            saveGroupDocument(groupDoc, String.format(\"User [%s] has cancel her join request.\", request.getUserId()));\n        }\n    }","id":102666,"modified_method":"@Override\n    public void cancelCandidacy(MemberCandidacy candidacy) throws WikiUserManagerException\n    {\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(candidacy.getWikiId());\n\n        // Get the candidacy object\n        DocumentReference candidateClassReference = new DocumentReference(candidacy.getWikiId(), CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        BaseObject object = groupDoc.getXObject(candidateClassReference, candidacy.getId());\n\n        // Remove the candidacy, if any\n        if (object != null) {\n            groupDoc.removeXObject(object);\n            saveGroupDocument(groupDoc, String.format(\"Candidacy [%d] is canceled.\", candidacy.getId()));\n        }\n    }","commit_id":"67d90fc4d970631e9eda227565991a1f83edab8f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Leave a wiki.\n     *\n     * @param userId userId to remove from the wiki\n     * @param wikiId id of the wiki\n     * @return true if it succeed\n     */\n    public boolean leave(String userId, String wikiId)\n    {\n        // Check if the current user is userId\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference userReference = documentReferenceResolver.resolve(userId);\n        if (!xcontext.getUserReference().equals(userReference)) {\n            //TODO\n            return false;\n        }\n\n        // Leave the wiki\n        try {\n            wikiUserManager.leave(userId, wikiId);\n        } catch (WikiUserManagerException e) {\n            // TODO\n            return false;\n        }\n\n        return true;\n    }","id":102667,"modified_method":"/**\n     * Leave a wiki.\n     *\n     * @param userId userId to remove from the wiki\n     * @param wikiId id of the wiki\n     * @return true if it succeed\n     */\n    public boolean leave(String userId, String wikiId)\n    {\n        // Check if the current user is userId\n        XWikiContext xcontext = xcontextProvider.get();\n        String currentUser = entityReferenceSerializer.serialize(xcontext.getUserReference());\n        if (!userId.equals(currentUser)) {\n            //TODO\n            return false;\n        }\n\n        // Leave the wiki\n        try {\n            wikiUserManager.leave(userId, wikiId);\n        } catch (WikiUserManagerException e) {\n            // TODO\n            return false;\n        }\n\n        return true;\n    }","commit_id":"67d90fc4d970631e9eda227565991a1f83edab8f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Join a wiki.\n     *\n     * @param userId userId to add to the wiki\n     * @param wikiId id of the wiki\n     * @return true if it succeed\n     */\n    public boolean join(String userId, String wikiId)\n    {\n        // Check if the current user is userId\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference userReference = documentReferenceResolver.resolve(userId);\n        if (!xcontext.getUserReference().equals(userReference)) {\n            //TODO\n            return false;\n        }\n\n        try {\n            wikiUserManager.join(userId, wikiId);\n        } catch (WikiUserManagerException e) {\n            // TODO\n            return false;\n        }\n        return true;\n    }","id":102668,"modified_method":"/**\n     * Join a wiki.\n     *\n     * @param userId userId to add to the wiki\n     * @param wikiId id of the wiki\n     * @return true if it succeed\n     */\n    public boolean join(String userId, String wikiId)\n    {\n        // Check if the current user is userId\n        XWikiContext xcontext = xcontextProvider.get();\n        String currentUser = entityReferenceSerializer.serialize(xcontext.getUserReference());\n        if (!userId.equals(currentUser)) {\n            //TODO\n            return false;\n        }\n\n        try {\n            wikiUserManager.join(userId, wikiId);\n        } catch (WikiUserManagerException e) {\n            // TODO\n            return false;\n        }\n        return true;\n    }","commit_id":"67d90fc4d970631e9eda227565991a1f83edab8f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Accept the request to join the wiki.\n     *\n     * @param request request to accept\n     * @param message message about the acceptance\n     * @param privateComment private comment that only the administrator can see\n     * @return true if it succeed\n     */\n    public boolean acceptRequest(MemberCandidacy request, String message, String privateComment)\n    {\n        // Check if the current user is userId\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference userReference = documentReferenceResolver.resolve(request.getUserId());\n        if (!xcontext.getUserReference().equals(userReference)) {\n            //TODO\n            return false;\n        }\n        try {\n            wikiUserManager.acceptRequest(request, message, privateComment);\n        } catch (WikiUserManagerException e) {\n            // TODO\n            return false;\n        }\n\n        return true;\n    }","id":102669,"modified_method":"/**\n     * Accept the request to join the wiki.\n     *\n     * @param request request to accept\n     * @param message message about the acceptance\n     * @param privateComment private comment that only the administrator can see\n     * @return true if it succeed\n     */\n    public boolean acceptRequest(MemberCandidacy request, String message, String privateComment)\n    {\n        // Check if the current user is userId\n        XWikiContext xcontext = xcontextProvider.get();\n        String currentUser = entityReferenceSerializer.serialize(xcontext.getUserReference());\n        if (!authorizationManager.hasAccess(Right.ADMIN, xcontext.getUserReference(),\n                new WikiReference(request.getWikiId()))) {\n            return false;\n        }\n        try {\n            wikiUserManager.acceptRequest(request, message, privateComment);\n        } catch (WikiUserManagerException e) {\n            // TODO\n            return false;\n        }\n\n        return true;\n    }","commit_id":"67d90fc4d970631e9eda227565991a1f83edab8f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private boolean canSeeCandidacy(MemberCandidacy candidacy)\n    {\n        XWikiContext xcontext = xcontextProvider.get();\n\n        // If the user is concerned by the candidacy\n        DocumentReference userReference = documentReferenceResolver.resolve(candidacy.getUserId());\n        if (userReference.equals(xcontext.getUserReference())) {\n            // Hide the admin private comment\n            candidacy.setAdminPrivateComment(null);\n            return true;\n        }\n\n        // Check if the user is an admin\n        return authorizationManager.hasAccess(Right.ADMIN, xcontext.getUserReference(),\n                new WikiReference(candidacy.getWikiId()));\n    }","id":102670,"modified_method":"private boolean canSeeCandidacy(MemberCandidacy candidacy)\n    {\n        XWikiContext xcontext = xcontextProvider.get();\n\n        // If the user is concerned by the candidacy\n        String currentUser = entityReferenceSerializer.serialize(xcontext.getUserReference());\n        if (candidacy.getUserId().equals(currentUser)) {\n            // Hide the admin private comment\n            candidacy.setAdminPrivateComment(null);\n            return true;\n        }\n\n        // Check if the user is an admin\n        return authorizationManager.hasAccess(Right.ADMIN, xcontext.getUserReference(),\n                new WikiReference(candidacy.getWikiId()));\n    }","commit_id":"67d90fc4d970631e9eda227565991a1f83edab8f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return the membership type of the current wiki\n     */\n    public MembershipType getMembershipType()\n    {\n        return getMembershipType(wikiDescriptorManager.getMainWikiId());\n    }","id":102671,"modified_method":"/**\n     * @return the membership type of the current wiki\n     */\n    public MembershipType getMembershipType()\n    {\n        return getMembershipType(wikiDescriptorManager.getCurrentWikiId());\n    }","commit_id":"67d90fc4d970631e9eda227565991a1f83edab8f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Refuse the request to join the wiki.\n     *\n     * @param request request to refuse\n     * @param message message about the refusal\n     * @param privateComment private comment that only the administrator can see\n     * @return true if it succeed\n     */\n    public boolean refuseRequest(MemberCandidacy request, String message, String privateComment)\n    {\n        // Check if the current user is userId\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference userReference = documentReferenceResolver.resolve(request.getUserId());\n        if (!xcontext.getUserReference().equals(userReference)) {\n            return false;\n        }\n        try {\n            wikiUserManager.refuseRequest(request, message, privateComment);\n        } catch (WikiUserManagerException e) {\n            // TODO\n            return false;\n        }\n\n        return true;\n    }","id":102672,"modified_method":"/**\n     * Refuse the request to join the wiki.\n     *\n     * @param request request to refuse\n     * @param message message about the refusal\n     * @param privateComment private comment that only the administrator can see\n     * @return true if it succeed\n     */\n    public boolean refuseRequest(MemberCandidacy request, String message, String privateComment)\n    {\n        // Check if the current user is admin\n        XWikiContext xcontext = xcontextProvider.get();\n        if (!authorizationManager.hasAccess(Right.ADMIN, xcontext.getUserReference(),\n                new WikiReference(request.getWikiId()))) {\n            return false;\n        }\n        try {\n            wikiUserManager.refuseRequest(request, message, privateComment);\n        } catch (WikiUserManagerException e) {\n            // TODO\n            return false;\n        }\n\n        return true;\n    }","commit_id":"67d90fc4d970631e9eda227565991a1f83edab8f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Cancel a join request.\n     *\n     * @param request Join request to cancel\n     * @return true if it succeed\n     */\n    public boolean cancelRequest(MemberCandidacy request)\n    {\n        // Check if the current user is userId\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference userReference = documentReferenceResolver.resolve(request.getUserId());\n        if (!xcontext.getUserReference().equals(userReference)) {\n            return false;\n        }\n        try {\n            wikiUserManager.cancelRequest(request);\n        } catch (WikiUserManagerException e) {\n            // TODO\n            return false;\n        }\n\n        return true;\n    }","id":102673,"modified_method":"/**\n     * Cancel a candidacy.\n     *\n     * @param candidacy Candidacy to cancel\n     * @return true if it succeed\n     */\n    public boolean cancelCandidacy(MemberCandidacy candidacy)\n    {\n        // Check if the current user is userId\n        XWikiContext xcontext = xcontextProvider.get();\n        String currentUser = entityReferenceSerializer.serialize(xcontext.getUserReference());\n        if (!candidacy.getUserId().equals(currentUser)) {\n            if (!authorizationManager.hasAccess(Right.ADMIN, xcontext.getUserReference(),\n                    new WikiReference(candidacy.getWikiId()))) {\n                return false;\n            }\n        }\n        try {\n            wikiUserManager.cancelCandidacy(candidacy);\n        } catch (WikiUserManagerException e) {\n            // TODO\n            return false;\n        }\n\n        return true;\n    }","commit_id":"67d90fc4d970631e9eda227565991a1f83edab8f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n   *\n   * Converts a constituency tree to the English basic, enhanced, or\n   * enhanced++ Universal dependencies representation, or an English basic\n   * Universal dependencies tree to the enhanced or enhanced++ representation.\n   * <p>\n   * Command-line options:<br>\n   * {@code -treeFile}: File with PTB-formatted constituency trees<br>\n   * {@code -conlluFile}: File with basic dependency trees in CoNLL-U format<br>\n   * {@code -outputRepresentation}: \"basic\" (default), \"enhanced\", or \"enhanced++\"\n   *\n   */\n  public static void main(String args[]) {\n    Properties props = StringUtils.argsToProperties(args);\n\n    String treeFileName = props.getProperty(\"treeFile\");\n    String conlluFileName = props.getProperty(\"conlluFile\");\n    String outputRepresentation = props.getProperty(\"outputRepresentation\", \"basic\");\n\n\n    Iterator<SemanticGraph> sgIterator = null;\n\n    if (treeFileName != null) {\n      MemoryTreebank tb = new MemoryTreebank(new NPTmpRetainingTreeNormalizer(0, false, 1, false));\n      tb.loadPath(treeFileName);\n      Iterator<Tree> treeIterator = tb.iterator();\n      sgIterator = new TreeToSemanticGraphIterator(treeIterator);\n    } else if (conlluFileName != null) {\n      CoNLLUDocumentReader reader = new CoNLLUDocumentReader();\n      try {\n        sgIterator = reader.getIterator(IOUtils.readerFromString(conlluFileName));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      System.err.println(\"No input file specified!\");\n      System.err.println(\"\");\n      System.err.printf(\"Usage: java %s [-treeFile trees.tree | -conlluFile deptrees.conllu]\"\n          + \" [-outputRepresentation basic|enhanced|enhanced++ (default: basic)]%n\",\n          UniversalDependenciesConverter.class.getCanonicalName());\n      return;\n    }\n\n    CoNLLUDocumentWriter writer = new CoNLLUDocumentWriter();\n\n    while (sgIterator.hasNext()) {\n      SemanticGraph sg = sgIterator.next();\n\n      if (treeFileName != null) {\n        //add UPOS tags\n        Tree tree = ((TreeToSemanticGraphIterator) sgIterator).getCurrentTree();\n        Tree uposTree = UniversalPOSMapper.mapTree(tree);\n        List<Label> uposLabels = uposTree.preTerminalYield();\n        for (IndexedWord token: sg.vertexListSorted()) {\n          int idx = token.index() - 1;\n          String uposTag = uposLabels.get(idx).value();\n          token.set(CoreAnnotations.CoarseTagAnnotation.class, uposTag);\n        }\n      }\n\n     if (outputRepresentation.equalsIgnoreCase(\"enhanced\")) {\n        sg = convertBasicToEnhanced(sg);\n      } else if (outputRepresentation.equalsIgnoreCase(\"enhanced++\")) {\n        sg = convertBasicToEnhancedPlusPlus(sg);\n      }\n      System.out.println(writer.printSemanticGraph(sg));\n\n    }\n\n  }","id":102674,"modified_method":"/**\n   *\n   * Converts a constituency tree to the English basic, enhanced, or\n   * enhanced++ Universal dependencies representation, or an English basic\n   * Universal dependencies tree to the enhanced or enhanced++ representation.\n   * <p>\n   * Command-line options:<br>\n   * {@code -treeFile}: File with PTB-formatted constituency trees<br>\n   * {@code -conlluFile}: File with basic dependency trees in CoNLL-U format<br>\n   * {@code -outputRepresentation}: \"basic\" (default), \"enhanced\", or \"enhanced++\"\n   *\n   */\n  public static void main(String args[]) {\n    Properties props = StringUtils.argsToProperties(args);\n\n    String treeFileName = props.getProperty(\"treeFile\");\n    String conlluFileName = props.getProperty(\"conlluFile\");\n    String outputRepresentation = props.getProperty(\"outputRepresentation\", \"basic\");\n\n\n    Iterator<SemanticGraph> sgIterator = null;\n\n    if (treeFileName != null) {\n      MemoryTreebank tb = new MemoryTreebank(new NPTmpRetainingTreeNormalizer(0, false, 1, false));\n      tb.loadPath(treeFileName);\n      Iterator<Tree> treeIterator = tb.iterator();\n      sgIterator = new TreeToSemanticGraphIterator(treeIterator);\n    } else if (conlluFileName != null) {\n      CoNLLUDocumentReader reader = new CoNLLUDocumentReader();\n      try {\n        sgIterator = reader.getIterator(IOUtils.readerFromString(conlluFileName));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      System.err.println(\"No input file specified!\");\n      System.err.println(\"\");\n      System.err.printf(\"Usage: java %s [-treeFile trees.tree | -conlluFile deptrees.conllu]\"\n          + \" [-outputRepresentation basic|enhanced|enhanced++ (default: basic)]%n\",\n          UniversalDependenciesConverter.class.getCanonicalName());\n      return;\n    }\n\n    CoNLLUDocumentWriter writer = new CoNLLUDocumentWriter();\n\n    while (sgIterator.hasNext()) {\n      SemanticGraph sg = sgIterator.next();\n\n\n      if (treeFileName != null) {\n        //add UPOS tags\n        Tree tree = ((TreeToSemanticGraphIterator) sgIterator).getCurrentTree();\n        Tree uposTree = UniversalPOSMapper.mapTree(tree);\n        List<Label> uposLabels = uposTree.preTerminalYield();\n        for (IndexedWord token: sg.vertexListSorted()) {\n          int idx = token.index() - 1;\n          String uposTag = uposLabels.get(idx).value();\n          token.set(CoreAnnotations.CoarseTagAnnotation.class, uposTag);\n        }\n      } else {\n        addLemmata(sg);\n        if (USE_NAME) {\n          addNERTags(sg);\n        }\n      }\n\n\n\n\n     if (outputRepresentation.equalsIgnoreCase(\"enhanced\")) {\n        sg = convertBasicToEnhanced(sg);\n      } else if (outputRepresentation.equalsIgnoreCase(\"enhanced++\")) {\n        sg = convertBasicToEnhancedPlusPlus(sg);\n      }\n      System.out.print(writer.printSemanticGraph(sg));\n\n    }\n\n  }","commit_id":"8dfb99dc8152df0a258f3f88b104888935570659","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static SemanticGraph convertTreeToBasic(Tree tree) {\n    SemanticGraph sg = SemanticGraphFactory.makeFromTree(tree, SemanticGraphFactory.Mode.BASIC,\n        GrammaticalStructure.Extras.NONE, false, null, false, true);\n    return sg;\n  }","id":102675,"modified_method":"private static SemanticGraph convertTreeToBasic(Tree tree) {\n    addLemmata(tree);\n    addNERTags(tree);\n    SemanticGraph sg = SemanticGraphFactory.makeFromTree(tree, SemanticGraphFactory.Mode.BASIC,\n        GrammaticalStructure.Extras.NONE, false, null, false, true);\n\n    addLemmata(sg);\n\n    if (USE_NAME) {\n      addNERTags(sg);\n    }\n    return sg;\n  }","commit_id":"8dfb99dc8152df0a258f3f88b104888935570659","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static void processNamesHelper(SemanticGraph sg, IndexedWord oldHead, List<IndexedWord> nameParts) {\n\n    if (nameParts.size() < 1) {\n      // if the named entity only spans one token, change compound relations\n      // to nmod relations to get the right structure for NPs with additional modifiers\n      // such as \"Mrs. Clinton\".\n      Set<IndexedWord> children = new HashSet<>(sg.getChildren(oldHead));\n      for (IndexedWord child : children) {\n        SemanticGraphEdge oldEdge = sg.getEdge(oldHead, child);\n        if (oldEdge.getRelation() == UniversalEnglishGrammaticalRelations.COMPOUND_MODIFIER) {\n          sg.addEdge(oldHead, child, UniversalEnglishGrammaticalRelations.NOMINAL_MODIFIER,\n              oldEdge.getWeight(), oldEdge.isExtra());\n          sg.removeEdge(oldEdge);\n        }\n      }\n      return;\n    }\n\n    // sort nameParts\n    Collections.sort(nameParts);\n\n    // check whether {nameParts[0], ..., nameParts[n], oldHead} are a contiguous NP\n    for (int i = nameParts.get(0).index(), end = oldHead.index(); i < end; i++) {\n      IndexedWord node = sg.getNodeByIndexSafe(i);\n      if (node == null) {\n        return;\n      }\n      if ( ! nameParts.contains(node) && PUNCT_TAG_FILTER.test(node.tag())) {\n        // not in nameParts and not a punctuation mark => not a contiguous NP\n        return;\n      }\n    }\n\n\n    IndexedWord gov = sg.getParent(oldHead);\n    IndexedWord newHead = nameParts.get(0);\n    Set<IndexedWord> children = new HashSet<>(sg.getChildren(oldHead));\n\n    //change structure and relations\n    for (IndexedWord child : children) {\n      if (child == newHead) {\n        // make the leftmost word the new head\n        SemanticGraphEdge oldEdge = sg.getEdge(gov, oldHead);\n        sg.addEdge(gov, newHead, oldEdge.getRelation(), oldEdge.getWeight(), oldEdge.isExtra());\n        sg.removeEdge(oldEdge);\n\n        // swap direction of relation between old head and new head and change it to name relation.\n        oldEdge = sg.getEdge(oldHead, newHead);\n        sg.addEdge(newHead, oldHead, UniversalEnglishGrammaticalRelations.NAME_MODIFIER, oldEdge.getWeight(), oldEdge.isExtra());\n        sg.removeEdge(oldEdge);\n      } else  if (nameParts.contains(child)) {\n        // remove relation between the old head and part of the name\n        // and introduce new relation between new head and part of the name\n        SemanticGraphEdge oldEdge = sg.getEdge(oldHead, child);\n        sg.addEdge(newHead, child, UniversalEnglishGrammaticalRelations.NAME_MODIFIER, oldEdge.getWeight(), oldEdge.isExtra());\n        sg.removeEdge(oldEdge);\n      } else {\n        // attach word to new head\n        SemanticGraphEdge oldEdge = sg.getEdge(oldHead, child);\n        //if not the entire compound is part of a named entity, attach the other tokens via an nmod relation\n        GrammaticalRelation reln = oldEdge.getRelation() == UniversalEnglishGrammaticalRelations.COMPOUND_MODIFIER ?\n            UniversalEnglishGrammaticalRelations.NOMINAL_MODIFIER : oldEdge.getRelation();\n        sg.addEdge(newHead, child, reln, oldEdge.getWeight(), oldEdge.isExtra());\n        sg.removeEdge(oldEdge);\n      }\n    }\n  }","id":102676,"modified_method":"private static void processNamesHelper(SemanticGraph sg, IndexedWord oldHead, List<IndexedWord> nameParts) {\n\n    if (nameParts.size() < 1) {\n      // if the named entity only spans one token, change compound relations\n      // to nmod relations to get the right structure for NPs with additional modifiers\n      // such as \"Mrs. Clinton\".\n      Set<IndexedWord> children = new HashSet<>(sg.getChildren(oldHead));\n      for (IndexedWord child : children) {\n        SemanticGraphEdge oldEdge = sg.getEdge(oldHead, child);\n        if (oldEdge.getRelation() == UniversalEnglishGrammaticalRelations.COMPOUND_MODIFIER) {\n          sg.addEdge(oldHead, child, UniversalEnglishGrammaticalRelations.NOMINAL_MODIFIER,\n              oldEdge.getWeight(), oldEdge.isExtra());\n          sg.removeEdge(oldEdge);\n        }\n      }\n      return;\n    }\n\n    // sort nameParts\n    Collections.sort(nameParts);\n\n    // check whether {nameParts[0], ..., nameParts[n], oldHead} are a contiguous NP\n    for (int i = nameParts.get(0).index(), end = oldHead.index(); i < end; i++) {\n      IndexedWord node = sg.getNodeByIndexSafe(i);\n      if (node == null) {\n        return;\n      }\n      if ( ! nameParts.contains(node) && PUNCT_TAG_FILTER.test(node.tag())) {\n        // not in nameParts and not a punctuation mark => not a contiguous NP\n        return;\n      }\n    }\n\n\n    IndexedWord gov = sg.getParent(oldHead);\n    if (gov == null && ! sg.getRoots().contains(oldHead)) {\n      return;\n    }\n    IndexedWord newHead = nameParts.get(0);\n    Set<IndexedWord> children = new HashSet<>(sg.getChildren(oldHead));\n\n    //change structure and relations\n    for (IndexedWord child : children) {\n      if (child == newHead) {\n        // make the leftmost word the new head\n        if (gov == null) {\n          sg.getRoots().add(newHead);\n          sg.getRoots().remove(oldHead);\n        } else {\n          SemanticGraphEdge oldEdge = sg.getEdge(gov, oldHead);\n          sg.addEdge(gov, newHead, oldEdge.getRelation(), oldEdge.getWeight(), oldEdge.isExtra());\n          sg.removeEdge(oldEdge);\n        }\n        // swap direction of relation between old head and new head and change it to name relation.\n        SemanticGraphEdge oldEdge = sg.getEdge(oldHead, newHead);\n        sg.addEdge(newHead, oldHead, UniversalEnglishGrammaticalRelations.NAME_MODIFIER, oldEdge.getWeight(), oldEdge.isExtra());\n        sg.removeEdge(oldEdge);\n      } else  if (nameParts.contains(child)) {\n        // remove relation between the old head and part of the name\n        // and introduce new relation between new head and part of the name\n        SemanticGraphEdge oldEdge = sg.getEdge(oldHead, child);\n        sg.addEdge(newHead, child, UniversalEnglishGrammaticalRelations.NAME_MODIFIER, oldEdge.getWeight(), oldEdge.isExtra());\n        sg.removeEdge(oldEdge);\n      } else {\n        // attach word to new head\n        SemanticGraphEdge oldEdge = sg.getEdge(oldHead, child);\n        //if not the entire compound is part of a named entity, attach the other tokens via an nmod relation\n        GrammaticalRelation reln = oldEdge.getRelation() == UniversalEnglishGrammaticalRelations.COMPOUND_MODIFIER ?\n            UniversalEnglishGrammaticalRelations.NOMINAL_MODIFIER : oldEdge.getRelation();\n        sg.addEdge(newHead, child, reln, oldEdge.getWeight(), oldEdge.isExtra());\n        sg.removeEdge(oldEdge);\n      }\n    }\n  }","commit_id":"8dfb99dc8152df0a258f3f88b104888935570659","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public boolean isSubtype(SNode subType, SNode superType, boolean isWeak) {\n    if (TypesUtil.isVariable(subType)) return false;\n    if (TypesUtil.isVariable(superType)) return false;\n\n    LanguageScope languageScope = LanguageScopeFactory.getInstance().getLanguageScope(\n      subType.getLanguage().getDependenciesManager().getAllExtendedLanguages(),\n      superType.getLanguage().getDependenciesManager().getAllExtendedLanguages());\n    try{\n      LanguageScope.pushCurrent(languageScope, this);\n      SubtypingResolver subtypingResolver = new SubtypingResolver(isWeak);\n      return subtypingResolver.calcIsSubType(subType, superType);\n    }\n    finally {\n      LanguageScope.popCurrent(languageScope, this);\n    }\n  }","id":102677,"modified_method":"@Override\n  public boolean isSubtype(final SNode subType, final SNode superType, final boolean isWeak) {\n    if (TypesUtil.isVariable(subType)) return false;\n    if (TypesUtil.isVariable(superType)) return false;\n\n    return LanguageScopeExecutor.execWithTwoLanguageScope(\n      subType != null ? subType.getLanguage() : null,\n      superType != null ? superType.getLanguage() : null,\n      new Computable<Boolean>() {\n        @Override\n        public Boolean compute() {\n          SubtypingResolver subtypingResolver = new SubtypingResolver(isWeak);\n          return subtypingResolver.calcIsSubType(subType, superType);\n        }\n      });\n  }","commit_id":"f8cd959f9329bd847f8d2211ea1bc09ed4be428a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void collectImmediateSuperTypes(final SNode term, boolean isWeak, StructuralNodeSet result, final TypeCheckingContext context) {\n    if (term == null) {\n      return;\n    }\n    LanguageScope languageScope = LanguageScope.getGlobal();\n//      LanguageScopeFactory.getInstance().getLanguageScope(term.getLanguage().getDependenciesManager().getAllExtendedLanguages());\n    try{\n      LanguageScope.pushCurrent(languageScope, this);\n      List<Pair<SubtypingRule_Runtime, IsApplicableStatus>> subtypingRule_runtimes = myTypeChecker.getRulesManager().getSubtypingRules(term, isWeak);\n      if (subtypingRule_runtimes != null) {\n        for (final Pair<SubtypingRule_Runtime, IsApplicableStatus> subtypingRule : subtypingRule_runtimes) {\n          List<SNode> superTypes = subtypingRule.o1.getSubOrSuperTypes(term, context, subtypingRule.o2);\n          if (superTypes != null) {\n            result.addAll(superTypes);\n          }\n        }\n      }\n    }\n    finally {\n      LanguageScope.popCurrent(languageScope, this);\n    }\n  }","id":102678,"modified_method":"@Override\n  public void collectImmediateSuperTypes(final SNode term, final boolean isWeak, final StructuralNodeSet result, final TypeCheckingContext context) {\n    if (term == null) {\n      return;\n    }\n\n    // use global language scope as the context is unknown\n    LanguageScopeExecutor.execWithLanguageScope(null, new Computable<Object>() {\n      @Override\n      public Object compute() {\n        List<Pair<SubtypingRule_Runtime, IsApplicableStatus>> subtypingRule_runtimes = myTypeChecker.getRulesManager().getSubtypingRules(term, isWeak);\n        if (subtypingRule_runtimes != null) {\n          for (final Pair<SubtypingRule_Runtime, IsApplicableStatus> subtypingRule : subtypingRule_runtimes) {\n            List<SNode> superTypes = subtypingRule.o1.getSubOrSuperTypes(term, context, subtypingRule.o2);\n            if (superTypes != null) {\n              result.addAll(superTypes);\n            }\n          }\n        }\n        return result;\n      }\n    });\n  }","commit_id":"f8cd959f9329bd847f8d2211ea1bc09ed4be428a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean isSubTypeByReplacementRules(SNode subType, SNode superType, boolean isWeak) {\n    LanguageScope languageScope = LanguageScopeFactory.getInstance().getLanguageScope(\n      subType.getLanguage().getDependenciesManager().getAllExtendedLanguages(),\n      superType.getLanguage().getDependenciesManager().getAllExtendedLanguages());\n    try{\n      LanguageScope.pushCurrent(languageScope, this);\n      for (Pair<InequationReplacementRule_Runtime, IsApplicable2Status> rule : myTypeChecker.getRulesManager().getReplacementRules(subType, superType)) {\n        if (rule.o1.checkInequation(subType, superType, new EquationInfo(null, null), rule.o2, isWeak)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    finally {\n      LanguageScope.popCurrent(languageScope, this);\n    }\n  }","id":102679,"modified_method":"@Override\n  public boolean isSubTypeByReplacementRules(final SNode subType, final SNode superType, final boolean isWeak) {\n    return LanguageScopeExecutor.execWithTwoLanguageScope(\n      subType != null ? subType.getLanguage() : null,\n      superType != null ? superType.getLanguage() : null,\n      new Computable<Boolean>() {\n        @Override\n        public Boolean compute() {\n          for (Pair<InequationReplacementRule_Runtime, IsApplicable2Status> rule : myTypeChecker.getRulesManager().getReplacementRules(subType, superType)) {\n            if (rule.o1.checkInequation(subType, superType, new EquationInfo(null, null), rule.o2, isWeak)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      });\n  }","commit_id":"f8cd959f9329bd847f8d2211ea1bc09ed4be428a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TypeCheckingContextNew(SNode rootNode, TypeChecker typeChecker) {\n    myState = new State(this);\n    myRootNode = rootNode;\n    myLangScope = LanguageScopeFactory.getInstance().getLanguageScope(\n      rootNode.getModel().getModelDepsManager().getAllImportedLanguages());\n    myNodeTypesComponent = new NodeTypesComponent(myRootNode, typeChecker, this);\n    myTypeChecker = typeChecker;\n  }","id":102680,"modified_method":"public TypeCheckingContextNew(SNode rootNode, TypeChecker typeChecker) {\n    myState = new State(this);\n    myRootNode = rootNode;\n    myNodeTypesComponent = new NodeTypesComponent(myRootNode, typeChecker, this);\n    myTypeChecker = typeChecker;\n  }","commit_id":"f8cd959f9329bd847f8d2211ea1bc09ed4be428a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void checkRoot(final boolean refreshTypes) {\n    synchronized (TYPECHECKING_LOCK) {\n      try {\n        LanguageScope.pushCurrent(myLangScope, this);\n        myNodeTypesComponent.computeTypes(refreshTypes);\n        myNodeTypesComponent.setCheckedTypesystem();\n      }\n      finally {\n        LanguageScope.popCurrent(myLangScope, this);\n      }\n    }\n  }","id":102681,"modified_method":"@Override\n  public void checkRoot(final boolean refreshTypes) {\n    synchronized (TYPECHECKING_LOCK) {\n      LanguageScopeExecutor.execWithModelScope(myRootNode.getModel(), new Computable<Object>() {\n        @Override\n        public Object compute() {\n          myNodeTypesComponent.computeTypes(refreshTypes);\n          myNodeTypesComponent.setCheckedTypesystem();\n          return null;\n        }\n      });\n    }\n  }","commit_id":"f8cd959f9329bd847f8d2211ea1bc09ed4be428a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TypeCheckingContextNew(SNode rootNode, TypeChecker typeChecker, boolean computeSingleType) {\n    myIsSingleTypeComputation = computeSingleType;\n    myState = new State(this);\n    myRootNode = rootNode;\n    myLangScope = LanguageScopeFactory.getInstance().getLanguageScope(\n      rootNode.getModel().getModelDepsManager().getAllImportedLanguages());\n    myNodeTypesComponent = new NodeTypesComponent(myRootNode, typeChecker, this);\n    myTypeChecker = typeChecker;\n  }","id":102682,"modified_method":"public TypeCheckingContextNew(SNode rootNode, TypeChecker typeChecker, boolean computeSingleType) {\n    myIsSingleTypeComputation = computeSingleType;\n    myState = new State(this);\n    myRootNode = rootNode;\n    myNodeTypesComponent = new NodeTypesComponent(myRootNode, typeChecker, this);\n    myTypeChecker = typeChecker;\n  }","commit_id":"f8cd959f9329bd847f8d2211ea1bc09ed4be428a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void initializeConnection() {\r\n    \ttry {\r\n\t    \tSystem.setProperty(\"hsqldb.cache_scale\", \"11\");\r\n\t\t\tSystem.setProperty(\"hsqldb.cache_size_scale\", \"12\");\r\n\t\t\tSystem.setProperty(\"hsqldb.default_table_type\", \"cached\");\r\n\t\t\t//Get a connection to the DB... and keep it\r\n\t\t\tthis.conn = DriverManager.getConnection(\"jdbc:hsqldb:\" + getDataDir() + \"/\" + db_file_name_prefix /* + \";shutdown=true\" */, \"sa\", \"\");\r\n\t\t\tResultSet rs = null;\r\n\t\t\ttry {\r\n\t        \trs = this.conn.getMetaData().getTables(null, null, TABLE_NAME, new String[] { \"TABLE\" });\r\n\t        \trs.last(); \r\n\t        \tif (rs.getRow() == 1) {\r\n\t\t            if (LOG.isDebugEnabled()) \r\n\t\t                LOG.debug(\"Opened GML index: \" + getDataDir() + \"/\" + db_file_name_prefix); \r\n\t\t        //Create the data structure if it doesn't exist\r\n\t        \t} else if (rs.getRow() == 0) {\r\n\t\t        \tStatement stmt = conn.createStatement();        \t\r\n\t\t        \t//Use CACHED table, not MEMORY one\r\n\t\t        \t//TODO : use hsqldb.default_table_type\t        \t\r\n\t\t        \tstmt.executeUpdate(\"CREATE TABLE \" + TABLE_NAME + \"(\" +\r\n\t\t        \t\t\t/*1*/ \"DOCUMENT_URI VARCHAR, \" +        \t\t\r\n\t\t        \t\t\t//TODO : use binary format ?\r\n\t\t        \t\t\t/*2*/ \"NODE_ID VARCHAR, \" +        \t\t\t\r\n\t\t        \t\t\t/*3*/ \"GEOMETRY_TYPE VARCHAR, \" +\r\n\t\t        \t\t\t/*4*/ \"SRS_NAME VARCHAR, \" +\r\n\t\t        \t\t\t/*5*/ \"WKT VARCHAR, \" +\r\n\t\t        \t\t\t//TODO : use binary format ?\r\n\t\t        \t\t\t/*6*/ \"BASE64_WKB VARCHAR, \" +\r\n\t\t        \t\t\t/*7*/ \"MINX DOUBLE, \" +\r\n\t\t        \t\t\t/*8*/ \"MAXX DOUBLE, \" +\r\n\t\t        \t\t\t/*9*/ \"MINY DOUBLE, \" +\r\n\t\t        \t\t\t/*10*/ \"MAXY DOUBLE, \" +\r\n\t\t        \t\t\t/*11*/ \"CENTROID_X DOUBLE, \" +\r\n\t\t        \t\t\t/*12*/ \"CENTROID_Y DOUBLE, \" +\r\n\t\t        \t\t\t/*13*/ \"AREA DOUBLE, \" +\r\n\t\t        \t\t\t//Boundary ?\r\n\t\t        \t\t\t/*14*/ \"EPSG4326_WKT VARCHAR, \" +\r\n\t\t        \t\t\t//TODO : use binary format ?\r\n\t\t        \t\t\t/*15*/ \"EPSG4326_BASE64_WKB VARCHAR, \" +\r\n\t\t        \t\t\t/*16*/ \"EPSG4326_MINX DOUBLE, \" +\r\n\t\t        \t\t\t/*17*/ \"EPSG4326_MAXX DOUBLE, \" +\r\n\t\t        \t\t\t/*18*/ \"EPSG4326_MINY DOUBLE, \" +\r\n\t\t        \t\t\t/*19*/ \"EPSG4326_MAXY DOUBLE, \" +\r\n\t\t        \t\t\t/*20*/ \"EPSG4326_CENTROID_X DOUBLE, \" +\r\n\t\t        \t\t\t/*21*/ \"EPSG4326_CENTROID_Y DOUBLE, \" +\r\n\t\t        \t\t\t/*22*/ \"EPSG4326_AREA DOUBLE, \" +\r\n\t\t        \t\t\t//Boundary ?\r\n\t\t        \t\t\t/*23*/ \"IS_CLOSED BOOLEAN, \" +\r\n\t\t        \t\t\t/*24*/ \"IS_SIMPLE BOOLEAN, \" +\r\n\t\t        \t\t\t/*25*/ \"IS_VALID BOOLEAN, \" +\r\n\t\t        \t\t\t//Enforce uniqueness\r\n\t\t        \t\t\t\"UNIQUE (\" +\r\n\t\t        \t\t\t\t\"DOCUMENT_URI, NODE_ID\" +\r\n\t\t        \t\t\t\")\" +\r\n\t\t        \t\t\")\"\r\n\t        \t\t);\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX DOCUMENT_URI ON \" + TABLE_NAME + \" (DOCUMENT_URI);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX NODE_ID ON \" + TABLE_NAME + \" (NODE_ID);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX GEOMETRY_TYPE ON \" + TABLE_NAME + \" (GEOMETRY_TYPE);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX SRS_NAME ON \" + TABLE_NAME + \" (SRS_NAME);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX EPSG4326_MINX ON \" + TABLE_NAME + \" (EPSG4326_MINX);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX EPSG4326_MAXX ON \" + TABLE_NAME + \" (EPSG4326_MAXX);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX EPSG4326_MINY ON \" + TABLE_NAME + \" (EPSG4326_MINY);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX EPSG4326_MAXY ON \" + TABLE_NAME + \" (EPSG4326_MAXY);\");        \t\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX EPSG4326_CENTROID_X ON \" + TABLE_NAME + \" (EPSG4326_CENTROID_X);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX EPSG4326_CENTROID_Y ON \" + TABLE_NAME + \" (EPSG4326_CENTROID_Y);\");\r\n\t\t        \t//AREA ?\r\n\t\t        \tstmt.close();        \t\r\n\t\t            if (LOG.isDebugEnabled()) \r\n\t\t                LOG.debug(\"Created GML index: \" + getDataDir() + \"/\" + db_file_name_prefix);  \r\n\t        \t} else {\r\n\t        \t\tthrow new SQLException(\"2 tables with the same name ?\"); \r\n\t        \t}\r\n\t\t\t} finally {\r\n\t\t\t\tif (rs != null)\r\n\t\t\t\t\trs.close();    \t\t\t\t\r\n\t    \t}        \r\n    \t} catch (SQLException e) {\r\n    \t\tLOG.error(e);\r\n    \t\tthis.conn = null;\r\n    \t}\r\n    }","id":102683,"modified_method":"private void initializeConnection() {\r\n    \ttry {\r\n\t    \tSystem.setProperty(\"hsqldb.cache_scale\", \"11\");\r\n\t\t\tSystem.setProperty(\"hsqldb.cache_size_scale\", \"12\");\r\n\t\t\tSystem.setProperty(\"hsqldb.default_table_type\", \"cached\");\r\n\t\t\t//Get a connection to the DB... and keep it\r\n\t\t\tthis.conn = DriverManager.getConnection(\"jdbc:hsqldb:\" + getDataDir() + \"/\" + db_file_name_prefix /* + \";shutdown=true\" */, \"sa\", \"\");\r\n\t\t\tResultSet rs = null;\r\n\t\t\ttry {\r\n\t        \trs = this.conn.getMetaData().getTables(null, null, TABLE_NAME, new String[] { \"TABLE\" });\r\n\t        \trs.last(); \r\n\t        \tif (rs.getRow() == 1) {\r\n\t\t            if (LOG.isDebugEnabled()) \r\n\t\t                LOG.debug(\"Opened GML index: \" + getDataDir() + \"/\" + db_file_name_prefix); \r\n\t\t        //Create the data structure if it doesn't exist\r\n\t        \t} else if (rs.getRow() == 0) {\r\n\t\t        \tStatement stmt = conn.createStatement();        \t\r\n\t\t        \t//Use CACHED table, not MEMORY one\r\n\t\t        \t//TODO : use hsqldb.default_table_type\t        \t\r\n\t\t        \tstmt.executeUpdate(\"CREATE TABLE \" + TABLE_NAME + \"(\" +\r\n\t\t        \t\t\t/*1*/ \"DOCUMENT_URI VARCHAR, \" +        \t\t\r\n\t\t        \t\t\t/*2*/ \"NODE_ID_UNITS INTEGER, \" + \r\n\t\t        \t\t\t/*3*/ \"NODE_ID BINARY, \" +        \t\t\t\r\n\t\t        \t\t\t/*4*/ \"GEOMETRY_TYPE VARCHAR, \" +\r\n\t\t        \t\t\t/*5*/ \"SRS_NAME VARCHAR, \" +\r\n\t\t        \t\t\t/*6*/ \"WKT VARCHAR, \" +\r\n\t\t        \t\t\t//TODO : use binary format ?\r\n\t\t        \t\t\t/*7*/ \"BASE64_WKB VARCHAR, \" +\r\n\t\t        \t\t\t/*8*/ \"MINX DOUBLE, \" +\r\n\t\t        \t\t\t/*9*/ \"MAXX DOUBLE, \" +\r\n\t\t        \t\t\t/*10*/ \"MINY DOUBLE, \" +\r\n\t\t        \t\t\t/*11*/ \"MAXY DOUBLE, \" +\r\n\t\t        \t\t\t/*12*/ \"CENTROID_X DOUBLE, \" +\r\n\t\t        \t\t\t/*13*/ \"CENTROID_Y DOUBLE, \" +\r\n\t\t        \t\t\t/*14*/ \"AREA DOUBLE, \" +\r\n\t\t        \t\t\t//Boundary ?\r\n\t\t        \t\t\t/*15*/ \"EPSG4326_WKT VARCHAR, \" +\r\n\t\t        \t\t\t//TODO : use binary format ?\r\n\t\t        \t\t\t/*16*/ \"EPSG4326_BASE64_WKB VARCHAR, \" +\r\n\t\t        \t\t\t/*17*/ \"EPSG4326_MINX DOUBLE, \" +\r\n\t\t        \t\t\t/*18*/ \"EPSG4326_MAXX DOUBLE, \" +\r\n\t\t        \t\t\t/*19*/ \"EPSG4326_MINY DOUBLE, \" +\r\n\t\t        \t\t\t/*20*/ \"EPSG4326_MAXY DOUBLE, \" +\r\n\t\t        \t\t\t/*21*/ \"EPSG4326_CENTROID_X DOUBLE, \" +\r\n\t\t        \t\t\t/*22*/ \"EPSG4326_CENTROID_Y DOUBLE, \" +\r\n\t\t        \t\t\t/*23*/ \"EPSG4326_AREA DOUBLE, \" +\r\n\t\t        \t\t\t//Boundary ?\r\n\t\t        \t\t\t/*24*/ \"IS_CLOSED BOOLEAN, \" +\r\n\t\t        \t\t\t/*25*/ \"IS_SIMPLE BOOLEAN, \" +\r\n\t\t        \t\t\t/*26*/ \"IS_VALID BOOLEAN, \" +\r\n\t\t        \t\t\t//Enforce uniqueness\r\n\t\t        \t\t\t\"UNIQUE (\" +\r\n\t\t        \t\t\t\t\"DOCUMENT_URI, NODE_ID\" +\r\n\t\t        \t\t\t\")\" +\r\n\t\t        \t\t\")\"\r\n\t        \t\t);\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX DOCUMENT_URI ON \" + TABLE_NAME + \" (DOCUMENT_URI);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX NODE_ID ON \" + TABLE_NAME + \" (NODE_ID);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX GEOMETRY_TYPE ON \" + TABLE_NAME + \" (GEOMETRY_TYPE);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX SRS_NAME ON \" + TABLE_NAME + \" (SRS_NAME);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX EPSG4326_MINX ON \" + TABLE_NAME + \" (EPSG4326_MINX);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX EPSG4326_MAXX ON \" + TABLE_NAME + \" (EPSG4326_MAXX);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX EPSG4326_MINY ON \" + TABLE_NAME + \" (EPSG4326_MINY);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX EPSG4326_MAXY ON \" + TABLE_NAME + \" (EPSG4326_MAXY);\");        \t\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX EPSG4326_CENTROID_X ON \" + TABLE_NAME + \" (EPSG4326_CENTROID_X);\");\r\n\t\t        \tstmt.executeUpdate(\"CREATE INDEX EPSG4326_CENTROID_Y ON \" + TABLE_NAME + \" (EPSG4326_CENTROID_Y);\");\r\n\t\t        \t//AREA ?\r\n\t\t        \tstmt.close();        \t\r\n\t\t            if (LOG.isDebugEnabled()) \r\n\t\t                LOG.debug(\"Created GML index: \" + getDataDir() + \"/\" + db_file_name_prefix);  \r\n\t        \t} else {\r\n\t        \t\tthrow new SQLException(\"2 tables with the same name ?\"); \r\n\t        \t}\r\n\t\t\t} finally {\r\n\t\t\t\tif (rs != null)\r\n\t\t\t\t\trs.close();    \t\t\t\t\r\n\t    \t}        \r\n    \t} catch (SQLException e) {\r\n    \t\tLOG.error(e);\r\n    \t\tthis.conn = null;\r\n    \t}\r\n    }","commit_id":"19574f6abae255c05f0d2b542ef04bdd075b3d4a","url":"https://github.com/eXist-db/exist"},{"original_method":"protected AtomicValue getGeometricPropertyForNode(DBBroker broker, NodeProxy p, Connection conn, String propertyName) throws SQLException, XPathException {\r\n        PreparedStatement ps = conn.prepareStatement(\r\n    \t\t\"SELECT \" + propertyName + \r\n    \t\t\" FROM \" + GMLHSQLIndex.TABLE_NAME + \r\n    \t\t\" WHERE DOCUMENT_URI = ? AND NODE_ID = ?;\"\r\n    \t);\r\n        ps.setString(1, p.getDocument().getURI().toString());\r\n    \tps.setString(2, p.getNodeId().toString());   \r\n    \tResultSet rs = null;    \t\r\n    \ttry {\r\n    \t\trs = ps.executeQuery();\r\n    \t\tif (!rs.next())\r\n    \t\t\t//Nothing returned\r\n    \t\t\treturn null;\r\n    \t\tAtomicValue result = null;\r\n    \t\tif (rs.getMetaData().getColumnClassName(1).equals(Boolean.class.getName())) {\r\n    \t\t\tresult = new BooleanValue(rs.getBoolean(1));\r\n    \t\t} else if (rs.getMetaData().getColumnClassName(1).equals(Double.class.getName())) {\r\n    \t\t\tresult = new DoubleValue(rs.getDouble(1));\r\n    \t\t} else if (rs.getMetaData().getColumnClassName(1).equals(String.class.getName())) {\r\n    \t\t\tif (\"WKB\".equals(propertyName) || \"EPSG4326_WKB\".equals(propertyName))\r\n    \t\t\t\tresult = new Base64Binary(rs.getString(1));\r\n    \t\t\telse    \t\t\t\t\r\n    \t\t\t\tresult = new StringValue(rs.getString(1));\r\n    \t\t} else \r\n    \t\t\tthrow new SQLException(\"Unable to make an atomic value from '\" + rs.getMetaData().getColumnClassName(1) + \"'\");\t\t\r\n        \tif (rs.next()) {   \t\r\n    \t\t\t//Should be impossible    \t\t\r\n    \t\t\tthrow new SQLException(\"More than one geometry for node \" + p);\r\n    \t\t}\r\n        \treturn result;    \r\n    \t} finally {   \r\n    \t\tif (rs != null)\r\n    \t\t\trs.close();\r\n    \t\tif (ps != null)\r\n    \t\t\tps.close();\r\n        }\r\n    }","id":102684,"modified_method":"protected AtomicValue getGeometricPropertyForNode(DBBroker broker, NodeProxy p, Connection conn, String propertyName) throws SQLException, XPathException {\r\n        PreparedStatement ps = conn.prepareStatement(\r\n    \t\t\"SELECT \" + propertyName + \r\n    \t\t\" FROM \" + GMLHSQLIndex.TABLE_NAME + \r\n    \t\t\" WHERE DOCUMENT_URI = ? AND NODE_ID = ?;\"\r\n    \t);\r\n        ps.setString(1, p.getDocument().getURI().toString());\r\n        byte[] bytes = new byte[p.getNodeId().size()];\r\n        p.getNodeId().serialize(bytes, 0);\r\n    \tps.setBytes(2, bytes);    \t\r\n    \tResultSet rs = null;    \t\r\n    \ttry {\r\n    \t\trs = ps.executeQuery();\r\n    \t\tif (!rs.next())\r\n    \t\t\t//Nothing returned\r\n    \t\t\treturn null;\r\n    \t\tAtomicValue result = null;\r\n    \t\tif (rs.getMetaData().getColumnClassName(1).equals(Boolean.class.getName())) {\r\n    \t\t\tresult = new BooleanValue(rs.getBoolean(1));\r\n    \t\t} else if (rs.getMetaData().getColumnClassName(1).equals(Double.class.getName())) {\r\n    \t\t\tresult = new DoubleValue(rs.getDouble(1));\r\n    \t\t} else if (rs.getMetaData().getColumnClassName(1).equals(String.class.getName())) {\r\n    \t\t\tif (\"WKB\".equals(propertyName) || \"EPSG4326_WKB\".equals(propertyName))\r\n    \t\t\t\tresult = new Base64Binary(rs.getString(1));\r\n    \t\t\telse    \t\t\t\t\r\n    \t\t\t\tresult = new StringValue(rs.getString(1));\r\n    \t\t} else \r\n    \t\t\tthrow new SQLException(\"Unable to make an atomic value from '\" + rs.getMetaData().getColumnClassName(1) + \"'\");\t\t\r\n        \tif (rs.next()) {   \t\r\n    \t\t\t//Should be impossible    \t\t\r\n    \t\t\tthrow new SQLException(\"More than one geometry for node \" + p);\r\n    \t\t}\r\n        \treturn result;    \r\n    \t} finally {   \r\n    \t\tif (rs != null)\r\n    \t\t\trs.close();\r\n    \t\tif (ps != null)\r\n    \t\t\tps.close();\r\n        }\r\n    }","commit_id":"19574f6abae255c05f0d2b542ef04bdd075b3d4a","url":"https://github.com/eXist-db/exist"},{"original_method":"protected Geometry getGeometryForNode(DBBroker broker, NodeProxy p, Connection conn) throws SQLException {\r\n        PreparedStatement ps = conn.prepareStatement(\r\n    \t\t\"SELECT EPSG4326_BASE64_WKB\" +\r\n    \t\t\" FROM \" + GMLHSQLIndex.TABLE_NAME + \r\n    \t\t\" WHERE DOCUMENT_URI = ? AND NODE_ID = ?;\"\r\n    \t);\r\n        ps.setString(1, p.getDocument().getURI().toString());\r\n    \tps.setString(2, p.getNodeId().toString());   \r\n    \tResultSet rs = null;    \t\r\n    \ttry {\r\n    \t\trs = ps.executeQuery();\r\n    \t\tif (!rs.next())\r\n    \t\t\t//Nothing returned\r\n    \t\t\treturn null;    \t\t\r\n\t\t\tbase64Decoder.reset();\r\n        \tbase64Decoder.translate(rs.getString(\"EPSG4326_BASE64_WKB\"));\r\n        \tGeometry geometry = wkbReader.read(base64Decoder.getByteArray());        \t\t\t\r\n        \tif (rs.next()) {   \t\r\n    \t\t\t//Should be impossible    \t\t\r\n    \t\t\tthrow new SQLException(\"More than one geometry for node \" + p);\r\n    \t\t}\r\n        \treturn geometry;    \r\n        } catch (ParseException e) {\r\n        \tLOG.error(e); \r\n        \treturn null;\r\n    \t} finally {   \r\n    \t\tif (rs != null)\r\n    \t\t\trs.close();\r\n    \t\tif (ps != null)\r\n    \t\t\tps.close();\r\n        }\r\n    }","id":102685,"modified_method":"protected Geometry getGeometryForNode(DBBroker broker, NodeProxy p, Connection conn) throws SQLException {\r\n        PreparedStatement ps = conn.prepareStatement(\r\n    \t\t\"SELECT EPSG4326_BASE64_WKB\" +\r\n    \t\t\" FROM \" + GMLHSQLIndex.TABLE_NAME + \r\n    \t\t\" WHERE DOCUMENT_URI = ? AND NODE_ID = ?;\"\r\n    \t);\r\n        ps.setString(1, p.getDocument().getURI().toString());\r\n        byte[] bytes = new byte[p.getNodeId().size()];\r\n        p.getNodeId().serialize(bytes, 0);\r\n    \tps.setBytes(2, bytes);   \r\n    \tResultSet rs = null;    \t\r\n    \ttry {\r\n    \t\trs = ps.executeQuery();\r\n    \t\tif (!rs.next())\r\n    \t\t\t//Nothing returned\r\n    \t\t\treturn null;    \t\t\r\n\t\t\tbase64Decoder.reset();\r\n        \tbase64Decoder.translate(rs.getString(\"EPSG4326_BASE64_WKB\"));\r\n        \tGeometry geometry = wkbReader.read(base64Decoder.getByteArray());        \t\t\t\r\n        \tif (rs.next()) {   \t\r\n    \t\t\t//Should be impossible    \t\t\r\n    \t\t\tthrow new SQLException(\"More than one geometry for node \" + p);\r\n    \t\t}\r\n        \treturn geometry;    \r\n        } catch (ParseException e) {\r\n        \tLOG.error(e); \r\n        \treturn null;\r\n    \t} finally {   \r\n    \t\tif (rs != null)\r\n    \t\t\trs.close();\r\n    \t\tif (ps != null)\r\n    \t\t\tps.close();\r\n        }\r\n    }","commit_id":"19574f6abae255c05f0d2b542ef04bdd075b3d4a","url":"https://github.com/eXist-db/exist"},{"original_method":"protected NodeSet isIndexed(DBBroker broker, Geometry EPSG4326_geometry, Connection conn) throws SQLException {    \t\r\n    \tString bboxConstraint = \"(EPSG4326_MINX = ? AND EPSG4326_MAXX = ?)\" +\r\n    \t\t\t\t\" AND (EPSG4326_MINY = ? AND EPSG4326_MAXY = ?)\"; \r\n    \tNodeSet result = null;\r\n        PreparedStatement ps = conn.prepareStatement(\r\n    \t\t\"SELECT EPSG4326_BASE64_WKB, DOCUMENT_URI, NODE_ID\" +\r\n    \t\t\" FROM \" + GMLHSQLIndex.TABLE_NAME + \r\n    \t\t\" WHERE \" + bboxConstraint + \";\"\r\n    \t);\r\n        ps.setDouble(1, EPSG4326_geometry.getEnvelopeInternal().getMinX());\r\n    \tps.setDouble(2, EPSG4326_geometry.getEnvelopeInternal().getMaxX());\r\n    \tps.setDouble(3, EPSG4326_geometry.getEnvelopeInternal().getMinY());\r\n    \tps.setDouble(4, EPSG4326_geometry.getEnvelopeInternal().getMaxY());      \r\n    \tResultSet rs = null;\r\n    \tresult = new ExtArrayNodeSet(); //new ExtArrayNodeSet(docs.getLength(), 250)\r\n    \ttry {\r\n    \t\trs = ps.executeQuery();\r\n    \t\twhile (rs.next()) {    \t\t\t\r\n    \t\t\tbase64Decoder.reset();\r\n\t        \tbase64Decoder.translate(rs.getString(\"EPSG4326_BASE64_WKB\"));\r\n\t        \tGeometry geometry = wkbReader.read(base64Decoder.getByteArray());\t\r\n\t        \tboolean geometryMatches = geometry.equals(EPSG4326_geometry);\t        \t\r\n\t        \tif (geometryMatches) {\t        \t\r\n\t        \t\tXmldbURI documentURI = XmldbURI.create(rs.getString(\"DOCUMENT_URI\"));\r\n\t        \t\ttry {\r\n\t        \t\t\tDocument doc = broker.getXMLResource(documentURI);\r\n\t\t        \t\tNodeId nodeId = new DLN(rs.getString(\"NODE_ID\")); \r\n\t\t        \t\tNodeProxy p = new NodeProxy((DocumentImpl)doc, nodeId);\r\n\t\t        \t\tresult.add(p);\r\n\t        \t\t} catch (PermissionDeniedException e) {\r\n\t        \t\t\tLOG.debug(e);\r\n\t        \t\t}\r\n\t        \t}\r\n    \t\t}\r\n    \t\tif (LOG.isDebugEnabled()) {\r\n    \t\t\tLOG.debug(rs.getRow() + \" eligible geometries, \" + result.getItemCount() + \"selected\");\r\n    \t\t}\r\n    \t\treturn result;\r\n        } catch (ParseException e) {\r\n        \tLOG.error(e);\r\n        \treturn null;\r\n    \t} finally {   \r\n    \t\tif (rs != null)\r\n    \t\t\trs.close();\r\n    \t\tif (ps != null)\r\n    \t\t\tps.close();\r\n    \t}    \t\r\n    }","id":102686,"modified_method":"protected NodeSet isIndexed(DBBroker broker, Geometry EPSG4326_geometry, Connection conn) throws SQLException {    \t\r\n    \tString bboxConstraint = \"(EPSG4326_MINX = ? AND EPSG4326_MAXX = ?)\" +\r\n    \t\t\t\t\" AND (EPSG4326_MINY = ? AND EPSG4326_MAXY = ?)\"; \r\n    \tNodeSet result = null;\r\n        PreparedStatement ps = conn.prepareStatement(\r\n    \t\t\"SELECT EPSG4326_BASE64_WKB, DOCUMENT_URI, NODE_ID_UNITS, NODE_ID\" +\r\n    \t\t\" FROM \" + GMLHSQLIndex.TABLE_NAME + \r\n    \t\t\" WHERE \" + bboxConstraint + \";\"\r\n    \t);\r\n        ps.setDouble(1, EPSG4326_geometry.getEnvelopeInternal().getMinX());\r\n    \tps.setDouble(2, EPSG4326_geometry.getEnvelopeInternal().getMaxX());\r\n    \tps.setDouble(3, EPSG4326_geometry.getEnvelopeInternal().getMinY());\r\n    \tps.setDouble(4, EPSG4326_geometry.getEnvelopeInternal().getMaxY());      \r\n    \tResultSet rs = null;\r\n    \tresult = new ExtArrayNodeSet(); //new ExtArrayNodeSet(docs.getLength(), 250)\r\n    \ttry {\r\n    \t\trs = ps.executeQuery();\r\n    \t\twhile (rs.next()) {    \t\t\t\r\n    \t\t\tbase64Decoder.reset();\r\n\t        \tbase64Decoder.translate(rs.getString(\"EPSG4326_BASE64_WKB\"));\r\n\t        \tGeometry geometry = wkbReader.read(base64Decoder.getByteArray());\t\r\n\t        \tboolean geometryMatches = geometry.equals(EPSG4326_geometry);\t        \t\r\n\t        \tif (geometryMatches) {\t        \t\r\n\t        \t\tXmldbURI documentURI = XmldbURI.create(rs.getString(\"DOCUMENT_URI\"));\r\n\t        \t\ttry {\r\n\t        \t\t\tDocument doc = broker.getXMLResource(documentURI);\t        \t\t\t\r\n\t\t        \t\tNodeId nodeId = new DLN(rs.getInt(\"NODE_ID_UNITS\"), rs.getBytes(\"NODE_ID\"), 0); \r\n\t\t        \t\tNodeProxy p = new NodeProxy((DocumentImpl)doc, nodeId);\r\n\t\t        \t\tresult.add(p);\r\n\t        \t\t} catch (PermissionDeniedException e) {\r\n\t        \t\t\tLOG.debug(e);\r\n\t        \t\t}\r\n\t        \t}\r\n    \t\t}\r\n    \t\tif (LOG.isDebugEnabled()) {\r\n    \t\t\tLOG.debug(rs.getRow() + \" eligible geometries, \" + result.getItemCount() + \"selected\");\r\n    \t\t}\r\n    \t\treturn result;\r\n        } catch (ParseException e) {\r\n        \tLOG.error(e);\r\n        \treturn null;\r\n    \t} finally {   \r\n    \t\tif (rs != null)\r\n    \t\t\trs.close();\r\n    \t\tif (ps != null)\r\n    \t\t\tps.close();\r\n    \t}    \t\r\n    }","commit_id":"19574f6abae255c05f0d2b542ef04bdd075b3d4a","url":"https://github.com/eXist-db/exist"},{"original_method":"protected NodeSet search(DBBroker broker, NodeSet contextSet, Geometry EPSG4326_geometry, int spatialOp, Connection conn) throws SQLException {\r\n    \tString extraSelection = null;\r\n    \tString bboxConstraint = null;    \t\r\n        switch (spatialOp) {\r\n        \t//BBoxes are equal\r\n        \tcase SpatialOperator.EQUALS:\r\n        \t\tbboxConstraint = \"(EPSG4326_MINX = ? AND EPSG4326_MAXX = ?)\" +\r\n    \t\t\t\t\" AND (EPSG4326_MINY = ? AND EPSG4326_MAXY = ?)\";\r\n        \t\tbreak;\r\n    \t\t//Nothing much we can do with the BBox at this stage\r\n        \tcase SpatialOperator.DISJOINT:\r\n        \t\t//Retrieve the BBox though...\r\n        \t\textraSelection = \", EPSG4326_MINX, EPSG4326_MAXX, EPSG4326_MINY, EPSG4326_MAXY\";\r\n        \t\tbreak;\r\n       \t\t//BBoxes intersect themselves\r\n        \tcase SpatialOperator.INTERSECTS:        \t\t\r\n        \tcase SpatialOperator.TOUCHES:        \t\t   \t\t\r\n        \tcase SpatialOperator.CROSSES:        \t\t      \t\t\r\n        \tcase SpatialOperator.OVERLAPS: \r\n        \t\tbboxConstraint = \"(EPSG4326_MAXX >= ? AND EPSG4326_MINX <= ?)\" +\r\n\t\t\t\t\" AND (EPSG4326_MAXY >= ? AND EPSG4326_MINY <= ?)\";\r\n        \t\tbreak;\r\n        \t//BBox is fully within\r\n        \tcase SpatialOperator.WITHIN:   \r\n        \t\tbboxConstraint = \"(EPSG4326_MINX >= ? AND EPSG4326_MAXX <= ?)\" +\r\n\t\t\t\t\" AND (EPSG4326_MINY >= ? AND EPSG4326_MAXY <= ?)\";\r\n        \t\tbreak;\r\n        \t//BBox fully contains\r\n        \tcase SpatialOperator.CONTAINS: \r\n        \t\tbboxConstraint = \"(EPSG4326_MINX <= ? AND EPSG4326_MAXX >= ?)\" +\r\n\t\t\t\t\" AND (EPSG4326_MINY <= ? AND EPSG4326_MAXY >= ?)\";\r\n        \t\tbreak;             \t\t\r\n        \tdefault:\r\n        \t\tthrow new IllegalArgumentException(\"Unsupported spatial operator:\" + spatialOp);\r\n        }\r\n        PreparedStatement ps = conn.prepareStatement(\r\n    \t\t\"SELECT EPSG4326_BASE64_WKB, DOCUMENT_URI, NODE_ID\" + (extraSelection == null ? \"\" : extraSelection) +\r\n    \t\t\" FROM \" + GMLHSQLIndex.TABLE_NAME + \r\n    \t\t(bboxConstraint == null ? \"\" : \" WHERE \" + bboxConstraint) + \";\"\r\n    \t);\r\n        if (bboxConstraint != null) {\r\n\t        ps.setDouble(1, EPSG4326_geometry.getEnvelopeInternal().getMinX());\r\n\t    \tps.setDouble(2, EPSG4326_geometry.getEnvelopeInternal().getMaxX());\r\n\t    \tps.setDouble(3, EPSG4326_geometry.getEnvelopeInternal().getMinY());\r\n\t    \tps.setDouble(4, EPSG4326_geometry.getEnvelopeInternal().getMaxY());\r\n        }\r\n    \tResultSet rs = null;\r\n    \tNodeSet result = null;\r\n    \ttry { \r\n    \t\tint disjointPostFiltered = 0;\r\n    \t\trs = ps.executeQuery();\r\n    \t\tresult = new ExtArrayNodeSet(); //new ExtArrayNodeSet(docs.getLength(), 250)\r\n    \t\twhile (rs.next()) {\r\n    \t\t\tNodeProxy p = null;\t    \t\t\r\n        \t\tXmldbURI documentURI = XmldbURI.create(rs.getString(\"DOCUMENT_URI\"));\r\n        \t\ttry {\r\n        \t\t\tDocument doc = broker.getXMLResource(documentURI);\r\n\t        \t\tNodeId nodeId = new DLN(rs.getString(\"NODE_ID\")); \r\n\t        \t\tp = new NodeProxy((DocumentImpl)doc, nodeId);\t\t        \t\t\r\n        \t\t} catch (PermissionDeniedException e) {\r\n        \t\t\tLOG.debug(e);\r\n        \t\t}        \t\t\r\n        \t\t//Node is in the context : check if it is accurate\r\n        \t\t//contextSet.contains(p) would have made more sense but there is a problem with\r\n        \t\t//VirtualNodeSet when on the DESCENDANT_OR_SELF axis\r\n        \t\tif (contextSet == null || contextSet.get(p) != null) {        \t\t\t\r\n\t\t        \tboolean geometryMatches = false;\r\n\t\t        \tif (spatialOp == SpatialOperator.DISJOINT) {\r\n\t\t        \t\t//No BBox intersection : obviously disjoint\r\n\t\t        \t\tif (rs.getDouble(\"EPSG4326_MAXX\") < EPSG4326_geometry.getEnvelopeInternal().getMinX() ||\t        \t\t\t\r\n\t\t\t        \t\trs.getDouble(\"EPSG4326_MINX\") > EPSG4326_geometry.getEnvelopeInternal().getMaxX() ||\t        \t\t\t\r\n\t\t\t        \t\trs.getDouble(\"EPSG4326_MAXY\") < EPSG4326_geometry.getEnvelopeInternal().getMinY() ||\t        \t\t\t\r\n\t\t\t        \t\trs.getDouble(\"EPSG4326_MINY\") > EPSG4326_geometry.getEnvelopeInternal().getMaxY()) {\r\n\t\t\t        \t\t\tgeometryMatches = true;\r\n\t\t\t\t\t        \t\tdisjointPostFiltered++;\t\r\n\t\t        \t\t}\r\n\t\t        \t}\r\n\t\t        \t//Possible match : check the geometry\r\n\t\t        \tif (!geometryMatches) {\t\r\n\t\t        \t\ttry {\t\t\t        \t\r\n\t\t\t    \t\t\tbase64Decoder.reset();\r\n\t\t\t\t        \tbase64Decoder.translate(rs.getString(\"EPSG4326_BASE64_WKB\"));\r\n\t\t\t\t        \tGeometry geometry = wkbReader.read(base64Decoder.getByteArray());\t\t\t        \t\r\n\t\t\t\t        \tswitch (spatialOp) {\r\n\t\t\t\t        \tcase SpatialOperator.EQUALS:\t        \t\t        \t\t\r\n\t\t\t\t        \t\tgeometryMatches = geometry.equals(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\r\n\t\t\t\t        \tcase SpatialOperator.DISJOINT:        \t\t\r\n\t\t\t\t        \t\tgeometryMatches = geometry.disjoint(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\t        \t\t\r\n\t\t\t\t        \tcase SpatialOperator.INTERSECTS:        \t\t\r\n\t\t\t\t        \t\tgeometryMatches = geometry.intersects(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\t        \t\t\r\n\t\t\t\t        \tcase SpatialOperator.TOUCHES:\r\n\t\t\t\t\t        \tgeometryMatches = geometry.touches(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\t        \t\t\r\n\t\t\t\t        \tcase SpatialOperator.CROSSES:\r\n\t\t\t\t\t        \tgeometryMatches = geometry.crosses(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\t        \t\t\r\n\t\t\t\t        \tcase SpatialOperator.WITHIN:        \t\t\r\n\t\t\t\t        \t\tgeometryMatches = geometry.within(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\t        \t\t\r\n\t\t\t\t        \tcase SpatialOperator.CONTAINS:\t        \t\t\r\n\t\t\t\t        \t\tgeometryMatches = geometry.contains(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\t        \t\t\r\n\t\t\t\t        \tcase SpatialOperator.OVERLAPS:\t        \t\t\r\n\t\t\t\t        \t\tgeometryMatches = geometry.overlaps(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\t        \t\t\r\n\t\t\t\t        \t}\r\n\t\t    \t        } catch (ParseException e) {\r\n\t\t    \t        \tLOG.error(e); \r\n\t\t    \t        \treturn NodeSet.EMPTY_SET;\r\n\t\t    \t        }\r\n\t\t        \t}\r\n\t\t        \tif (geometryMatches)        \t\r\n\t\t\t        \tresult.add(p);\r\n        \t\t}\r\n    \t\t}\r\n    \t\tif (LOG.isDebugEnabled()) {\r\n    \t\t\tLOG.debug(rs.getRow() + \" eligible geometries, \" + result.getItemCount() + \"selected\" +\r\n    \t\t\t\t(spatialOp == SpatialOperator.DISJOINT ? \"(\" + disjointPostFiltered + \" post filtered)\" : \"\"));\r\n    \t\t}\r\n    \t\treturn result;\t    \t\r\n    \t} finally {   \r\n    \t\tif (rs != null)\r\n    \t\t\trs.close();\r\n    \t\tif (ps != null)\r\n    \t\t\tps.close();\t    \t\t\r\n    \t}\r\n    }","id":102687,"modified_method":"protected NodeSet search(DBBroker broker, NodeSet contextSet, Geometry EPSG4326_geometry, int spatialOp, Connection conn) throws SQLException {\r\n    \tString extraSelection = null;\r\n    \tString bboxConstraint = null;    \t\r\n        switch (spatialOp) {\r\n        \t//BBoxes are equal\r\n        \tcase SpatialOperator.EQUALS:\r\n        \t\tbboxConstraint = \"(EPSG4326_MINX = ? AND EPSG4326_MAXX = ?)\" +\r\n    \t\t\t\t\" AND (EPSG4326_MINY = ? AND EPSG4326_MAXY = ?)\";\r\n        \t\tbreak;\r\n    \t\t//Nothing much we can do with the BBox at this stage\r\n        \tcase SpatialOperator.DISJOINT:\r\n        \t\t//Retrieve the BBox though...\r\n        \t\textraSelection = \", EPSG4326_MINX, EPSG4326_MAXX, EPSG4326_MINY, EPSG4326_MAXY\";\r\n        \t\tbreak;\r\n       \t\t//BBoxes intersect themselves\r\n        \tcase SpatialOperator.INTERSECTS:        \t\t\r\n        \tcase SpatialOperator.TOUCHES:        \t\t   \t\t\r\n        \tcase SpatialOperator.CROSSES:        \t\t      \t\t\r\n        \tcase SpatialOperator.OVERLAPS: \r\n        \t\tbboxConstraint = \"(EPSG4326_MAXX >= ? AND EPSG4326_MINX <= ?)\" +\r\n\t\t\t\t\" AND (EPSG4326_MAXY >= ? AND EPSG4326_MINY <= ?)\";\r\n        \t\tbreak;\r\n        \t//BBox is fully within\r\n        \tcase SpatialOperator.WITHIN:   \r\n        \t\tbboxConstraint = \"(EPSG4326_MINX >= ? AND EPSG4326_MAXX <= ?)\" +\r\n\t\t\t\t\" AND (EPSG4326_MINY >= ? AND EPSG4326_MAXY <= ?)\";\r\n        \t\tbreak;\r\n        \t//BBox fully contains\r\n        \tcase SpatialOperator.CONTAINS: \r\n        \t\tbboxConstraint = \"(EPSG4326_MINX <= ? AND EPSG4326_MAXX >= ?)\" +\r\n\t\t\t\t\" AND (EPSG4326_MINY <= ? AND EPSG4326_MAXY >= ?)\";\r\n        \t\tbreak;             \t\t\r\n        \tdefault:\r\n        \t\tthrow new IllegalArgumentException(\"Unsupported spatial operator:\" + spatialOp);\r\n        }\r\n        PreparedStatement ps = conn.prepareStatement(\r\n    \t\t\"SELECT EPSG4326_BASE64_WKB, DOCUMENT_URI, NODE_ID_UNITS, NODE_ID\" + (extraSelection == null ? \"\" : extraSelection) +\r\n    \t\t\" FROM \" + GMLHSQLIndex.TABLE_NAME + \r\n    \t\t(bboxConstraint == null ? \"\" : \" WHERE \" + bboxConstraint) + \";\"\r\n    \t);\r\n        if (bboxConstraint != null) {\r\n\t        ps.setDouble(1, EPSG4326_geometry.getEnvelopeInternal().getMinX());\r\n\t    \tps.setDouble(2, EPSG4326_geometry.getEnvelopeInternal().getMaxX());\r\n\t    \tps.setDouble(3, EPSG4326_geometry.getEnvelopeInternal().getMinY());\r\n\t    \tps.setDouble(4, EPSG4326_geometry.getEnvelopeInternal().getMaxY());\r\n        }\r\n    \tResultSet rs = null;\r\n    \tNodeSet result = null;\r\n    \ttry { \r\n    \t\tint disjointPostFiltered = 0;\r\n    \t\trs = ps.executeQuery();\r\n    \t\tresult = new ExtArrayNodeSet(); //new ExtArrayNodeSet(docs.getLength(), 250)\r\n    \t\twhile (rs.next()) {\r\n    \t\t\tNodeProxy p = null;\t    \t\t\r\n        \t\tXmldbURI documentURI = XmldbURI.create(rs.getString(\"DOCUMENT_URI\"));\r\n        \t\ttry {\r\n        \t\t\tDocument doc = broker.getXMLResource(documentURI);        \t\t\t\r\n        \t\t\tNodeId nodeId = new DLN(rs.getInt(\"NODE_ID_UNITS\"), rs.getBytes(\"NODE_ID\"), 0); \r\n\t        \t\tp = new NodeProxy((DocumentImpl)doc, nodeId);\t\t        \t\t\r\n        \t\t} catch (PermissionDeniedException e) {\r\n        \t\t\tLOG.debug(e);\r\n        \t\t}        \t\t\r\n        \t\t//Node is in the context : check if it is accurate\r\n        \t\t//contextSet.contains(p) would have made more sense but there is a problem with\r\n        \t\t//VirtualNodeSet when on the DESCENDANT_OR_SELF axis\r\n        \t\tif (contextSet == null || contextSet.get(p) != null) {        \t\t\t\r\n\t\t        \tboolean geometryMatches = false;\r\n\t\t        \tif (spatialOp == SpatialOperator.DISJOINT) {\r\n\t\t        \t\t//No BBox intersection : obviously disjoint\r\n\t\t        \t\tif (rs.getDouble(\"EPSG4326_MAXX\") < EPSG4326_geometry.getEnvelopeInternal().getMinX() ||\t        \t\t\t\r\n\t\t\t        \t\trs.getDouble(\"EPSG4326_MINX\") > EPSG4326_geometry.getEnvelopeInternal().getMaxX() ||\t        \t\t\t\r\n\t\t\t        \t\trs.getDouble(\"EPSG4326_MAXY\") < EPSG4326_geometry.getEnvelopeInternal().getMinY() ||\t        \t\t\t\r\n\t\t\t        \t\trs.getDouble(\"EPSG4326_MINY\") > EPSG4326_geometry.getEnvelopeInternal().getMaxY()) {\r\n\t\t\t        \t\t\tgeometryMatches = true;\r\n\t\t\t\t\t        \t\tdisjointPostFiltered++;\t\r\n\t\t        \t\t}\r\n\t\t        \t}\r\n\t\t        \t//Possible match : check the geometry\r\n\t\t        \tif (!geometryMatches) {\t\r\n\t\t        \t\ttry {\t\t\t        \t\r\n\t\t\t    \t\t\tbase64Decoder.reset();\r\n\t\t\t\t        \tbase64Decoder.translate(rs.getString(\"EPSG4326_BASE64_WKB\"));\r\n\t\t\t\t        \tGeometry geometry = wkbReader.read(base64Decoder.getByteArray());\t\t\t        \t\r\n\t\t\t\t        \tswitch (spatialOp) {\r\n\t\t\t\t        \tcase SpatialOperator.EQUALS:\t        \t\t        \t\t\r\n\t\t\t\t        \t\tgeometryMatches = geometry.equals(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\r\n\t\t\t\t        \tcase SpatialOperator.DISJOINT:        \t\t\r\n\t\t\t\t        \t\tgeometryMatches = geometry.disjoint(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\t        \t\t\r\n\t\t\t\t        \tcase SpatialOperator.INTERSECTS:        \t\t\r\n\t\t\t\t        \t\tgeometryMatches = geometry.intersects(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\t        \t\t\r\n\t\t\t\t        \tcase SpatialOperator.TOUCHES:\r\n\t\t\t\t\t        \tgeometryMatches = geometry.touches(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\t        \t\t\r\n\t\t\t\t        \tcase SpatialOperator.CROSSES:\r\n\t\t\t\t\t        \tgeometryMatches = geometry.crosses(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\t        \t\t\r\n\t\t\t\t        \tcase SpatialOperator.WITHIN:        \t\t\r\n\t\t\t\t        \t\tgeometryMatches = geometry.within(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\t        \t\t\r\n\t\t\t\t        \tcase SpatialOperator.CONTAINS:\t        \t\t\r\n\t\t\t\t        \t\tgeometryMatches = geometry.contains(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\t        \t\t\r\n\t\t\t\t        \tcase SpatialOperator.OVERLAPS:\t        \t\t\r\n\t\t\t\t        \t\tgeometryMatches = geometry.overlaps(EPSG4326_geometry);\r\n\t\t\t\t        \t\tbreak;\t        \t\t\r\n\t\t\t\t        \t}\r\n\t\t    \t        } catch (ParseException e) {\r\n\t\t    \t        \tLOG.error(e); \r\n\t\t    \t        \treturn NodeSet.EMPTY_SET;\r\n\t\t    \t        }\r\n\t\t        \t}\r\n\t\t        \tif (geometryMatches)        \t\r\n\t\t\t        \tresult.add(p);\r\n        \t\t}\r\n    \t\t}\r\n    \t\tif (LOG.isDebugEnabled()) {\r\n    \t\t\tLOG.debug(rs.getRow() + \" eligible geometries, \" + result.getItemCount() + \"selected\" +\r\n    \t\t\t\t(spatialOp == SpatialOperator.DISJOINT ? \"(\" + disjointPostFiltered + \" post filtered)\" : \"\"));\r\n    \t\t}\r\n    \t\treturn result;\t    \t\r\n    \t} finally {   \r\n    \t\tif (rs != null)\r\n    \t\t\trs.close();\r\n    \t\tif (ps != null)\r\n    \t\t\tps.close();\t    \t\t\r\n    \t}\r\n    }","commit_id":"19574f6abae255c05f0d2b542ef04bdd075b3d4a","url":"https://github.com/eXist-db/exist"},{"original_method":"protected boolean removeDocumentNode(DocumentImpl doc, NodeId nodeID, Connection conn) throws SQLException {   \r\n        PreparedStatement ps = conn.prepareStatement(\r\n        \t\t\"DELETE FROM \" + GMLHSQLIndex.TABLE_NAME + \" WHERE DOCUMENT_URI = ? AND NODE_ID = ?;\"\r\n        \t); \r\n        ps.setString(1, doc.getURI().toString());\t   \r\n        ps.setString(2, nodeID.toString());\r\n        try {\t \r\n\t        return (ps.executeUpdate() == 1);\r\n    \t} finally {\r\n    \t\tif (ps != null)\r\n    \t\t\tps.close();\r\n    \t}       \r\n    }","id":102688,"modified_method":"protected boolean removeDocumentNode(DocumentImpl doc, NodeId nodeId, Connection conn) throws SQLException {\r\n        PreparedStatement ps = conn.prepareStatement(\r\n        \t\t\"DELETE FROM \" + GMLHSQLIndex.TABLE_NAME + \" WHERE DOCUMENT_URI = ? AND NODE_ID = ?;\"\r\n        \t); \r\n        ps.setString(1, doc.getURI().toString());\r\n        byte[] bytes = new byte[nodeId.size()];\r\n        nodeId.serialize(bytes, 0);        \r\n        ps.setBytes(2, bytes);\r\n        try {\t \r\n\t        return (ps.executeUpdate() == 1);\r\n    \t} finally {\r\n    \t\tif (ps != null)\r\n    \t\t\tps.close();\r\n    \t}       \r\n    }","commit_id":"19574f6abae255c05f0d2b542ef04bdd075b3d4a","url":"https://github.com/eXist-db/exist"},{"original_method":"protected boolean saveGeometryNode(Geometry geometry, String srsName, DocumentImpl doc, NodeId nodeId, Connection conn) throws SQLException {\r\n    \tPreparedStatement ps = conn.prepareStatement(\"INSERT INTO \" + GMLHSQLIndex.TABLE_NAME + \"(\" +\r\n        \t\t/*1*/ \"DOCUMENT_URI, \" +            \t\t\r\n    \t\t\t//TODO : use binary format ?\r\n        \t\t/*2*/ \"NODE_ID, \" +        \t\t\t\r\n        \t\t/*3*/ \"GEOMETRY_TYPE, \" +\r\n        \t\t/*4*/ \"SRS_NAME, \" +\r\n        \t\t/*5*/ \"WKT, \" +\r\n    \t\t\t//TODO : use binary format ?\r\n        \t\t/*6*/ \"BASE64_WKB, \" +\r\n    \t\t\t/*7*/ \"MINX, \" +\r\n    \t\t\t/*8*/ \"MAXX, \" +\r\n    \t\t\t/*9*/ \"MINY, \" +\r\n    \t\t\t/*10*/ \"MAXY, \" +\r\n    \t\t\t/*11*/ \"CENTROID_X, \" +\r\n    \t\t\t/*12*/ \"CENTROID_Y, \" +\r\n    \t\t\t/*13*/ \"AREA, \" +\r\n    \t\t\t//Boundary ?        \t\t\r\n        \t\t/*14*/ \"EPSG4326_WKT, \" +\r\n    \t\t\t//TODO : use binary format ?\r\n        \t\t/*15*/ \"EPSG4326_BASE64_WKB, \" +\r\n        \t\t/*16*/ \"EPSG4326_MINX, \" +\r\n    \t\t\t/*17*/ \"EPSG4326_MAXX, \" +\r\n    \t\t\t/*18*/ \"EPSG4326_MINY, \" +\r\n    \t\t\t/*19*/ \"EPSG4326_MAXY, \" +\r\n    \t\t\t/*20*/ \"EPSG4326_CENTROID_X, \" +\r\n    \t\t\t/*21*/ \"EPSG4326_CENTROID_Y, \" +\r\n    \t\t\t/*22*/ \"EPSG4326_AREA,\" +\r\n    \t\t\t//Boundary ?\r\n    \t\t\t/*23*/ \"IS_CLOSED, \" +\r\n    \t\t\t/*24*/ \"IS_SIMPLE, \" +\r\n    \t\t\t/*25*/ \"IS_VALID\" +    \t\t\t\r\n        \t\t\") VALUES (\" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?\"\t            \t\t\r\n        \t\t+ \")\"\r\n            );       \r\n    \ttry {\r\n    \t\t//TODO : use a default SRS from the config file ?\r\n            if (srsName == null) {\r\n        \t\tLOG.error(\"Geometry has a null SRS\");\r\n        \t\treturn false;                    \t\r\n            }\r\n            MathTransform mathTransform = getTransform(srsName, \"EPSG:4326\");\r\n            if (mathTransform == null) {\r\n        \t\tLOG.error(\"Unable to get a transformation from '\" + srsName + \"' to 'EPSG:4326'\");\r\n        \t\treturn false;              \t\r\n            }\r\n            coordinateTransformer.setMathTransform(mathTransform);        \r\n            Geometry EPSG4326_geometry = null;\r\n            try {\r\n            \tEPSG4326_geometry = coordinateTransformer.transform(geometry);\r\n            } catch (TransformException e) {\r\n        \t\tLOG.error(e);\r\n        \t\treturn false;\r\n            }\r\n            /*DOCUMENT_URI*/ ps.setString(1, doc.getURI().toString());\t\t          \r\n            /*NODE_ID*/ ps.setString(2, nodeId.toString());\r\n            /*GEOMETRY_TYPE*/ ps.setString(3, geometry.getGeometryType());\r\n            /*SRS_NAME*/ ps.setString(4, srsName);\r\n            /*WKT*/ ps.setString(5, wktWriter.write(geometry));\r\n            base64Encoder.reset();\r\n            base64Encoder.translate(wkbWriter.write(geometry));\r\n            /*BASE64_WKB*/ ps.setString(6, new String(base64Encoder.getCharArray()));\r\n            /*MINX*/ ps.setDouble(7, geometry.getEnvelopeInternal().getMinX());\r\n        \t/*MAXX*/ ps.setDouble(8, geometry.getEnvelopeInternal().getMaxX());\r\n        \t/*MINY*/ ps.setDouble(9, geometry.getEnvelopeInternal().getMinY());\r\n        \t/*MAXY*/ ps.setDouble(10, geometry.getEnvelopeInternal().getMaxY());\r\n        \t/*CENTROID_X*/ ps.setDouble(11, geometry.getCentroid().getCoordinate().x);   \r\n        \t/*CENTROID_Y*/ ps.setDouble(12, geometry.getCentroid().getCoordinate().y);  \r\n            //geometry.getRepresentativePoint()\r\n        \t/*AREA*/ ps.setDouble(13, geometry.getArea());\r\n        \t//Boundary ?\r\n            /*EPSG4326_WKT*/ ps.setString(14, wktWriter.write(EPSG4326_geometry));\r\n            base64Encoder.reset();\r\n            base64Encoder.translate(wkbWriter.write(EPSG4326_geometry));\r\n            /*EPSG4326_BASE64_WKB*/ ps.setString(15, new String(base64Encoder.getCharArray()));\t\t\r\n        \t/*EPSG4326_MINX*/ ps.setDouble(16, EPSG4326_geometry.getEnvelopeInternal().getMinX());\r\n        \t/*EPSG4326_MAXX*/ ps.setDouble(17, EPSG4326_geometry.getEnvelopeInternal().getMaxX());\r\n        \t/*EPSG4326_MINY*/ ps.setDouble(18, EPSG4326_geometry.getEnvelopeInternal().getMinY());\r\n        \t/*EPSG4326_MAXY*/ ps.setDouble(19, EPSG4326_geometry.getEnvelopeInternal().getMaxY());\r\n        \t/*EPSG4326_CENTROID_X*/ ps.setDouble(20, EPSG4326_geometry.getCentroid().getCoordinate().x);   \r\n        \t/*EPSG4326_CENTROID_Y*/ ps.setDouble(21, EPSG4326_geometry.getCentroid().getCoordinate().y);  \r\n            //EPSG4326_geometry.getRepresentativePoint()\r\n        \t/*EPSG4326_AREA*/ ps.setDouble(22, EPSG4326_geometry.getArea());\r\n\t\t\t//Boundary ?\r\n        \t//As discussed earlier, all instances of SFS geometry classes\r\n        \t//are topologically closed by definition.\r\n        \t//For empty Curves, isClosed is defined to have the value false.\r\n        \t/*IS_CLOSED*/ ps.setBoolean(23, !geometry.isEmpty());\r\n\t\t\t/*IS_SIMPLE*/ ps.setBoolean(24, geometry.isSimple());\r\n\t\t\t//Should always be true (the GML SAX parser makes a too severe check)\r\n\t\t\t/*IS_VALID*/ ps.setBoolean(25, geometry.isValid());\r\n        \treturn (ps.executeUpdate() == 1);\r\n    \t} finally {\r\n        \tif (ps != null)\r\n        \t\tps.close();\r\n            //Let's help the garbage collector...\r\n        \tgeometry = null;\r\n    \t}    \t\r\n    }","id":102689,"modified_method":"protected boolean saveGeometryNode(Geometry geometry, String srsName, DocumentImpl doc, NodeId nodeId, Connection conn) throws SQLException {\r\n    \tPreparedStatement ps = conn.prepareStatement(\"INSERT INTO \" + GMLHSQLIndex.TABLE_NAME + \"(\" +\r\n        \t\t/*1*/ \"DOCUMENT_URI, \" +            \t\t\r\n        \t\t/*2*/ \"NODE_ID_UNITS, \" + \r\n        \t\t/*3*/ \"NODE_ID, \" +        \t\t\t\r\n        \t\t/*4*/ \"GEOMETRY_TYPE, \" +\r\n        \t\t/*5*/ \"SRS_NAME, \" +\r\n        \t\t/*6*/ \"WKT, \" +\r\n    \t\t\t//TODO : use binary format ?\r\n        \t\t/*7*/ \"BASE64_WKB, \" +\r\n    \t\t\t/*8*/ \"MINX, \" +\r\n    \t\t\t/*9*/ \"MAXX, \" +\r\n    \t\t\t/*10*/ \"MINY, \" +\r\n    \t\t\t/*11*/ \"MAXY, \" +\r\n    \t\t\t/*12*/ \"CENTROID_X, \" +\r\n    \t\t\t/*13*/ \"CENTROID_Y, \" +\r\n    \t\t\t/*14*/ \"AREA, \" +\r\n    \t\t\t//Boundary ?        \t\t\r\n        \t\t/*15*/ \"EPSG4326_WKT, \" +\r\n    \t\t\t//TODO : use binary format ?\r\n        \t\t/*16*/ \"EPSG4326_BASE64_WKB, \" +\r\n        \t\t/*17*/ \"EPSG4326_MINX, \" +\r\n    \t\t\t/*18*/ \"EPSG4326_MAXX, \" +\r\n    \t\t\t/*19*/ \"EPSG4326_MINY, \" +\r\n    \t\t\t/*20*/ \"EPSG4326_MAXY, \" +\r\n    \t\t\t/*21*/ \"EPSG4326_CENTROID_X, \" +\r\n    \t\t\t/*22*/ \"EPSG4326_CENTROID_Y, \" +\r\n    \t\t\t/*23*/ \"EPSG4326_AREA,\" +\r\n    \t\t\t//Boundary ?\r\n    \t\t\t/*24*/ \"IS_CLOSED, \" +\r\n    \t\t\t/*25*/ \"IS_SIMPLE, \" +\r\n    \t\t\t/*26*/ \"IS_VALID\" +    \t\t\t\r\n        \t\t\") VALUES (\" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?\"\r\n        \t\t+ \")\"\r\n            );       \r\n    \ttry {\r\n    \t\t//TODO : use a default SRS from the config file ?\r\n            if (srsName == null) {\r\n        \t\tLOG.error(\"Geometry has a null SRS\");\r\n        \t\treturn false;                    \t\r\n            }\r\n            MathTransform mathTransform = getTransform(srsName, \"EPSG:4326\");\r\n            if (mathTransform == null) {\r\n        \t\tLOG.error(\"Unable to get a transformation from '\" + srsName + \"' to 'EPSG:4326'\");\r\n        \t\treturn false;              \t\r\n            }\r\n            coordinateTransformer.setMathTransform(mathTransform);        \r\n            Geometry EPSG4326_geometry = null;\r\n            try {\r\n            \tEPSG4326_geometry = coordinateTransformer.transform(geometry);\r\n            } catch (TransformException e) {\r\n        \t\tLOG.error(e);\r\n        \t\treturn false;\r\n            }\r\n            /*DOCUMENT_URI*/ ps.setString(1, doc.getURI().toString());\t\r\n            /*NODE_ID_UNITS*/ ps.setInt(2, nodeId.units());\r\n            byte[] bytes = new byte[nodeId.size()];\r\n            nodeId.serialize(bytes, 0);\r\n            /*NODE_ID*/ ps.setBytes(3, bytes);\r\n            /*GEOMETRY_TYPE*/ ps.setString(4, geometry.getGeometryType());\r\n            /*SRS_NAME*/ ps.setString(5, srsName);\r\n            /*WKT*/ ps.setString(6, wktWriter.write(geometry));\r\n            base64Encoder.reset();\r\n            base64Encoder.translate(wkbWriter.write(geometry));\r\n            /*BASE64_WKB*/ ps.setString(7, new String(base64Encoder.getCharArray()));\r\n            /*MINX*/ ps.setDouble(8, geometry.getEnvelopeInternal().getMinX());\r\n        \t/*MAXX*/ ps.setDouble(9, geometry.getEnvelopeInternal().getMaxX());\r\n        \t/*MINY*/ ps.setDouble(10, geometry.getEnvelopeInternal().getMinY());\r\n        \t/*MAXY*/ ps.setDouble(11, geometry.getEnvelopeInternal().getMaxY());\r\n        \t/*CENTROID_X*/ ps.setDouble(12, geometry.getCentroid().getCoordinate().x);   \r\n        \t/*CENTROID_Y*/ ps.setDouble(13, geometry.getCentroid().getCoordinate().y);  \r\n            //geometry.getRepresentativePoint()\r\n        \t/*AREA*/ ps.setDouble(14, geometry.getArea());\r\n        \t//Boundary ?\r\n            /*EPSG4326_WKT*/ ps.setString(15, wktWriter.write(EPSG4326_geometry));\r\n            base64Encoder.reset();\r\n            base64Encoder.translate(wkbWriter.write(EPSG4326_geometry));\r\n            /*EPSG4326_BASE64_WKB*/ ps.setString(16, new String(base64Encoder.getCharArray()));\t\t\r\n        \t/*EPSG4326_MINX*/ ps.setDouble(17, EPSG4326_geometry.getEnvelopeInternal().getMinX());\r\n        \t/*EPSG4326_MAXX*/ ps.setDouble(18, EPSG4326_geometry.getEnvelopeInternal().getMaxX());\r\n        \t/*EPSG4326_MINY*/ ps.setDouble(19, EPSG4326_geometry.getEnvelopeInternal().getMinY());\r\n        \t/*EPSG4326_MAXY*/ ps.setDouble(20, EPSG4326_geometry.getEnvelopeInternal().getMaxY());\r\n        \t/*EPSG4326_CENTROID_X*/ ps.setDouble(21, EPSG4326_geometry.getCentroid().getCoordinate().x);   \r\n        \t/*EPSG4326_CENTROID_Y*/ ps.setDouble(22, EPSG4326_geometry.getCentroid().getCoordinate().y);  \r\n            //EPSG4326_geometry.getRepresentativePoint()\r\n        \t/*EPSG4326_AREA*/ ps.setDouble(23, EPSG4326_geometry.getArea());\r\n\t\t\t//Boundary ?\r\n        \t//As discussed earlier, all instances of SFS geometry classes\r\n        \t//are topologically closed by definition.\r\n        \t//For empty Curves, isClosed is defined to have the value false.\r\n        \t/*IS_CLOSED*/ ps.setBoolean(24, !geometry.isEmpty());\r\n\t\t\t/*IS_SIMPLE*/ ps.setBoolean(25, geometry.isSimple());\r\n\t\t\t//Should always be true (the GML SAX parser makes a too severe check)\r\n\t\t\t/*IS_VALID*/ ps.setBoolean(26, geometry.isValid());\r\n        \treturn (ps.executeUpdate() == 1);\r\n    \t} finally {\r\n        \tif (ps != null)\r\n        \t\tps.close();\r\n            //Let's help the garbage collector...\r\n        \tgeometry = null;\r\n    \t}    \t\r\n    }","commit_id":"19574f6abae255c05f0d2b542ef04bdd075b3d4a","url":"https://github.com/eXist-db/exist"},{"original_method":"protected boolean checkIndex(DBBroker broker, Connection conn) throws SQLException, SpatialIndexException {\r\n    \tPreparedStatement ps = conn.prepareStatement(\r\n\t    \t\t\"SELECT * FROM \" + GMLHSQLIndex.TABLE_NAME + \";\"\r\n\t    \t);\r\n    \tResultSet rs = null;\r\n    \ttry {\r\n    \t\trs = ps.executeQuery();\r\n\t        while (rs.next()) {\t        \t\r\n\t        \tbase64Decoder.reset();\r\n\t        \tbase64Decoder.translate(rs.getString(\"BASE64_WKB\"));\r\n\t        \tGeometry original_geometry = wkbReader.read(base64Decoder.getByteArray());\t\t        \t\r\n\t            if (! original_geometry.equals(wktReader.read(rs.getString(\"WKT\")))) {\r\n\t            \tLOG.info(\"Inconsistent WKT : \" + rs.getString(\"WKT\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\t\t            \t\r\n\t        \tbase64Decoder.reset();\r\n\t        \tbase64Decoder.translate(rs.getString(\"EPSG4326_BASE64_WKB\"));\r\n\t        \tGeometry EPSG4326_geometry = wkbReader.read(base64Decoder.getByteArray());\t\t        \t\r\n\t            if (!EPSG4326_geometry.equals(wktReader.read(rs.getString(\"EPSG4326_WKT\")))) {\r\n\t            \tLOG.info(\"Inconsistent WKT : \" + rs.getString(\"EPSG4326_WKT\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            \r\n\t        \tif (!original_geometry.getGeometryType().equals(rs.getString(\"GEOMETRY_TYPE\"))) {\r\n\t        \t\tLOG.info(\"Inconsistent geometry type: \" + rs.getDouble(\"GEOMETRY_TYPE\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t        \t\r\n\t            if (original_geometry.getEnvelopeInternal().getMinX() != rs.getDouble(\"MINX\")) {\r\n\t            \tLOG.info(\"Inconsistent MinX: \" + rs.getDouble(\"MINX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getEnvelopeInternal().getMaxX() != rs.getDouble(\"MAXX\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxX: \" + rs.getDouble(\"MAXX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getEnvelopeInternal().getMinY() != rs.getDouble(\"MINY\")) {\r\n\t            \tLOG.info(\"Inconsistent MinY: \" + rs.getDouble(\"MINY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getEnvelopeInternal().getMaxY() != rs.getDouble(\"MAXY\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxY: \" + rs.getDouble(\"MAXY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getCentroid().getCoordinate().x != rs.getDouble(\"CENTROID_X\")) {\r\n\t            \tLOG.info(\"Inconsistent X for centroid : \" + rs.getDouble(\"CENTROID_X\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getCentroid().getCoordinate().y != rs.getDouble(\"CENTROID_Y\")) {\r\n\t            \tLOG.info(\"Inconsistent Y for centroid : \" + rs.getDouble(\"CENTROID_Y\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getArea() != rs.getDouble(\"AREA\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getDouble(\"AREA\"));\r\n\t    \t\t\treturn false;\r\n\t            }\t        \t\r\n\t        \t\r\n\t        \tString srsName = rs.getString(\"SRS_NAME\");\r\n            \tif (!transformGeometry(original_geometry, srsName, \"EPSG:4326\").equals(EPSG4326_geometry)) {\r\n\t        \t\tLOG.info(\"Transformed original geometry inconsistent with stored tranformed one\");\r\n            \t\treturn false;\r\n            \t}\r\n\t\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMinX() != rs.getDouble(\"EPSG4326_MINX\")) {\r\n\t            \tLOG.info(\"Inconsistent MinX: \" + rs.getDouble(\"EPSG4326_MINX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMaxX() != rs.getDouble(\"EPSG4326_MAXX\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxX: \" + rs.getDouble(\"EPSG4326_MAXX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMinY() != rs.getDouble(\"EPSG4326_MINY\")) {\r\n\t            \tLOG.info(\"Inconsistent MinY: \" + rs.getDouble(\"EPSG4326_MINY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMaxY() != rs.getDouble(\"EPSG4326_MAXY\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxY: \" + rs.getDouble(\"EPSG4326_MAXY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getCentroid().getCoordinate().x != rs.getDouble(\"EPSG4326_CENTROID_X\")) {\r\n\t            \tLOG.info(\"Inconsistent X for centroid : \" + rs.getDouble(\"EPSG4326_CENTROID_X\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getCentroid().getCoordinate().y != rs.getDouble(\"EPSG4326_CENTROID_Y\")) {\r\n\t            \tLOG.info(\"Inconsistent Y for centroid : \" + rs.getDouble(\"EPSG4326_CENTROID_Y\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getArea() != rs.getDouble(\"EPSG4326_AREA\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getDouble(\"EPSG4326_AREA\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\t            \r\n\t            if (original_geometry.isEmpty() == rs.getBoolean(\"IS_CLOSED\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getBoolean(\"IS_CLOSED\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\t            if (original_geometry.isSimple() != rs.getBoolean(\"IS_SIMPLE\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getBoolean(\"IS_SIMPLE\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\t            if (original_geometry.isValid() != rs.getBoolean(\"IS_VALID\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getBoolean(\"IS_VALID\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\t            \r\n\t            Document doc = broker.getXMLResource(XmldbURI.create(rs.getString(\"DOCUMENT_URI\")));\r\n\t    \t\tNodeId nodeId = new DLN(rs.getString(\"NODE_ID\")); \r\n\t    \t\t\t           \r\n\t        \tStoredNode node = broker.objectWith(new NodeProxy((DocumentImpl)doc, nodeId));\r\n\t        \tif (!GMLHSQLIndexWorker.GML_NS.equals(node.getNamespaceURI())) {\r\n\t        \t\tLOG.info(\"GML indexed node (\" + node.getNodeId()+ \") is in the '\" + \r\n\t        \t\t\t\tnode.getNamespaceURI() + \"' namespace. '\" + \r\n\t        \t\t\t\tGMLHSQLIndexWorker.GML_NS + \"' was expected !\");\r\n\t        \t\treturn false;\r\n\t        \t}\r\n\t        \tif (!original_geometry.getGeometryType().equals(node.getLocalName())) {\r\n\t        \t\tif (\"Box\".equals(node.getLocalName()) && \"Polygon\".equals(original_geometry.getGeometryType())) {\r\n\t        \t\t\tLOG.debug(\"GML indexed node (\" + node.getNodeId() + \") is a gml:Box indexed as a polygon\");\r\n\t        \t\t} else {\r\n\t        \t\t\tLOG.info(\"GML indexed node (\" + node.getNodeId() + \") has '\" + \r\n\t        \t\t\t\t\tnode.getLocalName() + \"' as its local name. '\" + \r\n\t        \t\t\t\t\toriginal_geometry.getGeometryType() + \"' was expected !\");\r\n\t        \t\t\treturn false;\r\n\t        \t\t}\r\n\t        \t}\r\n\t        \t\r\n\t    \t\tLOG.info(node);\t        \t\t\r\n\t        }\r\n\t        return true;\r\n\t        \r\n        } catch (ParseException e) {\r\n        \tLOG.error(e);\r\n        \treturn false;\r\n        } catch (PermissionDeniedException e) {\r\n        \tLOG.error(e);\r\n        \treturn false;\r\n\t\t} finally {   \r\n\t\t\tif (rs != null)\r\n\t\t\t\trs.close();\r\n\t\t\tif (ps != null)\r\n\t\t\t\tps.close();\t\r\n\t    }\r\n    }","id":102690,"modified_method":"protected boolean checkIndex(DBBroker broker, Connection conn) throws SQLException, SpatialIndexException {\r\n    \tPreparedStatement ps = conn.prepareStatement(\r\n\t    \t\t\"SELECT * FROM \" + GMLHSQLIndex.TABLE_NAME + \";\"\r\n\t    \t);\r\n    \tResultSet rs = null;\r\n    \ttry {\r\n    \t\trs = ps.executeQuery();\r\n\t        while (rs.next()) {\t        \t\r\n\t        \tbase64Decoder.reset();\r\n\t        \tbase64Decoder.translate(rs.getString(\"BASE64_WKB\"));\r\n\t        \tGeometry original_geometry = wkbReader.read(base64Decoder.getByteArray());\t\t        \t\r\n\t            if (! original_geometry.equals(wktReader.read(rs.getString(\"WKT\")))) {\r\n\t            \tLOG.info(\"Inconsistent WKT : \" + rs.getString(\"WKT\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\t\t            \t\r\n\t        \tbase64Decoder.reset();\r\n\t        \tbase64Decoder.translate(rs.getString(\"EPSG4326_BASE64_WKB\"));\r\n\t        \tGeometry EPSG4326_geometry = wkbReader.read(base64Decoder.getByteArray());\t\t        \t\r\n\t            if (!EPSG4326_geometry.equals(wktReader.read(rs.getString(\"EPSG4326_WKT\")))) {\r\n\t            \tLOG.info(\"Inconsistent WKT : \" + rs.getString(\"EPSG4326_WKT\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            \r\n\t        \tif (!original_geometry.getGeometryType().equals(rs.getString(\"GEOMETRY_TYPE\"))) {\r\n\t        \t\tLOG.info(\"Inconsistent geometry type: \" + rs.getDouble(\"GEOMETRY_TYPE\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t        \t\r\n\t            if (original_geometry.getEnvelopeInternal().getMinX() != rs.getDouble(\"MINX\")) {\r\n\t            \tLOG.info(\"Inconsistent MinX: \" + rs.getDouble(\"MINX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getEnvelopeInternal().getMaxX() != rs.getDouble(\"MAXX\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxX: \" + rs.getDouble(\"MAXX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getEnvelopeInternal().getMinY() != rs.getDouble(\"MINY\")) {\r\n\t            \tLOG.info(\"Inconsistent MinY: \" + rs.getDouble(\"MINY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getEnvelopeInternal().getMaxY() != rs.getDouble(\"MAXY\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxY: \" + rs.getDouble(\"MAXY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getCentroid().getCoordinate().x != rs.getDouble(\"CENTROID_X\")) {\r\n\t            \tLOG.info(\"Inconsistent X for centroid : \" + rs.getDouble(\"CENTROID_X\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getCentroid().getCoordinate().y != rs.getDouble(\"CENTROID_Y\")) {\r\n\t            \tLOG.info(\"Inconsistent Y for centroid : \" + rs.getDouble(\"CENTROID_Y\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getArea() != rs.getDouble(\"AREA\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getDouble(\"AREA\"));\r\n\t    \t\t\treturn false;\r\n\t            }\t        \t\r\n\t        \t\r\n\t        \tString srsName = rs.getString(\"SRS_NAME\");\r\n            \tif (!transformGeometry(original_geometry, srsName, \"EPSG:4326\").equals(EPSG4326_geometry)) {\r\n\t        \t\tLOG.info(\"Transformed original geometry inconsistent with stored tranformed one\");\r\n            \t\treturn false;\r\n            \t}\r\n\t\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMinX() != rs.getDouble(\"EPSG4326_MINX\")) {\r\n\t            \tLOG.info(\"Inconsistent MinX: \" + rs.getDouble(\"EPSG4326_MINX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMaxX() != rs.getDouble(\"EPSG4326_MAXX\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxX: \" + rs.getDouble(\"EPSG4326_MAXX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMinY() != rs.getDouble(\"EPSG4326_MINY\")) {\r\n\t            \tLOG.info(\"Inconsistent MinY: \" + rs.getDouble(\"EPSG4326_MINY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMaxY() != rs.getDouble(\"EPSG4326_MAXY\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxY: \" + rs.getDouble(\"EPSG4326_MAXY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getCentroid().getCoordinate().x != rs.getDouble(\"EPSG4326_CENTROID_X\")) {\r\n\t            \tLOG.info(\"Inconsistent X for centroid : \" + rs.getDouble(\"EPSG4326_CENTROID_X\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getCentroid().getCoordinate().y != rs.getDouble(\"EPSG4326_CENTROID_Y\")) {\r\n\t            \tLOG.info(\"Inconsistent Y for centroid : \" + rs.getDouble(\"EPSG4326_CENTROID_Y\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getArea() != rs.getDouble(\"EPSG4326_AREA\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getDouble(\"EPSG4326_AREA\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\t            \r\n\t            if (original_geometry.isEmpty() == rs.getBoolean(\"IS_CLOSED\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getBoolean(\"IS_CLOSED\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\t            if (original_geometry.isSimple() != rs.getBoolean(\"IS_SIMPLE\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getBoolean(\"IS_SIMPLE\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\t            if (original_geometry.isValid() != rs.getBoolean(\"IS_VALID\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getBoolean(\"IS_VALID\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\t            \r\n\t            Document doc = broker.getXMLResource(XmldbURI.create(rs.getString(\"DOCUMENT_URI\")));\r\n\t            NodeId nodeId = new DLN(rs.getInt(\"NODE_ID_UNITS\"), rs.getBytes(\"NODE_ID\"), 0); \t    \t\t\r\n\t        \tStoredNode node = broker.objectWith(new NodeProxy((DocumentImpl)doc, nodeId));\r\n\t        \tif (!GMLHSQLIndexWorker.GML_NS.equals(node.getNamespaceURI())) {\r\n\t        \t\tLOG.info(\"GML indexed node (\" + node.getNodeId()+ \") is in the '\" + \r\n\t        \t\t\t\tnode.getNamespaceURI() + \"' namespace. '\" + \r\n\t        \t\t\t\tGMLHSQLIndexWorker.GML_NS + \"' was expected !\");\r\n\t        \t\treturn false;\r\n\t        \t}\r\n\t        \tif (!original_geometry.getGeometryType().equals(node.getLocalName())) {\r\n\t        \t\tif (\"Box\".equals(node.getLocalName()) && \"Polygon\".equals(original_geometry.getGeometryType())) {\r\n\t        \t\t\tLOG.debug(\"GML indexed node (\" + node.getNodeId() + \") is a gml:Box indexed as a polygon\");\r\n\t        \t\t} else {\r\n\t        \t\t\tLOG.info(\"GML indexed node (\" + node.getNodeId() + \") has '\" + \r\n\t        \t\t\t\t\tnode.getLocalName() + \"' as its local name. '\" + \r\n\t        \t\t\t\t\toriginal_geometry.getGeometryType() + \"' was expected !\");\r\n\t        \t\t\treturn false;\r\n\t        \t\t}\r\n\t        \t}\r\n\t        \t\r\n\t    \t\tLOG.info(node);\t        \t\t\r\n\t        }\r\n\t        return true;\r\n\t        \r\n        } catch (ParseException e) {\r\n        \tLOG.error(e);\r\n        \treturn false;\r\n        } catch (PermissionDeniedException e) {\r\n        \tLOG.error(e);\r\n        \treturn false;\r\n\t\t} finally {   \r\n\t\t\tif (rs != null)\r\n\t\t\t\trs.close();\r\n\t\t\tif (ps != null)\r\n\t\t\t\tps.close();\t\r\n\t    }\r\n    }","commit_id":"19574f6abae255c05f0d2b542ef04bdd075b3d4a","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public boolean applyLBRules(Network network, List<LoadBalancingRule> rules) throws ResourceUnavailableException {\n        //1) Get Internal LB VMs to destroy\n        Set<Ip> vmsToDestroy = getVmsToDestroy(rules);\n\n        //2) Get rules to apply\n        Map<Ip, List<LoadBalancingRule>> rulesToApply = getLbRulesToApply(rules);\n        s_logger.debug(\"Applying \" + rulesToApply.size() + \" on element \" + getName());\n\n        for (Ip sourceIp : rulesToApply.keySet()) {\n            if (vmsToDestroy.contains(sourceIp)) {\n                //2.1 Destroy internal lb vm\n                List<? extends VirtualRouter> vms = _internalLbMgr.findInternalLbVms(network.getId(), sourceIp);\n                if (vms.size() > 0) {\n                    //only one internal lb per IP exists\n                    try {\n                        s_logger.debug(\"Destroying internal lb vm for ip \" + sourceIp.addr() + \" as all the rules for this vm are in Revoke state\");\n                        return _internalLbMgr.destroyInternalLbVm(vms.get(0).getId(), _accountMgr.getAccount(Account.ACCOUNT_ID_SYSTEM),\n                            _accountMgr.getUserIncludingRemoved(User.UID_SYSTEM).getId());\n                    } catch (ConcurrentOperationException e) {\n                        s_logger.warn(\"Failed to apply lb rule(s) for ip \" + sourceIp.addr() + \" on the element \" + getName() + \" due to:\", e);\n                        return false;\n                    }\n                }\n            } else {\n                //2.2 Start Internal LB vm per IP address\n                List<? extends VirtualRouter> internalLbVms;\n                try {\n                    DeployDestination dest = new DeployDestination(_entityMgr.findById(DataCenter.class, network.getDataCenterId()), null, null, null);\n                    internalLbVms = _internalLbMgr.deployInternalLbVm(network, sourceIp, dest, _accountMgr.getAccount(network.getAccountId()), null);\n                } catch (InsufficientCapacityException e) {\n                    s_logger.warn(\"Failed to apply lb rule(s) for ip \" + sourceIp.addr() + \"on the element \" + getName() + \" due to:\", e);\n                    return false;\n                } catch (ConcurrentOperationException e) {\n                    s_logger.warn(\"Failed to apply lb rule(s) for ip \" + sourceIp.addr() + \"on the element \" + getName() + \" due to:\", e);\n                    return false;\n                }\n\n                if (internalLbVms == null || internalLbVms.isEmpty()) {\n                    throw new ResourceUnavailableException(\"Can't find/deploy internal lb vm to handle LB rules\", DataCenter.class, network.getDataCenterId());\n                }\n\n                //2.3 Apply Internal LB rules on the VM\n                if (!_internalLbMgr.applyLoadBalancingRules(network, rulesToApply.get(sourceIp), internalLbVms)) {\n                    throw new CloudRuntimeException(\"Failed to apply load balancing rules for ip \" + sourceIp.addr() + \" in network \" + network.getId() + \" on element \" +\n                        getName());\n                }\n            }\n        }\n\n        return true;\n    }","id":102691,"modified_method":"@Override\n    public boolean applyLBRules(Network network, List<LoadBalancingRule> rules) throws ResourceUnavailableException {\n        //1) Get Internal LB VMs to destroy\n        Set<Ip> vmsToDestroy = getVmsToDestroy(network, rules);\n\n        //2) Get rules to apply\n        Map<Ip, List<LoadBalancingRule>> rulesToApply = getLbRulesToApply(rules);\n        s_logger.debug(\"Applying \" + rulesToApply.size() + \" on element \" + getName());\n\n        for (Ip sourceIp : vmsToDestroy) {\n            //2.1 Destroy internal lb vm\n            List<? extends VirtualRouter> vms = _internalLbMgr.findInternalLbVms(network.getId(), sourceIp);\n            if (vms.size() > 0) {\n                //only one internal lb per IP exists\n                try {\n                    s_logger.debug(String.format(\"Destroying internal lb vm for ip %s as all the rules for this vm are in Revoke state\", sourceIp.addr()));\n                    return _internalLbMgr.destroyInternalLbVm(vms.get(0).getId(), _accountMgr.getAccount(Account.ACCOUNT_ID_SYSTEM),\n                            _accountMgr.getUserIncludingRemoved(User.UID_SYSTEM).getId());\n                } catch (ConcurrentOperationException e) {\n                    s_logger.warn(String.format(\"Failed to apply lb rule(s) for ip %s on the element %s due to: \", sourceIp.addr(), getName()), e);\n                    return false;\n                }\n            }\n\n            rulesToApply.remove(sourceIp);\n        }\n\n        for (Map.Entry<Ip,List<LoadBalancingRule>> entry : rulesToApply.entrySet()) {\n            Ip sourceIp = entry.getKey();\n            //2.2 Start Internal LB vm per IP address\n            List<? extends VirtualRouter> internalLbVms;\n            try {\n                DeployDestination dest = new DeployDestination(_entityMgr.findById(DataCenter.class, network.getDataCenterId()), null, null, null);\n                internalLbVms = _internalLbMgr.deployInternalLbVm(network, sourceIp, dest, _accountMgr.getAccount(network.getAccountId()), null);\n            } catch (InsufficientCapacityException e) {\n                s_logger.warn(String.format(\"Failed to apply lb rule(s) for ip %s on the element %s due to: \", sourceIp.addr(), getName()), e);\n                return false;\n            } catch (ConcurrentOperationException e) {\n                s_logger.warn(String.format(\"Failed to apply lb rule(s) for ip %s on the element %s due to: \", sourceIp.addr(), getName()), e);\n                return false;\n            }\n\n            if (internalLbVms == null || internalLbVms.isEmpty()) {\n                throw new ResourceUnavailableException(\"Can't find/deploy internal lb vm to handle LB rules\",\n                        DataCenter.class, network.getDataCenterId());\n            }\n\n            //2.3 Apply Internal LB rules on the VM\n            if (!_internalLbMgr.applyLoadBalancingRules(network, entry.getValue(), internalLbVms)) {\n                throw new CloudRuntimeException(\"Failed to apply load balancing rules for ip \" + sourceIp.addr() +\n                        \" in network \" + network.getId() + \" on element \" + getName());\n            }\n        }\n\n        return true;\n    }","commit_id":"741e88833f9b0d533f66bc8875675ede51c15922","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Set<Ip> getVmsToDestroy(List<LoadBalancingRule> rules) {\n        //1) Group rules by the source ip address as NetworkManager always passes the entire network lb config to the element\n        Map<Ip, List<LoadBalancingRule>> groupedRules = groupBySourceIp(rules);\n\n        Set<Ip> vmsToDestroy = new HashSet<Ip>();\n\n        for (Ip sourceIp : groupedRules.keySet()) {\n            //2) Check if there are non revoked rules for the source ip address\n            List<LoadBalancingRule> rulesToCheck = groupedRules.get(sourceIp);\n            if (_appLbDao.countBySourceIpAndNotRevoked(sourceIp, rulesToCheck.get(0).getNetworkId()) == 0) {\n                s_logger.debug(\"Have to destroy internal lb vm for source ip \" + sourceIp + \" as it has 0 rules in non-Revoke state\");\n                vmsToDestroy.add(sourceIp);\n            }\n        }\n        return vmsToDestroy;\n    }","id":102692,"modified_method":"protected Set<Ip> getVmsToDestroy(Network network, List<LoadBalancingRule> rules) {\n        //1) Group rules by the source ip address as NetworkManager always passes the entire network lb config to the element\n        Set<Ip> lbPublicIps = new HashSet<Ip>();\n        Set<Ip> vmsToDestroy = new HashSet<Ip>();\n\n        for (LoadBalancingRule rule : rules) {\n            lbPublicIps.add(rule.getSourceIp());\n        }\n\n        for (Ip sourceIp : lbPublicIps) {\n            //2) Check if there are non revoked rules for the source ip address\n            if (_appLbDao.countBySourceIpAndNotRevoked(sourceIp, network.getId()) == 0) {\n                s_logger.debug(\"Have to destroy internal lb vm for source ip \" + sourceIp + \" as it has 0 rules in non-Revoke state\");\n                vmsToDestroy.add(sourceIp);\n            }\n        }\n        return vmsToDestroy;\n    }","commit_id":"741e88833f9b0d533f66bc8875675ede51c15922","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n\t * Returns a qualifier that evalutes to true when the value of the given key\n\t * contains all of the given tokens (insensitively) in the search string.\n\t * The search string will be tokenized by splitting on space characters.\n\t * \n\t * @param key\n\t *            the key\n\t * @param tokensWithWhitespace\n\t *            a whitespace separated list of tokens to search for\n\t * @return an ERXAndQualifier\n\t */\n\tpublic static ERXAndQualifier containsAll(String key, String tokensWithWhitespace) {\n\t\tString[] searchStrings = tokensWithWhitespace.split(\"\\\\s+\");\n\t\treturn ERXQ.containsAll(key, searchStrings);\n\t}","id":102693,"modified_method":"/**\n\t * Returns a qualifier that evalutes to true when the value of the given key\n\t * contains all of the given tokens (insensitively) in the search string.\n\t * The search string will be tokenized by splitting on space characters.\n\t * \n\t * @param key\n\t *            the key\n\t * @param tokensWithWhitespace\n\t *            a whitespace separated list of tokens to search for\n\t * @return an ERXAndQualifier\n\t */\n\tpublic static ERXAndQualifier containsAll(String key, String tokensWithWhitespace) {\n\t\tString[] searchStrings;\n\t\tif (tokensWithWhitespace == null) {\n\t\t\tsearchStrings = new String[0];\n\t\t}\n\t\telse {\n\t\t\tsearchStrings = tokensWithWhitespace.split(\"\\\\s+\");\n\t\t}\n\t\treturn ERXQ.containsAll(key, searchStrings);\n\t}","commit_id":"d68f1c8acc000d42d1d4ae9452507cc630cbc25a","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Returns a qualifier that evalutes to true when the value of the given key\n\t * contains any of the given tokens (insensitively) in the search string.\n\t * The search string will be tokenized by splitting on space characters.\n\t * \n\t * @param key\n\t *            the key\n\t * @param tokensWithWhitespace\n\t *            a whitespace separated list of tokens to search for\n\t * @return an ERXOrQualifier\n\t */\n\tpublic static ERXOrQualifier containsAny(String key, String tokensWithWhitespace) {\n\t\tString[] searchStrings = tokensWithWhitespace.split(\"\\\\s+\");\n\t\treturn ERXQ.containsAny(key, searchStrings);\n\t}","id":102694,"modified_method":"/**\n\t * Returns a qualifier that evalutes to true when the value of the given key\n\t * contains any of the given tokens (insensitively) in the search string.\n\t * The search string will be tokenized by splitting on space characters.\n\t * \n\t * @param key\n\t *            the key\n\t * @param tokensWithWhitespace\n\t *            a whitespace separated list of tokens to search for\n\t * @return an ERXOrQualifier\n\t */\n\tpublic static ERXOrQualifier containsAny(String key, String tokensWithWhitespace) {\n\t\tString[] searchStrings;\n\t\tif (tokensWithWhitespace == null) {\n\t\t\tsearchStrings = new String[0];\n\t\t}\n\t\telse {\n\t\t\tsearchStrings = tokensWithWhitespace.split(\"\\\\s+\");\n\t\t}\n\t\treturn ERXQ.containsAny(key, searchStrings);\n\t}","commit_id":"d68f1c8acc000d42d1d4ae9452507cc630cbc25a","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void addModule(CommandContext ctx, final ParsedCommandLine parsedCmd) throws CommandLineException {\n\n        final String moduleName = name.getValue(parsedCmd, true);\n\n        final String resourcePaths = resources.getValue(parsedCmd, true);\n        final String[] resourceArr = resourcePaths.split(PATH_SEPARATOR);\n        File[] resourceFiles = new File[resourceArr.length];\n        for(int i = 0; i < resourceArr.length; ++i) {\n            final File f = new File(ctx.getCurrentDir(), resourceArr[i]);\n            if(!f.exists()) {\n                throw new CommandLineException(\"Failed to locate \" + f.getAbsolutePath());\n            }\n            resourceFiles[i] = f;\n        }\n\n        final File moduleDir = getModulePath(getModulesDir(), moduleName, slot.getValue(parsedCmd));\n        if(moduleDir.exists()) {\n            throw new CommandLineException(\"Module \" + moduleName + \" already exists at \" + moduleDir.getAbsolutePath());\n        }\n\n        if(!moduleDir.mkdirs()) {\n            throw new CommandLineException(\"Failed to create directory \" + moduleDir.getAbsolutePath());\n        }\n\n        final ModuleConfigImpl config;\n        final String moduleXml = moduleArg.getValue(parsedCmd);\n        if(moduleXml != null) {\n            config = null;\n            final File source = new File(ctx.getCurrentDir(), moduleXml);\n            if(!source.exists()) {\n                throw new CommandLineException(\"Failed to locate the file on the filesystem: \" + source.getAbsolutePath());\n            }\n            copy(source, new File(moduleDir, \"module.xml\"));\n        } else {\n            config = new ModuleConfigImpl(moduleName);\n        }\n\n        for(File f : resourceFiles) {\n            copy(f, new File(moduleDir, f.getName()));\n            if(config != null) {\n                config.addResource(new ResourceRoot(f.getName()));\n            }\n        }\n\n        if(config != null) {\n            final String dependenciesStr = dependencies.getValue(parsedCmd);\n            if(dependenciesStr != null) {\n                final String[] depsArr = dependenciesStr.split(\",+\");\n                for(String dep : depsArr) {\n                    // TODO validate dependencies\n                    config.addDependency(new ModuleDependency(dep));\n                }\n            }\n\n            final String propsStr = props.getValue(parsedCmd);\n            if(propsStr != null) {\n                final String[] pairs = propsStr.split(\",\");\n                for (String pair : pairs) {\n                    int equals = pair.indexOf('=');\n                    if (equals == -1) {\n                        throw new CommandFormatException(\"Property '\" + pair + \"' in '\" + propsStr + \"' is missing the equals sign.\");\n                    }\n                    final String propName = pair.substring(0, equals);\n                    if (propName.isEmpty()) {\n                        throw new CommandFormatException(\"Property name is missing for '\" + pair + \"' in '\" + propsStr + \"'\");\n                    }\n                    config.setProperty(propName, pair.substring(equals + 1));\n                }\n            }\n\n            final String mainCls = mainClass.getValue(parsedCmd);\n            if(mainCls != null) {\n                config.setMainClass(mainCls);\n            }\n\n            FileWriter moduleWriter = null;\n            final File moduleFile = new File(moduleDir, \"module.xml\");\n            try {\n                moduleWriter = new FileWriter(moduleFile);\n                XMLExtendedStreamWriter xmlWriter = create(XMLOutputFactory.newInstance().createXMLStreamWriter(moduleWriter));\n                config.writeContent(xmlWriter, null);\n                xmlWriter.flush();\n            } catch (IOException e) {\n                throw new CommandLineException(\"Failed to create file \" + moduleFile.getAbsolutePath(), e);\n            } catch (XMLStreamException e) {\n                throw new CommandLineException(\"Failed to write to \" + moduleFile.getAbsolutePath(), e);\n            } finally {\n                if(moduleWriter != null) {\n                    try {\n                        moduleWriter.close();\n                    } catch (IOException e) {}\n                }\n            }\n        }\n    }","id":102695,"modified_method":"protected void addModule(CommandContext ctx, final ParsedCommandLine parsedCmd) throws CommandLineException {\n\n        final String moduleName = name.getValue(parsedCmd, true);\n\n        // resources required only if we are generating module.xml\n        final String resourcePaths = resources.getValue(parsedCmd, !moduleArg.isPresent(parsedCmd));\n\n        final String[] resourceArr = (resourcePaths == null) ? new String[0] : resourcePaths.split(PATH_SEPARATOR);\n        File[] resourceFiles = new File[resourceArr.length];\n        for(int i = 0; i < resourceArr.length; ++i) {\n            final File f = new File(ctx.getCurrentDir(), resourceArr[i]);\n            if(!f.exists()) {\n                throw new CommandLineException(\"Failed to locate \" + f.getAbsolutePath());\n            }\n            resourceFiles[i] = f;\n        }\n\n        final File moduleDir = getModulePath(getModulesDir(), moduleName, slot.getValue(parsedCmd));\n        if(moduleDir.exists()) {\n            throw new CommandLineException(\"Module \" + moduleName + \" already exists at \" + moduleDir.getAbsolutePath());\n        }\n\n        if(!moduleDir.mkdirs()) {\n            throw new CommandLineException(\"Failed to create directory \" + moduleDir.getAbsolutePath());\n        }\n\n        final ModuleConfigImpl config;\n        final String moduleXml = moduleArg.getValue(parsedCmd);\n        if(moduleXml != null) {\n            config = null;\n            final File source = new File(ctx.getCurrentDir(), moduleXml);\n            if(!source.exists()) {\n                throw new CommandLineException(\"Failed to locate the file on the filesystem: \" + source.getAbsolutePath());\n            }\n            copy(source, new File(moduleDir, \"module.xml\"));\n        } else {\n            config = new ModuleConfigImpl(moduleName);\n        }\n\n        for(File f : resourceFiles) {\n            copy(f, new File(moduleDir, f.getName()));\n            if(config != null) {\n                config.addResource(new ResourceRoot(f.getName()));\n            }\n        }\n\n        if(config != null) {\n            final String dependenciesStr = dependencies.getValue(parsedCmd);\n            if(dependenciesStr != null) {\n                final String[] depsArr = dependenciesStr.split(\",+\");\n                for(String dep : depsArr) {\n                    // TODO validate dependencies\n                    config.addDependency(new ModuleDependency(dep));\n                }\n            }\n\n            final String propsStr = props.getValue(parsedCmd);\n            if(propsStr != null) {\n                final String[] pairs = propsStr.split(\",\");\n                for (String pair : pairs) {\n                    int equals = pair.indexOf('=');\n                    if (equals == -1) {\n                        throw new CommandFormatException(\"Property '\" + pair + \"' in '\" + propsStr + \"' is missing the equals sign.\");\n                    }\n                    final String propName = pair.substring(0, equals);\n                    if (propName.isEmpty()) {\n                        throw new CommandFormatException(\"Property name is missing for '\" + pair + \"' in '\" + propsStr + \"'\");\n                    }\n                    config.setProperty(propName, pair.substring(equals + 1));\n                }\n            }\n\n            final String mainCls = mainClass.getValue(parsedCmd);\n            if(mainCls != null) {\n                config.setMainClass(mainCls);\n            }\n\n            FileWriter moduleWriter = null;\n            final File moduleFile = new File(moduleDir, \"module.xml\");\n            try {\n                moduleWriter = new FileWriter(moduleFile);\n                XMLExtendedStreamWriter xmlWriter = create(XMLOutputFactory.newInstance().createXMLStreamWriter(moduleWriter));\n                config.writeContent(xmlWriter, null);\n                xmlWriter.flush();\n            } catch (IOException e) {\n                throw new CommandLineException(\"Failed to create file \" + moduleFile.getAbsolutePath(), e);\n            } catch (XMLStreamException e) {\n                throw new CommandLineException(\"Failed to write to \" + moduleFile.getAbsolutePath(), e);\n            } finally {\n                if(moduleWriter != null) {\n                    try {\n                        moduleWriter.close();\n                    } catch (IOException e) {}\n                }\n            }\n        }\n    }","commit_id":"3b14a5e425283f7af117aba0e61b36a0aedb6a75","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n    * Returns the number of entries in the nameCacheNoCachingList list\n    *\n    * @return int The number of entries in the nameCacheNoCachingList list\n    */\n    public static int nameCacheNoCachingListSize() {\n        return nameCacheNoCachingList.size();\n    }","id":102696,"modified_method":"/**\n    * Returns the number of entries in the nameCacheNoCachingList list\n    *\n    * @return int The number of entries in the nameCacheNoCachingList list\n    */\n    public static int nameCacheNoCachingListSize() {\n        return NAME_CACHE_NO_CACHING_LIST.size();\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static boolean isLocal(final String host, boolean recursive) {\n        if (host == null || host.length() == 0) return true;\n\n        // FIXME IPv4 only\n        // check local ip addresses\n        if (matchesList(host, localhostPatterns)) return true;\n        if (host.startsWith(\"0:0:0:0:0:0:0:1\")) return true;\n        \n        // check if there are other local IP addresses that are not in\n        // the standard IP range\n        if (localHostNames.contains(host)) return true;\n        /*\n        for (InetAddress a: localHostAddresses) {\n            String hostname = getHostName(a);\n            if (hostname != null && hostname.equals(host)) return true;\n            if (a.getHostAddress().equals(host)) return true;\n        }\n        */\n        \n        // check dns lookup: may be a local address even if the domain name looks global\n        if (!recursive) return false;\n        InetAddress a = dnsResolve(host);\n        /*\n        if (a == null) {\n            // unknown if this is a local address. Could also be a timeout.\n            // It would be harmful to declare any public address as local, therefore return false\n            return false;\n        }\n        */\n        return a == null || a.isAnyLocalAddress() || a.isLinkLocalAddress() || a.isLoopbackAddress() || a.isSiteLocalAddress() || isLocal(a.getHostAddress(), false);\n    }","id":102697,"modified_method":"private static boolean isLocal(final String host, boolean recursive) {\n        if (host == null || host.length() == 0) return true;\n\n        // FIXME IPv4 only\n        // check local ip addresses\n        if (matchesList(host, LOCALHOST_PATTERNS)) return true;\n        if (host.startsWith(\"0:0:0:0:0:0:0:1\")) return true;\n        \n        // check if there are other local IP addresses that are not in\n        // the standard IP range\n        if (localHostNames.contains(host)) return true;\n        /*\n        for (InetAddress a: localHostAddresses) {\n            String hostname = getHostName(a);\n            if (hostname != null && hostname.equals(host)) return true;\n            if (a.getHostAddress().equals(host)) return true;\n        }\n        */\n        \n        // check dns lookup: may be a local address even if the domain name looks global\n        if (!recursive) return false;\n        final InetAddress a = dnsResolve(host);\n        /*\n        if (a == null) {\n            // unknown if this is a local address. Could also be a timeout.\n            // It would be harmful to declare any public address as local, therefore return false\n            return false;\n        }\n        */\n        return a == null || a.isAnyLocalAddress() || a.isLinkLocalAddress() || a.isLoopbackAddress() || a.isSiteLocalAddress() || isLocal(a.getHostAddress(), false);\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n    * Returns the number of entries in the nameCacheHit map\n    *\n    * @return int The number of entries in the nameCacheHit map\n    */\n    public static int nameCacheHitSize() {\n        return nameCacheHit.size();\n    }","id":102698,"modified_method":"/**\n    * Returns the number of entries in the nameCacheHit map\n    *\n    * @return int The number of entries in the nameCacheHit map\n    */\n    public static int nameCacheHitSize() {\n        return NAME_CACHE_HIT.size();\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static InetAddress dnsResolve(String host) {\n        if ((host == null) || (host.length() == 0)) return null;\n        host = host.toLowerCase().trim();        \n        // try to simply parse the address\n        InetAddress ip = parseInetAddress(host);\n        if (ip != null) return ip;\n        \n        // try to resolve host by doing a name cache lookup\n        ip = nameCacheHit.get(host);\n        if (ip != null) return ip;\n        \n        if (nameCacheMiss.containsKey(host)) return null;\n        \n        // call dnsResolveNetBased(host) using concurrency to interrupt execution in case of a time-out\n        try {\n            boolean doCaching = true;\n            ip = InetAddress.getByName(host); //TimeoutRequest.getByName(host, 1000); // this makes the DNS request to backbone\n            if ((ip == null) ||\n                (ip.isLoopbackAddress()) ||\n                (nameCacheNoCachingList.containsKey(host))\n            ) {\n                doCaching = false;\n            } else {\n                if (matchesList(host, nameCacheNoCachingPatterns)) {\n                    nameCacheNoCachingList.put(host, PRESENT);\n                    doCaching = false;\n                }\n            }\n            \n            if (doCaching && ip != null) {\n                \n                // add new entries\n                nameCacheHit.put(host, ip);\n            }\n            return ip;\n        } catch (final UnknownHostException e) {\n            // remove old entries\n            flushMissNameCache();\n            \n            // add new entries\n            nameCacheMiss.put(host, PRESENT);\n        }\n        return null;\n    }","id":102699,"modified_method":"public static InetAddress dnsResolve(String host) {\n        if ((host == null) || (host.length() == 0)) return null;\n        host = host.toLowerCase().trim();\n        // try to simply parse the address\n        InetAddress ip = parseInetAddress(host);\n        if (ip != null) return ip;\n        \n        // try to resolve host by doing a name cache lookup\n        ip = NAME_CACHE_HIT.get(host);\n        if (ip != null) return ip;\n        \n        if (NAME_CACHE_MISS.containsKey(host)) return null;\n        \n        // call dnsResolveNetBased(host) using concurrency to interrupt execution in case of a time-out\n        try {\n            boolean doCaching = true;\n            ip = InetAddress.getByName(host); //TimeoutRequest.getByName(host, 1000); // this makes the DNS request to backbone\n            if ((ip == null) ||\n                (ip.isLoopbackAddress()) ||\n                (NAME_CACHE_NO_CACHING_LIST.containsKey(host))\n            ) {\n                doCaching = false;\n            } else {\n                if (matchesList(host, nameCacheNoCachingPatterns)) {\n                    NAME_CACHE_NO_CACHING_LIST.put(host, PRESENT);\n                    doCaching = false;\n                }\n            }\n            \n            if (doCaching && ip != null) {\n                \n                // add new entries\n                NAME_CACHE_HIT.put(host, ip);\n            }\n            return ip;\n        } catch (final UnknownHostException e) {\n            // remove old entries\n            flushMissNameCache();\n            \n            // add new entries\n            NAME_CACHE_MISS.put(host, PRESENT);\n        }\n        return null;\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static String getHostName(final InetAddress i) {\n        Collection<String> hosts = nameCacheHit.getKeys(i);\n        if (hosts.size() > 0) return hosts.iterator().next();\n        String host = i.getHostName();\n        nameCacheHit.put(host, i);\n        return host;\n        /*\n        // call i.getHostName() using concurrency to interrupt execution in case of a time-out\n        try {\n            //TimeoutRequest.getHostName(i, 1000);\n        } catch (ExecutionException e) {\n            return i.getHostAddress();\n        }\n        */\n    }","id":102700,"modified_method":"public static String getHostName(final InetAddress i) {\n        final Collection<String> hosts = NAME_CACHE_HIT.getKeys(i);\n        if (!hosts.isEmpty()) return hosts.iterator().next();\n        final String host = i.getHostName();\n        NAME_CACHE_HIT.put(host, i);\n        return host;\n        /*\n        // call i.getHostName() using concurrency to interrupt execution in case of a time-out\n        try {\n            //TimeoutRequest.getHostName(i, 1000);\n        } catch (ExecutionException e) {\n            return i.getHostAddress();\n        }\n        */\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n    * Does an DNS-Check to resolve a hostname to an IP.\n    *\n    * @param host Hostname of the host in demand.\n    * @return String with the ip. null, if the host could not be resolved.\n    */\n    public static InetAddress dnsResolveFromCache(String host) throws UnknownHostException {\n        if ((host == null) || (host.length() == 0)) return null;\n        host = host.toLowerCase().trim();        \n        \n        // try to simply parse the address\n        InetAddress ip = parseInetAddress(host);\n        if (ip != null) return ip;\n        \n        // trying to resolve host by doing a name cache lookup\n        ip = nameCacheHit.get(host);\n        if (ip != null) return ip;\n        \n        if (nameCacheMiss.containsKey(host)) return null;\n        throw new UnknownHostException(\"host not in cache\");\n    }","id":102701,"modified_method":"/**\n    * Does an DNS-Check to resolve a hostname to an IP.\n    *\n    * @param host Hostname of the host in demand.\n    * @return String with the ip. null, if the host could not be resolved.\n    */\n    public static InetAddress dnsResolveFromCache(String host) throws UnknownHostException {\n        if ((host == null) || host.isEmpty()) return null;\n        host = host.toLowerCase().trim();\n        \n        // try to simply parse the address\n        InetAddress ip = parseInetAddress(host);\n        if (ip != null) return ip;\n        \n        // trying to resolve host by doing a name cache lookup\n        ip = NAME_CACHE_HIT.get(host);\n        if (ip != null) return ip;\n        \n        if (NAME_CACHE_MISS.containsKey(host)) return null;\n        throw new UnknownHostException(\"host not in cache\");\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * generate a list of intranet InetAddresses without the loopback address 127.0.0.1\n     * @return list of all intranet addresses\n     */\n    public static Set<InetAddress> myIntranetIPs() {\n        // list all local addresses\n        if (localHostAddresses.size() < 1) try {Thread.sleep(1000);} catch (InterruptedException e) {}\n        Set<InetAddress> list = new HashSet<InetAddress>();\n        if (localHostAddresses.size() == 0) return list; // give up\n        for (InetAddress a: localHostAddresses) {\n            if ((0Xff & a.getAddress()[0]) == 127) continue;\n            if (!matchesList(a.getHostAddress(), localhostPatterns)) continue;\n            list.add(a);\n        }\n        return list;\n    }","id":102702,"modified_method":"/**\n     * generate a list of intranet InetAddresses without the loopback address 127.0.0.1\n     * @return list of all intranet addresses\n     */\n    public static Set<InetAddress> myIntranetIPs() {\n        // list all local addresses\n        if (localHostAddresses.size() < 1) try {Thread.sleep(1000);} catch (InterruptedException e) {}\n        final Set<InetAddress> list = new HashSet<InetAddress>();\n        if (localHostAddresses.isEmpty()) return list; // give up\n        for (final InetAddress a: localHostAddresses) {\n            if (((0Xff & a.getAddress()[0]) == 127) ||\n                    (!matchesList(a.getHostAddress(), LOCALHOST_PATTERNS))) continue;\n            list.add(a);\n        }\n        return list;\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static boolean matchesList(String obj, List<Pattern> patterns) {\n        for (Pattern nextPattern: patterns) {\n            if (nextPattern.matcher(obj).matches()) return true;\n        }\n        return false;\n    }","id":102703,"modified_method":"public static boolean matchesList(final String obj, final List<Pattern> patterns) {\n        for (final Pattern nextPattern: patterns) {\n            if (nextPattern.matcher(obj).matches()) return true;\n        }\n        return false;\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static List<Pattern> makePatterns(String patternList) {\n    \tfinal String[] entries = patternList.split(\",\");\n    \tfinal List<Pattern> patterns = new ArrayList<Pattern>(entries.length);\n    \tfor (int i = 0; i < entries.length; i++) {\n            patterns.add(Pattern.compile(entries[i].trim()));\n        }\n    \treturn patterns;\n    }","id":102704,"modified_method":"public static List<Pattern> makePatterns(final String patternList) {\n    \tfinal String[] entries = (patternList != null) ? patternList.split(\",\") : new String[0];\n    \tfinal List<Pattern> patterns = new ArrayList<Pattern>(entries.length);\n    \tfor (final String entry : entries) {\n            patterns.add(Pattern.compile(entry.trim()));\n        }\n    \treturn patterns;\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static boolean isThisHostIP(final String hostName) {\n        if ((hostName == null) || (hostName.length() == 0)) return false;\n        \n        boolean isThisHostIP = false;\n        try {\n            final InetAddress clientAddress = Domains.dnsResolve(hostName);\n            if (clientAddress == null) return false;\n            if (clientAddress.isAnyLocalAddress() || clientAddress.isLoopbackAddress()) return true;\n            for (InetAddress a: localHostAddresses) {\n                if (a.equals(clientAddress)) {\n                    isThisHostIP = true;\n                    break;\n                }\n            }  \n        } catch (final Exception e) {}   \n        return isThisHostIP;\n    }","id":102705,"modified_method":"public static boolean isThisHostIP(final String hostName) {\n        if ((hostName == null) || (hostName.length() == 0)) return false;\n        \n        boolean isThisHostIP = false;\n        try {\n            final InetAddress clientAddress = Domains.dnsResolve(hostName);\n            if (clientAddress == null) return false;\n            if (clientAddress.isAnyLocalAddress() || clientAddress.isLoopbackAddress()) return true;\n            for (final InetAddress a: localHostAddresses) {\n                if (a.equals(clientAddress)) {\n                    isThisHostIP = true;\n                    break;\n                }\n            }  \n        } catch (final Exception e) {}   \n        return isThisHostIP;\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static int getDomainID(final String host) {\n        if (host == null || host.length() == 0) return TLD_Local_ID;\n        if (isLocal(host)) return TLD_Local_ID;\n        final int p = host.lastIndexOf('.');\n        String tld = (p > 0) ? host.substring(p + 1) : \"\";\n        final Integer i = TLDID.get(tld);\n        if (i == null) return TLD_Generic_ID;\n        return i.intValue();\n    }","id":102706,"modified_method":"public static int getDomainID(final String host) {\n        if (host == null || host.isEmpty() || isLocal(host)) return TLD_Local_ID;\n        final int p = host.lastIndexOf('.');\n        final String tld = (p > 0) ? host.substring(p + 1) : \"\";\n        final Integer i = TLDID.get(tld);\n        return (i == null) ? TLD_Generic_ID : i.intValue();\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static int nameCacheMissSize() {\n        return nameCacheMiss.size();\n    }","id":102707,"modified_method":"public static int nameCacheMissSize() {\n        return NAME_CACHE_MISS.size();\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * Removes old entries from the dns miss cache\n     */\n     public static void flushMissNameCache() {\n         if (nameCacheMiss.size() > maxNameCacheMissSize) nameCacheMiss.clear();\n    }","id":102708,"modified_method":"/**\n     * Removes old entries from the dns miss cache\n     */\n     public static void flushMissNameCache() {\n         if (NAME_CACHE_MISS.size() > MAX_NAME_CACHE_MISS_SIZE) NAME_CACHE_MISS.clear();\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static InetAddress myPublicLocalIP() {\n        // list all addresses\n        // for (int i = 0; i < localHostAddresses.length; i++) System.out.println(\"IP: \" + localHostAddresses[i].getHostAddress()); // DEBUG\n        if (localHostAddresses.size() == 0) {\n            return null;\n        }\n        if (localHostAddresses.size() == 1) {\n            // only one network connection available\n            return localHostAddresses.iterator().next();\n        }\n        // we have more addresses, find an address that is not local\n        int b0, b1;\n        for (InetAddress a: localHostAddresses) {\n            b0 = 0Xff & a.getAddress()[0];\n            b1 = 0Xff & a.getAddress()[1];\n            if (b0 != 10 && // class A reserved\n                b0 != 127 && // loopback\n                (b0 != 172 || b1 < 16 || b1 > 31) && // class B reserved\n                (b0 != 192 || b1 != 168) && // class C reserved\n                (a.getHostAddress().indexOf(\":\") < 0))\n                return a;\n        }\n        // there is only a local address\n        // return that one that is returned with InetAddress.getLocalHost()\n        // if appropriate\n        try {\n            InetAddress localHostAddress = InetAddress.getLocalHost();\n            if (localHostAddress != null &&\n                (0Xff & localHostAddress.getAddress()[0]) != 127 &&\n                localHostAddress.getHostAddress().indexOf(\":\") < 0) return localHostAddress;\n        } catch (UnknownHostException e) {\n        }\n        // we filter out the loopback address 127.0.0.1 and all addresses without a name\n        for (InetAddress a: localHostAddresses) {\n            if ((0Xff & a.getAddress()[0]) != 127 &&\n                a.getHostAddress().indexOf(\":\") < 0 &&\n                a.getHostName() != null &&\n                a.getHostName().length() > 0) return a;\n        }\n        // if no address has a name, then take any other than the loopback\n        for (InetAddress a: localHostAddresses) {\n            if ((0Xff & a.getAddress()[0]) != 127 &&\n                a.getHostAddress().indexOf(\":\") < 0) return a;\n        }\n        // if all fails, give back whatever we have\n        for (InetAddress a: localHostAddresses) {\n            if (a.getHostAddress().indexOf(\":\") < 0) return a;\n        }\n        // finally, just get any\n        return localHostAddresses.iterator().next();\n    }","id":102709,"modified_method":"public static InetAddress myPublicLocalIP() {\n        // list all addresses\n        // for (int i = 0; i < localHostAddresses.length; i++) System.out.println(\"IP: \" + localHostAddresses[i].getHostAddress()); // DEBUG\n        if (localHostAddresses.isEmpty()) {\n            return null;\n        }\n        if (localHostAddresses.size() == 1) {\n            // only one network connection available\n            return localHostAddresses.iterator().next();\n        }\n        // we have more addresses, find an address that is not local\n        int b0, b1;\n        for (final InetAddress a: localHostAddresses) {\n            b0 = 0Xff & a.getAddress()[0];\n            b1 = 0Xff & a.getAddress()[1];\n            if (b0 != 10 && // class A reserved\n                b0 != 127 && // loopback\n                (b0 != 172 || b1 < 16 || b1 > 31) && // class B reserved\n                (b0 != 192 || b1 != 168) && // class C reserved\n                (a.getHostAddress().indexOf(\":\") < 0))\n                return a;\n        }\n        // there is only a local address\n        // return that one that is returned with InetAddress.getLocalHost()\n        // if appropriate\n        try {\n            final InetAddress localHostAddress = InetAddress.getLocalHost();\n            if (localHostAddress != null &&\n                (0Xff & localHostAddress.getAddress()[0]) != 127 &&\n                localHostAddress.getHostAddress().indexOf(\":\") < 0) return localHostAddress;\n        } catch (UnknownHostException e) {\n        }\n        // we filter out the loopback address 127.0.0.1 and all addresses without a name\n        for (final InetAddress a: localHostAddresses) {\n            if ((0Xff & a.getAddress()[0]) != 127 &&\n                a.getHostAddress().indexOf(\":\") < 0 &&\n                a.getHostName() != null &&\n                !a.getHostName().isEmpty()) return a;\n        }\n        // if no address has a name, then take any other than the loopback\n        for (final InetAddress a: localHostAddresses) {\n            if ((0Xff & a.getAddress()[0]) != 127 &&\n                a.getHostAddress().indexOf(\":\") < 0) return a;\n        }\n        // if all fails, give back whatever we have\n        for (final InetAddress a: localHostAddresses) {\n            if (a.getHostAddress().indexOf(\":\") < 0) return a;\n        }\n        // finally, just get any\n        return localHostAddresses.iterator().next();\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static final InetAddress parseInetAddress(final String ip) {\n        if (ip == null) return null;\n        if (ip.length() < 8) return null;\n        final String[] ips = ip.split(\"\\\\.\");\n        if (ips.length != 4) return null;\n        final byte[] ipb = new byte[4];\n        try {\n            ipb[0] = (byte) Integer.parseInt(ips[0]);\n            ipb[1] = (byte) Integer.parseInt(ips[1]);\n            ipb[2] = (byte) Integer.parseInt(ips[2]);\n            ipb[3] = (byte) Integer.parseInt(ips[3]);\n        } catch (final NumberFormatException e) {\n            return null;\n        }\n        try {\n            return InetAddress.getByAddress(ipb);\n        } catch (final UnknownHostException e) {\n            return null;\n        }\n    }","id":102710,"modified_method":"private static final InetAddress parseInetAddress(final String ip) {\n        if (ip == null || ip.length() < 8) return null;\n        final String[] ips = ip.split(\"\\\\.\");\n        if (ips.length != 4) return null;\n        final byte[] ipb = new byte[4];\n        try {\n            ipb[0] = (byte) Integer.parseInt(ips[0]);\n            ipb[1] = (byte) Integer.parseInt(ips[1]);\n            ipb[2] = (byte) Integer.parseInt(ips[2]);\n            ipb[3] = (byte) Integer.parseInt(ips[3]);\n        } catch (final NumberFormatException e) {\n            return null;\n        }\n        try {\n            return InetAddress.getByAddress(ipb);\n        } catch (final UnknownHostException e) {\n            return null;\n        }\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static boolean isThisHostIP(final InetAddress clientAddress) {\n        if (clientAddress == null) return false;\n        \n        boolean isThisHostIP = false;\n        try {\n            if (clientAddress.isAnyLocalAddress() || clientAddress.isLoopbackAddress()) return true;\n            \n            for (InetAddress a: localHostAddresses) {\n                if (a.equals(clientAddress)) {\n                    isThisHostIP = true;\n                    break;\n                }\n            }  \n        } catch (final Exception e) {}   \n        return isThisHostIP;\n    }","id":102711,"modified_method":"public static boolean isThisHostIP(final InetAddress clientAddress) {\n        if (clientAddress == null) return false;\n        \n        boolean isThisHostIP = false;\n        try {\n            if (clientAddress.isAnyLocalAddress() || clientAddress.isLoopbackAddress()) return true;\n            \n            for (final InetAddress a: localHostAddresses) {\n                if (a.equals(clientAddress)) {\n                    isThisHostIP = true;\n                    break;\n                }\n            }  \n        } catch (final Exception e) {}   \n        return isThisHostIP;\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static void insertTLDProps(final String[] TLDList, final int id) {\n        int p;\n        String tld;\n        //String name;\n        final Integer ID = Integer.valueOf(id);\n        for (int i = 0; i < TLDList.length; i++) {\n            p = TLDList[i].indexOf('=');\n            if (p > 0) {\n                tld = TLDList[i].substring(0, p).toLowerCase();\n                //name = TLDList[i].substring(p + 1);\n                TLDID.put(tld, ID);\n                //TLDName.put(tld, name);\n            }\n        }\n    }","id":102712,"modified_method":"private static void insertTLDProps(final String[] TLDList, final int id) {\n        int p;\n        String tld;\n        //String name;\n        final Integer ID = Integer.valueOf(id);\n        for (final String TLDelement : TLDList) {\n            p = TLDelement.indexOf('=');\n            if (p > 0) {\n                tld = TLDelement.substring(0, p).toLowerCase();\n                //name = TLDList[i].substring(p + 1);\n                TLDID.put(tld, ID);\n                //TLDName.put(tld, name);\n            }\n        }\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void main(String[] args) {\n        /*\n        try {\n            Enumeration<NetworkInterface> nis = NetworkInterface.getNetworkInterfaces();\n            while (nis.hasMoreElements()) {\n                NetworkInterface ni = nis.nextElement();\n                Enumeration<InetAddress> addrs = ni.getInetAddresses();\n                while (addrs.hasMoreElements()) {\n                    InetAddress addr = addrs.nextElement();\n                    System.out.println(addr);\n                }\n            }\n        } catch(SocketException e) {\n            System.err.println(e);\n        }\n        */\n        try { Thread.sleep(1000);} catch (InterruptedException e) {} // get time for class init\n        System.out.println(\"myPublicLocalIP: \" + myPublicLocalIP());\n        for (InetAddress a : myIntranetIPs()) {\n            System.out.println(\"Intranet IP: \" + a);\n        }\n    }","id":102713,"modified_method":"public static void main(final String[] args) {\n        /*\n        try {\n            Enumeration<NetworkInterface> nis = NetworkInterface.getNetworkInterfaces();\n            while (nis.hasMoreElements()) {\n                NetworkInterface ni = nis.nextElement();\n                Enumeration<InetAddress> addrs = ni.getInetAddresses();\n                while (addrs.hasMoreElements()) {\n                    InetAddress addr = addrs.nextElement();\n                    System.out.println(addr);\n                }\n            }\n        } catch(SocketException e) {\n            System.err.println(e);\n        }\n        */\n        try { Thread.sleep(1000);} catch (InterruptedException e) {} // get time for class init\n        System.out.println(\"myPublicLocalIP: \" + myPublicLocalIP());\n        for (final InetAddress a : myIntranetIPs()) {\n            System.out.println(\"Intranet IP: \" + a);\n        }\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static boolean isLocalhost(final String host) {\n        if (host.equals(\"127.0.0.1\")) return true;\n        if (host.equals(\"localhost\")) return true;\n        if (host.startsWith(\"0:0:0:0:0:0:0:1\")) return true;\n        return false;\n    }","id":102714,"modified_method":"public static boolean isLocalhost(final String host) {\n        return (\"127.0.0.1\".equals(host) ||\n                \"localhost\".equals(host) ||\n                host.startsWith(\"0:0:0:0:0:0:0:1\")\n                );\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static final void sendRespondError(\r\n            final Properties conProp,\r\n            final OutputStream respond,\r\n            final int errorcase,\r\n            final int httpStatusCode,            \r\n            String httpStatusText,\r\n            final String detailedErrorMsgText,\r\n            final Object detailedErrorMsgFile,\r\n            final serverObjects detailedErrorMsgValues,\r\n            final Throwable stackTrace,\r\n            ResponseHeader header\r\n    ) throws IOException {\r\n        \r\n        FileInputStream fis = null;\r\n        ByteArrayOutputStream o = null;\r\n        try {\r\n            // setting the proper http status message\r\n            final String httpVersion = conProp.getProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER,\"HTTP/1.1\");\r\n            if ((httpStatusText == null)||(httpStatusText.length()==0)) {\r\n                if (httpVersion.equals(\"HTTP/1.0\") && HeaderFramework.http1_0.containsKey(Integer.toString(httpStatusCode))) \r\n                    httpStatusText = HeaderFramework.http1_0.get(Integer.toString(httpStatusCode));\r\n                else if (httpVersion.equals(\"HTTP/1.1\") && HeaderFramework.http1_1.containsKey(Integer.toString(httpStatusCode)))\r\n                    httpStatusText = HeaderFramework.http1_1.get(Integer.toString(httpStatusCode));\r\n                else httpStatusText = \"Unknown\";\r\n            }\r\n            \r\n            // generating the desired request url\r\n            String host = conProp.getProperty(HeaderFramework.CONNECTION_PROP_HOST);\r\n            final String path = conProp.getProperty(HeaderFramework.CONNECTION_PROP_PATH,\"/\");\r\n            final String args = conProp.getProperty(HeaderFramework.CONNECTION_PROP_ARGS);\r\n            final String method = conProp.getProperty(HeaderFramework.CONNECTION_PROP_METHOD);\r\n            \r\n            int port = 80;\r\n            final int pos = host.indexOf(':');        \r\n            if (pos != -1) {\r\n                port = Integer.parseInt(host.substring(pos + 1));\r\n                host = host.substring(0, pos);\r\n            }\r\n            \r\n            String urlString;\r\n            try {\r\n                urlString = (new DigestURI((method.equals(HeaderFramework.METHOD_CONNECT)?\"https\":\"http\"), host, port, (args == null) ? path : path + \"?\" + args)).toString();\r\n            } catch (final MalformedURLException e) {\r\n                urlString = \"invalid URL\";\r\n            }\r\n\r\n            // set rewrite values\r\n            final serverObjects tp = new serverObjects();\r\n\r\n            final String clientIP = conProp.getProperty(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"127.0.0.1\");\r\n\r\n            // check if ip is local ip address\r\n            final InetAddress hostAddress = Domains.dnsResolve(clientIP);\r\n            if (hostAddress == null) {\r\n                tp.put(\"host\", Domains.myPublicLocalIP().getHostAddress());\r\n                tp.put(\"port\", serverCore.getPortNr(switchboard.getConfig(\"port\", \"8090\")));\r\n            } else if (hostAddress.isSiteLocalAddress() || hostAddress.isLoopbackAddress()) {\r\n                tp.put(\"host\", Domains.myPublicLocalIP().getHostAddress());\r\n                tp.put(\"port\", serverCore.getPortNr(switchboard.getConfig(\"port\", \"8090\")));\r\n            } else {\r\n                tp.put(\"host\", switchboard.myPublicIP());\r\n                tp.put(\"port\", Integer.toString(serverCore.getPortNr(switchboard.getConfig(\"port\", \"8090\"))));\r\n            }\r\n\r\n            tp.put(\"peerName\", (getAlternativeResolver() == null) ? \"\" : getAlternativeResolver().myName());\r\n            tp.put(\"errorMessageType\", errorcase);\r\n            tp.put(\"httpStatus\",       Integer.toString(httpStatusCode) + \" \" + httpStatusText);\r\n            tp.put(\"requestMethod\",    conProp.getProperty(HeaderFramework.CONNECTION_PROP_METHOD));\r\n            tp.put(\"requestURL\",       urlString);\r\n\r\n            switch (errorcase) {\r\n                case ERRORCASE_FILE:\r\n                    tp.put(\"errorMessageType_file\", (detailedErrorMsgFile == null) ? \"\" : detailedErrorMsgFile.toString());\r\n                    if ((detailedErrorMsgValues != null) && !detailedErrorMsgValues.isEmpty()) {\r\n                        // rewriting the value-names and add the proper name prefix:\r\n                        for (Entry<String, String> entry: detailedErrorMsgValues.entrySet()) {\r\n                            tp.put(\"errorMessageType_\" + entry.getKey(), entry.getValue());\r\n                        }                        \r\n                    }                    \r\n                    break;\r\n                case ERRORCASE_MESSAGE:\r\n                default:\r\n                    tp.put(\"errorMessageType_detailedErrorMsg\", (detailedErrorMsgText == null) ? \"\" : detailedErrorMsgText.replaceAll(\"\\n\", \"<br />\"));\r\n                    break;\r\n            }\r\n            \r\n            // building the stacktrace            \r\n            if (stackTrace != null) {  \r\n                tp.put(\"printStackTrace\",1);\r\n                final ByteBuffer errorMsg = new ByteBuffer(100);\r\n                stackTrace.printStackTrace(new PrintStream(errorMsg));\r\n                tp.put(\"printStackTrace_exception\", stackTrace.toString());\r\n                tp.put(\"printStackTrace_stacktrace\", new String(errorMsg.getBytes(),\"UTF-8\"));\r\n            } else {\r\n                tp.put(\"printStackTrace\", 0);\r\n            }\r\n            \r\n            // Generated Tue, 23 Aug 2005 11:19:14 GMT by brain.wg (squid/2.5.STABLE3)\r\n            // adding some system information\r\n            final String systemDate = HeaderFramework.formatRFC1123(new Date());\r\n            tp.put(\"date\", systemDate);\r\n            \r\n            // rewrite the file\r\n            final File htRootPath = new File(switchboard.getAppPath(), switchboard.getConfig(\"htRootPath\",\"htroot\"));\r\n            \r\n            TemplateEngine.writeTemplate(\r\n                    fis = new FileInputStream(new File(htRootPath, \"/proxymsg/error.html\")), \r\n                    o = new ByteArrayOutputStream(512), \r\n                    tp, \r\n                    \"-UNRESOLVED_PATTERN-\".getBytes()\r\n            );\r\n            final byte[] result = o.toByteArray();\r\n            o.close(); o = null;\r\n\r\n            if(header == null)\r\n                header = new ResponseHeader();\r\n            header.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_STATUS, Integer.toString(httpStatusCode));\r\n            header.put(HeaderFramework.DATE, systemDate);\r\n            header.put(HeaderFramework.CONTENT_TYPE, \"text/html\");\r\n            header.put(HeaderFramework.CONTENT_LENGTH, Integer.toString(result.length));\r\n            header.put(HeaderFramework.PRAGMA, \"no-cache\");\r\n            sendRespondHeader(conProp,respond,httpVersion,httpStatusCode,httpStatusText,header);\r\n\r\n            if (! method.equals(HeaderFramework.METHOD_HEAD)) {\r\n                // write the array to the client\r\n                FileUtils.copy(result, respond);\r\n            }\r\n            respond.flush();\r\n        } finally {\r\n            if (fis != null) try { fis.close(); } catch (final Exception e) { Log.logException(e); }\r\n            if (o != null)   try { o.close();   } catch (final Exception e) { Log.logException(e); }\r\n        }     \r\n    }","id":102715,"modified_method":"public static final void sendRespondError(\r\n            final Properties conProp,\r\n            final OutputStream respond,\r\n            final int errorcase,\r\n            final int httpStatusCode,            \r\n            String httpStatusText,\r\n            final String detailedErrorMsgText,\r\n            final Object detailedErrorMsgFile,\r\n            final serverObjects detailedErrorMsgValues,\r\n            final Throwable stackTrace,\r\n            ResponseHeader header\r\n    ) throws IOException {\r\n        \r\n        FileInputStream fis = null;\r\n        ByteArrayOutputStream o = null;\r\n        try {\r\n            // setting the proper http status message\r\n            final String httpVersion = conProp.getProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER,\"HTTP/1.1\");\r\n            if ((httpStatusText == null)||(httpStatusText.length()==0)) {\r\n                if (httpVersion.equals(\"HTTP/1.0\") && HeaderFramework.http1_0.containsKey(Integer.toString(httpStatusCode))) \r\n                    httpStatusText = HeaderFramework.http1_0.get(Integer.toString(httpStatusCode));\r\n                else if (httpVersion.equals(\"HTTP/1.1\") && HeaderFramework.http1_1.containsKey(Integer.toString(httpStatusCode)))\r\n                    httpStatusText = HeaderFramework.http1_1.get(Integer.toString(httpStatusCode));\r\n                else httpStatusText = \"Unknown\";\r\n            }\r\n            \r\n            // generating the desired request url\r\n            String host = conProp.getProperty(HeaderFramework.CONNECTION_PROP_HOST);\r\n            final String path = conProp.getProperty(HeaderFramework.CONNECTION_PROP_PATH,\"/\");\r\n            final String args = conProp.getProperty(HeaderFramework.CONNECTION_PROP_ARGS);\r\n            final String method = conProp.getProperty(HeaderFramework.CONNECTION_PROP_METHOD);\r\n            \r\n            final int port;\r\n            final int pos = host.indexOf(':');        \r\n            if (pos != -1) {\r\n                port = Integer.parseInt(host.substring(pos + 1));\r\n                host = host.substring(0, pos);\r\n            } else {\r\n                port = 80;\r\n            }\r\n            \r\n            String urlString;\r\n            try {\r\n                urlString = (new DigestURI((method.equals(HeaderFramework.METHOD_CONNECT)?\"https\":\"http\"), host, port, (args == null) ? path : path + \"?\" + args)).toString();\r\n            } catch (final MalformedURLException e) {\r\n                urlString = \"invalid URL\";\r\n            }\r\n\r\n            // set rewrite values\r\n            final serverObjects tp = new serverObjects();\r\n\r\n            final String clientIP = conProp.getProperty(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"127.0.0.1\");\r\n\r\n            // check if ip is local ip address\r\n            final InetAddress hostAddress = Domains.dnsResolve(clientIP);\r\n            if (hostAddress == null) {\r\n                tp.put(\"host\", Domains.myPublicLocalIP().getHostAddress());\r\n                tp.put(\"port\", serverCore.getPortNr(switchboard.getConfig(\"port\", \"8090\")));\r\n            } else if (hostAddress.isSiteLocalAddress() || hostAddress.isLoopbackAddress()) {\r\n                tp.put(\"host\", Domains.myPublicLocalIP().getHostAddress());\r\n                tp.put(\"port\", serverCore.getPortNr(switchboard.getConfig(\"port\", \"8090\")));\r\n            } else {\r\n                tp.put(\"host\", switchboard.myPublicIP());\r\n                tp.put(\"port\", Integer.toString(serverCore.getPortNr(switchboard.getConfig(\"port\", \"8090\"))));\r\n            }\r\n\r\n            tp.put(\"peerName\", (getAlternativeResolver() == null) ? \"\" : getAlternativeResolver().myName());\r\n            tp.put(\"errorMessageType\", errorcase);\r\n            tp.put(\"httpStatus\",       Integer.toString(httpStatusCode) + \" \" + httpStatusText);\r\n            tp.put(\"requestMethod\",    conProp.getProperty(HeaderFramework.CONNECTION_PROP_METHOD));\r\n            tp.put(\"requestURL\",       urlString);\r\n\r\n            switch (errorcase) {\r\n                case ERRORCASE_FILE:\r\n                    tp.put(\"errorMessageType_file\", (detailedErrorMsgFile == null) ? \"\" : detailedErrorMsgFile.toString());\r\n                    if ((detailedErrorMsgValues != null) && !detailedErrorMsgValues.isEmpty()) {\r\n                        // rewriting the value-names and add the proper name prefix:\r\n                        for (final Entry<String, String> entry: detailedErrorMsgValues.entrySet()) {\r\n                            tp.put(\"errorMessageType_\" + entry.getKey(), entry.getValue());\r\n                        }                        \r\n                    }                    \r\n                    break;\r\n                case ERRORCASE_MESSAGE:\r\n                default:\r\n                    tp.put(\"errorMessageType_detailedErrorMsg\", (detailedErrorMsgText == null) ? \"\" : detailedErrorMsgText.replaceAll(\"\\n\", \"<br />\"));\r\n                    break;\r\n            }\r\n            \r\n            // building the stacktrace            \r\n            if (stackTrace != null) {  \r\n                tp.put(\"printStackTrace\",1);\r\n                final ByteBuffer errorMsg = new ByteBuffer(100);\r\n                stackTrace.printStackTrace(new PrintStream(errorMsg));\r\n                tp.put(\"printStackTrace_exception\", stackTrace.toString());\r\n                tp.put(\"printStackTrace_stacktrace\", new String(errorMsg.getBytes(),\"UTF-8\"));\r\n            } else {\r\n                tp.put(\"printStackTrace\", 0);\r\n            }\r\n            \r\n            // Generated Tue, 23 Aug 2005 11:19:14 GMT by brain.wg (squid/2.5.STABLE3)\r\n            // adding some system information\r\n            final String systemDate = HeaderFramework.formatRFC1123(new Date());\r\n            tp.put(\"date\", systemDate);\r\n            \r\n            // rewrite the file\r\n            final File htRootPath = new File(switchboard.getAppPath(), switchboard.getConfig(\"htRootPath\",\"htroot\"));\r\n            \r\n            TemplateEngine.writeTemplate(\r\n                    fis = new FileInputStream(new File(htRootPath, \"/proxymsg/error.html\")), \r\n                    o = new ByteArrayOutputStream(512), \r\n                    tp, \r\n                    \"-UNRESOLVED_PATTERN-\".getBytes()\r\n            );\r\n            final byte[] result = o.toByteArray();\r\n            o.close(); o = null;\r\n\r\n            if(header == null) {\r\n                header = new ResponseHeader();\r\n            }\r\n            header.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_STATUS, Integer.toString(httpStatusCode));\r\n            header.put(HeaderFramework.DATE, systemDate);\r\n            header.put(HeaderFramework.CONTENT_TYPE, \"text/html\");\r\n            header.put(HeaderFramework.CONTENT_LENGTH, Integer.toString(result.length));\r\n            header.put(HeaderFramework.PRAGMA, \"no-cache\");\r\n            sendRespondHeader(conProp,respond,httpVersion,httpStatusCode,httpStatusText,header);\r\n\r\n            if (! method.equals(HeaderFramework.METHOD_HEAD)) {\r\n                // write the array to the client\r\n                FileUtils.copy(result, respond);\r\n            }\r\n            respond.flush();\r\n        } finally {\r\n            if (fis != null) try { fis.close(); } catch (final Exception e) { Log.logException(e); }\r\n            if (o != null)   try { o.close();   } catch (final Exception e) { Log.logException(e); }\r\n        }     \r\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static Properties parseRequestLine(final String cmd, String args, final String virtualHost) {\r\n        \r\n        final Properties prop = new Properties();\r\n        \r\n        // storing informations about the request\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_METHOD, cmd);\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_REQUESTLINE, cmd + \" \" + args);\r\n        \r\n        // this parses a whole URL\r\n        if (args.length() == 0) {\r\n            prop.setProperty(HeaderFramework.CONNECTION_PROP_HOST, virtualHost);\r\n            prop.setProperty(HeaderFramework.CONNECTION_PROP_PATH, \"/\");\r\n            prop.setProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, HeaderFramework.HTTP_VERSION_0_9);\r\n            prop.setProperty(HeaderFramework.CONNECTION_PROP_EXT, \"\");\r\n            return prop;\r\n        }\r\n        \r\n        // store the version propery \"HTTP\" and cut the query at both ends\r\n        int sep = args.lastIndexOf(' ');\r\n        if ((sep >= 0)&&(args.substring(sep + 1).toLowerCase().startsWith(\"http/\"))) {\r\n            // HTTP version is given\r\n            prop.setProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, args.substring(sep + 1).trim());\r\n            args = args.substring(0, sep).trim(); // cut off HTTP version mark\r\n        } else {\r\n            // HTTP version is not given, it will be treated as ver 0.9\r\n            prop.setProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, HeaderFramework.HTTP_VERSION_0_9);\r\n        }\r\n        \r\n        // replacing spaces in the url string correctly\r\n        args = P_20.matcher(args).replaceAll(\"%20\");\r\n        // replace unwise characters (see RFC 2396, 2.4.3), which may not be escaped\r\n        args = P_7B.matcher(args).replaceAll(\"%7B\");\r\n        args = P_7D.matcher(args).replaceAll(\"%7D\");\r\n        args = P_7C.matcher(args).replaceAll(\"%7C\");\r\n        args = P_5C.matcher(args).replaceAll(\"%5C\");\r\n        args = P_5E.matcher(args).replaceAll(\"%5E\");\r\n        args = P_5B.matcher(args).replaceAll(\"%5B\");\r\n        args = P_5D.matcher(args).replaceAll(\"%5D\");\r\n        args = P_60.matcher(args).replaceAll(\"%60\");\r\n        \r\n        // properties of the query are stored with the prefix \"&\"\r\n        // additionally, the values URL and ARGC are computed\r\n        \r\n        String argsString = \"\";\r\n        sep = args.indexOf('?');\r\n        if (sep >= 0) {\r\n            // there are values attached to the query string\r\n            argsString = args.substring(sep + 1); // cut head from tail of query\r\n            args = args.substring(0, sep);\r\n        }\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_URL, args); // store URL\r\n        //System.out.println(\"HTTPD: ARGS=\" + argsString);\r\n        if (argsString.length() != 0) prop.setProperty(HeaderFramework.CONNECTION_PROP_ARGS, argsString); // store arguments in original form\r\n        \r\n        // finally find host string\r\n        String path;\r\n        if (args.toUpperCase().startsWith(\"HTTP://\")) {\r\n            // a host was given. extract it and set path\r\n            args = args.substring(7);\r\n            sep = args.indexOf('/');\r\n            if (sep < 0) {\r\n                // this is a malformed url, something like\r\n                // http://index.html\r\n                // we are lazy and guess that it means\r\n                // /index.html\r\n                // which is a localhost access to the file servlet\r\n                prop.setProperty(HeaderFramework.CONNECTION_PROP_HOST, args);\r\n                path = \"/\";\r\n            } else {\r\n                // THIS IS THE \"GOOD\" CASE\r\n                // a perfect formulated url\r\n                final String dstHostSocket = args.substring(0, sep);\r\n                prop.setProperty(HeaderFramework.CONNECTION_PROP_HOST, (HTTPDemon.isThisHostName(dstHostSocket) ? virtualHost : dstHostSocket));\r\n                path = args.substring(sep); // yes, including beginning \"/\"\r\n            }\r\n        } else {\r\n            // no host in url. set path\r\n            if (args.length() > 0 && args.charAt(0) == '/') {\r\n                // thats also fine, its a perfect localhost access\r\n                // in this case, we simulate a\r\n                // http://localhost/s\r\n                // access by setting a virtual host\r\n                prop.setProperty(HeaderFramework.CONNECTION_PROP_HOST, virtualHost);\r\n                path = args;\r\n            } else {\r\n                // the client 'forgot' to set a leading '/'\r\n                // this is the same case as above, with some lazyness\r\n                prop.setProperty(HeaderFramework.CONNECTION_PROP_HOST, virtualHost);\r\n                path = \"/\" + args;\r\n            }\r\n        }\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_PATH, path);\r\n\r\n        // find out file extension (we already stripped ?-parameters from args)\r\n        String ext = \"\";  // default when no file extension\r\n        sep = path.lastIndexOf('.');\r\n        if (sep >= 0) {\r\n            final int ancpos = path.indexOf(\"#\", sep + 1);\r\n            if (ancpos  >= sep) {\r\n                // ex: /foo/bar.html#xy => html\r\n                ext = path.substring(sep + 1, ancpos).toLowerCase();\r\n            } else {\r\n                // ex: /foo/bar.php => php\r\n                ext = path.substring(sep + 1).toLowerCase();\r\n            }\r\n        }\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_EXT, ext);\r\n        \r\n        return prop;\r\n    }","id":102716,"modified_method":"public static Properties parseRequestLine(final String cmd, String args, final String virtualHost) {\r\n        \r\n        final Properties prop = new Properties();\r\n        \r\n        // storing informations about the request\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_METHOD, cmd);\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_REQUESTLINE, cmd + \" \" + args);\r\n        \r\n        // this parses a whole URL\r\n        if (args.isEmpty()) {\r\n            prop.setProperty(HeaderFramework.CONNECTION_PROP_HOST, virtualHost);\r\n            prop.setProperty(HeaderFramework.CONNECTION_PROP_PATH, \"/\");\r\n            prop.setProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, HeaderFramework.HTTP_VERSION_0_9);\r\n            prop.setProperty(HeaderFramework.CONNECTION_PROP_EXT, \"\");\r\n            return prop;\r\n        }\r\n        \r\n        // store the version propery \"HTTP\" and cut the query at both ends\r\n        int sep = args.lastIndexOf(' ');\r\n        if ((sep >= 0) && (args.substring(sep + 1).toLowerCase().startsWith(\"http/\"))) {\r\n            // HTTP version is given\r\n            prop.setProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, args.substring(sep + 1).trim());\r\n            args = args.substring(0, sep).trim(); // cut off HTTP version mark\r\n        } else {\r\n            // HTTP version is not given, it will be treated as ver 0.9\r\n            prop.setProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, HeaderFramework.HTTP_VERSION_0_9);\r\n        }\r\n        \r\n        // replacing spaces in the url string correctly\r\n        args = P_20.matcher(args).replaceAll(\"%20\");\r\n        // replace unwise characters (see RFC 2396, 2.4.3), which may not be escaped\r\n        args = P_7B.matcher(args).replaceAll(\"%7B\");\r\n        args = P_7D.matcher(args).replaceAll(\"%7D\");\r\n        args = P_7C.matcher(args).replaceAll(\"%7C\");\r\n        args = P_5C.matcher(args).replaceAll(\"%5C\");\r\n        args = P_5E.matcher(args).replaceAll(\"%5E\");\r\n        args = P_5B.matcher(args).replaceAll(\"%5B\");\r\n        args = P_5D.matcher(args).replaceAll(\"%5D\");\r\n        args = P_60.matcher(args).replaceAll(\"%60\");\r\n        \r\n        // properties of the query are stored with the prefix \"&\"\r\n        // additionally, the values URL and ARGC are computed\r\n        \r\n        final String argsString;\r\n        sep = args.indexOf('?');\r\n        if (sep >= 0) {\r\n            // there are values attached to the query string\r\n            argsString = args.substring(sep + 1); // cut head from tail of query\r\n            args = args.substring(0, sep);\r\n        } else {\r\n            argsString = \"\";\r\n        }\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_URL, args); // store URL\r\n        if (!argsString.isEmpty()) {\r\n            prop.setProperty(HeaderFramework.CONNECTION_PROP_ARGS, argsString);\r\n        } // store arguments in original form\r\n        \r\n        // finally find host string\r\n        final String path;\r\n        if (args.toUpperCase().startsWith(\"HTTP://\")) {\r\n            // a host was given. extract it and set path\r\n            args = args.substring(7);\r\n            sep = args.indexOf('/');\r\n            if (sep < 0) {\r\n                // this is a malformed url, something like\r\n                // http://index.html\r\n                // we are lazy and guess that it means\r\n                // /index.html\r\n                // which is a localhost access to the file servlet\r\n                prop.setProperty(HeaderFramework.CONNECTION_PROP_HOST, args);\r\n                path = \"/\";\r\n            } else {\r\n                // THIS IS THE \"GOOD\" CASE\r\n                // a perfect formulated url\r\n                final String dstHostSocket = args.substring(0, sep);\r\n                prop.setProperty(HeaderFramework.CONNECTION_PROP_HOST, (HTTPDemon.isThisHostName(dstHostSocket) ? virtualHost : dstHostSocket));\r\n                path = args.substring(sep); // yes, including beginning \"/\"\r\n            }\r\n        } else {\r\n            // no host in url. set path\r\n            if (args.length() > 0 && args.charAt(0) == '/') {\r\n                // thats also fine, its a perfect localhost access\r\n                // in this case, we simulate a\r\n                // http://localhost/s\r\n                // access by setting a virtual host\r\n                prop.setProperty(HeaderFramework.CONNECTION_PROP_HOST, virtualHost);\r\n                path = args;\r\n            } else {\r\n                // the client 'forgot' to set a leading '/'\r\n                // this is the same case as above, with some lazyness\r\n                prop.setProperty(HeaderFramework.CONNECTION_PROP_HOST, virtualHost);\r\n                path = \"/\" + args;\r\n            }\r\n        }\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_PATH, path);\r\n\r\n        // find out file extension (we already stripped ?-parameters from args)\r\n        final String ext;\r\n        sep = path.lastIndexOf('.');\r\n        if (sep >= 0) {\r\n            final int ancpos = path.indexOf(\"#\", sep + 1);\r\n            if (ancpos  >= sep) {\r\n                // ex: /foo/bar.html#xy => html\r\n                ext = path.substring(sep + 1, ancpos).toLowerCase();\r\n            } else {\r\n                // ex: /foo/bar.php => php\r\n                ext = path.substring(sep + 1).toLowerCase();\r\n            }\r\n        } else {\r\n            ext = \"\"; // default when no file extension\r\n        }\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_EXT, ext);\r\n        \r\n        return prop;\r\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static int indexOf(final int start, final byte[] array, final byte[] pattern) {\r\n        // return a position of a pattern in an array\r\n        if (start > array.length - pattern.length) return -1;\r\n        if (pattern.length == 0) return start;\r\n        for (int pos = start; pos <= array.length - pattern.length; pos++)\r\n            if ((array[pos] == pattern[0]) && (equals(array, pos, pattern, 0, pattern.length)))\r\n                return pos;\r\n        return -1;\r\n    }","id":102717,"modified_method":"public static int indexOf(final int start, final byte[] array, final byte[] pattern) {\r\n        // return a position of a pattern in an array\r\n        if (start > array.length - pattern.length) return -1;\r\n        if (pattern.length == 0) return start;\r\n        for (int pos = start, lens = array.length - pattern.length; pos <= lens; pos++) {\r\n            if ((array[pos] == pattern[0]) && (equals(array, pos, pattern, 0, pattern.length))) {\r\n                return pos;\r\n            }\r\n        }\r\n        return -1;\r\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static String decodeHtmlEntities(String s) {\r\n        // replace all entities defined in wikiCode.characters and htmlentities\r\n        s = CharacterCoding.html2unicode(s);\r\n        \r\n        // replace all other \r\n        final CharArrayWriter b = new CharArrayWriter(s.length());\r\n        int end;\r\n        for (int i=0; i<s.length(); i++) {\r\n            if (s.charAt(i) == '&' && (end = s.indexOf(';', i + 1)) > i) {\r\n                if (s.charAt(i + 1) == '#') {                           // &#1234; symbols\r\n                    b.write(Integer.parseInt(s.substring(i + 2, end)));\r\n                    i += end - i;\r\n                } else {                                                // 'named' smybols\r\n                    if (log.isFine()) log.logFine(\"discovered yet unimplemented HTML entity '\" + s.substring(i, end + 1) + \"'\");\r\n                    b.write(s.charAt(i));\r\n                }\r\n            } else {\r\n                b.write(s.charAt(i));\r\n            }\r\n        }\r\n        return b.toString();\r\n    }","id":102718,"modified_method":"public static String decodeHtmlEntities(String s) {\r\n        // replace all entities defined in wikiCode.characters and htmlentities\r\n        s = CharacterCoding.html2unicode(s);\r\n        \r\n        // replace all other \r\n        final CharArrayWriter b = new CharArrayWriter(s.length());\r\n        int end;\r\n        for (int i = 0, len = s.length(); i < len; i++) {\r\n            if (s.charAt(i) == '&' && (end = s.indexOf(';', i + 1)) > i) {\r\n                if (s.charAt(i + 1) == '#') {                           // &#1234; symbols\r\n                    b.write(Integer.parseInt(s.substring(i + 2, end)));\r\n                    i += end - i;\r\n                } else {                                                // 'named' smybols\r\n                    if (log.isFine()) log.logFine(\"discovered yet unimplemented HTML entity '\" + s.substring(i, end + 1) + \"'\");\r\n                    b.write(s.charAt(i));\r\n                }\r\n            } else {\r\n                b.write(s.charAt(i));\r\n            }\r\n        }\r\n        return b.toString();\r\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static final void sendRespondHeader(\r\n            final Properties conProp,\r\n            final OutputStream respond,\r\n            final String httpVersion,\r\n            final int httpStatusCode,\r\n            final String httpStatusText,\r\n            String contentType,\r\n            final long contentLength,\r\n            Date moddate,\r\n            final Date expires,\r\n            ResponseHeader headers,\r\n            final String contentEnc,\r\n            final String transferEnc,\r\n            final boolean nocache\r\n    ) throws IOException {\r\n        \r\n        final String reqMethod = conProp.getProperty(HeaderFramework.CONNECTION_PROP_METHOD);\r\n        \r\n        if ((transferEnc != null) && !httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1)) { \r\n            throw new IllegalArgumentException(\"Transfer encoding is only supported for http/1.1 connections. The current connection version is \" + httpVersion);\r\n        }\r\n\r\n        if (!reqMethod.equals(HeaderFramework.METHOD_HEAD)){\r\n            if (!conProp.getProperty(HeaderFramework.CONNECTION_PROP_PERSISTENT,\"close\").equals(\"close\")) {\r\n                if (transferEnc == null && contentLength < 0) {\r\n                    throw new IllegalArgumentException(\"Message MUST contain a Content-Length or a non-identity transfer-coding header field.\");\r\n                }\r\n            }\r\n            if (transferEnc != null && contentLength >= 0) {\r\n                throw new IllegalArgumentException(\"Messages MUST NOT include both a Content-Length header field and a non-identity transfer-coding.\");\r\n            }            \r\n        }\r\n        \r\n        if(headers==null) headers = new ResponseHeader();\r\n        final Date now = new Date(System.currentTimeMillis());\r\n        \r\n        headers.put(HeaderFramework.SERVER, \"AnomicHTTPD (www.anomic.de)\");\r\n        headers.put(HeaderFramework.DATE, HeaderFramework.formatRFC1123(now));\r\n        if (moddate.after(now)) {\r\n            //System.out.println(\"*** DEBUG: correcting moddate = \" + moddate.toString() + \" to now = \" + now.toString());\r\n            moddate = now;\r\n        }\r\n        headers.put(HeaderFramework.LAST_MODIFIED, HeaderFramework.formatRFC1123(moddate));\r\n        \r\n        if (nocache) {\r\n            headers.put(HeaderFramework.CACHE_CONTROL, \"no-cache\");\r\n            headers.put(HeaderFramework.CACHE_CONTROL, \"no-store\");\r\n            headers.put(HeaderFramework.PRAGMA, \"no-cache\");\r\n        }\r\n        \r\n        if (contentType == null) contentType = \"text/html; charset=UTF-8\";\r\n        if (headers.get(HeaderFramework.CONTENT_TYPE) == null) headers.put(HeaderFramework.CONTENT_TYPE, contentType);  \r\n        if (contentLength > 0)   headers.put(HeaderFramework.CONTENT_LENGTH, Long.toString(contentLength));\r\n        //if (cookie != null)      headers.put(httpHeader.SET_COOKIE, cookie);\r\n        if (expires != null)     headers.put(HeaderFramework.EXPIRES, HeaderFramework.formatRFC1123(expires));\r\n        if (contentEnc != null)  headers.put(HeaderFramework.CONTENT_ENCODING, contentEnc);\r\n        if (transferEnc != null) headers.put(HeaderFramework.TRANSFER_ENCODING, transferEnc);\r\n        \r\n        sendRespondHeader(conProp, respond, httpVersion, httpStatusCode, httpStatusText, headers);\r\n    }","id":102719,"modified_method":"public static final void sendRespondHeader(\r\n            final Properties conProp,\r\n            final OutputStream respond,\r\n            final String httpVersion,\r\n            final int httpStatusCode,\r\n            final String httpStatusText,\r\n            String contentType,\r\n            final long contentLength,\r\n            Date moddate,\r\n            final Date expires,\r\n            ResponseHeader headers,\r\n            final String contentEnc,\r\n            final String transferEnc,\r\n            final boolean nocache\r\n    ) throws IOException {\r\n        \r\n        final String reqMethod = conProp.getProperty(HeaderFramework.CONNECTION_PROP_METHOD);\r\n        \r\n        if ((transferEnc != null) && !httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1)) { \r\n            throw new IllegalArgumentException(\"Transfer encoding is only supported for http/1.1 connections. The current connection version is \" + httpVersion);\r\n        }\r\n\r\n        if (!reqMethod.equals(HeaderFramework.METHOD_HEAD)){\r\n            if (!conProp.getProperty(HeaderFramework.CONNECTION_PROP_PERSISTENT,\"close\").equals(\"close\") &&\r\n                    transferEnc == null && contentLength < 0) {\r\n                throw new IllegalArgumentException(\"Message MUST contain a Content-Length or a non-identity transfer-coding header field.\");\r\n            }\r\n            if (transferEnc != null && contentLength >= 0) {\r\n                throw new IllegalArgumentException(\"Messages MUST NOT include both a Content-Length header field and a non-identity transfer-coding.\");\r\n            }            \r\n        }\r\n        \r\n        if (headers == null) {\r\n            headers = new ResponseHeader();\r\n        }\r\n        final Date now = new Date(System.currentTimeMillis());\r\n        \r\n        headers.put(HeaderFramework.SERVER, \"AnomicHTTPD (www.anomic.de)\");\r\n        headers.put(HeaderFramework.DATE, HeaderFramework.formatRFC1123(now));\r\n        if (moddate.after(now)) {\r\n            moddate = now;\r\n        }\r\n        headers.put(HeaderFramework.LAST_MODIFIED, HeaderFramework.formatRFC1123(moddate));\r\n        \r\n        if (nocache) {\r\n            headers.put(HeaderFramework.CACHE_CONTROL, \"no-cache\");\r\n            headers.put(HeaderFramework.CACHE_CONTROL, \"no-store\");\r\n            headers.put(HeaderFramework.PRAGMA, \"no-cache\");\r\n        }\r\n        \r\n        if (contentType == null) contentType = \"text/html; charset=UTF-8\";\r\n        if (headers.get(HeaderFramework.CONTENT_TYPE) == null) headers.put(HeaderFramework.CONTENT_TYPE, contentType);  \r\n        if (contentLength > 0)   headers.put(HeaderFramework.CONTENT_LENGTH, Long.toString(contentLength));\r\n        //if (cookie != null)      headers.put(httpHeader.SET_COOKIE, cookie);\r\n        if (expires != null)     headers.put(HeaderFramework.EXPIRES, HeaderFramework.formatRFC1123(expires));\r\n        if (contentEnc != null)  headers.put(HeaderFramework.CONTENT_ENCODING, contentEnc);\r\n        if (transferEnc != null) headers.put(HeaderFramework.TRANSFER_ENCODING, transferEnc);\r\n        \r\n        sendRespondHeader(conProp, respond, httpVersion, httpStatusCode, httpStatusText, headers);\r\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Boolean GET(final String arg, Session session) {\r\n        try {\r\n            // parsing the http request line\r\n            Properties prop = parseRequestLine(HeaderFramework.METHOD_GET, arg, session);\r\n            \r\n            // we now know the HTTP version. depending on that, we read the header            \r\n            final String httpVersion = prop.getProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, HeaderFramework.HTTP_VERSION_0_9);\r\n            final RequestHeader header = (httpVersion.equals(HeaderFramework.HTTP_VERSION_0_9)) \r\n            \t\t\t      ? new RequestHeader(reverseMappingCache) \r\n                              : readHeader(prop, session);                  \r\n            \r\n            // handling transparent proxy support\r\n            handleTransparentProxySupport(header, prop, virtualHost, HTTPDProxyHandler.isTransparentProxy); \r\n            \r\n            // determines if the connection should be kept alive\r\n            handlePersistentConnection(header, prop);\r\n            \r\n            if (prop.getProperty(HeaderFramework.CONNECTION_PROP_HOST).equals(virtualHost)) {\r\n                // pass to server\r\n                if (allowServer(session)) {\r\n                    HTTPDFileHandler.doGet(prop, header, session.out);\r\n                } else {\r\n                    // not authorized through firewall blocking (ip does not match filter)\r\n                    session.out.write((httpVersion + \" 403 refused (IP not granted, 1)\" + serverCore.CRLF_STRING + serverCore.CRLF_STRING + \"you are not allowed to connect to this server, because you are using a non-granted IP (\" + session.userAddress.getHostAddress() + \"). allowed are only connections that match with the following filter: \" + switchboard.getConfig(\"serverClient\", \"*\") + serverCore.CRLF_STRING).getBytes());\r\n                    return serverCore.TERMINATE_CONNECTION;\r\n                }\r\n            } else {\r\n                // pass to proxy\r\n                if (((allowYaCyHop(session)) && (handleYaCyHopAuthentication(header, prop, session))) ||\r\n                    ((allowProxy(session)) && (handleProxyAuthentication(header, prop, session)))) {\r\n                    HTTPDProxyHandler.doGet(prop, header, session.out);\r\n                } else {\r\n                    // not authorized through firewall blocking (ip does not match filter)\r\n                    session.out.write((httpVersion + \" 403 refused (IP not granted, 2)\" + serverCore.CRLF_STRING + serverCore.CRLF_STRING + \"you are not allowed to connect to this proxy, because you are using a non-granted IP (\" + session.userAddress.getHostAddress() + \"). allowed are only connections that match with the following filter: \" + switchboard.getConfig(\"proxyClient\", \"*\") + serverCore.CRLF_STRING).getBytes());\r\n                    return serverCore.TERMINATE_CONNECTION;\r\n                }\r\n            }\r\n            \r\n            return prop.getProperty(HeaderFramework.CONNECTION_PROP_PERSISTENT).equals(\"keep-alive\") ? serverCore.RESUME_CONNECTION : serverCore.TERMINATE_CONNECTION;\r\n        } catch (final Exception e) {\r\n            logUnexpectedError(e, session.userAddress.getHostAddress());\r\n            return serverCore.TERMINATE_CONNECTION;\r\n        }\r\n    }","id":102720,"modified_method":"public Boolean GET(final String arg, final Session session) {\r\n        try {\r\n            // parsing the http request line\r\n            final Properties prop = parseRequestLine(HeaderFramework.METHOD_GET, arg, session);\r\n            \r\n            // we now know the HTTP version. depending on that, we read the header            \r\n            final String httpVersion = prop.getProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, HeaderFramework.HTTP_VERSION_0_9);\r\n            final RequestHeader header = (httpVersion.equals(HeaderFramework.HTTP_VERSION_0_9))\r\n                    ? new RequestHeader(reverseMappingCache)\r\n                    : readHeader(prop, session);\r\n            \r\n            // handling transparent proxy support\r\n            handleTransparentProxySupport(header, prop, virtualHost, HTTPDProxyHandler.isTransparentProxy); \r\n            \r\n            // determines if the connection should be kept alive\r\n            handlePersistentConnection(header, prop);\r\n            \r\n            if (prop.getProperty(HeaderFramework.CONNECTION_PROP_HOST).equals(virtualHost)) {\r\n                // pass to server\r\n                if (allowServer(session)) {\r\n                    HTTPDFileHandler.doGet(prop, header, session.out);\r\n                } else {\r\n                    // not authorized through firewall blocking (ip does not match filter)\r\n                    session.out.write((httpVersion + \" 403 refused (IP not granted, 1)\" + serverCore.CRLF_STRING + serverCore.CRLF_STRING + \"you are not allowed to connect to this server, because you are using a non-granted IP (\" + session.userAddress.getHostAddress() + \"). allowed are only connections that match with the following filter: \" + switchboard.getConfig(\"serverClient\", \"*\") + serverCore.CRLF_STRING).getBytes());\r\n                    return serverCore.TERMINATE_CONNECTION;\r\n                }\r\n            } else {\r\n                // pass to proxy\r\n                if (((allowYaCyHop(session)) && (handleYaCyHopAuthentication(header, prop, session))) ||\r\n                    ((allowProxy(session)) && (handleProxyAuthentication(header, prop, session)))) {\r\n                    HTTPDProxyHandler.doGet(prop, header, session.out);\r\n                } else {\r\n                    // not authorized through firewall blocking (ip does not match filter)\r\n                    session.out.write((httpVersion + \" 403 refused (IP not granted, 2)\" + serverCore.CRLF_STRING + serverCore.CRLF_STRING + \"you are not allowed to connect to this proxy, because you are using a non-granted IP (\" + session.userAddress.getHostAddress() + \"). allowed are only connections that match with the following filter: \" + switchboard.getConfig(\"proxyClient\", \"*\") + serverCore.CRLF_STRING).getBytes());\r\n                    return serverCore.TERMINATE_CONNECTION;\r\n                }\r\n            }\r\n            \r\n            return prop.getProperty(HeaderFramework.CONNECTION_PROP_PERSISTENT).equals(\"keep-alive\") ? serverCore.RESUME_CONNECTION : serverCore.TERMINATE_CONNECTION;\r\n        } catch (final Exception e) {\r\n            logUnexpectedError(e, session.userAddress.getHostAddress());\r\n            return serverCore.TERMINATE_CONNECTION;\r\n        }\r\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * This function is used to determine if a persistent connection was requested by the client.\r\n     * @param header the received http-headers\r\n     * @return <code>true<\/code> if a persistent connection was requested or <code>false<\/code> otherwise\r\n     */\r\n    private boolean handlePersistentConnection(final RequestHeader header, Properties prop) {\r\n        \r\n        if (!keepAliveSupport) {\r\n            prop.put(HeaderFramework.CONNECTION_PROP_PERSISTENT,\"close\");\r\n            return false;\r\n        }\r\n        \r\n        // getting the http version that is used by the client\r\n        final String httpVersion = prop.getProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, \"HTTP/0.9\");\r\n        \r\n        // managing keep-alive: in HTTP/0.9 and HTTP/1.0 every connection is closed\r\n        // afterwards. In HTTP/1.1 (and above, in the future?) connections are\r\n        // persistent by default, but closed with the \"Connection: close\"\r\n        // property.\r\n        boolean persistent = !(httpVersion.equals(HeaderFramework.HTTP_VERSION_0_9) || httpVersion.equals(HeaderFramework.HTTP_VERSION_1_0));\r\n        if ((header.get(RequestHeader.CONNECTION, \"keep-alive\")).toLowerCase().indexOf(\"close\") != -1 || \r\n            (header.get(RequestHeader.PROXY_CONNECTION, \"keep-alive\")).toLowerCase().indexOf(\"close\") != -1) {\r\n            persistent = false;\r\n        }        \r\n        \r\n        final String transferEncoding = header.get(HeaderFramework.TRANSFER_ENCODING, \"identity\");\r\n        final boolean isPostRequest = prop.getProperty(HeaderFramework.CONNECTION_PROP_METHOD).equals(HeaderFramework.METHOD_POST);\r\n        final boolean hasContentLength = header.containsKey(HeaderFramework.CONTENT_LENGTH);\r\n        final boolean hasTransferEncoding = header.containsKey(HeaderFramework.TRANSFER_ENCODING) && !transferEncoding.equalsIgnoreCase(\"identity\");\r\n        \r\n        // if the request does not contain a content-length we have to close the connection\r\n        // independently of the value of the connection header\r\n        if (persistent && isPostRequest && !(hasContentLength || hasTransferEncoding)) \r\n        \t  prop.put(HeaderFramework.CONNECTION_PROP_PERSISTENT,\"close\");\r\n        else  prop.put(HeaderFramework.CONNECTION_PROP_PERSISTENT,persistent?\"keep-alive\":\"close\");\r\n        \r\n        return persistent;\r\n    }","id":102721,"modified_method":"/**\r\n     * This function is used to determine if a persistent connection was requested by the client.\r\n     * @param header the received http-headers\r\n     * @param prop \r\n     * @return <code>true<\/code> if a persistent connection was requested or <code>false<\/code> otherwise\r\n     */\r\n    private boolean handlePersistentConnection(final RequestHeader header, final Properties prop) {\r\n        \r\n        if (!keepAliveSupport) {\r\n            prop.put(HeaderFramework.CONNECTION_PROP_PERSISTENT,\"close\");\r\n            return false;\r\n        }\r\n        \r\n        // getting the http version that is used by the client\r\n        final String httpVersion = prop.getProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, \"HTTP/0.9\");\r\n        \r\n        // managing keep-alive: in HTTP/0.9 and HTTP/1.0 every connection is closed\r\n        // afterwards. In HTTP/1.1 (and above, in the future?) connections are\r\n        // persistent by default, but closed with the \"Connection: close\"\r\n        // property.\r\n        boolean persistent = !(httpVersion.equals(HeaderFramework.HTTP_VERSION_0_9) || httpVersion.equals(HeaderFramework.HTTP_VERSION_1_0));\r\n        if ((header.get(RequestHeader.CONNECTION, \"keep-alive\")).toLowerCase().indexOf(\"close\") != -1 || \r\n            (header.get(RequestHeader.PROXY_CONNECTION, \"keep-alive\")).toLowerCase().indexOf(\"close\") != -1) {\r\n            persistent = false;\r\n        }        \r\n        \r\n        final String transferEncoding = header.get(HeaderFramework.TRANSFER_ENCODING, \"identity\");\r\n        final boolean isPostRequest = prop.getProperty(HeaderFramework.CONNECTION_PROP_METHOD).equals(HeaderFramework.METHOD_POST);\r\n        final boolean hasContentLength = header.containsKey(HeaderFramework.CONTENT_LENGTH);\r\n        final boolean hasTransferEncoding = header.containsKey(HeaderFramework.TRANSFER_ENCODING) && !transferEncoding.equalsIgnoreCase(\"identity\");\r\n        \r\n        // if the request does not contain a content-length we have to close the connection\r\n        // independently of the value of the connection header\r\n        if (persistent && isPostRequest && !(hasContentLength || hasTransferEncoding)) \r\n        \t  prop.put(HeaderFramework.CONNECTION_PROP_PERSISTENT,\"close\");\r\n        else  prop.put(HeaderFramework.CONNECTION_PROP_PERSISTENT,persistent?\"keep-alive\":\"close\");\r\n        \r\n        return persistent;\r\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private final Properties parseRequestLine(final String cmd, final String s, Session session) {\r\n        \r\n        // parsing the header\r\n        Properties p = parseRequestLine(cmd, s, virtualHost);\r\n        \r\n        // track the request\r\n        final String path = p.getProperty(HeaderFramework.CONNECTION_PROP_URL);\r\n        final String args = p.getProperty(HeaderFramework.CONNECTION_PROP_ARGS, \"\");\r\n        switchboard.track(session.userAddress.getHostAddress(), (args.length() > 0) ? path + \"?\" + args : path);\r\n\r\n        // reseting the empty request counter\r\n        this.emptyRequestCount = 0;\r\n        \r\n        // counting the amount of received requests within this permanent connection\r\n        p.setProperty(HeaderFramework.CONNECTION_PROP_KEEP_ALIVE_COUNT, Integer.toString(++this.keepAliveRequestCount));\r\n        \r\n        // setting the client-IP\r\n        p.setProperty(HeaderFramework.CONNECTION_PROP_CLIENTIP, session.userAddress.getHostAddress());\r\n        \r\n        return p;\r\n    }","id":102722,"modified_method":"private final Properties parseRequestLine(final String cmd, final String s, final Session session) {\r\n        \r\n        // parsing the header\r\n        final Properties p = parseRequestLine(cmd, s, virtualHost);\r\n        \r\n        // track the request\r\n        final String path = p.getProperty(HeaderFramework.CONNECTION_PROP_URL);\r\n        final String args = p.getProperty(HeaderFramework.CONNECTION_PROP_ARGS, \"\");\r\n        switchboard.track(session.userAddress.getHostAddress(), (args.length() > 0) ? path + \"?\" + args : path);\r\n\r\n        // reseting the empty request counter\r\n        this.emptyRequestCount = 0;\r\n        \r\n        // counting the amount of received requests within this permanent connection\r\n        p.setProperty(HeaderFramework.CONNECTION_PROP_KEEP_ALIVE_COUNT, Integer.toString(++this.keepAliveRequestCount));\r\n        \r\n        // setting the client-IP\r\n        p.setProperty(HeaderFramework.CONNECTION_PROP_CLIENTIP, session.userAddress.getHostAddress());\r\n        \r\n        return p;\r\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Boolean EMPTY(final String arg, Session session) throws IOException {\r\n        if (++this.emptyRequestCount > 10) return serverCore.TERMINATE_CONNECTION;\r\n        return serverCore.RESUME_CONNECTION;\r\n    }","id":102723,"modified_method":"public Boolean EMPTY(final String arg, final Session session) throws IOException {\r\n        return (++this.emptyRequestCount > 10) ? serverCore.TERMINATE_CONNECTION : serverCore.RESUME_CONNECTION;\r\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static long lastAccessDelta(final Map<String, Long> accessTable, final String domain) {\r\n        final Long lastAccess = accessTable.get(domain);\r\n        if (lastAccess == null) return Long.MAX_VALUE; // never accessed\r\n        return System.currentTimeMillis() - lastAccess.longValue();\r\n    }","id":102724,"modified_method":"private static long lastAccessDelta(final Map<String, Long> accessTable, final String domain) {\r\n        final Long lastAccess = accessTable.get(domain);\r\n        return (lastAccess == null) ? Long.MAX_VALUE : System.currentTimeMillis() - lastAccess.longValue();\r\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Boolean HEAD(final String arg, Session session) {\r\n        try {\r\n            Properties prop = parseRequestLine(HeaderFramework.METHOD_HEAD, arg, session);\r\n            \r\n            // we now know the HTTP version. depending on that, we read the header\r\n            RequestHeader header;\r\n            final String httpVersion = prop.getProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, HeaderFramework.HTTP_VERSION_0_9);\r\n            if (httpVersion.equals(HeaderFramework.HTTP_VERSION_0_9)) header = new RequestHeader(reverseMappingCache);\r\n            else  header = readHeader(prop,session);\r\n            \r\n            // handle transparent proxy support\r\n            handleTransparentProxySupport(header, prop, virtualHost, HTTPDProxyHandler.isTransparentProxy);\r\n            \r\n            // determines if the connection should be kept alive\r\n            handlePersistentConnection(header, prop);\r\n            \r\n            // return multi-line message\r\n            if (prop.getProperty(HeaderFramework.CONNECTION_PROP_HOST).equals(virtualHost)) {\r\n                // pass to server\r\n                if (allowServer(session)) {\r\n                    HTTPDFileHandler.doHead(prop, header, session.out);\r\n                } else {\r\n                    // not authorized through firewall blocking (ip does not match filter)\r\n                    session.out.write((httpVersion + \" 403 refused (IP not granted)\" +\r\n                            serverCore.CRLF_STRING).getBytes());\r\n                    return serverCore.TERMINATE_CONNECTION;\r\n                }\r\n            } else {\r\n                // pass to proxy\r\n                if (((allowYaCyHop(session)) && (handleYaCyHopAuthentication(header, prop, session))) ||\r\n                    ((allowProxy(session)) && (handleProxyAuthentication(header, prop, session)))) {\r\n                    HTTPDProxyHandler.doHead(prop, header, session.out);\r\n                } else {\r\n                    // not authorized through firewall blocking (ip does not match filter)\r\n                    session.out.write((httpVersion + \" 403 refused (IP not granted)\" +\r\n                            serverCore.CRLF_STRING).getBytes());\r\n                    return serverCore.TERMINATE_CONNECTION;\r\n                }\r\n            }\r\n            return prop.getProperty(HeaderFramework.CONNECTION_PROP_PERSISTENT).equals(\"keep-alive\") ? serverCore.RESUME_CONNECTION : serverCore.TERMINATE_CONNECTION;\r\n        } catch (final Exception e) {\r\n            logUnexpectedError(e, session.userAddress.getHostAddress());\r\n            return serverCore.TERMINATE_CONNECTION;\r\n        }\r\n    }","id":102725,"modified_method":"public Boolean HEAD(final String arg, final Session session) {\r\n        try {\r\n            final Properties prop = parseRequestLine(HeaderFramework.METHOD_HEAD, arg, session);\r\n            \r\n            // we now know the HTTP version. depending on that, we read the header\r\n            final String httpVersion = prop.getProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, HeaderFramework.HTTP_VERSION_0_9);\r\n            final RequestHeader header = (httpVersion.equals(HeaderFramework.HTTP_VERSION_0_9))\r\n                    ? new RequestHeader(reverseMappingCache)\r\n                    : readHeader(prop,session);\r\n            \r\n            // handle transparent proxy support\r\n            handleTransparentProxySupport(header, prop, virtualHost, HTTPDProxyHandler.isTransparentProxy);\r\n            \r\n            // determines if the connection should be kept alive\r\n            handlePersistentConnection(header, prop);\r\n            \r\n            // return multi-line message\r\n            if (prop.getProperty(HeaderFramework.CONNECTION_PROP_HOST).equals(virtualHost)) {\r\n                // pass to server\r\n                if (allowServer(session)) {\r\n                    HTTPDFileHandler.doHead(prop, header, session.out);\r\n                } else {\r\n                    // not authorized through firewall blocking (ip does not match filter)\r\n                    session.out.write((httpVersion + \" 403 refused (IP not granted)\" +\r\n                            serverCore.CRLF_STRING).getBytes());\r\n                    return serverCore.TERMINATE_CONNECTION;\r\n                }\r\n            } else {\r\n                // pass to proxy\r\n                if (((allowYaCyHop(session)) && (handleYaCyHopAuthentication(header, prop, session))) ||\r\n                    ((allowProxy(session)) && (handleProxyAuthentication(header, prop, session)))) {\r\n                    HTTPDProxyHandler.doHead(prop, header, session.out);\r\n                } else {\r\n                    // not authorized through firewall blocking (ip does not match filter)\r\n                    session.out.write((httpVersion + \" 403 refused (IP not granted)\" +\r\n                            serverCore.CRLF_STRING).getBytes());\r\n                    return serverCore.TERMINATE_CONNECTION;\r\n                }\r\n            }\r\n            return prop.getProperty(HeaderFramework.CONNECTION_PROP_PERSISTENT).equals(\"keep-alive\") ? serverCore.RESUME_CONNECTION : serverCore.TERMINATE_CONNECTION;\r\n        } catch (final Exception e) {\r\n            logUnexpectedError(e, session.userAddress.getHostAddress());\r\n            return serverCore.TERMINATE_CONNECTION;\r\n        }\r\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * parses the message accordingly to RFC 1867 using \"Commons FileUpload\" (http://commons.apache.org/fileupload/)\r\n     * \r\n     * @author danielr\r\n     * @since 07.08.2008\r\n     * @param header\r\n     *            hier muss ARGC gesetzt werden!\r\n     * @param args\r\n     * @param in the raw body\r\n     * @return\r\n     * @throws IOException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static Map<String, byte[]> parseMultipart(final RequestHeader header, final serverObjects args, final InputStream in) throws IOException {\r\n        //ByteArrayInputStream in = new ByteArrayInputStream(FileUtils.read(inx));\r\n        final InputStream body = prepareBody(header, in);\r\n        \r\n        RequestContext request = new yacyContextRequest(header, body);\r\n\r\n        // check information\r\n        if (!FileUploadBase.isMultipartContent(request)) {\r\n            throw new IOException(\"the request is not a multipart-message!\");\r\n        }\r\n        \r\n        // check if we have enough memory\r\n        if (!MemoryControl.request(request.getContentLength() * 3, false)) {\r\n        \tthrow new IOException(\"not enough memory available for request. request.getContentLength() = \" + request.getContentLength() + \", MemoryControl.available() = \" + MemoryControl.available());\r\n        }\r\n\r\n        // parse data in memory\r\n        FileUpload upload = new FileUpload(diskFileItemFactory);\r\n        List<FileItem> items;\r\n        //long time = System.currentTimeMillis();\r\n        try {\r\n            items = upload.parseRequest(request);\r\n        } catch (FileUploadException e) {\r\n            //Log.logException(e);\r\n            throw new IOException(\"FileUploadException \" + e.getMessage());\r\n        }\r\n        //System.out.println(\"**** FileUploadBase.parseRequest time = \" + (System.currentTimeMillis() - time));\r\n        \r\n        // format information for further usage\r\n        final HashMap<String, byte[]> files = new HashMap<String, byte[]>();\r\n        for (FileItem item : items) {\r\n            if (item.isFormField()) {\r\n                // simple text\r\n                if (item.getContentType() == null || !item.getContentType().contains(\"charset\")) {\r\n                    // old yacy clients use their local default charset, on most systems UTF-8 (I hope ;)\r\n                    args.put(item.getFieldName(), item.getString(\"UTF-8\"));\r\n                } else {\r\n                    // use default encoding (given as header or ISO-8859-1)\r\n                    args.put(item.getFieldName(), item.getString());\r\n                }\r\n            } else {\r\n                // file\r\n                args.put(item.getFieldName(), item.getName());\r\n                final byte[] fileContent = FileUtils.read(item.getInputStream());\r\n                item.getInputStream().close();\r\n                files.put(item.getFieldName(), fileContent);\r\n            }\r\n        }\r\n        header.put(\"ARGC\", String.valueOf(items.size())); // store argument count\r\n\r\n        return files;\r\n    }","id":102726,"modified_method":"/**\r\n     * parses the message accordingly to RFC 1867 using \"Commons FileUpload\" (http://commons.apache.org/fileupload/)\r\n     * \r\n     * @author danielr\r\n     * @since 07.08.2008\r\n     * @param header\r\n     *            hier muss ARGC gesetzt werden!\r\n     * @param args\r\n     * @param in the raw body\r\n     * @return\r\n     * @throws IOException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static Map<String, byte[]> parseMultipart(final RequestHeader header, final serverObjects args, final InputStream in) throws IOException {\r\n\r\n        final InputStream body = prepareBody(header, in);\r\n        \r\n        RequestContext request = new yacyContextRequest(header, body);\r\n\r\n        // check information\r\n        if (!FileUploadBase.isMultipartContent(request)) {\r\n            throw new IOException(\"the request is not a multipart-message!\");\r\n        }\r\n        \r\n        // check if we have enough memory\r\n        if (!MemoryControl.request(request.getContentLength() * 3, false)) {\r\n        \tthrow new IOException(\"not enough memory available for request. request.getContentLength() = \" + request.getContentLength() + \", MemoryControl.available() = \" + MemoryControl.available());\r\n        }\r\n\r\n        // parse data in memory\r\n        final FileUpload upload = new FileUpload(DISK_FILE_ITEM_FACTORY);\r\n        final List<FileItem> items;\r\n\r\n        try {\r\n            items = upload.parseRequest(request);\r\n        } catch (FileUploadException e) {\r\n            throw new IOException(\"FileUploadException \" + e.getMessage());\r\n        }\r\n\r\n        // format information for further usage\r\n        final Map<String, byte[]> files = new HashMap<String, byte[]>();\r\n        for (final FileItem item : items) {\r\n            if (item.isFormField()) {\r\n                // simple text\r\n                if (item.getContentType() == null || !item.getContentType().contains(\"charset\")) {\r\n                    // old yacy clients use their local default charset, on most systems UTF-8 (I hope ;)\r\n                    args.put(item.getFieldName(), item.getString(\"UTF-8\"));\r\n                } else {\r\n                    // use default encoding (given as header or ISO-8859-1)\r\n                    args.put(item.getFieldName(), item.getString());\r\n                }\r\n            } else {\r\n                // file\r\n                args.put(item.getFieldName(), item.getName());\r\n                final byte[] fileContent = FileUtils.read(item.getInputStream());\r\n                item.getInputStream().close();\r\n                files.put(item.getFieldName(), fileContent);\r\n            }\r\n        }\r\n        header.put(\"ARGC\", String.valueOf(items.size())); // store argument count\r\n\r\n        return files;\r\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Boolean POST(final String arg, Session session) {\r\n        try {\r\n            Properties prop = parseRequestLine(HeaderFramework.METHOD_POST, arg, session);\r\n            \r\n            // we now know the HTTP version. depending on that, we read the header\r\n            RequestHeader header;\r\n            final String httpVersion = prop.getProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, HeaderFramework.HTTP_VERSION_0_9);\r\n            if (httpVersion.equals(HeaderFramework.HTTP_VERSION_0_9))  header = new RequestHeader(reverseMappingCache);\r\n            else header = readHeader(prop, session);\r\n            \r\n            // handle transfer-coding\r\n            final InputStream sessionIn;\r\n            final String transferEncoding = header.get(HeaderFramework.TRANSFER_ENCODING);\r\n            if (transferEncoding != null) {\r\n                if (!HeaderFramework.HTTP_VERSION_1_1.equals(httpVersion)) {\r\n                    log.logWarning(\"client \"+ session.getName() +\" uses transfer-coding with HTTP version \"+ httpVersion +\"!\");\r\n                }\r\n                if(\"chunked\".equalsIgnoreCase(header.get(HeaderFramework.TRANSFER_ENCODING))) {\r\n                    sessionIn = new ChunkedInputStream(session.in);\r\n                } else {\r\n                    // \"A server which receives an entity-body with a transfer-coding it does\r\n                    // not understand SHOULD return 501 (Unimplemented), and close the\r\n                    // connection.\" [RFC 2616, section 3.6]\r\n                    session.out.write((httpVersion + \" 501 transfer-encoding not implemented\" + serverCore.CRLF_STRING + serverCore.CRLF_STRING + \"you send a transfer-encoding to this server, which is not supported: \" + transferEncoding + serverCore.CRLF_STRING).getBytes());\r\n                    return serverCore.TERMINATE_CONNECTION;\r\n                }\r\n            } else {\r\n                sessionIn = session.in;\r\n            }\r\n            \r\n            // handle transparent proxy support\r\n            handleTransparentProxySupport(header, prop, virtualHost, HTTPDProxyHandler.isTransparentProxy);\r\n            \r\n            // determines if the connection should be kept alive\r\n            handlePersistentConnection(header, prop);\r\n            \r\n            // return multi-line message\r\n            if (prop.getProperty(HeaderFramework.CONNECTION_PROP_HOST).equals(virtualHost)) {\r\n                // pass to server\r\n                if (allowServer(session)) {\r\n                    HTTPDFileHandler.doPost(prop, header, session.out, sessionIn);\r\n                } else {\r\n                    // not authorized through firewall blocking (ip does not match filter)\r\n                    session.out.write((httpVersion + \" 403 refused (IP not granted)\" + serverCore.CRLF_STRING + serverCore.CRLF_STRING + \"you are not allowed to connect to this server, because you are using the non-granted IP \" + session.userAddress.getHostAddress() + \". allowed are only connections that match with the following filter: \" + switchboard.getConfig(\"serverClient\", \"*\") + serverCore.CRLF_STRING).getBytes());\r\n                    return serverCore.TERMINATE_CONNECTION;\r\n                }\r\n            } else {\r\n                // pass to proxy\r\n                if (((allowYaCyHop(session)) && (handleYaCyHopAuthentication(header, prop, session))) ||\r\n                    ((allowProxy(session)) && (handleProxyAuthentication(header, prop, session)))) {\r\n                    HTTPDProxyHandler.doPost(prop, header, session.out, sessionIn);\r\n                } else {\r\n                    // not authorized through firewall blocking (ip does not match filter)\r\n                    session.out.write((httpVersion + \" 403 refused (IP not granted)\" + serverCore.CRLF_STRING + serverCore.CRLF_STRING + \"you are not allowed to connect to this proxy, because you are using the non-granted IP \" + session.userAddress.getHostAddress() + \". allowed are only connections that match with the following filter: \" + switchboard.getConfig(\"proxyClient\", \"*\") + serverCore.CRLF_STRING).getBytes());\r\n                    return serverCore.TERMINATE_CONNECTION;\r\n                }\r\n            }\r\n            if (sessionIn instanceof ChunkedInputStream) sessionIn.close(); // read to end, but do not close the stream (maybe HTTP/1.1 persistent)\r\n            //return serverCore.RESUME_CONNECTION;\r\n            return prop.getProperty(HeaderFramework.CONNECTION_PROP_PERSISTENT).equals(\"keep-alive\") ? serverCore.RESUME_CONNECTION : serverCore.TERMINATE_CONNECTION;\r\n        } catch (final Exception e) {\r\n            logUnexpectedError(e, session.userAddress.getHostAddress());\r\n            return serverCore.TERMINATE_CONNECTION;\r\n        }\r\n    }","id":102727,"modified_method":"public Boolean POST(final String arg, final Session session) {\r\n        try {\r\n            final Properties prop = parseRequestLine(HeaderFramework.METHOD_POST, arg, session);\r\n            \r\n            // we now know the HTTP version. depending on that, we read the header\r\n            final String httpVersion = prop.getProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, HeaderFramework.HTTP_VERSION_0_9);\r\n            final RequestHeader header = (httpVersion.equals(HeaderFramework.HTTP_VERSION_0_9))\r\n                    ? new RequestHeader(reverseMappingCache)\r\n                    : readHeader(prop, session);\r\n            \r\n            // handle transfer-coding\r\n            final InputStream sessionIn;\r\n            final String transferEncoding = header.get(HeaderFramework.TRANSFER_ENCODING);\r\n            if (transferEncoding != null) {\r\n                if (!HeaderFramework.HTTP_VERSION_1_1.equals(httpVersion)) {\r\n                    log.logWarning(\"client \"+ session.getName() +\" uses transfer-coding with HTTP version \"+ httpVersion +\"!\");\r\n                }\r\n                if(\"chunked\".equalsIgnoreCase(header.get(HeaderFramework.TRANSFER_ENCODING))) {\r\n                    sessionIn = new ChunkedInputStream(session.in);\r\n                } else {\r\n                    // \"A server which receives an entity-body with a transfer-coding it does\r\n                    // not understand SHOULD return 501 (Unimplemented), and close the\r\n                    // connection.\" [RFC 2616, section 3.6]\r\n                    session.out.write((httpVersion + \" 501 transfer-encoding not implemented\" + serverCore.CRLF_STRING + serverCore.CRLF_STRING + \"you send a transfer-encoding to this server, which is not supported: \" + transferEncoding + serverCore.CRLF_STRING).getBytes());\r\n                    return serverCore.TERMINATE_CONNECTION;\r\n                }\r\n            } else {\r\n                sessionIn = session.in;\r\n            }\r\n            \r\n            // handle transparent proxy support\r\n            handleTransparentProxySupport(header, prop, virtualHost, HTTPDProxyHandler.isTransparentProxy);\r\n            \r\n            // determines if the connection should be kept alive\r\n            handlePersistentConnection(header, prop);\r\n            \r\n            // return multi-line message\r\n            if (prop.getProperty(HeaderFramework.CONNECTION_PROP_HOST).equals(virtualHost)) {\r\n                // pass to server\r\n                if (allowServer(session)) {\r\n                    HTTPDFileHandler.doPost(prop, header, session.out, sessionIn);\r\n                } else {\r\n                    // not authorized through firewall blocking (ip does not match filter)\r\n                    session.out.write((httpVersion + \" 403 refused (IP not granted)\" + serverCore.CRLF_STRING + serverCore.CRLF_STRING + \"you are not allowed to connect to this server, because you are using the non-granted IP \" + session.userAddress.getHostAddress() + \". allowed are only connections that match with the following filter: \" + switchboard.getConfig(\"serverClient\", \"*\") + serverCore.CRLF_STRING).getBytes());\r\n                    return serverCore.TERMINATE_CONNECTION;\r\n                }\r\n            } else {\r\n                // pass to proxy\r\n                if (((allowYaCyHop(session)) && (handleYaCyHopAuthentication(header, prop, session))) ||\r\n                    ((allowProxy(session)) && (handleProxyAuthentication(header, prop, session)))) {\r\n                    HTTPDProxyHandler.doPost(prop, header, session.out, sessionIn);\r\n                } else {\r\n                    // not authorized through firewall blocking (ip does not match filter)\r\n                    session.out.write((httpVersion + \" 403 refused (IP not granted)\" + serverCore.CRLF_STRING + serverCore.CRLF_STRING + \"you are not allowed to connect to this proxy, because you are using the non-granted IP \" + session.userAddress.getHostAddress() + \". allowed are only connections that match with the following filter: \" + switchboard.getConfig(\"proxyClient\", \"*\") + serverCore.CRLF_STRING).getBytes());\r\n                    return serverCore.TERMINATE_CONNECTION;\r\n                }\r\n            }\r\n            if (sessionIn instanceof ChunkedInputStream) sessionIn.close(); // read to end, but do not close the stream (maybe HTTP/1.1 persistent)\r\n            //return serverCore.RESUME_CONNECTION;\r\n            return prop.getProperty(HeaderFramework.CONNECTION_PROP_PERSISTENT).equals(\"keep-alive\") ? serverCore.RESUME_CONNECTION : serverCore.TERMINATE_CONNECTION;\r\n        } catch (final Exception e) {\r\n            logUnexpectedError(e, session.userAddress.getHostAddress());\r\n            return serverCore.TERMINATE_CONNECTION;\r\n        }\r\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Boolean CONNECT(String arg, Session session) throws IOException {\r\n        // establish a ssh-tunneled http connection\r\n        // this is to support https   \r\n        \r\n        // parse HTTP version\r\n        int pos = arg.indexOf(' ');\r\n        String httpVersion = \"HTTP/1.0\";\r\n        if (pos >= 0) {\r\n            httpVersion = arg.substring(pos + 1);\r\n            arg = arg.substring(0, pos);\r\n        }\r\n        Properties prop = new Properties();\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, httpVersion);\r\n        \r\n        // parse hostname and port\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_HOST, arg);\r\n        pos = arg.indexOf(':');\r\n        int port = 443;\r\n        if (pos >= 0) {\r\n            port = Integer.parseInt(arg.substring(pos + 1));\r\n            //the offcut: arg = arg.substring(0, pos);\r\n        }       \r\n        \r\n        // setting other connection properties\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_CLIENTIP, session.userAddress.isAnyLocalAddress() ? \"localhost\" : session.userAddress.getHostAddress());\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_METHOD, HeaderFramework.METHOD_CONNECT);\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_PATH, \"/\");\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_EXT, \"\");\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_URL, \"\");        \r\n        \r\n        // parse remaining lines\r\n        final RequestHeader header = readHeader(prop,session);               \r\n        \r\n        if (!(allowProxy(session))) {\r\n            // not authorized through firewall blocking (ip does not match filter)          \r\n            session.out.write((httpVersion + \" 403 refused (IP not granted)\" + serverCore.CRLF_STRING + serverCore.CRLF_STRING + \"you are not allowed to connect to this proxy, because you are using the non-granted IP \" + session.userAddress.getHostAddress() + \". allowed are only connections that match with the following filter: \" + switchboard.getConfig(\"proxyClient\", \"*\") + serverCore.CRLF_STRING).getBytes());\r\n            return serverCore.TERMINATE_CONNECTION;\r\n        }        \r\n        \r\n        if (port != 443 && switchboard.getConfig(\"secureHttps\", \"true\").equals(\"true\")) {\r\n            // security: connection only to ssl port\r\n            // we send a 403 (forbidden) error back\r\n            session.out.write((httpVersion + \" 403 Connection to non-443 forbidden\" +\r\n                    serverCore.CRLF_STRING + serverCore.CRLF_STRING).getBytes());\r\n            return serverCore.TERMINATE_CONNECTION;\r\n        }\r\n        \r\n        // pass to proxy\r\n        if (((allowYaCyHop(session)) && (handleYaCyHopAuthentication(header, prop, session))) ||\r\n            ((allowProxy(session)) && (this.handleProxyAuthentication(header, prop, session)))) {\r\n            HTTPDProxyHandler.doConnect(prop, header, session.in, session.out);\r\n        } else {\r\n            // not authorized through firewall blocking (ip does not match filter)\r\n            session.out.write((httpVersion + \" 403 refused (IP not granted)\" + serverCore.CRLF_STRING + serverCore.CRLF_STRING + \"you are not allowed to connect to this proxy, because you are using the non-granted IP \" + session.userAddress.getHostAddress() + \". allowed are only connections that match with the following filter: \" + switchboard.getConfig(\"proxyClient\", \"*\") + serverCore.CRLF_STRING).getBytes());\r\n        }\r\n        \r\n        return serverCore.TERMINATE_CONNECTION;\r\n    }","id":102728,"modified_method":"public Boolean CONNECT(String arg, final Session session) throws IOException {\r\n        // establish a ssh-tunneled http connection\r\n        // this is to support https   \r\n        \r\n        // parse HTTP version\r\n        int pos = arg.indexOf(' ');\r\n        final String httpVersion;\r\n        if (pos >= 0) {\r\n            httpVersion = arg.substring(pos + 1);\r\n            arg = arg.substring(0, pos);\r\n        } else {\r\n            httpVersion = \"HTTP/1.0\";\r\n        }\r\n        Properties prop = new Properties();\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_HTTP_VER, httpVersion);\r\n        \r\n        // parse hostname and port\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_HOST, arg);\r\n        pos = arg.indexOf(':');\r\n        int port = 443;\r\n        if (pos >= 0) {\r\n            port = Integer.parseInt(arg.substring(pos + 1));\r\n            //the offcut: arg = arg.substring(0, pos);\r\n        }       \r\n        \r\n        // setting other connection properties\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_CLIENTIP, session.userAddress.isAnyLocalAddress() ? \"localhost\" : session.userAddress.getHostAddress());\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_METHOD, HeaderFramework.METHOD_CONNECT);\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_PATH, \"/\");\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_EXT, \"\");\r\n        prop.setProperty(HeaderFramework.CONNECTION_PROP_URL, \"\");        \r\n        \r\n        // parse remaining lines\r\n        final RequestHeader header = readHeader(prop,session);               \r\n        \r\n        if (!(allowProxy(session))) {\r\n            // not authorized through firewall blocking (ip does not match filter)          \r\n            session.out.write((httpVersion + \" 403 refused (IP not granted)\" + serverCore.CRLF_STRING + serverCore.CRLF_STRING + \"you are not allowed to connect to this proxy, because you are using the non-granted IP \" + session.userAddress.getHostAddress() + \". allowed are only connections that match with the following filter: \" + switchboard.getConfig(\"proxyClient\", \"*\") + serverCore.CRLF_STRING).getBytes());\r\n            return serverCore.TERMINATE_CONNECTION;\r\n        }        \r\n        \r\n        if (port != 443 && switchboard.getConfig(\"secureHttps\", \"true\").equals(\"true\")) {\r\n            // security: connection only to ssl port\r\n            // we send a 403 (forbidden) error back\r\n            session.out.write((httpVersion + \" 403 Connection to non-443 forbidden\" +\r\n                    serverCore.CRLF_STRING + serverCore.CRLF_STRING).getBytes());\r\n            return serverCore.TERMINATE_CONNECTION;\r\n        }\r\n        \r\n        // pass to proxy\r\n        if (((allowYaCyHop(session)) && (handleYaCyHopAuthentication(header, prop, session))) ||\r\n            ((allowProxy(session)) && (this.handleProxyAuthentication(header, prop, session)))) {\r\n            HTTPDProxyHandler.doConnect(prop, header, session.in, session.out);\r\n        } else {\r\n            // not authorized through firewall blocking (ip does not match filter)\r\n            session.out.write((httpVersion + \" 403 refused (IP not granted)\" + serverCore.CRLF_STRING + serverCore.CRLF_STRING + \"you are not allowed to connect to this proxy, because you are using the non-granted IP \" + session.userAddress.getHostAddress() + \". allowed are only connections that match with the following filter: \" + switchboard.getConfig(\"proxyClient\", \"*\") + serverCore.CRLF_STRING).getBytes());\r\n        }\r\n        \r\n        return serverCore.TERMINATE_CONNECTION;\r\n    }","commit_id":"64f32e8f009501a73e262922d17f0b018aac03c6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Path findSinglePath( Node start, Node end )\n    {\n        Collection<Path> paths = internalPaths( start, end, true );\n        return IteratorUtil.singleValueOrNull( paths.iterator() );\n    }","id":102729,"modified_method":"public Path findSinglePath( Node start, Node end )\n    {\n        Collection<Path> paths = internalPaths( start, end, true );\n        return paths.isEmpty() ? null : paths.iterator().next();\n    }","commit_id":"a6ea7f0fc462db9eaab4b92ca6158b7d27481516","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Path findSinglePath( Node start, Node end )\n    {\n        Collection<Path> paths = internalPaths( start, end, true );\n        return IteratorUtil.singleValueOrNull( paths.iterator() );\n    }","id":102730,"modified_method":"public Path findSinglePath( Node start, Node end )\n    {\n        Collection<Path> paths = internalPaths( start, end, true );\n        return paths.isEmpty() ? null : paths.iterator().next();\n    }","commit_id":"85cda70e20534c3ae4652f471aac84cc2179db8b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Path findSinglePath( Node start, Node end )\n    {\n        Collection<Path> paths = internalPaths( start, end, true );\n        return IteratorUtil.singleValueOrNull( paths.iterator() );\n    }","id":102731,"modified_method":"public Path findSinglePath( Node start, Node end )\n    {\n        Collection<Path> paths = internalPaths( start, end, true );\n        return paths.isEmpty() ? null : paths.iterator().next();\n    }","commit_id":"b68a7ab3a8c7279e21dd42c7311acbf5759f8a60","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n   * Elect one leader among the {@link DistributedStreamService}s running in different Twill runnables.\n   */\n  private void performLeaderElection() {\n    // Start the resource coordinator that will map Streams to Stream handlers\n    leaderElection = new LeaderElection(\n      zkClient, \"/election/\" + STREAMS_COORDINATOR, new ElectionHandler() {\n      @Override\n      public void leader() {\n        LOG.info(\"Became Stream handler leader. Starting resource coordinator.\");\n        resourceCoordinator = new ResourceCoordinator(zkClient, discoveryServiceClient,\n                                                      new BalancedAssignmentStrategy());\n        resourceCoordinator.startAndWait();\n\n        resourceCoordinatorClient.modifyRequirement(Constants.Service.STREAMS, new ResourceModifier() {\n          @Nullable\n          @Override\n          public ResourceRequirement apply(@Nullable ResourceRequirement existingRequirement) {\n            try {\n              // Create one requirement for the resource coordinator for all the streams.\n              // One stream is identified by one partition\n              ResourceRequirement.Builder builder = ResourceRequirement.builder(Constants.Service.STREAMS);\n              for (StreamSpecification spec : streamMetaStore.listStreams()) {\n                LOG.debug(\"Adding {} stream as a resource to the coordinator to manager streams leaders.\",\n                          spec.getName());\n                builder.addPartition(new ResourceRequirement.Partition(spec.getName(), 1));\n              }\n              return builder.build();\n            } catch (Throwable e) {\n              LOG.error(\"Could not create requirement for coordinator in Stream handler leader\", e);\n              Throwables.propagate(e);\n              return null;\n            }\n          }\n        });\n      }\n\n      @Override\n      public void follower() {\n        LOG.info(\"Became Stream handler follower.\");\n        if (resourceCoordinator != null) {\n          resourceCoordinator.stopAndWait();\n        }\n      }\n    });\n  }","id":102732,"modified_method":"/**\n   * Elect one leader among the {@link DistributedStreamService}s running in different Twill runnables.\n   */\n  private void performLeaderElection() {\n    // Start the resource coordinator that will map Streams to Stream handlers\n    leaderElection = new LeaderElection(\n      zkClient, \"/election/\" + STREAMS_COORDINATOR, new ElectionHandler() {\n      @Override\n      public void leader() {\n        LOG.info(\"Became Stream handler leader. Starting resource coordinator.\");\n        resourceCoordinator = new ResourceCoordinator(zkClient, discoveryServiceClient,\n                                                      new BalancedAssignmentStrategy());\n        resourceCoordinator.startAndWait();\n\n        resourceCoordinatorClient.modifyRequirement(Constants.Service.STREAMS, new ResourceModifier() {\n          @Nullable\n          @Override\n          public ResourceRequirement apply(@Nullable ResourceRequirement existingRequirement) {\n            try {\n              // Create one requirement for the resource coordinator for all the streams.\n              // One stream is identified by one partition\n              ResourceRequirement.Builder builder = ResourceRequirement.builder(Constants.Service.STREAMS);\n              Collection<StreamSpecification> specifications = streamMetaStore.listStreams().get(\n                  new NamespaceMeta.Builder().setId(Constants.DEFAULT_NAMESPACE).build());\n              for (StreamSpecification spec : specifications) {\n                LOG.debug(\"Adding {} stream as a resource to the coordinator to manager streams leaders.\",\n                          spec.getName());\n                builder.addPartition(new ResourceRequirement.Partition(spec.getName(), 1));\n              }\n              return builder.build();\n            } catch (Throwable e) {\n              LOG.error(\"Could not create requirement for coordinator in Stream handler leader\", e);\n              Throwables.propagate(e);\n              return null;\n            }\n          }\n        });\n      }\n\n      @Override\n      public void follower() {\n        LOG.info(\"Became Stream handler follower.\");\n        if (resourceCoordinator != null) {\n          resourceCoordinator.stopAndWait();\n        }\n      }\n    });\n  }","commit_id":"c65e02793a2c6ba988874e98339d48b4d73aa8a4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void runOneIteration() throws Exception {\n    LOG.trace(\"Performing heartbeat publishing in Stream service instance {}\", instanceId);\n    ImmutableMap.Builder<String, Long> sizes = ImmutableMap.builder();\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      sizes.put(streamSpec.getName(), streamWriterSizeCollector.getTotalCollected(streamSpec.getName()));\n    }\n    heartbeatPublisher.sendHeartbeat(new StreamWriterHeartbeat(System.currentTimeMillis(), instanceId, sizes.build()));\n  }","id":102733,"modified_method":"@Override\n  protected void runOneIteration() throws Exception {\n    LOG.trace(\"Performing heartbeat publishing in Stream service instance {}\", instanceId);\n    ImmutableMap.Builder<String, Long> sizes = ImmutableMap.builder();\n    Collection<StreamSpecification> specifications =\n      streamMetaStore.listStreams().get(new NamespaceMeta.Builder().setId(Constants.DEFAULT_NAMESPACE).build());\n    for (StreamSpecification streamSpec : specifications) {\n      sizes.put(streamSpec.getName(), streamWriterSizeCollector.getTotalCollected(streamSpec.getName()));\n    }\n    heartbeatPublisher.sendHeartbeat(new StreamWriterHeartbeat(System.currentTimeMillis(), instanceId, sizes.build()));\n  }","commit_id":"c65e02793a2c6ba988874e98339d48b4d73aa8a4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized List<StreamSpecification> listStreams() throws Exception {\n    ImmutableList.Builder<StreamSpecification> builder = ImmutableList.builder();\n    for (String stream : streams.values()) {\n      builder.add(new StreamSpecification.Builder().setName(stream).create());\n    }\n    return builder.build();\n  }","id":102734,"modified_method":"@Override\n  public synchronized Multimap<NamespaceMeta, StreamSpecification> listStreams() throws Exception {\n    ImmutableMultimap.Builder<NamespaceMeta, StreamSpecification> builder = ImmutableMultimap.builder();\n    for (String accountId : streams.keySet()) {\n      Collection<String> streamNames = streams.get(accountId);\n      builder.putAll(new NamespaceMeta.Builder().setId(accountId).build(),\n                     Collections2.transform(streamNames, new Function<String, StreamSpecification>() {\n                       @Nullable\n                       @Override\n                       public StreamSpecification apply(String input) {\n                         return new StreamSpecification.Builder().setName(input).create();\n                       }\n                     }));\n    }\n    return builder.build();\n  }","commit_id":"c65e02793a2c6ba988874e98339d48b4d73aa8a4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void initialize() throws Exception {\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n      long filesSize = StreamUtils.fetchStreamFilesSize(config);\n      createSizeAggregator(streamSpec.getName(), filesSize, config.getNotificationThresholdMB());\n    }\n  }","id":102735,"modified_method":"@Override\n  protected void initialize() throws Exception {\n    Collection<StreamSpecification> specifications =\n      streamMetaStore.listStreams().get(new NamespaceMeta.Builder().setId(Constants.DEFAULT_NAMESPACE).build());\n    for (StreamSpecification streamSpec : specifications) {\n      StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n      long filesSize = StreamUtils.fetchStreamFilesSize(config);\n      createSizeAggregator(streamSpec.getName(), filesSize, config.getNotificationThresholdMB());\n    }\n  }","commit_id":"c65e02793a2c6ba988874e98339d48b4d73aa8a4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void runOneIteration() throws Exception {\n    // Get stream size - which will be the entire size - and send a notification if the size is big enough\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      StreamSizeAggregator streamSizeAggregator = aggregators.get(streamSpec.getName());\n      if (streamSizeAggregator == null) {\n        // First time that we see this Stream here\n        StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n        streamSizeAggregator = createSizeAggregator(streamSpec.getName(), 0, config.getNotificationThresholdMB());\n      }\n      streamSizeAggregator.checkAggregatedSize();\n    }\n    isInit = false;\n  }","id":102736,"modified_method":"@Override\n  protected void runOneIteration() throws Exception {\n    // Get stream size - which will be the entire size - and send a notification if the size is big enough\n    Collection<StreamSpecification> specifications =\n      streamMetaStore.listStreams().get(new NamespaceMeta.Builder().setId(Constants.DEFAULT_NAMESPACE).build());\n    for (StreamSpecification streamSpec : specifications) {\n      StreamSizeAggregator streamSizeAggregator = aggregators.get(streamSpec.getName());\n      if (streamSizeAggregator == null) {\n        // First time that we see this Stream here\n        StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n        streamSizeAggregator = createSizeAggregator(streamSpec.getName(), 0, config.getNotificationThresholdMB());\n      }\n      streamSizeAggregator.checkAggregatedSize();\n    }\n    isInit = false;\n  }","commit_id":"c65e02793a2c6ba988874e98339d48b4d73aa8a4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<StreamSpecification> listStreams() throws Exception {\n    return txnl.executeUnchecked(new TransactionExecutor.Function<StreamMds, List<StreamSpecification>>() {\n      @Override\n      public List<StreamSpecification> apply(StreamMds mds) throws Exception {\n        return mds.streams.list(new MetadataStoreDataset.Key.Builder().add(TYPE_STREAM).build(),\n                                StreamSpecification.class);\n      }\n    });\n  }","id":102737,"modified_method":"@Override\n  public Multimap<NamespaceMeta, StreamSpecification> listStreams() throws Exception {\n    return txnl.executeUnchecked(\n      new TransactionExecutor.Function<StreamMds, Multimap<NamespaceMeta, StreamSpecification>>() {\n        @Override\n        public Multimap<NamespaceMeta, StreamSpecification> apply(StreamMds mds) throws Exception {\n          ImmutableMultimap.Builder<NamespaceMeta, StreamSpecification> builder = ImmutableMultimap.builder();\n          List<NamespaceMeta> namespaces =\n            mds.streams.list(new MetadataStoreDataset.Key.Builder().add(TYPE_NAMESPACE).build(), NamespaceMeta.class);\n          for (NamespaceMeta meta : namespaces) {\n            builder.putAll(meta, mds.streams.list(\n              new MetadataStoreDataset.Key.Builder().add(TYPE_STREAM, meta.getId()).build(),\n              StreamSpecification.class));\n          }\n          return builder.build();\n        }\n      });\n  }","commit_id":"c65e02793a2c6ba988874e98339d48b4d73aa8a4","url":"https://github.com/caskdata/cdap"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Wrappers._T<String> initialText = new Wrappers._T<String>(\"\");\n\n\n      NodeSubstituteChooser nodeSubstituteChooser = ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).getNodeSubstituteChooser();\n      if (check_a68f4j_a4a0(nodeSubstituteChooser)) {\n        String pattern = nodeSubstituteChooser.getPatternEditor().getPattern();\n        if (check_a68f4j_a1a4a0(pattern)) {\n          initialText.value = pattern;\n        }\n      }\n      if (isEmptyString(initialText.value)) {\n        EditorCell_Label label = AddModelImportByRoot_Action.this.getCellLabel(_params);\n        String selectedText = check_a68f4j_a0b0f0a(label);\n        if (selectedText != null && !(selectedText.isEmpty())) {\n          initialText.value = selectedText;\n        }\n      }\n\n      final EditorCell_Label errorLabel = AddModelImportByRoot_Action.this.getErrorCell(_params);\n      final SNode unresolvedReference = SNodeOperations.as(((SNode) MapSequence.fromMap(_params).get(\"node\")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x28e9fc3ba3fa3940L, \"jetbrains.mps.baseLanguage.structure.UnresolvedNameReference\"));\n      if (isEmptyString(initialText.value)) {\n\n        if (errorLabel != null) {\n          initialText.value = errorLabel.getRenderedText();\n        } else if (unresolvedReference != null) {\n          initialText.value = SPropertyOperations.getString(unresolvedReference, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x28e9fc3ba3fa3940L, 0x28e9fc3ba3fa3941L, \"resolveName\"));\n        }\n      }\n\n      ImportHelper.addModelImportByRoot(((Project) MapSequence.fromMap(_params).get(\"project\")), ((SModule) MapSequence.fromMap(_params).get(\"module\")), ((SModel) MapSequence.fromMap(_params).get(\"model\")), initialText.value, AddModelImportByRoot_Action.this, new ImportHelper.ModelImportByRootCallback() {\n        public void importForRootAdded(String rootName) {\n          String textToMatch = (rootName != null ? rootName : initialText.value);\n          if (textToMatch.length() == 0) {\n            return;\n          }\n          SubstituteInfo substituteInfo = null;\n          if (errorLabel != null) {\n            substituteInfo = errorLabel.getSubstituteInfo();\n          } else if (unresolvedReference != null && ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")) != null) {\n            substituteInfo = new DefaultChildSubstituteInfo(SNodeOperations.getParent(unresolvedReference), unresolvedReference, SNodeOperations.getContainingLinkDeclaration(unresolvedReference), ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")));\n            substituteInfo.setOriginalText(initialText.value);\n          }\n          if (substituteInfo == null) {\n            return;\n          }\n          substituteInfo.invalidateActions();\n          List<SubstituteAction> matchingActions = substituteInfo.getMatchingActions(textToMatch, true);\n          if (ListSequence.fromList(matchingActions).count() == 1) {\n            ListSequence.fromList(matchingActions).first().substitute(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")), initialText.value);\n          }\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"AddModelImportByRoot\", t);\n      }\n    }\n  }","id":102738,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Wrappers._T<String> initialText = new Wrappers._T<String>(\"\");\n\n      final Wrappers._T<EditorCell_Label> errorLabel = new Wrappers._T<EditorCell_Label>(null);\n      final Wrappers._T<SNode> unresolvedReference = new Wrappers._T<SNode>(null);\n      if (((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")) != null) {\n        unresolvedReference.value = SNodeOperations.as(((SNode) MapSequence.fromMap(_params).get(\"node\")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x28e9fc3ba3fa3940L, \"jetbrains.mps.baseLanguage.structure.UnresolvedNameReference\"));\n        errorLabel.value = AddModelImportByRoot_Action.this.getErrorCell(_params);\n        NodeSubstituteChooser nodeSubstituteChooser = ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).getNodeSubstituteChooser();\n        if (check_a68f4j_a3a4a0(nodeSubstituteChooser)) {\n          String pattern = nodeSubstituteChooser.getPatternEditor().getPattern();\n          if (check_a68f4j_a1a3a4a0(pattern)) {\n            initialText.value = pattern;\n          }\n        }\n        if (isEmptyString(initialText.value)) {\n          EditorCell_Label label = AddModelImportByRoot_Action.this.getCellLabel(_params);\n          String selectedText = check_a68f4j_a0b0e0e0a(label);\n          if (selectedText != null && !(selectedText.isEmpty())) {\n            initialText.value = selectedText;\n          }\n        }\n\n        if (isEmptyString(initialText.value)) {\n\n          if (errorLabel.value != null) {\n            initialText.value = errorLabel.value.getRenderedText();\n          } else if (unresolvedReference.value != null) {\n            initialText.value = SPropertyOperations.getString(unresolvedReference.value, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x28e9fc3ba3fa3940L, 0x28e9fc3ba3fa3941L, \"resolveName\"));\n          }\n        }\n\n      }\n      ImportHelper.addModelImportByRoot(((Project) MapSequence.fromMap(_params).get(\"project\")), ((SModule) MapSequence.fromMap(_params).get(\"module\")), ((SModel) MapSequence.fromMap(_params).get(\"model\")), initialText.value, AddModelImportByRoot_Action.this, new ImportHelper.ModelImportByRootCallback() {\n        public void importForRootAdded(String rootName) {\n          String textToMatch = (rootName != null ? rootName : initialText.value);\n          if (textToMatch.length() == 0) {\n            return;\n          }\n          SubstituteInfo substituteInfo = null;\n          if (errorLabel.value != null) {\n            substituteInfo = errorLabel.value.getSubstituteInfo();\n          } else if (unresolvedReference.value != null && ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")) != null) {\n            substituteInfo = new DefaultChildSubstituteInfo(SNodeOperations.getParent(unresolvedReference.value), unresolvedReference.value, SNodeOperations.getContainingLinkDeclaration(unresolvedReference.value), ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")));\n            substituteInfo.setOriginalText(initialText.value);\n          }\n          if (substituteInfo == null) {\n            return;\n          }\n          substituteInfo.invalidateActions();\n          List<SubstituteAction> matchingActions = substituteInfo.getMatchingActions(textToMatch, true);\n          if (ListSequence.fromList(matchingActions).count() == 1) {\n            ListSequence.fromList(matchingActions).first().substitute(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")), initialText.value);\n          }\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"AddModelImportByRoot\", t);\n      }\n    }\n  }","commit_id":"7273a67f81b2f76c897888f456615d76f777716e","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static String check_a68f4j_a0b0f0a(EditorCell_Label checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.getSelectedText();\n    }\n    return null;\n  }","id":102739,"modified_method":"private static String check_a68f4j_a0b0e0e0a(EditorCell_Label checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.getSelectedText();\n    }\n    return null;\n  }","commit_id":"7273a67f81b2f76c897888f456615d76f777716e","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean check_a68f4j_a4a0(NodeSubstituteChooser checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.isVisible();\n    }\n    return false;\n  }","id":102740,"modified_method":"private static boolean check_a68f4j_a3a4a0(NodeSubstituteChooser checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.isVisible();\n    }\n    return false;\n  }","commit_id":"7273a67f81b2f76c897888f456615d76f777716e","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean check_a68f4j_a1a4a0(String checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return (checkedDotOperand != null && checkedDotOperand.length() > 0);\n    }\n    return false;\n  }","id":102741,"modified_method":"private static boolean check_a68f4j_a1a3a4a0(String checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return (checkedDotOperand != null && checkedDotOperand.length() > 0);\n    }\n    return false;\n  }","commit_id":"7273a67f81b2f76c897888f456615d76f777716e","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"module\", event.getData(MPSDataKeys.MODULE));\n    if (MapSequence.fromMap(_params).get(\"module\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"model\", event.getData(MPSDataKeys.CONTEXT_MODEL));\n    if (MapSequence.fromMap(_params).get(\"model\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"editorComponent\", event.getData(MPSDataKeys.EDITOR_COMPONENT));\n    if (MapSequence.fromMap(_params).get(\"editorComponent\") == null) {\n      return false;\n    }\n    return true;\n  }","id":102742,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"module\", event.getData(MPSDataKeys.MODULE));\n    if (MapSequence.fromMap(_params).get(\"module\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"model\", event.getData(MPSDataKeys.CONTEXT_MODEL));\n    if (MapSequence.fromMap(_params).get(\"model\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"editorComponent\", event.getData(MPSDataKeys.EDITOR_COMPONENT));\n    if (MapSequence.fromMap(_params).get(\"editorComponent\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"editorContext\", event.getData(MPSDataKeys.EDITOR_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"editorContext\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"11a8089e02b15167fdb620a27a403924c0a803dc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      EditorCell selectedCell = ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).getSelectedCell();\n      String initialText = \"\";\n      if (selectedCell instanceof EditorCell_Label && ((EditorCell_Label) selectedCell).isErrorState()) {\n        EditorCell_Label editorCellLabel = (EditorCell_Label) selectedCell;\n        if (editorCellLabel.isErrorState() && !(StringUtils.isEmpty(editorCellLabel.getText()))) {\n          initialText = ((EditorCell_Label) selectedCell).getRenderedText();\n        }\n      }\n      ImportHelper.addModelImportByRoot(((Project) MapSequence.fromMap(_params).get(\"project\")), ((IModule) MapSequence.fromMap(_params).get(\"module\")), ((SModelDescriptor) MapSequence.fromMap(_params).get(\"model\")), initialText);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"AddModelImportByRoot\", t);\n      }\n    }\n  }","id":102743,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final EditorCell_Label errorLabel = AddModelImportByRoot_Action.this.getErrorCell(_params);\n      final String initialText = (errorLabel == null ?\n        \"\" :\n        errorLabel.getRenderedText()\n      );\n      ImportHelper.addModelImportByRoot(((Project) MapSequence.fromMap(_params).get(\"project\")), ((IModule) MapSequence.fromMap(_params).get(\"module\")), ((SModelDescriptor) MapSequence.fromMap(_params).get(\"model\")), initialText, new ImportHelper.ModelImportByRootCallback() {\n        public void importForRootAdded(String rootName) {\n          if (errorLabel == null) {\n            return;\n          }\n          String textToMatch = (rootName != null ?\n            rootName :\n            initialText\n          );\n          if (textToMatch.length() == 0) {\n            return;\n          }\n          NodeSubstituteInfo substituteInfo = errorLabel.getSubstituteInfo();\n          substituteInfo.invalidateActions();\n          List<INodeSubstituteAction> matchingActions = substituteInfo.getMatchingActions(textToMatch, true);\n          if ((int) ListSequence.fromList(matchingActions).count() == 1) {\n            ListSequence.fromList(matchingActions).first().substitute(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")), initialText);\n          }\n        }\n      });\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"AddModelImportByRoot\", t);\n      }\n    }\n  }","commit_id":"11a8089e02b15167fdb620a27a403924c0a803dc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void addModelImportByRoot(final Project project, final IModule contextModule, final SModelDescriptor model,\n                                          String initialText) {\n    FakePsiElement fakePsiContext = new FakePsiElement() {\n      public PsiElement getParent() {\n        return null;\n      }\n    };\n\n    BaseMPSChooseModel goToNodeModel;\n    if (!myUseCache) {\n      goToNodeModel = new BaseNodeModel(project) {\n        public NavigationItem doGetNavigationItem(SNode node) {\n          return new BaseNodeItem(node) {\n            public void navigate(boolean requestFocus) {\n              new AddModelItem(project, model, getNode().getModel().getSModelReference(), contextModule).navigate(requestFocus);\n            }\n          };\n        }\n\n        public SNode[] find(IScope scope) {\n          Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n            public boolean met(SModelDescriptor modelDescriptor) {\n              boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor);\n              boolean hasModule = modelDescriptor.getModule() != null;\n              return rightStereotype && hasModule;\n            }\n          };\n          ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n\n          final List<SNode> nodes = new ArrayList<SNode>();\n          for (SModelDescriptor modelDescriptor : iter) {\n            SModel model = modelDescriptor.getSModel();\n            if (model == null) continue;\n            nodes.addAll(IterableUtil.asCollection(model.roots()));\n          }\n          return nodes.toArray(new SNode[nodes.size()]);\n        }\n\n        @Nullable\n        public String getPromptText() {\n          return \"Import model that contains root:\";\n        }\n      };\n    } else {\n      goToNodeModel = new MPSChooseSNodeDescriptor(project, new RootNodeNameIndex()) {\n        public NavigationItem doGetNavigationItem(final BaseSNodeDescriptor object) {\n          return new RootNodeElement(object) {\n            public void navigate(boolean requestFocus) {\n              SModelDescriptor descriptor = GlobalScope.getInstance().getModelDescriptor(object.getModelReference());\n              SModel modelDescriptor = descriptor.getSModel();\n              SNode node = object.getNode(modelDescriptor);\n              new AddModelItem(project, model, node.getModel().getSModelReference(), contextModule).navigate(requestFocus);\n            }\n          };\n        }\n\n        @Nullable\n        public String getPromptText() {\n          return \"Import model that contains root:\";\n        }\n      };\n    }\n    ChooseByNamePopup popup = MpsPopupFactory.createNodePopup(project, goToNodeModel, initialText);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          public void run() {\n            ((NavigationItem) element).navigate(true);\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","id":102744,"modified_method":"public static void addModelImportByRoot(final Project project, final IModule contextModule, final SModelDescriptor model,\n                                          String initialText, final ModelImportByRootCallback callback) {\n    FakePsiElement fakePsiContext = new FakePsiElement() {\n      public PsiElement getParent() {\n        return null;\n      }\n    };\n\n    BaseMPSChooseModel goToNodeModel;\n    if (!myUseCache) {\n      goToNodeModel = new BaseNodeModel(project) {\n        public NavigationItem doGetNavigationItem(SNode node) {\n          return new BaseNodeItem(node) {\n            public void navigate(boolean requestFocus) {\n              new AddModelItem(project, model, getNode().getModel().getSModelReference(), contextModule).navigate(requestFocus);\n            }\n          };\n        }\n\n        public SNode[] find(IScope scope) {\n          Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n            public boolean met(SModelDescriptor modelDescriptor) {\n              boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor);\n              boolean hasModule = modelDescriptor.getModule() != null;\n              return rightStereotype && hasModule;\n            }\n          };\n          ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n\n          final List<SNode> nodes = new ArrayList<SNode>();\n          for (SModelDescriptor modelDescriptor : iter) {\n            SModel model = modelDescriptor.getSModel();\n            if (model == null) continue;\n            nodes.addAll(IterableUtil.asCollection(model.roots()));\n          }\n          return nodes.toArray(new SNode[nodes.size()]);\n        }\n\n        @Nullable\n        public String getPromptText() {\n          return \"Import model that contains root:\";\n        }\n      };\n    } else {\n      goToNodeModel = new MPSChooseSNodeDescriptor(project, new RootNodeNameIndex()) {\n        public NavigationItem doGetNavigationItem(final BaseSNodeDescriptor object) {\n          return new RootNodeElement(object) {\n            public void navigate(boolean requestFocus) {\n              SModelDescriptor descriptor = GlobalScope.getInstance().getModelDescriptor(object.getModelReference());\n              SModel modelDescriptor = descriptor.getSModel();\n              SNode node = object.getNode(modelDescriptor);\n              new AddModelItem(project, model, node.getModel().getSModelReference(), contextModule).navigate(requestFocus);\n            }\n          };\n        }\n\n        @Nullable\n        public String getPromptText() {\n          return \"Import model that contains root:\";\n        }\n      };\n    }\n    ChooseByNamePopup popup = MpsPopupFactory.createNodePopup(project, goToNodeModel, initialText);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          public void run() {\n            NavigationItem navigationItem = (NavigationItem) element;\n            navigationItem.navigate(true);\n            callback.importForRootAdded(navigationItem.getPresentation().getPresentableText());\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"11a8089e02b15167fdb620a27a403924c0a803dc","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"module\", event.getData(MPSDataKeys.MODULE));\n    if (MapSequence.fromMap(_params).get(\"module\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"model\", event.getData(MPSDataKeys.CONTEXT_MODEL));\n    if (MapSequence.fromMap(_params).get(\"model\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"editorComponent\", event.getData(MPSDataKeys.EDITOR_COMPONENT));\n    if (MapSequence.fromMap(_params).get(\"editorComponent\") == null) {\n      return false;\n    }\n    return true;\n  }","id":102745,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"module\", event.getData(MPSDataKeys.MODULE));\n    if (MapSequence.fromMap(_params).get(\"module\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"model\", event.getData(MPSDataKeys.CONTEXT_MODEL));\n    if (MapSequence.fromMap(_params).get(\"model\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"editorComponent\", event.getData(MPSDataKeys.EDITOR_COMPONENT));\n    if (MapSequence.fromMap(_params).get(\"editorComponent\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"editorContext\", event.getData(MPSDataKeys.EDITOR_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"editorContext\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"d6e6162895fe28a0f5b4e522f515ae6e449c5aee","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      EditorCell selectedCell = ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).getSelectedCell();\n      String initialText = \"\";\n      if (selectedCell instanceof EditorCell_Label && ((EditorCell_Label) selectedCell).isErrorState()) {\n        EditorCell_Label editorCellLabel = (EditorCell_Label) selectedCell;\n        if (editorCellLabel.isErrorState() && !(StringUtils.isEmpty(editorCellLabel.getText()))) {\n          initialText = ((EditorCell_Label) selectedCell).getRenderedText();\n        }\n      }\n      ImportHelper.addModelImportByRoot(((Project) MapSequence.fromMap(_params).get(\"project\")), ((IModule) MapSequence.fromMap(_params).get(\"module\")), ((SModelDescriptor) MapSequence.fromMap(_params).get(\"model\")), initialText);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"AddModelImportByRoot\", t);\n      }\n    }\n  }","id":102746,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final EditorCell_Label errorLabel = AddModelImportByRoot_Action.this.getErrorCell(_params);\n      final String initialText = (errorLabel == null ?\n        \"\" :\n        errorLabel.getRenderedText()\n      );\n      ImportHelper.addModelImportByRoot(((Project) MapSequence.fromMap(_params).get(\"project\")), ((IModule) MapSequence.fromMap(_params).get(\"module\")), ((SModelDescriptor) MapSequence.fromMap(_params).get(\"model\")), initialText, new ImportHelper.ModelImportByRootCallback() {\n        public void importForRootAdded(String rootName) {\n          if (errorLabel == null) {\n            return;\n          }\n          String textToMatch = (rootName != null ?\n            rootName :\n            initialText\n          );\n          if (textToMatch.length() == 0) {\n            return;\n          }\n          NodeSubstituteInfo substituteInfo = errorLabel.getSubstituteInfo();\n          substituteInfo.invalidateActions();\n          List<INodeSubstituteAction> matchingActions = substituteInfo.getMatchingActions(textToMatch, true);\n          if (ListSequence.fromList(matchingActions).count() == 1) {\n            ListSequence.fromList(matchingActions).first().substitute(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")), initialText);\n          }\n        }\n      });\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"AddModelImportByRoot\", t);\n      }\n    }\n  }","commit_id":"d6e6162895fe28a0f5b4e522f515ae6e449c5aee","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void addModelImportByRoot(final Project project, final IModule contextModule, final SModelDescriptor model,\n                                          String initialText) {\n    FakePsiElement fakePsiContext = new FakePsiElement() {\n      public PsiElement getParent() {\n        return null;\n      }\n    };\n\n    BaseMPSChooseModel goToNodeModel;\n    if (!myUseCache) {\n      goToNodeModel = new BaseNodeModel(project) {\n        public NavigationItem doGetNavigationItem(SNode node) {\n          return new BaseNodeItem(node) {\n            public void navigate(boolean requestFocus) {\n              new AddModelItem(project, model, getNode().getModel().getSModelReference(), contextModule).navigate(requestFocus);\n            }\n          };\n        }\n\n        public SNode[] find(IScope scope) {\n          Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n            public boolean met(SModelDescriptor modelDescriptor) {\n              boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor);\n              boolean hasModule = modelDescriptor.getModule() != null;\n              return rightStereotype && hasModule;\n            }\n          };\n          ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n\n          final List<SNode> nodes = new ArrayList<SNode>();\n          for (SModelDescriptor modelDescriptor : iter) {\n            SModel model = modelDescriptor.getSModel();\n            if (model == null) continue;\n            nodes.addAll(IterableUtil.asCollection(model.roots()));\n          }\n          return nodes.toArray(new SNode[nodes.size()]);\n        }\n\n        @Nullable\n        public String getPromptText() {\n          return \"Import model that contains root:\";\n        }\n      };\n    } else {\n      goToNodeModel = new MPSChooseSNodeDescriptor(project, new RootNodeNameIndex()) {\n        public NavigationItem doGetNavigationItem(final BaseSNodeDescriptor object) {\n          return new RootNodeElement(object) {\n            public void navigate(boolean requestFocus) {\n              SModelDescriptor descriptor = GlobalScope.getInstance().getModelDescriptor(object.getModelReference());\n              SModel modelDescriptor = descriptor.getSModel();\n              SNode node = object.getNode(modelDescriptor);\n              new AddModelItem(project, model, node.getModel().getSModelReference(), contextModule).navigate(requestFocus);\n            }\n          };\n        }\n\n        @Nullable\n        public String getPromptText() {\n          return \"Import model that contains root:\";\n        }\n      };\n    }\n    ChooseByNamePopup popup = MpsPopupFactory.createNodePopup(project, goToNodeModel, initialText);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          public void run() {\n            ((NavigationItem) element).navigate(true);\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","id":102747,"modified_method":"public static void addModelImportByRoot(final Project project, final IModule contextModule, final SModelDescriptor model,\n                                          String initialText, final ModelImportByRootCallback callback) {\n    FakePsiElement fakePsiContext = new FakePsiElement() {\n      public PsiElement getParent() {\n        return null;\n      }\n    };\n\n    BaseMPSChooseModel goToNodeModel;\n    if (!myUseCache) {\n      goToNodeModel = new BaseNodeModel(project) {\n        public NavigationItem doGetNavigationItem(SNode node) {\n          return new BaseNodeItem(node) {\n            public void navigate(boolean requestFocus) {\n              new AddModelItem(project, model, getNode().getModel().getSModelReference(), contextModule).navigate(requestFocus);\n            }\n          };\n        }\n\n        public SNode[] find(IScope scope) {\n          Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n            public boolean met(SModelDescriptor modelDescriptor) {\n              boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor);\n              boolean hasModule = modelDescriptor.getModule() != null;\n              return rightStereotype && hasModule;\n            }\n          };\n          ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n\n          final List<SNode> nodes = new ArrayList<SNode>();\n          for (SModelDescriptor modelDescriptor : iter) {\n            SModel model = modelDescriptor.getSModel();\n            if (model == null) continue;\n            nodes.addAll(IterableUtil.asCollection(model.roots()));\n          }\n          return nodes.toArray(new SNode[nodes.size()]);\n        }\n\n        @Nullable\n        public String getPromptText() {\n          return \"Import model that contains root:\";\n        }\n      };\n    } else {\n      goToNodeModel = new MPSChooseSNodeDescriptor(project, new RootNodeNameIndex()) {\n        public NavigationItem doGetNavigationItem(final BaseSNodeDescriptor object) {\n          return new RootNodeElement(object) {\n            public void navigate(boolean requestFocus) {\n              SModelDescriptor descriptor = GlobalScope.getInstance().getModelDescriptor(object.getModelReference());\n              SModel modelDescriptor = descriptor.getSModel();\n              SNode node = object.getNode(modelDescriptor);\n              new AddModelItem(project, model, node.getModel().getSModelReference(), contextModule).navigate(requestFocus);\n            }\n          };\n        }\n\n        @Nullable\n        public String getPromptText() {\n          return \"Import model that contains root:\";\n        }\n      };\n    }\n    ChooseByNamePopup popup = MpsPopupFactory.createNodePopup(project, goToNodeModel, initialText);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          public void run() {\n            NavigationItem navigationItem = (NavigationItem) element;\n            navigationItem.navigate(true);\n            callback.importForRootAdded(navigationItem.getPresentation().getPresentableText());\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"d6e6162895fe28a0f5b4e522f515ae6e449c5aee","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = (Switchboard) env;\r\n        \r\n        if (post != null) {\r\n            // AUTHENTICATE\r\n            if (!header.containsKey(RequestHeader.AUTHORIZATION)) {\r\n                prop.putHTML(\"AUTHENTICATE\",\"log-in\");\r\n                return prop;\r\n            }\r\n            \r\n            if (post.containsKey(\"popup\")) {\r\n                final String popup = post.get(\"popup\", \"status\");\r\n                if (\"front\".equals(popup)) {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"index.html?display=2\");\r\n                } else if (\"search\".equals(popup)) {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"yacysearch.html?display=2\");\r\n                } else if (\"interactive\".equals(popup)) {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"yacyinteractive.html?display=2\");\r\n                } else {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"Status.html\");\r\n                }\r\n            }\r\n            if (post.containsKey(\"searchpage_set\")) {\r\n                final String newGreeting = post.get(SwitchboardConstants.GREETING, \"\");\r\n                // store this call as api call\r\n                sb.tables.recordAPICall(post, \"ConfigPortal.html\", WorkTables.TABLE_API_TYPE_CONFIGURATION, \"new portal design. greeting: \" + newGreeting);\r\n                \r\n                sb.setConfig(SwitchboardConstants.GREETING, newGreeting);\r\n                sb.setConfig(SwitchboardConstants.GREETING_HOMEPAGE, post.get(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n                sb.setConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, post.get(SwitchboardConstants.GREETING_LARGE_IMAGE, \"\"));\r\n                sb.setConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, post.get(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n                sb.setConfig(SwitchboardConstants.SEARCH_TARGET, post.get(\"target\", \"_self\"));\r\n                sb.setConfig(SwitchboardConstants.INDEX_FORWARD, post.get(SwitchboardConstants.INDEX_FORWARD, \"\"));\r\n                HTTPDFileHandler.indexForward = post.get(SwitchboardConstants.INDEX_FORWARD, \"\");\r\n                sb.setConfig(\"publicTopmenu\", post.getBoolean(\"publicTopmenu\", true));\r\n                sb.setConfig(\"publicSearchpage\", post.getBoolean(\"publicSearchpage\", true));\r\n                sb.setConfig(\"search.options\", post.getBoolean(\"search.options\", false));\r\n                sb.setConfig(\"search.result.show.date\", post.getBoolean(\"search.result.show.date\", false));\r\n                sb.setConfig(\"search.result.show.size\", post.getBoolean(\"search.result.show.size\", false));\r\n                sb.setConfig(\"search.result.show.metadata\", post.getBoolean(\"search.result.show.metadata\", false));\r\n                sb.setConfig(\"search.result.show.parser\", post.getBoolean(\"search.result.show.parser\", false));\r\n                sb.setConfig(\"search.result.show.pictures\", post.getBoolean(\"search.result.show.pictures\", false));\r\n                sb.setConfig(\"search.verify\", post.get(\"search.verify\", \"ifexist\"));\r\n                sb.setConfig(\"search.verify.delete\", post.getBoolean(\"search.verify.delete\", false));\r\n                // construct navigation String\r\n                String nav = \"\";\r\n                if (post.getBoolean(\"search.navigation.hosts\", false)) nav += \"hosts,\";\r\n                if (post.getBoolean(\"search.navigation.authors\", false)) nav += \"authors,\";\r\n                if (post.getBoolean(\"search.navigation.namespace\", false)) nav += \"namespace,\";\r\n                if (post.getBoolean(\"search.navigation.topics\", false)) nav += \"topics,\";\r\n                if (nav.endsWith(\",\")) nav = nav.substring(0, nav.length() - 1);\r\n                 sb.setConfig(\"search.navigation\", nav);\r\n            }\r\n            if (post.containsKey(\"searchpage_default\")) {\r\n                sb.setConfig(SwitchboardConstants.GREETING, \"P2P Web Search\");\r\n                sb.setConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"http://yacy.net\");\r\n                sb.setConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, \"/env/grafics/YaCyLogo_120ppi.png\");\r\n                sb.setConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"/env/grafics/YaCyLogo_60ppi.png\");\r\n                sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"Status.html\");\r\n                sb.setConfig(SwitchboardConstants.INDEX_FORWARD, \"\");\r\n                HTTPDFileHandler.indexForward = \"\";\r\n                sb.setConfig(SwitchboardConstants.SEARCH_TARGET, \"_self\");\r\n                sb.setConfig(\"publicTopmenu\", true);\r\n                sb.setConfig(\"publicSearchpage\", true);\r\n                sb.setConfig(\"search.navigation\", \"hosts,authors,namespace,topics\");\r\n                sb.setConfig(\"search.options\", true);\r\n                sb.setConfig(\"search.result.show.date\", true);\r\n                sb.setConfig(\"search.result.show.size\", true);\r\n                sb.setConfig(\"search.result.show.metadata\", true);\r\n                sb.setConfig(\"search.result.show.parser\", true);\r\n                sb.setConfig(\"search.result.show.pictures\", true);\r\n                sb.setConfig(\"search.verify\", \"iffresh\");\r\n                sb.setConfig(\"search.verify.delete\", \"true\");\r\n            }            \r\n        }\r\n\r\n        prop.putHTML(SwitchboardConstants.GREETING, sb.getConfig(SwitchboardConstants.GREETING, \"\"));\r\n        prop.putHTML(SwitchboardConstants.GREETING_HOMEPAGE, sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n        prop.putHTML(SwitchboardConstants.GREETING_LARGE_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, \"\"));\r\n        prop.putHTML(SwitchboardConstants.GREETING_SMALL_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n        prop.putHTML(SwitchboardConstants.INDEX_FORWARD, sb.getConfig(SwitchboardConstants.INDEX_FORWARD, \"\"));\r\n        prop.put(\"publicTopmenu\", sb.getConfigBool(\"publicTopmenu\", false) ? 1 : 0);\r\n        prop.put(\"publicSearchpage\", sb.getConfigBool(\"publicSearchpage\", false) ? 1 : 0);\r\n        prop.put(\"search.options\", sb.getConfigBool(\"search.options\", false) ? 1 : 0);\r\n        \r\n        prop.put(\"search.result.show.date\", sb.getConfigBool(\"search.result.show.date\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.size\", sb.getConfigBool(\"search.result.show.size\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.metadata\", sb.getConfigBool(\"search.result.show.metadata\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.parser\", sb.getConfigBool(\"search.result.show.parser\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.pictures\", sb.getConfigBool(\"search.result.show.pictures\", false) ? 1 : 0);\r\n\r\n        prop.put(\"search.navigation.hosts\", sb.getConfig(\"search.navigation\", \"\").indexOf(\"hosts\") >= 0 ? 1 : 0);\r\n        prop.put(\"search.navigation.authors\", sb.getConfig(\"search.navigation\", \"\").indexOf(\"authors\") >= 0 ? 1 : 0);\r\n        prop.put(\"search.navigation.namespace\", sb.getConfig(\"search.navigation\", \"\").indexOf(\"namespace\") >= 0 ? 1 : 0);\r\n        prop.put(\"search.navigation.topics\", sb.getConfig(\"search.navigation\", \"\").indexOf(\"topics\") >= 0 ? 1 : 0);\r\n\r\n        prop.put(\"search.verify.nocache\", sb.getConfig(\"search.verify\", \"\").equals(\"nocache\") ? 1 : 0);\r\n        prop.put(\"search.verify.iffresh\", sb.getConfig(\"search.verify\", \"\").equals(\"iffresh\") ? 1 : 0);\r\n        prop.put(\"search.verify.ifexist\", sb.getConfig(\"search.verify\", \"\").equals(\"ifexist\") ? 1 : 0);\r\n        prop.put(\"search.verify.cacheonly\", sb.getConfig(\"search.verify\", \"\").equals(\"cacheonly\") ? 1 : 0);\r\n        prop.put(\"search.verify.false\", sb.getConfig(\"search.verify\", \"\").equals(\"false\") ? 1 : 0);\r\n        prop.put(\"search.verify.delete\", sb.getConfigBool(\"search.verify.delete\", true) ? 1 : 0);\r\n\r\n        final String  browserPopUpPage = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"ConfigBasic.html\");\r\n        prop.put(\"popupFront\", 0);\r\n        prop.put(\"popupSearch\", 0);\r\n        prop.put(\"popupInteractive\", 0);\r\n        prop.put(\"popupStatus\", 0);\r\n        if (browserPopUpPage.startsWith(\"index\")) {\r\n            prop.put(\"popupFront\", 1);\r\n        } else if (browserPopUpPage.startsWith(\"yacysearch\")) {\r\n            prop.put(\"popupSearch\", 1);\r\n        } else if (browserPopUpPage.startsWith(\"yacyinteractive\")) {\r\n            prop.put(\"popupInteractive\", 1);\r\n        } else {\r\n            prop.put(\"popupStatus\", 1);\r\n        }\r\n        \r\n        final String target = sb.getConfig(SwitchboardConstants.SEARCH_TARGET, \"_self\");\r\n        prop.put(\"selected_blank\", \"_blank\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_self\", \"_self\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_parent\", \"_parent\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_top\", \"_top\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_searchresult\", \"searchresult\".equals(target) ? 1 : 0);\r\n                \r\n        String myaddress = sb.peers.mySeed().getPublicAddress();\r\n        if (myaddress == null) {\r\n            myaddress = \"localhost:\" + sb.getConfig(\"port\", \"8090\");\r\n        }\r\n        prop.put(\"myaddress\", myaddress);\r\n        return prop;\r\n    }","id":102748,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = (Switchboard) env;\r\n        \r\n        if (post != null) {\r\n            // AUTHENTICATE\r\n            if (!header.containsKey(RequestHeader.AUTHORIZATION)) {\r\n                prop.putHTML(\"AUTHENTICATE\",\"log-in\");\r\n                return prop;\r\n            }\r\n            \r\n            if (post.containsKey(\"popup\")) {\r\n                final String popup = post.get(\"popup\", \"status\");\r\n                if (\"front\".equals(popup)) {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"index.html?display=2\");\r\n                } else if (\"search\".equals(popup)) {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"yacysearch.html?display=2\");\r\n                } else if (\"interactive\".equals(popup)) {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"yacyinteractive.html?display=2\");\r\n                } else {\r\n                    sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"Status.html\");\r\n                }\r\n            }\r\n            if (post.containsKey(\"searchpage_set\")) {\r\n                final String newGreeting = post.get(SwitchboardConstants.GREETING, \"\");\r\n                // store this call as api call\r\n                sb.tables.recordAPICall(post, \"ConfigPortal.html\", WorkTables.TABLE_API_TYPE_CONFIGURATION, \"new portal design. greeting: \" + newGreeting);\r\n                \r\n                sb.setConfig(SwitchboardConstants.GREETING, newGreeting);\r\n                sb.setConfig(SwitchboardConstants.GREETING_HOMEPAGE, post.get(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n                sb.setConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, post.get(SwitchboardConstants.GREETING_LARGE_IMAGE, \"\"));\r\n                sb.setConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, post.get(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n                sb.setConfig(SwitchboardConstants.SEARCH_TARGET, post.get(\"target\", \"_self\"));\r\n                sb.setConfig(SwitchboardConstants.INDEX_FORWARD, post.get(SwitchboardConstants.INDEX_FORWARD, \"\"));\r\n                HTTPDFileHandler.indexForward = post.get(SwitchboardConstants.INDEX_FORWARD, \"\");\r\n                sb.setConfig(\"publicTopmenu\", post.getBoolean(\"publicTopmenu\", true));\r\n                sb.setConfig(\"publicSearchpage\", post.getBoolean(\"publicSearchpage\", true));\r\n                sb.setConfig(\"search.options\", post.getBoolean(\"search.options\", false));\r\n                sb.setConfig(\"search.result.show.date\", post.getBoolean(\"search.result.show.date\", false));\r\n                sb.setConfig(\"search.result.show.size\", post.getBoolean(\"search.result.show.size\", false));\r\n                sb.setConfig(\"search.result.show.metadata\", post.getBoolean(\"search.result.show.metadata\", false));\r\n                sb.setConfig(\"search.result.show.parser\", post.getBoolean(\"search.result.show.parser\", false));\r\n                sb.setConfig(\"search.result.show.pictures\", post.getBoolean(\"search.result.show.pictures\", false));\r\n                sb.setConfig(\"search.verify\", post.get(\"search.verify\", \"ifexist\"));\r\n                sb.setConfig(\"search.verify.delete\", post.getBoolean(\"search.verify.delete\", false));\r\n                // construct navigation String\r\n                String nav = \"\";\r\n                if (post.getBoolean(\"search.navigation.hosts\", false)) nav += \"hosts,\";\r\n                if (post.getBoolean(\"search.navigation.authors\", false)) nav += \"authors,\";\r\n                if (post.getBoolean(\"search.navigation.namespace\", false)) nav += \"namespace,\";\r\n                if (post.getBoolean(\"search.navigation.topics\", false)) nav += \"topics,\";\r\n                if (nav.endsWith(\",\")) nav = nav.substring(0, nav.length() - 1);\r\n                 sb.setConfig(\"search.navigation\", nav);\r\n            }\r\n            if (post.containsKey(\"searchpage_default\")) {\r\n                sb.setConfig(SwitchboardConstants.GREETING, \"P2P Web Search\");\r\n                sb.setConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"http://yacy.net\");\r\n                sb.setConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, \"/env/grafics/YaCyLogo_120ppi.png\");\r\n                sb.setConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"/env/grafics/YaCyLogo_60ppi.png\");\r\n                sb.setConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"Status.html\");\r\n                sb.setConfig(SwitchboardConstants.INDEX_FORWARD, \"\");\r\n                HTTPDFileHandler.indexForward = \"\";\r\n                sb.setConfig(SwitchboardConstants.SEARCH_TARGET, \"_self\");\r\n                sb.setConfig(\"publicTopmenu\", true);\r\n                sb.setConfig(\"publicSearchpage\", true);\r\n                sb.setConfig(\"search.navigation\", \"hosts,authors,namespace,topics\");\r\n                sb.setConfig(\"search.options\", true);\r\n                sb.setConfig(\"search.result.show.date\", true);\r\n                sb.setConfig(\"search.result.show.size\", true);\r\n                sb.setConfig(\"search.result.show.metadata\", true);\r\n                sb.setConfig(\"search.result.show.parser\", true);\r\n                sb.setConfig(\"search.result.show.pictures\", true);\r\n                sb.setConfig(\"search.verify\", \"iffresh\");\r\n                sb.setConfig(\"search.verify.delete\", \"true\");\r\n            }            \r\n        }\r\n\r\n        prop.putHTML(SwitchboardConstants.GREETING, sb.getConfig(SwitchboardConstants.GREETING, \"\"));\r\n        prop.putHTML(SwitchboardConstants.GREETING_HOMEPAGE, sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n        prop.putHTML(SwitchboardConstants.GREETING_LARGE_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, \"\"));\r\n        prop.putHTML(SwitchboardConstants.GREETING_SMALL_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n        prop.putHTML(SwitchboardConstants.INDEX_FORWARD, sb.getConfig(SwitchboardConstants.INDEX_FORWARD, \"\"));\r\n        prop.put(\"publicTopmenu\", sb.getConfigBool(\"publicTopmenu\", false) ? 1 : 0);\r\n        prop.put(\"publicSearchpage\", sb.getConfigBool(\"publicSearchpage\", false) ? 1 : 0);\r\n        prop.put(\"search.options\", sb.getConfigBool(\"search.options\", false) ? 1 : 0);\r\n        \r\n        prop.put(\"search.result.show.date\", sb.getConfigBool(\"search.result.show.date\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.size\", sb.getConfigBool(\"search.result.show.size\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.metadata\", sb.getConfigBool(\"search.result.show.metadata\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.parser\", sb.getConfigBool(\"search.result.show.parser\", false) ? 1 : 0);\r\n        prop.put(\"search.result.show.pictures\", sb.getConfigBool(\"search.result.show.pictures\", false) ? 1 : 0);\r\n\r\n        prop.put(\"search.navigation.hosts\", sb.getConfig(\"search.navigation\", \"\").indexOf(\"hosts\") >= 0 ? 1 : 0);\r\n        prop.put(\"search.navigation.authors\", sb.getConfig(\"search.navigation\", \"\").indexOf(\"authors\") >= 0 ? 1 : 0);\r\n        prop.put(\"search.navigation.namespace\", sb.getConfig(\"search.navigation\", \"\").indexOf(\"namespace\") >= 0 ? 1 : 0);\r\n        prop.put(\"search.navigation.topics\", sb.getConfig(\"search.navigation\", \"\").indexOf(\"topics\") >= 0 ? 1 : 0);\r\n\r\n        prop.put(\"search.verify.nocache\", sb.getConfig(\"search.verify\", \"\").equals(\"nocache\") ? 1 : 0);\r\n        prop.put(\"search.verify.iffresh\", sb.getConfig(\"search.verify\", \"\").equals(\"iffresh\") ? 1 : 0);\r\n        prop.put(\"search.verify.ifexist\", sb.getConfig(\"search.verify\", \"\").equals(\"ifexist\") ? 1 : 0);\r\n        prop.put(\"search.verify.cacheonly\", sb.getConfig(\"search.verify\", \"\").equals(\"cacheonly\") ? 1 : 0);\r\n        prop.put(\"search.verify.false\", sb.getConfig(\"search.verify\", \"\").equals(\"false\") ? 1 : 0);\r\n        prop.put(\"search.verify.delete\", sb.getConfigBool(\"search.verify.delete\", true) ? 1 : 0);\r\n\r\n        final String  browserPopUpPage = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"ConfigBasic.html\");\r\n        prop.put(\"popupFront\", 0);\r\n        prop.put(\"popupSearch\", 0);\r\n        prop.put(\"popupInteractive\", 0);\r\n        prop.put(\"popupStatus\", 0);\r\n        if (browserPopUpPage.startsWith(\"index\")) {\r\n            prop.put(\"popupFront\", 1);\r\n        } else if (browserPopUpPage.startsWith(\"yacysearch\")) {\r\n            prop.put(\"popupSearch\", 1);\r\n        } else if (browserPopUpPage.startsWith(\"yacyinteractive\")) {\r\n            prop.put(\"popupInteractive\", 1);\r\n        } else {\r\n            prop.put(\"popupStatus\", 1);\r\n        }\r\n        \r\n        final String target = sb.getConfig(SwitchboardConstants.SEARCH_TARGET, \"_self\");\r\n        prop.put(\"selected_blank\", \"_blank\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_self\", \"_self\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_parent\", \"_parent\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_top\", \"_top\".equals(target) ? 1 : 0);\r\n        prop.put(\"selected_searchresult\", \"searchresult\".equals(target) ? 1 : 0);\r\n                \r\n        String myaddress = (sb.peers == null) ? null : sb.peers.mySeed() == null ? null : sb.peers.mySeed().getPublicAddress();\r\n        if (myaddress == null) {\r\n            myaddress = \"localhost:\" + sb.getConfig(\"port\", \"8090\");\r\n        }\r\n        prop.put(\"myaddress\", myaddress);\r\n        return prop;\r\n    }","commit_id":"d260b25457c7f38d529669ddddac4862407ae257","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private Seed(final String theHash) {\r\n        this.dna = new ConcurrentHashMap<String, String>();\r\n\r\n        // settings that can only be computed by originating peer:\r\n        // at first startup -\r\n        this.hash = theHash; // the hash key of the peer - very important. should be static somehow, even after restart\r\n        this.dna.put(Seed.NAME, defaultPeerName());\r\n\r\n        // later during operation -\r\n        this.dna.put(Seed.ISPEED, Seed.ZERO);\r\n        this.dna.put(Seed.RSPEED, Seed.ZERO);\r\n        this.dna.put(Seed.UPTIME, Seed.ZERO);\r\n        this.dna.put(Seed.LCOUNT, Seed.ZERO);\r\n        this.dna.put(Seed.NCOUNT, Seed.ZERO);\r\n        this.dna.put(Seed.RCOUNT, Seed.ZERO);\r\n        this.dna.put(Seed.ICOUNT, Seed.ZERO);\r\n        this.dna.put(Seed.SCOUNT, Seed.ZERO);\r\n        this.dna.put(Seed.CCOUNT, Seed.ZERO);\r\n        this.dna.put(Seed.VERSION, Seed.ZERO);\r\n\r\n        // settings that is created during the 'hello' phase - in first contact\r\n        this.dna.put(Seed.IP, \"\"); // 123.234.345.456\r\n        this.dna.put(Seed.PORT, \"&empty;\");\r\n        this.dna.put(Seed.IPTYPE, \"&empty;\");\r\n\r\n        // settings that can only be computed by visiting peer\r\n        this.dna.put(Seed.USPEED, Seed.ZERO); // the computated uplink speed of the peer\r\n\r\n        // settings that are needed to organize the seed round-trip\r\n        this.dna.put(Seed.FLAGS, Seed.FLAGSZERO);\r\n        setFlagDirectConnect(false);\r\n        setFlagAcceptRemoteCrawl(true);\r\n        setFlagAcceptRemoteIndex(true);\r\n        setUnusedFlags();\r\n\r\n        // index transfer\r\n        this.dna.put(Seed.INDEX_OUT, Seed.ZERO); // send index\r\n        this.dna.put(Seed.INDEX_IN, Seed.ZERO); // received index\r\n        this.dna.put(Seed.URL_OUT, Seed.ZERO); // send URLs\r\n        this.dna.put(Seed.URL_IN, Seed.ZERO); // received URLs\r\n\r\n        // default first filling\r\n        this.dna.put(Seed.BDATE, GenericFormatter.SHORT_SECOND_FORMATTER.format());\r\n        this.dna.put(Seed.LASTSEEN, this.dna.get(Seed.BDATE)); // just as initial setting\r\n        this.dna.put(Seed.UTC, GenericFormatter.UTCDiffString());\r\n        this.dna.put(Seed.PEERTYPE, Seed.PEERTYPE_VIRGIN); // virgin/junior/senior/principal\r\n\r\n        String jre = System.getProperty(\"java.version\");\r\n        this.dna.put(Seed.JRE, jre);\r\n        this.birthdate = System.currentTimeMillis();\r\n    }","id":102749,"modified_method":"private Seed(final String theHash) {\r\n        this.dna = new ConcurrentHashMap<String, String>();\r\n\r\n        // settings that can only be computed by originating peer:\r\n        // at first startup -\r\n        this.hash = theHash; // the hash key of the peer - very important. should be static somehow, even after restart\r\n        this.dna.put(Seed.NAME, defaultPeerName());\r\n\r\n        // later during operation -\r\n        this.dna.put(Seed.ISPEED, Seed.ZERO);\r\n        this.dna.put(Seed.RSPEED, Seed.ZERO);\r\n        this.dna.put(Seed.UPTIME, Seed.ZERO);\r\n        this.dna.put(Seed.LCOUNT, Seed.ZERO);\r\n        this.dna.put(Seed.NCOUNT, Seed.ZERO);\r\n        this.dna.put(Seed.RCOUNT, Seed.ZERO);\r\n        this.dna.put(Seed.ICOUNT, Seed.ZERO);\r\n        this.dna.put(Seed.SCOUNT, Seed.ZERO);\r\n        this.dna.put(Seed.CCOUNT, Seed.ZERO);\r\n        this.dna.put(Seed.VERSION, Seed.ZERO);\r\n\r\n        // settings that is created during the 'hello' phase - in first contact\r\n        this.dna.put(Seed.IP, \"\"); // 123.234.345.456\r\n        this.dna.put(Seed.PORT, \"&empty;\");\r\n\r\n        // settings that can only be computed by visiting peer\r\n        this.dna.put(Seed.USPEED, Seed.ZERO); // the computated uplink speed of the peer\r\n\r\n        // settings that are needed to organize the seed round-trip\r\n        this.dna.put(Seed.FLAGS, Seed.FLAGSZERO);\r\n        setFlagDirectConnect(false);\r\n        setFlagAcceptRemoteCrawl(true);\r\n        setFlagAcceptRemoteIndex(true);\r\n        setUnusedFlags();\r\n\r\n        // index transfer\r\n        this.dna.put(Seed.INDEX_OUT, Seed.ZERO); // send index\r\n        this.dna.put(Seed.INDEX_IN, Seed.ZERO); // received index\r\n        this.dna.put(Seed.URL_OUT, Seed.ZERO); // send URLs\r\n        this.dna.put(Seed.URL_IN, Seed.ZERO); // received URLs\r\n\r\n        // default first filling\r\n        this.dna.put(Seed.BDATE, GenericFormatter.SHORT_SECOND_FORMATTER.format());\r\n        this.dna.put(Seed.LASTSEEN, this.dna.get(Seed.BDATE)); // just as initial setting\r\n        this.dna.put(Seed.UTC, GenericFormatter.UTCDiffString());\r\n        this.dna.put(Seed.PEERTYPE, Seed.PEERTYPE_VIRGIN); // virgin/junior/senior/principal\r\n\r\n        String jre = System.getProperty(\"java.version\");\r\n        this.dna.put(Seed.JRE, jre);\r\n        this.birthdate = System.currentTimeMillis();\r\n    }","commit_id":"f23d8ab47b2a3e670b744796228d267a37d7be94","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"static String calculateReplacementExpression(\n            PsiAssignmentExpression expression){\n        final PsiBinaryExpression rhs =\n                (PsiBinaryExpression) expression.getRExpression();\n        final PsiExpression lhs = expression.getLExpression();\n        assert rhs != null;\n        final PsiJavaToken sign = rhs.getOperationSign();\n        final PsiExpression rhsRhs = rhs.getROperand();\n        assert rhsRhs != null;\n        String signText = sign.getText();\n        if(\"&&\".equals(signText)){\n            signText = \"&\";\n        } else if(\"||\".equals(signText)){\n            signText = \"|\";\n        }\n        return lhs.getText() + ' ' + signText + \"= \" + rhsRhs.getText();\n    }","id":102750,"modified_method":"static String calculateReplacementExpression(\n            PsiAssignmentExpression expression){\n        final PsiExpression rhs = expression.getRExpression();\n        final PsiBinaryExpression binaryExpression =\n                (PsiBinaryExpression)PsiUtil.deparenthesizeExpression(rhs);\n        final PsiExpression lhs = expression.getLExpression();\n        assert binaryExpression != null;\n        final PsiJavaToken sign = binaryExpression.getOperationSign();\n        final PsiExpression rhsRhs = binaryExpression.getROperand();\n        assert rhsRhs != null;\n        String signText = sign.getText();\n        if(\"&&\".equals(signText)){\n            signText = \"&\";\n        } else if(\"||\".equals(signText)){\n            signText = \"|\";\n        }\n        return lhs.getText() + ' ' + signText + \"= \" + rhsRhs.getText();\n    }","commit_id":"faf9fcc2c5f3846a0c2d592aae2adfc5ee08e8b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ReplaceAssignmentWithOperatorAssignmentFix(\n                PsiAssignmentExpression expression){\n            super();\n            final PsiBinaryExpression rhs =\n                    (PsiBinaryExpression) expression.getRExpression();\n            assert rhs != null;\n            final PsiJavaToken sign = rhs.getOperationSign();\n            String signText = sign.getText();\n            if(\"&&\".equals(signText)){\n                signText = \"&\";\n            } else if(\"||\".equals(signText)){\n                signText = \"|\";\n            }\n            m_name = InspectionGadgetsBundle.message(\n                    \"assignment.replaceable.with.operator.replace.quickfix\",\n                    signText, Character.valueOf('='));\n        }","id":102751,"modified_method":"private ReplaceAssignmentWithOperatorAssignmentFix(\n                PsiAssignmentExpression expression){\n            super();\n            final PsiExpression rhs = expression.getRExpression();\n            final PsiBinaryExpression binaryExpression =\n                    (PsiBinaryExpression) PsiUtil.deparenthesizeExpression(rhs);\n            assert binaryExpression != null;\n            final PsiJavaToken sign = binaryExpression.getOperationSign();\n            String signText = sign.getText();\n            if(\"&&\".equals(signText)){\n                signText = \"&\";\n            } else if(\"||\".equals(signText)){\n                signText = \"|\";\n            }\n            m_name = InspectionGadgetsBundle.message(\n                    \"assignment.replaceable.with.operator.replace.quickfix\",\n                    signText, Character.valueOf('='));\n        }","commit_id":"faf9fcc2c5f3846a0c2d592aae2adfc5ee08e8b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitAssignmentExpression(@NotNull\n                PsiAssignmentExpression assignment){\n            super.visitAssignmentExpression(assignment);\n            final PsiJavaToken sign = assignment.getOperationSign();\n            final IElementType assignmentTokenType = sign.getTokenType();\n            if(!assignmentTokenType.equals(JavaTokenType.EQ)){\n                return;\n            }\n            final PsiExpression lhs = assignment.getLExpression();\n            final PsiExpression rhs = assignment.getRExpression();\n            if(!(rhs instanceof PsiBinaryExpression)){\n                return;\n            }\n            final PsiBinaryExpression binaryRhs = (PsiBinaryExpression) rhs;\n            if(!(binaryRhs.getROperand() != null)){\n                return;\n            }\n            final IElementType expressionTokenType =\n                    binaryRhs.getOperationTokenType();\n            if (expressionTokenType.equals(JavaTokenType.EQEQ)) {\n                return;\n            }\n            if (ignoreLazyOperators) {\n                if (expressionTokenType.equals(JavaTokenType.ANDAND) ||\n                        expressionTokenType.equals(JavaTokenType.OROR)) {\n                    return;\n                }\n            }\n            if (ignoreObscureOperators) {\n                if (expressionTokenType.equals(JavaTokenType.XOR) ||\n                        expressionTokenType.equals(JavaTokenType.PERC)) {\n                    return;\n                }\n            }\n            final PsiExpression lOperand = binaryRhs.getLOperand();\n            if(SideEffectChecker.mayHaveSideEffects(lhs)){\n                return;\n            }\n            if(!EquivalenceChecker.expressionsAreEquivalent(lhs, lOperand)) {\n                return;\n            }\n            registerError(assignment, assignment);\n        }","id":102752,"modified_method":"public void visitAssignmentExpression(@NotNull\n                PsiAssignmentExpression assignment){\n            super.visitAssignmentExpression(assignment);\n            final PsiJavaToken sign = assignment.getOperationSign();\n            final IElementType assignmentTokenType = sign.getTokenType();\n            if(!assignmentTokenType.equals(JavaTokenType.EQ)){\n                return;\n            }\n            final PsiExpression lhs = assignment.getLExpression();\n            final PsiExpression rhs = PsiUtil.deparenthesizeExpression(\n                    assignment.getRExpression());\n            if(!(rhs instanceof PsiBinaryExpression)){\n                return;\n            }\n            final PsiBinaryExpression binaryRhs = (PsiBinaryExpression) rhs;\n            if(!(binaryRhs.getROperand() != null)){\n                return;\n            }\n            final IElementType expressionTokenType =\n                    binaryRhs.getOperationTokenType();\n            if (expressionTokenType.equals(JavaTokenType.EQEQ)) {\n                return;\n            }\n            if (ignoreLazyOperators) {\n                if (expressionTokenType.equals(JavaTokenType.ANDAND) ||\n                        expressionTokenType.equals(JavaTokenType.OROR)) {\n                    return;\n                }\n            }\n            if (ignoreObscureOperators) {\n                if (expressionTokenType.equals(JavaTokenType.XOR) ||\n                        expressionTokenType.equals(JavaTokenType.PERC)) {\n                    return;\n                }\n            }\n            final PsiExpression lOperand = binaryRhs.getLOperand();\n            if(SideEffectChecker.mayHaveSideEffects(lhs)){\n                return;\n            }\n            if(!EquivalenceChecker.expressionsAreEquivalent(lhs, lOperand)) {\n                return;\n            }\n            registerError(assignment, assignment);\n        }","commit_id":"faf9fcc2c5f3846a0c2d592aae2adfc5ee08e8b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processIntention(PsiElement element)\n            throws IncorrectOperationException {\n        final PsiAssignmentExpression expression =\n                (PsiAssignmentExpression)element;\n        final PsiBinaryExpression rhs =\n                (PsiBinaryExpression)expression.getRExpression();\n        final PsiExpression lhs = expression.getLExpression();\n        assert rhs != null;\n        final PsiJavaToken sign = rhs.getOperationSign();\n        final String operand = sign.getText();\n        final PsiExpression rhsrhs = rhs.getROperand();\n        assert rhsrhs != null;\n        final String newExpression =\n                lhs.getText() + operand + '=' + rhsrhs.getText();\n        replaceExpression(newExpression, expression);\n    }","id":102753,"modified_method":"public void processIntention(@NotNull PsiElement element)\n            throws IncorrectOperationException {\n        final PsiAssignmentExpression expression =\n                (PsiAssignmentExpression)element;\n        final PsiExpression rhs =\n\t\t        expression.getRExpression();\n\t    final PsiBinaryExpression binaryExpression =\n\t\t\t    (PsiBinaryExpression)PsiUtil.deparenthesizeExpression(rhs);\n        final PsiExpression lhs = expression.getLExpression();\n        assert rhs != null;\n        final PsiJavaToken sign = binaryExpression.getOperationSign();\n        final String operand = sign.getText();\n        final PsiExpression binaryRhs = binaryExpression.getROperand();\n        assert binaryRhs != null;\n        final String newExpression =\n                lhs.getText() + operand + '=' + binaryRhs.getText();\n        replaceExpression(newExpression, expression);\n    }","commit_id":"84b0af6dae6c18ee237b06cc20482225891fd49d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static SNode getContextClass_8008512149545173402(SNode expr) {\n    SNode contextNode = expr;\n    SNode parent = SNodeOperations.getAncestor(expr, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n    if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\")) {\n      for (SNode param : SLinkOperations.getTargets(SNodeOperations.cast(parent, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\"), \"parameter\", true)) {\n        if (ListSequence.fromList(SNodeOperations.getDescendants(param, null, true, new String[]{})).contains(expr)) {\n          contextNode = parent;\n          break;\n        }\n      }\n    }\n    return SNodeOperations.getAncestor(contextNode, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n  }","id":102754,"modified_method":"public static SNode getContextClass_8008512149545173402(SNode expr) {\n    SNode contextNode = expr;\n    SNode parent = SNodeOperations.getAncestor(expr, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n    if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\")) {\n      List<SNode> args = new ArrayList<SNode>();\n      ListSequence.fromList(args).addSequence(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(parent, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\"), \"parameter\", true)));\n      ListSequence.fromList(args).addSequence(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(parent, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\"), \"actualArgument\", true)));\n      for (SNode param : args) {\n        if (ListSequence.fromList(SNodeOperations.getDescendants(param, null, true, new String[]{})).contains(expr)) {\n          contextNode = parent;\n          break;\n        }\n      }\n    }\n    return SNodeOperations.getAncestor(contextNode, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n  }","commit_id":"b13cc7d29ef0f11b4d706d391a04916a4ab287b4","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> virtual_getTestMethods_2148145109766218395(SNode thisNode) {\n    return SLinkOperations.getTargets(SLinkOperations.getTarget(thisNode, \"testMethodList\", true), \"testMethod\", true);\n  }","id":102755,"modified_method":"public static List<SNode> virtual_getTestMethods_2148145109766218395(SNode thisNode) {\n    List<SNode> result = new ArrayList<SNode>();\n    ListSequence.fromList(result).addSequence(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(thisNode, \"testMethodList\", true), \"testMethod\", true)));\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(thisNode, \"superclass\", true), \"jetbrains.mps.baseLanguage.unitTest.structure.ITestCase\")) {\n      ListSequence.fromList(result).addSequence(ListSequence.fromList(ITestCase_Behavior.call_getTestMethods_2148145109766218395(SNodeOperations.cast(SLinkOperations.getTarget(thisNode, \"superclass\", true), \"jetbrains.mps.baseLanguage.unitTest.structure.ITestCase\"))));\n    }\n    return result;\n  }","commit_id":"e3ff7faaf39c3098e9416ce623c39021d2b5678d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void update() {\n    String loseTest = this.state.getLoseClass();\n    String loseMethod = this.state.getLoseMethod();\n    String test = this.state.getCurrentClass();\n    String method = this.state.getCurrentMethod();\n    if (loseTest != null && loseMethod != null) {\n      TestMethodTreeNode node = this.get(loseTest, loseMethod);\n      if (node != null) {\n        node.setState(TestState.ERROR);\n        if (this.getPreferences().getStateObject().isSelectFirstFailed) {\n          SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n              TestTree.this.selectFirstDefectNode();\n            }\n          });\n        }\n      }\n      if (this.getPreferences().getStateObject().isHidePassed) {\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            TestTree.this.hidePassed(true);\n          }\n        });\n      }\n    } else {\n      TestMethodTreeNode node = this.get(test, method);\n      if (node != null) {\n        if (TestEvent.START_TEST_PREFIX.equals(this.state.getToken())) {\n          node.setState(TestState.IN_PROGRESS);\n          if (this.getPreferences().getStateObject().isTrackRunning) {\n            this.setCurrentNode(node);\n          }\n        } else if (TestEvent.END_TEST_PREFIX.equals(this.state.getToken())) {\n          node.setState(TestState.PASSED);\n          TestMethodRow row = this.state.getTestMethodRow(test, method);\n          if (row != null) {\n            row.setSucceed();\n          }\n        } else if (TestEvent.FAILURE_TEST_PREFIX.equals(this.state.getToken())) {\n          node.setState(TestState.FAILED);\n        } else if (TestEvent.ERROR_TEST_PREFIX.equals(this.state.getToken())) {\n          node.setState(TestState.ERROR);\n        }\n      }\n      if (this.getPreferences().getStateObject().isHidePassed) {\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            TestTree.this.hidePassed(true);\n          }\n        });\n      }\n      if (node != null && this.getPreferences().getStateObject().isSelectFirstFailed && node.getNextLeaf() == null) {\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            TestTree.this.selectFirstDefectNode();\n          }\n        });\n      }\n    }\n  }","id":102756,"modified_method":"public void update() {\n    String loseTest = this.state.getLoseClass();\n    String loseMethod = this.state.getLoseMethod();\n    String test = this.state.getCurrentClass();\n    String method = this.state.getCurrentMethod();\n    if (loseTest != null && loseMethod != null) {\n      TestMethodTreeNode node = this.get(loseTest, loseMethod);\n      if (node != null) {\n        node.setState(TestState.ERROR);\n        if (this.getPreferences().getStateObject().isSelectFirstFailed) {\n          SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n              TestTree.this.selectFirstDefectNode();\n            }\n          });\n        }\n      }\n      if (this.getPreferences().getStateObject().isHidePassed) {\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            TestTree.this.hidePassed(true);\n          }\n        });\n      }\n    } else {\n      TestMethodTreeNode node = this.get(test, method);\n      if (node != null) {\n        if (TestEvent.START_TEST_PREFIX.equals(this.state.getToken())) {\n          node.setState(TestState.IN_PROGRESS);\n          if (this.getPreferences().getStateObject().isTrackRunning) {\n            this.setCurrentNode(node);\n          }\n        } else if (TestEvent.END_TEST_PREFIX.equals(this.state.getToken())) {\n          if (TestState.IN_PROGRESS.equals(node.getState())) {\n            node.setState(TestState.PASSED);\n            TestMethodRow row = this.state.getTestMethodRow(test, method);\n            if (row != null) {\n              row.setSucceed();\n            }\n          }\n        } else if (TestEvent.FAILURE_TEST_PREFIX.equals(this.state.getToken())) {\n          node.setState(TestState.FAILED);\n        } else if (TestEvent.ERROR_TEST_PREFIX.equals(this.state.getToken())) {\n          node.setState(TestState.ERROR);\n        }\n      }\n      if (this.getPreferences().getStateObject().isHidePassed) {\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            TestTree.this.hidePassed(true);\n          }\n        });\n      }\n      if (node != null && this.getPreferences().getStateObject().isSelectFirstFailed && node.getNextLeaf() == null) {\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            TestTree.this.selectFirstDefectNode();\n          }\n        });\n      }\n    }\n  }","commit_id":"e3ff7faaf39c3098e9416ce623c39021d2b5678d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Map<SNode, List<SNode>> fromTestCases(List<SNode> testCases, Map<SNode, List<SNode>> tests) {\n    for (SNode testCase : ListSequence.fromList(testCases)) {\n      List<SNode> testMethods = new ArrayList<SNode>();\n      MapSequence.fromMap(tests).put(testCase, testMethods);\n      for (SNode testMethod : ListSequence.fromList(ITestCase_Behavior.call_getTestSet_1216130724401(testCase))) {\n        ListSequence.fromList(testMethods).addElement(testMethod);\n      }\n    }\n    return tests;\n  }","id":102757,"modified_method":"private Map<SNode, List<SNode>> fromTestCases(List<SNode> testCases, Map<SNode, List<SNode>> tests) {\n    for (SNode testCase : ListSequence.fromList(testCases)) {\n      List<SNode> testMethods = new ArrayList<SNode>();\n      MapSequence.fromMap(tests).put(testCase, testMethods);\n      for (SNode testMethod : ListSequence.fromList(ITestCase_Behavior.call_getTestMethods_2148145109766218395(testCase))) {\n        ListSequence.fromList(testMethods).addElement(testMethod);\n      }\n    }\n    return tests;\n  }","commit_id":"e3ff7faaf39c3098e9416ce623c39021d2b5678d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> virtual_getOwnMethods_1906502351318572840(SNode thisNode) {\n    List<SNode> baseMethodDeclarations = SLinkOperations.getTargets(thisNode, \"method\", true);\n    ListSequence.fromList(baseMethodDeclarations).addSequence(ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"staticMethod\", true)));\n    return baseMethodDeclarations;\n  }","id":102758,"modified_method":"public static List<SNode> virtual_getOwnMethods_1906502351318572840(SNode thisNode) {\n    List<SNode> baseMethodDeclarations = new ArrayList<SNode>();\n    ListSequence.fromList(baseMethodDeclarations).addSequence(ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"method\", true)));\n    ListSequence.fromList(baseMethodDeclarations).addSequence(ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"staticMethod\", true)));\n    return baseMethodDeclarations;\n  }","commit_id":"c58be9ec14ce7a0bdc8e9b3515d746142ef8d95d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> virtual_getOwnMethods_1906502351318572840(SNode thisNode) {\n    return SLinkOperations.getTargets(thisNode, \"method\", true);\n  }","id":102759,"modified_method":"public static List<SNode> virtual_getOwnMethods_1906502351318572840(SNode thisNode) {\n    List<SNode> result = new ArrayList<SNode>();\n    ListSequence.fromList(result).addSequence(ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"method\", true)));\n    return result;\n  }","commit_id":"c58be9ec14ce7a0bdc8e9b3515d746142ef8d95d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode virtual_getLastStatement_1239354409446(SNode thisNode) {\n    List<SNode> statements = SLinkOperations.getTargets(IMethodLike_Behavior.call_getBody_1239354440022(thisNode), \"statement\", true);\n    while (SNodeOperations.getConceptDeclaration(ListSequence.fromList(statements).last()) == SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Statement\") || SNodeOperations.getConceptDeclaration(ListSequence.fromList(statements).last()) == SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.RemarkStatement\")) {\n      ListSequence.fromList(statements).removeLastElement();\n    }\n    return ListSequence.fromList(statements).last();\n  }","id":102760,"modified_method":"public static SNode virtual_getLastStatement_1239354409446(SNode thisNode) {\n    List<SNode> statements = new ArrayList<SNode>();\n    ListSequence.fromList(statements).addSequence(ListSequence.fromList(SLinkOperations.getTargets(IMethodLike_Behavior.call_getBody_1239354440022(thisNode), \"statement\", true)));\n    while (SNodeOperations.getConceptDeclaration(ListSequence.fromList(statements).last()) == SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.Statement\") || SNodeOperations.getConceptDeclaration(ListSequence.fromList(statements).last()) == SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.RemarkStatement\")) {\n      ListSequence.fromList(statements).removeLastElement();\n    }\n    return ListSequence.fromList(statements).last();\n  }","commit_id":"19e59951a9fc54491fd43676812a5d9ff57940cd","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean _parseTag(CompositeElement parent, Lexer lexer, Set<String> names) {\n    if (lexer.getTokenType() != XML_START_TAG_START) {\n      return false;\n    }\n\n    CompositeElement tag = Factory.createCompositeElement(XML_TAG);\n    TreeUtil.addChildren(parent, tag);\n\n    addToken(tag, lexer);\n\n    if (lexer.getTokenType() != XML_TAG_NAME) {\n      return true;\n    }\n\n    String openedName = StringFactory.createStringFromConstantArray(lexer.getBuffer(), lexer.getTokenStart(),\n                                                                      lexer.getTokenEnd() - lexer.getTokenStart());\n    addToken(tag, lexer);\n\n    parseAttributeList(tag, lexer);\n\n    while (lexer.getTokenType() == XML_BAD_CHARACTER || lexer.getTokenType() == XML_NAME) {\n      addToken(tag, lexer);\n      parseAttributeList(tag, lexer);\n    }\n    TreeElement tagEnd;\n    if (lexer.getTokenType() == XML_TAG_END) {\n      tagEnd = addToken(tag, lexer);\n      boolean setFlag = false;\n      if (!names.contains(openedName)) {\n        names.add(openedName);\n        setFlag = true;\n      }\n      while (true) {\n        if (parseProcessingInstruction(tag, lexer)) {\n        }\n        else if (_parseTag(tag, lexer, names)) {\n        }\n        else if (lexer.getTokenType() == XML_DATA_CHARACTERS) {\n          addToken(tag, lexer);\n        }\n        else if (lexer.getTokenType() == XML_CDATA_START) {\n          addToken(tag, lexer);\n        }\n        else if (lexer.getTokenType() == XML_CDATA_END) {\n          addToken(tag, lexer);\n        }\n        else if (lexer.getTokenType() == XML_CHAR_ENTITY_REF) {\n          addToken(tag, lexer);\n        }\n        else if (lexer.getTokenType() == XML_ENTITY_REF_TOKEN) {\n          TreeUtil.addChildren(tag, parseEntityRef(lexer));\n        }\n        else {\n          break;\n        }\n      }\n      if (setFlag) {\n        names.remove(openedName);\n      }\n\n      final LexerPosition pos = lexer.getCurrentPosition();\n\n      if (lexer.getTokenType() != XML_END_TAG_START) {\n        TreeUtil.insertAfter(tagEnd, Factory.createErrorElement(\"Element is not closed\"));\n\n        return false;\n      }\n      TreeElement endTagStart = ParseUtil.createTokenElement(lexer, myContext.getCharTable());\n      lexer.advance();\n\n      if (lexer.getTokenType() != XML_TAG_NAME) {\n        TreeUtil.addChildren(tag, endTagStart);\n        return true;\n      }\n\n      String closingName = StringFactory.createStringFromConstantArray(lexer.getBuffer(), lexer.getTokenStart(),\n                                                                         lexer.getTokenEnd() - lexer.getTokenStart());\n\n      if (!closingName.equals(openedName) && names.contains(closingName)) {\n        lexer.restore(pos);\n        if (tagEnd != null) {\n          final TreeElement start = tagEnd.getTreeNext();\n          tagEnd.setTreeNext(null);\n          if (start != null) {\n            TreeUtil.addChildren(parent, start);\n          }\n        }\n        TreeUtil.insertAfter(tagEnd, Factory.createErrorElement(\"Element is not closed\"));\n        return true;\n      }\n\n      TreeUtil.addChildren(tag, endTagStart);\n      addToken(tag, lexer);\n\n      if (lexer.getTokenType() != XML_TAG_END) {\n        return true;\n      }\n\n      addToken(tag, lexer);\n    }\n    else if (lexer.getTokenType() == XML_EMPTY_ELEMENT_END) {\n      addToken(tag, lexer);\n    }\n    else {\n      TreeUtil.insertAfter((TreeElement)tag.getLastChildNode(), Factory.createErrorElement(\"Element is not closed\"));\n    }\n\n    return true;\n  }","id":102761,"modified_method":"private boolean _parseTag(CompositeElement parent, Lexer lexer, Set<String> names) {\n    if (lexer.getTokenType() != XML_START_TAG_START) {\n      return false;\n    }\n\n    CompositeElement tag = Factory.createCompositeElement(XML_TAG);\n    TreeUtil.addChildren(parent, tag);\n\n    addToken(tag, lexer);\n\n    if (lexer.getTokenType() != XML_TAG_NAME) {\n      return true;\n    }\n\n    String openedName = StringFactory.createStringFromConstantArray(lexer.getBuffer(), lexer.getTokenStart(),\n                                                                      lexer.getTokenEnd() - lexer.getTokenStart());\n    addToken(tag, lexer);\n\n    parseAttributeList(tag, lexer);\n\n    while (lexer.getTokenType() == XML_BAD_CHARACTER || lexer.getTokenType() == XML_NAME) {\n      addToken(tag, lexer);\n      parseAttributeList(tag, lexer);\n    }\n    TreeElement tagEnd;\n    if (lexer.getTokenType() == XML_TAG_END) {\n      tagEnd = addToken(tag, lexer);\n      boolean setFlag = false;\n      if (!names.contains(openedName)) {\n        names.add(openedName);\n        setFlag = true;\n      }\n      \n      CompositeElement text = null;\n      while (true) {\n        if (parseProcessingInstruction(tag, lexer)) {\n        }\n        else if (_parseTag(tag, lexer, names)) {\n        }\n        else if (lexer.getTokenType() == XML_DATA_CHARACTERS) {\n          if (text == null) {\n            text = Factory.createCompositeElement(XML_TEXT);\n            TreeUtil.addChildren(tag, text);\n          }\n          addToken(text, lexer);\n        }\n        else if (lexer.getTokenType() == XML_CDATA_START) {\n          addToken(tag, lexer);\n        }\n        else if (lexer.getTokenType() == XML_CDATA_END) {\n          addToken(tag, lexer);\n        }\n        else if (lexer.getTokenType() == XML_CHAR_ENTITY_REF) {\n          addToken(tag, lexer);\n        }\n        else if (lexer.getTokenType() == XML_ENTITY_REF_TOKEN) {\n          TreeUtil.addChildren(tag, parseEntityRef(lexer));\n        }\n        else {\n          break;\n        }\n      }\n      if (setFlag) {\n        names.remove(openedName);\n      }\n\n      final LexerPosition pos = lexer.getCurrentPosition();\n\n      if (lexer.getTokenType() != XML_END_TAG_START) {\n        TreeUtil.insertAfter(tagEnd, Factory.createErrorElement(\"Element is not closed\"));\n\n        return false;\n      }\n      TreeElement endTagStart = ParseUtil.createTokenElement(lexer, myContext.getCharTable());\n      lexer.advance();\n\n      if (lexer.getTokenType() != XML_TAG_NAME) {\n        TreeUtil.addChildren(tag, endTagStart);\n        return true;\n      }\n\n      String closingName = StringFactory.createStringFromConstantArray(lexer.getBuffer(), lexer.getTokenStart(),\n                                                                         lexer.getTokenEnd() - lexer.getTokenStart());\n\n      if (!closingName.equals(openedName) && names.contains(closingName)) {\n        lexer.restore(pos);\n        if (tagEnd != null) {\n          final TreeElement start = tagEnd.getTreeNext();\n          tagEnd.setTreeNext(null);\n          if (start != null) {\n            TreeUtil.addChildren(parent, start);\n          }\n        }\n        TreeUtil.insertAfter(tagEnd, Factory.createErrorElement(\"Element is not closed\"));\n        return true;\n      }\n\n      TreeUtil.addChildren(tag, endTagStart);\n      addToken(tag, lexer);\n\n      if (lexer.getTokenType() != XML_TAG_END) {\n        return true;\n      }\n\n      addToken(tag, lexer);\n    }\n    else if (lexer.getTokenType() == XML_EMPTY_ELEMENT_END) {\n      addToken(tag, lexer);\n    }\n    else {\n      TreeUtil.insertAfter((TreeElement)tag.getLastChildNode(), Factory.createErrorElement(\"Element is not closed\"));\n    }\n\n    return true;\n  }","commit_id":"c38d64cd7f4a17c8952464e815b2d67042b4b2b7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void parseAttributeList(CompositeElement tag, Lexer lexer) {\n    int lastPosition = -1;\n    while (true) {\n      if (lexer.getTokenType() == XML_ENTITY_REF_TOKEN) {\n        TreeUtil.addChildren(tag, parseEntityRef(lexer));\n      continue;\n      }\n\n      if (lexer.getTokenType() != XML_NAME) {\n        return;\n      }\n\n      if (lastPosition != -1) {\n        if (lastPosition == lexer.getTokenStart()) {\n          TreeUtil.addChildren(tag, Factory.createErrorElement(\"Whitespace expected\"));\n          lastPosition = -1;\n        }\n      }\n\n      addToken(tag, lexer);\n\n      if (lexer.getTokenType() != XML_EQ) {\n        TreeUtil.addChildren(tag, Factory.createErrorElement(\"'=' expected\"));\n      continue;\n      }\n\n      addToken(tag, lexer);\n\n      if (lexer.getTokenType() != XML_ATTRIBUTE_VALUE_START_DELIMITER) {\n        return;\n      }\n\n      addToken(tag, lexer);\n\n      if (lexer.getTokenType() == XML_ATTRIBUTE_VALUE_TOKEN) {\n        addToken(tag, lexer);\n        if (lexer.getTokenType() == XML_ATTRIBUTE_VALUE_END_DELIMITER) {\n          lastPosition = lexer.getTokenEnd();\n          addToken(tag, lexer);\n        }\n        else {\n          lastPosition = -1;\n        }\n      }\n      else {\n        lastPosition = -1;\n      }\n    }\n  }","id":102762,"modified_method":"private void parseAttributeList(CompositeElement tag, Lexer lexer) {\n    int lastPosition = -1;\n    while (true) {\n      if (lexer.getTokenType() == XML_ENTITY_REF_TOKEN) {\n        TreeUtil.addChildren(tag, parseEntityRef(lexer));\n      continue;\n      }\n\n      if (lexer.getTokenType() != XML_NAME) {\n        return;\n      }\n\n      if (lastPosition != -1) {\n        if (lastPosition == lexer.getTokenStart()) {\n          TreeUtil.addChildren(tag, Factory.createErrorElement(\"Whitespace expected\"));\n          lastPosition = -1;\n        }\n      }\n\n      CompositeElement attribute = Factory.createCompositeElement(XML_ATTRIBUTE);\n      TreeUtil.addChildren(tag, attribute);\n      \n      addToken(attribute, lexer);\n\n      if (lexer.getTokenType() != XML_EQ) {\n        TreeUtil.addChildren(attribute, Factory.createErrorElement(\"'=' expected\"));\n        continue;\n      }\n\n      addToken(attribute, lexer);\n      \n      CompositeElement attributeValue = Factory.createCompositeElement(XML_ATTRIBUTE_VALUE);\n      TreeUtil.addChildren(attribute,attributeValue);\n\n      if (lexer.getTokenType() != XML_ATTRIBUTE_VALUE_START_DELIMITER) {\n        return;\n      }\n\n      addToken(attributeValue, lexer);\n\n      if (lexer.getTokenType() == XML_ATTRIBUTE_VALUE_TOKEN) {\n        addToken(attributeValue, lexer);\n        if (lexer.getTokenType() == XML_ATTRIBUTE_VALUE_END_DELIMITER) {\n          lastPosition = lexer.getTokenEnd();\n          addToken(attributeValue, lexer);\n        }\n        else {\n          lastPosition = -1;\n        }\n      }\n      else {\n        lastPosition = -1;\n      }\n    }\n  }","commit_id":"2ebafd11bc52db02474edfde7dd556dd1ee31fda","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MBMessage updateStatus(\n\t\t\tlong userId, MBMessage message, ServiceContext serviceContext,\n\t\t\tboolean reIndex)\n\t\tthrows PortalException, SystemException {\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tmessage.setStatus(serviceContext.getStatus());\n\t\tmessage.setStatusByUserId(userId);\n\t\tmessage.setStatusByUserName(user.getFullName());\n\t\tmessage.setStatusDate(now);\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif ((thread.getRootMessageId() == message.getMessageId()) &&\n\t\t\t(oldStatus != serviceContext.getStatus())) {\n\n\t\t\tthread.setStatus(serviceContext.getStatus());\n\t\t\tthread.setStatusByUserId(userId);\n\t\t\tthread.setStatusByUserName(user.getFullName());\n\t\t\tthread.setStatusDate(now);\n\t\t}\n\n\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\tif (message.isAnonymous()) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(now);\n\t\t}\n\n\t\tif ((serviceContext.getStatus() != StatusConstants.APPROVED) &&\n\t\t\t(oldStatus == StatusConstants.APPROVED)) {\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() - 1);\n\t\t}\n\n\t\tif (serviceContext.getStatus() != oldStatus) {\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Category\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tthread.getCategoryId());\n\n\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\tcategory.setLastPostDate(now);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\tif ((serviceContext.getStatus() != StatusConstants.APPROVED) &&\n\t\t\t(oldStatus == StatusConstants.APPROVED)) {\n\n\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tMBMessage.class.getName(), message.getMessageId(), true);\n\n\t\t\tif (reIndex) {\n\t\t\t\treIndex(message);\n\t\t\t}\n\t\t}\n\n\t\tif ((serviceContext.getStatus() != StatusConstants.APPROVED) &&\n\t\t\t(oldStatus == StatusConstants.APPROVED)) {\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tMBMessage.class.getName(), message.getMessageId(), false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()  &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId, now);\n\t\t}\n\n\t\t// Social\n\n\t\tif (!message.isDiscussion() && !message.isAnonymous() &&\n\t\t\t!user.isDefaultUser() &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\tlong receiverUserId = 0;\n\t\t\tMBMessage parentMessage =\n\t\t\t\tmbMessagePersistence.findByPrimaryKey(\n\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\tif (parentMessage !=  null) {\n\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, message.getGroupId(), MBMessage.class.getName(),\n\t\t\t\tmessage.getMessageId(), activityType, StringPool.BLANK,\n\t\t\t\treceiverUserId);\n\t\t}\n\n\t\treturn message;\n\t}","id":102763,"modified_method":"public MBMessage updateStatus(\n\t\t\tlong userId, MBMessage message, ServiceContext serviceContext,\n\t\t\tboolean reIndex)\n\t\tthrows PortalException, SystemException {\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tmessage.setStatus(serviceContext.getStatus());\n\t\tmessage.setStatusByUserId(userId);\n\t\tmessage.setStatusByUserName(user.getFullName());\n\t\tmessage.setStatusDate(now);\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif ((thread.getRootMessageId() == message.getMessageId()) &&\n\t\t\t(oldStatus != serviceContext.getStatus())) {\n\n\t\t\tthread.setStatus(serviceContext.getStatus());\n\t\t\tthread.setStatusByUserId(userId);\n\t\t\tthread.setStatusByUserName(user.getFullName());\n\t\t\tthread.setStatusDate(now);\n\t\t}\n\n\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\tif (message.isAnonymous()) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(now);\n\t\t}\n\n\t\tif ((serviceContext.getStatus() != StatusConstants.APPROVED) &&\n\t\t\t(oldStatus == StatusConstants.APPROVED)) {\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() - 1);\n\t\t}\n\n\t\tif (serviceContext.getStatus() != oldStatus) {\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Category\n\t\t//Todo\n\t\tMBCategory systemCategory = mbCategoryLocalService.getSystemCategory();\n\t\tboolean isSystemCategory =\n\t\t\t(systemCategory.getCategoryId() == message.getCategoryId());\n\n\t\tif (!isSystemCategory) {\n\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tthread.getCategoryId());\n\n\t\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\t\tcategory.setLastPostDate(now);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tif ((serviceContext.getStatus() != StatusConstants.APPROVED) &&\n\t\t\t\t(oldStatus == StatusConstants.APPROVED)) {\n\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\t\t// Asset\n\n\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tMBMessage.class.getName(), message.getMessageId(), true);\n\n\t\t\tif (reIndex) {\n\t\t\t\treIndex(message);\n\t\t\t}\n\t\t}\n\n\t\tif ((serviceContext.getStatus() != StatusConstants.APPROVED) &&\n\t\t\t(oldStatus == StatusConstants.APPROVED)) {\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tMBMessage.class.getName(), message.getMessageId(), false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()  &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId, now);\n\t\t}\n\n\t\t// Social\n\n\t\tif (!message.isDiscussion() && !message.isAnonymous() &&\n\t\t\t!user.isDefaultUser() &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\tlong receiverUserId = 0;\n\t\t\tMBMessage parentMessage =\n\t\t\t\tmbMessagePersistence.findByPrimaryKey(\n\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\tif (parentMessage !=  null) {\n\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, message.getGroupId(), MBMessage.class.getName(),\n\t\t\t\tmessage.getMessageId(), activityType, StringPool.BLANK,\n\t\t\t\treceiverUserId);\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"644dc7d892ad00cd88a4d5ada5cdbdeb47083189","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage updateMessage(\n\t\t\tlong messageId, Date createDate, Date modifiedDate)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tMBMessage message = mbMessagePersistence.findByPrimaryKey(messageId);\n\n\t\tmessage.setCreateDate(createDate);\n\t\tmessage.setModifiedDate(modifiedDate);\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tif (message.getStatus() == StatusConstants.APPROVED) {\n\t\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getThreadId());\n\n\t\t\tif (message.isAnonymous()) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(modifiedDate);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Category\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tmessage.getCategoryId());\n\n\t\tif (message.getStatus() == StatusConstants.APPROVED) {\n\t\t\tcategory.setLastPostDate(modifiedDate);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion() &&\n\t\t\t(message.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), message.getUserId(), modifiedDate);\n\t\t}\n\n\t\treturn message;\n\t}","id":102764,"modified_method":"public MBMessage updateMessage(\n\t\t\tlong messageId, Date createDate, Date modifiedDate)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tMBMessage message = mbMessagePersistence.findByPrimaryKey(messageId);\n\n\t\tmessage.setCreateDate(createDate);\n\t\tmessage.setModifiedDate(modifiedDate);\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tif (message.getStatus() == StatusConstants.APPROVED) {\n\t\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getThreadId());\n\n\t\t\tif (message.isAnonymous()) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(modifiedDate);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Category\n\t\tMBCategory systemCategory = mbCategoryLocalService.getSystemCategory();\n\t\tboolean isSystemCategory =\n\t\t\t(systemCategory.getCategoryId() == message.getCategoryId());\n\n\t\tif (!isSystemCategory) {\n\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getCategoryId());\n\n\t\t\tif (message.getStatus() == StatusConstants.APPROVED) {\n\t\t\t\tcategory.setLastPostDate(modifiedDate);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion() &&\n\t\t\t(message.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), message.getUserId(), modifiedDate);\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"644dc7d892ad00cd88a4d5ada5cdbdeb47083189","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage addMessage(\n\t\t\tString uuid, long userId, String userName, long groupId,\n\t\t\tlong categoryId, long threadId, long parentMessageId,\n\t\t\tString subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files, boolean anonymous,\n\t\t\tdouble priority, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\t// Message\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tuserName = user.isDefaultUser() ? userName : user.getFullName();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences != null) {\n\t\t\tif (!MBUtil.isAllowAnonymousPosting(preferences)) {\n\t\t\t\tif (anonymous || user.isDefaultUser()) {\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (user.isDefaultUser()) {\n\t\t\tanonymous = true;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tlong messageId = counterLocalService.increment();\n\n\t\tlogAddMessage(messageId, stopWatch, 1);\n\n\t\tMBMessage message = mbMessagePersistence.create(messageId);\n\n\t\tmessage.setUuid(uuid);\n\t\tmessage.setGroupId(groupId);\n\t\tmessage.setCompanyId(user.getCompanyId());\n\t\tmessage.setUserId(user.getUserId());\n\t\tmessage.setUserName(userName);\n\t\tmessage.setCreateDate(now);\n\t\tmessage.setModifiedDate(now);\n\t\tmessage.setStatus(serviceContext.getStatus());\n\t\tmessage.setStatusByUserId(user.getUserId());\n\t\tmessage.setStatusByUserName(userName);\n\t\tmessage.setStatusDate(now);\n\n\t\t// Thread\n\n\t\tMBMessage parentMessage = mbMessagePersistence.fetchByPrimaryKey(\n\t\t\tparentMessageId);\n\n\t\tif (parentMessage == null) {\n\t\t\tparentMessageId = MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID;\n\t\t}\n\n\t\tMBThread thread = null;\n\n\t\tif (threadId > 0) {\n\t\t\tthread = mbThreadPersistence.fetchByPrimaryKey(threadId);\n\t\t}\n\n\t\tif ((thread == null) ||\n\t\t\t(parentMessageId == MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\tthreadId = counterLocalService.increment();\n\n\t\t\tthread = mbThreadPersistence.create(threadId);\n\n\t\t\tthread.setGroupId(groupId);\n\t\t\tthread.setCategoryId(categoryId);\n\t\t\tthread.setRootMessageId(messageId);\n\t\t\tthread.setStatus(serviceContext.getStatus());\n\t\t\tthread.setStatusByUserId(user.getUserId());\n\t\t\tthread.setStatusByUserName(userName);\n\t\t\tthread.setStatusDate(now);\n\n\t\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t\t(categoryId !=\n\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID)) {\n\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tcategoryId);\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\n\t\tif (serviceContext.getStatus() == StatusConstants.APPROVED) {\n\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\tif (anonymous) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(userId);\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(now);\n\t\t}\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 2);\n\n\t\t// Message\n\n\t\tmessage.setCategoryId(categoryId);\n\t\tmessage.setThreadId(threadId);\n\t\tmessage.setParentMessageId(parentMessageId);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty());\n\t\tmessage.setAnonymous(anonymous);\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (files.size() > 0) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong dlGroupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, dlGroupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(dfe.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 3);\n\n\t\t// Commit\n\n\t\tmbThreadPersistence.update(thread, false);\n\t\tmbMessagePersistence.update(message, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 4);\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tif (user.isDefaultUser()) {\n\t\t\t\taddMessageResources(message, true, true);\n\t\t\t}\n\t\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getAddCommunityPermissions(),\n\t\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getCommunityPermissions(),\n\t\t\t\t\tserviceContext.getGuestPermissions());\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 5);\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion() &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId, now);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 6);\n\n\t\t// Category\n\n\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(categoryId != MBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID)) {\n\n\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tcategoryId);\n\n\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\tcategory.setLastPostDate(now);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 7);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\tlogAddMessage(messageId, stopWatch, 8);\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\tlogAddMessage(messageId, stopWatch, 9);\n\n\t\t// Social\n\n\t\tif (!message.isDiscussion() && !message.isAnonymous() &&\n\t\t\t!user.isDefaultUser() &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\tlong receiverUserId = 0;\n\n\t\t\tif (parentMessage != null) {\n\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, message.getGroupId(), MBMessage.class.getName(),\n\t\t\t\tmessageId, activityType, StringPool.BLANK, receiverUserId);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 10);\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(message, serviceContext, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 11);\n\n\t\t// Testing roll back\n\n\t\t/*if (true) {\n\t\t\tthrow new SystemException(\"Testing roll back\");\n\t\t}*/\n\n\t\t// Indexer\n\n\t\treIndex(message);\n\n\t\tlogAddMessage(messageId, stopWatch, 12);\n\n\t\treturn message;\n\t}","id":102765,"modified_method":"public MBMessage addMessage(\n\t\t\tString uuid, long userId, String userName, long groupId,\n\t\t\tlong categoryId, long threadId, long parentMessageId,\n\t\t\tString subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files, boolean anonymous,\n\t\t\tdouble priority, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\t// Message\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tuserName = user.isDefaultUser() ? userName : user.getFullName();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences != null) {\n\t\t\tif (!MBUtil.isAllowAnonymousPosting(preferences)) {\n\t\t\t\tif (anonymous || user.isDefaultUser()) {\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (user.isDefaultUser()) {\n\t\t\tanonymous = true;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tlong messageId = counterLocalService.increment();\n\n\t\tlogAddMessage(messageId, stopWatch, 1);\n\n\t\tMBMessage message = mbMessagePersistence.create(messageId);\n\n\t\tmessage.setUuid(uuid);\n\t\tmessage.setGroupId(groupId);\n\t\tmessage.setCompanyId(user.getCompanyId());\n\t\tmessage.setUserId(user.getUserId());\n\t\tmessage.setUserName(userName);\n\t\tmessage.setCreateDate(now);\n\t\tmessage.setModifiedDate(now);\n\t\tmessage.setStatus(serviceContext.getStatus());\n\t\tmessage.setStatusByUserId(user.getUserId());\n\t\tmessage.setStatusByUserName(userName);\n\t\tmessage.setStatusDate(now);\n\n\t\t// Thread\n\n\t\tMBMessage parentMessage = mbMessagePersistence.fetchByPrimaryKey(\n\t\t\tparentMessageId);\n\n\t\tif (parentMessage == null) {\n\t\t\tparentMessageId = MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID;\n\t\t}\n\n\t\tMBThread thread = null;\n\n\t\tif (threadId > 0) {\n\t\t\tthread = mbThreadPersistence.fetchByPrimaryKey(threadId);\n\t\t}\n\n\t\tif ((thread == null) ||\n\t\t\t(parentMessageId == MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\tthreadId = counterLocalService.increment();\n\n\t\t\tthread = mbThreadPersistence.create(threadId);\n\n\t\t\tthread.setGroupId(groupId);\n\t\t\tthread.setCategoryId(categoryId);\n\t\t\tthread.setRootMessageId(messageId);\n\t\t\tthread.setStatus(serviceContext.getStatus());\n\t\t\tthread.setStatusByUserId(user.getUserId());\n\t\t\tthread.setStatusByUserName(userName);\n\t\t\tthread.setStatusDate(now);\n\n\t\t\t//TODO\n\n\t\t\tMBCategory systemCategory = mbCategoryLocalService.getSystemCategory();\n\t\t\tboolean isSystemCategory =\n\t\t\t\t(systemCategory.getCategoryId() == message.getCategoryId());\n\n\t\t\tif (!isSystemCategory) {\n\t\t\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t\t\t(categoryId !=\n\t\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID)) {\n\n\t\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\t\tcategoryId);\n\n\t\t\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\n\t\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (serviceContext.getStatus() == StatusConstants.APPROVED) {\n\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\tif (anonymous) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(userId);\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(now);\n\t\t}\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 2);\n\n\t\t// Message\n\n\t\tmessage.setCategoryId(categoryId);\n\t\tmessage.setThreadId(threadId);\n\t\tmessage.setParentMessageId(parentMessageId);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty());\n\t\tmessage.setAnonymous(anonymous);\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (files.size() > 0) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong dlGroupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, dlGroupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(dfe.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 3);\n\n\t\t// Commit\n\n\t\tmbThreadPersistence.update(thread, false);\n\t\tmbMessagePersistence.update(message, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 4);\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tif (user.isDefaultUser()) {\n\t\t\t\taddMessageResources(message, true, true);\n\t\t\t}\n\t\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getAddCommunityPermissions(),\n\t\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getCommunityPermissions(),\n\t\t\t\t\tserviceContext.getGuestPermissions());\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 5);\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion() &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId, now);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 6);\n\n\t\t// Category\n\n\t\tMBCategory systemCategory = mbCategoryLocalService.getSystemCategory();\n\t\tboolean isSystemCategory =\n\t\t\t(systemCategory.getCategoryId() == categoryId);\n\n\t\tif (!isSystemCategory) {\n\t\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t\t(categoryId != MBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID)) {\n\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tcategoryId);\n\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\t\tcategory.setLastPostDate(now);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 7);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\tlogAddMessage(messageId, stopWatch, 8);\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\tlogAddMessage(messageId, stopWatch, 9);\n\n\t\t// Social\n\n\t\tif (!message.isDiscussion() && !message.isAnonymous() &&\n\t\t\t!user.isDefaultUser() &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\tlong receiverUserId = 0;\n\n\t\t\tif (parentMessage != null) {\n\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, message.getGroupId(), MBMessage.class.getName(),\n\t\t\t\tmessageId, activityType, StringPool.BLANK, receiverUserId);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 10);\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(message, serviceContext, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 11);\n\n\t\t// Testing roll back\n\n\t\t/*if (true) {\n\t\t\tthrow new SystemException(\"Testing roll back\");\n\t\t}*/\n\n\t\t// Indexer\n\n\t\treIndex(message);\n\n\t\tlogAddMessage(messageId, stopWatch, 12);\n\n\t\treturn message;\n\t}","commit_id":"644dc7d892ad00cd88a4d5ada5cdbdeb47083189","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteMessage(MBMessage message)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Indexer\n\n\t\ttry {\n\t\t\tIndexer.deleteMessage(\n\t\t\t\tmessage.getCompanyId(), message.getMessageId());\n\t\t}\n\t\tcatch (SearchException se) {\n\t\t\t_log.error(\"Deleting index \" + message.getMessageId(), se);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (message.isAttachments()) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Thread\n\n\t\tint count = mbMessagePersistence.countByThreadId(message.getThreadId());\n\n\t\t// Message flags\n\n\t\tif (message.isRoot()) {\n\t\t\tmbMessageFlagLocalService.deleteQuestionAndAnswerFlags(\n\t\t\t\tmessage.getThreadId());\n\t\t}\n\n\t\tif (count == 1) {\n\n\t\t\t// Attachments\n\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getThreadAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Subscriptions\n\n\t\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\t\tmessage.getCompanyId(), MBThread.class.getName(),\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Thread\n\n\t\t\tmbThreadPersistence.remove(message.getThreadId());\n\n\t\t\t// Category\n\n\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getCategoryId());\n\n\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\t\telse if (count > 1) {\n\t\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Message is a root message\n\n\t\t\tif (thread.getRootMessageId() == message.getMessageId()) {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\tif (childrenMessages.size() > 1) {\n\t\t\t\t\tthrow new RequiredMessageException(\n\t\t\t\t\t\tString.valueOf(message.getMessageId()));\n\t\t\t\t}\n\t\t\t\telse if (childrenMessages.size() == 1) {\n\t\t\t\t\tMBMessage childMessage = childrenMessages.get(0);\n\n\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID);\n\n\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\n\t\t\t\t\tthread.setRootMessageId(childMessage.getMessageId());\n\n\t\t\t\t\tmbThreadPersistence.update(thread, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Message is a child message\n\n\t\t\telse {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\t// Message has children messages\n\n\t\t\t\tif (childrenMessages.size() > 0) {\n\t\t\t\t\tIterator<MBMessage> itr = childrenMessages.iterator();\n\n\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\tMBMessage childMessage = itr.next();\n\n\t\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Thread\n\n\t\t\tthread.setMessageCount(count - 1);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\t// Category\n\n\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getCategoryId());\n\n\t\t\tcategory.setMessageCount(count - 1);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.deleteActivities(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Ratings\n\n\t\tratingsStatsLocalService.deleteStats(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), message.getUserId());\n\t\t}\n\n\t\t// Message flags\n\n\t\tmbMessageFlagPersistence.removeByMessageId(message.getMessageId());\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tresourceLocalService.deleteResource(\n\t\t\t\tmessage.getCompanyId(), MBMessage.class.getName(),\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, message.getMessageId());\n\t\t}\n\n\t\t// Message\n\n\t\tmbMessagePersistence.remove(message);\n\t}","id":102766,"modified_method":"public void deleteMessage(MBMessage message)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Indexer\n\n\t\ttry {\n\t\t\tIndexer.deleteMessage(\n\t\t\t\tmessage.getCompanyId(), message.getMessageId());\n\t\t}\n\t\tcatch (SearchException se) {\n\t\t\t_log.error(\"Deleting index \" + message.getMessageId(), se);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (message.isAttachments()) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Thread\n\n\t\tint count = mbMessagePersistence.countByThreadId(message.getThreadId());\n\n\t\t// Message flags\n\n\t\tif (message.isRoot()) {\n\t\t\tmbMessageFlagLocalService.deleteQuestionAndAnswerFlags(\n\t\t\t\tmessage.getThreadId());\n\t\t}\n\n\t\tMBCategory systemCategory = mbCategoryLocalService.getSystemCategory();\n\t\tboolean isSystemCategory =\n\t\t\t(systemCategory.getCategoryId() == message.getCategoryId());\n\n\t\tif (count == 1) {\n\n\t\t\t// Attachments\n\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getThreadAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Subscriptions\n\n\t\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\t\tmessage.getCompanyId(), MBThread.class.getName(),\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Thread\n\n\t\t\tmbThreadPersistence.remove(message.getThreadId());\n\n\t\t\t// Category\n\t\t\tif (!isSystemCategory) {\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tmessage.getCategoryId());\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\t\telse if (count > 1) {\n\t\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Message is a root message\n\n\t\t\tif (thread.getRootMessageId() == message.getMessageId()) {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\tif (childrenMessages.size() > 1) {\n\t\t\t\t\tthrow new RequiredMessageException(\n\t\t\t\t\t\tString.valueOf(message.getMessageId()));\n\t\t\t\t}\n\t\t\t\telse if (childrenMessages.size() == 1) {\n\t\t\t\t\tMBMessage childMessage = childrenMessages.get(0);\n\n\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID);\n\n\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\n\t\t\t\t\tthread.setRootMessageId(childMessage.getMessageId());\n\n\t\t\t\t\tmbThreadPersistence.update(thread, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Message is a child message\n\n\t\t\telse {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\t// Message has children messages\n\n\t\t\t\tif (childrenMessages.size() > 0) {\n\t\t\t\t\tIterator<MBMessage> itr = childrenMessages.iterator();\n\n\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\tMBMessage childMessage = itr.next();\n\n\t\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Thread\n\n\t\t\tthread.setMessageCount(count - 1);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\t// Category\n\t\t\tif (!isSystemCategory) {\n\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tmessage.getCategoryId());\n\n\t\t\t\tcategory.setMessageCount(count - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.deleteActivities(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Ratings\n\n\t\tratingsStatsLocalService.deleteStats(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), message.getUserId());\n\t\t}\n\n\t\t// Message flags\n\n\t\tmbMessageFlagPersistence.removeByMessageId(message.getMessageId());\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tresourceLocalService.deleteResource(\n\t\t\t\tmessage.getCompanyId(), MBMessage.class.getName(),\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, message.getMessageId());\n\t\t}\n\n\t\t// Message\n\n\t\tmbMessagePersistence.remove(message);\n\t}","commit_id":"644dc7d892ad00cd88a4d5ada5cdbdeb47083189","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage updateMessage(\n\t\t\tlong userId, long messageId, String subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files,\n\t\t\tList<String> existingFiles, double priority,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tMBMessage message = mbMessagePersistence.findByPrimaryKey(messageId);\n\n\t\tMBCategory category = message.getCategory();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tmessage.setModifiedDate(now);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty() || !existingFiles.isEmpty());\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tlong companyId = message.getCompanyId();\n\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\tlong groupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\tString dirName = message.getAttachmentsDir();\n\n\t\tif (!files.isEmpty() || !existingFiles.isEmpty()) {\n\t\t\ttry {\n\t\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (DuplicateDirectoryException dde) {\n\t\t\t}\n\n\t\t\tString[] fileNames = dlService.getFileNames(\n\t\t\t\tcompanyId, repositoryId, dirName);\n\n\t\t\tfor (String fileName: fileNames) {\n\t\t\t\tif (!existingFiles.contains(fileName)) {\n\t\t\t\t\tdlService.deleteFile(\n\t\t\t\t\t\tcompanyId, portletId, repositoryId, fileName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t}\n\t\t}\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Status\n\n\t\tif (oldStatus != serviceContext.getStatus()) {\n\t\t\tmessage = updateStatus(\n\t\t\t\tuserId, message, serviceContext, false);\n\t\t}\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\t// Category\n\n\t\tif (serviceContext.getStatus() == StatusConstants.APPROVED) {\n\t\t\tcategory.setLastPostDate(now);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Subscriptions\n\n\t\tboolean update = true;\n\n\t\tif ((oldStatus != StatusConstants.APPROVED) &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tupdate = false;\n\t\t}\n\n\t\tnotifySubscribers(message, serviceContext, update);\n\n\t\t// Indexer\n\n\t\treIndex(message);\n\n\t\treturn message;\n\t}","id":102767,"modified_method":"public MBMessage updateMessage(\n\t\t\tlong userId, long messageId, String subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files,\n\t\t\tList<String> existingFiles, double priority,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tMBMessage message = mbMessagePersistence.findByPrimaryKey(messageId);\n\n\t\tMBCategory category = message.getCategory();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tmessage.setModifiedDate(now);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty() || !existingFiles.isEmpty());\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tlong companyId = message.getCompanyId();\n\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\tlong groupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\tString dirName = message.getAttachmentsDir();\n\n\t\tif (!files.isEmpty() || !existingFiles.isEmpty()) {\n\t\t\ttry {\n\t\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (DuplicateDirectoryException dde) {\n\t\t\t}\n\n\t\t\tString[] fileNames = dlService.getFileNames(\n\t\t\t\tcompanyId, repositoryId, dirName);\n\n\t\t\tfor (String fileName: fileNames) {\n\t\t\t\tif (!existingFiles.contains(fileName)) {\n\t\t\t\t\tdlService.deleteFile(\n\t\t\t\t\t\tcompanyId, portletId, repositoryId, fileName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t}\n\t\t}\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Status\n\n\t\tif (oldStatus != serviceContext.getStatus()) {\n\t\t\tmessage = updateStatus(\n\t\t\t\tuserId, message, serviceContext, false);\n\t\t}\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\t// Category\n\t\tMBCategory systemCategory = mbCategoryLocalService.getSystemCategory();\n\t\tboolean isSystemCategory =\n\t\t\t(systemCategory.getCategoryId() == message.getCategoryId());\n\n\t\tif (!isSystemCategory &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED)) {\n\t\t\tcategory.setLastPostDate(now);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Subscriptions\n\n\t\tboolean update = true;\n\n\t\tif ((oldStatus != StatusConstants.APPROVED) &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tupdate = false;\n\t\t}\n\n\t\tnotifySubscribers(message, serviceContext, update);\n\n\t\t// Indexer\n\n\t\treIndex(message);\n\n\t\treturn message;\n\t}","commit_id":"644dc7d892ad00cd88a4d5ada5cdbdeb47083189","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage updateMessage(\n\t\t\tlong userId, long messageId, String subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files,\n\t\t\tList<String> existingFiles, double priority,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tMBMessage message = mbMessagePersistence.findByPrimaryKey(messageId);\n\n\t\tMBCategory category = message.getCategory();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tmessage.setModifiedDate(now);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty() || !existingFiles.isEmpty());\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tlong companyId = message.getCompanyId();\n\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\tlong groupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\tString dirName = message.getAttachmentsDir();\n\n\t\tif (!files.isEmpty() || !existingFiles.isEmpty()) {\n\t\t\ttry {\n\t\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (DuplicateDirectoryException dde) {\n\t\t\t}\n\n\t\t\tString[] fileNames = dlService.getFileNames(\n\t\t\t\tcompanyId, repositoryId, dirName);\n\n\t\t\tfor (String fileName: fileNames) {\n\t\t\t\tif (!existingFiles.contains(fileName)) {\n\t\t\t\t\tdlService.deleteFile(\n\t\t\t\t\t\tcompanyId, portletId, repositoryId, fileName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t}\n\t\t}\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Status\n\n\t\tif (oldStatus != serviceContext.getStatus()) {\n\t\t\tmessage = updateStatus(\n\t\t\t\tuserId, message, serviceContext, false);\n\t\t}\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\t// Category\n\n\t\tif (serviceContext.getStatus() == StatusConstants.APPROVED) {\n\t\t\tcategory.setLastPostDate(now);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Subscriptions\n\n\t\tboolean update = true;\n\n\t\tif ((oldStatus != StatusConstants.APPROVED) &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tupdate = false;\n\t\t}\n\n\t\tnotifySubscribers(message, serviceContext, update);\n\n\t\t// Indexer\n\n\t\treIndex(message);\n\n\t\treturn message;\n\t}","id":102768,"modified_method":"public MBMessage updateMessage(\n\t\t\tlong userId, long messageId, String subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files,\n\t\t\tList<String> existingFiles, double priority,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tMBMessage message = mbMessagePersistence.findByPrimaryKey(messageId);\n\n\t\tMBCategory category = message.getCategory();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tmessage.setModifiedDate(now);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty() || !existingFiles.isEmpty());\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tlong companyId = message.getCompanyId();\n\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\tlong groupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\tString dirName = message.getAttachmentsDir();\n\n\t\tif (!files.isEmpty() || !existingFiles.isEmpty()) {\n\t\t\ttry {\n\t\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (DuplicateDirectoryException dde) {\n\t\t\t}\n\n\t\t\tString[] fileNames = dlService.getFileNames(\n\t\t\t\tcompanyId, repositoryId, dirName);\n\n\t\t\tfor (String fileName: fileNames) {\n\t\t\t\tif (!existingFiles.contains(fileName)) {\n\t\t\t\t\tdlService.deleteFile(\n\t\t\t\t\t\tcompanyId, portletId, repositoryId, fileName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t}\n\t\t}\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Status\n\n\t\tif (oldStatus != serviceContext.getStatus()) {\n\t\t\tmessage = updateStatus(\n\t\t\t\tuserId, message, serviceContext, false);\n\t\t}\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\t// Category\n\n\t\tif (!message.isDiscussion() &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tcategory.setLastPostDate(now);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Subscriptions\n\n\t\tboolean update = true;\n\n\t\tif ((oldStatus != StatusConstants.APPROVED) &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tupdate = false;\n\t\t}\n\n\t\tnotifySubscribers(message, serviceContext, update);\n\n\t\t// Indexer\n\n\t\treIndex(message);\n\n\t\treturn message;\n\t}","commit_id":"14b310e860eb7a35e3d1b866a442939bbbfe8e4e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage addMessage(\n\t\t\tString uuid, long userId, String userName, long groupId,\n\t\t\tlong categoryId, long threadId, long parentMessageId,\n\t\t\tString subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files, boolean anonymous,\n\t\t\tdouble priority, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\t// Message\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tuserName = user.isDefaultUser() ? userName : user.getFullName();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences != null) {\n\t\t\tif (!MBUtil.isAllowAnonymousPosting(preferences)) {\n\t\t\t\tif (anonymous || user.isDefaultUser()) {\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (user.isDefaultUser()) {\n\t\t\tanonymous = true;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tlong messageId = counterLocalService.increment();\n\n\t\tlogAddMessage(messageId, stopWatch, 1);\n\n\t\tMBMessage message = mbMessagePersistence.create(messageId);\n\n\t\tmessage.setUuid(uuid);\n\t\tmessage.setGroupId(groupId);\n\t\tmessage.setCompanyId(user.getCompanyId());\n\t\tmessage.setUserId(user.getUserId());\n\t\tmessage.setUserName(userName);\n\t\tmessage.setCreateDate(now);\n\t\tmessage.setModifiedDate(now);\n\t\tmessage.setStatus(serviceContext.getStatus());\n\t\tmessage.setStatusByUserId(user.getUserId());\n\t\tmessage.setStatusByUserName(userName);\n\t\tmessage.setStatusDate(now);\n\n\t\t// Thread\n\n\t\tMBMessage parentMessage = mbMessagePersistence.fetchByPrimaryKey(\n\t\t\tparentMessageId);\n\n\t\tif (parentMessage == null) {\n\t\t\tparentMessageId = MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID;\n\t\t}\n\n\t\tMBThread thread = null;\n\n\t\tif (threadId > 0) {\n\t\t\tthread = mbThreadPersistence.fetchByPrimaryKey(threadId);\n\t\t}\n\n\t\tif ((thread == null) ||\n\t\t\t(parentMessageId == MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\tthreadId = counterLocalService.increment();\n\n\t\t\tthread = mbThreadPersistence.create(threadId);\n\n\t\t\tthread.setGroupId(groupId);\n\t\t\tthread.setCategoryId(categoryId);\n\t\t\tthread.setRootMessageId(messageId);\n\t\t\tthread.setStatus(serviceContext.getStatus());\n\t\t\tthread.setStatusByUserId(user.getUserId());\n\t\t\tthread.setStatusByUserName(userName);\n\t\t\tthread.setStatusDate(now);\n\n\t\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t\t(categoryId !=\n\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID)) {\n\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tcategoryId);\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\n\t\tif (serviceContext.getStatus() == StatusConstants.APPROVED) {\n\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\tif (anonymous) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(userId);\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(now);\n\t\t}\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 2);\n\n\t\t// Message\n\n\t\tmessage.setCategoryId(categoryId);\n\t\tmessage.setThreadId(threadId);\n\t\tmessage.setParentMessageId(parentMessageId);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty());\n\t\tmessage.setAnonymous(anonymous);\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (files.size() > 0) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong dlGroupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, dlGroupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(dfe.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 3);\n\n\t\t// Commit\n\n\t\tmbThreadPersistence.update(thread, false);\n\t\tmbMessagePersistence.update(message, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 4);\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tif (user.isDefaultUser()) {\n\t\t\t\taddMessageResources(message, true, true);\n\t\t\t}\n\t\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getAddCommunityPermissions(),\n\t\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getCommunityPermissions(),\n\t\t\t\t\tserviceContext.getGuestPermissions());\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 5);\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion() &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId, now);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 6);\n\n\t\t// Category\n\n\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(categoryId != MBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID)) {\n\n\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tcategoryId);\n\n\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\tcategory.setLastPostDate(now);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 7);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\tlogAddMessage(messageId, stopWatch, 8);\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\tlogAddMessage(messageId, stopWatch, 9);\n\n\t\t// Social\n\n\t\tif (!message.isDiscussion() && !message.isAnonymous() &&\n\t\t\t!user.isDefaultUser() &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\tlong receiverUserId = 0;\n\n\t\t\tif (parentMessage != null) {\n\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, message.getGroupId(), MBMessage.class.getName(),\n\t\t\t\tmessageId, activityType, StringPool.BLANK, receiverUserId);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 10);\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(message, serviceContext, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 11);\n\n\t\t// Testing roll back\n\n\t\t/*if (true) {\n\t\t\tthrow new SystemException(\"Testing roll back\");\n\t\t}*/\n\n\t\t// Indexer\n\n\t\treIndex(message);\n\n\t\tlogAddMessage(messageId, stopWatch, 12);\n\n\t\treturn message;\n\t}","id":102769,"modified_method":"public MBMessage addMessage(\n\t\t\tString uuid, long userId, String userName, long groupId,\n\t\t\tlong categoryId, long threadId, long parentMessageId,\n\t\t\tString subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files, boolean anonymous,\n\t\t\tdouble priority, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\t// Message\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tuserName = user.isDefaultUser() ? userName : user.getFullName();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences != null) {\n\t\t\tif (!MBUtil.isAllowAnonymousPosting(preferences)) {\n\t\t\t\tif (anonymous || user.isDefaultUser()) {\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (user.isDefaultUser()) {\n\t\t\tanonymous = true;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tlong messageId = counterLocalService.increment();\n\n\t\tlogAddMessage(messageId, stopWatch, 1);\n\n\t\tMBMessage message = mbMessagePersistence.create(messageId);\n\n\t\tmessage.setUuid(uuid);\n\t\tmessage.setGroupId(groupId);\n\t\tmessage.setCompanyId(user.getCompanyId());\n\t\tmessage.setUserId(user.getUserId());\n\t\tmessage.setUserName(userName);\n\t\tmessage.setCreateDate(now);\n\t\tmessage.setModifiedDate(now);\n\t\tmessage.setStatus(serviceContext.getStatus());\n\t\tmessage.setStatusByUserId(user.getUserId());\n\t\tmessage.setStatusByUserName(userName);\n\t\tmessage.setStatusDate(now);\n\n\t\t// Thread\n\n\t\tMBMessage parentMessage = mbMessagePersistence.fetchByPrimaryKey(\n\t\t\tparentMessageId);\n\n\t\tif (parentMessage == null) {\n\t\t\tparentMessageId = MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID;\n\t\t}\n\n\t\tMBThread thread = null;\n\n\t\tif (threadId > 0) {\n\t\t\tthread = mbThreadPersistence.fetchByPrimaryKey(threadId);\n\t\t}\n\n\t\tif ((thread == null) ||\n\t\t\t(parentMessageId == MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\tthreadId = counterLocalService.increment();\n\n\t\t\tthread = mbThreadPersistence.create(threadId);\n\n\t\t\tthread.setGroupId(groupId);\n\t\t\tthread.setCategoryId(categoryId);\n\t\t\tthread.setRootMessageId(messageId);\n\t\t\tthread.setStatus(serviceContext.getStatus());\n\t\t\tthread.setStatusByUserId(user.getUserId());\n\t\t\tthread.setStatusByUserName(userName);\n\t\t\tthread.setStatusDate(now);\n\n\t\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t\t(categoryId !=\n\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID)) {\n\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tcategoryId);\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\n\t\tif (serviceContext.getStatus() == StatusConstants.APPROVED) {\n\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\tif (anonymous) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(userId);\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(now);\n\t\t}\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 2);\n\n\t\t// Message\n\n\t\tmessage.setCategoryId(categoryId);\n\t\tmessage.setThreadId(threadId);\n\t\tmessage.setParentMessageId(parentMessageId);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty());\n\t\tmessage.setAnonymous(anonymous);\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (files.size() > 0) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong dlGroupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, dlGroupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(dfe.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 3);\n\n\t\t// Commit\n\n\t\tmbThreadPersistence.update(thread, false);\n\t\tmbMessagePersistence.update(message, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 4);\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tif (user.isDefaultUser()) {\n\t\t\t\taddMessageResources(message, true, true);\n\t\t\t}\n\t\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getAddCommunityPermissions(),\n\t\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getCommunityPermissions(),\n\t\t\t\t\tserviceContext.getGuestPermissions());\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 5);\n\n\t\tif (!message.isDiscussion() &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\t// Statistics\n\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId, now);\n\n\t\t\tlogAddMessage(messageId, stopWatch, 6);\n\n\t\t\t// Category\n\n\t\t\tif (categoryId != MBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tcategoryId);\n\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\t\tcategory.setLastPostDate(now);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 7);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\tlogAddMessage(messageId, stopWatch, 8);\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\tlogAddMessage(messageId, stopWatch, 9);\n\n\t\t// Social\n\n\t\tif (!message.isDiscussion() && !message.isAnonymous() &&\n\t\t\t!user.isDefaultUser() &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\tlong receiverUserId = 0;\n\n\t\t\tif (parentMessage != null) {\n\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, message.getGroupId(), MBMessage.class.getName(),\n\t\t\t\tmessageId, activityType, StringPool.BLANK, receiverUserId);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 10);\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(message, serviceContext, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 11);\n\n\t\t// Testing roll back\n\n\t\t/*if (true) {\n\t\t\tthrow new SystemException(\"Testing roll back\");\n\t\t}*/\n\n\t\t// Indexer\n\n\t\treIndex(message);\n\n\t\tlogAddMessage(messageId, stopWatch, 12);\n\n\t\treturn message;\n\t}","commit_id":"14b310e860eb7a35e3d1b866a442939bbbfe8e4e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage updateMessage(\n\t\t\tlong messageId, Date createDate, Date modifiedDate)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tMBMessage message = mbMessagePersistence.findByPrimaryKey(messageId);\n\n\t\tmessage.setCreateDate(createDate);\n\t\tmessage.setModifiedDate(modifiedDate);\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tif (message.getStatus() == StatusConstants.APPROVED) {\n\t\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getThreadId());\n\n\t\t\tif (message.isAnonymous()) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(modifiedDate);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Category\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tmessage.getCategoryId());\n\n\t\tif (message.getStatus() == StatusConstants.APPROVED) {\n\t\t\tcategory.setLastPostDate(modifiedDate);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion() &&\n\t\t\t(message.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), message.getUserId(), modifiedDate);\n\t\t}\n\n\t\treturn message;\n\t}","id":102770,"modified_method":"public MBMessage updateMessage(\n\t\t\tlong messageId, Date createDate, Date modifiedDate)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tMBMessage message = mbMessagePersistence.findByPrimaryKey(messageId);\n\n\t\tmessage.setCreateDate(createDate);\n\t\tmessage.setModifiedDate(modifiedDate);\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tif (message.getStatus() == StatusConstants.APPROVED) {\n\t\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getThreadId());\n\n\t\t\tif (message.isAnonymous()) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(modifiedDate);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\tif (!message.isDiscussion() &&\n\t\t\t(message.getStatus() == StatusConstants.APPROVED)) {\n\n\t\t\t// Category\n\n\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getCategoryId());\n\n\t\t\tcategory.setLastPostDate(modifiedDate);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\n\t\t\t// Statistics\n\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), message.getUserId(), modifiedDate);\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"14b310e860eb7a35e3d1b866a442939bbbfe8e4e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteMessage(MBMessage message)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Indexer\n\n\t\ttry {\n\t\t\tIndexer.deleteMessage(\n\t\t\t\tmessage.getCompanyId(), message.getMessageId());\n\t\t}\n\t\tcatch (SearchException se) {\n\t\t\t_log.error(\"Deleting index \" + message.getMessageId(), se);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (message.isAttachments()) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Thread\n\n\t\tint count = mbMessagePersistence.countByThreadId(message.getThreadId());\n\n\t\t// Message flags\n\n\t\tif (message.isRoot()) {\n\t\t\tmbMessageFlagLocalService.deleteQuestionAndAnswerFlags(\n\t\t\t\tmessage.getThreadId());\n\t\t}\n\n\t\tif (count == 1) {\n\n\t\t\t// Attachments\n\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getThreadAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Subscriptions\n\n\t\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\t\tmessage.getCompanyId(), MBThread.class.getName(),\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Thread\n\n\t\t\tmbThreadPersistence.remove(message.getThreadId());\n\n\t\t\t// Category\n\n\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getCategoryId());\n\n\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\t\telse if (count > 1) {\n\t\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Message is a root message\n\n\t\t\tif (thread.getRootMessageId() == message.getMessageId()) {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\tif (childrenMessages.size() > 1) {\n\t\t\t\t\tthrow new RequiredMessageException(\n\t\t\t\t\t\tString.valueOf(message.getMessageId()));\n\t\t\t\t}\n\t\t\t\telse if (childrenMessages.size() == 1) {\n\t\t\t\t\tMBMessage childMessage = childrenMessages.get(0);\n\n\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID);\n\n\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\n\t\t\t\t\tthread.setRootMessageId(childMessage.getMessageId());\n\n\t\t\t\t\tmbThreadPersistence.update(thread, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Message is a child message\n\n\t\t\telse {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\t// Message has children messages\n\n\t\t\t\tif (childrenMessages.size() > 0) {\n\t\t\t\t\tIterator<MBMessage> itr = childrenMessages.iterator();\n\n\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\tMBMessage childMessage = itr.next();\n\n\t\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Thread\n\n\t\t\tthread.setMessageCount(count - 1);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\t// Category\n\n\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getCategoryId());\n\n\t\t\tcategory.setMessageCount(count - 1);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.deleteActivities(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Ratings\n\n\t\tratingsStatsLocalService.deleteStats(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), message.getUserId());\n\t\t}\n\n\t\t// Message flags\n\n\t\tmbMessageFlagPersistence.removeByMessageId(message.getMessageId());\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tresourceLocalService.deleteResource(\n\t\t\t\tmessage.getCompanyId(), MBMessage.class.getName(),\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, message.getMessageId());\n\t\t}\n\n\t\t// Message\n\n\t\tmbMessagePersistence.remove(message);\n\t}","id":102771,"modified_method":"public void deleteMessage(MBMessage message)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Indexer\n\n\t\ttry {\n\t\t\tIndexer.deleteMessage(\n\t\t\t\tmessage.getCompanyId(), message.getMessageId());\n\t\t}\n\t\tcatch (SearchException se) {\n\t\t\t_log.error(\"Deleting index \" + message.getMessageId(), se);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (message.isAttachments()) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Thread\n\n\t\tint count = mbMessagePersistence.countByThreadId(message.getThreadId());\n\n\t\t// Message flags\n\n\t\tif (message.isRoot()) {\n\t\t\tmbMessageFlagLocalService.deleteQuestionAndAnswerFlags(\n\t\t\t\tmessage.getThreadId());\n\t\t}\n\n\t\tif (count == 1) {\n\n\t\t\t// Attachments\n\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getThreadAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Subscriptions\n\n\t\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\t\tmessage.getCompanyId(), MBThread.class.getName(),\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Thread\n\n\t\t\tmbThreadPersistence.remove(message.getThreadId());\n\n\t\t\t// Category\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tmessage.getCategoryId());\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\t\telse if (count > 1) {\n\t\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Message is a root message\n\n\t\t\tif (thread.getRootMessageId() == message.getMessageId()) {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\tif (childrenMessages.size() > 1) {\n\t\t\t\t\tthrow new RequiredMessageException(\n\t\t\t\t\t\tString.valueOf(message.getMessageId()));\n\t\t\t\t}\n\t\t\t\telse if (childrenMessages.size() == 1) {\n\t\t\t\t\tMBMessage childMessage = childrenMessages.get(0);\n\n\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID);\n\n\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\n\t\t\t\t\tthread.setRootMessageId(childMessage.getMessageId());\n\n\t\t\t\t\tmbThreadPersistence.update(thread, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Message is a child message\n\n\t\t\telse {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\t// Message has children messages\n\n\t\t\t\tif (childrenMessages.size() > 0) {\n\t\t\t\t\tIterator<MBMessage> itr = childrenMessages.iterator();\n\n\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\tMBMessage childMessage = itr.next();\n\n\t\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Thread\n\n\t\t\tthread.setMessageCount(count - 1);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\t// Category\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\t\tmessage.getCategoryId());\n\n\t\t\t\tcategory.setMessageCount(count - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.deleteActivities(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Ratings\n\n\t\tratingsStatsLocalService.deleteStats(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), message.getUserId());\n\t\t}\n\n\t\t// Message flags\n\n\t\tmbMessageFlagPersistence.removeByMessageId(message.getMessageId());\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tresourceLocalService.deleteResource(\n\t\t\t\tmessage.getCompanyId(), MBMessage.class.getName(),\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, message.getMessageId());\n\t\t}\n\n\t\t// Message\n\n\t\tmbMessagePersistence.remove(message);\n\t}","commit_id":"14b310e860eb7a35e3d1b866a442939bbbfe8e4e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteThread(MBThread thread)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tthread.getCategoryId());\n\t\tMBMessage rootMessage = mbMessagePersistence.findByPrimaryKey(\n\t\t\tthread.getRootMessageId());\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tindexer.delete(thread);\n\n\t\t// Attachments\n\n\t\tlong companyId = rootMessage.getCompanyId();\n\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\tString dirName = thread.getAttachmentsDir();\n\n\t\ttry {\n\t\t\tdlService.deleteDirectory(\n\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t}\n\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t}\n\n\t\t// Messages\n\n\t\tList<MBMessage> messages = mbMessagePersistence.findByThreadId(\n\t\t\tthread.getThreadId());\n\n\t\tfor (MBMessage message : messages) {\n\n\t\t\t// Social\n\n\t\t\tsocialActivityLocalService.deleteActivities(\n\t\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t\t// Ratings\n\n\t\t\tratingsStatsLocalService.deleteStats(\n\t\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t\t// Statistics\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\t\tmessage.getGroupId(), message.getUserId());\n\t\t\t}\n\n\t\t\t// Message flags\n\n\t\t\tmbMessageFlagPersistence.removeByMessageId(message.getMessageId());\n\n\t\t\t// Resources\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tresourceLocalService.deleteResource(\n\t\t\t\t\tmessage.getCompanyId(), MBMessage.class.getName(),\n\t\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, message.getMessageId());\n\t\t\t}\n\n\t\t\t// Message\n\n\t\t\tmbMessagePersistence.remove(message);\n\t\t}\n\n\t\t// Category\n\n\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\t\tcategory.setMessageCount(category.getMessageCount() - messages.size());\n\n\t\tmbCategoryPersistence.update(category, false);\n\n\t\t// Thread\n\n\t\tmbThreadPersistence.remove(thread);\n\t}","id":102772,"modified_method":"public void deleteThread(MBThread thread)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tthread.getCategoryId());\n\t\tMBMessage rootMessage = mbMessagePersistence.findByPrimaryKey(\n\t\t\tthread.getRootMessageId());\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tindexer.delete(thread);\n\n\t\t// Attachments\n\n\t\tlong companyId = rootMessage.getCompanyId();\n\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\tString dirName = thread.getAttachmentsDir();\n\n\t\ttry {\n\t\t\tdlService.deleteDirectory(\n\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t}\n\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t}\n\n\t\t// Messages\n\n\t\tList<MBMessage> messages = mbMessagePersistence.findByThreadId(\n\t\t\tthread.getThreadId());\n\n\t\tfor (MBMessage message : messages) {\n\n\t\t\t// Social\n\n\t\t\tsocialActivityLocalService.deleteActivities(\n\t\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t\t// Ratings\n\n\t\t\tratingsStatsLocalService.deleteStats(\n\t\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t\t// Statistics\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\t\tmessage.getGroupId(), message.getUserId());\n\t\t\t}\n\n\t\t\t// Message flags\n\n\t\t\tmbMessageFlagPersistence.removeByMessageId(message.getMessageId());\n\n\t\t\t// Resources\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tresourceLocalService.deleteResource(\n\t\t\t\t\tmessage.getCompanyId(), MBMessage.class.getName(),\n\t\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, message.getMessageId());\n\t\t\t}\n\n\t\t\t// Message\n\n\t\t\tmbMessagePersistence.remove(message);\n\t\t}\n\n\t\t// Category\n\n\t\tif (!rootMessage.isDiscussion()) {\n\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\t\t\tcategory.setMessageCount(\n\t\t\t\tcategory.getMessageCount() - messages.size());\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\t// Thread\n\n\t\tmbThreadPersistence.remove(thread);\n\t}","commit_id":"25058494cc3b26ccf084efe44ebefb35582e01e3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void init(SNode thisNode) {\n    SNode target = SConceptOperations.createNewNode(\"jetbrains.mps.buildlanguage.structure.TargetDeclaration\", null);\n    SLinkOperations.addChild(thisNode, \"target\", target);\n    SPropertyOperations.set(ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"target\", true)).first(), \"name\", \"default\");\n    SNode defaultRef = SConceptOperations.createNewNode(\"jetbrains.mps.buildlanguage.structure.TargetReference\", null);\n    SLinkOperations.setTarget(defaultRef, \"targetDeclaration\", ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"target\", true)).first(), false);\n    SLinkOperations.setTarget(thisNode, \"default\", defaultRef, true);\n  }","id":102773,"modified_method":"public static void init(SNode thisNode) {\n    SNode target = SConceptOperations.createNewNode(\"jetbrains.mps.buildlanguage.structure.TargetDeclaration\", null);\n    ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"target\", true)).addElement(target);\n    SPropertyOperations.set(ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"target\", true)).first(), \"name\", \"default\");\n    SNode defaultRef = SConceptOperations.createNewNode(\"jetbrains.mps.buildlanguage.structure.TargetReference\", null);\n    SLinkOperations.setTarget(defaultRef, \"targetDeclaration\", ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"target\", true)).first(), false);\n    SLinkOperations.setTarget(thisNode, \"default\", defaultRef, true);\n  }","commit_id":"56770a6244b72ad260d30715a9394b1b8661409f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String call_getDependanceString_1213877231974(SNode thisNode) {\n    if (ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"depends\", true)).isEmpty()) {\n      return \"\";\n    }\n    StringBuffer buffer = new StringBuffer();\n    for (int i = 0; i < SLinkOperations.getCount(thisNode, \"depends\"); i++) {\n      buffer.append(SPropertyOperations.getString(SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"depends\", true)).getElement(i), \"targetDeclaration\", false), \"name\"));\n      if (i < SLinkOperations.getCount(thisNode, \"depends\") - 1) {\n        buffer.append(\",\");\n      }\n    }\n    return buffer.toString();\n  }","id":102774,"modified_method":"public static String call_getDependanceString_1213877231974(SNode thisNode) {\n    if (ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"depends\", true)).isEmpty()) {\n      return \"\";\n    }\n    StringBuffer buffer = new StringBuffer();\n    for (int i = 0; i < ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"depends\", true)).count(); i++) {\n      buffer.append(SPropertyOperations.getString(SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"depends\", true)).getElement(i), \"targetDeclaration\", false), \"name\"));\n      if (i < ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"depends\", true)).count() - 1) {\n        buffer.append(\",\");\n      }\n    }\n    return buffer.toString();\n  }","commit_id":"56770a6244b72ad260d30715a9394b1b8661409f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean renderingCondition4669_0(SNode node, EditorContext editorContext, IScope scope) {\n    return SLinkOperations.getCount(node, \"depends\") != 0 || editorContext.isInspector();\n  }","id":102775,"modified_method":"private static boolean renderingCondition4669_0(SNode node, EditorContext editorContext, IScope scope) {\n    return ListSequence.fromList(SLinkOperations.getTargets(node, \"depends\", true)).count() != 0 || editorContext.isInspector();\n  }","commit_id":"56770a6244b72ad260d30715a9394b1b8661409f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean renderingCondition8362_0(SNode node, EditorContext editorContext, IScope scope) {\n    return SLinkOperations.getCount(node, \"depends\") != 0 || editorContext.isInspector();\n  }","id":102776,"modified_method":"private static boolean renderingCondition8362_0(SNode node, EditorContext editorContext, IScope scope) {\n    return ListSequence.fromList(SLinkOperations.getTargets(node, \"depends\", true)).count() != 0 || editorContext.isInspector();\n  }","commit_id":"56770a6244b72ad260d30715a9394b1b8661409f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean renderingCondition7316_0(SNode node, EditorContext editorContext, IScope scope) {\n    return SLinkOperations.getCount(node, \"parameter\") > 0;\n  }","id":102777,"modified_method":"private static boolean renderingCondition7316_0(SNode node, EditorContext editorContext, IScope scope) {\n    return ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).count() > 0;\n  }","commit_id":"b630c4e30f6587db7f189986cb8dfa047fdc6f74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isApplicableToNode(final SNode node, final EditorContext editorContext) {\n    return SLinkOperations.getCount(node, \"parameter\") == 0;\n  }","id":102778,"modified_method":"public boolean isApplicableToNode(final SNode node, final EditorContext editorContext) {\n    return ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).count() == 0;\n  }","commit_id":"b630c4e30f6587db7f189986cb8dfa047fdc6f74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode ite, final TypeCheckingContext typeCheckingContext) {\n    SNode c = SNodeOperations.getAncestor(ite, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n    SNode ct = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ClassifierType\", null);\n    SLinkOperations.setTarget(ct, \"classifier\", c, false);\n    SLinkOperations.getTargets(c, \"typeVariableDeclaration\", true);\n    {\n      SNode tvd;\n      Iterator<SNode> tvd_iterator = ListSequence.fromList(SLinkOperations.getTargets(c, \"typeVariableDeclaration\", true)).iterator();\n      while (true) {\n        if (!(tvd_iterator.hasNext())) {\n          break;\n        }\n        tvd = tvd_iterator.next();\n        {\n          SNode tvr = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", null);\n          SLinkOperations.setTarget(tvr, \"typeVariableDeclaration\", tvd, false);\n          SLinkOperations.addChild(ct, \"parameter\", tvr);\n        }\n      }\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = ite;\n      BaseIntentionProvider intentionProvider = null;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903ab(jetbrains.mps.baseLanguageInternal.typesystem)\", \"1202838278072\", 0, intentionProvider);\n      typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903ab(jetbrains.mps.baseLanguageInternal.typesystem)\", \"1202838281158\", true), (SNode) ct, _info_12389875345);\n    }\n  }","id":102779,"modified_method":"public void applyRule(final SNode ite, final TypeCheckingContext typeCheckingContext) {\n    SNode c = SNodeOperations.getAncestor(ite, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n    SNode ct = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ClassifierType\", null);\n    SLinkOperations.setTarget(ct, \"classifier\", c, false);\n    SLinkOperations.getTargets(c, \"typeVariableDeclaration\", true);\n    {\n      SNode tvd;\n      Iterator<SNode> tvd_iterator = ListSequence.fromList(SLinkOperations.getTargets(c, \"typeVariableDeclaration\", true)).iterator();\n      while (true) {\n        if (!(tvd_iterator.hasNext())) {\n          break;\n        }\n        tvd = tvd_iterator.next();\n        {\n          SNode tvr = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", null);\n          SLinkOperations.setTarget(tvr, \"typeVariableDeclaration\", tvd, false);\n          ListSequence.fromList(SLinkOperations.getTargets(ct, \"parameter\", true)).addElement(tvr);\n        }\n      }\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = ite;\n      BaseIntentionProvider intentionProvider = null;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895903ab(jetbrains.mps.baseLanguageInternal.typesystem)\", \"1202838278072\", 0, intentionProvider);\n      typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895903ab(jetbrains.mps.baseLanguageInternal.typesystem)\", \"1202838281158\", true), (SNode) ct, _info_12389875345);\n    }\n  }","commit_id":"b630c4e30f6587db7f189986cb8dfa047fdc6f74","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode generateEditorCellModel(SNode lineList, SNode concept, Map<SNode, SNode> partsToLinks) {\n    List<SNode> lines = SLinkOperations.getTargets(lineList, \"line\", true);\n    if (ListSequence.fromList(lines).count() == 0) {\n      if (SPropertyOperations.getBoolean(concept, \"abstract\")) {\n        SNode errorCell = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellModel_Error\", null);\n        SPropertyOperations.set(errorCell, \"text\", \"abstract \" + SPropertyOperations.getString(concept, \"name\"));\n        return errorCell;\n      } else {\n        return null;\n      }\n    } else if (ListSequence.fromList(lines).count() == 1) {\n      List<SNode> lineParts = SLinkOperations.getTargets(ListSequence.fromList(lines).first(), \"linePart\", true);\n      if (ListSequence.fromList(lineParts).count() == 1) {\n        return LinePart_Behavior.call_createCellModel_1238614099938(ListSequence.fromList(lineParts).first(), partsToLinks);\n      } else {\n        SNode hCollection = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellModel_Collection\", null);\n        SLinkOperations.setTarget(hCollection, \"cellLayout\", SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellLayout_Horizontal\", null), true);\n        for (SNode linePart : lineParts) {\n          SLinkOperations.addChild(hCollection, \"childCellModel\", LinePart_Behavior.call_createCellModel_1238614099938(linePart, partsToLinks));\n        }\n        return hCollection;\n      }\n    } else {\n      SNode vCollection = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellModel_Collection\", null);\n      SLinkOperations.setTarget(vCollection, \"cellLayout\", SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellLayout_Vertical\", null), true);\n      for (SNode line : lines) {\n        SNode hCollection = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellModel_Collection\", null);\n        SLinkOperations.setTarget(hCollection, \"cellLayout\", SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellLayout_Horizontal\", null), true);\n        SLinkOperations.addChild(vCollection, \"childCellModel\", hCollection);\n        for (SNode linePart : SLinkOperations.getTargets(line, \"linePart\", true)) {\n          SLinkOperations.addChild(hCollection, \"childCellModel\", LinePart_Behavior.call_createCellModel_1238614099938(linePart, partsToLinks));\n        }\n      }\n      return vCollection;\n    }\n  }","id":102780,"modified_method":"public static SNode generateEditorCellModel(SNode lineList, SNode concept, Map<SNode, SNode> partsToLinks) {\n    List<SNode> lines = SLinkOperations.getTargets(lineList, \"line\", true);\n    if (ListSequence.fromList(lines).count() == 0) {\n      if (SPropertyOperations.getBoolean(concept, \"abstract\")) {\n        SNode errorCell = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellModel_Error\", null);\n        SPropertyOperations.set(errorCell, \"text\", \"abstract \" + SPropertyOperations.getString(concept, \"name\"));\n        return errorCell;\n      } else {\n        return null;\n      }\n    } else if (ListSequence.fromList(lines).count() == 1) {\n      List<SNode> lineParts = SLinkOperations.getTargets(ListSequence.fromList(lines).first(), \"linePart\", true);\n      if (ListSequence.fromList(lineParts).count() == 1) {\n        return LinePart_Behavior.call_createCellModel_1238614099938(ListSequence.fromList(lineParts).first(), partsToLinks);\n      } else {\n        SNode hCollection = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellModel_Collection\", null);\n        SLinkOperations.setTarget(hCollection, \"cellLayout\", SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellLayout_Horizontal\", null), true);\n        for (SNode linePart : lineParts) {\n          ListSequence.fromList(SLinkOperations.getTargets(hCollection, \"childCellModel\", true)).addElement(LinePart_Behavior.call_createCellModel_1238614099938(linePart, partsToLinks));\n        }\n        return hCollection;\n      }\n    } else {\n      SNode vCollection = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellModel_Collection\", null);\n      SLinkOperations.setTarget(vCollection, \"cellLayout\", SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellLayout_Vertical\", null), true);\n      for (SNode line : lines) {\n        SNode hCollection = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellModel_Collection\", null);\n        SLinkOperations.setTarget(hCollection, \"cellLayout\", SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellLayout_Horizontal\", null), true);\n        ListSequence.fromList(SLinkOperations.getTargets(vCollection, \"childCellModel\", true)).addElement(hCollection);\n        for (SNode linePart : SLinkOperations.getTargets(line, \"linePart\", true)) {\n          ListSequence.fromList(SLinkOperations.getTargets(hCollection, \"childCellModel\", true)).addElement(LinePart_Behavior.call_createCellModel_1238614099938(linePart, partsToLinks));\n        }\n      }\n      return vCollection;\n    }\n  }","commit_id":"61867fe5d8fe909b4ad875cbf29c3b30ccf0762b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void fillBinarySideTransformActions(SNode binaryOperationConcept, SNode actions, Map<SNode, SNode> conceptsToTargets, Map<SNode, SNode> linePartsToLinks) {\n    SNode expressionConcept = (SNode)MapSequence.fromMap(conceptsToTargets).get(SLinkOperations.getTarget(SNodeOperations.getAncestor(binaryOperationConcept, \"jetbrains.mpslite.structure.ConceptContainer\", false, false), \"expressionConcept\", true));\n    if ((expressionConcept != null)) {\n      SNode rtBuilder = new _Quotations.QuotationClass_2().createNode(SNodeOperations.cast(MapSequence.fromMap(linePartsToLinks).get(SLinkOperations.getTarget(binaryOperationConcept, \"leftTarget\", true)), \"jetbrains.mps.lang.structure.structure.LinkDeclaration\"), MapSequence.fromMap(conceptsToTargets).get(binaryOperationConcept), expressionConcept);\n      SNode ltBuilder = new _Quotations.QuotationClass_3().createNode(SNodeOperations.cast(MapSequence.fromMap(linePartsToLinks).get(SLinkOperations.getTarget(binaryOperationConcept, \"rightTarget\", true)), \"jetbrains.mps.lang.structure.structure.LinkDeclaration\"), MapSequence.fromMap(conceptsToTargets).get(binaryOperationConcept), expressionConcept);\n      SLinkOperations.addChild(actions, \"actionsBuilder\", rtBuilder);\n      SLinkOperations.addChild(actions, \"actionsBuilder\", ltBuilder);\n    }\n  }","id":102781,"modified_method":"public static void fillBinarySideTransformActions(SNode binaryOperationConcept, SNode actions, Map<SNode, SNode> conceptsToTargets, Map<SNode, SNode> linePartsToLinks) {\n    SNode expressionConcept = (SNode)MapSequence.fromMap(conceptsToTargets).get(SLinkOperations.getTarget(SNodeOperations.getAncestor(binaryOperationConcept, \"jetbrains.mpslite.structure.ConceptContainer\", false, false), \"expressionConcept\", true));\n    if ((expressionConcept != null)) {\n      SNode rtBuilder = new _Quotations.QuotationClass_2().createNode(SNodeOperations.cast(MapSequence.fromMap(linePartsToLinks).get(SLinkOperations.getTarget(binaryOperationConcept, \"leftTarget\", true)), \"jetbrains.mps.lang.structure.structure.LinkDeclaration\"), MapSequence.fromMap(conceptsToTargets).get(binaryOperationConcept), expressionConcept);\n      SNode ltBuilder = new _Quotations.QuotationClass_3().createNode(SNodeOperations.cast(MapSequence.fromMap(linePartsToLinks).get(SLinkOperations.getTarget(binaryOperationConcept, \"rightTarget\", true)), \"jetbrains.mps.lang.structure.structure.LinkDeclaration\"), MapSequence.fromMap(conceptsToTargets).get(binaryOperationConcept), expressionConcept);\n      ListSequence.fromList(SLinkOperations.getTargets(actions, \"actionsBuilder\", true)).addElement(rtBuilder);\n      ListSequence.fromList(SLinkOperations.getTargets(actions, \"actionsBuilder\", true)).addElement(ltBuilder);\n    }\n  }","commit_id":"61867fe5d8fe909b4ad875cbf29c3b30ccf0762b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode virtual_createCellModel_1238614099938(SNode thisNode, Map<SNode, SNode> partsToLinks) {\n    SNode refCell = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellModel_RefCell\", null);\n    SNode linkDeclaration = SNodeOperations.cast(MapSequence.fromMap(partsToLinks).get(thisNode), \"jetbrains.mps.lang.structure.structure.LinkDeclaration\");\n    SLinkOperations.setTarget(refCell, \"relationDeclaration\", linkDeclaration, false);\n    SNode component = SLinkOperations.setNewChild(refCell, \"editorComponent\", \"jetbrains.mps.lang.editor.structure.InlineEditorComponent\");\n    SNode propertyCell = SLinkOperations.setNewChild(component, \"cellModel\", \"jetbrains.mps.lang.editor.structure.CellModel_Property\");\n    SNode targetConcept = SLinkOperations.getTarget(linkDeclaration, \"target\", false);\n    if (SConceptOperations.isSubConceptOf(targetConcept, \"jetbrains.mps.lang.core.structure.INamedConcept\")) {\n      SLinkOperations.setTarget(propertyCell, \"relationDeclaration\", ListSequence.fromList(SLinkOperations.getTargets(SConceptOperations.findConceptDeclaration(\"jetbrains.mps.lang.core.structure.INamedConcept\"), \"propertyDeclaration\", true)).first(), false);\n    } else if (SLinkOperations.getCount(targetConcept, \"propertyDeclaration\") == 1) {\n      SLinkOperations.setTarget(propertyCell, \"relationDeclaration\", ListSequence.fromList(SLinkOperations.getTargets(targetConcept, \"propertyDeclaration\", true)).first(), false);\n    }\n    return refCell;\n  }","id":102782,"modified_method":"public static SNode virtual_createCellModel_1238614099938(SNode thisNode, Map<SNode, SNode> partsToLinks) {\n    SNode refCell = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellModel_RefCell\", null);\n    SNode linkDeclaration = SNodeOperations.cast(MapSequence.fromMap(partsToLinks).get(thisNode), \"jetbrains.mps.lang.structure.structure.LinkDeclaration\");\n    SLinkOperations.setTarget(refCell, \"relationDeclaration\", linkDeclaration, false);\n    SNode component = SLinkOperations.setNewChild(refCell, \"editorComponent\", \"jetbrains.mps.lang.editor.structure.InlineEditorComponent\");\n    SNode propertyCell = SLinkOperations.setNewChild(component, \"cellModel\", \"jetbrains.mps.lang.editor.structure.CellModel_Property\");\n    SNode targetConcept = SLinkOperations.getTarget(linkDeclaration, \"target\", false);\n    if (SConceptOperations.isSubConceptOf(targetConcept, \"jetbrains.mps.lang.core.structure.INamedConcept\")) {\n      SLinkOperations.setTarget(propertyCell, \"relationDeclaration\", ListSequence.fromList(SLinkOperations.getTargets(SConceptOperations.findConceptDeclaration(\"jetbrains.mps.lang.core.structure.INamedConcept\"), \"propertyDeclaration\", true)).first(), false);\n    } else if (ListSequence.fromList(SLinkOperations.getTargets(targetConcept, \"propertyDeclaration\", true)).count() == 1) {\n      SLinkOperations.setTarget(propertyCell, \"relationDeclaration\", ListSequence.fromList(SLinkOperations.getTargets(targetConcept, \"propertyDeclaration\", true)).first(), false);\n    }\n    return refCell;\n  }","commit_id":"61867fe5d8fe909b4ad875cbf29c3b30ccf0762b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void execute_internal(final KeyEvent keyEvent, final EditorContext editorContext, final SNode node, final List<SNode> selectedNodes) {\n      SNode selectedNode = editorContext.getSelectedNode();\n      SNode linePart = SNodeOperations.getAncestor(selectedNode, \"jetbrains.mpslite.structure.LinePart\", true, false);\n      SNode prevLinePart = null;\n      while (linePart != null) {\n        prevLinePart = linePart;\n        linePart = SNodeOperations.getAncestor(linePart, \"jetbrains.mpslite.structure.LinePart\", false, false);\n      }\n      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(prevLinePart), \"jetbrains.mpslite.structure.Line\")) {\n        SNode line = SNodeOperations.cast(SNodeOperations.getParent(prevLinePart), \"jetbrains.mpslite.structure.Line\");\n        SNode nextLine = SNodeOperations.insertNextSiblingChild(line, SConceptOperations.createNewNode(\"jetbrains.mpslite.structure.Line\", null));\n        SNode sibling = SNodeOperations.cast(SNodeOperations.getNextSibling(prevLinePart), \"jetbrains.mpslite.structure.LinePart\");\n        while (sibling != null) {\n          SNode currentSibling = sibling;\n          sibling = SNodeOperations.cast(SNodeOperations.getNextSibling(sibling), \"jetbrains.mpslite.structure.LinePart\");\n          line.removeChild(currentSibling);\n          SLinkOperations.addChild(nextLine, \"linePart\", currentSibling);\n        }\n      }\n    }","id":102783,"modified_method":"private void execute_internal(final KeyEvent keyEvent, final EditorContext editorContext, final SNode node, final List<SNode> selectedNodes) {\n      SNode selectedNode = editorContext.getSelectedNode();\n      SNode linePart = SNodeOperations.getAncestor(selectedNode, \"jetbrains.mpslite.structure.LinePart\", true, false);\n      SNode prevLinePart = null;\n      while (linePart != null) {\n        prevLinePart = linePart;\n        linePart = SNodeOperations.getAncestor(linePart, \"jetbrains.mpslite.structure.LinePart\", false, false);\n      }\n      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(prevLinePart), \"jetbrains.mpslite.structure.Line\")) {\n        SNode line = SNodeOperations.cast(SNodeOperations.getParent(prevLinePart), \"jetbrains.mpslite.structure.Line\");\n        SNode nextLine = SNodeOperations.insertNextSiblingChild(line, SConceptOperations.createNewNode(\"jetbrains.mpslite.structure.Line\", null));\n        SNode sibling = SNodeOperations.cast(SNodeOperations.getNextSibling(prevLinePart), \"jetbrains.mpslite.structure.LinePart\");\n        while (sibling != null) {\n          SNode currentSibling = sibling;\n          sibling = SNodeOperations.cast(SNodeOperations.getNextSibling(sibling), \"jetbrains.mpslite.structure.LinePart\");\n          line.removeChild(currentSibling);\n          ListSequence.fromList(SLinkOperations.getTargets(nextLine, \"linePart\", true)).addElement(currentSibling);\n        }\n      }\n    }","commit_id":"61867fe5d8fe909b4ad875cbf29c3b30ccf0762b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public FindInstancesDialog(final IOperationContext context, final Language language) {\n    super(context.getMainFrame(), \"Find Instances by condition\");\n    this.myContext = context;\n    this.setSize(new Dimension(500, 500));\n    this.setModal(false);\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        FindInstancesDialog.this.myNode = SConceptOperations.createNewNode(\"jetbrains.mps.quickQueryLanguage.structure.ModelQuery\", null);\n        SNode statementList = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.StatementList\", null);\n        SNode expressionStatement = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null);\n        SNode defaultCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.BooleanConstant\", null);\n        SPropertyOperations.set(defaultCondition, \"value\", \"\" + true);\n        SLinkOperations.setTarget(expressionStatement, \"expression\", defaultCondition, true);\n        SLinkOperations.addChild(statementList, \"statement\", expressionStatement);\n        SLinkOperations.setTarget(SLinkOperations.getTarget(FindInstancesDialog.this.myNode, \"condition\", true), \"body\", statementList, true);\n        FindInstancesDialog.this.myEditor = new EmbeddableEditor(context, new ModelOwner() {}, FindInstancesDialog.this.myNode);\n      }\n    });\n    final Wrappers._T<List<Language>> languageList = new Wrappers._T<List<Language>>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        languageList.value = language.getAllExtendedLanguages();\n      }\n    });\n    for (Language extendedLanguage : languageList.value) {\n      this.myEditor.addLanguageStructureModel(extendedLanguage);\n    }\n    this.myPanel.add(this.myEditor.getComponenet(), BorderLayout.CENTER);\n    this.myEditor.addLanguageStructureModel(BootstrapLanguages.collectionsLanguage());\n    this.myEditor.addLanguageStructureModel(language);\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        FindInstancesDialog.this.myScope = new ScopeEditor(new ScopeOptions());\n        FindInstancesDialog.this.myPanel.add(FindInstancesDialog.this.myScope.getComponent(), BorderLayout.SOUTH);\n      }\n    });\n  }","id":102784,"modified_method":"public FindInstancesDialog(final IOperationContext context, final Language language) {\n    super(context.getMainFrame(), \"Find Instances by condition\");\n    this.myContext = context;\n    this.setSize(new Dimension(500, 500));\n    this.setModal(false);\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        FindInstancesDialog.this.myNode = SConceptOperations.createNewNode(\"jetbrains.mps.quickQueryLanguage.structure.ModelQuery\", null);\n        SNode statementList = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.StatementList\", null);\n        SNode expressionStatement = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null);\n        SNode defaultCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.BooleanConstant\", null);\n        SPropertyOperations.set(defaultCondition, \"value\", \"\" + true);\n        SLinkOperations.setTarget(expressionStatement, \"expression\", defaultCondition, true);\n        ListSequence.fromList(SLinkOperations.getTargets(statementList, \"statement\", true)).addElement(expressionStatement);\n        SLinkOperations.setTarget(SLinkOperations.getTarget(FindInstancesDialog.this.myNode, \"condition\", true), \"body\", statementList, true);\n        FindInstancesDialog.this.myEditor = new EmbeddableEditor(context, new ModelOwner() {}, FindInstancesDialog.this.myNode);\n      }\n    });\n    final Wrappers._T<List<Language>> languageList = new Wrappers._T<List<Language>>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        languageList.value = language.getAllExtendedLanguages();\n      }\n    });\n    for (Language extendedLanguage : languageList.value) {\n      this.myEditor.addLanguageStructureModel(extendedLanguage);\n    }\n    this.myPanel.add(this.myEditor.getComponenet(), BorderLayout.CENTER);\n    this.myEditor.addLanguageStructureModel(BootstrapLanguages.collectionsLanguage());\n    this.myEditor.addLanguageStructureModel(language);\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        FindInstancesDialog.this.myScope = new ScopeEditor(new ScopeOptions());\n        FindInstancesDialog.this.myPanel.add(FindInstancesDialog.this.myScope.getComponent(), BorderLayout.SOUTH);\n      }\n    });\n  }","commit_id":"d1bda9d448ad21b28e5f87bc93de849352ae7732","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode sourceNodeQuery_1220269203624(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    if ((SLinkOperations.getTarget(_context.getNode(), \"condition\", true) != null)) {\n      return SLinkOperations.getTarget(SLinkOperations.getTarget(_context.getNode(), \"condition\", true), \"body\", true);\n    }\n    SNode statementList = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.StatementList\", null);\n    SNode expressionStatement = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null);\n    SNode defaultCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.BooleanConstant\", null);\n    SPropertyOperations.set(defaultCondition, \"value\", \"\" + false);\n    SLinkOperations.setTarget(expressionStatement, \"expression\", defaultCondition, true);\n    SLinkOperations.addChild(statementList, \"statement\", expressionStatement);\n    return statementList;\n  }","id":102785,"modified_method":"public static SNode sourceNodeQuery_1220269203624(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    if ((SLinkOperations.getTarget(_context.getNode(), \"condition\", true) != null)) {\n      return SLinkOperations.getTarget(SLinkOperations.getTarget(_context.getNode(), \"condition\", true), \"body\", true);\n    }\n    SNode statementList = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.StatementList\", null);\n    SNode expressionStatement = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\", null);\n    SNode defaultCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.BooleanConstant\", null);\n    SPropertyOperations.set(defaultCondition, \"value\", \"\" + false);\n    SLinkOperations.setTarget(expressionStatement, \"expression\", defaultCondition, true);\n    ListSequence.fromList(SLinkOperations.getTargets(statementList, \"statement\", true)).addElement(expressionStatement);\n    return statementList;\n  }","commit_id":"d1bda9d448ad21b28e5f87bc93de849352ae7732","url":"https://github.com/JetBrains/MPS"},{"original_method":"@BeforeClass\r\n\t@Override\r\n\tpublic void beforeClass() throws Exception {\r\n\t\tsuper.beforeClass();\r\n\t\trecord = database.newInstance();\r\n\t}","id":102786,"modified_method":"@BeforeClass\r\n  @Override\r\n  public void beforeClass() throws Exception {\r\n    super.beforeClass();\r\n    record = new ORecordFlat();\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test(dependsOnMethods = \"testCreateRaw\")\r\n  public void readRawWithExpressiveForwardIterator() {\r\n    String[] fields;\r\n\r\n    Set<Integer> ids = new HashSet<Integer>(TOT_RECORDS);\r\n    for (int i = 0; i < TOT_RECORDS; i++)\r\n      ids.add(i);\r\n\r\n    for (ORecordFlat rec : database.browseCluster(CLUSTER_NAME)) {\r\n      fields = rec.value().split(\"-\");\r\n\r\n      int i = Integer.parseInt(fields[0]);\r\n      Assert.assertTrue(ids.remove(i));\r\n    }\r\n\r\n    Assert.assertTrue(ids.isEmpty());\r\n  }","id":102787,"modified_method":"@Test(dependsOnMethods = \"testCreateRaw\")\r\n  public void readRawWithExpressiveForwardIterator() {\r\n    String[] fields;\r\n\r\n    Set<Integer> ids = new HashSet<Integer>(TOT_RECORDS);\r\n    for (int i = 0; i < TOT_RECORDS; i++)\r\n      ids.add(i);\r\n\r\n    for (ORecordFlat rec : new ORecordIteratorCluster<ORecordFlat>(database, (ODatabaseRecordAbstract) database.getUnderlying(),\r\n        database.getClusterIdByName(CLUSTER_NAME), true)) {\r\n      fields = rec.value().split(\"-\");\r\n\r\n      int i = Integer.parseInt(fields[0]);\r\n      Assert.assertTrue(ids.remove(i));\r\n    }\r\n\r\n    Assert.assertTrue(ids.isEmpty());\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test(dependsOnMethods = \"updateRaw\")\r\n  public void testUpdateRaw() {\r\n    String[] fields;\r\n\r\n    Set<Integer> ids = new HashSet<Integer>(TOT_RECORDS);\r\n    for (int i = 0; i < TOT_RECORDS; i++)\r\n      ids.add(i);\r\n\r\n    for (ORecordFlat rec : database.browseCluster(CLUSTER_NAME)) {\r\n      fields = rec.value().split(\"-\");\r\n\r\n      int i = Integer.parseInt(fields[0]);\r\n      Assert.assertTrue(ids.remove(i));\r\n\r\n      if (i % 2 == 0)\r\n        Assert.assertTrue(fields[1].endsWith(\"+\"));\r\n      else\r\n        Assert.assertFalse(fields[1].endsWith(\"+\"));\r\n    }\r\n\r\n    Assert.assertTrue(ids.isEmpty());\r\n  }","id":102788,"modified_method":"@Test(dependsOnMethods = \"updateRaw\")\r\n  public void testUpdateRaw() {\r\n    String[] fields;\r\n\r\n    Set<Integer> ids = new HashSet<Integer>(TOT_RECORDS);\r\n    for (int i = 0; i < TOT_RECORDS; i++)\r\n      ids.add(i);\r\n\r\n    for (ORecordFlat rec : new ORecordIteratorCluster<ORecordFlat>(database, (ODatabaseRecordAbstract) database.getUnderlying(),\r\n        database.getClusterIdByName(CLUSTER_NAME), true)) {\r\n      fields = rec.value().split(\"-\");\r\n\r\n      int i = Integer.parseInt(fields[0]);\r\n      Assert.assertTrue(ids.remove(i));\r\n\r\n      if (i % 2 == 0)\r\n        Assert.assertTrue(fields[1].endsWith(\"+\"));\r\n      else\r\n        Assert.assertFalse(fields[1].endsWith(\"+\"));\r\n    }\r\n\r\n    Assert.assertTrue(ids.isEmpty());\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test(dependsOnMethods = \"readRawWithExpressiveForwardIterator\")\r\n  public void updateRaw() {\r\n    String[] fields;\r\n\r\n    for (ORecordFlat rec : database.browseCluster(CLUSTER_NAME)) {\r\n      fields = rec.value().split(\"-\");\r\n      int i = Integer.parseInt(fields[0]);\r\n      if (i % 2 == 0) {\r\n        rec.value(rec.value() + \"+\");\r\n        rec.save();\r\n      }\r\n    }\r\n  }","id":102789,"modified_method":"@Test(dependsOnMethods = \"readRawWithExpressiveForwardIterator\")\r\n  public void updateRaw() {\r\n    String[] fields;\r\n\r\n    for (ORecordFlat rec : new ORecordIteratorCluster<ORecordFlat>(database, (ODatabaseRecordAbstract) database.getUnderlying(),\r\n        database.getClusterIdByName(CLUSTER_NAME), true)) {\r\n      fields = rec.value().split(\"-\");\r\n      int i = Integer.parseInt(fields[0]);\r\n      if (i % 2 == 0) {\r\n        rec.value(rec.value() + \"+\");\r\n        rec.save();\r\n      }\r\n    }\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public DictionaryLookupInverseSpeedTest() {\r\n\t\tsuper(100000);\r\n\t\tOrient.instance().getProfiler().startRecording();\r\n\t\tdatabase = new ODatabaseFlat(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n\t}","id":102790,"modified_method":"public DictionaryLookupInverseSpeedTest() {\r\n\t\tsuper(100000);\r\n\t\tOrient.instance().getProfiler().startRecording();\r\n\t\tdatabase = new ODatabaseDocumentTx(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n\t}","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public DictionaryLookupSpeedTest() {\r\n\t\tsuper(100000);\r\n\t\tOrient.instance().getProfiler().startRecording();\r\n\t\tdatabase = new ODatabaseFlat(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n\t}","id":102791,"modified_method":"public DictionaryLookupSpeedTest() {\r\n\t\tsuper(100000);\r\n\t\tOrient.instance().getProfiler().startRecording();\r\n\t\tdatabase = new ODatabaseDocumentTx(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n\t}","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public DictionaryPutSpeedTest() throws InstantiationException, IllegalAccessException {\r\n\t\tsuper(1000000);\r\n\r\n\t\tString url = System.getProperty(\"url\");\r\n\t\tdatabase = new ODatabaseFlat(url).open(\"admin\", \"admin\");\r\n\t\tdatabase.declareIntent(new OIntentMassiveInsert());\r\n\r\n\t\trecord = database.newInstance();\r\n\t\tstartNum = 0;// database.countClusterElements(\"Animal\");\r\n\r\n\t\t Orient.instance().getProfiler().startRecording();\r\n\r\n\t\tSystem.out.println(\"Total element in the dictionary: \" + startNum);\r\n\r\n\t\tdatabase.begin(TXTYPE.NOTX);\r\n\t}","id":102792,"modified_method":"public DictionaryPutSpeedTest() throws InstantiationException, IllegalAccessException {\r\n\t\tsuper(1000000);\r\n\r\n\t\tString url = System.getProperty(\"url\");\r\n\t\tdatabase = new ODatabaseDocumentTx(url).open(\"admin\", \"admin\");\r\n\t\tdatabase.declareIntent(new OIntentMassiveInsert());\r\n\r\n\t\trecord = new ORecordFlat();\r\n\t\tstartNum = 0;// database.countClusterElements(\"Animal\");\r\n\r\n\t\t Orient.instance().getProfiler().startRecording();\r\n\r\n\t\tSystem.out.println(\"Total element in the dictionary: \" + startNum);\r\n\r\n\t\tdatabase.begin(TXTYPE.NOTX);\r\n\t}","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test(dependsOnMethods = \"testDictionaryDelete\")\r\n  public void testDictionaryMassiveCreate() throws IOException {\r\n    ODatabaseFlat database = new ODatabaseFlat(url);\r\n    database.open(\"admin\", \"admin\");\r\n\r\n    final long originalSize = database.getDictionary().size();\r\n\r\n    // ASSURE TO STORE THE PAGE-SIZE + 3 FORCING THE CREATION OF LEFT AND RIGHT\r\n    final int total = 1000;\r\n\r\n    for (int i = total; i > 0; --i) {\r\n      database.getDictionary().put(\"key-\" + (originalSize + i), database.newInstance().value(\"test-dictionary-\" + i));\r\n    }\r\n\r\n    for (int i = total; i > 0; --i) {\r\n      ORecord record = database.getDictionary().get(\"key-\" + (originalSize + i));\r\n      record.toString().equals(\"test-dictionary-\" + i);\r\n    }\r\n\r\n    Assert.assertEquals(database.getDictionary().size(), originalSize + total);\r\n\r\n    database.close();\r\n  }","id":102793,"modified_method":"@Test(dependsOnMethods = \"testDictionaryDelete\")\r\n  public void testDictionaryMassiveCreate() throws IOException {\r\n    final long originalSize = database.getDictionary().size();\r\n\r\n    // ASSURE TO STORE THE PAGE-SIZE + 3 FORCING THE CREATION OF LEFT AND RIGHT\r\n    final int total = 1000;\r\n\r\n    for (int i = total; i > 0; --i) {\r\n      database.getDictionary().put(\"key-\" + (originalSize + i), new ORecordFlat().value(\"test-dictionary-\" + i));\r\n    }\r\n\r\n    for (int i = total; i > 0; --i) {\r\n      ORecord record = database.getDictionary().get(\"key-\" + (originalSize + i));\r\n      record.toString().equals(\"test-dictionary-\" + i);\r\n    }\r\n\r\n    Assert.assertEquals(database.getDictionary().size(), originalSize + total);\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test(dependsOnMethods = \"testDictionaryMassiveCreate\")\r\n  public void testDictionaryInTx() throws IOException {\r\n    ODatabaseFlat database = new ODatabaseFlat(url);\r\n    database.open(\"admin\", \"admin\");\r\n\r\n    database.begin();\r\n    database.getDictionary().put(\"tx-key\", database.newInstance().value(\"tx-test-dictionary\"));\r\n    database.commit();\r\n\r\n    Assert.assertNotNull(database.getDictionary().get(\"tx-key\"));\r\n\r\n    database.close();\r\n  }","id":102794,"modified_method":"@Test(dependsOnMethods = \"testDictionaryMassiveCreate\")\r\n  public void testDictionaryInTx() throws IOException {\r\n    database.begin();\r\n    database.getDictionary().put(\"tx-key\", new ORecordFlat().value(\"tx-test-dictionary\"));\r\n    database.commit();\r\n\r\n    Assert.assertNotNull(database.getDictionary().get(\"tx-key\"));\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test(dependsOnMethods = \"testDictionaryLookup\")\r\n  public void testDictionaryUpdate() throws IOException {\r\n    ODatabaseFlat database = new ODatabaseFlat(url);\r\n    database.open(\"admin\", \"admin\");\r\n\r\n    final long originalSize = database.getDictionary().size();\r\n\r\n    database.getDictionary().put(\"key1\", database.newInstance().value(\"Text changed\"));\r\n\r\n    database.close();\r\n    database.open(\"admin\", \"admin\");\r\n\r\n    Assert.assertEquals(((ORecordFlat) database.getDictionary().get(\"key1\")).value(), \"Text changed\");\r\n    Assert.assertEquals(database.getDictionary().size(), originalSize);\r\n\r\n    database.close();\r\n  }","id":102795,"modified_method":"@Test(dependsOnMethods = \"testDictionaryLookup\")\r\n  public void testDictionaryUpdate() throws IOException {\r\n    final long originalSize = database.getDictionary().size();\r\n\r\n    database.getDictionary().put(\"key1\", new ORecordFlat().value(\"Text changed\"));\r\n\r\n    database.close();\r\n    database.open(\"admin\", \"admin\");\r\n\r\n    Assert.assertEquals(((ORecordFlat) database.getDictionary().get(\"key1\")).value(), \"Text changed\");\r\n    Assert.assertEquals(database.getDictionary().size(), originalSize);\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testDictionaryCreate() throws IOException {\r\n    ODatabaseFlat database = new ODatabaseFlat(url);\r\n    database.open(\"admin\", \"admin\");\r\n    ORecordFlat record = database.newInstance();\r\n\r\n    database.getDictionary().put(\"key1\", record.value(\"Dictionary test!\"));\r\n\r\n    database.close();\r\n  }","id":102796,"modified_method":"public void testDictionaryCreate() throws IOException {\r\n    ORecordFlat record = new ORecordFlat();\r\n\r\n    database.getDictionary().put(\"key1\", record.value(\"Dictionary test!\"));\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test(dependsOnMethods = \"testDictionaryCreate\")\r\n  public void testDictionaryLookup() throws IOException {\r\n    ODatabaseFlat database = new ODatabaseFlat(url);\r\n    database.open(\"admin\", \"admin\");\r\n\r\n    Assert.assertNotNull(database.getDictionary().get(\"key1\"));\r\n    Assert.assertTrue(((ORecordFlat) database.getDictionary().get(\"key1\")).value().equals(\"Dictionary test!\"));\r\n\r\n    database.close();\r\n  }","id":102797,"modified_method":"@Test(dependsOnMethods = \"testDictionaryCreate\")\r\n  public void testDictionaryLookup() throws IOException {\r\n    Assert.assertNotNull(database.getDictionary().get(\"key1\"));\r\n    Assert.assertTrue(((ORecordFlat) database.getDictionary().get(\"key1\")).value().equals(\"Dictionary test!\"));\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test(dependsOnMethods = \"testDictionaryUpdate\")\r\n  public void testDictionaryDelete() throws IOException {\r\n    ODatabaseFlat database = new ODatabaseFlat(url);\r\n    database.open(\"admin\", \"admin\");\r\n\r\n    final long originalSize = database.getDictionary().size();\r\n    Assert.assertNotNull(database.getDictionary().remove(\"key1\"));\r\n\r\n    database.close();\r\n    database.open(\"admin\", \"admin\");\r\n\r\n    Assert.assertEquals(database.getDictionary().size(), originalSize - 1);\r\n\r\n    database.close();\r\n  }","id":102798,"modified_method":"@Test(dependsOnMethods = \"testDictionaryUpdate\")\r\n  public void testDictionaryDelete() throws IOException {\r\n    final long originalSize = database.getDictionary().size();\r\n    Assert.assertNotNull(database.getDictionary().remove(\"key1\"));\r\n\r\n    database.close();\r\n    database.open(\"admin\", \"admin\");\r\n\r\n    Assert.assertEquals(database.getDictionary().size(), originalSize - 1);\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  public void init() {\r\n    Orient.instance().getProfiler().startRecording();\r\n\r\n    database = new ODatabaseFlat(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n    record = new ORecordBytes();\r\n\r\n    database.declareIntent(new OIntentMassiveInsert());\r\n    database.begin(TXTYPE.NOTX);\r\n    Random rnd = new Random();\r\n    recordContent = new byte[RECORD_SIZE];\r\n    for (int i = 0; i < RECORD_SIZE; ++i)\r\n      recordContent[i] = (byte) rnd.nextInt(256);\r\n  }","id":102799,"modified_method":"@Override\r\n  public void init() {\r\n    Orient.instance().getProfiler().startRecording();\r\n\r\n    database = new ODatabaseDocumentTx(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n    record = new ORecordBytes();\r\n\r\n    database.declareIntent(new OIntentMassiveInsert());\r\n    database.begin(TXTYPE.NOTX);\r\n    Random rnd = new Random();\r\n    recordContent = new byte[RECORD_SIZE];\r\n    for (int i = 0; i < RECORD_SIZE; ++i)\r\n      recordContent[i] = (byte) rnd.nextInt(256);\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n    public void init() {\r\n      database = new ODatabaseFlat(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n      record = database.newInstance();\r\n      database.declareIntent(new OIntentMassiveInsert());\r\n      database.begin(TXTYPE.NOTX);\r\n    }","id":102800,"modified_method":"@Override\r\n    public void init() {\r\n      database = new ODatabaseDocumentTx(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n      record = new ORecordFlat();\r\n      database.declareIntent(new OIntentMassiveInsert());\r\n      database.begin(TXTYPE.NOTX);\r\n    }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  public void init() {\r\n    database = new ODatabaseFlat(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n    foundObjects = database.countClusterElements(\"flat\");\r\n\r\n    System.out.println(\"\\nTotal objects in Animal cluster before the test: \" + foundObjects);\r\n  }","id":102801,"modified_method":"@Override\r\n  public void init() {\r\n    database = new ODatabaseDocumentTx(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n    foundObjects = database.countClusterElements(\"flat\");\r\n\r\n    System.out.println(\"\\nTotal objects in Animal cluster before the test: \" + foundObjects);\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  public void init() {\r\n    Orient.instance().getProfiler().startRecording();\r\n\r\n    database = new ODatabaseFlat(System.getProperty(\"url\"));\r\n    if (database.exists())\r\n      database.open(\"admin\", \"admin\");\r\n    else\r\n      database.create();\r\n\r\n    record = database.newInstance();\r\n\r\n    database.declareIntent(new OIntentMassiveInsert());\r\n    database.begin(TXTYPE.NOTX);\r\n  }","id":102802,"modified_method":"@Override\r\n  public void init() {\r\n    Orient.instance().getProfiler().startRecording();\r\n\r\n    database = new ODatabaseDocumentTx(System.getProperty(\"url\"));\r\n    if (database.exists())\r\n      database.open(\"admin\", \"admin\");\r\n    else\r\n      database.create();\r\n\r\n    record = new ORecordFlat();\r\n\r\n    database.declareIntent(new OIntentMassiveInsert());\r\n    database.begin(TXTYPE.NOTX);\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public ORecordFlat(ODatabaseFlat iDatabase) {\r\n    this();\r\n    ODatabaseRecordThreadLocal.INSTANCE.set(iDatabase);\r\n  }","id":102803,"modified_method":"public ORecordFlat(ODatabaseDocumentTx iDatabase) {\r\n    this();\r\n    ODatabaseRecordThreadLocal.INSTANCE.set(iDatabase);\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\r\n  public void testTransactionAtomic() throws IOException {\r\n    ODatabaseFlat db1 = new ODatabaseFlat(url);\r\n    db1.open(\"admin\", \"admin\");\r\n\r\n    ODatabaseFlat db2 = new ODatabaseFlat(url);\r\n    db2.open(\"admin\", \"admin\");\r\n\r\n    ORecordFlat record1 = new ORecordFlat(db1);\r\n    record1.value(\"This is the first version\").save();\r\n\r\n    // RE-READ THE RECORD\r\n    record1.reload();\r\n    ORecordFlat record2 = db2.load(record1.getIdentity());\r\n\r\n    record2.value(\"This is the second version\").save();\r\n    record2.value(\"This is the third version\").save();\r\n\r\n    record1.reload(null, true);\r\n\r\n    Assert.assertEquals(record1.value(), \"This is the third version\");\r\n\r\n    db1.close();\r\n    db2.close();\r\n  }","id":102804,"modified_method":"@Test\r\n  public void testTransactionAtomic() throws IOException {\r\n    ODatabaseDocumentTx db1 = new ODatabaseDocumentTx(url);\r\n    db1.open(\"admin\", \"admin\");\r\n\r\n    ODatabaseDocumentTx db2 = new ODatabaseDocumentTx(url);\r\n    db2.open(\"admin\", \"admin\");\r\n\r\n    ORecordFlat record1 = new ORecordFlat();\r\n    record1.value(\"This is the first version\").save();\r\n\r\n    // RE-READ THE RECORD\r\n    record1.reload();\r\n    ORecordFlat record2 = db2.load(record1.getIdentity());\r\n\r\n    record2.value(\"This is the second version\").save();\r\n    record2.value(\"This is the third version\").save();\r\n\r\n    record1.reload(null, true);\r\n\r\n    Assert.assertEquals(record1.value(), \"This is the third version\");\r\n\r\n    db1.close();\r\n    db2.close();\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test(expectedExceptions = OTransactionException.class)\r\n  public void testTransactionPreListenerRollback() throws IOException {\r\n    ODatabaseFlat db = new ODatabaseFlat(url);\r\n    db.open(\"admin\", \"admin\");\r\n\r\n    ORecordFlat record1 = new ORecordFlat(db);\r\n    record1.value(\"This is the first version\").save();\r\n\r\n    db.registerListener(new ODatabaseListener() {\r\n\r\n      @Override\r\n      public void onAfterTxCommit(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public void onAfterTxRollback(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public void onBeforeTxBegin(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public void onBeforeTxCommit(ODatabase iDatabase) {\r\n        throw new RuntimeException(\"Rollback test\");\r\n      }\r\n\r\n      @Override\r\n      public void onBeforeTxRollback(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public void onClose(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public void onCreate(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public void onDelete(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public void onOpen(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public boolean onCorruptionRepairDatabase(ODatabase iDatabase, final String iReason, String iWhatWillbeFixed) {\r\n        return true;\r\n      }\r\n    });\r\n\r\n    db.begin();\r\n    db.commit();\r\n\r\n    db.close();\r\n  }","id":102805,"modified_method":"@Test(expectedExceptions = OTransactionException.class)\r\n  public void testTransactionPreListenerRollback() throws IOException {\r\n    ODatabaseDocumentTx db = new ODatabaseDocumentTx(url);\r\n    db.open(\"admin\", \"admin\");\r\n\r\n    ORecordFlat record1 = new ORecordFlat(db);\r\n    record1.value(\"This is the first version\").save();\r\n\r\n    db.registerListener(new ODatabaseListener() {\r\n\r\n      @Override\r\n      public void onAfterTxCommit(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public void onAfterTxRollback(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public void onBeforeTxBegin(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public void onBeforeTxCommit(ODatabase iDatabase) {\r\n        throw new RuntimeException(\"Rollback test\");\r\n      }\r\n\r\n      @Override\r\n      public void onBeforeTxRollback(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public void onClose(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public void onCreate(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public void onDelete(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public void onOpen(ODatabase iDatabase) {\r\n      }\r\n\r\n      @Override\r\n      public boolean onCorruptionRepairDatabase(ODatabase iDatabase, final String iReason, String iWhatWillbeFixed) {\r\n        return true;\r\n      }\r\n    });\r\n\r\n    db.begin();\r\n    db.commit();\r\n\r\n    db.close();\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  public void init() {\r\n    Orient.instance().getProfiler().startRecording();\r\n\r\n    database = new ODatabaseFlat(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n    record = database.newInstance();\r\n\r\n    database.begin();\r\n  }","id":102806,"modified_method":"@Override\r\n  public void init() {\r\n    Orient.instance().getProfiler().startRecording();\r\n\r\n    database = new ODatabaseDocumentTx(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n    record = new ORecordFlat();\r\n\r\n    database.begin();\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n    public void init() {\r\n      database = new ODatabaseFlat(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n      record = database.newInstance();\r\n\r\n      database.begin(TXTYPE.NOTX);\r\n    }","id":102807,"modified_method":"@Override\r\n    public void init() {\r\n      database = new ODatabaseDocumentTx(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n      record = new ORecordFlat();\r\n\r\n      database.begin(TXTYPE.NOTX);\r\n    }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  public void init() {\r\n    database = new ODatabaseFlat(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n\r\n    if (!database.getStorage().getClusterNames().contains(\"Animal\"))\r\n      database.addCluster(\"Animal\");\r\n\r\n    foundObjects = database.countClusterElements(\"Animal\");\r\n    System.out.println(\"\\nTotal objects in Animal cluster before the test: \" + foundObjects);\r\n  }","id":102808,"modified_method":"@Override\r\n  public void init() {\r\n    database = new ODatabaseDocumentTx(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n\r\n    if (!database.getStorage().getClusterNames().contains(\"Animal\"))\r\n      database.addCluster(\"Animal\");\r\n\r\n    foundObjects = database.countClusterElements(\"Animal\");\r\n    System.out.println(\"\\nTotal objects in Animal cluster before the test: \" + foundObjects);\r\n  }","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public TxTest() throws InstantiationException, IllegalAccessException {\r\n\t\tsuper(10);\r\n\t\tdatabase = new ODatabaseFlat(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n\t\trecord = database.newInstance();\r\n\r\n\t\tdatabase.begin(TXTYPE.OPTIMISTIC);\r\n\t}","id":102809,"modified_method":"public TxTest() throws InstantiationException, IllegalAccessException {\r\n\t\tsuper(10);\r\n\t\tdatabase = new ODatabaseDocumentTx(System.getProperty(\"url\")).open(\"admin\", \"admin\");\r\n\t\trecord = new ORecordFlat();\r\n\r\n\t\tdatabase.begin(TXTYPE.OPTIMISTIC);\r\n\t}","commit_id":"e54358472c94d63c66ad607be256f94378e8ff16","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        int matchType = MATCH_TYPE_EXACT;\n        \n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.available();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n        \n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n        \n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retries\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n        \n        String diskName = ParameterMap.getKeyedString(parameters, \"disk\", null);\n        Integer percentFree = ParameterMap.getKeyedInteger(parameters, \"free\", 15);\n        \n        String matchTypeStr = ParameterMap.getKeyedString(parameters, \"match-type\", \"exact\");\n        if (matchTypeStr.equalsIgnoreCase(\"exact\")) {\n            matchType = MATCH_TYPE_EXACT; \n        } else if (matchTypeStr.equalsIgnoreCase(\"startswith\")) {\n            matchType = MATCH_TYPE_STARTSWITH;\n        } else if (matchTypeStr.equalsIgnoreCase(\"endswith\")) {\n            matchType = MATCH_TYPE_ENDSWITH;\n        } else if (matchTypeStr.equalsIgnoreCase(\"regex\")) {\n            matchType = MATCH_TYPE_REGEX;\n        } else {\n            throw new RuntimeException(\"Unknown value '\" + matchTypeStr + \"' for parameter 'match-type'\");\n        }\n        \n        log().debug(\"diskName=\" + diskName);\n        log().debug(\"percentfree=\" + percentFree);\n        log().debug(\"matchType=\" + matchTypeStr);\n        \n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        \n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"DiskUsageMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId hrStorageDescrSnmpObject = SnmpObjId.get(hrStorageDescr);\n            \n            \n            \n            Map<SnmpInstId, SnmpValue> flagResults = SnmpUtils.getOidValues(agentConfig, \"DiskUsagePoller\", hrStorageDescrSnmpObject);\n            \n            if(flagResults.size() == 0) {\n                log().debug(\"SNMP poll failed: no results, addr=\" + ipaddr.getHostAddress() + \" oid=\" + hrStorageDescrSnmpObject);\n                return PollStatus.unavailable();\n            }\n\n            for (Map.Entry<SnmpInstId, SnmpValue> e : flagResults.entrySet()) { \n                log().debug(\"poll: SNMPwalk poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + hrStorageDescrSnmpObject + \" instance=\" + e.getKey() + \" value=\" + e.getValue());\n                \n                if (isMatch(e.getValue().toString(), diskName, matchType)) {\n                \tlog().debug(\"DiskUsageMonitor.poll: found disk=\" + diskName);\n                \t\n                \tSnmpObjId hrStorageSizeSnmpObject = SnmpObjId.get(hrStorageSize + \".\" + e.getKey().toString());\n                \tSnmpObjId hrStorageUsedSnmpObject = SnmpObjId.get(hrStorageUsed + \".\" + e.getKey().toString());\n                \t\n                \t\n                \tSnmpValue snmpSize = SnmpUtils.get(agentConfig, hrStorageSizeSnmpObject);\n                \tSnmpValue snmpUsed = SnmpUtils.get(agentConfig, hrStorageUsedSnmpObject);\n                \tfloat calculatedPercentage = ( (( (float)snmpSize.toLong() - (float)snmpUsed.toLong() ) / (float)snmpSize.toLong() ) ) * 100;\n                \n                \tlog().debug(\"DiskUsageMonitor: calculatedPercentage=\" + calculatedPercentage + \" percentFree=\"+percentFree);\n                \t\n                \tif (calculatedPercentage < percentFree) {\n                \t\n                \t\treturn PollStatus.unavailable(diskName + \" usage high (\" + (100 - (int)calculatedPercentage)  + \"%)\");\n                \t\t\n                \t}\n                \telse {\n                \t\treturn status;\n                \t}\n                }\n            \n                 \n            }\n\n            // if we get here.. it means we did not find the disk...  which means we should not be monitoring it.\n            log().debug(\"DiskUsageMonitor: no disks found\");\n            return PollStatus.unavailable(\"could not find \" + diskName + \"in table\");\n            \n            \n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","id":102810,"modified_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        int matchType = MATCH_TYPE_EXACT;\n        \n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.available();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n        \n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n        \n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n        \n        String diskName = ParameterMap.getKeyedString(parameters, \"disk\", null);\n        Integer percentFree = ParameterMap.getKeyedInteger(parameters, \"free\", 15);\n        \n        String matchTypeStr = ParameterMap.getKeyedString(parameters, \"match-type\", \"exact\");\n        if (matchTypeStr.equalsIgnoreCase(\"exact\")) {\n            matchType = MATCH_TYPE_EXACT; \n        } else if (matchTypeStr.equalsIgnoreCase(\"startswith\")) {\n            matchType = MATCH_TYPE_STARTSWITH;\n        } else if (matchTypeStr.equalsIgnoreCase(\"endswith\")) {\n            matchType = MATCH_TYPE_ENDSWITH;\n        } else if (matchTypeStr.equalsIgnoreCase(\"regex\")) {\n            matchType = MATCH_TYPE_REGEX;\n        } else {\n            throw new RuntimeException(\"Unknown value '\" + matchTypeStr + \"' for parameter 'match-type'\");\n        }\n        \n        log().debug(\"diskName=\" + diskName);\n        log().debug(\"percentfree=\" + percentFree);\n        log().debug(\"matchType=\" + matchTypeStr);\n        \n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        \n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"DiskUsageMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId hrStorageDescrSnmpObject = SnmpObjId.get(hrStorageDescr);\n            \n            \n            \n            Map<SnmpInstId, SnmpValue> flagResults = SnmpUtils.getOidValues(agentConfig, \"DiskUsagePoller\", hrStorageDescrSnmpObject);\n            \n            if(flagResults.size() == 0) {\n                log().debug(\"SNMP poll failed: no results, addr=\" + ipaddr.getHostAddress() + \" oid=\" + hrStorageDescrSnmpObject);\n                return PollStatus.unavailable();\n            }\n\n            for (Map.Entry<SnmpInstId, SnmpValue> e : flagResults.entrySet()) { \n                log().debug(\"poll: SNMPwalk poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + hrStorageDescrSnmpObject + \" instance=\" + e.getKey() + \" value=\" + e.getValue());\n                \n                if (isMatch(e.getValue().toString(), diskName, matchType)) {\n                \tlog().debug(\"DiskUsageMonitor.poll: found disk=\" + diskName);\n                \t\n                \tSnmpObjId hrStorageSizeSnmpObject = SnmpObjId.get(hrStorageSize + \".\" + e.getKey().toString());\n                \tSnmpObjId hrStorageUsedSnmpObject = SnmpObjId.get(hrStorageUsed + \".\" + e.getKey().toString());\n                \t\n                \t\n                \tSnmpValue snmpSize = SnmpUtils.get(agentConfig, hrStorageSizeSnmpObject);\n                \tSnmpValue snmpUsed = SnmpUtils.get(agentConfig, hrStorageUsedSnmpObject);\n                \tfloat calculatedPercentage = ( (( (float)snmpSize.toLong() - (float)snmpUsed.toLong() ) / (float)snmpSize.toLong() ) ) * 100;\n                \n                \tlog().debug(\"DiskUsageMonitor: calculatedPercentage=\" + calculatedPercentage + \" percentFree=\"+percentFree);\n                \t\n                \tif (calculatedPercentage < percentFree) {\n                \t\n                \t\treturn PollStatus.unavailable(diskName + \" usage high (\" + (100 - (int)calculatedPercentage)  + \"%)\");\n                \t\t\n                \t}\n                \telse {\n                \t\treturn status;\n                \t}\n                }\n            \n                 \n            }\n\n            // if we get here.. it means we did not find the disk...  which means we should not be monitoring it.\n            log().debug(\"DiskUsageMonitor: no disks found\");\n            return PollStatus.unavailable(\"could not find \" + diskName + \"in table\");\n            \n            \n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","commit_id":"20e750190f0fc4aa73a270e3b55e34bb908e61db","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * <\/p>\n     * \n     * <p>\n     * In addition, the input qualifiers map also provides information about how\n     * the plugin should contact the remote server. The plugin may check the\n     * qualifier map for specific elements and then adjust its behavior as\n     * necessary\n     * <\/p>\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map<String, Object> qualifiers) {\n        int port = DEFAULT_PORT;\n        int timeout = DEFAULT_TIMEOUT;\n        int retries = DEFAULT_RETRY;\n        String lookup = DEFAULT_LOOKUP;\n        if (qualifiers != null) {\n            port = ParameterMap.getKeyedInteger(qualifiers, \"port\", DEFAULT_PORT);\n            timeout = ParameterMap.getKeyedInteger(qualifiers, \"timeout\", DEFAULT_TIMEOUT);\n            retries = ParameterMap.getKeyedInteger(qualifiers, \"retries\", DEFAULT_RETRY);\n            lookup = ParameterMap.getKeyedString(qualifiers, \"lookup\", DEFAULT_LOOKUP);\n        }\n\n        boolean result = isServer(address, port, retries, timeout, lookup);\n        if (result && qualifiers != null && !qualifiers.containsKey(\"port\"))\n            qualifiers.put(\"port\", new Integer(port));\n\n        return result;\n    }","id":102811,"modified_method":"/**\n     * <p>\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * <\/p>\n     * \n     * <p>\n     * In addition, the input qualifiers map also provides information about how\n     * the plugin should contact the remote server. The plugin may check the\n     * qualifier map for specific elements and then adjust its behavior as\n     * necessary\n     * <\/p>\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map<String, Object> qualifiers) {\n        int port = DEFAULT_PORT;\n        int timeout = DEFAULT_TIMEOUT;\n        int retries = DEFAULT_RETRY;\n        String lookup = DEFAULT_LOOKUP;\n        if (qualifiers != null) {\n            port = ParameterMap.getKeyedInteger(qualifiers, \"port\", DEFAULT_PORT);\n            timeout = ParameterMap.getKeyedInteger(qualifiers, \"timeout\", DEFAULT_TIMEOUT);\n            retries = ParameterMap.getKeyedInteger(qualifiers, \"retry\", DEFAULT_RETRY);\n            lookup = ParameterMap.getKeyedString(qualifiers, \"lookup\", DEFAULT_LOOKUP);\n        }\n\n        boolean result = isServer(address, port, retries, timeout, lookup);\n        if (result && qualifiers != null && !qualifiers.containsKey(\"port\"))\n            qualifiers.put(\"port\", new Integer(port));\n\n        return result;\n    }","commit_id":"20e750190f0fc4aa73a270e3b55e34bb908e61db","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Poll the specified address for FTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port (by\n     * default TCP port 21). If the connection request is successful, the banner\n     * line generated by the interface is parsed and if the extracted return\n     * code indicates that we are talking to an FTP server we continue. Next, an\n     * FTP 'QUIT' command is sent. Provided that the interface's response is\n     * valid we set the service status to SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Check the interface type\n        if (iface.getType() != NetworkInterface.TYPE_IPV4) {\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n        }\n\n        // Get the parameters\n        TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n        int port = ParameterMap.getKeyedInteger(parameters, \"port\", DEFAULT_PORT);\n        String userid = ParameterMap.getKeyedString(parameters, \"userid\", null);\n        String password = ParameterMap.getKeyedString(parameters, \"password\", null);\n\n        // Extract the address\n        InetAddress ipv4Addr = (InetAddress) iface.getAddress();\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"FtpMonitor.poll: Polling interface: \" + ipv4Addr.getHostAddress() + tracker);\n        }\n\n        PollStatus serviceStatus = PollStatus.unavailable();\n        for (tracker.reset(); tracker.shouldRetry() && !serviceStatus.isAvailable(); tracker.nextAttempt()) {\n            Socket socket = null;\n            try {\n                // create a connected socket\n                tracker.startAttempt();\n\n                socket = new Socket();\n                socket.connect(new InetSocketAddress(ipv4Addr, port), tracker.getConnectionTimeout());\n                socket.setSoTimeout(tracker.getSoTimeout());\n                log().debug(\"FtpMonitor: connected to host: \" + ipv4Addr + \" on port: \" + port);\n\n                // We're connected, so upgrade status to unresponsive\n                serviceStatus = PollStatus.unresponsive();\n\n                BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                \n                FtpResponse bannerResponse = FtpResponse.readResponse(lineRdr);\n\n                if (bannerResponse.isSuccess()) {\n                    // Attempt to login if userid and password available\n                    boolean loggedInSuccessfully = false;\n                    if (userid == null || userid.length() == 0 || password == null || password.length() == 0) {\n                        loggedInSuccessfully = true;\n                    } else {\n                        FtpResponse.sendCommand(socket, \"USER \" + userid);\n\n                        FtpResponse userResponse = FtpResponse.readResponse(lineRdr);\n\n                        if (userResponse.isSuccess()) {\n                            FtpResponse.sendCommand(socket, \"PASS \" + password);\n                            \n                            FtpResponse passResponse = FtpResponse.readResponse(lineRdr);\n                            if (passResponse.isSuccess()) {\n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"FtpMonitor.poll: Login successful, parsed return code: \" + passResponse.getCode());\n                                }\n                                loggedInSuccessfully = true;\n                            } else {\n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"FtpMonitor.poll: Login failed, parsed return code: \" + passResponse.getCode() + \", full response: \" + passResponse.toString());\n                                }\n                                loggedInSuccessfully = false;\n                            }\n                        }\n                    }\n\n                    // Store the response time before we try to quit\n                    double responseTime = tracker.elapsedTimeInMillis();\n\n                    if (loggedInSuccessfully) {\n                        FtpResponse.sendCommand(socket, \"QUIT\");\n\n                        FtpResponse quitResponse = FtpResponse.readResponse(lineRdr);\n\n                        /*\n                         * Special Cases for success:\n                         * \n                         * Also want to accept the following\n                         * ERROR message generated by some FTP servers\n                         * following a QUIT command without a previous\n                         * successful login:\n                         *\n                         * \"530 QUIT : User not logged in. Please login with\n                         * USER and PASS first.\"\n                         * \n                         * Also want to accept the following ERROR\n                         * message generated by some FTP servers following a\n                         * QUIT command without a previously successful login:\n                         *\n                         * \"425 Session is disconnected.\"\n                         */\n                        if (quitResponse.isSuccess()\n                                || (quitResponse.getCode() == 530 && (quitResponse.responseContains(FTP_ERROR_530_TEXT) || quitResponse.responseContains(FTP_ERROR_530_TEXT2)))\n                                || (quitResponse.getCode() == 425 && quitResponse.responseContains(FTP_ERROR_425_TEXT))) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                    }\n                }\n\n                /*\n                 * If we get this far and the status has not been set\n                 * to available, then something didn't verify during\n                 * the banner checking or login/QUIT command process.\n                 */\n                if (!serviceStatus.isAvailable()) {\n                    serviceStatus = PollStatus.unavailable();\n                }\n            } catch (NumberFormatException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"NumberFormatException while polling address: \" + ipv4Addr, e);\n            } catch (NoRouteToHostException e) {\n            \tserviceStatus = logDown(Level.WARN, \"No route to host exception for address: \" + ipv4Addr, e);\n            } catch (InterruptedIOException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"did not connect to host with \" + tracker);\n            } catch (ConnectException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"Connection exception for address: \" + ipv4Addr, e);\n            } catch (IOException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"IOException while polling address: \" + ipv4Addr, e);\n            } finally {\n                try {\n                    // Close the socket\n                    if (socket != null) {\n                        socket.close();\n                    }\n                } catch (IOException e) {\n                    log().debug(\"FtpMonitor.poll: Error closing socket: \" + e, e);\n                }\n            }\n        }\n\n        return serviceStatus;\n    }","id":102812,"modified_method":"/**\n     * Poll the specified address for FTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port (by\n     * default TCP port 21). If the connection request is successful, the banner\n     * line generated by the interface is parsed and if the extracted return\n     * code indicates that we are talking to an FTP server we continue. Next, an\n     * FTP 'QUIT' command is sent. Provided that the interface's response is\n     * valid we set the service status to SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Check the interface type\n        if (iface.getType() != NetworkInterface.TYPE_IPV4) {\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n        }\n\n        // Get the parameters\n        TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n        int port = ParameterMap.getKeyedInteger(parameters, \"port\", DEFAULT_PORT);\n        String userid = ParameterMap.getKeyedString(parameters, \"userid\", null);\n        String password = ParameterMap.getKeyedString(parameters, \"password\", null);\n\n        // Extract the address\n        InetAddress ipv4Addr = (InetAddress) iface.getAddress();\n\n        PollStatus serviceStatus = PollStatus.unavailable();\n        for (tracker.reset(); tracker.shouldRetry() && !serviceStatus.isAvailable(); tracker.nextAttempt()) {\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"FtpMonitor.poll: Polling interface: \" + ipv4Addr.getHostAddress() + tracker);\n            }\n\n            Socket socket = null;\n            try {\n                // create a connected socket\n                tracker.startAttempt();\n\n                socket = new Socket();\n                socket.connect(new InetSocketAddress(ipv4Addr, port), tracker.getConnectionTimeout());\n                socket.setSoTimeout(tracker.getSoTimeout());\n                log().debug(\"FtpMonitor: connected to host: \" + ipv4Addr + \" on port: \" + port);\n\n                // We're connected, so upgrade status to unresponsive\n                serviceStatus = PollStatus.unresponsive();\n\n                BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                \n                FtpResponse bannerResponse = FtpResponse.readResponse(lineRdr);\n\n                if (bannerResponse.isSuccess()) {\n                    // Attempt to login if userid and password available\n                    boolean loggedInSuccessfully = false;\n                    log().debug(\"FtpMonitor: Banner response successful.\");\n                    if (userid == null || userid.length() == 0 || password == null || password.length() == 0) {\n                        loggedInSuccessfully = true;\n                    } else {\n                        FtpResponse.sendCommand(socket, \"USER \" + userid);\n\n                        FtpResponse userResponse = FtpResponse.readResponse(lineRdr);\n\n                        if (userResponse.isSuccess() || userResponse.isIntermediate()) {\n                            log().debug(\"FtpMonitor: User response successful.\");\n                            FtpResponse.sendCommand(socket, \"PASS \" + password);\n                            \n                            FtpResponse passResponse = FtpResponse.readResponse(lineRdr);\n                            if (passResponse.isSuccess()) {\n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"FtpMonitor.poll: Login successful, parsed return code: \" + passResponse.getCode());\n                                }\n                                loggedInSuccessfully = true;\n                            } else {\n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"FtpMonitor.poll: Login failed, parsed return code: \" + passResponse.getCode() + \", full response: \" + passResponse.toString());\n                                }\n                                loggedInSuccessfully = false;\n                            }\n                        }\n                    }\n\n                    // Store the response time before we try to quit\n                    double responseTime = tracker.elapsedTimeInMillis();\n\n                    if (loggedInSuccessfully) {\n                        FtpResponse.sendCommand(socket, \"QUIT\");\n\n                        FtpResponse quitResponse = FtpResponse.readResponse(lineRdr);\n\n                        /*\n                         * Special Cases for success:\n                         * \n                         * Also want to accept the following\n                         * ERROR message generated by some FTP servers\n                         * following a QUIT command without a previous\n                         * successful login:\n                         *\n                         * \"530 QUIT : User not logged in. Please login with\n                         * USER and PASS first.\"\n                         * \n                         * Also want to accept the following ERROR\n                         * message generated by some FTP servers following a\n                         * QUIT command without a previously successful login:\n                         *\n                         * \"425 Session is disconnected.\"\n                         */\n                        if (quitResponse.isSuccess()\n                                || (quitResponse.getCode() == 530 && (quitResponse.responseContains(FTP_ERROR_530_TEXT) || quitResponse.responseContains(FTP_ERROR_530_TEXT2)))\n                                || (quitResponse.getCode() == 425 && quitResponse.responseContains(FTP_ERROR_425_TEXT))) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                    }\n                }\n\n                /*\n                 * If we get this far and the status has not been set\n                 * to available, then something didn't verify during\n                 * the banner checking or login/QUIT command process.\n                 */\n                if (!serviceStatus.isAvailable()) {\n                    serviceStatus = PollStatus.unavailable();\n                }\n            } catch (NumberFormatException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"NumberFormatException while polling address: \" + ipv4Addr, e);\n            } catch (NoRouteToHostException e) {\n            \tserviceStatus = logDown(Level.WARN, \"No route to host exception for address: \" + ipv4Addr, e);\n            } catch (InterruptedIOException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"did not connect to host with \" + tracker);\n            } catch (ConnectException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"Connection exception for address: \" + ipv4Addr, e);\n            } catch (IOException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"IOException while polling address: \" + ipv4Addr, e);\n            } finally {\n                try {\n                    // Close the socket\n                    if (socket != null) {\n                        socket.close();\n                    }\n                } catch (IOException e) {\n                    log().debug(\"FtpMonitor.poll: Error closing socket: \" + e, e);\n                }\n            }\n        }\n\n        return serviceStatus;\n    }","commit_id":"20e750190f0fc4aa73a270e3b55e34bb908e61db","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * <\/p>\n     * \n     * <p>\n     * In addition, the input qualifiers map also provides information about how\n     * the plugin should contact the remote server. The plugin may check the\n     * qualifier map for specific elements and then adjust its behavior as\n     * necessary\n     * <\/p>\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map<String, Object> qualifiers) {\n        int port = DEFAULT_PORT;\n        int timeout = DEFAULT_TIMEOUT;\n        int retries = DEFAULT_RETRY;\n        if (qualifiers != null) {\n            port = ParameterMap.getKeyedInteger(qualifiers, \"port\", DEFAULT_PORT);\n            timeout = ParameterMap.getKeyedInteger(qualifiers, \"timeout\", DEFAULT_TIMEOUT);\n            retries = ParameterMap.getKeyedInteger(qualifiers, \"retries\", DEFAULT_RETRY);\n        }\n\n        boolean result = isServer(address, port, retries, timeout);\n        if (result && qualifiers != null && !qualifiers.containsKey(\"port\"))\n            qualifiers.put(\"port\", new Integer(port));\n\n        return result;\n    }","id":102813,"modified_method":"/**\n     * <p>\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * <\/p>\n     * \n     * <p>\n     * In addition, the input qualifiers map also provides information about how\n     * the plugin should contact the remote server. The plugin may check the\n     * qualifier map for specific elements and then adjust its behavior as\n     * necessary\n     * <\/p>\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map<String, Object> qualifiers) {\n        int port = DEFAULT_PORT;\n        int timeout = DEFAULT_TIMEOUT;\n        int retries = DEFAULT_RETRY;\n        if (qualifiers != null) {\n            port = ParameterMap.getKeyedInteger(qualifiers, \"port\", DEFAULT_PORT);\n            timeout = ParameterMap.getKeyedInteger(qualifiers, \"timeout\", DEFAULT_TIMEOUT);\n            retries = ParameterMap.getKeyedInteger(qualifiers, \"retry\", DEFAULT_RETRY);\n        }\n\n        boolean result = isServer(address, port, retries, timeout);\n        if (result && qualifiers != null && !qualifiers.containsKey(\"port\"))\n            qualifiers.put(\"port\", new Integer(port));\n\n        return result;\n    }","commit_id":"20e750190f0fc4aa73a270e3b55e34bb908e61db","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private SnmpAgentConfig configureAgent(Map parameters, NetworkInterface iface, InetAddress ipaddr) throws RuntimeException {\n\t\tSnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(snmpAgentConfigKey);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retries\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n\t\treturn agentConfig;\n\t}","id":102814,"modified_method":"private SnmpAgentConfig configureAgent(Map parameters, NetworkInterface iface, InetAddress ipaddr) throws RuntimeException {\n\t\tSnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(snmpAgentConfigKey);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n\t\treturn agentConfig;\n\t}","commit_id":"20e750190f0fc4aa73a270e3b55e34bb908e61db","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.unavailable();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n\n        // Retrieve this interface's SNMP peer object\n        //\n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n\n        // Get configuration parameters\n        //\n        // set timeout and retries on SNMP peer object\n        //\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retries\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n        \n        String arrayNumber = ParameterMap.getKeyedString(parameters,\"array\",\"0.0\");\n\n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        // Establish SNMP session with interface\n        //\n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"PercMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId snmpObjectId = SnmpObjId.get(LOGICAL_BASE_OID + \".\" + arrayNumber);\n\n            // First walk the physical OID Tree and check the returned values \n\n            String returnValue = new String(); \n          \n            SnmpValue value = SnmpUtils.get(agentConfig,snmpObjectId);\n            \n            if (value.toInt()!=2){\n            \tlog().debug(\"PercMonitor.poll: Bad Disk Found\");\n            \treturnValue = \"log vol(\" + arrayNumber + \") degraded\"; // XXX should degraded be the virtualDiskState ?\n            \t// array is bad\n            \t// lets find out which disks are bad in the array\n            \t\n            \t// first we need to fetch the arrayPosition table.\n            \tSnmpObjId arrayPositionSnmpObject = SnmpObjId.get(ARRAY_POSITION_BASE_OID);\n            \tSnmpObjId diskStatesSnmpObject = SnmpObjId.get(PHYSICAL_BASE_OID); \n            \t\n            \tMap<SnmpInstId,SnmpValue> arrayDisks = SnmpUtils.getOidValues(agentConfig, \"PercMonitor\", arrayPositionSnmpObject);\n            \tMap<SnmpInstId,SnmpValue> diskStates = SnmpUtils.getOidValues(agentConfig, \"PercMonitor\", diskStatesSnmpObject);\n            \t\n            \tfor (Map.Entry<SnmpInstId, SnmpValue> disk: arrayDisks.entrySet()) {\n            \t\t\n            \t\tif (disk.getValue().toString().contains(\"A\" + arrayNumber.toString() + \"-\")) {\n            \t\t\t// this is a member of the array\n            \t\t\t\n            \t\t\tif ( diskStates.get(disk.getKey()).toInt() !=3 ){\n            \t\t\t\t// this is bad disk.\n            \t\t\t\t\n            \t\t\t\treturnValue  += \"phy drv(\" + disk.getKey().toString() + \")\";\n            \t\t\t\t\n            \t\t\t}\n            \t\t\t\n            \t\t}\n            \n            \t\treturn PollStatus.unavailable(returnValue);\n            \t}\n            \t\n            \t\n            }\n        \n            status = PollStatus.available();\n            \n\n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","id":102815,"modified_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.unavailable();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n\n        // Retrieve this interface's SNMP peer object\n        //\n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n\n        // Get configuration parameters\n        //\n        // set timeout and retries on SNMP peer object\n        //\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n        \n        String arrayNumber = ParameterMap.getKeyedString(parameters,\"array\",\"0.0\");\n\n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        // Establish SNMP session with interface\n        //\n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"PercMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId snmpObjectId = SnmpObjId.get(LOGICAL_BASE_OID + \".\" + arrayNumber);\n\n            // First walk the physical OID Tree and check the returned values \n\n            String returnValue = new String(); \n          \n            SnmpValue value = SnmpUtils.get(agentConfig,snmpObjectId);\n            \n            if (value.toInt()!=2){\n            \tlog().debug(\"PercMonitor.poll: Bad Disk Found\");\n            \treturnValue = \"log vol(\" + arrayNumber + \") degraded\"; // XXX should degraded be the virtualDiskState ?\n            \t// array is bad\n            \t// lets find out which disks are bad in the array\n            \t\n            \t// first we need to fetch the arrayPosition table.\n            \tSnmpObjId arrayPositionSnmpObject = SnmpObjId.get(ARRAY_POSITION_BASE_OID);\n            \tSnmpObjId diskStatesSnmpObject = SnmpObjId.get(PHYSICAL_BASE_OID); \n            \t\n            \tMap<SnmpInstId,SnmpValue> arrayDisks = SnmpUtils.getOidValues(agentConfig, \"PercMonitor\", arrayPositionSnmpObject);\n            \tMap<SnmpInstId,SnmpValue> diskStates = SnmpUtils.getOidValues(agentConfig, \"PercMonitor\", diskStatesSnmpObject);\n            \t\n            \tfor (Map.Entry<SnmpInstId, SnmpValue> disk: arrayDisks.entrySet()) {\n            \t\t\n            \t\tif (disk.getValue().toString().contains(\"A\" + arrayNumber.toString() + \"-\")) {\n            \t\t\t// this is a member of the array\n            \t\t\t\n            \t\t\tif ( diskStates.get(disk.getKey()).toInt() !=3 ){\n            \t\t\t\t// this is bad disk.\n            \t\t\t\t\n            \t\t\t\treturnValue  += \"phy drv(\" + disk.getKey().toString() + \")\";\n            \t\t\t\t\n            \t\t\t}\n            \t\t\t\n            \t\t}\n            \n            \t\treturn PollStatus.unavailable(returnValue);\n            \t}\n            \t\n            \t\n            }\n        \n            status = PollStatus.available();\n            \n\n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","commit_id":"20e750190f0fc4aa73a270e3b55e34bb908e61db","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void schedulePolls() throws Exception {\n        \n        log().debug(\"Enter schedulePolls\");\n\t\t\n\t\tCollection<PolledService> polledServices = m_pollerFrontEnd.getPolledServices();\n\n\t\tif (polledServices == null || polledServices.size() == 0) {\n\t\t\tlog().warn(\"No polling scheduled.\");\n            log().debug(\"Exit schedulePolls\");\n\t\t\treturn;\n\t\t}\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tlong scheduleSpacing = m_initialSpreadTime / polledServices.size();\n\n        for (PolledService polledService : polledServices) {\n\t\t\t\n\t\t\tDate initialPollTime = new Date(startTime);\n\t\t\t\n\t\t\tm_pollerFrontEnd.setInitialPollTime(polledService.getServiceId(), initialPollTime);\n\t\t\t\n\t\t\tTrigger pollTrigger = new PolledServiceTrigger(polledService);\n\t\t\tpollTrigger.setStartTime(initialPollTime);\n\t\t\t\n\t\t\tPollJobDetail jobDetail = new PollJobDetail(polledService.toString(), PollJob.class);\n\t\t\tjobDetail.setPolledService(polledService);\n\t\t\tjobDetail.setPollerFrontEnd(m_pollerFrontEnd);\n\t\t\t\n            log().debug(\"Scheduling job for \"+polledService);\n            \n\t\t\tm_scheduler.scheduleJob(jobDetail, pollTrigger);\n\t\t\t\n\t\t\tstartTime += scheduleSpacing;\n\t\t}\n\t\t\n        log().debug(\"Exit schedulePolls\");\n\t\t\n\t}","id":102816,"modified_method":"private void schedulePolls() throws Exception {\n        \n        log().debug(\"Enter schedulePolls\");\n\t\t\n\t\tCollection<PolledService> polledServices = m_pollerFrontEnd.getPolledServices();\n\n\t\tif (polledServices == null || polledServices.size() == 0) {\n\t\t\tlog().warn(\"No polling scheduled.\");\n            log().debug(\"Exit schedulePolls\");\n\t\t\treturn;\n\t\t}\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tlong scheduleSpacing = m_initialSpreadTime / polledServices.size();\n\t\t\n        for (PolledService polledService : polledServices) {\n            \n            String jobName = polledService.toString();\n\n            // remove any currently scheduled job\n            if (m_scheduler.deleteJob(jobName, PollJobDetail.GROUP)) {\n                log().debug(String.format(\"Job for %s already scheduled.  Rescheduling\", polledService));\n            } else {\n                log().debug(\"Scheduling job for \"+polledService);\n            }\n\t\t\t\n\t\t\tDate initialPollTime = new Date(startTime);\n\t\t\t\n\t\t\tm_pollerFrontEnd.setInitialPollTime(polledService.getServiceId(), initialPollTime);\n\t\t\t\n\t\t\tTrigger pollTrigger = new PolledServiceTrigger(polledService);\n\t\t\tpollTrigger.setStartTime(initialPollTime);\n\t\t\t\n            PollJobDetail jobDetail = new PollJobDetail(jobName, PollJob.class);\n\t\t\tjobDetail.setPolledService(polledService);\n\t\t\tjobDetail.setPollerFrontEnd(m_pollerFrontEnd);\n\t\t\t\n            \n\t\t\tm_scheduler.scheduleJob(jobDetail, pollTrigger);\n\t\t\t\n\t\t\tstartTime += scheduleSpacing;\n\t\t}\n\t\t\n        log().debug(\"Exit schedulePolls\");\n\t\t\n\t}","commit_id":"20e750190f0fc4aa73a270e3b55e34bb908e61db","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testSchedule() throws Exception {\n\t\t\n\t\tScheduler scheduler = createMock(Scheduler.class);\n\t\tPollService pollService = createNiceMock(PollService.class);\n\t\tPollerFrontEnd pollerFrontEnd = createMock(PollerFrontEnd.class);\n\t\t\n\t\tOnmsMonitoredService svc = getMonitoredService();\n        svc.setId(7);\n\t\t\n\t\tPollConfiguration pollConfig = new PollConfiguration(svc, new HashMap(), 300000);\n\t\t\n\t\tPolledService polledService = new PolledService(pollConfig.getMonitoredService(), pollConfig.getMonitorConfiguration(), pollConfig.getPollModel());\n\t\t\n\t\tSet<PolledService> polledServices = Collections.singleton(polledService);\n\n        Poller poller = new Poller();\n\n        pollerFrontEnd.addConfigurationChangedListener(poller);\n        pollerFrontEnd.addPropertyChangeListener(poller);\n\t\texpect(pollerFrontEnd.getPolledServices()).andReturn(polledServices);\n        expect(pollerFrontEnd.isStarted()).andReturn(true);\n\t\tpollerFrontEnd.setInitialPollTime(eq(svc.getId()), isA(Date.class));\n\t\texpect(scheduler.scheduleJob(isA(PollJobDetail.class), isA(PolledServiceTrigger.class))).andReturn(new Date());\n\t\t\n\t\treplay(scheduler, pollService, pollerFrontEnd);\n\t\t\n\t\tpoller.setScheduler(scheduler);\n\t\tpoller.setPollerFrontEnd(pollerFrontEnd);\n\t\t\n\t\tpoller.afterPropertiesSet();\n\t\t\n\t\tverify(scheduler, pollService, pollerFrontEnd);\n\t\t\n\t}","id":102817,"modified_method":"public void testSchedule() throws Exception {\n        testSchedule(false);\n    }","commit_id":"20e750190f0fc4aa73a270e3b55e34bb908e61db","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.unavailable();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n\n        // Retrieve this interface's SNMP peer object\n        //\n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n\n        // Get configuration parameters\n        //\n        String oid = ParameterMap.getKeyedString(parameters, \"oid\", DEFAULT_OBJECT_IDENTIFIER);\n        String operator = ParameterMap.getKeyedString(parameters, \"operator\", null);\n        String operand = ParameterMap.getKeyedString(parameters, \"operand\", null);\n        String walkstr = ParameterMap.getKeyedString(parameters, \"walk\", \"false\");\n\n        // set timeout and retries on SNMP peer object\n        //\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retries\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n\n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        // Establish SNMP session with interface\n        //\n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"SnmpMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId snmpObjectId = SnmpObjId.get(oid);\n\n            if (\"true\".equals(walkstr)) {\n                List<SnmpValue> results = SnmpUtils.getColumns(agentConfig, \"snmpPoller\", snmpObjectId);\n                for(SnmpValue result : results) {\n\n                    if (result != null) {\n                        log().debug(\"poll: SNMPwalk poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid + \" value=\" + result);\n                        if (meetsCriteria(result, operator, operand)) {\n                            status = PollStatus.available();\n                        }\n                    } else {\n                        status = logDown(Level.DEBUG, \"SNMP poll failed, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid);\n                        return status;\n                    }\n                }\n\n            } else {\n\n                SnmpValue result = SnmpUtils.get(agentConfig, snmpObjectId);\n\n                if (result != null) {\n                    log().debug(\"poll: SNMP poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid + \" value=\" + result);\n                    status = (meetsCriteria(result, operator, operand) ? PollStatus.available() : PollStatus.unavailable());\n                } else {\n                    status = logDown(Level.DEBUG, \"SNMP poll failed, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid);\n                }\n            }\n\n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","id":102818,"modified_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.unavailable();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n\n        // Retrieve this interface's SNMP peer object\n        //\n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n\n        // Get configuration parameters\n        //\n        String oid = ParameterMap.getKeyedString(parameters, \"oid\", DEFAULT_OBJECT_IDENTIFIER);\n        String operator = ParameterMap.getKeyedString(parameters, \"operator\", null);\n        String operand = ParameterMap.getKeyedString(parameters, \"operand\", null);\n        String walkstr = ParameterMap.getKeyedString(parameters, \"walk\", \"false\");\n\n        // set timeout and retries on SNMP peer object\n        //\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n\n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        // Establish SNMP session with interface\n        //\n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"SnmpMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId snmpObjectId = SnmpObjId.get(oid);\n\n            if (\"true\".equals(walkstr)) {\n                List<SnmpValue> results = SnmpUtils.getColumns(agentConfig, \"snmpPoller\", snmpObjectId);\n                for(SnmpValue result : results) {\n\n                    if (result != null) {\n                        log().debug(\"poll: SNMPwalk poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid + \" value=\" + result);\n                        if (meetsCriteria(result, operator, operand)) {\n                            status = PollStatus.available();\n                        }\n                    } else {\n                        status = logDown(Level.DEBUG, \"SNMP poll failed, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid);\n                        return status;\n                    }\n                }\n\n            } else {\n\n                SnmpValue result = SnmpUtils.get(agentConfig, snmpObjectId);\n\n                if (result != null) {\n                    log().debug(\"poll: SNMP poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid + \" value=\" + result);\n                    status = (meetsCriteria(result, operator, operand) ? PollStatus.available() : PollStatus.unavailable());\n                } else {\n                    status = logDown(Level.DEBUG, \"SNMP poll failed, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid);\n                }\n            }\n\n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","commit_id":"20e750190f0fc4aa73a270e3b55e34bb908e61db","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        int matchType = MATCH_TYPE_EXACT;\n        \n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.available();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n        \n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n        \n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retries\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n        \n        String diskName = ParameterMap.getKeyedString(parameters, \"disk\", null);\n        Integer percentFree = ParameterMap.getKeyedInteger(parameters, \"free\", 15);\n        \n        String matchTypeStr = ParameterMap.getKeyedString(parameters, \"match-type\", \"exact\");\n        if (matchTypeStr.equalsIgnoreCase(\"exact\")) {\n            matchType = MATCH_TYPE_EXACT; \n        } else if (matchTypeStr.equalsIgnoreCase(\"startswith\")) {\n            matchType = MATCH_TYPE_STARTSWITH;\n        } else if (matchTypeStr.equalsIgnoreCase(\"endswith\")) {\n            matchType = MATCH_TYPE_ENDSWITH;\n        } else if (matchTypeStr.equalsIgnoreCase(\"regex\")) {\n            matchType = MATCH_TYPE_REGEX;\n        } else {\n            throw new RuntimeException(\"Unknown value '\" + matchTypeStr + \"' for parameter 'match-type'\");\n        }\n        \n        log().debug(\"diskName=\" + diskName);\n        log().debug(\"percentfree=\" + percentFree);\n        log().debug(\"matchType=\" + matchTypeStr);\n        \n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        \n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"DiskUsageMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId hrStorageDescrSnmpObject = SnmpObjId.get(hrStorageDescr);\n            \n            \n            \n            Map<SnmpInstId, SnmpValue> flagResults = SnmpUtils.getOidValues(agentConfig, \"DiskUsagePoller\", hrStorageDescrSnmpObject);\n            \n            if(flagResults.size() == 0) {\n                log().debug(\"SNMP poll failed: no results, addr=\" + ipaddr.getHostAddress() + \" oid=\" + hrStorageDescrSnmpObject);\n                return PollStatus.unavailable();\n            }\n\n            for (Map.Entry<SnmpInstId, SnmpValue> e : flagResults.entrySet()) { \n                log().debug(\"poll: SNMPwalk poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + hrStorageDescrSnmpObject + \" instance=\" + e.getKey() + \" value=\" + e.getValue());\n                \n                if (isMatch(e.getValue().toString(), diskName, matchType)) {\n                \tlog().debug(\"DiskUsageMonitor.poll: found disk=\" + diskName);\n                \t\n                \tSnmpObjId hrStorageSizeSnmpObject = SnmpObjId.get(hrStorageSize + \".\" + e.getKey().toString());\n                \tSnmpObjId hrStorageUsedSnmpObject = SnmpObjId.get(hrStorageUsed + \".\" + e.getKey().toString());\n                \t\n                \t\n                \tSnmpValue snmpSize = SnmpUtils.get(agentConfig, hrStorageSizeSnmpObject);\n                \tSnmpValue snmpUsed = SnmpUtils.get(agentConfig, hrStorageUsedSnmpObject);\n                \tfloat calculatedPercentage = ( (( (float)snmpSize.toLong() - (float)snmpUsed.toLong() ) / (float)snmpSize.toLong() ) ) * 100;\n                \n                \tlog().debug(\"DiskUsageMonitor: calculatedPercentage=\" + calculatedPercentage + \" percentFree=\"+percentFree);\n                \t\n                \tif (calculatedPercentage < percentFree) {\n                \t\n                \t\treturn PollStatus.unavailable(diskName + \" usage high (\" + (100 - (int)calculatedPercentage)  + \"%)\");\n                \t\t\n                \t}\n                \telse {\n                \t\treturn status;\n                \t}\n                }\n            \n                 \n            }\n\n            // if we get here.. it means we did not find the disk...  which means we should not be monitoring it.\n            log().debug(\"DiskUsageMonitor: no disks found\");\n            return PollStatus.unavailable(\"could not find \" + diskName + \"in table\");\n            \n            \n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","id":102819,"modified_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        int matchType = MATCH_TYPE_EXACT;\n        \n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.available();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n        \n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n        \n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n        \n        String diskName = ParameterMap.getKeyedString(parameters, \"disk\", null);\n        Integer percentFree = ParameterMap.getKeyedInteger(parameters, \"free\", 15);\n        \n        String matchTypeStr = ParameterMap.getKeyedString(parameters, \"match-type\", \"exact\");\n        if (matchTypeStr.equalsIgnoreCase(\"exact\")) {\n            matchType = MATCH_TYPE_EXACT; \n        } else if (matchTypeStr.equalsIgnoreCase(\"startswith\")) {\n            matchType = MATCH_TYPE_STARTSWITH;\n        } else if (matchTypeStr.equalsIgnoreCase(\"endswith\")) {\n            matchType = MATCH_TYPE_ENDSWITH;\n        } else if (matchTypeStr.equalsIgnoreCase(\"regex\")) {\n            matchType = MATCH_TYPE_REGEX;\n        } else {\n            throw new RuntimeException(\"Unknown value '\" + matchTypeStr + \"' for parameter 'match-type'\");\n        }\n        \n        log().debug(\"diskName=\" + diskName);\n        log().debug(\"percentfree=\" + percentFree);\n        log().debug(\"matchType=\" + matchTypeStr);\n        \n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        \n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"DiskUsageMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId hrStorageDescrSnmpObject = SnmpObjId.get(hrStorageDescr);\n            \n            \n            \n            Map<SnmpInstId, SnmpValue> flagResults = SnmpUtils.getOidValues(agentConfig, \"DiskUsagePoller\", hrStorageDescrSnmpObject);\n            \n            if(flagResults.size() == 0) {\n                log().debug(\"SNMP poll failed: no results, addr=\" + ipaddr.getHostAddress() + \" oid=\" + hrStorageDescrSnmpObject);\n                return PollStatus.unavailable();\n            }\n\n            for (Map.Entry<SnmpInstId, SnmpValue> e : flagResults.entrySet()) { \n                log().debug(\"poll: SNMPwalk poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + hrStorageDescrSnmpObject + \" instance=\" + e.getKey() + \" value=\" + e.getValue());\n                \n                if (isMatch(e.getValue().toString(), diskName, matchType)) {\n                \tlog().debug(\"DiskUsageMonitor.poll: found disk=\" + diskName);\n                \t\n                \tSnmpObjId hrStorageSizeSnmpObject = SnmpObjId.get(hrStorageSize + \".\" + e.getKey().toString());\n                \tSnmpObjId hrStorageUsedSnmpObject = SnmpObjId.get(hrStorageUsed + \".\" + e.getKey().toString());\n                \t\n                \t\n                \tSnmpValue snmpSize = SnmpUtils.get(agentConfig, hrStorageSizeSnmpObject);\n                \tSnmpValue snmpUsed = SnmpUtils.get(agentConfig, hrStorageUsedSnmpObject);\n                \tfloat calculatedPercentage = ( (( (float)snmpSize.toLong() - (float)snmpUsed.toLong() ) / (float)snmpSize.toLong() ) ) * 100;\n                \n                \tlog().debug(\"DiskUsageMonitor: calculatedPercentage=\" + calculatedPercentage + \" percentFree=\"+percentFree);\n                \t\n                \tif (calculatedPercentage < percentFree) {\n                \t\n                \t\treturn PollStatus.unavailable(diskName + \" usage high (\" + (100 - (int)calculatedPercentage)  + \"%)\");\n                \t\t\n                \t}\n                \telse {\n                \t\treturn status;\n                \t}\n                }\n            \n                 \n            }\n\n            // if we get here.. it means we did not find the disk...  which means we should not be monitoring it.\n            log().debug(\"DiskUsageMonitor: no disks found\");\n            return PollStatus.unavailable(\"could not find \" + diskName + \"in table\");\n            \n            \n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","commit_id":"4e06d24cafb891df31bbe13354c5377a7197291a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * <\/p>\n     * \n     * <p>\n     * In addition, the input qualifiers map also provides information about how\n     * the plugin should contact the remote server. The plugin may check the\n     * qualifier map for specific elements and then adjust its behavior as\n     * necessary\n     * <\/p>\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map<String, Object> qualifiers) {\n        int port = DEFAULT_PORT;\n        int timeout = DEFAULT_TIMEOUT;\n        int retries = DEFAULT_RETRY;\n        String lookup = DEFAULT_LOOKUP;\n        if (qualifiers != null) {\n            port = ParameterMap.getKeyedInteger(qualifiers, \"port\", DEFAULT_PORT);\n            timeout = ParameterMap.getKeyedInteger(qualifiers, \"timeout\", DEFAULT_TIMEOUT);\n            retries = ParameterMap.getKeyedInteger(qualifiers, \"retries\", DEFAULT_RETRY);\n            lookup = ParameterMap.getKeyedString(qualifiers, \"lookup\", DEFAULT_LOOKUP);\n        }\n\n        boolean result = isServer(address, port, retries, timeout, lookup);\n        if (result && qualifiers != null && !qualifiers.containsKey(\"port\"))\n            qualifiers.put(\"port\", new Integer(port));\n\n        return result;\n    }","id":102820,"modified_method":"/**\n     * <p>\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * <\/p>\n     * \n     * <p>\n     * In addition, the input qualifiers map also provides information about how\n     * the plugin should contact the remote server. The plugin may check the\n     * qualifier map for specific elements and then adjust its behavior as\n     * necessary\n     * <\/p>\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map<String, Object> qualifiers) {\n        int port = DEFAULT_PORT;\n        int timeout = DEFAULT_TIMEOUT;\n        int retries = DEFAULT_RETRY;\n        String lookup = DEFAULT_LOOKUP;\n        if (qualifiers != null) {\n            port = ParameterMap.getKeyedInteger(qualifiers, \"port\", DEFAULT_PORT);\n            timeout = ParameterMap.getKeyedInteger(qualifiers, \"timeout\", DEFAULT_TIMEOUT);\n            retries = ParameterMap.getKeyedInteger(qualifiers, \"retry\", DEFAULT_RETRY);\n            lookup = ParameterMap.getKeyedString(qualifiers, \"lookup\", DEFAULT_LOOKUP);\n        }\n\n        boolean result = isServer(address, port, retries, timeout, lookup);\n        if (result && qualifiers != null && !qualifiers.containsKey(\"port\"))\n            qualifiers.put(\"port\", new Integer(port));\n\n        return result;\n    }","commit_id":"4e06d24cafb891df31bbe13354c5377a7197291a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Poll the specified address for FTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port (by\n     * default TCP port 21). If the connection request is successful, the banner\n     * line generated by the interface is parsed and if the extracted return\n     * code indicates that we are talking to an FTP server we continue. Next, an\n     * FTP 'QUIT' command is sent. Provided that the interface's response is\n     * valid we set the service status to SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Check the interface type\n        if (iface.getType() != NetworkInterface.TYPE_IPV4) {\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n        }\n\n        // Get the parameters\n        TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n        int port = ParameterMap.getKeyedInteger(parameters, \"port\", DEFAULT_PORT);\n        String userid = ParameterMap.getKeyedString(parameters, \"userid\", null);\n        String password = ParameterMap.getKeyedString(parameters, \"password\", null);\n\n        // Extract the address\n        InetAddress ipv4Addr = (InetAddress) iface.getAddress();\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"FtpMonitor.poll: Polling interface: \" + ipv4Addr.getHostAddress() + tracker);\n        }\n\n        PollStatus serviceStatus = PollStatus.unavailable();\n        for (tracker.reset(); tracker.shouldRetry() && !serviceStatus.isAvailable(); tracker.nextAttempt()) {\n            Socket socket = null;\n            try {\n                // create a connected socket\n                tracker.startAttempt();\n\n                socket = new Socket();\n                socket.connect(new InetSocketAddress(ipv4Addr, port), tracker.getConnectionTimeout());\n                socket.setSoTimeout(tracker.getSoTimeout());\n                log().debug(\"FtpMonitor: connected to host: \" + ipv4Addr + \" on port: \" + port);\n\n                // We're connected, so upgrade status to unresponsive\n                serviceStatus = PollStatus.unresponsive();\n\n                BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                \n                FtpResponse bannerResponse = FtpResponse.readResponse(lineRdr);\n\n                if (bannerResponse.isSuccess()) {\n                    // Attempt to login if userid and password available\n                    boolean loggedInSuccessfully = false;\n                    if (userid == null || userid.length() == 0 || password == null || password.length() == 0) {\n                        loggedInSuccessfully = true;\n                    } else {\n                        FtpResponse.sendCommand(socket, \"USER \" + userid);\n\n                        FtpResponse userResponse = FtpResponse.readResponse(lineRdr);\n\n                        if (userResponse.isSuccess()) {\n                            FtpResponse.sendCommand(socket, \"PASS \" + password);\n                            \n                            FtpResponse passResponse = FtpResponse.readResponse(lineRdr);\n                            if (passResponse.isSuccess()) {\n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"FtpMonitor.poll: Login successful, parsed return code: \" + passResponse.getCode());\n                                }\n                                loggedInSuccessfully = true;\n                            } else {\n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"FtpMonitor.poll: Login failed, parsed return code: \" + passResponse.getCode() + \", full response: \" + passResponse.toString());\n                                }\n                                loggedInSuccessfully = false;\n                            }\n                        }\n                    }\n\n                    // Store the response time before we try to quit\n                    double responseTime = tracker.elapsedTimeInMillis();\n\n                    if (loggedInSuccessfully) {\n                        FtpResponse.sendCommand(socket, \"QUIT\");\n\n                        FtpResponse quitResponse = FtpResponse.readResponse(lineRdr);\n\n                        /*\n                         * Special Cases for success:\n                         * \n                         * Also want to accept the following\n                         * ERROR message generated by some FTP servers\n                         * following a QUIT command without a previous\n                         * successful login:\n                         *\n                         * \"530 QUIT : User not logged in. Please login with\n                         * USER and PASS first.\"\n                         * \n                         * Also want to accept the following ERROR\n                         * message generated by some FTP servers following a\n                         * QUIT command without a previously successful login:\n                         *\n                         * \"425 Session is disconnected.\"\n                         */\n                        if (quitResponse.isSuccess()\n                                || (quitResponse.getCode() == 530 && (quitResponse.responseContains(FTP_ERROR_530_TEXT) || quitResponse.responseContains(FTP_ERROR_530_TEXT2)))\n                                || (quitResponse.getCode() == 425 && quitResponse.responseContains(FTP_ERROR_425_TEXT))) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                    }\n                }\n\n                /*\n                 * If we get this far and the status has not been set\n                 * to available, then something didn't verify during\n                 * the banner checking or login/QUIT command process.\n                 */\n                if (!serviceStatus.isAvailable()) {\n                    serviceStatus = PollStatus.unavailable();\n                }\n            } catch (NumberFormatException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"NumberFormatException while polling address: \" + ipv4Addr, e);\n            } catch (NoRouteToHostException e) {\n            \tserviceStatus = logDown(Level.WARN, \"No route to host exception for address: \" + ipv4Addr, e);\n            } catch (InterruptedIOException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"did not connect to host with \" + tracker);\n            } catch (ConnectException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"Connection exception for address: \" + ipv4Addr, e);\n            } catch (IOException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"IOException while polling address: \" + ipv4Addr, e);\n            } finally {\n                try {\n                    // Close the socket\n                    if (socket != null) {\n                        socket.close();\n                    }\n                } catch (IOException e) {\n                    log().debug(\"FtpMonitor.poll: Error closing socket: \" + e, e);\n                }\n            }\n        }\n\n        return serviceStatus;\n    }","id":102821,"modified_method":"/**\n     * Poll the specified address for FTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port (by\n     * default TCP port 21). If the connection request is successful, the banner\n     * line generated by the interface is parsed and if the extracted return\n     * code indicates that we are talking to an FTP server we continue. Next, an\n     * FTP 'QUIT' command is sent. Provided that the interface's response is\n     * valid we set the service status to SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Check the interface type\n        if (iface.getType() != NetworkInterface.TYPE_IPV4) {\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n        }\n\n        // Get the parameters\n        TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n        int port = ParameterMap.getKeyedInteger(parameters, \"port\", DEFAULT_PORT);\n        String userid = ParameterMap.getKeyedString(parameters, \"userid\", null);\n        String password = ParameterMap.getKeyedString(parameters, \"password\", null);\n\n        // Extract the address\n        InetAddress ipv4Addr = (InetAddress) iface.getAddress();\n\n        PollStatus serviceStatus = PollStatus.unavailable();\n        for (tracker.reset(); tracker.shouldRetry() && !serviceStatus.isAvailable(); tracker.nextAttempt()) {\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"FtpMonitor.poll: Polling interface: \" + ipv4Addr.getHostAddress() + tracker);\n            }\n\n            Socket socket = null;\n            try {\n                // create a connected socket\n                tracker.startAttempt();\n\n                socket = new Socket();\n                socket.connect(new InetSocketAddress(ipv4Addr, port), tracker.getConnectionTimeout());\n                socket.setSoTimeout(tracker.getSoTimeout());\n                log().debug(\"FtpMonitor: connected to host: \" + ipv4Addr + \" on port: \" + port);\n\n                // We're connected, so upgrade status to unresponsive\n                serviceStatus = PollStatus.unresponsive();\n\n                BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                \n                FtpResponse bannerResponse = FtpResponse.readResponse(lineRdr);\n\n                if (bannerResponse.isSuccess()) {\n                    // Attempt to login if userid and password available\n                    boolean loggedInSuccessfully = false;\n                    log().debug(\"FtpMonitor: Banner response successful.\");\n                    if (userid == null || userid.length() == 0 || password == null || password.length() == 0) {\n                        loggedInSuccessfully = true;\n                    } else {\n                        FtpResponse.sendCommand(socket, \"USER \" + userid);\n\n                        FtpResponse userResponse = FtpResponse.readResponse(lineRdr);\n\n                        if (userResponse.isSuccess() || userResponse.isIntermediate()) {\n                            log().debug(\"FtpMonitor: User response successful.\");\n                            FtpResponse.sendCommand(socket, \"PASS \" + password);\n                            \n                            FtpResponse passResponse = FtpResponse.readResponse(lineRdr);\n                            if (passResponse.isSuccess()) {\n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"FtpMonitor.poll: Login successful, parsed return code: \" + passResponse.getCode());\n                                }\n                                loggedInSuccessfully = true;\n                            } else {\n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"FtpMonitor.poll: Login failed, parsed return code: \" + passResponse.getCode() + \", full response: \" + passResponse.toString());\n                                }\n                                loggedInSuccessfully = false;\n                            }\n                        }\n                    }\n\n                    // Store the response time before we try to quit\n                    double responseTime = tracker.elapsedTimeInMillis();\n\n                    if (loggedInSuccessfully) {\n                        FtpResponse.sendCommand(socket, \"QUIT\");\n\n                        FtpResponse quitResponse = FtpResponse.readResponse(lineRdr);\n\n                        /*\n                         * Special Cases for success:\n                         * \n                         * Also want to accept the following\n                         * ERROR message generated by some FTP servers\n                         * following a QUIT command without a previous\n                         * successful login:\n                         *\n                         * \"530 QUIT : User not logged in. Please login with\n                         * USER and PASS first.\"\n                         * \n                         * Also want to accept the following ERROR\n                         * message generated by some FTP servers following a\n                         * QUIT command without a previously successful login:\n                         *\n                         * \"425 Session is disconnected.\"\n                         */\n                        if (quitResponse.isSuccess()\n                                || (quitResponse.getCode() == 530 && (quitResponse.responseContains(FTP_ERROR_530_TEXT) || quitResponse.responseContains(FTP_ERROR_530_TEXT2)))\n                                || (quitResponse.getCode() == 425 && quitResponse.responseContains(FTP_ERROR_425_TEXT))) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                    }\n                }\n\n                /*\n                 * If we get this far and the status has not been set\n                 * to available, then something didn't verify during\n                 * the banner checking or login/QUIT command process.\n                 */\n                if (!serviceStatus.isAvailable()) {\n                    serviceStatus = PollStatus.unavailable();\n                }\n            } catch (NumberFormatException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"NumberFormatException while polling address: \" + ipv4Addr, e);\n            } catch (NoRouteToHostException e) {\n            \tserviceStatus = logDown(Level.WARN, \"No route to host exception for address: \" + ipv4Addr, e);\n            } catch (InterruptedIOException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"did not connect to host with \" + tracker);\n            } catch (ConnectException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"Connection exception for address: \" + ipv4Addr, e);\n            } catch (IOException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"IOException while polling address: \" + ipv4Addr, e);\n            } finally {\n                try {\n                    // Close the socket\n                    if (socket != null) {\n                        socket.close();\n                    }\n                } catch (IOException e) {\n                    log().debug(\"FtpMonitor.poll: Error closing socket: \" + e, e);\n                }\n            }\n        }\n\n        return serviceStatus;\n    }","commit_id":"4e06d24cafb891df31bbe13354c5377a7197291a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * <\/p>\n     * \n     * <p>\n     * In addition, the input qualifiers map also provides information about how\n     * the plugin should contact the remote server. The plugin may check the\n     * qualifier map for specific elements and then adjust its behavior as\n     * necessary\n     * <\/p>\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map<String, Object> qualifiers) {\n        int port = DEFAULT_PORT;\n        int timeout = DEFAULT_TIMEOUT;\n        int retries = DEFAULT_RETRY;\n        if (qualifiers != null) {\n            port = ParameterMap.getKeyedInteger(qualifiers, \"port\", DEFAULT_PORT);\n            timeout = ParameterMap.getKeyedInteger(qualifiers, \"timeout\", DEFAULT_TIMEOUT);\n            retries = ParameterMap.getKeyedInteger(qualifiers, \"retries\", DEFAULT_RETRY);\n        }\n\n        boolean result = isServer(address, port, retries, timeout);\n        if (result && qualifiers != null && !qualifiers.containsKey(\"port\"))\n            qualifiers.put(\"port\", new Integer(port));\n\n        return result;\n    }","id":102822,"modified_method":"/**\n     * <p>\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * <\/p>\n     * \n     * <p>\n     * In addition, the input qualifiers map also provides information about how\n     * the plugin should contact the remote server. The plugin may check the\n     * qualifier map for specific elements and then adjust its behavior as\n     * necessary\n     * <\/p>\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map<String, Object> qualifiers) {\n        int port = DEFAULT_PORT;\n        int timeout = DEFAULT_TIMEOUT;\n        int retries = DEFAULT_RETRY;\n        if (qualifiers != null) {\n            port = ParameterMap.getKeyedInteger(qualifiers, \"port\", DEFAULT_PORT);\n            timeout = ParameterMap.getKeyedInteger(qualifiers, \"timeout\", DEFAULT_TIMEOUT);\n            retries = ParameterMap.getKeyedInteger(qualifiers, \"retry\", DEFAULT_RETRY);\n        }\n\n        boolean result = isServer(address, port, retries, timeout);\n        if (result && qualifiers != null && !qualifiers.containsKey(\"port\"))\n            qualifiers.put(\"port\", new Integer(port));\n\n        return result;\n    }","commit_id":"4e06d24cafb891df31bbe13354c5377a7197291a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private SnmpAgentConfig configureAgent(Map parameters, NetworkInterface iface, InetAddress ipaddr) throws RuntimeException {\n\t\tSnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(snmpAgentConfigKey);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retries\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n\t\treturn agentConfig;\n\t}","id":102823,"modified_method":"private SnmpAgentConfig configureAgent(Map parameters, NetworkInterface iface, InetAddress ipaddr) throws RuntimeException {\n\t\tSnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(snmpAgentConfigKey);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n\t\treturn agentConfig;\n\t}","commit_id":"4e06d24cafb891df31bbe13354c5377a7197291a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.unavailable();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n\n        // Retrieve this interface's SNMP peer object\n        //\n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n\n        // Get configuration parameters\n        //\n        // set timeout and retries on SNMP peer object\n        //\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retries\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n        \n        String arrayNumber = ParameterMap.getKeyedString(parameters,\"array\",\"0.0\");\n\n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        // Establish SNMP session with interface\n        //\n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"PercMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId snmpObjectId = SnmpObjId.get(LOGICAL_BASE_OID + \".\" + arrayNumber);\n\n            // First walk the physical OID Tree and check the returned values \n\n            String returnValue = new String(); \n          \n            SnmpValue value = SnmpUtils.get(agentConfig,snmpObjectId);\n            \n            if (value.toInt()!=2){\n            \tlog().debug(\"PercMonitor.poll: Bad Disk Found\");\n            \treturnValue = \"log vol(\" + arrayNumber + \") degraded\"; // XXX should degraded be the virtualDiskState ?\n            \t// array is bad\n            \t// lets find out which disks are bad in the array\n            \t\n            \t// first we need to fetch the arrayPosition table.\n            \tSnmpObjId arrayPositionSnmpObject = SnmpObjId.get(ARRAY_POSITION_BASE_OID);\n            \tSnmpObjId diskStatesSnmpObject = SnmpObjId.get(PHYSICAL_BASE_OID); \n            \t\n            \tMap<SnmpInstId,SnmpValue> arrayDisks = SnmpUtils.getOidValues(agentConfig, \"PercMonitor\", arrayPositionSnmpObject);\n            \tMap<SnmpInstId,SnmpValue> diskStates = SnmpUtils.getOidValues(agentConfig, \"PercMonitor\", diskStatesSnmpObject);\n            \t\n            \tfor (Map.Entry<SnmpInstId, SnmpValue> disk: arrayDisks.entrySet()) {\n            \t\t\n            \t\tif (disk.getValue().toString().contains(\"A\" + arrayNumber.toString() + \"-\")) {\n            \t\t\t// this is a member of the array\n            \t\t\t\n            \t\t\tif ( diskStates.get(disk.getKey()).toInt() !=3 ){\n            \t\t\t\t// this is bad disk.\n            \t\t\t\t\n            \t\t\t\treturnValue  += \"phy drv(\" + disk.getKey().toString() + \")\";\n            \t\t\t\t\n            \t\t\t}\n            \t\t\t\n            \t\t}\n            \n            \t\treturn PollStatus.unavailable(returnValue);\n            \t}\n            \t\n            \t\n            }\n        \n            status = PollStatus.available();\n            \n\n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","id":102824,"modified_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.unavailable();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n\n        // Retrieve this interface's SNMP peer object\n        //\n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n\n        // Get configuration parameters\n        //\n        // set timeout and retries on SNMP peer object\n        //\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n        \n        String arrayNumber = ParameterMap.getKeyedString(parameters,\"array\",\"0.0\");\n\n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        // Establish SNMP session with interface\n        //\n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"PercMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId snmpObjectId = SnmpObjId.get(LOGICAL_BASE_OID + \".\" + arrayNumber);\n\n            // First walk the physical OID Tree and check the returned values \n\n            String returnValue = new String(); \n          \n            SnmpValue value = SnmpUtils.get(agentConfig,snmpObjectId);\n            \n            if (value.toInt()!=2){\n            \tlog().debug(\"PercMonitor.poll: Bad Disk Found\");\n            \treturnValue = \"log vol(\" + arrayNumber + \") degraded\"; // XXX should degraded be the virtualDiskState ?\n            \t// array is bad\n            \t// lets find out which disks are bad in the array\n            \t\n            \t// first we need to fetch the arrayPosition table.\n            \tSnmpObjId arrayPositionSnmpObject = SnmpObjId.get(ARRAY_POSITION_BASE_OID);\n            \tSnmpObjId diskStatesSnmpObject = SnmpObjId.get(PHYSICAL_BASE_OID); \n            \t\n            \tMap<SnmpInstId,SnmpValue> arrayDisks = SnmpUtils.getOidValues(agentConfig, \"PercMonitor\", arrayPositionSnmpObject);\n            \tMap<SnmpInstId,SnmpValue> diskStates = SnmpUtils.getOidValues(agentConfig, \"PercMonitor\", diskStatesSnmpObject);\n            \t\n            \tfor (Map.Entry<SnmpInstId, SnmpValue> disk: arrayDisks.entrySet()) {\n            \t\t\n            \t\tif (disk.getValue().toString().contains(\"A\" + arrayNumber.toString() + \"-\")) {\n            \t\t\t// this is a member of the array\n            \t\t\t\n            \t\t\tif ( diskStates.get(disk.getKey()).toInt() !=3 ){\n            \t\t\t\t// this is bad disk.\n            \t\t\t\t\n            \t\t\t\treturnValue  += \"phy drv(\" + disk.getKey().toString() + \")\";\n            \t\t\t\t\n            \t\t\t}\n            \t\t\t\n            \t\t}\n            \n            \t\treturn PollStatus.unavailable(returnValue);\n            \t}\n            \t\n            \t\n            }\n        \n            status = PollStatus.available();\n            \n\n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","commit_id":"4e06d24cafb891df31bbe13354c5377a7197291a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void schedulePolls() throws Exception {\n        \n        log().debug(\"Enter schedulePolls\");\n\t\t\n\t\tCollection<PolledService> polledServices = m_pollerFrontEnd.getPolledServices();\n\n\t\tif (polledServices == null || polledServices.size() == 0) {\n\t\t\tlog().warn(\"No polling scheduled.\");\n            log().debug(\"Exit schedulePolls\");\n\t\t\treturn;\n\t\t}\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tlong scheduleSpacing = m_initialSpreadTime / polledServices.size();\n\n        for (PolledService polledService : polledServices) {\n\t\t\t\n\t\t\tDate initialPollTime = new Date(startTime);\n\t\t\t\n\t\t\tm_pollerFrontEnd.setInitialPollTime(polledService.getServiceId(), initialPollTime);\n\t\t\t\n\t\t\tTrigger pollTrigger = new PolledServiceTrigger(polledService);\n\t\t\tpollTrigger.setStartTime(initialPollTime);\n\t\t\t\n\t\t\tPollJobDetail jobDetail = new PollJobDetail(polledService.toString(), PollJob.class);\n\t\t\tjobDetail.setPolledService(polledService);\n\t\t\tjobDetail.setPollerFrontEnd(m_pollerFrontEnd);\n\t\t\t\n            log().debug(\"Scheduling job for \"+polledService);\n            \n\t\t\tm_scheduler.scheduleJob(jobDetail, pollTrigger);\n\t\t\t\n\t\t\tstartTime += scheduleSpacing;\n\t\t}\n\t\t\n        log().debug(\"Exit schedulePolls\");\n\t\t\n\t}","id":102825,"modified_method":"private void schedulePolls() throws Exception {\n        \n        log().debug(\"Enter schedulePolls\");\n\t\t\n\t\tCollection<PolledService> polledServices = m_pollerFrontEnd.getPolledServices();\n\n\t\tif (polledServices == null || polledServices.size() == 0) {\n\t\t\tlog().warn(\"No polling scheduled.\");\n            log().debug(\"Exit schedulePolls\");\n\t\t\treturn;\n\t\t}\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tlong scheduleSpacing = m_initialSpreadTime / polledServices.size();\n\t\t\n        for (PolledService polledService : polledServices) {\n            \n            String jobName = polledService.toString();\n\n            // remove any currently scheduled job\n            if (m_scheduler.deleteJob(jobName, PollJobDetail.GROUP)) {\n                log().debug(String.format(\"Job for %s already scheduled.  Rescheduling\", polledService));\n            } else {\n                log().debug(\"Scheduling job for \"+polledService);\n            }\n\t\t\t\n\t\t\tDate initialPollTime = new Date(startTime);\n\t\t\t\n\t\t\tm_pollerFrontEnd.setInitialPollTime(polledService.getServiceId(), initialPollTime);\n\t\t\t\n\t\t\tTrigger pollTrigger = new PolledServiceTrigger(polledService);\n\t\t\tpollTrigger.setStartTime(initialPollTime);\n\t\t\t\n            PollJobDetail jobDetail = new PollJobDetail(jobName, PollJob.class);\n\t\t\tjobDetail.setPolledService(polledService);\n\t\t\tjobDetail.setPollerFrontEnd(m_pollerFrontEnd);\n\t\t\t\n            \n\t\t\tm_scheduler.scheduleJob(jobDetail, pollTrigger);\n\t\t\t\n\t\t\tstartTime += scheduleSpacing;\n\t\t}\n\t\t\n        log().debug(\"Exit schedulePolls\");\n\t\t\n\t}","commit_id":"4e06d24cafb891df31bbe13354c5377a7197291a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testSchedule() throws Exception {\n\t\t\n\t\tScheduler scheduler = createMock(Scheduler.class);\n\t\tPollService pollService = createNiceMock(PollService.class);\n\t\tPollerFrontEnd pollerFrontEnd = createMock(PollerFrontEnd.class);\n\t\t\n\t\tOnmsMonitoredService svc = getMonitoredService();\n        svc.setId(7);\n\t\t\n\t\tPollConfiguration pollConfig = new PollConfiguration(svc, new HashMap(), 300000);\n\t\t\n\t\tPolledService polledService = new PolledService(pollConfig.getMonitoredService(), pollConfig.getMonitorConfiguration(), pollConfig.getPollModel());\n\t\t\n\t\tSet<PolledService> polledServices = Collections.singleton(polledService);\n\n        Poller poller = new Poller();\n\n        pollerFrontEnd.addConfigurationChangedListener(poller);\n        pollerFrontEnd.addPropertyChangeListener(poller);\n\t\texpect(pollerFrontEnd.getPolledServices()).andReturn(polledServices);\n        expect(pollerFrontEnd.isStarted()).andReturn(true);\n\t\tpollerFrontEnd.setInitialPollTime(eq(svc.getId()), isA(Date.class));\n\t\texpect(scheduler.scheduleJob(isA(PollJobDetail.class), isA(PolledServiceTrigger.class))).andReturn(new Date());\n\t\t\n\t\treplay(scheduler, pollService, pollerFrontEnd);\n\t\t\n\t\tpoller.setScheduler(scheduler);\n\t\tpoller.setPollerFrontEnd(pollerFrontEnd);\n\t\t\n\t\tpoller.afterPropertiesSet();\n\t\t\n\t\tverify(scheduler, pollService, pollerFrontEnd);\n\t\t\n\t}","id":102826,"modified_method":"public void testSchedule() throws Exception {\n        testSchedule(false);\n    }","commit_id":"4e06d24cafb891df31bbe13354c5377a7197291a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.unavailable();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n\n        // Retrieve this interface's SNMP peer object\n        //\n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n\n        // Get configuration parameters\n        //\n        String oid = ParameterMap.getKeyedString(parameters, \"oid\", DEFAULT_OBJECT_IDENTIFIER);\n        String operator = ParameterMap.getKeyedString(parameters, \"operator\", null);\n        String operand = ParameterMap.getKeyedString(parameters, \"operand\", null);\n        String walkstr = ParameterMap.getKeyedString(parameters, \"walk\", \"false\");\n\n        // set timeout and retries on SNMP peer object\n        //\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retries\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n\n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        // Establish SNMP session with interface\n        //\n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"SnmpMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId snmpObjectId = SnmpObjId.get(oid);\n\n            if (\"true\".equals(walkstr)) {\n                List<SnmpValue> results = SnmpUtils.getColumns(agentConfig, \"snmpPoller\", snmpObjectId);\n                for(SnmpValue result : results) {\n\n                    if (result != null) {\n                        log().debug(\"poll: SNMPwalk poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid + \" value=\" + result);\n                        if (meetsCriteria(result, operator, operand)) {\n                            status = PollStatus.available();\n                        }\n                    } else {\n                        status = logDown(Level.DEBUG, \"SNMP poll failed, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid);\n                        return status;\n                    }\n                }\n\n            } else {\n\n                SnmpValue result = SnmpUtils.get(agentConfig, snmpObjectId);\n\n                if (result != null) {\n                    log().debug(\"poll: SNMP poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid + \" value=\" + result);\n                    status = (meetsCriteria(result, operator, operand) ? PollStatus.available() : PollStatus.unavailable());\n                } else {\n                    status = logDown(Level.DEBUG, \"SNMP poll failed, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid);\n                }\n            }\n\n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","id":102827,"modified_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.unavailable();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n\n        // Retrieve this interface's SNMP peer object\n        //\n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n\n        // Get configuration parameters\n        //\n        String oid = ParameterMap.getKeyedString(parameters, \"oid\", DEFAULT_OBJECT_IDENTIFIER);\n        String operator = ParameterMap.getKeyedString(parameters, \"operator\", null);\n        String operand = ParameterMap.getKeyedString(parameters, \"operand\", null);\n        String walkstr = ParameterMap.getKeyedString(parameters, \"walk\", \"false\");\n\n        // set timeout and retries on SNMP peer object\n        //\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n\n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        // Establish SNMP session with interface\n        //\n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"SnmpMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId snmpObjectId = SnmpObjId.get(oid);\n\n            if (\"true\".equals(walkstr)) {\n                List<SnmpValue> results = SnmpUtils.getColumns(agentConfig, \"snmpPoller\", snmpObjectId);\n                for(SnmpValue result : results) {\n\n                    if (result != null) {\n                        log().debug(\"poll: SNMPwalk poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid + \" value=\" + result);\n                        if (meetsCriteria(result, operator, operand)) {\n                            status = PollStatus.available();\n                        }\n                    } else {\n                        status = logDown(Level.DEBUG, \"SNMP poll failed, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid);\n                        return status;\n                    }\n                }\n\n            } else {\n\n                SnmpValue result = SnmpUtils.get(agentConfig, snmpObjectId);\n\n                if (result != null) {\n                    log().debug(\"poll: SNMP poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid + \" value=\" + result);\n                    status = (meetsCriteria(result, operator, operand) ? PollStatus.available() : PollStatus.unavailable());\n                } else {\n                    status = logDown(Level.DEBUG, \"SNMP poll failed, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid);\n                }\n            }\n\n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","commit_id":"4e06d24cafb891df31bbe13354c5377a7197291a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        int matchType = MATCH_TYPE_EXACT;\n        \n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.available();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n        \n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n        \n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retries\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n        \n        String diskName = ParameterMap.getKeyedString(parameters, \"disk\", null);\n        Integer percentFree = ParameterMap.getKeyedInteger(parameters, \"free\", 15);\n        \n        String matchTypeStr = ParameterMap.getKeyedString(parameters, \"match-type\", \"exact\");\n        if (matchTypeStr.equalsIgnoreCase(\"exact\")) {\n            matchType = MATCH_TYPE_EXACT; \n        } else if (matchTypeStr.equalsIgnoreCase(\"startswith\")) {\n            matchType = MATCH_TYPE_STARTSWITH;\n        } else if (matchTypeStr.equalsIgnoreCase(\"endswith\")) {\n            matchType = MATCH_TYPE_ENDSWITH;\n        } else if (matchTypeStr.equalsIgnoreCase(\"regex\")) {\n            matchType = MATCH_TYPE_REGEX;\n        } else {\n            throw new RuntimeException(\"Unknown value '\" + matchTypeStr + \"' for parameter 'match-type'\");\n        }\n        \n        log().debug(\"diskName=\" + diskName);\n        log().debug(\"percentfree=\" + percentFree);\n        log().debug(\"matchType=\" + matchTypeStr);\n        \n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        \n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"DiskUsageMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId hrStorageDescrSnmpObject = SnmpObjId.get(hrStorageDescr);\n            \n            \n            \n            Map<SnmpInstId, SnmpValue> flagResults = SnmpUtils.getOidValues(agentConfig, \"DiskUsagePoller\", hrStorageDescrSnmpObject);\n            \n            if(flagResults.size() == 0) {\n                log().debug(\"SNMP poll failed: no results, addr=\" + ipaddr.getHostAddress() + \" oid=\" + hrStorageDescrSnmpObject);\n                return PollStatus.unavailable();\n            }\n\n            for (Map.Entry<SnmpInstId, SnmpValue> e : flagResults.entrySet()) { \n                log().debug(\"poll: SNMPwalk poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + hrStorageDescrSnmpObject + \" instance=\" + e.getKey() + \" value=\" + e.getValue());\n                \n                if (isMatch(e.getValue().toString(), diskName, matchType)) {\n                \tlog().debug(\"DiskUsageMonitor.poll: found disk=\" + diskName);\n                \t\n                \tSnmpObjId hrStorageSizeSnmpObject = SnmpObjId.get(hrStorageSize + \".\" + e.getKey().toString());\n                \tSnmpObjId hrStorageUsedSnmpObject = SnmpObjId.get(hrStorageUsed + \".\" + e.getKey().toString());\n                \t\n                \t\n                \tSnmpValue snmpSize = SnmpUtils.get(agentConfig, hrStorageSizeSnmpObject);\n                \tSnmpValue snmpUsed = SnmpUtils.get(agentConfig, hrStorageUsedSnmpObject);\n                \tfloat calculatedPercentage = ( (( (float)snmpSize.toLong() - (float)snmpUsed.toLong() ) / (float)snmpSize.toLong() ) ) * 100;\n                \n                \tlog().debug(\"DiskUsageMonitor: calculatedPercentage=\" + calculatedPercentage + \" percentFree=\"+percentFree);\n                \t\n                \tif (calculatedPercentage < percentFree) {\n                \t\n                \t\treturn PollStatus.unavailable(diskName + \" usage high (\" + (100 - (int)calculatedPercentage)  + \"%)\");\n                \t\t\n                \t}\n                \telse {\n                \t\treturn status;\n                \t}\n                }\n            \n                 \n            }\n\n            // if we get here.. it means we did not find the disk...  which means we should not be monitoring it.\n            log().debug(\"DiskUsageMonitor: no disks found\");\n            return PollStatus.unavailable(\"could not find \" + diskName + \"in table\");\n            \n            \n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","id":102828,"modified_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        int matchType = MATCH_TYPE_EXACT;\n        \n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.available();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n        \n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n        \n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n        \n        String diskName = ParameterMap.getKeyedString(parameters, \"disk\", null);\n        Integer percentFree = ParameterMap.getKeyedInteger(parameters, \"free\", 15);\n        \n        String matchTypeStr = ParameterMap.getKeyedString(parameters, \"match-type\", \"exact\");\n        if (matchTypeStr.equalsIgnoreCase(\"exact\")) {\n            matchType = MATCH_TYPE_EXACT; \n        } else if (matchTypeStr.equalsIgnoreCase(\"startswith\")) {\n            matchType = MATCH_TYPE_STARTSWITH;\n        } else if (matchTypeStr.equalsIgnoreCase(\"endswith\")) {\n            matchType = MATCH_TYPE_ENDSWITH;\n        } else if (matchTypeStr.equalsIgnoreCase(\"regex\")) {\n            matchType = MATCH_TYPE_REGEX;\n        } else {\n            throw new RuntimeException(\"Unknown value '\" + matchTypeStr + \"' for parameter 'match-type'\");\n        }\n        \n        log().debug(\"diskName=\" + diskName);\n        log().debug(\"percentfree=\" + percentFree);\n        log().debug(\"matchType=\" + matchTypeStr);\n        \n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        \n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"DiskUsageMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId hrStorageDescrSnmpObject = SnmpObjId.get(hrStorageDescr);\n            \n            \n            \n            Map<SnmpInstId, SnmpValue> flagResults = SnmpUtils.getOidValues(agentConfig, \"DiskUsagePoller\", hrStorageDescrSnmpObject);\n            \n            if(flagResults.size() == 0) {\n                log().debug(\"SNMP poll failed: no results, addr=\" + ipaddr.getHostAddress() + \" oid=\" + hrStorageDescrSnmpObject);\n                return PollStatus.unavailable();\n            }\n\n            for (Map.Entry<SnmpInstId, SnmpValue> e : flagResults.entrySet()) { \n                log().debug(\"poll: SNMPwalk poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + hrStorageDescrSnmpObject + \" instance=\" + e.getKey() + \" value=\" + e.getValue());\n                \n                if (isMatch(e.getValue().toString(), diskName, matchType)) {\n                \tlog().debug(\"DiskUsageMonitor.poll: found disk=\" + diskName);\n                \t\n                \tSnmpObjId hrStorageSizeSnmpObject = SnmpObjId.get(hrStorageSize + \".\" + e.getKey().toString());\n                \tSnmpObjId hrStorageUsedSnmpObject = SnmpObjId.get(hrStorageUsed + \".\" + e.getKey().toString());\n                \t\n                \t\n                \tSnmpValue snmpSize = SnmpUtils.get(agentConfig, hrStorageSizeSnmpObject);\n                \tSnmpValue snmpUsed = SnmpUtils.get(agentConfig, hrStorageUsedSnmpObject);\n                \tfloat calculatedPercentage = ( (( (float)snmpSize.toLong() - (float)snmpUsed.toLong() ) / (float)snmpSize.toLong() ) ) * 100;\n                \n                \tlog().debug(\"DiskUsageMonitor: calculatedPercentage=\" + calculatedPercentage + \" percentFree=\"+percentFree);\n                \t\n                \tif (calculatedPercentage < percentFree) {\n                \t\n                \t\treturn PollStatus.unavailable(diskName + \" usage high (\" + (100 - (int)calculatedPercentage)  + \"%)\");\n                \t\t\n                \t}\n                \telse {\n                \t\treturn status;\n                \t}\n                }\n            \n                 \n            }\n\n            // if we get here.. it means we did not find the disk...  which means we should not be monitoring it.\n            log().debug(\"DiskUsageMonitor: no disks found\");\n            return PollStatus.unavailable(\"could not find \" + diskName + \"in table\");\n            \n            \n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","commit_id":"d8efabe301004a188fcedc1259a0fce40dacc6f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * <\/p>\n     * \n     * <p>\n     * In addition, the input qualifiers map also provides information about how\n     * the plugin should contact the remote server. The plugin may check the\n     * qualifier map for specific elements and then adjust its behavior as\n     * necessary\n     * <\/p>\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map<String, Object> qualifiers) {\n        int port = DEFAULT_PORT;\n        int timeout = DEFAULT_TIMEOUT;\n        int retries = DEFAULT_RETRY;\n        String lookup = DEFAULT_LOOKUP;\n        if (qualifiers != null) {\n            port = ParameterMap.getKeyedInteger(qualifiers, \"port\", DEFAULT_PORT);\n            timeout = ParameterMap.getKeyedInteger(qualifiers, \"timeout\", DEFAULT_TIMEOUT);\n            retries = ParameterMap.getKeyedInteger(qualifiers, \"retries\", DEFAULT_RETRY);\n            lookup = ParameterMap.getKeyedString(qualifiers, \"lookup\", DEFAULT_LOOKUP);\n        }\n\n        boolean result = isServer(address, port, retries, timeout, lookup);\n        if (result && qualifiers != null && !qualifiers.containsKey(\"port\"))\n            qualifiers.put(\"port\", new Integer(port));\n\n        return result;\n    }","id":102829,"modified_method":"/**\n     * <p>\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * <\/p>\n     * \n     * <p>\n     * In addition, the input qualifiers map also provides information about how\n     * the plugin should contact the remote server. The plugin may check the\n     * qualifier map for specific elements and then adjust its behavior as\n     * necessary\n     * <\/p>\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map<String, Object> qualifiers) {\n        int port = DEFAULT_PORT;\n        int timeout = DEFAULT_TIMEOUT;\n        int retries = DEFAULT_RETRY;\n        String lookup = DEFAULT_LOOKUP;\n        if (qualifiers != null) {\n            port = ParameterMap.getKeyedInteger(qualifiers, \"port\", DEFAULT_PORT);\n            timeout = ParameterMap.getKeyedInteger(qualifiers, \"timeout\", DEFAULT_TIMEOUT);\n            retries = ParameterMap.getKeyedInteger(qualifiers, \"retry\", DEFAULT_RETRY);\n            lookup = ParameterMap.getKeyedString(qualifiers, \"lookup\", DEFAULT_LOOKUP);\n        }\n\n        boolean result = isServer(address, port, retries, timeout, lookup);\n        if (result && qualifiers != null && !qualifiers.containsKey(\"port\"))\n            qualifiers.put(\"port\", new Integer(port));\n\n        return result;\n    }","commit_id":"d8efabe301004a188fcedc1259a0fce40dacc6f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Poll the specified address for FTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port (by\n     * default TCP port 21). If the connection request is successful, the banner\n     * line generated by the interface is parsed and if the extracted return\n     * code indicates that we are talking to an FTP server we continue. Next, an\n     * FTP 'QUIT' command is sent. Provided that the interface's response is\n     * valid we set the service status to SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Check the interface type\n        if (iface.getType() != NetworkInterface.TYPE_IPV4) {\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n        }\n\n        // Get the parameters\n        TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n        int port = ParameterMap.getKeyedInteger(parameters, \"port\", DEFAULT_PORT);\n        String userid = ParameterMap.getKeyedString(parameters, \"userid\", null);\n        String password = ParameterMap.getKeyedString(parameters, \"password\", null);\n\n        // Extract the address\n        InetAddress ipv4Addr = (InetAddress) iface.getAddress();\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"FtpMonitor.poll: Polling interface: \" + ipv4Addr.getHostAddress() + tracker);\n        }\n\n        PollStatus serviceStatus = PollStatus.unavailable();\n        for (tracker.reset(); tracker.shouldRetry() && !serviceStatus.isAvailable(); tracker.nextAttempt()) {\n            Socket socket = null;\n            try {\n                // create a connected socket\n                tracker.startAttempt();\n\n                socket = new Socket();\n                socket.connect(new InetSocketAddress(ipv4Addr, port), tracker.getConnectionTimeout());\n                socket.setSoTimeout(tracker.getSoTimeout());\n                log().debug(\"FtpMonitor: connected to host: \" + ipv4Addr + \" on port: \" + port);\n\n                // We're connected, so upgrade status to unresponsive\n                serviceStatus = PollStatus.unresponsive();\n\n                BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                \n                FtpResponse bannerResponse = FtpResponse.readResponse(lineRdr);\n\n                if (bannerResponse.isSuccess()) {\n                    // Attempt to login if userid and password available\n                    boolean loggedInSuccessfully = false;\n                    if (userid == null || userid.length() == 0 || password == null || password.length() == 0) {\n                        loggedInSuccessfully = true;\n                    } else {\n                        FtpResponse.sendCommand(socket, \"USER \" + userid);\n\n                        FtpResponse userResponse = FtpResponse.readResponse(lineRdr);\n\n                        if (userResponse.isSuccess()) {\n                            FtpResponse.sendCommand(socket, \"PASS \" + password);\n                            \n                            FtpResponse passResponse = FtpResponse.readResponse(lineRdr);\n                            if (passResponse.isSuccess()) {\n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"FtpMonitor.poll: Login successful, parsed return code: \" + passResponse.getCode());\n                                }\n                                loggedInSuccessfully = true;\n                            } else {\n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"FtpMonitor.poll: Login failed, parsed return code: \" + passResponse.getCode() + \", full response: \" + passResponse.toString());\n                                }\n                                loggedInSuccessfully = false;\n                            }\n                        }\n                    }\n\n                    // Store the response time before we try to quit\n                    double responseTime = tracker.elapsedTimeInMillis();\n\n                    if (loggedInSuccessfully) {\n                        FtpResponse.sendCommand(socket, \"QUIT\");\n\n                        FtpResponse quitResponse = FtpResponse.readResponse(lineRdr);\n\n                        /*\n                         * Special Cases for success:\n                         * \n                         * Also want to accept the following\n                         * ERROR message generated by some FTP servers\n                         * following a QUIT command without a previous\n                         * successful login:\n                         *\n                         * \"530 QUIT : User not logged in. Please login with\n                         * USER and PASS first.\"\n                         * \n                         * Also want to accept the following ERROR\n                         * message generated by some FTP servers following a\n                         * QUIT command without a previously successful login:\n                         *\n                         * \"425 Session is disconnected.\"\n                         */\n                        if (quitResponse.isSuccess()\n                                || (quitResponse.getCode() == 530 && (quitResponse.responseContains(FTP_ERROR_530_TEXT) || quitResponse.responseContains(FTP_ERROR_530_TEXT2)))\n                                || (quitResponse.getCode() == 425 && quitResponse.responseContains(FTP_ERROR_425_TEXT))) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                    }\n                }\n\n                /*\n                 * If we get this far and the status has not been set\n                 * to available, then something didn't verify during\n                 * the banner checking or login/QUIT command process.\n                 */\n                if (!serviceStatus.isAvailable()) {\n                    serviceStatus = PollStatus.unavailable();\n                }\n            } catch (NumberFormatException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"NumberFormatException while polling address: \" + ipv4Addr, e);\n            } catch (NoRouteToHostException e) {\n            \tserviceStatus = logDown(Level.WARN, \"No route to host exception for address: \" + ipv4Addr, e);\n            } catch (InterruptedIOException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"did not connect to host with \" + tracker);\n            } catch (ConnectException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"Connection exception for address: \" + ipv4Addr, e);\n            } catch (IOException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"IOException while polling address: \" + ipv4Addr, e);\n            } finally {\n                try {\n                    // Close the socket\n                    if (socket != null) {\n                        socket.close();\n                    }\n                } catch (IOException e) {\n                    log().debug(\"FtpMonitor.poll: Error closing socket: \" + e, e);\n                }\n            }\n        }\n\n        return serviceStatus;\n    }","id":102830,"modified_method":"/**\n     * Poll the specified address for FTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port (by\n     * default TCP port 21). If the connection request is successful, the banner\n     * line generated by the interface is parsed and if the extracted return\n     * code indicates that we are talking to an FTP server we continue. Next, an\n     * FTP 'QUIT' command is sent. Provided that the interface's response is\n     * valid we set the service status to SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Check the interface type\n        if (iface.getType() != NetworkInterface.TYPE_IPV4) {\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n        }\n\n        // Get the parameters\n        TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n        int port = ParameterMap.getKeyedInteger(parameters, \"port\", DEFAULT_PORT);\n        String userid = ParameterMap.getKeyedString(parameters, \"userid\", null);\n        String password = ParameterMap.getKeyedString(parameters, \"password\", null);\n\n        // Extract the address\n        InetAddress ipv4Addr = (InetAddress) iface.getAddress();\n\n        PollStatus serviceStatus = PollStatus.unavailable();\n        for (tracker.reset(); tracker.shouldRetry() && !serviceStatus.isAvailable(); tracker.nextAttempt()) {\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"FtpMonitor.poll: Polling interface: \" + ipv4Addr.getHostAddress() + tracker);\n            }\n\n            Socket socket = null;\n            try {\n                // create a connected socket\n                tracker.startAttempt();\n\n                socket = new Socket();\n                socket.connect(new InetSocketAddress(ipv4Addr, port), tracker.getConnectionTimeout());\n                socket.setSoTimeout(tracker.getSoTimeout());\n                log().debug(\"FtpMonitor: connected to host: \" + ipv4Addr + \" on port: \" + port);\n\n                // We're connected, so upgrade status to unresponsive\n                serviceStatus = PollStatus.unresponsive();\n\n                BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                \n                FtpResponse bannerResponse = FtpResponse.readResponse(lineRdr);\n\n                if (bannerResponse.isSuccess()) {\n                    // Attempt to login if userid and password available\n                    boolean loggedInSuccessfully = false;\n                    log().debug(\"FtpMonitor: Banner response successful.\");\n                    if (userid == null || userid.length() == 0 || password == null || password.length() == 0) {\n                        loggedInSuccessfully = true;\n                    } else {\n                        FtpResponse.sendCommand(socket, \"USER \" + userid);\n\n                        FtpResponse userResponse = FtpResponse.readResponse(lineRdr);\n\n                        if (userResponse.isSuccess() || userResponse.isIntermediate()) {\n                            log().debug(\"FtpMonitor: User response successful.\");\n                            FtpResponse.sendCommand(socket, \"PASS \" + password);\n                            \n                            FtpResponse passResponse = FtpResponse.readResponse(lineRdr);\n                            if (passResponse.isSuccess()) {\n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"FtpMonitor.poll: Login successful, parsed return code: \" + passResponse.getCode());\n                                }\n                                loggedInSuccessfully = true;\n                            } else {\n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"FtpMonitor.poll: Login failed, parsed return code: \" + passResponse.getCode() + \", full response: \" + passResponse.toString());\n                                }\n                                loggedInSuccessfully = false;\n                            }\n                        }\n                    }\n\n                    // Store the response time before we try to quit\n                    double responseTime = tracker.elapsedTimeInMillis();\n\n                    if (loggedInSuccessfully) {\n                        FtpResponse.sendCommand(socket, \"QUIT\");\n\n                        FtpResponse quitResponse = FtpResponse.readResponse(lineRdr);\n\n                        /*\n                         * Special Cases for success:\n                         * \n                         * Also want to accept the following\n                         * ERROR message generated by some FTP servers\n                         * following a QUIT command without a previous\n                         * successful login:\n                         *\n                         * \"530 QUIT : User not logged in. Please login with\n                         * USER and PASS first.\"\n                         * \n                         * Also want to accept the following ERROR\n                         * message generated by some FTP servers following a\n                         * QUIT command without a previously successful login:\n                         *\n                         * \"425 Session is disconnected.\"\n                         */\n                        if (quitResponse.isSuccess()\n                                || (quitResponse.getCode() == 530 && (quitResponse.responseContains(FTP_ERROR_530_TEXT) || quitResponse.responseContains(FTP_ERROR_530_TEXT2)))\n                                || (quitResponse.getCode() == 425 && quitResponse.responseContains(FTP_ERROR_425_TEXT))) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                    }\n                }\n\n                /*\n                 * If we get this far and the status has not been set\n                 * to available, then something didn't verify during\n                 * the banner checking or login/QUIT command process.\n                 */\n                if (!serviceStatus.isAvailable()) {\n                    serviceStatus = PollStatus.unavailable();\n                }\n            } catch (NumberFormatException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"NumberFormatException while polling address: \" + ipv4Addr, e);\n            } catch (NoRouteToHostException e) {\n            \tserviceStatus = logDown(Level.WARN, \"No route to host exception for address: \" + ipv4Addr, e);\n            } catch (InterruptedIOException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"did not connect to host with \" + tracker);\n            } catch (ConnectException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"Connection exception for address: \" + ipv4Addr, e);\n            } catch (IOException e) {\n            \tserviceStatus = logDown(Level.DEBUG, \"IOException while polling address: \" + ipv4Addr, e);\n            } finally {\n                try {\n                    // Close the socket\n                    if (socket != null) {\n                        socket.close();\n                    }\n                } catch (IOException e) {\n                    log().debug(\"FtpMonitor.poll: Error closing socket: \" + e, e);\n                }\n            }\n        }\n\n        return serviceStatus;\n    }","commit_id":"d8efabe301004a188fcedc1259a0fce40dacc6f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * <\/p>\n     * \n     * <p>\n     * In addition, the input qualifiers map also provides information about how\n     * the plugin should contact the remote server. The plugin may check the\n     * qualifier map for specific elements and then adjust its behavior as\n     * necessary\n     * <\/p>\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map<String, Object> qualifiers) {\n        int port = DEFAULT_PORT;\n        int timeout = DEFAULT_TIMEOUT;\n        int retries = DEFAULT_RETRY;\n        if (qualifiers != null) {\n            port = ParameterMap.getKeyedInteger(qualifiers, \"port\", DEFAULT_PORT);\n            timeout = ParameterMap.getKeyedInteger(qualifiers, \"timeout\", DEFAULT_TIMEOUT);\n            retries = ParameterMap.getKeyedInteger(qualifiers, \"retries\", DEFAULT_RETRY);\n        }\n\n        boolean result = isServer(address, port, retries, timeout);\n        if (result && qualifiers != null && !qualifiers.containsKey(\"port\"))\n            qualifiers.put(\"port\", new Integer(port));\n\n        return result;\n    }","id":102831,"modified_method":"/**\n     * <p>\n     * Returns true if the protocol defined by this plugin is supported. If the\n     * protocol is not supported then a false value is returned to the caller.\n     * The qualifier map passed to the method is used by the plugin to return\n     * additional information by key-name. These key-value pairs can be added to\n     * service events if needed.\n     * <\/p>\n     * \n     * <p>\n     * In addition, the input qualifiers map also provides information about how\n     * the plugin should contact the remote server. The plugin may check the\n     * qualifier map for specific elements and then adjust its behavior as\n     * necessary\n     * <\/p>\n     * \n     * @param address\n     *            The address to check for support.\n     * @param qualifiers\n     *            The map where qualification are set by the plugin.\n     * \n     * @return True if the protocol is supported by the address.\n     */\n    public boolean isProtocolSupported(InetAddress address, Map<String, Object> qualifiers) {\n        int port = DEFAULT_PORT;\n        int timeout = DEFAULT_TIMEOUT;\n        int retries = DEFAULT_RETRY;\n        if (qualifiers != null) {\n            port = ParameterMap.getKeyedInteger(qualifiers, \"port\", DEFAULT_PORT);\n            timeout = ParameterMap.getKeyedInteger(qualifiers, \"timeout\", DEFAULT_TIMEOUT);\n            retries = ParameterMap.getKeyedInteger(qualifiers, \"retry\", DEFAULT_RETRY);\n        }\n\n        boolean result = isServer(address, port, retries, timeout);\n        if (result && qualifiers != null && !qualifiers.containsKey(\"port\"))\n            qualifiers.put(\"port\", new Integer(port));\n\n        return result;\n    }","commit_id":"d8efabe301004a188fcedc1259a0fce40dacc6f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private SnmpAgentConfig configureAgent(Map parameters, NetworkInterface iface, InetAddress ipaddr) throws RuntimeException {\n\t\tSnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(snmpAgentConfigKey);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retries\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n\t\treturn agentConfig;\n\t}","id":102832,"modified_method":"private SnmpAgentConfig configureAgent(Map parameters, NetworkInterface iface, InetAddress ipaddr) throws RuntimeException {\n\t\tSnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(snmpAgentConfigKey);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n\t\treturn agentConfig;\n\t}","commit_id":"d8efabe301004a188fcedc1259a0fce40dacc6f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.unavailable();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n\n        // Retrieve this interface's SNMP peer object\n        //\n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n\n        // Get configuration parameters\n        //\n        // set timeout and retries on SNMP peer object\n        //\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retries\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n        \n        String arrayNumber = ParameterMap.getKeyedString(parameters,\"array\",\"0.0\");\n\n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        // Establish SNMP session with interface\n        //\n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"PercMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId snmpObjectId = SnmpObjId.get(LOGICAL_BASE_OID + \".\" + arrayNumber);\n\n            // First walk the physical OID Tree and check the returned values \n\n            String returnValue = new String(); \n          \n            SnmpValue value = SnmpUtils.get(agentConfig,snmpObjectId);\n            \n            if (value.toInt()!=2){\n            \tlog().debug(\"PercMonitor.poll: Bad Disk Found\");\n            \treturnValue = \"log vol(\" + arrayNumber + \") degraded\"; // XXX should degraded be the virtualDiskState ?\n            \t// array is bad\n            \t// lets find out which disks are bad in the array\n            \t\n            \t// first we need to fetch the arrayPosition table.\n            \tSnmpObjId arrayPositionSnmpObject = SnmpObjId.get(ARRAY_POSITION_BASE_OID);\n            \tSnmpObjId diskStatesSnmpObject = SnmpObjId.get(PHYSICAL_BASE_OID); \n            \t\n            \tMap<SnmpInstId,SnmpValue> arrayDisks = SnmpUtils.getOidValues(agentConfig, \"PercMonitor\", arrayPositionSnmpObject);\n            \tMap<SnmpInstId,SnmpValue> diskStates = SnmpUtils.getOidValues(agentConfig, \"PercMonitor\", diskStatesSnmpObject);\n            \t\n            \tfor (Map.Entry<SnmpInstId, SnmpValue> disk: arrayDisks.entrySet()) {\n            \t\t\n            \t\tif (disk.getValue().toString().contains(\"A\" + arrayNumber.toString() + \"-\")) {\n            \t\t\t// this is a member of the array\n            \t\t\t\n            \t\t\tif ( diskStates.get(disk.getKey()).toInt() !=3 ){\n            \t\t\t\t// this is bad disk.\n            \t\t\t\t\n            \t\t\t\treturnValue  += \"phy drv(\" + disk.getKey().toString() + \")\";\n            \t\t\t\t\n            \t\t\t}\n            \t\t\t\n            \t\t}\n            \n            \t\treturn PollStatus.unavailable(returnValue);\n            \t}\n            \t\n            \t\n            }\n        \n            status = PollStatus.available();\n            \n\n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","id":102833,"modified_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.unavailable();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n\n        // Retrieve this interface's SNMP peer object\n        //\n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n\n        // Get configuration parameters\n        //\n        // set timeout and retries on SNMP peer object\n        //\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n        \n        String arrayNumber = ParameterMap.getKeyedString(parameters,\"array\",\"0.0\");\n\n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        // Establish SNMP session with interface\n        //\n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"PercMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId snmpObjectId = SnmpObjId.get(LOGICAL_BASE_OID + \".\" + arrayNumber);\n\n            // First walk the physical OID Tree and check the returned values \n\n            String returnValue = new String(); \n          \n            SnmpValue value = SnmpUtils.get(agentConfig,snmpObjectId);\n            \n            if (value.toInt()!=2){\n            \tlog().debug(\"PercMonitor.poll: Bad Disk Found\");\n            \treturnValue = \"log vol(\" + arrayNumber + \") degraded\"; // XXX should degraded be the virtualDiskState ?\n            \t// array is bad\n            \t// lets find out which disks are bad in the array\n            \t\n            \t// first we need to fetch the arrayPosition table.\n            \tSnmpObjId arrayPositionSnmpObject = SnmpObjId.get(ARRAY_POSITION_BASE_OID);\n            \tSnmpObjId diskStatesSnmpObject = SnmpObjId.get(PHYSICAL_BASE_OID); \n            \t\n            \tMap<SnmpInstId,SnmpValue> arrayDisks = SnmpUtils.getOidValues(agentConfig, \"PercMonitor\", arrayPositionSnmpObject);\n            \tMap<SnmpInstId,SnmpValue> diskStates = SnmpUtils.getOidValues(agentConfig, \"PercMonitor\", diskStatesSnmpObject);\n            \t\n            \tfor (Map.Entry<SnmpInstId, SnmpValue> disk: arrayDisks.entrySet()) {\n            \t\t\n            \t\tif (disk.getValue().toString().contains(\"A\" + arrayNumber.toString() + \"-\")) {\n            \t\t\t// this is a member of the array\n            \t\t\t\n            \t\t\tif ( diskStates.get(disk.getKey()).toInt() !=3 ){\n            \t\t\t\t// this is bad disk.\n            \t\t\t\t\n            \t\t\t\treturnValue  += \"phy drv(\" + disk.getKey().toString() + \")\";\n            \t\t\t\t\n            \t\t\t}\n            \t\t\t\n            \t\t}\n            \n            \t\treturn PollStatus.unavailable(returnValue);\n            \t}\n            \t\n            \t\n            }\n        \n            status = PollStatus.available();\n            \n\n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","commit_id":"d8efabe301004a188fcedc1259a0fce40dacc6f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void schedulePolls() throws Exception {\n        \n        log().debug(\"Enter schedulePolls\");\n\t\t\n\t\tCollection<PolledService> polledServices = m_pollerFrontEnd.getPolledServices();\n\n\t\tif (polledServices == null || polledServices.size() == 0) {\n\t\t\tlog().warn(\"No polling scheduled.\");\n            log().debug(\"Exit schedulePolls\");\n\t\t\treturn;\n\t\t}\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tlong scheduleSpacing = m_initialSpreadTime / polledServices.size();\n\n        for (PolledService polledService : polledServices) {\n\t\t\t\n\t\t\tDate initialPollTime = new Date(startTime);\n\t\t\t\n\t\t\tm_pollerFrontEnd.setInitialPollTime(polledService.getServiceId(), initialPollTime);\n\t\t\t\n\t\t\tTrigger pollTrigger = new PolledServiceTrigger(polledService);\n\t\t\tpollTrigger.setStartTime(initialPollTime);\n\t\t\t\n\t\t\tPollJobDetail jobDetail = new PollJobDetail(polledService.toString(), PollJob.class);\n\t\t\tjobDetail.setPolledService(polledService);\n\t\t\tjobDetail.setPollerFrontEnd(m_pollerFrontEnd);\n\t\t\t\n            log().debug(\"Scheduling job for \"+polledService);\n            \n\t\t\tm_scheduler.scheduleJob(jobDetail, pollTrigger);\n\t\t\t\n\t\t\tstartTime += scheduleSpacing;\n\t\t}\n\t\t\n        log().debug(\"Exit schedulePolls\");\n\t\t\n\t}","id":102834,"modified_method":"private void schedulePolls() throws Exception {\n        \n        log().debug(\"Enter schedulePolls\");\n\t\t\n\t\tCollection<PolledService> polledServices = m_pollerFrontEnd.getPolledServices();\n\n\t\tif (polledServices == null || polledServices.size() == 0) {\n\t\t\tlog().warn(\"No polling scheduled.\");\n            log().debug(\"Exit schedulePolls\");\n\t\t\treturn;\n\t\t}\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tlong scheduleSpacing = m_initialSpreadTime / polledServices.size();\n\t\t\n        for (PolledService polledService : polledServices) {\n            \n            String jobName = polledService.toString();\n\n            // remove any currently scheduled job\n            if (m_scheduler.deleteJob(jobName, PollJobDetail.GROUP)) {\n                log().debug(String.format(\"Job for %s already scheduled.  Rescheduling\", polledService));\n            } else {\n                log().debug(\"Scheduling job for \"+polledService);\n            }\n\t\t\t\n\t\t\tDate initialPollTime = new Date(startTime);\n\t\t\t\n\t\t\tm_pollerFrontEnd.setInitialPollTime(polledService.getServiceId(), initialPollTime);\n\t\t\t\n\t\t\tTrigger pollTrigger = new PolledServiceTrigger(polledService);\n\t\t\tpollTrigger.setStartTime(initialPollTime);\n\t\t\t\n            PollJobDetail jobDetail = new PollJobDetail(jobName, PollJob.class);\n\t\t\tjobDetail.setPolledService(polledService);\n\t\t\tjobDetail.setPollerFrontEnd(m_pollerFrontEnd);\n\t\t\t\n            \n\t\t\tm_scheduler.scheduleJob(jobDetail, pollTrigger);\n\t\t\t\n\t\t\tstartTime += scheduleSpacing;\n\t\t}\n\t\t\n        log().debug(\"Exit schedulePolls\");\n\t\t\n\t}","commit_id":"d8efabe301004a188fcedc1259a0fce40dacc6f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testSchedule() throws Exception {\n\t\t\n\t\tScheduler scheduler = createMock(Scheduler.class);\n\t\tPollService pollService = createNiceMock(PollService.class);\n\t\tPollerFrontEnd pollerFrontEnd = createMock(PollerFrontEnd.class);\n\t\t\n\t\tOnmsMonitoredService svc = getMonitoredService();\n        svc.setId(7);\n\t\t\n\t\tPollConfiguration pollConfig = new PollConfiguration(svc, new HashMap(), 300000);\n\t\t\n\t\tPolledService polledService = new PolledService(pollConfig.getMonitoredService(), pollConfig.getMonitorConfiguration(), pollConfig.getPollModel());\n\t\t\n\t\tSet<PolledService> polledServices = Collections.singleton(polledService);\n\n        Poller poller = new Poller();\n\n        pollerFrontEnd.addConfigurationChangedListener(poller);\n        pollerFrontEnd.addPropertyChangeListener(poller);\n\t\texpect(pollerFrontEnd.getPolledServices()).andReturn(polledServices);\n        expect(pollerFrontEnd.isStarted()).andReturn(true);\n\t\tpollerFrontEnd.setInitialPollTime(eq(svc.getId()), isA(Date.class));\n\t\texpect(scheduler.scheduleJob(isA(PollJobDetail.class), isA(PolledServiceTrigger.class))).andReturn(new Date());\n\t\t\n\t\treplay(scheduler, pollService, pollerFrontEnd);\n\t\t\n\t\tpoller.setScheduler(scheduler);\n\t\tpoller.setPollerFrontEnd(pollerFrontEnd);\n\t\t\n\t\tpoller.afterPropertiesSet();\n\t\t\n\t\tverify(scheduler, pollService, pollerFrontEnd);\n\t\t\n\t}","id":102835,"modified_method":"public void testSchedule() throws Exception {\n        testSchedule(false);\n    }","commit_id":"d8efabe301004a188fcedc1259a0fce40dacc6f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.unavailable();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n\n        // Retrieve this interface's SNMP peer object\n        //\n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n\n        // Get configuration parameters\n        //\n        String oid = ParameterMap.getKeyedString(parameters, \"oid\", DEFAULT_OBJECT_IDENTIFIER);\n        String operator = ParameterMap.getKeyedString(parameters, \"operator\", null);\n        String operand = ParameterMap.getKeyedString(parameters, \"operand\", null);\n        String walkstr = ParameterMap.getKeyedString(parameters, \"walk\", \"false\");\n\n        // set timeout and retries on SNMP peer object\n        //\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retries\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n\n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        // Establish SNMP session with interface\n        //\n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"SnmpMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId snmpObjectId = SnmpObjId.get(oid);\n\n            if (\"true\".equals(walkstr)) {\n                List<SnmpValue> results = SnmpUtils.getColumns(agentConfig, \"snmpPoller\", snmpObjectId);\n                for(SnmpValue result : results) {\n\n                    if (result != null) {\n                        log().debug(\"poll: SNMPwalk poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid + \" value=\" + result);\n                        if (meetsCriteria(result, operator, operand)) {\n                            status = PollStatus.available();\n                        }\n                    } else {\n                        status = logDown(Level.DEBUG, \"SNMP poll failed, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid);\n                        return status;\n                    }\n                }\n\n            } else {\n\n                SnmpValue result = SnmpUtils.get(agentConfig, snmpObjectId);\n\n                if (result != null) {\n                    log().debug(\"poll: SNMP poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid + \" value=\" + result);\n                    status = (meetsCriteria(result, operator, operand) ? PollStatus.available() : PollStatus.unavailable());\n                } else {\n                    status = logDown(Level.DEBUG, \"SNMP poll failed, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid);\n                }\n            }\n\n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","id":102836,"modified_method":"/**\n     * <P>\n     * The poll() method is responsible for polling the specified address for\n     * SNMP service availability.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be supressed.\n     * \n     * @exception RuntimeException\n     *                Thrown for any uncrecoverable errors.\n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        PollStatus status = PollStatus.unavailable();\n        InetAddress ipaddr = (InetAddress) iface.getAddress();\n\n        // Retrieve this interface's SNMP peer object\n        //\n        SnmpAgentConfig agentConfig = (SnmpAgentConfig) iface.getAttribute(SNMP_AGENTCONFIG_KEY);\n        if (agentConfig == null) throw new RuntimeException(\"SnmpAgentConfig object not available for interface \" + ipaddr);\n\n        // Get configuration parameters\n        //\n        String oid = ParameterMap.getKeyedString(parameters, \"oid\", DEFAULT_OBJECT_IDENTIFIER);\n        String operator = ParameterMap.getKeyedString(parameters, \"operator\", null);\n        String operand = ParameterMap.getKeyedString(parameters, \"operand\", null);\n        String walkstr = ParameterMap.getKeyedString(parameters, \"walk\", \"false\");\n\n        // set timeout and retries on SNMP peer object\n        //\n        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, \"timeout\", agentConfig.getTimeout()));\n        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, \"retry\", agentConfig.getRetries()));\n        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, \"port\", agentConfig.getPort()));\n\n        if (log().isDebugEnabled()) log().debug(\"poll: service= SNMP address= \" + agentConfig);\n\n        // Establish SNMP session with interface\n        //\n        try {\n            if (log().isDebugEnabled()) {\n                log().debug(\"SnmpMonitor.poll: SnmpAgentConfig address: \" +agentConfig);\n            }\n            SnmpObjId snmpObjectId = SnmpObjId.get(oid);\n\n            if (\"true\".equals(walkstr)) {\n                List<SnmpValue> results = SnmpUtils.getColumns(agentConfig, \"snmpPoller\", snmpObjectId);\n                for(SnmpValue result : results) {\n\n                    if (result != null) {\n                        log().debug(\"poll: SNMPwalk poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid + \" value=\" + result);\n                        if (meetsCriteria(result, operator, operand)) {\n                            status = PollStatus.available();\n                        }\n                    } else {\n                        status = logDown(Level.DEBUG, \"SNMP poll failed, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid);\n                        return status;\n                    }\n                }\n\n            } else {\n\n                SnmpValue result = SnmpUtils.get(agentConfig, snmpObjectId);\n\n                if (result != null) {\n                    log().debug(\"poll: SNMP poll succeeded, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid + \" value=\" + result);\n                    status = (meetsCriteria(result, operator, operand) ? PollStatus.available() : PollStatus.unavailable());\n                } else {\n                    status = logDown(Level.DEBUG, \"SNMP poll failed, addr=\" + ipaddr.getHostAddress() + \" oid=\" + oid);\n                }\n            }\n\n        } catch (NumberFormatException e) {\n            status = logDown(Level.ERROR, \"Number operator used on a non-number \" + e.getMessage());\n        } catch (IllegalArgumentException e) {\n            status = logDown(Level.ERROR, \"Invalid Snmp Criteria: \" + e.getMessage());\n        } catch (Throwable t) {\n            status = logDown(Level.WARN, \"Unexpected exception during SNMP poll of interface \" + ipaddr.getHostAddress(), t);\n        }\n\n        return status;\n    }","commit_id":"d8efabe301004a188fcedc1259a0fce40dacc6f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        pmFavourites = new javax.swing.JPopupMenu();\n        miRemoveFavourite = new javax.swing.JMenuItem();\n        jSeparator2 = new javax.swing.JPopupMenu.Separator();\n        miImportFavourites = new javax.swing.JMenuItem();\n        miExportFavourites = new javax.swing.JMenuItem();\n        lblExistLogo = new javax.swing.JLabel();\n        lblUsername = new javax.swing.JLabel();\n        lblPassword = new javax.swing.JLabel();\n        lblConnectionType = new javax.swing.JLabel();\n        cmbConnectionType = new javax.swing.JComboBox();\n        txtUsername = new javax.swing.JTextField();\n        txtPassword = new javax.swing.JPasswordField();\n        tpConnectionType = new javax.swing.JTabbedPane();\n        tpConnectionType.setUI(new javax.swing.plaf.basic.BasicTabbedPaneUI(){\n\n            @Override\n            protected final void paintContentBorder(final java.awt.Graphics g, final int tabPlacement, final int selectedIndex) {\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintContentBorderBottomEdge(final java.awt.Graphics g, final int tabPlacement, final int selectedIndex, final int x, final int y, int w, final int h) {\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintContentBorderLeftEdge(final java.awt.Graphics g, final int tabPlacement, final int selectedIndex, final int x, final int y, int w, final int h) {\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintContentBorderRightEdge(final java.awt.Graphics g, final int tabPlacement, final int selectedIndex, final int x, final int y, int w, final int h) {\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintContentBorderTopEdge(final java.awt.Graphics g, final int tabPlacement, final int selectedIndex, final int x, int y, final int w, final int h) {\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintFocusIndicator(final java.awt.Graphics g, final int tabPlacement, final java.awt.Rectangle[] rects, final int tabIndex, final java.awt.Rectangle iconRect, final java.awt.Rectangle textRect, final boolean isSelected) {\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintTab(final java.awt.Graphics g, final int tabPlacement, final java.awt.Rectangle[] rects, final int tabIndex, final java.awt.Rectangle iconRect, final java.awt.Rectangle textRect) {\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintTabArea(final java.awt.Graphics g, final int tabPlacement, final int selectedIndex){\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintTabBackground(final Graphics g, final int tabPlacement, final int tabIndex, final int x, final int y, final int w, final int h, final boolean isSelected) {\n            }\n\n            @Override\n            protected final void paintTabBorder(final java.awt.Graphics g, final int tabPlacement, final int tabIndex, final int x, final int y, final int w, final int h, final boolean isSelected) {\n                //dont paint tabs!\n            }\n        });\n        panRemote = new javax.swing.JPanel();\n        lblServerUri = new javax.swing.JLabel();\n        txtServerUri = new javax.swing.JTextField();\n        chkSsl = new javax.swing.JCheckBox();\n        panEmbedded = new javax.swing.JPanel();\n        lblConfiguration = new javax.swing.JLabel();\n        txtConfiguration = new javax.swing.JTextField();\n        btnSelectConfiguration = new javax.swing.JButton();\n        panFavourites = new javax.swing.JPanel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        lstFavourites = new javax.swing.JList();\n        btnSaveToFavourites = new javax.swing.JButton();\n        btnClose = new javax.swing.JButton();\n        btnConnect = new javax.swing.JButton();\n        jSeparator1 = new javax.swing.JSeparator();\n\n        miRemoveFavourite.setText(\"Remove\");\n        miRemoveFavourite.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                miRemoveFavouriteActionPerformed(evt);\n            }\n        });\n        pmFavourites.add(miRemoveFavourite);\n        pmFavourites.add(jSeparator2);\n\n        miImportFavourites.setText(\"Import Favourites...\");\n        miImportFavourites.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                miImportFavouritesActionPerformed(evt);\n            }\n        });\n        pmFavourites.add(miImportFavourites);\n\n        miExportFavourites.setText(\"Export Favourites...\");\n        miExportFavourites.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                miExportFavouritesActionPerformed(evt);\n            }\n        });\n        pmFavourites.add(miExportFavourites);\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);\n        setTitle(\"Database Connection\");\n\n        lblExistLogo.setIcon(InteractiveClient.getExistIcon(getClass()));\n\n        lblUsername.setText(getLabelText(\"LoginPanel.2\"));\n\n        lblPassword.setText(getLabelText(\"LoginPanel.3\"));\n\n        lblConnectionType.setText(getLabelText(\"LoginPanel.4\"));\n\n        cmbConnectionType.setModel(getConnectionTypeModel());\n        cmbConnectionType.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                cmbConnectionTypeActionPerformed(evt);\n            }\n        });\n\n        txtUsername.setText(getDefaultConnectionSettings().getUsername());\n\n        tpConnectionType.setTabPlacement(javax.swing.JTabbedPane.RIGHT);\n\n        lblServerUri.setText(getLabelText(\"LoginPanel.12\"));\n\n        txtServerUri.setText(getDefaultConnectionSettings().getUri());\n\n        chkSsl.setSelected(getDefaultConnectionSettings().isSsl());\n        chkSsl.setText(getLabel(\"LoginPanel.47\"));\n\n        final javax.swing.GroupLayout panRemoteLayout = new javax.swing.GroupLayout(panRemote);\n        panRemote.setLayout(panRemoteLayout);\n        panRemoteLayout.setHorizontalGroup(\n            panRemoteLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(panRemoteLayout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(lblServerUri)\n                .addGap(63, 63, 63)\n                .addGroup(panRemoteLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(chkSsl)\n                    .addComponent(txtServerUri, javax.swing.GroupLayout.PREFERRED_SIZE, 336, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n        panRemoteLayout.setVerticalGroup(\n            panRemoteLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panRemoteLayout.createSequentialGroup()\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addGroup(panRemoteLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblServerUri)\n                    .addComponent(txtServerUri, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(chkSsl)\n                .addGap(25, 25, 25))\n        );\n\n        tpConnectionType.addTab(\"tab3\", panRemote);\n\n        lblConfiguration.setText(getLabelText(\"LoginPanel.8\"));\n\n        txtConfiguration.setEditable(false);\n        txtConfiguration.setText(config.getAbsolutePath());\n        txtConfiguration.setToolTipText(getLabel(\"LoginPanel.9\"));\n\n        btnSelectConfiguration.setText(\"...\");\n        btnSelectConfiguration.setToolTipText(getLabel(\"LoginPanel.11\"));\n        btnSelectConfiguration.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnSelectConfigurationActionPerformed(evt);\n            }\n        });\n\n        final javax.swing.GroupLayout panEmbeddedLayout = new javax.swing.GroupLayout(panEmbedded);\n        panEmbedded.setLayout(panEmbeddedLayout);\n        panEmbeddedLayout.setHorizontalGroup(\n            panEmbeddedLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(panEmbeddedLayout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(lblConfiguration)\n                .addGap(33, 33, 33)\n                .addComponent(txtConfiguration, javax.swing.GroupLayout.DEFAULT_SIZE, 313, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(btnSelectConfiguration, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap())\n        );\n        panEmbeddedLayout.setVerticalGroup(\n            panEmbeddedLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panEmbeddedLayout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(panEmbeddedLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblConfiguration)\n                    .addComponent(txtConfiguration, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(btnSelectConfiguration, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap(30, Short.MAX_VALUE))\n        );\n\n        tpConnectionType.addTab(\"tab2\", panEmbedded);\n\n        panFavourites.setBorder(javax.swing.BorderFactory.createTitledBorder(getLabel(\"LoginPanel.14\")));\n\n        lstFavourites.setModel(getFavouritesModel());\n        lstFavourites.setComponentPopupMenu(pmFavourites);\n        lstFavourites.addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mouseClicked(java.awt.event.MouseEvent evt) {\n                lstFavouritesMouseClicked(evt);\n            }\n        });\n        jScrollPane1.setViewportView(lstFavourites);\n\n        btnSaveToFavourites.setText(getLabel(\"LoginPanel.17\"));\n        btnSaveToFavourites.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnSaveToFavouritesActionPerformed(evt);\n            }\n        });\n\n        final javax.swing.GroupLayout panFavouritesLayout = new javax.swing.GroupLayout(panFavourites);\n        panFavourites.setLayout(panFavouritesLayout);\n        panFavouritesLayout.setHorizontalGroup(\n            panFavouritesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(panFavouritesLayout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(panFavouritesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 463, Short.MAX_VALUE)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panFavouritesLayout.createSequentialGroup()\n                        .addGap(0, 0, Short.MAX_VALUE)\n                        .addComponent(btnSaveToFavourites)))\n                .addContainerGap())\n        );\n        panFavouritesLayout.setVerticalGroup(\n            panFavouritesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(panFavouritesLayout.createSequentialGroup()\n                .addComponent(btnSaveToFavourites)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 143, Short.MAX_VALUE)\n                .addContainerGap())\n        );\n\n        btnClose.setText(getLabel(\"LoginPanel.51\"));\n        btnClose.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnCloseActionPerformed(evt);\n            }\n        });\n\n        btnConnect.setText(getLabel(\"LoginPanel.50\"));\n        btnConnect.addKeyListener(new EnterKeyAdapter());\n        btnConnect.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnConnectActionPerformed(evt);\n            }\n        });\n\n        final javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addGap(0, 0, Short.MAX_VALUE)\n                        .addComponent(btnClose)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(btnConnect))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(8, 8, 8)\n                                .addComponent(lblExistLogo, javax.swing.GroupLayout.PREFERRED_SIZE, 113, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addGap(18, 18, 18)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(panFavourites, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addComponent(tpConnectionType, javax.swing.GroupLayout.PREFERRED_SIZE, 527, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addComponent(lblUsername)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                            .addComponent(lblConnectionType)\n                                            .addComponent(lblPassword))\n                                        .addGap(18, 18, 18)\n                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                                            .addComponent(cmbConnectionType, javax.swing.GroupLayout.PREFERRED_SIZE, 122, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                            .addComponent(txtUsername)\n                                            .addComponent(txtPassword, javax.swing.GroupLayout.PREFERRED_SIZE, 300, javax.swing.GroupLayout.PREFERRED_SIZE)))))\n                            .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 666, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addGap(0, 0, Short.MAX_VALUE)))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(14, 14, 14)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(lblUsername)\n                            .addComponent(txtUsername, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addGap(18, 18, 18)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(lblPassword)\n                            .addComponent(txtPassword, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addGap(26, 26, 26)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(lblConnectionType)\n                            .addComponent(cmbConnectionType, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(22, 22, 22)\n                        .addComponent(lblExistLogo, javax.swing.GroupLayout.PREFERRED_SIZE, 108, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(tpConnectionType, javax.swing.GroupLayout.PREFERRED_SIZE, 86, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(panFavourites, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(btnClose)\n                    .addComponent(btnConnect))\n                .addContainerGap(35, Short.MAX_VALUE))\n        );\n\n        pack();\n    }","id":102837,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        pmFavourites = new javax.swing.JPopupMenu();\n        miRemoveFavourite = new javax.swing.JMenuItem();\n        jSeparator2 = new javax.swing.JPopupMenu.Separator();\n        miImportFavourites = new javax.swing.JMenuItem();\n        miExportFavourites = new javax.swing.JMenuItem();\n        lblExistLogo = new javax.swing.JLabel();\n        lblUsername = new javax.swing.JLabel();\n        lblPassword = new javax.swing.JLabel();\n        lblConnectionType = new javax.swing.JLabel();\n        cmbConnectionType = new javax.swing.JComboBox();\n        txtUsername = new javax.swing.JTextField();\n        txtPassword = new javax.swing.JPasswordField();\n        tpConnectionType = new javax.swing.JTabbedPane();\n        tpConnectionType.setUI(new javax.swing.plaf.basic.BasicTabbedPaneUI(){\n\n            @Override\n            protected final void paintContentBorder(final java.awt.Graphics g, final int tabPlacement, final int selectedIndex) {\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintContentBorderBottomEdge(final java.awt.Graphics g, final int tabPlacement, final int selectedIndex, final int x, final int y, int w, final int h) {\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintContentBorderLeftEdge(final java.awt.Graphics g, final int tabPlacement, final int selectedIndex, final int x, final int y, int w, final int h) {\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintContentBorderRightEdge(final java.awt.Graphics g, final int tabPlacement, final int selectedIndex, final int x, final int y, int w, final int h) {\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintContentBorderTopEdge(final java.awt.Graphics g, final int tabPlacement, final int selectedIndex, final int x, int y, final int w, final int h) {\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintFocusIndicator(final java.awt.Graphics g, final int tabPlacement, final java.awt.Rectangle[] rects, final int tabIndex, final java.awt.Rectangle iconRect, final java.awt.Rectangle textRect, final boolean isSelected) {\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintTab(final java.awt.Graphics g, final int tabPlacement, final java.awt.Rectangle[] rects, final int tabIndex, final java.awt.Rectangle iconRect, final java.awt.Rectangle textRect) {\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintTabArea(final java.awt.Graphics g, final int tabPlacement, final int selectedIndex){\n                //dont paint tabs!\n            }\n\n            @Override\n            protected final void paintTabBackground(final Graphics g, final int tabPlacement, final int tabIndex, final int x, final int y, final int w, final int h, final boolean isSelected) {\n            }\n\n            @Override\n            protected final void paintTabBorder(final java.awt.Graphics g, final int tabPlacement, final int tabIndex, final int x, final int y, final int w, final int h, final boolean isSelected) {\n                //dont paint tabs!\n            }\n        });\n        panRemote = new javax.swing.JPanel();\n        lblServerUri = new javax.swing.JLabel();\n        txtServerUri = new javax.swing.JTextField();\n        chkSsl = new javax.swing.JCheckBox();\n        panEmbedded = new javax.swing.JPanel();\n        lblConfiguration = new javax.swing.JLabel();\n        txtConfiguration = new javax.swing.JTextField();\n        btnSelectConfiguration = new javax.swing.JButton();\n        panFavourites = new javax.swing.JPanel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        lstFavourites = new javax.swing.JList();\n        btnSaveToFavourites = new javax.swing.JButton();\n        btnClose = new javax.swing.JButton();\n        btnConnect = new javax.swing.JButton();\n        jSeparator1 = new javax.swing.JSeparator();\n\n        miRemoveFavourite.setText(\"Remove\");\n        miRemoveFavourite.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                miRemoveFavouriteActionPerformed(evt);\n            }\n        });\n        pmFavourites.add(miRemoveFavourite);\n        pmFavourites.add(jSeparator2);\n\n        miImportFavourites.setText(\"Import Favourites...\");\n        miImportFavourites.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                miImportFavouritesActionPerformed(evt);\n            }\n        });\n        pmFavourites.add(miImportFavourites);\n\n        miExportFavourites.setText(\"Export Favourites...\");\n        miExportFavourites.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                miExportFavouritesActionPerformed(evt);\n            }\n        });\n        pmFavourites.add(miExportFavourites);\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);\n        setTitle(\"Database Connection\");\n\n        lblExistLogo.setIcon(InteractiveClient.getExistIcon(getClass()));\n\n        lblUsername.setText(getLabelText(\"LoginPanel.2\"));\n\n        lblPassword.setText(getLabelText(\"LoginPanel.3\"));\n\n        lblConnectionType.setText(getLabelText(\"LoginPanel.4\"));\n\n        cmbConnectionType.setModel(getConnectionTypeModel());\n        cmbConnectionType.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                cmbConnectionTypeActionPerformed(evt);\n            }\n        });\n\n        txtUsername.setText(getDefaultConnectionSettings().getUsername());\n\n        tpConnectionType.setTabPlacement(javax.swing.JTabbedPane.RIGHT);\n\n        lblServerUri.setText(getLabelText(\"LoginPanel.12\"));\n\n        txtServerUri.setText(getDefaultConnectionSettings().getUri());\n\n        chkSsl.setSelected(getDefaultConnectionSettings().isSsl());\n        chkSsl.setText(getLabel(\"LoginPanel.47\"));\n\n        javax.swing.GroupLayout panRemoteLayout = new javax.swing.GroupLayout(panRemote);\n        panRemote.setLayout(panRemoteLayout);\n        panRemoteLayout.setHorizontalGroup(\n            panRemoteLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(panRemoteLayout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(lblServerUri)\n                .addGap(63, 63, 63)\n                .addGroup(panRemoteLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(chkSsl)\n                    .addComponent(txtServerUri, javax.swing.GroupLayout.PREFERRED_SIZE, 336, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n        panRemoteLayout.setVerticalGroup(\n            panRemoteLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panRemoteLayout.createSequentialGroup()\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addGroup(panRemoteLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblServerUri)\n                    .addComponent(txtServerUri, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(chkSsl)\n                .addGap(25, 25, 25))\n        );\n\n        tpConnectionType.addTab(\"tab3\", panRemote);\n\n        lblConfiguration.setText(getLabelText(\"LoginPanel.8\"));\n\n        txtConfiguration.setEditable(false);\n        txtConfiguration.setText(config.getAbsolutePath());\n        txtConfiguration.setToolTipText(getLabel(\"LoginPanel.9\"));\n\n        btnSelectConfiguration.setText(\"...\");\n        btnSelectConfiguration.setToolTipText(getLabel(\"LoginPanel.11\"));\n        btnSelectConfiguration.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnSelectConfigurationActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout panEmbeddedLayout = new javax.swing.GroupLayout(panEmbedded);\n        panEmbedded.setLayout(panEmbeddedLayout);\n        panEmbeddedLayout.setHorizontalGroup(\n            panEmbeddedLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(panEmbeddedLayout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(lblConfiguration)\n                .addGap(33, 33, 33)\n                .addComponent(txtConfiguration, javax.swing.GroupLayout.DEFAULT_SIZE, 279, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(btnSelectConfiguration, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap())\n        );\n        panEmbeddedLayout.setVerticalGroup(\n            panEmbeddedLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panEmbeddedLayout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(panEmbeddedLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblConfiguration)\n                    .addComponent(txtConfiguration, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(btnSelectConfiguration, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap(38, Short.MAX_VALUE))\n        );\n\n        tpConnectionType.addTab(\"tab2\", panEmbedded);\n\n        panFavourites.setBorder(javax.swing.BorderFactory.createTitledBorder(getLabel(\"LoginPanel.14\")));\n\n        lstFavourites.setModel(getFavouritesModel());\n        lstFavourites.setComponentPopupMenu(pmFavourites);\n        lstFavourites.addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mouseClicked(java.awt.event.MouseEvent evt) {\n                lstFavouritesMouseClicked(evt);\n            }\n        });\n        jScrollPane1.setViewportView(lstFavourites);\n\n        btnSaveToFavourites.setText(getLabel(\"LoginPanel.17\"));\n        btnSaveToFavourites.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnSaveToFavouritesActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout panFavouritesLayout = new javax.swing.GroupLayout(panFavourites);\n        panFavourites.setLayout(panFavouritesLayout);\n        panFavouritesLayout.setHorizontalGroup(\n            panFavouritesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(panFavouritesLayout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(panFavouritesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 463, Short.MAX_VALUE)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panFavouritesLayout.createSequentialGroup()\n                        .addGap(0, 0, Short.MAX_VALUE)\n                        .addComponent(btnSaveToFavourites)))\n                .addContainerGap())\n        );\n        panFavouritesLayout.setVerticalGroup(\n            panFavouritesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(panFavouritesLayout.createSequentialGroup()\n                .addComponent(btnSaveToFavourites)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 143, Short.MAX_VALUE)\n                .addContainerGap())\n        );\n\n        btnClose.setText(getLabel(\"LoginPanel.51\"));\n        btnClose.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnCloseActionPerformed(evt);\n            }\n        });\n\n        btnConnect.setText(getLabel(\"LoginPanel.50\"));\n        btnConnect.addKeyListener(new EnterKeyAdapter());\n        btnConnect.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnConnectActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addGap(0, 0, Short.MAX_VALUE)\n                        .addComponent(btnClose)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(btnConnect))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(8, 8, 8)\n                                .addComponent(lblExistLogo, javax.swing.GroupLayout.PREFERRED_SIZE, 113, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addGap(18, 18, 18)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(panFavourites, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addComponent(tpConnectionType, javax.swing.GroupLayout.PREFERRED_SIZE, 527, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                                            .addComponent(lblPassword, javax.swing.GroupLayout.DEFAULT_SIZE, 110, Short.MAX_VALUE)\n                                            .addComponent(lblConnectionType, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                                        .addGap(6, 6, 6)\n                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                            .addComponent(txtPassword, javax.swing.GroupLayout.PREFERRED_SIZE, 270, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                            .addComponent(txtUsername, javax.swing.GroupLayout.PREFERRED_SIZE, 270, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                            .addComponent(cmbConnectionType, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                                    .addComponent(lblUsername, javax.swing.GroupLayout.PREFERRED_SIZE, 115, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                            .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 666, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addGap(0, 0, Short.MAX_VALUE)))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(14, 14, 14)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(lblUsername)\n                            .addComponent(txtUsername, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addGap(18, 18, 18)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(lblPassword)\n                            .addComponent(txtPassword, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addGap(26, 26, 26)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(lblConnectionType)\n                            .addComponent(cmbConnectionType, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(22, 22, 22)\n                        .addComponent(lblExistLogo, javax.swing.GroupLayout.PREFERRED_SIZE, 108, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(tpConnectionType, javax.swing.GroupLayout.PREFERRED_SIZE, 86, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(panFavourites, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(btnClose)\n                    .addComponent(btnConnect))\n                .addContainerGap(35, Short.MAX_VALUE))\n        );\n\n        pack();\n    }","commit_id":"f04894e1dc47055763801a1f712fc190ef1ca5ec","url":"https://github.com/eXist-db/exist"},{"original_method":"private Grid addClusterEntry ( int row, ClusterInfoWeb clusterInfo, final StorageInfoWeb storageInfo)\n\t{\n\t\tGrid g = new Grid (18, 2);\n\t\tg.setStyleName( \"euca-table\" );\n\t\tif (row > 0) {\n\t\t\tg.setStyleName( \"euca-nonfirst-cluster-entry\" );\n\t\t}\n\t\tg.setCellPadding( 4 );\n\n\t\tint i = 0; // row 1\n\t\tg.setWidget( i, 0, new HTML( \"<b>Name:<\/b>\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal HorizontalPanel namePanel = new HorizontalPanel ();\n\t\tnamePanel.setSpacing (0);\n\n\t\tif (clusterInfo.isCommitted()) {\n\t\t\tnamePanel.add (new Label ( clusterInfo.getName() ));\n\t\t} else {\n\t\t\tfinal TextBox nb = new TextBox();\n\t\t\tnb.addChangeListener (new ChangeCallback (this, row));\n\t\t\tnb.setVisibleLength( 12 );\n\t\t\tnb.setText( clusterInfo.getName() );\n\t\t\tnb.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\t\tnamePanel.add ( nb );\n\t\t}\n\t\tnamePanel.add (new Button (\"Deregister Cluster\", new DeleteCallback( this, row )));\n\t\tg.setWidget ( i, 1, namePanel);\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 1, new Label( \"Cluster Controller\" ));\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Host:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox hb = new TextBox();\n\t\thb.addChangeListener (new ChangeCallback (this, row));\n\t\thb.setVisibleLength( 20 );\n\t\thb.setText( clusterInfo.getHost() );\n\t\thb.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget ( i, 1, hb );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Port:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox pb = new TextBox();\n\t\tpb.addChangeListener (new ChangeCallback (this, row));\n\t\tpb.setVisibleLength( 5 );\n\t\tpb.setText( \"\" + clusterInfo.getPort() );\n\t\tpb.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget( i, 1, pb );\n\n\t\tfinal TextBox reservedAddressesBox = new TextBox(); // declare here, set up after the checkbox later\n\n\t\ti++; // next row\n\t\tfinal CheckBox dynamicAddressesCheckbox = new CheckBox ();\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tg.setWidget (i, 0, dynamicAddressesCheckbox );\n\t\tif (systemConfig.isDoDynamicPublicAddresses()) {\n\t\t\tdynamicAddressesCheckbox.setChecked(true);\n\t\t\treservedAddressesBox.setEnabled(false);\n\t\t} else {\n\t\t\tdynamicAddressesCheckbox.setChecked(false);\n\t\t\treservedAddressesBox.setEnabled(true);\n\t\t}\n\t\tdynamicAddressesCheckbox.addClickListener (new ClickListener() {\n\t\t\tpublic void onClick( Widget sender )\n\t\t\t{\n\t\t\t\tif (((CheckBox)sender).isChecked()) {\n\t\t\t\t\treservedAddressesBox.setEnabled(false);\n\t\t\t\t\tsystemConfig.setDoDynamicPublicAddresses( true );\n\t\t\t\t} else {\n\t\t\t\t\treservedAddressesBox.setEnabled(true);\n\t\t\t\t\tsystemConfig.setDoDynamicPublicAddresses( false );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tg.setWidget( i, 1, new Label (\"Dynamic public IP address assignment\") );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Reserve for assignment\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\treservedAddressesBox.addChangeListener (new ChangeCallback (this, row));\n\t\treservedAddressesBox.setVisibleLength( 5 );\n\t\treservedAddressesBox.setText( \"\" + systemConfig.getSystemReservedPublicAddresses());\n\t\tfinal HorizontalPanel reservedAddressesPanel = new HorizontalPanel ();\n\t\treservedAddressesPanel.setSpacing(4);\n\t\treservedAddressesPanel.add (reservedAddressesBox);\n\t\treservedAddressesPanel.add (new HTML (\"public IP addresses\"));\n\t\treservedAddressesBox.setText(\"\"+systemConfig.getSystemReservedPublicAddresses());\n\t\tg.setWidget( i, 1, reservedAddressesPanel );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Maximum of\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox publicAddressesBox = new TextBox();\n\t\tpublicAddressesBox.addChangeListener (new ChangeCallback (this, row));\n\t\tpublicAddressesBox.setVisibleLength( 5 );\n\t\tpublicAddressesBox.setText( \"\" + systemConfig.getMaxUserPublicAddresses());\n\t\tfinal HorizontalPanel publicAddressesPanel = new HorizontalPanel ();\n\t\tpublicAddressesPanel.setSpacing(4);\n\t\tpublicAddressesPanel.add (publicAddressesBox);\n\t\tpublicAddressesPanel.add (new HTML (\"public IP addresses per user\"));\n\t\tg.setWidget( i, 1, publicAddressesPanel );\n\n\t\ti++;\n\t\tg.setWidget( i, 0, new Label( \"Use VLAN tags\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox minVlanBox = new TextBox();\n\t\tminVlanBox.addChangeListener (new ChangeCallback (this, row));\n\t\tminVlanBox.setVisibleLength( 4 );\n\t\tminVlanBox.setText(String.valueOf(clusterInfo.getMinVlans()));\n\t\tfinal TextBox maxVlanBox = new TextBox();\n\t\tmaxVlanBox.addChangeListener (new ChangeCallback (this, row));\n\t\tmaxVlanBox.setVisibleLength( 4 );\n\t\tmaxVlanBox.setText(String.valueOf(clusterInfo.getMaxVlans()));\n\t\tfinal HorizontalPanel vlanPanel = new HorizontalPanel ();\n\t\tvlanPanel.setSpacing(4);\n\t\tvlanPanel.add (minVlanBox);\n\t\tvlanPanel.add (new HTML (\"through\"));\n\t\tvlanPanel.add (maxVlanBox);\n\t\tg.setWidget( i, 1, vlanPanel );\n\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 1, new Label( \"Storage Controller\" ));\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Host:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox sb = new TextBox();\n\t\tsb.addChangeListener (new ChangeCallback (this, row));\n\t\tsb.setVisibleLength( 20 );\n\t\tsb.setText( storageInfo.getHost() ); \n\t\tsb.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget ( i, 1, sb );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Interface:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox sib = new TextBox();\n\t\tsib.addChangeListener (new ChangeCallback (this, row));\n\t\tsib.setVisibleLength( 5 );\n\t\tsib.setText( \"\" + storageInfo.getStorageInterface());\n\t\tsib.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget( i, 1, sib );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Volumes path:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox volumesPathBox = new TextBox();\n\t\tvolumesPathBox.addChangeListener (new ChangeCallback (this, row));\n\t\tvolumesPathBox.setVisibleLength( 30 );\n\t\tvolumesPathBox.setText( storageInfo.getVolumesPath() );\n\t\tvolumesPathBox.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget( i, 1, volumesPathBox );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Max volume size:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox volumeMaxBox = new TextBox();\n\t\tvolumeMaxBox.addChangeListener (new ChangeCallback (this, row));\n\t\tvolumeMaxBox.setVisibleLength( 5 );\n\t\tvolumeMaxBox.setText( \"\" + storageInfo.getMaxVolumeSizeInGB());\n\t\tvolumeMaxBox.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tfinal HorizontalPanel volumesMaxPanel = new HorizontalPanel ();\n\t\tvolumesMaxPanel.setSpacing(4);\n\t\tvolumesMaxPanel.add (volumeMaxBox);\n\t\tvolumesMaxPanel.add (new Label (\"GB\"));\n\t\tg.setWidget( i, 1, volumesMaxPanel );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Disk space reserved for volumes:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox volumesTotalBox = new TextBox();\n\t\tvolumesTotalBox.addChangeListener (new ChangeCallback (this, row));\n\t\tvolumesTotalBox.setVisibleLength( 5 );\n\t\tvolumesTotalBox.setText( \"\" + storageInfo.getTotalVolumesSizeInGB());\n\t\tvolumesTotalBox.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tfinal HorizontalPanel volumesTotalPanel = new HorizontalPanel ();\n\t\tvolumesTotalPanel.setSpacing(4);\n\t\tvolumesTotalPanel.add (volumesTotalBox);\n\t\tvolumesTotalPanel.add (new Label (\"GB\"));\n\t\tg.setWidget( i, 1, volumesTotalPanel );\n\n\t\ti++; // next row\n\t\tfinal CheckBox zeroFillVolumesCheckbox = new CheckBox ();\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tg.setWidget( i, 0, zeroFillVolumesCheckbox );\n\t\tif (storageInfo.getZeroFillVolumes()) {\n\t\t\tzeroFillVolumesCheckbox.setChecked(true);\n\t\t} else {\n\t\t\tzeroFillVolumesCheckbox.setChecked(false);\n\t\t}\n\t\tzeroFillVolumesCheckbox.addClickListener (new ClickListener() {\n\t\t\tpublic void onClick( Widget sender )\n\t\t\t{\n\t\t\t\tif (((CheckBox)sender).isChecked()) {\n\t\t\t\t\tstorageInfo.setZeroFillVolumes( true );\n\t\t\t\t} else {\n\t\t\t\t\tstorageInfo.setZeroFillVolumes( false );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tg.setWidget( i, 1, new Label (\"Zero-fill volumes\") );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"SAN Host:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox sanHostTextBox = new TextBox();\n\t\tsanHostTextBox.addChangeListener (new ChangeCallback (this, row));\n\t\tsanHostTextBox.setVisibleLength( 30 );\n\t\tsanHostTextBox.setText( storageInfo.getSanHost() );\n\t\tsanHostTextBox.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget( i, 1, sanHostTextBox );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"SAN User Name:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox sanUserBox = new TextBox();\n\t\tsanUserBox.addChangeListener (new ChangeCallback (this, row));\n\t\tsanUserBox.setVisibleLength( 30 );\n\t\tsanUserBox.setText( storageInfo.getSanUser() );\n\t\tsanUserBox.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget( i, 1, sanUserBox );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"SAN Password:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal PasswordTextBox sanPasswordBox = new PasswordTextBox();\n\t\tsanPasswordBox.addChangeListener (new ChangeCallback (this, row));\n\t\tsanPasswordBox.setVisibleLength( 30 );\n\t\tsanPasswordBox.setText( storageInfo.getSanPassword() );\n\t\tsanPasswordBox.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget( i, 1, sanPasswordBox );\n\t\t/*g.setWidget( i, 0, new Label( \"DAS Partition:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox dasPartitionBox = new TextBox();\n\t\tdasPartitionBox.addChangeListener (new ChangeCallback (this, row));\n\t\tdasPartitionBox.setVisibleLength( 5 );\n\t\tdasPartitionBox.setText( \"\" + storageInfo.getDASPartition());\n\t\tdasPartitionBox.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget( i, 1, dasPartitionBox );*/\n\n\t\treturn g;\n\t}","id":102838,"modified_method":"private Grid addClusterEntry ( int row, ClusterInfoWeb clusterInfo, final StorageInfoWeb storageInfo)\n\t{\n\t\tGrid g = new Grid (15, 2);\n\t\tg.setStyleName( \"euca-table\" );\n\t\tif (row > 0) {\n\t\t\tg.setStyleName( \"euca-nonfirst-cluster-entry\" );\n\t\t}\n\t\tg.setCellPadding( 4 );\n\n\t\tint i = 0; // row 1\n\t\tg.setWidget( i, 0, new HTML( \"<b>Name:<\/b>\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal HorizontalPanel namePanel = new HorizontalPanel ();\n\t\tnamePanel.setSpacing (0);\n\n\t\tif (clusterInfo.isCommitted()) {\n\t\t\tnamePanel.add (new Label ( clusterInfo.getName() ));\n\t\t} else {\n\t\t\tfinal TextBox nb = new TextBox();\n\t\t\tnb.addChangeListener (new ChangeCallback (this, row));\n\t\t\tnb.setVisibleLength( 12 );\n\t\t\tnb.setText( clusterInfo.getName() );\n\t\t\tnb.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\t\tnamePanel.add ( nb );\n\t\t}\n\t\tnamePanel.add (new Button (\"Deregister Cluster\", new DeleteCallback( this, row )));\n\t\tg.setWidget ( i, 1, namePanel);\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 1, new Label( \"Cluster Controller\" ));\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Host:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox hb = new TextBox();\n\t\thb.addChangeListener (new ChangeCallback (this, row));\n\t\thb.setVisibleLength( 20 );\n\t\thb.setText( clusterInfo.getHost() );\n\t\thb.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget ( i, 1, hb );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Port:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox pb = new TextBox();\n\t\tpb.addChangeListener (new ChangeCallback (this, row));\n\t\tpb.setVisibleLength( 5 );\n\t\tpb.setText( \"\" + clusterInfo.getPort() );\n\t\tpb.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget( i, 1, pb );\n\n\t\tfinal TextBox reservedAddressesBox = new TextBox(); // declare here, set up after the checkbox later\n\n\t\ti++; // next row\n\t\tfinal CheckBox dynamicAddressesCheckbox = new CheckBox ();\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tg.setWidget (i, 0, dynamicAddressesCheckbox );\n\t\tif (systemConfig.isDoDynamicPublicAddresses()) {\n\t\t\tdynamicAddressesCheckbox.setChecked(true);\n\t\t\treservedAddressesBox.setEnabled(false);\n\t\t} else {\n\t\t\tdynamicAddressesCheckbox.setChecked(false);\n\t\t\treservedAddressesBox.setEnabled(true);\n\t\t}\n\t\tdynamicAddressesCheckbox.addClickListener (new ClickListener() {\n\t\t\tpublic void onClick( Widget sender )\n\t\t\t{\n\t\t\t\tif (((CheckBox)sender).isChecked()) {\n\t\t\t\t\treservedAddressesBox.setEnabled(false);\n\t\t\t\t\tsystemConfig.setDoDynamicPublicAddresses( true );\n\t\t\t\t} else {\n\t\t\t\t\treservedAddressesBox.setEnabled(true);\n\t\t\t\t\tsystemConfig.setDoDynamicPublicAddresses( false );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tg.setWidget( i, 1, new Label (\"Dynamic public IP address assignment\") );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Reserve for assignment\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\treservedAddressesBox.addChangeListener (new ChangeCallback (this, row));\n\t\treservedAddressesBox.setVisibleLength( 5 );\n\t\treservedAddressesBox.setText( \"\" + systemConfig.getSystemReservedPublicAddresses());\n\t\tfinal HorizontalPanel reservedAddressesPanel = new HorizontalPanel ();\n\t\treservedAddressesPanel.setSpacing(4);\n\t\treservedAddressesPanel.add (reservedAddressesBox);\n\t\treservedAddressesPanel.add (new HTML (\"public IP addresses\"));\n\t\treservedAddressesBox.setText(\"\"+systemConfig.getSystemReservedPublicAddresses());\n\t\tg.setWidget( i, 1, reservedAddressesPanel );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Maximum of\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox publicAddressesBox = new TextBox();\n\t\tpublicAddressesBox.addChangeListener (new ChangeCallback (this, row));\n\t\tpublicAddressesBox.setVisibleLength( 5 );\n\t\tpublicAddressesBox.setText( \"\" + systemConfig.getMaxUserPublicAddresses());\n\t\tfinal HorizontalPanel publicAddressesPanel = new HorizontalPanel ();\n\t\tpublicAddressesPanel.setSpacing(4);\n\t\tpublicAddressesPanel.add (publicAddressesBox);\n\t\tpublicAddressesPanel.add (new HTML (\"public IP addresses per user\"));\n\t\tg.setWidget( i, 1, publicAddressesPanel );\n\n\t\ti++;\n\t\tg.setWidget( i, 0, new Label( \"Use VLAN tags\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox minVlanBox = new TextBox();\n\t\tminVlanBox.addChangeListener (new ChangeCallback (this, row));\n\t\tminVlanBox.setVisibleLength( 4 );\n\t\tminVlanBox.setText(String.valueOf(clusterInfo.getMinVlans()));\n\t\tfinal TextBox maxVlanBox = new TextBox();\n\t\tmaxVlanBox.addChangeListener (new ChangeCallback (this, row));\n\t\tmaxVlanBox.setVisibleLength( 4 );\n\t\tmaxVlanBox.setText(String.valueOf(clusterInfo.getMaxVlans()));\n\t\tfinal HorizontalPanel vlanPanel = new HorizontalPanel ();\n\t\tvlanPanel.setSpacing(4);\n\t\tvlanPanel.add (minVlanBox);\n\t\tvlanPanel.add (new HTML (\"through\"));\n\t\tvlanPanel.add (maxVlanBox);\n\t\tg.setWidget( i, 1, vlanPanel );\n\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 1, new Label( \"Storage Controller\" ));\n\n\t\t/*i++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Host:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox sb = new TextBox();\n\t\tsb.addChangeListener (new ChangeCallback (this, row));\n\t\tsb.setVisibleLength( 20 );\n\t\tsb.setText( storageInfo.getHost() ); \n\t\tsb.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget ( i, 1, sb );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Interface:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox sib = new TextBox();\n\t\tsib.addChangeListener (new ChangeCallback (this, row));\n\t\tsib.setVisibleLength( 5 );\n\t\tsib.setText( \"\" + storageInfo.getStorageInterface());\n\t\tsib.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget( i, 1, sib );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Volumes path:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox volumesPathBox = new TextBox();\n\t\tvolumesPathBox.addChangeListener (new ChangeCallback (this, row));\n\t\tvolumesPathBox.setVisibleLength( 30 );\n\t\tvolumesPathBox.setText( storageInfo.getVolumesPath() );\n\t\tvolumesPathBox.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget( i, 1, volumesPathBox );*/\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Max volume size:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox volumeMaxBox = new TextBox();\n\t\tvolumeMaxBox.addChangeListener (new ChangeCallback (this, row));\n\t\tvolumeMaxBox.setVisibleLength( 5 );\n\t\tvolumeMaxBox.setText( \"\" + storageInfo.getMaxVolumeSizeInGB());\n\t\tvolumeMaxBox.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tfinal HorizontalPanel volumesMaxPanel = new HorizontalPanel ();\n\t\tvolumesMaxPanel.setSpacing(4);\n\t\tvolumesMaxPanel.add (volumeMaxBox);\n\t\tvolumesMaxPanel.add (new Label (\"GB\"));\n\t\tg.setWidget( i, 1, volumesMaxPanel );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"Disk space reserved for volumes:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox volumesTotalBox = new TextBox();\n\t\tvolumesTotalBox.addChangeListener (new ChangeCallback (this, row));\n\t\tvolumesTotalBox.setVisibleLength( 5 );\n\t\tvolumesTotalBox.setText( \"\" + storageInfo.getTotalVolumesSizeInGB());\n\t\tvolumesTotalBox.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tfinal HorizontalPanel volumesTotalPanel = new HorizontalPanel ();\n\t\tvolumesTotalPanel.setSpacing(4);\n\t\tvolumesTotalPanel.add (volumesTotalBox);\n\t\tvolumesTotalPanel.add (new Label (\"GB\"));\n\t\tg.setWidget( i, 1, volumesTotalPanel );\n\n\t\t/*i++; // next row\n\t\tfinal CheckBox zeroFillVolumesCheckbox = new CheckBox ();\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tg.setWidget( i, 0, zeroFillVolumesCheckbox );\n\t\tif (storageInfo.getZeroFillVolumes()) {\n\t\t\tzeroFillVolumesCheckbox.setChecked(true);\n\t\t} else {\n\t\t\tzeroFillVolumesCheckbox.setChecked(false);\n\t\t}\n\t\tzeroFillVolumesCheckbox.addClickListener (new ClickListener() {\n\t\t\tpublic void onClick( Widget sender )\n\t\t\t{\n\t\t\t\tif (((CheckBox)sender).isChecked()) {\n\t\t\t\t\tstorageInfo.setZeroFillVolumes( true );\n\t\t\t\t} else {\n\t\t\t\t\tstorageInfo.setZeroFillVolumes( false );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tg.setWidget( i, 1, new Label (\"Zero-fill volumes\") );*/\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"SAN Host:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox sanHostTextBox = new TextBox();\n\t\tsanHostTextBox.addChangeListener (new ChangeCallback (this, row));\n\t\tsanHostTextBox.setVisibleLength( 30 );\n\t\tsanHostTextBox.setText( storageInfo.getSanHost() );\n\t\tsanHostTextBox.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget( i, 1, sanHostTextBox );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"SAN User Name:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox sanUserBox = new TextBox();\n\t\tsanUserBox.addChangeListener (new ChangeCallback (this, row));\n\t\tsanUserBox.setVisibleLength( 30 );\n\t\tsanUserBox.setText( storageInfo.getSanUser() );\n\t\tsanUserBox.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget( i, 1, sanUserBox );\n\n\t\ti++; // next row\n\t\tg.setWidget( i, 0, new Label( \"SAN Password:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal PasswordTextBox sanPasswordBox = new PasswordTextBox();\n\t\tsanPasswordBox.addChangeListener (new ChangeCallback (this, row));\n\t\tsanPasswordBox.setVisibleLength( 30 );\n\t\tsanPasswordBox.setText( storageInfo.getSanPassword() );\n\t\tsanPasswordBox.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget( i, 1, sanPasswordBox );\n\t\t/*g.setWidget( i, 0, new Label( \"DAS Partition:\" ) );\n\t\tg.getCellFormatter().setHorizontalAlignment(i, 0, HasHorizontalAlignment.ALIGN_RIGHT);\n\t\tfinal TextBox dasPartitionBox = new TextBox();\n\t\tdasPartitionBox.addChangeListener (new ChangeCallback (this, row));\n\t\tdasPartitionBox.setVisibleLength( 5 );\n\t\tdasPartitionBox.setText( \"\" + storageInfo.getDASPartition());\n\t\tdasPartitionBox.addFocusListener (new FocusHandler (this.hint, this.warningMessage));\n\t\tg.setWidget( i, 1, dasPartitionBox );*/\n\n\t\treturn g;\n\t}","commit_id":"a93f0dc357f35b74f3f0b18e563c591226fa1510","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void updateRow (int row)\n\t{\n\t\tClusterInfoWeb cluster = this.clusterList.get (row);\n\t\tStorageInfoWeb storage = this.storageList.get(row);\n\t\tGrid g = (Grid)this.grid.getWidget(row, 0);\n\t\tHorizontalPanel p = (HorizontalPanel)g.getWidget(0, 1);\n\t\tif (p.getWidget(0) instanceof TextBox) {\n\t\t\tcluster.setName (((TextBox)p.getWidget(0)).getText());\n\t\t\tstorage.setName (((TextBox)p.getWidget(0)).getText());\n\t\t} else {\n\t\t\tcluster.setName (((Label)p.getWidget(0)).getText());\n\t\t\tstorage.setName (((Label)p.getWidget(0)).getText());\n\t\t}\n\n\t\t// CC section\n\t\tcluster.setHost (((TextBox)g.getWidget(2, 1)).getText());\n\t\tcluster.setPort (Integer.parseInt(((TextBox)g.getWidget(3, 1)).getText()));\n\t\tp = (HorizontalPanel)g.getWidget(5, 1);\n\t\tsystemConfig.setSystemReservedPublicAddresses(Integer.parseInt(((TextBox)p.getWidget(0)).getText()));\n\t\tp = (HorizontalPanel)g.getWidget(6, 1);\n\t\tsystemConfig.setMaxUserPublicAddresses(Integer.parseInt(((TextBox)p.getWidget(0)).getText()));\n\t\tp = (HorizontalPanel)g.getWidget(7, 1);\n\t\tcluster.setMinVlans(Integer.parseInt(((TextBox)p.getWidget(0)).getText()));\n\t\tcluster.setMaxVlans(Integer.parseInt(((TextBox)p.getWidget(2)).getText()));\n\n\t\t// SC section\n\t\tstorage.setHost (((TextBox)g.getWidget(9, 1)).getText());\n\t\tstorage.setStorageInterface(((TextBox)g.getWidget(10, 1)).getText());\n\t\tstorage.setVolumesPath (((TextBox)g.getWidget(11, 1)).getText());\n\t\tp = (HorizontalPanel)g.getWidget(12, 1);\n\t\tstorage.setMaxVolumeSizeInGB (Integer.parseInt(((TextBox)p.getWidget(0)).getText()));\n\t\tp = (HorizontalPanel)g.getWidget(13, 1);\n\t\tstorage.setTotalVolumesSizeInGB((Integer.parseInt(((TextBox)p.getWidget(0)).getText())));\n\t\n\t\tstorage.setSanHost (((TextBox)g.getWidget(15, 1)).getText());\n\t\tstorage.setSanUser (((TextBox)g.getWidget(16, 1)).getText());\n\t\tstorage.setSanPassword (((TextBox)g.getWidget(17, 1)).getText());\n\n\t\t//storage.setDASPartition(((TextBox)g.getWidget(15, 1)).getText());\n\t\t//    systemConfig.setDoDynamicPublicAddresses( !((TextBox)p.getWidget(0)).isEnabled() ? true : false );\n\t}","id":102839,"modified_method":"public void updateRow (int row)\n\t{\n\t\tClusterInfoWeb cluster = this.clusterList.get (row);\n\t\tStorageInfoWeb storage = this.storageList.get(row);\n\t\tGrid g = (Grid)this.grid.getWidget(row, 0);\n\t\tHorizontalPanel p = (HorizontalPanel)g.getWidget(0, 1);\n\t\tif (p.getWidget(0) instanceof TextBox) {\n\t\t\tcluster.setName (((TextBox)p.getWidget(0)).getText());\n\t\t\tstorage.setName (((TextBox)p.getWidget(0)).getText());\n\t\t} else {\n\t\t\tcluster.setName (((Label)p.getWidget(0)).getText());\n\t\t\tstorage.setName (((Label)p.getWidget(0)).getText());\n\t\t}\n\n\t\t// CC section\n\t\tcluster.setHost (((TextBox)g.getWidget(2, 1)).getText());\n\t\tcluster.setPort (Integer.parseInt(((TextBox)g.getWidget(3, 1)).getText()));\n\t\tp = (HorizontalPanel)g.getWidget(5, 1);\n\t\tsystemConfig.setSystemReservedPublicAddresses(Integer.parseInt(((TextBox)p.getWidget(0)).getText()));\n\t\tp = (HorizontalPanel)g.getWidget(6, 1);\n\t\tsystemConfig.setMaxUserPublicAddresses(Integer.parseInt(((TextBox)p.getWidget(0)).getText()));\n\t\tp = (HorizontalPanel)g.getWidget(7, 1);\n\t\tcluster.setMinVlans(Integer.parseInt(((TextBox)p.getWidget(0)).getText()));\n\t\tcluster.setMaxVlans(Integer.parseInt(((TextBox)p.getWidget(2)).getText()));\n\n\t\t// SC section\n\t\t//storage.setHost (((TextBox)g.getWidget(9, 1)).getText());\n\t\t//storage.setStorageInterface(((TextBox)g.getWidget(10, 1)).getText());\n\t\t//storage.setVolumesPath (((TextBox)g.getWidget(11, 1)).getText());\n\t\tp = (HorizontalPanel)g.getWidget(9, 1);\n\t\tstorage.setMaxVolumeSizeInGB (Integer.parseInt(((TextBox)p.getWidget(0)).getText()));\n\t\tp = (HorizontalPanel)g.getWidget(10, 1);\n\t\tstorage.setTotalVolumesSizeInGB((Integer.parseInt(((TextBox)p.getWidget(0)).getText())));\n\t\n\t\tstorage.setSanHost (((TextBox)g.getWidget(11, 1)).getText());\n\t\tstorage.setSanUser (((TextBox)g.getWidget(12, 1)).getText());\n\t\tstorage.setSanPassword (((TextBox)g.getWidget(13, 1)).getText());\n\n\t\t//storage.setDASPartition(((TextBox)g.getWidget(15, 1)).getText());\n\t\t//    systemConfig.setDoDynamicPublicAddresses( !((TextBox)p.getWidget(0)).isEnabled() ? true : false );\n\t}","commit_id":"a93f0dc357f35b74f3f0b18e563c591226fa1510","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/** \n    * Flush out cached state at the end of a method.\n    */\n   private void flush() {\n\tif (systemGC != null && !sawCurrentTimeMillis) {\n\t\tbugReporter.reportBug(systemGC);\n\t}\n\n\tsawCurrentTimeMillis = false;\n\tsystemGC = null;\n\talreadyReported.clear();\n   }","id":102840,"modified_method":"/** \n    * Flush out cached state at the end of a method.\n    */\n   private void flush() {\n\tif (gcInvocationBugReport != null && !sawCurrentTimeMillis) {\n\t\t// Make sure the GC invocation is not in an exception handler\n\t\t// for OutOfMemoryError.\n\t\tboolean outOfMemoryHandler = false;\n\t\tfor (int i = 0; i < exceptionTable.length; ++i) {\n\t\t\tCodeException handler = exceptionTable[i];\n\t\t\tif (gcInvocationPC < handler.getHandlerPC() ||\n\t\t\t    gcInvocationPC > handler.getHandlerPC() + OOM_CATCH_LEN)\n\t\t\t\tcontinue;\n\t\t\tint catchTypeIndex = handler.getCatchType();\n\t\t\tif (catchTypeIndex > 0) {\n\t\t\t\tConstantPool cp = thisClass.getConstantPool();\n\t\t\t\tConstant constant = cp.getConstant(catchTypeIndex);\n\t\t\t\tif (constant instanceof ConstantClass) {\n\t\t\t\t\tString exClassName = (String) ((ConstantClass) constant).getConstantValue(cp);\n\t\t\t\t\tif (exClassName.equals(\"java/lang/OutOfMemoryError\")) {\n\t\t\t\t\t\toutOfMemoryHandler = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!outOfMemoryHandler)\n\t\t\tbugReporter.reportBug(gcInvocationBugReport);\n\t}\n\n\tsawCurrentTimeMillis = false;\n\tgcInvocationBugReport = null;\n\talreadyReported.clear();\n\texceptionTable = null;\n   }","commit_id":"4e4cc20296354fc59be13b8349274d80f6f176ff","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void sawOpcode(int seen) {\n\tif ((seen == INVOKESPECIAL)\n\t\t\t\t&& classConstant.equals(\"java/lang/String\")\n\t\t\t\t&& nameConstant.equals(\"<init>\")\n\t\t\t\t&& sigConstant.equals(\"(Ljava/lang/String;)V\"))\n\t\tif (alreadyReported.add(refConstant))\n\t\t\tbugReporter.reportBug(new BugInstance(\"DM_STRING_CTOR\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t.addSourceLine(this));\n\tif ((seen == INVOKESPECIAL)\n\t\t\t\t&& classConstant.equals(\"java/lang/String\")\n\t\t\t\t&& nameConstant.equals(\"<init>\")\n\t\t\t\t&& sigConstant.equals(\"()V\"))\n\t\tif (alreadyReported.add(refConstant))\n\t\t\tbugReporter.reportBug(new BugInstance(\"DM_STRING_VOID_CTOR\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t.addSourceLine(this));\n\tif (((seen == INVOKESTATIC\n\t\t\t\t&& classConstant.equals(\"java/lang/System\"))\n\t    || (seen == INVOKEVIRTUAL\n\t\t\t\t&& classConstant.equals(\"java/lang/Runtime\")))\n\t\t\t\t&& nameConstant.equals(\"gc\")\n\t\t\t\t&& sigConstant.equals(\"()V\")\n\t\t\t\t&& !betterClassName.startsWith(\"java.lang\"))\n\t\tif (alreadyReported.add(refConstant))\n\t\t\t// Just save this report in a field; it will be flushed\n\t\t\t// IFF there were no calls to System.currentTimeMillis();\n\t\t\t// in the method.\n\t\t\tsystemGC = new BugInstance(\"DM_GC\", HIGH_PRIORITY)\n\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t.addSourceLine(this);\n\tif ((seen == INVOKESPECIAL)\n\t\t\t\t&& classConstant.equals(\"java/lang/Boolean\")\n\t\t\t\t&& nameConstant.equals(\"<init>\")\n\t\t\t\t&& !className.equals(\"java/lang/Boolean\")\n\t\t\t\t)\n\t\tif (alreadyReported.add(refConstant))\n\t\t\tbugReporter.reportBug(new BugInstance(\"DM_BOOLEAN_CTOR\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t.addSourceLine(this));\n\tif ((seen == INVOKESTATIC)\n\t\t\t\t&& classConstant.equals(\"java/lang/System\")\n\t\t\t\t&& nameConstant.equals(\"currentTimeMillis\"))\n\t\t\tsawCurrentTimeMillis = true;\n\t}","id":102841,"modified_method":"public void sawOpcode(int seen) {\n\tif ((seen == INVOKESPECIAL)\n\t\t\t\t&& classConstant.equals(\"java/lang/String\")\n\t\t\t\t&& nameConstant.equals(\"<init>\")\n\t\t\t\t&& sigConstant.equals(\"(Ljava/lang/String;)V\"))\n\t\tif (alreadyReported.add(refConstant))\n\t\t\tbugReporter.reportBug(new BugInstance(\"DM_STRING_CTOR\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t.addSourceLine(this));\n\tif ((seen == INVOKESPECIAL)\n\t\t\t\t&& classConstant.equals(\"java/lang/String\")\n\t\t\t\t&& nameConstant.equals(\"<init>\")\n\t\t\t\t&& sigConstant.equals(\"()V\"))\n\t\tif (alreadyReported.add(refConstant))\n\t\t\tbugReporter.reportBug(new BugInstance(\"DM_STRING_VOID_CTOR\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t.addSourceLine(this));\n\tif (((seen == INVOKESTATIC\n\t\t\t\t&& classConstant.equals(\"java/lang/System\"))\n\t    || (seen == INVOKEVIRTUAL\n\t\t\t\t&& classConstant.equals(\"java/lang/Runtime\")))\n\t\t\t\t&& nameConstant.equals(\"gc\")\n\t\t\t\t&& sigConstant.equals(\"()V\")\n\t\t\t\t&& !betterClassName.startsWith(\"java.lang\"))\n\t\tif (alreadyReported.add(refConstant)) {\n\t\t\t// Just save this report in a field; it will be flushed\n\t\t\t// IFF there were no calls to System.currentTimeMillis();\n\t\t\t// in the method.\n\t\t\tgcInvocationBugReport = new BugInstance(\"DM_GC\", HIGH_PRIORITY)\n\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t.addSourceLine(this);\n\t\t\tgcInvocationPC = PC;\n\t\t\t//System.out.println(\"GC invocation at pc \" + PC);\n\t\t\t}\n\tif ((seen == INVOKESPECIAL)\n\t\t\t\t&& classConstant.equals(\"java/lang/Boolean\")\n\t\t\t\t&& nameConstant.equals(\"<init>\")\n\t\t\t\t&& !className.equals(\"java/lang/Boolean\")\n\t\t\t\t)\n\t\tif (alreadyReported.add(refConstant))\n\t\t\tbugReporter.reportBug(new BugInstance(\"DM_BOOLEAN_CTOR\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t.addSourceLine(this));\n\tif ((seen == INVOKESTATIC)\n\t\t\t\t&& classConstant.equals(\"java/lang/System\")\n\t\t\t\t&& nameConstant.equals(\"currentTimeMillis\"))\n\t\t\tsawCurrentTimeMillis = true;\n\t}","commit_id":"4e4cc20296354fc59be13b8349274d80f6f176ff","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visit(Method method) {\n\tflush();\n   }","id":102842,"modified_method":"public void visit(Method method) {\n\tflush();\n\n\tCode code = method.getCode();\n\tif (code != null)\n\t\tthis.exceptionTable = code.getExceptionTable();\n\tif (this.exceptionTable == null)\n\t\tthis.exceptionTable = new CodeException[0];\n   }","commit_id":"4e4cc20296354fc59be13b8349274d80f6f176ff","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void checkEqualsComparison(\n\t\t\tLocation location,\n\t\t\tJavaClass jclass,\n\t\t\tMethodGen methodGen,\n\t\t\tTypeDataflow typeDataflow) throws DataflowAnalysisException {\n\n\t\tInstructionHandle handle = location.getHandle();\n\t\tString sourceFile = jclass.getSourceFileName();\n\n\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\tif (frame.getStackDepth() < 2)\n\t\t\tthrow new DataflowAnalysisException(\"Stack underflow\", methodGen, handle);\n\n\t\tint numSlots = frame.getNumSlots();\n\t\tType lhsType_ = frame.getValue(numSlots - 2);\n\t\tType rhsType_ = frame.getValue(numSlots - 1);\n\n\t\n\t\t// Ignore top and bottom values\n\t\tif (lhsType_.getType() == T_TOP || lhsType_.getType() == T_BOTTOM\n\t\t        || rhsType_.getType() == T_TOP || rhsType_.getType() == T_BOTTOM)\n\t\t\treturn;\n\n\t\tif (!(lhsType_ instanceof ReferenceType) || !(rhsType_ instanceof ReferenceType)) {\n\t\t\tif (rhsType_.getType() == T_NULL) {\n\t\t\t\t// A literal null value was passed directly to equals().\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_NULL_ARG\", NORMAL_PRIORITY)\n\t\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle()));\n\t\t\t} else if (lhsType_.getType() == T_NULL) {\n\t\t\t\t// Hmm...in this case, equals() is being invoked on\n\t\t\t\t// a literal null value.  This is really the\n\t\t\t\t// purview of FindNullDeref.  So, we'll just do nothing.\n\t\t\t} else {\n\t\t\t\tbugReporter.logError(\"equals() used to compare non-object type(s) \" +\n\t\t\t\t        lhsType_ + \" and \" + rhsType_ +\n\t\t\t\t        \" in \" +\n\t\t\t\t        SignatureConverter.convertMethodSignature(methodGen) +\n\t\t\t\t        \" at \" + location.getHandle());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t        .addClass(lhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addClass(rhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t         );\n\t\tdo {\n\t\t\tlhsType_ = ((ArrayType)lhsType_).getElementType();\n\t\t\trhsType_ = ((ArrayType)rhsType_).getElementType();\n\t\t} while  (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType);\n\t\t}\n\t\t\n\t\tif (lhsType_ instanceof ArrayType) {\n\t\t\tint priority = HIGH_PRIORITY;\n\t\t\tif (rhsType_.equals(ObjectType.OBJECT)) priority = LOW_PRIORITY;\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", priority)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t        .addClass(lhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addClass(rhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t         );\n\t\t}\n\t\tif (rhsType_ instanceof ArrayType) {\n\t\t\tint priority = HIGH_PRIORITY;\n\t\t\tif (lhsType_.equals(ObjectType.OBJECT)) priority = LOW_PRIORITY;\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", priority)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t        .addClass(rhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addClass(lhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t         );\n\t\t}\n\t\tif (lhsType_.equals(rhsType_))\n\t\t\treturn;\n\n\t\t// For now, ignore the case where either reference is not\n\t\t// of an object type.  (It could be either an array or null.)\n\t\tif (!(lhsType_ instanceof ObjectType) || !(rhsType_ instanceof ObjectType))\n\t\t\treturn;\n\n\t\tObjectType lhsType = (ObjectType) lhsType_;\n\t\tObjectType rhsType = (ObjectType) rhsType_;\n\n\t\tint priority = LOW_PRIORITY + 1;\n\t\tString bugType = \"EC_UNRELATED_TYPES\";\n\n\t\t// See if the types are related by inheritance.\n\t\ttry {\n\t\t\tif (!Hierarchy.isSubtype(lhsType, rhsType) && !Hierarchy.isSubtype(rhsType, lhsType)) {\n\t\t\t\tAnalysisContext analysisContext = AnalysisContext.currentAnalysisContext();\n\t\t\t\t\n\t\t\t\t// Look up the classes\n\t\t\t\tJavaClass lhsClass = analysisContext.lookupClass(lhsType.getClassName());\n\t\t\t\tJavaClass rhsClass = analysisContext.lookupClass(rhsType.getClassName());\n\n\t\t\t\tif (!lhsClass.isInterface() && !rhsClass.isInterface()) {\n\t\t\t\t\t// Both are class types, and therefore there is no possible way\n\t\t\t\t\t// the compared objects can have the same runtime type.\n\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"Subtypes of \" + lhsClass.getClassName() + \" are \" +\n\t\t\t\t\t\t\t\tclassSetToString(analysisContext.getSubtypes().getTransitiveSubtypes(lhsClass)));\n\t\t\t\t\t\tSystem.out.println(\"Subtypes of \" + rhsClass.getClassName() + \" are \" +\n\t\t\t\t\t\t\t\tclassSetToString(analysisContext.getSubtypes().getTransitiveSubtypes(rhsClass)));\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\t\n\t\t\t\t\t// Look up the common subtypes of the two types.  If the\n\t\t\t\t\t// intersection does not contain at least one instantiable class,\n\t\t\t\t\t// then issue a warning of the appropriate type.\n\t\t\t\t\tSet<JavaClass> commonSubtypes =\n\t\t\t\t\t\tanalysisContext.getSubtypes().getTransitiveCommonSubtypes(lhsClass, rhsClass);\n\t\t\t\t\t\n\t\t\t\t\tif (!containsAtLeastOneInstantiableClass(commonSubtypes)) {\n\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\t\tbugType = (lhsClass.isInterface() && rhsClass.isInterface())\n\t\t\t\t\t\t\t? \"EC_UNRELATED_INTERFACES\" : \"EC_UNRELATED_CLASS_AND_INTERFACE\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tbugReporter.reportMissingClass(e);\n\t\t\treturn;\n\t\t}\n\n\t\tif (methodGen.getName().startsWith(\"test\") && methodGen.getSignature().equals(\"()V\")) {\n\t\t\ttry {\n\t\t\t\tif (Hierarchy.isSubtype(methodGen.getClassName(), \"junit.framework.TestCase\"))\n\t\t\t\t\tpriority+=2;\n\t\t\t} catch (ClassNotFoundException e) { priority+=2; }\n\t\t\t}\n\n\n\t\t\n\n\t\tif (priority <= LOW_PRIORITY) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, bugType, priority)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t        .addClass(lhsType.getClassName()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addClass(rhsType.getClassName()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t        );\n\t\t}\n\t}","id":102843,"modified_method":"private void checkEqualsComparison(\n\t\t\tLocation location,\n\t\t\tJavaClass jclass,\n\t\t\tMethodGen methodGen,\n\t\t\tTypeDataflow typeDataflow) throws DataflowAnalysisException {\n\n\t\tInstructionHandle handle = location.getHandle();\n\t\tString sourceFile = jclass.getSourceFileName();\n\n\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\tif (frame.getStackDepth() < 2)\n\t\t\tthrow new DataflowAnalysisException(\"Stack underflow\", methodGen, handle);\n\n\t\tint numSlots = frame.getNumSlots();\n\t\tType lhsType_ = frame.getValue(numSlots - 2);\n\t\tType rhsType_ = frame.getValue(numSlots - 1);\n\n\t\n\t\t// Ignore top and bottom values\n\t\tif (lhsType_.getType() == T_TOP || lhsType_.getType() == T_BOTTOM\n\t\t        || rhsType_.getType() == T_TOP || rhsType_.getType() == T_BOTTOM)\n\t\t\treturn;\n\n\t\tif (!(lhsType_ instanceof ReferenceType) || !(rhsType_ instanceof ReferenceType)) {\n\t\t\tif (rhsType_.getType() == T_NULL) {\n\t\t\t\tboolean isTestCase = false;\n\t\t\t\tMethod method = methodGen.getMethod();\n\t\t\t\tif (method.getName().startsWith(\"test\") && method.isPublic() && method.getSignature().equals(\"()V\")\n\t\t\t\t\t\t|| methodGen.getClassName().endsWith(\"Test\"))\n\t\t\t\t\tisTestCase = true;\n\t\t\t\t// A literal null value was passed directly to equals().\n\t\t\t\tif (!isTestCase)\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_NULL_ARG\", NORMAL_PRIORITY)\n\t\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle()));\n\t\t\t} else if (lhsType_.getType() == T_NULL) {\n\t\t\t\t// Hmm...in this case, equals() is being invoked on\n\t\t\t\t// a literal null value.  This is really the\n\t\t\t\t// purview of FindNullDeref.  So, we'll just do nothing.\n\t\t\t} else {\n\t\t\t\tbugReporter.logError(\"equals() used to compare non-object type(s) \" +\n\t\t\t\t        lhsType_ + \" and \" + rhsType_ +\n\t\t\t\t        \" in \" +\n\t\t\t\t        SignatureConverter.convertMethodSignature(methodGen) +\n\t\t\t\t        \" at \" + location.getHandle());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t        .addClass(lhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addClass(rhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t         );\n\t\tdo {\n\t\t\tlhsType_ = ((ArrayType)lhsType_).getElementType();\n\t\t\trhsType_ = ((ArrayType)rhsType_).getElementType();\n\t\t} while  (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType);\n\t\t}\n\t\t\n\t\tif (lhsType_ instanceof ArrayType) {\n\t\t\tint priority = HIGH_PRIORITY;\n\t\t\tif (rhsType_.equals(ObjectType.OBJECT)) priority = LOW_PRIORITY;\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", priority)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t        .addClass(lhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addClass(rhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t         );\n\t\t}\n\t\tif (rhsType_ instanceof ArrayType) {\n\t\t\tint priority = HIGH_PRIORITY;\n\t\t\tif (lhsType_.equals(ObjectType.OBJECT)) priority = LOW_PRIORITY;\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", priority)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t        .addClass(rhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addClass(lhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t         );\n\t\t}\n\t\tif (lhsType_.equals(rhsType_))\n\t\t\treturn;\n\n\t\t// For now, ignore the case where either reference is not\n\t\t// of an object type.  (It could be either an array or null.)\n\t\tif (!(lhsType_ instanceof ObjectType) || !(rhsType_ instanceof ObjectType))\n\t\t\treturn;\n\n\t\tObjectType lhsType = (ObjectType) lhsType_;\n\t\tObjectType rhsType = (ObjectType) rhsType_;\n\n\t\tint priority = LOW_PRIORITY + 1;\n\t\tString bugType = \"EC_UNRELATED_TYPES\";\n\n\t\t// See if the types are related by inheritance.\n\t\ttry {\n\t\t\tif (!Hierarchy.isSubtype(lhsType, rhsType) && !Hierarchy.isSubtype(rhsType, lhsType)) {\n\t\t\t\tAnalysisContext analysisContext = AnalysisContext.currentAnalysisContext();\n\t\t\t\t\n\t\t\t\t// Look up the classes\n\t\t\t\tJavaClass lhsClass = analysisContext.lookupClass(lhsType.getClassName());\n\t\t\t\tJavaClass rhsClass = analysisContext.lookupClass(rhsType.getClassName());\n\n\t\t\t\tif (!lhsClass.isInterface() && !rhsClass.isInterface()) {\n\t\t\t\t\t// Both are class types, and therefore there is no possible way\n\t\t\t\t\t// the compared objects can have the same runtime type.\n\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"Subtypes of \" + lhsClass.getClassName() + \" are \" +\n\t\t\t\t\t\t\t\tclassSetToString(analysisContext.getSubtypes().getTransitiveSubtypes(lhsClass)));\n\t\t\t\t\t\tSystem.out.println(\"Subtypes of \" + rhsClass.getClassName() + \" are \" +\n\t\t\t\t\t\t\t\tclassSetToString(analysisContext.getSubtypes().getTransitiveSubtypes(rhsClass)));\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\t\n\t\t\t\t\t// Look up the common subtypes of the two types.  If the\n\t\t\t\t\t// intersection does not contain at least one instantiable class,\n\t\t\t\t\t// then issue a warning of the appropriate type.\n\t\t\t\t\tSet<JavaClass> commonSubtypes =\n\t\t\t\t\t\tanalysisContext.getSubtypes().getTransitiveCommonSubtypes(lhsClass, rhsClass);\n\t\t\t\t\t\n\t\t\t\t\tif (!containsAtLeastOneInstantiableClass(commonSubtypes)) {\n\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\t\tbugType = (lhsClass.isInterface() && rhsClass.isInterface())\n\t\t\t\t\t\t\t? \"EC_UNRELATED_INTERFACES\" : \"EC_UNRELATED_CLASS_AND_INTERFACE\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tbugReporter.reportMissingClass(e);\n\t\t\treturn;\n\t\t}\n\n\t\tif (methodGen.getName().startsWith(\"test\") && methodGen.getSignature().equals(\"()V\")) {\n\t\t\ttry {\n\t\t\t\tif (Hierarchy.isSubtype(methodGen.getClassName(), \"junit.framework.TestCase\"))\n\t\t\t\t\tpriority+=2;\n\t\t\t} catch (ClassNotFoundException e) { priority+=2; }\n\t\t\t}\n\n\n\t\t\n\n\t\tif (priority <= LOW_PRIORITY) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, bugType, priority)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t        .addClass(lhsType.getClassName()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addClass(rhsType.getClassName()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t        );\n\t\t}\n\t}","commit_id":"d8584614b0dd180d6c83b558fad2f3291895c18a","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitAfter(JavaClass obj) {\n\tif (!obj.isClass()) return;\n\tif (getDottedClassName().equals(\"java.lang.Object\")) return;\n\tint accessFlags = obj.getAccessFlags();\n\tif ((accessFlags & ACC_INTERFACE) != 0) return;\n  \tvisibleOutsidePackage = obj.isPublic() || obj.isProtected();\n\tString whereEqual = getDottedClassName();\n\tboolean classThatDefinesEqualsIsAbstract = false;\n\tif (!hasEqualsObject)  {\n\t\tJavaClass we = Lookup.findSuperImplementor(obj, \"equals\",\n\t\t\t\t\t\"(Ljava/lang/Object;)Z\", bugReporter);\n\t\tif (we == null) {\n\t\t\twhereEqual = \"java.lang.Object\";\n\t\t}\n\t\telse {\n\t\t\twhereEqual = we.getClassName();\n\t\t\tclassThatDefinesEqualsIsAbstract = we.isAbstract();;\n\t\t\t}\n\t\t}\n\tboolean usesDefaultEquals = whereEqual.equals(\"java.lang.Object\");\n\tString whereHashCode = getDottedClassName();\n\tif (!hasHashCode) {\n\t\tJavaClass wh = Lookup.findSuperImplementor(obj, \"hashCode\",\n\t\t\t\t\t\"()I\", bugReporter);\n\t\tif (wh == null) {\n\t\t\twhereHashCode = \"java.lang.Object\";\n\t\t\t}\n\t\telse whereHashCode = wh.getClassName();\n\t\t}\n\tboolean usesDefaultHashCode = whereHashCode.equals(\"java.lang.Object\");\n\tif (false && (usesDefaultEquals ||  usesDefaultHashCode)) {\n\t\ttry {\n\t\t  if (Repository.implementationOf(obj, \"java/util/Set\")\n\t\t    || Repository.implementationOf(obj, \"java/util/List\")\n\t\t    || Repository.implementationOf(obj, \"java/util/Map\")) {\n\t\t  // System.out.println(getDottedClassName() + \" uses default hashCode or equals\");\n\t\t  }\n                } catch (ClassNotFoundException e) {\n\t\t\t// e.printStackTrace();\n                }\n\t}\n\n\tif (!hasEqualsObject &&  hasEqualsSelf) {\n\t\t\n\t\tif (usesDefaultEquals)  {\n\t\t  int priority = HIGH_PRIORITY;\n\t\t  if (usesDefaultHashCode || obj.isAbstract()) \n\t\t\tpriority++;\n\t\t  if (!visibleOutsidePackage)\n\t\t\tpriority++;\n\t\t  bugReporter.reportBug(new BugInstance(\"EQ_SELF_USE_OBJECT\", priority).addClass(getDottedClassName()));\n\t\t   }\n\t\telse {\n\t\t  int priority = NORMAL_PRIORITY;\n\t\t  if (hasFields)\n\t\t\tpriority--;\n\t\t  if (obj.isAbstract()) priority++;\n\t\t  bugReporter.reportBug(new BugInstance(\"EQ_SELF_NO_OBJECT\", priority).addClass(getDottedClassName()));\n\t\t}\n\t\t}\n\t/*\n\tSystem.out.println(\"Class \" + betterClassName);\n\tSystem.out.println(\"usesDefaultEquals: \" + usesDefaultEquals);\n\tSystem.out.println(\"hasHashCode: : \" + hasHashCode);\n\tSystem.out.println(\"usesDefaultHashCode: \" + usesDefaultHashCode);\n\tSystem.out.println(\"hasEquals: : \" + hasEqualsObject);\n\t*/\n\n\tif (!hasCompareToObject &&  hasCompareToSelf) {\n\t\tif (!extendsObject)\n\t\t  bugReporter.reportBug(new BugInstance(\"CO_SELF_NO_OBJECT\", NORMAL_PRIORITY).addClass(getDottedClassName()));\n\t\t}\n\n\t// if (!hasFields) return;\n\tif (hasHashCode && !hashCodeIsAbstract && !(hasEqualsObject ||  hasEqualsSelf))  { \n\t\tint priority = LOW_PRIORITY;\n\t\tif (usesDefaultEquals) \n\t\t  bugReporter.reportBug(new BugInstance(\"HE_HASHCODE_USE_OBJECT_EQUALS\", priority).addClass(getDottedClassName()));\n\t\telse\n\t\t  bugReporter.reportBug(new BugInstance(\"HE_HASHCODE_NO_EQUALS\", priority). addClass(getDottedClassName()));\n\t\t}\n\tif (!hasHashCode && (hasEqualsObject && !equalsObjectIsAbstract ||  hasEqualsSelf))  {\n\t\tif (usesDefaultHashCode) {\n\t\t  int priority = HIGH_PRIORITY;\n\t\t  if (equalsMethodIsInstanceOfEquals) priority+= 2;\n\t\t  else if (obj.isAbstract() || !hasEqualsObject) priority++;\n\t\t  if (!visibleOutsidePackage) {\n\t\t\tpriority++;\n\t\t\t}\n\t\t  bugReporter.reportBug(new BugInstance(\"HE_EQUALS_USE_HASHCODE\", \n\t\t\t\tpriority ).addClass(getDottedClassName()));\n\t\t  }\n\t\telse {\n\t\t  int priority = LOW_PRIORITY;\n\t\t  if (hasFields) priority--;\n\t\t  if (equalsMethodIsInstanceOfEquals || !hasEqualsObject) priority+= 2;\n\t\t  else if (obj.isAbstract()) priority++;\n\t\t   bugReporter.reportBug(\n\t\t    new BugInstance(\"HE_EQUALS_NO_HASHCODE\", \n\t\t\tpriority)\n\t\t    .addClass(getDottedClassName()));\n\t\t}\n\t\t}\n\tif (!hasHashCode && !hasEqualsObject &&  !hasEqualsSelf\n\t\t&& !usesDefaultEquals && usesDefaultHashCode\n\t\t&& !obj.isAbstract() && classThatDefinesEqualsIsAbstract) {\n\t  bugReporter.reportBug(new BugInstance(\"HE_INHERITS_EQUALS_USE_HASHCODE\", \n\t\t\tNORMAL_PRIORITY ).addClass(getDottedClassName()));\n\t  }\n\t}","id":102844,"modified_method":"public void visitAfter(JavaClass obj) {\n\tif (!obj.isClass()) return;\n\tif (getDottedClassName().equals(\"java.lang.Object\")) return;\n\tint accessFlags = obj.getAccessFlags();\n\tif ((accessFlags & ACC_INTERFACE) != 0) return;\n  \tvisibleOutsidePackage = obj.isPublic() || obj.isProtected();\n\tString whereEqual = getDottedClassName();\n\tboolean classThatDefinesEqualsIsAbstract = false;\n\tboolean inheritedHashCodeIsFinal = false;\n\tboolean inheritedEqualsIsFinal = false;\n\tboolean inheritedHashCodeIsAbstract = false;\n\tboolean inheritedEqualsIsAbstract = false;\n\tif (!hasEqualsObject)  {\n\t\tJavaClass we = Lookup.findSuperImplementor(obj, \"equals\",\n\t\t\t\t\t\"(Ljava/lang/Object;)Z\", bugReporter);\n\t\tif (we == null) {\n\t\t\twhereEqual = \"java.lang.Object\";\n\t\t}\n\t\telse {\n\t\t\twhereEqual = we.getClassName();\n\t\t\tclassThatDefinesEqualsIsAbstract = we.isAbstract();;\n\t\t\tMethod m = findMethod(we, \"equals\", \"(Ljava/lang/Object;)Z\");\n\t\t\tif (m != null && m.isFinal()) inheritedEqualsIsFinal = true;\n\t\t\tif (m != null && m.isAbstract()) inheritedEqualsIsAbstract = true;\n\t\t\t}\n\t\t}\n\tboolean usesDefaultEquals = whereEqual.equals(\"java.lang.Object\");\n\tString whereHashCode = getDottedClassName();\n\tif (!hasHashCode) {\n\t\tJavaClass wh = Lookup.findSuperImplementor(obj, \"hashCode\",\n\t\t\t\t\t\"()I\", bugReporter);\n\t\tif (wh == null) {\n\t\t\twhereHashCode = \"java.lang.Object\";\n\t\t\t}\n\t\telse {\n\t\t\twhereHashCode = wh.getClassName();\n\t\t\tMethod m = findMethod(wh, \"hashCode\", \"()I\");\n\t\t\tif (m != null && m.isFinal()) inheritedHashCodeIsFinal = true;\n\t\t\tif (m != null && m.isAbstract()) inheritedHashCodeIsAbstract = true;\n\t\t\t}\n\t\t}\n\tboolean usesDefaultHashCode = whereHashCode.equals(\"java.lang.Object\");\n\tif (false && (usesDefaultEquals ||  usesDefaultHashCode)) {\n\t\ttry {\n\t\t  if (Repository.implementationOf(obj, \"java/util/Set\")\n\t\t    || Repository.implementationOf(obj, \"java/util/List\")\n\t\t    || Repository.implementationOf(obj, \"java/util/Map\")) {\n\t\t  // System.out.println(getDottedClassName() + \" uses default hashCode or equals\");\n\t\t  }\n                } catch (ClassNotFoundException e) {\n\t\t\t// e.printStackTrace();\n                }\n\t}\n\n\tif (!hasEqualsObject &&  hasEqualsSelf) {\n\t\t\n\t\tif (usesDefaultEquals)  {\n\t\t  int priority = HIGH_PRIORITY;\n\t\t  if (usesDefaultHashCode || obj.isAbstract()) \n\t\t\tpriority++;\n\t\t  if (!visibleOutsidePackage)\n\t\t\tpriority++;\n\t\t  bugReporter.reportBug(new BugInstance(\"EQ_SELF_USE_OBJECT\", priority).addClass(getDottedClassName()));\n\t\t   }\n\t\telse {\n\t\t  int priority = NORMAL_PRIORITY;\n\t\t  if (hasFields)\n\t\t\tpriority--;\n\t\t  if (obj.isAbstract()) priority++;\n\t\t  bugReporter.reportBug(new BugInstance(\"EQ_SELF_NO_OBJECT\", priority).addClass(getDottedClassName()));\n\t\t}\n\t\t}\n\t/*\n\tSystem.out.println(\"Class \" + betterClassName);\n\tSystem.out.println(\"usesDefaultEquals: \" + usesDefaultEquals);\n\tSystem.out.println(\"hasHashCode: : \" + hasHashCode);\n\tSystem.out.println(\"usesDefaultHashCode: \" + usesDefaultHashCode);\n\tSystem.out.println(\"hasEquals: : \" + hasEqualsObject);\n\t*/\n\n\tif (!hasCompareToObject &&  hasCompareToSelf) {\n\t\tif (!extendsObject)\n\t\t  bugReporter.reportBug(new BugInstance(\"CO_SELF_NO_OBJECT\", NORMAL_PRIORITY).addClass(getDottedClassName()));\n\t\t}\n\n\t// if (!hasFields) return;\n\tif (hasHashCode && !hashCodeIsAbstract && !(hasEqualsObject ||  hasEqualsSelf))  { \n\t\tint priority = LOW_PRIORITY;\n\t\tif (usesDefaultEquals) \n\t\t  bugReporter.reportBug(new BugInstance(\"HE_HASHCODE_USE_OBJECT_EQUALS\", priority).addClass(getDottedClassName()));\n\t\telse if (!inheritedEqualsIsFinal)\n\t\t  bugReporter.reportBug(new BugInstance(\"HE_HASHCODE_NO_EQUALS\", priority). addClass(getDottedClassName()));\n\t\t}\n\tif (!hasHashCode \n\t\t&& (hasEqualsObject && !equalsObjectIsAbstract ||  hasEqualsSelf))  {\n\t\tif (usesDefaultHashCode) {\n\t\t  int priority = HIGH_PRIORITY;\n\t\t  if (equalsMethodIsInstanceOfEquals) priority+= 2;\n\t\t  else if (obj.isAbstract() || !hasEqualsObject) priority++;\n\t\t  if (!visibleOutsidePackage) {\n\t\t\tpriority++;\n\t\t\t}\n\t\t  bugReporter.reportBug(new BugInstance(\"HE_EQUALS_USE_HASHCODE\", \n\t\t\t\tpriority ).addClass(getDottedClassName()));\n\t\t  }\n\t\telse if (!inheritedHashCodeIsFinal) {\n\t\t  int priority = LOW_PRIORITY;\n\t\t  if (hasEqualsObject && inheritedEqualsIsAbstract)\n\t\t\tpriority++;\n\t\t  if (hasFields) priority--;\n\t\t  if (equalsMethodIsInstanceOfEquals || !hasEqualsObject) priority+= 2;\n\t\t  else if (obj.isAbstract()) priority++;\n\t\t   bugReporter.reportBug(\n\t\t    new BugInstance(\"HE_EQUALS_NO_HASHCODE\", \n\t\t\tpriority)\n\t\t    .addClass(getDottedClassName()));\n\t\t}\n\t\t}\n\tif (!hasHashCode && !hasEqualsObject &&  !hasEqualsSelf\n\t\t&& !usesDefaultEquals && usesDefaultHashCode\n\t\t&& !obj.isAbstract() && classThatDefinesEqualsIsAbstract) {\n\t  bugReporter.reportBug(new BugInstance(\"HE_INHERITS_EQUALS_USE_HASHCODE\", \n\t\t\tNORMAL_PRIORITY ).addClass(getDottedClassName()));\n\t  }\n\t}","commit_id":"c052209ef5f1e878100f672cd548f11a4eb388da","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visit(Method obj) {\n\tint accessFlags = obj.getAccessFlags();\n\tif ((accessFlags & ACC_STATIC) != 0) return;\n\tString name = obj.getName();\n\tString sig = obj.getSignature();\n\tif ((accessFlags & ACC_ABSTRACT) != 0) {\n\t\tif (name.equals(\"equals\")\n\t\t\t&& sig.equals(\"(L\"+getClassName()+\";)Z\"))\n\t\t  bugReporter.reportBug(new BugInstance(\"EQ_ABSTRACT_SELF\", LOW_PRIORITY).addClass(getDottedClassName()));\n\t\telse if (name.equals(\"compareTo\")\n\t\t\t&& sig.equals(\"(L\"+getClassName()+\";)I\"))\n\t\t  bugReporter.reportBug(new BugInstance(\"CO_ABSTRACT_SELF\", LOW_PRIORITY).addClass(getDottedClassName()));\n\t\treturn;\n\t\t}\n\tboolean sigIsObject = sig.equals(\"(Ljava/lang/Object;)Z\");\n\tif (name.equals(\"hashCode\")\n\t\t&& sig.equals(\"()I\")) {\n\t\thasHashCode = true;\n        \tif (obj.isAbstract()) hashCodeIsAbstract = true;\n\t\t// System.out.println(\"Found hashCode for \" + betterClassName);\n\t\t}\n\telse if (name.equals(\"equals\")) {\n\t\tif (sigIsObject) {\n\t\t\thasEqualsObject = true; \n        \t\tif (obj.isAbstract())\n\t\t\t\tequalsObjectIsAbstract = true;\n\t\t\telse {\n\t\t\tCode code = obj.getCode();\n\t\t\tbyte [] codeBytes = code.getCode();\n\t\t\n\t\t\tif ((codeBytes.length == 5 &&\n\t\t\t\t(codeBytes[1] & 0xff) == INSTANCEOF) \n\t\t\t    || (codeBytes.length == 15 &&\n\t\t\t\t(codeBytes[1] & 0xff) == INSTANCEOF  &&\n\t\t\t\t(codeBytes[11] & 0xff) == INVOKESPECIAL))  {\n\t\t\tequalsMethodIsInstanceOfEquals = true;\n\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\telse if (sig.equals(\"(L\"+getClassName()+\";)Z\"))\n\t\t\t\thasEqualsSelf = true;\n\t\t}\n\telse if (name.equals(\"compareTo\")) {\n\t\tif (sig.equals(\"(Ljava/lang/Object;)I\")) \n\t\t\thasCompareToObject = true;\n\t\telse if (sig.equals(\"(L\"+getClassName()+\";)I\"))\n\t\t\t\thasCompareToSelf = true;\n\t\t}\n\t}","id":102845,"modified_method":"public void visit(Method obj) {\n\tint accessFlags = obj.getAccessFlags();\n\tif ((accessFlags & ACC_STATIC) != 0) return;\n\tString name = obj.getName();\n\tString sig = obj.getSignature();\n\tif ((accessFlags & ACC_ABSTRACT) != 0) {\n\t\tif (name.equals(\"equals\")\n\t\t\t&& sig.equals(\"(L\"+getClassName()+\";)Z\"))  {\n\t\t  bugReporter.reportBug(new BugInstance(\"EQ_ABSTRACT_SELF\", LOW_PRIORITY).addClass(getDottedClassName()));\n\t\t  return;\n\t\t  } \n\t\telse if (name.equals(\"compareTo\")\n\t\t\t&& sig.equals(\"(L\"+getClassName()+\";)I\")) {\n\t\t  bugReporter.reportBug(new BugInstance(\"CO_ABSTRACT_SELF\", LOW_PRIORITY).addClass(getDottedClassName()));\n\t\treturn;\n\t\t}\n\t\t}\n\tboolean sigIsObject = sig.equals(\"(Ljava/lang/Object;)Z\");\n\tif (name.equals(\"hashCode\")\n\t\t&& sig.equals(\"()I\")) {\n\t\thasHashCode = true;\n        \tif (obj.isAbstract()) hashCodeIsAbstract = true;\n\t\t// System.out.println(\"Found hashCode for \" + betterClassName);\n\t\t}\n\telse if (name.equals(\"equals\")) {\n\t\tif (sigIsObject) {\n\t\t\thasEqualsObject = true; \n        \t\tif (obj.isAbstract())\n\t\t\t\tequalsObjectIsAbstract = true;\n\t\t\telse {\n\t\t\tCode code = obj.getCode();\n\t\t\tbyte [] codeBytes = code.getCode();\n\t\t\n\t\t\tif ((codeBytes.length == 5 &&\n\t\t\t\t(codeBytes[1] & 0xff) == INSTANCEOF) \n\t\t\t    || (codeBytes.length == 15 &&\n\t\t\t\t(codeBytes[1] & 0xff) == INSTANCEOF  &&\n\t\t\t\t(codeBytes[11] & 0xff) == INVOKESPECIAL))  {\n\t\t\tequalsMethodIsInstanceOfEquals = true;\n\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\telse if (sig.equals(\"(L\"+getClassName()+\";)Z\"))\n\t\t\t\thasEqualsSelf = true;\n\t\t}\n\telse if (name.equals(\"compareTo\")) {\n\t\tif (sig.equals(\"(Ljava/lang/Object;)I\")) \n\t\t\thasCompareToObject = true;\n\t\telse if (sig.equals(\"(L\"+getClassName()+\";)I\"))\n\t\t\t\thasCompareToSelf = true;\n\t\t}\n\t}","commit_id":"c052209ef5f1e878100f672cd548f11a4eb388da","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void doTransform(ModelNode modelOrOp, AbstractTransformationContext context, Set<String> reject) {\n        Map<String, String> renames = new HashMap<String, String>();\n        for(final Map.Entry<String, AttributeTransformationDescription> entry : descriptions.entrySet()) {\n            final String attributeName = entry.getKey();\n            final ModelNode attributeValue = modelOrOp.get(attributeName);\n\n            AttributeTransformationDescription description = entry.getValue();\n\n            //discard what can be discarded\n            if (description.shouldDiscard(attributeValue, context)) {\n                modelOrOp.remove(attributeName);\n            }\n\n            //Check the rest of the model can be transformed\n            if (!description.checkAttributeValueIsValid(attributeValue, context)) {\n                reject.add(attributeName);\n            }\n\n            //Now transform the value\n            description.convertValue(attributeValue, context);\n\n            //Store the rename until we are done\n            String newName = description.getNewName();\n            if (newName != null) {\n                renames.put(attributeName, newName);\n            }\n\n            //Add attribute\n            ModelNode added = description.addAttribute(context);\n            if (added != null) {\n                modelOrOp.get(attributeName).set(added);\n            }\n        }\n\n        if (renames.size() > 0) {\n            for (Map.Entry<String, String> entry : renames.entrySet()) {\n                if (modelOrOp.has(entry.getKey())) {\n                    ModelNode model = modelOrOp.remove(entry.getKey());\n                    if (model.isDefined()) {\n                        modelOrOp.get(entry.getValue()).set(model);\n                    }\n                }\n            }\n        }\n    }","id":102846,"modified_method":"private void doTransform(ModelNode modelOrOp, AbstractTransformationContext context, Set<String> reject) {\n        Map<String, String> renames = new HashMap<String, String>();\n        Map<String, ModelNode> adds = new HashMap<String, ModelNode>();\n        for(final Map.Entry<String, AttributeTransformationDescription> entry : descriptions.entrySet()) {\n            final String attributeName = entry.getKey();\n            final ModelNode attributeValue = modelOrOp.get(attributeName);\n\n            AttributeTransformationDescription description = entry.getValue();\n\n            //discard what can be discarded\n            if (description.shouldDiscard(attributeValue, context)) {\n                modelOrOp.remove(attributeName);\n            }\n\n            //Check the rest of the model can be transformed\n            if (!description.checkAttributeValueIsValid(attributeValue, context)) {\n                reject.add(attributeName);\n            }\n\n            //Now transform the value\n            description.convertValue(attributeValue, context);\n\n            //Store the rename until we are done\n            String newName = description.getNewName();\n            if (newName != null) {\n                renames.put(attributeName, newName);\n            }\n\n            //Add attribute\n            ModelNode added = description.addAttribute(context);\n            if (added != null) {\n                adds.put(attributeName, added);\n            }\n        }\n\n        if (renames.size() > 0) {\n            for (Map.Entry<String, String> entry : renames.entrySet()) {\n                if (modelOrOp.has(entry.getKey())) {\n                    ModelNode model = modelOrOp.remove(entry.getKey());\n                    if (model.isDefined()) {\n                        modelOrOp.get(entry.getValue()).set(model);\n                    }\n                }\n            }\n        }\n        if (adds.size() > 0) {\n            for (Map.Entry<String, ModelNode> entry : adds.entrySet()) {\n                modelOrOp.get(entry.getKey()).set(entry.getValue());\n            }\n        }\n    }","commit_id":"6be22436566f3a45963f0bf64f36645e6423f18c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testConvertValue() throws Exception {\n        resourceModel.get(\"value1\").set(\"one\");\n        resourceModel.get(\"value2\").set(\"two\");\n\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n        builder.getStringAttributeBuilder().convertValue(new AttributeConverter() {\n            @Override\n            public void convertAttribute(String name, ModelNode attributeValue, TransformationContext context) {\n                if (name.equals(\"value2\") && attributeValue.asString().equals(\"two\")) {\n                    attributeValue.set(1);\n                }\n            }\n        }, \"value1\", \"value2\").end()\n        .build().register(transformersSubRegistration);\n\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertEquals(2, model.keys().size());\n        Assert.assertEquals(\"one\", model.get(\"value1\").asString());\n        Assert.assertEquals(ModelType.INT, model.get(\"value2\").getType());\n        Assert.assertEquals(1, model.get(\"value2\").asInt());\n\n        ModelNode add = Util.createAddOperation(PathAddress.pathAddress(PATH));\n        add.get(\"value1\").set(\"one\");\n        add.get(\"value2\").set(\"two\");\n        OperationTransformer.TransformedOperation transformedAdd = transformOperation(add);\n        Assert.assertFalse(transformedAdd.rejectOperation(success()));\n        Assert.assertEquals(\"one\", transformedAdd.getTransformedOperation().get(\"value1\").asString());\n        Assert.assertEquals(ModelType.INT, transformedAdd.getTransformedOperation().get(\"value2\").getType());\n        Assert.assertEquals(1, transformedAdd.getTransformedOperation().get(\"value2\").asInt());\n\n        ModelNode write = Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"value1\", new ModelNode(\"value\"));\n        OperationTransformer.TransformedOperation transformedWrite = transformOperation(write);\n        Assert.assertFalse(transformedWrite.rejectOperation(success()));\n        Assert.assertEquals(write, transformedWrite.getTransformedOperation());\n\n        ModelNode write2 = Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"value2\", new ModelNode(\"two\"));\n        OperationTransformer.TransformedOperation transformedWrite2 = transformOperation(write2);\n        Assert.assertFalse(transformedWrite2.rejectOperation(success()));\n        Assert.assertEquals(ModelType.INT, transformedWrite2.getTransformedOperation().get(\"value\").getType());\n        Assert.assertEquals(1, transformedWrite2.getTransformedOperation().get(\"value\").asInt());\n    }","id":102847,"modified_method":"@Test\n    public void testConvertValue() throws Exception {\n        resourceModel.get(\"value1\").set(\"one\");\n        resourceModel.get(\"value2\").set(\"two\");\n\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n        builder.getStringAttributeBuilder().convertValue(new AttributeConverter() {\n            @Override\n            public void convertAttribute(String name, ModelNode attributeValue, TransformationContext context) {\n                if (name.equals(\"value2\") && attributeValue.asString().equals(\"two\")) {\n                    attributeValue.set(1);\n                }\n            }\n        }, \"value1\", \"value2\").end()\n        .build().register(transformersSubRegistration);\n\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertEquals(2, model.keys().size());\n        Assert.assertEquals(\"one\", model.get(\"value1\").asString());\n        Assert.assertEquals(ModelType.INT, model.get(\"value2\").getType());\n        Assert.assertEquals(1, model.get(\"value2\").asInt());\n\n        ModelNode add = Util.createAddOperation(PathAddress.pathAddress(PATH));\n        add.get(\"value1\").set(\"one\");\n        add.get(\"value2\").set(\"two\");\n        OperationTransformer.TransformedOperation transformedAdd = transformOperation(add);\n        Assert.assertFalse(transformedAdd.rejectOperation(success()));\n        Assert.assertEquals(\"one\", transformedAdd.getTransformedOperation().get(\"value1\").asString());\n        Assert.assertEquals(ModelType.INT, transformedAdd.getTransformedOperation().get(\"value2\").getType());\n        Assert.assertEquals(1, transformedAdd.getTransformedOperation().get(\"value2\").asInt());\n\n        checkWriteOp(Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"value1\", new ModelNode(\"value\")),\n                \"value1\", new ModelNode(\"value\"));\n        checkWriteOp(Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"value2\", new ModelNode(\"two\")),\n                \"value2\", new ModelNode(1));\n    }","commit_id":"6be22436566f3a45963f0bf64f36645e6423f18c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDiscardDefaultValue() throws Exception {\n        //Set up the model\n        resourceModel.get(\"discard\").set(\"default\");\n        resourceModel.get(\"keep\").set(\"non-default\");\n\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n            builder.getStringAttributeBuilder().discard(new DefaultAttributeChecker(false, true) {\n                @Override\n                public boolean isValueDiscardable(String attributeName, ModelNode attributeValue, TransformationContext context) {\n                    if (attributeName.equals(\"discard\") || attributeName.equals(\"keep\")) {\n                        if (attributeValue.asString().equals(\"default\")) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            }, \"discard\", \"keep\").end()\n            .build().register(transformersSubRegistration);\n\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertTrue(model.hasDefined(\"keep\"));\n        Assert.assertFalse(model.has(\"discard\"));\n\n        ModelNode add = Util.createAddOperation(PathAddress.pathAddress(PATH));\n        add.get(\"discard\");\n        add.get(\"keep\").set(\"here\");\n        OperationTransformer.TransformedOperation transformedAdd = transformOperation(add);\n        Assert.assertFalse(transformedAdd.rejectOperation(success()));\n        Assert.assertTrue(transformedAdd.getTransformedOperation().hasDefined(\"keep\"));\n        Assert.assertFalse(transformedAdd.getTransformedOperation().has(\"discard\"));\n\n        ModelNode write = Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"discard\", new ModelNode(\"default\"));\n        OperationTransformer.TransformedOperation transformedWrite = transformOperation(write);\n        Assert.assertFalse(transformedWrite.rejectOperation(success()));\n        //TODO this should be null, i.e. the write-attribute operation should not be pushed to the slave\n        //Assert.assertNull(transformedWrite.getTransformedOperation());\n\n        ModelNode write2 = Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"discard\", new ModelNode(\"something\"));\n        OperationTransformer.TransformedOperation transformedWrite2 = transformOperation(write2);\n        Assert.assertFalse(transformedWrite2.rejectOperation(success()));\n        Assert.assertEquals(write2, transformedWrite2.getTransformedOperation());\n    }","id":102848,"modified_method":"@Test\n    public void testDiscardDefaultValue() throws Exception {\n        //Set up the model\n        resourceModel.get(\"discard\").set(\"default\");\n        resourceModel.get(\"keep\").set(\"non-default\");\n\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n            builder.getStringAttributeBuilder().discard(new DefaultAttributeChecker(false, true) {\n                @Override\n                public boolean isValueDiscardable(String attributeName, ModelNode attributeValue, TransformationContext context) {\n                    if (attributeName.equals(\"discard\") || attributeName.equals(\"keep\")) {\n                        if (attributeValue.asString().equals(\"default\")) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            }, \"discard\", \"keep\").end()\n            .build().register(transformersSubRegistration);\n\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertTrue(model.hasDefined(\"keep\"));\n        Assert.assertFalse(model.has(\"discard\"));\n\n        ModelNode add = Util.createAddOperation(PathAddress.pathAddress(PATH));\n        add.get(\"discard\");\n        add.get(\"keep\").set(\"here\");\n        OperationTransformer.TransformedOperation transformedAdd = transformOperation(add);\n        Assert.assertFalse(transformedAdd.rejectOperation(success()));\n        Assert.assertTrue(transformedAdd.getTransformedOperation().hasDefined(\"keep\"));\n        Assert.assertFalse(transformedAdd.getTransformedOperation().has(\"discard\"));\n\n        checkWriteOpDiscarded(Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"discard\", new ModelNode(\"default\")));\n        checkWriteOp(Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"discard\", new ModelNode(\"something\")),\n                \"discard\", new ModelNode(\"something\"));\n    }","commit_id":"6be22436566f3a45963f0bf64f36645e6423f18c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testRenameAttribute() throws Exception {\n        resourceModel.get(\"old\").set(\"value\");\n\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n            builder.getStringAttributeBuilder().rename(Collections.singletonMap(\"old\", \"new\")).end()\n            .build().register(transformersSubRegistration);\n\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertEquals(1, model.keys().size());\n        Assert.assertEquals(\"value\", model.get(\"new\").asString());\n\n        ModelNode add = Util.createAddOperation(PathAddress.pathAddress(PATH));\n        add.get(\"old\").set(\"value\");\n        OperationTransformer.TransformedOperation transformedAdd = transformOperation(add);\n        Assert.assertFalse(transformedAdd.rejectOperation(success()));\n        Assert.assertFalse(transformedAdd.getTransformedOperation().hasDefined(\"old\"));\n        Assert.assertEquals(\"value\", transformedAdd.getTransformedOperation().get(\"new\").asString());\n\n\n        ModelNode write = Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"old\", new ModelNode(\"value\"));\n        OperationTransformer.TransformedOperation transformedWrite = transformOperation(write);\n        Assert.assertFalse(transformedWrite.rejectOperation(success()));\n        Assert.assertEquals(\"new\", transformedWrite.getTransformedOperation().get(NAME));\n        Assert.assertEquals(\"value\", transformedWrite.getTransformedOperation().get(VALUE));\n    }","id":102849,"modified_method":"@Test\n    public void testRenameAttribute() throws Exception {\n        resourceModel.get(\"old\").set(\"value\");\n\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n            builder.getStringAttributeBuilder().rename(Collections.singletonMap(\"old\", \"new\")).end()\n            .build().register(transformersSubRegistration);\n\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertEquals(1, model.keys().size());\n        Assert.assertEquals(\"value\", model.get(\"new\").asString());\n\n        ModelNode add = Util.createAddOperation(PathAddress.pathAddress(PATH));\n        add.get(\"old\").set(\"value\");\n        OperationTransformer.TransformedOperation transformedAdd = transformOperation(add);\n        Assert.assertFalse(transformedAdd.rejectOperation(success()));\n        Assert.assertFalse(transformedAdd.getTransformedOperation().hasDefined(\"old\"));\n        Assert.assertEquals(\"value\", transformedAdd.getTransformedOperation().get(\"new\").asString());\n\n\n        checkWriteOp(Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"old\", new ModelNode(\"value\")),\n                \"new\", new ModelNode(\"value\"));\n    }","commit_id":"6be22436566f3a45963f0bf64f36645e6423f18c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDiscardAlways() throws Exception {\n        //Set up the model\n        resourceModel.get(\"discard\").set(\"nothing\");\n        resourceModel.get(\"keep\").set(\"here\");\n\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n            builder.getStringAttributeBuilder().discard(DiscardAttributeChecker.ALWAYS, \"discard\").end()\n            .build().register(transformersSubRegistration);\n\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertTrue(model.hasDefined(\"keep\"));\n        Assert.assertFalse(model.has(\"discard\"));\n\n        ModelNode add = Util.createAddOperation(PathAddress.pathAddress(PATH));\n        add.get(\"discard\").set(\"nothing\");\n        add.get(\"keep\").set(\"here\");\n        OperationTransformer.TransformedOperation transformedAdd = transformOperation(add);\n        Assert.assertFalse(transformedAdd.rejectOperation(success()));\n        Assert.assertTrue(transformedAdd.getTransformedOperation().hasDefined(\"keep\"));\n        Assert.assertFalse(transformedAdd.getTransformedOperation().has(\"discard\"));\n\n        ModelNode write = Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"discard\", new ModelNode(\"nothing\"));\n        OperationTransformer.TransformedOperation transformedWrite = transformOperation(write);\n        Assert.assertFalse(transformedWrite.rejectOperation(success()));\n        //TODO this should be null, i.e. the write-attribute operation should not be pushed to the slave\n        //Assert.assertNull(transformedWrite.getTransformedOperation());\n    }","id":102850,"modified_method":"@Test\n    public void testDiscardAlways() throws Exception {\n        //Set up the model\n        resourceModel.get(\"discard\").set(\"nothing\");\n        resourceModel.get(\"keep\").set(\"here\");\n\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n            builder.getStringAttributeBuilder().discard(DiscardAttributeChecker.ALWAYS, \"discard\").end()\n            .build().register(transformersSubRegistration);\n\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertTrue(model.hasDefined(\"keep\"));\n        Assert.assertFalse(model.has(\"discard\"));\n\n        ModelNode add = Util.createAddOperation(PathAddress.pathAddress(PATH));\n        add.get(\"discard\").set(\"nothing\");\n        add.get(\"keep\").set(\"here\");\n        OperationTransformer.TransformedOperation transformedAdd = transformOperation(add);\n        Assert.assertFalse(transformedAdd.rejectOperation(success()));\n        Assert.assertTrue(transformedAdd.getTransformedOperation().hasDefined(\"keep\"));\n        Assert.assertFalse(transformedAdd.getTransformedOperation().has(\"discard\"));\n\n        checkWriteOpDiscarded(Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"discard\", new ModelNode(\"nothing\")));\n    }","commit_id":"6be22436566f3a45963f0bf64f36645e6423f18c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDiscardNotHappeningWithExpressions() throws Exception {\n        //Set up the model\n        resourceModel.get(\"discard\").setExpression(\"${xxx}\");\n\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n            builder.getStringAttributeBuilder().discard(new DefaultAttributeChecker(false, false) {\n                @Override\n                public boolean isValueDiscardable(String attributeName, ModelNode attributeValue, TransformationContext context) {\n                    return true;\n                }\n            }, \"discard\").end()\n            .build().register(transformersSubRegistration);\n\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertEquals(new ModelNode().setExpression(\"${xxx}\"), model.get(\"discard\"));\n\n        ModelNode add = Util.createAddOperation(PathAddress.pathAddress(PATH));\n        add.get(\"discard\").setExpression(\"${xxx}\");\n        OperationTransformer.TransformedOperation transformedAdd = transformOperation(add);\n        Assert.assertFalse(transformedAdd.rejectOperation(success()));\n        Assert.assertEquals(add, transformedAdd.getTransformedOperation());\n\n\n        ModelNode write = Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"discard\", new ModelNode().setExpression(\"${xxx}\"));\n        OperationTransformer.TransformedOperation transformedWrite = transformOperation(write);\n        Assert.assertFalse(transformedWrite.rejectOperation(success()));\n        Assert.assertEquals(write, transformedWrite.getTransformedOperation());\n    }","id":102851,"modified_method":"@Test\n    public void testDiscardNotHappeningWithExpressions() throws Exception {\n        //Set up the model\n        resourceModel.get(\"discard\").setExpression(\"${xxx}\");\n\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n            builder.getStringAttributeBuilder().discard(new DefaultAttributeChecker(false, false) {\n                @Override\n                public boolean isValueDiscardable(String attributeName, ModelNode attributeValue, TransformationContext context) {\n                    return true;\n                }\n            }, \"discard\").end()\n            .build().register(transformersSubRegistration);\n\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertEquals(new ModelNode().setExpression(\"${xxx}\"), model.get(\"discard\"));\n\n        ModelNode add = Util.createAddOperation(PathAddress.pathAddress(PATH));\n        add.get(\"discard\").setExpression(\"${xxx}\");\n        OperationTransformer.TransformedOperation transformedAdd = transformOperation(add);\n        Assert.assertFalse(transformedAdd.rejectOperation(success()));\n        Assert.assertEquals(add, transformedAdd.getTransformedOperation());\n\n        checkWriteOp(Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"discard\", new ModelNode().setExpression(\"${xxx}\")),\n                \"discard\", new ModelNode().setExpression(\"${xxx}\"));\n    }","commit_id":"6be22436566f3a45963f0bf64f36645e6423f18c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDiscardUndefined() throws Exception {\n        //Set up the model\n        resourceModel.get(\"discard\");\n        resourceModel.get(\"keep\").set(\"here\");\n\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n            builder.getStringAttributeBuilder().discard(DiscardAttributeChecker.UNDEFINED, \"discard\", \"keep\").end()\n            .build().register(transformersSubRegistration);\n\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertTrue(model.hasDefined(\"keep\"));\n        Assert.assertFalse(model.has(\"discard\"));\n\n        ModelNode add = Util.createAddOperation(PathAddress.pathAddress(PATH));\n        add.get(\"discard\");\n        add.get(\"keep\").set(\"here\");\n        OperationTransformer.TransformedOperation transformedAdd = transformOperation(add);\n        Assert.assertFalse(transformedAdd.rejectOperation(success()));\n        Assert.assertTrue(transformedAdd.getTransformedOperation().hasDefined(\"keep\"));\n        Assert.assertFalse(transformedAdd.getTransformedOperation().has(\"discard\"));\n\n        ModelNode write = Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"discard\", new ModelNode());\n        OperationTransformer.TransformedOperation transformedWrite = transformOperation(write);\n        Assert.assertFalse(transformedWrite.rejectOperation(success()));\n        //TODO this should be null, i.e. the write-attribute operation should not be pushed to the slave\n        //Assert.assertNull(transformedWrite.getTransformedOperation());\n\n        ModelNode write2 = Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"discard\", new ModelNode(\"nothing\"));\n        OperationTransformer.TransformedOperation transformedWrite2 = transformOperation(write2);\n        Assert.assertFalse(transformedWrite2.rejectOperation(success()));\n        Assert.assertEquals(write2, transformedWrite2.getTransformedOperation());\n    }","id":102852,"modified_method":"@Test\n    public void testDiscardUndefined() throws Exception {\n        //Set up the model\n        resourceModel.get(\"discard\");\n        resourceModel.get(\"keep\").set(\"here\");\n\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n            builder.getStringAttributeBuilder().discard(DiscardAttributeChecker.UNDEFINED, \"discard\", \"keep\").end()\n            .build().register(transformersSubRegistration);\n\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertTrue(model.hasDefined(\"keep\"));\n        Assert.assertFalse(model.has(\"discard\"));\n\n        ModelNode add = Util.createAddOperation(PathAddress.pathAddress(PATH));\n        add.get(\"discard\");\n        add.get(\"keep\").set(\"here\");\n        OperationTransformer.TransformedOperation transformedAdd = transformOperation(add);\n        Assert.assertFalse(transformedAdd.rejectOperation(success()));\n        Assert.assertTrue(transformedAdd.getTransformedOperation().hasDefined(\"keep\"));\n        Assert.assertFalse(transformedAdd.getTransformedOperation().has(\"discard\"));\n\n        checkWriteOpDiscarded(Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"discard\", new ModelNode()));\n\n        checkWriteOp(Util.getWriteAttributeOperation(PathAddress.pathAddress(PATH), \"discard\", new ModelNode(\"nothing\")),\n                \"discard\", new ModelNode(\"nothing\"));\n    }","commit_id":"6be22436566f3a45963f0bf64f36645e6423f18c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public TransformedOperation transformOperation(TransformationContext context, PathAddress address, ModelNode operation) throws OperationFailedException {\n\n            final String attributeName = operation.require(ModelDescriptionConstants.NAME).asString();\n            final AttributeTransformationDescription description = attributeTransformations.get(attributeName);\n            if(description == null) {\n                return new TransformedOperation(operation, OperationResultTransformer.ORIGINAL_RESULT);\n            }\n            // Process\n            final ModelNode originalModel = operation.clone();\n            originalModel.protect();\n            final boolean reject = !description.checkAttributeValueIsValid(operation.get(ModelDescriptionConstants.VALUE), new TransformationRule.AbstractTransformationContext(context, originalModel) {\n                @Override\n                protected TransformationContext getContext() {\n                    return super.getContext();\n                }\n            });\n            final OperationRejectionPolicy policy;\n            if(reject) {\n                policy = new OperationRejectionPolicy() {\n                    @Override\n                    public boolean rejectOperation(ModelNode preparedResult) {\n                        return true;\n                    }\n\n                    @Override\n                    public String getFailureDescription() {\n                        return \"\";\n                    }\n                };\n            } else {\n                policy = DEFAULT_REJECTION_POLICY;\n            }\n            //\n            return new TransformedOperation(operation, policy, OperationResultTransformer.ORIGINAL_RESULT);\n        }","id":102853,"modified_method":"@Override\n        public TransformedOperation transformOperation(TransformationContext context, PathAddress address, ModelNode operation) throws OperationFailedException {\n\n            final String attributeName = operation.require(ModelDescriptionConstants.NAME).asString();\n            final AttributeTransformationDescription description = attributeTransformations.get(attributeName);\n            if(description == null) {\n                return new TransformedOperation(operation, OperationResultTransformer.ORIGINAL_RESULT);\n            }\n\n            ModelNode attributeValue = operation.get(ModelDescriptionConstants.VALUE);\n\n\n            // Process\n            final ModelNode originalModel = operation.clone();\n            TransformationRule.AbstractTransformationContext ctx =new TransformationRule.AbstractTransformationContext(context, originalModel) {\n                @Override\n                protected TransformationContext getContext() {\n                    return super.getContext();\n                }\n            };\n            originalModel.protect();\n            //discard what can be discarded\n            if (description.shouldDiscard(attributeValue, ctx)) {\n                return OperationTransformer.DISCARD.transformOperation(context, address, operation);\n            }\n\n            //Check the rest of the model can be transformed\n            final boolean reject = !description.checkAttributeValueIsValid(attributeValue, ctx);\n            final OperationRejectionPolicy policy;\n            if(reject) {\n                policy = new OperationRejectionPolicy() {\n                    @Override\n                    public boolean rejectOperation(ModelNode preparedResult) {\n                        return true;\n                    }\n\n                    @Override\n                    public String getFailureDescription() {\n                        return \"\";\n                    }\n                };\n            } else {\n                policy = DEFAULT_REJECTION_POLICY;\n            }\n\n            //Now transform the value\n            description.convertValue(attributeValue, ctx);\n\n            //Store the rename until we are done\n            String newName = description.getNewName();\n            if (newName != null) {\n                operation.get(NAME).set(newName);\n            }\n\n            return new TransformedOperation(operation, policy, OperationResultTransformer.ORIGINAL_RESULT);\n        }","commit_id":"6be22436566f3a45963f0bf64f36645e6423f18c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public boolean isNodeReady(AdapterOperation op) {\n        if (op.getType() == AdapterOperationType.CONFIG_CHANGE) {\n            Integer nodeid = op.getNodeId();\n            updateRancidNodeState(nodeid, true);\n            if ( m_rancidAdapterConfig.isCurTimeInSchedule(getSuitableIpForRancid(nodeid))) {\n              return true;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }","id":102854,"modified_method":"@Override\n    public boolean isNodeReady(AdapterOperation op) {\n        if (op.getType() == AdapterOperationType.CONFIG_CHANGE) {\n            Integer nodeid = op.getNodeId();\n            updateRancidNodeState(nodeid, true);\n            return \n            m_rancidAdapterConfig.isCurTimeInSchedule(getSuitableIpForRancid(nodeid));\n        }\n        return true;\n    }","commit_id":"a1831e49ab91457fe068ca290c17cacd8e3ca497","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public boolean isNodeReady(AdapterOperation op) {\n        if (op.getType() == AdapterOperationType.CONFIG_CHANGE) {\n            Integer nodeid = op.getNodeId();\n            updateRancidNodeState(nodeid, true);\n            if ( m_rancidAdapterConfig.isCurTimeInSchedule(getSuitableIpForRancid(nodeid))) {\n              return true;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }","id":102855,"modified_method":"@Override\n    public boolean isNodeReady(AdapterOperation op) {\n        if (op.getType() == AdapterOperationType.CONFIG_CHANGE) {\n            Integer nodeid = op.getNodeId();\n            updateRancidNodeState(nodeid, true);\n            return \n            m_rancidAdapterConfig.isCurTimeInSchedule(getSuitableIpForRancid(nodeid));\n        }\n        return true;\n    }","commit_id":"5f436afdbffc1397a18c9e946716ffc76ae93745","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public boolean isNodeReady(AdapterOperation op) {\n        if (op.getType() == AdapterOperationType.CONFIG_CHANGE) {\n            Integer nodeid = op.getNodeId();\n            updateRancidNodeState(nodeid, true);\n            if ( m_rancidAdapterConfig.isCurTimeInSchedule(getSuitableIpForRancid(nodeid))) {\n              return true;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }","id":102856,"modified_method":"@Override\n    public boolean isNodeReady(AdapterOperation op) {\n        if (op.getType() == AdapterOperationType.CONFIG_CHANGE) {\n            Integer nodeid = op.getNodeId();\n            updateRancidNodeState(nodeid, true);\n            return \n            m_rancidAdapterConfig.isCurTimeInSchedule(getSuitableIpForRancid(nodeid));\n        }\n        return true;\n    }","commit_id":"af123b2668426fa83e9e156f0dbc3371b3278cfe","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Action when the \"Search\" button is pressed.\n     *\n     * @param evt  the action event\n     */\n    private void search() {\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        try {\n            if (this.anyFiltersEnabled()) {\n                String title = \"File Search Results \" + index;\n                String pathText = \"Filename Search Results:\";\n\n                // try to get the number of matches first\n                Case currentCase = Case.getCurrentCase(); // get the most updated case\n                int totalMatches = 0;\n                ArrayList<FsContent> fsContentList = new ArrayList<FsContent>();\n                try {\n                    List<FsContent> currentDbList;\n                    SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n                    ResultSet rs = tempDb.runQuery(this.getQuery(\"count(*) as TotalMatches\"));\n                    totalMatches = totalMatches + rs.getInt(\"TotalMatches\");\n                    rs.getStatement().close();\n                    rs.close();\n                    rs = tempDb.runQuery(this.getQuery(null));\n                    currentDbList = tempDb.resultSetToFsContents(rs);\n                    rs.getStatement().close();\n                    rs.close();\n                    fsContentList.addAll(currentDbList);\n                } catch (SQLException ex) {\n                    Logger logger = Logger.getLogger(this.getClass().getName());\n                    logger.log(Level.WARNING, \"Error while trying to get the number of matches.\", ex);\n                }\n\n                TopComponent searchResultWin = DataResultTopComponent.createInstance(title, pathText, new TableFilterNode(new SearchNode(fsContentList), true), totalMatches);\n\n                searchResultWin.requestActive(); // make it the active top component\n\n                searchResultWin.addPropertyChangeListener(this);\n                searchResults.add((DataResultTopComponent) searchResultWin);\n                index++;\n\n                /**\n                 * If total matches more than 1000, pop up a dialog box that say\n                 * the performance maybe be slow and to increase the performance,\n                 * tell the users to refine their search.\n                 */\n                if (totalMatches > 1000) {\n                    // show the confirmation\n                    NotifyDescriptor d = new NotifyDescriptor.Message(\"Note: \" + totalMatches + \" matches found. Due to the large number of search results, performance may be slow for some operations. (In particular the thumbnail view in this version of Autospy, should be fixed in a future version) \\n\\nPlease refine your search to get better search results and improve performance.\");\n                    DialogDisplayer.getDefault().notify(d);\n                }\n            } else {\n                throw new FilterValidationException(\"At least one filter must be selected.\");\n            }\n        } catch (FilterValidationException ex) {\n            NotifyDescriptor d = new NotifyDescriptor.Message(\"Validation Error: \" + ex.getMessage());\n            DialogDisplayer.getDefault().notify(d);\n        } finally {\n            this.setCursor(null);\n        }\n    }","id":102857,"modified_method":"/**\n     * Action when the \"Search\" button is pressed.\n     *\n     * @param evt  the action event\n     */\n    private void search() {\n        // change the cursor to \"waiting cursor\" for this operation\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        try {\n            if (this.anyFiltersEnabled()) {\n                String title = \"File Search Results \" + index;\n                String pathText = \"Filename Search Results:\";\n\n                // try to get the number of matches first\n                Case currentCase = Case.getCurrentCase(); // get the most updated case\n                int totalMatches = 0;\n                ArrayList<FsContent> fsContentList = new ArrayList<FsContent>();\n                try {\n                    List<FsContent> currentDbList;\n                    SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n                    ResultSet rs = tempDb.runQuery(this.getQuery(\"count(*) as TotalMatches\"));\n                    totalMatches = totalMatches + rs.getInt(\"TotalMatches\");\n                    Statement s = rs.getStatement();\n                    rs.close();\n                    if (s != null)\n                        s.close();\n                    rs = tempDb.runQuery(this.getQuery(null));\n                    currentDbList = tempDb.resultSetToFsContents(rs);\n                    s = rs.getStatement();\n                    rs.close();\n                    if (s != null)\n                        s.close();\n                    fsContentList.addAll(currentDbList);\n                } catch (SQLException ex) {\n                    Logger logger = Logger.getLogger(this.getClass().getName());\n                    logger.log(Level.WARNING, \"Error while trying to get the number of matches.\", ex);\n                }\n\n                TopComponent searchResultWin = DataResultTopComponent.createInstance(title, pathText, new TableFilterNode(new SearchNode(fsContentList), true), totalMatches);\n\n                searchResultWin.requestActive(); // make it the active top component\n\n                searchResultWin.addPropertyChangeListener(this);\n                searchResults.add((DataResultTopComponent) searchResultWin);\n                index++;\n\n                /**\n                 * If total matches more than 1000, pop up a dialog box that say\n                 * the performance maybe be slow and to increase the performance,\n                 * tell the users to refine their search.\n                 */\n                if (totalMatches > 1000) {\n                    // show the confirmation\n                    NotifyDescriptor d = new NotifyDescriptor.Message(\"Note: \" + totalMatches + \" matches found. Due to the large number of search results, performance may be slow for some operations. (In particular the thumbnail view in this version of Autospy, should be fixed in a future version) \\n\\nPlease refine your search to get better search results and improve performance.\");\n                    DialogDisplayer.getDefault().notify(d);\n                }\n            } else {\n                throw new FilterValidationException(\"At least one filter must be selected.\");\n            }\n        } catch (FilterValidationException ex) {\n            NotifyDescriptor d = new NotifyDescriptor.Message(\"Validation Error: \" + ex.getMessage());\n            DialogDisplayer.getDefault().notify(d);\n        } finally {\n            this.setCursor(null);\n        }\n    }","commit_id":"7086ed3cf5c6c82137e61735049197b26948d329","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void getffdb(){\n         //Make these seperate, this is for history\n        try \n        {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n            List<FsContent> FFSqlitedb;  \n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE '%places.sqlite%' and parent_path LIKE '%Firefox%'\");\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            rs.getStatement().close();\n            rs.close();\n                    FireFoxCount = FFSqlitedb.size();\n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                 \n                \n                try\n                {\n                   \n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(ffquery);  \n                   while(temprs.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_HISTORY);\n                      HashMap<String, Object> kvs = new HashMap<String, Object>();\n                      kvs.put(\"Url\", temprs.getString(\"url\"));\n                      kvs.put(\"Title\", ((temprs.getString(\"title\") != null) ? temprs.getString(\"title\") : \"No Title\"));\n                      kvs.put(\"Count\", temprs.getString(\"visit_count\"));\n                      kvs.put(\"Last Accessed\", temprs.getString(\"visit_date\"));\n                      kvs.put(\"Reference\", temprs.getString(\"from_visit\"));\n                      \n                      BlackboardAttribute bbatturl = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(),\"RecentActivity\",\"FireFox\",temprs.getString(\"url\"));\n                      bbart.addAttribute(bbatturl);\n                       BlackboardAttribute bbattdate = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(),\"RecentActivity\",\"FireFox\",temprs.getString(\"visit_date\"));\n                      bbart.addAttribute(bbattdate);\n                       BlackboardAttribute bbattref = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID(),\"RecentActivity\",\"FireFox\",temprs.getString(\"from_visit\"));\n                      bbart.addAttribute(bbattref);\n                       BlackboardAttribute bbatttitle = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(),\"RecentActivity\",\"FireFox\",((temprs.getString(\"title\") != null) ? temprs.getString(\"title\") : \"No Title\"));\n                      bbart.addAttribute(bbatttitle);\n                       BlackboardAttribute bbattprog = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"FireFox\",\"FireFox\");\n                       bbart.addAttribute(bbattprog);\n                      //bbart.addAttribute(ATTRIBUTE_TYPE.TSK_URL, temprs.getString(\"url\"), \"RecentActivity\",\"FireFox\");\n                      //bbart.addAttribute(ATTRIBUTE_TYPE.TSK_DATETIME, temprs.getString(\"visit_date\"), \"RecentActivity\",\"FireFox\");\n                      //bbart.addAttribute(ATTRIBUTE_TYPE.TSK_REFERRER, temprs.getString(\"from_visit\"), \"RecentActivity\",\"FireFox\");\n                      //bbart.addAttribute(ATTRIBUTE_TYPE.TSK_NAME, ((temprs.getString(\"title\") != null) ? temprs.getString(\"title\") : \"No Title\"), \"RecentActivity\",\"FireFox\");\n                      als.add(kvs);\n                      \n                   }\n                   temprs.close(); \n                   ResultSet tempbm = tempdbconnect.executeQry(ffbookmarkquery);  \n                   while(tempbm.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_BOOKMARK);\n                      HashMap<String, Object> kvs = new HashMap<String, Object>();\n                      kvs.put(\"Url\", temprs.getString(\"url\"));\n                      kvs.put(\"Title\", ((temprs.getString(\"title\") != null) ? temprs.getString(\"title\") : \"No Title\"));\n                      kvs.put(\"Count\", \"\");\n                      kvs.put(\"Last Accessed\", \"\");\n                      kvs.put(\"Reference\", \"\");   \n                      BlackboardAttribute bbatturl = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(),\"RecentActivity\",\"FireFox\",((temprs.getString(\"url\") != null) ? temprs.getString(\"url\") : \"No URL\"));\n                      bbart.addAttribute(bbatturl);\n                      BlackboardAttribute bbatttitle = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"FireFox\", ((temprs.getString(\"title\") != null) ? temprs.getString(\"title\").replaceAll(\"'\", \"''\") : \"No Title\"));\n                      bbart.addAttribute(bbatttitle);\n                     BlackboardAttribute bbattprog = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"FireFox\",\"FireFox\");\n                       bbart.addAttribute(bbattprog);\n                      bookmarks.add(kvs);\n                      \n                   } \n                   tempbm.close();\n                   tempdbconnect.closeConnection();\n                   \n \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Firefox SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        }\n        \n        \n        //COOKIES section\n          // This gets the cookie info\n         try \n        {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n            List<FsContent> FFSqlitedb;  \n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE '%cookies.sqlite%' and parent_path LIKE '%Firefox%'\");\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            rs.getStatement().close();\n            rs.close();\n            \n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                 try\n                {\n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(ffcookiequery);  \n                   while(temprs.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_COOKIE);\n                      HashMap<String, Object> kvs = new HashMap<String, Object>();\n                      kvs.put(\"Url\", temprs.getString(\"host\"));\n                      kvs.put(\"Title\", ((temprs.getString(\"name\") != null) ? temprs.getString(\"name\") : \"No name\"));\n                      kvs.put(\"Count\", temprs.getString(\"value\"));\n                      kvs.put(\"Last Accessed\", temprs.getString(\"lastAccessed\"));\n                      kvs.put(\"Reference\", temprs.getString(\"creationTime\"));\n                     BlackboardAttribute bbatturl = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\", \"FireFox\", temprs.getString(\"host\"));\n                     bbart.addAttribute(bbatturl);\n                     BlackboardAttribute bbattdate = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", \"FireFox\", temprs.getString(\"lastAccessed\"));\n                     bbart.addAttribute(bbattdate);\n                     BlackboardAttribute bbattvalue = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_TEXT.getTypeID(), \"RecentActivity\", \"FireFox\", temprs.getString(\"value\"));\n                     bbart.addAttribute(bbattvalue);\n                     BlackboardAttribute bbatttitle = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"FireFox\",((temprs.getString(\"name\") != null) ? temprs.getString(\"name\") : \"No name\"));\n                     bbart.addAttribute(bbatttitle);\n                       BlackboardAttribute bbattprog = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"FireFox\",\"FireFox\");\n                       bbart.addAttribute(bbattprog);\n                      \n                      cookies.add(kvs);\n                      \n                   } \n                   tempdbconnect.closeConnection();\n                   temprs.close();\n                    \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Firefox SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        }\n   }","id":102858,"modified_method":"public void getffdb(){\n         //Make these seperate, this is for history\n        try \n        {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n            List<FsContent> FFSqlitedb;  \n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE '%places.sqlite%' and parent_path LIKE '%Firefox%'\");\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            Statement s = rs.getStatement();\n            rs.close();\n            if (s != null)\n                s.close();\n                    FireFoxCount = FFSqlitedb.size();\n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                 \n                \n                try\n                {\n                   \n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(ffquery);  \n                   while(temprs.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_HISTORY);\n                      HashMap<String, Object> kvs = new HashMap<String, Object>();\n                      kvs.put(\"Url\", temprs.getString(\"url\"));\n                      kvs.put(\"Title\", ((temprs.getString(\"title\") != null) ? temprs.getString(\"title\") : \"No Title\"));\n                      kvs.put(\"Count\", temprs.getString(\"visit_count\"));\n                      kvs.put(\"Last Accessed\", temprs.getString(\"visit_date\"));\n                      kvs.put(\"Reference\", temprs.getString(\"from_visit\"));\n                      \n                      BlackboardAttribute bbatturl = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(),\"RecentActivity\",\"FireFox\",temprs.getString(\"url\"));\n                      bbart.addAttribute(bbatturl);\n                       BlackboardAttribute bbattdate = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(),\"RecentActivity\",\"FireFox\",temprs.getString(\"visit_date\"));\n                      bbart.addAttribute(bbattdate);\n                       BlackboardAttribute bbattref = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID(),\"RecentActivity\",\"FireFox\",temprs.getString(\"from_visit\"));\n                      bbart.addAttribute(bbattref);\n                       BlackboardAttribute bbatttitle = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(),\"RecentActivity\",\"FireFox\",((temprs.getString(\"title\") != null) ? temprs.getString(\"title\") : \"No Title\"));\n                      bbart.addAttribute(bbatttitle);\n                       BlackboardAttribute bbattprog = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"FireFox\",\"FireFox\");\n                       bbart.addAttribute(bbattprog);\n                      //bbart.addAttribute(ATTRIBUTE_TYPE.TSK_URL, temprs.getString(\"url\"), \"RecentActivity\",\"FireFox\");\n                      //bbart.addAttribute(ATTRIBUTE_TYPE.TSK_DATETIME, temprs.getString(\"visit_date\"), \"RecentActivity\",\"FireFox\");\n                      //bbart.addAttribute(ATTRIBUTE_TYPE.TSK_REFERRER, temprs.getString(\"from_visit\"), \"RecentActivity\",\"FireFox\");\n                      //bbart.addAttribute(ATTRIBUTE_TYPE.TSK_NAME, ((temprs.getString(\"title\") != null) ? temprs.getString(\"title\") : \"No Title\"), \"RecentActivity\",\"FireFox\");\n                      als.add(kvs);\n                      \n                   }\n                   temprs.close(); \n                   ResultSet tempbm = tempdbconnect.executeQry(ffbookmarkquery);  \n                   while(tempbm.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_BOOKMARK);\n                      HashMap<String, Object> kvs = new HashMap<String, Object>();\n                      kvs.put(\"Url\", temprs.getString(\"url\"));\n                      kvs.put(\"Title\", ((temprs.getString(\"title\") != null) ? temprs.getString(\"title\") : \"No Title\"));\n                      kvs.put(\"Count\", \"\");\n                      kvs.put(\"Last Accessed\", \"\");\n                      kvs.put(\"Reference\", \"\");   \n                      BlackboardAttribute bbatturl = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(),\"RecentActivity\",\"FireFox\",((temprs.getString(\"url\") != null) ? temprs.getString(\"url\") : \"No URL\"));\n                      bbart.addAttribute(bbatturl);\n                      BlackboardAttribute bbatttitle = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"FireFox\", ((temprs.getString(\"title\") != null) ? temprs.getString(\"title\").replaceAll(\"'\", \"''\") : \"No Title\"));\n                      bbart.addAttribute(bbatttitle);\n                     BlackboardAttribute bbattprog = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"FireFox\",\"FireFox\");\n                       bbart.addAttribute(bbattprog);\n                      bookmarks.add(kvs);\n                      \n                   } \n                   tempbm.close();\n                   tempdbconnect.closeConnection();\n                   \n \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Firefox SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        }\n        \n        \n        //COOKIES section\n          // This gets the cookie info\n         try \n        {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n            List<FsContent> FFSqlitedb;  \n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE '%cookies.sqlite%' and parent_path LIKE '%Firefox%'\");\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            Statement s = rs.getStatement();\n            rs.close();\n            if (s != null)\n                s.close();\n            \n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                 try\n                {\n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(ffcookiequery);  \n                   while(temprs.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_COOKIE);\n                      HashMap<String, Object> kvs = new HashMap<String, Object>();\n                      kvs.put(\"Url\", temprs.getString(\"host\"));\n                      kvs.put(\"Title\", ((temprs.getString(\"name\") != null) ? temprs.getString(\"name\") : \"No name\"));\n                      kvs.put(\"Count\", temprs.getString(\"value\"));\n                      kvs.put(\"Last Accessed\", temprs.getString(\"lastAccessed\"));\n                      kvs.put(\"Reference\", temprs.getString(\"creationTime\"));\n                     BlackboardAttribute bbatturl = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\", \"FireFox\", temprs.getString(\"host\"));\n                     bbart.addAttribute(bbatturl);\n                     BlackboardAttribute bbattdate = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", \"FireFox\", temprs.getString(\"lastAccessed\"));\n                     bbart.addAttribute(bbattdate);\n                     BlackboardAttribute bbattvalue = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_TEXT.getTypeID(), \"RecentActivity\", \"FireFox\", temprs.getString(\"value\"));\n                     bbart.addAttribute(bbattvalue);\n                     BlackboardAttribute bbatttitle = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"FireFox\",((temprs.getString(\"name\") != null) ? temprs.getString(\"name\") : \"No name\"));\n                     bbart.addAttribute(bbatttitle);\n                       BlackboardAttribute bbattprog = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"FireFox\",\"FireFox\");\n                       bbart.addAttribute(bbattprog);\n                      \n                      cookies.add(kvs);\n                      \n                   } \n                   tempdbconnect.closeConnection();\n                   temprs.close();\n                    \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Firefox SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        }\n   }","commit_id":"7086ed3cf5c6c82137e61735049197b26948d329","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public Collection<FsContent> visit(FileSystem fs) {\n        // Files in the database have a filesystem field, so it's quick to\n        // get all the matching files for an entire filesystem with a query\n\n        SleuthkitCase sc = Case.getCurrentCase().getSleuthkitCase();\n\n        String query = \"SELECT * FROM tsk_files WHERE fs_obj_id = \" + fs.getId()\n                + \" AND (meta_type = \" + TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_REG.getMetaType() + \n                \") AND (known != \" + FileKnown.KNOWN.toLong() + \") AND (size > 0)\";\n        try {\n            ResultSet rs = sc.runQuery(query);\n            List<FsContent>contents =  sc.resultSetToFsContents(rs);\n            rs.getStatement().close();\n            rs.close();\n            return contents;\n        } catch (SQLException ex) {\n            logger.log(Level.WARNING, \"Couldn't get all files in FileSystem\", ex);\n            return Collections.EMPTY_SET;\n        }\n    }","id":102859,"modified_method":"@Override\n    public Collection<FsContent> visit(FileSystem fs) {\n        // Files in the database have a filesystem field, so it's quick to\n        // get all the matching files for an entire filesystem with a query\n\n        SleuthkitCase sc = Case.getCurrentCase().getSleuthkitCase();\n\n        String query = \"SELECT * FROM tsk_files WHERE fs_obj_id = \" + fs.getId()\n                + \" AND (meta_type = \" + TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_REG.getMetaType()\n                + \") AND (known != \" + FileKnown.KNOWN.toLong() + \") AND (size > 0)\";\n        try {\n            ResultSet rs = sc.runQuery(query);\n            List<FsContent> contents = sc.resultSetToFsContents(rs);\n            Statement s = rs.getStatement();\n            rs.close();\n            if (s != null) {\n                s.close();\n            }\n            return contents;\n        } catch (SQLException ex) {\n            logger.log(Level.WARNING, \"Couldn't get all files in FileSystem\", ex);\n            return Collections.EMPTY_SET;\n        }\n    }","commit_id":"7086ed3cf5c6c82137e61735049197b26948d329","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public Collection<FsContent> visit(FileSystem fs) {\n        // Files in the database have a filesystem field, so it's quick to\n        // get all the matching files for an entire filesystem with a query\n\n        SleuthkitCase sc = Case.getCurrentCase().getSleuthkitCase();\n\n        String query = \"SELECT * FROM tsk_files WHERE fs_obj_id = \" + fs.getId()\n                + \" AND (meta_type = \" + TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_REG.getMetaType() + \n                \") AND (known != \" + FileKnown.KNOWN.toLong() + \") AND (size > 0)\";\n        try {\n            ResultSet rs = sc.runQuery(query);\n            List<FsContent> contents = sc.resultSetToFsContents(rs);\n            rs.getStatement().close();\n            rs.close();\n            return contents;\n        } catch (SQLException ex) {\n            logger.log(Level.WARNING, \"Couldn't get all files in FileSystem\", ex);\n            return Collections.EMPTY_SET;\n        }\n    }","id":102860,"modified_method":"@Override\n    public Collection<FsContent> visit(FileSystem fs) {\n        // Files in the database have a filesystem field, so it's quick to\n        // get all the matching files for an entire filesystem with a query\n\n        SleuthkitCase sc = Case.getCurrentCase().getSleuthkitCase();\n\n        String query = \"SELECT * FROM tsk_files WHERE fs_obj_id = \" + fs.getId()\n                + \" AND (meta_type = \" + TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_REG.getMetaType()\n                + \") AND (known != \" + FileKnown.KNOWN.toLong() + \") AND (size > 0)\";\n        try {\n            ResultSet rs = sc.runQuery(query);\n            List<FsContent> contents = sc.resultSetToFsContents(rs);\n            Statement s = rs.getStatement();\n            rs.close();\n            if (s != null) {\n                s.close();\n            }\n            return contents;\n        } catch (SQLException ex) {\n            logger.log(Level.WARNING, \"Couldn't get all files in FileSystem\", ex);\n            return Collections.EMPTY_SET;\n        }\n    }","commit_id":"7086ed3cf5c6c82137e61735049197b26948d329","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public Collection<FsContent> visit(FileSystem fs) {\n        // Files in the database have a filesystem field, so it's quick to\n        // get all the matching files for an entire filesystem with a query\n        \n        SleuthkitCase sc = Case.getCurrentCase().getSleuthkitCase();\n\n        String query = \"SELECT * FROM tsk_files WHERE fs_obj_id = \" + fs.getId()\n                + \" AND (\" + extensionsLikePredicate + \")\"\n                + \" AND (known != \" + FileKnown.KNOWN.toLong() + \")\" \n                + \" AND (meta_type = \" + TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_REG.getMetaType() + \")\" \n                + \" AND (size > 0)\";\n        try {\n            ResultSet rs = sc.runQuery(query);\n            List<FsContent> contents =  sc.resultSetToFsContents(rs);\n            rs.getStatement().close();\n            rs.close();\n            return contents;\n        } catch (SQLException ex) {\n            logger.log(Level.WARNING, \"Couldn't get all files in FileSystem\", ex);\n            return Collections.EMPTY_SET;\n        }\n    }","id":102861,"modified_method":"@Override\n    public Collection<FsContent> visit(FileSystem fs) {\n        // Files in the database have a filesystem field, so it's quick to\n        // get all the matching files for an entire filesystem with a query\n\n        SleuthkitCase sc = Case.getCurrentCase().getSleuthkitCase();\n\n        String query = \"SELECT * FROM tsk_files WHERE fs_obj_id = \" + fs.getId()\n                + \" AND (\" + extensionsLikePredicate + \")\"\n                + \" AND (known != \" + FileKnown.KNOWN.toLong() + \")\"\n                + \" AND (meta_type = \" + TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_REG.getMetaType() + \")\"\n                + \" AND (size > 0)\";\n        try {\n            ResultSet rs = sc.runQuery(query);\n            List<FsContent> contents = sc.resultSetToFsContents(rs);\n            final Statement s = rs.getStatement();\n            rs.close();\n            if (s != null) {\n                s.close();\n            }\n            return contents;\n        } catch (SQLException ex) {\n            logger.log(Level.WARNING, \"Couldn't get all files in FileSystem\", ex);\n            return Collections.EMPTY_SET;\n        }\n    }","commit_id":"7086ed3cf5c6c82137e61735049197b26948d329","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Just perform the query and return result without updating the GUI\n     * This utility is used in this class, can be potentially reused by other classes\n     * @param query\n     * @return matches List\n     */\n    @Override\n    public List<FsContent> performQuery() throws RuntimeException {\n        List<FsContent> matches = new ArrayList<FsContent>();\n\n        boolean allMatchesFetched = false;\n        final int ROWS_PER_FETCH = 10000;\n\n        Server.Core solrCore = KeywordSearch.getServer().getCore();\n\n        SolrQuery q = new SolrQuery();\n\n        q.setQuery(queryEscaped);\n        q.setRows(ROWS_PER_FETCH);\n        q.setFields(\"id\");\n\n        for (int start = 0; !allMatchesFetched; start = start + ROWS_PER_FETCH) {\n\n            q.setStart(start);\n\n            try {\n                QueryResponse response = solrCore.query(q, METHOD.POST);\n                SolrDocumentList resultList = response.getResults();\n                long results = resultList.getNumFound();\n\n                allMatchesFetched = start + ROWS_PER_FETCH >= results;\n\n                for (SolrDocument resultDoc : resultList) {\n                    long id = Long.parseLong((String) resultDoc.getFieldValue(\"id\"));\n\n                    SleuthkitCase sc = Case.getCurrentCase().getSleuthkitCase();\n\n                    // TODO: has to be a better way to get files. Also, need to \n                    // check that we actually get 1 hit for each id\n                    ResultSet rs = sc.runQuery(\"select * from tsk_files where obj_id=\" + id);\n                    matches.addAll(sc.resultSetToFsContents(rs));\n                    rs.getStatement().close();\n                    rs.close();\n                }\n\n            } catch (SolrServerException ex) {\n                logger.log(Level.WARNING, \"Error executing Lucene Solr Query: \" + query.substring(0,Math.min(query.length()-1, 200)), ex);\n                throw new RuntimeException(ex);\n                // TODO: handle bad query strings, among other issues\n            } catch (SQLException ex) {\n                logger.log(Level.WARNING, \"Error interpreting results from Lucene Solr Query: \" + query, ex);\n            }\n\n        }\n        return matches;\n    }","id":102862,"modified_method":"/**\n     * Just perform the query and return result without updating the GUI\n     * This utility is used in this class, can be potentially reused by other classes\n     * @param query\n     * @return matches List\n     */\n    @Override\n    public List<FsContent> performQuery() throws RuntimeException {\n        List<FsContent> matches = new ArrayList<FsContent>();\n\n        boolean allMatchesFetched = false;\n        final int ROWS_PER_FETCH = 10000;\n\n        Server.Core solrCore = KeywordSearch.getServer().getCore();\n\n        SolrQuery q = new SolrQuery();\n\n        q.setQuery(queryEscaped);\n        q.setRows(ROWS_PER_FETCH);\n        q.setFields(\"id\");\n\n        for (int start = 0; !allMatchesFetched; start = start + ROWS_PER_FETCH) {\n\n            q.setStart(start);\n\n            try {\n                QueryResponse response = solrCore.query(q, METHOD.POST);\n                SolrDocumentList resultList = response.getResults();\n                long results = resultList.getNumFound();\n\n                allMatchesFetched = start + ROWS_PER_FETCH >= results;\n\n                for (SolrDocument resultDoc : resultList) {\n                    long id = Long.parseLong((String) resultDoc.getFieldValue(\"id\"));\n\n                    SleuthkitCase sc = Case.getCurrentCase().getSleuthkitCase();\n\n                    // TODO: has to be a better way to get files. Also, need to \n                    // check that we actually get 1 hit for each id\n                    ResultSet rs = sc.runQuery(\"select * from tsk_files where obj_id=\" + id);\n                    matches.addAll(sc.resultSetToFsContents(rs));\n                    final Statement s = rs.getStatement();\n                    rs.close();\n                    if (s != null) {\n                        s.close();\n                    }\n                }\n\n            } catch (SolrServerException ex) {\n                logger.log(Level.WARNING, \"Error executing Lucene Solr Query: \" + query.substring(0, Math.min(query.length() - 1, 200)), ex);\n                throw new RuntimeException(ex);\n                // TODO: handle bad query strings, among other issues\n            } catch (SQLException ex) {\n                logger.log(Level.WARNING, \"Error interpreting results from Lucene Solr Query: \" + query, ex);\n            }\n\n        }\n        return matches;\n    }","commit_id":"7086ed3cf5c6c82137e61735049197b26948d329","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public static boolean imgpathexists(String path){\n    Case currentCase = Case.getCurrentCase(); // get the most updated case\n    SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n    \n    int count = 0;\n    try { \n     List<FsContent> FFSqlitedb;\n     ResultSet rs = tempDb.runQuery(\"select * from tsk_files where parent_path LIKE '%\"+ path + \"%'\");\n     FFSqlitedb = tempDb.resultSetToFsContents(rs);\n     count = FFSqlitedb.size();\n     rs.getStatement().close();\n     rs.close();\n    }\n    catch (SQLException ex) \n        {\n           //logger.log(Level.WARNING, \"Error while trying to contact SQLite db.\", ex);\n        }\n    finally {\n        \n        if(count > 0)\n            {\n            return true;\n            }\n        else\n            {\n             return false;\n            }\n        }    \n\n    }","id":102863,"modified_method":"public static boolean imgpathexists(String path){\n    Case currentCase = Case.getCurrentCase(); // get the most updated case\n    SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n    \n    int count = 0;\n    try { \n     List<FsContent> FFSqlitedb;\n     ResultSet rs = tempDb.runQuery(\"select * from tsk_files where parent_path LIKE '%\"+ path + \"%'\");\n     FFSqlitedb = tempDb.resultSetToFsContents(rs);\n     count = FFSqlitedb.size();\n     final Statement s = rs.getStatement();\n     rs.close();\n     if (s != null)\n        s.close();\n    }\n    catch (SQLException ex) \n        {\n           //logger.log(Level.WARNING, \"Error while trying to contact SQLite db.\", ex);\n        }\n    finally {\n        \n        if(count > 0)\n            {\n            return true;\n            }\n        else\n            {\n             return false;\n            }\n        }    \n\n    }","commit_id":"7086ed3cf5c6c82137e61735049197b26948d329","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public static HazelcastInstance getOrCreateHazelcastInstance(Config config) {\n        if (config == null) {\n            throw new NullPointerException(\"config can't be null\");\n        }\n\n        String name = config.getInstanceName();\n        hasText(name, \"instanceName\");\n\n        InstanceFuture future = INSTANCE_MAP.get(name);\n        if (future != null) {\n            return future.get();\n        }\n\n        future = new InstanceFuture();\n        InstanceFuture found = INSTANCE_MAP.putIfAbsent(name, future);\n        if (found != null) {\n            return found.get();\n        }\n\n        try {\n            HazelcastInstanceProxy hz = constructHazelcastInstance(config, name, new DefaultNodeContext());\n            future.set(hz);\n            return hz;\n        } catch (Throwable t) {\n            INSTANCE_MAP.remove(name, future);\n            future.setFailure(t);\n            throw ExceptionUtil.rethrow(t);\n        }\n    }","id":102864,"modified_method":"public static HazelcastInstance getOrCreateHazelcastInstance(Config config) {\n        if (config == null) {\n            throw new NullPointerException(\"config can't be null\");\n        }\n\n        String name = config.getInstanceName();\n        hasText(name, \"instanceName\");\n\n        InstanceFuture future = INSTANCE_MAP.get(name);\n        if (future != null) {\n            return future.get();\n        }\n\n        future = new InstanceFuture();\n        InstanceFuture found = INSTANCE_MAP.putIfAbsent(name, future);\n        if (found != null) {\n            return found.get();\n        }\n\n        try {\n            return constructHazelcastInstance(config, name, new DefaultNodeContext(), future);\n        } catch (Throwable t) {\n            INSTANCE_MAP.remove(name, future);\n            future.setFailure(t);\n            throw ExceptionUtil.rethrow(t);\n        }\n    }","commit_id":"fc77e2c99d0da9b05ea0a62234a5ac51fef9b963","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public static HazelcastInstance newHazelcastInstance(Config config, String instanceName,\n                                                              NodeContext nodeContext) {\n        if (config == null) {\n            config = new XmlConfigBuilder().build();\n        }\n\n        String name = instanceName;\n        if (name == null || name.trim().length() == 0) {\n            name = createInstanceName(config);\n        }\n\n        InstanceFuture future = new InstanceFuture();\n        if (INSTANCE_MAP.putIfAbsent(name, future) != null) {\n            throw new DuplicateInstanceNameException(\"HazelcastInstance with name '\" + name + \"' already exists!\");\n        }\n\n        try {\n            HazelcastInstanceProxy hz = constructHazelcastInstance(config, name, nodeContext);\n            future.set(hz);\n            return hz;\n        } catch (Throwable t) {\n            INSTANCE_MAP.remove(name, future);\n            future.setFailure(t);\n            throw ExceptionUtil.rethrow(t);\n        }\n    }","id":102865,"modified_method":"public static HazelcastInstance newHazelcastInstance(Config config, String instanceName,\n                                                              NodeContext nodeContext) {\n        if (config == null) {\n            config = new XmlConfigBuilder().build();\n        }\n\n        String name = instanceName;\n        if (name == null || name.trim().length() == 0) {\n            name = createInstanceName(config);\n        }\n\n        InstanceFuture future = new InstanceFuture();\n        if (INSTANCE_MAP.putIfAbsent(name, future) != null) {\n            throw new DuplicateInstanceNameException(\"HazelcastInstance with name '\" + name + \"' already exists!\");\n        }\n\n        try {\n            return constructHazelcastInstance(config, name, nodeContext, future);\n        } catch (Throwable t) {\n            INSTANCE_MAP.remove(name, future);\n            future.setFailure(t);\n            throw ExceptionUtil.rethrow(t);\n        }\n    }","commit_id":"fc77e2c99d0da9b05ea0a62234a5ac51fef9b963","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private static HazelcastInstanceProxy constructHazelcastInstance(Config config, String instanceName,\n                                                                     NodeContext nodeContext) {\n        final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\n        HazelcastInstanceProxy proxy;\n        try {\n            if (classLoader == null) {\n                Thread.currentThread().setContextClassLoader(HazelcastInstanceFactory.class.getClassLoader());\n            }\n            HazelcastInstanceImpl hazelcastInstance = new HazelcastInstanceImpl(instanceName, config, nodeContext);\n            OutOfMemoryErrorDispatcher.register(hazelcastInstance);\n            proxy = new HazelcastInstanceProxy(hazelcastInstance);\n            final Node node = hazelcastInstance.node;\n            final boolean firstMember = isFirstMember(node);\n            final int initialWaitSeconds = node.groupProperties.INITIAL_WAIT_SECONDS.getInteger();\n            if (initialWaitSeconds > 0) {\n                hazelcastInstance.logger.info(\"Waiting \"\n                        + initialWaitSeconds + \" seconds before completing HazelcastInstance startup...\");\n                try {\n                    Thread.sleep(TimeUnit.SECONDS.toMillis(initialWaitSeconds));\n                    if (firstMember) {\n                        node.partitionService.firstArrangement();\n                    } else {\n                        Thread.sleep(TimeUnit.SECONDS.toMillis(4));\n                    }\n                } catch (InterruptedException ignored) {\n                }\n            }\n            awaitMinimalClusterSize(hazelcastInstance, node, firstMember);\n            hazelcastInstance.lifecycleService.fireLifecycleEvent(STARTED);\n        } catch (Throwable t) {\n            throw ExceptionUtil.rethrow(t);\n        } finally {\n            Thread.currentThread().setContextClassLoader(classLoader);\n        }\n        return proxy;\n    }","id":102866,"modified_method":"private static HazelcastInstanceProxy constructHazelcastInstance(Config config, String instanceName,\n                                                                     NodeContext nodeContext, InstanceFuture future) {\n        final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\n        HazelcastInstanceProxy proxy;\n        try {\n            if (classLoader == null) {\n                Thread.currentThread().setContextClassLoader(HazelcastInstanceFactory.class.getClassLoader());\n            }\n            HazelcastInstanceImpl hazelcastInstance = new HazelcastInstanceImpl(instanceName, config, nodeContext);\n            OutOfMemoryErrorDispatcher.register(hazelcastInstance);\n            proxy = new HazelcastInstanceProxy(hazelcastInstance);\n            final Node node = hazelcastInstance.node;\n            final boolean firstMember = isFirstMember(node);\n            final int initialWaitSeconds = node.groupProperties.INITIAL_WAIT_SECONDS.getInteger();\n            if (initialWaitSeconds > 0) {\n                hazelcastInstance.logger.info(\"Waiting \"\n                        + initialWaitSeconds + \" seconds before completing HazelcastInstance startup...\");\n                try {\n                    Thread.sleep(TimeUnit.SECONDS.toMillis(initialWaitSeconds));\n                    if (firstMember) {\n                        node.partitionService.firstArrangement();\n                    } else {\n                        Thread.sleep(TimeUnit.SECONDS.toMillis(4));\n                    }\n                } catch (InterruptedException ignored) {\n                }\n            }\n            awaitMinimalClusterSize(hazelcastInstance, node, firstMember);\n            future.set(proxy);\n            hazelcastInstance.lifecycleService.fireLifecycleEvent(STARTED);\n        } catch (Throwable t) {\n            throw ExceptionUtil.rethrow(t);\n        } finally {\n            Thread.currentThread().setContextClassLoader(classLoader);\n        }\n        return proxy;\n    }","commit_id":"fc77e2c99d0da9b05ea0a62234a5ac51fef9b963","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private static HazelcastInstanceProxy constructHazelcastInstance(Config config, String instanceName, NodeContext nodeContext) {\n        final ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n\n        HazelcastInstanceProxy proxy;\n        try {\n            if (tccl == null) {\n                Thread.currentThread().setContextClassLoader(HazelcastInstanceFactory.class.getClassLoader());\n            }\n            final HazelcastInstanceImpl hazelcastInstance = new HazelcastInstanceImpl(instanceName, config, nodeContext);\n            OutOfMemoryErrorDispatcher.register(hazelcastInstance);\n            proxy = new HazelcastInstanceProxy(hazelcastInstance);\n            final Node node = hazelcastInstance.node;\n            final Iterator<Member> iter = node.getClusterService().getMembers().iterator();\n            final boolean firstMember = (iter.hasNext() && iter.next().localMember());\n            final int initialWaitSeconds = node.groupProperties.INITIAL_WAIT_SECONDS.getInteger();\n            if (initialWaitSeconds > 0) {\n                hazelcastInstance.logger.info(\"Waiting \" + initialWaitSeconds + \" seconds before completing HazelcastInstance startup...\");\n                try {\n                    Thread.sleep(initialWaitSeconds * 1000);\n                    if (firstMember) {\n                        node.partitionService.firstArrangement();\n                    } else {\n                        Thread.sleep(4 * 1000);\n                    }\n                } catch (InterruptedException ignored) {\n                }\n            }\n            final int initialMinClusterSize = node.groupProperties.INITIAL_MIN_CLUSTER_SIZE.getInteger();\n            while (node.getClusterService().getSize() < initialMinClusterSize) {\n                try {\n                    hazelcastInstance.logger.info(\"HazelcastInstance waiting for cluster size of \" + initialMinClusterSize);\n                    //noinspection BusyWait\n                    Thread.sleep(1000);\n                } catch (InterruptedException ignored) {\n                }\n            }\n            if (initialMinClusterSize > 1) {\n                if (firstMember) {\n                    node.partitionService.firstArrangement();\n                } else {\n                    Thread.sleep(3 * 1000);\n                }\n                hazelcastInstance.logger.info(\"HazelcastInstance starting after waiting for cluster size of \"\n                        + initialMinClusterSize);\n            }\n            hazelcastInstance.lifecycleService.fireLifecycleEvent(STARTED);\n        } catch (Throwable t) {\n            throw ExceptionUtil.rethrow(t);\n        } finally {\n            Thread.currentThread().setContextClassLoader(tccl);\n        }\n        return proxy;\n    }","id":102867,"modified_method":"private static HazelcastInstanceProxy constructHazelcastInstance(Config config, String instanceName,\n                                                                     NodeContext nodeContext, InstanceFuture future) {\n        final ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n\n        HazelcastInstanceProxy proxy;\n        try {\n            if (tccl == null) {\n                Thread.currentThread().setContextClassLoader(HazelcastInstanceFactory.class.getClassLoader());\n            }\n            final HazelcastInstanceImpl hazelcastInstance = new HazelcastInstanceImpl(instanceName, config, nodeContext);\n            OutOfMemoryErrorDispatcher.register(hazelcastInstance);\n            proxy = new HazelcastInstanceProxy(hazelcastInstance);\n            final Node node = hazelcastInstance.node;\n            final Iterator<Member> iter = node.getClusterService().getMembers().iterator();\n            final boolean firstMember = (iter.hasNext() && iter.next().localMember());\n            final int initialWaitSeconds = node.groupProperties.INITIAL_WAIT_SECONDS.getInteger();\n            if (initialWaitSeconds > 0) {\n                hazelcastInstance.logger.info(\"Waiting \" + initialWaitSeconds + \" seconds before completing HazelcastInstance startup...\");\n                try {\n                    Thread.sleep(initialWaitSeconds * 1000);\n                    if (firstMember) {\n                        node.partitionService.firstArrangement();\n                    } else {\n                        Thread.sleep(4 * 1000);\n                    }\n                } catch (InterruptedException ignored) {\n                }\n            }\n            final int initialMinClusterSize = node.groupProperties.INITIAL_MIN_CLUSTER_SIZE.getInteger();\n            while (node.getClusterService().getSize() < initialMinClusterSize) {\n                try {\n                    hazelcastInstance.logger.info(\"HazelcastInstance waiting for cluster size of \" + initialMinClusterSize);\n                    //noinspection BusyWait\n                    Thread.sleep(1000);\n                } catch (InterruptedException ignored) {\n                }\n            }\n            if (initialMinClusterSize > 1) {\n                if (firstMember) {\n                    node.partitionService.firstArrangement();\n                } else {\n                    Thread.sleep(3 * 1000);\n                }\n                hazelcastInstance.logger.info(\"HazelcastInstance starting after waiting for cluster size of \"\n                        + initialMinClusterSize);\n            }\n            future.set(proxy);\n            hazelcastInstance.lifecycleService.fireLifecycleEvent(STARTED);\n        } catch (Throwable t) {\n            throw ExceptionUtil.rethrow(t);\n        } finally {\n            Thread.currentThread().setContextClassLoader(tccl);\n        }\n        return proxy;\n    }","commit_id":"25c70ec64e97d3f232cb9855e36ddd50a767f3aa","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public static HazelcastInstance getOrCreateHazelcastInstance(Config config) {\n        if (config == null) {\n            throw new NullPointerException(\"config can't be null\");\n        }\n\n        String name = config.getInstanceName();\n        hasText(name, \"instanceName\");\n\n        InstanceFuture future = instanceMap.get(name);\n        if (future != null) {\n            return future.get();\n        }\n\n        future = new InstanceFuture();\n        InstanceFuture found = instanceMap.putIfAbsent(name, future);\n        if (found != null) {\n            return found.get();\n        }\n\n        try {\n            HazelcastInstanceProxy hz = constructHazelcastInstance(config, name, new DefaultNodeContext());\n            future.set(hz);\n            return hz;\n        } catch (Throwable t) {\n            instanceMap.remove(name, future);\n            future.setFailure(t);\n            throw ExceptionUtil.rethrow(t);\n        }\n    }","id":102868,"modified_method":"public static HazelcastInstance getOrCreateHazelcastInstance(Config config) {\n        if (config == null) {\n            throw new NullPointerException(\"config can't be null\");\n        }\n\n        String name = config.getInstanceName();\n        hasText(name, \"instanceName\");\n\n        InstanceFuture future = instanceMap.get(name);\n        if (future != null) {\n            return future.get();\n        }\n\n        future = new InstanceFuture();\n        InstanceFuture found = instanceMap.putIfAbsent(name, future);\n        if (found != null) {\n            return found.get();\n        }\n\n        try {\n            return constructHazelcastInstance(config, name, new DefaultNodeContext(), future);\n        } catch (Throwable t) {\n            instanceMap.remove(name, future);\n            future.setFailure(t);\n            throw ExceptionUtil.rethrow(t);\n        }\n    }","commit_id":"25c70ec64e97d3f232cb9855e36ddd50a767f3aa","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public static HazelcastInstance newHazelcastInstance(Config config, String instanceName, NodeContext nodeContext) {\n        if (config == null) {\n            config = new XmlConfigBuilder().build();\n        }\n\n        String name = instanceName;\n        if (name == null || name.trim().length() == 0) {\n            name = createInstanceName(config);\n        }\n\n        InstanceFuture future = new InstanceFuture();\n        if (instanceMap.putIfAbsent(name, future) != null) {\n            throw new DuplicateInstanceNameException(\"HazelcastInstance with name '\" + name + \"' already exists!\");\n        }\n\n        try {\n            HazelcastInstanceProxy hz = constructHazelcastInstance(config, name, nodeContext);\n            future.set(hz);\n            return hz;\n        } catch (Throwable t) {\n            instanceMap.remove(name, future);\n            future.setFailure(t);\n            throw ExceptionUtil.rethrow(t);\n        }\n    }","id":102869,"modified_method":"public static HazelcastInstance newHazelcastInstance(Config config, String instanceName, NodeContext nodeContext) {\n        if (config == null) {\n            config = new XmlConfigBuilder().build();\n        }\n\n        String name = instanceName;\n        if (name == null || name.trim().length() == 0) {\n            name = createInstanceName(config);\n        }\n\n        InstanceFuture future = new InstanceFuture();\n        if (instanceMap.putIfAbsent(name, future) != null) {\n            throw new DuplicateInstanceNameException(\"HazelcastInstance with name '\" + name + \"' already exists!\");\n        }\n\n        try {\n            return constructHazelcastInstance(config, name, nodeContext, future);\n        } catch (Throwable t) {\n            instanceMap.remove(name, future);\n            future.setFailure(t);\n            throw ExceptionUtil.rethrow(t);\n        }\n    }","commit_id":"25c70ec64e97d3f232cb9855e36ddd50a767f3aa","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Starts Neo4j with default configuration\n     * @param graphDb The graph database service.\n     *\n     * @param storeDir path to directory where Neo4j store is located\n     * @param create if true a new Neo4j store will be created if no store exist\n     *            at <CODE>storeDir<\/CODE>\n     * @param configuration parameters\n     * @throws StartupFailedException if unable to start\n     */\n    public synchronized Map<Object, Object> start(\n            GraphDatabaseService graphDb,\n            Map<String, String> stringParams, KernelPanicEventGenerator kpe,\n            TxEventSyncHookFactory syncHookFactory )\n    {\n        if ( started )\n        {\n            throw new IllegalStateException( \"Neo4j instance already started\" );\n        }\n        Map<Object, Object> params = getDefaultParams();\n        boolean useMemoryMapped = true;\n        if ( stringParams.containsKey( Config.USE_MEMORY_MAPPED_BUFFERS ) )\n        {\n            params.put( Config.USE_MEMORY_MAPPED_BUFFERS, \n                    stringParams.get( Config.USE_MEMORY_MAPPED_BUFFERS ) );\n        }\n        if ( \"false\".equals( params.get( Config.USE_MEMORY_MAPPED_BUFFERS ) ) )\n        {\n            useMemoryMapped = false;\n        }\n        boolean dump = false;\n        if ( \"true\".equals( stringParams.get( Config.DUMP_CONFIGURATION ) ) )\n        {\n            dump = true;\n        }\n        storeDir = FileUtils.fixSeparatorsInPath( storeDir );\n        new AutoConfigurator( storeDir, useMemoryMapped, dump ).configure( params );\n        for ( Map.Entry<String, String> entry : stringParams.entrySet() )\n        {\n            params.put( entry.getKey(), entry.getValue() );\n        }\n        config = new Config( graphDb, storeDir, params, kpe );\n\n        String separator = System.getProperty( \"file.separator\" );\n        String store = storeDir + separator + \"neostore\";\n        params.put( \"store_dir\", storeDir );\n        params.put( \"neo_store\", store );\n        params.put( \"create\", String.valueOf( create ) );\n        String logicalLog = storeDir + separator + \"nioneo_logical.log\";\n        params.put( \"logical_log\", logicalLog );\n        byte resourceId[] = \"414141\".getBytes();\n        params.put( LockManager.class, config.getLockManager() );\n        params.put( LockReleaser.class, config.getLockReleaser() );\n        config.getTxModule().registerDataSource( Config.DEFAULT_DATA_SOURCE_NAME,\n                Config.NIO_NEO_DB_CLASS, resourceId, params );\n        // hack for lucene index recovery if in path\n        if ( !config.isReadOnly() || config.isBackupSlave() )\n        {\n            try\n            {\n                Class clazz = Class.forName( Config.LUCENE_DS_CLASS );\n                cleanWriteLocksInLuceneDirectory( storeDir + \"/lucene\" );\n                byte luceneId[] = \"162373\".getBytes();\n                registerLuceneDataSource( \"lucene\", clazz.getName(),\n                        config.getTxModule(), storeDir + \"/lucene\",\n                        config.getLockManager(), luceneId, params );\n                clazz = Class.forName( Config.LUCENE_FULLTEXT_DS_CLASS );\n                cleanWriteLocksInLuceneDirectory( storeDir + \"/lucene-fulltext\" );\n                luceneId = \"262374\".getBytes();\n                registerLuceneDataSource( \"lucene-fulltext\",\n                        clazz.getName(), config.getTxModule(),\n                        storeDir + \"/lucene-fulltext\", config.getLockManager(),\n                        luceneId, params );\n            }\n            catch ( ClassNotFoundException e )\n            { // ok index util not on class path\n            }\n        }\n        persistenceSource = new NioNeoDbPersistenceSource();\n        config.setPersistenceSource( Config.DEFAULT_DATA_SOURCE_NAME, create );\n        config.getIdGeneratorModule().setPersistenceSourceInstance(\n                persistenceSource );\n        config.getTxModule().init();\n        config.getPersistenceModule().init();\n        persistenceSource.init();\n        config.getIdGeneratorModule().init();\n        config.getGraphDbModule().init();\n\n        config.getTxModule().start();\n        config.getPersistenceModule().start(\n                config.getTxModule().getTxManager(), persistenceSource,\n                syncHookFactory );\n        persistenceSource.start( config.getTxModule().getXaDataSourceManager() );\n        config.getIdGeneratorModule().start();\n        config.getGraphDbModule().start( config.getLockReleaser(),\n                config.getPersistenceModule().getPersistenceManager(), params );\n        if ( \"true\".equals( params.get( Config.DUMP_CONFIGURATION ) ) )\n        {\n            for ( Object key : params.keySet() )\n            {\n                if ( key instanceof String )\n                {\n                    Object value = params.get( key );\n                    if ( value instanceof String )\n                    {\n                        System.out.println( key + \"=\" + value );\n                    }\n                }\n            }\n        }\n        started = true;\n        return Collections.unmodifiableMap( params );\n    }","id":102870,"modified_method":"/**\n     * Starts Neo4j with default configuration\n     * @param graphDb The graph database service.\n     *\n     * @param storeDir path to directory where Neo4j store is located\n     * @param create if true a new Neo4j store will be created if no store exist\n     *            at <CODE>storeDir<\/CODE>\n     * @param configuration parameters\n     * @throws StartupFailedException if unable to start\n     */\n    public synchronized Map<Object, Object> start(\n            GraphDatabaseService graphDb,\n            Map<String, String> stringParams, KernelPanicEventGenerator kpe,\n            TxEventSyncHookFactory syncHookFactory )\n    {\n        if ( started )\n        {\n            throw new IllegalStateException( \"Neo4j instance already started\" );\n        }\n        Map<Object, Object> params = getDefaultParams();\n        boolean useMemoryMapped = true;\n        if ( stringParams.containsKey( Config.USE_MEMORY_MAPPED_BUFFERS ) )\n        {\n            params.put( Config.USE_MEMORY_MAPPED_BUFFERS, \n                    stringParams.get( Config.USE_MEMORY_MAPPED_BUFFERS ) );\n        }\n        if ( \"false\".equals( params.get( Config.USE_MEMORY_MAPPED_BUFFERS ) ) )\n        {\n            useMemoryMapped = false;\n        }\n        boolean dump = false;\n        if ( \"true\".equals( stringParams.get( Config.DUMP_CONFIGURATION ) ) )\n        {\n            dump = true;\n        }\n        storeDir = FileUtils.fixSeparatorsInPath( storeDir );\n        new AutoConfigurator( storeDir, useMemoryMapped, dump ).configure( params );\n        for ( Map.Entry<String, String> entry : stringParams.entrySet() )\n        {\n            params.put( entry.getKey(), entry.getValue() );\n        }\n        config = new Config( graphDb, storeDir, params, kpe );\n\n        String separator = System.getProperty( \"file.separator\" );\n        String store = storeDir + separator + \"neostore\";\n        params.put( \"store_dir\", storeDir );\n        params.put( \"neo_store\", store );\n        params.put( \"create\", String.valueOf( create ) );\n        String logicalLog = storeDir + separator + \"nioneo_logical.log\";\n        params.put( \"logical_log\", logicalLog );\n        byte resourceId[] = \"414141\".getBytes();\n        params.put( LockManager.class, config.getLockManager() );\n        params.put( LockReleaser.class, config.getLockReleaser() );\n        config.getTxModule().registerDataSource( Config.DEFAULT_DATA_SOURCE_NAME,\n                Config.NIO_NEO_DB_CLASS, resourceId, params );\n        // hack for lucene index recovery if in path\n        if ( !config.isReadOnly() || config.isBackupSlave() )\n        {\n            try\n            {\n                Class clazz = Class.forName( Config.LUCENE_DS_CLASS );\n                cleanWriteLocksInLuceneDirectory( storeDir + \"/lucene\" );\n                byte luceneId[] = \"162373\".getBytes();\n                registerLuceneDataSource( \"lucene\", clazz.getName(),\n                        config.getTxModule(), storeDir + \"/lucene\",\n                        config.getLockManager(), luceneId, params );\n            }\n            catch ( ClassNotFoundException e )\n            { // ok index util not on class path\n            }\n            \n            try\n            {\n                Class clazz = Class.forName( Config.LUCENE_FULLTEXT_DS_CLASS );\n                cleanWriteLocksInLuceneDirectory( storeDir + \"/lucene-fulltext\" );\n                byte[] luceneId = \"262374\".getBytes();\n                registerLuceneDataSource( \"lucene-fulltext\",\n                        clazz.getName(), config.getTxModule(),\n                        storeDir + \"/lucene-fulltext\", config.getLockManager(),\n                        luceneId, params );\n            }\n            catch ( ClassNotFoundException e )\n            { // ok index util not on class path\n            }\n        }\n        persistenceSource = new NioNeoDbPersistenceSource();\n        config.setPersistenceSource( Config.DEFAULT_DATA_SOURCE_NAME, create );\n        config.getIdGeneratorModule().setPersistenceSourceInstance(\n                persistenceSource );\n        config.getTxModule().init();\n        config.getPersistenceModule().init();\n        persistenceSource.init();\n        config.getIdGeneratorModule().init();\n        config.getGraphDbModule().init();\n\n        config.getTxModule().start();\n        config.getPersistenceModule().start(\n                config.getTxModule().getTxManager(), persistenceSource,\n                syncHookFactory );\n        persistenceSource.start( config.getTxModule().getXaDataSourceManager() );\n        config.getIdGeneratorModule().start();\n        config.getGraphDbModule().start( config.getLockReleaser(),\n                config.getPersistenceModule().getPersistenceManager(), params );\n        if ( \"true\".equals( params.get( Config.DUMP_CONFIGURATION ) ) )\n        {\n            for ( Object key : params.keySet() )\n            {\n                if ( key instanceof String )\n                {\n                    Object value = params.get( key );\n                    if ( value instanceof String )\n                    {\n                        System.out.println( key + \"=\" + value );\n                    }\n                }\n            }\n        }\n        started = true;\n        return Collections.unmodifiableMap( params );\n    }","commit_id":"79c341ea106feab1bbd0adb3df87cebe5e017ebd","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Starts Neo4j with default configuration\n     * @param graphDb The graph database service.\n     *\n     * @param storeDir path to directory where Neo4j store is located\n     * @param create if true a new Neo4j store will be created if no store exist\n     *            at <CODE>storeDir<\/CODE>\n     * @param configuration parameters\n     * @throws StartupFailedException if unable to start\n     */\n    public synchronized Map<Object, Object> start(\n            GraphDatabaseService graphDb,\n            Map<String, String> stringParams, KernelPanicEventGenerator kpe,\n            TxEventSyncHookFactory syncHookFactory )\n    {\n        if ( started )\n        {\n            throw new IllegalStateException( \"Neo4j instance already started\" );\n        }\n        Map<Object, Object> params = getDefaultParams();\n        boolean useMemoryMapped = true;\n        if ( stringParams.containsKey( Config.USE_MEMORY_MAPPED_BUFFERS ) )\n        {\n            params.put( Config.USE_MEMORY_MAPPED_BUFFERS, \n                    stringParams.get( Config.USE_MEMORY_MAPPED_BUFFERS ) );\n        }\n        if ( \"false\".equals( params.get( Config.USE_MEMORY_MAPPED_BUFFERS ) ) )\n        {\n            useMemoryMapped = false;\n        }\n        boolean dump = false;\n        if ( \"true\".equals( stringParams.get( Config.DUMP_CONFIGURATION ) ) )\n        {\n            dump = true;\n        }\n        storeDir = FileUtils.fixSeparatorsInPath( storeDir );\n        new AutoConfigurator( storeDir, useMemoryMapped, dump ).configure( params );\n        for ( Map.Entry<String, String> entry : stringParams.entrySet() )\n        {\n            params.put( entry.getKey(), entry.getValue() );\n        }\n        config = new Config( graphDb, storeDir, params, kpe );\n\n        String separator = System.getProperty( \"file.separator\" );\n        String store = storeDir + separator + \"neostore\";\n        params.put( \"store_dir\", storeDir );\n        params.put( \"neo_store\", store );\n        params.put( \"create\", String.valueOf( create ) );\n        String logicalLog = storeDir + separator + \"nioneo_logical.log\";\n        params.put( \"logical_log\", logicalLog );\n        byte resourceId[] = \"414141\".getBytes();\n        params.put( LockManager.class, config.getLockManager() );\n        params.put( LockReleaser.class, config.getLockReleaser() );\n        config.getTxModule().registerDataSource( Config.DEFAULT_DATA_SOURCE_NAME,\n                Config.NIO_NEO_DB_CLASS, resourceId, params );\n        // hack for lucene index recovery if in path\n        if ( !config.isReadOnly() || config.isBackupSlave() )\n        {\n            try\n            {\n                Class clazz = Class.forName( Config.LUCENE_DS_CLASS );\n                cleanWriteLocksInLuceneDirectory( storeDir + \"/lucene\" );\n                byte luceneId[] = \"162373\".getBytes();\n                registerLuceneDataSource( \"lucene\", clazz.getName(),\n                        config.getTxModule(), storeDir + \"/lucene\",\n                        config.getLockManager(), luceneId, params );\n                clazz = Class.forName( Config.LUCENE_FULLTEXT_DS_CLASS );\n                cleanWriteLocksInLuceneDirectory( storeDir + \"/lucene-fulltext\" );\n                luceneId = \"262374\".getBytes();\n                registerLuceneDataSource( \"lucene-fulltext\",\n                        clazz.getName(), config.getTxModule(),\n                        storeDir + \"/lucene-fulltext\", config.getLockManager(),\n                        luceneId, params );\n            }\n            catch ( ClassNotFoundException e )\n            { // ok index util not on class path\n            }\n        }\n        persistenceSource = new NioNeoDbPersistenceSource();\n        config.setPersistenceSource( Config.DEFAULT_DATA_SOURCE_NAME, create );\n        config.getIdGeneratorModule().setPersistenceSourceInstance(\n                persistenceSource );\n        config.getTxModule().init();\n        config.getPersistenceModule().init();\n        persistenceSource.init();\n        config.getIdGeneratorModule().init();\n        config.getGraphDbModule().init();\n\n        config.getTxModule().start();\n        config.getPersistenceModule().start(\n                config.getTxModule().getTxManager(), persistenceSource,\n                syncHookFactory );\n        persistenceSource.start( config.getTxModule().getXaDataSourceManager() );\n        config.getIdGeneratorModule().start();\n        config.getGraphDbModule().start( config.getLockReleaser(),\n                config.getPersistenceModule().getPersistenceManager(), params );\n        if ( \"true\".equals( params.get( Config.DUMP_CONFIGURATION ) ) )\n        {\n            for ( Object key : params.keySet() )\n            {\n                if ( key instanceof String )\n                {\n                    Object value = params.get( key );\n                    if ( value instanceof String )\n                    {\n                        System.out.println( key + \"=\" + value );\n                    }\n                }\n            }\n        }\n        started = true;\n        return Collections.unmodifiableMap( params );\n    }","id":102871,"modified_method":"/**\n     * Starts Neo4j with default configuration\n     * @param graphDb The graph database service.\n     *\n     * @param storeDir path to directory where Neo4j store is located\n     * @param create if true a new Neo4j store will be created if no store exist\n     *            at <CODE>storeDir<\/CODE>\n     * @param configuration parameters\n     * @throws StartupFailedException if unable to start\n     */\n    public synchronized Map<Object, Object> start(\n            GraphDatabaseService graphDb,\n            Map<String, String> stringParams, KernelPanicEventGenerator kpe,\n            TxEventSyncHookFactory syncHookFactory )\n    {\n        if ( started )\n        {\n            throw new IllegalStateException( \"Neo4j instance already started\" );\n        }\n        Map<Object, Object> params = getDefaultParams();\n        boolean useMemoryMapped = true;\n        if ( stringParams.containsKey( Config.USE_MEMORY_MAPPED_BUFFERS ) )\n        {\n            params.put( Config.USE_MEMORY_MAPPED_BUFFERS, \n                    stringParams.get( Config.USE_MEMORY_MAPPED_BUFFERS ) );\n        }\n        if ( \"false\".equals( params.get( Config.USE_MEMORY_MAPPED_BUFFERS ) ) )\n        {\n            useMemoryMapped = false;\n        }\n        boolean dump = false;\n        if ( \"true\".equals( stringParams.get( Config.DUMP_CONFIGURATION ) ) )\n        {\n            dump = true;\n        }\n        storeDir = FileUtils.fixSeparatorsInPath( storeDir );\n        new AutoConfigurator( storeDir, useMemoryMapped, dump ).configure( params );\n        for ( Map.Entry<String, String> entry : stringParams.entrySet() )\n        {\n            params.put( entry.getKey(), entry.getValue() );\n        }\n        config = new Config( graphDb, storeDir, params, kpe );\n\n        String separator = System.getProperty( \"file.separator\" );\n        String store = storeDir + separator + \"neostore\";\n        params.put( \"store_dir\", storeDir );\n        params.put( \"neo_store\", store );\n        params.put( \"create\", String.valueOf( create ) );\n        String logicalLog = storeDir + separator + \"nioneo_logical.log\";\n        params.put( \"logical_log\", logicalLog );\n        byte resourceId[] = \"414141\".getBytes();\n        params.put( LockManager.class, config.getLockManager() );\n        params.put( LockReleaser.class, config.getLockReleaser() );\n        config.getTxModule().registerDataSource( Config.DEFAULT_DATA_SOURCE_NAME,\n                Config.NIO_NEO_DB_CLASS, resourceId, params );\n        // hack for lucene index recovery if in path\n        if ( !config.isReadOnly() || config.isBackupSlave() )\n        {\n            try\n            {\n                Class clazz = Class.forName( Config.LUCENE_DS_CLASS );\n                cleanWriteLocksInLuceneDirectory( storeDir + \"/lucene\" );\n                byte luceneId[] = \"162373\".getBytes();\n                registerLuceneDataSource( \"lucene\", clazz.getName(),\n                        config.getTxModule(), storeDir + \"/lucene\",\n                        config.getLockManager(), luceneId, params );\n            }\n            catch ( ClassNotFoundException e )\n            { // ok index util not on class path\n            }\n            \n            try\n            {\n                Class clazz = Class.forName( Config.LUCENE_FULLTEXT_DS_CLASS );\n                cleanWriteLocksInLuceneDirectory( storeDir + \"/lucene-fulltext\" );\n                byte[] luceneId = \"262374\".getBytes();\n                registerLuceneDataSource( \"lucene-fulltext\",\n                        clazz.getName(), config.getTxModule(),\n                        storeDir + \"/lucene-fulltext\", config.getLockManager(),\n                        luceneId, params );\n            }\n            catch ( ClassNotFoundException e )\n            { // ok index util not on class path\n            }\n        }\n        persistenceSource = new NioNeoDbPersistenceSource();\n        config.setPersistenceSource( Config.DEFAULT_DATA_SOURCE_NAME, create );\n        config.getIdGeneratorModule().setPersistenceSourceInstance(\n                persistenceSource );\n        config.getTxModule().init();\n        config.getPersistenceModule().init();\n        persistenceSource.init();\n        config.getIdGeneratorModule().init();\n        config.getGraphDbModule().init();\n\n        config.getTxModule().start();\n        config.getPersistenceModule().start(\n                config.getTxModule().getTxManager(), persistenceSource,\n                syncHookFactory );\n        persistenceSource.start( config.getTxModule().getXaDataSourceManager() );\n        config.getIdGeneratorModule().start();\n        config.getGraphDbModule().start( config.getLockReleaser(),\n                config.getPersistenceModule().getPersistenceManager(), params );\n        if ( \"true\".equals( params.get( Config.DUMP_CONFIGURATION ) ) )\n        {\n            for ( Object key : params.keySet() )\n            {\n                if ( key instanceof String )\n                {\n                    Object value = params.get( key );\n                    if ( value instanceof String )\n                    {\n                        System.out.println( key + \"=\" + value );\n                    }\n                }\n            }\n        }\n        started = true;\n        return Collections.unmodifiableMap( params );\n    }","commit_id":"6b53d409a463e6b22b214cad7410c56e30009acb","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Starts Neo4j with default configuration\n     * @param graphDb The graph database service.\n     *\n     * @param storeDir path to directory where Neo4j store is located\n     * @param create if true a new Neo4j store will be created if no store exist\n     *            at <CODE>storeDir<\/CODE>\n     * @param configuration parameters\n     * @throws StartupFailedException if unable to start\n     */\n    public synchronized Map<Object, Object> start(\n            GraphDatabaseService graphDb,\n            Map<String, String> stringParams, KernelPanicEventGenerator kpe,\n            TxEventSyncHookFactory syncHookFactory )\n    {\n        if ( started )\n        {\n            throw new IllegalStateException( \"Neo4j instance already started\" );\n        }\n        Map<Object, Object> params = getDefaultParams();\n        boolean useMemoryMapped = true;\n        if ( stringParams.containsKey( Config.USE_MEMORY_MAPPED_BUFFERS ) )\n        {\n            params.put( Config.USE_MEMORY_MAPPED_BUFFERS, \n                    stringParams.get( Config.USE_MEMORY_MAPPED_BUFFERS ) );\n        }\n        if ( \"false\".equals( params.get( Config.USE_MEMORY_MAPPED_BUFFERS ) ) )\n        {\n            useMemoryMapped = false;\n        }\n        boolean dump = false;\n        if ( \"true\".equals( stringParams.get( Config.DUMP_CONFIGURATION ) ) )\n        {\n            dump = true;\n        }\n        storeDir = FileUtils.fixSeparatorsInPath( storeDir );\n        new AutoConfigurator( storeDir, useMemoryMapped, dump ).configure( params );\n        for ( Map.Entry<String, String> entry : stringParams.entrySet() )\n        {\n            params.put( entry.getKey(), entry.getValue() );\n        }\n        config = new Config( graphDb, storeDir, params, kpe );\n\n        String separator = System.getProperty( \"file.separator\" );\n        String store = storeDir + separator + \"neostore\";\n        params.put( \"store_dir\", storeDir );\n        params.put( \"neo_store\", store );\n        params.put( \"create\", String.valueOf( create ) );\n        String logicalLog = storeDir + separator + \"nioneo_logical.log\";\n        params.put( \"logical_log\", logicalLog );\n        byte resourceId[] = \"414141\".getBytes();\n        params.put( LockManager.class, config.getLockManager() );\n        params.put( LockReleaser.class, config.getLockReleaser() );\n        config.getTxModule().registerDataSource( Config.DEFAULT_DATA_SOURCE_NAME,\n                Config.NIO_NEO_DB_CLASS, resourceId, params );\n        // hack for lucene index recovery if in path\n        if ( !config.isReadOnly() || config.isBackupSlave() )\n        {\n            try\n            {\n                Class clazz = Class.forName( Config.LUCENE_DS_CLASS );\n                cleanWriteLocksInLuceneDirectory( storeDir + \"/lucene\" );\n                byte luceneId[] = \"162373\".getBytes();\n                registerLuceneDataSource( \"lucene\", clazz.getName(),\n                        config.getTxModule(), storeDir + \"/lucene\",\n                        config.getLockManager(), luceneId, params );\n                clazz = Class.forName( Config.LUCENE_FULLTEXT_DS_CLASS );\n                cleanWriteLocksInLuceneDirectory( storeDir + \"/lucene-fulltext\" );\n                luceneId = \"262374\".getBytes();\n                registerLuceneDataSource( \"lucene-fulltext\",\n                        clazz.getName(), config.getTxModule(),\n                        storeDir + \"/lucene-fulltext\", config.getLockManager(),\n                        luceneId, params );\n            }\n            catch ( ClassNotFoundException e )\n            { // ok index util not on class path\n            }\n        }\n        persistenceSource = new NioNeoDbPersistenceSource();\n        config.setPersistenceSource( Config.DEFAULT_DATA_SOURCE_NAME, create );\n        config.getIdGeneratorModule().setPersistenceSourceInstance(\n                persistenceSource );\n        config.getTxModule().init();\n        config.getPersistenceModule().init();\n        persistenceSource.init();\n        config.getIdGeneratorModule().init();\n        config.getGraphDbModule().init();\n\n        config.getTxModule().start();\n        config.getPersistenceModule().start(\n                config.getTxModule().getTxManager(), persistenceSource,\n                syncHookFactory );\n        persistenceSource.start( config.getTxModule().getXaDataSourceManager() );\n        config.getIdGeneratorModule().start();\n        config.getGraphDbModule().start( config.getLockReleaser(),\n                config.getPersistenceModule().getPersistenceManager(), params );\n        if ( \"true\".equals( params.get( Config.DUMP_CONFIGURATION ) ) )\n        {\n            for ( Object key : params.keySet() )\n            {\n                if ( key instanceof String )\n                {\n                    Object value = params.get( key );\n                    if ( value instanceof String )\n                    {\n                        System.out.println( key + \"=\" + value );\n                    }\n                }\n            }\n        }\n        started = true;\n        return Collections.unmodifiableMap( params );\n    }","id":102872,"modified_method":"/**\n     * Starts Neo4j with default configuration\n     * @param graphDb The graph database service.\n     *\n     * @param storeDir path to directory where Neo4j store is located\n     * @param create if true a new Neo4j store will be created if no store exist\n     *            at <CODE>storeDir<\/CODE>\n     * @param configuration parameters\n     * @throws StartupFailedException if unable to start\n     */\n    public synchronized Map<Object, Object> start(\n            GraphDatabaseService graphDb,\n            Map<String, String> stringParams, KernelPanicEventGenerator kpe,\n            TxEventSyncHookFactory syncHookFactory )\n    {\n        if ( started )\n        {\n            throw new IllegalStateException( \"Neo4j instance already started\" );\n        }\n        Map<Object, Object> params = getDefaultParams();\n        boolean useMemoryMapped = true;\n        if ( stringParams.containsKey( Config.USE_MEMORY_MAPPED_BUFFERS ) )\n        {\n            params.put( Config.USE_MEMORY_MAPPED_BUFFERS, \n                    stringParams.get( Config.USE_MEMORY_MAPPED_BUFFERS ) );\n        }\n        if ( \"false\".equals( params.get( Config.USE_MEMORY_MAPPED_BUFFERS ) ) )\n        {\n            useMemoryMapped = false;\n        }\n        boolean dump = false;\n        if ( \"true\".equals( stringParams.get( Config.DUMP_CONFIGURATION ) ) )\n        {\n            dump = true;\n        }\n        storeDir = FileUtils.fixSeparatorsInPath( storeDir );\n        new AutoConfigurator( storeDir, useMemoryMapped, dump ).configure( params );\n        for ( Map.Entry<String, String> entry : stringParams.entrySet() )\n        {\n            params.put( entry.getKey(), entry.getValue() );\n        }\n        config = new Config( graphDb, storeDir, params, kpe );\n\n        String separator = System.getProperty( \"file.separator\" );\n        String store = storeDir + separator + \"neostore\";\n        params.put( \"store_dir\", storeDir );\n        params.put( \"neo_store\", store );\n        params.put( \"create\", String.valueOf( create ) );\n        String logicalLog = storeDir + separator + \"nioneo_logical.log\";\n        params.put( \"logical_log\", logicalLog );\n        byte resourceId[] = \"414141\".getBytes();\n        params.put( LockManager.class, config.getLockManager() );\n        params.put( LockReleaser.class, config.getLockReleaser() );\n        config.getTxModule().registerDataSource( Config.DEFAULT_DATA_SOURCE_NAME,\n                Config.NIO_NEO_DB_CLASS, resourceId, params );\n        // hack for lucene index recovery if in path\n        if ( !config.isReadOnly() || config.isBackupSlave() )\n        {\n            try\n            {\n                Class clazz = Class.forName( Config.LUCENE_DS_CLASS );\n                cleanWriteLocksInLuceneDirectory( storeDir + \"/lucene\" );\n                byte luceneId[] = \"162373\".getBytes();\n                registerLuceneDataSource( \"lucene\", clazz.getName(),\n                        config.getTxModule(), storeDir + \"/lucene\",\n                        config.getLockManager(), luceneId, params );\n            }\n            catch ( ClassNotFoundException e )\n            { // ok index util not on class path\n            }\n            \n            try\n            {\n                Class clazz = Class.forName( Config.LUCENE_FULLTEXT_DS_CLASS );\n                cleanWriteLocksInLuceneDirectory( storeDir + \"/lucene-fulltext\" );\n                byte[] luceneId = \"262374\".getBytes();\n                registerLuceneDataSource( \"lucene-fulltext\",\n                        clazz.getName(), config.getTxModule(),\n                        storeDir + \"/lucene-fulltext\", config.getLockManager(),\n                        luceneId, params );\n            }\n            catch ( ClassNotFoundException e )\n            { // ok index util not on class path\n            }\n        }\n        persistenceSource = new NioNeoDbPersistenceSource();\n        config.setPersistenceSource( Config.DEFAULT_DATA_SOURCE_NAME, create );\n        config.getIdGeneratorModule().setPersistenceSourceInstance(\n                persistenceSource );\n        config.getTxModule().init();\n        config.getPersistenceModule().init();\n        persistenceSource.init();\n        config.getIdGeneratorModule().init();\n        config.getGraphDbModule().init();\n\n        config.getTxModule().start();\n        config.getPersistenceModule().start(\n                config.getTxModule().getTxManager(), persistenceSource,\n                syncHookFactory );\n        persistenceSource.start( config.getTxModule().getXaDataSourceManager() );\n        config.getIdGeneratorModule().start();\n        config.getGraphDbModule().start( config.getLockReleaser(),\n                config.getPersistenceModule().getPersistenceManager(), params );\n        if ( \"true\".equals( params.get( Config.DUMP_CONFIGURATION ) ) )\n        {\n            for ( Object key : params.keySet() )\n            {\n                if ( key instanceof String )\n                {\n                    Object value = params.get( key );\n                    if ( value instanceof String )\n                    {\n                        System.out.println( key + \"=\" + value );\n                    }\n                }\n            }\n        }\n        started = true;\n        return Collections.unmodifiableMap( params );\n    }","commit_id":"33827b9fc976b8457a333d23a987c055e7567a08","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Iterable<Node> get( IndexProvider indexes, AppCommandParser parser, Session session,\n            Output out )\n    {\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 1 );\n        String value = parser.arguments().get( 2 );\n        return indexes.nodeIndex( index, emptyConfig() ).get( key, value );\n    }","id":102873,"modified_method":"private Iterable<Node> get( IndexProvider indexes, AppCommandParser parser )\n    {\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 1 );\n        String value = parser.arguments().get( 2 );\n        return indexes.nodeIndex( index, emptyConfig() ).get( key, value );\n    }","commit_id":"fbc63379bf31f387003698e99af5497bab0eaabb","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n            throws ShellException, RemoteException\n    {\n        IndexProvider indexes = indexes();\n\n        boolean doCd = parser.options().containsKey( \"cd\" );\n        boolean doLs = parser.options().containsKey( \"ls\" );\n        boolean query = parser.options().containsKey( \"q\" );\n        boolean get = parser.options().containsKey( \"g\" ) || query || doCd || doLs;\n        boolean index = parser.options().containsKey( \"i\" );\n        boolean remove = parser.options().containsKey( \"r\" );\n        int count = boolCount( get, index, remove );\n        if ( count != 1 )\n        {\n            throw new ShellException( \"Supply one of: -g, -i, -r\" );\n        }\n\n        if ( get )\n        {\n            String commandToRun = parser.options().get( \"c\" );\n            Collection<String> commandsToRun = new ArrayList<String>();\n            boolean specialCommand = false;\n            if ( doCd || doLs )\n            {\n                specialCommand = true;\n                if ( doCd )\n                {\n                    commandsToRun.add( \"cd -a $n\" );\n                }\n                else if ( doLs )\n                {\n                    commandsToRun.add( \"ls $n\" );\n                }\n            }\n            else if ( commandToRun != null )\n            {\n                commandsToRun.addAll( Arrays.asList( commandToRun.split( Pattern.quote( \"&&\" ) ) ) );\n            }\n            Iterable<Node> result;\n            if ( query )\n            {\n                result = query( indexes, parser, session, out );\n            }\n            else\n            {\n                result = get( indexes, parser, session, out );\n            }\n            for ( Node node : result )\n            {\n                printAndInterpretTemplateLines( commandsToRun, false, !specialCommand, node,\n                        getServer(), session, out );\n            }\n        }\n        else if ( index )\n        {\n            index( indexes, parser, session, out );\n        }\n        else if ( remove )\n        {\n            remove( indexes, parser, session, out );\n        }\n        return null;\n    }","id":102874,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n            throws ShellException, RemoteException\n    {\n        IndexProvider indexes = indexes();\n\n        boolean doCd = parser.options().containsKey( \"cd\" );\n        boolean doLs = parser.options().containsKey( \"ls\" );\n        boolean query = parser.options().containsKey( \"q\" );\n        boolean get = parser.options().containsKey( \"g\" ) || query || doCd || doLs;\n        boolean index = parser.options().containsKey( \"i\" );\n        boolean remove = parser.options().containsKey( \"r\" );\n        int count = boolCount( get, index, remove );\n        if ( count != 1 )\n        {\n            throw new ShellException( \"Supply one of: -g, -i, -r\" );\n        }\n\n        if ( get )\n        {\n            String commandToRun = parser.options().get( \"c\" );\n            Collection<String> commandsToRun = new ArrayList<String>();\n            boolean specialCommand = false;\n            if ( doCd || doLs )\n            {\n                specialCommand = true;\n                if ( doCd )\n                {\n                    commandsToRun.add( \"cd -a $n\" );\n                }\n                else if ( doLs )\n                {\n                    commandsToRun.add( \"ls $n\" );\n                }\n            }\n            else if ( commandToRun != null )\n            {\n                commandsToRun.addAll( Arrays.asList( commandToRun.split( Pattern.quote( \"&&\" ) ) ) );\n            }\n            Iterable<Node> result;\n            if ( query )\n            {\n                result = query( indexes, parser );\n            }\n            else\n            {\n                result = get( indexes, parser );\n            }\n            for ( Node node : result )\n            {\n                printAndInterpretTemplateLines( commandsToRun, false, !specialCommand, node,\n                        getServer(), session, out );\n            }\n        }\n        else if ( index )\n        {\n            index( indexes, parser, session );\n        }\n        else if ( remove )\n        {\n            remove( indexes, parser, session );\n        }\n        return null;\n    }","commit_id":"fbc63379bf31f387003698e99af5497bab0eaabb","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void index( IndexProvider indexes, AppCommandParser parser, Session session, Output out )\n            throws ShellException\n    {\n        Node node = getCurrent( session ).asNode();\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 0 );\n        Object value = parser.arguments().size() > 1 ? parser.arguments().get( 1 )\n                : node.getProperty( key, null );\n        if ( value == null )\n        {\n            throw new ShellException( \"No value to index\" );\n        }\n        indexes.nodeIndex( index, emptyConfig() ).add( node, key, value );\n    }","id":102875,"modified_method":"private void index( IndexProvider indexes, AppCommandParser parser, Session session )\n            throws ShellException\n    {\n        Node node = getCurrent( session ).asNode();\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 1 );\n        Object value = parser.arguments().size() > 2 ? parser.arguments().get( 2 )\n                : node.getProperty( key, null );\n        if ( value == null )\n        {\n            throw new ShellException( \"No value to index\" );\n        }\n        indexes.nodeIndex( index, emptyConfig() ).add( node, key, value );\n    }","commit_id":"fbc63379bf31f387003698e99af5497bab0eaabb","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void remove( IndexProvider indexes, AppCommandParser parser, Session session, Output out )\n            throws ShellException\n    {\n        Node node = getCurrent( session ).asNode();\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 0 );\n        Object value = parser.arguments().size() > 1 ? parser.arguments().get( 1 )\n                : node.getProperty( key, null );\n        if ( value == null )\n        {\n            throw new ShellException( \"No value to remove\" );\n        }\n        indexes.nodeIndex( index, emptyConfig() ).remove( node, key, value );\n    }","id":102876,"modified_method":"private void remove( IndexProvider indexes, AppCommandParser parser, Session session )\n            throws ShellException\n    {\n        Node node = getCurrent( session ).asNode();\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 0 );\n        Object value = parser.arguments().size() > 1 ? parser.arguments().get( 1 )\n                : node.getProperty( key, null );\n        if ( value == null )\n        {\n            throw new ShellException( \"No value to remove\" );\n        }\n        indexes.nodeIndex( index, emptyConfig() ).remove( node, key, value );\n    }","commit_id":"fbc63379bf31f387003698e99af5497bab0eaabb","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Iterable<Node> query( IndexProvider indexes, AppCommandParser parser, Session session,\n            Output out )\n    {\n        String index = parser.arguments().get( 0 );\n        String query = parser.arguments().get( 1 );\n        return indexes.nodeIndex( index, emptyConfig() ).query( query );\n    }","id":102877,"modified_method":"private Iterable<Node> query( IndexProvider indexes, AppCommandParser parser )\n    {\n        String index = parser.arguments().get( 0 );\n        String query = parser.arguments().get( 1 );\n        return indexes.nodeIndex( index, emptyConfig() ).query( query );\n    }","commit_id":"fbc63379bf31f387003698e99af5497bab0eaabb","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void index( IndexProvider indexes, AppCommandParser parser, Session session, Output out )\n            throws ShellException\n    {\n        Node node = getCurrent( session ).asNode();\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 0 );\n        Object value = parser.arguments().size() > 1 ? parser.arguments().get( 1 )\n                : node.getProperty( key, null );\n        if ( value == null )\n        {\n            throw new ShellException( \"No value to index\" );\n        }\n        indexes.nodeIndex( index, emptyConfig() ).add( node, key, value );\n    }","id":102878,"modified_method":"private void index( IndexProvider indexes, AppCommandParser parser, Session session )\n            throws ShellException\n    {\n        Node node = getCurrent( session ).asNode();\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 1 );\n        Object value = parser.arguments().size() > 2 ? parser.arguments().get( 2 )\n                : node.getProperty( key, null );\n        if ( value == null )\n        {\n            throw new ShellException( \"No value to index\" );\n        }\n        indexes.nodeIndex( index, emptyConfig() ).add( node, key, value );\n    }","commit_id":"0c9184608eaa283c74f4bf95f68ceddf5b48b775","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void remove( IndexProvider indexes, AppCommandParser parser, Session session, Output out )\n            throws ShellException\n    {\n        Node node = getCurrent( session ).asNode();\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 0 );\n        Object value = parser.arguments().size() > 1 ? parser.arguments().get( 1 )\n                : node.getProperty( key, null );\n        if ( value == null )\n        {\n            throw new ShellException( \"No value to remove\" );\n        }\n        indexes.nodeIndex( index, emptyConfig() ).remove( node, key, value );\n    }","id":102879,"modified_method":"private void remove( IndexProvider indexes, AppCommandParser parser, Session session )\n            throws ShellException\n    {\n        Node node = getCurrent( session ).asNode();\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 0 );\n        Object value = parser.arguments().size() > 1 ? parser.arguments().get( 1 )\n                : node.getProperty( key, null );\n        if ( value == null )\n        {\n            throw new ShellException( \"No value to remove\" );\n        }\n        indexes.nodeIndex( index, emptyConfig() ).remove( node, key, value );\n    }","commit_id":"0c9184608eaa283c74f4bf95f68ceddf5b48b775","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Iterable<Node> query( IndexProvider indexes, AppCommandParser parser, Session session,\n            Output out )\n    {\n        String index = parser.arguments().get( 0 );\n        String query = parser.arguments().get( 1 );\n        return indexes.nodeIndex( index, emptyConfig() ).query( query );\n    }","id":102880,"modified_method":"private Iterable<Node> query( IndexProvider indexes, AppCommandParser parser )\n    {\n        String index = parser.arguments().get( 0 );\n        String query = parser.arguments().get( 1 );\n        return indexes.nodeIndex( index, emptyConfig() ).query( query );\n    }","commit_id":"0c9184608eaa283c74f4bf95f68ceddf5b48b775","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Iterable<Node> get( IndexProvider indexes, AppCommandParser parser, Session session,\n            Output out )\n    {\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 1 );\n        String value = parser.arguments().get( 2 );\n        return indexes.nodeIndex( index, emptyConfig() ).get( key, value );\n    }","id":102881,"modified_method":"private Iterable<Node> get( IndexProvider indexes, AppCommandParser parser )\n    {\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 1 );\n        String value = parser.arguments().get( 2 );\n        return indexes.nodeIndex( index, emptyConfig() ).get( key, value );\n    }","commit_id":"0c9184608eaa283c74f4bf95f68ceddf5b48b775","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n            throws ShellException, RemoteException\n    {\n        IndexProvider indexes = indexes();\n\n        boolean doCd = parser.options().containsKey( \"cd\" );\n        boolean doLs = parser.options().containsKey( \"ls\" );\n        boolean query = parser.options().containsKey( \"q\" );\n        boolean get = parser.options().containsKey( \"g\" ) || query || doCd || doLs;\n        boolean index = parser.options().containsKey( \"i\" );\n        boolean remove = parser.options().containsKey( \"r\" );\n        int count = boolCount( get, index, remove );\n        if ( count != 1 )\n        {\n            throw new ShellException( \"Supply one of: -g, -i, -r\" );\n        }\n\n        if ( get )\n        {\n            String commandToRun = parser.options().get( \"c\" );\n            Collection<String> commandsToRun = new ArrayList<String>();\n            boolean specialCommand = false;\n            if ( doCd || doLs )\n            {\n                specialCommand = true;\n                if ( doCd )\n                {\n                    commandsToRun.add( \"cd -a $n\" );\n                }\n                else if ( doLs )\n                {\n                    commandsToRun.add( \"ls $n\" );\n                }\n            }\n            else if ( commandToRun != null )\n            {\n                commandsToRun.addAll( Arrays.asList( commandToRun.split( Pattern.quote( \"&&\" ) ) ) );\n            }\n            Iterable<Node> result;\n            if ( query )\n            {\n                result = query( indexes, parser, session, out );\n            }\n            else\n            {\n                result = get( indexes, parser, session, out );\n            }\n            for ( Node node : result )\n            {\n                printAndInterpretTemplateLines( commandsToRun, false, !specialCommand, node,\n                        getServer(), session, out );\n            }\n        }\n        else if ( index )\n        {\n            index( indexes, parser, session, out );\n        }\n        else if ( remove )\n        {\n            remove( indexes, parser, session, out );\n        }\n        return null;\n    }","id":102882,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n            throws ShellException, RemoteException\n    {\n        IndexProvider indexes = indexes();\n\n        boolean doCd = parser.options().containsKey( \"cd\" );\n        boolean doLs = parser.options().containsKey( \"ls\" );\n        boolean query = parser.options().containsKey( \"q\" );\n        boolean get = parser.options().containsKey( \"g\" ) || query || doCd || doLs;\n        boolean index = parser.options().containsKey( \"i\" );\n        boolean remove = parser.options().containsKey( \"r\" );\n        int count = boolCount( get, index, remove );\n        if ( count != 1 )\n        {\n            throw new ShellException( \"Supply one of: -g, -i, -r\" );\n        }\n\n        if ( get )\n        {\n            String commandToRun = parser.options().get( \"c\" );\n            Collection<String> commandsToRun = new ArrayList<String>();\n            boolean specialCommand = false;\n            if ( doCd || doLs )\n            {\n                specialCommand = true;\n                if ( doCd )\n                {\n                    commandsToRun.add( \"cd -a $n\" );\n                }\n                else if ( doLs )\n                {\n                    commandsToRun.add( \"ls $n\" );\n                }\n            }\n            else if ( commandToRun != null )\n            {\n                commandsToRun.addAll( Arrays.asList( commandToRun.split( Pattern.quote( \"&&\" ) ) ) );\n            }\n            Iterable<Node> result;\n            if ( query )\n            {\n                result = query( indexes, parser );\n            }\n            else\n            {\n                result = get( indexes, parser );\n            }\n            for ( Node node : result )\n            {\n                printAndInterpretTemplateLines( commandsToRun, false, !specialCommand, node,\n                        getServer(), session, out );\n            }\n        }\n        else if ( index )\n        {\n            index( indexes, parser, session );\n        }\n        else if ( remove )\n        {\n            remove( indexes, parser, session );\n        }\n        return null;\n    }","commit_id":"0c9184608eaa283c74f4bf95f68ceddf5b48b775","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Iterable<Node> query( IndexProvider indexes, AppCommandParser parser, Session session,\n            Output out )\n    {\n        String index = parser.arguments().get( 0 );\n        String query = parser.arguments().get( 1 );\n        return indexes.nodeIndex( index, emptyConfig() ).query( query );\n    }","id":102883,"modified_method":"private Iterable<Node> query( IndexProvider indexes, AppCommandParser parser )\n    {\n        String index = parser.arguments().get( 0 );\n        String query = parser.arguments().get( 1 );\n        return indexes.nodeIndex( index, emptyConfig() ).query( query );\n    }","commit_id":"28843153e885d84a65848ae4ad6868b307b15f30","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void remove( IndexProvider indexes, AppCommandParser parser, Session session, Output out )\n            throws ShellException\n    {\n        Node node = getCurrent( session ).asNode();\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 0 );\n        Object value = parser.arguments().size() > 1 ? parser.arguments().get( 1 )\n                : node.getProperty( key, null );\n        if ( value == null )\n        {\n            throw new ShellException( \"No value to remove\" );\n        }\n        indexes.nodeIndex( index, emptyConfig() ).remove( node, key, value );\n    }","id":102884,"modified_method":"private void remove( IndexProvider indexes, AppCommandParser parser, Session session )\n            throws ShellException\n    {\n        Node node = getCurrent( session ).asNode();\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 0 );\n        Object value = parser.arguments().size() > 1 ? parser.arguments().get( 1 )\n                : node.getProperty( key, null );\n        if ( value == null )\n        {\n            throw new ShellException( \"No value to remove\" );\n        }\n        indexes.nodeIndex( index, emptyConfig() ).remove( node, key, value );\n    }","commit_id":"28843153e885d84a65848ae4ad6868b307b15f30","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Iterable<Node> get( IndexProvider indexes, AppCommandParser parser, Session session,\n            Output out )\n    {\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 1 );\n        String value = parser.arguments().get( 2 );\n        return indexes.nodeIndex( index, emptyConfig() ).get( key, value );\n    }","id":102885,"modified_method":"private Iterable<Node> get( IndexProvider indexes, AppCommandParser parser )\n    {\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 1 );\n        String value = parser.arguments().get( 2 );\n        return indexes.nodeIndex( index, emptyConfig() ).get( key, value );\n    }","commit_id":"28843153e885d84a65848ae4ad6868b307b15f30","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n            throws ShellException, RemoteException\n    {\n        IndexProvider indexes = indexes();\n\n        boolean doCd = parser.options().containsKey( \"cd\" );\n        boolean doLs = parser.options().containsKey( \"ls\" );\n        boolean query = parser.options().containsKey( \"q\" );\n        boolean get = parser.options().containsKey( \"g\" ) || query || doCd || doLs;\n        boolean index = parser.options().containsKey( \"i\" );\n        boolean remove = parser.options().containsKey( \"r\" );\n        int count = boolCount( get, index, remove );\n        if ( count != 1 )\n        {\n            throw new ShellException( \"Supply one of: -g, -i, -r\" );\n        }\n\n        if ( get )\n        {\n            String commandToRun = parser.options().get( \"c\" );\n            Collection<String> commandsToRun = new ArrayList<String>();\n            boolean specialCommand = false;\n            if ( doCd || doLs )\n            {\n                specialCommand = true;\n                if ( doCd )\n                {\n                    commandsToRun.add( \"cd -a $n\" );\n                }\n                else if ( doLs )\n                {\n                    commandsToRun.add( \"ls $n\" );\n                }\n            }\n            else if ( commandToRun != null )\n            {\n                commandsToRun.addAll( Arrays.asList( commandToRun.split( Pattern.quote( \"&&\" ) ) ) );\n            }\n            Iterable<Node> result;\n            if ( query )\n            {\n                result = query( indexes, parser, session, out );\n            }\n            else\n            {\n                result = get( indexes, parser, session, out );\n            }\n            for ( Node node : result )\n            {\n                printAndInterpretTemplateLines( commandsToRun, false, !specialCommand, node,\n                        getServer(), session, out );\n            }\n        }\n        else if ( index )\n        {\n            index( indexes, parser, session, out );\n        }\n        else if ( remove )\n        {\n            remove( indexes, parser, session, out );\n        }\n        return null;\n    }","id":102886,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n            throws ShellException, RemoteException\n    {\n        IndexProvider indexes = indexes();\n\n        boolean doCd = parser.options().containsKey( \"cd\" );\n        boolean doLs = parser.options().containsKey( \"ls\" );\n        boolean query = parser.options().containsKey( \"q\" );\n        boolean get = parser.options().containsKey( \"g\" ) || query || doCd || doLs;\n        boolean index = parser.options().containsKey( \"i\" );\n        boolean remove = parser.options().containsKey( \"r\" );\n        int count = boolCount( get, index, remove );\n        if ( count != 1 )\n        {\n            throw new ShellException( \"Supply one of: -g, -i, -r\" );\n        }\n\n        if ( get )\n        {\n            String commandToRun = parser.options().get( \"c\" );\n            Collection<String> commandsToRun = new ArrayList<String>();\n            boolean specialCommand = false;\n            if ( doCd || doLs )\n            {\n                specialCommand = true;\n                if ( doCd )\n                {\n                    commandsToRun.add( \"cd -a $n\" );\n                }\n                else if ( doLs )\n                {\n                    commandsToRun.add( \"ls $n\" );\n                }\n            }\n            else if ( commandToRun != null )\n            {\n                commandsToRun.addAll( Arrays.asList( commandToRun.split( Pattern.quote( \"&&\" ) ) ) );\n            }\n            Iterable<Node> result;\n            if ( query )\n            {\n                result = query( indexes, parser );\n            }\n            else\n            {\n                result = get( indexes, parser );\n            }\n            for ( Node node : result )\n            {\n                printAndInterpretTemplateLines( commandsToRun, false, !specialCommand, node,\n                        getServer(), session, out );\n            }\n        }\n        else if ( index )\n        {\n            index( indexes, parser, session );\n        }\n        else if ( remove )\n        {\n            remove( indexes, parser, session );\n        }\n        return null;\n    }","commit_id":"28843153e885d84a65848ae4ad6868b307b15f30","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void index( IndexProvider indexes, AppCommandParser parser, Session session, Output out )\n            throws ShellException\n    {\n        Node node = getCurrent( session ).asNode();\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 0 );\n        Object value = parser.arguments().size() > 1 ? parser.arguments().get( 1 )\n                : node.getProperty( key, null );\n        if ( value == null )\n        {\n            throw new ShellException( \"No value to index\" );\n        }\n        indexes.nodeIndex( index, emptyConfig() ).add( node, key, value );\n    }","id":102887,"modified_method":"private void index( IndexProvider indexes, AppCommandParser parser, Session session )\n            throws ShellException\n    {\n        Node node = getCurrent( session ).asNode();\n        String index = parser.arguments().get( 0 );\n        String key = parser.arguments().get( 1 );\n        Object value = parser.arguments().size() > 2 ? parser.arguments().get( 2 )\n                : node.getProperty( key, null );\n        if ( value == null )\n        {\n            throw new ShellException( \"No value to index\" );\n        }\n        indexes.nodeIndex( index, emptyConfig() ).add( node, key, value );\n    }","commit_id":"28843153e885d84a65848ae4ad6868b307b15f30","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n  public void close() throws IOException {\n    int quietPeriodSecs =\n        Configuration.getInt(PropertyKey.WORKER_NETWORK_NETTY_SHUTDOWN_QUIET_PERIOD);\n    int timeoutSecs = Configuration.getInt(PropertyKey.WORKER_NETWORK_NETTY_SHUTDOWN_TIMEOUT);\n    mChannelFuture.channel().close().awaitUninterruptibly(timeoutSecs, TimeUnit.SECONDS);\n    mBootstrap.group().shutdownGracefully(quietPeriodSecs, timeoutSecs, TimeUnit.SECONDS)\n        .awaitUninterruptibly(timeoutSecs, TimeUnit.SECONDS);\n    mBootstrap.childGroup().shutdownGracefully(quietPeriodSecs, timeoutSecs, TimeUnit.SECONDS)\n        .awaitUninterruptibly(timeoutSecs, TimeUnit.SECONDS);\n  }","id":102888,"modified_method":"@Override\n  public void close() throws IOException {\n    boolean completed;\n\n    int quietPeriodSecs =\n        Configuration.getInt(PropertyKey.WORKER_NETWORK_NETTY_SHUTDOWN_QUIET_PERIOD);\n    int timeoutSecs = Configuration.getInt(PropertyKey.WORKER_NETWORK_NETTY_SHUTDOWN_TIMEOUT);\n\n    // The following steps are needed to shut down the data server:\n    //\n    // 1) its channel needs to be closed\n    // 2) its main EventLoopGroup needs to be shut down\n    // 3) its child EventLoopGroup needs to be shut down\n    //\n    // Each of the above steps can time out. If 1) times out, we simply give up on closing the\n    // channel. If 2) or 3) times out, the respective EventLoopGroup failed to shut down\n    // gracefully and its shutdown is forced.\n\n    completed =\n        mChannelFuture.channel().close().awaitUninterruptibly(timeoutSecs, TimeUnit.SECONDS);\n    if (!completed) {\n      LOG.warn(\"Closing the channel timed out.\");\n    }\n    completed =\n        mBootstrap.group().shutdownGracefully(quietPeriodSecs, timeoutSecs, TimeUnit.SECONDS)\n            .awaitUninterruptibly(timeoutSecs, TimeUnit.SECONDS);\n    if (!completed) {\n      LOG.warn(\"Forced group shutdown because graceful shutdown timed out.\");\n    }\n    completed =\n        mBootstrap.childGroup().shutdownGracefully(quietPeriodSecs, timeoutSecs, TimeUnit.SECONDS)\n            .awaitUninterruptibly(timeoutSecs, TimeUnit.SECONDS);\n    if (!completed) {\n      LOG.warn(\"Forced child group shutdown because graceful shutdown timed out.\");\n    }\n  }","commit_id":"ba547aa33ea6a0002e104b38e15e0555af4853ce","url":"https://github.com/amplab/tachyon"},{"original_method":"public void testDoNotImportIfGeneralSpaceExist() {\n        configureByFile(getTestName(false) + \".kt\");\n        ImportClassHelper.addImportDirective(\"jettesting.data.testFunction\", (JetFile) getFile());\n        checkResultByFile(getTestName(false) + \".kt.after\");\n    }","id":102889,"modified_method":"public void testDoNotImportIfGeneralSpaceExist() {\n        testImportInFile(\"jettesting.data.testFunction\");\n    }","commit_id":"a9bab96e33e16cfa30c0b854ed7ca3fa9d37c69b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void testDoNotImportIfGeneralExist() {\n        configureByFile(getTestName(false) + \".kt\");\n        ImportClassHelper.addImportDirective(\"jettesting.data.testFunction\", (JetFile) getFile());\n        checkResultByFile(getTestName(false) + \".kt.after\");\n    }","id":102890,"modified_method":"public void testDoNotImportIfGeneralExist() {\n        testImportInFile(\"jettesting.data.testFunction\");\n    }","commit_id":"a9bab96e33e16cfa30c0b854ed7ca3fa9d37c69b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void testNoDefaultImport() {\n        configureByFile(getTestName(false) + \".kt\");\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            @Override\n            public void run() {\n                ImportClassHelper.addImportDirective(\"std.io.println\", (JetFile) getFile());\n            }\n        });\n        checkResultByFile(getTestName(false) + \".kt.after\");\n    }","id":102891,"modified_method":"public void testNoDefaultImport() {\n        testImportInFile(\"std.io.println\");\n    }","commit_id":"a9bab96e33e16cfa30c0b854ed7ca3fa9d37c69b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        return new SpacingBuilder(settings)\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .before(IMPORT_DIRECTIVE).lineBreakInCode()\n                .between(IMPORT_DIRECTIVE, CLASS).blankLines(1)\n                .between(IMPORT_DIRECTIVE, FUN).blankLines(1)\n                .between(IMPORT_DIRECTIVE, PROPERTY).blankLines(1)\n\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .before(COMMA).spaceIf(settings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(settings.SPACE_AFTER_COMMA)\n                .around(EQ).spaceIf(settings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .beforeInside(BLOCK, FUN).spaceIf(settings.SPACE_BEFORE_METHOD_LBRACE)\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode();\n    }","id":102892,"modified_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        return new SpacingBuilder(settings)\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .before(IMPORT_DIRECTIVE).lineBreakInCode()\n                .between(IMPORT_DIRECTIVE, CLASS).blankLines(1)\n                .between(IMPORT_DIRECTIVE, FUN).blankLines(1)\n                .between(IMPORT_DIRECTIVE, PROPERTY).blankLines(1)\n                .between(IMPORT_DIRECTIVE, OBJECT_DECLARATION).blankLines(1)\n\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .before(COMMA).spaceIf(settings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(settings.SPACE_AFTER_COMMA)\n                .around(EQ).spaceIf(settings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .beforeInside(BLOCK, FUN).spaceIf(settings.SPACE_BEFORE_METHOD_LBRACE)\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode();\n    }","commit_id":"a9bab96e33e16cfa30c0b854ed7ca3fa9d37c69b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Add import directive into the PSI tree for the given namespace.\n     *\n     * @param importString full name of the import. Can contain .* if necessary.\n     * @param file File where directive should be added.\n     */\n    public static void addImportDirective(@NotNull String importString, @NotNull JetFile file) {\n\n        // TODO: hack\n        if (importString.startsWith(JavaDescriptorResolver.JAVA_ROOT + \".\")) {\n            importString = importString.substring((JavaDescriptorResolver.JAVA_ROOT + \".\").length());\n        }\n\n        if (isImportedByDefault(importString, JetPsiUtil.getFQName(file))) {\n            return;\n        }\n\n        List<JetImportDirective> importDirectives = file.getImportDirectives();\n\n        JetImportDirective newDirective = JetPsiFactory.createImportDirective(file.getProject(), importString);\n\n        if (!importDirectives.isEmpty()) {\n            \n            // Check if import is already present\n            for (JetImportDirective directive : importDirectives) {\n                String importPath = JetPsiUtil.getImportPath(directive);\n                if (importPath != null && QualifiedNamesUtil.isImported(importPath, importString)) {\n                    return;\n                }\n            }\n\n            JetImportDirective lastDirective = importDirectives.get(importDirectives.size() - 1);\n            lastDirective.getParent().addAfter(newDirective, lastDirective);\n        }\n        else {\n            List<JetDeclaration> declarations = file.getDeclarations();\n            assert !declarations.isEmpty();\n            JetDeclaration firstDeclaration = declarations.iterator().next();\n            firstDeclaration.getParent().addBefore(newDirective, firstDeclaration);\n        }\n    }","id":102893,"modified_method":"/**\n     * Add import directive into the PSI tree for the given namespace.\n     *\n     * @param importString full name of the import. Can contain .* if necessary.\n     * @param file File where directive should be added.\n     */\n    public static void addImportDirective(@NotNull String importString, @NotNull JetFile file) {\n\n        // TODO: hack\n        if (importString.startsWith(JavaDescriptorResolver.JAVA_ROOT + \".\")) {\n            importString = importString.substring((JavaDescriptorResolver.JAVA_ROOT + \".\").length());\n        }\n\n        if (isImportedByDefault(importString, JetPsiUtil.getFQName(file))) {\n            return;\n        }\n\n        List<JetImportDirective> importDirectives = file.getImportDirectives();\n\n        JetImportDirective newDirective = JetPsiFactory.createImportDirective(file.getProject(), importString);\n\n        if (!importDirectives.isEmpty()) {\n            \n            // Check if import is already present\n            for (JetImportDirective directive : importDirectives) {\n                String importPath = JetPsiUtil.getImportPath(directive);\n                if (importPath != null && QualifiedNamesUtil.isImported(importPath, importString)) {\n                    return;\n                }\n            }\n\n            JetImportDirective lastDirective = importDirectives.get(importDirectives.size() - 1);\n            lastDirective.getParent().addAfter(newDirective, lastDirective);\n        }\n        else {\n            List<JetDeclaration> declarations = file.getDeclarations();\n\n            if (!declarations.isEmpty()) {\n                JetDeclaration firstDeclaration = declarations.iterator().next();\n                firstDeclaration.getParent().addBefore(newDirective, firstDeclaration);\n            }\n            else {\n                file.getNamespaceHeader().getParent().addAfter(newDirective, file.getNamespaceHeader());\n            }\n        }\n    }","commit_id":"010090cd51ea7f8778c5b4fcfc7373ce035ad908","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        return new SpacingBuilder(settings)\n                .before(IMPORT_DIRECTIVE).lineBreakInCode()\n                .between(IMPORT_DIRECTIVE, CLASS).blankLines(1)\n                .between(IMPORT_DIRECTIVE, FUN).blankLines(1)\n                .between(IMPORT_DIRECTIVE, PROPERTY).blankLines(1)\n\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .before(COMMA).spaceIf(settings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(settings.SPACE_AFTER_COMMA)\n                .around(EQ).spaceIf(settings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .beforeInside(BLOCK, FUN).spaceIf(settings.SPACE_BEFORE_METHOD_LBRACE)\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode();\n    }","id":102894,"modified_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        return new SpacingBuilder(settings)\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .before(IMPORT_DIRECTIVE).lineBreakInCode()\n                .between(IMPORT_DIRECTIVE, CLASS).blankLines(1)\n                .between(IMPORT_DIRECTIVE, FUN).blankLines(1)\n                .between(IMPORT_DIRECTIVE, PROPERTY).blankLines(1)\n\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .before(COMMA).spaceIf(settings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(settings.SPACE_AFTER_COMMA)\n                .around(EQ).spaceIf(settings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .beforeInside(BLOCK, FUN).spaceIf(settings.SPACE_BEFORE_METHOD_LBRACE)\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode();\n    }","commit_id":"010090cd51ea7f8778c5b4fcfc7373ce035ad908","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void addParenthesis(InsertionContext context, LookupElement item, PsiElement offsetElement) {\n        int startOffset = context.getStartOffset();\n\n        int lookupStringLength = item.getLookupString().length();\n        int endOffset = startOffset + lookupStringLength;\n        Document document = context.getDocument();\n\n        boolean bothParentheses = false;\n        String documentText = document.getText();\n\n        if (!(endOffset < documentText.length() && documentText.charAt(endOffset) == '(')) {\n            // Insert () if it's not already exist\n            document.insertString(endOffset, \"()\");\n            bothParentheses = true;\n        } else if (endOffset + 1 < documentText.length() && documentText.charAt(endOffset) == ')') {\n            bothParentheses = true;\n        }\n\n        Editor editor = context.getEditor();\n        if (caretPosition == CaretPosition.IN_BRACKETS || !bothParentheses) {\n            editor.getCaretModel().moveToOffset(editor.getCaretModel().getOffset() + 1);\n            AutoPopupController.getInstance(context.getProject()).autoPopupParameterInfo(editor, offsetElement);\n        } else {\n            editor.getCaretModel().moveToOffset(editor.getCaretModel().getOffset() + 2);\n        }\n\n        PsiDocumentManager.getInstance(context.getProject()).commitDocument(context.getDocument());\n    }","id":102895,"modified_method":"private void addParenthesis(InsertionContext context, LookupElement item, PsiElement offsetElement) {\n        int startOffset = context.getStartOffset();\n\n        int lookupStringLength = item.getLookupString().length();\n        int endOffset = startOffset + lookupStringLength;\n        Document document = context.getDocument();\n\n        boolean bothParentheses = false;\n        String documentText = document.getText();\n\n        if (!(endOffset < documentText.length() && documentText.charAt(endOffset) == '(')) {\n            // Insert () if it's not already exist\n            document.insertString(endOffset, \"()\");\n            bothParentheses = true;\n        } else if (endOffset + 1 < documentText.length() && documentText.charAt(endOffset + 1) == ')') {\n            bothParentheses = true;\n        }\n\n        Editor editor = context.getEditor();\n        if (caretPosition == CaretPosition.IN_BRACKETS || !bothParentheses) {\n            editor.getCaretModel().moveToOffset(editor.getCaretModel().getOffset() + 1);\n            AutoPopupController.getInstance(context.getProject()).autoPopupParameterInfo(editor, offsetElement);\n        } else {\n            editor.getCaretModel().moveToOffset(editor.getCaretModel().getOffset() + 2);\n        }\n\n        PsiDocumentManager.getInstance(context.getProject()).commitDocument(context.getDocument());\n    }","commit_id":"010090cd51ea7f8778c5b4fcfc7373ce035ad908","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n  public boolean isAvailable(@NotNull Project project,\n                             @NotNull PsiFile file,\n                             @NotNull PsiElement startElement,\n                             @NotNull PsiElement endElement) {\n    final PsiMethod myMethod = (PsiMethod)startElement;\n\n    PsiType myReturnType = myReturnTypePointer.getType();\n    return myMethod.isValid()\n        && myMethod.getManager().isInProject(myMethod)\n        && myReturnType != null\n        && myReturnType.isValid()\n        && !TypeConversionUtil.isNullType(myReturnType)\n        && myMethod.getReturnType() != null\n        && !Comparing.equal(myReturnType, myMethod.getReturnType());\n  }","id":102896,"modified_method":"@Override\n  public boolean isAvailable(@NotNull Project project,\n                             @NotNull PsiFile file,\n                             @NotNull PsiElement startElement,\n                             @NotNull PsiElement endElement) {\n    final PsiMethod myMethod = (PsiMethod)startElement;\n\n    final PsiType myReturnType = myReturnTypePointer.getType();\n    if (myMethod.isValid() &&\n        myMethod.getManager().isInProject(myMethod) &&\n        myReturnType != null &&\n        myReturnType.isValid() &&\n        !TypeConversionUtil.isNullType(myReturnType)) {\n      final PsiType returnType = myMethod.getReturnType();\n      if (returnType != null && returnType.isValid() && !Comparing.equal(myReturnType, returnType)) return true;\n    }\n    return false;\n  }","commit_id":"1126e85c51d63c6ae01df0c007e722db0c4de513","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    private JetTypeInfo visitElvisExpression(\n            @NotNull JetBinaryExpression expression,\n            @NotNull ExpressionTypingContext contextWithExpectedType\n    ) {\n        ExpressionTypingContext context = contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE);\n        JetExpression left = expression.getLeft();\n        JetExpression right = expression.getRight();\n\n        if (left == null || right == null) {\n            getTypeInfoOrNullType(left, context, facade);\n            return JetTypeInfo.create(null, context.dataFlowInfo);\n        }\n\n        Call call = createCallForSpecialConstruction(expression, Lists.newArrayList(left, right));\n        ResolvedCall<FunctionDescriptor> resolvedCall = resolveSpecialConstructionAsCall(\n                call, \"Elvis\", Lists.newArrayList(\"left\", \"right\"), Lists.newArrayList(true, false), contextWithExpectedType, null);\n        JetTypeInfo leftTypeInfo = BindingContextUtils.getRecordedTypeInfo(left, context.trace.getBindingContext());\n        assert leftTypeInfo != null : \"Left expression was not processed: \" + expression;\n        JetType leftType = leftTypeInfo.getType();\n        if (leftType != null && isKnownToBeNotNull(left, leftType, context)) {\n            context.trace.report(USELESS_ELVIS.on(left, leftType));\n        }\n        return JetTypeInfo.create(resolvedCall.getResultingDescriptor().getReturnType(),\n                                  resolvedCall.getDataFlowInfoForArguments().getResultInfo());\n    }","id":102897,"modified_method":"@NotNull\n    private JetTypeInfo visitElvisExpression(\n            @NotNull JetBinaryExpression expression,\n            @NotNull ExpressionTypingContext contextWithExpectedType\n    ) {\n        ExpressionTypingContext context = contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE);\n        JetExpression left = expression.getLeft();\n        JetExpression right = expression.getRight();\n\n        if (left == null || right == null) {\n            getTypeInfoOrNullType(left, context, facade);\n            return JetTypeInfo.create(null, context.dataFlowInfo);\n        }\n\n        Call call = createCallForSpecialConstruction(expression, Lists.newArrayList(left, right));\n        ResolvedCall<FunctionDescriptor> resolvedCall = resolveSpecialConstructionAsCall(\n                call, \"Elvis\", Lists.newArrayList(\"left\", \"right\"), Lists.newArrayList(true, false), contextWithExpectedType, null);\n        JetTypeInfo leftTypeInfo = BindingContextUtils.getRecordedTypeInfo(left, context.trace.getBindingContext());\n        assert leftTypeInfo != null : \"Left expression was not processed: \" + expression;\n        JetType leftType = leftTypeInfo.getType();\n        if (leftType != null && isKnownToBeNotNull(left, leftType, context)) {\n            context.trace.report(USELESS_ELVIS.on(left, leftType));\n        }\n        JetTypeInfo rightTypeInfo = BindingContextUtils.getRecordedTypeInfo(right, context.trace.getBindingContext());\n        assert rightTypeInfo != null : \"Right expression was not processed: \" + expression;\n        JetType rightType = rightTypeInfo.getType();\n\n        DataFlowInfo dataFlowInfo = resolvedCall.getDataFlowInfoForArguments().getResultInfo();\n        JetType type = resolvedCall.getResultingDescriptor().getReturnType();\n        if (type == null || rightType == null) return JetTypeInfo.create(null, dataFlowInfo);\n\n        return JetTypeInfo.create(TypeUtils.makeNullableAsSpecified(type, rightType.isNullable()), dataFlowInfo);\n    }","commit_id":"c0f7a82b15f6f7de4f7796847ff9adb92ce41ae2","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public PyType getType(@NotNull TypeEvalContext context) {\n    if (!TypeEvalStack.mayEvaluate(this)) {\n      return null;\n    }\n    try {\n      if (PyNames.ALL.equals(getName())) {\n        // no type for __all__, to avoid unresolved reference errors for expressions where a qualifier is a name\n        // imported via __all__\n        return null;\n      }\n      if (!context.maySwitchToAST(this)) {\n        final PsiElement value = getStub() != null ? findAssignedValueByStub() : findAssignedValue();\n        if (value instanceof PyTypedElement) {\n          return ((PyTypedElement)value).getType(context);\n        }\n        return null;\n      }\n      PyType type = getTypeFromDocString(this);\n      if (type != null) {\n        return type;\n      }\n      type = getTypeFromComment(this);\n      if (type != null) {\n        return type;\n      }\n      final PsiElement parent = getParent();\n      if (parent instanceof PyAssignmentStatement) {\n        final PyAssignmentStatement assignmentStatement = (PyAssignmentStatement)parent;\n        final PyExpression assignedValue = assignmentStatement.getAssignedValue();\n        if (assignedValue != null) {\n          if (assignedValue instanceof PyReferenceExpressionImpl) {\n            final PyReferenceExpressionImpl refex = (PyReferenceExpressionImpl)assignedValue;\n            PyType maybe_type = PyUtil.getSpecialAttributeType(refex, context);\n            if (maybe_type != null) return maybe_type;\n            final PyResolveContext resolveContext = PyResolveContext.noImplicits().withTypeEvalContext(context);\n            final ResolveResult[] resolveResult = refex.getReference(resolveContext).multiResolve(false);\n            if (resolveResult.length == 1) {\n              PsiElement target = resolveResult[0].getElement();\n              if (target == this || target == null) {\n                return null;  // fix SOE on \"a = a\"\n              }\n              final PyType typeFromTarget = PyReferenceExpressionImpl.getTypeFromTarget(target, context, refex);\n              if (target instanceof PyTargetExpression && typeFromTarget instanceof PyNoneType) {\n                // this usually means that the variable is initialized to a non-None value somewhere else where we haven't looked\n                return null;\n              }\n              Ref<PyType> typeOfProperty = refex.getTypeOfProperty(context);\n              if (typeOfProperty != null) {\n                return typeOfProperty.get();\n              }\n              return typeFromTarget;\n            }\n          }\n          if (assignedValue instanceof PyYieldExpression) {\n            return null;\n          }\n          return context.getType(assignedValue);\n        }\n      }\n      if (parent instanceof PyTupleExpression) {\n        final PyAssignmentStatement assignment = PsiTreeUtil.getParentOfType(parent, PyAssignmentStatement.class);\n        if (assignment != null) {\n          final PyExpression value = assignment.getAssignedValue();\n          if (value != null) {\n            final PyType assignedType = value.getType(context);\n            if (assignedType instanceof PyTupleType) {\n              final PyType t = getTypeFromTupleAssignment((PyTupleExpression)parent, (PyTupleType)assignedType);\n              if (t != null) {\n                return t;\n              }\n            }\n          }\n        }\n      }\n      if (parent instanceof PyWithItem) {\n        final PyWithItem item = (PyWithItem)parent;\n        final PyExpression expression = item.getExpression();\n        if (expression != null) {\n          final PyType exprType = expression.getType(context);\n          if (exprType instanceof PyClassType) {\n            final PyClass cls = ((PyClassType)exprType).getPyClass();\n            if (cls != null) {\n              final PyFunction enter = cls.findMethodByName(PyNames.ENTER, true);\n              if (enter != null) {\n                return enter.getReturnType(context, null);\n              }\n            }\n          }\n        }\n        return null;\n      }\n      PyType iterType = getTypeFromIteration(context);\n      if (iterType != null) {\n        return iterType;\n      }\n      PyType excType = getTypeFromExcept();\n      if (excType != null) {\n        return excType;\n      }\n      return null;\n    }\n    finally {\n      TypeEvalStack.evaluated(this);\n    }\n  }","id":102898,"modified_method":"public PyType getType(@NotNull TypeEvalContext context) {\n    if (!TypeEvalStack.mayEvaluate(this)) {\n      return null;\n    }\n    try {\n      if (PyNames.ALL.equals(getName())) {\n        // no type for __all__, to avoid unresolved reference errors for expressions where a qualifier is a name\n        // imported via __all__\n        return null;\n      }\n      if (!context.maySwitchToAST(this)) {\n        final PsiElement value = getStub() != null ? findAssignedValueByStub() : findAssignedValue();\n        if (value instanceof PyTypedElement) {\n          return ((PyTypedElement)value).getType(context);\n        }\n        return null;\n      }\n      PyType type = getTypeFromDocString(this);\n      if (type != null) {\n        return type;\n      }\n      type = getTypeFromComment(this);\n      if (type != null) {\n        return type;\n      }\n      final PsiElement parent = getParent();\n      if (parent instanceof PyAssignmentStatement) {\n        final PyAssignmentStatement assignmentStatement = (PyAssignmentStatement)parent;\n        final PyExpression assignedValue = assignmentStatement.getAssignedValue();\n        if (assignedValue != null) {\n          if (assignedValue instanceof PyReferenceExpressionImpl) {\n            final PyReferenceExpressionImpl refex = (PyReferenceExpressionImpl)assignedValue;\n            PyType maybe_type = PyUtil.getSpecialAttributeType(refex, context);\n            if (maybe_type != null) return maybe_type;\n            final PyResolveContext resolveContext = PyResolveContext.noImplicits().withTypeEvalContext(context);\n            final ResolveResult[] resolveResult = refex.getReference(resolveContext).multiResolve(false);\n            if (resolveResult.length == 1) {\n              PsiElement target = resolveResult[0].getElement();\n              if (target == this || target == null) {\n                return null;  // fix SOE on \"a = a\"\n              }\n              final PyType typeFromTarget = PyReferenceExpressionImpl.getTypeFromTarget(target, context, refex);\n              if (target instanceof PyTargetExpression && typeFromTarget instanceof PyNoneType) {\n                // this usually means that the variable is initialized to a non-None value somewhere else where we haven't looked\n                return null;\n              }\n              Ref<PyType> typeOfProperty = refex.getTypeOfProperty(context);\n              if (typeOfProperty != null) {\n                return typeOfProperty.get();\n              }\n              return typeFromTarget;\n            }\n          }\n          if (assignedValue instanceof PyYieldExpression) {\n            return null;\n          }\n          return context.getType(assignedValue);\n        }\n      }\n      if (parent instanceof PyTupleExpression) {\n        final PyAssignmentStatement assignment = PsiTreeUtil.getParentOfType(parent, PyAssignmentStatement.class);\n        if (assignment != null) {\n          final PyExpression value = assignment.getAssignedValue();\n          if (value != null) {\n            final PyType assignedType = value.getType(context);\n            if (assignedType instanceof PyTupleType) {\n              final PyType t = getTypeFromTupleAssignment((PyTupleExpression)parent, (PyTupleType)assignedType);\n              if (t != null) {\n                return t;\n              }\n            }\n          }\n        }\n      }\n      if (parent instanceof PyWithItem) {\n        final PyWithItem item = (PyWithItem)parent;\n        final PyExpression expression = item.getExpression();\n        if (expression != null) {\n          final PyType exprType = expression.getType(context);\n          if (exprType instanceof PyClassType) {\n            final PyClass cls = ((PyClassType)exprType).getPyClass();\n            if (cls != null) {\n              final PyFunction enter = cls.findMethodByName(PyNames.ENTER, true);\n              if (enter != null) {\n                final PyType enterType = enter.getReturnType(context, null);\n                if (enterType != null) {\n                  return enterType;\n                }\n                // Guess the return type of __enter__\n                return PyUnionType.createWeakType(exprType);\n              }\n            }\n          }\n        }\n        return null;\n      }\n      PyType iterType = getTypeFromIteration(context);\n      if (iterType != null) {\n        return iterType;\n      }\n      PyType excType = getTypeFromExcept();\n      if (excType != null) {\n        return excType;\n      }\n      return null;\n    }\n    finally {\n      TypeEvalStack.evaluated(this);\n    }\n  }","commit_id":"613b414c1c6ad328d8ba0d2a1107ef617582143a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String determineMostLikelyLocationInJAR(@NotNull VirtualFile file)\n  {\n    Project project = _editorContext.getProject();\n    Module module = _editorContext.getModule();\n\n    VirtualFile[] contentRoots = module != null ? ModuleRootManager.getInstance(module).getContentRoots() : new VirtualFile[0];\n    for (VirtualFile contentRoot : contentRoots)\n    {\n      if (VfsUtil.isAncestor(contentRoot, file, false))\n      {\n        return VfsUtil.getRelativePath(file, contentRoot, '/');\n      }\n    }\n\n    VirtualFile projectBaseFolder = project != null ? project.getBaseDir() : null;\n    if (projectBaseFolder != null && VfsUtil.isAncestor(projectBaseFolder, file, false))\n    {\n      return VfsUtil.getRelativePath(file, projectBaseFolder, '/');\n    }\n    return file.getName();\n  }","id":102899,"modified_method":"private String determineMostLikelyLocationInJAR(@NotNull VirtualFile file)\n  {\n    Project project = _editorContext.getProject();\n    Module module = _editorContext.getModule();\n\n    VirtualFile[] contentRoots = ModuleRootManager.getInstance(module).getContentRoots();\n    for (VirtualFile contentRoot : contentRoots)\n    {\n      if (VfsUtil.isAncestor(contentRoot, file, false))\n      {\n        return VfsUtil.getRelativePath(file, contentRoot, '/');\n      }\n    }\n\n    VirtualFile projectBaseFolder = project.getBaseDir();\n    if (projectBaseFolder != null && VfsUtil.isAncestor(projectBaseFolder, file, false))\n    {\n      return VfsUtil.getRelativePath(file, projectBaseFolder, '/');\n    }\n    return file.getName();\n  }","commit_id":"9bb5dde245c05bda80ea799a9a82e7b1ad60916d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void onAddAdditionalJARContent()\n  {\n    Project project = _editorContext.getProject();\n    FileChooserDescriptor descriptor = new FileChooserDescriptor(true, true, true, true, false, true);\n    descriptor.setTitle(\"Choose source file or folder\");\n    FileChooserDialog fileChooserDialog =\n        FileChooserFactory.getInstance().createFileChooser(descriptor, project);\n    VirtualFile rootFolder = null;\n    Module module = _editorContext.getModule();\n    VirtualFile[] contentRoots = module != null ? ModuleRootManager.getInstance(module).getContentRoots() : new VirtualFile[0];\n    if (contentRoots.length > 0)\n    {\n      rootFolder = contentRoots[0];\n    }\n    else if (project != null && project.getBaseDir() != null)\n    {\n      rootFolder = project.getBaseDir();\n    }\n    VirtualFile[] files =\n        fileChooserDialog.choose(rootFolder, project);\n    for (VirtualFile file : files)\n    {\n      String destFile = determineMostLikelyLocationInJAR(file);\n      _additionalJARContentsTableModel.addAdditionalJARContent(file.getPath(), destFile);\n    }\n  }","id":102900,"modified_method":"private void onAddAdditionalJARContent()\n  {\n    Project project = _editorContext.getProject();\n    FileChooserDescriptor descriptor = new FileChooserDescriptor(true, true, true, true, false, true);\n    descriptor.setTitle(\"Choose source file or folder\");\n    FileChooserDialog fileChooserDialog =\n        FileChooserFactory.getInstance().createFileChooser(descriptor, project);\n    VirtualFile rootFolder = null;\n    Module module = _editorContext.getModule();\n    VirtualFile[] contentRoots = ModuleRootManager.getInstance(module).getContentRoots();\n    if (contentRoots.length > 0)\n    {\n      rootFolder = contentRoots[0];\n    }\n    else if (project.getBaseDir() != null)\n    {\n      rootFolder = project.getBaseDir();\n    }\n    VirtualFile[] files =\n        fileChooserDialog.choose(rootFolder, project);\n    for (VirtualFile file : files)\n    {\n      String destFile = determineMostLikelyLocationInJAR(file);\n      _additionalJARContentsTableModel.addAdditionalJARContent(file.getPath(), destFile);\n    }\n  }","commit_id":"9bb5dde245c05bda80ea799a9a82e7b1ad60916d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void onEditAdditionalJARContent()\n  {\n    int row = _additionalJARContentsTable.getSelectedRow();\n    Pair<String, String> additionalJARContent =\n        _additionalJARContentsTableModel.getAdditionalJARContent(row);\n    Project project = _editorContext.getProject();\n    FileChooserDescriptor descriptor = new FileChooserDescriptor(true, true, true, true, false, false);\n    descriptor.setTitle(\"Choose source file or folder\");\n    FileChooserDialog fileChooserDialog =\n        FileChooserFactory.getInstance().createFileChooser(descriptor, project);\n    VirtualFile preselectedPath = LocalFileSystem.getInstance().findFileByPath(additionalJARContent.getFirst());\n    if (preselectedPath == null)\n    {\n      Module module = _editorContext.getModule();\n      VirtualFile[] contentRoots = module != null ? ModuleRootManager.getInstance(module).getContentRoots() : new VirtualFile[0];\n      if (contentRoots.length > 0)\n      {\n        for (VirtualFile contentRoot : contentRoots)\n        {\n          VirtualFile path = VfsUtil.findRelativeFile(additionalJARContent.getFirst(), contentRoot);\n          if (path != null)\n          {\n            preselectedPath = path;\n            break;\n          }\n        }\n        if (preselectedPath == null)\n        {\n          preselectedPath = contentRoots[0];\n        }\n      }\n      else if (project != null && project.getBaseDir() != null)\n      {\n        preselectedPath = project.getBaseDir();\n      }\n    }\n    VirtualFile[] files = fileChooserDialog\n        .choose(preselectedPath, project);\n    if (files.length > 0)\n    {\n      String sourcePath = files[0].getPath();\n      String destPath = determineMostLikelyLocationInJAR(files[0]);\n      String newDestPath = Messages.showInputDialog(project, String.format(\"Change destination file path from \\\"%s\\\" to\", additionalJARContent.getSecond()), \"Change destination file path\", Messages.getQuestionIcon(), destPath, null);\n\n      _additionalJARContentsTableModel.changeAdditionalJARConent(row, sourcePath, newDestPath != null ? newDestPath : additionalJARContent.getSecond());\n    }\n  }","id":102901,"modified_method":"private void onEditAdditionalJARContent()\n  {\n    int row = _additionalJARContentsTable.getSelectedRow();\n    Pair<String, String> additionalJARContent =\n        _additionalJARContentsTableModel.getAdditionalJARContent(row);\n    Project project = _editorContext.getProject();\n    FileChooserDescriptor descriptor = new FileChooserDescriptor(true, true, true, true, false, false);\n    descriptor.setTitle(\"Choose source file or folder\");\n    FileChooserDialog fileChooserDialog =\n        FileChooserFactory.getInstance().createFileChooser(descriptor, project);\n    VirtualFile preselectedPath = LocalFileSystem.getInstance().findFileByPath(additionalJARContent.getFirst());\n    if (preselectedPath == null)\n    {\n      Module module = _editorContext.getModule();\n      VirtualFile[] contentRoots = ModuleRootManager.getInstance(module).getContentRoots();\n      if (contentRoots.length > 0)\n      {\n        for (VirtualFile contentRoot : contentRoots)\n        {\n          VirtualFile path = VfsUtil.findRelativeFile(additionalJARContent.getFirst(), contentRoot);\n          if (path != null)\n          {\n            preselectedPath = path;\n            break;\n          }\n        }\n        if (preselectedPath == null)\n        {\n          preselectedPath = contentRoots[0];\n        }\n      }\n      else if (project.getBaseDir() != null)\n      {\n        preselectedPath = project.getBaseDir();\n      }\n    }\n    VirtualFile[] files = fileChooserDialog\n        .choose(preselectedPath, project);\n    if (files.length > 0)\n    {\n      String sourcePath = files[0].getPath();\n      String destPath = determineMostLikelyLocationInJAR(files[0]);\n      String newDestPath = Messages.showInputDialog(project, String.format(\"Change destination file path from \\\"%s\\\" to\", additionalJARContent.getSecond()), \"Change destination file path\", Messages.getQuestionIcon(), destPath, null);\n\n      _additionalJARContentsTableModel.changeAdditionalJARConent(row, sourcePath, newDestPath != null ? newDestPath : additionalJARContent.getSecond());\n    }\n  }","commit_id":"9bb5dde245c05bda80ea799a9a82e7b1ad60916d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public int read(byte dest[], int off, int len) throws IOException {\n        int read = in.read(dest, off, len);\n        _context.bandwidthLimiter().delayInbound(_peer, read);\n        return read;\n    }","id":102902,"modified_method":"public int read(byte dest[], int off, int len) throws IOException {\n        int read = in.read(dest, off, len);\n        if (_pullFromOutbound)\n            _context.bandwidthLimiter().delayOutbound(_peer, read);\n        else\n            _context.bandwidthLimiter().delayInbound(_peer, read);\n        return read;\n    }","commit_id":"8fd02ee8dd64a618f0e62ce73334f03550800b88","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public long skip(long numBytes) throws IOException {\n        long skip = in.skip(numBytes);\n        _context.bandwidthLimiter().delayInbound(_peer, (int)skip);\n        return skip;\n    }","id":102903,"modified_method":"public long skip(long numBytes) throws IOException {\n        long skip = in.skip(numBytes);\n        if (_pullFromOutbound)\n            _context.bandwidthLimiter().delayOutbound(_peer, (int)skip);\n        else\n            _context.bandwidthLimiter().delayInbound(_peer, (int)skip);\n        return skip;\n    }","commit_id":"8fd02ee8dd64a618f0e62ce73334f03550800b88","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public int read() throws IOException {\n        _context.bandwidthLimiter().delayInbound(_peer, 1);\n        return in.read();\n    }","id":102904,"modified_method":"public int read() throws IOException {\n        if (_pullFromOutbound)\n            _context.bandwidthLimiter().delayOutbound(_peer, 1);\n        else\n            _context.bandwidthLimiter().delayInbound(_peer, 1);\n        return in.read();\n    }","commit_id":"8fd02ee8dd64a618f0e62ce73334f03550800b88","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public int read(byte dest[]) throws IOException {\n        int read = in.read(dest);\n        _context.bandwidthLimiter().delayInbound(_peer, read);\n        return read;\n    }","id":102905,"modified_method":"public int read(byte dest[]) throws IOException {\n        int read = in.read(dest);\n        if (_pullFromOutbound)\n            _context.bandwidthLimiter().delayOutbound(_peer, read);\n        else\n            _context.bandwidthLimiter().delayInbound(_peer, read);\n        return read;\n    }","commit_id":"8fd02ee8dd64a618f0e62ce73334f03550800b88","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public BandwidthLimitedInputStream(RouterContext context, InputStream source, RouterIdentity peer) {\n        super(source);\n        _context = context;\n        _peer = peer;\n    }","id":102906,"modified_method":"public BandwidthLimitedInputStream(RouterContext context, InputStream source, RouterIdentity peer) {\n        this(context, source, peer, false);\n    }","commit_id":"8fd02ee8dd64a618f0e62ce73334f03550800b88","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public synchronized void applyTransactionWithoutTxId( ReadableByteChannel byteChannel, \n            long nextTxId, int masterId ) throws IOException\n    {\n        if ( nextTxId != (xaTf.getLastCommittedTx() + 1) )\n        {\n            throw new IllegalStateException( \"Tried to apply tx \" + \n                nextTxId + \" but expected transaction \" + \n                (xaTf.getCurrentVersion() + 1) );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \", committing tx=\" + nextTxId + \")\" );\n//        System.out.println( \"applyTxWithoutTxId#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        scanIsComplete = false;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        long startEntryPosition = writeBuffer.getFileChannelPosition();\n        while ( logApplier.readAndWriteAndApplyEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        LogEntry.Start startEntry = logApplier.startEntry;\n        if ( startEntry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        startEntry.setStartPosition( startEntryPosition );\n//        System.out.println( \"applyTxWithoutTxId#before 1PC @ pos: \" + writeBuffer.getFileChannelPosition() );\n        LogEntry.OnePhaseCommit commit = new LogEntry.OnePhaseCommit( \n                xidIdent, nextTxId, masterId );\n        LogIoUtils.writeLogEntry( commit, writeBuffer );\n        Xid xid = startEntry.getXid();\n        try\n        {\n            XaTransaction xaTx = xaRm.getXaTransaction( xid );\n            xaTx.setCommitTxId( nextTxId );\n            xaRm.commit( xid, true );\n            LogEntry doneEntry = new LogEntry.Done( startEntry.getIdentifier() );\n            LogIoUtils.writeLogEntry( doneEntry, writeBuffer );\n            xidIdentMap.remove( startEntry.getIdentifier() );\n            recoveredTxMap.remove( startEntry.getIdentifier() );\n            cacheTxStartPosition( nextTxId, startEntry );\n        }\n        catch ( XAException e )\n        {\n            e.printStackTrace();\n            throw new IOException( e.getMessage() );\n        }\n        \n//        LogEntry.Done done = new LogEntry.Done( entry.getIdentifier() );\n//        LogIoUtils.writeLogEntry( done, writeBuffer );\n        // xaTf.setLastCommittedTx( nextTxId ); // done in doCommit\n        scanIsComplete = true;\n//        log.info( \"Tx[\" + nextTxId + \"] \" + \" applied successfully.\" );\n        msgLog.logMessage( \"Applied external tx and generated tx id=\" + nextTxId );\n//        System.out.println( \"applyTxWithoutTxId#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","id":102907,"modified_method":"public synchronized void applyTransactionWithoutTxId( ReadableByteChannel byteChannel, \n            long nextTxId, int masterId ) throws IOException\n    {\n        if ( nextTxId != (xaTf.getLastCommittedTx() + 1) )\n        {\n            throw new IllegalStateException( \"Tried to apply tx \" + \n                nextTxId + \" but expected transaction \" + \n                (xaTf.getCurrentVersion() + 1) );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \", committing tx=\" + nextTxId + \")\" );\n//        System.out.println( \"applyTxWithoutTxId#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        scanIsComplete = false;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        long startEntryPosition = writeBuffer.getFileChannelPosition();\n        while ( logApplier.readAndWriteAndApplyEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        LogEntry.Start startEntry = logApplier.startEntry;\n        if ( startEntry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        startEntry.setStartPosition( startEntryPosition );\n//        System.out.println( \"applyTxWithoutTxId#before 1PC @ pos: \" + writeBuffer.getFileChannelPosition() );\n        LogEntry.OnePhaseCommit commit = new LogEntry.OnePhaseCommit( \n                xidIdent, nextTxId, masterId );\n        LogIoUtils.writeLogEntry( commit, writeBuffer );\n        Xid xid = startEntry.getXid();\n        try\n        {\n            XaTransaction xaTx = xaRm.getXaTransaction( xid );\n            xaTx.setCommitTxId( nextTxId );\n            xaRm.commit( xid, true );\n            LogEntry doneEntry = new LogEntry.Done( startEntry.getIdentifier() );\n            LogIoUtils.writeLogEntry( doneEntry, writeBuffer );\n            xidIdentMap.remove( startEntry.getIdentifier() );\n            recoveredTxMap.remove( startEntry.getIdentifier() );\n            cacheTxStartPosition( nextTxId, masterId, startEntry );\n        }\n        catch ( XAException e )\n        {\n            e.printStackTrace();\n            throw new IOException( e.getMessage() );\n        }\n        \n//        LogEntry.Done done = new LogEntry.Done( entry.getIdentifier() );\n//        LogIoUtils.writeLogEntry( done, writeBuffer );\n        // xaTf.setLastCommittedTx( nextTxId ); // done in doCommit\n        scanIsComplete = true;\n//        log.info( \"Tx[\" + nextTxId + \"] \" + \" applied successfully.\" );\n        msgLog.logMessage( \"Applied external tx and generated tx id=\" + nextTxId );\n//        System.out.println( \"applyTxWithoutTxId#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","commit_id":"08d5f67e75a89719aa05ca0ad841d558c161b3bc","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return logEntryList;\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","id":102908,"modified_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return logEntryList;\n        }\n        Triplet<Long, Integer, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.third() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","commit_id":"08d5f67e75a89719aa05ca0ad841d558c161b3bc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        long[] header =  readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    cacheTxStartPosition( ( (LogEntry.Commit) entry ).getTxId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","id":102909,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","commit_id":"08d5f67e75a89719aa05ca0ad841d558c161b3bc","url":"https://github.com/neo4j/neo4j"},{"original_method":"private synchronized void cacheTxStartPosition( long txId, LogEntry.Start startEntry )\n    {\n        if ( startEntry.getStartPosition() == -1 )\n        {\n            throw new RuntimeException( \"StartEntry.position is \" + startEntry.getStartPosition() );\n        }\n        txStartPositionCache.put( txId, new Pair<Long, Long>(\n                logVersion, startEntry.getStartPosition() ) );\n    }","id":102910,"modified_method":"private synchronized void cacheTxStartPosition( long txId, int masterId,\n            LogEntry.Start startEntry )\n    {\n        if ( startEntry.getStartPosition() == -1 )\n        {\n            throw new RuntimeException( \"StartEntry.position is \" + startEntry.getStartPosition() );\n        }\n        txStartPositionCache.put( txId, Triplet.of( logVersion, masterId, startEntry.getStartPosition() ) );\n    }","commit_id":"08d5f67e75a89719aa05ca0ad841d558c161b3bc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void commitTwoPhase( int identifier, long txId, int masterId ) \n        throws XAException\n    {\n        LogEntry.Start startEntry = xidIdentMap.get( identifier );\n        assert startEntry != null;\n        assert txId != -1;\n        try\n        {\n            writeBuffer.put( LogEntry.TX_2P_COMMIT ).putInt( \n                identifier ).putLong( txId ).putInt( masterId );\n            writeBuffer.force();\n            cacheTxStartPosition( txId, startEntry );\n        }\n        catch ( IOException e )\n        {\n            throw new XAException( \"Logical log unable to mark 2PC [\"\n                + identifier + \"] \" + e );\n        }\n    }","id":102911,"modified_method":"public synchronized void commitTwoPhase( int identifier, long txId, int masterId ) \n        throws XAException\n    {\n        LogEntry.Start startEntry = xidIdentMap.get( identifier );\n        assert startEntry != null;\n        assert txId != -1;\n        try\n        {\n            writeBuffer.put( LogEntry.TX_2P_COMMIT ).putInt( \n                identifier ).putLong( txId ).putInt( masterId );\n            writeBuffer.force();\n            cacheTxStartPosition( txId, masterId, startEntry );\n        }\n        catch ( IOException e )\n        {\n            throw new XAException( \"Logical log unable to mark 2PC [\"\n                + identifier + \"] \" + e );\n        }\n    }","commit_id":"08d5f67e75a89719aa05ca0ad841d558c161b3bc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void applyTransaction( ReadableByteChannel byteChannel )\n        throws IOException\n    {\n//        System.out.println( \"applyFullTx#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        scanIsComplete = false;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        long startEntryPosition = writeBuffer.getFileChannelPosition();\n        while ( logApplier.readAndWriteAndApplyEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        scanIsComplete = true;\n        LogEntry.Start startEntry = logApplier.startEntry;\n        if ( startEntry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        startEntry.setStartPosition( startEntryPosition );\n        cacheTxStartPosition( logApplier.commitEntry.getTxId(), startEntry );\n//        System.out.println( \"applyFullTx#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","id":102912,"modified_method":"public synchronized void applyTransaction( ReadableByteChannel byteChannel )\n        throws IOException\n    {\n//        System.out.println( \"applyFullTx#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        scanIsComplete = false;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        long startEntryPosition = writeBuffer.getFileChannelPosition();\n        while ( logApplier.readAndWriteAndApplyEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        scanIsComplete = true;\n        LogEntry.Start startEntry = logApplier.startEntry;\n        if ( startEntry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        startEntry.setStartPosition( startEntryPosition );\n        cacheTxStartPosition( logApplier.commitEntry.getTxId(), logApplier.commitEntry.getMasterId(), startEntry );\n//        System.out.println( \"applyFullTx#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","commit_id":"08d5f67e75a89719aa05ca0ad841d558c161b3bc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","id":102913,"modified_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        Triplet<Long, Integer, Long> cache = this.txStartPositionCache.get( txId );\n        if ( cache != null )\n        {\n            return cache.other();\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","commit_id":"08d5f67e75a89719aa05ca0ad841d558c161b3bc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void commitOnePhase( int identifier, long txId, int masterId )\n        throws XAException\n    {\n        LogEntry.Start startEntry = xidIdentMap.get( identifier );\n        assert startEntry != null;\n        assert txId != -1;\n        try\n        {\n            writeBuffer.put( LogEntry.TX_1P_COMMIT ).putInt( \n                identifier ).putLong( txId ).putInt( masterId );\n            writeBuffer.force();\n            cacheTxStartPosition( txId, startEntry );\n        }\n        catch ( IOException e )\n        {\n            throw new XAException( \"Logical log unable to mark 1P-commit [\"\n                + identifier + \"] \" + e );\n        }\n    }","id":102914,"modified_method":"public synchronized void commitOnePhase( int identifier, long txId, int masterId )\n        throws XAException\n    {\n        LogEntry.Start startEntry = xidIdentMap.get( identifier );\n        assert startEntry != null;\n        assert txId != -1;\n        try\n        {\n            writeBuffer.put( LogEntry.TX_1P_COMMIT ).putInt( \n                identifier ).putLong( txId ).putInt( masterId );\n            writeBuffer.force();\n            cacheTxStartPosition( txId, masterId, startEntry );\n        }\n        catch ( IOException e )\n        {\n            throw new XAException( \"Logical log unable to mark 1P-commit [\"\n                + identifier + \"] \" + e );\n        }\n    }","commit_id":"08d5f67e75a89719aa05ca0ad841d558c161b3bc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void applyTransaction( ReadableByteChannel byteChannel )\n        throws IOException\n    {\n//        System.out.println( \"applyFullTx#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        scanIsComplete = false;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        long startEntryPosition = writeBuffer.getFileChannelPosition();\n        while ( logApplier.readAndWriteAndApplyEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        scanIsComplete = true;\n        LogEntry.Start startEntry = logApplier.startEntry;\n        if ( startEntry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        startEntry.setStartPosition( startEntryPosition );\n        cacheTxStartPosition( logApplier.commitEntry.getTxId(), startEntry );\n//        System.out.println( \"applyFullTx#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","id":102915,"modified_method":"public synchronized void applyTransaction( ReadableByteChannel byteChannel )\n        throws IOException\n    {\n//        System.out.println( \"applyFullTx#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        scanIsComplete = false;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        long startEntryPosition = writeBuffer.getFileChannelPosition();\n        while ( logApplier.readAndWriteAndApplyEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        scanIsComplete = true;\n        LogEntry.Start startEntry = logApplier.startEntry;\n        if ( startEntry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        startEntry.setStartPosition( startEntryPosition );\n        cacheTxStartPosition( logApplier.commitEntry.getTxId(), logApplier.commitEntry.getMasterId(), startEntry );\n//        System.out.println( \"applyFullTx#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","commit_id":"78d77c2d45cb2b4aabf2eea88f5a5021e7796fee","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return logEntryList;\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","id":102916,"modified_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return logEntryList;\n        }\n        Triplet<Long, Integer, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.third() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","commit_id":"78d77c2d45cb2b4aabf2eea88f5a5021e7796fee","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void commitOnePhase( int identifier, long txId, int masterId )\n        throws XAException\n    {\n        LogEntry.Start startEntry = xidIdentMap.get( identifier );\n        assert startEntry != null;\n        assert txId != -1;\n        try\n        {\n            writeBuffer.put( LogEntry.TX_1P_COMMIT ).putInt( \n                identifier ).putLong( txId ).putInt( masterId );\n            writeBuffer.force();\n            cacheTxStartPosition( txId, startEntry );\n        }\n        catch ( IOException e )\n        {\n            throw new XAException( \"Logical log unable to mark 1P-commit [\"\n                + identifier + \"] \" + e );\n        }\n    }","id":102917,"modified_method":"public synchronized void commitOnePhase( int identifier, long txId, int masterId )\n        throws XAException\n    {\n        LogEntry.Start startEntry = xidIdentMap.get( identifier );\n        assert startEntry != null;\n        assert txId != -1;\n        try\n        {\n            writeBuffer.put( LogEntry.TX_1P_COMMIT ).putInt( \n                identifier ).putLong( txId ).putInt( masterId );\n            writeBuffer.force();\n            cacheTxStartPosition( txId, masterId, startEntry );\n        }\n        catch ( IOException e )\n        {\n            throw new XAException( \"Logical log unable to mark 1P-commit [\"\n                + identifier + \"] \" + e );\n        }\n    }","commit_id":"78d77c2d45cb2b4aabf2eea88f5a5021e7796fee","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","id":102918,"modified_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        Triplet<Long, Integer, Long> cache = this.txStartPositionCache.get( txId );\n        if ( cache != null )\n        {\n            return cache.other();\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","commit_id":"78d77c2d45cb2b4aabf2eea88f5a5021e7796fee","url":"https://github.com/neo4j/neo4j"},{"original_method":"private synchronized void cacheTxStartPosition( long txId, LogEntry.Start startEntry )\n    {\n        if ( startEntry.getStartPosition() == -1 )\n        {\n            throw new RuntimeException( \"StartEntry.position is \" + startEntry.getStartPosition() );\n        }\n        txStartPositionCache.put( txId, new Pair<Long, Long>(\n                logVersion, startEntry.getStartPosition() ) );\n    }","id":102919,"modified_method":"private synchronized void cacheTxStartPosition( long txId, int masterId,\n            LogEntry.Start startEntry )\n    {\n        if ( startEntry.getStartPosition() == -1 )\n        {\n            throw new RuntimeException( \"StartEntry.position is \" + startEntry.getStartPosition() );\n        }\n        txStartPositionCache.put( txId, Triplet.of( logVersion, masterId, startEntry.getStartPosition() ) );\n    }","commit_id":"78d77c2d45cb2b4aabf2eea88f5a5021e7796fee","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void applyTransactionWithoutTxId( ReadableByteChannel byteChannel, \n            long nextTxId, int masterId ) throws IOException\n    {\n        if ( nextTxId != (xaTf.getLastCommittedTx() + 1) )\n        {\n            throw new IllegalStateException( \"Tried to apply tx \" + \n                nextTxId + \" but expected transaction \" + \n                (xaTf.getCurrentVersion() + 1) );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \", committing tx=\" + nextTxId + \")\" );\n//        System.out.println( \"applyTxWithoutTxId#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        scanIsComplete = false;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        long startEntryPosition = writeBuffer.getFileChannelPosition();\n        while ( logApplier.readAndWriteAndApplyEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        LogEntry.Start startEntry = logApplier.startEntry;\n        if ( startEntry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        startEntry.setStartPosition( startEntryPosition );\n//        System.out.println( \"applyTxWithoutTxId#before 1PC @ pos: \" + writeBuffer.getFileChannelPosition() );\n        LogEntry.OnePhaseCommit commit = new LogEntry.OnePhaseCommit( \n                xidIdent, nextTxId, masterId );\n        LogIoUtils.writeLogEntry( commit, writeBuffer );\n        Xid xid = startEntry.getXid();\n        try\n        {\n            XaTransaction xaTx = xaRm.getXaTransaction( xid );\n            xaTx.setCommitTxId( nextTxId );\n            xaRm.commit( xid, true );\n            LogEntry doneEntry = new LogEntry.Done( startEntry.getIdentifier() );\n            LogIoUtils.writeLogEntry( doneEntry, writeBuffer );\n            xidIdentMap.remove( startEntry.getIdentifier() );\n            recoveredTxMap.remove( startEntry.getIdentifier() );\n            cacheTxStartPosition( nextTxId, startEntry );\n        }\n        catch ( XAException e )\n        {\n            e.printStackTrace();\n            throw new IOException( e.getMessage() );\n        }\n        \n//        LogEntry.Done done = new LogEntry.Done( entry.getIdentifier() );\n//        LogIoUtils.writeLogEntry( done, writeBuffer );\n        // xaTf.setLastCommittedTx( nextTxId ); // done in doCommit\n        scanIsComplete = true;\n//        log.info( \"Tx[\" + nextTxId + \"] \" + \" applied successfully.\" );\n        msgLog.logMessage( \"Applied external tx and generated tx id=\" + nextTxId );\n//        System.out.println( \"applyTxWithoutTxId#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","id":102920,"modified_method":"public synchronized void applyTransactionWithoutTxId( ReadableByteChannel byteChannel, \n            long nextTxId, int masterId ) throws IOException\n    {\n        if ( nextTxId != (xaTf.getLastCommittedTx() + 1) )\n        {\n            throw new IllegalStateException( \"Tried to apply tx \" + \n                nextTxId + \" but expected transaction \" + \n                (xaTf.getCurrentVersion() + 1) );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \", committing tx=\" + nextTxId + \")\" );\n//        System.out.println( \"applyTxWithoutTxId#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        scanIsComplete = false;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        long startEntryPosition = writeBuffer.getFileChannelPosition();\n        while ( logApplier.readAndWriteAndApplyEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        LogEntry.Start startEntry = logApplier.startEntry;\n        if ( startEntry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        startEntry.setStartPosition( startEntryPosition );\n//        System.out.println( \"applyTxWithoutTxId#before 1PC @ pos: \" + writeBuffer.getFileChannelPosition() );\n        LogEntry.OnePhaseCommit commit = new LogEntry.OnePhaseCommit( \n                xidIdent, nextTxId, masterId );\n        LogIoUtils.writeLogEntry( commit, writeBuffer );\n        Xid xid = startEntry.getXid();\n        try\n        {\n            XaTransaction xaTx = xaRm.getXaTransaction( xid );\n            xaTx.setCommitTxId( nextTxId );\n            xaRm.commit( xid, true );\n            LogEntry doneEntry = new LogEntry.Done( startEntry.getIdentifier() );\n            LogIoUtils.writeLogEntry( doneEntry, writeBuffer );\n            xidIdentMap.remove( startEntry.getIdentifier() );\n            recoveredTxMap.remove( startEntry.getIdentifier() );\n            cacheTxStartPosition( nextTxId, masterId, startEntry );\n        }\n        catch ( XAException e )\n        {\n            e.printStackTrace();\n            throw new IOException( e.getMessage() );\n        }\n        \n//        LogEntry.Done done = new LogEntry.Done( entry.getIdentifier() );\n//        LogIoUtils.writeLogEntry( done, writeBuffer );\n        // xaTf.setLastCommittedTx( nextTxId ); // done in doCommit\n        scanIsComplete = true;\n//        log.info( \"Tx[\" + nextTxId + \"] \" + \" applied successfully.\" );\n        msgLog.logMessage( \"Applied external tx and generated tx id=\" + nextTxId );\n//        System.out.println( \"applyTxWithoutTxId#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","commit_id":"78d77c2d45cb2b4aabf2eea88f5a5021e7796fee","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void commitTwoPhase( int identifier, long txId, int masterId ) \n        throws XAException\n    {\n        LogEntry.Start startEntry = xidIdentMap.get( identifier );\n        assert startEntry != null;\n        assert txId != -1;\n        try\n        {\n            writeBuffer.put( LogEntry.TX_2P_COMMIT ).putInt( \n                identifier ).putLong( txId ).putInt( masterId );\n            writeBuffer.force();\n            cacheTxStartPosition( txId, startEntry );\n        }\n        catch ( IOException e )\n        {\n            throw new XAException( \"Logical log unable to mark 2PC [\"\n                + identifier + \"] \" + e );\n        }\n    }","id":102921,"modified_method":"public synchronized void commitTwoPhase( int identifier, long txId, int masterId ) \n        throws XAException\n    {\n        LogEntry.Start startEntry = xidIdentMap.get( identifier );\n        assert startEntry != null;\n        assert txId != -1;\n        try\n        {\n            writeBuffer.put( LogEntry.TX_2P_COMMIT ).putInt( \n                identifier ).putLong( txId ).putInt( masterId );\n            writeBuffer.force();\n            cacheTxStartPosition( txId, masterId, startEntry );\n        }\n        catch ( IOException e )\n        {\n            throw new XAException( \"Logical log unable to mark 2PC [\"\n                + identifier + \"] \" + e );\n        }\n    }","commit_id":"78d77c2d45cb2b4aabf2eea88f5a5021e7796fee","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        long[] header =  readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    cacheTxStartPosition( ( (LogEntry.Commit) entry ).getTxId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","id":102922,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","commit_id":"78d77c2d45cb2b4aabf2eea88f5a5021e7796fee","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return logEntryList;\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","id":102923,"modified_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return logEntryList;\n        }\n        Triplet<Long, Integer, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.third() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","commit_id":"15bb4d332ab6f3fbfe6943a529b961d6cb13d89a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        long[] header =  readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    cacheTxStartPosition( ( (LogEntry.Commit) entry ).getTxId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","id":102924,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","commit_id":"15bb4d332ab6f3fbfe6943a529b961d6cb13d89a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void applyTransaction( ReadableByteChannel byteChannel )\n        throws IOException\n    {\n//        System.out.println( \"applyFullTx#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        scanIsComplete = false;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        long startEntryPosition = writeBuffer.getFileChannelPosition();\n        while ( logApplier.readAndWriteAndApplyEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        scanIsComplete = true;\n        LogEntry.Start startEntry = logApplier.startEntry;\n        if ( startEntry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        startEntry.setStartPosition( startEntryPosition );\n        cacheTxStartPosition( logApplier.commitEntry.getTxId(), startEntry );\n//        System.out.println( \"applyFullTx#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","id":102925,"modified_method":"public synchronized void applyTransaction( ReadableByteChannel byteChannel )\n        throws IOException\n    {\n//        System.out.println( \"applyFullTx#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        scanIsComplete = false;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        long startEntryPosition = writeBuffer.getFileChannelPosition();\n        while ( logApplier.readAndWriteAndApplyEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        scanIsComplete = true;\n        LogEntry.Start startEntry = logApplier.startEntry;\n        if ( startEntry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        startEntry.setStartPosition( startEntryPosition );\n        cacheTxStartPosition( logApplier.commitEntry.getTxId(), logApplier.commitEntry.getMasterId(), startEntry );\n//        System.out.println( \"applyFullTx#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","commit_id":"15bb4d332ab6f3fbfe6943a529b961d6cb13d89a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","id":102926,"modified_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        Triplet<Long, Integer, Long> cache = this.txStartPositionCache.get( txId );\n        if ( cache != null )\n        {\n            return cache.other();\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","commit_id":"15bb4d332ab6f3fbfe6943a529b961d6cb13d89a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void commitTwoPhase( int identifier, long txId, int masterId ) \n        throws XAException\n    {\n        LogEntry.Start startEntry = xidIdentMap.get( identifier );\n        assert startEntry != null;\n        assert txId != -1;\n        try\n        {\n            writeBuffer.put( LogEntry.TX_2P_COMMIT ).putInt( \n                identifier ).putLong( txId ).putInt( masterId );\n            writeBuffer.force();\n            cacheTxStartPosition( txId, startEntry );\n        }\n        catch ( IOException e )\n        {\n            throw new XAException( \"Logical log unable to mark 2PC [\"\n                + identifier + \"] \" + e );\n        }\n    }","id":102927,"modified_method":"public synchronized void commitTwoPhase( int identifier, long txId, int masterId ) \n        throws XAException\n    {\n        LogEntry.Start startEntry = xidIdentMap.get( identifier );\n        assert startEntry != null;\n        assert txId != -1;\n        try\n        {\n            writeBuffer.put( LogEntry.TX_2P_COMMIT ).putInt( \n                identifier ).putLong( txId ).putInt( masterId );\n            writeBuffer.force();\n            cacheTxStartPosition( txId, masterId, startEntry );\n        }\n        catch ( IOException e )\n        {\n            throw new XAException( \"Logical log unable to mark 2PC [\"\n                + identifier + \"] \" + e );\n        }\n    }","commit_id":"15bb4d332ab6f3fbfe6943a529b961d6cb13d89a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private synchronized void cacheTxStartPosition( long txId, LogEntry.Start startEntry )\n    {\n        if ( startEntry.getStartPosition() == -1 )\n        {\n            throw new RuntimeException( \"StartEntry.position is \" + startEntry.getStartPosition() );\n        }\n        txStartPositionCache.put( txId, new Pair<Long, Long>(\n                logVersion, startEntry.getStartPosition() ) );\n    }","id":102928,"modified_method":"private synchronized void cacheTxStartPosition( long txId, int masterId,\n            LogEntry.Start startEntry )\n    {\n        if ( startEntry.getStartPosition() == -1 )\n        {\n            throw new RuntimeException( \"StartEntry.position is \" + startEntry.getStartPosition() );\n        }\n        txStartPositionCache.put( txId, Triplet.of( logVersion, masterId, startEntry.getStartPosition() ) );\n    }","commit_id":"15bb4d332ab6f3fbfe6943a529b961d6cb13d89a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void applyTransactionWithoutTxId( ReadableByteChannel byteChannel, \n            long nextTxId, int masterId ) throws IOException\n    {\n        if ( nextTxId != (xaTf.getLastCommittedTx() + 1) )\n        {\n            throw new IllegalStateException( \"Tried to apply tx \" + \n                nextTxId + \" but expected transaction \" + \n                (xaTf.getCurrentVersion() + 1) );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \", committing tx=\" + nextTxId + \")\" );\n//        System.out.println( \"applyTxWithoutTxId#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        scanIsComplete = false;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        long startEntryPosition = writeBuffer.getFileChannelPosition();\n        while ( logApplier.readAndWriteAndApplyEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        LogEntry.Start startEntry = logApplier.startEntry;\n        if ( startEntry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        startEntry.setStartPosition( startEntryPosition );\n//        System.out.println( \"applyTxWithoutTxId#before 1PC @ pos: \" + writeBuffer.getFileChannelPosition() );\n        LogEntry.OnePhaseCommit commit = new LogEntry.OnePhaseCommit( \n                xidIdent, nextTxId, masterId );\n        LogIoUtils.writeLogEntry( commit, writeBuffer );\n        Xid xid = startEntry.getXid();\n        try\n        {\n            XaTransaction xaTx = xaRm.getXaTransaction( xid );\n            xaTx.setCommitTxId( nextTxId );\n            xaRm.commit( xid, true );\n            LogEntry doneEntry = new LogEntry.Done( startEntry.getIdentifier() );\n            LogIoUtils.writeLogEntry( doneEntry, writeBuffer );\n            xidIdentMap.remove( startEntry.getIdentifier() );\n            recoveredTxMap.remove( startEntry.getIdentifier() );\n            cacheTxStartPosition( nextTxId, startEntry );\n        }\n        catch ( XAException e )\n        {\n            e.printStackTrace();\n            throw new IOException( e.getMessage() );\n        }\n        \n//        LogEntry.Done done = new LogEntry.Done( entry.getIdentifier() );\n//        LogIoUtils.writeLogEntry( done, writeBuffer );\n        // xaTf.setLastCommittedTx( nextTxId ); // done in doCommit\n        scanIsComplete = true;\n//        log.info( \"Tx[\" + nextTxId + \"] \" + \" applied successfully.\" );\n        msgLog.logMessage( \"Applied external tx and generated tx id=\" + nextTxId );\n//        System.out.println( \"applyTxWithoutTxId#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","id":102929,"modified_method":"public synchronized void applyTransactionWithoutTxId( ReadableByteChannel byteChannel, \n            long nextTxId, int masterId ) throws IOException\n    {\n        if ( nextTxId != (xaTf.getLastCommittedTx() + 1) )\n        {\n            throw new IllegalStateException( \"Tried to apply tx \" + \n                nextTxId + \" but expected transaction \" + \n                (xaTf.getCurrentVersion() + 1) );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \", committing tx=\" + nextTxId + \")\" );\n//        System.out.println( \"applyTxWithoutTxId#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        scanIsComplete = false;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        long startEntryPosition = writeBuffer.getFileChannelPosition();\n        while ( logApplier.readAndWriteAndApplyEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        LogEntry.Start startEntry = logApplier.startEntry;\n        if ( startEntry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        startEntry.setStartPosition( startEntryPosition );\n//        System.out.println( \"applyTxWithoutTxId#before 1PC @ pos: \" + writeBuffer.getFileChannelPosition() );\n        LogEntry.OnePhaseCommit commit = new LogEntry.OnePhaseCommit( \n                xidIdent, nextTxId, masterId );\n        LogIoUtils.writeLogEntry( commit, writeBuffer );\n        Xid xid = startEntry.getXid();\n        try\n        {\n            XaTransaction xaTx = xaRm.getXaTransaction( xid );\n            xaTx.setCommitTxId( nextTxId );\n            xaRm.commit( xid, true );\n            LogEntry doneEntry = new LogEntry.Done( startEntry.getIdentifier() );\n            LogIoUtils.writeLogEntry( doneEntry, writeBuffer );\n            xidIdentMap.remove( startEntry.getIdentifier() );\n            recoveredTxMap.remove( startEntry.getIdentifier() );\n            cacheTxStartPosition( nextTxId, masterId, startEntry );\n        }\n        catch ( XAException e )\n        {\n            e.printStackTrace();\n            throw new IOException( e.getMessage() );\n        }\n        \n//        LogEntry.Done done = new LogEntry.Done( entry.getIdentifier() );\n//        LogIoUtils.writeLogEntry( done, writeBuffer );\n        // xaTf.setLastCommittedTx( nextTxId ); // done in doCommit\n        scanIsComplete = true;\n//        log.info( \"Tx[\" + nextTxId + \"] \" + \" applied successfully.\" );\n        msgLog.logMessage( \"Applied external tx and generated tx id=\" + nextTxId );\n//        System.out.println( \"applyTxWithoutTxId#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","commit_id":"15bb4d332ab6f3fbfe6943a529b961d6cb13d89a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void commitOnePhase( int identifier, long txId, int masterId )\n        throws XAException\n    {\n        LogEntry.Start startEntry = xidIdentMap.get( identifier );\n        assert startEntry != null;\n        assert txId != -1;\n        try\n        {\n            writeBuffer.put( LogEntry.TX_1P_COMMIT ).putInt( \n                identifier ).putLong( txId ).putInt( masterId );\n            writeBuffer.force();\n            cacheTxStartPosition( txId, startEntry );\n        }\n        catch ( IOException e )\n        {\n            throw new XAException( \"Logical log unable to mark 1P-commit [\"\n                + identifier + \"] \" + e );\n        }\n    }","id":102930,"modified_method":"public synchronized void commitOnePhase( int identifier, long txId, int masterId )\n        throws XAException\n    {\n        LogEntry.Start startEntry = xidIdentMap.get( identifier );\n        assert startEntry != null;\n        assert txId != -1;\n        try\n        {\n            writeBuffer.put( LogEntry.TX_1P_COMMIT ).putInt( \n                identifier ).putLong( txId ).putInt( masterId );\n            writeBuffer.force();\n            cacheTxStartPosition( txId, masterId, startEntry );\n        }\n        catch ( IOException e )\n        {\n            throw new XAException( \"Logical log unable to mark 1P-commit [\"\n                + identifier + \"] \" + e );\n        }\n    }","commit_id":"15bb4d332ab6f3fbfe6943a529b961d6cb13d89a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void visit(Tree.TypeLiteral literal) {\n        if (annotationConstructor != null) {\n            if (checkingArguments || checkingDefaults){\n                appendLiteralArgument(literal, literal);\n            }\n        }\n    }","id":102931,"modified_method":"public void visit(Tree.TypeLiteral literal) {\n        if (annotationConstructor != null) {\n            if (checkingArguments || checkingDefaults){\n                LiteralAnnotationTerm argument = new DeclarationLiteralAnnotationTerm(new String[]{literal.getText()});\n                argument.setTerm(literal);\n                appendLiteralArgument(literal, argument);\n            }\n        }\n    }","commit_id":"4af132aee2c431c051977ff1b5d7898c5fd5a164","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public void visit(Tree.MemberLiteral literal) {\n        if (annotationConstructor != null) {\n            if (checkingArguments || checkingDefaults){\n                appendLiteralArgument(literal, literal);\n            }\n        }\n    }","id":102932,"modified_method":"public void visit(Tree.MemberLiteral literal) {\n        if (annotationConstructor != null) {\n            if (checkingArguments || checkingDefaults){\n                LiteralAnnotationTerm argument = new DeclarationLiteralAnnotationTerm(new String[]{literal.getText()});\n                argument.setTerm(literal);\n                appendLiteralArgument(literal, argument);\n            }\n        }\n    }","commit_id":"4af132aee2c431c051977ff1b5d7898c5fd5a164","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public void visit(Tree.Literal literal) {\n        if (annotationConstructor != null) {\n            if (checkingArguments || checkingDefaults){\n                appendLiteralArgument(literal, literal);\n            }\n        }\n    }","id":102933,"modified_method":"public void visit(Tree.CharLiteral literal) {\n        if (annotationConstructor != null) {\n            if (checkingArguments || checkingDefaults){\n                LiteralAnnotationTerm argument = new CharacterLiteralAnnotationTerm(new int[]{ExpressionTransformer.literalValue(literal)});\n                argument.setTerm(literal);\n                appendLiteralArgument(literal, argument);\n            }\n        }\n    }","commit_id":"4af132aee2c431c051977ff1b5d7898c5fd5a164","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void visit(Tree.BaseMemberExpression bme) {\n        if (annotationConstructor != null) {\n            Declaration declaration = bme.getDeclaration();\n            if (checkingInvocationPrimary \n                    && isAnnotationConstructor(bme.getDeclaration())) {\n                Method ctor = (Method)bme.getDeclaration();\n                instantiation.setPrimary(ctor);\n                if (ctor.getAnnotationConstructor() != null) {\n                    instantiation.getConstructorParameters().addAll(((AnnotationInvocation)ctor.getAnnotationConstructor()).getConstructorParameters());\n                }\n            } else if (checkingArguments || checkingDefaults) {\n                if (declaration instanceof Value && ((Value)declaration).isParameter()) {\n                    Value constructorParameter = (Value)declaration;\n                    ParameterAnnotationTerm a = new ParameterAnnotationTerm();\n                    a.setSpread(spread);\n                    // XXX Is this right?\n                    a.setSourceParameter(constructorParameter.getInitializerParameter());\n                    this.term = a;\n                } else if (isBooleanTrue(declaration)) {\n                    appendLiteralArgument(bme, bme);\n                } else if (isBooleanFalse(declaration)) {\n                    appendLiteralArgument(bme, bme);\n                } else if (Decl.isAnonCaseOfEnumeratedType(bme)) {\n                    appendLiteralArgument(bme, bme).setLiteralObject(bme.getTypeModel());\n                } else {\n                    bme.addError(\"Unsupported base member expression in annotation constructor\");\n                }\n            } else {\n                bme.addError(\"Unsupported base member expression in annotation constructor\");\n            }\n        }\n    }","id":102934,"modified_method":"@Override\n    public void visit(Tree.BaseMemberExpression bme) {\n        if (annotationConstructor != null) {\n            Declaration declaration = bme.getDeclaration();\n            if (checkingInvocationPrimary \n                    && isAnnotationConstructor(bme.getDeclaration())) {\n                Method ctor = (Method)bme.getDeclaration();\n                instantiation.setPrimary(ctor);\n                if (ctor.getAnnotationConstructor() != null) {\n                    instantiation.getConstructorParameters().addAll(((AnnotationInvocation)ctor.getAnnotationConstructor()).getConstructorParameters());\n                }\n            } else if (checkingArguments || checkingDefaults) {\n                if (declaration instanceof Value && ((Value)declaration).isParameter()) {\n                    Value constructorParameter = (Value)declaration;\n                    ParameterAnnotationTerm a = new ParameterAnnotationTerm();\n                    a.setSpread(spread);\n                    // XXX Is this right?\n                    a.setSourceParameter(constructorParameter.getInitializerParameter());\n                    this.term = a;\n                } else if (isBooleanTrue(declaration)) {\n                    LiteralAnnotationTerm argument = new BooleanLiteralAnnotationTerm(new boolean[]{true});\n                    argument.setTerm(bme);\n                    appendLiteralArgument(bme, argument);\n                } else if (isBooleanFalse(declaration)) {\n                    LiteralAnnotationTerm argument = new BooleanLiteralAnnotationTerm(new boolean[]{false});\n                    argument.setTerm(bme);\n                    appendLiteralArgument(bme, argument);\n                } else if (Decl.isAnonCaseOfEnumeratedType(bme)) {\n                    LiteralAnnotationTerm argument = new ObjectLiteralAnnotationTerm(new ProducedType[]{bme.getTypeModel()});\n                    argument.setTerm(bme);\n                    appendLiteralArgument(bme, argument);\n                } else {\n                    bme.addError(\"Unsupported base member expression in annotation constructor\");\n                }\n            } else {\n                bme.addError(\"Unsupported base member expression in annotation constructor\");\n            }\n        }\n    }","commit_id":"4af132aee2c431c051977ff1b5d7898c5fd5a164","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public void visit(Tree.NegativeOp op) {\n        if (annotationConstructor != null) {\n            if (checkingArguments || checkingDefaults){\n                if (op.getTerm() instanceof Tree.Literal) {\n                    appendLiteralArgument(op, op);\n                }\n            }\n        }\n    }","id":102935,"modified_method":"public void visit(Tree.NegativeOp op) {\n        if (annotationConstructor != null) {\n            if (checkingArguments || checkingDefaults){\n                try {\n                    if (op.getTerm() instanceof Tree.NaturalLiteral) {\n                        LiteralAnnotationTerm argument = new IntegerLiteralAnnotationTerm(new long[]{ExpressionTransformer.literalValue(op)});\n                        argument.setTerm(op);\n                        appendLiteralArgument(op, argument);\n                    } else if (op.getTerm() instanceof Tree.FloatLiteral) {\n                        LiteralAnnotationTerm argument = new FloatLiteralAnnotationTerm(new double[]{-ExpressionTransformer.literalValue((Tree.FloatLiteral)op.getTerm())});\n                        argument.setTerm(op);\n                        appendLiteralArgument(op, argument);\n                    }\n                } catch (ErroneousException e) {\n                    // Ignore it: The ExpressionTransformer will produce an error later in codegen\n                }\n            }\n        }\n    }","commit_id":"4af132aee2c431c051977ff1b5d7898c5fd5a164","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/** \n     * Records <strong>either<\/strong> \n     * a literal argument to the annotation class instantiation:\n     * <pre>\n     *    ... => AnnotationClass(\"\", 1, true, 1.0, 'x')\n     * <\/pre>\n     * <strong>Or<\/strong> a literal default argument in an annotation constructor:\n     * <pre>\n     *     AnnotationClass ctor(String s=\"\", Integer i=1,\n     *             Boolean b=true, Float f=1.0,\n     *             Character c='x') => ...\n     * <\/pre>\n     * Literal is in the Javac sense.\n     */\n    private LiteralAnnotationTerm appendLiteralArgument(Node bme, Tree.Term literal) {\n        if (spread) {\n            bme.addError(\"Spread static arguments not supported\");\n        }\n        LiteralAnnotationTerm argument = new LiteralAnnotationTerm();\n        argument.setTerm(literal);\n        this.term = argument;\n        return argument;\n    }","id":102936,"modified_method":"/** \n     * Records <strong>either<\/strong> \n     * a literal argument to the annotation class instantiation:\n     * <pre>\n     *    ... => AnnotationClass(\"\", 1, true, 1.0, 'x')\n     * <\/pre>\n     * <strong>Or<\/strong> a literal default argument in an annotation constructor:\n     * <pre>\n     *     AnnotationClass ctor(String s=\"\", Integer i=1,\n     *             Boolean b=true, Float f=1.0,\n     *             Character c='x') => ...\n     * <\/pre>\n     * Literal is in the Javac sense.\n     */\n    private LiteralAnnotationTerm appendLiteralArgument(Node bme, LiteralAnnotationTerm argument) {\n        if (spread) {\n            bme.addError(\"Spread static arguments not supported\");\n        }\n        if (this.elements != null) {\n           this.elements.add(argument);\n        } else {\n            this.term = argument;\n        }\n        return argument;\n    }","commit_id":"4af132aee2c431c051977ff1b5d7898c5fd5a164","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\r\n     * @see org.opencms.workplace.CmsWidgetDialog#defineWidgets()\r\n     */\r\n    @Override\r\n    protected void defineWidgets() {\r\n\r\n        initSite();\r\n        setKeyPrefix(CmsSitesOverviewList.KEY_PREFIX_SITES);\r\n\r\n        if (DIALOG_NEW.equals(getParamEditaction()) || DIALOG_EDIT.equals(getParamEditaction())) {\r\n            // edit or new\r\n            // site info\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"title\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(this, \"sitename\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"server\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"errorPage\", PAGES[0], new CmsVfsFileWidget(\r\n                true,\r\n                \"\",\r\n                true,\r\n                false)));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"position\", PAGES[0], new CmsSelectWidget(\r\n                createNavOpts(m_site))));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"webserver\", PAGES[0], new CmsCheckboxWidget()));\r\n            if (DIALOG_NEW.equals(getParamEditaction())) {\r\n                addWidget(new CmsWidgetDialogParameter(this, \"createou\", PAGES[0], new CmsCheckboxWidget()));\r\n                addWidget(new CmsWidgetDialogParameter(this, \"template\", PAGES[0], new CmsVfsFileWidget(\r\n                    true,\r\n                    \"\",\r\n                    true,\r\n                    false)));\r\n            }\r\n\r\n            if (m_site.getFavicon() != null) {\r\n                try {\r\n                    CmsObject clone = OpenCms.initCmsObject(getCms());\r\n                    clone.getRequestContext().setSiteRoot(\"\");\r\n\r\n                    CmsDisplayWidget dis = new CmsDisplayWidget(\"<img src='\"\r\n                        + OpenCms.getLinkManager().getOnlineLink(clone, m_site.getFavicon())\r\n                        + \"' border='0' width='16' height='16' />\");\r\n                    addWidget(new CmsWidgetDialogParameter(m_site, \"favicon\", PAGES[0], dis));\r\n                } catch (Exception e) {\r\n                    // noop\r\n                }\r\n            }\r\n\r\n            // secure site\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"secureUrl\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveUrl\", PAGES[0], new CmsCheckboxWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveError\", PAGES[0], new CmsCheckboxWidget()));\r\n\r\n            // site aliases\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"aliases\", PAGES[0], new CmsInputWidget()));\r\n        } else {\r\n            // display site\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"title\", PAGES[0], new CmsDisplayWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"siteRoot\", PAGES[0], new CmsDisplayWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"server\", PAGES[0], new CmsDisplayWidget()));\r\n            CmsWidgetDialogParameter errorPage;\r\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_site.getErrorPage())) {\r\n                errorPage = new CmsWidgetDialogParameter(m_site, \"errorPage\", PAGES[0], new CmsDisplayWidget(\r\n                    Messages.get().container(Messages.GUI_SITES_ERROR_PAGE_NOT_AVAILABLE_0).key()));\r\n            } else {\r\n                errorPage = new CmsWidgetDialogParameter(m_site, \"errorPage\", PAGES[0], new CmsDisplayWidget());\r\n            }\r\n            addWidget(errorPage);\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"webserver\", PAGES[0], new CmsDisplayWidget()));\r\n\r\n            if (m_site.getFavicon() != null) {\r\n                try {\r\n                    CmsObject clone = OpenCms.initCmsObject(getCms());\r\n                    clone.getRequestContext().setSiteRoot(\"\");\r\n\r\n                    CmsDisplayWidget dis = new CmsDisplayWidget(\"<img src='\"\r\n                        + OpenCms.getLinkManager().getOnlineLink(clone, m_site.getFavicon())\r\n                        + \"' border='0' width='16' height='16' />\");\r\n                    addWidget(new CmsWidgetDialogParameter(m_site, \"favicon\", PAGES[0], dis));\r\n                } catch (Exception e) {\r\n                    // noop\r\n                }\r\n            }\r\n\r\n            if (m_site.hasSecureServer()) {\r\n                addWidget(new CmsWidgetDialogParameter(m_site, \"secureUrl\", PAGES[0], new CmsDisplayWidget()));\r\n                addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveUrl\", PAGES[0], new CmsDisplayWidget()));\r\n                addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveError\", PAGES[0], new CmsDisplayWidget()));\r\n            }\r\n            int count = 0;\r\n            for (String aliasUrl : m_site.getAliases()) {\r\n                CmsWidgetDialogParameter alias = new CmsWidgetDialogParameter(\r\n                    aliasUrl,\r\n                    aliasUrl,\r\n                    Messages.get().getBundle(getCms().getRequestContext().getLocale()).key(\r\n                        Messages.GUI_SITES_DETAIL_LABEL_ALIAS_0)\r\n                        + \" [\"\r\n                        + (count + 1)\r\n                        + \"]\",\r\n                    new CmsDisplayWidget(),\r\n                    PAGES[0],\r\n                    1,\r\n                    1,\r\n                    count);\r\n                addWidget(alias);\r\n                count++;\r\n            }\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"aliases\", PAGES[0], new CmsDisplayWidget()));\r\n        }\r\n    }","id":102937,"modified_method":"/**\r\n     * @see org.opencms.workplace.CmsWidgetDialog#defineWidgets()\r\n     */\r\n    @Override\r\n    protected void defineWidgets() {\r\n\r\n        initSite();\r\n        setKeyPrefix(CmsSitesOverviewList.KEY_PREFIX_SITES);\r\n\r\n        if (DIALOG_NEW.equals(getParamEditaction()) || DIALOG_EDIT.equals(getParamEditaction())) {\r\n            // edit or new\r\n            // site info\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"title\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(this, \"sitename\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"server\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"errorPage\", PAGES[0], new CmsVfsFileWidget(\r\n                true,\r\n                \"\",\r\n                true,\r\n                false)));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"position\", PAGES[0], new CmsSelectWidget(\r\n                createNavOpts(m_site))));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"webserver\", PAGES[0], new CmsCheckboxWidget()));\r\n            if (DIALOG_NEW.equals(getParamEditaction())) {\r\n                addWidget(new CmsWidgetDialogParameter(this, \"createou\", PAGES[0], new CmsCheckboxWidget()));\r\n                addWidget(new CmsWidgetDialogParameter(this, \"template\", PAGES[0], new CmsVfsFileWidget(\r\n                    true,\r\n                    \"\",\r\n                    true,\r\n                    false)));\r\n            }\r\n\r\n            if (m_site.getFavicon() != null) {\r\n                try {\r\n                    CmsObject clone = OpenCms.initCmsObject(getCms());\r\n                    clone.getRequestContext().setSiteRoot(\"\");\r\n\r\n                    CmsDisplayWidget dis = new CmsDisplayWidget(\"<img src='\"\r\n                        + OpenCms.getLinkManager().getOnlineLink(clone, m_site.getFavicon())\r\n                        + \"' border='0' width='16' height='16' />\");\r\n                    addWidget(new CmsWidgetDialogParameter(m_site, \"favicon\", PAGES[0], dis));\r\n                } catch (Exception e) {\r\n                    // noop\r\n                }\r\n            }\r\n\r\n            // secure site\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"secureUrl\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveUrl\", PAGES[0], new CmsCheckboxWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveError\", PAGES[0], new CmsCheckboxWidget()));\r\n\r\n            // site aliases\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"aliases\", PAGES[0], new CmsInputWidget()));\r\n        } else {\r\n            // display site\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"title\", PAGES[0], new CmsDisplayWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"siteRoot\", PAGES[0], new CmsDisplayWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"server\", PAGES[0], new CmsDisplayWidget()));\r\n            CmsWidgetDialogParameter errorPage;\r\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_site.getErrorPage())) {\r\n                errorPage = new CmsWidgetDialogParameter(m_site, \"errorPage\", PAGES[0], new CmsDisplayWidget(\r\n                    Messages.get().getBundle(getCms().getRequestContext().getLocale()).key(\r\n                        Messages.GUI_SITES_ERROR_PAGE_NOT_AVAILABLE_0)));\r\n            } else {\r\n                errorPage = new CmsWidgetDialogParameter(m_site, \"errorPage\", PAGES[0], new CmsDisplayWidget());\r\n            }\r\n            addWidget(errorPage);\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"webserver\", PAGES[0], new CmsDisplayWidget()));\r\n\r\n            if (m_site.getFavicon() != null) {\r\n                try {\r\n                    CmsObject clone = OpenCms.initCmsObject(getCms());\r\n                    clone.getRequestContext().setSiteRoot(\"\");\r\n\r\n                    CmsDisplayWidget dis = new CmsDisplayWidget(\"<img src='\"\r\n                        + OpenCms.getLinkManager().getOnlineLink(clone, m_site.getFavicon())\r\n                        + \"' border='0' width='16' height='16' />\");\r\n                    addWidget(new CmsWidgetDialogParameter(m_site, \"favicon\", PAGES[0], dis));\r\n                } catch (Exception e) {\r\n                    // noop\r\n                }\r\n            }\r\n\r\n            if (m_site.hasSecureServer()) {\r\n                addWidget(new CmsWidgetDialogParameter(m_site, \"secureUrl\", PAGES[0], new CmsDisplayWidget()));\r\n                addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveUrl\", PAGES[0], new CmsDisplayWidget()));\r\n                addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveError\", PAGES[0], new CmsDisplayWidget()));\r\n            }\r\n            int count = 0;\r\n            for (String aliasUrl : m_site.getAliases()) {\r\n                CmsWidgetDialogParameter alias = new CmsWidgetDialogParameter(\r\n                    aliasUrl,\r\n                    aliasUrl,\r\n                    Messages.get().getBundle(getCms().getRequestContext().getLocale()).key(\r\n                        Messages.GUI_SITES_DETAIL_LABEL_ALIAS_0)\r\n                        + \" [\"\r\n                        + (count + 1)\r\n                        + \"]\",\r\n                    new CmsDisplayWidget(),\r\n                    PAGES[0],\r\n                    1,\r\n                    1,\r\n                    count);\r\n                addWidget(alias);\r\n                count++;\r\n            }\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"aliases\", PAGES[0], new CmsDisplayWidget()));\r\n        }\r\n    }","commit_id":"3ed1621b7c5c7cd349ef9ab0deb428e7828b4b10","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.workplace.CmsWidgetDialog#actionCommit()\n     */\n    @Override\n    public void actionCommit() {\n\n        try {\n\n            // validate the dialog form\n            validateDialog();\n\n            // create a root site clone of the current CMS object.\n            CmsObject cms = OpenCms.initCmsObject(getCms());\n            cms.getRequestContext().setSiteRoot(\"\");\n\n            // create the site root path\n            String siteRoot = \"/sites\".concat(m_sitename);\n            m_site.setSiteRoot(siteRoot);\n\n            CmsResource siteRootResource = null;\n            String sitePath = null;\n            // check if the site root already exists\n            try {\n                // take the existing site and do not perform any OU related actions\n                siteRootResource = cms.readResource(siteRoot);\n                sitePath = cms.getSitePath(siteRootResource);\n            } catch (@SuppressWarnings(\"unused\") CmsVfsResourceNotFoundException e) {\n                // not create a new site folder and the according OU if option is checked checked\n                I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(\n                    CmsResourceTypeFolderSubSitemap.TYPE_SUBSITEMAP);\n                siteRootResource = cms.createResource(siteRoot, type);\n                sitePath = cms.getSitePath(siteRootResource);\n            }\n\n            // add template  property\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(getTemplate())) {\n                CmsProperty prop = new CmsProperty(\n                    CmsPropertyDefinition.PROPERTY_TEMPLATE,\n                    getTemplate(),\n                    getTemplate());\n                cms.writePropertyObject(siteRoot, prop);\n            }\n            OpenCms.getPublishManager().publishResource(\n                cms,\n                siteRoot,\n                false,\n                new CmsLogReport(cms.getRequestContext().getLocale(), getClass()));\n\n            // create OU\n            if (m_createou) {\n                OpenCms.getOrgUnitManager().createOrganizationalUnit(\n                    cms,\n                    \"/\" + siteRootResource.getName(),\n                    m_ouDescription.replace(\"%(site)\", m_site.getTitle() + \" [\" + m_site.getSiteRoot() + \"]\"),\n                    0,\n                    siteRootResource.getRootPath());\n            }\n\n            // create sitemap configuration\n            String contentFolder = CmsStringUtil.joinPaths(sitePath, CmsADEManager.CONTENT_FOLDER_NAME + \"/\");\n            String sitemapConfig = CmsStringUtil.joinPaths(contentFolder, CmsADEManager.CONFIG_FILE_NAME);\n            if (!cms.existsResource(sitemapConfig)) {\n                CmsResource config = createSitemapContentFolder(cms, siteRootResource);\n                if (config != null) {\n                    try {\n                        CmsResource newFolder = cms.createResource(\n                            contentFolder + NEW,\n                            OpenCms.getResourceManager().getResourceType(CmsResourceTypeFolder.RESOURCE_TYPE_NAME));\n                        I_CmsResourceType containerType = OpenCms.getResourceManager().getResourceType(\n                            org.opencms.file.types.CmsResourceTypeXmlContainerPage.RESOURCE_TYPE_NAME);\n                        CmsResource modelPage = cms.createResource(newFolder.getRootPath() + BLANK_HTML, containerType);\n                        String defTitle = Messages.get().container(\n                            Messages.GUI_DEFAULT_MODEL_TITLE_1,\n                            m_site.getTitle()).getKey();\n                        String defDes = Messages.get().container(\n                            Messages.GUI_DEFAULT_MODEL_DESCRIPTION_1,\n                            m_site.getTitle()).getKey();\n                        CmsProperty prop = new CmsProperty(CmsPropertyDefinition.PROPERTY_TITLE, defTitle, defTitle);\n                        cms.writePropertyObject(modelPage.getRootPath(), prop);\n                        prop = new CmsProperty(CmsPropertyDefinition.PROPERTY_DESCRIPTION, defDes, defDes);\n                        cms.writePropertyObject(modelPage.getRootPath(), prop);\n                        CmsFile file = cms.readFile(config);\n                        CmsXmlContent con = CmsXmlContentFactory.unmarshal(cms, file);\n                        con.addValue(cms, MODEL_PAGE, Locale.ENGLISH, 0);\n                        I_CmsXmlContentValue val = con.getValue(MODEL_PAGE_PAGE, Locale.ENGLISH);\n                        val.setStringValue(cms, modelPage.getRootPath());\n                        file.setContents(con.marshal());\n                        cms.writeFile(file);\n                    } catch (CmsException e) {\n                        addCommitError(e);\n                    }\n                }\n            }\n\n            // update the site manager state\n            CmsSite newSite = m_site.toCmsSite();\n            OpenCms.getSiteManager().updateSite(getCms(), m_site.getOriginalSite(), newSite);\n            // update the workplace server if the changed site was the workplace server\n            if ((m_site.getOriginalSite() != null)\n                && m_site.getOriginalSite().getUrl().equals(OpenCms.getSiteManager().getWorkplaceServer())) {\n                OpenCms.getSiteManager().updateGeneralSettings(\n                    getCms(),\n                    OpenCms.getSiteManager().getDefaultUri(),\n                    newSite.getUrl(),\n                    OpenCms.getSiteManager().getSharedFolder());\n            }\n            // write the system configuration\n            OpenCms.writeConfiguration(CmsSystemConfiguration.class);\n            // refresh the list of sites\n            Map<?, ?> objects = (Map<?, ?>)getSettings().getListObject();\n            if (objects != null) {\n                objects.remove(CmsSitesOverviewList.class.getName());\n            }\n        } catch (Exception e) {\n            addCommitError(e);\n        }\n    }","id":102938,"modified_method":"/**\n     * @see org.opencms.workplace.CmsWidgetDialog#actionCommit()\n     */\n    @Override\n    public void actionCommit() {\n\n        try {\n\n            // validate the dialog form\n            validateDialog();\n\n            // create a root site clone of the current CMS object.\n            CmsObject cms = OpenCms.initCmsObject(getCms());\n            cms.getRequestContext().setSiteRoot(\"\");\n\n            // create the site root path\n            String siteRoot = \"/sites\".concat(m_sitename);\n            m_site.setSiteRoot(siteRoot);\n\n            CmsResource siteRootResource = null;\n            String sitePath = null;\n            // check if the site root already exists\n            try {\n                // take the existing site and do not perform any OU related actions\n                siteRootResource = cms.readResource(siteRoot);\n                sitePath = cms.getSitePath(siteRootResource);\n            } catch (@SuppressWarnings(\"unused\") CmsVfsResourceNotFoundException e) {\n                // not create a new site folder and the according OU if option is checked checked\n                I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(\n                    CmsResourceTypeFolderSubSitemap.TYPE_SUBSITEMAP);\n                siteRootResource = cms.createResource(siteRoot, type);\n                sitePath = cms.getSitePath(siteRootResource);\n            }\n\n            // add template  property\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(getTemplate())) {\n                CmsProperty prop = new CmsProperty(\n                    CmsPropertyDefinition.PROPERTY_TEMPLATE,\n                    getTemplate(),\n                    getTemplate());\n                cms.writePropertyObject(siteRoot, prop);\n            }\n            OpenCms.getPublishManager().publishResource(\n                cms,\n                siteRoot,\n                false,\n                new CmsLogReport(cms.getRequestContext().getLocale(), getClass()));\n\n            // create OU\n            if (m_createou) {\n                OpenCms.getOrgUnitManager().createOrganizationalUnit(\n                    cms,\n                    \"/\" + siteRootResource.getName(),\n                    m_ouDescription.replace(\"%(site)\", m_site.getTitle() + \" [\" + m_site.getSiteRoot() + \"]\"),\n                    0,\n                    siteRootResource.getRootPath());\n            }\n\n            // create sitemap configuration\n            String contentFolder = CmsStringUtil.joinPaths(sitePath, CmsADEManager.CONTENT_FOLDER_NAME + \"/\");\n            String sitemapConfig = CmsStringUtil.joinPaths(contentFolder, CmsADEManager.CONFIG_FILE_NAME);\n            if (!cms.existsResource(sitemapConfig)) {\n                CmsResource config = createSitemapContentFolder(cms, siteRootResource);\n                if (config != null) {\n                    try {\n                        CmsResource newFolder = cms.createResource(\n                            contentFolder + NEW,\n                            OpenCms.getResourceManager().getResourceType(CmsResourceTypeFolder.RESOURCE_TYPE_NAME));\n                        I_CmsResourceType containerType = OpenCms.getResourceManager().getResourceType(\n                            org.opencms.file.types.CmsResourceTypeXmlContainerPage.RESOURCE_TYPE_NAME);\n                        CmsResource modelPage = cms.createResource(newFolder.getRootPath() + BLANK_HTML, containerType);\n                        String defTitle = Messages.get().getBundle(getCms().getRequestContext().getLocale()).key(\n                            Messages.GUI_DEFAULT_MODEL_TITLE_1,\n                            m_site.getTitle());\n                        String defDes = Messages.get().getBundle(getCms().getRequestContext().getLocale()).key(\n                            Messages.GUI_DEFAULT_MODEL_DESCRIPTION_1,\n                            m_site.getTitle());\n                        CmsProperty prop = new CmsProperty(CmsPropertyDefinition.PROPERTY_TITLE, defTitle, defTitle);\n                        cms.writePropertyObject(modelPage.getRootPath(), prop);\n                        prop = new CmsProperty(CmsPropertyDefinition.PROPERTY_DESCRIPTION, defDes, defDes);\n                        cms.writePropertyObject(modelPage.getRootPath(), prop);\n                        CmsFile file = cms.readFile(config);\n                        CmsXmlContent con = CmsXmlContentFactory.unmarshal(cms, file);\n                        con.addValue(cms, MODEL_PAGE, Locale.ENGLISH, 0);\n                        I_CmsXmlContentValue val = con.getValue(MODEL_PAGE_PAGE, Locale.ENGLISH);\n                        val.setStringValue(cms, modelPage.getRootPath());\n                        file.setContents(con.marshal());\n                        cms.writeFile(file);\n                    } catch (CmsException e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                    }\n                }\n            }\n\n            // update the site manager state\n            CmsSite newSite = m_site.toCmsSite();\n            OpenCms.getSiteManager().updateSite(getCms(), m_site.getOriginalSite(), newSite);\n            // update the workplace server if the changed site was the workplace server\n            if ((m_site.getOriginalSite() != null)\n                && m_site.getOriginalSite().getUrl().equals(OpenCms.getSiteManager().getWorkplaceServer())) {\n                OpenCms.getSiteManager().updateGeneralSettings(\n                    getCms(),\n                    OpenCms.getSiteManager().getDefaultUri(),\n                    newSite.getUrl(),\n                    OpenCms.getSiteManager().getSharedFolder());\n            }\n            // write the system configuration\n            OpenCms.writeConfiguration(CmsSystemConfiguration.class);\n            // refresh the list of sites\n            Map<?, ?> objects = (Map<?, ?>)getSettings().getListObject();\n            if (objects != null) {\n                objects.remove(CmsSitesOverviewList.class.getName());\n            }\n        } catch (Exception e) {\n            addCommitError(e);\n        }\n    }","commit_id":"b0902769557823d71203b0fb106c95e7a83c835a","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Helper method for creating the .content folder of a sub-sitemap.<p>\n     *\n     * @param cms the current CMS context\n     * @param subSitemapFolder the sub-sitemap folder in which the .content folder should be created\n     *\n     * @return the created folder\n     *\n     * @throws CmsException if something goes wrong\n     * @throws CmsLoaderException if something goes wrong\n     */\n    private CmsResource createSitemapContentFolder(CmsObject cms, CmsResource subSitemapFolder)\n    throws CmsException, CmsLoaderException {\n\n        CmsResource configFile = null;\n        String sitePath = cms.getSitePath(subSitemapFolder);\n        String folderName = CmsStringUtil.joinPaths(sitePath, CmsADEManager.CONTENT_FOLDER_NAME + \"/\");\n        String sitemapConfigName = CmsStringUtil.joinPaths(folderName, CmsADEManager.CONFIG_FILE_NAME);\n        if (!cms.existsResource(folderName)) {\n            cms.createResource(\n                folderName,\n                OpenCms.getResourceManager().getResourceType(CmsADEManager.CONFIG_FOLDER_TYPE));\n        }\n        I_CmsResourceType configType = OpenCms.getResourceManager().getResourceType(CmsADEManager.CONFIG_TYPE);\n        if (cms.existsResource(sitemapConfigName)) {\n            configFile = cms.readResource(sitemapConfigName);\n            if (OpenCms.getResourceManager().getResourceType(configFile).getTypeName().equals(\n                configType.getTypeName())) {\n                throw new CmsException(\n                    Messages.get().container(\n                        Messages.ERR_CREATING_SUB_SITEMAP_WRONG_CONFIG_FILE_TYPE_2,\n                        sitemapConfigName,\n                        CmsADEManager.CONFIG_TYPE));\n            }\n        } else {\n            configFile = cms.createResource(\n                sitemapConfigName,\n                OpenCms.getResourceManager().getResourceType(CmsADEManager.CONFIG_TYPE));\n        }\n        return configFile;\n    }","id":102939,"modified_method":"/**\n     * Helper method for creating the .content folder of a sub-sitemap.<p>\n     *\n     * @param cms the current CMS context\n     * @param subSitemapFolder the sub-sitemap folder in which the .content folder should be created\n     *\n     * @return the created folder\n     *\n     * @throws CmsException if something goes wrong\n     * @throws CmsLoaderException if something goes wrong\n     */\n    private CmsResource createSitemapContentFolder(CmsObject cms, CmsResource subSitemapFolder)\n    throws CmsException, CmsLoaderException {\n\n        CmsResource configFile = null;\n        String sitePath = cms.getSitePath(subSitemapFolder);\n        String folderName = CmsStringUtil.joinPaths(sitePath, CmsADEManager.CONTENT_FOLDER_NAME + \"/\");\n        String sitemapConfigName = CmsStringUtil.joinPaths(folderName, CmsADEManager.CONFIG_FILE_NAME);\n        if (!cms.existsResource(folderName)) {\n            cms.createResource(\n                folderName,\n                OpenCms.getResourceManager().getResourceType(CmsADEManager.CONFIG_FOLDER_TYPE));\n        }\n        I_CmsResourceType configType = OpenCms.getResourceManager().getResourceType(CmsADEManager.CONFIG_TYPE);\n        if (cms.existsResource(sitemapConfigName)) {\n            configFile = cms.readResource(sitemapConfigName);\n            if (!OpenCms.getResourceManager().getResourceType(configFile).getTypeName().equals(\n                configType.getTypeName())) {\n                throw new CmsException(\n                    Messages.get().container(\n                        Messages.ERR_CREATING_SUB_SITEMAP_WRONG_CONFIG_FILE_TYPE_2,\n                        sitemapConfigName,\n                        CmsADEManager.CONFIG_TYPE));\n            }\n        } else {\n            configFile = cms.createResource(\n                sitemapConfigName,\n                OpenCms.getResourceManager().getResourceType(CmsADEManager.CONFIG_TYPE));\n        }\n        return configFile;\n    }","commit_id":"b0902769557823d71203b0fb106c95e7a83c835a","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see org.opencms.workplace.CmsWidgetDialog#defineWidgets()\r\n     */\r\n    @Override\r\n    protected void defineWidgets() {\r\n\r\n        initSite();\r\n        setKeyPrefix(CmsSitesOverviewList.KEY_PREFIX_SITES);\r\n\r\n        if (DIALOG_NEW.equals(getParamEditaction()) || DIALOG_EDIT.equals(getParamEditaction())) {\r\n            // edit or new\r\n            // site info\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"title\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(this, \"sitename\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"server\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"errorPage\", PAGES[0], new CmsVfsFileWidget(\r\n                true,\r\n                \"\",\r\n                true,\r\n                false)));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"position\", PAGES[0], new CmsSelectWidget(\r\n                createNavOpts(m_site))));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"webserver\", PAGES[0], new CmsCheckboxWidget()));\r\n            if (DIALOG_NEW.equals(getParamEditaction())) {\r\n                addWidget(new CmsWidgetDialogParameter(this, \"createou\", PAGES[0], new CmsCheckboxWidget()));\r\n                addWidget(new CmsWidgetDialogParameter(this, \"template\", PAGES[0], new CmsVfsFileWidget(\r\n                    true,\r\n                    \"\",\r\n                    true,\r\n                    false)));\r\n            }\r\n\r\n            if (m_site.getFavicon() != null) {\r\n                try {\r\n                    CmsObject clone = OpenCms.initCmsObject(getCms());\r\n                    clone.getRequestContext().setSiteRoot(\"\");\r\n\r\n                    CmsDisplayWidget dis = new CmsDisplayWidget(\"<img src='\"\r\n                        + OpenCms.getLinkManager().getOnlineLink(clone, m_site.getFavicon())\r\n                        + \"' border='0' width='16' height='16' />\");\r\n                    addWidget(new CmsWidgetDialogParameter(m_site, \"favicon\", PAGES[0], dis));\r\n                } catch (Exception e) {\r\n                    // noop\r\n                }\r\n            }\r\n\r\n            // secure site\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"secureUrl\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveUrl\", PAGES[0], new CmsCheckboxWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveError\", PAGES[0], new CmsCheckboxWidget()));\r\n\r\n            // site aliases\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"aliases\", PAGES[0], new CmsInputWidget()));\r\n        } else {\r\n            // display site\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"title\", PAGES[0], new CmsDisplayWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"siteRoot\", PAGES[0], new CmsDisplayWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"server\", PAGES[0], new CmsDisplayWidget()));\r\n            CmsWidgetDialogParameter errorPage;\r\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_site.getErrorPage())) {\r\n                errorPage = new CmsWidgetDialogParameter(m_site, \"errorPage\", PAGES[0], new CmsDisplayWidget(\r\n                    Messages.get().container(Messages.GUI_SITES_ERROR_PAGE_NOT_AVAILABLE_0).key()));\r\n            } else {\r\n                errorPage = new CmsWidgetDialogParameter(m_site, \"errorPage\", PAGES[0], new CmsDisplayWidget());\r\n            }\r\n            addWidget(errorPage);\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"webserver\", PAGES[0], new CmsDisplayWidget()));\r\n\r\n            if (m_site.getFavicon() != null) {\r\n                try {\r\n                    CmsObject clone = OpenCms.initCmsObject(getCms());\r\n                    clone.getRequestContext().setSiteRoot(\"\");\r\n\r\n                    CmsDisplayWidget dis = new CmsDisplayWidget(\"<img src='\"\r\n                        + OpenCms.getLinkManager().getOnlineLink(clone, m_site.getFavicon())\r\n                        + \"' border='0' width='16' height='16' />\");\r\n                    addWidget(new CmsWidgetDialogParameter(m_site, \"favicon\", PAGES[0], dis));\r\n                } catch (Exception e) {\r\n                    // noop\r\n                }\r\n            }\r\n\r\n            if (m_site.hasSecureServer()) {\r\n                addWidget(new CmsWidgetDialogParameter(m_site, \"secureUrl\", PAGES[0], new CmsDisplayWidget()));\r\n                addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveUrl\", PAGES[0], new CmsDisplayWidget()));\r\n                addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveError\", PAGES[0], new CmsDisplayWidget()));\r\n            }\r\n            int count = 0;\r\n            for (String aliasUrl : m_site.getAliases()) {\r\n                CmsWidgetDialogParameter alias = new CmsWidgetDialogParameter(\r\n                    aliasUrl,\r\n                    aliasUrl,\r\n                    Messages.get().getBundle(getCms().getRequestContext().getLocale()).key(\r\n                        Messages.GUI_SITES_DETAIL_LABEL_ALIAS_0)\r\n                        + \" [\"\r\n                        + (count + 1)\r\n                        + \"]\",\r\n                    new CmsDisplayWidget(),\r\n                    PAGES[0],\r\n                    1,\r\n                    1,\r\n                    count);\r\n                addWidget(alias);\r\n                count++;\r\n            }\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"aliases\", PAGES[0], new CmsDisplayWidget()));\r\n        }\r\n    }","id":102940,"modified_method":"/**\r\n     * @see org.opencms.workplace.CmsWidgetDialog#defineWidgets()\r\n     */\r\n    @Override\r\n    protected void defineWidgets() {\r\n\r\n        initSite();\r\n        setKeyPrefix(CmsSitesOverviewList.KEY_PREFIX_SITES);\r\n\r\n        if (DIALOG_NEW.equals(getParamEditaction()) || DIALOG_EDIT.equals(getParamEditaction())) {\r\n            // edit or new\r\n            // site info\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"title\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(this, \"sitename\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"server\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"errorPage\", PAGES[0], new CmsVfsFileWidget(\r\n                true,\r\n                \"\",\r\n                true,\r\n                false)));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"position\", PAGES[0], new CmsSelectWidget(\r\n                createNavOpts(m_site))));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"webserver\", PAGES[0], new CmsCheckboxWidget()));\r\n            if (DIALOG_NEW.equals(getParamEditaction())) {\r\n                addWidget(new CmsWidgetDialogParameter(this, \"createou\", PAGES[0], new CmsCheckboxWidget()));\r\n                addWidget(new CmsWidgetDialogParameter(this, \"template\", PAGES[0], new CmsVfsFileWidget(\r\n                    true,\r\n                    \"\",\r\n                    true,\r\n                    false)));\r\n            }\r\n\r\n            if (m_site.getFavicon() != null) {\r\n                try {\r\n                    CmsObject clone = OpenCms.initCmsObject(getCms());\r\n                    clone.getRequestContext().setSiteRoot(\"\");\r\n\r\n                    CmsDisplayWidget dis = new CmsDisplayWidget(\"<img src='\"\r\n                        + OpenCms.getLinkManager().getOnlineLink(clone, m_site.getFavicon())\r\n                        + \"' border='0' width='16' height='16' />\");\r\n                    addWidget(new CmsWidgetDialogParameter(m_site, \"favicon\", PAGES[0], dis));\r\n                } catch (Exception e) {\r\n                    // noop\r\n                }\r\n            }\r\n\r\n            // secure site\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"secureUrl\", PAGES[0], new CmsInputWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveUrl\", PAGES[0], new CmsCheckboxWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveError\", PAGES[0], new CmsCheckboxWidget()));\r\n\r\n            // site aliases\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"aliases\", PAGES[0], new CmsInputWidget()));\r\n        } else {\r\n            // display site\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"title\", PAGES[0], new CmsDisplayWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"siteRoot\", PAGES[0], new CmsDisplayWidget()));\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"server\", PAGES[0], new CmsDisplayWidget()));\r\n            CmsWidgetDialogParameter errorPage;\r\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_site.getErrorPage())) {\r\n                errorPage = new CmsWidgetDialogParameter(m_site, \"errorPage\", PAGES[0], new CmsDisplayWidget(\r\n                    Messages.get().getBundle(getCms().getRequestContext().getLocale()).key(\r\n                        Messages.GUI_SITES_ERROR_PAGE_NOT_AVAILABLE_0)));\r\n            } else {\r\n                errorPage = new CmsWidgetDialogParameter(m_site, \"errorPage\", PAGES[0], new CmsDisplayWidget());\r\n            }\r\n            addWidget(errorPage);\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"webserver\", PAGES[0], new CmsDisplayWidget()));\r\n\r\n            if (m_site.getFavicon() != null) {\r\n                try {\r\n                    CmsObject clone = OpenCms.initCmsObject(getCms());\r\n                    clone.getRequestContext().setSiteRoot(\"\");\r\n\r\n                    CmsDisplayWidget dis = new CmsDisplayWidget(\"<img src='\"\r\n                        + OpenCms.getLinkManager().getOnlineLink(clone, m_site.getFavicon())\r\n                        + \"' border='0' width='16' height='16' />\");\r\n                    addWidget(new CmsWidgetDialogParameter(m_site, \"favicon\", PAGES[0], dis));\r\n                } catch (Exception e) {\r\n                    // noop\r\n                }\r\n            }\r\n\r\n            if (m_site.hasSecureServer()) {\r\n                addWidget(new CmsWidgetDialogParameter(m_site, \"secureUrl\", PAGES[0], new CmsDisplayWidget()));\r\n                addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveUrl\", PAGES[0], new CmsDisplayWidget()));\r\n                addWidget(new CmsWidgetDialogParameter(m_site, \"exclusiveError\", PAGES[0], new CmsDisplayWidget()));\r\n            }\r\n            int count = 0;\r\n            for (String aliasUrl : m_site.getAliases()) {\r\n                CmsWidgetDialogParameter alias = new CmsWidgetDialogParameter(\r\n                    aliasUrl,\r\n                    aliasUrl,\r\n                    Messages.get().getBundle(getCms().getRequestContext().getLocale()).key(\r\n                        Messages.GUI_SITES_DETAIL_LABEL_ALIAS_0)\r\n                        + \" [\"\r\n                        + (count + 1)\r\n                        + \"]\",\r\n                    new CmsDisplayWidget(),\r\n                    PAGES[0],\r\n                    1,\r\n                    1,\r\n                    count);\r\n                addWidget(alias);\r\n                count++;\r\n            }\r\n            addWidget(new CmsWidgetDialogParameter(m_site, \"aliases\", PAGES[0], new CmsDisplayWidget()));\r\n        }\r\n    }","commit_id":"31deb7b2f6bd868d7bc2cf14bd3087d240710515","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void doProcessResult(Exchange exchange, Object result, SqlSession session) {\n        if (endpoint.getStatementType() == StatementType.SelectList || endpoint.getStatementType() == StatementType.SelectOne) {\n            Message answer = exchange.getIn();\n            if (ExchangeHelper.isOutCapable(exchange)) {\n                answer = exchange.getOut();\n                // preserve headers\n                answer.getHeaders().putAll(exchange.getIn().getHeaders());\n            }\n\n            // we should not set the body if its a stored procedure as the result is already in its OUT parameter\n            MappedStatement ms = session.getConfiguration().getMappedStatement(statement);\n            final String outputHeader = getEndpoint().getOutputHeader();\n            if (ms != null && ms.getStatementType() == org.apache.ibatis.mapping.StatementType.CALLABLE) {\n                if (result == null) {\n                    LOG.trace(\"Setting result as existing body as MyBatis statement type is Callable, and there was no result.\");\n                    answer.setBody(exchange.getIn().getBody());\n                } else {\n                \tif(outputHeader != null) {\n                \t\t// set the result as header for insert\n    \t                LOG.trace(\"Setting result as header [{}]: {}\", outputHeader, result);\n                \t\tanswer.setHeader(outputHeader, result);\n                \t} else {\n\t                    // set the result as body for insert\n\t                    LOG.trace(\"Setting result as body: {}\", result);\n\t                    answer.setBody(result);\n\t                    answer.setHeader(MyBatisConstants.MYBATIS_RESULT, result);\n                \t}\n                }\n            } else {\n            \tif(outputHeader != null) {\n\t                LOG.trace(\"Setting result as header [{}]: {}\", outputHeader, result);\n            \t\tanswer.setHeader(outputHeader, result);\n            \t} else {\n\t            \t// set the result as body for insert\n\t                LOG.trace(\"Setting result as body: {}\", result);\n\t                answer.setBody(result);\n\t                answer.setHeader(MyBatisConstants.MYBATIS_RESULT, result);\n            \t}\n            }\n\n            answer.setHeader(MyBatisConstants.MYBATIS_STATEMENT_NAME, statement);\n        } else {\n            Message msg = exchange.getIn();\n            msg.setHeader(MyBatisConstants.MYBATIS_RESULT, result);\n            msg.setHeader(MyBatisConstants.MYBATIS_STATEMENT_NAME, statement);\n        }\n    }","id":102941,"modified_method":"private void doProcessResult(Exchange exchange, Object result, SqlSession session) {\n        final String outputHeader = getEndpoint().getOutputHeader();\n    \tif (endpoint.getStatementType() == StatementType.SelectList || endpoint.getStatementType() == StatementType.SelectOne) {\n            Message answer = exchange.getIn();\n            if (ExchangeHelper.isOutCapable(exchange)) {\n                answer = exchange.getOut();\n                // preserve headers\n                answer.getHeaders().putAll(exchange.getIn().getHeaders());\n            }\n\n            // we should not set the body if its a stored procedure as the result is already in its OUT parameter\n            MappedStatement ms = session.getConfiguration().getMappedStatement(statement);\n            if (ms != null && ms.getStatementType() == org.apache.ibatis.mapping.StatementType.CALLABLE) {\n                if (result == null) {\n                    LOG.trace(\"Setting result as existing body as MyBatis statement type is Callable, and there was no result.\");\n                    answer.setBody(exchange.getIn().getBody());\n                } else {\n                \tif(outputHeader != null) {\n                \t\t// set the result as header for insert\n    \t                LOG.trace(\"Setting result as header [{}]: {}\", outputHeader, result);\n                \t\tanswer.setHeader(outputHeader, result);\n                \t} else {\n\t                    // set the result as body for insert\n\t                    LOG.trace(\"Setting result as body: {}\", result);\n\t                    answer.setBody(result);\n\t                    answer.setHeader(MyBatisConstants.MYBATIS_RESULT, result);\n                \t}\n                }\n            } else {\n            \tif(outputHeader != null) {\n\t                LOG.trace(\"Setting result as header [{}]: {}\", outputHeader, result);\n            \t\tanswer.setHeader(outputHeader, result);\n            \t} else {\n\t            \t// set the result as body for insert\n\t                LOG.trace(\"Setting result as body: {}\", result);\n\t                answer.setBody(result);\n\t                answer.setHeader(MyBatisConstants.MYBATIS_RESULT, result);\n            \t}\n            }\n\n            answer.setHeader(MyBatisConstants.MYBATIS_STATEMENT_NAME, statement);\n        } else {\n            Message msg = exchange.getIn();\n            if(outputHeader != null) {\n            \tmsg.setHeader(outputHeader, result);\n            } else {\n                msg.setHeader(MyBatisConstants.MYBATIS_RESULT, result);\n            }\n            msg.setHeader(MyBatisConstants.MYBATIS_STATEMENT_NAME, statement);\n        }\n    }","commit_id":"2c4c06c1e3712e2cd4a4b7e10c0b649db5a94886","url":"https://github.com/apache/camel"},{"original_method":"private Exchange createExchange(Object data) {\n        final MyBatisEndpoint endpoint = getEndpoint();\n        final Exchange exchange = endpoint.createExchange(ExchangePattern.InOnly);\n\n        Message msg = exchange.getIn();\n        msg.setBody(data);\n        msg.setHeader(MyBatisConstants.MYBATIS_STATEMENT_NAME, endpoint.getStatement());\n\n        return exchange;\n    }","id":102942,"modified_method":"private Exchange createExchange(Object data) {\n        final MyBatisEndpoint endpoint = getEndpoint();\n        final Exchange exchange = endpoint.createExchange(ExchangePattern.InOnly);\n        final String outputHeader = getEndpoint().getOutputHeader();\n\n        Message msg = exchange.getIn();\n        if(outputHeader != null) {\n        \tmsg.setHeader(outputHeader, data);\n        } else {\n        \tmsg.setBody(data);\n        }\n        msg.setHeader(MyBatisConstants.MYBATIS_STATEMENT_NAME, endpoint.getStatement());\n\n        return exchange;\n    }","commit_id":"c88effa908591f824c989a43e625178744bf12eb","url":"https://github.com/apache/camel"},{"original_method":"private void doProcessResult(Exchange exchange, Object result, SqlSession session) {\n        if (endpoint.getStatementType() == StatementType.SelectList || endpoint.getStatementType() == StatementType.SelectOne) {\n            Message answer = exchange.getIn();\n            if (ExchangeHelper.isOutCapable(exchange)) {\n                answer = exchange.getOut();\n                // preserve headers\n                answer.getHeaders().putAll(exchange.getIn().getHeaders());\n            }\n\n            // we should not set the body if its a stored procedure as the result is already in its OUT parameter\n            MappedStatement ms = session.getConfiguration().getMappedStatement(statement);\n            if (ms != null && ms.getStatementType() == org.apache.ibatis.mapping.StatementType.CALLABLE) {\n                if (result == null) {\n                    LOG.trace(\"Setting result as existing body as MyBatis statement type is Callable, and there was no result.\");\n                    answer.setBody(exchange.getIn().getBody());\n                } else {\n                    // set the result as body for insert\n                    LOG.trace(\"Setting result as body: {}\", result);\n                    answer.setBody(result);\n                }\n            } else {\n                // set the result as body for insert\n                LOG.trace(\"Setting result as body: {}\", result);\n                answer.setBody(result);\n            }\n\n            answer.setHeader(MyBatisConstants.MYBATIS_RESULT, result);\n            answer.setHeader(MyBatisConstants.MYBATIS_STATEMENT_NAME, statement);\n        } else {\n            Message msg = exchange.getIn();\n            msg.setHeader(MyBatisConstants.MYBATIS_RESULT, result);\n            msg.setHeader(MyBatisConstants.MYBATIS_STATEMENT_NAME, statement);\n        }\n    }","id":102943,"modified_method":"private void doProcessResult(Exchange exchange, Object result, SqlSession session) {\n        if (endpoint.getStatementType() == StatementType.SelectList || endpoint.getStatementType() == StatementType.SelectOne) {\n            Message answer = exchange.getIn();\n            if (ExchangeHelper.isOutCapable(exchange)) {\n                answer = exchange.getOut();\n                // preserve headers\n                answer.getHeaders().putAll(exchange.getIn().getHeaders());\n            }\n\n            // we should not set the body if its a stored procedure as the result is already in its OUT parameter\n            MappedStatement ms = session.getConfiguration().getMappedStatement(statement);\n            final String outputHeader = getEndpoint().getOutputHeader();\n            if (ms != null && ms.getStatementType() == org.apache.ibatis.mapping.StatementType.CALLABLE) {\n                if (result == null) {\n                    LOG.trace(\"Setting result as existing body as MyBatis statement type is Callable, and there was no result.\");\n                    answer.setBody(exchange.getIn().getBody());\n                } else {\n                \tif(outputHeader != null) {\n                \t\t// set the result as header for insert\n    \t                LOG.trace(\"Setting result as header [{}]: {}\", outputHeader, result);\n                \t\tanswer.setHeader(outputHeader, result);\n                \t} else {\n\t                    // set the result as body for insert\n\t                    LOG.trace(\"Setting result as body: {}\", result);\n\t                    answer.setBody(result);\n\t                    answer.setHeader(MyBatisConstants.MYBATIS_RESULT, result);\n                \t}\n                }\n            } else {\n            \tif(outputHeader != null) {\n\t                LOG.trace(\"Setting result as header [{}]: {}\", outputHeader, result);\n            \t\tanswer.setHeader(outputHeader, result);\n            \t} else {\n\t            \t// set the result as body for insert\n\t                LOG.trace(\"Setting result as body: {}\", result);\n\t                answer.setBody(result);\n\t                answer.setHeader(MyBatisConstants.MYBATIS_RESULT, result);\n            \t}\n            }\n\n            answer.setHeader(MyBatisConstants.MYBATIS_STATEMENT_NAME, statement);\n        } else {\n            Message msg = exchange.getIn();\n            msg.setHeader(MyBatisConstants.MYBATIS_RESULT, result);\n            msg.setHeader(MyBatisConstants.MYBATIS_STATEMENT_NAME, statement);\n        }\n    }","commit_id":"c88effa908591f824c989a43e625178744bf12eb","url":"https://github.com/apache/camel"},{"original_method":"public WOActionResults keepAliveAction() {\n            WOResponse response = WOApplication.application().createResponseInContext(context());\n            // we give over the session id as we also need to touch the session anyway\n            response.setHeader(ERXSession.DONT_STORE_PAGE, session().sessionID());\n\t\t    return response;\n\t\t}","id":102944,"modified_method":"public WOActionResults keepAliveAction() {\n\t\t\tWOApplication application = WOApplication.application();\n\t\t\tWOContext context = context();\n\t\t\tWOResponse response = application.createResponseInContext(context);\n\t\t\tString sessionID = context.request().stringFormValueForKey(\"erxsid\");\n\t\t\tif (!application.isRefusingNewSessions()) {\n\t\t\t\tWOSession session = application.restoreSessionWithID(sessionID, context);\n\t\t\t\tif (session != null) {\n\t\t\t\t\tlog.debug(\"Pinging \" + sessionID);\n\t\t\t\t\t// CHECKME TH do we still need that?\n\t\t\t\t\t// we give over the session id as we also need to touch the session anyway\n\t\t\t\t\tresponse.setHeader(ERXSession.DONT_STORE_PAGE, sessionID);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug(\"Couldn't ping \" + sessionID);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog.debug(\"Application is refusing new sessions. Not pinging \" + sessionID);\n\t\t\t}\n\t\t\treturn response;\n\t\t}","commit_id":"286a9cd7c4e44aecf0d1465b4106559e0ec0c45b","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * @return the nearest way segment to the screen point given that is not\n     * in ignore.\n     *\n     * @param p the point for which to search the nearest segment.\n     * @param ignore a collection of segments which are not to be returned.\n     * May be null.\n     */\n    public final WaySegment getNearestWaySegment(Point p, Collection<WaySegment> ignore) {\n        List<WaySegment> nearest = getNearestWaySegments(p);\n        if (ignore != null) {\n            nearest.removeAll(ignore);\n        }\n        return nearest.isEmpty() ? null : nearest.get(0);\n    }","id":102945,"modified_method":"/**\n     * @return the nearest way segment to the screen point given that is not\n     * in ignore.\n     *\n     * @param p the point for which to search the nearest segment.\n     * @param ignore a collection of segments which are not to be returned.\n     * May be null.\n     */\n    public final WaySegment getNearestWaySegment(Point p, Collection<WaySegment> ignore) {\n        List<WaySegment> nearest = getNearestWaySegments(p);\n        if(nearest == null)\n            return null;\n        if (ignore != null) {\n            nearest.removeAll(ignore);\n        }\n        return nearest.isEmpty() ? null : nearest.get(0);\n    }","commit_id":"689e7780fc04d3ab05aab0e387c86111ff751f81","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Return the nearest point to the screen point given.\n     * If a node within snapDistance pixel is found, the nearest node is returned.\n     */\n    public final Node getNearestNode(Point p) {\n        double minDistanceSq = snapDistance;\n        Node minPrimitive = null;\n        for (Node n : getCurrentDataSet().nodes) {\n            if (n.deleted || n.incomplete) {\n                continue;\n            }\n            Point sp = getPoint(n);\n            double dist = p.distanceSq(sp);\n            if (dist < minDistanceSq) {\n                minDistanceSq = dist;\n                minPrimitive = n;\n            }\n            // when multiple nodes on one point, prefer new or selected nodes\n            else if(dist == minDistanceSq && minPrimitive != null\n                    && ((n.id == 0 && n.isSelected())\n                            || (!minPrimitive.isSelected() && (n.isSelected() || n.id == 0)))) {\n                minPrimitive = n;\n            }\n        }\n        return minPrimitive;\n    }","id":102946,"modified_method":"/**\n     * Return the nearest point to the screen point given.\n     * If a node within snapDistance pixel is found, the nearest node is returned.\n     */\n    public final Node getNearestNode(Point p) {\n        double minDistanceSq = snapDistance;\n        Node minPrimitive = null;\n        DataSet ds = getCurrentDataSet();\n        if(ds == null)\n            return null;\n        for (Node n : ds.nodes) {\n            if (n.deleted || n.incomplete) {\n                continue;\n            }\n            Point sp = getPoint(n);\n            double dist = p.distanceSq(sp);\n            if (dist < minDistanceSq) {\n                minDistanceSq = dist;\n                minPrimitive = n;\n            }\n            // when multiple nodes on one point, prefer new or selected nodes\n            else if(dist == minDistanceSq && minPrimitive != null\n                    && ((n.id == 0 && n.isSelected())\n                            || (!minPrimitive.isSelected() && (n.isSelected() || n.id == 0)))) {\n                minPrimitive = n;\n            }\n        }\n        return minPrimitive;\n    }","commit_id":"689e7780fc04d3ab05aab0e387c86111ff751f81","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * @return A list of all nodes that are nearest to\n     * the mouse.  Does a simple sequential scan on all the data.\n     *\n     * @return A collection of all nodes or <code>null<\/code>\n     *      if no node under or near the point. The returned\n     *      list is never empty.\n     */\n    public Collection<Node> getNearestNodes(Point p) {\n        Collection<Node> nearest = new HashSet<Node>();\n        for (Node n : getCurrentDataSet().nodes) {\n            if (!n.deleted && !n.incomplete\n                    && getPoint(n).distanceSq(p) < snapDistance) {\n                nearest.add(n);\n            }\n        }\n        return nearest.isEmpty() ? null : nearest;\n    }","id":102947,"modified_method":"/**\n     * @return A list of all nodes that are nearest to\n     * the mouse.  Does a simple sequential scan on all the data.\n     *\n     * @return A collection of all nodes or <code>null<\/code>\n     *      if no node under or near the point. The returned\n     *      list is never empty.\n     */\n    public Collection<Node> getNearestNodes(Point p) {\n        Collection<Node> nearest = new HashSet<Node>();\n        DataSet ds = getCurrentDataSet();\n        if(ds == null)\n            return null;\n        for (Node n : ds.nodes) {\n            if (!n.deleted && !n.incomplete\n                    && getPoint(n).distanceSq(p) < snapDistance) {\n                nearest.add(n);\n            }\n        }\n        return nearest.isEmpty() ? null : nearest;\n    }","commit_id":"689e7780fc04d3ab05aab0e387c86111ff751f81","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * @return A list of all objects that are nearest to\n     * the mouse.  Does a simple sequential scan on all the data.\n     *\n     * @return A collection of all items or <code>null<\/code>\n     *      if no item under or near the point. The returned\n     *      list is never empty.\n     */\n    public Collection<OsmPrimitive> getAllNearest(Point p) {\n        Collection<OsmPrimitive> nearest = new HashSet<OsmPrimitive>();\n        for (Way w : getCurrentDataSet().ways) {\n            if (w.deleted || w.incomplete) {\n                continue;\n            }\n            Node lastN = null;\n            for (Node n : w.getNodes()) {\n                if (n.deleted || n.incomplete) {\n                    continue;\n                }\n                if (lastN == null) {\n                    lastN = n;\n                    continue;\n                }\n                Point A = getPoint(lastN);\n                Point B = getPoint(n);\n                double c = A.distanceSq(B);\n                double a = p.distanceSq(B);\n                double b = p.distanceSq(A);\n                double perDist = a-(a-b+c)*(a-b+c)/4/c; // perpendicular distance squared\n                if (perDist < snapDistance && a < c+snapDistance && b < c+snapDistance) {\n                    nearest.add(w);\n                    break;\n                }\n                lastN = n;\n            }\n        }\n        for (Node n : getCurrentDataSet().nodes) {\n            if (!n.deleted && !n.incomplete\n                    && getPoint(n).distanceSq(p) < snapDistance) {\n                nearest.add(n);\n            }\n        }\n        return nearest.isEmpty() ? null : nearest;\n    }","id":102948,"modified_method":"/**\n     * @return A list of all objects that are nearest to\n     * the mouse.  Does a simple sequential scan on all the data.\n     *\n     * @return A collection of all items or <code>null<\/code>\n     *      if no item under or near the point. The returned\n     *      list is never empty.\n     */\n    public Collection<OsmPrimitive> getAllNearest(Point p) {\n        Collection<OsmPrimitive> nearest = new HashSet<OsmPrimitive>();\n        DataSet ds = getCurrentDataSet();\n        if(ds == null)\n            return null;\n        for (Way w : ds.ways) {\n            if (w.deleted || w.incomplete) {\n                continue;\n            }\n            Node lastN = null;\n            for (Node n : w.getNodes()) {\n                if (n.deleted || n.incomplete) {\n                    continue;\n                }\n                if (lastN == null) {\n                    lastN = n;\n                    continue;\n                }\n                Point A = getPoint(lastN);\n                Point B = getPoint(n);\n                double c = A.distanceSq(B);\n                double a = p.distanceSq(B);\n                double b = p.distanceSq(A);\n                double perDist = a-(a-b+c)*(a-b+c)/4/c; // perpendicular distance squared\n                if (perDist < snapDistance && a < c+snapDistance && b < c+snapDistance) {\n                    nearest.add(w);\n                    break;\n                }\n                lastN = n;\n            }\n        }\n        for (Node n : ds.nodes) {\n            if (!n.deleted && !n.incomplete\n                    && getPoint(n).distanceSq(p) < snapDistance) {\n                nearest.add(n);\n            }\n        }\n        return nearest.isEmpty() ? null : nearest;\n    }","commit_id":"689e7780fc04d3ab05aab0e387c86111ff751f81","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * @return all way segments within 10px of p, sorted by their\n     * perpendicular distance.\n     *\n     * @param p the point for which to search the nearest segment.\n     */\n    public final List<WaySegment> getNearestWaySegments(Point p) {\n        TreeMap<Double, List<WaySegment>> nearest = new TreeMap<Double, List<WaySegment>>();\n        for (Way w : getCurrentDataSet().ways) {\n            if (w.deleted || w.incomplete) {\n                continue;\n            }\n            Node lastN = null;\n            int i = -2;\n            for (Node n : w.getNodes()) {\n                i++;\n                if (n.deleted || n.incomplete) {\n                    continue;\n                }\n                if (lastN == null) {\n                    lastN = n;\n                    continue;\n                }\n\n                Point A = getPoint(lastN);\n                Point B = getPoint(n);\n                double c = A.distanceSq(B);\n                double a = p.distanceSq(B);\n                double b = p.distanceSq(A);\n                double perDist = a-(a-b+c)*(a-b+c)/4/c; // perpendicular distance squared\n                if (perDist < snapDistance && a < c+snapDistance && b < c+snapDistance) {\n                    if(w.isSelected()) {\n                        perDist -= 0.00001;\n                    }\n                    List<WaySegment> l;\n                    if (nearest.containsKey(perDist)) {\n                        l = nearest.get(perDist);\n                    } else {\n                        l = new LinkedList<WaySegment>();\n                        nearest.put(perDist, l);\n                    }\n                    l.add(new WaySegment(w, i));\n                }\n\n                lastN = n;\n            }\n        }\n        ArrayList<WaySegment> nearestList = new ArrayList<WaySegment>();\n        for (List<WaySegment> wss : nearest.values()) {\n            nearestList.addAll(wss);\n        }\n        return nearestList;\n    }","id":102949,"modified_method":"/**\n     * @return all way segments within 10px of p, sorted by their\n     * perpendicular distance.\n     *\n     * @param p the point for which to search the nearest segment.\n     */\n    public final List<WaySegment> getNearestWaySegments(Point p) {\n        TreeMap<Double, List<WaySegment>> nearest = new TreeMap<Double, List<WaySegment>>();\n        DataSet ds = getCurrentDataSet();\n        if(ds == null)\n            return null;\n        for (Way w : ds.ways) {\n            if (w.deleted || w.incomplete) {\n                continue;\n            }\n            Node lastN = null;\n            int i = -2;\n            for (Node n : w.getNodes()) {\n                i++;\n                if (n.deleted || n.incomplete) {\n                    continue;\n                }\n                if (lastN == null) {\n                    lastN = n;\n                    continue;\n                }\n\n                Point A = getPoint(lastN);\n                Point B = getPoint(n);\n                double c = A.distanceSq(B);\n                double a = p.distanceSq(B);\n                double b = p.distanceSq(A);\n                double perDist = a-(a-b+c)*(a-b+c)/4/c; // perpendicular distance squared\n                if (perDist < snapDistance && a < c+snapDistance && b < c+snapDistance) {\n                    if(w.isSelected()) {\n                        perDist -= 0.00001;\n                    }\n                    List<WaySegment> l;\n                    if (nearest.containsKey(perDist)) {\n                        l = nearest.get(perDist);\n                    } else {\n                        l = new LinkedList<WaySegment>();\n                        nearest.put(perDist, l);\n                    }\n                    l.add(new WaySegment(w, i));\n                }\n\n                lastN = n;\n            }\n        }\n        ArrayList<WaySegment> nearestList = new ArrayList<WaySegment>();\n        for (List<WaySegment> wss : nearest.values()) {\n            nearestList.addAll(wss);\n        }\n        return nearestList;\n    }","commit_id":"689e7780fc04d3ab05aab0e387c86111ff751f81","url":"https://github.com/openstreetmap/josm"},{"original_method":"public DeleteEntityDownloadURLCommand(String path, Upload.Type type, String url) {\n        super();\n        this.path = path;\n        this.type = type;\n        this.extractUrl = url;\n    }","id":102950,"modified_method":"public DeleteEntityDownloadURLCommand(String path, Upload.Type type, String url, String parentPath) {\n        super();\n        this.path = path;\n        this.type = type;\n        this.extractUrl = url;\n        this.parentPath = parentPath;\n    }","commit_id":"5ef0c96e7008e08a763df6f6a441b46a7d2f8634","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public DeleteEntityDownloadURLAnswer handleDeleteEntityDownloadURLCommand(DeleteEntityDownloadURLCommand cmd){\n\n        //Delete the soft link. Example path = volumes/8/74eeb2c6-8ab1-4357-841f-2e9d06d1f360.vhd\n        s_logger.warn(\"handleDeleteEntityDownloadURLCommand Path:\"+cmd.getPath() + \" Type:\" +cmd.getType().toString());\n        String path = cmd.getPath();\n        Script command = new Script(\"/bin/bash\", s_logger);\n        command.add(\"-c\");\n        \n\t\t//We just need to remove the UUID.vhd\n        String extractUrl = cmd.getExtractUrl();\n        command.add(\"unlink /var/www/html/userdata/\" +extractUrl.substring(extractUrl.lastIndexOf(File.separator) + 1));\n        String result = command.execute();\n        if (result != null) {\n            String errorString = \"Error in deleting =\" + result;\n            s_logger.warn(errorString);\n            return new DeleteEntityDownloadURLAnswer(errorString, CreateEntityDownloadURLAnswer.RESULT_FAILURE);\n        }\n        \n        // If its a volume also delete the Hard link since it was created only for the purpose of download.\n        if(cmd.getType() == Upload.Type.VOLUME){\n            command = new Script(\"/bin/bash\", s_logger);\n            command.add(\"-c\");\n            command.add(\"rm -f \" + parentDir +File.separator+ path);\n            s_logger.warn(\" \" +parentDir +File.separator+ path);\n            result = command.execute();\n            if (result != null) {\n                String errorString = \"Error in linking  err=\" + result;\n                s_logger.warn(errorString);\n                return new DeleteEntityDownloadURLAnswer(errorString, CreateEntityDownloadURLAnswer.RESULT_FAILURE);\n            }\n        }\n        \n        return new DeleteEntityDownloadURLAnswer(\"\", CreateEntityDownloadURLAnswer.RESULT_SUCCESS);\n    }","id":102951,"modified_method":"@Override\n    public DeleteEntityDownloadURLAnswer handleDeleteEntityDownloadURLCommand(DeleteEntityDownloadURLCommand cmd){\n\n        //Delete the soft link. Example path = volumes/8/74eeb2c6-8ab1-4357-841f-2e9d06d1f360.vhd\n        s_logger.warn(\"handleDeleteEntityDownloadURLCommand Path:\"+cmd.getPath() + \" Type:\" +cmd.getType().toString());\n        String path = cmd.getPath();\n        Script command = new Script(\"/bin/bash\", s_logger);\n        command.add(\"-c\");\n        \n\t\t//We just need to remove the UUID.vhd\n        String extractUrl = cmd.getExtractUrl();\n        command.add(\"unlink /var/www/html/userdata/\" +extractUrl.substring(extractUrl.lastIndexOf(File.separator) + 1));\n        String result = command.execute();\n        if (result != null) {\n            String errorString = \"Error in deleting =\" + result;\n            s_logger.warn(errorString);\n            return new DeleteEntityDownloadURLAnswer(errorString, CreateEntityDownloadURLAnswer.RESULT_FAILURE);\n        }\n        \n        // If its a volume also delete the Hard link since it was created only for the purpose of download.\n        if(cmd.getType() == Upload.Type.VOLUME){\n            command = new Script(\"/bin/bash\", s_logger);\n            command.add(\"-c\");\n            command.add(\"rm -f /mnt/SecStorage/\" + cmd.getParentPath() +File.separator+ path);\n            s_logger.warn(\" \" +parentDir +File.separator+ path);\n            result = command.execute();\n            if (result != null) {\n                String errorString = \"Error in linking  err=\" + result;\n                s_logger.warn(errorString);\n                return new DeleteEntityDownloadURLAnswer(errorString, CreateEntityDownloadURLAnswer.RESULT_FAILURE);\n            }\n        }\n        \n        return new DeleteEntityDownloadURLAnswer(\"\", CreateEntityDownloadURLAnswer.RESULT_SUCCESS);\n    }","commit_id":"5ef0c96e7008e08a763df6f6a441b46a7d2f8634","url":"https://github.com/apache/cloudstack"},{"original_method":"public void cleanupStorage() {\n\n        final int EXTRACT_URL_LIFE_LIMIT_IN_SECONDS = _urlExpirationInterval;\n        List<UploadVO> extractJobs= _uploadDao.listByModeAndStatus(Mode.HTTP_DOWNLOAD, Status.DOWNLOAD_URL_CREATED);\n        \n        for (UploadVO extractJob : extractJobs){\n            if( getTimeDiff(extractJob.getLastUpdated()) > EXTRACT_URL_LIFE_LIMIT_IN_SECONDS ){                           \n                String path = extractJob.getInstallPath();\n                s_logger.debug(\"Sending deletion of extract URL \"+extractJob.getUploadUrl());\n                // Would delete the symlink for the Type and if Type == VOLUME then also the volume\n                DeleteEntityDownloadURLCommand cmd = new DeleteEntityDownloadURLCommand(path, extractJob.getType(),extractJob.getUploadUrl());\n                HostVO ssvm = _agentMgr.getSSAgent(ApiDBUtils.findHostById(extractJob.getHostId()));\n                if( ssvm == null ) {\n                \ts_logger.warn(\"There is no secondary storage VM for secondary storage host \" + extractJob.getHostId());\n                \tcontinue;\n                }\n                long result = send(ssvm.getId(), cmd, null);\n                if (result == -1){\n                    s_logger.warn(\"Unable to delete the link for \" +extractJob.getType()+ \" id=\" +extractJob.getTypeId()+ \" url=\"+extractJob.getUploadUrl());\n                }else{\n                    _uploadDao.remove(extractJob.getId());\n                }\n            }\n        }\n                \n    }","id":102952,"modified_method":"public void cleanupStorage() {\n\n        final int EXTRACT_URL_LIFE_LIMIT_IN_SECONDS = _urlExpirationInterval;\n        List<UploadVO> extractJobs= _uploadDao.listByModeAndStatus(Mode.HTTP_DOWNLOAD, Status.DOWNLOAD_URL_CREATED);\n        \n        for (UploadVO extractJob : extractJobs){\n            if( getTimeDiff(extractJob.getLastUpdated()) > EXTRACT_URL_LIFE_LIMIT_IN_SECONDS ){                           \n                String path = extractJob.getInstallPath();\n                HostVO secStorage = ApiDBUtils.findHostById(extractJob.getHostId());\n                s_logger.debug(\"Sending deletion of extract URL \"+extractJob.getUploadUrl());\n                // Would delete the symlink for the Type and if Type == VOLUME then also the volume\n                DeleteEntityDownloadURLCommand cmd = new DeleteEntityDownloadURLCommand(path, extractJob.getType(),extractJob.getUploadUrl(), secStorage.getParent());\n                HostVO ssvm = _agentMgr.getSSAgent(secStorage);\n                if( ssvm == null ) {\n                \ts_logger.warn(\"There is no secondary storage VM for secondary storage host \" + extractJob.getHostId());\n                \tcontinue;\n                }\n                long result = send(ssvm.getId(), cmd, null);\n                if (result == -1){\n                    s_logger.warn(\"Unable to delete the link for \" +extractJob.getType()+ \" id=\" +extractJob.getTypeId()+ \" url=\"+extractJob.getUploadUrl());\n                }else{\n                    _uploadDao.remove(extractJob.getId());\n                }\n            }\n        }\n                \n    }","commit_id":"5ef0c96e7008e08a763df6f6a441b46a7d2f8634","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n\tpublic UploadVO createEntityDownloadURL(VMTemplateVO template, VMTemplateHostVO vmTemplateHost, Long dataCenterId, long eventId) {\n\t    \n\t    String errorString = \"\";\n\t    boolean success = false;\n\t    List<HostVO> storageServers = _serverDao.listByTypeDataCenter(Host.Type.SecondaryStorage, dataCenterId);\n\t    if(storageServers == null || storageServers.size() == 0) {\n            throw new CloudRuntimeException(\"No Storage Server found at the datacenter - \" +dataCenterId);\n        }\n\t    \n\t    Type type = (template.getFormat() == ImageFormat.ISO) ? Type.ISO : Type.TEMPLATE ;\n\t    \n\t    List<HostVO> storageServerVMs = _serverDao.listByTypeDataCenter(Host.Type.SecondaryStorageVM, dataCenterId);\n        //Check if one ssvm is up\n        boolean no_vm_up = true;\n        HostVO use_ssvm = null;\n        for (HostVO ssvm: storageServerVMs){\n            if(ssvm.getStatus() == com.cloud.host.Status.Up){\n                no_vm_up = false;\n                use_ssvm = ssvm;\n                break;\n            }  \n        }\n        if(no_vm_up){\n            throw new CloudRuntimeException(\"Couldnt create extract link - Secondary Storage Vm is not up\");\n        }\n\t    \n\t    //Check if it already exists.\n\t    List<UploadVO> extractURLList = _uploadDao.listByTypeUploadStatus(template.getId(), type, UploadVO.Status.DOWNLOAD_URL_CREATED);\t    \n\t    if (extractURLList.size() > 0) {\n            return extractURLList.get(0);\n        }\n\t    \n\t    // It doesn't exist so create a DB entry.\t    \n\t    UploadVO uploadTemplateObj = new UploadVO(use_ssvm.getId(), template.getId(), new Date(), \n\t                                                Status.DOWNLOAD_URL_NOT_CREATED, 0, type, Mode.HTTP_DOWNLOAD); \n\t    uploadTemplateObj.setInstallPath(vmTemplateHost.getInstallPath());\t                                                \n\t    _uploadDao.persist(uploadTemplateObj);\n\t    try{\n    \t    // Create Symlink at ssvm\n\t    \tString path = vmTemplateHost.getInstallPath();\n\t    \tString uuid = UUID.randomUUID().toString() + path.substring(path.length() - 4) ; // last 4 characters of the path specify the format like .vhd\n\t    \tCreateEntityDownloadURLCommand cmd = new CreateEntityDownloadURLCommand(storageServers.get(0).getParent(), path, uuid);\n    \t    long result = send(use_ssvm.getId(), cmd, null);\n    \t    if (result == -1){\n    \t        errorString = \"Unable to create a link for \" +type+ \" id:\"+template.getId();\n                s_logger.error(errorString);\n                throw new CloudRuntimeException(errorString);\n    \t    }\n    \t    \n    \t    //Construct actual URL locally now that the symlink exists at SSVM\n    \t    List<SecondaryStorageVmVO> ssVms = _secStorageVmDao.getSecStorageVmListInStates(SecondaryStorageVm.Role.templateProcessor, dataCenterId, State.Running);\n    \t    if (ssVms.size() > 0) {\n                SecondaryStorageVmVO ssVm = ssVms.get(0);\n                if (ssVm.getPublicIpAddress() == null) {\n                    errorString = \"A running secondary storage vm has a null public ip?\";\n                    s_logger.error(errorString);\n                    throw new CloudRuntimeException(errorString);\n                }\n                String extractURL = generateCopyUrl(ssVm.getPublicIpAddress(), uuid);\n                UploadVO vo = _uploadDao.createForUpdate();\n                vo.setLastUpdated(new Date());\n                vo.setUploadUrl(extractURL);\n                vo.setUploadState(Status.DOWNLOAD_URL_CREATED);\n                _uploadDao.update(uploadTemplateObj.getId(), vo);\n                success = true;\n                return _uploadDao.findById(uploadTemplateObj.getId(), true);\n            }\n            errorString = \"Couldnt find a running SSVM in the zone\" + dataCenterId+ \". Couldnt create the extraction URL.\";\n            throw new CloudRuntimeException(errorString);\n\t    }finally{\n           if(!success){\n                UploadVO uploadJob = _uploadDao.createForUpdate(uploadTemplateObj.getId());\n                uploadJob.setLastUpdated(new Date());\n                uploadJob.setErrorString(errorString);\n                uploadJob.setUploadState(Status.ERROR);\n                _uploadDao.update(uploadTemplateObj.getId(), uploadJob);\n            }\n\t    }\n\t    \n\t}","id":102953,"modified_method":"@Override\n\tpublic UploadVO createEntityDownloadURL(VMTemplateVO template, VMTemplateHostVO vmTemplateHost, Long dataCenterId, long eventId) {\n\t    \n\t    String errorString = \"\";\n\t    boolean success = false;\n\t    Host secStorage = ApiDBUtils.findHostById(vmTemplateHost.getHostId());\t    \n\t    Type type = (template.getFormat() == ImageFormat.ISO) ? Type.ISO : Type.TEMPLATE ;\n\t    \n        //Check if ssvm is up\n        HostVO ssvm = _agentMgr.getSSAgent(ApiDBUtils.findHostById(vmTemplateHost.getHostId()));\n        if( ssvm == null ) {\n            throw new CloudRuntimeException(\"There is no secondary storage VM for secondary storage host \" + secStorage.getId());\n        }\n\t    \n\t    //Check if it already exists.\n\t    List<UploadVO> extractURLList = _uploadDao.listByTypeUploadStatus(template.getId(), type, UploadVO.Status.DOWNLOAD_URL_CREATED);\t    \n\t    if (extractURLList.size() > 0) {\n            return extractURLList.get(0);\n        }\n\t    \n\t    // It doesn't exist so create a DB entry.\t    \n\t    UploadVO uploadTemplateObj = new UploadVO(vmTemplateHost.getHostId(), template.getId(), new Date(), \n\t                                                Status.DOWNLOAD_URL_NOT_CREATED, 0, type, Mode.HTTP_DOWNLOAD); \n\t    uploadTemplateObj.setInstallPath(vmTemplateHost.getInstallPath());\t                                                \n\t    _uploadDao.persist(uploadTemplateObj);\n\t    try{\n    \t    // Create Symlink at ssvm\n\t    \tString path = vmTemplateHost.getInstallPath();\n\t    \tString uuid = UUID.randomUUID().toString() + path.substring(path.length() - 4) ; // last 4 characters of the path specify the format like .vhd\n\t    \tCreateEntityDownloadURLCommand cmd = new CreateEntityDownloadURLCommand(secStorage.getParent(), path, uuid);\n    \t    long result = send(ssvm.getId(), cmd, null);\n    \t    if (result == -1){\n    \t        errorString = \"Unable to create a link for \" +type+ \" id:\"+template.getId();\n                s_logger.error(errorString);\n                throw new CloudRuntimeException(errorString);\n    \t    }\n    \t    \n    \t    //Construct actual URL locally now that the symlink exists at SSVM\n    \t    List<SecondaryStorageVmVO> ssVms = _secStorageVmDao.getSecStorageVmListInStates(SecondaryStorageVm.Role.templateProcessor, dataCenterId, State.Running);\n    \t    if (ssVms.size() > 0) {\n                SecondaryStorageVmVO ssVm = ssVms.get(0);\n                if (ssVm.getPublicIpAddress() == null) {\n                    errorString = \"A running secondary storage vm has a null public ip?\";\n                    s_logger.error(errorString);\n                    throw new CloudRuntimeException(errorString);\n                }\n                String extractURL = generateCopyUrl(ssVm.getPublicIpAddress(), uuid);\n                UploadVO vo = _uploadDao.createForUpdate();\n                vo.setLastUpdated(new Date());\n                vo.setUploadUrl(extractURL);\n                vo.setUploadState(Status.DOWNLOAD_URL_CREATED);\n                _uploadDao.update(uploadTemplateObj.getId(), vo);\n                success = true;\n                return _uploadDao.findById(uploadTemplateObj.getId(), true);\n            }\n            errorString = \"Couldnt find a running SSVM in the zone\" + dataCenterId+ \". Couldnt create the extraction URL.\";\n            throw new CloudRuntimeException(errorString);\n\t    }finally{\n           if(!success){\n                UploadVO uploadJob = _uploadDao.createForUpdate(uploadTemplateObj.getId());\n                uploadJob.setLastUpdated(new Date());\n                uploadJob.setErrorString(errorString);\n                uploadJob.setUploadState(Status.ERROR);\n                _uploadDao.update(uploadTemplateObj.getId(), uploadJob);\n            }\n\t    }\n\t    \n\t}","commit_id":"5ef0c96e7008e08a763df6f6a441b46a7d2f8634","url":"https://github.com/apache/cloudstack"},{"original_method":"public DeleteEntityDownloadURLCommand(String path, Upload.Type type, String url) {\n        super();\n        this.path = path;\n        this.type = type;\n        this.extractUrl = url;\n    }","id":102954,"modified_method":"public DeleteEntityDownloadURLCommand(String path, Upload.Type type, String url, String parentPath) {\n        super();\n        this.path = path;\n        this.type = type;\n        this.extractUrl = url;\n        this.parentPath = parentPath;\n    }","commit_id":"f1d13729afde0051383462e43ae1cfd8e717f5bc","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public DeleteEntityDownloadURLAnswer handleDeleteEntityDownloadURLCommand(DeleteEntityDownloadURLCommand cmd){\n\n        //Delete the soft link. Example path = volumes/8/74eeb2c6-8ab1-4357-841f-2e9d06d1f360.vhd\n        s_logger.warn(\"handleDeleteEntityDownloadURLCommand Path:\"+cmd.getPath() + \" Type:\" +cmd.getType().toString());\n        String path = cmd.getPath();\n        Script command = new Script(\"/bin/bash\", s_logger);\n        command.add(\"-c\");\n        \n\t\t//We just need to remove the UUID.vhd\n        String extractUrl = cmd.getExtractUrl();\n        command.add(\"unlink /var/www/html/userdata/\" +extractUrl.substring(extractUrl.lastIndexOf(File.separator) + 1));\n        String result = command.execute();\n        if (result != null) {\n            String errorString = \"Error in deleting =\" + result;\n            s_logger.warn(errorString);\n            return new DeleteEntityDownloadURLAnswer(errorString, CreateEntityDownloadURLAnswer.RESULT_FAILURE);\n        }\n        \n        // If its a volume also delete the Hard link since it was created only for the purpose of download.\n        if(cmd.getType() == Upload.Type.VOLUME){\n            command = new Script(\"/bin/bash\", s_logger);\n            command.add(\"-c\");\n            command.add(\"rm -f \" + parentDir +File.separator+ path);\n            s_logger.warn(\" \" +parentDir +File.separator+ path);\n            result = command.execute();\n            if (result != null) {\n                String errorString = \"Error in linking  err=\" + result;\n                s_logger.warn(errorString);\n                return new DeleteEntityDownloadURLAnswer(errorString, CreateEntityDownloadURLAnswer.RESULT_FAILURE);\n            }\n        }\n        \n        return new DeleteEntityDownloadURLAnswer(\"\", CreateEntityDownloadURLAnswer.RESULT_SUCCESS);\n    }","id":102955,"modified_method":"@Override\n    public DeleteEntityDownloadURLAnswer handleDeleteEntityDownloadURLCommand(DeleteEntityDownloadURLCommand cmd){\n\n        //Delete the soft link. Example path = volumes/8/74eeb2c6-8ab1-4357-841f-2e9d06d1f360.vhd\n        s_logger.warn(\"handleDeleteEntityDownloadURLCommand Path:\"+cmd.getPath() + \" Type:\" +cmd.getType().toString());\n        String path = cmd.getPath();\n        Script command = new Script(\"/bin/bash\", s_logger);\n        command.add(\"-c\");\n        \n\t\t//We just need to remove the UUID.vhd\n        String extractUrl = cmd.getExtractUrl();\n        command.add(\"unlink /var/www/html/userdata/\" +extractUrl.substring(extractUrl.lastIndexOf(File.separator) + 1));\n        String result = command.execute();\n        if (result != null) {\n            String errorString = \"Error in deleting =\" + result;\n            s_logger.warn(errorString);\n            return new DeleteEntityDownloadURLAnswer(errorString, CreateEntityDownloadURLAnswer.RESULT_FAILURE);\n        }\n        \n        // If its a volume also delete the Hard link since it was created only for the purpose of download.\n        if(cmd.getType() == Upload.Type.VOLUME){\n            command = new Script(\"/bin/bash\", s_logger);\n            command.add(\"-c\");\n            command.add(\"rm -f /mnt/SecStorage/\" + cmd.getParentPath() +File.separator+ path);\n            s_logger.warn(\" \" +parentDir +File.separator+ path);\n            result = command.execute();\n            if (result != null) {\n                String errorString = \"Error in linking  err=\" + result;\n                s_logger.warn(errorString);\n                return new DeleteEntityDownloadURLAnswer(errorString, CreateEntityDownloadURLAnswer.RESULT_FAILURE);\n            }\n        }\n        \n        return new DeleteEntityDownloadURLAnswer(\"\", CreateEntityDownloadURLAnswer.RESULT_SUCCESS);\n    }","commit_id":"f1d13729afde0051383462e43ae1cfd8e717f5bc","url":"https://github.com/apache/cloudstack"},{"original_method":"public void cleanupStorage() {\n\n        final int EXTRACT_URL_LIFE_LIMIT_IN_SECONDS = _urlExpirationInterval;\n        List<UploadVO> extractJobs= _uploadDao.listByModeAndStatus(Mode.HTTP_DOWNLOAD, Status.DOWNLOAD_URL_CREATED);\n        \n        for (UploadVO extractJob : extractJobs){\n            if( getTimeDiff(extractJob.getLastUpdated()) > EXTRACT_URL_LIFE_LIMIT_IN_SECONDS ){                           \n                String path = extractJob.getInstallPath();\n                s_logger.debug(\"Sending deletion of extract URL \"+extractJob.getUploadUrl());\n                // Would delete the symlink for the Type and if Type == VOLUME then also the volume\n                DeleteEntityDownloadURLCommand cmd = new DeleteEntityDownloadURLCommand(path, extractJob.getType(),extractJob.getUploadUrl());\n                HostVO ssvm = _agentMgr.getSSAgent(ApiDBUtils.findHostById(extractJob.getHostId()));\n                if( ssvm == null ) {\n                \ts_logger.warn(\"There is no secondary storage VM for secondary storage host \" + extractJob.getHostId());\n                \tcontinue;\n                }\n                long result = send(ssvm.getId(), cmd, null);\n                if (result == -1){\n                    s_logger.warn(\"Unable to delete the link for \" +extractJob.getType()+ \" id=\" +extractJob.getTypeId()+ \" url=\"+extractJob.getUploadUrl());\n                }else{\n                    _uploadDao.remove(extractJob.getId());\n                }\n            }\n        }\n                \n    }","id":102956,"modified_method":"public void cleanupStorage() {\n\n        final int EXTRACT_URL_LIFE_LIMIT_IN_SECONDS = _urlExpirationInterval;\n        List<UploadVO> extractJobs= _uploadDao.listByModeAndStatus(Mode.HTTP_DOWNLOAD, Status.DOWNLOAD_URL_CREATED);\n        \n        for (UploadVO extractJob : extractJobs){\n            if( getTimeDiff(extractJob.getLastUpdated()) > EXTRACT_URL_LIFE_LIMIT_IN_SECONDS ){                           \n                String path = extractJob.getInstallPath();\n                HostVO secStorage = ApiDBUtils.findHostById(extractJob.getHostId());\n                s_logger.debug(\"Sending deletion of extract URL \"+extractJob.getUploadUrl());\n                // Would delete the symlink for the Type and if Type == VOLUME then also the volume\n                DeleteEntityDownloadURLCommand cmd = new DeleteEntityDownloadURLCommand(path, extractJob.getType(),extractJob.getUploadUrl(), secStorage.getParent());\n                HostVO ssvm = _agentMgr.getSSAgent(secStorage);\n                if( ssvm == null ) {\n                \ts_logger.warn(\"There is no secondary storage VM for secondary storage host \" + extractJob.getHostId());\n                \tcontinue;\n                }\n                long result = send(ssvm.getId(), cmd, null);\n                if (result == -1){\n                    s_logger.warn(\"Unable to delete the link for \" +extractJob.getType()+ \" id=\" +extractJob.getTypeId()+ \" url=\"+extractJob.getUploadUrl());\n                }else{\n                    _uploadDao.remove(extractJob.getId());\n                }\n            }\n        }\n                \n    }","commit_id":"f1d13729afde0051383462e43ae1cfd8e717f5bc","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n\tpublic UploadVO createEntityDownloadURL(VMTemplateVO template, VMTemplateHostVO vmTemplateHost, Long dataCenterId, long eventId) {\n\t    \n\t    String errorString = \"\";\n\t    boolean success = false;\n\t    List<HostVO> storageServers = _serverDao.listByTypeDataCenter(Host.Type.SecondaryStorage, dataCenterId);\n\t    if(storageServers == null || storageServers.size() == 0) {\n            throw new CloudRuntimeException(\"No Storage Server found at the datacenter - \" +dataCenterId);\n        }\n\t    \n\t    Type type = (template.getFormat() == ImageFormat.ISO) ? Type.ISO : Type.TEMPLATE ;\n\t    \n\t    List<HostVO> storageServerVMs = _serverDao.listByTypeDataCenter(Host.Type.SecondaryStorageVM, dataCenterId);\n        //Check if one ssvm is up\n        boolean no_vm_up = true;\n        HostVO use_ssvm = null;\n        for (HostVO ssvm: storageServerVMs){\n            if(ssvm.getStatus() == com.cloud.host.Status.Up){\n                no_vm_up = false;\n                use_ssvm = ssvm;\n                break;\n            }  \n        }\n        if(no_vm_up){\n            throw new CloudRuntimeException(\"Couldnt create extract link - Secondary Storage Vm is not up\");\n        }\n\t    \n\t    //Check if it already exists.\n\t    List<UploadVO> extractURLList = _uploadDao.listByTypeUploadStatus(template.getId(), type, UploadVO.Status.DOWNLOAD_URL_CREATED);\t    \n\t    if (extractURLList.size() > 0) {\n            return extractURLList.get(0);\n        }\n\t    \n\t    // It doesn't exist so create a DB entry.\t    \n\t    UploadVO uploadTemplateObj = new UploadVO(use_ssvm.getId(), template.getId(), new Date(), \n\t                                                Status.DOWNLOAD_URL_NOT_CREATED, 0, type, Mode.HTTP_DOWNLOAD); \n\t    uploadTemplateObj.setInstallPath(vmTemplateHost.getInstallPath());\t                                                \n\t    _uploadDao.persist(uploadTemplateObj);\n\t    try{\n    \t    // Create Symlink at ssvm\n\t    \tString path = vmTemplateHost.getInstallPath();\n\t    \tString uuid = UUID.randomUUID().toString() + path.substring(path.length() - 4) ; // last 4 characters of the path specify the format like .vhd\n\t    \tCreateEntityDownloadURLCommand cmd = new CreateEntityDownloadURLCommand(storageServers.get(0).getParent(), path, uuid);\n    \t    long result = send(use_ssvm.getId(), cmd, null);\n    \t    if (result == -1){\n    \t        errorString = \"Unable to create a link for \" +type+ \" id:\"+template.getId();\n                s_logger.error(errorString);\n                throw new CloudRuntimeException(errorString);\n    \t    }\n    \t    \n    \t    //Construct actual URL locally now that the symlink exists at SSVM\n    \t    List<SecondaryStorageVmVO> ssVms = _secStorageVmDao.getSecStorageVmListInStates(SecondaryStorageVm.Role.templateProcessor, dataCenterId, State.Running);\n    \t    if (ssVms.size() > 0) {\n                SecondaryStorageVmVO ssVm = ssVms.get(0);\n                if (ssVm.getPublicIpAddress() == null) {\n                    errorString = \"A running secondary storage vm has a null public ip?\";\n                    s_logger.error(errorString);\n                    throw new CloudRuntimeException(errorString);\n                }\n                String extractURL = generateCopyUrl(ssVm.getPublicIpAddress(), uuid);\n                UploadVO vo = _uploadDao.createForUpdate();\n                vo.setLastUpdated(new Date());\n                vo.setUploadUrl(extractURL);\n                vo.setUploadState(Status.DOWNLOAD_URL_CREATED);\n                _uploadDao.update(uploadTemplateObj.getId(), vo);\n                success = true;\n                return _uploadDao.findById(uploadTemplateObj.getId(), true);\n            }\n            errorString = \"Couldnt find a running SSVM in the zone\" + dataCenterId+ \". Couldnt create the extraction URL.\";\n            throw new CloudRuntimeException(errorString);\n\t    }finally{\n           if(!success){\n                UploadVO uploadJob = _uploadDao.createForUpdate(uploadTemplateObj.getId());\n                uploadJob.setLastUpdated(new Date());\n                uploadJob.setErrorString(errorString);\n                uploadJob.setUploadState(Status.ERROR);\n                _uploadDao.update(uploadTemplateObj.getId(), uploadJob);\n            }\n\t    }\n\t    \n\t}","id":102957,"modified_method":"@Override\n\tpublic UploadVO createEntityDownloadURL(VMTemplateVO template, VMTemplateHostVO vmTemplateHost, Long dataCenterId, long eventId) {\n\t    \n\t    String errorString = \"\";\n\t    boolean success = false;\n\t    Host secStorage = ApiDBUtils.findHostById(vmTemplateHost.getHostId());\t    \n\t    Type type = (template.getFormat() == ImageFormat.ISO) ? Type.ISO : Type.TEMPLATE ;\n\t    \n        //Check if ssvm is up\n        HostVO ssvm = _agentMgr.getSSAgent(ApiDBUtils.findHostById(vmTemplateHost.getHostId()));\n        if( ssvm == null ) {\n            throw new CloudRuntimeException(\"There is no secondary storage VM for secondary storage host \" + secStorage.getId());\n        }\n\t    \n\t    //Check if it already exists.\n\t    List<UploadVO> extractURLList = _uploadDao.listByTypeUploadStatus(template.getId(), type, UploadVO.Status.DOWNLOAD_URL_CREATED);\t    \n\t    if (extractURLList.size() > 0) {\n            return extractURLList.get(0);\n        }\n\t    \n\t    // It doesn't exist so create a DB entry.\t    \n\t    UploadVO uploadTemplateObj = new UploadVO(vmTemplateHost.getHostId(), template.getId(), new Date(), \n\t                                                Status.DOWNLOAD_URL_NOT_CREATED, 0, type, Mode.HTTP_DOWNLOAD); \n\t    uploadTemplateObj.setInstallPath(vmTemplateHost.getInstallPath());\t                                                \n\t    _uploadDao.persist(uploadTemplateObj);\n\t    try{\n    \t    // Create Symlink at ssvm\n\t    \tString path = vmTemplateHost.getInstallPath();\n\t    \tString uuid = UUID.randomUUID().toString() + path.substring(path.length() - 4) ; // last 4 characters of the path specify the format like .vhd\n\t    \tCreateEntityDownloadURLCommand cmd = new CreateEntityDownloadURLCommand(secStorage.getParent(), path, uuid);\n    \t    long result = send(ssvm.getId(), cmd, null);\n    \t    if (result == -1){\n    \t        errorString = \"Unable to create a link for \" +type+ \" id:\"+template.getId();\n                s_logger.error(errorString);\n                throw new CloudRuntimeException(errorString);\n    \t    }\n    \t    \n    \t    //Construct actual URL locally now that the symlink exists at SSVM\n    \t    List<SecondaryStorageVmVO> ssVms = _secStorageVmDao.getSecStorageVmListInStates(SecondaryStorageVm.Role.templateProcessor, dataCenterId, State.Running);\n    \t    if (ssVms.size() > 0) {\n                SecondaryStorageVmVO ssVm = ssVms.get(0);\n                if (ssVm.getPublicIpAddress() == null) {\n                    errorString = \"A running secondary storage vm has a null public ip?\";\n                    s_logger.error(errorString);\n                    throw new CloudRuntimeException(errorString);\n                }\n                String extractURL = generateCopyUrl(ssVm.getPublicIpAddress(), uuid);\n                UploadVO vo = _uploadDao.createForUpdate();\n                vo.setLastUpdated(new Date());\n                vo.setUploadUrl(extractURL);\n                vo.setUploadState(Status.DOWNLOAD_URL_CREATED);\n                _uploadDao.update(uploadTemplateObj.getId(), vo);\n                success = true;\n                return _uploadDao.findById(uploadTemplateObj.getId(), true);\n            }\n            errorString = \"Couldnt find a running SSVM in the zone\" + dataCenterId+ \". Couldnt create the extraction URL.\";\n            throw new CloudRuntimeException(errorString);\n\t    }finally{\n           if(!success){\n                UploadVO uploadJob = _uploadDao.createForUpdate(uploadTemplateObj.getId());\n                uploadJob.setLastUpdated(new Date());\n                uploadJob.setErrorString(errorString);\n                uploadJob.setUploadState(Status.ERROR);\n                _uploadDao.update(uploadTemplateObj.getId(), uploadJob);\n            }\n\t    }\n\t    \n\t}","commit_id":"f1d13729afde0051383462e43ae1cfd8e717f5bc","url":"https://github.com/apache/cloudstack"},{"original_method":"public DeleteEntityDownloadURLCommand(String path, Upload.Type type, String url) {\n        super();\n        this.path = path;\n        this.type = type;\n        this.extractUrl = url;\n    }","id":102958,"modified_method":"public DeleteEntityDownloadURLCommand(String path, Upload.Type type, String url, String parentPath) {\n        super();\n        this.path = path;\n        this.type = type;\n        this.extractUrl = url;\n        this.parentPath = parentPath;\n    }","commit_id":"e7a199e253ecd3cc80fe180a2ae07b70c76cdfc2","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public DeleteEntityDownloadURLAnswer handleDeleteEntityDownloadURLCommand(DeleteEntityDownloadURLCommand cmd){\n\n        //Delete the soft link. Example path = volumes/8/74eeb2c6-8ab1-4357-841f-2e9d06d1f360.vhd\n        s_logger.warn(\"handleDeleteEntityDownloadURLCommand Path:\"+cmd.getPath() + \" Type:\" +cmd.getType().toString());\n        String path = cmd.getPath();\n        Script command = new Script(\"/bin/bash\", s_logger);\n        command.add(\"-c\");\n        \n\t\t//We just need to remove the UUID.vhd\n        String extractUrl = cmd.getExtractUrl();\n        command.add(\"unlink /var/www/html/userdata/\" +extractUrl.substring(extractUrl.lastIndexOf(File.separator) + 1));\n        String result = command.execute();\n        if (result != null) {\n            String errorString = \"Error in deleting =\" + result;\n            s_logger.warn(errorString);\n            return new DeleteEntityDownloadURLAnswer(errorString, CreateEntityDownloadURLAnswer.RESULT_FAILURE);\n        }\n        \n        // If its a volume also delete the Hard link since it was created only for the purpose of download.\n        if(cmd.getType() == Upload.Type.VOLUME){\n            command = new Script(\"/bin/bash\", s_logger);\n            command.add(\"-c\");\n            command.add(\"rm -f \" + parentDir +File.separator+ path);\n            s_logger.warn(\" \" +parentDir +File.separator+ path);\n            result = command.execute();\n            if (result != null) {\n                String errorString = \"Error in linking  err=\" + result;\n                s_logger.warn(errorString);\n                return new DeleteEntityDownloadURLAnswer(errorString, CreateEntityDownloadURLAnswer.RESULT_FAILURE);\n            }\n        }\n        \n        return new DeleteEntityDownloadURLAnswer(\"\", CreateEntityDownloadURLAnswer.RESULT_SUCCESS);\n    }","id":102959,"modified_method":"@Override\n    public DeleteEntityDownloadURLAnswer handleDeleteEntityDownloadURLCommand(DeleteEntityDownloadURLCommand cmd){\n\n        //Delete the soft link. Example path = volumes/8/74eeb2c6-8ab1-4357-841f-2e9d06d1f360.vhd\n        s_logger.warn(\"handleDeleteEntityDownloadURLCommand Path:\"+cmd.getPath() + \" Type:\" +cmd.getType().toString());\n        String path = cmd.getPath();\n        Script command = new Script(\"/bin/bash\", s_logger);\n        command.add(\"-c\");\n        \n\t\t//We just need to remove the UUID.vhd\n        String extractUrl = cmd.getExtractUrl();\n        command.add(\"unlink /var/www/html/userdata/\" +extractUrl.substring(extractUrl.lastIndexOf(File.separator) + 1));\n        String result = command.execute();\n        if (result != null) {\n            String errorString = \"Error in deleting =\" + result;\n            s_logger.warn(errorString);\n            return new DeleteEntityDownloadURLAnswer(errorString, CreateEntityDownloadURLAnswer.RESULT_FAILURE);\n        }\n        \n        // If its a volume also delete the Hard link since it was created only for the purpose of download.\n        if(cmd.getType() == Upload.Type.VOLUME){\n            command = new Script(\"/bin/bash\", s_logger);\n            command.add(\"-c\");\n            command.add(\"rm -f /mnt/SecStorage/\" + cmd.getParentPath() +File.separator+ path);\n            s_logger.warn(\" \" +parentDir +File.separator+ path);\n            result = command.execute();\n            if (result != null) {\n                String errorString = \"Error in linking  err=\" + result;\n                s_logger.warn(errorString);\n                return new DeleteEntityDownloadURLAnswer(errorString, CreateEntityDownloadURLAnswer.RESULT_FAILURE);\n            }\n        }\n        \n        return new DeleteEntityDownloadURLAnswer(\"\", CreateEntityDownloadURLAnswer.RESULT_SUCCESS);\n    }","commit_id":"e7a199e253ecd3cc80fe180a2ae07b70c76cdfc2","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n\tpublic UploadVO createEntityDownloadURL(VMTemplateVO template, VMTemplateHostVO vmTemplateHost, Long dataCenterId, long eventId) {\n\t    \n\t    String errorString = \"\";\n\t    boolean success = false;\n\t    List<HostVO> storageServers = _serverDao.listByTypeDataCenter(Host.Type.SecondaryStorage, dataCenterId);\n\t    if(storageServers == null || storageServers.size() == 0) {\n            throw new CloudRuntimeException(\"No Storage Server found at the datacenter - \" +dataCenterId);\n        }\n\t    \n\t    Type type = (template.getFormat() == ImageFormat.ISO) ? Type.ISO : Type.TEMPLATE ;\n\t    \n\t    List<HostVO> storageServerVMs = _serverDao.listByTypeDataCenter(Host.Type.SecondaryStorageVM, dataCenterId);\n        //Check if one ssvm is up\n        boolean no_vm_up = true;\n        HostVO use_ssvm = null;\n        for (HostVO ssvm: storageServerVMs){\n            if(ssvm.getStatus() == com.cloud.host.Status.Up){\n                no_vm_up = false;\n                use_ssvm = ssvm;\n                break;\n            }  \n        }\n        if(no_vm_up){\n            throw new CloudRuntimeException(\"Couldnt create extract link - Secondary Storage Vm is not up\");\n        }\n\t    \n\t    //Check if it already exists.\n\t    List<UploadVO> extractURLList = _uploadDao.listByTypeUploadStatus(template.getId(), type, UploadVO.Status.DOWNLOAD_URL_CREATED);\t    \n\t    if (extractURLList.size() > 0) {\n            return extractURLList.get(0);\n        }\n\t    \n\t    // It doesn't exist so create a DB entry.\t    \n\t    UploadVO uploadTemplateObj = new UploadVO(use_ssvm.getId(), template.getId(), new Date(), \n\t                                                Status.DOWNLOAD_URL_NOT_CREATED, 0, type, Mode.HTTP_DOWNLOAD); \n\t    uploadTemplateObj.setInstallPath(vmTemplateHost.getInstallPath());\t                                                \n\t    _uploadDao.persist(uploadTemplateObj);\n\t    try{\n    \t    // Create Symlink at ssvm\n\t    \tString path = vmTemplateHost.getInstallPath();\n\t    \tString uuid = UUID.randomUUID().toString() + path.substring(path.length() - 4) ; // last 4 characters of the path specify the format like .vhd\n\t    \tCreateEntityDownloadURLCommand cmd = new CreateEntityDownloadURLCommand(storageServers.get(0).getParent(), path, uuid);\n    \t    long result = send(use_ssvm.getId(), cmd, null);\n    \t    if (result == -1){\n    \t        errorString = \"Unable to create a link for \" +type+ \" id:\"+template.getId();\n                s_logger.error(errorString);\n                throw new CloudRuntimeException(errorString);\n    \t    }\n    \t    \n    \t    //Construct actual URL locally now that the symlink exists at SSVM\n    \t    List<SecondaryStorageVmVO> ssVms = _secStorageVmDao.getSecStorageVmListInStates(SecondaryStorageVm.Role.templateProcessor, dataCenterId, State.Running);\n    \t    if (ssVms.size() > 0) {\n                SecondaryStorageVmVO ssVm = ssVms.get(0);\n                if (ssVm.getPublicIpAddress() == null) {\n                    errorString = \"A running secondary storage vm has a null public ip?\";\n                    s_logger.error(errorString);\n                    throw new CloudRuntimeException(errorString);\n                }\n                String extractURL = generateCopyUrl(ssVm.getPublicIpAddress(), uuid);\n                UploadVO vo = _uploadDao.createForUpdate();\n                vo.setLastUpdated(new Date());\n                vo.setUploadUrl(extractURL);\n                vo.setUploadState(Status.DOWNLOAD_URL_CREATED);\n                _uploadDao.update(uploadTemplateObj.getId(), vo);\n                success = true;\n                return _uploadDao.findById(uploadTemplateObj.getId(), true);\n            }\n            errorString = \"Couldnt find a running SSVM in the zone\" + dataCenterId+ \". Couldnt create the extraction URL.\";\n            throw new CloudRuntimeException(errorString);\n\t    }finally{\n           if(!success){\n                UploadVO uploadJob = _uploadDao.createForUpdate(uploadTemplateObj.getId());\n                uploadJob.setLastUpdated(new Date());\n                uploadJob.setErrorString(errorString);\n                uploadJob.setUploadState(Status.ERROR);\n                _uploadDao.update(uploadTemplateObj.getId(), uploadJob);\n            }\n\t    }\n\t    \n\t}","id":102960,"modified_method":"@Override\n\tpublic UploadVO createEntityDownloadURL(VMTemplateVO template, VMTemplateHostVO vmTemplateHost, Long dataCenterId, long eventId) {\n\t    \n\t    String errorString = \"\";\n\t    boolean success = false;\n\t    Host secStorage = ApiDBUtils.findHostById(vmTemplateHost.getHostId());\t    \n\t    Type type = (template.getFormat() == ImageFormat.ISO) ? Type.ISO : Type.TEMPLATE ;\n\t    \n        //Check if ssvm is up\n        HostVO ssvm = _agentMgr.getSSAgent(ApiDBUtils.findHostById(vmTemplateHost.getHostId()));\n        if( ssvm == null ) {\n            throw new CloudRuntimeException(\"There is no secondary storage VM for secondary storage host \" + secStorage.getId());\n        }\n\t    \n\t    //Check if it already exists.\n\t    List<UploadVO> extractURLList = _uploadDao.listByTypeUploadStatus(template.getId(), type, UploadVO.Status.DOWNLOAD_URL_CREATED);\t    \n\t    if (extractURLList.size() > 0) {\n            return extractURLList.get(0);\n        }\n\t    \n\t    // It doesn't exist so create a DB entry.\t    \n\t    UploadVO uploadTemplateObj = new UploadVO(vmTemplateHost.getHostId(), template.getId(), new Date(), \n\t                                                Status.DOWNLOAD_URL_NOT_CREATED, 0, type, Mode.HTTP_DOWNLOAD); \n\t    uploadTemplateObj.setInstallPath(vmTemplateHost.getInstallPath());\t                                                \n\t    _uploadDao.persist(uploadTemplateObj);\n\t    try{\n    \t    // Create Symlink at ssvm\n\t    \tString path = vmTemplateHost.getInstallPath();\n\t    \tString uuid = UUID.randomUUID().toString() + path.substring(path.length() - 4) ; // last 4 characters of the path specify the format like .vhd\n\t    \tCreateEntityDownloadURLCommand cmd = new CreateEntityDownloadURLCommand(secStorage.getParent(), path, uuid);\n    \t    long result = send(ssvm.getId(), cmd, null);\n    \t    if (result == -1){\n    \t        errorString = \"Unable to create a link for \" +type+ \" id:\"+template.getId();\n                s_logger.error(errorString);\n                throw new CloudRuntimeException(errorString);\n    \t    }\n    \t    \n    \t    //Construct actual URL locally now that the symlink exists at SSVM\n    \t    List<SecondaryStorageVmVO> ssVms = _secStorageVmDao.getSecStorageVmListInStates(SecondaryStorageVm.Role.templateProcessor, dataCenterId, State.Running);\n    \t    if (ssVms.size() > 0) {\n                SecondaryStorageVmVO ssVm = ssVms.get(0);\n                if (ssVm.getPublicIpAddress() == null) {\n                    errorString = \"A running secondary storage vm has a null public ip?\";\n                    s_logger.error(errorString);\n                    throw new CloudRuntimeException(errorString);\n                }\n                String extractURL = generateCopyUrl(ssVm.getPublicIpAddress(), uuid);\n                UploadVO vo = _uploadDao.createForUpdate();\n                vo.setLastUpdated(new Date());\n                vo.setUploadUrl(extractURL);\n                vo.setUploadState(Status.DOWNLOAD_URL_CREATED);\n                _uploadDao.update(uploadTemplateObj.getId(), vo);\n                success = true;\n                return _uploadDao.findById(uploadTemplateObj.getId(), true);\n            }\n            errorString = \"Couldnt find a running SSVM in the zone\" + dataCenterId+ \". Couldnt create the extraction URL.\";\n            throw new CloudRuntimeException(errorString);\n\t    }finally{\n           if(!success){\n                UploadVO uploadJob = _uploadDao.createForUpdate(uploadTemplateObj.getId());\n                uploadJob.setLastUpdated(new Date());\n                uploadJob.setErrorString(errorString);\n                uploadJob.setUploadState(Status.ERROR);\n                _uploadDao.update(uploadTemplateObj.getId(), uploadJob);\n            }\n\t    }\n\t    \n\t}","commit_id":"e7a199e253ecd3cc80fe180a2ae07b70c76cdfc2","url":"https://github.com/apache/cloudstack"},{"original_method":"public void cleanupStorage() {\n\n        final int EXTRACT_URL_LIFE_LIMIT_IN_SECONDS = _urlExpirationInterval;\n        List<UploadVO> extractJobs= _uploadDao.listByModeAndStatus(Mode.HTTP_DOWNLOAD, Status.DOWNLOAD_URL_CREATED);\n        \n        for (UploadVO extractJob : extractJobs){\n            if( getTimeDiff(extractJob.getLastUpdated()) > EXTRACT_URL_LIFE_LIMIT_IN_SECONDS ){                           \n                String path = extractJob.getInstallPath();\n                s_logger.debug(\"Sending deletion of extract URL \"+extractJob.getUploadUrl());\n                // Would delete the symlink for the Type and if Type == VOLUME then also the volume\n                DeleteEntityDownloadURLCommand cmd = new DeleteEntityDownloadURLCommand(path, extractJob.getType(),extractJob.getUploadUrl());\n                HostVO ssvm = _agentMgr.getSSAgent(ApiDBUtils.findHostById(extractJob.getHostId()));\n                if( ssvm == null ) {\n                \ts_logger.warn(\"There is no secondary storage VM for secondary storage host \" + extractJob.getHostId());\n                \tcontinue;\n                }\n                long result = send(ssvm.getId(), cmd, null);\n                if (result == -1){\n                    s_logger.warn(\"Unable to delete the link for \" +extractJob.getType()+ \" id=\" +extractJob.getTypeId()+ \" url=\"+extractJob.getUploadUrl());\n                }else{\n                    _uploadDao.remove(extractJob.getId());\n                }\n            }\n        }\n                \n    }","id":102961,"modified_method":"public void cleanupStorage() {\n\n        final int EXTRACT_URL_LIFE_LIMIT_IN_SECONDS = _urlExpirationInterval;\n        List<UploadVO> extractJobs= _uploadDao.listByModeAndStatus(Mode.HTTP_DOWNLOAD, Status.DOWNLOAD_URL_CREATED);\n        \n        for (UploadVO extractJob : extractJobs){\n            if( getTimeDiff(extractJob.getLastUpdated()) > EXTRACT_URL_LIFE_LIMIT_IN_SECONDS ){                           \n                String path = extractJob.getInstallPath();\n                HostVO secStorage = ApiDBUtils.findHostById(extractJob.getHostId());\n                s_logger.debug(\"Sending deletion of extract URL \"+extractJob.getUploadUrl());\n                // Would delete the symlink for the Type and if Type == VOLUME then also the volume\n                DeleteEntityDownloadURLCommand cmd = new DeleteEntityDownloadURLCommand(path, extractJob.getType(),extractJob.getUploadUrl(), secStorage.getParent());\n                HostVO ssvm = _agentMgr.getSSAgent(secStorage);\n                if( ssvm == null ) {\n                \ts_logger.warn(\"There is no secondary storage VM for secondary storage host \" + extractJob.getHostId());\n                \tcontinue;\n                }\n                long result = send(ssvm.getId(), cmd, null);\n                if (result == -1){\n                    s_logger.warn(\"Unable to delete the link for \" +extractJob.getType()+ \" id=\" +extractJob.getTypeId()+ \" url=\"+extractJob.getUploadUrl());\n                }else{\n                    _uploadDao.remove(extractJob.getId());\n                }\n            }\n        }\n                \n    }","commit_id":"e7a199e253ecd3cc80fe180a2ae07b70c76cdfc2","url":"https://github.com/apache/cloudstack"},{"original_method":"public void destroy() throws Exception {\n        ServiceHelper.stopService(producer);\n    }","id":102962,"modified_method":"public void destroy() throws Exception {\n        // we let CamelContext manage the lifecycle of the producer and shut it down when Camel stops\n    }","commit_id":"342c21829ba595ff8927fd134d8a6aab8c691972","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void afterPropertiesSet() {\n        if (endpoint == null) {\n            if (ObjectHelper.isNotEmpty(camelContextId)) {\n                camelContext = CamelContextResolverHelper.getCamelContextWithId(applicationContext, camelContextId);\n            }\n            if (camelContext == null) {\n                throw new IllegalArgumentException(\"camelContext or camelContextId must be specified\");\n            }\n            \n            if (getServiceUrl() == null && getServiceRef() == null) {\n                throw new IllegalArgumentException(\"serviceUrl or serviceRef must be specified.\");\n            }\n\n            // lookup endpoint or we have the url for it\n            if (getServiceRef() != null) {\n                endpoint = camelContext.getRegistry().lookupByNameAndType(getServiceRef(), Endpoint.class);\n            } else {\n                endpoint = camelContext.getEndpoint(getServiceUrl());\n            }\n\n            if (endpoint == null) {\n                throw new IllegalArgumentException(\"Could not resolve endpoint: \" + getServiceUrl());\n            }\n        }\n\n        // binding is enabled by default\n        boolean bind = getBinding() != null ? getBinding() : true;\n\n        try {\n            producer = endpoint.createProducer();\n            ServiceHelper.startService(producer);\n            serviceProxy = ProxyHelper.createProxy(endpoint, bind, producer, getServiceInterface());\n        } catch (Exception e) {\n            throw new FailedToCreateProducerException(endpoint, e);\n        }\n    }","id":102963,"modified_method":"@Override\n    public void afterPropertiesSet() {\n        if (endpoint == null) {\n            if (ObjectHelper.isNotEmpty(camelContextId)) {\n                camelContext = CamelContextResolverHelper.getCamelContextWithId(applicationContext, camelContextId);\n            }\n            if (camelContext == null) {\n                throw new IllegalArgumentException(\"camelContext or camelContextId must be specified\");\n            }\n            \n            if (getServiceUrl() == null && getServiceRef() == null) {\n                throw new IllegalArgumentException(\"serviceUrl or serviceRef must be specified.\");\n            }\n\n            // lookup endpoint or we have the url for it\n            if (getServiceRef() != null) {\n                endpoint = camelContext.getRegistry().lookupByNameAndType(getServiceRef(), Endpoint.class);\n            } else {\n                endpoint = camelContext.getEndpoint(getServiceUrl());\n            }\n\n            if (endpoint == null) {\n                throw new IllegalArgumentException(\"Could not resolve endpoint: \" + getServiceUrl());\n            }\n        }\n\n        // binding is enabled by default\n        boolean bind = getBinding() != null ? getBinding() : true;\n\n        try {\n            // need to start endpoint before we create producer\n            ServiceHelper.startService(endpoint);\n            producer = endpoint.createProducer();\n            // add and start producer\n            camelContext.addService(producer, true, true);\n            serviceProxy = ProxyHelper.createProxy(endpoint, bind, producer, getServiceInterface());\n        } catch (Exception e) {\n            throw new FailedToCreateProducerException(endpoint, e);\n        }\n    }","commit_id":"342c21829ba595ff8927fd134d8a6aab8c691972","url":"https://github.com/apache/camel"},{"original_method":"public void destroy() throws Exception {\n        ServiceHelper.stopService(producer);\n    }","id":102964,"modified_method":"public void destroy() throws Exception {\n        // we let CamelContext manage the lifecycle of the producer and shut it down when Camel stops\n    }","commit_id":"342c21829ba595ff8927fd134d8a6aab8c691972","url":"https://github.com/apache/camel"},{"original_method":"public void afterPropertiesSet() throws Exception {\n        if (endpoint == null) {\n            getCamelContext();\n            if (getServiceUrl() == null && getServiceRef() == null) {\n                throw new IllegalArgumentException(\"serviceUrl or serviceRef must be specified.\");\n            }\n            if (getServiceInterface() == null) {\n                throw new IllegalArgumentException(\"serviceInterface must be specified.\");\n            }\n\n            // lookup endpoint or we have the url for it\n            if (getServiceRef() != null) {\n                endpoint = getCamelContext().getRegistry().lookupByNameAndType(getServiceRef(), Endpoint.class);\n            } else {\n                endpoint = getCamelContext().getEndpoint(getServiceUrl());\n            }\n\n            if (endpoint == null) {\n                throw new IllegalArgumentException(\"Could not resolve endpoint: \" + getServiceUrl());\n            }\n        }\n\n        // binding is enabled by default\n        boolean bind = getBinding() != null ? getBinding() : true;\n\n        try {\n            producer = endpoint.createProducer();\n            ServiceHelper.startService(producer);\n            Class<?> clazz = blueprintContainer.loadClass(getServiceInterface());\n            serviceProxy = ProxyHelper.createProxy(endpoint, bind, producer, clazz);\n        } catch (Exception e) {\n            throw new FailedToCreateProducerException(endpoint, e);\n        }\n    }","id":102965,"modified_method":"public void afterPropertiesSet() throws Exception {\n        if (endpoint == null) {\n            getCamelContext();\n            if (getServiceUrl() == null && getServiceRef() == null) {\n                throw new IllegalArgumentException(\"serviceUrl or serviceRef must be specified.\");\n            }\n            if (getServiceInterface() == null) {\n                throw new IllegalArgumentException(\"serviceInterface must be specified.\");\n            }\n\n            // lookup endpoint or we have the url for it\n            if (getServiceRef() != null) {\n                endpoint = getCamelContext().getRegistry().lookupByNameAndType(getServiceRef(), Endpoint.class);\n            } else {\n                endpoint = getCamelContext().getEndpoint(getServiceUrl());\n            }\n\n            if (endpoint == null) {\n                throw new IllegalArgumentException(\"Could not resolve endpoint: \" + getServiceUrl());\n            }\n        }\n\n        // binding is enabled by default\n        boolean bind = getBinding() != null ? getBinding() : true;\n\n        try {\n            // need to start endpoint before we create producer\n            ServiceHelper.startService(endpoint);\n            producer = endpoint.createProducer();\n            // add and start producer\n            getCamelContext().addService(producer, true, true);\n            Class<?> clazz = blueprintContainer.loadClass(getServiceInterface());\n            serviceProxy = ProxyHelper.createProxy(endpoint, bind, producer, clazz);\n        } catch (Exception e) {\n            throw new FailedToCreateProducerException(endpoint, e);\n        }\n    }","commit_id":"342c21829ba595ff8927fd134d8a6aab8c691972","url":"https://github.com/apache/camel"},{"original_method":"public void destroy() throws Exception {\n        ServiceHelper.startService(consumer);\n    }","id":102966,"modified_method":"public void destroy() throws Exception {\n        // we let CamelContext manage the lifecycle of the consumer and shut it down when Camel stops\n    }","commit_id":"342c21829ba595ff8927fd134d8a6aab8c691972","url":"https://github.com/apache/camel"},{"original_method":"public void afterPropertiesSet() throws Exception {\n        // lets bind the URI to a pojo\n        notNull(uri, \"uri\");\n        // Always resolve the camel context by using the camelContextID\n        if (ObjectHelper.isNotEmpty(camelContextId)) {\n            camelContext = CamelContextResolverHelper.getCamelContextWithId(applicationContext, camelContextId);\n        }\n        notNull(camelContext, \"camelContext\");\n        if (serviceRef != null && getService() == null && applicationContext != null) {\n            setService(applicationContext.getBean(serviceRef));\n        }\n\n        Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(camelContext, uri);\n        notNull(getService(), \"service\");\n        Object proxy = getProxyForService();\n\n        consumer = endpoint.createConsumer(new BeanProcessor(proxy, camelContext));\n        ServiceHelper.startService(consumer);\n    }","id":102967,"modified_method":"public void afterPropertiesSet() throws Exception {\n        // lets bind the URI to a pojo\n        notNull(uri, \"uri\");\n        // Always resolve the camel context by using the camelContextID\n        if (ObjectHelper.isNotEmpty(camelContextId)) {\n            camelContext = CamelContextResolverHelper.getCamelContextWithId(applicationContext, camelContextId);\n        }\n        notNull(camelContext, \"camelContext\");\n        if (serviceRef != null && getService() == null && applicationContext != null) {\n            setService(applicationContext.getBean(serviceRef));\n        }\n\n        Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(camelContext, uri);\n        notNull(getService(), \"service\");\n        Object proxy = getProxyForService();\n\n        try {\n            // need to start endpoint before we create consumer\n            ServiceHelper.startService(endpoint);\n            consumer = endpoint.createConsumer(new BeanProcessor(proxy, camelContext));\n            // add and start consumer\n            camelContext.addService(consumer, true, true);\n        } catch (Exception e) {\n            throw new FailedToCreateConsumerException(endpoint, e);\n        }\n    }","commit_id":"342c21829ba595ff8927fd134d8a6aab8c691972","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testRemoting() throws Exception {\n        ISay proxy = applicationContext.getBean(\"sayProxy\", ISay.class);\n        String rc = proxy.say();\n        assertEquals(\"Hello\", rc);\n    }","id":102968,"modified_method":"@Test\n    public void testRemoting() throws Exception {\n        ISay proxy = applicationContext.getBean(\"sayProxy\", ISay.class);\n        String rc = proxy.say(\"Camel\");\n        assertEquals(\"Hello Camel\", rc);\n    }","commit_id":"342c21829ba595ff8927fd134d8a6aab8c691972","url":"https://github.com/apache/camel"},{"original_method":"public void move(XmldbURI collectionPath, XmldbURI destinationPath,\n            XmldbURI newName) throws XMLDBException {\n    \tcollectionPath = parent.getPathURI().resolveCollectionPath(collectionPath);\n    \tdestinationPath = parent.getPathURI().resolveCollectionPath(destinationPath);\n    \t\n        TransactionManager transact = brokerPool.getTransactionManager();\n        Txn transaction = transact.beginTransaction();\n        DBBroker broker = null;\n        org.exist.collections.Collection collection = null;\n        org.exist.collections.Collection destination = null;\n        try {\n            broker = brokerPool.get(user);\n            collection = broker.openCollection(collectionPath, Lock.WRITE_LOCK);\n            if(collection == null) {\n                transact.abort(transaction);\n                throw new XMLDBException(ErrorCodes.NO_SUCH_COLLECTION, \"Collection \" + collectionPath + \" not found\");\n            }\n            destination = broker.openCollection(destinationPath, Lock.WRITE_LOCK);\n            if(destination == null) {\n                transact.abort(transaction);\n                throw new XMLDBException(ErrorCodes.NO_SUCH_COLLECTION, \"Collection \" + destinationPath + \" not found\");\n            }\n            if (newName == null)\n                newName = collectionPath.lastSegment();\n            broker.moveCollection(transaction, collection, destination, newName);\n            transact.commit(transaction);\n        } catch ( EXistException e ) {\n            transact.abort(transaction);\n        \te.printStackTrace();\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                \"failed to move collection \" + collectionPath, e );\n        } catch ( PermissionDeniedException e ) {\n            transact.abort(transaction);\n            throw new XMLDBException( ErrorCodes.PERMISSION_DENIED,\n                e.getMessage(), e );\n        } catch (LockException e) {\n            transact.abort(transaction);\n            throw new XMLDBException( ErrorCodes.PERMISSION_DENIED,\n                    e.getMessage(), e );\n        } finally {\n        \tif(destination != null)\n        \t\tdestination.release();\n        \tif(collection != null)\n        \t\tcollection.release();\n            brokerPool.release( broker );\n        }\n    }","id":102969,"modified_method":"public void move(XmldbURI collectionPath, XmldbURI destinationPath,\n            XmldbURI newName) throws XMLDBException {\n    \tcollectionPath = parent.getPathURI().resolveCollectionPath(collectionPath);\n    \tdestinationPath = destinationPath == null ? collectionPath.removeLastSegment() : parent.getPathURI().resolveCollectionPath(destinationPath);\n    \t\n        TransactionManager transact = brokerPool.getTransactionManager();\n        Txn transaction = transact.beginTransaction();\n        DBBroker broker = null;\n        org.exist.collections.Collection collection = null;\n        org.exist.collections.Collection destination = null;\n        try {\n            broker = brokerPool.get(user);\n            collection = broker.openCollection(collectionPath, Lock.WRITE_LOCK);\n            if(collection == null) {\n                transact.abort(transaction);\n                throw new XMLDBException(ErrorCodes.NO_SUCH_COLLECTION, \"Collection \" + collectionPath + \" not found\");\n            }\n            destination = broker.openCollection(destinationPath, Lock.WRITE_LOCK);\n            if(destination == null) {\n                transact.abort(transaction);\n                throw new XMLDBException(ErrorCodes.NO_SUCH_COLLECTION, \"Collection \" + destinationPath + \" not found\");\n            }\n            if (newName == null)\n                newName = collectionPath.lastSegment();\n            broker.moveCollection(transaction, collection, destination, newName);\n            transact.commit(transaction);\n        } catch ( EXistException e ) {\n            transact.abort(transaction);\n        \te.printStackTrace();\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                \"failed to move collection \" + collectionPath, e );\n        } catch ( PermissionDeniedException e ) {\n            transact.abort(transaction);\n            throw new XMLDBException( ErrorCodes.PERMISSION_DENIED,\n                e.getMessage(), e );\n        } catch (LockException e) {\n            transact.abort(transaction);\n            throw new XMLDBException( ErrorCodes.PERMISSION_DENIED,\n                    e.getMessage(), e );\n        } finally {\n        \tif(destination != null)\n        \t\tdestination.release();\n        \tif(collection != null)\n        \t\tcollection.release();\n            brokerPool.release( broker );\n        }\n    }","commit_id":"052239708f337cb83d40dbf17a4b7296abfc65c2","url":"https://github.com/eXist-db/exist"},{"original_method":"public void copyResource(XmldbURI resourcePath, XmldbURI destinationPath, XmldbURI newName) \n    \t\tthrows XMLDBException { \n    \tresourcePath = parent.getPathURI().resolveCollectionPath(resourcePath);\n    \tdestinationPath = parent.getPathURI().resolveCollectionPath(destinationPath);\n\n\t\tTransactionManager transact = brokerPool.getTransactionManager();\n        Txn transaction = transact.beginTransaction();\n        DBBroker broker = null;\n        org.exist.collections.Collection destination = null;\n        org.exist.collections.Collection source = null;\n        try {\n            broker = brokerPool.get(user);\n     \t\tsource = broker.openCollection(resourcePath.removeLastSegment(), Lock.WRITE_LOCK);\n    \t\tif(source == null) {\n                transact.abort(transaction);\n    \t\t\tthrow new XMLDBException(ErrorCodes.INVALID_COLLECTION, \"Collection \" + resourcePath.removeLastSegment() + \" not found\");\n            }\n    \t\tDocumentImpl doc = source.getDocument(broker, resourcePath.lastSegment());\n            if(doc == null) {\n                transact.abort(transaction);\n                throw new XMLDBException(ErrorCodes.NO_SUCH_RESOURCE, \"Resource \" + resourcePath + \" not found\");\n            }\n            destination = broker.openCollection(destinationPath, Lock.WRITE_LOCK);\n            if(destination == null) {\n                transact.abort(transaction);\n                throw new XMLDBException(ErrorCodes.NO_SUCH_COLLECTION, \"Collection \" + destinationPath + \" not found\");\n            }\n            broker.copyXMLResource(transaction, doc, destination, newName);\n            transact.commit(transaction);\n        } catch ( EXistException e ) {\n            transact.abort(transaction);\n        \te.printStackTrace();\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                \"failed to move resource \" + resourcePath, e );\n        } catch ( PermissionDeniedException e ) {\n            transact.abort(transaction);\n            throw new XMLDBException( ErrorCodes.PERMISSION_DENIED,\n                e.getMessage(), e );\n        } catch (LockException e) {\n            transact.abort(transaction);\n            throw new XMLDBException( ErrorCodes.PERMISSION_DENIED,\n                    e.getMessage(), e );\n        } finally {\n        \tif(source != null) source.release();\n        \tif(destination != null) destination.release();\n            brokerPool.release( broker );\n        }\n\t}","id":102970,"modified_method":"public void copyResource(XmldbURI resourcePath, XmldbURI destinationPath, XmldbURI newName) \n    \t\tthrows XMLDBException { \n    \tresourcePath = parent.getPathURI().resolveCollectionPath(resourcePath);\n\n    \tif (destinationPath == null)\n\t    destinationPath = resourcePath.removeLastSegment();\n    \telse\n\t    destinationPath = parent.getPathURI().resolveCollectionPath(destinationPath);\t\n    \n    TransactionManager transact = brokerPool.getTransactionManager();\n        Txn transaction = transact.beginTransaction();\n        DBBroker broker = null;\n        org.exist.collections.Collection destination = null;\n        org.exist.collections.Collection source = null;\n        try {\n            broker = brokerPool.get(user);\n     \t\tsource = broker.openCollection(resourcePath.removeLastSegment(), Lock.WRITE_LOCK);\n    \t\tif(source == null) {\n                transact.abort(transaction);\n    \t\t\tthrow new XMLDBException(ErrorCodes.INVALID_COLLECTION, \"Collection \" + resourcePath.removeLastSegment() + \" not found\");\n            }\n    \t\tDocumentImpl doc = source.getDocument(broker, resourcePath.lastSegment());\n            if(doc == null) {\n                transact.abort(transaction);\n                throw new XMLDBException(ErrorCodes.NO_SUCH_RESOURCE, \"Resource \" + resourcePath + \" not found\");\n            }\n            destination = broker.openCollection(destinationPath, Lock.WRITE_LOCK);\n            if(destination == null) {\n                transact.abort(transaction);\n                throw new XMLDBException(ErrorCodes.NO_SUCH_COLLECTION, \"Collection \" + destinationPath + \" not found\");\n            }\n\t    if (newName == null) {\n\t\tnewName = resourcePath.lastSegment();\n\t    }\n            broker.copyXMLResource(transaction, doc, destination, newName);\n            transact.commit(transaction);\n        } catch ( EXistException e ) {\n            transact.abort(transaction);\n        \te.printStackTrace();\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                \"failed to move resource \" + resourcePath, e );\n        } catch ( PermissionDeniedException e ) {\n            transact.abort(transaction);\n            throw new XMLDBException( ErrorCodes.PERMISSION_DENIED,\n                e.getMessage(), e );\n        } catch (LockException e) {\n            transact.abort(transaction);\n            throw new XMLDBException( ErrorCodes.PERMISSION_DENIED,\n                    e.getMessage(), e );\n        } finally {\n        \tif(source != null) source.release();\n        \tif(destination != null) destination.release();\n            brokerPool.release( broker );\n        }\n\t}","commit_id":"052239708f337cb83d40dbf17a4b7296abfc65c2","url":"https://github.com/eXist-db/exist"},{"original_method":"public void copy(XmldbURI collectionPath, XmldbURI destinationPath,\n            XmldbURI newName) throws XMLDBException {\n    \tcollectionPath = parent.getPathURI().resolveCollectionPath(collectionPath);\n    \tdestinationPath = parent.getPathURI().resolveCollectionPath(destinationPath);\n\n        System.out.println(\"Copying '\" + collectionPath + \"' to '\" + destinationPath + \"' as '\" + newName + \"'\");\n        TransactionManager transact = brokerPool.getTransactionManager();\n        Txn transaction = transact.beginTransaction();\n        DBBroker broker = null;\n        org.exist.collections.Collection collection = null;\n        org.exist.collections.Collection destination = null;\n        try {\n            broker = brokerPool.get(user);\n            collection = broker.openCollection(collectionPath, Lock.READ_LOCK);\n            if(collection == null) {\n                transact.abort(transaction);\n                throw new XMLDBException(ErrorCodes.NO_SUCH_COLLECTION, \"Collection '\" + collectionPath + \"' not found\");\n            }\n            destination = broker.openCollection(destinationPath, Lock.WRITE_LOCK);\n            if(destination == null) {\n                transact.abort(transaction);\n                throw new XMLDBException(ErrorCodes.NO_SUCH_COLLECTION, \"Collection '\" + destinationPath + \"' not found\");\n            }\n            broker.copyCollection(transaction, collection, destination, newName);\n            transact.commit(transaction);\n        } catch ( EXistException e ) {\n            transact.abort(transaction);\n        \te.printStackTrace();\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                \"failed to move collection \" + collectionPath, e );\n        } catch ( PermissionDeniedException e ) {\n            transact.abort(transaction);\n            throw new XMLDBException( ErrorCodes.PERMISSION_DENIED,\n                e.getMessage(), e );\n        } catch (LockException e) {\n            transact.abort(transaction);\n            throw new XMLDBException( ErrorCodes.PERMISSION_DENIED,\n                    e.getMessage(), e );\n        } finally {\n        \tif(collection != null) collection.release();\n        \tif(destination != null) destination.release();\n            brokerPool.release( broker );\n        }\n\t}","id":102971,"modified_method":"public void copy(XmldbURI collectionPath, XmldbURI destinationPath,\n            XmldbURI newName) throws XMLDBException {\n    \tcollectionPath = parent.getPathURI().resolveCollectionPath(collectionPath);\n    \tdestinationPath = destinationPath == null ? collectionPath.removeLastSegment() : parent.getPathURI().resolveCollectionPath(destinationPath);\n\n        TransactionManager transact = brokerPool.getTransactionManager();\n        Txn transaction = transact.beginTransaction();\n        DBBroker broker = null;\n        org.exist.collections.Collection collection = null;\n        org.exist.collections.Collection destination = null;\n        try {\n            broker = brokerPool.get(user);\n            collection = broker.openCollection(collectionPath, Lock.READ_LOCK);\n            if(collection == null) {\n                transact.abort(transaction);\n                throw new XMLDBException(ErrorCodes.NO_SUCH_COLLECTION, \"Collection '\" + collectionPath + \"' not found\");\n            }\n            destination = broker.openCollection(destinationPath, Lock.WRITE_LOCK);\n            if(destination == null) {\n                transact.abort(transaction);\n                throw new XMLDBException(ErrorCodes.NO_SUCH_COLLECTION, \"Collection '\" + destinationPath + \"' not found\");\n            }\n\t    if (newName == null) {\n\t\tnewName = collectionPath.lastSegment();\n\t    }\n            broker.copyCollection(transaction, collection, destination, newName);\n            transact.commit(transaction);\n        } catch ( EXistException e ) {\n            transact.abort(transaction);\n        \te.printStackTrace();\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                \"failed to move collection \" + collectionPath, e );\n        } catch ( PermissionDeniedException e ) {\n            transact.abort(transaction);\n            throw new XMLDBException( ErrorCodes.PERMISSION_DENIED,\n                e.getMessage(), e );\n        } catch (LockException e) {\n            transact.abort(transaction);\n            throw new XMLDBException( ErrorCodes.PERMISSION_DENIED,\n                    e.getMessage(), e );\n        } finally {\n        \tif(collection != null) collection.release();\n        \tif(destination != null) destination.release();\n            brokerPool.release( broker );\n        }\n\t}","commit_id":"052239708f337cb83d40dbf17a4b7296abfc65c2","url":"https://github.com/eXist-db/exist"},{"original_method":"public void copyResource(String resourcePath, String destinationPath,\n            String newName) throws XMLDBException {\n    \ttry{\n    \t\tmove(XmldbURI.xmldbUriFor(resourcePath), XmldbURI.xmldbUriFor(destinationPath),XmldbURI.xmldbUriFor(newName));\n    \t} catch(URISyntaxException e) {\n    \t\tthrow new XMLDBException(ErrorCodes.INVALID_URI,e);\n    \t}\n    }","id":102972,"modified_method":"public void copyResource(String resourcePath, String destinationPath,\n            String newName) throws XMLDBException {\n    \ttry{\n    \t\tcopyResource(XmldbURI.xmldbUriFor(resourcePath), XmldbURI.xmldbUriFor(destinationPath),XmldbURI.xmldbUriFor(newName));\n    \t} catch(URISyntaxException e) {\n    \t\tthrow new XMLDBException(ErrorCodes.INVALID_URI,e);\n    \t}\n    }","commit_id":"7af7988ace8a25d73835a6205e8cf15ebac8acbc","url":"https://github.com/eXist-db/exist"},{"original_method":"public void move(XmldbURI collectionPath, XmldbURI destinationPath,\n            XmldbURI newName) throws XMLDBException {\n    \tcollectionPath = parent.getPathURI().resolveCollectionPath(collectionPath);\n    \tdestinationPath = parent.getPathURI().resolveCollectionPath(destinationPath);\n    \t\n        if(newName == null) {\n            newName = collectionPath.lastSegment();\n        }\n        Vector params = new Vector();\n        params.addElement( collectionPath.toString() );\n        params.addElement( destinationPath.toString() );\n        params.addElement( newName.toString() );\n        try {\n            client.execute( \"moveCollection\", params );\n        } catch ( XmlRpcException xre ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                xre.getMessage(),\n                xre );\n        } catch ( IOException ioe ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                ioe.getMessage(),\n                ioe);\n        }\n    }","id":102973,"modified_method":"public void move(XmldbURI collectionPath, XmldbURI destinationPath,\n            XmldbURI newName) throws XMLDBException {\n    \tcollectionPath = parent.getPathURI().resolveCollectionPath(collectionPath);\n    \tdestinationPath = destinationPath == null ? collectionPath.removeLastSegment() : parent.getPathURI().resolveCollectionPath(destinationPath);\n    \t\n        if(newName == null) {\n            newName = collectionPath.lastSegment();\n        }\n        Vector params = new Vector();\n        params.addElement( collectionPath.toString() );\n        params.addElement( destinationPath.toString() );\n        params.addElement( newName.toString() );\n        try {\n            client.execute( \"moveCollection\", params );\n        } catch ( XmlRpcException xre ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                xre.getMessage(),\n                xre );\n        } catch ( IOException ioe ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                ioe.getMessage(),\n                ioe);\n        }\n    }","commit_id":"7af7988ace8a25d73835a6205e8cf15ebac8acbc","url":"https://github.com/eXist-db/exist"},{"original_method":"public void copy(String collectionPath, String destinationPath,\n            String newName) throws XMLDBException {\n    \ttry{\n    \t\tmove(XmldbURI.xmldbUriFor(collectionPath), XmldbURI.xmldbUriFor(destinationPath),XmldbURI.xmldbUriFor(newName));\n    \t} catch(URISyntaxException e) {\n    \t\tthrow new XMLDBException(ErrorCodes.INVALID_URI,e);\n    \t}\n    }","id":102974,"modified_method":"public void copy(String collectionPath, String destinationPath,\n            String newName) throws XMLDBException {\n    \ttry{\n    \t\tcopy(XmldbURI.xmldbUriFor(collectionPath), XmldbURI.xmldbUriFor(destinationPath),XmldbURI.xmldbUriFor(newName));\n    \t} catch(URISyntaxException e) {\n    \t\tthrow new XMLDBException(ErrorCodes.INVALID_URI,e);\n    \t}\n    }","commit_id":"7af7988ace8a25d73835a6205e8cf15ebac8acbc","url":"https://github.com/eXist-db/exist"},{"original_method":"public void copy(XmldbURI collectionPath, XmldbURI destinationPath,\n            XmldbURI newName) throws XMLDBException {\n    \tcollectionPath = parent.getPathURI().resolveCollectionPath(collectionPath);\n    \tdestinationPath = parent.getPathURI().resolveCollectionPath(destinationPath);\n        if(newName == null) {\n            newName = collectionPath.lastSegment();\n        }\n\n        Vector params = new Vector();\n        params.addElement( collectionPath.toString() );\n        params.addElement( destinationPath.toString() );\n        params.addElement( newName.toString() );\n        try {\n            client.execute( \"copyCollection\", params );\n        } catch ( XmlRpcException xre ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                xre.getMessage(),\n                xre );\n        } catch ( IOException ioe ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                ioe.getMessage(),\n                ioe);\n        }\n\t}","id":102975,"modified_method":"public void copy(XmldbURI collectionPath, XmldbURI destinationPath,\n            XmldbURI newName) throws XMLDBException {\n    \tcollectionPath = parent.getPathURI().resolveCollectionPath(collectionPath);\n    \tdestinationPath = destinationPath == null ? collectionPath.removeLastSegment() : parent.getPathURI().resolveCollectionPath(destinationPath);\n\n        if(newName == null) {\n            newName = collectionPath.lastSegment();\n        }\n\n        Vector params = new Vector();\n        params.addElement( collectionPath.toString() );\n        params.addElement( destinationPath.toString() );\n        params.addElement( newName.toString() );\n        try {\n            client.execute( \"copyCollection\", params );\n        } catch ( XmlRpcException xre ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                xre.getMessage(),\n                xre );\n        } catch ( IOException ioe ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                ioe.getMessage(),\n                ioe);\n        }\n\t}","commit_id":"7af7988ace8a25d73835a6205e8cf15ebac8acbc","url":"https://github.com/eXist-db/exist"},{"original_method":"public void copyResource(XmldbURI resourcePath, XmldbURI destinationPath, XmldbURI newName) \n    \t\tthrows XMLDBException { \n    \tresourcePath = parent.getPathURI().resolveCollectionPath(resourcePath);\n    \tdestinationPath = parent.getPathURI().resolveCollectionPath(destinationPath);\n        if(newName == null) {\n            newName = resourcePath.lastSegment();\n        }\n        Vector params = new Vector();\n        params.addElement( resourcePath.toString() );\n        params.addElement( destinationPath.toString() );\n        params.addElement( newName.toString() );\n        try {\n            client.execute( \"copyResource\", params );\n        } catch ( XmlRpcException xre ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                xre.getMessage(),\n                xre );\n        } catch ( IOException ioe ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                ioe.getMessage(),\n                ioe);\n        }\n    }","id":102976,"modified_method":"public void copyResource(XmldbURI resourcePath, XmldbURI destinationPath, XmldbURI newName) \n    \t\tthrows XMLDBException { \n    \tresourcePath = parent.getPathURI().resolveCollectionPath(resourcePath);\n    \tif (destinationPath == null)\n\t    destinationPath = resourcePath.removeLastSegment();\n    \telse\n\t    destinationPath = parent.getPathURI().resolveCollectionPath(destinationPath);\n        if(newName == null) {\n            newName = resourcePath.lastSegment();\n        }\n        Vector params = new Vector();\n        params.addElement( resourcePath.toString() );\n        params.addElement( destinationPath.toString() );\n        params.addElement( newName.toString() );\n        try {\n            client.execute( \"copyResource\", params );\n        } catch ( XmlRpcException xre ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                xre.getMessage(),\n                xre );\n        } catch ( IOException ioe ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                ioe.getMessage(),\n                ioe);\n        }\n    }","commit_id":"7af7988ace8a25d73835a6205e8cf15ebac8acbc","url":"https://github.com/eXist-db/exist"},{"original_method":"public void moveResource(XmldbURI resourcePath, XmldbURI destinationPath, XmldbURI newName) \n    \t\tthrows XMLDBException { \n    \tresourcePath = parent.getPathURI().resolveCollectionPath(resourcePath);\n    \tdestinationPath = parent.getPathURI().resolveCollectionPath(destinationPath);\n        if(newName == null) {\n            newName = resourcePath.lastSegment();\n        }\n\n        Vector params = new Vector();\n        params.addElement( resourcePath.toString() );\n        params.addElement( destinationPath.toString() );\n        params.addElement( newName.toString() );\n        try {\n            client.execute( \"moveResource\", params );\n        } catch ( XmlRpcException xre ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                xre.getMessage(),\n                xre );\n        } catch ( IOException ioe ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                ioe.getMessage(),\n                ioe);\n        }\n    }","id":102977,"modified_method":"public void moveResource(XmldbURI resourcePath, XmldbURI destinationPath, XmldbURI newName) \n    \t\tthrows XMLDBException { \n    \tresourcePath = parent.getPathURI().resolveCollectionPath(resourcePath);\n\tif (destinationPath == null)\n\t    destinationPath = resourcePath.removeLastSegment();\n    \telse\n\t    destinationPath = parent.getPathURI().resolveCollectionPath(destinationPath);\n        if(newName == null) {\n            newName = resourcePath.lastSegment();\n        }\n\n        Vector params = new Vector();\n        params.addElement( resourcePath.toString() );\n        params.addElement( destinationPath.toString() );\n        params.addElement( newName.toString() );\n        try {\n            client.execute( \"moveResource\", params );\n        } catch ( XmlRpcException xre ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                xre.getMessage(),\n                xre );\n        } catch ( IOException ioe ) {\n            throw new XMLDBException( ErrorCodes.VENDOR_ERROR,\n                ioe.getMessage(),\n                ioe);\n        }\n    }","commit_id":"7af7988ace8a25d73835a6205e8cf15ebac8acbc","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Create a manifest\n     */\n    private void createManifest(final java.util.jar.Manifest manifest) throws MojoExecutionException {\n        // create a new manifest\n        final Manifest outManifest = new Manifest();\n\n        try {\n            boolean hasMain = false;\n\n            // copy entries from existing manifest\n            if ( manifest != null ) {\n                final Map<Object, Object> attrs = manifest.getMainAttributes();\n                for(final Map.Entry<Object, Object> entry : attrs.entrySet()) {\n                    final String key = entry.getKey().toString();\n                    if ( !BuildConstants.ATTRS_EXCLUDES.contains(key)) {\n                        final Attribute a = new Attribute(key, entry.getValue().toString());\n                        outManifest.addConfiguredAttribute(a);\n                    }\n                    if ( key.equals(BuildConstants.ATTR_MAIN_CLASS) ) {\n                        hasMain = true;\n                    }\n                }\n            }\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_IMPLEMENTATION_BUILD,\n                            project.getVersion()));\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_IMPLEMENTATION_VENDOR,\n                            project.getOrganization().getName()));\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_IMPLEMENTATION_VERSION,\n                            project.getVersion()));\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_CREATED_BY,\n                            project.getOrganization().getName()));\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_BUILT_BY,\n                            project.getOrganization().getName()));\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_IMPLEMENTATION_VENDOR_ID,\n                            project.getGroupId()));\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_IMPLEMENTATION_TITLE,\n                            project.getName()));\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_SPECIFICATION_TITLE,\n                            project.getName()));\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_SPECIFICATION_VENDOR,\n                            project.getOrganization().getName()));\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_SPECIFICATION_VERSION,\n                            project.getVersion()));\n\n            if ( archiver.getDestFile().getName().endsWith(\".jar\") && !hasMain) {\n                outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_MAIN_CLASS,\n                                BuildConstants.ATTR_VALUE_MAIN_CLASS));\n            }\n\n            archiver.addConfiguredManifest(outManifest);\n        } catch (final ManifestException e) {\n            throw new MojoExecutionException(\"Unable to create manifest for \" + this.archiver.getDestFile(), e);\n        }\n    }","id":102978,"modified_method":"/**\n     * Create a manifest\n     */\n    private void createManifest(final java.util.jar.Manifest manifest) throws MojoExecutionException {\n        // create a new manifest\n        final Manifest outManifest = new Manifest();\n\n        try {\n            boolean hasMain = false;\n\n            // copy entries from existing manifest\n            if ( manifest != null ) {\n                final Map<Object, Object> attrs = manifest.getMainAttributes();\n                for(final Map.Entry<Object, Object> entry : attrs.entrySet()) {\n                    final String key = entry.getKey().toString();\n                    if ( !BuildConstants.ATTRS_EXCLUDES.contains(key)) {\n                        final Attribute a = new Attribute(key, entry.getValue().toString());\n                        outManifest.addConfiguredAttribute(a);\n                    }\n                    if ( key.equals(BuildConstants.ATTR_MAIN_CLASS) ) {\n                        hasMain = true;\n                    }\n                }\n            }\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_IMPLEMENTATION_BUILD,\n                            project.getVersion()));\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_IMPLEMENTATION_VERSION,\n                            project.getVersion()));\n\n            String organizationName = project.getOrganization() != null ? project.getOrganization().getName() : null;\n            if ( organizationName != null ) {\n                outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_IMPLEMENTATION_VENDOR,\n                            organizationName));\n                outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_CREATED_BY,\n                            organizationName));\n                outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_BUILT_BY,\n                            organizationName));\n                outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_SPECIFICATION_VENDOR,\n                        organizationName));\n            }\n\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_IMPLEMENTATION_VENDOR_ID,\n                            project.getGroupId()));\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_IMPLEMENTATION_TITLE,\n                            project.getName()));\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_SPECIFICATION_TITLE,\n                            project.getName()));\n            outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_SPECIFICATION_VERSION,\n                            project.getVersion()));\n\n            if ( archiver.getDestFile().getName().endsWith(\".jar\") && !hasMain) {\n                outManifest.addConfiguredAttribute(new Attribute(BuildConstants.ATTR_MAIN_CLASS,\n                                BuildConstants.ATTR_VALUE_MAIN_CLASS));\n            }\n\n            archiver.addConfiguredManifest(outManifest);\n        } catch (final ManifestException e) {\n            throw new MojoExecutionException(\"Unable to create manifest for \" + this.archiver.getDestFile(), e);\n        }\n    }","commit_id":"317a29a4cbcc475f220640d8789da8c9d11a8bd6","url":"https://github.com/apache/sling"},{"original_method":"/**\n   * Authenticates User with the Credentials passed\n   *\n   * @param credentials UserCredentials that authenticates the user\n   * @return {@code AuthenticationStatus}\n   * @throws {@code RetryException}\n   */\n  @Override\n  public AuthenticationStatus authenticate(Credentials credentials) throws RetryException {\n\n    UsernamePasswordApiKeyCredentials userCredentials = (UsernamePasswordApiKeyCredentials) credentials;\n\n    UsernamePasswordApiKeyToken token = new UsernamePasswordApiKeyToken(userCredentials.getUserName(),\n      userCredentials.getPassword(),\n      userCredentials.getApiKey());\n\n    try {\n      Subject currentUser = SecurityUtils.getSubject();\n      currentUser.login(token);\n      Account account = (Account) currentUser.getPrincipal();\n      return new AuthenticationStatus(AuthenticationStatus.Type.AUTHENTICATED, account.toString());\n    } catch (Exception e) {\n      return new AuthenticationStatus(AuthenticationStatus.Type.AUTHENTICATION_FAILED,\n        \"Authentication Failed. \" + e.getMessage());\n\n    }\n\n  }","id":102979,"modified_method":"/**\n   * Authenticates User with the Credentials passed\n   *\n   * @param credentials UserCredentials that authenticates the user\n   * @return {@code AuthenticationStatus}\n   * @throws {@code RetryException}\n   */\n  @Override\n  public AuthenticationStatus authenticate(Credentials credentials) throws RetryException {\n\n    UsernamePasswordApiKeyCredentials userCredentials = (UsernamePasswordApiKeyCredentials) credentials;\n\n    UsernamePasswordApiKeyToken token = new UsernamePasswordApiKeyToken(userCredentials.getUserName(),\n      userCredentials.getPassword(),\n      userCredentials.getApiKey());\n    Subject currentUser = null;\n\n    try {\n      currentUser = SecurityUtils.getSubject();\n      currentUser.login(token);\n      Account account = (Account) currentUser.getPrincipal();\n      return new AuthenticationStatus(AuthenticationStatus.Type.AUTHENTICATED, account.toString());\n    } catch (Exception e) {\n      return new AuthenticationStatus(AuthenticationStatus.Type.AUTHENTICATION_FAILED,\n        \"Authentication Failed. \" + e.getMessage());\n\n    }\n    finally {\n      if (currentUser != null) {\n        currentUser.logout();\n      }\n    }\n\n  }","commit_id":"85b12dcaf7d1a74253a433c011ad8ada80fbf8c2","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Retrieves the AuthorizationInfo for the given principals from the underlying data store.  When returning\n   * an instance from this method, you might want to consider using an instance of\n   * {@link org.apache.shiro.authz.SimpleAuthorizationInfo SimpleAuthorizationInfo}, as it is suitable in most cases.\n   *\n   * @param principals the primary identifying principals of the AuthorizationInfo that should be retrieved.\n   * @return the AuthorizationInfo associated with this principals.\n   * @see org.apache.shiro.authz.SimpleAuthorizationInfo\n   */\n  @Override\n  protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n    if (principals == null) {\n      throw new AuthorizationException(\"PrincipalCollection argument cannot be null\");\n    }\n\n    int accountId = (Integer) getAvailablePrincipal(principals);\n    Set<String> rolePermissions = null;\n    Set<String> roleNames = null;\n    SimpleAuthorizationInfo info = null;\n    try {\n      Connection connection = this.poolManager.getConnection();\n\n      String SQL = String.format(\"SELECT %s,%s,%s FROM %s JOIN %s ON %s = %s WHERE %s = ?\",\n\n        //SELECT COLS\n        DBUtils.AccountRoleType.TABLE_NAME + \".\" + DBUtils.AccountRoleType.ROLE_NAME_COLUMN,\n        DBUtils.AccountRoleType.TABLE_NAME + \".\" + DBUtils.AccountRoleType.PERMISSIONS_COLUMN,\n        DBUtils.VPCRole.TABLE_NAME + \".\" + DBUtils.VPCRole.ROLE_OVERRIDES_COLUMN,\n\n        //TABLE NAMES\n        DBUtils.AccountRoleType.TABLE_NAME, DBUtils.VPCRole.TABLE_NAME,\n\n        //JOIN CONDITION\n        DBUtils.AccountRoleType.TABLE_NAME + \".\" + DBUtils.AccountRoleType.ACCOUNT_ID_COLUMN,\n        DBUtils.VPCRole.TABLE_NAME + \".\" + DBUtils.VPCRole.ACCOUNT_ID_COLUMN,\n\n        //WHERE CLAUSE\n        DBUtils.VPCRole.USER_ID_COLUMN);\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n      ps.setInt(1, accountId);\n      ResultSet rs = ps.executeQuery();\n\n      while (rs.next()) {\n\n        String roleName = rs.getString(1);\n        String permissions = rs.getString(2);\n        String overrides = rs.getString(3);\n        if (overrides != null && !overrides.isEmpty()) {\n          rolePermissions.add(overrides);\n        } else {\n          rolePermissions.add(permissions);\n        }\n        roleNames.add(roleName);\n      }\n\n\n      info = new SimpleAuthorizationInfo(roleNames);\n      info.setStringPermissions(rolePermissions);\n\n    } catch (SQLException e) {\n      //TODO: Log and throw exception\n      e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n    }\n\n\n    return info;\n  }","id":102980,"modified_method":"/**\n   * Retrieves the AuthorizationInfo for the given principals from the underlying data store.  When returning\n   * an instance from this method, you might want to consider using an instance of\n   * {@link org.apache.shiro.authz.SimpleAuthorizationInfo SimpleAuthorizationInfo}, as it is suitable in most cases.\n   *\n   * @param principals the primary identifying principals of the AuthorizationInfo that should be retrieved.\n   * @return the AuthorizationInfo associated with this principals.\n   * @see org.apache.shiro.authz.SimpleAuthorizationInfo\n   */\n  @Override\n  protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n    if (principals == null) {\n      throw new AuthorizationException(\"PrincipalCollection argument cannot be null\");\n    }\n\n    Connection connection  = null;\n    PreparedStatement ps  = null;\n    ResultSet rs = null;\n    int accountId = (Integer) getAvailablePrincipal(principals);\n    Set<String> rolePermissions = null;\n    Set<String> roleNames = null;\n    SimpleAuthorizationInfo info = null;\n    try {\n       connection = this.poolManager.getConnection();\n\n      String SQL = String.format(\"SELECT %s,%s,%s FROM %s JOIN %s ON %s = %s WHERE %s = ?\",\n\n        //SELECT COLS\n        DBUtils.AccountRoleType.TABLE_NAME + \".\" + DBUtils.AccountRoleType.ROLE_NAME_COLUMN,\n        DBUtils.AccountRoleType.TABLE_NAME + \".\" + DBUtils.AccountRoleType.PERMISSIONS_COLUMN,\n        DBUtils.VPCRole.TABLE_NAME + \".\" + DBUtils.VPCRole.ROLE_OVERRIDES_COLUMN,\n\n        //TABLE NAMES\n        DBUtils.AccountRoleType.TABLE_NAME, DBUtils.VPCRole.TABLE_NAME,\n\n        //JOIN CONDITION\n        DBUtils.AccountRoleType.TABLE_NAME + \".\" + DBUtils.AccountRoleType.ACCOUNT_ID_COLUMN,\n        DBUtils.VPCRole.TABLE_NAME + \".\" + DBUtils.VPCRole.ACCOUNT_ID_COLUMN,\n\n        //WHERE CLAUSE\n        DBUtils.VPCRole.USER_ID_COLUMN);\n\n       ps = connection.prepareStatement(SQL);\n       ps.setInt(1, accountId);\n       rs = ps.executeQuery();\n\n      while (rs.next()) {\n\n        String roleName = rs.getString(1);\n        String permissions = rs.getString(2);\n        String overrides = rs.getString(3);\n        if (overrides != null && !overrides.isEmpty()) {\n          rolePermissions.add(overrides);\n        } else {\n          rolePermissions.add(permissions);\n        }\n        roleNames.add(roleName);\n      }\n\n\n      info = new SimpleAuthorizationInfo(roleNames);\n      info.setStringPermissions(rolePermissions);\n\n    } catch (SQLException e) {\n      return null;\n    }\n    finally {\n      try {\n        if (connection != null) {\n          connection.close();\n        }\n        if (ps != null) {\n          ps.close();\n        }\n        if (rs != null) {\n          rs.close();\n        }\n      } catch (SQLException e) {\n        throw new RuntimeException(e.getMessage(), e.getCause());\n      }\n    }\n\n\n    return info;\n  }","commit_id":"85b12dcaf7d1a74253a433c011ad8ada80fbf8c2","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Retrieves authentication data from RDBMS for the given authentication token.\n   * <p/>\n   * For most datasources, this means just 'pulling' authentication data for an associated subject/user and nothing\n   * more and letting Shiro do the rest.  But in some systems, this method could actually perform EIS specific\n   * log-in logic in addition to just retrieving data - it is up to the Realm implementation.\n   * <p/>\n   * A {@code null} return value means that no account could be associated with the specified token.\n   *\n   * @param token the authentication token containing the user's principal and credentials.\n   * @return an {@link org.apache.shiro.authc.AuthenticationInfo} object containing account data resulting from the\n   *         authentication ONLY if the lookup is successful (i.e. account exists and is valid, etc.)\n   * @throws org.apache.shiro.authc.AuthenticationException\n   *          if there is an error acquiring data or performing\n   *          realm-specific authentication logic for the specified <tt>token<\/tt>\n   */\n  @Override\n  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n    UsernamePasswordApiKeyToken upToken = (UsernamePasswordApiKeyToken) token;\n    String emailId = upToken.getUsername();\n    String apiKey = upToken.getApiKey();\n\n    SimpleAuthenticationInfo info = null;\n    try {\n      Connection connection = this.poolManager.getConnection();\n\n\n      String SQL = null;\n      PreparedStatement ps = null;\n      //Precedence for lookup if emailID is present use that to lookup. Else use apIKey.\n      if (emailId != null && !emailId.isEmpty()) {\n        SQL = SQL_LOOKUP_BY_EMAIL;\n        ps = connection.prepareStatement(SQL);\n        ps.setString(1, emailId);\n\n      } else if (apiKey != null && !apiKey.isEmpty()) {\n        SQL = SQL_LOOKUP_BY_APIKEY;\n        ps = connection.prepareStatement(SQL);\n        ps.setString(1, apiKey);\n\n      }\n\n      if (ps == null) {\n        throw new AuthenticationException(\"ApiKey or emailId should be set.\");\n      }\n\n      ResultSet rs = ps.executeQuery();\n\n      int count = 0;\n      String password = null;\n      int accountId = -1;\n      String firstName = null;\n      String lastName = null;\n      String company = null;\n      String apiToken = null;\n      boolean confirmed = false;\n      while (rs.next()) {\n        firstName = rs.getString(1);\n        lastName = rs.getString(2);\n        company = rs.getString(3);\n\n        accountId = rs.getInt(4);\n        password = rs.getString(5);\n        apiToken = rs.getString(6);\n        confirmed = rs.getBoolean(7);\n        count++;\n        if (count > 1) {\n          // Note: This condition should never occur since ids are auto generated.\n          throw new RuntimeException(\"Multiple accounts with same account ID\");\n        }\n      }\n\n      if (password == null || password.isEmpty()) {\n        throw new RuntimeException(String.format(\"Password not found for %s\", emailId));\n      }\n\n      Account account = new Account(firstName, lastName, company, emailId, accountId, apiToken, confirmed);\n      info = new SimpleAuthenticationInfo(account, password, getName());\n\n    } catch (SQLException e) {\n      //TODO: Log and throw exception\n      e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n    }\n    return info;\n  }","id":102981,"modified_method":"/**\n   * Retrieves authentication data from RDBMS for the given authentication token.\n   * <p/>\n   * For most datasources, this means just 'pulling' authentication data for an associated subject/user and nothing\n   * more and letting Shiro do the rest.  But in some systems, this method could actually perform EIS specific\n   * log-in logic in addition to just retrieving data - it is up to the Realm implementation.\n   * <p/>\n   * A {@code null} return value means that no account could be associated with the specified token.\n   *\n   * @param token the authentication token containing the user's principal and credentials.\n   * @return an {@link org.apache.shiro.authc.AuthenticationInfo} object containing account data resulting from the\n   *         authentication ONLY if the lookup is successful (i.e. account exists and is valid, etc.)\n   * @throws org.apache.shiro.authc.AuthenticationException\n   *          if there is an error acquiring data or performing\n   *          realm-specific authentication logic for the specified <tt>token<\/tt>\n   */\n  @Override\n  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n    UsernamePasswordApiKeyToken upToken = (UsernamePasswordApiKeyToken) token;\n    String emailId = upToken.getUsername();\n    String apiKey = upToken.getApiKey();\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    SimpleAuthenticationInfo info = null;\n    try {\n       connection = this.poolManager.getConnection();\n\n\n      String SQL = null;\n       ps = null;\n      //Precedence for lookup if emailID is present use that to lookup. Else use apIKey.\n      if (emailId != null && !emailId.isEmpty()) {\n        SQL = SQL_LOOKUP_BY_EMAIL;\n        ps = connection.prepareStatement(SQL);\n        ps.setString(1, emailId);\n\n      } else if (apiKey != null && !apiKey.isEmpty()) {\n        SQL = SQL_LOOKUP_BY_APIKEY;\n        ps = connection.prepareStatement(SQL);\n        ps.setString(1, apiKey);\n\n      }\n\n      if (ps == null) {\n        throw new AuthenticationException(\"ApiKey or emailId should be set.\");\n      }\n\n       rs = ps.executeQuery();\n\n      int count = 0;\n      String password = null;\n      int accountId = -1;\n      String firstName = null;\n      String lastName = null;\n      String company = null;\n      String apiToken = null;\n      boolean confirmed = false;\n      while (rs.next()) {\n        firstName = rs.getString(1);\n        lastName = rs.getString(2);\n        company = rs.getString(3);\n\n        accountId = rs.getInt(4);\n        password = rs.getString(5);\n        apiToken = rs.getString(6);\n        confirmed = rs.getBoolean(7);\n        count++;\n        if (count > 1) {\n          // Note: This condition should never occur since ids are auto generated.\n          throw new RuntimeException(\"Multiple accounts with same account ID\");\n        }\n      }\n\n      if (password == null || password.isEmpty()) {\n        throw new RuntimeException(String.format(\"Password not found for %s\", emailId));\n      }\n\n      Account account = new Account(firstName, lastName, company, emailId, accountId, apiToken, confirmed);\n      info = new SimpleAuthenticationInfo(account, password, getName());\n\n    } catch (SQLException e) {\n      return null;\n    }\n    finally {\n      try {\n        if (connection != null) {\n          connection.close();\n        }\n        if (ps != null) {\n          ps.close();\n        }\n        if (rs != null) {\n          rs.close();\n        }\n      } catch (SQLException e) {\n        throw new RuntimeException(e.getMessage(), e.getCause());\n      }\n    }\n\n    return info;\n  }","commit_id":"85b12dcaf7d1a74253a433c011ad8ada80fbf8c2","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void changePassword(int accountId, String oldPassword, String newPassword) throws RuntimeException {\n    Connection connection = null;\n    try {\n      connection = this.poolManager.getConnection();\n\n      String SQL = String.format( \"UPDATE %s SET %s = ?, %s = ? WHERE %s = ? AND %s and %s = ?\" ,\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.PASSWORD_COLUMN,\n        DBUtils.AccountTable.API_KEY_COLUMN,\n        DBUtils.AccountTable.ID_COLUMN,\n        DBUtils.AccountTable.PASSWORD_COLUMN);\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n\n      ps.setString(1,newPassword);\n      ps.setString(2, ApiKey.generateKey(String.valueOf(accountId)));\n      ps.setInt(3,accountId);\n      ps.setString(4,oldPassword);\n      ps.executeUpdate();\n    } catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n  }","id":102982,"modified_method":"@Override\n  public void changePassword(int accountId, String oldPassword, String newPassword) throws RuntimeException {\n    Connection connection = null;\n    PreparedStatement ps = null;\n    try {\n      connection = this.poolManager.getConnection();\n\n      String SQL = String.format( \"UPDATE %s SET %s = ?, %s = ? WHERE %s = ? AND %s and %s = ?\" ,\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.PASSWORD_COLUMN,\n        DBUtils.AccountTable.API_KEY_COLUMN,\n        DBUtils.AccountTable.ID_COLUMN,\n        DBUtils.AccountTable.PASSWORD_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setString(1,newPassword);\n      ps.setString(2, ApiKey.generateKey(String.valueOf(accountId)));\n      ps.setInt(3,accountId);\n      ps.setString(4,oldPassword);\n      ps.executeUpdate();\n\n    } catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n    finally {\n      close(connection, ps);\n    }\n\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * @param accountId\n   * @throws com.continuuity.passport.core.exceptions.ConfigurationException\n   *\n   * @throws RuntimeException\n   */\n  @Override\n  public void confirmDownload(int accountId) throws ConfigurationException, RuntimeException {\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n      String SQL = String.format( \"UPDATE %s SET %s = ? WHERE %s = ? AND %s is NULL\" ,\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.DEV_SUITE_DOWNLOADED_AT,\n        DBUtils.AccountTable.ID_COLUMN,\n        DBUtils.AccountTable.DEV_SUITE_DOWNLOADED_AT);\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n\n      ps.setTimestamp(1, new java.sql.Timestamp(System.currentTimeMillis()));\n      ps.setInt(2, accountId);\n\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e){\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n  }","id":102983,"modified_method":"/**\n   * @param accountId\n   * @throws com.continuuity.passport.core.exceptions.ConfigurationException\n   *\n   * @throws RuntimeException\n   */\n  @Override\n  public void confirmDownload(int accountId) throws ConfigurationException, RuntimeException {\n    Connection connection = null;\n    PreparedStatement ps = null;\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format( \"UPDATE %s SET %s = ? WHERE %s = ? AND %s is NULL\" ,\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.DEV_SUITE_DOWNLOADED_AT,\n        DBUtils.AccountTable.ID_COLUMN,\n        DBUtils.AccountTable.DEV_SUITE_DOWNLOADED_AT);\n\n      ps = connection.prepareStatement(SQL);\n\n      ps.setTimestamp(1, new java.sql.Timestamp(System.currentTimeMillis()));\n      ps.setInt(2, accountId);\n\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e){\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n    finally {\n      close(connection, ps);\n    }\n\n\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"public boolean confirmRegistration(AccountSecurity security) throws ConfigurationException, RuntimeException{\n\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n      String SQL = String.format( \"UPDATE %s SET %s = ?, %s = ?, %s = ? WHERE %s = ?\" ,\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.PASSWORD_COLUMN, DBUtils.AccountTable.CONFIRMED_COLUMN,\n        DBUtils.AccountTable.API_KEY_COLUMN, DBUtils.AccountTable.ID_COLUMN);\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n      ps.setString(1, generateSaltedHashedPassword(security.getPassword()));\n      ps.setInt(2, DBUtils.AccountTable.ACCOUNT_CONFIRMED);\n      ps.setString(3, ApiKey.generateKey(String.valueOf(security.getAccountId())));\n      ps.setInt(4, security.getAccountId());\n\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e){\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n\n    return true;\n  }","id":102984,"modified_method":"public boolean confirmRegistration(AccountSecurity security) throws ConfigurationException, RuntimeException{\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format( \"UPDATE %s SET %s = ?, %s = ?, %s = ? WHERE %s = ?\" ,\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.PASSWORD_COLUMN, DBUtils.AccountTable.CONFIRMED_COLUMN,\n        DBUtils.AccountTable.API_KEY_COLUMN, DBUtils.AccountTable.ID_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setString(1, generateSaltedHashedPassword(security.getPassword()));\n      ps.setInt(2, DBUtils.AccountTable.ACCOUNT_CONFIRMED);\n      ps.setString(3, ApiKey.generateKey(String.valueOf(security.getAccountId())));\n      ps.setInt(4, security.getAccountId());\n\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e){\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n    finally {\n      close(connection, ps);\n    }\n\n    return true;\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Delete Account in the system\n   *\n   * @param accountId AccountId to be deleted\n   * @return boolean status of account deletion\n   * @throws {@code RetryException}\n   */\n  @Override\n  public boolean deleteAccount(String accountId) throws ConfigurationException, RuntimeException {\n\n    //TODO: accountId to int\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n      String SQL = String.format( \"DELETE FROM %s WHERE %s = ?\",\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.ID_COLUMN);\n      PreparedStatement ps = connection.prepareStatement(SQL);\n\n      ps.setString(1, accountId);\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e){\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n    return true;\n  }","id":102985,"modified_method":"/**\n   * Delete Account in the system\n   *\n   * @param accountId AccountId to be deleted\n   * @return boolean status of account deletion\n   * @throws {@code RetryException}\n   */\n  @Override\n  public boolean deleteAccount(String accountId) throws ConfigurationException, RuntimeException {\n\n    PreparedStatement ps = null;\n    Connection connection = null;\n    //TODO: accountId to int\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format( \"DELETE FROM %s WHERE %s = ?\",\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.ID_COLUMN);\n      ps = connection.prepareStatement(SQL);\n\n      ps.setString(1, accountId);\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e){\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n\n    finally {\n      close(connection, ps);\n    }\n\n    return true;\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void updateAccount(int accountId, Map<String, Object> keyValueParams) throws  ConfigurationException, RuntimeException {\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n\n      Connection connection = this.poolManager.getConnection();\n\n      //Set basic update command\n      StringBuilder sb  = new StringBuilder();\n\n      sb.append(String.format(\"UPDATE %s SET \", DBUtils.AccountTable.TABLE_NAME));\n      boolean firstValue = true;\n\n      if(!keyValueParams.isEmpty()){\n\n        //Add Column names\n        for(Map.Entry e: keyValueParams.entrySet()){\n\n          if (firstValue){\n            sb.append(String.format(\" %s= ?\", (String) e.getKey()));\n            firstValue = false;\n          }\n          else {\n            //append a comma as well\n            sb.append(String.format(\", %s = ?\", (String) e.getKey()));\n          }\n        }\n\n        sb.append(String.format(\" where %s = ? \", DBUtils.AccountTable.ID_COLUMN));\n\n        //Prepared Statement\n        PreparedStatement ps = connection.prepareStatement(sb.toString());\n        int count = 1;\n\n        System.out.println(sb.toString());\n        //Set Values in prepared statement\n        //All values are set as String for now.\n        //For now we are only updating String fields\n        // TODO: Enhance it to actual type of columns later.\n\n        for (Map.Entry e : keyValueParams.entrySet()){\n          ps.setString(count,(String)e.getValue());\n          count++;\n        }\n\n        //Set value for where clause\n        ps.setInt(count, accountId);\n        ps.executeUpdate();\n\n      }\n    }\n    catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n  }","id":102986,"modified_method":"@Override\n  public void updateAccount(int accountId, Map<String, Object> keyValueParams) throws  ConfigurationException, RuntimeException {\n    Connection connection = null;\n    PreparedStatement ps = null;\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n\n      connection = this.poolManager.getConnection();\n\n      //Set basic update command\n      StringBuilder sb  = new StringBuilder();\n\n      sb.append(String.format(\"UPDATE %s SET \", DBUtils.AccountTable.TABLE_NAME));\n      boolean firstValue = true;\n\n      if(!keyValueParams.isEmpty()){\n\n        //Add Column names\n        for(Map.Entry e: keyValueParams.entrySet()){\n\n          if (firstValue){\n            sb.append(String.format(\" %s= ?\", (String) e.getKey()));\n            firstValue = false;\n          }\n          else {\n            //append a comma as well\n            sb.append(String.format(\", %s = ?\", (String) e.getKey()));\n          }\n        }\n\n        sb.append(String.format(\" where %s = ? \", DBUtils.AccountTable.ID_COLUMN));\n\n        //Prepared Statement\n        ps = connection.prepareStatement(sb.toString());\n        int count = 1;\n\n        System.out.println(sb.toString());\n        //Set Values in prepared statement\n        //All values are set as String for now.\n        //For now we are only updating String fields\n        // TODO: Enhance it to actual type of columns later.\n\n        for (Map.Entry e : keyValueParams.entrySet()){\n          ps.setString(count,(String)e.getValue());\n          count++;\n        }\n\n        //Set value for where clause\n        ps.setInt(count, accountId);\n        ps.executeUpdate();\n\n      }\n    }\n    catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n    finally {\n      close(connection, ps);\n    }\n\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean updateBillingInfo(int accountId, BillingInfo billingInfo) throws ConfigurationException,RuntimeException {\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n\n\n      String SQL = String.format( \"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES(?,?,?,?,?)\" ,\n        DBUtils.AccountPayment.TABLE_NAME,\n        DBUtils.AccountPayment.ACCOUNT_ID_COLUMN,\n        DBUtils.AccountPayment.CREDIT_CARD_NAME_COLUMN,\n        DBUtils.AccountPayment.CREDIT_CARD_NUMBER_COLUMN,\n        DBUtils.AccountPayment.CREDIT_CARD_CVV_COLUMN,\n        DBUtils.AccountPayment.CREDIT_CARD_EXPIRY_COLUMN);\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n\n      ps.setInt(1,accountId);\n      ps.setString(2, billingInfo.getCreditCardName());\n      ps.setString(3, billingInfo.getCreditCardNumber());\n      ps.setString(4,billingInfo.getCvv());\n      ps.setString(5,billingInfo.getExpirationDate());\n\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e){\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n\n    return false;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":102987,"modified_method":"@Override\n  public boolean updateBillingInfo(int accountId, BillingInfo billingInfo) throws ConfigurationException,RuntimeException {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n\n\n      String SQL = String.format( \"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES(?,?,?,?,?)\" ,\n        DBUtils.AccountPayment.TABLE_NAME,\n        DBUtils.AccountPayment.ACCOUNT_ID_COLUMN,\n        DBUtils.AccountPayment.CREDIT_CARD_NAME_COLUMN,\n        DBUtils.AccountPayment.CREDIT_CARD_NUMBER_COLUMN,\n        DBUtils.AccountPayment.CREDIT_CARD_CVV_COLUMN,\n        DBUtils.AccountPayment.CREDIT_CARD_EXPIRY_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n\n      ps.setInt(1,accountId);\n      ps.setString(2, billingInfo.getCreditCardName());\n      ps.setString(3, billingInfo.getCreditCardNumber());\n      ps.setString(4,billingInfo.getCvv());\n      ps.setString(5,billingInfo.getExpirationDate());\n\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e){\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n    finally {\n      close(connection, ps);\n    }\n\n    return false;  //To change body of implemented methods use File | Settings | File Templates.\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * GetAccount\n   *\n   * @param accountId id of the account\n   * @return null if no entry matches, Instance of {@code Account} otherwise\n   * @throws {@code RetryException}\n   */\n  @Override\n  public Account getAccount(int accountId) throws ConfigurationException, RuntimeException {\n\n    Account account = null;\n\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n\n      String SQL = String.format( \"SELECT %s,%s,%s,%s,%s, %s FROM %s WHERE %s = ?\",\n        DBUtils.AccountTable.FIRST_NAME_COLUMN,DBUtils.AccountTable.LAST_NAME_COLUMN,\n        DBUtils.AccountTable.COMPANY_COLUMN, DBUtils.AccountTable.EMAIL_COLUMN,\n        DBUtils.AccountTable.ID_COLUMN, DBUtils.AccountTable.API_KEY_COLUMN,\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.ID_COLUMN);\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n      ps.setInt(1,accountId);\n      ResultSet rs = ps.executeQuery();\n\n      int count  = 0;\n      while(rs.next()) {\n        count++;\n        account = new Account(rs.getString(1),rs.getString(2),rs.getString(3),\n          rs.getString(4),rs.getInt(5),rs.getString(6));\n        if (count > 1 ) { // Note: This condition should never occur since ids are auto generated.\n          throw new RuntimeException(\"Multiple accounts with same account ID\");\n        }\n      }\n\n    }\n    catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n    return account;\n  }","id":102988,"modified_method":"/**\n   * GetAccount\n   *\n   * @param accountId id of the account\n   * @return null if no entry matches, Instance of {@code Account} otherwise\n   * @throws {@code RetryException}\n   */\n  @Override\n  public Account getAccount(int accountId) throws ConfigurationException, RuntimeException {\n\n    Account account = null;\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n\n      String SQL = String.format( \"SELECT %s,%s,%s,%s,%s, %s FROM %s WHERE %s = ?\",\n        DBUtils.AccountTable.FIRST_NAME_COLUMN,DBUtils.AccountTable.LAST_NAME_COLUMN,\n        DBUtils.AccountTable.COMPANY_COLUMN, DBUtils.AccountTable.EMAIL_COLUMN,\n        DBUtils.AccountTable.ID_COLUMN, DBUtils.AccountTable.API_KEY_COLUMN,\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.ID_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setInt(1,accountId);\n      rs = ps.executeQuery();\n\n      int count  = 0;\n      while(rs.next()) {\n        count++;\n        account = new Account(rs.getString(1),rs.getString(2),rs.getString(3),\n          rs.getString(4),rs.getInt(5),rs.getString(6));\n        if (count > 1 ) { // Note: This condition should never occur since ids are auto generated.\n          throw new RuntimeException(\"Multiple accounts with same account ID\");\n        }\n      }\n\n    }\n    catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n    finally {\n      close(connection, ps,rs);\n    }\n\n\n    return account;\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Create Account in the system\n   * @param account Instance of {@code Account}\n   * @return boolean status of account creation\n   * @throws {@code RetryException}\n   */\n  @Override\n  public Account createAccount(Account account) throws ConfigurationException, RuntimeException {\n    //TODO: Return boolean?\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection= this.poolManager.getConnection();\n      String SQL = String.format( \"INSERT INTO %s (%s, %s, %s, %s, %s, %s) VALUES (?,?,?,?,?,?)\",\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.EMAIL_COLUMN, DBUtils.AccountTable.FIRST_NAME_COLUMN,\n        DBUtils.AccountTable.LAST_NAME_COLUMN, DBUtils.AccountTable.COMPANY_COLUMN,\n        DBUtils.AccountTable.CONFIRMED_COLUMN, DBUtils.AccountTable.ACCOUNT_CREATED_AT\n      );\n\n\n      PreparedStatement ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setString(1, account.getEmailId());\n      ps.setString(2,account.getFirstName());\n      ps.setString(3,account.getLastName());\n      ps.setString(4, account.getCompany());\n      ps.setInt(5, DBUtils.AccountTable.ACCOUNT_UNCONFIRMED);\n      ps.setTimestamp(6, new java.sql.Timestamp(System.currentTimeMillis()));\n\n      ps.executeUpdate();\n\n      ResultSet result = ps.getGeneratedKeys();\n      if (result == null) {\n        throw new RuntimeException(\"Failed Insert\");\n      }\n      result.next();\n\n      Account createdAccount  = new Account(account.getFirstName(),account.getLastName(),\n        account.getCompany(),account.getEmailId(),result.getInt(1));\n      return createdAccount;\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n  }","id":102989,"modified_method":"/**\n   * Create Account in the system\n   * @param account Instance of {@code Account}\n   * @return boolean status of account creation\n   * @throws {@code RetryException}\n   */\n  @Override\n  public Account createAccount(Account account) throws ConfigurationException, RuntimeException {\n    //TODO: Return boolean?\n    Connection connection = null;\n    PreparedStatement ps  = null;\n    ResultSet result = null;\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection= this.poolManager.getConnection();\n      String SQL = String.format( \"INSERT INTO %s (%s, %s, %s, %s, %s, %s) VALUES (?,?,?,?,?,?)\",\n        DBUtils.AccountTable.TABLE_NAME,\n        DBUtils.AccountTable.EMAIL_COLUMN, DBUtils.AccountTable.FIRST_NAME_COLUMN,\n        DBUtils.AccountTable.LAST_NAME_COLUMN, DBUtils.AccountTable.COMPANY_COLUMN,\n        DBUtils.AccountTable.CONFIRMED_COLUMN, DBUtils.AccountTable.ACCOUNT_CREATED_AT\n      );\n\n\n      ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setString(1, account.getEmailId());\n      ps.setString(2,account.getFirstName());\n      ps.setString(3,account.getLastName());\n      ps.setString(4, account.getCompany());\n      ps.setInt(5, DBUtils.AccountTable.ACCOUNT_UNCONFIRMED);\n      ps.setTimestamp(6, new java.sql.Timestamp(System.currentTimeMillis()));\n\n      ps.executeUpdate();\n\n      result = ps.getGeneratedKeys();\n      if (result == null) {\n        throw new RuntimeException(\"Failed Insert\");\n      }\n      result.next();\n\n      Account createdAccount  = new Account(account.getFirstName(),account.getLastName(),\n        account.getCompany(),account.getEmailId(),result.getInt(1));\n      return createdAccount;\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    finally {\n      close(connection, ps, result);\n    }\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean addRoleType(int accountId, Role role) throws ConfigurationException, RuntimeException {\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n      String SQL = String.format( \"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES(?,?,?,?,?)\" ,\n        DBUtils.AccountRoleType.TABLE_NAME,\n        DBUtils.AccountRoleType.ACCOUNT_ID_COLUMN,\n        DBUtils.AccountRoleType.ROLE_NAME_COLUMN,\n        DBUtils.AccountRoleType.PERMISSIONS_COLUMN);\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n\n      ps.setInt(1,accountId);\n      ps.setString(2,role.getRoleName());\n      ps.setString(3,role.getPermissions());\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n    return false;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":102990,"modified_method":"@Override\n  public boolean addRoleType(int accountId, Role role) throws ConfigurationException, RuntimeException {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n\n    if(this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format( \"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES(?,?,?,?,?)\" ,\n        DBUtils.AccountRoleType.TABLE_NAME,\n        DBUtils.AccountRoleType.ACCOUNT_ID_COLUMN,\n        DBUtils.AccountRoleType.ROLE_NAME_COLUMN,\n        DBUtils.AccountRoleType.PERMISSIONS_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n\n      ps.setInt(1,accountId);\n      ps.setString(2,role.getRoleName());\n      ps.setString(3,role.getPermissions());\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e) {\n      throw new RuntimeException(e.getMessage(),e.getCause());\n    }\n    finally {\n      close(connection, ps);\n    }\n\n    return false;  //To change body of implemented methods use File | Settings | File Templates.\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"private DataManagementServiceImpl() {\n    accountDAO = new AccountDBAccess();\n    Map<String,String> config = new HashMap<String,String>();\n    config.put(\"jdbcType\",\"mysql\");\n    config.put(\"connectionString\",\"jdbc:mysql://a101.dev.sl:3306/continuuity?user=passport_user\");\n    //config.put(\"connectionString\",\"jdbc:mysql://localhost/continuuity?user=passport_user\");\n    accountDAO.configure(config);\n\n    vpcDao = new VpcDBAccess();\n    vpcDao.configure(config);\n  }","id":102991,"modified_method":"private DataManagementServiceImpl() {\n    accountDAO = new AccountDBAccess();\n    Map<String,String> config = new HashMap<String,String>();\n    config.put(\"jdbcType\",\"mysql\");\n    //config.put(\"connectionString\",\"jdbc:mysql://a101.dev.sl:3306/continuuity?user=passport_user\");\n    config.put(\"connectionString\",\"jdbc:mysql://localhost/continuuity?user=passport_user\");\n    accountDAO.configure(config);\n\n    vpcDao = new VpcDBAccess();\n    vpcDao.configure(config);\n\n    nonceDAO = new NonceDBAccess(config);\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"public static void main(String [] args) {\n\n    Map<String,String> config = new HashMap<String,String>();\n\n    //TODO: Move this configurations to a central place\n    config.put(\"jdbcType\",\"mysql\");\n    config.put(\"connectionString\",\"jdbc:mysql://a101.dev.sl:3306/continuuity?user=passport_user\");\n   // config.put(\"connectionString\",\"jdbc:mysql://localhost:3306/continuuity?user=passport_user\");\n\n    Realm realm = new JDBCAuthrozingRealm(config);\n\n    org.apache.shiro.mgt.SecurityManager securityManager = new DefaultSecurityManager(realm);\n    SecurityUtils.setSecurityManager(securityManager);\n\n    PassportHttpServer server = new PassportHttpServer();\n    server.start();\n\n\n  }","id":102992,"modified_method":"public static void main(String [] args) {\n\n    Map<String,String> config = new HashMap<String,String>();\n\n    //TODO: Move this configurations to a central place\n    config.put(\"jdbcType\",\"mysql\");\n   // config.put(\"connectionString\",\"jdbc:mysql://a101.dev.sl:3306/continuuity?user=passport_user\");\n    config.put(\"connectionString\",\"jdbc:mysql://localhost:3306/continuuity?user=passport_user\");\n\n    Realm realm = new JDBCAuthrozingRealm(config);\n\n    org.apache.shiro.mgt.SecurityManager securityManager = new DefaultSecurityManager(realm);\n    SecurityUtils.setSecurityManager(securityManager);\n\n    PassportHttpServer server = new PassportHttpServer();\n    server.start();\n\n\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean addRoles(int accountId, int vpcId, int userId, Role role, String overrides)\n           throws ConfigurationException, RuntimeException {\n\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection= this.poolManager.getConnection();\n\n\n      String SQL = String.format( \"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES (?,?,?,?,?)\",\n                                  DBUtils.VPCRole.TABLE_NAME,\n                                  DBUtils.VPCRole.VPC_ID_COLUMN, DBUtils.VPCRole.ACCOUNT_ID_COLUMN,\n                                  DBUtils.VPCRole.USER_ID_COLUMN, DBUtils.VPCRole.ROLE_TYPE_COLUMN,\n                                  DBUtils.VPCRole.ROLE_OVERRIDES_COLUMN);\n\n      PreparedStatement ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setInt(1, vpcId);\n      ps.setInt(2, accountId);\n      ps.setInt(3, userId);\n      ps.setString(4, role.getRoleType());\n      ps.setString(5,overrides);\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    return false;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":102993,"modified_method":"@Override\n  public boolean addRoles(int accountId, int vpcId, int userId, Role role, String overrides)\n    throws ConfigurationException, RuntimeException {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection= this.poolManager.getConnection();\n\n\n      String SQL = String.format( \"INSERT INTO %s (%s,%s,%s,%s,%s) VALUES (?,?,?,?,?)\",\n        DBUtils.VPCRole.TABLE_NAME,\n        DBUtils.VPCRole.VPC_ID_COLUMN, DBUtils.VPCRole.ACCOUNT_ID_COLUMN,\n        DBUtils.VPCRole.USER_ID_COLUMN, DBUtils.VPCRole.ROLE_TYPE_COLUMN,\n        DBUtils.VPCRole.ROLE_OVERRIDES_COLUMN);\n\n      ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setInt(1, vpcId);\n      ps.setInt(2, accountId);\n      ps.setInt(3, userId);\n      ps.setString(4, role.getRoleType());\n      ps.setString(5,overrides);\n      ps.executeUpdate();\n\n    }\n    catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    finally {\n      close(connection, ps);\n    }\n    return false;  //To change body of implemented methods use File | Settings | File Templates.\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean removeVPC( int vpcId) throws ConfigurationException, RuntimeException {\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection= this.poolManager.getConnection();\n\n      String SQL = String.format( \"DELETE FROM %s WHERE %s = ?\",\n                                  DBUtils.VPC.TABLE_NAME,\n                                  DBUtils.VPC.VPC_ID_COLUMN);\n      PreparedStatement ps = connection.prepareStatement(SQL);\n\n      ps.setInt(1,vpcId);\n      ps.executeUpdate();\n\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    return true;\n  }","id":102994,"modified_method":"@Override\n  public boolean removeVPC( int vpcId) throws ConfigurationException, RuntimeException {\n\n    Connection connection = null;\n    PreparedStatement ps = null;\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection= this.poolManager.getConnection();\n\n      String SQL = String.format( \"DELETE FROM %s WHERE %s = ?\",\n        DBUtils.VPC.TABLE_NAME,\n        DBUtils.VPC.VPC_ID_COLUMN);\n      ps = connection.prepareStatement(SQL);\n\n      ps.setInt(1,vpcId);\n      ps.executeUpdate();\n\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    finally {\n      close(connection, ps);\n    }\n    return true;\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<VPC> getVPC(int accountId) throws RuntimeException, ConfigurationException {\n\n    List<VPC> vpcList = new ArrayList<VPC>();\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n      String SQL = String.format( \"SELECT %s, %s, %s FROM %s WHERE %s = ?\",\n                                  DBUtils.VPC.VPC_ID_COLUMN, DBUtils.VPC.NAME_COLUMN,\n                                  DBUtils.VPC.LABEL_COLUMN, //COLUMNS\n                                  DBUtils.VPC.TABLE_NAME, //FROM\n                                  DBUtils.VPC.ACCOUNT_ID_COLUMN); //WHERE\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n      ps.setInt(1,accountId);\n      ResultSet rs = ps.executeQuery();\n\n\n      while(rs.next()) {\n        VPC vpc = new VPC(rs.getInt(1),rs.getString(2),rs.getString(3));\n        vpcList.add(vpc);\n\n      }\n\n    }\n    catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    return vpcList;\n  }","id":102995,"modified_method":"@Override\n  public List<VPC> getVPC(int accountId) throws RuntimeException, ConfigurationException {\n\n    List<VPC> vpcList = new ArrayList<VPC>();\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format( \"SELECT %s, %s, %s FROM %s WHERE %s = ?\",\n        DBUtils.VPC.VPC_ID_COLUMN, DBUtils.VPC.NAME_COLUMN,\n        DBUtils.VPC.LABEL_COLUMN, //COLUMNS\n        DBUtils.VPC.TABLE_NAME, //FROM\n        DBUtils.VPC.ACCOUNT_ID_COLUMN); //WHERE\n\n      ps = connection.prepareStatement(SQL);\n      ps.setInt(1,accountId);\n      rs = ps.executeQuery();\n\n\n      while(rs.next()) {\n        VPC vpc = new VPC(rs.getInt(1),rs.getString(2),rs.getString(3));\n        vpcList.add(vpc);\n\n      }\n\n    }\n    catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    finally {\n      close(connection, ps,rs);\n    }\n    return vpcList;\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public VPC addVPC(int accountId, VPC vpc) throws ConfigurationException, RuntimeException {\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection= this.poolManager.getConnection();\n\n      String SQL = String.format( \"INSERT INTO %s (%s, %s, %s, %s) VALUES (?,?,?,?)\",\n                                  DBUtils.VPC.TABLE_NAME,\n                                  DBUtils.VPC.ACCOUNT_ID_COLUMN, DBUtils.VPC.NAME_COLUMN ,\n                                  DBUtils.VPC.LABEL_COLUMN,\n                                  DBUtils.VPC.VPC_CREATED_AT);\n\n      Date date = new Date();\n      PreparedStatement ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setInt(1, accountId);\n      ps.setString(2, vpc.getVpcName());\n      ps.setString(3,vpc.getVpcLabel());\n      ps.setTimestamp(3, new java.sql.Timestamp(date.getTime()));\n\n      ps.executeUpdate();\n\n      ResultSet result = ps.getGeneratedKeys();\n      if (result == null) {\n        throw new RuntimeException(\"Failed Insert\");\n      }\n      result.next();\n      return new VPC(result.getInt(1),vpc.getVpcName(), vpc.getVpcLabel());\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n  }","id":102996,"modified_method":"@Override\n  public VPC addVPC(int accountId, VPC vpc) throws ConfigurationException, RuntimeException {\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet result = null;\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection= this.poolManager.getConnection();\n\n      String SQL = String.format( \"INSERT INTO %s (%s, %s, %s, %s) VALUES (?,?,?,?)\",\n        DBUtils.VPC.TABLE_NAME,\n        DBUtils.VPC.ACCOUNT_ID_COLUMN, DBUtils.VPC.NAME_COLUMN ,\n        DBUtils.VPC.LABEL_COLUMN,\n        DBUtils.VPC.VPC_CREATED_AT);\n\n      Date date = new Date();\n      ps = connection.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);\n      ps.setInt(1, accountId);\n      ps.setString(2, vpc.getVpcName());\n      ps.setString(3,vpc.getVpcLabel());\n      ps.setTimestamp(3, new java.sql.Timestamp(date.getTime()));\n\n      ps.executeUpdate();\n\n      result = ps.getGeneratedKeys();\n      if (result == null) {\n        throw new RuntimeException(\"Failed Insert\");\n      }\n      result.next();\n      return new VPC(result.getInt(1),vpc.getVpcName(), vpc.getVpcLabel());\n    } catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    finally {\n      close(connection, ps,result);\n    }\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<VPC> getVPC(String apiKey) throws RuntimeException, ConfigurationException {\n\n    List<VPC> vpcList = new ArrayList<VPC>();\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      Connection connection = this.poolManager.getConnection();\n      String SQL = String.format( \"SELECT %s, %s, %s FROM %s JOIN %s ON %s = %s WHERE %s = ?\",\n                                  DBUtils.VPC.TABLE_NAME+\".\"+DBUtils.VPC.VPC_ID_COLUMN,\n                                  DBUtils.VPC.TABLE_NAME+\".\"+DBUtils.VPC.NAME_COLUMN, //COLUMNS\n                                  DBUtils.VPC.TABLE_NAME+\".\"+DBUtils.VPC.LABEL_COLUMN, //COLUMNS\n                                  DBUtils.VPC.TABLE_NAME, //FROM\n                                  DBUtils.AccountTable.TABLE_NAME, //JOIN\n                                  DBUtils.VPC.TABLE_NAME+\".\"+DBUtils.VPC.ACCOUNT_ID_COLUMN, //CONDITION\n                                  DBUtils.AccountTable.TABLE_NAME+\".\"+DBUtils.AccountTable.ID_COLUMN,\n                                  DBUtils.AccountTable.TABLE_NAME+\".\"+DBUtils.AccountTable.API_KEY_COLUMN);\n\n      PreparedStatement ps = connection.prepareStatement(SQL);\n      ps.setString(1,apiKey);\n      ResultSet rs = ps.executeQuery();\n\n      while(rs.next()) {\n        VPC vpc = new VPC(rs.getInt(1),rs.getString(2),rs.getString(3));\n        vpcList.add(vpc);\n\n      }\n\n    }\n    catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    return vpcList;\n  }","id":102997,"modified_method":"@Override\n  public List<VPC> getVPC(String apiKey) throws RuntimeException, ConfigurationException {\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    List<VPC> vpcList = new ArrayList<VPC>();\n    if (this.poolManager == null){\n      throw new ConfigurationException(\"DBConnection pool is null. DAO is not configured\");\n    }\n    try {\n      connection = this.poolManager.getConnection();\n      String SQL = String.format( \"SELECT %s, %s, %s FROM %s JOIN %s ON %s = %s WHERE %s = ?\",\n        DBUtils.VPC.TABLE_NAME+\".\"+DBUtils.VPC.VPC_ID_COLUMN,\n        DBUtils.VPC.TABLE_NAME+\".\"+DBUtils.VPC.NAME_COLUMN, //COLUMNS\n        DBUtils.VPC.TABLE_NAME+\".\"+DBUtils.VPC.LABEL_COLUMN, //COLUMNS\n        DBUtils.VPC.TABLE_NAME, //FROM\n        DBUtils.AccountTable.TABLE_NAME, //JOIN\n        DBUtils.VPC.TABLE_NAME+\".\"+DBUtils.VPC.ACCOUNT_ID_COLUMN, //CONDITION\n        DBUtils.AccountTable.TABLE_NAME+\".\"+DBUtils.AccountTable.ID_COLUMN,\n        DBUtils.AccountTable.TABLE_NAME+\".\"+DBUtils.AccountTable.API_KEY_COLUMN);\n\n      ps = connection.prepareStatement(SQL);\n      ps.setString(1,apiKey);\n      rs = ps.executeQuery();\n\n      while(rs.next()) {\n        VPC vpc = new VPC(rs.getInt(1),rs.getString(2),rs.getString(3));\n        vpcList.add(vpc);\n\n      }\n\n    }\n    catch (SQLException e) {\n      //TODO: Log\n      throw new RuntimeException(e.getMessage(), e.getCause());\n    }\n    finally {\n      close(connection, ps,rs);\n    }\n    return vpcList;\n  }","commit_id":"fda71f38b52fd2582a5e7fadaff772fa8c5ba14f","url":"https://github.com/caskdata/cdap"},{"original_method":"public long serializedSize(Inner inner, int version)\n            {\n                int size = inner.hash == null\n                ? TypeSizes.sizeof(-1)\n                        : TypeSizes.sizeof(inner.hash().length) + inner.hash().length;\n\n                size += Token.serializer.serializedSize(inner.token, version)\n                + Hashable.serializer.serializedSize(inner.lchild, version)\n                + Hashable.serializer.serializedSize(inner.rchild, version);\n                return size;\n            }","id":102998,"modified_method":"public long serializedSize(Inner inner, int version)\n            {\n                long size = 0;\n                if (version < MessagingService.VERSION_30)\n                {\n                    size += inner.hash == null\n                                       ? TypeSizes.sizeof(-1)\n                                       : TypeSizes.sizeof(inner.hash().length) + inner.hash().length;\n                }\n\n                size += Token.serializer.serializedSize(inner.token, version)\n                + Hashable.serializer.serializedSize(inner.lchild, version)\n                + Hashable.serializer.serializedSize(inner.rchild, version);\n                return size;\n            }","commit_id":"90e0013126e4875d696891c67d1b22fdb2b8ba7a","url":"https://github.com/apache/cassandra"},{"original_method":"public void serialize(Leaf leaf, DataOutputPlus out, int version) throws IOException\n            {\n                if (leaf.hash == null)\n                {\n                    out.writeInt(-1);\n                }\n                else\n                {\n                    out.writeInt(leaf.hash.length);\n                    out.write(leaf.hash);\n                }\n            }","id":102999,"modified_method":"public void serialize(Leaf leaf, DataOutputPlus out, int version) throws IOException\n            {\n                if (leaf.hash == null)\n                {\n                    if (version < MessagingService.VERSION_30)\n                        out.writeInt(-1);\n                    else\n                        out.writeByte(-1);\n                }\n                else\n                {\n                    if (version < MessagingService.VERSION_30)\n                        out.writeInt(leaf.hash.length);\n                    else\n                        out.writeByte(leaf.hash.length);\n                    out.write(leaf.hash);\n                }\n            }","commit_id":"90e0013126e4875d696891c67d1b22fdb2b8ba7a","url":"https://github.com/apache/cassandra"}]